     1→/**
     2→ * @license
     3→ * Copyright 2025 Google LLC
     4→ * SPDX-License-Identifier: Apache-2.0
     5→ */
     6→
     7→/**
     8→ * @fileoverview Manages background agent task execution, similar to Claude Code's Task tool.
     9→ * Allows spawning agents in the background and retrieving their output later.
    10→ */
    11→
    12→import { randomUUID } from 'node:crypto';
    13→import type { Config } from '../config/config.js';
    14→import type { AgentDefinition, AgentInputs, OutputObject } from './types.js';
    15→import { LocalAgentExecutor } from './local-executor.js';
    16→import { debugLogger } from '../utils/debugLogger.js';
    17→
    18→/**
    19→ * Status of a background agent task.
    20→ */
    21→export type TaskStatus = 'pending' | 'running' | 'completed' | 'error' | 'cancelled';
    22→
    23→/**
    24→ * Represents a background agent task.
    25→ */
    26→export interface AgentTask {
    27→  /** Unique identifier for the task. */
    28→  id: string;
    29→  /** Name of the agent executing the task. */
    30→  agentName: string;
    31→  /** Display name of the agent (if different from name). */
    32→  agentDisplayName?: string;
    33→  /** Current status of the task. */
    34→  status: TaskStatus;
    35→  /** When the task was created. */
    36→  createdAt: Date;
    37→  /** When the task started executing. */
    38→  startedAt?: Date;
    39→  /** When the task completed (successfully or with error). */
    40→  completedAt?: Date;
    41→  /** The result if the task completed successfully. */
    42→  result?: OutputObject;
    43→  /** Error message if the task failed. */
    44→  error?: string;
    45→  /** The inputs provided to the agent. */
    46→  inputs: AgentInputs;
    47→}
    48→
    49→/**
    50→ * Options for retrieving task output.
    51→ */
    52→export interface GetOutputOptions {
    53→  /** Whether to block and wait for completion. Default: true. */
    54→  block?: boolean;
    55→  /** Maximum time to wait in milliseconds. Default: 30000. */
    56→  timeout?: number;
    57→}
    58→
    59→/**
    60→ * Result of spawning a background task.
    61→ */
    62→export interface SpawnResult {
    63→  /** The unique task ID. */
    64→  taskId: string;
    65→  /** Status message. */
    66→  status: 'spawned';
    67→}
    68→
    69→/**
    70→ * Manages background agent task execution.
    71→ * Provides a way to spawn agents in the background and retrieve their output later.
    72→ */
    73→export class AgentTaskManager {
    74→  private readonly tasks = new Map<string, AgentTask>();
    75→  private readonly abortControllers = new Map<string, AbortController>();
    76→  private readonly completionPromises = new Map<string, Promise<void>>();
    77→  private readonly completionResolvers = new Map<string, () => void>();
    78→
    79→  constructor(private readonly config: Config) {}
    80→
    81→  /**
    82→   * Spawns an agent to run in the background.
    83→   * Returns immediately with a task ID that can be used to check status later.
    84→   *
    85→   * @param definition The agent definition to execute.
    86→   * @param inputs The inputs to provide to the agent.
    87→   * @returns The task ID and spawn status.
    88→   */
    89→  async spawnBackground(
    90→    definition: AgentDefinition,
    91→    inputs: AgentInputs,
    92→  ): Promise<SpawnResult> {
    93→    const taskId = randomUUID();
    94→    const abortController = new AbortController();
    95→
    96→    const task: AgentTask = {
    97→      id: taskId,
    98→      agentName: definition.name,
    99→      agentDisplayName: definition.displayName,
   100→      status: 'pending',
   101→      createdAt: new Date(),
   102→      inputs,
   103→    };
   104→
   105→    this.tasks.set(taskId, task);
   106→    this.abortControllers.set(taskId, abortController);
   107→
   108→    // Create a promise that resolves when the task completes
   109→    let resolver: () => void;
   110→    const completionPromise = new Promise<void>((resolve) => {
   111→      resolver = resolve;
   112→    });
   113→    this.completionPromises.set(taskId, completionPromise);
   114→    this.completionResolvers.set(taskId, resolver!);
   115→
   116→    // Run in background (don't await)
   117→    void this.executeInBackground(taskId, definition, inputs, abortController.signal);
   118→
   119→    debugLogger.log(`[AgentTaskManager] Spawned background task ${taskId} for agent '${definition.name}'`);
   120→
   121→    return { taskId, status: 'spawned' };
   122→  }
   123→
   124→  /**
   125→   * Executes an agent in the background.
   126→   * This method is intentionally not awaited by spawnBackground.
   127→   */
   128→  private async executeInBackground(
   129→    taskId: string,
   130→    definition: AgentDefinition,
   131→    inputs: AgentInputs,
   132→    signal: AbortSignal,
   133→  ): Promise<void> {
   134→    const task = this.tasks.get(taskId);
   135→    if (!task) {
   136→      debugLogger.warn(`[AgentTaskManager] Task ${taskId} not found during execution`);
   137→      return;
   138→    }
   139→
   140→    task.status = 'running';
   141→    task.startedAt = new Date();
   142→
   143→    try {
   144→      if (definition.kind !== 'local') {
   145→        throw new Error(`Background execution only supports local agents. Agent '${definition.name}' is of kind '${definition.kind}'.`);
   146→      }
   147→
   148→      const executor = await LocalAgentExecutor.create(
   149→        definition,
   150→        this.config,
   151→        // Activity callback - could be used for streaming in future
   152→        () => {},
   153→      );
   154→
   155→      const result = await executor.run(inputs, signal);
   156→
   157→      task.status = 'completed';
   158→      task.result = result;
   159→      task.completedAt = new Date();
   160→
   161→      debugLogger.log(`[AgentTaskManager] Task ${taskId} completed successfully`);
   162→    } catch (error) {
   163→      if (signal.aborted) {
   164→        task.status = 'cancelled';
   165→        task.error = 'Task was cancelled';
   166→      } else {
   167→        task.status = 'error';
   168→        task.error = error instanceof Error ? error.message : String(error);
   169→      }
   170→      task.completedAt = new Date();
   171→
   172→      debugLogger.warn(`[AgentTaskManager] Task ${taskId} failed: ${task.error}`);
   173→    } finally {
   174→      // Notify waiters that the task is complete
   175→      const resolver = this.completionResolvers.get(taskId);
   176→      if (resolver) {
   177→        resolver();
   178→        this.completionResolvers.delete(taskId);
   179→      }
   180→    }
   181→  }
   182→
   183→  /**
   184→   * Gets the output/status of a task.
   185→   *
   186→   * @param taskId The task ID to query.
   187→   * @param options Options for retrieving output.
   188→   * @returns The task with current status and result (if available).
   189→   */
   190→  async getOutput(taskId: string, options: GetOutputOptions = {}): Promise<AgentTask> {
   191→    const { block = true, timeout = 30000 } = options;
   192→
   193→    const task = this.tasks.get(taskId);
   194→    if (!task) {
   195→      throw new Error(`Task '${taskId}' not found`);
   196→    }
   197→
   198→    // If not blocking or task is already complete, return immediately
   199→    if (!block || task.status === 'completed' || task.status === 'error' || task.status === 'cancelled') {
   200→      return { ...task };
   201→    }
   202→
   203→    // Wait for completion with timeout
   204→    const completionPromise = this.completionPromises.get(taskId);
   205→    if (completionPromise) {
   206→      const timeoutPromise = new Promise<void>((_, reject) => {
   207→        setTimeout(() => reject(new Error(`Timeout waiting for task '${taskId}'`)), timeout);
   208→      });
   209→
   210→      try {
   211→        await Promise.race([completionPromise, timeoutPromise]);
   212→      } catch (error) {
   213→        // On timeout, return current status
   214→        if (error instanceof Error && error.message.includes('Timeout')) {
   215→          return { ...task };
   216→        }
   217→        throw error;
   218→      }
   219→    }
   220→
   221→    // Return the updated task
   222→    const updatedTask = this.tasks.get(taskId);
   223→    return updatedTask ? { ...updatedTask } : task;
   224→  }
   225→
   226→  /**
   227→   * Cancels a running task.
   228→   *
   229→   * @param taskId The task ID to cancel.
   230→   * @returns True if the task was cancelled, false if it was not running.
   231→   */
   232→  cancelTask(taskId: string): boolean {
   233→    const task = this.tasks.get(taskId);
   234→    if (!task) {
   235→      throw new Error(`Task '${taskId}' not found`);
   236→    }
   237→
   238→    if (task.status !== 'pending' && task.status !== 'running') {
   239→      return false;
   240→    }
   241→
   242→    const abortController = this.abortControllers.get(taskId);
   243→    if (abortController) {
   244→      abortController.abort();
   245→      debugLogger.log(`[AgentTaskManager] Cancelled task ${taskId}`);
   246→      return true;
   247→    }
   248→
   249→    return false;
   250→  }
   251→
   252→  /**
   253→   * Lists all tasks.
   254→   *
   255→   * @returns Array of all tasks.
   256→   */
   257→  listTasks(): AgentTask[] {
   258→    return Array.from(this.tasks.values()).map((task) => ({ ...task }));
   259→  }
   260→
   261→  /**
   262→   * Lists tasks filtered by status.
   263→   *
   264→   * @param status The status to filter by.
   265→   * @returns Array of tasks with the specified status.
   266→   */
   267→  listTasksByStatus(status: TaskStatus): AgentTask[] {
   268→    return this.listTasks().filter((task) => task.status === status);
   269→  }
   270→
   271→  /**
   272→   * Clears completed, errored, or cancelled tasks from the manager.
   273→   * Running and pending tasks are preserved.
   274→   */
   275→  clearFinishedTasks(): void {
   276→    for (const [taskId, task] of this.tasks) {
   277→      if (task.status === 'completed' || task.status === 'error' || task.status === 'cancelled') {
   278→        this.tasks.delete(taskId);
   279→        this.abortControllers.delete(taskId);
   280→        this.completionPromises.delete(taskId);
   281→        this.completionResolvers.delete(taskId);
   282→      }
   283→    }
   284→    debugLogger.log('[AgentTaskManager] Cleared finished tasks');
   285→  }
   286→
   287→  /**
   288→   * Gets a specific task by ID.
   289→   *
   290→   * @param taskId The task ID to get.
   291→   * @returns The task or undefined if not found.
   292→   */
   293→  getTask(taskId: string): AgentTask | undefined {
   294→    const task = this.tasks.get(taskId);
   295→    return task ? { ...task } : undefined;
   296→  }
   297→
   298→  /**
   299→   * Checks if there are any running tasks.
   300→   *
   301→   * @returns True if there are running tasks.
   302→   */
   303→  hasRunningTasks(): boolean {
   304→    return Array.from(this.tasks.values()).some(
   305→      (task) => task.status === 'pending' || task.status === 'running',
   306→    );
   307→  }
   308→}
   309→
   310→// Singleton instance for the task manager
   311→let taskManagerInstance: AgentTaskManager | null = null;
   312→
   313→/**
   314→ * Gets or creates the singleton AgentTaskManager instance.
   315→ *
   316→ * @param config The configuration (required on first call).
   317→ * @returns The AgentTaskManager instance.
   318→ */
   319→export function getTaskManager(config?: Config): AgentTaskManager {
   320→  if (!taskManagerInstance) {
   321→    if (!config) {
   322→      throw new Error('Config is required to initialize AgentTaskManager');
   323→    }
   324→    taskManagerInstance = new AgentTaskManager(config);
   325→  }
   326→  return taskManagerInstance;
   327→}
   328→
   329→/**
   330→ * Resets the singleton instance (primarily for testing).
   331→ */
   332→export function resetTaskManager(): void {
   333→  taskManagerInstance = null;
   334→}
   335→

</system-reminder>
