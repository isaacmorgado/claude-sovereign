     1→/**
     2→ * Facial Profile Analyzer
     3→ * High-level analysis functions for front and side profile measurements
     4→ *
     5→ * Features:
     6→ * - 32+ front profile measurements
     7→ * - 30+ side profile measurements
     8→ * - Ethnicity-specific ideal ranges
     9→ * - Combined harmony analysis
    10→ */
    11→
    12→import {
    13→  Point,
    14→  MetricScoreResult,
    15→  HarmonyAnalysis,
    16→  FlawAssessment,
    17→  StrengthAssessment,
    18→  DemographicOptions,
    19→  FrontProfileResults,
    20→  SideProfileResults,
    21→  Gender,
    22→  Ethnicity,
    23→} from './types';
    24→
    25→import {
    26→  calculateMetricScore,
    27→  getQualityTier,
    28→  getSeverityLevel,
    29→  distance,
    30→  calculateAngle,
    31→  perpendicularDistance,
    32→  standardizeScore,
    33→  calculateHarmonyPercentile,
    34→  getDeviationDescription,
    35→} from './calculator';
    36→
    37→import { METRIC_CONFIGS } from '@/lib/data/metric-configs';
    38→import { getMetricConfigForDemographics } from '@/lib/data/demographic-overrides';
    39→import { LandmarkPoint } from '@/lib/landmarks';
    40→
    41→// ============================================
    42→// HELPER FUNCTIONS
    43→// ============================================
    44→
    45→/**
    46→ * Helper to get landmark by ID
    47→ */
    48→export function getLandmark(landmarks: LandmarkPoint[], id: string): Point | null {
    49→  const lm = landmarks.find((l) => l.id === id);
    50→  return lm ? { x: lm.x, y: lm.y } : null;
    51→}
    52→
    53→// ============================================
    54→// SCORE A SINGLE MEASUREMENT
    55→// ============================================
    56→
    57→/**
    58→ * Calculate complete score result for a measurement.
    59→ * If demographics provided, uses demographic-specific ideal ranges.
    60→ */
    61→export function scoreMeasurement(
    62→  metricId: string,
    63→  value: number,
    64→  demographics?: DemographicOptions
    65→): MetricScoreResult | null {
    66→  // Get config with demographic overrides if provided
    67→  const config = demographics?.gender
    68→    ? getMetricConfigForDemographics(metricId, demographics.gender, demographics.ethnicity || 'other', METRIC_CONFIGS)
    69→    : METRIC_CONFIGS[metricId];
    70→
    71→  if (!config) return null;
    72→
    73→  const score = calculateMetricScore(value, config);
    74→  const standardizedScore = standardizeScore(score, config.maxScore);
    75→  const qualityTier = getQualityTier(score, config.maxScore);
    76→  const severity = getSeverityLevel(score, config.maxScore);
    77→  const { deviation, direction } = getDeviationDescription(
    78→    value,
    79→    config.idealMin,
    80→    config.idealMax,
    81→    config.unit
    82→  );
    83→
    84→  return {
    85→    metricId,
    86→    name: config.name,
    87→    value,
    88→    score,
    89→    standardizedScore,
    90→    qualityTier,
    91→    severity,
    92→    idealMin: config.idealMin,
    93→    idealMax: config.idealMax,
    94→    deviation,
    95→    deviationDirection: direction,
    96→    unit: config.unit,
    97→    category: config.category,
    98→  };
    99→}
   100→
   101→// ============================================
   102→// FRONT PROFILE ANALYSIS
   103→// ============================================
   104→
   105→/**
   106→ * Calculate all front profile measurements from landmarks.
   107→ * Now supports ethnicity-specific ideal ranges for more accurate scoring.
   108→ */
   109→export function analyzeFrontProfile(
   110→  landmarks: LandmarkPoint[],
   111→  gender: Gender = 'male',
   112→  ethnicity: Ethnicity = 'other'
   113→): FrontProfileResults {
   114→  const measurements: MetricScoreResult[] = [];
   115→  const demographics: DemographicOptions = { gender, ethnicity };
   116→
   117→  // Helper to add measurement if landmarks available
   118→  const addMeasurement = (metricId: string, value: number | null) => {
   119→    if (value !== null) {
   120→      const result = scoreMeasurement(metricId, value, demographics);
   121→      if (result) measurements.push(result);
   122→    }
   123→  };
   124→
   125→  // Get key landmarks
   126→  const trichion = getLandmark(landmarks, 'trichion');
   127→  const nasalBase = getLandmark(landmarks, 'nasal_base');
   128→  const subnasale = getLandmark(landmarks, 'subnasale');
   129→  const menton = getLandmark(landmarks, 'menton');
   130→  const leftZygion = getLandmark(landmarks, 'left_zygion');
   131→  const rightZygion = getLandmark(landmarks, 'right_zygion');
   132→  const leftGonion = getLandmark(landmarks, 'left_gonion_inferior');
   133→  const rightGonion = getLandmark(landmarks, 'right_gonion_inferior');
   134→  const leftPupil = getLandmark(landmarks, 'left_pupila');
   135→  const rightPupil = getLandmark(landmarks, 'right_pupila');
   136→  const leftCanthusM = getLandmark(landmarks, 'left_canthus_medialis');
   137→  const leftCanthusL = getLandmark(landmarks, 'left_canthus_lateralis');
   138→  const rightCanthusM = getLandmark(landmarks, 'right_canthus_medialis');
   139→  const rightCanthusL = getLandmark(landmarks, 'right_canthus_lateralis');
   140→  void rightCanthusL; // Will be used for asymmetry measurements
   141→  const leftAlaNasi = getLandmark(landmarks, 'left_ala_nasi');
   142→  const rightAlaNasi = getLandmark(landmarks, 'right_ala_nasi');
   143→  const leftCheilion = getLandmark(landmarks, 'left_cheilion');
   144→  const rightCheilion = getLandmark(landmarks, 'right_cheilion');
   145→  const labraleSuperius = getLandmark(landmarks, 'labrale_superius');
   146→  const labraleInferius = getLandmark(landmarks, 'labrale_inferius');
   147→
   148→  // FACIAL THIRDS
   149→  if (trichion && nasalBase && subnasale && menton) {
   150→    const totalHeight = distance(trichion, menton);
   151→    if (totalHeight > 0) {
   152→      const upperThird = (distance(trichion, nasalBase) / totalHeight) * 100;
   153→      const middleThird = (distance(nasalBase, subnasale) / totalHeight) * 100;
   154→      const lowerThird = (distance(subnasale, menton) / totalHeight) * 100;
   155→
   156→      addMeasurement('upperThirdProportion', upperThird);
   157→      addMeasurement('middleThirdProportion', middleThird);
   158→      addMeasurement('lowerThirdProportion', lowerThird);
   159→
   160→      // Lower Third Internal Ratio (subnasale to stomion / subnasale to menton)
   161→      const stomion = getLandmark(landmarks, 'mouth_middle');
   162→      if (stomion) {
   163→        const subnasaleToStomion = distance(subnasale, stomion);
   164→        const subnasaleToMenton = distance(subnasale, menton);
   165→        if (subnasaleToMenton > 0) {
   166→          const lowerThirdAlt = (subnasaleToStomion / subnasaleToMenton) * 100;
   167→          addMeasurement('lowerThirdProportionAlt', lowerThirdAlt);
   168→        }
   169→      }
   170→    }
   171→  }
   172→
   173→  // FACE WIDTH TO HEIGHT RATIO (FWHR)
   174→  if (leftZygion && rightZygion && nasalBase && labraleSuperius) {
   175→    const bizygomaticWidth = distance(leftZygion, rightZygion);
   176→    const upperFaceHeight = distance(nasalBase, labraleSuperius);
   177→    if (upperFaceHeight > 0) {
   178→      addMeasurement('faceWidthToHeight', bizygomaticWidth / upperFaceHeight);
   179→    }
   180→  }
   181→
   182→  // TOTAL FACIAL WIDTH TO HEIGHT
   183→  if (leftZygion && rightZygion && trichion && menton) {
   184→    const cheekWidth = distance(leftZygion, rightZygion);
   185→    const totalHeight = distance(trichion, menton);
   186→    if (cheekWidth > 0) {
   187→      addMeasurement('totalFacialWidthToHeight', totalHeight / cheekWidth);
   188→    }
   189→  }
   190→
   191→  // JAW WIDTH RATIO
   192→  if (leftGonion && rightGonion && leftZygion && rightZygion) {
   193→    const bigonialWidth = distance(leftGonion, rightGonion);
   194→    const bizygomaticWidth = distance(leftZygion, rightZygion);
   195→    if (bizygomaticWidth > 0) {
   196→      const ratio = bigonialWidth / bizygomaticWidth;
   197→      addMeasurement('jawWidthRatio', ratio);
   198→      addMeasurement('bigonialWidth', ratio * 100);
   199→    }
   200→  }
   201→
   202→  // CANTHAL TILT
   203→  // Positive tilt = lateral canthus is higher than medial (lower y in screen coords)
   204→  // Use abs(deltaX) to avoid sign issues between left/right eye
   205→  if (leftCanthusM && leftCanthusL) {
   206→    const deltaY = leftCanthusM.y - leftCanthusL.y;  // positive if lateral is higher
   207→    const deltaX = Math.abs(leftCanthusM.x - leftCanthusL.x);  // eye width (always positive)
   208→    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
   209→    addMeasurement('lateralCanthalTilt', angle);
   210→  }
   211→
   212→  // EYE ASPECT RATIO
   213→  if (leftCanthusM && leftCanthusL) {
   214→    const leftPalpSup = getLandmark(landmarks, 'left_palpebra_superior');
   215→    const leftPalpInf = getLandmark(landmarks, 'left_palpebra_inferior');
   216→    if (leftPalpSup && leftPalpInf) {
   217→      const eyeWidth = distance(leftCanthusM, leftCanthusL);
   218→      const eyeHeight = distance(leftPalpSup, leftPalpInf);
   219→      if (eyeHeight > 0) {
   220→        // Eye aspect ratio = width / height (ideal ~3.0-3.5 for almond shape)
   221→        addMeasurement('eyeAspectRatio', eyeWidth / eyeHeight);
   222→      }
   223→    }
   224→  }
   225→
   226→  // EYE SEPARATION RATIO
   227→  if (leftCanthusM && rightCanthusM && leftZygion && rightZygion) {
   228→    const intercanthal = distance(leftCanthusM, rightCanthusM);
   229→    const bizygomatic = distance(leftZygion, rightZygion);
   230→    if (bizygomatic > 0) {
   231→      addMeasurement('eyeSeparationRatio', intercanthal / bizygomatic);
   232→    }
   233→  }
   234→
   235→  // IPD RATIO
   236→  if (leftPupil && rightPupil && leftZygion && rightZygion) {
   237→    const ipd = distance(leftPupil, rightPupil);
   238→    const bizygomatic = distance(leftZygion, rightZygion);
   239→    if (bizygomatic > 0) {
   240→      addMeasurement('interpupillaryRatio', (ipd / bizygomatic) * 100);
   241→    }
   242→  }
   243→
   244→  // ONE EYE APART TEST
   245→  if (leftCanthusM && rightCanthusM && leftCanthusL) {
   246→    const intercanthal = distance(leftCanthusM, rightCanthusM);
   247→    const eyeWidth = distance(leftCanthusM, leftCanthusL);
   248→    if (eyeWidth > 0) {
   249→      addMeasurement('oneEyeApartTest', intercanthal / eyeWidth);
   250→    }
   251→  }
   252→
   253→  // NASAL INDEX
   254→  if (leftAlaNasi && rightAlaNasi && nasalBase && subnasale) {
   255→    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);
   256→    const nasalHeight = distance(nasalBase, subnasale);
   257→    if (nasalHeight > 0) {
   258→      addMeasurement('nasalIndex', (nasalWidth / nasalHeight) * 100);
   259→    }
   260→  }
   261→
   262→  // INTERCANTHAL-NASAL WIDTH RATIO
   263→  if (leftCanthusM && rightCanthusM && leftAlaNasi && rightAlaNasi) {
   264→    const intercanthal = distance(leftCanthusM, rightCanthusM);
   265→    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);
   266→    if (nasalWidth > 0) {
   267→      addMeasurement('intercanthalNasalRatio', intercanthal / nasalWidth);
   268→    }
   269→  }
   270→
   271→  // MOUTH TO NOSE RATIO
   272→  if (leftCheilion && rightCheilion && leftAlaNasi && rightAlaNasi) {
   273→    const mouthWidth = distance(leftCheilion, rightCheilion);
   274→    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);
   275→    if (nasalWidth > 0) {
   276→      addMeasurement('mouthWidthToNoseRatio', mouthWidth / nasalWidth);
   277→    }
   278→  }
   279→
   280→  // IPD TO MOUTH WIDTH RATIO
   281→  if (leftPupil && rightPupil && leftCheilion && rightCheilion) {
   282→    const ipd = distance(leftPupil, rightPupil);
   283→    const mouthWidth = distance(leftCheilion, rightCheilion);
   284→    if (ipd > 0) {
   285→      addMeasurement('interpupillaryMouthWidthRatio', mouthWidth / ipd);
   286→    }
   287→  }
   288→
   289→  // LIP RATIO
   290→  if (labraleSuperius && labraleInferius && subnasale) {
   291→    const mouthMiddle = getLandmark(landmarks, 'mouth_middle');
   292→    if (mouthMiddle) {
   293→      const upperLipHeight = distance(subnasale, labraleSuperius);
   294→      const lowerLipHeight = distance(mouthMiddle, labraleInferius);
   295→      if (upperLipHeight > 0) {
   296→        addMeasurement('lowerToUpperLipRatio', lowerLipHeight / upperLipHeight);
   297→      }
   298→    }
   299→  }
   300→
   301→  // MIDFACE RATIO
   302→  if (leftZygion && rightZygion && nasalBase && subnasale) {
   303→    const midfaceWidth = distance(leftZygion, rightZygion);
   304→    const midfaceHeight = distance(nasalBase, subnasale);
   305→    if (midfaceHeight > 0) {
   306→      addMeasurement('midfaceRatio', midfaceWidth / midfaceHeight / 10); // Normalized
   307→    }
   308→  }
   309→
   310→  // CHEEK FULLNESS (Malar Convexity)
   311→  // Measures how much the cheek protrudes outward from the line between zygion and gonion
   312→  // Positive = Full/Youthful cheeks; Negative = Hollow/Gaunt cheeks
   313→  const leftMalar = getLandmark(landmarks, 'left_malar');
   314→  const rightMalar = getLandmark(landmarks, 'right_malar');
   315→
   316→  if (leftZygion && rightZygion && leftGonion && rightGonion && leftMalar && rightMalar) {
   317→    // Helper: Calculate signed perpendicular distance from point to line
   318→    const pointLineDistance = (p: Point, a: Point, b: Point): number => {
   319→      // Cross product: (bx - ax)(py - ay) - (by - ay)(px - ax)
   320→      const cross = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);
   321→      const lineLength = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
   322→      return cross / lineLength;
   323→    };
   324→
   325→    // Calculate convexity for both sides
   326→    const rightFullness = Math.abs(pointLineDistance(rightMalar, rightZygion, rightGonion));
   327→    const leftFullness = Math.abs(pointLineDistance(leftMalar, leftZygion, leftGonion));
   328→
   329→    // Normalize by face width to make scale-invariant
   330→    const faceWidth = distance(leftZygion, rightZygion);
   331→    if (faceWidth > 0) {
   332→      const rawScore = (rightFullness + leftFullness) / 2;
   333→      const normalizedScore = (rawScore / faceWidth) * 100;
   334→      addMeasurement('cheekFullness', normalizedScore);
   335→    }
   336→  }
   337→
   338→  // CHIN WIDTH
   339→  // Measures horizontal width of the mental protuberance (chin bone)
   340→  // Uses left/right mentum lateralis landmarks (132, 361 in MediaPipe)
   341→  const leftMentumLat = getLandmark(landmarks, 'left_mentum_lateralis');
   342→  const rightMentumLat = getLandmark(landmarks, 'right_mentum_lateralis');
   343→
   344→  if (leftMentumLat && rightMentumLat && leftZygion && rightZygion) {
   345→    const chinWidth = distance(leftMentumLat, rightMentumLat);
   346→    const faceWidth = distance(leftZygion, rightZygion);
   347→    if (faceWidth > 0) {
   348→      const chinWidthPercent = (chinWidth / faceWidth) * 100;
   349→      addMeasurement('chinWidth', chinWidthPercent);
   350→    }
   351→  }
   352→
   353→  // EYEBROW THICKNESS
   354→  // Measures vertical height of eyebrow at thickest point
   355→  // Landmarks: brow top (66, 296) and brow bottom (46, 276)
   356→  const leftBrowTop = getLandmark(landmarks, 'left_supercilium_superior');  // 52 in mapping, but we need 66
   357→  const leftBrowBottom = getLandmark(landmarks, 'left_supercilium_apex');  // 105 in mapping, but we need 46
   358→  const rightBrowTop = getLandmark(landmarks, 'right_supercilium_superior');  // 282 in mapping, but we need 296
   359→  const rightBrowBottom = getLandmark(landmarks, 'right_supercilium_apex');  // 334 in mapping, but we need 276
   360→
   361→  if (leftBrowTop && leftBrowBottom && rightBrowTop && rightBrowBottom && leftCanthusM && leftCanthusL) {
   362→    const leftThickness = distance(leftBrowTop, leftBrowBottom);
   363→    const rightThickness = distance(rightBrowTop, rightBrowBottom);
   364→    const avgThickness = (leftThickness + rightThickness) / 2;
   365→
   366→    // Normalize by eye height to make scale-invariant
   367→    const leftPalpSup = getLandmark(landmarks, 'left_palpebra_superior');
   368→    const leftPalpInf = getLandmark(landmarks, 'left_palpebra_inferior');
   369→    if (leftPalpSup && leftPalpInf) {
   370→      const eyeHeight = distance(leftPalpSup, leftPalpInf);
   371→      if (eyeHeight > 0) {
   372→        const normalizedThickness = (avgThickness / eyeHeight) * 10.0;  // Scale factor
   373→        addMeasurement('eyebrowThickness', normalizedThickness);
   374→      }
   375→    }
   376→  }
   377→
   378→  // UPPER EYELID EXPOSURE
   379→  // Measures visible skin between eyelash line and eyelid crease
   380→  // Landmarks: crease (27, 257) and lid top/lash line (159, 386)
   381→  if (leftCanthusM && leftCanthusL) {
   382→    const leftPalpSup = getLandmark(landmarks, 'left_palpebra_superior');
   383→    const leftPalpInf = getLandmark(landmarks, 'left_palpebra_inferior');
   384→    const leftCrease = getLandmark(landmarks, 'left_pretarsal_skin_crease');
   385→
   386→    if (leftPalpSup && leftPalpInf && leftCrease) {
   387→      // Distance from brow bone/crease to lash line
   388→      const lidGap = distance(leftCrease, leftPalpSup);
   389→
   390→      // Normalize by total eye opening height
   391→      const eyeOpen = distance(leftPalpSup, leftPalpInf);
   392→      if (eyeOpen > 0) {
   393→        const exposure = lidGap / eyeOpen;
   394→        addMeasurement('upperEyelidExposure', exposure);
   395→      }
   396→    }
   397→  }
   398→
   399→  // TEAR TROUGH DEPTH
   400→  // Placeholder metric: Default to 0.2 (clean/good) since we can't measure depth from 2D landmarks
   401→  // Future upgrade: Implement OpenCV color sampler to detect darkness under eyes
   402→  // For now, assign a neutral/good value so it doesn't unfairly penalize users
   403→  addMeasurement('tearTroughDepth', 0.2);
   404→
   405→  // Calculate category scores
   406→  const categoryScores: Record<string, { total: number; count: number }> = {};
   407→  for (const m of measurements) {
   408→    if (!categoryScores[m.category]) {
   409→      categoryScores[m.category] = { total: 0, count: 0 };
   410→    }
   411→    categoryScores[m.category].total += m.standardizedScore;
   412→    categoryScores[m.category].count++;
   413→  }
   414→
   415→  const categoryAvg: Record<string, number> = {};
   416→  for (const [cat, data] of Object.entries(categoryScores)) {
   417→    categoryAvg[cat] = data.count > 0 ? data.total / data.count : 0;
   418→  }
   419→
   420→  // Calculate overall score (weighted average)
   421→  let totalWeight = 0;
   422→  let weightedSum = 0;
   423→  for (const m of measurements) {
   424→    const config = METRIC_CONFIGS[m.metricId];
   425→    if (config) {
   426→      weightedSum += m.standardizedScore * config.weight;
   427→      totalWeight += config.weight;
   428→    }
   429→  }
   430→
   431→  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;
   432→  const standardizedScoreValue = overallScore;
   433→
   434→  return {
   435→    measurements,
   436→    overallScore,
   437→    standardizedScore: standardizedScoreValue,
   438→    qualityTier: getQualityTier(overallScore),
   439→    categoryScores: categoryAvg,
   440→  };
   441→}
   442→
   443→// ============================================
   444→// SIDE PROFILE ANALYSIS
   445→// ============================================
   446→
   447→/**
   448→ * Calculate all side profile measurements from landmarks.
   449→ * Now supports ethnicity-specific ideal ranges for more accurate scoring.
   450→ */
   451→export function analyzeSideProfile(
   452→  landmarks: LandmarkPoint[],
   453→  gender: Gender = 'male',
   454→  ethnicity: Ethnicity = 'other'
   455→): SideProfileResults {
   456→  const measurements: MetricScoreResult[] = [];
   457→  const demographics: DemographicOptions = { gender, ethnicity };
   458→
   459→  const addMeasurement = (metricId: string, value: number | null) => {
   460→    if (value !== null) {
   461→      const result = scoreMeasurement(metricId, value, demographics);
   462→      if (result) measurements.push(result);
   463→    }
   464→  };
   465→
   466→  // Get key landmarks
   467→  const glabella = getLandmark(landmarks, 'glabella');
   468→  const nasion = getLandmark(landmarks, 'nasion');
   469→  const rhinion = getLandmark(landmarks, 'rhinion');
   470→  const pronasale = getLandmark(landmarks, 'pronasale');
   471→  const columella = getLandmark(landmarks, 'columella');
   472→  const subnasale = getLandmark(landmarks, 'subnasale');
   473→  const labraleSuperius = getLandmark(landmarks, 'labraleSuperius');
   474→  const labraleInferius = getLandmark(landmarks, 'labraleInferius');
   475→  const sublabiale = getLandmark(landmarks, 'sublabiale');
   476→  const pogonion = getLandmark(landmarks, 'pogonion');
   477→  const menton = getLandmark(landmarks, 'menton');
   478→  const tragus = getLandmark(landmarks, 'tragus');
   479→  const gonionBottom = getLandmark(landmarks, 'gonionBottom');
   480→  const cervicalPoint = getLandmark(landmarks, 'cervicalPoint');
   481→  const orbitale = getLandmark(landmarks, 'orbitale');
   482→  const porion = getLandmark(landmarks, 'porion');
   483→
   484→  // GONIAL ANGLE
   485→  if (tragus && gonionBottom && menton) {
   486→    const angle = calculateAngle(tragus, gonionBottom, menton);
   487→    addMeasurement('gonialAngle', angle);
   488→  }
   489→
   490→  // NASOLABIAL ANGLE
   491→  if (columella && subnasale && labraleSuperius) {
   492→    const angle = calculateAngle(columella, subnasale, labraleSuperius);
   493→    addMeasurement('nasolabialAngle', angle);
   494→  }
   495→
   496→  // NASOFRONTAL ANGLE
   497→  if (glabella && nasion && rhinion) {
   498→    const angle = calculateAngle(glabella, nasion, rhinion);
   499→    addMeasurement('nasofrontalAngle', angle);
   500→  }
   501→
   502→  // MENTOLABIAL ANGLE
   503→  if (labraleInferius && sublabiale && pogonion) {
   504→    const angle = calculateAngle(labraleInferius, sublabiale, pogonion);
   505→    addMeasurement('mentolabialAngle', angle);
   506→  }
   507→
   508→  // E-LINE MEASUREMENTS (Ricketts)
   509→  // E-line runs from pronasale (nose tip) to soft tissue pogonion (chin)
   510→  // Sign convention: positive = in front of line, negative = behind
   511→  // perpendicularDistance returns positive for behind, so we negate
   512→  if (pronasale && pogonion && labraleSuperius && labraleInferius) {
   513→    const upperLipDist = perpendicularDistance(labraleSuperius, pronasale, pogonion);
   514→    const lowerLipDist = perpendicularDistance(labraleInferius, pronasale, pogonion);
   515→    // Negate to match sign convention (positive = protruding/in front)
   516→    addMeasurement('eLineUpperLip', -upperLipDist);
   517→    addMeasurement('eLineLowerLip', -lowerLipDist);
   518→  }
   519→
   520→  // BURSTONE LINE MEASUREMENTS
   521→  // Burstone line runs from subnasale to soft tissue pogonion
   522→  // Sign convention: negative = behind line (ideal is -4.7 to -2.3 for upper, -2.8 to -1.2 for lower)
   523→  if (subnasale && pogonion && labraleSuperius && labraleInferius) {
   524→    const upperLipBurstone = perpendicularDistance(labraleSuperius, subnasale, pogonion);
   525→    const lowerLipBurstone = perpendicularDistance(labraleInferius, subnasale, pogonion);
   526→    // Negate to match sign convention (negative = behind)
   527→    addMeasurement('burstoneUpperLip', -upperLipBurstone);
   528→    addMeasurement('burstoneLowerLip', -lowerLipBurstone);
   529→  }
   530→
   531→  // S-LINE MEASUREMENTS (Steiner)
   532→  // S-line runs from columella (or subnasale) to soft tissue pogonion
   533→  // Sign convention: positive = in front of line, negative = behind
   534→  const sLineStart = columella || subnasale;
   535→  if (sLineStart && pogonion && labraleSuperius && labraleInferius) {
   536→    const upperLipSLine = perpendicularDistance(labraleSuperius, sLineStart, pogonion);
   537→    const lowerLipSLine = perpendicularDistance(labraleInferius, sLineStart, pogonion);
   538→    // Negate to match sign convention (positive = protruding/in front)
   539→    addMeasurement('sLineUpperLip', -upperLipSLine);
   540→    addMeasurement('sLineLowerLip', -lowerLipSLine);
   541→  }
   542→
   543→  // HOLDAWAY H-LINE MEASUREMENT
   544→  // H-line runs from upper lip (labrale superius) to soft tissue pogonion
   545→  // Measures lower lip distance from this line
   546→  // Sign convention: positive = in front of line (ideal 0-4mm)
   547→  if (labraleSuperius && pogonion && labraleInferius) {
   548→    const lowerLipHLine = perpendicularDistance(labraleInferius, labraleSuperius, pogonion);
   549→    // Negate to match sign convention (positive = protruding/in front)
   550→    addMeasurement('holdawayHLine', -lowerLipHLine);
   551→  }
   552→
   553→  // NASOMENTAL ANGLE
   554→  if (nasion && pronasale && pogonion) {
   555→    const angle = calculateAngle(nasion, pronasale, pogonion);
   556→    addMeasurement('nasomentaAngle', angle);
   557→  }
   558→
   559→  // FACIAL CONVEXITY (GLABELLA)
   560→  if (glabella && subnasale && pogonion) {
   561→    const angle = calculateAngle(glabella, subnasale, pogonion);
   562→    addMeasurement('facialConvexityGlabella', angle);
   563→  }
   564→
   565→  // FACIAL CONVEXITY (NASION)
   566→  if (nasion && subnasale && pogonion) {
   567→    const angle = calculateAngle(nasion, subnasale, pogonion);
   568→    addMeasurement('facialConvexityNasion', angle);
   569→  }
   570→
   571→  // TOTAL FACIAL CONVEXITY
   572→  if (glabella && pronasale && pogonion) {
   573→    const angle = calculateAngle(glabella, pronasale, pogonion);
   574→    addMeasurement('totalFacialConvexity', angle);
   575→  }
   576→
   577→  // SUBMENTAL CERVICAL ANGLE
   578→  if (menton && cervicalPoint && pogonion) {
   579→    const neckPoint = getLandmark(landmarks, 'neckPoint');
   580→    if (neckPoint) {
   581→      const angle = calculateAngle(pogonion, menton, neckPoint);
   582→      addMeasurement('submentalCervicalAngle', angle);
   583→    }
   584→  }
   585→
   586→  // NASAL PROJECTION (Goode ratio)
   587→  if (pronasale && subnasale && nasion) {
   588→    const projection = distance(pronasale, subnasale);
   589→    const nasalLength = distance(nasion, pronasale);
   590→    if (nasalLength > 0) {
   591→      addMeasurement('nasalProjection', projection / nasalLength);
   592→    }
   593→  }
   594→
   595→  // NASOFACIAL ANGLE
   596→  if (nasion && pronasale && pogonion) {
   597→    // Angle between nose dorsum and facial plane
   598→    const nasalDorsum = { x: pronasale.x - nasion.x, y: pronasale.y - nasion.y };
   599→    const facialPlane = { x: pogonion.x - nasion.x, y: pogonion.y - nasion.y };
   600→
   601→    const dot = nasalDorsum.x * facialPlane.x + nasalDorsum.y * facialPlane.y;
   602→    const mag1 = Math.sqrt(nasalDorsum.x ** 2 + nasalDorsum.y ** 2);
   603→    const mag2 = Math.sqrt(facialPlane.x ** 2 + facialPlane.y ** 2);
   604→
   605→    if (mag1 > 0 && mag2 > 0) {
   606→      const angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
   607→      addMeasurement('nasofacialAngle', angle);
   608→    }
   609→  }
   610→
   611→  // MANDIBULAR PLANE ANGLE (using Frankfort horizontal)
   612→  if (porion && orbitale && gonionBottom && menton) {
   613→    // Frankfort horizontal is porion to orbitale
   614→    // Mandibular plane is gonion to menton
   615→    const fhAngle = Math.atan2(orbitale.y - porion.y, orbitale.x - porion.x);
   616→    const mpAngle = Math.atan2(menton.y - gonionBottom.y, menton.x - gonionBottom.x);
   617→    const angle = Math.abs(fhAngle - mpAngle) * (180 / Math.PI);
   618→    addMeasurement('mandibularPlaneAngle', angle);
   619→  }
   620→
   621→  // CHIN PROJECTION
   622→  if (pogonion && subnasale) {
   623→    // Distance from pogonion to vertical line through subnasale
   624→    const projection = pogonion.x - subnasale.x;
   625→    addMeasurement('chinProjection', projection);
   626→  }
   627→
   628→  // Calculate category scores
   629→  const categoryScores: Record<string, { total: number; count: number }> = {};
   630→  for (const m of measurements) {
   631→    if (!categoryScores[m.category]) {
   632→      categoryScores[m.category] = { total: 0, count: 0 };
   633→    }
   634→    categoryScores[m.category].total += m.standardizedScore;
   635→    categoryScores[m.category].count++;
   636→  }
   637→
   638→  const categoryAvg: Record<string, number> = {};
   639→  for (const [cat, data] of Object.entries(categoryScores)) {
   640→    categoryAvg[cat] = data.count > 0 ? data.total / data.count : 0;
   641→  }
   642→
   643→  // Calculate overall score
   644→  let totalWeight = 0;
   645→  let weightedSum = 0;
   646→  for (const m of measurements) {
   647→    const config = METRIC_CONFIGS[m.metricId];
   648→    if (config) {
   649→      weightedSum += m.standardizedScore * config.weight;
   650→      totalWeight += config.weight;
   651→    }
   652→  }
   653→
   654→  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;
   655→
   656→  return {
   657→    measurements,
   658→    overallScore,
   659→    standardizedScore: overallScore,
   660→    qualityTier: getQualityTier(overallScore),
   661→    categoryScores: categoryAvg,
   662→  };
   663→}
   664→
   665→// ============================================
   666→// COMPLETE HARMONY ANALYSIS
   667→// ============================================
   668→
   669→/**
   670→ * Run complete facial harmony analysis.
   671→ * Now supports ethnicity-specific ideal ranges for more accurate scoring.
   672→ */
   673→export function analyzeHarmony(
   674→  frontLandmarks: LandmarkPoint[],
   675→  sideLandmarks: LandmarkPoint[],
   676→  gender: Gender = 'male',
   677→  ethnicity: Ethnicity = 'other'
   678→): HarmonyAnalysis {
   679→  const frontResults = analyzeFrontProfile(frontLandmarks, gender, ethnicity);
   680→  const sideResults = analyzeSideProfile(sideLandmarks, gender, ethnicity);
   681→
   682→  const allMeasurements = [...frontResults.measurements, ...sideResults.measurements];
   683→
   684→  // Combined category scores
   685→  const allCategories: Record<string, { total: number; count: number }> = {};
   686→  for (const m of allMeasurements) {
   687→    if (!allCategories[m.category]) {
   688→      allCategories[m.category] = { total: 0, count: 0 };
   689→    }
   690→    allCategories[m.category].total += m.standardizedScore;
   691→    allCategories[m.category].count++;
   692→  }
   693→
   694→  const categoryScores: Record<string, number> = {};
   695→  for (const [cat, data] of Object.entries(allCategories)) {
   696→    categoryScores[cat] = data.count > 0 ? data.total / data.count : 0;
   697→  }
   698→
   699→  // Overall weighted score
   700→  let totalWeight = 0;
   701→  let weightedSum = 0;
   702→  for (const m of allMeasurements) {
   703→    const config = METRIC_CONFIGS[m.metricId];
   704→    if (config) {
   705→      weightedSum += m.standardizedScore * config.weight;
   706→      totalWeight += config.weight;
   707→    }
   708→  }
   709→
   710→  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;
   711→
   712→  // Identify flaws (below average measurements)
   713→  const flaws: FlawAssessment[] = allMeasurements
   714→    .filter((m) => m.severity !== 'optimal' && m.severity !== 'minor')
   715→    .map((m) => ({
   716→      category: m.category,
   717→      metricId: m.metricId,
   718→      metricName: m.name,
   719→      severity: m.severity,
   720→      deviation: `${m.deviation.toFixed(2)} ${m.deviationDirection} ideal`,
   721→      reasoning: `${m.name} is outside the ideal range`,
   722→      confidence: m.severity === 'extremely_severe' || m.severity === 'severe'
   723→        ? 'confirmed' as const
   724→        : 'likely' as const,
   725→    }))
   726→    .sort((a, b) => {
   727→      const severityOrder = { extremely_severe: 0, severe: 1, major: 2, moderate: 3 };
   728→      return (severityOrder[a.severity as keyof typeof severityOrder] ?? 4) -
   729→             (severityOrder[b.severity as keyof typeof severityOrder] ?? 4);
   730→    });
   731→
   732→  // Identify strengths (ideal measurements)
   733→  const strengths: StrengthAssessment[] = allMeasurements
   734→    .filter((m) => m.qualityTier === 'ideal' || m.qualityTier === 'excellent')
   735→    .map((m) => ({
   736→      category: m.category,
   737→      metricId: m.metricId,
   738→      metricName: m.name,
   739→      qualityTier: m.qualityTier,
   740→      value: m.value,
   741→      reasoning: `${m.name} is within the ${m.qualityTier} range`,
   742→    }));
   743→
   744→  // Calculate percentile (based on population stats)
   745→  const percentile = calculateHarmonyPercentile(overallScore);
   746→
   747→  return {
   748→    overallScore,
   749→    standardizedScore: overallScore,
   750→    qualityTier: getQualityTier(overallScore),
   751→    percentile,
   752→    frontScore: frontResults.overallScore,
   753→    sideScore: sideResults.overallScore,
   754→    categoryScores,
   755→    measurements: allMeasurements,
   756→    flaws,
   757→    strengths,
   758→  };
   759→}
   760→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
