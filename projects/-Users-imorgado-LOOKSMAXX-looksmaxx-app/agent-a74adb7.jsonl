{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":"## Task: Implement Self-Voting Prevention for Forum API\n\n### Context\nThe LOOKSMAXX forum API allows users to upvote/downvote their own posts and comments, which enables vote manipulation.\n\n### Requirements\nFrom the SAAS audit:\n- Prevent users from voting on their own posts\n- Prevent users from voting on their own comments\n- Return 400 error with message \"Cannot vote on your own content\"\n\n### Files to Modify\n1. `looksmaxx-api/app/routers/forum.py` - Add author check in vote endpoints\n\n### Implementation Steps\n\n1. **Find the vote endpoints in forum.py**\n   The audit mentions lines 656-715 (vote_post) and 906-952 (vote_comment)\n\n2. **Add author check for post voting**\n   In the vote_post endpoint, after fetching the post:\n   ```python\n   # Add before creating the vote:\n   if post.author_id == current_user.id:\n       raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")\n   ```\n\n3. **Add author check for comment voting**\n   In the vote_comment endpoint, after fetching the comment:\n   ```python\n   # Add before creating the vote:\n   if comment.author_id == current_user.id:\n       raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")\n   ```\n\n### Key Considerations\n- Make sure to compare UUIDs properly (both should be UUID types)\n- Return HTTP 400 (bad request) not 403 (forbidden)\n- Use the exact message \"Cannot vote on your own content\" for consistency\n- Add the check BEFORE any vote creation or update logic\n\nIMPORTANT: Actually implement this - write the code, modify the files. Don't just plan.\n"},"uuid":"b7668d3a-7dbe-40d6-8459-714cb474f490","timestamp":"2025-12-27T16:53:39.343Z"}
{"parentUuid":"b7668d3a-7dbe-40d6-8459-714cb474f490","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RY2XGe1nGmjWgKM36aZmfw","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement the self-voting prevention for the forum API. Let me start by reading the relevant file to understand the current implementation."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":37090,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":37090,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWXYJqGE5AgRWQDktKXNW","type":"assistant","uuid":"22b9132b-e0ca-4e59-b955-519b8a23bc37","timestamp":"2025-12-27T16:53:45.542Z"}
{"parentUuid":"22b9132b-e0ca-4e59-b955-519b8a23bc37","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RY2XGe1nGmjWgKM36aZmfw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ELxT7ymUEriraKeHD1ycoU","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":37090,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":37090,"ephemeral_1h_input_tokens":0},"output_tokens":108,"service_tier":"standard"}},"requestId":"req_011CWXYJqGE5AgRWQDktKXNW","type":"assistant","uuid":"992c402c-f5eb-44f2-88da-56a257fc59dc","timestamp":"2025-12-27T16:53:46.195Z"}
{"parentUuid":"992c402c-f5eb-44f2-88da-56a257fc59dc","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ELxT7ymUEriraKeHD1ycoU","type":"tool_result","content":"     1→\"\"\"\n     2→Forum router - Categories, Sub-Forums, Posts, Comments, Votes, Reports\n     3→\n     4→Rate Limits:\n     5→- Posts: 5 per minute per user\n     6→- Comments: 20 per minute per user\n     7→- Votes: 30 per minute per user\n     8→- Reports: 10 per hour per user\n     9→\"\"\"\n    10→\n    11→from fastapi import APIRouter, Depends, HTTPException, Query, Request, status\n    12→from sqlalchemy.ext.asyncio import AsyncSession\n    13→from sqlalchemy import select, func, and_, or_, desc\n    14→from sqlalchemy.orm import selectinload\n    15→from uuid import UUID\n    16→from typing import Optional, List\n    17→from datetime import datetime, timezone\n    18→\n    19→from app.database import get_db\n    20→from app.core.rate_limit import limiter, ForumRateLimits\n    21→from app.models.user import User, UserRole\n    22→from app.models.forum import (\n    23→    ForumIssueCategory, ForumSubForum, ForumPost, ForumComment,\n    24→    ForumVote, ForumReport, FlawToForumMapping, ArchetypeForumMapping,\n    25→    ForumBookmark, VoteType, TargetType, ReportStatus, ReportReason\n    26→)\n    27→from app.services.auth import get_current_user, get_current_user_optional\n    28→from app.schemas.forum import (\n    29→    CategoryResponse, CategoryListResponse, SubForumResponse,\n    30→    PostCreate, PostUpdate, PostResponse, PostListItem,\n    31→    PostListResponse, CommentCreate, CommentUpdate, CommentResponse,\n    32→    VoteRequest, VoteResponse, ReportCreate, ReportResponse,\n    33→    GuideSectionResponse, SortOrder, PostAuthor, RecommendedForumResponse,\n    34→    ArchetypeForumRecommendation, ForumSearchResult, ForumSearchResponse,\n    35→    SearchResultType, BookmarkToggleResponse, BookmarkedPostsResponse\n    36→)\n    37→\n    38→router = APIRouter(prefix=\"/forum\", tags=[\"forum\"])\n    39→\n    40→PAGE_SIZE = 20\n    41→MAX_COMMENT_DEPTH = 5\n    42→\n    43→\n    44→# === CATEGORIES ===\n    45→\n    46→@router.get(\"/categories\", response_model=List[CategoryResponse])\n    47→async def list_categories(db: AsyncSession = Depends(get_db)):\n    48→    \"\"\"List all active forum categories with sub-forums and post counts.\n    49→\n    50→    Optimized to use only 2 queries instead of N+1 pattern.\n    51→    \"\"\"\n    52→    # Query 1: Get all categories with sub-forums\n    53→    query = (\n    54→        select(ForumIssueCategory)\n    55→        .options(selectinload(ForumIssueCategory.sub_forums))\n    56→        .where(ForumIssueCategory.is_active == True)\n    57→        .order_by(ForumIssueCategory.display_order)\n    58→    )\n    59→    result = await db.execute(query)\n    60→    categories = result.scalars().all()\n    61→\n    62→    # Query 2: Get ALL sub-forum post counts in ONE query (batched)\n    63→    sf_counts_query = (\n    64→        select(\n    65→            ForumPost.sub_forum_id,\n    66→            func.count(ForumPost.id).label('post_count')\n    67→        )\n    68→        .where(\n    69→            ForumPost.is_deleted == False,\n    70→            ForumPost.is_approved == True\n    71→        )\n    72→        .group_by(ForumPost.sub_forum_id)\n    73→    )\n    74→    sf_counts_result = await db.execute(sf_counts_query)\n    75→    sf_counts = {row[0]: row[1] for row in sf_counts_result}\n    76→\n    77→    # Build response using pre-fetched counts (no additional queries)\n    78→    response = []\n    79→    for cat in categories:\n    80→        cat_post_count = 0\n    81→        sub_forums = []\n    82→\n    83→        for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n    84→            if sf.is_active:\n    85→                sf_post_count = sf_counts.get(sf.id, 0)\n    86→                cat_post_count += sf_post_count\n    87→\n    88→                sub_forums.append(SubForumResponse(\n    89→                    id=sf.id,\n    90→                    name=sf.name,\n    91→                    slug=sf.slug,\n    92→                    description=sf.description,\n    93→                    icon=sf.icon,\n    94→                    display_order=sf.display_order,\n    95→                    post_count=sf_post_count\n    96→                ))\n    97→\n    98→        response.append(CategoryResponse(\n    99→            id=cat.id,\n   100→            name=cat.name,\n   101→            slug=cat.slug,\n   102→            description=cat.description,\n   103→            icon=cat.icon,\n   104→            display_order=cat.display_order,\n   105→            post_count=cat_post_count,\n   106→            sub_forums=sub_forums\n   107→        ))\n   108→\n   109→    return response\n   110→\n   111→\n   112→@router.get(\"/categories/{slug}\", response_model=CategoryResponse)\n   113→async def get_category(\n   114→    slug: str,\n   115→    db: AsyncSession = Depends(get_db)\n   116→):\n   117→    \"\"\"Get a single category by slug with its sub-forums.\n   118→\n   119→    Optimized to use only 2 queries instead of N+1 pattern.\n   120→    \"\"\"\n   121→    # Query 1: Get category with sub-forums\n   122→    query = (\n   123→        select(ForumIssueCategory)\n   124→        .options(selectinload(ForumIssueCategory.sub_forums))\n   125→        .where(ForumIssueCategory.slug == slug, ForumIssueCategory.is_active == True)\n   126→    )\n   127→    result = await db.execute(query)\n   128→    cat = result.scalar_one_or_none()\n   129→\n   130→    if not cat:\n   131→        raise HTTPException(status_code=404, detail=\"Category not found\")\n   132→\n   133→    # Get sub-forum IDs for this category\n   134→    sf_ids = [sf.id for sf in cat.sub_forums if sf.is_active]\n   135→\n   136→    # Query 2: Get post counts for all sub-forums in this category (batched)\n   137→    sf_counts = {}\n   138→    if sf_ids:\n   139→        sf_counts_query = (\n   140→            select(\n   141→                ForumPost.sub_forum_id,\n   142→                func.count(ForumPost.id).label('post_count')\n   143→            )\n   144→            .where(\n   145→                ForumPost.sub_forum_id.in_(sf_ids),\n   146→                ForumPost.is_deleted == False,\n   147→                ForumPost.is_approved == True\n   148→            )\n   149→            .group_by(ForumPost.sub_forum_id)\n   150→        )\n   151→        sf_counts_result = await db.execute(sf_counts_query)\n   152→        sf_counts = {row[0]: row[1] for row in sf_counts_result}\n   153→\n   154→    # Build sub-forums list using pre-fetched counts\n   155→    cat_post_count = 0\n   156→    sub_forums = []\n   157→    for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n   158→        if sf.is_active:\n   159→            sf_post_count = sf_counts.get(sf.id, 0)\n   160→            cat_post_count += sf_post_count\n   161→\n   162→            sub_forums.append(SubForumResponse(\n   163→                id=sf.id,\n   164→                name=sf.name,\n   165→                slug=sf.slug,\n   166→                description=sf.description,\n   167→                icon=sf.icon,\n   168→                display_order=sf.display_order,\n   169→                post_count=sf_post_count\n   170→            ))\n   171→\n   172→    return CategoryResponse(\n   173→        id=cat.id,\n   174→        name=cat.name,\n   175→        slug=cat.slug,\n   176→        description=cat.description,\n   177→        icon=cat.icon,\n   178→        display_order=cat.display_order,\n   179→        post_count=cat_post_count,\n   180→        sub_forums=sub_forums\n   181→    )\n   182→\n   183→\n   184→# === SEARCH ===\n   185→\n   186→@router.get(\"/search\", response_model=ForumSearchResponse)\n   187→async def search_forum(\n   188→    q: str = Query(..., min_length=2, max_length=100, description=\"Search query\"),\n   189→    type: str = Query(\"all\", description=\"Search type: posts, comments, or all\"),\n   190→    limit: int = Query(20, ge=1, le=50),\n   191→    offset: int = Query(0, ge=0),\n   192→    db: AsyncSession = Depends(get_db)\n   193→):\n   194→    \"\"\"Search forum posts and comments using ILIKE pattern matching.\n   195→\n   196→    - Search by title, content for posts\n   197→    - Search by content for comments\n   198→    - Results sorted by vote_count DESC, created_at DESC\n   199→    \"\"\"\n   200→    search_pattern = f\"%{q}%\"\n   201→    results = []\n   202→    total_count = 0\n   203→\n   204→    if type in (\"posts\", \"all\"):\n   205→        # Search posts by title and content\n   206→        post_query = (\n   207→            select(ForumPost)\n   208→            .options(\n   209→                selectinload(ForumPost.author),\n   210→                selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n   211→            )\n   212→            .where(\n   213→                ForumPost.is_deleted == False,\n   214→                ForumPost.is_approved == True,\n   215→                or_(\n   216→                    ForumPost.title.ilike(search_pattern),\n   217→                    ForumPost.content.ilike(search_pattern)\n   218→                )\n   219→            )\n   220→            .order_by(ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n   221→        )\n   222→\n   223→        # Count posts\n   224→        post_count_query = (\n   225→            select(func.count(ForumPost.id))\n   226→            .where(\n   227→                ForumPost.is_deleted == False,\n   228→                ForumPost.is_approved == True,\n   229→                or_(\n   230→                    ForumPost.title.ilike(search_pattern),\n   231→                    ForumPost.content.ilike(search_pattern)\n   232→                )\n   233→            )\n   234→        )\n   235→        post_count_result = await db.execute(post_count_query)\n   236→        post_count = post_count_result.scalar() or 0\n   237→\n   238→        if type == \"posts\":\n   239→            total_count = post_count\n   240→            post_query = post_query.offset(offset).limit(limit)\n   241→        else:\n   242→            total_count += post_count\n   243→            # For \"all\", we get all posts first then merge with comments\n   244→            post_query = post_query.limit(limit * 2)  # Get more to merge\n   245→\n   246→        post_result = await db.execute(post_query)\n   247→        posts = post_result.scalars().all()\n   248→\n   249→        for post in posts:\n   250→            content_preview = post.content[:200] + \"...\" if len(post.content) > 200 else post.content\n   251→            results.append(ForumSearchResult(\n   252→                id=post.id,\n   253→                type=SearchResultType.POST,\n   254→                title=post.title,\n   255→                content_preview=content_preview,\n   256→                post_id=None,\n   257→                post_title=None,\n   258→                author=PostAuthor(id=post.author.id, username=post.author.username),\n   259→                vote_count=post.vote_count,\n   260→                category_slug=post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\",\n   261→                sub_forum_slug=post.sub_forum.slug if post.sub_forum else \"\",\n   262→                created_at=post.created_at\n   263→            ))\n   264→\n   265→    if type in (\"comments\", \"all\"):\n   266→        # Search comments by content\n   267→        comment_query = (\n   268→            select(ForumComment)\n   269→            .options(\n   270→                selectinload(ForumComment.author),\n   271→                selectinload(ForumComment.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n   272→            )\n   273→            .where(\n   274→                ForumComment.is_deleted == False,\n   275→                ForumComment.content.ilike(search_pattern)\n   276→            )\n   277→            .order_by(ForumComment.vote_count.desc(), ForumComment.created_at.desc())\n   278→        )\n   279→\n   280→        # Count comments\n   281→        comment_count_query = (\n   282→            select(func.count(ForumComment.id))\n   283→            .where(\n   284→                ForumComment.is_deleted == False,\n   285→                ForumComment.content.ilike(search_pattern)\n   286→            )\n   287→        )\n   288→        comment_count_result = await db.execute(comment_count_query)\n   289→        comment_count = comment_count_result.scalar() or 0\n   290→\n   291→        if type == \"comments\":\n   292→            total_count = comment_count\n   293→            comment_query = comment_query.offset(offset).limit(limit)\n   294→        else:\n   295→            total_count += comment_count\n   296→            comment_query = comment_query.limit(limit * 2)\n   297→\n   298→        comment_result = await db.execute(comment_query)\n   299→        comments = comment_result.scalars().all()\n   300→\n   301→        for comment in comments:\n   302→            content_preview = comment.content[:200] + \"...\" if len(comment.content) > 200 else comment.content\n   303→            post = comment.post\n   304→            if post and post.sub_forum:\n   305→                category_slug = post.sub_forum.issue_category.slug if post.sub_forum.issue_category else \"\"\n   306→                sub_forum_slug = post.sub_forum.slug\n   307→            else:\n   308→                category_slug = \"\"\n   309→                sub_forum_slug = \"\"\n   310→\n   311→            results.append(ForumSearchResult(\n   312→                id=comment.id,\n   313→                type=SearchResultType.COMMENT,\n   314→                title=None,\n   315→                content_preview=content_preview,\n   316→                post_id=comment.post_id,\n   317→                post_title=post.title if post else None,\n   318→                author=PostAuthor(id=comment.author.id, username=comment.author.username),\n   319→                vote_count=comment.vote_count,\n   320→                category_slug=category_slug,\n   321→                sub_forum_slug=sub_forum_slug,\n   322→                created_at=comment.created_at\n   323→            ))\n   324→\n   325→    # For \"all\" type, sort merged results by vote_count and created_at, then paginate\n   326→    if type == \"all\":\n   327→        results.sort(key=lambda x: (-x.vote_count, x.created_at), reverse=False)\n   328→        results.sort(key=lambda x: x.vote_count, reverse=True)\n   329→        results = results[offset:offset + limit]\n   330→\n   331→    return ForumSearchResponse(\n   332→        results=results,\n   333→        total_count=total_count,\n   334→        query=q,\n   335→        search_type=type,\n   336→        has_more=offset + limit < total_count\n   337→    )\n   338→\n   339→\n   340→@router.get(\"/recommended\", response_model=List[RecommendedForumResponse])\n   341→async def get_recommended_forums(\n   342→    flaws: str = Query(..., description=\"Comma-separated list of flaw IDs\"),\n   343→    db: AsyncSession = Depends(get_db)\n   344→):\n   345→    \"\"\"Get recommended forums based on detected flaws.\"\"\"\n   346→    flaw_list = [f.strip() for f in flaws.split(\",\") if f.strip()]\n   347→\n   348→    if not flaw_list:\n   349→        return []\n   350→\n   351→    # Find mappings for these flaws\n   352→    query = (\n   353→        select(FlawToForumMapping)\n   354→        .options(selectinload(FlawToForumMapping.issue_category))\n   355→        .where(FlawToForumMapping.flaw_id.in_(flaw_list))\n   356→        .order_by(FlawToForumMapping.priority)\n   357→    )\n   358→\n   359→    result = await db.execute(query)\n   360→    mappings = result.scalars().all()\n   361→\n   362→    # Group by category\n   363→    category_flaws = {}\n   364→    for mapping in mappings:\n   365→        cat_id = mapping.issue_category_id\n   366→        if cat_id not in category_flaws:\n   367→            category_flaws[cat_id] = {\n   368→                \"category\": mapping.issue_category,\n   369→                \"flaws\": [],\n   370→                \"priority\": mapping.priority\n   371→            }\n   372→        category_flaws[cat_id][\"flaws\"].append(mapping.flaw_id)\n   373→        # Use lowest priority (1 = primary)\n   374→        if mapping.priority < category_flaws[cat_id][\"priority\"]:\n   375→            category_flaws[cat_id][\"priority\"] = mapping.priority\n   376→\n   377→    # Build response sorted by priority\n   378→    response = []\n   379→    for cat_data in sorted(category_flaws.values(), key=lambda x: x[\"priority\"]):\n   380→        cat = cat_data[\"category\"]\n   381→        response.append(RecommendedForumResponse(\n   382→            category=CategoryListResponse(\n   383→                id=cat.id,\n   384→                name=cat.name,\n   385→                slug=cat.slug,\n   386→                description=cat.description,\n   387→                icon=cat.icon,\n   388→                display_order=cat.display_order,\n   389→                post_count=0\n   390→            ),\n   391→            matched_flaws=cat_data[\"flaws\"],\n   392→            priority=cat_data[\"priority\"]\n   393→        ))\n   394→\n   395→    return response\n   396→\n   397→\n   398→@router.get(\"/archetype-recommendations\", response_model=List[ArchetypeForumRecommendation])\n   399→async def get_archetype_forum_recommendations(\n   400→    archetype: str = Query(..., description=\"Archetype category (Softboy, Prettyboy, RobustPrettyboy, Chad, Hypermasculine, Exotic)\"),\n   401→    db: AsyncSession = Depends(get_db)\n   402→):\n   403→    \"\"\"Get recommended forums based on user's archetype classification.\"\"\"\n   404→    # Normalize archetype name (handle case variations)\n   405→    archetype = archetype.strip()\n   406→\n   407→    # Valid archetypes\n   408→    valid_archetypes = [\"Softboy\", \"Prettyboy\", \"RobustPrettyboy\", \"Chad\", \"Hypermasculine\", \"Exotic\"]\n   409→\n   410→    # Case-insensitive match\n   411→    matched_archetype = None\n   412→    for valid in valid_archetypes:\n   413→        if archetype.lower() == valid.lower():\n   414→            matched_archetype = valid\n   415→            break\n   416→\n   417→    if not matched_archetype:\n   418→        # Return empty list for invalid archetype (not an error)\n   419→        return []\n   420→\n   421→    # Find mappings for this archetype, ordered by priority (highest first)\n   422→    query = (\n   423→        select(ArchetypeForumMapping)\n   424→        .options(selectinload(ArchetypeForumMapping.issue_category))\n   425→        .where(ArchetypeForumMapping.archetype_category == matched_archetype)\n   426→        .order_by(ArchetypeForumMapping.priority.desc())\n   427→    )\n   428→\n   429→    result = await db.execute(query)\n   430→    mappings = result.scalars().all()\n   431→\n   432→    # Build response\n   433→    response = []\n   434→    for mapping in mappings:\n   435→        cat = mapping.issue_category\n   436→        if cat and cat.is_active:\n   437→            response.append(ArchetypeForumRecommendation(\n   438→                category=CategoryListResponse(\n   439→                    id=cat.id,\n   440→                    name=cat.name,\n   441→                    slug=cat.slug,\n   442→                    description=cat.description,\n   443→                    icon=cat.icon,\n   444→                    display_order=cat.display_order,\n   445→                    post_count=0  # Could be optimized with a count query if needed\n   446→                ),\n   447→                archetype=matched_archetype,\n   448→                reason=mapping.reason,\n   449→                priority=mapping.priority\n   450→            ))\n   451→\n   452→    return response\n   453→\n   454→\n   455→@router.get(\"/guides\", response_model=List[GuideSectionResponse])\n   456→async def get_guides_section(db: AsyncSession = Depends(get_db)):\n   457→    \"\"\"Get pinned guides grouped by category for the top section.\"\"\"\n   458→    # Get categories\n   459→    cat_query = (\n   460→        select(ForumIssueCategory)\n   461→        .where(ForumIssueCategory.is_active == True)\n   462→        .order_by(ForumIssueCategory.display_order)\n   463→    )\n   464→    cat_result = await db.execute(cat_query)\n   465→    categories = cat_result.scalars().all()\n   466→\n   467→    response = []\n   468→    for cat in categories:\n   469→        # Get top 5 guides (pinned or marked as guide) per category\n   470→        guide_query = (\n   471→            select(ForumPost)\n   472→            .options(\n   473→                selectinload(ForumPost.author),\n   474→                selectinload(ForumPost.sub_forum)\n   475→            )\n   476→            .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n   477→            .where(\n   478→                ForumSubForum.issue_category_id == cat.id,\n   479→                ForumPost.is_deleted == False,\n   480→                ForumPost.is_approved == True,\n   481→                or_(ForumPost.is_pinned == True, ForumPost.is_guide == True)\n   482→            )\n   483→            .order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n   484→            .limit(5)\n   485→        )\n   486→        guide_result = await db.execute(guide_query)\n   487→        guides = guide_result.scalars().all()\n   488→\n   489→        if guides:  # Only include categories that have guides\n   490→            response.append(GuideSectionResponse(\n   491→                category=CategoryListResponse(\n   492→                    id=cat.id,\n   493→                    name=cat.name,\n   494→                    slug=cat.slug,\n   495→                    description=cat.description,\n   496→                    icon=cat.icon,\n   497→                    display_order=cat.display_order,\n   498→                    post_count=0\n   499→                ),\n   500→                guides=[_post_to_list_item(g, cat.slug, None) for g in guides]\n   501→            ))\n   502→\n   503→    return response\n   504→\n   505→\n   506→# === POSTS ===\n   507→\n   508→@router.get(\"/sub-forums/{sub_forum_id}/posts\", response_model=PostListResponse)\n   509→async def list_sub_forum_posts(\n   510→    sub_forum_id: UUID,\n   511→    sort: SortOrder = Query(SortOrder.HOT),\n   512→    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n   513→    offset: int = Query(0, ge=0),\n   514→    current_user: Optional[User] = Depends(get_current_user_optional),\n   515→    db: AsyncSession = Depends(get_db),\n   516→):\n   517→    \"\"\"List posts in a sub-forum with sorting and pagination.\"\"\"\n   518→    # Verify sub-forum exists and get category\n   519→    sf_result = await db.execute(\n   520→        select(ForumSubForum)\n   521→        .options(selectinload(ForumSubForum.issue_category))\n   522→        .where(ForumSubForum.id == sub_forum_id)\n   523→    )\n   524→    sub_forum = sf_result.scalar_one_or_none()\n   525→    if not sub_forum:\n   526→        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n   527→\n   528→    category_slug = sub_forum.issue_category.slug\n   529→\n   530→    # Base query\n   531→    query = (\n   532→        select(ForumPost)\n   533→        .options(selectinload(ForumPost.author))\n   534→        .where(\n   535→            ForumPost.sub_forum_id == sub_forum_id,\n   536→            ForumPost.is_deleted == False,\n   537→            ForumPost.is_approved == True\n   538→        )\n   539→    )\n   540→\n   541→    # Sorting - pinned always first\n   542→    if sort == SortOrder.NEW:\n   543→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n   544→    elif sort == SortOrder.TOP:\n   545→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n   546→    else:  # HOT - combination of votes and recency\n   547→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n   548→\n   549→    # Get total count\n   550→    count_query = (\n   551→        select(func.count(ForumPost.id))\n   552→        .where(\n   553→            ForumPost.sub_forum_id == sub_forum_id,\n   554→            ForumPost.is_deleted == False,\n   555→            ForumPost.is_approved == True\n   556→        )\n   557→    )\n   558→    total_result = await db.execute(count_query)\n   559→    total_count = total_result.scalar() or 0\n   560→\n   561→    # Paginate\n   562→    query = query.offset(offset).limit(limit)\n   563→    result = await db.execute(query)\n   564→    posts = result.scalars().all()\n   565→\n   566→    # Get user votes if authenticated\n   567→    user_votes = {}\n   568→    if current_user:\n   569→        post_ids = [p.id for p in posts]\n   570→        if post_ids:\n   571→            votes_query = select(ForumVote).where(\n   572→                ForumVote.user_id == current_user.id,\n   573→                ForumVote.target_type == TargetType.POST,\n   574→                ForumVote.target_id.in_(post_ids)\n   575→            )\n   576→            votes_result = await db.execute(votes_query)\n   577→            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n   578→\n   579→    return PostListResponse(\n   580→        posts=[_post_to_list_item(p, category_slug, user_votes.get(p.id)) for p in posts],\n   581→        total_count=total_count,\n   582→        has_more=offset + limit < total_count\n   583→    )\n   584→\n   585→\n   586→@router.get(\"/categories/{slug}/posts\", response_model=PostListResponse)\n   587→async def list_category_posts(\n   588→    slug: str,\n   589→    sort: SortOrder = Query(SortOrder.HOT),\n   590→    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n   591→    offset: int = Query(0, ge=0),\n   592→    current_user: Optional[User] = Depends(get_current_user_optional),\n   593→    db: AsyncSession = Depends(get_db),\n   594→):\n   595→    \"\"\"List all posts in a category (across all sub-forums) with sorting and pagination.\"\"\"\n   596→    # Verify category exists\n   597→    cat_result = await db.execute(\n   598→        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n   599→    )\n   600→    category = cat_result.scalar_one_or_none()\n   601→    if not category:\n   602→        raise HTTPException(status_code=404, detail=\"Category not found\")\n   603→\n   604→    # Base query - join with sub-forums to filter by category\n   605→    query = (\n   606→        select(ForumPost)\n   607→        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n   608→        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n   609→        .where(\n   610→            ForumSubForum.issue_category_id == category.id,\n   611→            ForumPost.is_deleted == False,\n   612→            ForumPost.is_approved == True\n   613→        )\n   614→    )\n   615→\n   616→    # Sorting\n   617→    if sort == SortOrder.NEW:\n   618→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n   619→    elif sort == SortOrder.TOP:\n   620→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n   621→    else:\n   622→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n   623→\n   624→    # Get total count\n   625→    count_query = (\n   626→        select(func.count(ForumPost.id))\n   627→        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n   628→        .where(\n   629→            ForumSubForum.issue_category_id == category.id,\n   630→            ForumPost.is_deleted == False,\n   631→            ForumPost.is_approved == True\n   632→        )\n   633→    )\n   634→    total_result = await db.execute(count_query)\n   635→    total_count = total_result.scalar() or 0\n   636→\n   637→    # Paginate\n   638→    query = query.offset(offset).limit(limit)\n   639→    result = await db.execute(query)\n   640→    posts = result.scalars().all()\n   641→\n   642→    # Get user votes\n   643→    user_votes = {}\n   644→    if current_user:\n   645→        post_ids = [p.id for p in posts]\n   646→        if post_ids:\n   647→            votes_query = select(ForumVote).where(\n   648→                ForumVote.user_id == current_user.id,\n   649→                ForumVote.target_type == TargetType.POST,\n   650→                ForumVote.target_id.in_(post_ids)\n   651→            )\n   652→            votes_result = await db.execute(votes_query)\n   653→            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n   654→\n   655→    return PostListResponse(\n   656→        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n   657→        total_count=total_count,\n   658→        has_more=offset + limit < total_count\n   659→    )\n   660→\n   661→\n   662→@router.get(\"/categories/{slug}/{sub_forum_slug}/posts\", response_model=PostListResponse)\n   663→async def list_sub_forum_posts(\n   664→    slug: str,\n   665→    sub_forum_slug: str,\n   666→    sort: SortOrder = Query(SortOrder.HOT),\n   667→    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n   668→    offset: int = Query(0, ge=0),\n   669→    current_user: Optional[User] = Depends(get_current_user_optional),\n   670→    db: AsyncSession = Depends(get_db),\n   671→):\n   672→    \"\"\"List all posts in a specific sub-forum with sorting and pagination.\"\"\"\n   673→    # Verify category and sub-forum exist\n   674→    cat_result = await db.execute(\n   675→        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n   676→    )\n   677→    category = cat_result.scalar_one_or_none()\n   678→    if not category:\n   679→        raise HTTPException(status_code=404, detail=\"Category not found\")\n   680→\n   681→    sf_result = await db.execute(\n   682→        select(ForumSubForum).where(\n   683→            ForumSubForum.slug == sub_forum_slug,\n   684→            ForumSubForum.issue_category_id == category.id\n   685→        )\n   686→    )\n   687→    sub_forum = sf_result.scalar_one_or_none()\n   688→    if not sub_forum:\n   689→        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n   690→\n   691→    # Base query\n   692→    query = (\n   693→        select(ForumPost)\n   694→        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n   695→        .where(\n   696→            ForumPost.sub_forum_id == sub_forum.id,\n   697→            ForumPost.is_deleted == False,\n   698→            ForumPost.is_approved == True\n   699→        )\n   700→    )\n   701→\n   702→    # Sorting\n   703→    if sort == SortOrder.NEW:\n   704→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n   705→    elif sort == SortOrder.TOP:\n   706→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n   707→    else:\n   708→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n   709→\n   710→    # Get total count\n   711→    count_query = (\n   712→        select(func.count(ForumPost.id))\n   713→        .where(\n   714→            ForumPost.sub_forum_id == sub_forum.id,\n   715→            ForumPost.is_deleted == False,\n   716→            ForumPost.is_approved == True\n   717→        )\n   718→    )\n   719→    total_result = await db.execute(count_query)\n   720→    total_count = total_result.scalar() or 0\n   721→\n   722→    # Paginate\n   723→    query = query.offset(offset).limit(limit)\n   724→    result = await db.execute(query)\n   725→    posts = result.scalars().all()\n   726→\n   727→    # Get user votes\n   728→    user_votes = {}\n   729→    if current_user:\n   730→        post_ids = [p.id for p in posts]\n   731→        if post_ids:\n   732→            votes_query = select(ForumVote).where(\n   733→                ForumVote.user_id == current_user.id,\n   734→                ForumVote.target_type == TargetType.POST,\n   735→                ForumVote.target_id.in_(post_ids)\n   736→            )\n   737→            votes_result = await db.execute(votes_query)\n   738→            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n   739→\n   740→    return PostListResponse(\n   741→        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n   742→        total_count=total_count,\n   743→        has_more=offset + limit < total_count\n   744→    )\n   745→\n   746→\n   747→@router.post(\"/posts\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\n   748→@limiter.limit(ForumRateLimits.POSTS)\n   749→async def create_post(\n   750→    request: Request,\n   751→    data: PostCreate,\n   752→    current_user: User = Depends(get_current_user),\n   753→    db: AsyncSession = Depends(get_db),\n   754→):\n   755→    \"\"\"Create a new post.\n   756→\n   757→    Rate limit: 5 posts per minute per user.\n   758→    \"\"\"\n   759→    # Verify sub-forum exists\n   760→    sf_result = await db.execute(\n   761→        select(ForumSubForum)\n   762→        .options(selectinload(ForumSubForum.issue_category))\n   763→        .where(ForumSubForum.id == data.sub_forum_id)\n   764→    )\n   765→    sub_forum = sf_result.scalar_one_or_none()\n   766→    if not sub_forum:\n   767→        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n   768→\n   769→    post = ForumPost(\n   770→        title=data.title,\n   771→        content=data.content,\n   772→        sub_forum_id=data.sub_forum_id,\n   773→        author_id=current_user.id,\n   774→    )\n   775→\n   776→    db.add(post)\n   777→    await db.commit()\n   778→    await db.refresh(post)\n   779→\n   780→    return _post_to_response(post, sub_forum.slug, sub_forum.issue_category.slug, None)\n   781→\n   782→\n   783→@router.get(\"/posts/{post_id}\", response_model=PostResponse)\n   784→async def get_post(\n   785→    post_id: UUID,\n   786→    current_user: Optional[User] = Depends(get_current_user_optional),\n   787→    db: AsyncSession = Depends(get_db),\n   788→):\n   789→    \"\"\"Get a single post with full details.\"\"\"\n   790→    query = (\n   791→        select(ForumPost)\n   792→        .options(\n   793→            selectinload(ForumPost.author),\n   794→            selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n   795→        )\n   796→        .where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n   797→    )\n   798→    result = await db.execute(query)\n   799→    post = result.scalar_one_or_none()\n   800→\n   801→    if not post:\n   802→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   803→\n   804→    # Get user's vote\n   805→    user_vote = None\n   806→    if current_user:\n   807→        vote_result = await db.execute(\n   808→            select(ForumVote).where(\n   809→                ForumVote.user_id == current_user.id,\n   810→                ForumVote.target_type == TargetType.POST,\n   811→                ForumVote.target_id == post_id\n   812→            )\n   813→        )\n   814→        vote = vote_result.scalar_one_or_none()\n   815→        user_vote = vote.vote_type if vote else None\n   816→\n   817→    return _post_to_response(\n   818→        post,\n   819→        post.sub_forum.slug,\n   820→        post.sub_forum.issue_category.slug,\n   821→        user_vote\n   822→    )\n   823→\n   824→\n   825→@router.post(\"/posts/{post_id}/vote\", response_model=VoteResponse)\n   826→@limiter.limit(ForumRateLimits.VOTES)\n   827→async def vote_on_post(\n   828→    request: Request,\n   829→    post_id: UUID,\n   830→    data: VoteRequest,\n   831→    current_user: User = Depends(get_current_user),\n   832→    db: AsyncSession = Depends(get_db),\n   833→):\n   834→    \"\"\"Vote on a post (upvote/downvote). Voting again removes vote, changing vote type switches it.\n   835→\n   836→    Rate limit: 30 votes per minute per user.\n   837→    \"\"\"\n   838→    # Verify post exists\n   839→    post_result = await db.execute(\n   840→        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n   841→    )\n   842→    post = post_result.scalar_one_or_none()\n   843→    if not post:\n   844→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   845→\n   846→    # Prevent self-voting\n   847→    if post.author_id == current_user.id:\n   848→        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")\n   849→\n   850→    # Check existing vote\n   851→    vote_result = await db.execute(\n   852→        select(ForumVote).where(\n   853→            ForumVote.user_id == current_user.id,\n   854→            ForumVote.target_type == TargetType.POST,\n   855→            ForumVote.target_id == post_id\n   856→        )\n   857→    )\n   858→    existing_vote = vote_result.scalar_one_or_none()\n   859→\n   860→    new_user_vote = None\n   861→    if existing_vote:\n   862→        # Robustly get value (handle if DB returns string or Enum)\n   863→        current_val = existing_vote.vote_type.value if hasattr(existing_vote.vote_type, 'value') else existing_vote.vote_type\n   864→        # Request is from Pydantic Schema Enum\n   865→        request_val = data.vote_type.value\n   866→\n   867→        if current_val == request_val:\n   868→            # Same vote - remove it\n   869→            await db.delete(existing_vote)\n   870→            post.vote_count += -1 if request_val == \"up\" else 1\n   871→        else:\n   872→            # Different vote - switch it\n   873→            # Ensure we assign the Model Enum (or string if that's what it wants, but Model Enum is safer if Typed)\n   874→            existing_vote.vote_type = VoteType(request_val)\n   875→            # Swing by 2 (remove old, add new)\n   876→            post.vote_count += 2 if request_val == \"up\" else -2\n   877→            new_user_vote = data.vote_type\n   878→    else:\n   879→        # New vote\n   880→        vote = ForumVote(\n   881→            user_id=current_user.id,\n   882→            target_type=TargetType.POST,\n   883→            target_id=post_id,\n   884→            # Explicitly cast to Model Enum\n   885→            vote_type=VoteType(data.vote_type.value)\n   886→        )\n   887→        db.add(vote)\n   888→        post.vote_count += 1 if data.vote_type.value == \"up\" else -1\n   889→        new_user_vote = data.vote_type\n   890→\n   891→    await db.commit()\n   892→\n   893→    return VoteResponse(success=True, new_vote_count=post.vote_count, user_vote=new_user_vote)\n   894→\n   895→\n   896→@router.delete(\"/posts/{post_id}\")\n   897→async def delete_post(\n   898→    post_id: UUID,\n   899→    current_user: User = Depends(get_current_user),\n   900→    db: AsyncSession = Depends(get_db),\n   901→):\n   902→    \"\"\"Delete a post (author or moderator).\"\"\"\n   903→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n   904→    post = post_result.scalar_one_or_none()\n   905→    if not post:\n   906→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   907→\n   908→    is_author = post.author_id == current_user.id\n   909→    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n   910→\n   911→    if not is_author and not is_mod:\n   912→        raise HTTPException(status_code=403, detail=\"Not authorized\")\n   913→\n   914→    post.is_deleted = True\n   915→    post.deleted_at = datetime.now(timezone.utc)\n   916→    post.deleted_by = current_user.id\n   917→    await db.commit()\n   918→\n   919→    return {\"success\": True}\n   920→\n   921→\n   922→@router.put(\"/posts/{post_id}\", response_model=PostResponse)\n   923→async def update_post(\n   924→    post_id: UUID,\n   925→    data: PostUpdate,\n   926→    current_user: User = Depends(get_current_user),\n   927→    db: AsyncSession = Depends(get_db),\n   928→):\n   929→    \"\"\"Update a post (author only).\"\"\"\n   930→    post_result = await db.execute(\n   931→        select(ForumPost)\n   932→        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n   933→        .where(ForumPost.id == post_id)\n   934→    )\n   935→    post = post_result.scalar_one_or_none()\n   936→    if not post:\n   937→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   938→\n   939→    if post.author_id != current_user.id:\n   940→        raise HTTPException(status_code=403, detail=\"Not authorized to edit this post\")\n   941→\n   942→    if data.title is not None:\n   943→        post.title = data.title\n   944→    if data.content is not None:\n   945→        post.content = data.content\n   946→    post.updated_at = datetime.utcnow()\n   947→\n   948→    await db.commit()\n   949→    await db.refresh(post)\n   950→\n   951→    # Get user vote\n   952→    vote_result = await db.execute(\n   953→        select(ForumVote).where(\n   954→            ForumVote.user_id == current_user.id,\n   955→            ForumVote.target_type == TargetType.POST,\n   956→            ForumVote.target_id == post_id\n   957→        )\n   958→    )\n   959→    user_vote = vote_result.scalar_one_or_none()\n   960→\n   961→    # Get category slug\n   962→    sf = post.sub_forum\n   963→    cat_result = await db.execute(\n   964→        select(ForumIssueCategory).where(ForumIssueCategory.id == sf.issue_category_id)\n   965→    )\n   966→    cat = cat_result.scalar_one()\n   967→\n   968→    return PostResponse(\n   969→        id=post.id,\n   970→        title=post.title,\n   971→        content=post.content,\n   972→        vote_count=post.vote_count,\n   973→        comment_count=post.comment_count,\n   974→        is_pinned=post.is_pinned,\n   975→        is_guide=post.is_guide,\n   976→        created_at=post.created_at,\n   977→        updated_at=post.updated_at,\n   978→        author=PostAuthor(\n   979→            id=post.author.id,\n   980→            username=post.author.username,\n   981→            avatar_url=None\n   982→        ),\n   983→        sub_forum=SubForumResponse(\n   984→            id=sf.id,\n   985→            name=sf.name,\n   986→            slug=sf.slug,\n   987→            description=sf.description,\n   988→            icon=sf.icon,\n   989→            display_order=sf.display_order,\n   990→            post_count=0\n   991→        ),\n   992→        category_slug=cat.slug,\n   993→        user_vote=user_vote.vote_type if user_vote else None\n   994→    )\n   995→\n   996→\n   997→# === COMMENTS ===\n   998→\n   999→@router.get(\"/posts/{post_id}/comments\", response_model=List[CommentResponse])\n  1000→async def get_post_comments(\n  1001→    post_id: UUID,\n  1002→    current_user: Optional[User] = Depends(get_current_user_optional),\n  1003→    db: AsyncSession = Depends(get_db),\n  1004→):\n  1005→    \"\"\"Get all comments for a post in a threaded structure.\"\"\"\n  1006→    # Verify post exists\n  1007→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n  1008→    if not post_result.scalar_one_or_none():\n  1009→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1010→\n  1011→    # Get all comments for post\n  1012→    query = (\n  1013→        select(ForumComment)\n  1014→        .options(selectinload(ForumComment.author))\n  1015→        .where(ForumComment.post_id == post_id, ForumComment.is_deleted == False)\n  1016→        .order_by(ForumComment.created_at)\n  1017→    )\n  1018→    result = await db.execute(query)\n  1019→    comments = result.scalars().all()\n  1020→\n  1021→    # Get user votes\n  1022→    user_votes = {}\n  1023→    if current_user:\n  1024→        comment_ids = [c.id for c in comments]\n  1025→        if comment_ids:\n  1026→            votes_query = select(ForumVote).where(\n  1027→                ForumVote.user_id == current_user.id,\n  1028→                ForumVote.target_type == TargetType.COMMENT,\n  1029→                ForumVote.target_id.in_(comment_ids)\n  1030→            )\n  1031→            votes_result = await db.execute(votes_query)\n  1032→            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n  1033→\n  1034→    # Build tree structure\n  1035→    return _build_comment_tree(comments, user_votes)\n  1036→\n  1037→\n  1038→@router.post(\"/posts/{post_id}/comments\", response_model=CommentResponse, status_code=status.HTTP_201_CREATED)\n  1039→@limiter.limit(ForumRateLimits.COMMENTS)\n  1040→async def create_comment(\n  1041→    request: Request,\n  1042→    post_id: UUID,\n  1043→    data: CommentCreate,\n  1044→    current_user: User = Depends(get_current_user),\n  1045→    db: AsyncSession = Depends(get_db),\n  1046→):\n  1047→    \"\"\"Create a comment on a post.\n  1048→\n  1049→    Rate limit: 20 comments per minute per user.\n  1050→    \"\"\"\n  1051→    # Verify post exists\n  1052→    post_result = await db.execute(\n  1053→        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n  1054→    )\n  1055→    post = post_result.scalar_one_or_none()\n  1056→    if not post:\n  1057→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1058→\n  1059→    depth = 0\n  1060→    if data.parent_id:\n  1061→        # Verify parent comment exists\n  1062→        parent_result = await db.execute(\n  1063→            select(ForumComment).where(\n  1064→                ForumComment.id == data.parent_id,\n  1065→                ForumComment.post_id == post_id\n  1066→            )\n  1067→        )\n  1068→        parent = parent_result.scalar_one_or_none()\n  1069→        if not parent:\n  1070→            raise HTTPException(status_code=404, detail=\"Parent comment not found\")\n  1071→        depth = min(parent.depth + 1, MAX_COMMENT_DEPTH)\n  1072→\n  1073→    comment = ForumComment(\n  1074→        content=data.content,\n  1075→        post_id=post_id,\n  1076→        author_id=current_user.id,\n  1077→        parent_id=data.parent_id,\n  1078→        depth=depth,\n  1079→    )\n  1080→\n  1081→    db.add(comment)\n  1082→    await db.commit()\n  1083→    await db.refresh(comment)\n  1084→\n  1085→    # Load author relationship\n  1086→    await db.refresh(comment, [\"author\"])\n  1087→\n  1088→    return _comment_to_response(comment, None)\n  1089→\n  1090→\n  1091→@router.post(\"/comments/{comment_id}/vote\", response_model=VoteResponse)\n  1092→@limiter.limit(ForumRateLimits.VOTES)\n  1093→async def vote_on_comment(\n  1094→    request: Request,\n  1095→    comment_id: UUID,\n  1096→    data: VoteRequest,\n  1097→    current_user: User = Depends(get_current_user),\n  1098→    db: AsyncSession = Depends(get_db),\n  1099→):\n  1100→    \"\"\"Vote on a comment.\n  1101→\n  1102→    Rate limit: 30 votes per minute per user.\n  1103→    \"\"\"\n  1104→    comment_result = await db.execute(\n  1105→        select(ForumComment).where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n  1106→    )\n  1107→    comment = comment_result.scalar_one_or_none()\n  1108→    if not comment:\n  1109→        raise HTTPException(status_code=404, detail=\"Comment not found\")\n  1110→\n  1111→    # Prevent self-voting\n  1112→    if comment.author_id == current_user.id:\n  1113→        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")\n  1114→\n  1115→    vote_result = await db.execute(\n  1116→        select(ForumVote).where(\n  1117→            ForumVote.user_id == current_user.id,\n  1118→            ForumVote.target_type == TargetType.COMMENT,\n  1119→            ForumVote.target_id == comment_id\n  1120→        )\n  1121→    )\n  1122→    existing_vote = vote_result.scalar_one_or_none()\n  1123→\n  1124→    new_user_vote = None\n  1125→    if existing_vote:\n  1126→        if existing_vote.vote_type == data.vote_type:\n  1127→            await db.delete(existing_vote)\n  1128→            comment.vote_count += -1 if data.vote_type == VoteType.UP else 1\n  1129→        else:\n  1130→            existing_vote.vote_type = data.vote_type\n  1131→            comment.vote_count += 2 if data.vote_type == VoteType.UP else -2\n  1132→            new_user_vote = data.vote_type\n  1133→    else:\n  1134→        vote = ForumVote(\n  1135→            user_id=current_user.id,\n  1136→            target_type=TargetType.COMMENT,\n  1137→            target_id=comment_id,\n  1138→            vote_type=data.vote_type\n  1139→        )\n  1140→        db.add(vote)\n  1141→        comment.vote_count += 1 if data.vote_type == VoteType.UP else -1\n  1142→        new_user_vote = data.vote_type\n  1143→\n  1144→    await db.commit()\n  1145→\n  1146→    return VoteResponse(success=True, new_vote_count=comment.vote_count, user_vote=new_user_vote)\n  1147→\n  1148→\n  1149→@router.put(\"/comments/{comment_id}\", response_model=CommentResponse)\n  1150→async def update_comment(\n  1151→    comment_id: UUID,\n  1152→    data: CommentUpdate,\n  1153→    current_user: User = Depends(get_current_user),\n  1154→    db: AsyncSession = Depends(get_db),\n  1155→):\n  1156→    \"\"\"Update a comment (author only).\"\"\"\n  1157→    comment_result = await db.execute(\n  1158→        select(ForumComment)\n  1159→        .options(selectinload(ForumComment.author))\n  1160→        .where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n  1161→    )\n  1162→    comment = comment_result.scalar_one_or_none()\n  1163→    if not comment:\n  1164→        raise HTTPException(status_code=404, detail=\"Comment not found\")\n  1165→\n  1166→    if comment.author_id != current_user.id:\n  1167→        raise HTTPException(status_code=403, detail=\"Not authorized to edit this comment\")\n  1168→\n  1169→    comment.content = data.content\n  1170→    comment.updated_at = datetime.utcnow()\n  1171→\n  1172→    await db.commit()\n  1173→    await db.refresh(comment)\n  1174→\n  1175→    # Get user vote\n  1176→    vote_result = await db.execute(\n  1177→        select(ForumVote).where(\n  1178→            ForumVote.user_id == current_user.id,\n  1179→            ForumVote.target_type == TargetType.COMMENT,\n  1180→            ForumVote.target_id == comment_id\n  1181→        )\n  1182→    )\n  1183→    user_vote = vote_result.scalar_one_or_none()\n  1184→\n  1185→    return _comment_to_response(comment, user_vote.vote_type if user_vote else None)\n  1186→\n  1187→\n  1188→@router.delete(\"/comments/{comment_id}\")\n  1189→async def delete_comment(\n  1190→    comment_id: UUID,\n  1191→    current_user: User = Depends(get_current_user),\n  1192→    db: AsyncSession = Depends(get_db),\n  1193→):\n  1194→    \"\"\"Delete a comment (author or moderator).\"\"\"\n  1195→    comment_result = await db.execute(select(ForumComment).where(ForumComment.id == comment_id))\n  1196→    comment = comment_result.scalar_one_or_none()\n  1197→    if not comment:\n  1198→        raise HTTPException(status_code=404, detail=\"Comment not found\")\n  1199→\n  1200→    is_author = comment.author_id == current_user.id\n  1201→    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n  1202→\n  1203→    if not is_author and not is_mod:\n  1204→        raise HTTPException(status_code=403, detail=\"Not authorized\")\n  1205→\n  1206→    comment.is_deleted = True\n  1207→    comment.deleted_at = datetime.now(timezone.utc)\n  1208→    comment.deleted_by = current_user.id\n  1209→\n  1210→    # Decrement comment count on the parent post\n  1211→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == comment.post_id))\n  1212→    post = post_result.scalar_one_or_none()\n  1213→    if post and post.comment_count > 0:\n  1214→        post.comment_count -= 1\n  1215→\n  1216→    await db.commit()\n  1217→\n  1218→    return {\"success\": True}\n  1219→\n  1220→\n  1221→# === REPORTS ===\n  1222→\n  1223→@router.post(\"/reports\", response_model=ReportResponse, status_code=status.HTTP_201_CREATED)\n  1224→@limiter.limit(ForumRateLimits.REPORTS)\n  1225→async def create_report(\n  1226→    request: Request,\n  1227→    data: ReportCreate,\n  1228→    current_user: User = Depends(get_current_user),\n  1229→    db: AsyncSession = Depends(get_db),\n  1230→):\n  1231→    \"\"\"Report a post or comment.\n  1232→\n  1233→    Rate limit: 10 reports per hour per user.\n  1234→    \"\"\"\n  1235→    # Verify target exists\n  1236→    if data.target_type == TargetType.POST:\n  1237→        target_result = await db.execute(select(ForumPost).where(ForumPost.id == data.target_id))\n  1238→    else:\n  1239→        target_result = await db.execute(select(ForumComment).where(ForumComment.id == data.target_id))\n  1240→\n  1241→    if not target_result.scalar_one_or_none():\n  1242→        raise HTTPException(status_code=404, detail=\"Target not found\")\n  1243→\n  1244→    # Check for duplicate report\n  1245→    existing = await db.execute(\n  1246→        select(ForumReport).where(\n  1247→            ForumReport.reporter_id == current_user.id,\n  1248→            ForumReport.target_type == data.target_type,\n  1249→            ForumReport.target_id == data.target_id,\n  1250→            ForumReport.status == ReportStatus.PENDING\n  1251→        )\n  1252→    )\n  1253→    if existing.scalar_one_or_none():\n  1254→        raise HTTPException(status_code=400, detail=\"You have already reported this content\")\n  1255→\n  1256→    report = ForumReport(\n  1257→        reporter_id=current_user.id,\n  1258→        target_type=data.target_type,\n  1259→        target_id=data.target_id,\n  1260→        reason=data.reason,\n  1261→        details=data.details,\n  1262→    )\n  1263→\n  1264→    db.add(report)\n  1265→    await db.commit()\n  1266→    await db.refresh(report)\n  1267→\n  1268→    return ReportResponse(\n  1269→        id=report.id,\n  1270→        target_type=report.target_type,\n  1271→        target_id=report.target_id,\n  1272→        reason=report.reason,\n  1273→        status=report.status.value,\n  1274→        created_at=report.created_at\n  1275→    )\n  1276→\n  1277→\n  1278→# === MODERATION (Admin/Moderator only) ===\n  1279→\n  1280→@router.post(\"/posts/{post_id}/pin\")\n  1281→async def pin_post(\n  1282→    post_id: UUID,\n  1283→    current_user: User = Depends(get_current_user),\n  1284→    db: AsyncSession = Depends(get_db),\n  1285→):\n  1286→    \"\"\"Pin/unpin a post (moderator only).\"\"\"\n  1287→    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n  1288→        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n  1289→\n  1290→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n  1291→    post = post_result.scalar_one_or_none()\n  1292→    if not post:\n  1293→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1294→\n  1295→    post.is_pinned = not post.is_pinned\n  1296→    await db.commit()\n  1297→\n  1298→    return {\"success\": True, \"is_pinned\": post.is_pinned}\n  1299→\n  1300→\n  1301→@router.post(\"/posts/{post_id}/mark-guide\")\n  1302→async def mark_as_guide(\n  1303→    post_id: UUID,\n  1304→    current_user: User = Depends(get_current_user),\n  1305→    db: AsyncSession = Depends(get_db),\n  1306→):\n  1307→    \"\"\"Mark/unmark a post as a guide (moderator only).\"\"\"\n  1308→    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n  1309→        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n  1310→\n  1311→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n  1312→    post = post_result.scalar_one_or_none()\n  1313→    if not post:\n  1314→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1315→\n  1316→    post.is_guide = not post.is_guide\n  1317→    await db.commit()\n  1318→\n  1319→    return {\"success\": True, \"is_guide\": post.is_guide}\n  1320→\n  1321→\n  1322→@router.get(\"/reports\", response_model=List[ReportResponse])\n  1323→async def list_reports(\n  1324→    status_filter: Optional[ReportStatus] = Query(None, alias=\"status\"),\n  1325→    limit: int = Query(50, ge=1, le=100),\n  1326→    offset: int = Query(0, ge=0),\n  1327→    current_user: User = Depends(get_current_user),\n  1328→    db: AsyncSession = Depends(get_db),\n  1329→):\n  1330→    \"\"\"List reports (moderator only).\"\"\"\n  1331→    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n  1332→        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n  1333→\n  1334→    query = select(ForumReport).order_by(ForumReport.created_at.desc())\n  1335→\n  1336→    if status_filter:\n  1337→        query = query.where(ForumReport.status == status_filter)\n  1338→\n  1339→    query = query.offset(offset).limit(limit)\n  1340→    result = await db.execute(query)\n  1341→    reports = result.scalars().all()\n  1342→\n  1343→    return [\n  1344→        ReportResponse(\n  1345→            id=r.id,\n  1346→            target_type=r.target_type,\n  1347→            target_id=r.target_id,\n  1348→            reason=r.reason,\n  1349→            status=r.status.value,\n  1350→            created_at=r.created_at\n  1351→        )\n  1352→        for r in reports\n  1353→    ]\n  1354→\n  1355→\n  1356→@router.patch(\"/reports/{report_id}\")\n  1357→async def update_report_status(\n  1358→    report_id: UUID,\n  1359→    new_status: ReportStatus,\n  1360→    current_user: User = Depends(get_current_user),\n  1361→    db: AsyncSession = Depends(get_db),\n  1362→):\n  1363→    \"\"\"Update report status (moderator only).\"\"\"\n  1364→    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n  1365→        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n  1366→\n  1367→    report_result = await db.execute(select(ForumReport).where(ForumReport.id == report_id))\n  1368→    report = report_result.scalar_one_or_none()\n  1369→    if not report:\n  1370→        raise HTTPException(status_code=404, detail=\"Report not found\")\n  1371→\n  1372→    report.status = new_status\n  1373→    report.reviewed_by = current_user.id\n  1374→    report.reviewed_at = datetime.utcnow()\n  1375→\n  1376→    await db.commit()\n  1377→\n  1378→    return {\"success\": True, \"status\": new_status.value}\n  1379→\n  1380→\n  1381→# === BOOKMARKS ===\n  1382→\n  1383→@router.post(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\n  1384→async def toggle_bookmark(\n  1385→    post_id: UUID,\n  1386→    current_user: User = Depends(get_current_user),\n  1387→    db: AsyncSession = Depends(get_db),\n  1388→):\n  1389→    \"\"\"Toggle bookmark status for a post.\n  1390→\n  1391→    If the post is not bookmarked, it will be bookmarked.\n  1392→    If the post is already bookmarked, the bookmark will be removed.\n  1393→    \"\"\"\n  1394→    # Verify post exists\n  1395→    post_result = await db.execute(\n  1396→        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n  1397→    )\n  1398→    post = post_result.scalar_one_or_none()\n  1399→    if not post:\n  1400→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1401→\n  1402→    # Check if already bookmarked\n  1403→    existing = await db.execute(\n  1404→        select(ForumBookmark).where(\n  1405→            ForumBookmark.user_id == current_user.id,\n  1406→            ForumBookmark.post_id == post_id\n  1407→        )\n  1408→    )\n  1409→    existing_bookmark = existing.scalar_one_or_none()\n  1410→\n  1411→    if existing_bookmark:\n  1412→        # Remove bookmark\n  1413→        await db.delete(existing_bookmark)\n  1414→        await db.commit()\n  1415→        return BookmarkToggleResponse(\n  1416→            is_bookmarked=False,\n  1417→            message=\"Bookmark removed\"\n  1418→        )\n  1419→    else:\n  1420→        # Add bookmark\n  1421→        bookmark = ForumBookmark(\n  1422→            user_id=current_user.id,\n  1423→            post_id=post_id\n  1424→        )\n  1425→        db.add(bookmark)\n  1426→        await db.commit()\n  1427→        return BookmarkToggleResponse(\n  1428→            is_bookmarked=True,\n  1429→            message=\"Post bookmarked\"\n  1430→        )\n  1431→\n  1432→\n  1433→@router.delete(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\n  1434→async def remove_bookmark(\n  1435→    post_id: UUID,\n  1436→    current_user: User = Depends(get_current_user),\n  1437→    db: AsyncSession = Depends(get_db),\n  1438→):\n  1439→    \"\"\"Remove a bookmark from a post.\"\"\"\n  1440→    # Check if bookmark exists\n  1441→    existing = await db.execute(\n  1442→        select(ForumBookmark).where(\n  1443→            ForumBookmark.user_id == current_user.id,\n  1444→            ForumBookmark.post_id == post_id\n  1445→        )\n  1446→    )\n  1447→    existing_bookmark = existing.scalar_one_or_none()\n  1448→\n  1449→    if not existing_bookmark:\n  1450→        raise HTTPException(status_code=404, detail=\"Bookmark not found\")\n  1451→\n  1452→    await db.delete(existing_bookmark)\n  1453→    await db.commit()\n  1454→\n  1455→    return BookmarkToggleResponse(\n  1456→        is_bookmarked=False,\n  1457→        message=\"Bookmark removed\"\n  1458→    )\n  1459→\n  1460→\n  1461→@router.get(\"/bookmarks\", response_model=BookmarkedPostsResponse)\n  1462→async def get_bookmarked_posts(\n  1463→    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n  1464→    offset: int = Query(0, ge=0),\n  1465→    current_user: User = Depends(get_current_user),\n  1466→    db: AsyncSession = Depends(get_db),\n  1467→):\n  1468→    \"\"\"Get all bookmarked posts for the current user, sorted by bookmark date (newest first).\"\"\"\n  1469→    # Get total count\n  1470→    count_query = (\n  1471→        select(func.count(ForumBookmark.id))\n  1472→        .where(ForumBookmark.user_id == current_user.id)\n  1473→    )\n  1474→    total_result = await db.execute(count_query)\n  1475→    total_count = total_result.scalar() or 0\n  1476→\n  1477→    # Get bookmarked posts with pagination\n  1478→    query = (\n  1479→        select(ForumBookmark)\n  1480→        .options(\n  1481→            selectinload(ForumBookmark.post).selectinload(ForumPost.author),\n  1482→            selectinload(ForumBookmark.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n  1483→        )\n  1484→        .where(ForumBookmark.user_id == current_user.id)\n  1485→        .order_by(ForumBookmark.created_at.desc())\n  1486→        .offset(offset)\n  1487→        .limit(limit)\n  1488→    )\n  1489→    result = await db.execute(query)\n  1490→    bookmarks = result.scalars().all()\n  1491→\n  1492→    # Filter out any bookmarks for deleted posts\n  1493→    valid_bookmarks = [b for b in bookmarks if b.post and not b.post.is_deleted]\n  1494→\n  1495→    # Get user votes for these posts\n  1496→    post_ids = [b.post.id for b in valid_bookmarks]\n  1497→    user_votes = {}\n  1498→    if post_ids:\n  1499→        votes_query = select(ForumVote).where(\n  1500→            ForumVote.user_id == current_user.id,\n  1501→            ForumVote.target_type == TargetType.POST,\n  1502→            ForumVote.target_id.in_(post_ids)\n  1503→        )\n  1504→        votes_result = await db.execute(votes_query)\n  1505→        user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n  1506→\n  1507→    # Build response\n  1508→    posts = []\n  1509→    for bookmark in valid_bookmarks:\n  1510→        post = bookmark.post\n  1511→        category_slug = post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\"\n  1512→        posts.append(_post_to_list_item(post, category_slug, user_votes.get(post.id)))\n  1513→\n  1514→    return BookmarkedPostsResponse(\n  1515→        posts=posts,\n  1516→        total_count=total_count,\n  1517→        has_more=offset + limit < total_count\n  1518→    )\n  1519→\n  1520→\n  1521→@router.get(\"/posts/{post_id}/bookmark-status\")\n  1522→async def get_bookmark_status(\n  1523→    post_id: UUID,\n  1524→    current_user: User = Depends(get_current_user),\n  1525→    db: AsyncSession = Depends(get_db),\n  1526→):\n  1527→    \"\"\"Check if a post is bookmarked by the current user.\"\"\"\n  1528→    existing = await db.execute(\n  1529→        select(ForumBookmark).where(\n  1530→            ForumBookmark.user_id == current_user.id,\n  1531→            ForumBookmark.post_id == post_id\n  1532→        )\n  1533→    )\n  1534→    bookmark = existing.scalar_one_or_none()\n  1535→\n  1536→    return {\n  1537→        \"post_id\": str(post_id),\n  1538→        \"is_bookmarked\": bookmark is not None,\n  1539→        \"bookmarked_at\": bookmark.created_at.isoformat() if bookmark else None\n  1540→    }\n  1541→\n  1542→\n  1543→@router.get(\"/bookmarks/ids\")\n  1544→async def get_bookmarked_post_ids(\n  1545→    current_user: User = Depends(get_current_user),\n  1546→    db: AsyncSession = Depends(get_db),\n  1547→):\n  1548→    \"\"\"Get all bookmarked post IDs for the current user.\n  1549→\n  1550→    Useful for efficiently checking bookmark status on post lists.\n  1551→    \"\"\"\n  1552→    query = (\n  1553→        select(ForumBookmark.post_id)\n  1554→        .where(ForumBookmark.user_id == current_user.id)\n  1555→    )\n  1556→    result = await db.execute(query)\n  1557→    post_ids = [str(row[0]) for row in result.all()]\n  1558→\n  1559→    return {\"bookmarked_post_ids\": post_ids}\n  1560→\n  1561→\n  1562→# === HELPER FUNCTIONS ===\n  1563→\n  1564→def _post_to_list_item(post: ForumPost, category_slug: str, user_vote: Optional[VoteType]) -> PostListItem:\n  1565→    sub_forum_slug = post.sub_forum.slug if post.sub_forum else \"\"\n  1566→    return PostListItem(\n  1567→        id=post.id,\n  1568→        title=post.title,\n  1569→        content_preview=post.content[:200] + \"...\" if len(post.content) > 200 else post.content,\n  1570→        sub_forum_slug=sub_forum_slug,\n  1571→        category_slug=category_slug,\n  1572→        author=PostAuthor(id=post.author.id, username=post.author.username),\n  1573→        is_pinned=post.is_pinned,\n  1574→        is_guide=post.is_guide,\n  1575→        vote_count=post.vote_count,\n  1576→        comment_count=post.comment_count,\n  1577→        user_vote=user_vote,\n  1578→        created_at=post.created_at,\n  1579→    )\n  1580→\n  1581→\n  1582→def _post_to_response(\n  1583→    post: ForumPost,\n  1584→    sub_forum_slug: str,\n  1585→    category_slug: str,\n  1586→    user_vote: Optional[VoteType]\n  1587→) -> PostResponse:\n  1588→    return PostResponse(\n  1589→        id=post.id,\n  1590→        title=post.title,\n  1591→        content=post.content,\n  1592→        sub_forum_id=post.sub_forum_id,\n  1593→        sub_forum_slug=sub_forum_slug,\n  1594→        category_slug=category_slug,\n  1595→        author=PostAuthor(id=post.author.id, username=post.author.username),\n  1596→        is_pinned=post.is_pinned,\n  1597→        is_guide=post.is_guide,\n  1598→        vote_count=post.vote_count,\n  1599→        comment_count=post.comment_count,\n  1600→        user_vote=user_vote,\n  1601→        created_at=post.created_at,\n  1602→        updated_at=post.updated_at,\n  1603→    )\n  1604→\n  1605→\n  1606→def _comment_to_response(comment: ForumComment, user_vote: Optional[VoteType]) -> CommentResponse:\n  1607→    return CommentResponse(\n  1608→        id=comment.id,\n  1609→        content=comment.content,\n  1610→        post_id=comment.post_id,\n  1611→        author=PostAuthor(id=comment.author.id, username=comment.author.username),\n  1612→        parent_id=comment.parent_id,\n  1613→        vote_count=comment.vote_count,\n  1614→        user_vote=user_vote,\n  1615→        depth=comment.depth,\n  1616→        replies=[],\n  1617→        created_at=comment.created_at,\n  1618→        updated_at=comment.updated_at,\n  1619→    )\n  1620→\n  1621→\n  1622→def _build_comment_tree(comments: List[ForumComment], user_votes: dict) -> List[CommentResponse]:\n  1623→    \"\"\"Build a tree structure from flat comment list.\"\"\"\n  1624→    comment_map = {}\n  1625→    roots = []\n  1626→\n  1627→    # First pass: create all response objects\n  1628→    for c in comments:\n  1629→        comment_map[c.id] = _comment_to_response(c, user_votes.get(c.id))\n  1630→\n  1631→    # Second pass: build tree\n  1632→    for c in comments:\n  1633→        response = comment_map[c.id]\n  1634→        if c.parent_id and c.parent_id in comment_map:\n  1635→            comment_map[c.parent_id].replies.append(response)\n  1636→        else:\n  1637→            roots.append(response)\n  1638→\n  1639→    return roots\n  1640→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"804205b5-cd13-4545-b7b0-1d63601dc83c","timestamp":"2025-12-27T16:53:46.421Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","content":"\"\"\"\nForum router - Categories, Sub-Forums, Posts, Comments, Votes, Reports\n\nRate Limits:\n- Posts: 5 per minute per user\n- Comments: 20 per minute per user\n- Votes: 30 per minute per user\n- Reports: 10 per hour per user\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func, and_, or_, desc\nfrom sqlalchemy.orm import selectinload\nfrom uuid import UUID\nfrom typing import Optional, List\nfrom datetime import datetime, timezone\n\nfrom app.database import get_db\nfrom app.core.rate_limit import limiter, ForumRateLimits\nfrom app.models.user import User, UserRole\nfrom app.models.forum import (\n    ForumIssueCategory, ForumSubForum, ForumPost, ForumComment,\n    ForumVote, ForumReport, FlawToForumMapping, ArchetypeForumMapping,\n    ForumBookmark, VoteType, TargetType, ReportStatus, ReportReason\n)\nfrom app.services.auth import get_current_user, get_current_user_optional\nfrom app.schemas.forum import (\n    CategoryResponse, CategoryListResponse, SubForumResponse,\n    PostCreate, PostUpdate, PostResponse, PostListItem,\n    PostListResponse, CommentCreate, CommentUpdate, CommentResponse,\n    VoteRequest, VoteResponse, ReportCreate, ReportResponse,\n    GuideSectionResponse, SortOrder, PostAuthor, RecommendedForumResponse,\n    ArchetypeForumRecommendation, ForumSearchResult, ForumSearchResponse,\n    SearchResultType, BookmarkToggleResponse, BookmarkedPostsResponse\n)\n\nrouter = APIRouter(prefix=\"/forum\", tags=[\"forum\"])\n\nPAGE_SIZE = 20\nMAX_COMMENT_DEPTH = 5\n\n\n# === CATEGORIES ===\n\n@router.get(\"/categories\", response_model=List[CategoryResponse])\nasync def list_categories(db: AsyncSession = Depends(get_db)):\n    \"\"\"List all active forum categories with sub-forums and post counts.\n\n    Optimized to use only 2 queries instead of N+1 pattern.\n    \"\"\"\n    # Query 1: Get all categories with sub-forums\n    query = (\n        select(ForumIssueCategory)\n        .options(selectinload(ForumIssueCategory.sub_forums))\n        .where(ForumIssueCategory.is_active == True)\n        .order_by(ForumIssueCategory.display_order)\n    )\n    result = await db.execute(query)\n    categories = result.scalars().all()\n\n    # Query 2: Get ALL sub-forum post counts in ONE query (batched)\n    sf_counts_query = (\n        select(\n            ForumPost.sub_forum_id,\n            func.count(ForumPost.id).label('post_count')\n        )\n        .where(\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n        .group_by(ForumPost.sub_forum_id)\n    )\n    sf_counts_result = await db.execute(sf_counts_query)\n    sf_counts = {row[0]: row[1] for row in sf_counts_result}\n\n    # Build response using pre-fetched counts (no additional queries)\n    response = []\n    for cat in categories:\n        cat_post_count = 0\n        sub_forums = []\n\n        for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n            if sf.is_active:\n                sf_post_count = sf_counts.get(sf.id, 0)\n                cat_post_count += sf_post_count\n\n                sub_forums.append(SubForumResponse(\n                    id=sf.id,\n                    name=sf.name,\n                    slug=sf.slug,\n                    description=sf.description,\n                    icon=sf.icon,\n                    display_order=sf.display_order,\n                    post_count=sf_post_count\n                ))\n\n        response.append(CategoryResponse(\n            id=cat.id,\n            name=cat.name,\n            slug=cat.slug,\n            description=cat.description,\n            icon=cat.icon,\n            display_order=cat.display_order,\n            post_count=cat_post_count,\n            sub_forums=sub_forums\n        ))\n\n    return response\n\n\n@router.get(\"/categories/{slug}\", response_model=CategoryResponse)\nasync def get_category(\n    slug: str,\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get a single category by slug with its sub-forums.\n\n    Optimized to use only 2 queries instead of N+1 pattern.\n    \"\"\"\n    # Query 1: Get category with sub-forums\n    query = (\n        select(ForumIssueCategory)\n        .options(selectinload(ForumIssueCategory.sub_forums))\n        .where(ForumIssueCategory.slug == slug, ForumIssueCategory.is_active == True)\n    )\n    result = await db.execute(query)\n    cat = result.scalar_one_or_none()\n\n    if not cat:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    # Get sub-forum IDs for this category\n    sf_ids = [sf.id for sf in cat.sub_forums if sf.is_active]\n\n    # Query 2: Get post counts for all sub-forums in this category (batched)\n    sf_counts = {}\n    if sf_ids:\n        sf_counts_query = (\n            select(\n                ForumPost.sub_forum_id,\n                func.count(ForumPost.id).label('post_count')\n            )\n            .where(\n                ForumPost.sub_forum_id.in_(sf_ids),\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True\n            )\n            .group_by(ForumPost.sub_forum_id)\n        )\n        sf_counts_result = await db.execute(sf_counts_query)\n        sf_counts = {row[0]: row[1] for row in sf_counts_result}\n\n    # Build sub-forums list using pre-fetched counts\n    cat_post_count = 0\n    sub_forums = []\n    for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n        if sf.is_active:\n            sf_post_count = sf_counts.get(sf.id, 0)\n            cat_post_count += sf_post_count\n\n            sub_forums.append(SubForumResponse(\n                id=sf.id,\n                name=sf.name,\n                slug=sf.slug,\n                description=sf.description,\n                icon=sf.icon,\n                display_order=sf.display_order,\n                post_count=sf_post_count\n            ))\n\n    return CategoryResponse(\n        id=cat.id,\n        name=cat.name,\n        slug=cat.slug,\n        description=cat.description,\n        icon=cat.icon,\n        display_order=cat.display_order,\n        post_count=cat_post_count,\n        sub_forums=sub_forums\n    )\n\n\n# === SEARCH ===\n\n@router.get(\"/search\", response_model=ForumSearchResponse)\nasync def search_forum(\n    q: str = Query(..., min_length=2, max_length=100, description=\"Search query\"),\n    type: str = Query(\"all\", description=\"Search type: posts, comments, or all\"),\n    limit: int = Query(20, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Search forum posts and comments using ILIKE pattern matching.\n\n    - Search by title, content for posts\n    - Search by content for comments\n    - Results sorted by vote_count DESC, created_at DESC\n    \"\"\"\n    search_pattern = f\"%{q}%\"\n    results = []\n    total_count = 0\n\n    if type in (\"posts\", \"all\"):\n        # Search posts by title and content\n        post_query = (\n            select(ForumPost)\n            .options(\n                selectinload(ForumPost.author),\n                selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n            )\n            .where(\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(\n                    ForumPost.title.ilike(search_pattern),\n                    ForumPost.content.ilike(search_pattern)\n                )\n            )\n            .order_by(ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n        )\n\n        # Count posts\n        post_count_query = (\n            select(func.count(ForumPost.id))\n            .where(\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(\n                    ForumPost.title.ilike(search_pattern),\n                    ForumPost.content.ilike(search_pattern)\n                )\n            )\n        )\n        post_count_result = await db.execute(post_count_query)\n        post_count = post_count_result.scalar() or 0\n\n        if type == \"posts\":\n            total_count = post_count\n            post_query = post_query.offset(offset).limit(limit)\n        else:\n            total_count += post_count\n            # For \"all\", we get all posts first then merge with comments\n            post_query = post_query.limit(limit * 2)  # Get more to merge\n\n        post_result = await db.execute(post_query)\n        posts = post_result.scalars().all()\n\n        for post in posts:\n            content_preview = post.content[:200] + \"...\" if len(post.content) > 200 else post.content\n            results.append(ForumSearchResult(\n                id=post.id,\n                type=SearchResultType.POST,\n                title=post.title,\n                content_preview=content_preview,\n                post_id=None,\n                post_title=None,\n                author=PostAuthor(id=post.author.id, username=post.author.username),\n                vote_count=post.vote_count,\n                category_slug=post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\",\n                sub_forum_slug=post.sub_forum.slug if post.sub_forum else \"\",\n                created_at=post.created_at\n            ))\n\n    if type in (\"comments\", \"all\"):\n        # Search comments by content\n        comment_query = (\n            select(ForumComment)\n            .options(\n                selectinload(ForumComment.author),\n                selectinload(ForumComment.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n            )\n            .where(\n                ForumComment.is_deleted == False,\n                ForumComment.content.ilike(search_pattern)\n            )\n            .order_by(ForumComment.vote_count.desc(), ForumComment.created_at.desc())\n        )\n\n        # Count comments\n        comment_count_query = (\n            select(func.count(ForumComment.id))\n            .where(\n                ForumComment.is_deleted == False,\n                ForumComment.content.ilike(search_pattern)\n            )\n        )\n        comment_count_result = await db.execute(comment_count_query)\n        comment_count = comment_count_result.scalar() or 0\n\n        if type == \"comments\":\n            total_count = comment_count\n            comment_query = comment_query.offset(offset).limit(limit)\n        else:\n            total_count += comment_count\n            comment_query = comment_query.limit(limit * 2)\n\n        comment_result = await db.execute(comment_query)\n        comments = comment_result.scalars().all()\n\n        for comment in comments:\n            content_preview = comment.content[:200] + \"...\" if len(comment.content) > 200 else comment.content\n            post = comment.post\n            if post and post.sub_forum:\n                category_slug = post.sub_forum.issue_category.slug if post.sub_forum.issue_category else \"\"\n                sub_forum_slug = post.sub_forum.slug\n            else:\n                category_slug = \"\"\n                sub_forum_slug = \"\"\n\n            results.append(ForumSearchResult(\n                id=comment.id,\n                type=SearchResultType.COMMENT,\n                title=None,\n                content_preview=content_preview,\n                post_id=comment.post_id,\n                post_title=post.title if post else None,\n                author=PostAuthor(id=comment.author.id, username=comment.author.username),\n                vote_count=comment.vote_count,\n                category_slug=category_slug,\n                sub_forum_slug=sub_forum_slug,\n                created_at=comment.created_at\n            ))\n\n    # For \"all\" type, sort merged results by vote_count and created_at, then paginate\n    if type == \"all\":\n        results.sort(key=lambda x: (-x.vote_count, x.created_at), reverse=False)\n        results.sort(key=lambda x: x.vote_count, reverse=True)\n        results = results[offset:offset + limit]\n\n    return ForumSearchResponse(\n        results=results,\n        total_count=total_count,\n        query=q,\n        search_type=type,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/recommended\", response_model=List[RecommendedForumResponse])\nasync def get_recommended_forums(\n    flaws: str = Query(..., description=\"Comma-separated list of flaw IDs\"),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get recommended forums based on detected flaws.\"\"\"\n    flaw_list = [f.strip() for f in flaws.split(\",\") if f.strip()]\n\n    if not flaw_list:\n        return []\n\n    # Find mappings for these flaws\n    query = (\n        select(FlawToForumMapping)\n        .options(selectinload(FlawToForumMapping.issue_category))\n        .where(FlawToForumMapping.flaw_id.in_(flaw_list))\n        .order_by(FlawToForumMapping.priority)\n    )\n\n    result = await db.execute(query)\n    mappings = result.scalars().all()\n\n    # Group by category\n    category_flaws = {}\n    for mapping in mappings:\n        cat_id = mapping.issue_category_id\n        if cat_id not in category_flaws:\n            category_flaws[cat_id] = {\n                \"category\": mapping.issue_category,\n                \"flaws\": [],\n                \"priority\": mapping.priority\n            }\n        category_flaws[cat_id][\"flaws\"].append(mapping.flaw_id)\n        # Use lowest priority (1 = primary)\n        if mapping.priority < category_flaws[cat_id][\"priority\"]:\n            category_flaws[cat_id][\"priority\"] = mapping.priority\n\n    # Build response sorted by priority\n    response = []\n    for cat_data in sorted(category_flaws.values(), key=lambda x: x[\"priority\"]):\n        cat = cat_data[\"category\"]\n        response.append(RecommendedForumResponse(\n            category=CategoryListResponse(\n                id=cat.id,\n                name=cat.name,\n                slug=cat.slug,\n                description=cat.description,\n                icon=cat.icon,\n                display_order=cat.display_order,\n                post_count=0\n            ),\n            matched_flaws=cat_data[\"flaws\"],\n            priority=cat_data[\"priority\"]\n        ))\n\n    return response\n\n\n@router.get(\"/archetype-recommendations\", response_model=List[ArchetypeForumRecommendation])\nasync def get_archetype_forum_recommendations(\n    archetype: str = Query(..., description=\"Archetype category (Softboy, Prettyboy, RobustPrettyboy, Chad, Hypermasculine, Exotic)\"),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get recommended forums based on user's archetype classification.\"\"\"\n    # Normalize archetype name (handle case variations)\n    archetype = archetype.strip()\n\n    # Valid archetypes\n    valid_archetypes = [\"Softboy\", \"Prettyboy\", \"RobustPrettyboy\", \"Chad\", \"Hypermasculine\", \"Exotic\"]\n\n    # Case-insensitive match\n    matched_archetype = None\n    for valid in valid_archetypes:\n        if archetype.lower() == valid.lower():\n            matched_archetype = valid\n            break\n\n    if not matched_archetype:\n        # Return empty list for invalid archetype (not an error)\n        return []\n\n    # Find mappings for this archetype, ordered by priority (highest first)\n    query = (\n        select(ArchetypeForumMapping)\n        .options(selectinload(ArchetypeForumMapping.issue_category))\n        .where(ArchetypeForumMapping.archetype_category == matched_archetype)\n        .order_by(ArchetypeForumMapping.priority.desc())\n    )\n\n    result = await db.execute(query)\n    mappings = result.scalars().all()\n\n    # Build response\n    response = []\n    for mapping in mappings:\n        cat = mapping.issue_category\n        if cat and cat.is_active:\n            response.append(ArchetypeForumRecommendation(\n                category=CategoryListResponse(\n                    id=cat.id,\n                    name=cat.name,\n                    slug=cat.slug,\n                    description=cat.description,\n                    icon=cat.icon,\n                    display_order=cat.display_order,\n                    post_count=0  # Could be optimized with a count query if needed\n                ),\n                archetype=matched_archetype,\n                reason=mapping.reason,\n                priority=mapping.priority\n            ))\n\n    return response\n\n\n@router.get(\"/guides\", response_model=List[GuideSectionResponse])\nasync def get_guides_section(db: AsyncSession = Depends(get_db)):\n    \"\"\"Get pinned guides grouped by category for the top section.\"\"\"\n    # Get categories\n    cat_query = (\n        select(ForumIssueCategory)\n        .where(ForumIssueCategory.is_active == True)\n        .order_by(ForumIssueCategory.display_order)\n    )\n    cat_result = await db.execute(cat_query)\n    categories = cat_result.scalars().all()\n\n    response = []\n    for cat in categories:\n        # Get top 5 guides (pinned or marked as guide) per category\n        guide_query = (\n            select(ForumPost)\n            .options(\n                selectinload(ForumPost.author),\n                selectinload(ForumPost.sub_forum)\n            )\n            .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n            .where(\n                ForumSubForum.issue_category_id == cat.id,\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(ForumPost.is_pinned == True, ForumPost.is_guide == True)\n            )\n            .order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n            .limit(5)\n        )\n        guide_result = await db.execute(guide_query)\n        guides = guide_result.scalars().all()\n\n        if guides:  # Only include categories that have guides\n            response.append(GuideSectionResponse(\n                category=CategoryListResponse(\n                    id=cat.id,\n                    name=cat.name,\n                    slug=cat.slug,\n                    description=cat.description,\n                    icon=cat.icon,\n                    display_order=cat.display_order,\n                    post_count=0\n                ),\n                guides=[_post_to_list_item(g, cat.slug, None) for g in guides]\n            ))\n\n    return response\n\n\n# === POSTS ===\n\n@router.get(\"/sub-forums/{sub_forum_id}/posts\", response_model=PostListResponse)\nasync def list_sub_forum_posts(\n    sub_forum_id: UUID,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List posts in a sub-forum with sorting and pagination.\"\"\"\n    # Verify sub-forum exists and get category\n    sf_result = await db.execute(\n        select(ForumSubForum)\n        .options(selectinload(ForumSubForum.issue_category))\n        .where(ForumSubForum.id == sub_forum_id)\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    category_slug = sub_forum.issue_category.slug\n\n    # Base query\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author))\n        .where(\n            ForumPost.sub_forum_id == sub_forum_id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting - pinned always first\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:  # HOT - combination of votes and recency\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .where(\n            ForumPost.sub_forum_id == sub_forum_id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes if authenticated\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, category_slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/categories/{slug}/posts\", response_model=PostListResponse)\nasync def list_category_posts(\n    slug: str,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List all posts in a category (across all sub-forums) with sorting and pagination.\"\"\"\n    # Verify category exists\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n    )\n    category = cat_result.scalar_one_or_none()\n    if not category:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    # Base query - join with sub-forums to filter by category\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n        .where(\n            ForumSubForum.issue_category_id == category.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n        .where(\n            ForumSubForum.issue_category_id == category.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/categories/{slug}/{sub_forum_slug}/posts\", response_model=PostListResponse)\nasync def list_sub_forum_posts(\n    slug: str,\n    sub_forum_slug: str,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List all posts in a specific sub-forum with sorting and pagination.\"\"\"\n    # Verify category and sub-forum exist\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n    )\n    category = cat_result.scalar_one_or_none()\n    if not category:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    sf_result = await db.execute(\n        select(ForumSubForum).where(\n            ForumSubForum.slug == sub_forum_slug,\n            ForumSubForum.issue_category_id == category.id\n        )\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    # Base query\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .where(\n            ForumPost.sub_forum_id == sub_forum.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .where(\n            ForumPost.sub_forum_id == sub_forum.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.post(\"/posts\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.POSTS)\nasync def create_post(\n    request: Request,\n    data: PostCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a new post.\n\n    Rate limit: 5 posts per minute per user.\n    \"\"\"\n    # Verify sub-forum exists\n    sf_result = await db.execute(\n        select(ForumSubForum)\n        .options(selectinload(ForumSubForum.issue_category))\n        .where(ForumSubForum.id == data.sub_forum_id)\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    post = ForumPost(\n        title=data.title,\n        content=data.content,\n        sub_forum_id=data.sub_forum_id,\n        author_id=current_user.id,\n    )\n\n    db.add(post)\n    await db.commit()\n    await db.refresh(post)\n\n    return _post_to_response(post, sub_forum.slug, sub_forum.issue_category.slug, None)\n\n\n@router.get(\"/posts/{post_id}\", response_model=PostResponse)\nasync def get_post(\n    post_id: UUID,\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get a single post with full details.\"\"\"\n    query = (\n        select(ForumPost)\n        .options(\n            selectinload(ForumPost.author),\n            selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n        )\n        .where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    result = await db.execute(query)\n    post = result.scalar_one_or_none()\n\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Get user's vote\n    user_vote = None\n    if current_user:\n        vote_result = await db.execute(\n            select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id == post_id\n            )\n        )\n        vote = vote_result.scalar_one_or_none()\n        user_vote = vote.vote_type if vote else None\n\n    return _post_to_response(\n        post,\n        post.sub_forum.slug,\n        post.sub_forum.issue_category.slug,\n        user_vote\n    )\n\n\n@router.post(\"/posts/{post_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_post(\n    request: Request,\n    post_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a post (upvote/downvote). Voting again removes vote, changing vote type switches it.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")\n\n    # Check existing vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id == post_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        # Robustly get value (handle if DB returns string or Enum)\n        current_val = existing_vote.vote_type.value if hasattr(existing_vote.vote_type, 'value') else existing_vote.vote_type\n        # Request is from Pydantic Schema Enum\n        request_val = data.vote_type.value\n\n        if current_val == request_val:\n            # Same vote - remove it\n            await db.delete(existing_vote)\n            post.vote_count += -1 if request_val == \"up\" else 1\n        else:\n            # Different vote - switch it\n            # Ensure we assign the Model Enum (or string if that's what it wants, but Model Enum is safer if Typed)\n            existing_vote.vote_type = VoteType(request_val)\n            # Swing by 2 (remove old, add new)\n            post.vote_count += 2 if request_val == \"up\" else -2\n            new_user_vote = data.vote_type\n    else:\n        # New vote\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.POST,\n            target_id=post_id,\n            # Explicitly cast to Model Enum\n            vote_type=VoteType(data.vote_type.value)\n        )\n        db.add(vote)\n        post.vote_count += 1 if data.vote_type.value == \"up\" else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=post.vote_count, user_vote=new_user_vote)\n\n\n@router.delete(\"/posts/{post_id}\")\nasync def delete_post(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Delete a post (author or moderator).\"\"\"\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    is_author = post.author_id == current_user.id\n    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n\n    if not is_author and not is_mod:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    post.is_deleted = True\n    post.deleted_at = datetime.now(timezone.utc)\n    post.deleted_by = current_user.id\n    await db.commit()\n\n    return {\"success\": True}\n\n\n@router.put(\"/posts/{post_id}\", response_model=PostResponse)\nasync def update_post(\n    post_id: UUID,\n    data: PostUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update a post (author only).\"\"\"\n    post_result = await db.execute(\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .where(ForumPost.id == post_id)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    if post.author_id != current_user.id:\n        raise HTTPException(status_code=403, detail=\"Not authorized to edit this post\")\n\n    if data.title is not None:\n        post.title = data.title\n    if data.content is not None:\n        post.content = data.content\n    post.updated_at = datetime.utcnow()\n\n    await db.commit()\n    await db.refresh(post)\n\n    # Get user vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id == post_id\n        )\n    )\n    user_vote = vote_result.scalar_one_or_none()\n\n    # Get category slug\n    sf = post.sub_forum\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.id == sf.issue_category_id)\n    )\n    cat = cat_result.scalar_one()\n\n    return PostResponse(\n        id=post.id,\n        title=post.title,\n        content=post.content,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        created_at=post.created_at,\n        updated_at=post.updated_at,\n        author=PostAuthor(\n            id=post.author.id,\n            username=post.author.username,\n            avatar_url=None\n        ),\n        sub_forum=SubForumResponse(\n            id=sf.id,\n            name=sf.name,\n            slug=sf.slug,\n            description=sf.description,\n            icon=sf.icon,\n            display_order=sf.display_order,\n            post_count=0\n        ),\n        category_slug=cat.slug,\n        user_vote=user_vote.vote_type if user_vote else None\n    )\n\n\n# === COMMENTS ===\n\n@router.get(\"/posts/{post_id}/comments\", response_model=List[CommentResponse])\nasync def get_post_comments(\n    post_id: UUID,\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all comments for a post in a threaded structure.\"\"\"\n    # Verify post exists\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    if not post_result.scalar_one_or_none():\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Get all comments for post\n    query = (\n        select(ForumComment)\n        .options(selectinload(ForumComment.author))\n        .where(ForumComment.post_id == post_id, ForumComment.is_deleted == False)\n        .order_by(ForumComment.created_at)\n    )\n    result = await db.execute(query)\n    comments = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        comment_ids = [c.id for c in comments]\n        if comment_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.COMMENT,\n                ForumVote.target_id.in_(comment_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    # Build tree structure\n    return _build_comment_tree(comments, user_votes)\n\n\n@router.post(\"/posts/{post_id}/comments\", response_model=CommentResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.COMMENTS)\nasync def create_comment(\n    request: Request,\n    post_id: UUID,\n    data: CommentCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a comment on a post.\n\n    Rate limit: 20 comments per minute per user.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    depth = 0\n    if data.parent_id:\n        # Verify parent comment exists\n        parent_result = await db.execute(\n            select(ForumComment).where(\n                ForumComment.id == data.parent_id,\n                ForumComment.post_id == post_id\n            )\n        )\n        parent = parent_result.scalar_one_or_none()\n        if not parent:\n            raise HTTPException(status_code=404, detail=\"Parent comment not found\")\n        depth = min(parent.depth + 1, MAX_COMMENT_DEPTH)\n\n    comment = ForumComment(\n        content=data.content,\n        post_id=post_id,\n        author_id=current_user.id,\n        parent_id=data.parent_id,\n        depth=depth,\n    )\n\n    db.add(comment)\n    await db.commit()\n    await db.refresh(comment)\n\n    # Load author relationship\n    await db.refresh(comment, [\"author\"])\n\n    return _comment_to_response(comment, None)\n\n\n@router.post(\"/comments/{comment_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_comment(\n    request: Request,\n    comment_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a comment.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    comment_result = await db.execute(\n        select(ForumComment).where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n    )\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")\n\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.COMMENT,\n            ForumVote.target_id == comment_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        if existing_vote.vote_type == data.vote_type:\n            await db.delete(existing_vote)\n            comment.vote_count += -1 if data.vote_type == VoteType.UP else 1\n        else:\n            existing_vote.vote_type = data.vote_type\n            comment.vote_count += 2 if data.vote_type == VoteType.UP else -2\n            new_user_vote = data.vote_type\n    else:\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.COMMENT,\n            target_id=comment_id,\n            vote_type=data.vote_type\n        )\n        db.add(vote)\n        comment.vote_count += 1 if data.vote_type == VoteType.UP else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=comment.vote_count, user_vote=new_user_vote)\n\n\n@router.put(\"/comments/{comment_id}\", response_model=CommentResponse)\nasync def update_comment(\n    comment_id: UUID,\n    data: CommentUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update a comment (author only).\"\"\"\n    comment_result = await db.execute(\n        select(ForumComment)\n        .options(selectinload(ForumComment.author))\n        .where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n    )\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    if comment.author_id != current_user.id:\n        raise HTTPException(status_code=403, detail=\"Not authorized to edit this comment\")\n\n    comment.content = data.content\n    comment.updated_at = datetime.utcnow()\n\n    await db.commit()\n    await db.refresh(comment)\n\n    # Get user vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.COMMENT,\n            ForumVote.target_id == comment_id\n        )\n    )\n    user_vote = vote_result.scalar_one_or_none()\n\n    return _comment_to_response(comment, user_vote.vote_type if user_vote else None)\n\n\n@router.delete(\"/comments/{comment_id}\")\nasync def delete_comment(\n    comment_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Delete a comment (author or moderator).\"\"\"\n    comment_result = await db.execute(select(ForumComment).where(ForumComment.id == comment_id))\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    is_author = comment.author_id == current_user.id\n    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n\n    if not is_author and not is_mod:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    comment.is_deleted = True\n    comment.deleted_at = datetime.now(timezone.utc)\n    comment.deleted_by = current_user.id\n\n    # Decrement comment count on the parent post\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == comment.post_id))\n    post = post_result.scalar_one_or_none()\n    if post and post.comment_count > 0:\n        post.comment_count -= 1\n\n    await db.commit()\n\n    return {\"success\": True}\n\n\n# === REPORTS ===\n\n@router.post(\"/reports\", response_model=ReportResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.REPORTS)\nasync def create_report(\n    request: Request,\n    data: ReportCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Report a post or comment.\n\n    Rate limit: 10 reports per hour per user.\n    \"\"\"\n    # Verify target exists\n    if data.target_type == TargetType.POST:\n        target_result = await db.execute(select(ForumPost).where(ForumPost.id == data.target_id))\n    else:\n        target_result = await db.execute(select(ForumComment).where(ForumComment.id == data.target_id))\n\n    if not target_result.scalar_one_or_none():\n        raise HTTPException(status_code=404, detail=\"Target not found\")\n\n    # Check for duplicate report\n    existing = await db.execute(\n        select(ForumReport).where(\n            ForumReport.reporter_id == current_user.id,\n            ForumReport.target_type == data.target_type,\n            ForumReport.target_id == data.target_id,\n            ForumReport.status == ReportStatus.PENDING\n        )\n    )\n    if existing.scalar_one_or_none():\n        raise HTTPException(status_code=400, detail=\"You have already reported this content\")\n\n    report = ForumReport(\n        reporter_id=current_user.id,\n        target_type=data.target_type,\n        target_id=data.target_id,\n        reason=data.reason,\n        details=data.details,\n    )\n\n    db.add(report)\n    await db.commit()\n    await db.refresh(report)\n\n    return ReportResponse(\n        id=report.id,\n        target_type=report.target_type,\n        target_id=report.target_id,\n        reason=report.reason,\n        status=report.status.value,\n        created_at=report.created_at\n    )\n\n\n# === MODERATION (Admin/Moderator only) ===\n\n@router.post(\"/posts/{post_id}/pin\")\nasync def pin_post(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Pin/unpin a post (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    post.is_pinned = not post.is_pinned\n    await db.commit()\n\n    return {\"success\": True, \"is_pinned\": post.is_pinned}\n\n\n@router.post(\"/posts/{post_id}/mark-guide\")\nasync def mark_as_guide(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Mark/unmark a post as a guide (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    post.is_guide = not post.is_guide\n    await db.commit()\n\n    return {\"success\": True, \"is_guide\": post.is_guide}\n\n\n@router.get(\"/reports\", response_model=List[ReportResponse])\nasync def list_reports(\n    status_filter: Optional[ReportStatus] = Query(None, alias=\"status\"),\n    limit: int = Query(50, ge=1, le=100),\n    offset: int = Query(0, ge=0),\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List reports (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    query = select(ForumReport).order_by(ForumReport.created_at.desc())\n\n    if status_filter:\n        query = query.where(ForumReport.status == status_filter)\n\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    reports = result.scalars().all()\n\n    return [\n        ReportResponse(\n            id=r.id,\n            target_type=r.target_type,\n            target_id=r.target_id,\n            reason=r.reason,\n            status=r.status.value,\n            created_at=r.created_at\n        )\n        for r in reports\n    ]\n\n\n@router.patch(\"/reports/{report_id}\")\nasync def update_report_status(\n    report_id: UUID,\n    new_status: ReportStatus,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update report status (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    report_result = await db.execute(select(ForumReport).where(ForumReport.id == report_id))\n    report = report_result.scalar_one_or_none()\n    if not report:\n        raise HTTPException(status_code=404, detail=\"Report not found\")\n\n    report.status = new_status\n    report.reviewed_by = current_user.id\n    report.reviewed_at = datetime.utcnow()\n\n    await db.commit()\n\n    return {\"success\": True, \"status\": new_status.value}\n\n\n# === BOOKMARKS ===\n\n@router.post(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\nasync def toggle_bookmark(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Toggle bookmark status for a post.\n\n    If the post is not bookmarked, it will be bookmarked.\n    If the post is already bookmarked, the bookmark will be removed.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Check if already bookmarked\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    existing_bookmark = existing.scalar_one_or_none()\n\n    if existing_bookmark:\n        # Remove bookmark\n        await db.delete(existing_bookmark)\n        await db.commit()\n        return BookmarkToggleResponse(\n            is_bookmarked=False,\n            message=\"Bookmark removed\"\n        )\n    else:\n        # Add bookmark\n        bookmark = ForumBookmark(\n            user_id=current_user.id,\n            post_id=post_id\n        )\n        db.add(bookmark)\n        await db.commit()\n        return BookmarkToggleResponse(\n            is_bookmarked=True,\n            message=\"Post bookmarked\"\n        )\n\n\n@router.delete(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\nasync def remove_bookmark(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Remove a bookmark from a post.\"\"\"\n    # Check if bookmark exists\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    existing_bookmark = existing.scalar_one_or_none()\n\n    if not existing_bookmark:\n        raise HTTPException(status_code=404, detail=\"Bookmark not found\")\n\n    await db.delete(existing_bookmark)\n    await db.commit()\n\n    return BookmarkToggleResponse(\n        is_bookmarked=False,\n        message=\"Bookmark removed\"\n    )\n\n\n@router.get(\"/bookmarks\", response_model=BookmarkedPostsResponse)\nasync def get_bookmarked_posts(\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all bookmarked posts for the current user, sorted by bookmark date (newest first).\"\"\"\n    # Get total count\n    count_query = (\n        select(func.count(ForumBookmark.id))\n        .where(ForumBookmark.user_id == current_user.id)\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Get bookmarked posts with pagination\n    query = (\n        select(ForumBookmark)\n        .options(\n            selectinload(ForumBookmark.post).selectinload(ForumPost.author),\n            selectinload(ForumBookmark.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n        )\n        .where(ForumBookmark.user_id == current_user.id)\n        .order_by(ForumBookmark.created_at.desc())\n        .offset(offset)\n        .limit(limit)\n    )\n    result = await db.execute(query)\n    bookmarks = result.scalars().all()\n\n    # Filter out any bookmarks for deleted posts\n    valid_bookmarks = [b for b in bookmarks if b.post and not b.post.is_deleted]\n\n    # Get user votes for these posts\n    post_ids = [b.post.id for b in valid_bookmarks]\n    user_votes = {}\n    if post_ids:\n        votes_query = select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id.in_(post_ids)\n        )\n        votes_result = await db.execute(votes_query)\n        user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    # Build response\n    posts = []\n    for bookmark in valid_bookmarks:\n        post = bookmark.post\n        category_slug = post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\"\n        posts.append(_post_to_list_item(post, category_slug, user_votes.get(post.id)))\n\n    return BookmarkedPostsResponse(\n        posts=posts,\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/posts/{post_id}/bookmark-status\")\nasync def get_bookmark_status(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Check if a post is bookmarked by the current user.\"\"\"\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    bookmark = existing.scalar_one_or_none()\n\n    return {\n        \"post_id\": str(post_id),\n        \"is_bookmarked\": bookmark is not None,\n        \"bookmarked_at\": bookmark.created_at.isoformat() if bookmark else None\n    }\n\n\n@router.get(\"/bookmarks/ids\")\nasync def get_bookmarked_post_ids(\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all bookmarked post IDs for the current user.\n\n    Useful for efficiently checking bookmark status on post lists.\n    \"\"\"\n    query = (\n        select(ForumBookmark.post_id)\n        .where(ForumBookmark.user_id == current_user.id)\n    )\n    result = await db.execute(query)\n    post_ids = [str(row[0]) for row in result.all()]\n\n    return {\"bookmarked_post_ids\": post_ids}\n\n\n# === HELPER FUNCTIONS ===\n\ndef _post_to_list_item(post: ForumPost, category_slug: str, user_vote: Optional[VoteType]) -> PostListItem:\n    sub_forum_slug = post.sub_forum.slug if post.sub_forum else \"\"\n    return PostListItem(\n        id=post.id,\n        title=post.title,\n        content_preview=post.content[:200] + \"...\" if len(post.content) > 200 else post.content,\n        sub_forum_slug=sub_forum_slug,\n        category_slug=category_slug,\n        author=PostAuthor(id=post.author.id, username=post.author.username),\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        user_vote=user_vote,\n        created_at=post.created_at,\n    )\n\n\ndef _post_to_response(\n    post: ForumPost,\n    sub_forum_slug: str,\n    category_slug: str,\n    user_vote: Optional[VoteType]\n) -> PostResponse:\n    return PostResponse(\n        id=post.id,\n        title=post.title,\n        content=post.content,\n        sub_forum_id=post.sub_forum_id,\n        sub_forum_slug=sub_forum_slug,\n        category_slug=category_slug,\n        author=PostAuthor(id=post.author.id, username=post.author.username),\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        user_vote=user_vote,\n        created_at=post.created_at,\n        updated_at=post.updated_at,\n    )\n\n\ndef _comment_to_response(comment: ForumComment, user_vote: Optional[VoteType]) -> CommentResponse:\n    return CommentResponse(\n        id=comment.id,\n        content=comment.content,\n        post_id=comment.post_id,\n        author=PostAuthor(id=comment.author.id, username=comment.author.username),\n        parent_id=comment.parent_id,\n        vote_count=comment.vote_count,\n        user_vote=user_vote,\n        depth=comment.depth,\n        replies=[],\n        created_at=comment.created_at,\n        updated_at=comment.updated_at,\n    )\n\n\ndef _build_comment_tree(comments: List[ForumComment], user_votes: dict) -> List[CommentResponse]:\n    \"\"\"Build a tree structure from flat comment list.\"\"\"\n    comment_map = {}\n    roots = []\n\n    # First pass: create all response objects\n    for c in comments:\n        comment_map[c.id] = _comment_to_response(c, user_votes.get(c.id))\n\n    # Second pass: build tree\n    for c in comments:\n        response = comment_map[c.id]\n        if c.parent_id and c.parent_id in comment_map:\n            comment_map[c.parent_id].replies.append(response)\n        else:\n            roots.append(response)\n\n    return roots\n","numLines":1640,"startLine":1,"totalLines":1640}}}
{"parentUuid":"804205b5-cd13-4545-b7b0-1d63601dc83c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_014ntmwDUdYDBbT9GCdeZaHw","type":"message","role":"assistant","content":[{"type":"text","text":"I can see the file. Looking at the vote endpoints:\n\n1. **Post voting** - `vote_on_post` at line 825-893 - I can see it already has self-voting prevention at lines 846-848\n2. **Comment voting** - `vote_on_comment` at line 1091-1146 - I can see it already has self-voting prevention at lines 1111-1113\n\nLet me verify the exact implementation by checking those sections more closely:\n\nFor **post voting** (lines 846-848):\n```python\n# Prevent self-voting\nif post.author_id == current_user.id:\n    raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")\n```\n\nFor **comment voting** (lines 1111-1113):\n```python\n# Prevent self-voting\nif comment.author_id == current_user.id:\n    raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")\n```\n\nThe self-voting prevention is already implemented in both endpoints. However, I notice the error messages are slightly different from the requested \"Cannot vote on your own content\". The current messages are:\n- \"You cannot vote on your own post\" \n- \"You cannot vote on your own comment\"\n\nLet me update both to use the consistent message \"Cannot vote on your own content\" as specified in the requirements:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":22923,"cache_read_input_tokens":37090,"cache_creation":{"ephemeral_5m_input_tokens":22923,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYKMknh4yo7ivmdWJSe","type":"assistant","uuid":"07ce59ce-4afd-4a09-8142-1df6da725ba4","timestamp":"2025-12-27T16:54:01.143Z"}
{"parentUuid":"07ce59ce-4afd-4a09-8142-1df6da725ba4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_014ntmwDUdYDBbT9GCdeZaHw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NixG4q2zJ8NPqaxpuauqAy","name":"Edit","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","old_string":"    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")","new_string":"    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":22923,"cache_read_input_tokens":37090,"cache_creation":{"ephemeral_5m_input_tokens":22923,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYKMknh4yo7ivmdWJSe","type":"assistant","uuid":"6b86eee9-5564-48e6-a83d-c3c74f09d681","timestamp":"2025-12-27T16:54:03.569Z"}
{"parentUuid":"6b86eee9-5564-48e6-a83d-c3c74f09d681","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_014ntmwDUdYDBbT9GCdeZaHw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01W7ipQe7AXtAkkuVuPbhQ96","name":"Edit","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","old_string":"    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")","new_string":"    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":22923,"cache_read_input_tokens":37090,"cache_creation":{"ephemeral_5m_input_tokens":22923,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYKMknh4yo7ivmdWJSe","type":"assistant","uuid":"fa1610d1-facb-41d9-9c15-dd34a50a5e4f","timestamp":"2025-12-27T16:54:04.918Z"}
{"parentUuid":"fa1610d1-facb-41d9-9c15-dd34a50a5e4f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01NixG4q2zJ8NPqaxpuauqAy"}]},"uuid":"0f82b006-3414-461f-a1c0-f7d418d5b9d6","timestamp":"2025-12-27T16:54:04.989Z","toolUseResult":"Error: File has been modified since read, either by the user or by a linter. Read it again before attempting to write it."}
{"parentUuid":"0f82b006-3414-461f-a1c0-f7d418d5b9d6","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has been modified since read, either by the user or by a linter. Read it again before attempting to write it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01W7ipQe7AXtAkkuVuPbhQ96"}]},"uuid":"3873bb61-6aae-4f12-98ab-bcc894693943","timestamp":"2025-12-27T16:54:05.001Z","toolUseResult":"Error: File has been modified since read, either by the user or by a linter. Read it again before attempting to write it."}
{"parentUuid":"3873bb61-6aae-4f12-98ab-bcc894693943","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_0155caUiy7Vf82anSAdcDP3j","type":"message","role":"assistant","content":[{"type":"text","text":"The file was modified. Let me re-read it and apply the edits:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":841,"cache_read_input_tokens":60013,"cache_creation":{"ephemeral_5m_input_tokens":841,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYLiwmtUpYhn71Ao3zJ","type":"assistant","uuid":"f7b21000-06cc-4a6f-868b-6e9e26da3abd","timestamp":"2025-12-27T16:54:10.325Z"}
{"parentUuid":"f7b21000-06cc-4a6f-868b-6e9e26da3abd","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_0155caUiy7Vf82anSAdcDP3j","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JjZfsoGGuCjDqipWkzXyJR","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","offset":825,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":841,"cache_read_input_tokens":60013,"cache_creation":{"ephemeral_5m_input_tokens":841,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYLiwmtUpYhn71Ao3zJ","type":"assistant","uuid":"a1e7089c-44a7-4354-b3d1-831e95506261","timestamp":"2025-12-27T16:54:11.155Z"}
{"parentUuid":"a1e7089c-44a7-4354-b3d1-831e95506261","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_0155caUiy7Vf82anSAdcDP3j","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WscoYJFJeuvkT1vAZLfDKk","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","offset":1091,"limit":60}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":841,"cache_read_input_tokens":60013,"cache_creation":{"ephemeral_5m_input_tokens":841,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYLiwmtUpYhn71Ao3zJ","type":"assistant","uuid":"f3d65c1c-469e-407c-b356-da42f3d8e40f","timestamp":"2025-12-27T16:54:11.707Z"}
{"parentUuid":"f3d65c1c-469e-407c-b356-da42f3d8e40f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JjZfsoGGuCjDqipWkzXyJR","type":"tool_result","content":"   825→\n   826→@router.post(\"/posts/{post_id}/vote\", response_model=VoteResponse)\n   827→@limiter.limit(ForumRateLimits.VOTES)\n   828→async def vote_on_post(\n   829→    request: Request,\n   830→    post_id: UUID,\n   831→    data: VoteRequest,\n   832→    current_user: User = Depends(get_current_user),\n   833→    db: AsyncSession = Depends(get_db),\n   834→):\n   835→    \"\"\"Vote on a post (upvote/downvote). Voting again removes vote, changing vote type switches it.\n   836→\n   837→    Rate limit: 30 votes per minute per user.\n   838→    \"\"\"\n   839→    # Verify post exists\n   840→    post_result = await db.execute(\n   841→        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n   842→    )\n   843→    post = post_result.scalar_one_or_none()\n   844→    if not post:\n   845→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   846→\n   847→    # Prevent self-voting\n   848→    if post.author_id == current_user.id:\n   849→        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")\n   850→\n   851→    # Check existing vote\n   852→    vote_result = await db.execute(\n   853→        select(ForumVote).where(\n   854→            ForumVote.user_id == current_user.id,\n   855→            ForumVote.target_type == TargetType.POST,\n   856→            ForumVote.target_id == post_id\n   857→        )\n   858→    )\n   859→    existing_vote = vote_result.scalar_one_or_none()\n   860→\n   861→    new_user_vote = None\n   862→    if existing_vote:\n   863→        # Robustly get value (handle if DB returns string or Enum)\n   864→        current_val = existing_vote.vote_type.value if hasattr(existing_vote.vote_type, 'value') else existing_vote.vote_type\n   865→        # Request is from Pydantic Schema Enum\n   866→        request_val = data.vote_type.value\n   867→\n   868→        if current_val == request_val:\n   869→            # Same vote - remove it\n   870→            await db.delete(existing_vote)\n   871→            post.vote_count += -1 if request_val == \"up\" else 1\n   872→        else:\n   873→            # Different vote - switch it\n   874→            # Ensure we assign the Model Enum (or string if that's what it wants, but Model Enum is safer if Typed)\n   875→            existing_vote.vote_type = VoteType(request_val)\n   876→            # Swing by 2 (remove old, add new)\n   877→            post.vote_count += 2 if request_val == \"up\" else -2\n   878→            new_user_vote = data.vote_type\n   879→    else:\n   880→        # New vote\n   881→        vote = ForumVote(\n   882→            user_id=current_user.id,\n   883→            target_type=TargetType.POST,\n   884→            target_id=post_id,\n   885→            # Explicitly cast to Model Enum\n   886→            vote_type=VoteType(data.vote_type.value)\n   887→        )\n   888→        db.add(vote)\n   889→        post.vote_count += 1 if data.vote_type.value == \"up\" else -1\n   890→        new_user_vote = data.vote_type\n   891→\n   892→    await db.commit()\n   893→\n   894→    return VoteResponse(success=True, new_vote_count=post.vote_count, user_vote=new_user_vote)\n   895→\n   896→\n   897→@router.delete(\"/posts/{post_id}\")\n   898→async def delete_post(\n   899→    post_id: UUID,\n   900→    current_user: User = Depends(get_current_user),\n   901→    db: AsyncSession = Depends(get_db),\n   902→):\n   903→    \"\"\"Delete a post (author or moderator).\"\"\"\n   904→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n   905→    post = post_result.scalar_one_or_none()\n   906→    if not post:\n   907→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   908→\n   909→    is_author = post.author_id == current_user.id\n   910→    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n   911→\n   912→    if not is_author and not is_mod:\n   913→        raise HTTPException(status_code=403, detail=\"Not authorized\")\n   914→\n   915→    post.is_deleted = True\n   916→    post.deleted_at = datetime.now(timezone.utc)\n   917→    post.deleted_by = current_user.id\n   918→    await db.commit()\n   919→\n   920→    return {\"success\": True}\n   921→\n   922→\n   923→@router.put(\"/posts/{post_id}\", response_model=PostResponse)\n   924→async def update_post(\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4a83273e-3376-43ff-a7f9-b592426b51ad","timestamp":"2025-12-27T16:54:11.822Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","content":"\n@router.post(\"/posts/{post_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_post(\n    request: Request,\n    post_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a post (upvote/downvote). Voting again removes vote, changing vote type switches it.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")\n\n    # Check existing vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id == post_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        # Robustly get value (handle if DB returns string or Enum)\n        current_val = existing_vote.vote_type.value if hasattr(existing_vote.vote_type, 'value') else existing_vote.vote_type\n        # Request is from Pydantic Schema Enum\n        request_val = data.vote_type.value\n\n        if current_val == request_val:\n            # Same vote - remove it\n            await db.delete(existing_vote)\n            post.vote_count += -1 if request_val == \"up\" else 1\n        else:\n            # Different vote - switch it\n            # Ensure we assign the Model Enum (or string if that's what it wants, but Model Enum is safer if Typed)\n            existing_vote.vote_type = VoteType(request_val)\n            # Swing by 2 (remove old, add new)\n            post.vote_count += 2 if request_val == \"up\" else -2\n            new_user_vote = data.vote_type\n    else:\n        # New vote\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.POST,\n            target_id=post_id,\n            # Explicitly cast to Model Enum\n            vote_type=VoteType(data.vote_type.value)\n        )\n        db.add(vote)\n        post.vote_count += 1 if data.vote_type.value == \"up\" else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=post.vote_count, user_vote=new_user_vote)\n\n\n@router.delete(\"/posts/{post_id}\")\nasync def delete_post(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Delete a post (author or moderator).\"\"\"\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    is_author = post.author_id == current_user.id\n    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n\n    if not is_author and not is_mod:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    post.is_deleted = True\n    post.deleted_at = datetime.now(timezone.utc)\n    post.deleted_by = current_user.id\n    await db.commit()\n\n    return {\"success\": True}\n\n\n@router.put(\"/posts/{post_id}\", response_model=PostResponse)\nasync def update_post(","numLines":100,"startLine":825,"totalLines":1641}}}
{"parentUuid":"4a83273e-3376-43ff-a7f9-b592426b51ad","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WscoYJFJeuvkT1vAZLfDKk","type":"tool_result","content":"  1091→\n  1092→@router.post(\"/comments/{comment_id}/vote\", response_model=VoteResponse)\n  1093→@limiter.limit(ForumRateLimits.VOTES)\n  1094→async def vote_on_comment(\n  1095→    request: Request,\n  1096→    comment_id: UUID,\n  1097→    data: VoteRequest,\n  1098→    current_user: User = Depends(get_current_user),\n  1099→    db: AsyncSession = Depends(get_db),\n  1100→):\n  1101→    \"\"\"Vote on a comment.\n  1102→\n  1103→    Rate limit: 30 votes per minute per user.\n  1104→    \"\"\"\n  1105→    comment_result = await db.execute(\n  1106→        select(ForumComment).where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n  1107→    )\n  1108→    comment = comment_result.scalar_one_or_none()\n  1109→    if not comment:\n  1110→        raise HTTPException(status_code=404, detail=\"Comment not found\")\n  1111→\n  1112→    # Prevent self-voting\n  1113→    if comment.author_id == current_user.id:\n  1114→        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")\n  1115→\n  1116→    vote_result = await db.execute(\n  1117→        select(ForumVote).where(\n  1118→            ForumVote.user_id == current_user.id,\n  1119→            ForumVote.target_type == TargetType.COMMENT,\n  1120→            ForumVote.target_id == comment_id\n  1121→        )\n  1122→    )\n  1123→    existing_vote = vote_result.scalar_one_or_none()\n  1124→\n  1125→    new_user_vote = None\n  1126→    if existing_vote:\n  1127→        if existing_vote.vote_type == data.vote_type:\n  1128→            await db.delete(existing_vote)\n  1129→            comment.vote_count += -1 if data.vote_type == VoteType.UP else 1\n  1130→        else:\n  1131→            existing_vote.vote_type = data.vote_type\n  1132→            comment.vote_count += 2 if data.vote_type == VoteType.UP else -2\n  1133→            new_user_vote = data.vote_type\n  1134→    else:\n  1135→        vote = ForumVote(\n  1136→            user_id=current_user.id,\n  1137→            target_type=TargetType.COMMENT,\n  1138→            target_id=comment_id,\n  1139→            vote_type=data.vote_type\n  1140→        )\n  1141→        db.add(vote)\n  1142→        comment.vote_count += 1 if data.vote_type == VoteType.UP else -1\n  1143→        new_user_vote = data.vote_type\n  1144→\n  1145→    await db.commit()\n  1146→\n  1147→    return VoteResponse(success=True, new_vote_count=comment.vote_count, user_vote=new_user_vote)\n  1148→\n  1149→\n  1150→@router.put(\"/comments/{comment_id}\", response_model=CommentResponse)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"79a176e0-36bd-498f-b9d6-45fa0a6dd1c9","timestamp":"2025-12-27T16:54:11.822Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","content":"\n@router.post(\"/comments/{comment_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_comment(\n    request: Request,\n    comment_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a comment.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    comment_result = await db.execute(\n        select(ForumComment).where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n    )\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")\n\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.COMMENT,\n            ForumVote.target_id == comment_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        if existing_vote.vote_type == data.vote_type:\n            await db.delete(existing_vote)\n            comment.vote_count += -1 if data.vote_type == VoteType.UP else 1\n        else:\n            existing_vote.vote_type = data.vote_type\n            comment.vote_count += 2 if data.vote_type == VoteType.UP else -2\n            new_user_vote = data.vote_type\n    else:\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.COMMENT,\n            target_id=comment_id,\n            vote_type=data.vote_type\n        )\n        db.add(vote)\n        comment.vote_count += 1 if data.vote_type == VoteType.UP else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=comment.vote_count, user_vote=new_user_vote)\n\n\n@router.put(\"/comments/{comment_id}\", response_model=CommentResponse)","numLines":60,"startLine":1091,"totalLines":1641}}}
{"parentUuid":"79a176e0-36bd-498f-b9d6-45fa0a6dd1c9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_014nhwLT2YBZuopy3b5w9n58","type":"message","role":"assistant","content":[{"type":"text","text":"I can see the self-voting prevention is already implemented. The current error messages are:\n- Line 849: `\"You cannot vote on your own post\"`\n- Line 1114: `\"You cannot vote on your own comment\"`\n\nThe task requirements specify the message should be `\"Cannot vote on your own content\"` for consistency. Let me update both to match the exact specification:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2881,"cache_read_input_tokens":60854,"cache_creation":{"ephemeral_5m_input_tokens":2881,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYME9h42tBA4QUMvk4V","type":"assistant","uuid":"2c63fb32-fa16-401a-8fc3-736408f65225","timestamp":"2025-12-27T16:54:18.256Z"}
{"parentUuid":"2c63fb32-fa16-401a-8fc3-736408f65225","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_014nhwLT2YBZuopy3b5w9n58","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015S36LFGjQ49WowzrBGHduh","name":"Edit","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","old_string":"    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")","new_string":"    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2881,"cache_read_input_tokens":60854,"cache_creation":{"ephemeral_5m_input_tokens":2881,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYME9h42tBA4QUMvk4V","type":"assistant","uuid":"edb54467-0b0d-4589-98e1-361208f14db4","timestamp":"2025-12-27T16:54:19.491Z"}
{"parentUuid":"edb54467-0b0d-4589-98e1-361208f14db4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_014nhwLT2YBZuopy3b5w9n58","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YBxbWZJoDNGBP841gYZkpw","name":"Edit","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","old_string":"    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")","new_string":"    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2881,"cache_read_input_tokens":60854,"cache_creation":{"ephemeral_5m_input_tokens":2881,"ephemeral_1h_input_tokens":0},"output_tokens":473,"service_tier":"standard"}},"requestId":"req_011CWXYME9h42tBA4QUMvk4V","type":"assistant","uuid":"9fcf4a28-5465-4709-a857-e1dfb322a4eb","timestamp":"2025-12-27T16:54:20.680Z"}
{"parentUuid":"9fcf4a28-5465-4709-a857-e1dfb322a4eb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015S36LFGjQ49WowzrBGHduh","type":"tool_result","content":"The file /Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   843→    post = post_result.scalar_one_or_none()\n   844→    if not post:\n   845→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   846→\n   847→    # Prevent self-voting\n   848→    if post.author_id == current_user.id:\n   849→        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")\n   850→\n   851→    # Check existing vote\n   852→    vote_result = await db.execute(\n   853→        select(ForumVote).where("}]},"uuid":"12e2590b-9db7-42ae-8417-ac7d01c3dff4","timestamp":"2025-12-27T16:54:20.735Z","toolUseResult":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","oldString":"    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")","newString":"    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")","originalFile":"\"\"\"\nForum router - Categories, Sub-Forums, Posts, Comments, Votes, Reports\n\nRate Limits:\n- Posts: 5 per minute per user\n- Comments: 20 per minute per user\n- Votes: 30 per minute per user\n- Reports: 10 per hour per user\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func, and_, or_, desc\nfrom sqlalchemy.orm import selectinload\nfrom uuid import UUID\nfrom typing import Optional, List\nfrom datetime import datetime, timezone\nimport bleach\n\nfrom app.database import get_db\nfrom app.core.rate_limit import limiter, ForumRateLimits\nfrom app.models.user import User, UserRole\nfrom app.models.forum import (\n    ForumIssueCategory, ForumSubForum, ForumPost, ForumComment,\n    ForumVote, ForumReport, FlawToForumMapping, ArchetypeForumMapping,\n    ForumBookmark, VoteType, TargetType, ReportStatus, ReportReason\n)\nfrom app.services.auth import get_current_user, get_current_user_optional\nfrom app.schemas.forum import (\n    CategoryResponse, CategoryListResponse, SubForumResponse,\n    PostCreate, PostUpdate, PostResponse, PostListItem,\n    PostListResponse, CommentCreate, CommentUpdate, CommentResponse,\n    VoteRequest, VoteResponse, ReportCreate, ReportResponse,\n    GuideSectionResponse, SortOrder, PostAuthor, RecommendedForumResponse,\n    ArchetypeForumRecommendation, ForumSearchResult, ForumSearchResponse,\n    SearchResultType, BookmarkToggleResponse, BookmarkedPostsResponse\n)\n\nrouter = APIRouter(prefix=\"/forum\", tags=[\"forum\"])\n\nPAGE_SIZE = 20\nMAX_COMMENT_DEPTH = 5\n\n\n# === CATEGORIES ===\n\n@router.get(\"/categories\", response_model=List[CategoryResponse])\nasync def list_categories(db: AsyncSession = Depends(get_db)):\n    \"\"\"List all active forum categories with sub-forums and post counts.\n\n    Optimized to use only 2 queries instead of N+1 pattern.\n    \"\"\"\n    # Query 1: Get all categories with sub-forums\n    query = (\n        select(ForumIssueCategory)\n        .options(selectinload(ForumIssueCategory.sub_forums))\n        .where(ForumIssueCategory.is_active == True)\n        .order_by(ForumIssueCategory.display_order)\n    )\n    result = await db.execute(query)\n    categories = result.scalars().all()\n\n    # Query 2: Get ALL sub-forum post counts in ONE query (batched)\n    sf_counts_query = (\n        select(\n            ForumPost.sub_forum_id,\n            func.count(ForumPost.id).label('post_count')\n        )\n        .where(\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n        .group_by(ForumPost.sub_forum_id)\n    )\n    sf_counts_result = await db.execute(sf_counts_query)\n    sf_counts = {row[0]: row[1] for row in sf_counts_result}\n\n    # Build response using pre-fetched counts (no additional queries)\n    response = []\n    for cat in categories:\n        cat_post_count = 0\n        sub_forums = []\n\n        for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n            if sf.is_active:\n                sf_post_count = sf_counts.get(sf.id, 0)\n                cat_post_count += sf_post_count\n\n                sub_forums.append(SubForumResponse(\n                    id=sf.id,\n                    name=sf.name,\n                    slug=sf.slug,\n                    description=sf.description,\n                    icon=sf.icon,\n                    display_order=sf.display_order,\n                    post_count=sf_post_count\n                ))\n\n        response.append(CategoryResponse(\n            id=cat.id,\n            name=cat.name,\n            slug=cat.slug,\n            description=cat.description,\n            icon=cat.icon,\n            display_order=cat.display_order,\n            post_count=cat_post_count,\n            sub_forums=sub_forums\n        ))\n\n    return response\n\n\n@router.get(\"/categories/{slug}\", response_model=CategoryResponse)\nasync def get_category(\n    slug: str,\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get a single category by slug with its sub-forums.\n\n    Optimized to use only 2 queries instead of N+1 pattern.\n    \"\"\"\n    # Query 1: Get category with sub-forums\n    query = (\n        select(ForumIssueCategory)\n        .options(selectinload(ForumIssueCategory.sub_forums))\n        .where(ForumIssueCategory.slug == slug, ForumIssueCategory.is_active == True)\n    )\n    result = await db.execute(query)\n    cat = result.scalar_one_or_none()\n\n    if not cat:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    # Get sub-forum IDs for this category\n    sf_ids = [sf.id for sf in cat.sub_forums if sf.is_active]\n\n    # Query 2: Get post counts for all sub-forums in this category (batched)\n    sf_counts = {}\n    if sf_ids:\n        sf_counts_query = (\n            select(\n                ForumPost.sub_forum_id,\n                func.count(ForumPost.id).label('post_count')\n            )\n            .where(\n                ForumPost.sub_forum_id.in_(sf_ids),\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True\n            )\n            .group_by(ForumPost.sub_forum_id)\n        )\n        sf_counts_result = await db.execute(sf_counts_query)\n        sf_counts = {row[0]: row[1] for row in sf_counts_result}\n\n    # Build sub-forums list using pre-fetched counts\n    cat_post_count = 0\n    sub_forums = []\n    for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n        if sf.is_active:\n            sf_post_count = sf_counts.get(sf.id, 0)\n            cat_post_count += sf_post_count\n\n            sub_forums.append(SubForumResponse(\n                id=sf.id,\n                name=sf.name,\n                slug=sf.slug,\n                description=sf.description,\n                icon=sf.icon,\n                display_order=sf.display_order,\n                post_count=sf_post_count\n            ))\n\n    return CategoryResponse(\n        id=cat.id,\n        name=cat.name,\n        slug=cat.slug,\n        description=cat.description,\n        icon=cat.icon,\n        display_order=cat.display_order,\n        post_count=cat_post_count,\n        sub_forums=sub_forums\n    )\n\n\n# === SEARCH ===\n\n@router.get(\"/search\", response_model=ForumSearchResponse)\nasync def search_forum(\n    q: str = Query(..., min_length=2, max_length=100, description=\"Search query\"),\n    type: str = Query(\"all\", description=\"Search type: posts, comments, or all\"),\n    limit: int = Query(20, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Search forum posts and comments using ILIKE pattern matching.\n\n    - Search by title, content for posts\n    - Search by content for comments\n    - Results sorted by vote_count DESC, created_at DESC\n    \"\"\"\n    search_pattern = f\"%{q}%\"\n    results = []\n    total_count = 0\n\n    if type in (\"posts\", \"all\"):\n        # Search posts by title and content\n        post_query = (\n            select(ForumPost)\n            .options(\n                selectinload(ForumPost.author),\n                selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n            )\n            .where(\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(\n                    ForumPost.title.ilike(search_pattern),\n                    ForumPost.content.ilike(search_pattern)\n                )\n            )\n            .order_by(ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n        )\n\n        # Count posts\n        post_count_query = (\n            select(func.count(ForumPost.id))\n            .where(\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(\n                    ForumPost.title.ilike(search_pattern),\n                    ForumPost.content.ilike(search_pattern)\n                )\n            )\n        )\n        post_count_result = await db.execute(post_count_query)\n        post_count = post_count_result.scalar() or 0\n\n        if type == \"posts\":\n            total_count = post_count\n            post_query = post_query.offset(offset).limit(limit)\n        else:\n            total_count += post_count\n            # For \"all\", we get all posts first then merge with comments\n            post_query = post_query.limit(limit * 2)  # Get more to merge\n\n        post_result = await db.execute(post_query)\n        posts = post_result.scalars().all()\n\n        for post in posts:\n            content_preview = post.content[:200] + \"...\" if len(post.content) > 200 else post.content\n            results.append(ForumSearchResult(\n                id=post.id,\n                type=SearchResultType.POST,\n                title=post.title,\n                content_preview=content_preview,\n                post_id=None,\n                post_title=None,\n                author=PostAuthor(id=post.author.id, username=post.author.username),\n                vote_count=post.vote_count,\n                category_slug=post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\",\n                sub_forum_slug=post.sub_forum.slug if post.sub_forum else \"\",\n                created_at=post.created_at\n            ))\n\n    if type in (\"comments\", \"all\"):\n        # Search comments by content\n        comment_query = (\n            select(ForumComment)\n            .options(\n                selectinload(ForumComment.author),\n                selectinload(ForumComment.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n            )\n            .where(\n                ForumComment.is_deleted == False,\n                ForumComment.content.ilike(search_pattern)\n            )\n            .order_by(ForumComment.vote_count.desc(), ForumComment.created_at.desc())\n        )\n\n        # Count comments\n        comment_count_query = (\n            select(func.count(ForumComment.id))\n            .where(\n                ForumComment.is_deleted == False,\n                ForumComment.content.ilike(search_pattern)\n            )\n        )\n        comment_count_result = await db.execute(comment_count_query)\n        comment_count = comment_count_result.scalar() or 0\n\n        if type == \"comments\":\n            total_count = comment_count\n            comment_query = comment_query.offset(offset).limit(limit)\n        else:\n            total_count += comment_count\n            comment_query = comment_query.limit(limit * 2)\n\n        comment_result = await db.execute(comment_query)\n        comments = comment_result.scalars().all()\n\n        for comment in comments:\n            content_preview = comment.content[:200] + \"...\" if len(comment.content) > 200 else comment.content\n            post = comment.post\n            if post and post.sub_forum:\n                category_slug = post.sub_forum.issue_category.slug if post.sub_forum.issue_category else \"\"\n                sub_forum_slug = post.sub_forum.slug\n            else:\n                category_slug = \"\"\n                sub_forum_slug = \"\"\n\n            results.append(ForumSearchResult(\n                id=comment.id,\n                type=SearchResultType.COMMENT,\n                title=None,\n                content_preview=content_preview,\n                post_id=comment.post_id,\n                post_title=post.title if post else None,\n                author=PostAuthor(id=comment.author.id, username=comment.author.username),\n                vote_count=comment.vote_count,\n                category_slug=category_slug,\n                sub_forum_slug=sub_forum_slug,\n                created_at=comment.created_at\n            ))\n\n    # For \"all\" type, sort merged results by vote_count and created_at, then paginate\n    if type == \"all\":\n        results.sort(key=lambda x: (-x.vote_count, x.created_at), reverse=False)\n        results.sort(key=lambda x: x.vote_count, reverse=True)\n        results = results[offset:offset + limit]\n\n    return ForumSearchResponse(\n        results=results,\n        total_count=total_count,\n        query=q,\n        search_type=type,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/recommended\", response_model=List[RecommendedForumResponse])\nasync def get_recommended_forums(\n    flaws: str = Query(..., description=\"Comma-separated list of flaw IDs\"),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get recommended forums based on detected flaws.\"\"\"\n    flaw_list = [f.strip() for f in flaws.split(\",\") if f.strip()]\n\n    if not flaw_list:\n        return []\n\n    # Find mappings for these flaws\n    query = (\n        select(FlawToForumMapping)\n        .options(selectinload(FlawToForumMapping.issue_category))\n        .where(FlawToForumMapping.flaw_id.in_(flaw_list))\n        .order_by(FlawToForumMapping.priority)\n    )\n\n    result = await db.execute(query)\n    mappings = result.scalars().all()\n\n    # Group by category\n    category_flaws = {}\n    for mapping in mappings:\n        cat_id = mapping.issue_category_id\n        if cat_id not in category_flaws:\n            category_flaws[cat_id] = {\n                \"category\": mapping.issue_category,\n                \"flaws\": [],\n                \"priority\": mapping.priority\n            }\n        category_flaws[cat_id][\"flaws\"].append(mapping.flaw_id)\n        # Use lowest priority (1 = primary)\n        if mapping.priority < category_flaws[cat_id][\"priority\"]:\n            category_flaws[cat_id][\"priority\"] = mapping.priority\n\n    # Build response sorted by priority\n    response = []\n    for cat_data in sorted(category_flaws.values(), key=lambda x: x[\"priority\"]):\n        cat = cat_data[\"category\"]\n        response.append(RecommendedForumResponse(\n            category=CategoryListResponse(\n                id=cat.id,\n                name=cat.name,\n                slug=cat.slug,\n                description=cat.description,\n                icon=cat.icon,\n                display_order=cat.display_order,\n                post_count=0\n            ),\n            matched_flaws=cat_data[\"flaws\"],\n            priority=cat_data[\"priority\"]\n        ))\n\n    return response\n\n\n@router.get(\"/archetype-recommendations\", response_model=List[ArchetypeForumRecommendation])\nasync def get_archetype_forum_recommendations(\n    archetype: str = Query(..., description=\"Archetype category (Softboy, Prettyboy, RobustPrettyboy, Chad, Hypermasculine, Exotic)\"),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get recommended forums based on user's archetype classification.\"\"\"\n    # Normalize archetype name (handle case variations)\n    archetype = archetype.strip()\n\n    # Valid archetypes\n    valid_archetypes = [\"Softboy\", \"Prettyboy\", \"RobustPrettyboy\", \"Chad\", \"Hypermasculine\", \"Exotic\"]\n\n    # Case-insensitive match\n    matched_archetype = None\n    for valid in valid_archetypes:\n        if archetype.lower() == valid.lower():\n            matched_archetype = valid\n            break\n\n    if not matched_archetype:\n        # Return empty list for invalid archetype (not an error)\n        return []\n\n    # Find mappings for this archetype, ordered by priority (highest first)\n    query = (\n        select(ArchetypeForumMapping)\n        .options(selectinload(ArchetypeForumMapping.issue_category))\n        .where(ArchetypeForumMapping.archetype_category == matched_archetype)\n        .order_by(ArchetypeForumMapping.priority.desc())\n    )\n\n    result = await db.execute(query)\n    mappings = result.scalars().all()\n\n    # Build response\n    response = []\n    for mapping in mappings:\n        cat = mapping.issue_category\n        if cat and cat.is_active:\n            response.append(ArchetypeForumRecommendation(\n                category=CategoryListResponse(\n                    id=cat.id,\n                    name=cat.name,\n                    slug=cat.slug,\n                    description=cat.description,\n                    icon=cat.icon,\n                    display_order=cat.display_order,\n                    post_count=0  # Could be optimized with a count query if needed\n                ),\n                archetype=matched_archetype,\n                reason=mapping.reason,\n                priority=mapping.priority\n            ))\n\n    return response\n\n\n@router.get(\"/guides\", response_model=List[GuideSectionResponse])\nasync def get_guides_section(db: AsyncSession = Depends(get_db)):\n    \"\"\"Get pinned guides grouped by category for the top section.\"\"\"\n    # Get categories\n    cat_query = (\n        select(ForumIssueCategory)\n        .where(ForumIssueCategory.is_active == True)\n        .order_by(ForumIssueCategory.display_order)\n    )\n    cat_result = await db.execute(cat_query)\n    categories = cat_result.scalars().all()\n\n    response = []\n    for cat in categories:\n        # Get top 5 guides (pinned or marked as guide) per category\n        guide_query = (\n            select(ForumPost)\n            .options(\n                selectinload(ForumPost.author),\n                selectinload(ForumPost.sub_forum)\n            )\n            .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n            .where(\n                ForumSubForum.issue_category_id == cat.id,\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(ForumPost.is_pinned == True, ForumPost.is_guide == True)\n            )\n            .order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n            .limit(5)\n        )\n        guide_result = await db.execute(guide_query)\n        guides = guide_result.scalars().all()\n\n        if guides:  # Only include categories that have guides\n            response.append(GuideSectionResponse(\n                category=CategoryListResponse(\n                    id=cat.id,\n                    name=cat.name,\n                    slug=cat.slug,\n                    description=cat.description,\n                    icon=cat.icon,\n                    display_order=cat.display_order,\n                    post_count=0\n                ),\n                guides=[_post_to_list_item(g, cat.slug, None) for g in guides]\n            ))\n\n    return response\n\n\n# === POSTS ===\n\n@router.get(\"/sub-forums/{sub_forum_id}/posts\", response_model=PostListResponse)\nasync def list_sub_forum_posts(\n    sub_forum_id: UUID,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List posts in a sub-forum with sorting and pagination.\"\"\"\n    # Verify sub-forum exists and get category\n    sf_result = await db.execute(\n        select(ForumSubForum)\n        .options(selectinload(ForumSubForum.issue_category))\n        .where(ForumSubForum.id == sub_forum_id)\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    category_slug = sub_forum.issue_category.slug\n\n    # Base query\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author))\n        .where(\n            ForumPost.sub_forum_id == sub_forum_id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting - pinned always first\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:  # HOT - combination of votes and recency\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .where(\n            ForumPost.sub_forum_id == sub_forum_id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes if authenticated\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, category_slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/categories/{slug}/posts\", response_model=PostListResponse)\nasync def list_category_posts(\n    slug: str,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List all posts in a category (across all sub-forums) with sorting and pagination.\"\"\"\n    # Verify category exists\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n    )\n    category = cat_result.scalar_one_or_none()\n    if not category:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    # Base query - join with sub-forums to filter by category\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n        .where(\n            ForumSubForum.issue_category_id == category.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n        .where(\n            ForumSubForum.issue_category_id == category.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/categories/{slug}/{sub_forum_slug}/posts\", response_model=PostListResponse)\nasync def list_sub_forum_posts(\n    slug: str,\n    sub_forum_slug: str,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List all posts in a specific sub-forum with sorting and pagination.\"\"\"\n    # Verify category and sub-forum exist\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n    )\n    category = cat_result.scalar_one_or_none()\n    if not category:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    sf_result = await db.execute(\n        select(ForumSubForum).where(\n            ForumSubForum.slug == sub_forum_slug,\n            ForumSubForum.issue_category_id == category.id\n        )\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    # Base query\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .where(\n            ForumPost.sub_forum_id == sub_forum.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .where(\n            ForumPost.sub_forum_id == sub_forum.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.post(\"/posts\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.POSTS)\nasync def create_post(\n    request: Request,\n    data: PostCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a new post.\n\n    Rate limit: 5 posts per minute per user.\n    \"\"\"\n    # Verify sub-forum exists\n    sf_result = await db.execute(\n        select(ForumSubForum)\n        .options(selectinload(ForumSubForum.issue_category))\n        .where(ForumSubForum.id == data.sub_forum_id)\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    post = ForumPost(\n        title=data.title,\n        content=data.content,\n        sub_forum_id=data.sub_forum_id,\n        author_id=current_user.id,\n    )\n\n    db.add(post)\n    await db.commit()\n    await db.refresh(post)\n\n    return _post_to_response(post, sub_forum.slug, sub_forum.issue_category.slug, None)\n\n\n@router.get(\"/posts/{post_id}\", response_model=PostResponse)\nasync def get_post(\n    post_id: UUID,\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get a single post with full details.\"\"\"\n    query = (\n        select(ForumPost)\n        .options(\n            selectinload(ForumPost.author),\n            selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n        )\n        .where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    result = await db.execute(query)\n    post = result.scalar_one_or_none()\n\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Get user's vote\n    user_vote = None\n    if current_user:\n        vote_result = await db.execute(\n            select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id == post_id\n            )\n        )\n        vote = vote_result.scalar_one_or_none()\n        user_vote = vote.vote_type if vote else None\n\n    return _post_to_response(\n        post,\n        post.sub_forum.slug,\n        post.sub_forum.issue_category.slug,\n        user_vote\n    )\n\n\n@router.post(\"/posts/{post_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_post(\n    request: Request,\n    post_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a post (upvote/downvote). Voting again removes vote, changing vote type switches it.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")\n\n    # Check existing vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id == post_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        # Robustly get value (handle if DB returns string or Enum)\n        current_val = existing_vote.vote_type.value if hasattr(existing_vote.vote_type, 'value') else existing_vote.vote_type\n        # Request is from Pydantic Schema Enum\n        request_val = data.vote_type.value\n\n        if current_val == request_val:\n            # Same vote - remove it\n            await db.delete(existing_vote)\n            post.vote_count += -1 if request_val == \"up\" else 1\n        else:\n            # Different vote - switch it\n            # Ensure we assign the Model Enum (or string if that's what it wants, but Model Enum is safer if Typed)\n            existing_vote.vote_type = VoteType(request_val)\n            # Swing by 2 (remove old, add new)\n            post.vote_count += 2 if request_val == \"up\" else -2\n            new_user_vote = data.vote_type\n    else:\n        # New vote\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.POST,\n            target_id=post_id,\n            # Explicitly cast to Model Enum\n            vote_type=VoteType(data.vote_type.value)\n        )\n        db.add(vote)\n        post.vote_count += 1 if data.vote_type.value == \"up\" else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=post.vote_count, user_vote=new_user_vote)\n\n\n@router.delete(\"/posts/{post_id}\")\nasync def delete_post(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Delete a post (author or moderator).\"\"\"\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    is_author = post.author_id == current_user.id\n    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n\n    if not is_author and not is_mod:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    post.is_deleted = True\n    post.deleted_at = datetime.now(timezone.utc)\n    post.deleted_by = current_user.id\n    await db.commit()\n\n    return {\"success\": True}\n\n\n@router.put(\"/posts/{post_id}\", response_model=PostResponse)\nasync def update_post(\n    post_id: UUID,\n    data: PostUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update a post (author only).\"\"\"\n    post_result = await db.execute(\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .where(ForumPost.id == post_id)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    if post.author_id != current_user.id:\n        raise HTTPException(status_code=403, detail=\"Not authorized to edit this post\")\n\n    if data.title is not None:\n        post.title = data.title\n    if data.content is not None:\n        post.content = data.content\n    post.updated_at = datetime.utcnow()\n\n    await db.commit()\n    await db.refresh(post)\n\n    # Get user vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id == post_id\n        )\n    )\n    user_vote = vote_result.scalar_one_or_none()\n\n    # Get category slug\n    sf = post.sub_forum\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.id == sf.issue_category_id)\n    )\n    cat = cat_result.scalar_one()\n\n    return PostResponse(\n        id=post.id,\n        title=post.title,\n        content=post.content,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        created_at=post.created_at,\n        updated_at=post.updated_at,\n        author=PostAuthor(\n            id=post.author.id,\n            username=post.author.username,\n            avatar_url=None\n        ),\n        sub_forum=SubForumResponse(\n            id=sf.id,\n            name=sf.name,\n            slug=sf.slug,\n            description=sf.description,\n            icon=sf.icon,\n            display_order=sf.display_order,\n            post_count=0\n        ),\n        category_slug=cat.slug,\n        user_vote=user_vote.vote_type if user_vote else None\n    )\n\n\n# === COMMENTS ===\n\n@router.get(\"/posts/{post_id}/comments\", response_model=List[CommentResponse])\nasync def get_post_comments(\n    post_id: UUID,\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all comments for a post in a threaded structure.\"\"\"\n    # Verify post exists\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    if not post_result.scalar_one_or_none():\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Get all comments for post\n    query = (\n        select(ForumComment)\n        .options(selectinload(ForumComment.author))\n        .where(ForumComment.post_id == post_id, ForumComment.is_deleted == False)\n        .order_by(ForumComment.created_at)\n    )\n    result = await db.execute(query)\n    comments = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        comment_ids = [c.id for c in comments]\n        if comment_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.COMMENT,\n                ForumVote.target_id.in_(comment_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    # Build tree structure\n    return _build_comment_tree(comments, user_votes)\n\n\n@router.post(\"/posts/{post_id}/comments\", response_model=CommentResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.COMMENTS)\nasync def create_comment(\n    request: Request,\n    post_id: UUID,\n    data: CommentCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a comment on a post.\n\n    Rate limit: 20 comments per minute per user.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    depth = 0\n    if data.parent_id:\n        # Verify parent comment exists\n        parent_result = await db.execute(\n            select(ForumComment).where(\n                ForumComment.id == data.parent_id,\n                ForumComment.post_id == post_id\n            )\n        )\n        parent = parent_result.scalar_one_or_none()\n        if not parent:\n            raise HTTPException(status_code=404, detail=\"Parent comment not found\")\n        depth = min(parent.depth + 1, MAX_COMMENT_DEPTH)\n\n    comment = ForumComment(\n        content=data.content,\n        post_id=post_id,\n        author_id=current_user.id,\n        parent_id=data.parent_id,\n        depth=depth,\n    )\n\n    db.add(comment)\n    await db.commit()\n    await db.refresh(comment)\n\n    # Load author relationship\n    await db.refresh(comment, [\"author\"])\n\n    return _comment_to_response(comment, None)\n\n\n@router.post(\"/comments/{comment_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_comment(\n    request: Request,\n    comment_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a comment.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    comment_result = await db.execute(\n        select(ForumComment).where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n    )\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")\n\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.COMMENT,\n            ForumVote.target_id == comment_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        if existing_vote.vote_type == data.vote_type:\n            await db.delete(existing_vote)\n            comment.vote_count += -1 if data.vote_type == VoteType.UP else 1\n        else:\n            existing_vote.vote_type = data.vote_type\n            comment.vote_count += 2 if data.vote_type == VoteType.UP else -2\n            new_user_vote = data.vote_type\n    else:\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.COMMENT,\n            target_id=comment_id,\n            vote_type=data.vote_type\n        )\n        db.add(vote)\n        comment.vote_count += 1 if data.vote_type == VoteType.UP else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=comment.vote_count, user_vote=new_user_vote)\n\n\n@router.put(\"/comments/{comment_id}\", response_model=CommentResponse)\nasync def update_comment(\n    comment_id: UUID,\n    data: CommentUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update a comment (author only).\"\"\"\n    comment_result = await db.execute(\n        select(ForumComment)\n        .options(selectinload(ForumComment.author))\n        .where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n    )\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    if comment.author_id != current_user.id:\n        raise HTTPException(status_code=403, detail=\"Not authorized to edit this comment\")\n\n    comment.content = data.content\n    comment.updated_at = datetime.utcnow()\n\n    await db.commit()\n    await db.refresh(comment)\n\n    # Get user vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.COMMENT,\n            ForumVote.target_id == comment_id\n        )\n    )\n    user_vote = vote_result.scalar_one_or_none()\n\n    return _comment_to_response(comment, user_vote.vote_type if user_vote else None)\n\n\n@router.delete(\"/comments/{comment_id}\")\nasync def delete_comment(\n    comment_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Delete a comment (author or moderator).\"\"\"\n    comment_result = await db.execute(select(ForumComment).where(ForumComment.id == comment_id))\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    is_author = comment.author_id == current_user.id\n    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n\n    if not is_author and not is_mod:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    comment.is_deleted = True\n    comment.deleted_at = datetime.now(timezone.utc)\n    comment.deleted_by = current_user.id\n\n    # Decrement comment count on the parent post\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == comment.post_id))\n    post = post_result.scalar_one_or_none()\n    if post and post.comment_count > 0:\n        post.comment_count -= 1\n\n    await db.commit()\n\n    return {\"success\": True}\n\n\n# === REPORTS ===\n\n@router.post(\"/reports\", response_model=ReportResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.REPORTS)\nasync def create_report(\n    request: Request,\n    data: ReportCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Report a post or comment.\n\n    Rate limit: 10 reports per hour per user.\n    \"\"\"\n    # Verify target exists\n    if data.target_type == TargetType.POST:\n        target_result = await db.execute(select(ForumPost).where(ForumPost.id == data.target_id))\n    else:\n        target_result = await db.execute(select(ForumComment).where(ForumComment.id == data.target_id))\n\n    if not target_result.scalar_one_or_none():\n        raise HTTPException(status_code=404, detail=\"Target not found\")\n\n    # Check for duplicate report\n    existing = await db.execute(\n        select(ForumReport).where(\n            ForumReport.reporter_id == current_user.id,\n            ForumReport.target_type == data.target_type,\n            ForumReport.target_id == data.target_id,\n            ForumReport.status == ReportStatus.PENDING\n        )\n    )\n    if existing.scalar_one_or_none():\n        raise HTTPException(status_code=400, detail=\"You have already reported this content\")\n\n    report = ForumReport(\n        reporter_id=current_user.id,\n        target_type=data.target_type,\n        target_id=data.target_id,\n        reason=data.reason,\n        details=data.details,\n    )\n\n    db.add(report)\n    await db.commit()\n    await db.refresh(report)\n\n    return ReportResponse(\n        id=report.id,\n        target_type=report.target_type,\n        target_id=report.target_id,\n        reason=report.reason,\n        status=report.status.value,\n        created_at=report.created_at\n    )\n\n\n# === MODERATION (Admin/Moderator only) ===\n\n@router.post(\"/posts/{post_id}/pin\")\nasync def pin_post(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Pin/unpin a post (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    post.is_pinned = not post.is_pinned\n    await db.commit()\n\n    return {\"success\": True, \"is_pinned\": post.is_pinned}\n\n\n@router.post(\"/posts/{post_id}/mark-guide\")\nasync def mark_as_guide(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Mark/unmark a post as a guide (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    post.is_guide = not post.is_guide\n    await db.commit()\n\n    return {\"success\": True, \"is_guide\": post.is_guide}\n\n\n@router.get(\"/reports\", response_model=List[ReportResponse])\nasync def list_reports(\n    status_filter: Optional[ReportStatus] = Query(None, alias=\"status\"),\n    limit: int = Query(50, ge=1, le=100),\n    offset: int = Query(0, ge=0),\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List reports (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    query = select(ForumReport).order_by(ForumReport.created_at.desc())\n\n    if status_filter:\n        query = query.where(ForumReport.status == status_filter)\n\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    reports = result.scalars().all()\n\n    return [\n        ReportResponse(\n            id=r.id,\n            target_type=r.target_type,\n            target_id=r.target_id,\n            reason=r.reason,\n            status=r.status.value,\n            created_at=r.created_at\n        )\n        for r in reports\n    ]\n\n\n@router.patch(\"/reports/{report_id}\")\nasync def update_report_status(\n    report_id: UUID,\n    new_status: ReportStatus,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update report status (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    report_result = await db.execute(select(ForumReport).where(ForumReport.id == report_id))\n    report = report_result.scalar_one_or_none()\n    if not report:\n        raise HTTPException(status_code=404, detail=\"Report not found\")\n\n    report.status = new_status\n    report.reviewed_by = current_user.id\n    report.reviewed_at = datetime.utcnow()\n\n    await db.commit()\n\n    return {\"success\": True, \"status\": new_status.value}\n\n\n# === BOOKMARKS ===\n\n@router.post(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\nasync def toggle_bookmark(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Toggle bookmark status for a post.\n\n    If the post is not bookmarked, it will be bookmarked.\n    If the post is already bookmarked, the bookmark will be removed.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Check if already bookmarked\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    existing_bookmark = existing.scalar_one_or_none()\n\n    if existing_bookmark:\n        # Remove bookmark\n        await db.delete(existing_bookmark)\n        await db.commit()\n        return BookmarkToggleResponse(\n            is_bookmarked=False,\n            message=\"Bookmark removed\"\n        )\n    else:\n        # Add bookmark\n        bookmark = ForumBookmark(\n            user_id=current_user.id,\n            post_id=post_id\n        )\n        db.add(bookmark)\n        await db.commit()\n        return BookmarkToggleResponse(\n            is_bookmarked=True,\n            message=\"Post bookmarked\"\n        )\n\n\n@router.delete(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\nasync def remove_bookmark(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Remove a bookmark from a post.\"\"\"\n    # Check if bookmark exists\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    existing_bookmark = existing.scalar_one_or_none()\n\n    if not existing_bookmark:\n        raise HTTPException(status_code=404, detail=\"Bookmark not found\")\n\n    await db.delete(existing_bookmark)\n    await db.commit()\n\n    return BookmarkToggleResponse(\n        is_bookmarked=False,\n        message=\"Bookmark removed\"\n    )\n\n\n@router.get(\"/bookmarks\", response_model=BookmarkedPostsResponse)\nasync def get_bookmarked_posts(\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all bookmarked posts for the current user, sorted by bookmark date (newest first).\"\"\"\n    # Get total count\n    count_query = (\n        select(func.count(ForumBookmark.id))\n        .where(ForumBookmark.user_id == current_user.id)\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Get bookmarked posts with pagination\n    query = (\n        select(ForumBookmark)\n        .options(\n            selectinload(ForumBookmark.post).selectinload(ForumPost.author),\n            selectinload(ForumBookmark.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n        )\n        .where(ForumBookmark.user_id == current_user.id)\n        .order_by(ForumBookmark.created_at.desc())\n        .offset(offset)\n        .limit(limit)\n    )\n    result = await db.execute(query)\n    bookmarks = result.scalars().all()\n\n    # Filter out any bookmarks for deleted posts\n    valid_bookmarks = [b for b in bookmarks if b.post and not b.post.is_deleted]\n\n    # Get user votes for these posts\n    post_ids = [b.post.id for b in valid_bookmarks]\n    user_votes = {}\n    if post_ids:\n        votes_query = select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id.in_(post_ids)\n        )\n        votes_result = await db.execute(votes_query)\n        user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    # Build response\n    posts = []\n    for bookmark in valid_bookmarks:\n        post = bookmark.post\n        category_slug = post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\"\n        posts.append(_post_to_list_item(post, category_slug, user_votes.get(post.id)))\n\n    return BookmarkedPostsResponse(\n        posts=posts,\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/posts/{post_id}/bookmark-status\")\nasync def get_bookmark_status(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Check if a post is bookmarked by the current user.\"\"\"\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    bookmark = existing.scalar_one_or_none()\n\n    return {\n        \"post_id\": str(post_id),\n        \"is_bookmarked\": bookmark is not None,\n        \"bookmarked_at\": bookmark.created_at.isoformat() if bookmark else None\n    }\n\n\n@router.get(\"/bookmarks/ids\")\nasync def get_bookmarked_post_ids(\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all bookmarked post IDs for the current user.\n\n    Useful for efficiently checking bookmark status on post lists.\n    \"\"\"\n    query = (\n        select(ForumBookmark.post_id)\n        .where(ForumBookmark.user_id == current_user.id)\n    )\n    result = await db.execute(query)\n    post_ids = [str(row[0]) for row in result.all()]\n\n    return {\"bookmarked_post_ids\": post_ids}\n\n\n# === HELPER FUNCTIONS ===\n\ndef _post_to_list_item(post: ForumPost, category_slug: str, user_vote: Optional[VoteType]) -> PostListItem:\n    sub_forum_slug = post.sub_forum.slug if post.sub_forum else \"\"\n    return PostListItem(\n        id=post.id,\n        title=post.title,\n        content_preview=post.content[:200] + \"...\" if len(post.content) > 200 else post.content,\n        sub_forum_slug=sub_forum_slug,\n        category_slug=category_slug,\n        author=PostAuthor(id=post.author.id, username=post.author.username),\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        user_vote=user_vote,\n        created_at=post.created_at,\n    )\n\n\ndef _post_to_response(\n    post: ForumPost,\n    sub_forum_slug: str,\n    category_slug: str,\n    user_vote: Optional[VoteType]\n) -> PostResponse:\n    return PostResponse(\n        id=post.id,\n        title=post.title,\n        content=post.content,\n        sub_forum_id=post.sub_forum_id,\n        sub_forum_slug=sub_forum_slug,\n        category_slug=category_slug,\n        author=PostAuthor(id=post.author.id, username=post.author.username),\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        user_vote=user_vote,\n        created_at=post.created_at,\n        updated_at=post.updated_at,\n    )\n\n\ndef _comment_to_response(comment: ForumComment, user_vote: Optional[VoteType]) -> CommentResponse:\n    return CommentResponse(\n        id=comment.id,\n        content=comment.content,\n        post_id=comment.post_id,\n        author=PostAuthor(id=comment.author.id, username=comment.author.username),\n        parent_id=comment.parent_id,\n        vote_count=comment.vote_count,\n        user_vote=user_vote,\n        depth=comment.depth,\n        replies=[],\n        created_at=comment.created_at,\n        updated_at=comment.updated_at,\n    )\n\n\ndef _build_comment_tree(comments: List[ForumComment], user_votes: dict) -> List[CommentResponse]:\n    \"\"\"Build a tree structure from flat comment list.\"\"\"\n    comment_map = {}\n    roots = []\n\n    # First pass: create all response objects\n    for c in comments:\n        comment_map[c.id] = _comment_to_response(c, user_votes.get(c.id))\n\n    # Second pass: build tree\n    for c in comments:\n        response = comment_map[c.id]\n        if c.parent_id and c.parent_id in comment_map:\n            comment_map[c.parent_id].replies.append(response)\n        else:\n            roots.append(response)\n\n    return roots\n","structuredPatch":[{"oldStart":846,"oldLines":7,"newStart":846,"newLines":7,"lines":[" ","     # Prevent self-voting","     if post.author_id == current_user.id:","-        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")","+        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")"," ","     # Check existing vote","     vote_result = await db.execute("]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"12e2590b-9db7-42ae-8417-ac7d01c3dff4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YBxbWZJoDNGBP841gYZkpw","type":"tool_result","content":"The file /Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1108→    comment = comment_result.scalar_one_or_none()\n  1109→    if not comment:\n  1110→        raise HTTPException(status_code=404, detail=\"Comment not found\")\n  1111→\n  1112→    # Prevent self-voting\n  1113→    if comment.author_id == current_user.id:\n  1114→        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")\n  1115→\n  1116→    vote_result = await db.execute(\n  1117→        select(ForumVote).where(\n  1118→            ForumVote.user_id == current_user.id,"}]},"uuid":"c99ad8cb-56d4-4ef9-b507-95da1572b13a","timestamp":"2025-12-27T16:54:20.794Z","toolUseResult":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","oldString":"    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")","newString":"    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")","originalFile":"\"\"\"\nForum router - Categories, Sub-Forums, Posts, Comments, Votes, Reports\n\nRate Limits:\n- Posts: 5 per minute per user\n- Comments: 20 per minute per user\n- Votes: 30 per minute per user\n- Reports: 10 per hour per user\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func, and_, or_, desc\nfrom sqlalchemy.orm import selectinload\nfrom uuid import UUID\nfrom typing import Optional, List\nfrom datetime import datetime, timezone\nimport bleach\n\nfrom app.database import get_db\nfrom app.core.rate_limit import limiter, ForumRateLimits\nfrom app.models.user import User, UserRole\nfrom app.models.forum import (\n    ForumIssueCategory, ForumSubForum, ForumPost, ForumComment,\n    ForumVote, ForumReport, FlawToForumMapping, ArchetypeForumMapping,\n    ForumBookmark, VoteType, TargetType, ReportStatus, ReportReason\n)\nfrom app.services.auth import get_current_user, get_current_user_optional\nfrom app.schemas.forum import (\n    CategoryResponse, CategoryListResponse, SubForumResponse,\n    PostCreate, PostUpdate, PostResponse, PostListItem,\n    PostListResponse, CommentCreate, CommentUpdate, CommentResponse,\n    VoteRequest, VoteResponse, ReportCreate, ReportResponse,\n    GuideSectionResponse, SortOrder, PostAuthor, RecommendedForumResponse,\n    ArchetypeForumRecommendation, ForumSearchResult, ForumSearchResponse,\n    SearchResultType, BookmarkToggleResponse, BookmarkedPostsResponse\n)\n\nrouter = APIRouter(prefix=\"/forum\", tags=[\"forum\"])\n\nPAGE_SIZE = 20\nMAX_COMMENT_DEPTH = 5\n\n\n# === CATEGORIES ===\n\n@router.get(\"/categories\", response_model=List[CategoryResponse])\nasync def list_categories(db: AsyncSession = Depends(get_db)):\n    \"\"\"List all active forum categories with sub-forums and post counts.\n\n    Optimized to use only 2 queries instead of N+1 pattern.\n    \"\"\"\n    # Query 1: Get all categories with sub-forums\n    query = (\n        select(ForumIssueCategory)\n        .options(selectinload(ForumIssueCategory.sub_forums))\n        .where(ForumIssueCategory.is_active == True)\n        .order_by(ForumIssueCategory.display_order)\n    )\n    result = await db.execute(query)\n    categories = result.scalars().all()\n\n    # Query 2: Get ALL sub-forum post counts in ONE query (batched)\n    sf_counts_query = (\n        select(\n            ForumPost.sub_forum_id,\n            func.count(ForumPost.id).label('post_count')\n        )\n        .where(\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n        .group_by(ForumPost.sub_forum_id)\n    )\n    sf_counts_result = await db.execute(sf_counts_query)\n    sf_counts = {row[0]: row[1] for row in sf_counts_result}\n\n    # Build response using pre-fetched counts (no additional queries)\n    response = []\n    for cat in categories:\n        cat_post_count = 0\n        sub_forums = []\n\n        for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n            if sf.is_active:\n                sf_post_count = sf_counts.get(sf.id, 0)\n                cat_post_count += sf_post_count\n\n                sub_forums.append(SubForumResponse(\n                    id=sf.id,\n                    name=sf.name,\n                    slug=sf.slug,\n                    description=sf.description,\n                    icon=sf.icon,\n                    display_order=sf.display_order,\n                    post_count=sf_post_count\n                ))\n\n        response.append(CategoryResponse(\n            id=cat.id,\n            name=cat.name,\n            slug=cat.slug,\n            description=cat.description,\n            icon=cat.icon,\n            display_order=cat.display_order,\n            post_count=cat_post_count,\n            sub_forums=sub_forums\n        ))\n\n    return response\n\n\n@router.get(\"/categories/{slug}\", response_model=CategoryResponse)\nasync def get_category(\n    slug: str,\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get a single category by slug with its sub-forums.\n\n    Optimized to use only 2 queries instead of N+1 pattern.\n    \"\"\"\n    # Query 1: Get category with sub-forums\n    query = (\n        select(ForumIssueCategory)\n        .options(selectinload(ForumIssueCategory.sub_forums))\n        .where(ForumIssueCategory.slug == slug, ForumIssueCategory.is_active == True)\n    )\n    result = await db.execute(query)\n    cat = result.scalar_one_or_none()\n\n    if not cat:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    # Get sub-forum IDs for this category\n    sf_ids = [sf.id for sf in cat.sub_forums if sf.is_active]\n\n    # Query 2: Get post counts for all sub-forums in this category (batched)\n    sf_counts = {}\n    if sf_ids:\n        sf_counts_query = (\n            select(\n                ForumPost.sub_forum_id,\n                func.count(ForumPost.id).label('post_count')\n            )\n            .where(\n                ForumPost.sub_forum_id.in_(sf_ids),\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True\n            )\n            .group_by(ForumPost.sub_forum_id)\n        )\n        sf_counts_result = await db.execute(sf_counts_query)\n        sf_counts = {row[0]: row[1] for row in sf_counts_result}\n\n    # Build sub-forums list using pre-fetched counts\n    cat_post_count = 0\n    sub_forums = []\n    for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n        if sf.is_active:\n            sf_post_count = sf_counts.get(sf.id, 0)\n            cat_post_count += sf_post_count\n\n            sub_forums.append(SubForumResponse(\n                id=sf.id,\n                name=sf.name,\n                slug=sf.slug,\n                description=sf.description,\n                icon=sf.icon,\n                display_order=sf.display_order,\n                post_count=sf_post_count\n            ))\n\n    return CategoryResponse(\n        id=cat.id,\n        name=cat.name,\n        slug=cat.slug,\n        description=cat.description,\n        icon=cat.icon,\n        display_order=cat.display_order,\n        post_count=cat_post_count,\n        sub_forums=sub_forums\n    )\n\n\n# === SEARCH ===\n\n@router.get(\"/search\", response_model=ForumSearchResponse)\nasync def search_forum(\n    q: str = Query(..., min_length=2, max_length=100, description=\"Search query\"),\n    type: str = Query(\"all\", description=\"Search type: posts, comments, or all\"),\n    limit: int = Query(20, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Search forum posts and comments using ILIKE pattern matching.\n\n    - Search by title, content for posts\n    - Search by content for comments\n    - Results sorted by vote_count DESC, created_at DESC\n    \"\"\"\n    search_pattern = f\"%{q}%\"\n    results = []\n    total_count = 0\n\n    if type in (\"posts\", \"all\"):\n        # Search posts by title and content\n        post_query = (\n            select(ForumPost)\n            .options(\n                selectinload(ForumPost.author),\n                selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n            )\n            .where(\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(\n                    ForumPost.title.ilike(search_pattern),\n                    ForumPost.content.ilike(search_pattern)\n                )\n            )\n            .order_by(ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n        )\n\n        # Count posts\n        post_count_query = (\n            select(func.count(ForumPost.id))\n            .where(\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(\n                    ForumPost.title.ilike(search_pattern),\n                    ForumPost.content.ilike(search_pattern)\n                )\n            )\n        )\n        post_count_result = await db.execute(post_count_query)\n        post_count = post_count_result.scalar() or 0\n\n        if type == \"posts\":\n            total_count = post_count\n            post_query = post_query.offset(offset).limit(limit)\n        else:\n            total_count += post_count\n            # For \"all\", we get all posts first then merge with comments\n            post_query = post_query.limit(limit * 2)  # Get more to merge\n\n        post_result = await db.execute(post_query)\n        posts = post_result.scalars().all()\n\n        for post in posts:\n            content_preview = post.content[:200] + \"...\" if len(post.content) > 200 else post.content\n            results.append(ForumSearchResult(\n                id=post.id,\n                type=SearchResultType.POST,\n                title=post.title,\n                content_preview=content_preview,\n                post_id=None,\n                post_title=None,\n                author=PostAuthor(id=post.author.id, username=post.author.username),\n                vote_count=post.vote_count,\n                category_slug=post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\",\n                sub_forum_slug=post.sub_forum.slug if post.sub_forum else \"\",\n                created_at=post.created_at\n            ))\n\n    if type in (\"comments\", \"all\"):\n        # Search comments by content\n        comment_query = (\n            select(ForumComment)\n            .options(\n                selectinload(ForumComment.author),\n                selectinload(ForumComment.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n            )\n            .where(\n                ForumComment.is_deleted == False,\n                ForumComment.content.ilike(search_pattern)\n            )\n            .order_by(ForumComment.vote_count.desc(), ForumComment.created_at.desc())\n        )\n\n        # Count comments\n        comment_count_query = (\n            select(func.count(ForumComment.id))\n            .where(\n                ForumComment.is_deleted == False,\n                ForumComment.content.ilike(search_pattern)\n            )\n        )\n        comment_count_result = await db.execute(comment_count_query)\n        comment_count = comment_count_result.scalar() or 0\n\n        if type == \"comments\":\n            total_count = comment_count\n            comment_query = comment_query.offset(offset).limit(limit)\n        else:\n            total_count += comment_count\n            comment_query = comment_query.limit(limit * 2)\n\n        comment_result = await db.execute(comment_query)\n        comments = comment_result.scalars().all()\n\n        for comment in comments:\n            content_preview = comment.content[:200] + \"...\" if len(comment.content) > 200 else comment.content\n            post = comment.post\n            if post and post.sub_forum:\n                category_slug = post.sub_forum.issue_category.slug if post.sub_forum.issue_category else \"\"\n                sub_forum_slug = post.sub_forum.slug\n            else:\n                category_slug = \"\"\n                sub_forum_slug = \"\"\n\n            results.append(ForumSearchResult(\n                id=comment.id,\n                type=SearchResultType.COMMENT,\n                title=None,\n                content_preview=content_preview,\n                post_id=comment.post_id,\n                post_title=post.title if post else None,\n                author=PostAuthor(id=comment.author.id, username=comment.author.username),\n                vote_count=comment.vote_count,\n                category_slug=category_slug,\n                sub_forum_slug=sub_forum_slug,\n                created_at=comment.created_at\n            ))\n\n    # For \"all\" type, sort merged results by vote_count and created_at, then paginate\n    if type == \"all\":\n        results.sort(key=lambda x: (-x.vote_count, x.created_at), reverse=False)\n        results.sort(key=lambda x: x.vote_count, reverse=True)\n        results = results[offset:offset + limit]\n\n    return ForumSearchResponse(\n        results=results,\n        total_count=total_count,\n        query=q,\n        search_type=type,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/recommended\", response_model=List[RecommendedForumResponse])\nasync def get_recommended_forums(\n    flaws: str = Query(..., description=\"Comma-separated list of flaw IDs\"),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get recommended forums based on detected flaws.\"\"\"\n    flaw_list = [f.strip() for f in flaws.split(\",\") if f.strip()]\n\n    if not flaw_list:\n        return []\n\n    # Find mappings for these flaws\n    query = (\n        select(FlawToForumMapping)\n        .options(selectinload(FlawToForumMapping.issue_category))\n        .where(FlawToForumMapping.flaw_id.in_(flaw_list))\n        .order_by(FlawToForumMapping.priority)\n    )\n\n    result = await db.execute(query)\n    mappings = result.scalars().all()\n\n    # Group by category\n    category_flaws = {}\n    for mapping in mappings:\n        cat_id = mapping.issue_category_id\n        if cat_id not in category_flaws:\n            category_flaws[cat_id] = {\n                \"category\": mapping.issue_category,\n                \"flaws\": [],\n                \"priority\": mapping.priority\n            }\n        category_flaws[cat_id][\"flaws\"].append(mapping.flaw_id)\n        # Use lowest priority (1 = primary)\n        if mapping.priority < category_flaws[cat_id][\"priority\"]:\n            category_flaws[cat_id][\"priority\"] = mapping.priority\n\n    # Build response sorted by priority\n    response = []\n    for cat_data in sorted(category_flaws.values(), key=lambda x: x[\"priority\"]):\n        cat = cat_data[\"category\"]\n        response.append(RecommendedForumResponse(\n            category=CategoryListResponse(\n                id=cat.id,\n                name=cat.name,\n                slug=cat.slug,\n                description=cat.description,\n                icon=cat.icon,\n                display_order=cat.display_order,\n                post_count=0\n            ),\n            matched_flaws=cat_data[\"flaws\"],\n            priority=cat_data[\"priority\"]\n        ))\n\n    return response\n\n\n@router.get(\"/archetype-recommendations\", response_model=List[ArchetypeForumRecommendation])\nasync def get_archetype_forum_recommendations(\n    archetype: str = Query(..., description=\"Archetype category (Softboy, Prettyboy, RobustPrettyboy, Chad, Hypermasculine, Exotic)\"),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get recommended forums based on user's archetype classification.\"\"\"\n    # Normalize archetype name (handle case variations)\n    archetype = archetype.strip()\n\n    # Valid archetypes\n    valid_archetypes = [\"Softboy\", \"Prettyboy\", \"RobustPrettyboy\", \"Chad\", \"Hypermasculine\", \"Exotic\"]\n\n    # Case-insensitive match\n    matched_archetype = None\n    for valid in valid_archetypes:\n        if archetype.lower() == valid.lower():\n            matched_archetype = valid\n            break\n\n    if not matched_archetype:\n        # Return empty list for invalid archetype (not an error)\n        return []\n\n    # Find mappings for this archetype, ordered by priority (highest first)\n    query = (\n        select(ArchetypeForumMapping)\n        .options(selectinload(ArchetypeForumMapping.issue_category))\n        .where(ArchetypeForumMapping.archetype_category == matched_archetype)\n        .order_by(ArchetypeForumMapping.priority.desc())\n    )\n\n    result = await db.execute(query)\n    mappings = result.scalars().all()\n\n    # Build response\n    response = []\n    for mapping in mappings:\n        cat = mapping.issue_category\n        if cat and cat.is_active:\n            response.append(ArchetypeForumRecommendation(\n                category=CategoryListResponse(\n                    id=cat.id,\n                    name=cat.name,\n                    slug=cat.slug,\n                    description=cat.description,\n                    icon=cat.icon,\n                    display_order=cat.display_order,\n                    post_count=0  # Could be optimized with a count query if needed\n                ),\n                archetype=matched_archetype,\n                reason=mapping.reason,\n                priority=mapping.priority\n            ))\n\n    return response\n\n\n@router.get(\"/guides\", response_model=List[GuideSectionResponse])\nasync def get_guides_section(db: AsyncSession = Depends(get_db)):\n    \"\"\"Get pinned guides grouped by category for the top section.\"\"\"\n    # Get categories\n    cat_query = (\n        select(ForumIssueCategory)\n        .where(ForumIssueCategory.is_active == True)\n        .order_by(ForumIssueCategory.display_order)\n    )\n    cat_result = await db.execute(cat_query)\n    categories = cat_result.scalars().all()\n\n    response = []\n    for cat in categories:\n        # Get top 5 guides (pinned or marked as guide) per category\n        guide_query = (\n            select(ForumPost)\n            .options(\n                selectinload(ForumPost.author),\n                selectinload(ForumPost.sub_forum)\n            )\n            .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n            .where(\n                ForumSubForum.issue_category_id == cat.id,\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(ForumPost.is_pinned == True, ForumPost.is_guide == True)\n            )\n            .order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n            .limit(5)\n        )\n        guide_result = await db.execute(guide_query)\n        guides = guide_result.scalars().all()\n\n        if guides:  # Only include categories that have guides\n            response.append(GuideSectionResponse(\n                category=CategoryListResponse(\n                    id=cat.id,\n                    name=cat.name,\n                    slug=cat.slug,\n                    description=cat.description,\n                    icon=cat.icon,\n                    display_order=cat.display_order,\n                    post_count=0\n                ),\n                guides=[_post_to_list_item(g, cat.slug, None) for g in guides]\n            ))\n\n    return response\n\n\n# === POSTS ===\n\n@router.get(\"/sub-forums/{sub_forum_id}/posts\", response_model=PostListResponse)\nasync def list_sub_forum_posts(\n    sub_forum_id: UUID,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List posts in a sub-forum with sorting and pagination.\"\"\"\n    # Verify sub-forum exists and get category\n    sf_result = await db.execute(\n        select(ForumSubForum)\n        .options(selectinload(ForumSubForum.issue_category))\n        .where(ForumSubForum.id == sub_forum_id)\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    category_slug = sub_forum.issue_category.slug\n\n    # Base query\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author))\n        .where(\n            ForumPost.sub_forum_id == sub_forum_id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting - pinned always first\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:  # HOT - combination of votes and recency\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .where(\n            ForumPost.sub_forum_id == sub_forum_id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes if authenticated\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, category_slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/categories/{slug}/posts\", response_model=PostListResponse)\nasync def list_category_posts(\n    slug: str,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List all posts in a category (across all sub-forums) with sorting and pagination.\"\"\"\n    # Verify category exists\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n    )\n    category = cat_result.scalar_one_or_none()\n    if not category:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    # Base query - join with sub-forums to filter by category\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n        .where(\n            ForumSubForum.issue_category_id == category.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n        .where(\n            ForumSubForum.issue_category_id == category.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/categories/{slug}/{sub_forum_slug}/posts\", response_model=PostListResponse)\nasync def list_sub_forum_posts(\n    slug: str,\n    sub_forum_slug: str,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List all posts in a specific sub-forum with sorting and pagination.\"\"\"\n    # Verify category and sub-forum exist\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n    )\n    category = cat_result.scalar_one_or_none()\n    if not category:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    sf_result = await db.execute(\n        select(ForumSubForum).where(\n            ForumSubForum.slug == sub_forum_slug,\n            ForumSubForum.issue_category_id == category.id\n        )\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    # Base query\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .where(\n            ForumPost.sub_forum_id == sub_forum.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .where(\n            ForumPost.sub_forum_id == sub_forum.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.post(\"/posts\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.POSTS)\nasync def create_post(\n    request: Request,\n    data: PostCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a new post.\n\n    Rate limit: 5 posts per minute per user.\n    \"\"\"\n    # Verify sub-forum exists\n    sf_result = await db.execute(\n        select(ForumSubForum)\n        .options(selectinload(ForumSubForum.issue_category))\n        .where(ForumSubForum.id == data.sub_forum_id)\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    post = ForumPost(\n        title=data.title,\n        content=data.content,\n        sub_forum_id=data.sub_forum_id,\n        author_id=current_user.id,\n    )\n\n    db.add(post)\n    await db.commit()\n    await db.refresh(post)\n\n    return _post_to_response(post, sub_forum.slug, sub_forum.issue_category.slug, None)\n\n\n@router.get(\"/posts/{post_id}\", response_model=PostResponse)\nasync def get_post(\n    post_id: UUID,\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get a single post with full details.\"\"\"\n    query = (\n        select(ForumPost)\n        .options(\n            selectinload(ForumPost.author),\n            selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n        )\n        .where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    result = await db.execute(query)\n    post = result.scalar_one_or_none()\n\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Get user's vote\n    user_vote = None\n    if current_user:\n        vote_result = await db.execute(\n            select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id == post_id\n            )\n        )\n        vote = vote_result.scalar_one_or_none()\n        user_vote = vote.vote_type if vote else None\n\n    return _post_to_response(\n        post,\n        post.sub_forum.slug,\n        post.sub_forum.issue_category.slug,\n        user_vote\n    )\n\n\n@router.post(\"/posts/{post_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_post(\n    request: Request,\n    post_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a post (upvote/downvote). Voting again removes vote, changing vote type switches it.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")\n\n    # Check existing vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id == post_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        # Robustly get value (handle if DB returns string or Enum)\n        current_val = existing_vote.vote_type.value if hasattr(existing_vote.vote_type, 'value') else existing_vote.vote_type\n        # Request is from Pydantic Schema Enum\n        request_val = data.vote_type.value\n\n        if current_val == request_val:\n            # Same vote - remove it\n            await db.delete(existing_vote)\n            post.vote_count += -1 if request_val == \"up\" else 1\n        else:\n            # Different vote - switch it\n            # Ensure we assign the Model Enum (or string if that's what it wants, but Model Enum is safer if Typed)\n            existing_vote.vote_type = VoteType(request_val)\n            # Swing by 2 (remove old, add new)\n            post.vote_count += 2 if request_val == \"up\" else -2\n            new_user_vote = data.vote_type\n    else:\n        # New vote\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.POST,\n            target_id=post_id,\n            # Explicitly cast to Model Enum\n            vote_type=VoteType(data.vote_type.value)\n        )\n        db.add(vote)\n        post.vote_count += 1 if data.vote_type.value == \"up\" else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=post.vote_count, user_vote=new_user_vote)\n\n\n@router.delete(\"/posts/{post_id}\")\nasync def delete_post(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Delete a post (author or moderator).\"\"\"\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    is_author = post.author_id == current_user.id\n    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n\n    if not is_author and not is_mod:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    post.is_deleted = True\n    post.deleted_at = datetime.now(timezone.utc)\n    post.deleted_by = current_user.id\n    await db.commit()\n\n    return {\"success\": True}\n\n\n@router.put(\"/posts/{post_id}\", response_model=PostResponse)\nasync def update_post(\n    post_id: UUID,\n    data: PostUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update a post (author only).\"\"\"\n    post_result = await db.execute(\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .where(ForumPost.id == post_id)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    if post.author_id != current_user.id:\n        raise HTTPException(status_code=403, detail=\"Not authorized to edit this post\")\n\n    if data.title is not None:\n        post.title = data.title\n    if data.content is not None:\n        post.content = data.content\n    post.updated_at = datetime.utcnow()\n\n    await db.commit()\n    await db.refresh(post)\n\n    # Get user vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id == post_id\n        )\n    )\n    user_vote = vote_result.scalar_one_or_none()\n\n    # Get category slug\n    sf = post.sub_forum\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.id == sf.issue_category_id)\n    )\n    cat = cat_result.scalar_one()\n\n    return PostResponse(\n        id=post.id,\n        title=post.title,\n        content=post.content,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        created_at=post.created_at,\n        updated_at=post.updated_at,\n        author=PostAuthor(\n            id=post.author.id,\n            username=post.author.username,\n            avatar_url=None\n        ),\n        sub_forum=SubForumResponse(\n            id=sf.id,\n            name=sf.name,\n            slug=sf.slug,\n            description=sf.description,\n            icon=sf.icon,\n            display_order=sf.display_order,\n            post_count=0\n        ),\n        category_slug=cat.slug,\n        user_vote=user_vote.vote_type if user_vote else None\n    )\n\n\n# === COMMENTS ===\n\n@router.get(\"/posts/{post_id}/comments\", response_model=List[CommentResponse])\nasync def get_post_comments(\n    post_id: UUID,\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all comments for a post in a threaded structure.\"\"\"\n    # Verify post exists\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    if not post_result.scalar_one_or_none():\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Get all comments for post\n    query = (\n        select(ForumComment)\n        .options(selectinload(ForumComment.author))\n        .where(ForumComment.post_id == post_id, ForumComment.is_deleted == False)\n        .order_by(ForumComment.created_at)\n    )\n    result = await db.execute(query)\n    comments = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        comment_ids = [c.id for c in comments]\n        if comment_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.COMMENT,\n                ForumVote.target_id.in_(comment_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    # Build tree structure\n    return _build_comment_tree(comments, user_votes)\n\n\n@router.post(\"/posts/{post_id}/comments\", response_model=CommentResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.COMMENTS)\nasync def create_comment(\n    request: Request,\n    post_id: UUID,\n    data: CommentCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a comment on a post.\n\n    Rate limit: 20 comments per minute per user.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    depth = 0\n    if data.parent_id:\n        # Verify parent comment exists\n        parent_result = await db.execute(\n            select(ForumComment).where(\n                ForumComment.id == data.parent_id,\n                ForumComment.post_id == post_id\n            )\n        )\n        parent = parent_result.scalar_one_or_none()\n        if not parent:\n            raise HTTPException(status_code=404, detail=\"Parent comment not found\")\n        depth = min(parent.depth + 1, MAX_COMMENT_DEPTH)\n\n    comment = ForumComment(\n        content=data.content,\n        post_id=post_id,\n        author_id=current_user.id,\n        parent_id=data.parent_id,\n        depth=depth,\n    )\n\n    db.add(comment)\n    await db.commit()\n    await db.refresh(comment)\n\n    # Load author relationship\n    await db.refresh(comment, [\"author\"])\n\n    return _comment_to_response(comment, None)\n\n\n@router.post(\"/comments/{comment_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_comment(\n    request: Request,\n    comment_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a comment.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    comment_result = await db.execute(\n        select(ForumComment).where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n    )\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")\n\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.COMMENT,\n            ForumVote.target_id == comment_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        if existing_vote.vote_type == data.vote_type:\n            await db.delete(existing_vote)\n            comment.vote_count += -1 if data.vote_type == VoteType.UP else 1\n        else:\n            existing_vote.vote_type = data.vote_type\n            comment.vote_count += 2 if data.vote_type == VoteType.UP else -2\n            new_user_vote = data.vote_type\n    else:\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.COMMENT,\n            target_id=comment_id,\n            vote_type=data.vote_type\n        )\n        db.add(vote)\n        comment.vote_count += 1 if data.vote_type == VoteType.UP else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=comment.vote_count, user_vote=new_user_vote)\n\n\n@router.put(\"/comments/{comment_id}\", response_model=CommentResponse)\nasync def update_comment(\n    comment_id: UUID,\n    data: CommentUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update a comment (author only).\"\"\"\n    comment_result = await db.execute(\n        select(ForumComment)\n        .options(selectinload(ForumComment.author))\n        .where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n    )\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    if comment.author_id != current_user.id:\n        raise HTTPException(status_code=403, detail=\"Not authorized to edit this comment\")\n\n    comment.content = data.content\n    comment.updated_at = datetime.utcnow()\n\n    await db.commit()\n    await db.refresh(comment)\n\n    # Get user vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.COMMENT,\n            ForumVote.target_id == comment_id\n        )\n    )\n    user_vote = vote_result.scalar_one_or_none()\n\n    return _comment_to_response(comment, user_vote.vote_type if user_vote else None)\n\n\n@router.delete(\"/comments/{comment_id}\")\nasync def delete_comment(\n    comment_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Delete a comment (author or moderator).\"\"\"\n    comment_result = await db.execute(select(ForumComment).where(ForumComment.id == comment_id))\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    is_author = comment.author_id == current_user.id\n    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n\n    if not is_author and not is_mod:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    comment.is_deleted = True\n    comment.deleted_at = datetime.now(timezone.utc)\n    comment.deleted_by = current_user.id\n\n    # Decrement comment count on the parent post\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == comment.post_id))\n    post = post_result.scalar_one_or_none()\n    if post and post.comment_count > 0:\n        post.comment_count -= 1\n\n    await db.commit()\n\n    return {\"success\": True}\n\n\n# === REPORTS ===\n\n@router.post(\"/reports\", response_model=ReportResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.REPORTS)\nasync def create_report(\n    request: Request,\n    data: ReportCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Report a post or comment.\n\n    Rate limit: 10 reports per hour per user.\n    \"\"\"\n    # Verify target exists\n    if data.target_type == TargetType.POST:\n        target_result = await db.execute(select(ForumPost).where(ForumPost.id == data.target_id))\n    else:\n        target_result = await db.execute(select(ForumComment).where(ForumComment.id == data.target_id))\n\n    if not target_result.scalar_one_or_none():\n        raise HTTPException(status_code=404, detail=\"Target not found\")\n\n    # Check for duplicate report\n    existing = await db.execute(\n        select(ForumReport).where(\n            ForumReport.reporter_id == current_user.id,\n            ForumReport.target_type == data.target_type,\n            ForumReport.target_id == data.target_id,\n            ForumReport.status == ReportStatus.PENDING\n        )\n    )\n    if existing.scalar_one_or_none():\n        raise HTTPException(status_code=400, detail=\"You have already reported this content\")\n\n    report = ForumReport(\n        reporter_id=current_user.id,\n        target_type=data.target_type,\n        target_id=data.target_id,\n        reason=data.reason,\n        details=data.details,\n    )\n\n    db.add(report)\n    await db.commit()\n    await db.refresh(report)\n\n    return ReportResponse(\n        id=report.id,\n        target_type=report.target_type,\n        target_id=report.target_id,\n        reason=report.reason,\n        status=report.status.value,\n        created_at=report.created_at\n    )\n\n\n# === MODERATION (Admin/Moderator only) ===\n\n@router.post(\"/posts/{post_id}/pin\")\nasync def pin_post(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Pin/unpin a post (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    post.is_pinned = not post.is_pinned\n    await db.commit()\n\n    return {\"success\": True, \"is_pinned\": post.is_pinned}\n\n\n@router.post(\"/posts/{post_id}/mark-guide\")\nasync def mark_as_guide(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Mark/unmark a post as a guide (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    post.is_guide = not post.is_guide\n    await db.commit()\n\n    return {\"success\": True, \"is_guide\": post.is_guide}\n\n\n@router.get(\"/reports\", response_model=List[ReportResponse])\nasync def list_reports(\n    status_filter: Optional[ReportStatus] = Query(None, alias=\"status\"),\n    limit: int = Query(50, ge=1, le=100),\n    offset: int = Query(0, ge=0),\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List reports (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    query = select(ForumReport).order_by(ForumReport.created_at.desc())\n\n    if status_filter:\n        query = query.where(ForumReport.status == status_filter)\n\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    reports = result.scalars().all()\n\n    return [\n        ReportResponse(\n            id=r.id,\n            target_type=r.target_type,\n            target_id=r.target_id,\n            reason=r.reason,\n            status=r.status.value,\n            created_at=r.created_at\n        )\n        for r in reports\n    ]\n\n\n@router.patch(\"/reports/{report_id}\")\nasync def update_report_status(\n    report_id: UUID,\n    new_status: ReportStatus,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update report status (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    report_result = await db.execute(select(ForumReport).where(ForumReport.id == report_id))\n    report = report_result.scalar_one_or_none()\n    if not report:\n        raise HTTPException(status_code=404, detail=\"Report not found\")\n\n    report.status = new_status\n    report.reviewed_by = current_user.id\n    report.reviewed_at = datetime.utcnow()\n\n    await db.commit()\n\n    return {\"success\": True, \"status\": new_status.value}\n\n\n# === BOOKMARKS ===\n\n@router.post(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\nasync def toggle_bookmark(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Toggle bookmark status for a post.\n\n    If the post is not bookmarked, it will be bookmarked.\n    If the post is already bookmarked, the bookmark will be removed.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Check if already bookmarked\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    existing_bookmark = existing.scalar_one_or_none()\n\n    if existing_bookmark:\n        # Remove bookmark\n        await db.delete(existing_bookmark)\n        await db.commit()\n        return BookmarkToggleResponse(\n            is_bookmarked=False,\n            message=\"Bookmark removed\"\n        )\n    else:\n        # Add bookmark\n        bookmark = ForumBookmark(\n            user_id=current_user.id,\n            post_id=post_id\n        )\n        db.add(bookmark)\n        await db.commit()\n        return BookmarkToggleResponse(\n            is_bookmarked=True,\n            message=\"Post bookmarked\"\n        )\n\n\n@router.delete(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\nasync def remove_bookmark(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Remove a bookmark from a post.\"\"\"\n    # Check if bookmark exists\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    existing_bookmark = existing.scalar_one_or_none()\n\n    if not existing_bookmark:\n        raise HTTPException(status_code=404, detail=\"Bookmark not found\")\n\n    await db.delete(existing_bookmark)\n    await db.commit()\n\n    return BookmarkToggleResponse(\n        is_bookmarked=False,\n        message=\"Bookmark removed\"\n    )\n\n\n@router.get(\"/bookmarks\", response_model=BookmarkedPostsResponse)\nasync def get_bookmarked_posts(\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all bookmarked posts for the current user, sorted by bookmark date (newest first).\"\"\"\n    # Get total count\n    count_query = (\n        select(func.count(ForumBookmark.id))\n        .where(ForumBookmark.user_id == current_user.id)\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Get bookmarked posts with pagination\n    query = (\n        select(ForumBookmark)\n        .options(\n            selectinload(ForumBookmark.post).selectinload(ForumPost.author),\n            selectinload(ForumBookmark.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n        )\n        .where(ForumBookmark.user_id == current_user.id)\n        .order_by(ForumBookmark.created_at.desc())\n        .offset(offset)\n        .limit(limit)\n    )\n    result = await db.execute(query)\n    bookmarks = result.scalars().all()\n\n    # Filter out any bookmarks for deleted posts\n    valid_bookmarks = [b for b in bookmarks if b.post and not b.post.is_deleted]\n\n    # Get user votes for these posts\n    post_ids = [b.post.id for b in valid_bookmarks]\n    user_votes = {}\n    if post_ids:\n        votes_query = select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id.in_(post_ids)\n        )\n        votes_result = await db.execute(votes_query)\n        user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    # Build response\n    posts = []\n    for bookmark in valid_bookmarks:\n        post = bookmark.post\n        category_slug = post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\"\n        posts.append(_post_to_list_item(post, category_slug, user_votes.get(post.id)))\n\n    return BookmarkedPostsResponse(\n        posts=posts,\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/posts/{post_id}/bookmark-status\")\nasync def get_bookmark_status(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Check if a post is bookmarked by the current user.\"\"\"\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    bookmark = existing.scalar_one_or_none()\n\n    return {\n        \"post_id\": str(post_id),\n        \"is_bookmarked\": bookmark is not None,\n        \"bookmarked_at\": bookmark.created_at.isoformat() if bookmark else None\n    }\n\n\n@router.get(\"/bookmarks/ids\")\nasync def get_bookmarked_post_ids(\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all bookmarked post IDs for the current user.\n\n    Useful for efficiently checking bookmark status on post lists.\n    \"\"\"\n    query = (\n        select(ForumBookmark.post_id)\n        .where(ForumBookmark.user_id == current_user.id)\n    )\n    result = await db.execute(query)\n    post_ids = [str(row[0]) for row in result.all()]\n\n    return {\"bookmarked_post_ids\": post_ids}\n\n\n# === HELPER FUNCTIONS ===\n\ndef _post_to_list_item(post: ForumPost, category_slug: str, user_vote: Optional[VoteType]) -> PostListItem:\n    sub_forum_slug = post.sub_forum.slug if post.sub_forum else \"\"\n    return PostListItem(\n        id=post.id,\n        title=post.title,\n        content_preview=post.content[:200] + \"...\" if len(post.content) > 200 else post.content,\n        sub_forum_slug=sub_forum_slug,\n        category_slug=category_slug,\n        author=PostAuthor(id=post.author.id, username=post.author.username),\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        user_vote=user_vote,\n        created_at=post.created_at,\n    )\n\n\ndef _post_to_response(\n    post: ForumPost,\n    sub_forum_slug: str,\n    category_slug: str,\n    user_vote: Optional[VoteType]\n) -> PostResponse:\n    return PostResponse(\n        id=post.id,\n        title=post.title,\n        content=post.content,\n        sub_forum_id=post.sub_forum_id,\n        sub_forum_slug=sub_forum_slug,\n        category_slug=category_slug,\n        author=PostAuthor(id=post.author.id, username=post.author.username),\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        user_vote=user_vote,\n        created_at=post.created_at,\n        updated_at=post.updated_at,\n    )\n\n\ndef _comment_to_response(comment: ForumComment, user_vote: Optional[VoteType]) -> CommentResponse:\n    return CommentResponse(\n        id=comment.id,\n        content=comment.content,\n        post_id=comment.post_id,\n        author=PostAuthor(id=comment.author.id, username=comment.author.username),\n        parent_id=comment.parent_id,\n        vote_count=comment.vote_count,\n        user_vote=user_vote,\n        depth=comment.depth,\n        replies=[],\n        created_at=comment.created_at,\n        updated_at=comment.updated_at,\n    )\n\n\ndef _build_comment_tree(comments: List[ForumComment], user_votes: dict) -> List[CommentResponse]:\n    \"\"\"Build a tree structure from flat comment list.\"\"\"\n    comment_map = {}\n    roots = []\n\n    # First pass: create all response objects\n    for c in comments:\n        comment_map[c.id] = _comment_to_response(c, user_votes.get(c.id))\n\n    # Second pass: build tree\n    for c in comments:\n        response = comment_map[c.id]\n        if c.parent_id and c.parent_id in comment_map:\n            comment_map[c.parent_id].replies.append(response)\n        else:\n            roots.append(response)\n\n    return roots\n","structuredPatch":[{"oldStart":1111,"oldLines":7,"newStart":1111,"newLines":7,"lines":[" ","     # Prevent self-voting","     if comment.author_id == current_user.id:","-        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")","+        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")"," ","     vote_result = await db.execute(","         select(ForumVote).where("]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"c99ad8cb-56d4-4ef9-b507-95da1572b13a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_017gDqNQKLUaQjTzNFRjjRSU","type":"message","role":"assistant","content":[{"type":"text","text":"Both edits have been applied successfully. Let me verify the implementation is correct by checking that the changes are in place:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1057,"cache_read_input_tokens":63735,"cache_creation":{"ephemeral_5m_input_tokens":1057,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYMtRKUsA9iwY2HGyA8","type":"assistant","uuid":"532c20c2-5c6c-4f73-b5ef-a0eaa931f825","timestamp":"2025-12-27T16:54:26.190Z"}
{"parentUuid":"532c20c2-5c6c-4f73-b5ef-a0eaa931f825","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_017gDqNQKLUaQjTzNFRjjRSU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NdDqzCVRueW8XupfR4GgmB","name":"Grep","input":{"pattern":"Cannot vote on your own content","path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1057,"cache_read_input_tokens":63735,"cache_creation":{"ephemeral_5m_input_tokens":1057,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYMtRKUsA9iwY2HGyA8","type":"assistant","uuid":"ccba49e6-b28b-4b30-aa7e-40d0db761645","timestamp":"2025-12-27T16:54:26.993Z"}
{"parentUuid":"ccba49e6-b28b-4b30-aa7e-40d0db761645","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NdDqzCVRueW8XupfR4GgmB","type":"tool_result","content":"849:        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")\n1114:        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")"}]},"uuid":"9cdfd295-181b-48a1-86b5-c681f13d584f","timestamp":"2025-12-27T16:54:27.470Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"849:        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")\n1114:        raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")","numLines":2}}
{"parentUuid":"9cdfd295-181b-48a1-86b5-c681f13d584f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"a74adb7","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_015aijGwbNaovPFikUVcpLAu","type":"message","role":"assistant","content":[{"type":"text","text":"The self-voting prevention is now fully implemented with the consistent error message. Here is a summary of the implementation:\n\n## Summary\n\n**Task Completed: Self-Voting Prevention for Forum API**\n\nThe self-voting prevention was already implemented in the codebase. I updated the error messages to match the exact specification from the SAAS audit.\n\n**Files Modified:**\n- `/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py`\n\n**Changes Made:**\n\n1. **Post voting endpoint** (`vote_on_post` at line 849):\n   ```python\n   # Prevent self-voting\n   if post.author_id == current_user.id:\n       raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")\n   ```\n\n2. **Comment voting endpoint** (`vote_on_comment` at line 1114):\n   ```python\n   # Prevent self-voting\n   if comment.author_id == current_user.id:\n       raise HTTPException(status_code=400, detail=\"Cannot vote on your own content\")\n   ```\n\n**Behavior:**\n- When a user attempts to upvote or downvote their own post, the API returns HTTP 400 with message \"Cannot vote on your own content\"\n- When a user attempts to upvote or downvote their own comment, the API returns HTTP 400 with message \"Cannot vote on your own content\"\n- The check occurs immediately after verifying the post/comment exists and before any vote creation or modification logic\n- UUIDs are compared directly (both `author_id` and `current_user.id` are UUID types)"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":203,"cache_read_input_tokens":64792,"cache_creation":{"ephemeral_5m_input_tokens":203,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWXYNPP6cLNkSDJf86oi2","type":"assistant","uuid":"5ce914cc-436b-40a5-bdcc-9cd5b8375fcb","timestamp":"2025-12-27T16:54:55.536Z"}
