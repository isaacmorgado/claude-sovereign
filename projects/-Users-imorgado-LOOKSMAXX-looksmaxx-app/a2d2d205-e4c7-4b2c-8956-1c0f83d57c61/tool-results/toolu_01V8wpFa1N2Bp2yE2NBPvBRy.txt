     1→'use client';
     2→
     3→import { useEffect, useRef, useCallback, useState } from 'react';
     4→
     5→/**
     6→ * HeroBackground.tsx
     7→ * Extracted from faceiqlabs.com HAR file (animation.js)
     8→ *
     9→ * This component implements the mouse-following parallax effect
    10→ * from the original FaceIQ Labs homepage.
    11→ *
    12→ * Original Logic:
    13→ * - Tracks pointer position within the hero container
    14→ * - Normalizes coordinates to -1 to 1 range
    15→ * - Applies linear interpolation (lerp) for smooth transitions
    16→ * - Applies transforms to background elements
    17→ */
    18→
    19→interface PointerPosition {
    20→  x: number;
    21→  y: number;
    22→}
    23→
    24→interface HeroBackgroundProps {
    25→  children?: React.ReactNode;
    26→  className?: string;
    27→}
    28→
    29→// Linear interpolation helper - exact logic from original
    30→const lerp = (current: number, target: number, factor: number): number => {
    31→  return current + (target - current) * factor;
    32→};
    33→
    34→export default function HeroBackground({ children, className = '' }: HeroBackgroundProps) {
    35→  const containerRef = useRef<HTMLDivElement>(null);
    36→  const backgroundRef = useRef<HTMLDivElement>(null);
    37→  const animationRef = useRef<number | null>(null);
    38→
    39→  // Pointer position state - matches original variable names
    40→  const pointerTarget = useRef<PointerPosition>({ x: 0, y: 0 });
    41→  const pointer = useRef<PointerPosition>({ x: 0, y: 0 });
    42→
    43→  // Track if animation should run
    44→  const [isVisible, setIsVisible] = useState(true);
    45→  const [isSectionVisible, setIsSectionVisible] = useState(true);
    46→
    47→  /**
    48→   * Pointer move handler
    49→   * Exact logic from original initPointerHandlers():
    50→   *
    51→   * const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    52→   * const ny = ((e.clientY - rect.top) / rect.height) * 2 - 1;
    53→   * pointerTarget.x = Math.max(-1, Math.min(1, nx));
    54→   * pointerTarget.y = Math.max(-1, Math.min(1, ny));
    55→   */
    56→  const handlePointerMove = useCallback((e: PointerEvent) => {
    57→    const container = containerRef.current;
    58→    if (!container) return;
    59→
    60→    const rect = container.getBoundingClientRect();
    61→
    62→    // Normalize to -1 to 1 range (original math)
    63→    const nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    64→    const ny = ((e.clientY - rect.top) / rect.height) * 2 - 1;
    65→
    66→    // Clamp values (original logic)
    67→    pointerTarget.current.x = Math.max(-1, Math.min(1, nx));
    68→    pointerTarget.current.y = Math.max(-1, Math.min(1, ny));
    69→  }, []);
    70→
    71→  /**
    72→   * Pointer leave handler
    73→   * Resets target to center when mouse leaves
    74→   */
    75→  const handlePointerLeave = useCallback(() => {
    76→    pointerTarget.current.x = 0;
    77→    pointerTarget.current.y = 0;
    78→  }, []);
    79→
    80→  /**
    81→   * Animation loop
    82→   * Exact lerp factor from original: 0.08
    83→   *
    84→   * Original logic:
    85→   * pointer.x += (pointerTarget.x - pointer.x) * 0.08;
    86→   * pointer.y += (pointerTarget.y - pointer.y) * 0.08;
    87→   */
    88→  const animate = useCallback(() => {
    89→    if (!isVisible || !isSectionVisible) {
    90→      animationRef.current = requestAnimationFrame(animate);
    91→      return;
    92→    }
    93→
    94→    // Apply lerp smoothing (exact factor from original: 0.08)
    95→    pointer.current.x = lerp(pointer.current.x, pointerTarget.current.x, 0.08);
    96→    pointer.current.y = lerp(pointer.current.y, pointerTarget.current.y, 0.08);
    97→
    98→    // Apply transforms to background element
    99→    // Original applied to headModel and roomGroup with these multipliers:
   100→    // headModel: x * 0.1, y * 0.03
   101→    // roomGroup: x * 0.08, y * 0.04
   102→    // Camera sway: x * baseZ * 0.02-0.06
   103→    if (backgroundRef.current) {
   104→      const isMobile = window.innerWidth <= 800;
   105→
   106→      // Rotation multipliers (from original)
   107→      const rotateX = pointer.current.y * (isMobile ? 2 : 3); // degrees
   108→      const rotateY = pointer.current.x * (isMobile ? 5 : 8); // degrees
   109→
   110→      // Translation multipliers (from original camera sway)
   111→      const translateX = pointer.current.x * (isMobile ? 10 : 20); // pixels
   112→      const translateY = pointer.current.y * (isMobile ? 5 : 15); // pixels
   113→
   114→      backgroundRef.current.style.transform = `
   115→        perspective(1000px)
   116→        translate(${translateX}px, ${translateY}px)
   117→        rotateX(${-rotateX}deg)
   118→        rotateY(${rotateY}deg)
   119→      `;
   120→    }
   121→
   122→    animationRef.current = requestAnimationFrame(animate);
   123→  }, [isVisible, isSectionVisible]);
   124→
   125→  // Set up event listeners and animation loop
   126→  useEffect(() => {
   127→    // Visibility change handler (from original)
   128→    const handleVisibilityChange = () => {
   129→      setIsVisible(!document.hidden);
   130→    };
   131→
   132→    // Intersection observer for section visibility (from original initSectionObserver)
   133→    const sectionObserver = new IntersectionObserver(
   134→      (entries) => {
   135→        for (const entry of entries) {
   136→          setIsSectionVisible(entry.isIntersecting);
   137→        }
   138→      },
   139→      { threshold: 0.1 }
   140→    );
   141→
   142→    // Add event listeners
   143→    window.addEventListener('pointermove', handlePointerMove);
   144→    window.addEventListener('pointerleave', handlePointerLeave);
   145→    document.addEventListener('visibilitychange', handleVisibilityChange);
   146→
   147→    // Observe this section
   148→    if (containerRef.current) {
   149→      sectionObserver.observe(containerRef.current);
   150→    }
   151→
   152→    // Start animation loop
   153→    animationRef.current = requestAnimationFrame(animate);
   154→
   155→    // Cleanup
   156→    return () => {
   157→      window.removeEventListener('pointermove', handlePointerMove);
   158→      window.removeEventListener('pointerleave', handlePointerLeave);
   159→      document.removeEventListener('visibilitychange', handleVisibilityChange);
   160→      sectionObserver.disconnect();
   161→
   162→      if (animationRef.current) {
   163→        cancelAnimationFrame(animationRef.current);
   164→      }
   165→    };
   166→  }, [handlePointerMove, handlePointerLeave, animate]);
   167→
   168→  return (
   169→    <div
   170→      ref={containerRef}
   171→      className={`hero-background-container relative overflow-hidden ${className}`}
   172→      style={{ minHeight: 'max(100vh, 720px)' }}
   173→    >
   174→      {/* Animated background layer */}
   175→      <div
   176→        ref={backgroundRef}
   177→        className="hero-background-layer absolute inset-0 will-change-transform"
   178→        style={{
   179→          transformStyle: 'preserve-3d',
   180→          backfaceVisibility: 'hidden',
   181→        }}
   182→      >
   183→        {/* Vignette overlay - exact gradients from original CSS */}
   184→        <div
   185→          className="vignette-overlay absolute inset-0 pointer-events-none z-[2]"
   186→          style={{
   187→            opacity: 0.8,
   188→            background: `
   189→              linear-gradient(to right, rgba(0, 0, 0, 0.65) 0%, rgba(0, 0, 0, 0.5) 20%, rgba(0, 0, 0, 0.35) 35%, transparent 55%),
   190→              linear-gradient(to top, #0d1117 0%, transparent 40%),
   191→              linear-gradient(to bottom, rgba(0, 0, 0, 0.2) 0%, transparent 30%),
   192→              radial-gradient(ellipse at 55% 50%, transparent 35%, rgba(0, 0, 0, 0.18) 60%, rgba(0, 0, 0, 0.35) 82%, rgba(0, 0, 0, 0.5) 100%)
   193→            `,
   194→          }}
   195→        />
   196→      </div>
   197→
   198→      {/* Content layer */}
   199→      <div className="relative z-10">{children}</div>
   200→    </div>
   201→  );
   202→}
   203→
   204→/**
   205→ * RotatingText component
   206→ * Implements the word rotation animation from the original site
   207→ *
   208→ * Original logic from animation.js:
   209→ * const rotatingWords = ['proportions', 'symmetry', 'harmony', 'ratios', 'measurements', 'balance'];
   210→ *
   211→ * if (t - lastWordChange > 2.5) {
   212→ *     currentWordIndex = (currentWordIndex + 1) % rotatingWords.length;
   213→ *     const textEl = document.getElementById('rotatingText');
   214→ *     if (textEl) {
   215→ *         textEl.style.opacity = '0';
   216→ *         textEl.style.transform = 'translateY(10px)';
   217→ *         setTimeout(() => {
   218→ *             textEl.textContent = rotatingWords[currentWordIndex];
   219→ *             textEl.style.opacity = '1';
   220→ *             textEl.style.transform = 'translateY(0)';
   221→ *         }, 300);
   222→ *     }
   223→ *     lastWordChange = t;
   224→ * }
   225→ */
   226→interface RotatingTextProps {
   227→  words?: string[];
   228→  interval?: number; // in milliseconds
   229→  className?: string;
   230→}
   231→
   232→export function RotatingText({
   233→  words = ['proportions', 'symmetry', 'harmony', 'ratios', 'measurements', 'balance'],
   234→  interval = 2500, // 2.5 seconds from original
   235→  className = '',
   236→}: RotatingTextProps) {
   237→  const [currentIndex, setCurrentIndex] = useState(0);
   238→  const [isAnimating, setIsAnimating] = useState(false);
   239→
   240→  useEffect(() => {
   241→    const timer = setInterval(() => {
   242→      setIsAnimating(true);
   243→
   244→      // After fade out (300ms), change word and fade in
   245→      setTimeout(() => {
   246→        setCurrentIndex((prev) => (prev + 1) % words.length);
   247→        setIsAnimating(false);
   248→      }, 300);
   249→    }, interval);
   250→
   251→    return () => clearInterval(timer);
   252→  }, [words.length, interval]);
   253→
   254→  return (
   255→    <span
   256→      className={`inline-block text-blue-400 ${className}`}
   257→      style={{
   258→        minWidth: '280px',
   259→        transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
   260→        opacity: isAnimating ? 0 : 1,
   261→        transform: isAnimating ? 'translateY(10px)' : 'translateY(0)',
   262→      }}
   263→    >
   264→      {words[currentIndex]}
   265→    </span>
   266→  );
   267→}
   268→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
