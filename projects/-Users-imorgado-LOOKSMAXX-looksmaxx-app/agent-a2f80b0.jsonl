{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":"Analyze and compare metric calculation mathematics (angles, distances, ratios) between LOOKSMAXX and FACEIQPAID.\n\n**Focus Areas:**\n\n1. **Angle Calculations**\n   - File: `src/lib/faceiq-parity/metricLandmarks.ts`\n   - Gonial angle, nasal angles, facial angles\n   - Arc tangent vs law of cosines\n   - Degree vs radian handling\n   - 3D projection handling (side profile)\n\n2. **Distance Calculations**\n   - Euclidean distance formula\n   - Pixel to millimeter conversion\n   - Perspective distortion correction\n   - Depth handling (2D from 3D)\n\n3. **Ratio Calculations**\n   - Facial width to height ratios\n   - Golden ratio implementations\n   - Proportional metrics\n   - Division by zero handling\n\n4. **Mathematical Precision**\n   - Floating point precision\n   - Rounding errors\n   - Landmark coordinate accuracy (sub-pixel)\n\n**Output:** Detailed comparison of metric calculation accuracy, identify mathematical errors or improvements."},"uuid":"64239182-d43c-4c5a-ac21-6d451a767025","timestamp":"2025-12-30T15:24:40.974Z"}
{"parentUuid":"64239182-d43c-4c5a-ac21-6d451a767025","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SWLmoFayzD4uTz2cyfb7hb","type":"message","role":"assistant","content":[{"type":"text","text":"I'll analyze the mathematical calculations across the LOOKSMAXX codebase, focusing on angles, distances, ratios, and precision handling."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":39787,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":39787,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd6x5mdVXMKFUUJZXyDg","type":"assistant","uuid":"3568e9fe-c52d-489c-bd72-b3e69b70df8f","timestamp":"2025-12-30T15:24:46.492Z"}
{"parentUuid":"3568e9fe-c52d-489c-bd72-b3e69b70df8f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SWLmoFayzD4uTz2cyfb7hb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GCPNJrth2dohkPgYHjCQjc","name":"Glob","input":{"pattern":"src/lib/**/*.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":39787,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":39787,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd6x5mdVXMKFUUJZXyDg","type":"assistant","uuid":"bd9c692f-e6eb-4fba-b827-57489ffe79cb","timestamp":"2025-12-30T15:24:46.885Z"}
{"parentUuid":"bd9c692f-e6eb-4fba-b827-57489ffe79cb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SWLmoFayzD4uTz2cyfb7hb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RkYFY5ZkQVsr7VvYnFjJca","name":"Glob","input":{"pattern":"src/lib/faceiq-parity/**/*.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":39787,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":39787,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd6x5mdVXMKFUUJZXyDg","type":"assistant","uuid":"0d10be2f-6dd8-40ba-a914-8f00030d0ac7","timestamp":"2025-12-30T15:24:47.178Z"}
{"parentUuid":"0d10be2f-6dd8-40ba-a914-8f00030d0ac7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RkYFY5ZkQVsr7VvYnFjJca","type":"tool_result","content":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/sideLandmarks.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/scoring.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/metricLandmarks.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/categoryScores.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/index.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/potential.ts"}]},"uuid":"287a53fc-2209-4630-b7f0-7397f0cd58aa","timestamp":"2025-12-30T15:24:47.671Z","toolUseResult":{"filenames":["/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/sideLandmarks.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/scoring.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/metricLandmarks.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/categoryScores.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/index.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/potential.ts"],"durationMs":449,"numFiles":6,"truncated":false}}
{"parentUuid":"287a53fc-2209-4630-b7f0-7397f0cd58aa","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GCPNJrth2dohkPgYHjCQjc","type":"tool_result","content":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/supplements.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/aiDescriptions.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/taxonomy.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/results/transformations.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/data/demographic-overrides.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/ffmi-calculator.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/region.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/severity.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/calculator.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/looksmax-scoring.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceDetectionService.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sideProfileDetection.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/psl-calculator.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/archetype-classifier.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/utils.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/types.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/harmony-scoring.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/bezier-curves.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/data/metric-configs.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/engine.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/hardmaxxing.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/softmaxxing.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/results/analysis.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/nonSurgical.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/insights-engine.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/types.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/rate-limit.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/shareResults.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/landmarkImages.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/index.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/exportReport.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/products.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/product-recommendations.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/daily-stack.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/product_db.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/api.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sample-data.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/sideLandmarks.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/landmarks.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/scoring.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/colors.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/metricLandmarks.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/categoryScores.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/index.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/trigger-rules.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/advice-engine.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sideProfileNormalization.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/potential.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/serverSideDetection.ts\n/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/mediapipeDetection.ts"}]},"uuid":"46a9e8d3-0990-4295-87b5-69538559697d","timestamp":"2025-12-30T15:24:47.677Z","toolUseResult":{"filenames":["/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/supplements.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/aiDescriptions.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/taxonomy.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/results/transformations.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/data/demographic-overrides.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/ffmi-calculator.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/region.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/severity.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/calculator.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/looksmax-scoring.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceDetectionService.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sideProfileDetection.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/psl-calculator.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/archetype-classifier.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/utils.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/types.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/harmony-scoring.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/bezier-curves.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/data/metric-configs.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/engine.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/hardmaxxing.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/softmaxxing.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/results/analysis.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/nonSurgical.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/insights-engine.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/types.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/rate-limit.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/shareResults.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/landmarkImages.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/index.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/exportReport.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/recommendations/products.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/product-recommendations.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/daily-stack.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/product_db.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/api.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sample-data.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/sideLandmarks.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/landmarks.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/scoring.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/colors.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/metricLandmarks.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/categoryScores.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/index.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/trigger-rules.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/advice-engine.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sideProfileNormalization.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/potential.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/serverSideDetection.ts","/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/mediapipeDetection.ts"],"durationMs":456,"numFiles":52,"truncated":false}}
{"parentUuid":"46a9e8d3-0990-4295-87b5-69538559697d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Y1DuvRi8gQurWeLT5q4P6Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UePY3Mg62fc4b1rbrvi1SP","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/metricLandmarks.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":248,"cache_creation_input_tokens":1816,"cache_read_input_tokens":39787,"cache_creation":{"ephemeral_5m_input_tokens":1816,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWd6xZo78bXjBTaTkzf8Q","type":"assistant","uuid":"fadee544-04be-4516-9093-93e4233d7fe0","timestamp":"2025-12-30T15:24:51.396Z"}
{"parentUuid":"fadee544-04be-4516-9093-93e4233d7fe0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Y1DuvRi8gQurWeLT5q4P6Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Eb7LsFTzA8N2o1d7e4fLvB","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/landmarks.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":248,"cache_creation_input_tokens":1816,"cache_read_input_tokens":39787,"cache_creation":{"ephemeral_5m_input_tokens":1816,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWd6xZo78bXjBTaTkzf8Q","type":"assistant","uuid":"58a6ab42-d6bf-4a3a-b5b3-c69e6494822c","timestamp":"2025-12-30T15:24:51.682Z"}
{"parentUuid":"58a6ab42-d6bf-4a3a-b5b3-c69e6494822c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Y1DuvRi8gQurWeLT5q4P6Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PcUZeoUujgWbPBjruGMwJ4","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/mediapipeDetection.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":248,"cache_creation_input_tokens":1816,"cache_read_input_tokens":39787,"cache_creation":{"ephemeral_5m_input_tokens":1816,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWd6xZo78bXjBTaTkzf8Q","type":"assistant","uuid":"99b4f828-02eb-45db-a260-6c59ba4fc4a7","timestamp":"2025-12-30T15:24:52.123Z"}
{"parentUuid":"99b4f828-02eb-45db-a260-6c59ba4fc4a7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Y1DuvRi8gQurWeLT5q4P6Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QsWVUYUz2JESvzSHVo67TF","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/serverSideDetection.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":248,"cache_creation_input_tokens":1816,"cache_read_input_tokens":39787,"cache_creation":{"ephemeral_5m_input_tokens":1816,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWd6xZo78bXjBTaTkzf8Q","type":"assistant","uuid":"6b031ab9-f9e6-4436-a3b0-da95013dc2c2","timestamp":"2025-12-30T15:24:52.638Z"}
{"parentUuid":"6b031ab9-f9e6-4436-a3b0-da95013dc2c2","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UePY3Mg62fc4b1rbrvi1SP","type":"tool_result","content":"     1→/**\n     2→ * FaceIQ Parity - Metric to Landmark Mappings\n     3→ *\n     4→ * Exact mappings of which landmarks are used for each facial metric.\n     5→ * Extracted from FaceIQ's codebase for 100% calculation parity.\n     6→ */\n     7→\n     8→/**\n     9→ * FRONT VIEW METRICS\n    10→ * Maps each front view ratio to the landmarks needed for its calculation\n    11→ */\n    12→export const FACEIQ_FRONT_METRIC_LANDMARKS: Record<string, string[]> = {\n    13→  // Face Shape & Proportions\n    14→  'Face Width to Height Ratio': [\n    15→    'cupidsBow', 'leftBrowHead', 'leftBrowInnerCorner', 'leftCheek',\n    16→    'rightBrowHead', 'rightBrowInnerCorner', 'rightCheek'\n    17→  ],\n    18→  'Total Facial Width to Height Ratio': [\n    19→    'chinBottom', 'hairline', 'leftCheek', 'rightCheek'\n    20→  ],\n    21→  'Bigonial width': [\n    22→    'leftCheek', 'leftTopGonion', 'rightCheek', 'rightTopGonion'\n    23→  ],\n    24→  'Bitemporal Width': [\n    25→    'leftCheek', 'leftTemple', 'rightCheek', 'rightTemple'\n    26→  ],\n    27→\n    28→  // Thirds & Proportions\n    29→  'Top Third': [\n    30→    'chinBottom', 'hairline', 'leftBrowHead', 'leftBrowInnerCorner',\n    31→    'noseBottom', 'rightBrowHead', 'rightBrowInnerCorner'\n    32→  ],\n    33→  'Middle Third': [\n    34→    'chinBottom', 'hairline', 'leftBrowHead', 'leftBrowInnerCorner',\n    35→    'noseBottom', 'rightBrowHead', 'rightBrowInnerCorner'\n    36→  ],\n    37→  'Lower Third': [\n    38→    'chinBottom', 'hairline', 'leftBrowHead', 'leftBrowInnerCorner',\n    39→    'noseBottom', 'rightBrowHead', 'rightBrowInnerCorner'\n    40→  ],\n    41→  'Lower Third Proportion': [\n    42→    'chinBottom', 'mouthMiddle', 'noseBottom'\n    43→  ],\n    44→\n    45→  // Eye Metrics\n    46→  'Eye Aspect Ratio': [\n    47→    'leftEyeLateralCanthus', 'leftEyeLowerEyelid', 'leftEyeMedialCanthus', 'leftEyeUpperEyelid',\n    48→    'rightEyeLateralCanthus', 'rightEyeLowerEyelid', 'rightEyeMedialCanthus', 'rightEyeUpperEyelid'\n    49→  ],\n    50→  'Eye Separation Ratio': [\n    51→    'leftCheek', 'leftEyePupil', 'rightCheek', 'rightEyePupil'\n    52→  ],\n    53→  'Lateral Canthal Tilt': [\n    54→    'leftBrowInnerCorner', 'leftEyeLateralCanthus', 'leftEyeLowerEyelid', 'leftEyeMedialCanthus', 'leftEyelidHoodEnd',\n    55→    'rightBrowInnerCorner', 'rightEyeLateralCanthus', 'rightEyeLowerEyelid', 'rightEyeMedialCanthus', 'rightEyelidHoodEnd'\n    56→  ],\n    57→  'Upper Eyelid Exposure': [\n    58→    'leftEyeLateralCanthus', 'leftEyeLowerEyelid', 'leftEyeMedialCanthus', 'leftEyeUpperEyelid', 'leftUpperEyelidCrease',\n    59→    'rightEyeLowerEyelid', 'rightEyeUpperEyelid', 'rightUpperEyelidCrease'\n    60→  ],\n    61→  'One Eye Apart Test': [\n    62→    'leftBrowInnerCorner', 'leftEyeLowerEyelid', 'leftEyeMedialCanthus', 'leftEyelidHoodEnd',\n    63→    'rightBrowInnerCorner', 'rightEyeLowerEyelid', 'rightEyeMedialCanthus', 'rightEyelidHoodEnd'\n    64→  ],\n    65→\n    66→  // Eyebrow Metrics\n    67→  'Brow Length to Face Width Ratio': [\n    68→    'leftBrowArch', 'leftBrowInnerCorner', 'leftBrowTail', 'leftCheek',\n    69→    'rightBrowArch', 'rightBrowInnerCorner', 'rightBrowTail', 'rightCheek'\n    70→  ],\n    71→  'Brow Thickness': [\n    72→    'leftBrowArch', 'leftBrowInnerCorner', 'leftBrowPeak', 'leftEyelidHoodEnd',\n    73→    'rightBrowArch', 'rightBrowInnerCorner', 'rightBrowPeak', 'rightEyelidHoodEnd'\n    74→  ],\n    75→  'Eyebrow Tilt': [\n    76→    'leftBrowArch', 'leftBrowHead', 'leftBrowInnerCorner', 'leftBrowPeak', 'leftEyeLowerEyelid', 'leftEyelidHoodEnd',\n    77→    'rightBrowArch', 'rightBrowHead', 'rightBrowInnerCorner', 'rightBrowPeak', 'rightEyeLowerEyelid', 'rightEyelidHoodEnd'\n    78→  ],\n    79→  'Eyebrow Low Setedness': [\n    80→    'leftBrowInnerCorner', 'leftEyeLowerEyelid', 'leftEyePupil', 'leftEyeUpperEyelid', 'leftEyelidHoodEnd',\n    81→    'rightBrowInnerCorner', 'rightEyeLowerEyelid', 'rightEyePupil', 'rightEyeUpperEyelid', 'rightEyelidHoodEnd'\n    82→  ],\n    83→\n    84→  // Cheekbone & Midface\n    85→  'Cheekbone height': [\n    86→    'cupidsBow', 'leftBrowInnerCorner', 'leftBrowPeak', 'leftCheek', 'leftEyePupil', 'lowerLip',\n    87→    'rightBrowInnerCorner', 'rightBrowPeak', 'rightCheek', 'rightEyePupil'\n    88→  ],\n    89→  'Midface Ratio': [\n    90→    'cupidsBow', 'leftEyePupil', 'rightEyePupil'\n    91→  ],\n    92→\n    93→  // Nose Metrics\n    94→  'Nose Bridge to Nose Width': [\n    95→    'leftNoseBridge', 'noseLeft', 'noseRight', 'rightNoseBridge'\n    96→  ],\n    97→  'Nose Tip Position': [\n    98→    'chinBottom', 'hairline', 'leftEyeLowerEyelid', 'nasalBase', 'noseBottom', 'noseLeft', 'noseRight', 'rightEyeLowerEyelid'\n    99→  ],\n   100→  'Intercanthal-Nasal Width Ratio': [\n   101→    'leftEyeMedialCanthus', 'noseBottom', 'noseLeft', 'noseRight', 'rightEyeMedialCanthus'\n   102→  ],\n   103→  'Ipsilateral Alar Angle': [\n   104→    'leftEyelidHoodEnd', 'noseBottom', 'rightEyelidHoodEnd'\n   105→  ],\n   106→\n   107→  // Mouth & Lips\n   108→  'Mouth width to nose width ratio': [\n   109→    'mouthLeft', 'mouthRight', 'noseLeft', 'noseRight'\n   110→  ],\n   111→  'Interpupillary-Mouth Width Ratio': [\n   112→    'leftEyePupil', 'lowerLip', 'mouthLeft', 'mouthRight', 'rightEyePupil'\n   113→  ],\n   114→  'Mouth Corner Position': [\n   115→    'chinBottom', 'hairline', 'mouthLeft', 'mouthMiddle', 'mouthRight'\n   116→  ],\n   117→  'Lip Thickness': [\n   118→    'chinBottom', 'cupidsBow', 'lowerLip', 'nasalBase'\n   119→  ],\n   120→  'Lower Lip to Upper Lip Ratio': [\n   121→    'cupidsBow', 'lowerLip', 'mouthLeft', 'mouthMiddle', 'mouthRight'\n   122→  ],\n   123→  \"Cupid's Bow Depth\": [\n   124→    'cupidsBow', 'innerCupidsBow', 'mouthLeft', 'mouthRight'\n   125→  ],\n   126→\n   127→  // Chin & Jaw\n   128→  'Chin to philtrum ratio': [\n   129→    'chinBottom', 'cupidsBow', 'lowerLip', 'nasalBase'\n   130→  ],\n   131→  'Jaw Frontal Angle': [\n   132→    'chinLeft', 'chinRight', 'leftBottomGonion', 'rightBottomGonion'\n   133→  ],\n   134→  'Jaw Slope': [\n   135→    'chinLeft', 'chinRight', 'leftBottomGonion', 'leftCheek', 'leftTopGonion',\n   136→    'rightBottomGonion', 'rightCheek', 'rightTopGonion'\n   137→  ],\n   138→  'Deviation of IAA(Ipsilateral alar angle) & JFA(Jaw frontal angle)': [\n   139→    'chinLeft', 'chinRight', 'leftBottomGonion', 'leftEyelidHoodEnd', 'noseBottom', 'rightBottomGonion', 'rightEyelidHoodEnd'\n   140→  ],\n   141→\n   142→  // Ear Metrics\n   143→  'Ear Protrusion Angle': [\n   144→    'leftCheek', 'leftOuterEar', 'mouthMiddle', 'rightCheek', 'rightOuterEar'\n   145→  ],\n   146→  'Ear Protrusion Ratio': [\n   147→    'leftCheek', 'leftOuterEar', 'rightCheek', 'rightOuterEar'\n   148→  ],\n   149→\n   150→  // Neck\n   151→  'Neck Width': [\n   152→    'leftTopGonion', 'neckLeft', 'neckRight', 'rightTopGonion'\n   153→  ],\n   154→};\n   155→\n   156→/**\n   157→ * SIDE VIEW METRICS\n   158→ * Maps each side view ratio to the landmarks needed for its calculation\n   159→ */\n   160→export const FACEIQ_SIDE_METRIC_LANDMARKS: Record<string, string[]> = {\n   161→  // Facial Depth & Projection\n   162→  'Anterior Facial Depth': [\n   163→    'lowerEyelid', 'subalare', 'tragus'\n   164→  ],\n   165→  'Facial Depth to Height Ratio': [\n   166→    'nasion', 'sublabiale', 'subnasale', 'tragus'\n   167→  ],\n   168→\n   169→  // Eye Metrics\n   170→  'Eye Protrusion': [\n   171→    'cornealApex', 'lowerEyelid', 'menton', 'trichion'\n   172→  ],\n   173→  'Orbital Vector': [\n   174→    'cornealApex', 'menton', 'orbitale', 'trichion'\n   175→  ],\n   176→\n   177→  // Forehead & Brow\n   178→  'Browridge Inclination Angle': [\n   179→    'glabella', 'trichion'\n   180→  ],\n   181→  'Upper Forehead Slope': [\n   182→    'forehead', 'glabella', 'trichion'\n   183→  ],\n   184→\n   185→  // Nasal Metrics\n   186→  'Nasal W to H ratio': [\n   187→    'cornealApex', 'pronasale', 'subalare'\n   188→  ],\n   189→  'Nasal Projection': [\n   190→    'nasion', 'pronasale', 'rhinion', 'subalare'\n   191→  ],\n   192→  'Nasal Tip Angle': [\n   193→    'infratip', 'pronasale', 'supratip'\n   194→  ],\n   195→  'Nasofrontal Angle': [\n   196→    'glabella', 'nasion', 'supratip'\n   197→  ],\n   198→  'Nasolabial Angle': [\n   199→    'columella', 'labraleSuperius', 'subnasale'\n   200→  ],\n   201→  'Nasofacial Angle': [\n   202→    'nasion', 'pogonion', 'pronasale'\n   203→  ],\n   204→  'Nasomental Angle': [\n   205→    'nasion', 'pogonion', 'pronasale'\n   206→  ],\n   207→  'Nose Tip Rotation Angle': [\n   208→    'columella', 'cornealApex', 'orbitale', 'porion', 'subnasale'\n   209→  ],\n   210→  'Frankfort-tip Angle': [\n   211→    'cornealApex', 'orbitale', 'porion', 'pronasale', 'subnasale'\n   212→  ],\n   213→\n   214→  // Convexity & Profile\n   215→  'Facial Convexity (Glabella)': [\n   216→    'glabella', 'pogonion', 'subnasale'\n   217→  ],\n   218→  'Facial Convexity (Nasion)': [\n   219→    'nasion', 'pogonion', 'subnasale'\n   220→  ],\n   221→  'Total Facial Convexity': [\n   222→    'glabella', 'pogonion', 'pronasale'\n   223→  ],\n   224→\n   225→  // Jaw & Mandible\n   226→  'Gonial Angle': [\n   227→    'gonionBottom', 'gonionTop', 'intertragicNotch', 'menton'\n   228→  ],\n   229→  'Mandibular Plane Angle': [\n   230→    'gonionBottom', 'gonionTop', 'menton', 'tragus'\n   231→  ],\n   232→  'Ramus to Mandible Ratio': [\n   233→    'gonionBottom', 'gonionTop', 'menton', 'pogonion', 'tragus'\n   234→  ],\n   235→  'Lower Jaw Prominence': [\n   236→    'gonionBottom', 'pogonion', 'tragus'\n   237→  ],\n   238→  'Upper Jaw Prominence': [\n   239→    'gonionBottom', 'subnasale', 'tragus'\n   240→  ],\n   241→\n   242→  // Midface\n   243→  'Interior Midface Projection Angle': [\n   244→    'eyelidEnd', 'subalare'\n   245→  ],\n   246→  'Midface Prominence': [\n   247→    'gonionBottom', 'orbitale', 'tragus'\n   248→  ],\n   249→\n   250→  // Lips & Profile Lines\n   251→  'Holdaway H Line': [\n   252→    'labraleInferius', 'labraleSuperius', 'menton', 'pogonion', 'trichion'\n   253→  ],\n   254→  'Upper Lip Burstone Line': [\n   255→    'labraleSuperius', 'menton', 'pogonion', 'subnasale', 'trichion'\n   256→  ],\n   257→  'Lower Lip Burstone Line': [\n   258→    'labraleInferius', 'menton', 'pogonion', 'subnasale', 'trichion'\n   259→  ],\n   260→  'Upper Lip E-Line Position': [\n   261→    'labraleSuperius', 'menton', 'pogonion', 'pronasale', 'trichion'\n   262→  ],\n   263→  'Lower Lip E-Line Position': [\n   264→    'labraleInferius', 'menton', 'pogonion', 'pronasale', 'trichion'\n   265→  ],\n   266→  'Upper Lip S-Line Position': [\n   267→    'labraleSuperius', 'menton', 'pogonion', 'pronasale', 'subnasale', 'trichion'\n   268→  ],\n   269→  'Lower Lip S-Line Position': [\n   270→    'labraleInferius', 'menton', 'pogonion', 'pronasale', 'subnasale', 'trichion'\n   271→  ],\n   272→  'Z Angle': [\n   273→    'labraleSuperius', 'orbitale', 'pogonion', 'porion'\n   274→  ],\n   275→  'Mentolabial Angle': [\n   276→    'labraleInferius', 'pogonion', 'sublabiale'\n   277→  ],\n   278→\n   279→  // Gonion & Mouth\n   280→  'Gonion to mouth line': [\n   281→    'cheilion', 'gonionBottom', 'gonionTop', 'menton', 'tragus', 'trichion'\n   282→  ],\n   283→\n   284→  // Neck\n   285→  'Submental Cervical Angle': [\n   286→    'cervicalPoint', 'menton', 'neckPoint'\n   287→  ],\n   288→\n   289→  // Recession Analysis\n   290→  'Recession relative to frankfort plane': [\n   291→    'glabella', 'menton', 'nasion', 'neckPoint', 'pogonion', 'pronasale', 'trichion'\n   292→  ],\n   293→};\n   294→\n   295→/**\n   296→ * Get landmarks for a metric by name\n   297→ */\n   298→export function getFaceIQMetricLandmarks(\n   299→  metricName: string,\n   300→  profileType: 'front' | 'side'\n   301→): string[] {\n   302→  const mappings = profileType === 'front'\n   303→    ? FACEIQ_FRONT_METRIC_LANDMARKS\n   304→    : FACEIQ_SIDE_METRIC_LANDMARKS;\n   305→\n   306→  return mappings[metricName] || [];\n   307→}\n   308→\n   309→/**\n   310→ * Get all metrics that use a specific landmark\n   311→ */\n   312→export function getMetricsUsingLandmark(\n   313→  landmarkId: string,\n   314→  profileType: 'front' | 'side'\n   315→): string[] {\n   316→  const mappings = profileType === 'front'\n   317→    ? FACEIQ_FRONT_METRIC_LANDMARKS\n   318→    : FACEIQ_SIDE_METRIC_LANDMARKS;\n   319→\n   320→  return Object.entries(mappings)\n   321→    .filter(([, landmarks]) => landmarks.includes(landmarkId))\n   322→    .map(([metricName]) => metricName);\n   323→}\n   324→\n   325→/**\n   326→ * Get all unique landmarks used in calculations\n   327→ */\n   328→export function getAllUsedLandmarks(profileType: 'front' | 'side'): string[] {\n   329→  const mappings = profileType === 'front'\n   330→    ? FACEIQ_FRONT_METRIC_LANDMARKS\n   331→    : FACEIQ_SIDE_METRIC_LANDMARKS;\n   332→\n   333→  const allLandmarks = new Set<string>();\n   334→  Object.values(mappings).forEach(landmarks => {\n   335→    landmarks.forEach(lm => allLandmarks.add(lm));\n   336→  });\n   337→\n   338→  return Array.from(allLandmarks).sort();\n   339→}\n   340→\n   341→/**\n   342→ * Front metric count\n   343→ */\n   344→export const FRONT_METRIC_COUNT = Object.keys(FACEIQ_FRONT_METRIC_LANDMARKS).length;\n   345→\n   346→/**\n   347→ * Side metric count\n   348→ */\n   349→export const SIDE_METRIC_COUNT = Object.keys(FACEIQ_SIDE_METRIC_LANDMARKS).length;\n   350→\n\n</system-reminder>\n"}]},"uuid":"02faa0d0-e06d-4ff9-8be1-e479d364acaf","timestamp":"2025-12-30T15:24:52.683Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/metricLandmarks.ts","content":"/**\n * FaceIQ Parity - Metric to Landmark Mappings\n *\n * Exact mappings of which landmarks are used for each facial metric.\n * Extracted from FaceIQ's codebase for 100% calculation parity.\n */\n\n/**\n * FRONT VIEW METRICS\n * Maps each front view ratio to the landmarks needed for its calculation\n */\nexport const FACEIQ_FRONT_METRIC_LANDMARKS: Record<string, string[]> = {\n  // Face Shape & Proportions\n  'Face Width to Height Ratio': [\n    'cupidsBow', 'leftBrowHead', 'leftBrowInnerCorner', 'leftCheek',\n    'rightBrowHead', 'rightBrowInnerCorner', 'rightCheek'\n  ],\n  'Total Facial Width to Height Ratio': [\n    'chinBottom', 'hairline', 'leftCheek', 'rightCheek'\n  ],\n  'Bigonial width': [\n    'leftCheek', 'leftTopGonion', 'rightCheek', 'rightTopGonion'\n  ],\n  'Bitemporal Width': [\n    'leftCheek', 'leftTemple', 'rightCheek', 'rightTemple'\n  ],\n\n  // Thirds & Proportions\n  'Top Third': [\n    'chinBottom', 'hairline', 'leftBrowHead', 'leftBrowInnerCorner',\n    'noseBottom', 'rightBrowHead', 'rightBrowInnerCorner'\n  ],\n  'Middle Third': [\n    'chinBottom', 'hairline', 'leftBrowHead', 'leftBrowInnerCorner',\n    'noseBottom', 'rightBrowHead', 'rightBrowInnerCorner'\n  ],\n  'Lower Third': [\n    'chinBottom', 'hairline', 'leftBrowHead', 'leftBrowInnerCorner',\n    'noseBottom', 'rightBrowHead', 'rightBrowInnerCorner'\n  ],\n  'Lower Third Proportion': [\n    'chinBottom', 'mouthMiddle', 'noseBottom'\n  ],\n\n  // Eye Metrics\n  'Eye Aspect Ratio': [\n    'leftEyeLateralCanthus', 'leftEyeLowerEyelid', 'leftEyeMedialCanthus', 'leftEyeUpperEyelid',\n    'rightEyeLateralCanthus', 'rightEyeLowerEyelid', 'rightEyeMedialCanthus', 'rightEyeUpperEyelid'\n  ],\n  'Eye Separation Ratio': [\n    'leftCheek', 'leftEyePupil', 'rightCheek', 'rightEyePupil'\n  ],\n  'Lateral Canthal Tilt': [\n    'leftBrowInnerCorner', 'leftEyeLateralCanthus', 'leftEyeLowerEyelid', 'leftEyeMedialCanthus', 'leftEyelidHoodEnd',\n    'rightBrowInnerCorner', 'rightEyeLateralCanthus', 'rightEyeLowerEyelid', 'rightEyeMedialCanthus', 'rightEyelidHoodEnd'\n  ],\n  'Upper Eyelid Exposure': [\n    'leftEyeLateralCanthus', 'leftEyeLowerEyelid', 'leftEyeMedialCanthus', 'leftEyeUpperEyelid', 'leftUpperEyelidCrease',\n    'rightEyeLowerEyelid', 'rightEyeUpperEyelid', 'rightUpperEyelidCrease'\n  ],\n  'One Eye Apart Test': [\n    'leftBrowInnerCorner', 'leftEyeLowerEyelid', 'leftEyeMedialCanthus', 'leftEyelidHoodEnd',\n    'rightBrowInnerCorner', 'rightEyeLowerEyelid', 'rightEyeMedialCanthus', 'rightEyelidHoodEnd'\n  ],\n\n  // Eyebrow Metrics\n  'Brow Length to Face Width Ratio': [\n    'leftBrowArch', 'leftBrowInnerCorner', 'leftBrowTail', 'leftCheek',\n    'rightBrowArch', 'rightBrowInnerCorner', 'rightBrowTail', 'rightCheek'\n  ],\n  'Brow Thickness': [\n    'leftBrowArch', 'leftBrowInnerCorner', 'leftBrowPeak', 'leftEyelidHoodEnd',\n    'rightBrowArch', 'rightBrowInnerCorner', 'rightBrowPeak', 'rightEyelidHoodEnd'\n  ],\n  'Eyebrow Tilt': [\n    'leftBrowArch', 'leftBrowHead', 'leftBrowInnerCorner', 'leftBrowPeak', 'leftEyeLowerEyelid', 'leftEyelidHoodEnd',\n    'rightBrowArch', 'rightBrowHead', 'rightBrowInnerCorner', 'rightBrowPeak', 'rightEyeLowerEyelid', 'rightEyelidHoodEnd'\n  ],\n  'Eyebrow Low Setedness': [\n    'leftBrowInnerCorner', 'leftEyeLowerEyelid', 'leftEyePupil', 'leftEyeUpperEyelid', 'leftEyelidHoodEnd',\n    'rightBrowInnerCorner', 'rightEyeLowerEyelid', 'rightEyePupil', 'rightEyeUpperEyelid', 'rightEyelidHoodEnd'\n  ],\n\n  // Cheekbone & Midface\n  'Cheekbone height': [\n    'cupidsBow', 'leftBrowInnerCorner', 'leftBrowPeak', 'leftCheek', 'leftEyePupil', 'lowerLip',\n    'rightBrowInnerCorner', 'rightBrowPeak', 'rightCheek', 'rightEyePupil'\n  ],\n  'Midface Ratio': [\n    'cupidsBow', 'leftEyePupil', 'rightEyePupil'\n  ],\n\n  // Nose Metrics\n  'Nose Bridge to Nose Width': [\n    'leftNoseBridge', 'noseLeft', 'noseRight', 'rightNoseBridge'\n  ],\n  'Nose Tip Position': [\n    'chinBottom', 'hairline', 'leftEyeLowerEyelid', 'nasalBase', 'noseBottom', 'noseLeft', 'noseRight', 'rightEyeLowerEyelid'\n  ],\n  'Intercanthal-Nasal Width Ratio': [\n    'leftEyeMedialCanthus', 'noseBottom', 'noseLeft', 'noseRight', 'rightEyeMedialCanthus'\n  ],\n  'Ipsilateral Alar Angle': [\n    'leftEyelidHoodEnd', 'noseBottom', 'rightEyelidHoodEnd'\n  ],\n\n  // Mouth & Lips\n  'Mouth width to nose width ratio': [\n    'mouthLeft', 'mouthRight', 'noseLeft', 'noseRight'\n  ],\n  'Interpupillary-Mouth Width Ratio': [\n    'leftEyePupil', 'lowerLip', 'mouthLeft', 'mouthRight', 'rightEyePupil'\n  ],\n  'Mouth Corner Position': [\n    'chinBottom', 'hairline', 'mouthLeft', 'mouthMiddle', 'mouthRight'\n  ],\n  'Lip Thickness': [\n    'chinBottom', 'cupidsBow', 'lowerLip', 'nasalBase'\n  ],\n  'Lower Lip to Upper Lip Ratio': [\n    'cupidsBow', 'lowerLip', 'mouthLeft', 'mouthMiddle', 'mouthRight'\n  ],\n  \"Cupid's Bow Depth\": [\n    'cupidsBow', 'innerCupidsBow', 'mouthLeft', 'mouthRight'\n  ],\n\n  // Chin & Jaw\n  'Chin to philtrum ratio': [\n    'chinBottom', 'cupidsBow', 'lowerLip', 'nasalBase'\n  ],\n  'Jaw Frontal Angle': [\n    'chinLeft', 'chinRight', 'leftBottomGonion', 'rightBottomGonion'\n  ],\n  'Jaw Slope': [\n    'chinLeft', 'chinRight', 'leftBottomGonion', 'leftCheek', 'leftTopGonion',\n    'rightBottomGonion', 'rightCheek', 'rightTopGonion'\n  ],\n  'Deviation of IAA(Ipsilateral alar angle) & JFA(Jaw frontal angle)': [\n    'chinLeft', 'chinRight', 'leftBottomGonion', 'leftEyelidHoodEnd', 'noseBottom', 'rightBottomGonion', 'rightEyelidHoodEnd'\n  ],\n\n  // Ear Metrics\n  'Ear Protrusion Angle': [\n    'leftCheek', 'leftOuterEar', 'mouthMiddle', 'rightCheek', 'rightOuterEar'\n  ],\n  'Ear Protrusion Ratio': [\n    'leftCheek', 'leftOuterEar', 'rightCheek', 'rightOuterEar'\n  ],\n\n  // Neck\n  'Neck Width': [\n    'leftTopGonion', 'neckLeft', 'neckRight', 'rightTopGonion'\n  ],\n};\n\n/**\n * SIDE VIEW METRICS\n * Maps each side view ratio to the landmarks needed for its calculation\n */\nexport const FACEIQ_SIDE_METRIC_LANDMARKS: Record<string, string[]> = {\n  // Facial Depth & Projection\n  'Anterior Facial Depth': [\n    'lowerEyelid', 'subalare', 'tragus'\n  ],\n  'Facial Depth to Height Ratio': [\n    'nasion', 'sublabiale', 'subnasale', 'tragus'\n  ],\n\n  // Eye Metrics\n  'Eye Protrusion': [\n    'cornealApex', 'lowerEyelid', 'menton', 'trichion'\n  ],\n  'Orbital Vector': [\n    'cornealApex', 'menton', 'orbitale', 'trichion'\n  ],\n\n  // Forehead & Brow\n  'Browridge Inclination Angle': [\n    'glabella', 'trichion'\n  ],\n  'Upper Forehead Slope': [\n    'forehead', 'glabella', 'trichion'\n  ],\n\n  // Nasal Metrics\n  'Nasal W to H ratio': [\n    'cornealApex', 'pronasale', 'subalare'\n  ],\n  'Nasal Projection': [\n    'nasion', 'pronasale', 'rhinion', 'subalare'\n  ],\n  'Nasal Tip Angle': [\n    'infratip', 'pronasale', 'supratip'\n  ],\n  'Nasofrontal Angle': [\n    'glabella', 'nasion', 'supratip'\n  ],\n  'Nasolabial Angle': [\n    'columella', 'labraleSuperius', 'subnasale'\n  ],\n  'Nasofacial Angle': [\n    'nasion', 'pogonion', 'pronasale'\n  ],\n  'Nasomental Angle': [\n    'nasion', 'pogonion', 'pronasale'\n  ],\n  'Nose Tip Rotation Angle': [\n    'columella', 'cornealApex', 'orbitale', 'porion', 'subnasale'\n  ],\n  'Frankfort-tip Angle': [\n    'cornealApex', 'orbitale', 'porion', 'pronasale', 'subnasale'\n  ],\n\n  // Convexity & Profile\n  'Facial Convexity (Glabella)': [\n    'glabella', 'pogonion', 'subnasale'\n  ],\n  'Facial Convexity (Nasion)': [\n    'nasion', 'pogonion', 'subnasale'\n  ],\n  'Total Facial Convexity': [\n    'glabella', 'pogonion', 'pronasale'\n  ],\n\n  // Jaw & Mandible\n  'Gonial Angle': [\n    'gonionBottom', 'gonionTop', 'intertragicNotch', 'menton'\n  ],\n  'Mandibular Plane Angle': [\n    'gonionBottom', 'gonionTop', 'menton', 'tragus'\n  ],\n  'Ramus to Mandible Ratio': [\n    'gonionBottom', 'gonionTop', 'menton', 'pogonion', 'tragus'\n  ],\n  'Lower Jaw Prominence': [\n    'gonionBottom', 'pogonion', 'tragus'\n  ],\n  'Upper Jaw Prominence': [\n    'gonionBottom', 'subnasale', 'tragus'\n  ],\n\n  // Midface\n  'Interior Midface Projection Angle': [\n    'eyelidEnd', 'subalare'\n  ],\n  'Midface Prominence': [\n    'gonionBottom', 'orbitale', 'tragus'\n  ],\n\n  // Lips & Profile Lines\n  'Holdaway H Line': [\n    'labraleInferius', 'labraleSuperius', 'menton', 'pogonion', 'trichion'\n  ],\n  'Upper Lip Burstone Line': [\n    'labraleSuperius', 'menton', 'pogonion', 'subnasale', 'trichion'\n  ],\n  'Lower Lip Burstone Line': [\n    'labraleInferius', 'menton', 'pogonion', 'subnasale', 'trichion'\n  ],\n  'Upper Lip E-Line Position': [\n    'labraleSuperius', 'menton', 'pogonion', 'pronasale', 'trichion'\n  ],\n  'Lower Lip E-Line Position': [\n    'labraleInferius', 'menton', 'pogonion', 'pronasale', 'trichion'\n  ],\n  'Upper Lip S-Line Position': [\n    'labraleSuperius', 'menton', 'pogonion', 'pronasale', 'subnasale', 'trichion'\n  ],\n  'Lower Lip S-Line Position': [\n    'labraleInferius', 'menton', 'pogonion', 'pronasale', 'subnasale', 'trichion'\n  ],\n  'Z Angle': [\n    'labraleSuperius', 'orbitale', 'pogonion', 'porion'\n  ],\n  'Mentolabial Angle': [\n    'labraleInferius', 'pogonion', 'sublabiale'\n  ],\n\n  // Gonion & Mouth\n  'Gonion to mouth line': [\n    'cheilion', 'gonionBottom', 'gonionTop', 'menton', 'tragus', 'trichion'\n  ],\n\n  // Neck\n  'Submental Cervical Angle': [\n    'cervicalPoint', 'menton', 'neckPoint'\n  ],\n\n  // Recession Analysis\n  'Recession relative to frankfort plane': [\n    'glabella', 'menton', 'nasion', 'neckPoint', 'pogonion', 'pronasale', 'trichion'\n  ],\n};\n\n/**\n * Get landmarks for a metric by name\n */\nexport function getFaceIQMetricLandmarks(\n  metricName: string,\n  profileType: 'front' | 'side'\n): string[] {\n  const mappings = profileType === 'front'\n    ? FACEIQ_FRONT_METRIC_LANDMARKS\n    : FACEIQ_SIDE_METRIC_LANDMARKS;\n\n  return mappings[metricName] || [];\n}\n\n/**\n * Get all metrics that use a specific landmark\n */\nexport function getMetricsUsingLandmark(\n  landmarkId: string,\n  profileType: 'front' | 'side'\n): string[] {\n  const mappings = profileType === 'front'\n    ? FACEIQ_FRONT_METRIC_LANDMARKS\n    : FACEIQ_SIDE_METRIC_LANDMARKS;\n\n  return Object.entries(mappings)\n    .filter(([, landmarks]) => landmarks.includes(landmarkId))\n    .map(([metricName]) => metricName);\n}\n\n/**\n * Get all unique landmarks used in calculations\n */\nexport function getAllUsedLandmarks(profileType: 'front' | 'side'): string[] {\n  const mappings = profileType === 'front'\n    ? FACEIQ_FRONT_METRIC_LANDMARKS\n    : FACEIQ_SIDE_METRIC_LANDMARKS;\n\n  const allLandmarks = new Set<string>();\n  Object.values(mappings).forEach(landmarks => {\n    landmarks.forEach(lm => allLandmarks.add(lm));\n  });\n\n  return Array.from(allLandmarks).sort();\n}\n\n/**\n * Front metric count\n */\nexport const FRONT_METRIC_COUNT = Object.keys(FACEIQ_FRONT_METRIC_LANDMARKS).length;\n\n/**\n * Side metric count\n */\nexport const SIDE_METRIC_COUNT = Object.keys(FACEIQ_SIDE_METRIC_LANDMARKS).length;\n","numLines":350,"startLine":1,"totalLines":350}}}
{"parentUuid":"02faa0d0-e06d-4ff9-8be1-e479d364acaf","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PcUZeoUujgWbPBjruGMwJ4","type":"tool_result","content":"     1→/**\n     2→ * Face Landmark Detection using MediaPipe Tasks Vision\n     3→ * Maps detected landmarks to our custom facial landmarks\n     4→ *\n     5→ * Detection hierarchy:\n     6→ * - Front profile: MediaPipe Face Mesh (478 landmarks)\n     7→ * - Side profile: Server-side InsightFace (106 landmarks) → Edge-based fallback\n     8→ */\n     9→\n    10→import { faceDetectionService } from './faceDetectionService';\n    11→import { detectSideProfile } from './sideProfileDetection';\n    12→import { detectSideProfileServer } from './serverSideDetection';\n    13→import { applyFaceIQCorrection, applyFrankfortCorrection, rotateImageFaceIQ } from './sideProfileNormalization';\n    14→\n    15→// MediaPipe Face Mesh landmark indices (478 landmarks total)\n    16→// Reference: https://github.com/google/mediapipe/blob/master/mediapipe/modules/face_geometry/data/canonical_face_model_uv_visualization.png\n    17→\n    18→// Front profile landmark mapping\n    19→// Based on the reference website's exact MediaPipe indices\n    20→// Uses SUBJECT's perspective: \"left\" = subject's left (appears on RIGHT side of image)\n    21→export const MEDIAPIPE_FRONT_MAPPING: Record<string, number> = {\n    22→  // Head\n    23→  // Note: MediaPipe 10 is the forehead/glabella, not actual hairline\n    24→  // We apply a Y offset during mapping to estimate the hairline position\n    25→  trichion: 10, // hairline (requires Y offset - see TRICHION_Y_OFFSET)\n    26→\n    27→  // Left Eye (subject's LEFT eye - appears on RIGHT of image)\n    28→  left_pupila: 468,\n    29→  left_canthus_medialis: 133,\n    30→  left_canthus_lateralis: 33,\n    31→  left_palpebra_superior: 470,\n    32→  left_palpebra_inferior: 472,\n    33→  left_sulcus_palpebralis_lateralis: 247,\n    34→  left_pretarsal_skin_crease: 470,\n    35→\n    36→  // Right Eye (subject's RIGHT eye - appears on LEFT of image)\n    37→  right_pupila: 473,\n    38→  right_canthus_medialis: 362,\n    39→  right_canthus_lateralis: 263,\n    40→  right_palpebra_superior: 475,\n    41→  right_palpebra_inferior: 374,\n    42→  right_sulcus_palpebralis_lateralis: 467,\n    43→  right_pretarsal_skin_crease: 475,\n    44→\n    45→  // Left Brow (subject's LEFT brow - appears on RIGHT of image)\n    46→  left_supercilium_medialis: 107,\n    47→  left_supercilium_medial_corner: 55,\n    48→  left_supercilium_superior: 52,\n    49→  left_supercilium_apex: 105,\n    50→  left_supercilium_lateralis: 70,\n    51→\n    52→  // Right Brow (subject's RIGHT brow - appears on LEFT of image)\n    53→  right_supercilium_medialis: 336,\n    54→  right_supercilium_medial_corner: 285,\n    55→  right_supercilium_superior: 282,\n    56→  right_supercilium_apex: 334,\n    57→  right_supercilium_lateralis: 276,\n    58→\n    59→  // Nose\n    60→  nasal_base: 290, // Base of nose (per landmarkers.js)\n    61→  left_dorsum_nasi: 174,\n    62→  right_dorsum_nasi: 399,\n    63→  left_ala_nasi: 48,\n    64→  right_ala_nasi: 278,\n    65→  subnasale: 2, // noseBottom in landmarkers.js\n    66→  nasion: 6, // Added for correct FWHR calculation\n    67→  glabella: 9, // Added for reference\n    68→\n    69→  // Mouth\n    70→  labrale_superius: 267, // cupidsBow - peak of cupid's bow\n    71→  cupids_bow: 0, // innerCupidsBow - center dip of upper lip\n    72→  mouth_middle: 14,\n    73→  labrale_inferius: 17,\n    74→  left_cheilion: 61,\n    75→  right_cheilion: 306,\n    76→\n    77→  // Jaw\n    78→  left_gonion_superior: 58,\n    79→  right_gonion_superior: 288,\n    80→  left_gonion_inferior: 172,\n    81→  right_gonion_inferior: 397,\n    82→\n    83→  // Chin\n    84→  left_mentum_lateralis: 176,\n    85→  right_mentum_lateralis: 400,\n    86→  menton: 152,\n    87→\n    88→  // Cheeks\n    89→  left_zygion: 234,\n    90→  right_zygion: 454,\n    91→  left_malar: 205,        // Cheek center point for fullness calculation\n    92→  right_malar: 425,       // Cheek center point for fullness calculation\n    93→  left_temporal: 54,\n    94→  right_temporal: 284,\n    95→\n    96→  // Ears\n    97→  left_auricular_lateral: 127,\n    98→  right_auricular_lateral: 356,\n    99→\n   100→  // Neck (same as bottom gonion indices, but apply +5% yOffset when rendering)\n   101→  // Per landmarkers.js: neckLeft: 172 with yOffset: 0.05, neckRight: 397 with yOffset: 0.05\n   102→  left_cervical_lateralis: 172,\n   103→  right_cervical_lateralis: 397,\n   104→};\n   105→\n   106→// ============================================\n   107→// DEPTH VARIANCE RESULT INTERFACE\n   108→// ============================================\n   109→\n   110→export interface DepthVarianceResult {\n   111→  isValid: boolean;\n   112→  confidence: number;\n   113→  depthSpread: number;        // Horizontal distance from nose to ear (0-1 normalized)\n   114→  nosalProjection: number;    // How much the nose projects forward\n   115→  frankfortDeviation: number; // Degrees deviation from horizontal\n   116→  issues: string[];           // List of validation issues\n   117→}\n   118→\n   119→// Side profile landmark mapping (IDs must match SIDE_PROFILE_LANDMARKS in landmarks.ts)\n   120→// Matches 28 side profile landmarks exactly\n   121→// For side profile photos, uses MediaPipe LEFT indices (appearing on left side of image)\n   122→// Note: Server uses a custom server-side model for side detection; this is our MediaPipe fallback\n   123→export const MEDIAPIPE_SIDE_MAPPING: Record<string, number> = {\n   124→  // 1. vertex - top of head\n   125→  vertex: 10,\n   126→  // 2. occiput - back of head (no good MediaPipe equivalent, use top)\n   127→  occiput: 10,\n   128→  // 3. pronasale - nose tip\n   129→  pronasale: 1,\n   130→  // 4. neckPoint - lower neck (no good equivalent, use chin)\n   131→  neckPoint: 152,\n   132→  // 5. porion - ear canal opening (use ear area)\n   133→  porion: 127,\n   134→  // 6. orbitale - lowest point of orbital rim (index 33 per cephalometric landmarkers.js)\n   135→  orbitale: 33,\n   136→  // 7. tragus - ear cartilage\n   137→  tragus: 127,\n   138→  // 8. intertragicNotch - notch in ear\n   139→  intertragicNotch: 127,\n   140→  // 9. cornealApex - forward point of cornea\n   141→  cornealApex: 468,\n   142→  // 10. cheekbone - zygomatic prominence\n   143→  cheekbone: 234,\n   144→  // 11. trichion - hairline\n   145→  trichion: 10,\n   146→  // 12. glabella - between brows\n   147→  glabella: 9,\n   148→  // 13. nasion - nasal root depression\n   149→  nasion: 6,\n   150→  // 14. rhinion - dorsal nose point\n   151→  rhinion: 4,\n   152→  // 15. supratip - above nose tip\n   153→  supratip: 4,\n   154→  // 16. infratip - below nose tip\n   155→  infratip: 2,\n   156→  // 17. columella - nasal septum\n   157→  columella: 2,\n   158→  // 18. subnasale - nose base meets upper lip\n   159→  subnasale: 2,\n   160→  // 19. subalare - nostril wing\n   161→  subalare: 129,\n   162→  // 20. labraleSuperius - upper lip\n   163→  labraleSuperius: 0,\n   164→  // 21. cheilion - mouth corner\n   165→  cheilion: 61,\n   166→  // 22. labraleInferius - lower lip\n   167→  labraleInferius: 17,\n   168→  // 23. sublabiale - below lower lip\n   169→  sublabiale: 18,\n   170→  // 24. pogonion - chin point\n   171→  pogonion: 152,\n   172→  // 25. menton - chin bottom\n   173→  menton: 152,\n   174→  // 26. cervicalPoint - high neck point\n   175→  cervicalPoint: 152,\n   176→  // 27. gonionTop - upper jaw angle\n   177→  gonionTop: 116,\n   178→  // 28. gonionBottom - lower jaw angle\n   179→  gonionBottom: 172,\n   180→};\n   181→\n   182→export interface DetectedLandmarks {\n   183→  landmarks: Array<{ id: string; x: number; y: number }>;\n   184→  confidence: number;\n   185→  faceBox: { x: number; y: number; width: number; height: number };\n   186→  frankfortPlane?: {\n   187→    angle: number;\n   188→    orbitale: { x: number; y: number };\n   189→    porion: { x: number; y: number };\n   190→  };\n   191→  depthValidation?: DepthVarianceResult;\n   192→  /** Rotated image URL for FaceIQ parity (side profiles only) */\n   193→  rotatedImageUrl?: string;\n   194→}\n   195→\n   196→/**\n   197→ * Detect facial landmarks from an image URL\n   198→ *\n   199→ * Detection hierarchy:\n   200→ * - Front profile: MediaPipe Face Mesh (478 landmarks) - unchanged\n   201→ * - Side profile: Server-side InsightFace → Edge-based fallback → Manual placement\n   202→ */\n   203→export async function detectFromImageUrl(\n   204→  imageUrl: string,\n   205→  mode: 'front' | 'side'\n   206→): Promise<DetectedLandmarks | null> {\n   207→  try {\n   208→    // ============================================\n   209→    // SIDE PROFILE: Use server-side detection\n   210→    // ============================================\n   211→    if (mode === 'side') {\n   212→      console.log('[Detection] Side profile mode - trying server-side detection...');\n   213→\n   214→      // Try server-side InsightFace first (best accuracy)\n   215→      const serverResult = await detectSideProfileServer(imageUrl);\n   216→      if (serverResult) {\n   217→        console.log('[Detection] Server-side detection succeeded');\n   218→\n   219→        // Validate side profile depth variance\n   220→        const depthValidation = validateSideProfileDepth(\n   221→          serverResult.landmarks,\n   222→          serverResult.frankfortPlane\n   223→        );\n   224→        console.log('[Detection] Depth validation:', {\n   225→          isValid: depthValidation.isValid,\n   226→          confidence: depthValidation.confidence.toFixed(2),\n   227→          depthSpread: (depthValidation.depthSpread * 100).toFixed(1) + '%',\n   228→          issues: depthValidation.issues,\n   229→        });\n   230→\n   231→        // FaceIQ PARITY FIX: Apply rotation in pixel space FIRST, then normalize to 0-1\n   232→        // Step 1: Rotate landmarks using FaceIQ algorithm (in pixel coordinates)\n   233→        const rotatedLandmarks = applyFaceIQCorrection(\n   234→          serverResult.landmarks,\n   235→          serverResult.rawLandmarks,\n   236→          serverResult.direction\n   237→        );\n   238→        console.log('[Detection] Applied FaceIQ correction, direction:',\n   239→          serverResult.direction || 'N/A');\n   240→\n   241→        // Step 2: Rotate image to match rotated landmarks (FaceIQ parity)\n   242→        const rotatedImageUrl = await rotateImageFaceIQ(\n   243→          imageUrl,\n   244→          serverResult.rawLandmarks!,\n   245→          serverResult.direction!,\n   246→          serverResult.faceBox\n   247→        );\n   248→        console.log('[Detection] Rotated image to match FaceIQ-normalized landmarks');\n   249→\n   250→        // Step 3: Normalize to 0-1 range AFTER rotation\n   251→        const { width, height } = serverResult.imageDimensions;\n   252→        const normalizedLandmarks = rotatedLandmarks.map(lm => ({\n   253→          id: lm.id,\n   254→          x: Math.max(0, Math.min(1, lm.x / width)),\n   255→          y: Math.max(0, Math.min(1, lm.y / height)),\n   256→        }));\n   257→        console.log('[Detection] Normalized landmarks to 0-1 range after rotation');\n   258→\n   259→        // Step 3: Normalize Frankfort plane coordinates (for display only)\n   260→        const normalizedFrankfortPlane = serverResult.frankfortPlane ? {\n   261→          angle: serverResult.frankfortPlane.angle,\n   262→          orbitale: {\n   263→            x: Math.max(0, Math.min(1, serverResult.frankfortPlane.orbitale.x / width)),\n   264→            y: Math.max(0, Math.min(1, serverResult.frankfortPlane.orbitale.y / height)),\n   265→          },\n   266→          porion: {\n   267→            x: Math.max(0, Math.min(1, serverResult.frankfortPlane.porion.x / width)),\n   268→            y: Math.max(0, Math.min(1, serverResult.frankfortPlane.porion.y / height)),\n   269→          },\n   270→        } : undefined;\n   271→\n   272→        return {\n   273→          landmarks: normalizedLandmarks,\n   274→          confidence: serverResult.confidence,\n   275→          faceBox: serverResult.faceBox,\n   276→          frankfortPlane: normalizedFrankfortPlane,\n   277→          depthValidation,\n   278→          rotatedImageUrl, // FaceIQ parity: rotated image matches rotated landmarks\n   279→        };\n   280→      }\n   281→\n   282→      console.log('[Detection] Server-side failed, trying edge-based detection...');\n   283→\n   284→      // Fallback to edge-based detection\n   285→      const sideResult = await detectSideProfile(imageUrl);\n   286→      if (sideResult) {\n   287→        console.log('[Detection] Edge-based side profile detection succeeded');\n   288→\n   289→        // Validate side profile depth variance\n   290→        const depthValidation = validateSideProfileDepth(sideResult.landmarks);\n   291→        console.log('[Detection] Depth validation (edge-based):', {\n   292→          isValid: depthValidation.isValid,\n   293→          confidence: depthValidation.confidence.toFixed(2),\n   294→          issues: depthValidation.issues,\n   295→        });\n   296→\n   297→        // Apply Frankfort correction (edge-based doesn't have pre-calculated plane)\n   298→        const normalizedLandmarks = applyFrankfortCorrection(sideResult.landmarks);\n   299→        console.log('[Detection] Applied Frankfort correction to edge-based result');\n   300→\n   301→        return {\n   302→          landmarks: normalizedLandmarks,\n   303→          confidence: sideResult.confidence,\n   304→          faceBox: {\n   305→            x: 0,\n   306→            y: 0,\n   307→            width: 1,\n   308→            height: 1,\n   309→          },\n   310→          depthValidation,\n   311→        };\n   312→      }\n   313→\n   314→      console.log('[Detection] All side profile detection methods failed - manual placement required');\n   315→      return null;\n   316→    }\n   317→\n   318→    // ============================================\n   319→    // FRONT PROFILE: Use MediaPipe (UNCHANGED)\n   320→    // ============================================\n   321→    // Load the image\n   322→    const img = await loadImage(imageUrl);\n   323→\n   324→    // Use the singleton service\n   325→    const result = await faceDetectionService.detect(img);\n   326→\n   327→    // Check if MediaPipe detected a face\n   328→    const mediaPipeSucceeded = result.faceLandmarks && result.faceLandmarks.length > 0;\n   329→\n   330→    if (!mediaPipeSucceeded) {\n   331→      console.log('No faces detected');\n   332→      return null;\n   333→    }\n   334→\n   335→    const faceLandmarks = result.faceLandmarks[0];\n   336→\n   337→    // Front profile uses MediaPipe mapping\n   338→    const mapping = MEDIAPIPE_FRONT_MAPPING;\n   339→\n   340→    // Exact landmark offsets for cephalometric accuracy\n   341→    // These offsets correct MediaPipe's raw positions to match cephalometric standards\n   342→    const LANDMARK_OFFSETS: Record<string, { xOffset?: number; yOffset?: number }> = {\n   343→      // Hairline offset: MediaPipe index 10 is forehead/glabella, not actual hairline\n   344→      trichion: { yOffset: -0.06 },\n   345→\n   346→      // Pupil offsets: small adjustments for accurate pupil center\n   347→      left_pupila: { xOffset: 0.0015, yOffset: -0.005 },\n   348→      right_pupila: { xOffset: -0.0015, yOffset: -0.005 },\n   349→\n   350→      // Nose side offsets: widen nose detection slightly\n   351→      left_ala_nasi: { xOffset: 0.0025 },\n   352→      right_ala_nasi: { xOffset: -0.0025 },\n   353→\n   354→      // Temple offsets: move temples up slightly\n   355→      left_temporal: { yOffset: -0.01 },\n   356→      right_temporal: { yOffset: -0.01 },\n   357→\n   358→      // Outer ear offsets: push ears outward for accurate face width\n   359→      left_auricular_lateral: { xOffset: -0.04 },\n   360→      right_auricular_lateral: { xOffset: 0.04 },\n   361→\n   362→      // Neck offsets: move neck points down\n   363→      left_cervical_lateralis: { yOffset: 0.05 },\n   364→      right_cervical_lateralis: { yOffset: 0.05 },\n   365→\n   366→      // Upper eyelid crease offsets: move crease up slightly\n   367→      left_pretarsal_skin_crease: { yOffset: -0.015 },\n   368→      right_pretarsal_skin_crease: { yOffset: -0.015 },\n   369→    };\n   370→\n   371→    // Map keypoints to our landmarks\n   372→    const landmarks = Object.entries(mapping).map(([id, index]) => {\n   373→      // Handle index bounds\n   374→      const safeIndex = Math.min(index, faceLandmarks.length - 1);\n   375→      const landmark = faceLandmarks[safeIndex];\n   376→\n   377→      // Apply cephalometric offsets\n   378→      const offsets = LANDMARK_OFFSETS[id] || {};\n   379→      const xOffset = offsets.xOffset || 0;\n   380→      const yOffset = offsets.yOffset || 0;\n   381→\n   382→      return {\n   383→        id,\n   384→        // MediaPipe returns normalized coordinates (0-1)\n   385→        // Apply offsets and clamp to valid range\n   386→        x: landmark ? Math.max(0, Math.min(landmark.x + xOffset, 1)) : 0.5,\n   387→        y: landmark ? Math.max(0, Math.min(landmark.y + yOffset, 1)) : 0.5,\n   388→      };\n   389→    });\n   390→\n   391→    // Calculate face bounding box from all landmarks\n   392→    let minX = 1, minY = 1, maxX = 0, maxY = 0;\n   393→    faceLandmarks.forEach((lm) => {\n   394→      minX = Math.min(minX, lm.x);\n   395→      minY = Math.min(minY, lm.y);\n   396→      maxX = Math.max(maxX, lm.x);\n   397→      maxY = Math.max(maxY, lm.y);\n   398→    });\n   399→\n   400→    return {\n   401→      landmarks,\n   402→      confidence: 0.95, // MediaPipe doesn't return confidence per landmark\n   403→      faceBox: {\n   404→        x: minX,\n   405→        y: minY,\n   406→        width: maxX - minX,\n   407→        height: maxY - minY,\n   408→      },\n   409→    };\n   410→  } catch (error) {\n   411→    console.error('Face detection error:', error);\n   412→    return null;\n   413→  }\n   414→}\n   415→\n   416→/**\n   417→ * Load an image from URL\n   418→ */\n   419→function loadImage(url: string): Promise<HTMLImageElement> {\n   420→  return new Promise((resolve, reject) => {\n   421→    const img = new Image();\n   422→    img.crossOrigin = 'anonymous';\n   423→    img.onload = () => resolve(img);\n   424→    img.onerror = (e) => reject(e);\n   425→    img.src = url;\n   426→  });\n   427→}\n   428→\n   429→// ============================================\n   430→// SIDE PROFILE DEPTH VARIANCE VALIDATION\n   431→// ============================================\n   432→\n   433→/**\n   434→ * Validate 3D depth variance from side profile landmarks\n   435→ *\n   436→ * Checks that the photo shows a true side profile by analyzing:\n   437→ * 1. Depth spread: Horizontal distance from nose tip to ear landmarks\n   438→ * 2. Nasal projection: How far the nose projects forward\n   439→ * 3. Frankfort plane: Should be relatively horizontal in proper side profiles\n   440→ *\n   441→ * @param landmarks Array of detected landmarks with x, y coordinates\n   442→ * @param frankfortPlane Optional Frankfort plane data\n   443→ * @returns Validation result with confidence score and issues\n   444→ */\n   445→export function validateSideProfileDepth(\n   446→  landmarks: Array<{ id: string; x: number; y: number }>,\n   447→  frankfortPlane?: { angle: number; orbitale: { x: number; y: number }; porion: { x: number; y: number } }\n   448→): DepthVarianceResult {\n   449→  const issues: string[] = [];\n   450→  let confidence = 1.0;\n   451→\n   452→  // Get key landmarks for depth validation\n   453→  const getLandmark = (id: string) => landmarks.find(l => l.id === id);\n   454→\n   455→  const pronasale = getLandmark('pronasale');     // Nose tip\n   456→  const nasion = getLandmark('nasion');           // Nasal root\n   457→  const porion = getLandmark('porion');           // Ear opening\n   458→  const tragus = getLandmark('tragus');           // Ear cartilage\n   459→  const orbitale = getLandmark('orbitale');       // Lowest orbital point\n   460→  const pogonion = getLandmark('pogonion');       // Chin point\n   461→  const subnasale = getLandmark('subnasale');     // Nose base\n   462→\n   463→  // Calculate depth spread (nose to ear horizontal distance)\n   464→  let depthSpread = 0;\n   465→  const earLandmark = porion || tragus;\n   466→\n   467→  if (pronasale && earLandmark) {\n   468→    // In a true side profile, nose tip should be significantly forward of ear\n   469→    depthSpread = Math.abs(pronasale.x - earLandmark.x);\n   470→\n   471→    // Minimum depth spread threshold (nose should be at least 15% face width from ear)\n   472→    const MIN_DEPTH_SPREAD = 0.15;\n   473→    if (depthSpread < MIN_DEPTH_SPREAD) {\n   474→      issues.push(`Insufficient depth spread (${(depthSpread * 100).toFixed(1)}%): Photo may not be a true side profile`);\n   475→      confidence -= 0.3;\n   476→    }\n   477→  } else {\n   478→    issues.push('Missing key landmarks for depth calculation (pronasale or ear landmark)');\n   479→    confidence -= 0.4;\n   480→  }\n   481→\n   482→  // Calculate nasal projection\n   483→  let nosalProjection = 0;\n   484→  if (pronasale && subnasale) {\n   485→    // Nasal projection: horizontal distance from nose base to tip\n   486→    nosalProjection = Math.abs(pronasale.x - subnasale.x);\n   487→\n   488→    // Minimum nasal projection (nose tip should project at least 5% forward of base)\n   489→    const MIN_NASAL_PROJECTION = 0.05;\n   490→    if (nosalProjection < MIN_NASAL_PROJECTION) {\n   491→      issues.push(`Low nasal projection (${(nosalProjection * 100).toFixed(1)}%): Profile angle may be too frontal`);\n   492→      confidence -= 0.2;\n   493→    }\n   494→  }\n   495→\n   496→  // Check Frankfort plane deviation\n   497→  let frankfortDeviation = 0;\n   498→  if (frankfortPlane) {\n   499→    frankfortDeviation = Math.abs(frankfortPlane.angle);\n   500→\n   501→    // Frankfort plane should be within ±10 degrees of horizontal in ideal photos\n   502→    const MAX_FRANKFORT_DEVIATION = 15;\n   503→    if (frankfortDeviation > MAX_FRANKFORT_DEVIATION) {\n   504→      issues.push(`Head tilt detected (${frankfortDeviation.toFixed(1)}°): Consider re-taking photo with head level`);\n   505→      confidence -= 0.15;\n   506→    }\n   507→  } else if (orbitale && (porion || tragus)) {\n   508→    // Calculate from landmarks if not provided\n   509→    const ear = porion || tragus;\n   510→    if (ear && orbitale) {\n   511→      const dx = ear.x - orbitale.x;\n   512→      const dy = ear.y - orbitale.y;\n   513→      frankfortDeviation = Math.abs(Math.atan2(dy, dx) * (180 / Math.PI));\n   514→\n   515→      const MAX_FRANKFORT_DEVIATION = 15;\n   516→      if (frankfortDeviation > MAX_FRANKFORT_DEVIATION) {\n   517→        issues.push(`Head tilt detected (${frankfortDeviation.toFixed(1)}°): Consider re-taking photo with head level`);\n   518→        confidence -= 0.15;\n   519→      }\n   520→    }\n   521→  }\n   522→\n   523→  // Additional validation: Check landmark horizontal ordering\n   524→  // In a true side profile facing left, nose should be leftmost, ear rightmost\n   525→  // In a true side profile facing right, the opposite\n   526→  if (pronasale && earLandmark && nasion) {\n   527→    const noseToEar = pronasale.x - earLandmark.x;\n   528→    const nasionToEar = nasion.x - earLandmark.x;\n   529→\n   530→    // Both should have the same sign (nose and nasion on same side relative to ear)\n   531→    if (noseToEar * nasionToEar < 0) {\n   532→      issues.push('Inconsistent landmark positions: May indicate partial profile or rotation');\n   533→      confidence -= 0.2;\n   534→    }\n   535→  }\n   536→\n   537→  // Check chin position relative to profile\n   538→  if (pogonion && pronasale && earLandmark) {\n   539→    const chinDepth = Math.abs(pogonion.x - earLandmark.x);\n   540→    const noseDepth = Math.abs(pronasale.x - earLandmark.x);\n   541→\n   542→    // In a normal profile, chin should be closer to ear than nose tip\n   543→    // A severely recessed chin might have issues, but this is a soft check\n   544→    if (noseDepth > 0 && chinDepth / noseDepth < 0.3) {\n   545→      issues.push('Unusual chin position: Very recessed or photo angle issue');\n   546→      confidence -= 0.1;\n   547→    }\n   548→  }\n   549→\n   550→  // Clamp confidence between 0 and 1\n   551→  confidence = Math.max(0, Math.min(1, confidence));\n   552→\n   553→  return {\n   554→    isValid: confidence >= 0.5 && issues.length < 3,\n   555→    confidence,\n   556→    depthSpread,\n   557→    nosalProjection,\n   558→    frankfortDeviation,\n   559→    issues,\n   560→  };\n   561→}\n   562→\n   563→/**\n   564→ * Get the region to zoom into for a specific landmark\n   565→ */\n   566→export function getLandmarkZoomRegion(\n   567→  landmarkId: string\n   568→): { centerX: number; centerY: number; zoomLevel: number } {\n   569→  const regions: Record<string, { centerX: number; centerY: number; zoomLevel: number }> = {\n   570→    // Eyes - zoom in close\n   571→    left_pupila: { centerX: 0.35, centerY: 0.35, zoomLevel: 3 },\n   572→    left_canthus_medialis: { centerX: 0.4, centerY: 0.35, zoomLevel: 3 },\n   573→    left_canthus_lateralis: { centerX: 0.3, centerY: 0.35, zoomLevel: 3 },\n   574→    right_pupila: { centerX: 0.65, centerY: 0.35, zoomLevel: 3 },\n   575→    right_canthus_medialis: { centerX: 0.6, centerY: 0.35, zoomLevel: 3 },\n   576→    right_canthus_lateralis: { centerX: 0.7, centerY: 0.35, zoomLevel: 3 },\n   577→\n   578→    // Brows\n   579→    left_supercilium_apex: { centerX: 0.35, centerY: 0.28, zoomLevel: 2.5 },\n   580→    right_supercilium_apex: { centerX: 0.65, centerY: 0.28, zoomLevel: 2.5 },\n   581→\n   582→    // Nose\n   583→    nasal_base: { centerX: 0.5, centerY: 0.4, zoomLevel: 2 },\n   584→    subnasale: { centerX: 0.5, centerY: 0.55, zoomLevel: 2.5 },\n   585→\n   586→    // Mouth\n   587→    labrale_superius: { centerX: 0.5, centerY: 0.6, zoomLevel: 2.5 },\n   588→    mouth_middle: { centerX: 0.5, centerY: 0.65, zoomLevel: 2 },\n   589→\n   590→    // Chin\n   591→    menton: { centerX: 0.5, centerY: 0.85, zoomLevel: 2 },\n   592→\n   593→    // Default for other landmarks\n   594→    default: { centerX: 0.5, centerY: 0.5, zoomLevel: 1.5 },\n   595→  };\n   596→\n   597→  return regions[landmarkId] || regions.default;\n   598→}\n   599→\n\n</system-reminder>\n"}]},"uuid":"639be84d-4763-450e-ad14-a9828847dac3","timestamp":"2025-12-30T15:24:52.683Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/mediapipeDetection.ts","content":"/**\n * Face Landmark Detection using MediaPipe Tasks Vision\n * Maps detected landmarks to our custom facial landmarks\n *\n * Detection hierarchy:\n * - Front profile: MediaPipe Face Mesh (478 landmarks)\n * - Side profile: Server-side InsightFace (106 landmarks) → Edge-based fallback\n */\n\nimport { faceDetectionService } from './faceDetectionService';\nimport { detectSideProfile } from './sideProfileDetection';\nimport { detectSideProfileServer } from './serverSideDetection';\nimport { applyFaceIQCorrection, applyFrankfortCorrection, rotateImageFaceIQ } from './sideProfileNormalization';\n\n// MediaPipe Face Mesh landmark indices (478 landmarks total)\n// Reference: https://github.com/google/mediapipe/blob/master/mediapipe/modules/face_geometry/data/canonical_face_model_uv_visualization.png\n\n// Front profile landmark mapping\n// Based on the reference website's exact MediaPipe indices\n// Uses SUBJECT's perspective: \"left\" = subject's left (appears on RIGHT side of image)\nexport const MEDIAPIPE_FRONT_MAPPING: Record<string, number> = {\n  // Head\n  // Note: MediaPipe 10 is the forehead/glabella, not actual hairline\n  // We apply a Y offset during mapping to estimate the hairline position\n  trichion: 10, // hairline (requires Y offset - see TRICHION_Y_OFFSET)\n\n  // Left Eye (subject's LEFT eye - appears on RIGHT of image)\n  left_pupila: 468,\n  left_canthus_medialis: 133,\n  left_canthus_lateralis: 33,\n  left_palpebra_superior: 470,\n  left_palpebra_inferior: 472,\n  left_sulcus_palpebralis_lateralis: 247,\n  left_pretarsal_skin_crease: 470,\n\n  // Right Eye (subject's RIGHT eye - appears on LEFT of image)\n  right_pupila: 473,\n  right_canthus_medialis: 362,\n  right_canthus_lateralis: 263,\n  right_palpebra_superior: 475,\n  right_palpebra_inferior: 374,\n  right_sulcus_palpebralis_lateralis: 467,\n  right_pretarsal_skin_crease: 475,\n\n  // Left Brow (subject's LEFT brow - appears on RIGHT of image)\n  left_supercilium_medialis: 107,\n  left_supercilium_medial_corner: 55,\n  left_supercilium_superior: 52,\n  left_supercilium_apex: 105,\n  left_supercilium_lateralis: 70,\n\n  // Right Brow (subject's RIGHT brow - appears on LEFT of image)\n  right_supercilium_medialis: 336,\n  right_supercilium_medial_corner: 285,\n  right_supercilium_superior: 282,\n  right_supercilium_apex: 334,\n  right_supercilium_lateralis: 276,\n\n  // Nose\n  nasal_base: 290, // Base of nose (per landmarkers.js)\n  left_dorsum_nasi: 174,\n  right_dorsum_nasi: 399,\n  left_ala_nasi: 48,\n  right_ala_nasi: 278,\n  subnasale: 2, // noseBottom in landmarkers.js\n  nasion: 6, // Added for correct FWHR calculation\n  glabella: 9, // Added for reference\n\n  // Mouth\n  labrale_superius: 267, // cupidsBow - peak of cupid's bow\n  cupids_bow: 0, // innerCupidsBow - center dip of upper lip\n  mouth_middle: 14,\n  labrale_inferius: 17,\n  left_cheilion: 61,\n  right_cheilion: 306,\n\n  // Jaw\n  left_gonion_superior: 58,\n  right_gonion_superior: 288,\n  left_gonion_inferior: 172,\n  right_gonion_inferior: 397,\n\n  // Chin\n  left_mentum_lateralis: 176,\n  right_mentum_lateralis: 400,\n  menton: 152,\n\n  // Cheeks\n  left_zygion: 234,\n  right_zygion: 454,\n  left_malar: 205,        // Cheek center point for fullness calculation\n  right_malar: 425,       // Cheek center point for fullness calculation\n  left_temporal: 54,\n  right_temporal: 284,\n\n  // Ears\n  left_auricular_lateral: 127,\n  right_auricular_lateral: 356,\n\n  // Neck (same as bottom gonion indices, but apply +5% yOffset when rendering)\n  // Per landmarkers.js: neckLeft: 172 with yOffset: 0.05, neckRight: 397 with yOffset: 0.05\n  left_cervical_lateralis: 172,\n  right_cervical_lateralis: 397,\n};\n\n// ============================================\n// DEPTH VARIANCE RESULT INTERFACE\n// ============================================\n\nexport interface DepthVarianceResult {\n  isValid: boolean;\n  confidence: number;\n  depthSpread: number;        // Horizontal distance from nose to ear (0-1 normalized)\n  nosalProjection: number;    // How much the nose projects forward\n  frankfortDeviation: number; // Degrees deviation from horizontal\n  issues: string[];           // List of validation issues\n}\n\n// Side profile landmark mapping (IDs must match SIDE_PROFILE_LANDMARKS in landmarks.ts)\n// Matches 28 side profile landmarks exactly\n// For side profile photos, uses MediaPipe LEFT indices (appearing on left side of image)\n// Note: Server uses a custom server-side model for side detection; this is our MediaPipe fallback\nexport const MEDIAPIPE_SIDE_MAPPING: Record<string, number> = {\n  // 1. vertex - top of head\n  vertex: 10,\n  // 2. occiput - back of head (no good MediaPipe equivalent, use top)\n  occiput: 10,\n  // 3. pronasale - nose tip\n  pronasale: 1,\n  // 4. neckPoint - lower neck (no good equivalent, use chin)\n  neckPoint: 152,\n  // 5. porion - ear canal opening (use ear area)\n  porion: 127,\n  // 6. orbitale - lowest point of orbital rim (index 33 per cephalometric landmarkers.js)\n  orbitale: 33,\n  // 7. tragus - ear cartilage\n  tragus: 127,\n  // 8. intertragicNotch - notch in ear\n  intertragicNotch: 127,\n  // 9. cornealApex - forward point of cornea\n  cornealApex: 468,\n  // 10. cheekbone - zygomatic prominence\n  cheekbone: 234,\n  // 11. trichion - hairline\n  trichion: 10,\n  // 12. glabella - between brows\n  glabella: 9,\n  // 13. nasion - nasal root depression\n  nasion: 6,\n  // 14. rhinion - dorsal nose point\n  rhinion: 4,\n  // 15. supratip - above nose tip\n  supratip: 4,\n  // 16. infratip - below nose tip\n  infratip: 2,\n  // 17. columella - nasal septum\n  columella: 2,\n  // 18. subnasale - nose base meets upper lip\n  subnasale: 2,\n  // 19. subalare - nostril wing\n  subalare: 129,\n  // 20. labraleSuperius - upper lip\n  labraleSuperius: 0,\n  // 21. cheilion - mouth corner\n  cheilion: 61,\n  // 22. labraleInferius - lower lip\n  labraleInferius: 17,\n  // 23. sublabiale - below lower lip\n  sublabiale: 18,\n  // 24. pogonion - chin point\n  pogonion: 152,\n  // 25. menton - chin bottom\n  menton: 152,\n  // 26. cervicalPoint - high neck point\n  cervicalPoint: 152,\n  // 27. gonionTop - upper jaw angle\n  gonionTop: 116,\n  // 28. gonionBottom - lower jaw angle\n  gonionBottom: 172,\n};\n\nexport interface DetectedLandmarks {\n  landmarks: Array<{ id: string; x: number; y: number }>;\n  confidence: number;\n  faceBox: { x: number; y: number; width: number; height: number };\n  frankfortPlane?: {\n    angle: number;\n    orbitale: { x: number; y: number };\n    porion: { x: number; y: number };\n  };\n  depthValidation?: DepthVarianceResult;\n  /** Rotated image URL for FaceIQ parity (side profiles only) */\n  rotatedImageUrl?: string;\n}\n\n/**\n * Detect facial landmarks from an image URL\n *\n * Detection hierarchy:\n * - Front profile: MediaPipe Face Mesh (478 landmarks) - unchanged\n * - Side profile: Server-side InsightFace → Edge-based fallback → Manual placement\n */\nexport async function detectFromImageUrl(\n  imageUrl: string,\n  mode: 'front' | 'side'\n): Promise<DetectedLandmarks | null> {\n  try {\n    // ============================================\n    // SIDE PROFILE: Use server-side detection\n    // ============================================\n    if (mode === 'side') {\n      console.log('[Detection] Side profile mode - trying server-side detection...');\n\n      // Try server-side InsightFace first (best accuracy)\n      const serverResult = await detectSideProfileServer(imageUrl);\n      if (serverResult) {\n        console.log('[Detection] Server-side detection succeeded');\n\n        // Validate side profile depth variance\n        const depthValidation = validateSideProfileDepth(\n          serverResult.landmarks,\n          serverResult.frankfortPlane\n        );\n        console.log('[Detection] Depth validation:', {\n          isValid: depthValidation.isValid,\n          confidence: depthValidation.confidence.toFixed(2),\n          depthSpread: (depthValidation.depthSpread * 100).toFixed(1) + '%',\n          issues: depthValidation.issues,\n        });\n\n        // FaceIQ PARITY FIX: Apply rotation in pixel space FIRST, then normalize to 0-1\n        // Step 1: Rotate landmarks using FaceIQ algorithm (in pixel coordinates)\n        const rotatedLandmarks = applyFaceIQCorrection(\n          serverResult.landmarks,\n          serverResult.rawLandmarks,\n          serverResult.direction\n        );\n        console.log('[Detection] Applied FaceIQ correction, direction:',\n          serverResult.direction || 'N/A');\n\n        // Step 2: Rotate image to match rotated landmarks (FaceIQ parity)\n        const rotatedImageUrl = await rotateImageFaceIQ(\n          imageUrl,\n          serverResult.rawLandmarks!,\n          serverResult.direction!,\n          serverResult.faceBox\n        );\n        console.log('[Detection] Rotated image to match FaceIQ-normalized landmarks');\n\n        // Step 3: Normalize to 0-1 range AFTER rotation\n        const { width, height } = serverResult.imageDimensions;\n        const normalizedLandmarks = rotatedLandmarks.map(lm => ({\n          id: lm.id,\n          x: Math.max(0, Math.min(1, lm.x / width)),\n          y: Math.max(0, Math.min(1, lm.y / height)),\n        }));\n        console.log('[Detection] Normalized landmarks to 0-1 range after rotation');\n\n        // Step 3: Normalize Frankfort plane coordinates (for display only)\n        const normalizedFrankfortPlane = serverResult.frankfortPlane ? {\n          angle: serverResult.frankfortPlane.angle,\n          orbitale: {\n            x: Math.max(0, Math.min(1, serverResult.frankfortPlane.orbitale.x / width)),\n            y: Math.max(0, Math.min(1, serverResult.frankfortPlane.orbitale.y / height)),\n          },\n          porion: {\n            x: Math.max(0, Math.min(1, serverResult.frankfortPlane.porion.x / width)),\n            y: Math.max(0, Math.min(1, serverResult.frankfortPlane.porion.y / height)),\n          },\n        } : undefined;\n\n        return {\n          landmarks: normalizedLandmarks,\n          confidence: serverResult.confidence,\n          faceBox: serverResult.faceBox,\n          frankfortPlane: normalizedFrankfortPlane,\n          depthValidation,\n          rotatedImageUrl, // FaceIQ parity: rotated image matches rotated landmarks\n        };\n      }\n\n      console.log('[Detection] Server-side failed, trying edge-based detection...');\n\n      // Fallback to edge-based detection\n      const sideResult = await detectSideProfile(imageUrl);\n      if (sideResult) {\n        console.log('[Detection] Edge-based side profile detection succeeded');\n\n        // Validate side profile depth variance\n        const depthValidation = validateSideProfileDepth(sideResult.landmarks);\n        console.log('[Detection] Depth validation (edge-based):', {\n          isValid: depthValidation.isValid,\n          confidence: depthValidation.confidence.toFixed(2),\n          issues: depthValidation.issues,\n        });\n\n        // Apply Frankfort correction (edge-based doesn't have pre-calculated plane)\n        const normalizedLandmarks = applyFrankfortCorrection(sideResult.landmarks);\n        console.log('[Detection] Applied Frankfort correction to edge-based result');\n\n        return {\n          landmarks: normalizedLandmarks,\n          confidence: sideResult.confidence,\n          faceBox: {\n            x: 0,\n            y: 0,\n            width: 1,\n            height: 1,\n          },\n          depthValidation,\n        };\n      }\n\n      console.log('[Detection] All side profile detection methods failed - manual placement required');\n      return null;\n    }\n\n    // ============================================\n    // FRONT PROFILE: Use MediaPipe (UNCHANGED)\n    // ============================================\n    // Load the image\n    const img = await loadImage(imageUrl);\n\n    // Use the singleton service\n    const result = await faceDetectionService.detect(img);\n\n    // Check if MediaPipe detected a face\n    const mediaPipeSucceeded = result.faceLandmarks && result.faceLandmarks.length > 0;\n\n    if (!mediaPipeSucceeded) {\n      console.log('No faces detected');\n      return null;\n    }\n\n    const faceLandmarks = result.faceLandmarks[0];\n\n    // Front profile uses MediaPipe mapping\n    const mapping = MEDIAPIPE_FRONT_MAPPING;\n\n    // Exact landmark offsets for cephalometric accuracy\n    // These offsets correct MediaPipe's raw positions to match cephalometric standards\n    const LANDMARK_OFFSETS: Record<string, { xOffset?: number; yOffset?: number }> = {\n      // Hairline offset: MediaPipe index 10 is forehead/glabella, not actual hairline\n      trichion: { yOffset: -0.06 },\n\n      // Pupil offsets: small adjustments for accurate pupil center\n      left_pupila: { xOffset: 0.0015, yOffset: -0.005 },\n      right_pupila: { xOffset: -0.0015, yOffset: -0.005 },\n\n      // Nose side offsets: widen nose detection slightly\n      left_ala_nasi: { xOffset: 0.0025 },\n      right_ala_nasi: { xOffset: -0.0025 },\n\n      // Temple offsets: move temples up slightly\n      left_temporal: { yOffset: -0.01 },\n      right_temporal: { yOffset: -0.01 },\n\n      // Outer ear offsets: push ears outward for accurate face width\n      left_auricular_lateral: { xOffset: -0.04 },\n      right_auricular_lateral: { xOffset: 0.04 },\n\n      // Neck offsets: move neck points down\n      left_cervical_lateralis: { yOffset: 0.05 },\n      right_cervical_lateralis: { yOffset: 0.05 },\n\n      // Upper eyelid crease offsets: move crease up slightly\n      left_pretarsal_skin_crease: { yOffset: -0.015 },\n      right_pretarsal_skin_crease: { yOffset: -0.015 },\n    };\n\n    // Map keypoints to our landmarks\n    const landmarks = Object.entries(mapping).map(([id, index]) => {\n      // Handle index bounds\n      const safeIndex = Math.min(index, faceLandmarks.length - 1);\n      const landmark = faceLandmarks[safeIndex];\n\n      // Apply cephalometric offsets\n      const offsets = LANDMARK_OFFSETS[id] || {};\n      const xOffset = offsets.xOffset || 0;\n      const yOffset = offsets.yOffset || 0;\n\n      return {\n        id,\n        // MediaPipe returns normalized coordinates (0-1)\n        // Apply offsets and clamp to valid range\n        x: landmark ? Math.max(0, Math.min(landmark.x + xOffset, 1)) : 0.5,\n        y: landmark ? Math.max(0, Math.min(landmark.y + yOffset, 1)) : 0.5,\n      };\n    });\n\n    // Calculate face bounding box from all landmarks\n    let minX = 1, minY = 1, maxX = 0, maxY = 0;\n    faceLandmarks.forEach((lm) => {\n      minX = Math.min(minX, lm.x);\n      minY = Math.min(minY, lm.y);\n      maxX = Math.max(maxX, lm.x);\n      maxY = Math.max(maxY, lm.y);\n    });\n\n    return {\n      landmarks,\n      confidence: 0.95, // MediaPipe doesn't return confidence per landmark\n      faceBox: {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY,\n      },\n    };\n  } catch (error) {\n    console.error('Face detection error:', error);\n    return null;\n  }\n}\n\n/**\n * Load an image from URL\n */\nfunction loadImage(url: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = () => resolve(img);\n    img.onerror = (e) => reject(e);\n    img.src = url;\n  });\n}\n\n// ============================================\n// SIDE PROFILE DEPTH VARIANCE VALIDATION\n// ============================================\n\n/**\n * Validate 3D depth variance from side profile landmarks\n *\n * Checks that the photo shows a true side profile by analyzing:\n * 1. Depth spread: Horizontal distance from nose tip to ear landmarks\n * 2. Nasal projection: How far the nose projects forward\n * 3. Frankfort plane: Should be relatively horizontal in proper side profiles\n *\n * @param landmarks Array of detected landmarks with x, y coordinates\n * @param frankfortPlane Optional Frankfort plane data\n * @returns Validation result with confidence score and issues\n */\nexport function validateSideProfileDepth(\n  landmarks: Array<{ id: string; x: number; y: number }>,\n  frankfortPlane?: { angle: number; orbitale: { x: number; y: number }; porion: { x: number; y: number } }\n): DepthVarianceResult {\n  const issues: string[] = [];\n  let confidence = 1.0;\n\n  // Get key landmarks for depth validation\n  const getLandmark = (id: string) => landmarks.find(l => l.id === id);\n\n  const pronasale = getLandmark('pronasale');     // Nose tip\n  const nasion = getLandmark('nasion');           // Nasal root\n  const porion = getLandmark('porion');           // Ear opening\n  const tragus = getLandmark('tragus');           // Ear cartilage\n  const orbitale = getLandmark('orbitale');       // Lowest orbital point\n  const pogonion = getLandmark('pogonion');       // Chin point\n  const subnasale = getLandmark('subnasale');     // Nose base\n\n  // Calculate depth spread (nose to ear horizontal distance)\n  let depthSpread = 0;\n  const earLandmark = porion || tragus;\n\n  if (pronasale && earLandmark) {\n    // In a true side profile, nose tip should be significantly forward of ear\n    depthSpread = Math.abs(pronasale.x - earLandmark.x);\n\n    // Minimum depth spread threshold (nose should be at least 15% face width from ear)\n    const MIN_DEPTH_SPREAD = 0.15;\n    if (depthSpread < MIN_DEPTH_SPREAD) {\n      issues.push(`Insufficient depth spread (${(depthSpread * 100).toFixed(1)}%): Photo may not be a true side profile`);\n      confidence -= 0.3;\n    }\n  } else {\n    issues.push('Missing key landmarks for depth calculation (pronasale or ear landmark)');\n    confidence -= 0.4;\n  }\n\n  // Calculate nasal projection\n  let nosalProjection = 0;\n  if (pronasale && subnasale) {\n    // Nasal projection: horizontal distance from nose base to tip\n    nosalProjection = Math.abs(pronasale.x - subnasale.x);\n\n    // Minimum nasal projection (nose tip should project at least 5% forward of base)\n    const MIN_NASAL_PROJECTION = 0.05;\n    if (nosalProjection < MIN_NASAL_PROJECTION) {\n      issues.push(`Low nasal projection (${(nosalProjection * 100).toFixed(1)}%): Profile angle may be too frontal`);\n      confidence -= 0.2;\n    }\n  }\n\n  // Check Frankfort plane deviation\n  let frankfortDeviation = 0;\n  if (frankfortPlane) {\n    frankfortDeviation = Math.abs(frankfortPlane.angle);\n\n    // Frankfort plane should be within ±10 degrees of horizontal in ideal photos\n    const MAX_FRANKFORT_DEVIATION = 15;\n    if (frankfortDeviation > MAX_FRANKFORT_DEVIATION) {\n      issues.push(`Head tilt detected (${frankfortDeviation.toFixed(1)}°): Consider re-taking photo with head level`);\n      confidence -= 0.15;\n    }\n  } else if (orbitale && (porion || tragus)) {\n    // Calculate from landmarks if not provided\n    const ear = porion || tragus;\n    if (ear && orbitale) {\n      const dx = ear.x - orbitale.x;\n      const dy = ear.y - orbitale.y;\n      frankfortDeviation = Math.abs(Math.atan2(dy, dx) * (180 / Math.PI));\n\n      const MAX_FRANKFORT_DEVIATION = 15;\n      if (frankfortDeviation > MAX_FRANKFORT_DEVIATION) {\n        issues.push(`Head tilt detected (${frankfortDeviation.toFixed(1)}°): Consider re-taking photo with head level`);\n        confidence -= 0.15;\n      }\n    }\n  }\n\n  // Additional validation: Check landmark horizontal ordering\n  // In a true side profile facing left, nose should be leftmost, ear rightmost\n  // In a true side profile facing right, the opposite\n  if (pronasale && earLandmark && nasion) {\n    const noseToEar = pronasale.x - earLandmark.x;\n    const nasionToEar = nasion.x - earLandmark.x;\n\n    // Both should have the same sign (nose and nasion on same side relative to ear)\n    if (noseToEar * nasionToEar < 0) {\n      issues.push('Inconsistent landmark positions: May indicate partial profile or rotation');\n      confidence -= 0.2;\n    }\n  }\n\n  // Check chin position relative to profile\n  if (pogonion && pronasale && earLandmark) {\n    const chinDepth = Math.abs(pogonion.x - earLandmark.x);\n    const noseDepth = Math.abs(pronasale.x - earLandmark.x);\n\n    // In a normal profile, chin should be closer to ear than nose tip\n    // A severely recessed chin might have issues, but this is a soft check\n    if (noseDepth > 0 && chinDepth / noseDepth < 0.3) {\n      issues.push('Unusual chin position: Very recessed or photo angle issue');\n      confidence -= 0.1;\n    }\n  }\n\n  // Clamp confidence between 0 and 1\n  confidence = Math.max(0, Math.min(1, confidence));\n\n  return {\n    isValid: confidence >= 0.5 && issues.length < 3,\n    confidence,\n    depthSpread,\n    nosalProjection,\n    frankfortDeviation,\n    issues,\n  };\n}\n\n/**\n * Get the region to zoom into for a specific landmark\n */\nexport function getLandmarkZoomRegion(\n  landmarkId: string\n): { centerX: number; centerY: number; zoomLevel: number } {\n  const regions: Record<string, { centerX: number; centerY: number; zoomLevel: number }> = {\n    // Eyes - zoom in close\n    left_pupila: { centerX: 0.35, centerY: 0.35, zoomLevel: 3 },\n    left_canthus_medialis: { centerX: 0.4, centerY: 0.35, zoomLevel: 3 },\n    left_canthus_lateralis: { centerX: 0.3, centerY: 0.35, zoomLevel: 3 },\n    right_pupila: { centerX: 0.65, centerY: 0.35, zoomLevel: 3 },\n    right_canthus_medialis: { centerX: 0.6, centerY: 0.35, zoomLevel: 3 },\n    right_canthus_lateralis: { centerX: 0.7, centerY: 0.35, zoomLevel: 3 },\n\n    // Brows\n    left_supercilium_apex: { centerX: 0.35, centerY: 0.28, zoomLevel: 2.5 },\n    right_supercilium_apex: { centerX: 0.65, centerY: 0.28, zoomLevel: 2.5 },\n\n    // Nose\n    nasal_base: { centerX: 0.5, centerY: 0.4, zoomLevel: 2 },\n    subnasale: { centerX: 0.5, centerY: 0.55, zoomLevel: 2.5 },\n\n    // Mouth\n    labrale_superius: { centerX: 0.5, centerY: 0.6, zoomLevel: 2.5 },\n    mouth_middle: { centerX: 0.5, centerY: 0.65, zoomLevel: 2 },\n\n    // Chin\n    menton: { centerX: 0.5, centerY: 0.85, zoomLevel: 2 },\n\n    // Default for other landmarks\n    default: { centerX: 0.5, centerY: 0.5, zoomLevel: 1.5 },\n  };\n\n  return regions[landmarkId] || regions.default;\n}\n","numLines":599,"startLine":1,"totalLines":599}}}
{"parentUuid":"639be84d-4763-450e-ad14-a9828847dac3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QsWVUYUz2JESvzSHVo67TF","type":"tool_result","content":"     1→/**\n     2→ * Server-Side Detection Service for Side Profiles\n     3→ *\n     4→ * Calls the Railway-hosted InsightFace API for accurate side profile detection.\n     5→ * Returns 106 raw landmarks mapped to our 28 cephalometric landmarks.\n     6→ *\n     7→ * Supports manual overrides for estimated landmarks (porion, tragus, intertragicNotch)\n     8→ * to achieve FaceIQ-level Frankfort plane accuracy.\n     9→ */\n    10→\n    11→import { SideLandmarkResponse } from '@/app/api/side-landmarks/route';\n    12→\n    13→/**\n    14→ * Landmarks that are geometrically estimated and benefit from manual adjustment\n    15→ */\n    16→export const ESTIMATED_LANDMARK_IDS = ['porion', 'tragus', 'intertragicNotch'] as const;\n    17→export type EstimatedLandmarkId = typeof ESTIMATED_LANDMARK_IDS[number];\n    18→\n    19→export interface ServerDetectionResult {\n    20→  landmarks: Array<{ id: string; x: number; y: number }>;  // In PIXEL coordinates\n    21→  rawLandmarks?: Array<{ x: number; y: number }>;  // Raw 106 landmarks for FaceIQ-style normalization (pixels)\n    22→  confidence: number;\n    23→  faceBox: { x: number; y: number; width: number; height: number };\n    24→  direction?: 'left' | 'right';\n    25→  rotationAngle?: number;\n    26→  frankfortPlane?: {\n    27→    angle: number;\n    28→    orbitale: { x: number; y: number };\n    29→    porion: { x: number; y: number };\n    30→  };\n    31→  /** Image dimensions for normalization AFTER rotation */\n    32→  imageDimensions: { width: number; height: number };\n    33→  /** Rotated image URL (for display with rotated landmarks) */\n    34→  rotatedImageUrl?: string;\n    35→  /** Tracks which landmarks were manually adjusted */\n    36→  manuallyAdjusted?: string[];\n    37→}\n    38→\n    39→/**\n    40→ * Manual landmark override for estimated ear landmarks\n    41→ */\n    42→export interface LandmarkOverride {\n    43→  id: string;\n    44→  x: number;\n    45→  y: number;\n    46→}\n    47→\n    48→/**\n    49→ * Convert image URL to base64\n    50→ */\n    51→async function imageUrlToBase64(imageUrl: string): Promise<string> {\n    52→  // If it's already a data URL, extract the base64 part\n    53→  if (imageUrl.startsWith('data:')) {\n    54→    return imageUrl;\n    55→  }\n    56→\n    57→  // If it's a blob URL or regular URL, fetch and convert\n    58→  const response = await fetch(imageUrl);\n    59→  const blob = await response.blob();\n    60→\n    61→  return new Promise((resolve, reject) => {\n    62→    const reader = new FileReader();\n    63→    reader.onloadend = () => {\n    64→      if (typeof reader.result === 'string') {\n    65→        resolve(reader.result);\n    66→      } else {\n    67→        reject(new Error('Failed to convert to base64'));\n    68→      }\n    69→    };\n    70→    reader.onerror = reject;\n    71→    reader.readAsDataURL(blob);\n    72→  });\n    73→}\n    74→\n    75→\n    76→/**\n    77→ * Get image dimensions\n    78→ */\n    79→function getImageDimensions(imageUrl: string): Promise<{ width: number; height: number }> {\n    80→  return new Promise((resolve, reject) => {\n    81→    const img = new Image();\n    82→    img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });\n    83→    img.onerror = reject;\n    84→    img.src = imageUrl;\n    85→  });\n    86→}\n    87→\n    88→/**\n    89→ * Calculate Frankfort Horizontal Plane from orbitale and porion landmarks\n    90→ */\n    91→function calculateFrankfortPlane(\n    92→  orbitale: { x: number; y: number },\n    93→  porion: { x: number; y: number }\n    94→): { angle: number; orbitale: { x: number; y: number }; porion: { x: number; y: number } } {\n    95→  // Calculate angle from horizontal (in degrees)\n    96→  const dx = porion.x - orbitale.x;\n    97→  const dy = porion.y - orbitale.y;\n    98→  const angle = Math.atan2(dy, dx) * (180 / Math.PI);\n    99→\n   100→  return {\n   101→    angle,\n   102→    orbitale,\n   103→    porion,\n   104→  };\n   105→}\n   106→\n   107→/**\n   108→ * Detect side profile landmarks using server-side InsightFace API\n   109→ */\n   110→export async function detectSideProfileServer(\n   111→  imageUrl: string\n   112→): Promise<ServerDetectionResult | null> {\n   113→  try {\n   114→    console.log('[ServerDetection] Starting server-side detection...');\n   115→\n   116→    // Convert image to base64\n   117→    const base64Image = await imageUrlToBase64(imageUrl);\n   118→\n   119→    // Call our API proxy\n   120→    const response = await fetch('/api/side-landmarks', {\n   121→      method: 'POST',\n   122→      headers: {\n   123→        'Content-Type': 'application/json',\n   124→      },\n   125→      body: JSON.stringify({ image: base64Image }),\n   126→    });\n   127→\n   128→    if (!response.ok) {\n   129→      console.error('[ServerDetection] API error:', response.status);\n   130→      return null;\n   131→    }\n   132→\n   133→    const data: SideLandmarkResponse = await response.json();\n   134→\n   135→    if (!data.success || !data.data?.namedLandmarks) {\n   136→      console.log('[ServerDetection] Detection failed:', data.error || 'No landmarks found');\n   137→      return null;\n   138→    }\n   139→\n   140→    const resultData = data.data;\n   141→    console.log('[ServerDetection] Detection successful, count:', resultData.landmarkCount);\n   142→\n   143→    // Get image dimensions for normalization\n   144→    const { width, height } = await getImageDimensions(imageUrl);\n   145→    console.log('[ServerDetection] Image dimensions:', width, 'x', height);\n   146→\n   147→    // FaceIQ PARITY FIX #1: Keep landmarks in PIXEL coordinates (NOT normalized 0-1)\n   148→    // Normalization must happen AFTER FaceIQ rotation algorithm\n   149→    const landmarks = Object.entries(resultData.namedLandmarks).map(([id, point]) => ({\n   150→      id,\n   151→      x: point.x,  // Keep pixel coordinates\n   152→      y: point.y,  // Keep pixel coordinates\n   153→    }));\n   154→\n   155→    // Keep raw landmarks in pixel coordinates for FaceIQ rotation (indices 10, 26, 75)\n   156→    const rawLandmarks = resultData.landmarks?.map(pt => ({\n   157→      x: pt.x,  // Keep pixel coordinates\n   158→      y: pt.y,  // Keep pixel coordinates\n   159→    })) || [];\n   160→\n   161→    // Use Frankfort Plane from server if available (future proof), otherwise calculate locally\n   162→    let frankfortPlane: ServerDetectionResult['frankfortPlane'];\n   163→    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n   164→    const serverFrankfort = (resultData as any).frankfort_plane;\n   165→\n   166→    if (serverFrankfort) {\n   167→      frankfortPlane = serverFrankfort;\n   168→      console.log('[ServerDetection] Frankfort Plane angle (from server):', serverFrankfort.angle.toFixed(2), 'degrees');\n   169→    } else {\n   170→      // Find normalized orbitale and porion from our processed list\n   171→      const normOrbitale = landmarks.find(l => l.id === 'orbitale');\n   172→      const normPorion = landmarks.find(l => l.id === 'porion');\n   173→\n   174→      if (normOrbitale && normPorion) {\n   175→        frankfortPlane = calculateFrankfortPlane(normOrbitale, normPorion);\n   176→        console.log('[ServerDetection] Frankfort Plane angle (calculated):', frankfortPlane.angle.toFixed(2), 'degrees');\n   177→      }\n   178→    }\n   179→\n   180→    return {\n   181→      landmarks,  // Pixel coordinates (NOT normalized)\n   182→      rawLandmarks,  // Raw 106 landmarks in pixel coordinates for FaceIQ algorithm\n   183→      confidence: 0.95, // InsightFace is generally high confidence\n   184→      faceBox: resultData.crop || { x: 0, y: 0, width: 1, height: 1 },\n   185→      direction: resultData.direction,\n   186→      rotationAngle: resultData.rotationAngle,\n   187→      frankfortPlane,\n   188→      imageDimensions: { width, height },  // For normalization AFTER rotation\n   189→    };\n   190→  } catch (error) {\n   191→    console.error('[ServerDetection] Error:', error);\n   192→    return null;\n   193→  }\n   194→}\n   195→\n   196→/**\n   197→ * Merge manual landmark overrides with detected landmarks\n   198→ *\n   199→ * Used for applying user adjustments to estimated ear landmarks\n   200→ * (porion, tragus, intertragicNotch) for FaceIQ-level accuracy.\n   201→ *\n   202→ * @param detectedLandmarks - Landmarks from server detection\n   203→ * @param overrides - Manual adjustments from user\n   204→ * @returns Merged landmarks with manual overrides applied\n   205→ */\n   206→export function mergeWithOverrides(\n   207→  detectedLandmarks: Array<{ id: string; x: number; y: number }>,\n   208→  overrides: LandmarkOverride[]\n   209→): Array<{ id: string; x: number; y: number }> {\n   210→  if (!overrides.length) return detectedLandmarks;\n   211→\n   212→  const overrideMap = new Map(overrides.map(o => [o.id, o]));\n   213→\n   214→  return detectedLandmarks.map(landmark => {\n   215→    const override = overrideMap.get(landmark.id);\n   216→    if (override) {\n   217→      console.log(`[ServerDetection] Applied override for ${landmark.id}:`, {\n   218→        original: { x: landmark.x.toFixed(4), y: landmark.y.toFixed(4) },\n   219→        adjusted: { x: override.x.toFixed(4), y: override.y.toFixed(4) },\n   220→      });\n   221→      return { ...landmark, x: override.x, y: override.y };\n   222→    }\n   223→    return landmark;\n   224→  });\n   225→}\n   226→\n   227→/**\n   228→ * Recalculate Frankfort Horizontal Plane after manual adjustments\n   229→ *\n   230→ * Call this after applying overrides to porion or orbitale to update\n   231→ * the Frankfort plane angle used in side profile analysis.\n   232→ *\n   233→ * @param landmarks - Merged landmarks with overrides applied\n   234→ * @returns Updated Frankfort plane calculation or null if landmarks not found\n   235→ */\n   236→export function recalculateFrankfortPlane(\n   237→  landmarks: Array<{ id: string; x: number; y: number }>\n   238→): ServerDetectionResult['frankfortPlane'] | null {\n   239→  const orbitale = landmarks.find(l => l.id === 'orbitale');\n   240→  const porion = landmarks.find(l => l.id === 'porion');\n   241→\n   242→  if (!orbitale || !porion) {\n   243→    console.warn('[ServerDetection] Cannot calculate Frankfort plane: missing orbitale or porion');\n   244→    return null;\n   245→  }\n   246→\n   247→  const plane = calculateFrankfortPlane(orbitale, porion);\n   248→  console.log('[ServerDetection] Recalculated Frankfort Plane angle:', plane.angle.toFixed(2), 'degrees');\n   249→\n   250→  return plane;\n   251→}\n   252→\n   253→/**\n   254→ * Apply manual overrides to a detection result\n   255→ *\n   256→ * FaceIQ PARITY FIX #2: Manual overrides update landmark positions only.\n   257→ * The FaceIQ rotation reference (indices 10, 26, 75) is preserved from rawLandmarks.\n   258→ * Frankfort plane is updated for DISPLAY purposes only, not normalization.\n   259→ *\n   260→ * @param result - Original detection result\n   261→ * @param overrides - Manual landmark adjustments (in pixel coordinates)\n   262→ * @returns Updated result with overrides applied\n   263→ */\n   264→export function applyManualOverrides(\n   265→  result: ServerDetectionResult,\n   266→  overrides: LandmarkOverride[]\n   267→): ServerDetectionResult {\n   268→  if (!overrides.length) return result;\n   269→\n   270→  const mergedLandmarks = mergeWithOverrides(result.landmarks, overrides);\n   271→  const adjustedIds = overrides.map(o => o.id);\n   272→\n   273→  // FaceIQ PARITY: Update Frankfort plane for DISPLAY only (not normalization)\n   274→  // Normalization ALWAYS uses FaceIQ indices 10, 26, 75 from rawLandmarks\n   275→  const updatedFrankfort = recalculateFrankfortPlane(mergedLandmarks);\n   276→\n   277→  return {\n   278→    ...result,\n   279→    landmarks: mergedLandmarks,\n   280→    frankfortPlane: updatedFrankfort || result.frankfortPlane,  // Display only\n   281→    manuallyAdjusted: adjustedIds,\n   282→    // rawLandmarks preserved unchanged - critical for FaceIQ rotation\n   283→  };\n   284→}\n   285→\n   286→/**\n   287→ * Check if a landmark is estimated (vs directly detected)\n   288→ */\n   289→export function isEstimatedLandmark(landmarkId: string): boolean {\n   290→  return ESTIMATED_LANDMARK_IDS.includes(landmarkId as EstimatedLandmarkId);\n   291→}\n   292→\n\n</system-reminder>\n"}]},"uuid":"7d4a0d45-490b-428f-850a-0c960d5ba13b","timestamp":"2025-12-30T15:24:52.683Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/serverSideDetection.ts","content":"/**\n * Server-Side Detection Service for Side Profiles\n *\n * Calls the Railway-hosted InsightFace API for accurate side profile detection.\n * Returns 106 raw landmarks mapped to our 28 cephalometric landmarks.\n *\n * Supports manual overrides for estimated landmarks (porion, tragus, intertragicNotch)\n * to achieve FaceIQ-level Frankfort plane accuracy.\n */\n\nimport { SideLandmarkResponse } from '@/app/api/side-landmarks/route';\n\n/**\n * Landmarks that are geometrically estimated and benefit from manual adjustment\n */\nexport const ESTIMATED_LANDMARK_IDS = ['porion', 'tragus', 'intertragicNotch'] as const;\nexport type EstimatedLandmarkId = typeof ESTIMATED_LANDMARK_IDS[number];\n\nexport interface ServerDetectionResult {\n  landmarks: Array<{ id: string; x: number; y: number }>;  // In PIXEL coordinates\n  rawLandmarks?: Array<{ x: number; y: number }>;  // Raw 106 landmarks for FaceIQ-style normalization (pixels)\n  confidence: number;\n  faceBox: { x: number; y: number; width: number; height: number };\n  direction?: 'left' | 'right';\n  rotationAngle?: number;\n  frankfortPlane?: {\n    angle: number;\n    orbitale: { x: number; y: number };\n    porion: { x: number; y: number };\n  };\n  /** Image dimensions for normalization AFTER rotation */\n  imageDimensions: { width: number; height: number };\n  /** Rotated image URL (for display with rotated landmarks) */\n  rotatedImageUrl?: string;\n  /** Tracks which landmarks were manually adjusted */\n  manuallyAdjusted?: string[];\n}\n\n/**\n * Manual landmark override for estimated ear landmarks\n */\nexport interface LandmarkOverride {\n  id: string;\n  x: number;\n  y: number;\n}\n\n/**\n * Convert image URL to base64\n */\nasync function imageUrlToBase64(imageUrl: string): Promise<string> {\n  // If it's already a data URL, extract the base64 part\n  if (imageUrl.startsWith('data:')) {\n    return imageUrl;\n  }\n\n  // If it's a blob URL or regular URL, fetch and convert\n  const response = await fetch(imageUrl);\n  const blob = await response.blob();\n\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      if (typeof reader.result === 'string') {\n        resolve(reader.result);\n      } else {\n        reject(new Error('Failed to convert to base64'));\n      }\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\n\n/**\n * Get image dimensions\n */\nfunction getImageDimensions(imageUrl: string): Promise<{ width: number; height: number }> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });\n    img.onerror = reject;\n    img.src = imageUrl;\n  });\n}\n\n/**\n * Calculate Frankfort Horizontal Plane from orbitale and porion landmarks\n */\nfunction calculateFrankfortPlane(\n  orbitale: { x: number; y: number },\n  porion: { x: number; y: number }\n): { angle: number; orbitale: { x: number; y: number }; porion: { x: number; y: number } } {\n  // Calculate angle from horizontal (in degrees)\n  const dx = porion.x - orbitale.x;\n  const dy = porion.y - orbitale.y;\n  const angle = Math.atan2(dy, dx) * (180 / Math.PI);\n\n  return {\n    angle,\n    orbitale,\n    porion,\n  };\n}\n\n/**\n * Detect side profile landmarks using server-side InsightFace API\n */\nexport async function detectSideProfileServer(\n  imageUrl: string\n): Promise<ServerDetectionResult | null> {\n  try {\n    console.log('[ServerDetection] Starting server-side detection...');\n\n    // Convert image to base64\n    const base64Image = await imageUrlToBase64(imageUrl);\n\n    // Call our API proxy\n    const response = await fetch('/api/side-landmarks', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ image: base64Image }),\n    });\n\n    if (!response.ok) {\n      console.error('[ServerDetection] API error:', response.status);\n      return null;\n    }\n\n    const data: SideLandmarkResponse = await response.json();\n\n    if (!data.success || !data.data?.namedLandmarks) {\n      console.log('[ServerDetection] Detection failed:', data.error || 'No landmarks found');\n      return null;\n    }\n\n    const resultData = data.data;\n    console.log('[ServerDetection] Detection successful, count:', resultData.landmarkCount);\n\n    // Get image dimensions for normalization\n    const { width, height } = await getImageDimensions(imageUrl);\n    console.log('[ServerDetection] Image dimensions:', width, 'x', height);\n\n    // FaceIQ PARITY FIX #1: Keep landmarks in PIXEL coordinates (NOT normalized 0-1)\n    // Normalization must happen AFTER FaceIQ rotation algorithm\n    const landmarks = Object.entries(resultData.namedLandmarks).map(([id, point]) => ({\n      id,\n      x: point.x,  // Keep pixel coordinates\n      y: point.y,  // Keep pixel coordinates\n    }));\n\n    // Keep raw landmarks in pixel coordinates for FaceIQ rotation (indices 10, 26, 75)\n    const rawLandmarks = resultData.landmarks?.map(pt => ({\n      x: pt.x,  // Keep pixel coordinates\n      y: pt.y,  // Keep pixel coordinates\n    })) || [];\n\n    // Use Frankfort Plane from server if available (future proof), otherwise calculate locally\n    let frankfortPlane: ServerDetectionResult['frankfortPlane'];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const serverFrankfort = (resultData as any).frankfort_plane;\n\n    if (serverFrankfort) {\n      frankfortPlane = serverFrankfort;\n      console.log('[ServerDetection] Frankfort Plane angle (from server):', serverFrankfort.angle.toFixed(2), 'degrees');\n    } else {\n      // Find normalized orbitale and porion from our processed list\n      const normOrbitale = landmarks.find(l => l.id === 'orbitale');\n      const normPorion = landmarks.find(l => l.id === 'porion');\n\n      if (normOrbitale && normPorion) {\n        frankfortPlane = calculateFrankfortPlane(normOrbitale, normPorion);\n        console.log('[ServerDetection] Frankfort Plane angle (calculated):', frankfortPlane.angle.toFixed(2), 'degrees');\n      }\n    }\n\n    return {\n      landmarks,  // Pixel coordinates (NOT normalized)\n      rawLandmarks,  // Raw 106 landmarks in pixel coordinates for FaceIQ algorithm\n      confidence: 0.95, // InsightFace is generally high confidence\n      faceBox: resultData.crop || { x: 0, y: 0, width: 1, height: 1 },\n      direction: resultData.direction,\n      rotationAngle: resultData.rotationAngle,\n      frankfortPlane,\n      imageDimensions: { width, height },  // For normalization AFTER rotation\n    };\n  } catch (error) {\n    console.error('[ServerDetection] Error:', error);\n    return null;\n  }\n}\n\n/**\n * Merge manual landmark overrides with detected landmarks\n *\n * Used for applying user adjustments to estimated ear landmarks\n * (porion, tragus, intertragicNotch) for FaceIQ-level accuracy.\n *\n * @param detectedLandmarks - Landmarks from server detection\n * @param overrides - Manual adjustments from user\n * @returns Merged landmarks with manual overrides applied\n */\nexport function mergeWithOverrides(\n  detectedLandmarks: Array<{ id: string; x: number; y: number }>,\n  overrides: LandmarkOverride[]\n): Array<{ id: string; x: number; y: number }> {\n  if (!overrides.length) return detectedLandmarks;\n\n  const overrideMap = new Map(overrides.map(o => [o.id, o]));\n\n  return detectedLandmarks.map(landmark => {\n    const override = overrideMap.get(landmark.id);\n    if (override) {\n      console.log(`[ServerDetection] Applied override for ${landmark.id}:`, {\n        original: { x: landmark.x.toFixed(4), y: landmark.y.toFixed(4) },\n        adjusted: { x: override.x.toFixed(4), y: override.y.toFixed(4) },\n      });\n      return { ...landmark, x: override.x, y: override.y };\n    }\n    return landmark;\n  });\n}\n\n/**\n * Recalculate Frankfort Horizontal Plane after manual adjustments\n *\n * Call this after applying overrides to porion or orbitale to update\n * the Frankfort plane angle used in side profile analysis.\n *\n * @param landmarks - Merged landmarks with overrides applied\n * @returns Updated Frankfort plane calculation or null if landmarks not found\n */\nexport function recalculateFrankfortPlane(\n  landmarks: Array<{ id: string; x: number; y: number }>\n): ServerDetectionResult['frankfortPlane'] | null {\n  const orbitale = landmarks.find(l => l.id === 'orbitale');\n  const porion = landmarks.find(l => l.id === 'porion');\n\n  if (!orbitale || !porion) {\n    console.warn('[ServerDetection] Cannot calculate Frankfort plane: missing orbitale or porion');\n    return null;\n  }\n\n  const plane = calculateFrankfortPlane(orbitale, porion);\n  console.log('[ServerDetection] Recalculated Frankfort Plane angle:', plane.angle.toFixed(2), 'degrees');\n\n  return plane;\n}\n\n/**\n * Apply manual overrides to a detection result\n *\n * FaceIQ PARITY FIX #2: Manual overrides update landmark positions only.\n * The FaceIQ rotation reference (indices 10, 26, 75) is preserved from rawLandmarks.\n * Frankfort plane is updated for DISPLAY purposes only, not normalization.\n *\n * @param result - Original detection result\n * @param overrides - Manual landmark adjustments (in pixel coordinates)\n * @returns Updated result with overrides applied\n */\nexport function applyManualOverrides(\n  result: ServerDetectionResult,\n  overrides: LandmarkOverride[]\n): ServerDetectionResult {\n  if (!overrides.length) return result;\n\n  const mergedLandmarks = mergeWithOverrides(result.landmarks, overrides);\n  const adjustedIds = overrides.map(o => o.id);\n\n  // FaceIQ PARITY: Update Frankfort plane for DISPLAY only (not normalization)\n  // Normalization ALWAYS uses FaceIQ indices 10, 26, 75 from rawLandmarks\n  const updatedFrankfort = recalculateFrankfortPlane(mergedLandmarks);\n\n  return {\n    ...result,\n    landmarks: mergedLandmarks,\n    frankfortPlane: updatedFrankfort || result.frankfortPlane,  // Display only\n    manuallyAdjusted: adjustedIds,\n    // rawLandmarks preserved unchanged - critical for FaceIQ rotation\n  };\n}\n\n/**\n * Check if a landmark is estimated (vs directly detected)\n */\nexport function isEstimatedLandmark(landmarkId: string): boolean {\n  return ESTIMATED_LANDMARK_IDS.includes(landmarkId as EstimatedLandmarkId);\n}\n","numLines":292,"startLine":1,"totalLines":292}}}
{"parentUuid":"7d4a0d45-490b-428f-850a-0c960d5ba13b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Eb7LsFTzA8N2o1d7e4fLvB","type":"tool_result","content":"     1→/**\n     2→ * Facial Landmark Types and Default Data\n     3→ * Based on TECHNICAL_SPECS.md medical terminology\n     4→ */\n     5→\n     6→export interface LandmarkPoint {\n     7→  id: string;\n     8→  label: string;\n     9→  medicalTerm: string;\n    10→  description: string;\n    11→  x: number;\n    12→  y: number;\n    13→  category: string;\n    14→}\n    15→\n    16→export interface LandmarkCategory {\n    17→  name: string;\n    18→  color: string;\n    19→  landmarks: string[];\n    20→}\n    21→\n    22→// ============================================\n    23→// FRONT PROFILE LANDMARKS (52 Points)\n    24→// ============================================\n    25→\n    26→export const FRONT_LANDMARK_CATEGORIES: LandmarkCategory[] = [\n    27→  {\n    28→    name: 'Head',\n    29→    color: '#FF6B6B',\n    30→    landmarks: ['trichion'],\n    31→  },\n    32→  {\n    33→    name: 'Eyes - Left',\n    34→    color: '#4ECDC4',\n    35→    landmarks: [\n    36→      'left_pupila',\n    37→      'left_canthus_medialis',\n    38→      'left_canthus_lateralis',\n    39→      'left_palpebra_superior',\n    40→      'left_palpebra_inferior',\n    41→      'left_sulcus_palpebralis_lateralis',\n    42→      'left_pretarsal_skin_crease',\n    43→    ],\n    44→  },\n    45→  {\n    46→    name: 'Eyes - Right',\n    47→    color: '#45B7D1',\n    48→    landmarks: [\n    49→      'right_pupila',\n    50→      'right_canthus_medialis',\n    51→      'right_canthus_lateralis',\n    52→      'right_palpebra_superior',\n    53→      'right_palpebra_inferior',\n    54→      'right_sulcus_palpebralis_lateralis',\n    55→      'right_pretarsal_skin_crease',\n    56→    ],\n    57→  },\n    58→  {\n    59→    name: 'Eyebrows - Left',\n    60→    color: '#96CEB4',\n    61→    landmarks: [\n    62→      'left_supercilium_medialis',\n    63→      'left_supercilium_medial_corner',\n    64→      'left_supercilium_superior',\n    65→      'left_supercilium_apex',\n    66→      'left_supercilium_lateralis',\n    67→    ],\n    68→  },\n    69→  {\n    70→    name: 'Eyebrows - Right',\n    71→    color: '#88D8B0',\n    72→    landmarks: [\n    73→      'right_supercilium_medialis',\n    74→      'right_supercilium_medial_corner',\n    75→      'right_supercilium_superior',\n    76→      'right_supercilium_apex',\n    77→      'right_supercilium_lateralis',\n    78→    ],\n    79→  },\n    80→  {\n    81→    name: 'Nose',\n    82→    color: '#FFEAA7',\n    83→    landmarks: [\n    84→      'nasal_base',\n    85→      'left_dorsum_nasi',\n    86→      'right_dorsum_nasi',\n    87→      'left_ala_nasi',\n    88→      'right_ala_nasi',\n    89→      'subnasale',\n    90→    ],\n    91→  },\n    92→  {\n    93→    name: 'Mouth',\n    94→    color: '#DDA0DD',\n    95→    landmarks: [\n    96→      'labrale_superius',\n    97→      'cupids_bow',\n    98→      'mouth_middle',\n    99→      'labrale_inferius',\n   100→      'left_cheilion',\n   101→      'right_cheilion',\n   102→    ],\n   103→  },\n   104→  {\n   105→    name: 'Jaw',\n   106→    color: '#F39C12',\n   107→    landmarks: [\n   108→      'left_gonion_superior',\n   109→      'right_gonion_superior',\n   110→      'left_gonion_inferior',\n   111→      'right_gonion_inferior',\n   112→    ],\n   113→  },\n   114→  {\n   115→    name: 'Chin',\n   116→    color: '#E74C3C',\n   117→    landmarks: ['left_mentum_lateralis', 'right_mentum_lateralis', 'menton'],\n   118→  },\n   119→  {\n   120→    name: 'Face Width',\n   121→    color: '#9B59B6',\n   122→    landmarks: [\n   123→      'left_zygion',\n   124→      'right_zygion',\n   125→      'left_temporal',\n   126→      'right_temporal',\n   127→      'left_auricular_lateral',\n   128→      'right_auricular_lateral',\n   129→    ],\n   130→  },\n   131→  {\n   132→    name: 'Neck',\n   133→    color: '#1ABC9C',\n   134→    landmarks: ['left_cervical_lateralis', 'right_cervical_lateralis'],\n   135→  },\n   136→];\n   137→\n   138→export const FRONT_PROFILE_LANDMARKS: LandmarkPoint[] = [\n   139→  // Head/Hair\n   140→  {\n   141→    id: 'trichion',\n   142→    label: 'Hairline',\n   143→    medicalTerm: 'Trichion (frontal view)',\n   144→    description: 'Anterior hairline at midline',\n   145→    x: 0.5,\n   146→    y: 0.08,\n   147→    category: 'Head',\n   148→  },\n   149→\n   150→  // Eyes - Left\n   151→  {\n   152→    id: 'left_pupila',\n   153→    label: 'Left Pupil',\n   154→    medicalTerm: 'Left Pupila',\n   155→    description: 'Center of left pupil',\n   156→    x: 0.38,\n   157→    y: 0.35,\n   158→    category: 'Eyes - Left',\n   159→  },\n   160→  {\n   161→    id: 'left_canthus_medialis',\n   162→    label: 'Left Medial Canthus',\n   163→    medicalTerm: 'Left Canthus Medialis',\n   164→    description: 'Inner corner of left eye',\n   165→    x: 0.42,\n   166→    y: 0.35,\n   167→    category: 'Eyes - Left',\n   168→  },\n   169→  {\n   170→    id: 'left_canthus_lateralis',\n   171→    label: 'Left Lateral Canthus',\n   172→    medicalTerm: 'Left Canthus Lateralis',\n   173→    description: 'Outer corner of left eye',\n   174→    x: 0.32,\n   175→    y: 0.34,\n   176→    category: 'Eyes - Left',\n   177→  },\n   178→  {\n   179→    id: 'left_palpebra_superior',\n   180→    label: 'Left Upper Eyelid',\n   181→    medicalTerm: 'Left Palpebra Superior',\n   182→    description: 'Upper eyelid of left eye',\n   183→    x: 0.37,\n   184→    y: 0.33,\n   185→    category: 'Eyes - Left',\n   186→  },\n   187→  {\n   188→    id: 'left_palpebra_inferior',\n   189→    label: 'Left Lower Eyelid',\n   190→    medicalTerm: 'Left Palpebra Inferior',\n   191→    description: 'Lower eyelid of left eye',\n   192→    x: 0.37,\n   193→    y: 0.37,\n   194→    category: 'Eyes - Left',\n   195→  },\n   196→  {\n   197→    id: 'left_sulcus_palpebralis_lateralis',\n   198→    label: 'Left Eyelid Hood End',\n   199→    medicalTerm: 'Left Sulcus Palpebralis Lateralis',\n   200→    description: 'Lateral end of left upper eyelid crease',\n   201→    x: 0.31,\n   202→    y: 0.33,\n   203→    category: 'Eyes - Left',\n   204→  },\n   205→  {\n   206→    id: 'left_pretarsal_skin_crease',\n   207→    label: 'Left Upper Eyelid Crease',\n   208→    medicalTerm: 'Left Pretarsal Skin Crease',\n   209→    description: 'Left upper eyelid crease',\n   210→    x: 0.37,\n   211→    y: 0.32,\n   212→    category: 'Eyes - Left',\n   213→  },\n   214→\n   215→  // Eyes - Right\n   216→  {\n   217→    id: 'right_pupila',\n   218→    label: 'Right Pupil',\n   219→    medicalTerm: 'Right Pupila',\n   220→    description: 'Center of right pupil',\n   221→    x: 0.62,\n   222→    y: 0.35,\n   223→    category: 'Eyes - Right',\n   224→  },\n   225→  {\n   226→    id: 'right_canthus_medialis',\n   227→    label: 'Right Medial Canthus',\n   228→    medicalTerm: 'Right Canthus Medialis',\n   229→    description: 'Inner corner of right eye',\n   230→    x: 0.58,\n   231→    y: 0.35,\n   232→    category: 'Eyes - Right',\n   233→  },\n   234→  {\n   235→    id: 'right_canthus_lateralis',\n   236→    label: 'Right Lateral Canthus',\n   237→    medicalTerm: 'Right Canthus Lateralis',\n   238→    description: 'Outer corner of right eye',\n   239→    x: 0.68,\n   240→    y: 0.34,\n   241→    category: 'Eyes - Right',\n   242→  },\n   243→  {\n   244→    id: 'right_palpebra_superior',\n   245→    label: 'Right Upper Eyelid',\n   246→    medicalTerm: 'Right Palpebra Superior',\n   247→    description: 'Upper eyelid of right eye',\n   248→    x: 0.63,\n   249→    y: 0.33,\n   250→    category: 'Eyes - Right',\n   251→  },\n   252→  {\n   253→    id: 'right_palpebra_inferior',\n   254→    label: 'Right Lower Eyelid',\n   255→    medicalTerm: 'Right Palpebra Inferior',\n   256→    description: 'Lower eyelid of right eye',\n   257→    x: 0.63,\n   258→    y: 0.37,\n   259→    category: 'Eyes - Right',\n   260→  },\n   261→  {\n   262→    id: 'right_sulcus_palpebralis_lateralis',\n   263→    label: 'Right Eyelid Hood End',\n   264→    medicalTerm: 'Right Sulcus Palpebralis Lateralis',\n   265→    description: 'Lateral end of right upper eyelid crease',\n   266→    x: 0.69,\n   267→    y: 0.33,\n   268→    category: 'Eyes - Right',\n   269→  },\n   270→  {\n   271→    id: 'right_pretarsal_skin_crease',\n   272→    label: 'Right Upper Eyelid Crease',\n   273→    medicalTerm: 'Right Pretarsal Skin Crease',\n   274→    description: 'Right upper eyelid crease',\n   275→    x: 0.63,\n   276→    y: 0.32,\n   277→    category: 'Eyes - Right',\n   278→  },\n   279→\n   280→  // Eyebrows - Left\n   281→  {\n   282→    id: 'left_supercilium_medialis',\n   283→    label: 'Left Brow Head',\n   284→    medicalTerm: 'Left Supercilium Medialis',\n   285→    description: 'Medial start of left eyebrow',\n   286→    x: 0.43,\n   287→    y: 0.28,\n   288→    category: 'Eyebrows - Left',\n   289→  },\n   290→  {\n   291→    id: 'left_supercilium_medial_corner',\n   292→    label: 'Left Brow Inner Corner',\n   293→    medicalTerm: 'Left Supercilium Medial Corner',\n   294→    description: 'Inner corner of left eyebrow',\n   295→    x: 0.41,\n   296→    y: 0.27,\n   297→    category: 'Eyebrows - Left',\n   298→  },\n   299→  {\n   300→    id: 'left_supercilium_superior',\n   301→    label: 'Left Brow Arch',\n   302→    medicalTerm: 'Left Supercilium Superior',\n   303→    description: 'Superior arc of left eyebrow',\n   304→    x: 0.36,\n   305→    y: 0.26,\n   306→    category: 'Eyebrows - Left',\n   307→  },\n   308→  {\n   309→    id: 'left_supercilium_apex',\n   310→    label: 'Left Brow Peak',\n   311→    medicalTerm: 'Left Supercilium Apex',\n   312→    description: 'Highest point of left eyebrow',\n   313→    x: 0.34,\n   314→    y: 0.26,\n   315→    category: 'Eyebrows - Left',\n   316→  },\n   317→  {\n   318→    id: 'left_supercilium_lateralis',\n   319→    label: 'Left Brow Tail',\n   320→    medicalTerm: 'Left Supercilium Lateralis',\n   321→    description: 'Lateral end of left eyebrow',\n   322→    x: 0.29,\n   323→    y: 0.28,\n   324→    category: 'Eyebrows - Left',\n   325→  },\n   326→\n   327→  // Eyebrows - Right\n   328→  {\n   329→    id: 'right_supercilium_medialis',\n   330→    label: 'Right Brow Head',\n   331→    medicalTerm: 'Right Supercilium Medialis',\n   332→    description: 'Medial start of right eyebrow',\n   333→    x: 0.57,\n   334→    y: 0.28,\n   335→    category: 'Eyebrows - Right',\n   336→  },\n   337→  {\n   338→    id: 'right_supercilium_medial_corner',\n   339→    label: 'Right Brow Inner Corner',\n   340→    medicalTerm: 'Right Supercilium Medial Corner',\n   341→    description: 'Inner corner of right eyebrow',\n   342→    x: 0.59,\n   343→    y: 0.27,\n   344→    category: 'Eyebrows - Right',\n   345→  },\n   346→  {\n   347→    id: 'right_supercilium_superior',\n   348→    label: 'Right Brow Arch',\n   349→    medicalTerm: 'Right Supercilium Superior',\n   350→    description: 'Superior arc of right eyebrow',\n   351→    x: 0.64,\n   352→    y: 0.26,\n   353→    category: 'Eyebrows - Right',\n   354→  },\n   355→  {\n   356→    id: 'right_supercilium_apex',\n   357→    label: 'Right Brow Peak',\n   358→    medicalTerm: 'Right Supercilium Apex',\n   359→    description: 'Highest point of right eyebrow',\n   360→    x: 0.66,\n   361→    y: 0.26,\n   362→    category: 'Eyebrows - Right',\n   363→  },\n   364→  {\n   365→    id: 'right_supercilium_lateralis',\n   366→    label: 'Right Brow Tail',\n   367→    medicalTerm: 'Right Supercilium Lateralis',\n   368→    description: 'Lateral end of right eyebrow',\n   369→    x: 0.71,\n   370→    y: 0.28,\n   371→    category: 'Eyebrows - Right',\n   372→  },\n   373→\n   374→  // Nose\n   375→  {\n   376→    id: 'nasal_base',\n   377→    label: 'Nasal Base',\n   378→    medicalTerm: 'Nasal Base',\n   379→    description: 'Base of nasal dorsum',\n   380→    x: 0.5,\n   381→    y: 0.38,\n   382→    category: 'Nose',\n   383→  },\n   384→  {\n   385→    id: 'left_dorsum_nasi',\n   386→    label: 'Left Nose Bridge',\n   387→    medicalTerm: 'Left Dorsum Nasi',\n   388→    description: 'Left side of nasal bridge',\n   389→    x: 0.47,\n   390→    y: 0.42,\n   391→    category: 'Nose',\n   392→  },\n   393→  {\n   394→    id: 'right_dorsum_nasi',\n   395→    label: 'Right Nose Bridge',\n   396→    medicalTerm: 'Right Dorsum Nasi',\n   397→    description: 'Right side of nasal bridge',\n   398→    x: 0.53,\n   399→    y: 0.42,\n   400→    category: 'Nose',\n   401→  },\n   402→  {\n   403→    id: 'left_ala_nasi',\n   404→    label: 'Left Nose Side',\n   405→    medicalTerm: 'Left Ala Nasi',\n   406→    description: 'Lateral aspect of left nasal ala',\n   407→    x: 0.44,\n   408→    y: 0.5,\n   409→    category: 'Nose',\n   410→  },\n   411→  {\n   412→    id: 'right_ala_nasi',\n   413→    label: 'Right Nose Side',\n   414→    medicalTerm: 'Right Ala Nasi',\n   415→    description: 'Lateral aspect of right nasal ala',\n   416→    x: 0.56,\n   417→    y: 0.5,\n   418→    category: 'Nose',\n   419→  },\n   420→  {\n   421→    id: 'subnasale',\n   422→    label: 'Nose Bottom',\n   423→    medicalTerm: 'Subnasale',\n   424→    description: 'Junction of columella and upper lip',\n   425→    x: 0.5,\n   426→    y: 0.52,\n   427→    category: 'Nose',\n   428→  },\n   429→\n   430→  // Mouth\n   431→  {\n   432→    id: 'labrale_superius',\n   433→    label: \"Cupid's Bow\",\n   434→    medicalTerm: 'Labrale Superius',\n   435→    description: 'Midpoint of upper lip vermilion',\n   436→    x: 0.5,\n   437→    y: 0.58,\n   438→    category: 'Mouth',\n   439→  },\n   440→  {\n   441→    id: 'cupids_bow',\n   442→    label: \"Inner Cupid's Bow\",\n   443→    medicalTerm: \"Cupid's Bow\",\n   444→    description: 'Central peak of upper lip',\n   445→    x: 0.5,\n   446→    y: 0.57,\n   447→    category: 'Mouth',\n   448→  },\n   449→  {\n   450→    id: 'mouth_middle',\n   451→    label: 'Mouth Middle',\n   452→    medicalTerm: 'Mouth Middle',\n   453→    description: 'Center of mouth opening',\n   454→    x: 0.5,\n   455→    y: 0.62,\n   456→    category: 'Mouth',\n   457→  },\n   458→  {\n   459→    id: 'labrale_inferius',\n   460→    label: 'Lower Lip Center',\n   461→    medicalTerm: 'Labrale Inferius',\n   462→    description: 'Midpoint of lower lip vermilion border',\n   463→    x: 0.5,\n   464→    y: 0.66,\n   465→    category: 'Mouth',\n   466→  },\n   467→  {\n   468→    id: 'left_cheilion',\n   469→    label: 'Left Mouth Corner',\n   470→    medicalTerm: 'Left Cheilion',\n   471→    description: 'Left oral commissure',\n   472→    x: 0.42,\n   473→    y: 0.62,\n   474→    category: 'Mouth',\n   475→  },\n   476→  {\n   477→    id: 'right_cheilion',\n   478→    label: 'Right Mouth Corner',\n   479→    medicalTerm: 'Right Cheilion',\n   480→    description: 'Right oral commissure',\n   481→    x: 0.58,\n   482→    y: 0.62,\n   483→    category: 'Mouth',\n   484→  },\n   485→\n   486→  // Jaw\n   487→  {\n   488→    id: 'left_gonion_superior',\n   489→    label: 'Left Upper Jaw Angle',\n   490→    medicalTerm: 'Left Gonion Superior',\n   491→    description: 'Superior aspect of left mandibular angle',\n   492→    x: 0.22,\n   493→    y: 0.55,\n   494→    category: 'Jaw',\n   495→  },\n   496→  {\n   497→    id: 'right_gonion_superior',\n   498→    label: 'Right Upper Jaw Angle',\n   499→    medicalTerm: 'Right Gonion Superior',\n   500→    description: 'Superior aspect of right mandibular angle',\n   501→    x: 0.78,\n   502→    y: 0.55,\n   503→    category: 'Jaw',\n   504→  },\n   505→  {\n   506→    id: 'left_gonion_inferior',\n   507→    label: 'Left Lower Jaw Angle',\n   508→    medicalTerm: 'Left Gonion Inferior',\n   509→    description: 'Inferior aspect of left mandibular angle',\n   510→    x: 0.24,\n   511→    y: 0.7,\n   512→    category: 'Jaw',\n   513→  },\n   514→  {\n   515→    id: 'right_gonion_inferior',\n   516→    label: 'Right Lower Jaw Angle',\n   517→    medicalTerm: 'Right Gonion Inferior',\n   518→    description: 'Inferior aspect of right mandibular angle',\n   519→    x: 0.76,\n   520→    y: 0.7,\n   521→    category: 'Jaw',\n   522→  },\n   523→\n   524→  // Chin\n   525→  {\n   526→    id: 'left_mentum_lateralis',\n   527→    label: 'Left Chin',\n   528→    medicalTerm: 'Left Mentum Lateralis',\n   529→    description: 'Left lateral chin',\n   530→    x: 0.42,\n   531→    y: 0.8,\n   532→    category: 'Chin',\n   533→  },\n   534→  {\n   535→    id: 'right_mentum_lateralis',\n   536→    label: 'Right Chin',\n   537→    medicalTerm: 'Right Mentum Lateralis',\n   538→    description: 'Right lateral chin',\n   539→    x: 0.58,\n   540→    y: 0.8,\n   541→    category: 'Chin',\n   542→  },\n   543→  {\n   544→    id: 'menton',\n   545→    label: 'Chin Bottom',\n   546→    medicalTerm: 'Menton',\n   547→    description: 'Lowest point of chin in midline',\n   548→    x: 0.5,\n   549→    y: 0.88,\n   550→    category: 'Chin',\n   551→  },\n   552→\n   553→  // Face Width\n   554→  {\n   555→    id: 'left_zygion',\n   556→    label: 'Left Cheekbone',\n   557→    medicalTerm: 'Left Zygion',\n   558→    description: 'Most lateral point of left zygomatic arch',\n   559→    x: 0.18,\n   560→    y: 0.42,\n   561→    category: 'Face Width',\n   562→  },\n   563→  {\n   564→    id: 'right_zygion',\n   565→    label: 'Right Cheekbone',\n   566→    medicalTerm: 'Right Zygion',\n   567→    description: 'Most lateral point of right zygomatic arch',\n   568→    x: 0.82,\n   569→    y: 0.42,\n   570→    category: 'Face Width',\n   571→  },\n   572→  {\n   573→    id: 'left_temporal',\n   574→    label: 'Left Temple',\n   575→    medicalTerm: 'Left Temporal Point',\n   576→    description: 'Left temporal region',\n   577→    x: 0.2,\n   578→    y: 0.3,\n   579→    category: 'Face Width',\n   580→  },\n   581→  {\n   582→    id: 'right_temporal',\n   583→    label: 'Right Temple',\n   584→    medicalTerm: 'Right Temporal Point',\n   585→    description: 'Right temporal region',\n   586→    x: 0.8,\n   587→    y: 0.3,\n   588→    category: 'Face Width',\n   589→  },\n   590→  {\n   591→    id: 'left_auricular_lateral',\n   592→    label: 'Left Outer Ear',\n   593→    medicalTerm: 'Left Auricular Lateral Point',\n   594→    description: 'Lateral-most point of left ear',\n   595→    x: 0.12,\n   596→    y: 0.4,\n   597→    category: 'Face Width',\n   598→  },\n   599→  {\n   600→    id: 'right_auricular_lateral',\n   601→    label: 'Right Outer Ear',\n   602→    medicalTerm: 'Right Auricular Lateral Point',\n   603→    description: 'Lateral-most point of right ear',\n   604→    x: 0.88,\n   605→    y: 0.4,\n   606→    category: 'Face Width',\n   607→  },\n   608→\n   609→  // Neck\n   610→  {\n   611→    id: 'left_cervical_lateralis',\n   612→    label: 'Left Neck Point',\n   613→    medicalTerm: 'Left Cervical Lateralis',\n   614→    description: 'Left cervical point',\n   615→    x: 0.35,\n   616→    y: 0.95,\n   617→    category: 'Neck',\n   618→  },\n   619→  {\n   620→    id: 'right_cervical_lateralis',\n   621→    label: 'Right Neck Point',\n   622→    medicalTerm: 'Right Cervical Lateralis',\n   623→    description: 'Right cervical point',\n   624→    x: 0.65,\n   625→    y: 0.95,\n   626→    category: 'Neck',\n   627→  },\n   628→];\n   629→\n   630→// ============================================\n   631→// SIDE PROFILE LANDMARKS (31 Points)\n   632→// FaceIQ Parity - Matches FaceIQ's exact order and flow\n   633→// ============================================\n   634→\n   635→export const SIDE_LANDMARK_CATEGORIES: LandmarkCategory[] = [\n   636→  {\n   637→    name: 'Head',\n   638→    color: '#FF6B6B',\n   639→    landmarks: ['vertex', 'occiput'],\n   640→  },\n   641→  {\n   642→    name: 'Forehead',\n   643→    color: '#4ECDC4',\n   644→    landmarks: ['trichion', 'forehead', 'glabella'],\n   645→  },\n   646→  {\n   647→    name: 'Eye Region',\n   648→    color: '#45B7D1',\n   649→    landmarks: ['orbitale', 'cornealApex', 'eyelidEnd', 'lowerEyelid'],\n   650→  },\n   651→  {\n   652→    name: 'Ear',\n   653→    color: '#3498DB',\n   654→    landmarks: ['porion', 'tragus', 'intertragicNotch'],\n   655→  },\n   656→  {\n   657→    name: 'Cheek',\n   658→    color: '#9B59B6',\n   659→    landmarks: ['cheekbone'],\n   660→  },\n   661→  {\n   662→    name: 'Nose',\n   663→    color: '#FFEAA7',\n   664→    landmarks: [\n   665→      'nasion',\n   666→      'rhinion',\n   667→      'supratip',\n   668→      'pronasale',\n   669→      'infratip',\n   670→      'columella',\n   671→      'subnasale',\n   672→      'subalare',\n   673→    ],\n   674→  },\n   675→  {\n   676→    name: 'Lips',\n   677→    color: '#DDA0DD',\n   678→    landmarks: ['labraleSuperius', 'cheilion', 'labraleInferius', 'sublabiale'],\n   679→  },\n   680→  {\n   681→    name: 'Chin',\n   682→    color: '#E74C3C',\n   683→    landmarks: ['pogonion', 'menton'],\n   684→  },\n   685→  {\n   686→    name: 'Jaw',\n   687→    color: '#F39C12',\n   688→    landmarks: ['gonionTop', 'gonionBottom'],\n   689→  },\n   690→  {\n   691→    name: 'Neck',\n   692→    color: '#1ABC9C',\n   693→    landmarks: ['cervicalPoint', 'neckPoint'],\n   694→  },\n   695→];\n   696→\n   697→// FaceIQ Parity Order: Matches FaceIQ's exact flow (1 of 31 → 31 of 31)\n   698→// Head → Forehead → Eye → Ear → Cheek → Nose → Lips → Chin → Jaw → Neck\n   699→export const SIDE_PROFILE_LANDMARKS: LandmarkPoint[] = [\n   700→  // ========== HEAD (1-2) ==========\n   701→  {\n   702→    id: 'vertex',\n   703→    label: 'Top of Head',\n   704→    medicalTerm: 'Vertex',\n   705→    description: 'The highest point on the top of the head when looking from the side',\n   706→    x: 0.45,\n   707→    y: 0.02,\n   708→    category: 'Head',\n   709→  },\n   710→  {\n   711→    id: 'occiput',\n   712→    label: 'Back of Head',\n   713→    medicalTerm: 'Occiput',\n   714→    description: 'The most posterior point on the back of the head',\n   715→    x: 0.85,\n   716→    y: 0.15,\n   717→    category: 'Head',\n   718→  },\n   719→\n   720→  // ========== FOREHEAD (3-5) ==========\n   721→  {\n   722→    id: 'trichion',\n   723→    label: 'Hairline',\n   724→    medicalTerm: 'Trichion',\n   725→    description: 'The point where the hairline meets the forehead in the midline',\n   726→    x: 0.35,\n   727→    y: 0.1,\n   728→    category: 'Forehead',\n   729→  },\n   730→  {\n   731→    id: 'forehead',\n   732→    label: 'Forehead Point',\n   733→    medicalTerm: 'Forehead',\n   734→    description: 'The most prominent point on the forehead between hairline and glabella',\n   735→    x: 0.30,\n   736→    y: 0.20,\n   737→    category: 'Forehead',\n   738→  },\n   739→  {\n   740→    id: 'glabella',\n   741→    label: 'Glabella',\n   742→    medicalTerm: 'Glabella',\n   743→    description: 'The most prominent point between the eyebrows',\n   744→    x: 0.32,\n   745→    y: 0.28,\n   746→    category: 'Forehead',\n   747→  },\n   748→\n   749→  // ========== EYE REGION (6-9) ==========\n   750→  {\n   751→    id: 'orbitale',\n   752→    label: 'Orbitale',\n   753→    medicalTerm: 'Orbitale',\n   754→    description: 'The lowest point on the lower edge of the eye socket (orbital rim)',\n   755→    x: 0.35,\n   756→    y: 0.38,\n   757→    category: 'Eye Region',\n   758→  },\n   759→  {\n   760→    id: 'cornealApex',\n   761→    label: 'Corneal Apex',\n   762→    medicalTerm: 'Corneal Apex',\n   763→    description: 'The most anterior point of the cornea (eyeball)',\n   764→    x: 0.28,\n   765→    y: 0.34,\n   766→    category: 'Eye Region',\n   767→  },\n   768→  {\n   769→    id: 'eyelidEnd',\n   770→    label: 'Eyelid End',\n   771→    medicalTerm: 'Lateral Canthus',\n   772→    description: 'The outer corner of the eye where upper and lower eyelids meet',\n   773→    x: 0.38,\n   774→    y: 0.33,\n   775→    category: 'Eye Region',\n   776→  },\n   777→  {\n   778→    id: 'lowerEyelid',\n   779→    label: 'Lower Eyelid',\n   780→    medicalTerm: 'Lower Palpebra',\n   781→    description: 'The lowest point of the lower eyelid margin',\n   782→    x: 0.32,\n   783→    y: 0.36,\n   784→    category: 'Eye Region',\n   785→  },\n   786→\n   787→  // ========== EAR (10-12) - Critical for Frankfort Plane ==========\n   788→  {\n   789→    id: 'porion',\n   790→    label: 'Porion',\n   791→    medicalTerm: 'Porion',\n   792→    description: 'The highest point on the upper margin of the external auditory meatus (ear canal opening). Forms the Frankfort Horizontal Plane with Orbitale.',\n   793→    x: 0.75,\n   794→    y: 0.35,\n   795→    category: 'Ear',\n   796→  },\n   797→  {\n   798→    id: 'tragus',\n   799→    label: 'Tragus',\n   800→    medicalTerm: 'Tragus',\n   801→    description: 'The small pointed cartilage projection in front of the ear canal',\n   802→    x: 0.72,\n   803→    y: 0.42,\n   804→    category: 'Ear',\n   805→  },\n   806→  {\n   807→    id: 'intertragicNotch',\n   808→    label: 'Intertragic Notch',\n   809→    medicalTerm: 'Intertragic Notch',\n   810→    description: 'The depression between the tragus and antitragus of the ear',\n   811→    x: 0.73,\n   812→    y: 0.45,\n   813→    category: 'Ear',\n   814→  },\n   815→\n   816→  // ========== CHEEK (13) ==========\n   817→  {\n   818→    id: 'cheekbone',\n   819→    label: 'Cheekbone',\n   820→    medicalTerm: 'Zygion',\n   821→    description: 'The most lateral point on the zygomatic arch (cheekbone)',\n   822→    x: 0.45,\n   823→    y: 0.42,\n   824→    category: 'Cheek',\n   825→  },\n   826→\n   827→  // ========== NOSE (14-21) ==========\n   828→  {\n   829→    id: 'nasion',\n   830→    label: 'Nasal Bridge Root',\n   831→    medicalTerm: 'Nasion',\n   832→    description: 'The deepest point at the bridge of the nose, between the eyes',\n   833→    x: 0.35,\n   834→    y: 0.32,\n   835→    category: 'Nose',\n   836→  },\n   837→  {\n   838→    id: 'rhinion',\n   839→    label: 'Nasal Bridge',\n   840→    medicalTerm: 'Rhinion',\n   841→    description: 'The midpoint on the nasal bridge',\n   842→    x: 0.28,\n   843→    y: 0.4,\n   844→    category: 'Nose',\n   845→  },\n   846→  {\n   847→    id: 'supratip',\n   848→    label: 'Supratip',\n   849→    medicalTerm: 'Supratip',\n   850→    description: 'The point just above the nose tip, on the dorsum',\n   851→    x: 0.22,\n   852→    y: 0.46,\n   853→    category: 'Nose',\n   854→  },\n   855→  {\n   856→    id: 'pronasale',\n   857→    label: 'Nose Tip',\n   858→    medicalTerm: 'Pronasale',\n   859→    description: 'The most anterior point of the nose tip',\n   860→    x: 0.18,\n   861→    y: 0.48,\n   862→    category: 'Nose',\n   863→  },\n   864→  {\n   865→    id: 'infratip',\n   866→    label: 'Infratip',\n   867→    medicalTerm: 'Infratip',\n   868→    description: 'The point just below the nose tip',\n   869→    x: 0.2,\n   870→    y: 0.5,\n   871→    category: 'Nose',\n   872→  },\n   873→  {\n   874→    id: 'columella',\n   875→    label: 'Columella',\n   876→    medicalTerm: 'Columella',\n   877→    description: 'The skin bridge between the nostrils',\n   878→    x: 0.24,\n   879→    y: 0.52,\n   880→    category: 'Nose',\n   881→  },\n   882→  {\n   883→    id: 'subnasale',\n   884→    label: 'Subnasale',\n   885→    medicalTerm: 'Subnasale',\n   886→    description: 'The point where the columella meets the upper lip',\n   887→    x: 0.3,\n   888→    y: 0.54,\n   889→    category: 'Nose',\n   890→  },\n   891→  {\n   892→    id: 'subalare',\n   893→    label: 'Subalare',\n   894→    medicalTerm: 'Subalare',\n   895→    description: 'The point where the nostril wing meets the cheek',\n   896→    x: 0.28,\n   897→    y: 0.53,\n   898→    category: 'Nose',\n   899→  },\n   900→\n   901→  // ========== LIPS (22-25) ==========\n   902→  {\n   903→    id: 'labraleSuperius',\n   904→    label: 'Upper Lip',\n   905→    medicalTerm: 'Labrale Superius',\n   906→    description: 'The most anterior point of the upper lip vermilion',\n   907→    x: 0.28,\n   908→    y: 0.58,\n   909→    category: 'Lips',\n   910→  },\n   911→  {\n   912→    id: 'cheilion',\n   913→    label: 'Mouth Corner',\n   914→    medicalTerm: 'Cheilion',\n   915→    description: 'The corner of the mouth where upper and lower lips meet',\n   916→    x: 0.35,\n   917→    y: 0.62,\n   918→    category: 'Lips',\n   919→  },\n   920→  {\n   921→    id: 'labraleInferius',\n   922→    label: 'Lower Lip',\n   923→    medicalTerm: 'Labrale Inferius',\n   924→    description: 'The most anterior point of the lower lip vermilion',\n   925→    x: 0.3,\n   926→    y: 0.66,\n   927→    category: 'Lips',\n   928→  },\n   929→  {\n   930→    id: 'sublabiale',\n   931→    label: 'Labiomental Fold',\n   932→    medicalTerm: 'Sublabiale',\n   933→    description: 'The deepest point of the crease between lower lip and chin',\n   934→    x: 0.32,\n   935→    y: 0.7,\n   936→    category: 'Lips',\n   937→  },\n   938→\n   939→  // ========== CHIN (26-27) ==========\n   940→  {\n   941→    id: 'pogonion',\n   942→    label: 'Chin Point',\n   943→    medicalTerm: 'Pogonion',\n   944→    description: 'The most anterior point of the chin',\n   945→    x: 0.3,\n   946→    y: 0.76,\n   947→    category: 'Chin',\n   948→  },\n   949→  {\n   950→    id: 'menton',\n   951→    label: 'Chin Bottom',\n   952→    medicalTerm: 'Menton',\n   953→    description: 'The lowest point on the chin',\n   954→    x: 0.35,\n   955→    y: 0.82,\n   956→    category: 'Chin',\n   957→  },\n   958→\n   959→  // ========== JAW (28-29) ==========\n   960→  {\n   961→    id: 'gonionTop',\n   962→    label: 'Upper Jaw Angle',\n   963→    medicalTerm: 'Gonion Superior',\n   964→    description: 'The upper point of the jaw angle (mandibular angle)',\n   965→    x: 0.7,\n   966→    y: 0.6,\n   967→    category: 'Jaw',\n   968→  },\n   969→  {\n   970→    id: 'gonionBottom',\n   971→    label: 'Lower Jaw Angle',\n   972→    medicalTerm: 'Gonion Inferior',\n   973→    description: 'The lower point of the jaw angle (mandibular angle)',\n   974→    x: 0.65,\n   975→    y: 0.72,\n   976→    category: 'Jaw',\n   977→  },\n   978→\n   979→  // ========== NECK (30-31) ==========\n   980→  {\n   981→    id: 'cervicalPoint',\n   982→    label: 'Cervical Point',\n   983→    medicalTerm: 'Cervical Point',\n   984→    description: 'The point where the neck meets the underside of the chin',\n   985→    x: 0.5,\n   986→    y: 0.9,\n   987→    category: 'Neck',\n   988→  },\n   989→  {\n   990→    id: 'neckPoint',\n   991→    label: 'Neck Point',\n   992→    medicalTerm: 'Throat Point',\n   993→    description: 'A point on the front of the neck below the chin',\n   994→    x: 0.4,\n   995→    y: 0.88,\n   996→    category: 'Neck',\n   997→  },\n   998→];\n   999→\n  1000→// ============================================\n  1001→// MediaPipe Face Mesh Index Mapping\n  1002→// ============================================\n  1003→// NOTE: MEDIAPIPE_FRONT_MAPPING is defined in mediapipeDetection.ts (single source of truth)\n  1004→// Import from there if needed: import { MEDIAPIPE_FRONT_MAPPING } from './mediapipeDetection';\n  1005→\n  1006→// Helper to get category color for a landmark\n  1007→export function getLandmarkColor(\n  1008→  landmarkId: string,\n  1009→  categories: LandmarkCategory[]\n  1010→): string {\n  1011→  for (const category of categories) {\n  1012→    if (category.landmarks.includes(landmarkId)) {\n  1013→      return category.color;\n  1014→    }\n  1015→  }\n  1016→  return '#00f3ff'; // Default cyan\n  1017→}\n  1018→\n  1019→// ============================================\n  1020→// Side Profile Landmark Indices (106 points)\n  1021→// Reverse-engineered from PROJECT CASSANOVA API\n  1022→// ============================================\n  1023→\n  1024→export const SIDE_LANDMARKS = {\n  1025→  // Face Contour (0-16) - Jaw/Chin outline\n  1026→  MENTON: 0, // Chin bottom (lowest point)\n  1027→  POGONION: 2, // Chin prominence\n  1028→  GNATHION: 3, // Chin point\n  1029→  MANDIBLE_CONTOUR: [2, 3, 4, 5, 6, 7, 8], // Jaw line\n  1030→\n  1031→  // Posterior Points (1, 9-16) - Ear/Back of head\n  1032→  TRAGION: 1, // Ear point\n  1033→  EAR_CONTOUR: [9, 10, 11, 12, 13, 14, 15, 16],\n  1034→\n  1035→  // Forehead/Hairline (17)\n  1036→  TRICHION: 17, // Hairline\n  1037→\n  1038→  // Nose Profile (18-32)\n  1039→  NASION: 25, // Bridge of nose (deepest point)\n  1040→  PRONASALE: 32, // Nose tip\n  1041→  SUBNASALE: 52, // Base of nose\n  1042→  COLUMELLA: 53, // Nose columella\n  1043→  NOSE_BRIDGE: [25, 26, 27, 28, 29, 30, 31, 32],\n  1044→  NOSE_TIP_CONTOUR: [52, 53, 54, 55, 56, 57, 58, 59, 60],\n  1045→\n  1046→  // Eye Region (33-51)\n  1047→  EYE_LATERAL_CANTHUS: 33, // Outer eye corner\n  1048→  EYE_MEDIAL_CANTHUS: 35, // Inner eye corner\n  1049→  UPPER_EYELID: [37, 38, 39],\n  1050→  LOWER_EYELID: [40, 41, 42],\n  1051→  PUPIL: 34,\n  1052→  BROW_HEAD: 44, // Inner brow\n  1053→  BROW_ARCH: 45, // Brow peak\n  1054→  BROW_TAIL: 46, // Outer brow\n  1055→\n  1056→  // Lip Region (52-75)\n  1057→  LABRALE_SUPERIUS: 63, // Upper lip top\n  1058→  LABRALE_INFERIUS: 66, // Lower lip bottom\n  1059→  STOMION: 65, // Lip meeting point\n  1060→  UPPER_LIP_CONTOUR: [63, 64, 65],\n  1061→  LOWER_LIP_CONTOUR: [66, 67, 68],\n  1062→\n  1063→  // Additional Profile Points (76-105)\n  1064→  GLABELLA: 76, // Between eyebrows\n  1065→  SELLION: 77, // Deepest point of nasal bridge\n  1066→  SOFT_TISSUE_NASION: 78,\n  1067→  ORBITALE: 79, // Lowest point of eye socket\n  1068→  GONION: 85, // Jaw angle\n  1069→  CONDYLION: 86, // Top of jaw joint\n  1070→};\n  1071→\n  1072→// ============================================\n  1073→// Front Face Landmark Indices (MediaPipe 478 points)\n  1074→// ============================================\n  1075→\n  1076→export const FRONT_LANDMARKS = {\n  1077→  // Key points from MediaPipe Face Mesh\n  1078→  NOSE_TIP: 1,\n  1079→  LEFT_EYE_INNER: 133,\n  1080→  LEFT_EYE_OUTER: 33,\n  1081→  RIGHT_EYE_INNER: 362,\n  1082→  RIGHT_EYE_OUTER: 263,\n  1083→  LEFT_CHEEK: 234,\n  1084→  RIGHT_CHEEK: 454,\n  1085→  UPPER_LIP: 13,\n  1086→  LOWER_LIP: 14,\n  1087→  CHIN: 152,\n  1088→  FOREHEAD: 10,\n  1089→  LEFT_EAR: 234,\n  1090→  RIGHT_EAR: 454,\n  1091→  LEFT_BROW_INNER: 107,\n  1092→  LEFT_BROW_OUTER: 70,\n  1093→  RIGHT_BROW_INNER: 336,\n  1094→  RIGHT_BROW_OUTER: 300,\n  1095→  NOSE_BRIDGE: 6,\n  1096→  LEFT_NOSTRIL: 129,\n  1097→  RIGHT_NOSTRIL: 358,\n  1098→};\n  1099→\n  1100→// ============================================\n  1101→// Scoring Configuration Types\n  1102→// ============================================\n  1103→\n  1104→export interface ScoringConfig {\n  1105→  idealValue: number;\n  1106→  standardDeviation: number;\n  1107→  minScore: number;\n  1108→  maxScore: number;\n  1109→  weight: number;\n  1110→}\n  1111→\n  1112→export interface GenderSpecificValues {\n  1113→  male: { ideal: number; range: [number, number] };\n  1114→  female: { ideal: number; range: [number, number] };\n  1115→}\n  1116→\n  1117→// ============================================\n  1118→// Ideal Values (Gender-Specific)\n  1119→// ============================================\n  1120→\n  1121→export const IDEAL_VALUES: Record<string, GenderSpecificValues> = {\n  1122→  fwhr: {\n  1123→    male: { ideal: 1.9, range: [1.8, 2.1] },\n  1124→    female: { ideal: 1.75, range: [1.6, 1.9] },\n  1125→  },\n  1126→  canthalTilt: {\n  1127→    male: { ideal: 4, range: [2, 7] },\n  1128→    female: { ideal: 6, range: [4, 10] },\n  1129→  },\n  1130→  nasolabialAngle: {\n  1131→    male: { ideal: 95, range: [90, 100] },\n  1132→    female: { ideal: 105, range: [100, 115] },\n  1133→  },\n  1134→  gonialAngle: {\n  1135→    male: { ideal: 125, range: [120, 130] },\n  1136→    female: { ideal: 128, range: [125, 135] },\n  1137→  },\n  1138→  nasalIndex: {\n  1139→    male: { ideal: 0.7, range: [0.65, 0.75] },\n  1140→    female: { ideal: 0.65, range: [0.6, 0.7] },\n  1141→  },\n  1142→  lipRatio: {\n  1143→    male: { ideal: 0.5, range: [0.4, 0.6] },\n  1144→    female: { ideal: 0.5, range: [0.45, 0.55] },\n  1145→  },\n  1146→  facialConvexity: {\n  1147→    male: { ideal: 170, range: [165, 175] },\n  1148→    female: { ideal: 168, range: [163, 173] },\n  1149→  },\n  1150→  chinProjection: {\n  1151→    male: { ideal: 0, range: [-3, 3] },\n  1152→    female: { ideal: -2, range: [-5, 1] },\n  1153→  },\n  1154→};\n  1155→\n  1156→// ============================================\n  1157→// Scoring Configurations\n  1158→// ============================================\n  1159→\n  1160→export const SCORING_CONFIGS: Record<string, ScoringConfig> = {\n  1161→  fwhr: {\n  1162→    idealValue: 1.9,\n  1163→    standardDeviation: 0.15,\n  1164→    minScore: 0,\n  1165→    maxScore: 100,\n  1166→    weight: 0.15,\n  1167→  },\n  1168→  canthalTilt: {\n  1169→    idealValue: 6,\n  1170→    standardDeviation: 3,\n  1171→    minScore: 0,\n  1172→    maxScore: 100,\n  1173→    weight: 0.1,\n  1174→  },\n  1175→  facialThirds: {\n  1176→    idealValue: 33.33,\n  1177→    standardDeviation: 3,\n  1178→    minScore: 0,\n  1179→    maxScore: 100,\n  1180→    weight: 0.1,\n  1181→  },\n  1182→  nasolabialAngle: {\n  1183→    idealValue: 102,\n  1184→    standardDeviation: 8,\n  1185→    minScore: 0,\n  1186→    maxScore: 100,\n  1187→    weight: 0.08,\n  1188→  },\n  1189→  gonialAngle: {\n  1190→    idealValue: 125,\n  1191→    standardDeviation: 5,\n  1192→    minScore: 0,\n  1193→    maxScore: 100,\n  1194→    weight: 0.08,\n  1195→  },\n  1196→  overallSymmetry: {\n  1197→    idealValue: 100,\n  1198→    standardDeviation: 5,\n  1199→    minScore: 0,\n  1200→    maxScore: 100,\n  1201→    weight: 0.15,\n  1202→  },\n  1203→  goldenRatio: {\n  1204→    idealValue: 1.618,\n  1205→    standardDeviation: 0.1,\n  1206→    minScore: 0,\n  1207→    maxScore: 100,\n  1208→    weight: 0.12,\n  1209→  },\n  1210→  nasalIndex: {\n  1211→    idealValue: 0.7,\n  1212→    standardDeviation: 0.08,\n  1213→    minScore: 0,\n  1214→    maxScore: 100,\n  1215→    weight: 0.06,\n  1216→  },\n  1217→  lipRatio: {\n  1218→    idealValue: 0.5,\n  1219→    standardDeviation: 0.1,\n  1220→    minScore: 0,\n  1221→    maxScore: 100,\n  1222→    weight: 0.06,\n  1223→  },\n  1224→  chinProjection: {\n  1225→    idealValue: 0,\n  1226→    standardDeviation: 3,\n  1227→    minScore: 0,\n  1228→    maxScore: 100,\n  1229→    weight: 0.05,\n  1230→  },\n  1231→  noseProjection: {\n  1232→    idealValue: 0.67,\n  1233→    standardDeviation: 0.05,\n  1234→    minScore: 0,\n  1235→    maxScore: 100,\n  1236→    weight: 0.05,\n  1237→  },\n  1238→};\n  1239→\n  1240→// ============================================\n  1241→// Population Statistics for Percentile Ranking\n  1242→// ============================================\n  1243→\n  1244→export interface PopulationStats {\n  1245→  mean: number;\n  1246→  standardDeviation: number;\n  1247→  sampleSize: number;\n  1248→}\n  1249→\n  1250→export const POPULATION_STATS: Record<string, PopulationStats> = {\n  1251→  harmonyScore: { mean: 65, standardDeviation: 12, sampleSize: 10000 },\n  1252→  fwhr: { mean: 1.85, standardDeviation: 0.2, sampleSize: 10000 },\n  1253→  canthalTilt: { mean: 4, standardDeviation: 4, sampleSize: 10000 },\n  1254→  symmetry: { mean: 85, standardDeviation: 8, sampleSize: 10000 },\n  1255→  goldenRatioMatch: { mean: 70, standardDeviation: 15, sampleSize: 10000 },\n  1256→};\n  1257→\n\n</system-reminder>\n"}]},"uuid":"8b176a8c-6390-4940-aee9-3cfdebdd53ee","timestamp":"2025-12-30T15:24:52.869Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/landmarks.ts","content":"/**\n * Facial Landmark Types and Default Data\n * Based on TECHNICAL_SPECS.md medical terminology\n */\n\nexport interface LandmarkPoint {\n  id: string;\n  label: string;\n  medicalTerm: string;\n  description: string;\n  x: number;\n  y: number;\n  category: string;\n}\n\nexport interface LandmarkCategory {\n  name: string;\n  color: string;\n  landmarks: string[];\n}\n\n// ============================================\n// FRONT PROFILE LANDMARKS (52 Points)\n// ============================================\n\nexport const FRONT_LANDMARK_CATEGORIES: LandmarkCategory[] = [\n  {\n    name: 'Head',\n    color: '#FF6B6B',\n    landmarks: ['trichion'],\n  },\n  {\n    name: 'Eyes - Left',\n    color: '#4ECDC4',\n    landmarks: [\n      'left_pupila',\n      'left_canthus_medialis',\n      'left_canthus_lateralis',\n      'left_palpebra_superior',\n      'left_palpebra_inferior',\n      'left_sulcus_palpebralis_lateralis',\n      'left_pretarsal_skin_crease',\n    ],\n  },\n  {\n    name: 'Eyes - Right',\n    color: '#45B7D1',\n    landmarks: [\n      'right_pupila',\n      'right_canthus_medialis',\n      'right_canthus_lateralis',\n      'right_palpebra_superior',\n      'right_palpebra_inferior',\n      'right_sulcus_palpebralis_lateralis',\n      'right_pretarsal_skin_crease',\n    ],\n  },\n  {\n    name: 'Eyebrows - Left',\n    color: '#96CEB4',\n    landmarks: [\n      'left_supercilium_medialis',\n      'left_supercilium_medial_corner',\n      'left_supercilium_superior',\n      'left_supercilium_apex',\n      'left_supercilium_lateralis',\n    ],\n  },\n  {\n    name: 'Eyebrows - Right',\n    color: '#88D8B0',\n    landmarks: [\n      'right_supercilium_medialis',\n      'right_supercilium_medial_corner',\n      'right_supercilium_superior',\n      'right_supercilium_apex',\n      'right_supercilium_lateralis',\n    ],\n  },\n  {\n    name: 'Nose',\n    color: '#FFEAA7',\n    landmarks: [\n      'nasal_base',\n      'left_dorsum_nasi',\n      'right_dorsum_nasi',\n      'left_ala_nasi',\n      'right_ala_nasi',\n      'subnasale',\n    ],\n  },\n  {\n    name: 'Mouth',\n    color: '#DDA0DD',\n    landmarks: [\n      'labrale_superius',\n      'cupids_bow',\n      'mouth_middle',\n      'labrale_inferius',\n      'left_cheilion',\n      'right_cheilion',\n    ],\n  },\n  {\n    name: 'Jaw',\n    color: '#F39C12',\n    landmarks: [\n      'left_gonion_superior',\n      'right_gonion_superior',\n      'left_gonion_inferior',\n      'right_gonion_inferior',\n    ],\n  },\n  {\n    name: 'Chin',\n    color: '#E74C3C',\n    landmarks: ['left_mentum_lateralis', 'right_mentum_lateralis', 'menton'],\n  },\n  {\n    name: 'Face Width',\n    color: '#9B59B6',\n    landmarks: [\n      'left_zygion',\n      'right_zygion',\n      'left_temporal',\n      'right_temporal',\n      'left_auricular_lateral',\n      'right_auricular_lateral',\n    ],\n  },\n  {\n    name: 'Neck',\n    color: '#1ABC9C',\n    landmarks: ['left_cervical_lateralis', 'right_cervical_lateralis'],\n  },\n];\n\nexport const FRONT_PROFILE_LANDMARKS: LandmarkPoint[] = [\n  // Head/Hair\n  {\n    id: 'trichion',\n    label: 'Hairline',\n    medicalTerm: 'Trichion (frontal view)',\n    description: 'Anterior hairline at midline',\n    x: 0.5,\n    y: 0.08,\n    category: 'Head',\n  },\n\n  // Eyes - Left\n  {\n    id: 'left_pupila',\n    label: 'Left Pupil',\n    medicalTerm: 'Left Pupila',\n    description: 'Center of left pupil',\n    x: 0.38,\n    y: 0.35,\n    category: 'Eyes - Left',\n  },\n  {\n    id: 'left_canthus_medialis',\n    label: 'Left Medial Canthus',\n    medicalTerm: 'Left Canthus Medialis',\n    description: 'Inner corner of left eye',\n    x: 0.42,\n    y: 0.35,\n    category: 'Eyes - Left',\n  },\n  {\n    id: 'left_canthus_lateralis',\n    label: 'Left Lateral Canthus',\n    medicalTerm: 'Left Canthus Lateralis',\n    description: 'Outer corner of left eye',\n    x: 0.32,\n    y: 0.34,\n    category: 'Eyes - Left',\n  },\n  {\n    id: 'left_palpebra_superior',\n    label: 'Left Upper Eyelid',\n    medicalTerm: 'Left Palpebra Superior',\n    description: 'Upper eyelid of left eye',\n    x: 0.37,\n    y: 0.33,\n    category: 'Eyes - Left',\n  },\n  {\n    id: 'left_palpebra_inferior',\n    label: 'Left Lower Eyelid',\n    medicalTerm: 'Left Palpebra Inferior',\n    description: 'Lower eyelid of left eye',\n    x: 0.37,\n    y: 0.37,\n    category: 'Eyes - Left',\n  },\n  {\n    id: 'left_sulcus_palpebralis_lateralis',\n    label: 'Left Eyelid Hood End',\n    medicalTerm: 'Left Sulcus Palpebralis Lateralis',\n    description: 'Lateral end of left upper eyelid crease',\n    x: 0.31,\n    y: 0.33,\n    category: 'Eyes - Left',\n  },\n  {\n    id: 'left_pretarsal_skin_crease',\n    label: 'Left Upper Eyelid Crease',\n    medicalTerm: 'Left Pretarsal Skin Crease',\n    description: 'Left upper eyelid crease',\n    x: 0.37,\n    y: 0.32,\n    category: 'Eyes - Left',\n  },\n\n  // Eyes - Right\n  {\n    id: 'right_pupila',\n    label: 'Right Pupil',\n    medicalTerm: 'Right Pupila',\n    description: 'Center of right pupil',\n    x: 0.62,\n    y: 0.35,\n    category: 'Eyes - Right',\n  },\n  {\n    id: 'right_canthus_medialis',\n    label: 'Right Medial Canthus',\n    medicalTerm: 'Right Canthus Medialis',\n    description: 'Inner corner of right eye',\n    x: 0.58,\n    y: 0.35,\n    category: 'Eyes - Right',\n  },\n  {\n    id: 'right_canthus_lateralis',\n    label: 'Right Lateral Canthus',\n    medicalTerm: 'Right Canthus Lateralis',\n    description: 'Outer corner of right eye',\n    x: 0.68,\n    y: 0.34,\n    category: 'Eyes - Right',\n  },\n  {\n    id: 'right_palpebra_superior',\n    label: 'Right Upper Eyelid',\n    medicalTerm: 'Right Palpebra Superior',\n    description: 'Upper eyelid of right eye',\n    x: 0.63,\n    y: 0.33,\n    category: 'Eyes - Right',\n  },\n  {\n    id: 'right_palpebra_inferior',\n    label: 'Right Lower Eyelid',\n    medicalTerm: 'Right Palpebra Inferior',\n    description: 'Lower eyelid of right eye',\n    x: 0.63,\n    y: 0.37,\n    category: 'Eyes - Right',\n  },\n  {\n    id: 'right_sulcus_palpebralis_lateralis',\n    label: 'Right Eyelid Hood End',\n    medicalTerm: 'Right Sulcus Palpebralis Lateralis',\n    description: 'Lateral end of right upper eyelid crease',\n    x: 0.69,\n    y: 0.33,\n    category: 'Eyes - Right',\n  },\n  {\n    id: 'right_pretarsal_skin_crease',\n    label: 'Right Upper Eyelid Crease',\n    medicalTerm: 'Right Pretarsal Skin Crease',\n    description: 'Right upper eyelid crease',\n    x: 0.63,\n    y: 0.32,\n    category: 'Eyes - Right',\n  },\n\n  // Eyebrows - Left\n  {\n    id: 'left_supercilium_medialis',\n    label: 'Left Brow Head',\n    medicalTerm: 'Left Supercilium Medialis',\n    description: 'Medial start of left eyebrow',\n    x: 0.43,\n    y: 0.28,\n    category: 'Eyebrows - Left',\n  },\n  {\n    id: 'left_supercilium_medial_corner',\n    label: 'Left Brow Inner Corner',\n    medicalTerm: 'Left Supercilium Medial Corner',\n    description: 'Inner corner of left eyebrow',\n    x: 0.41,\n    y: 0.27,\n    category: 'Eyebrows - Left',\n  },\n  {\n    id: 'left_supercilium_superior',\n    label: 'Left Brow Arch',\n    medicalTerm: 'Left Supercilium Superior',\n    description: 'Superior arc of left eyebrow',\n    x: 0.36,\n    y: 0.26,\n    category: 'Eyebrows - Left',\n  },\n  {\n    id: 'left_supercilium_apex',\n    label: 'Left Brow Peak',\n    medicalTerm: 'Left Supercilium Apex',\n    description: 'Highest point of left eyebrow',\n    x: 0.34,\n    y: 0.26,\n    category: 'Eyebrows - Left',\n  },\n  {\n    id: 'left_supercilium_lateralis',\n    label: 'Left Brow Tail',\n    medicalTerm: 'Left Supercilium Lateralis',\n    description: 'Lateral end of left eyebrow',\n    x: 0.29,\n    y: 0.28,\n    category: 'Eyebrows - Left',\n  },\n\n  // Eyebrows - Right\n  {\n    id: 'right_supercilium_medialis',\n    label: 'Right Brow Head',\n    medicalTerm: 'Right Supercilium Medialis',\n    description: 'Medial start of right eyebrow',\n    x: 0.57,\n    y: 0.28,\n    category: 'Eyebrows - Right',\n  },\n  {\n    id: 'right_supercilium_medial_corner',\n    label: 'Right Brow Inner Corner',\n    medicalTerm: 'Right Supercilium Medial Corner',\n    description: 'Inner corner of right eyebrow',\n    x: 0.59,\n    y: 0.27,\n    category: 'Eyebrows - Right',\n  },\n  {\n    id: 'right_supercilium_superior',\n    label: 'Right Brow Arch',\n    medicalTerm: 'Right Supercilium Superior',\n    description: 'Superior arc of right eyebrow',\n    x: 0.64,\n    y: 0.26,\n    category: 'Eyebrows - Right',\n  },\n  {\n    id: 'right_supercilium_apex',\n    label: 'Right Brow Peak',\n    medicalTerm: 'Right Supercilium Apex',\n    description: 'Highest point of right eyebrow',\n    x: 0.66,\n    y: 0.26,\n    category: 'Eyebrows - Right',\n  },\n  {\n    id: 'right_supercilium_lateralis',\n    label: 'Right Brow Tail',\n    medicalTerm: 'Right Supercilium Lateralis',\n    description: 'Lateral end of right eyebrow',\n    x: 0.71,\n    y: 0.28,\n    category: 'Eyebrows - Right',\n  },\n\n  // Nose\n  {\n    id: 'nasal_base',\n    label: 'Nasal Base',\n    medicalTerm: 'Nasal Base',\n    description: 'Base of nasal dorsum',\n    x: 0.5,\n    y: 0.38,\n    category: 'Nose',\n  },\n  {\n    id: 'left_dorsum_nasi',\n    label: 'Left Nose Bridge',\n    medicalTerm: 'Left Dorsum Nasi',\n    description: 'Left side of nasal bridge',\n    x: 0.47,\n    y: 0.42,\n    category: 'Nose',\n  },\n  {\n    id: 'right_dorsum_nasi',\n    label: 'Right Nose Bridge',\n    medicalTerm: 'Right Dorsum Nasi',\n    description: 'Right side of nasal bridge',\n    x: 0.53,\n    y: 0.42,\n    category: 'Nose',\n  },\n  {\n    id: 'left_ala_nasi',\n    label: 'Left Nose Side',\n    medicalTerm: 'Left Ala Nasi',\n    description: 'Lateral aspect of left nasal ala',\n    x: 0.44,\n    y: 0.5,\n    category: 'Nose',\n  },\n  {\n    id: 'right_ala_nasi',\n    label: 'Right Nose Side',\n    medicalTerm: 'Right Ala Nasi',\n    description: 'Lateral aspect of right nasal ala',\n    x: 0.56,\n    y: 0.5,\n    category: 'Nose',\n  },\n  {\n    id: 'subnasale',\n    label: 'Nose Bottom',\n    medicalTerm: 'Subnasale',\n    description: 'Junction of columella and upper lip',\n    x: 0.5,\n    y: 0.52,\n    category: 'Nose',\n  },\n\n  // Mouth\n  {\n    id: 'labrale_superius',\n    label: \"Cupid's Bow\",\n    medicalTerm: 'Labrale Superius',\n    description: 'Midpoint of upper lip vermilion',\n    x: 0.5,\n    y: 0.58,\n    category: 'Mouth',\n  },\n  {\n    id: 'cupids_bow',\n    label: \"Inner Cupid's Bow\",\n    medicalTerm: \"Cupid's Bow\",\n    description: 'Central peak of upper lip',\n    x: 0.5,\n    y: 0.57,\n    category: 'Mouth',\n  },\n  {\n    id: 'mouth_middle',\n    label: 'Mouth Middle',\n    medicalTerm: 'Mouth Middle',\n    description: 'Center of mouth opening',\n    x: 0.5,\n    y: 0.62,\n    category: 'Mouth',\n  },\n  {\n    id: 'labrale_inferius',\n    label: 'Lower Lip Center',\n    medicalTerm: 'Labrale Inferius',\n    description: 'Midpoint of lower lip vermilion border',\n    x: 0.5,\n    y: 0.66,\n    category: 'Mouth',\n  },\n  {\n    id: 'left_cheilion',\n    label: 'Left Mouth Corner',\n    medicalTerm: 'Left Cheilion',\n    description: 'Left oral commissure',\n    x: 0.42,\n    y: 0.62,\n    category: 'Mouth',\n  },\n  {\n    id: 'right_cheilion',\n    label: 'Right Mouth Corner',\n    medicalTerm: 'Right Cheilion',\n    description: 'Right oral commissure',\n    x: 0.58,\n    y: 0.62,\n    category: 'Mouth',\n  },\n\n  // Jaw\n  {\n    id: 'left_gonion_superior',\n    label: 'Left Upper Jaw Angle',\n    medicalTerm: 'Left Gonion Superior',\n    description: 'Superior aspect of left mandibular angle',\n    x: 0.22,\n    y: 0.55,\n    category: 'Jaw',\n  },\n  {\n    id: 'right_gonion_superior',\n    label: 'Right Upper Jaw Angle',\n    medicalTerm: 'Right Gonion Superior',\n    description: 'Superior aspect of right mandibular angle',\n    x: 0.78,\n    y: 0.55,\n    category: 'Jaw',\n  },\n  {\n    id: 'left_gonion_inferior',\n    label: 'Left Lower Jaw Angle',\n    medicalTerm: 'Left Gonion Inferior',\n    description: 'Inferior aspect of left mandibular angle',\n    x: 0.24,\n    y: 0.7,\n    category: 'Jaw',\n  },\n  {\n    id: 'right_gonion_inferior',\n    label: 'Right Lower Jaw Angle',\n    medicalTerm: 'Right Gonion Inferior',\n    description: 'Inferior aspect of right mandibular angle',\n    x: 0.76,\n    y: 0.7,\n    category: 'Jaw',\n  },\n\n  // Chin\n  {\n    id: 'left_mentum_lateralis',\n    label: 'Left Chin',\n    medicalTerm: 'Left Mentum Lateralis',\n    description: 'Left lateral chin',\n    x: 0.42,\n    y: 0.8,\n    category: 'Chin',\n  },\n  {\n    id: 'right_mentum_lateralis',\n    label: 'Right Chin',\n    medicalTerm: 'Right Mentum Lateralis',\n    description: 'Right lateral chin',\n    x: 0.58,\n    y: 0.8,\n    category: 'Chin',\n  },\n  {\n    id: 'menton',\n    label: 'Chin Bottom',\n    medicalTerm: 'Menton',\n    description: 'Lowest point of chin in midline',\n    x: 0.5,\n    y: 0.88,\n    category: 'Chin',\n  },\n\n  // Face Width\n  {\n    id: 'left_zygion',\n    label: 'Left Cheekbone',\n    medicalTerm: 'Left Zygion',\n    description: 'Most lateral point of left zygomatic arch',\n    x: 0.18,\n    y: 0.42,\n    category: 'Face Width',\n  },\n  {\n    id: 'right_zygion',\n    label: 'Right Cheekbone',\n    medicalTerm: 'Right Zygion',\n    description: 'Most lateral point of right zygomatic arch',\n    x: 0.82,\n    y: 0.42,\n    category: 'Face Width',\n  },\n  {\n    id: 'left_temporal',\n    label: 'Left Temple',\n    medicalTerm: 'Left Temporal Point',\n    description: 'Left temporal region',\n    x: 0.2,\n    y: 0.3,\n    category: 'Face Width',\n  },\n  {\n    id: 'right_temporal',\n    label: 'Right Temple',\n    medicalTerm: 'Right Temporal Point',\n    description: 'Right temporal region',\n    x: 0.8,\n    y: 0.3,\n    category: 'Face Width',\n  },\n  {\n    id: 'left_auricular_lateral',\n    label: 'Left Outer Ear',\n    medicalTerm: 'Left Auricular Lateral Point',\n    description: 'Lateral-most point of left ear',\n    x: 0.12,\n    y: 0.4,\n    category: 'Face Width',\n  },\n  {\n    id: 'right_auricular_lateral',\n    label: 'Right Outer Ear',\n    medicalTerm: 'Right Auricular Lateral Point',\n    description: 'Lateral-most point of right ear',\n    x: 0.88,\n    y: 0.4,\n    category: 'Face Width',\n  },\n\n  // Neck\n  {\n    id: 'left_cervical_lateralis',\n    label: 'Left Neck Point',\n    medicalTerm: 'Left Cervical Lateralis',\n    description: 'Left cervical point',\n    x: 0.35,\n    y: 0.95,\n    category: 'Neck',\n  },\n  {\n    id: 'right_cervical_lateralis',\n    label: 'Right Neck Point',\n    medicalTerm: 'Right Cervical Lateralis',\n    description: 'Right cervical point',\n    x: 0.65,\n    y: 0.95,\n    category: 'Neck',\n  },\n];\n\n// ============================================\n// SIDE PROFILE LANDMARKS (31 Points)\n// FaceIQ Parity - Matches FaceIQ's exact order and flow\n// ============================================\n\nexport const SIDE_LANDMARK_CATEGORIES: LandmarkCategory[] = [\n  {\n    name: 'Head',\n    color: '#FF6B6B',\n    landmarks: ['vertex', 'occiput'],\n  },\n  {\n    name: 'Forehead',\n    color: '#4ECDC4',\n    landmarks: ['trichion', 'forehead', 'glabella'],\n  },\n  {\n    name: 'Eye Region',\n    color: '#45B7D1',\n    landmarks: ['orbitale', 'cornealApex', 'eyelidEnd', 'lowerEyelid'],\n  },\n  {\n    name: 'Ear',\n    color: '#3498DB',\n    landmarks: ['porion', 'tragus', 'intertragicNotch'],\n  },\n  {\n    name: 'Cheek',\n    color: '#9B59B6',\n    landmarks: ['cheekbone'],\n  },\n  {\n    name: 'Nose',\n    color: '#FFEAA7',\n    landmarks: [\n      'nasion',\n      'rhinion',\n      'supratip',\n      'pronasale',\n      'infratip',\n      'columella',\n      'subnasale',\n      'subalare',\n    ],\n  },\n  {\n    name: 'Lips',\n    color: '#DDA0DD',\n    landmarks: ['labraleSuperius', 'cheilion', 'labraleInferius', 'sublabiale'],\n  },\n  {\n    name: 'Chin',\n    color: '#E74C3C',\n    landmarks: ['pogonion', 'menton'],\n  },\n  {\n    name: 'Jaw',\n    color: '#F39C12',\n    landmarks: ['gonionTop', 'gonionBottom'],\n  },\n  {\n    name: 'Neck',\n    color: '#1ABC9C',\n    landmarks: ['cervicalPoint', 'neckPoint'],\n  },\n];\n\n// FaceIQ Parity Order: Matches FaceIQ's exact flow (1 of 31 → 31 of 31)\n// Head → Forehead → Eye → Ear → Cheek → Nose → Lips → Chin → Jaw → Neck\nexport const SIDE_PROFILE_LANDMARKS: LandmarkPoint[] = [\n  // ========== HEAD (1-2) ==========\n  {\n    id: 'vertex',\n    label: 'Top of Head',\n    medicalTerm: 'Vertex',\n    description: 'The highest point on the top of the head when looking from the side',\n    x: 0.45,\n    y: 0.02,\n    category: 'Head',\n  },\n  {\n    id: 'occiput',\n    label: 'Back of Head',\n    medicalTerm: 'Occiput',\n    description: 'The most posterior point on the back of the head',\n    x: 0.85,\n    y: 0.15,\n    category: 'Head',\n  },\n\n  // ========== FOREHEAD (3-5) ==========\n  {\n    id: 'trichion',\n    label: 'Hairline',\n    medicalTerm: 'Trichion',\n    description: 'The point where the hairline meets the forehead in the midline',\n    x: 0.35,\n    y: 0.1,\n    category: 'Forehead',\n  },\n  {\n    id: 'forehead',\n    label: 'Forehead Point',\n    medicalTerm: 'Forehead',\n    description: 'The most prominent point on the forehead between hairline and glabella',\n    x: 0.30,\n    y: 0.20,\n    category: 'Forehead',\n  },\n  {\n    id: 'glabella',\n    label: 'Glabella',\n    medicalTerm: 'Glabella',\n    description: 'The most prominent point between the eyebrows',\n    x: 0.32,\n    y: 0.28,\n    category: 'Forehead',\n  },\n\n  // ========== EYE REGION (6-9) ==========\n  {\n    id: 'orbitale',\n    label: 'Orbitale',\n    medicalTerm: 'Orbitale',\n    description: 'The lowest point on the lower edge of the eye socket (orbital rim)',\n    x: 0.35,\n    y: 0.38,\n    category: 'Eye Region',\n  },\n  {\n    id: 'cornealApex',\n    label: 'Corneal Apex',\n    medicalTerm: 'Corneal Apex',\n    description: 'The most anterior point of the cornea (eyeball)',\n    x: 0.28,\n    y: 0.34,\n    category: 'Eye Region',\n  },\n  {\n    id: 'eyelidEnd',\n    label: 'Eyelid End',\n    medicalTerm: 'Lateral Canthus',\n    description: 'The outer corner of the eye where upper and lower eyelids meet',\n    x: 0.38,\n    y: 0.33,\n    category: 'Eye Region',\n  },\n  {\n    id: 'lowerEyelid',\n    label: 'Lower Eyelid',\n    medicalTerm: 'Lower Palpebra',\n    description: 'The lowest point of the lower eyelid margin',\n    x: 0.32,\n    y: 0.36,\n    category: 'Eye Region',\n  },\n\n  // ========== EAR (10-12) - Critical for Frankfort Plane ==========\n  {\n    id: 'porion',\n    label: 'Porion',\n    medicalTerm: 'Porion',\n    description: 'The highest point on the upper margin of the external auditory meatus (ear canal opening). Forms the Frankfort Horizontal Plane with Orbitale.',\n    x: 0.75,\n    y: 0.35,\n    category: 'Ear',\n  },\n  {\n    id: 'tragus',\n    label: 'Tragus',\n    medicalTerm: 'Tragus',\n    description: 'The small pointed cartilage projection in front of the ear canal',\n    x: 0.72,\n    y: 0.42,\n    category: 'Ear',\n  },\n  {\n    id: 'intertragicNotch',\n    label: 'Intertragic Notch',\n    medicalTerm: 'Intertragic Notch',\n    description: 'The depression between the tragus and antitragus of the ear',\n    x: 0.73,\n    y: 0.45,\n    category: 'Ear',\n  },\n\n  // ========== CHEEK (13) ==========\n  {\n    id: 'cheekbone',\n    label: 'Cheekbone',\n    medicalTerm: 'Zygion',\n    description: 'The most lateral point on the zygomatic arch (cheekbone)',\n    x: 0.45,\n    y: 0.42,\n    category: 'Cheek',\n  },\n\n  // ========== NOSE (14-21) ==========\n  {\n    id: 'nasion',\n    label: 'Nasal Bridge Root',\n    medicalTerm: 'Nasion',\n    description: 'The deepest point at the bridge of the nose, between the eyes',\n    x: 0.35,\n    y: 0.32,\n    category: 'Nose',\n  },\n  {\n    id: 'rhinion',\n    label: 'Nasal Bridge',\n    medicalTerm: 'Rhinion',\n    description: 'The midpoint on the nasal bridge',\n    x: 0.28,\n    y: 0.4,\n    category: 'Nose',\n  },\n  {\n    id: 'supratip',\n    label: 'Supratip',\n    medicalTerm: 'Supratip',\n    description: 'The point just above the nose tip, on the dorsum',\n    x: 0.22,\n    y: 0.46,\n    category: 'Nose',\n  },\n  {\n    id: 'pronasale',\n    label: 'Nose Tip',\n    medicalTerm: 'Pronasale',\n    description: 'The most anterior point of the nose tip',\n    x: 0.18,\n    y: 0.48,\n    category: 'Nose',\n  },\n  {\n    id: 'infratip',\n    label: 'Infratip',\n    medicalTerm: 'Infratip',\n    description: 'The point just below the nose tip',\n    x: 0.2,\n    y: 0.5,\n    category: 'Nose',\n  },\n  {\n    id: 'columella',\n    label: 'Columella',\n    medicalTerm: 'Columella',\n    description: 'The skin bridge between the nostrils',\n    x: 0.24,\n    y: 0.52,\n    category: 'Nose',\n  },\n  {\n    id: 'subnasale',\n    label: 'Subnasale',\n    medicalTerm: 'Subnasale',\n    description: 'The point where the columella meets the upper lip',\n    x: 0.3,\n    y: 0.54,\n    category: 'Nose',\n  },\n  {\n    id: 'subalare',\n    label: 'Subalare',\n    medicalTerm: 'Subalare',\n    description: 'The point where the nostril wing meets the cheek',\n    x: 0.28,\n    y: 0.53,\n    category: 'Nose',\n  },\n\n  // ========== LIPS (22-25) ==========\n  {\n    id: 'labraleSuperius',\n    label: 'Upper Lip',\n    medicalTerm: 'Labrale Superius',\n    description: 'The most anterior point of the upper lip vermilion',\n    x: 0.28,\n    y: 0.58,\n    category: 'Lips',\n  },\n  {\n    id: 'cheilion',\n    label: 'Mouth Corner',\n    medicalTerm: 'Cheilion',\n    description: 'The corner of the mouth where upper and lower lips meet',\n    x: 0.35,\n    y: 0.62,\n    category: 'Lips',\n  },\n  {\n    id: 'labraleInferius',\n    label: 'Lower Lip',\n    medicalTerm: 'Labrale Inferius',\n    description: 'The most anterior point of the lower lip vermilion',\n    x: 0.3,\n    y: 0.66,\n    category: 'Lips',\n  },\n  {\n    id: 'sublabiale',\n    label: 'Labiomental Fold',\n    medicalTerm: 'Sublabiale',\n    description: 'The deepest point of the crease between lower lip and chin',\n    x: 0.32,\n    y: 0.7,\n    category: 'Lips',\n  },\n\n  // ========== CHIN (26-27) ==========\n  {\n    id: 'pogonion',\n    label: 'Chin Point',\n    medicalTerm: 'Pogonion',\n    description: 'The most anterior point of the chin',\n    x: 0.3,\n    y: 0.76,\n    category: 'Chin',\n  },\n  {\n    id: 'menton',\n    label: 'Chin Bottom',\n    medicalTerm: 'Menton',\n    description: 'The lowest point on the chin',\n    x: 0.35,\n    y: 0.82,\n    category: 'Chin',\n  },\n\n  // ========== JAW (28-29) ==========\n  {\n    id: 'gonionTop',\n    label: 'Upper Jaw Angle',\n    medicalTerm: 'Gonion Superior',\n    description: 'The upper point of the jaw angle (mandibular angle)',\n    x: 0.7,\n    y: 0.6,\n    category: 'Jaw',\n  },\n  {\n    id: 'gonionBottom',\n    label: 'Lower Jaw Angle',\n    medicalTerm: 'Gonion Inferior',\n    description: 'The lower point of the jaw angle (mandibular angle)',\n    x: 0.65,\n    y: 0.72,\n    category: 'Jaw',\n  },\n\n  // ========== NECK (30-31) ==========\n  {\n    id: 'cervicalPoint',\n    label: 'Cervical Point',\n    medicalTerm: 'Cervical Point',\n    description: 'The point where the neck meets the underside of the chin',\n    x: 0.5,\n    y: 0.9,\n    category: 'Neck',\n  },\n  {\n    id: 'neckPoint',\n    label: 'Neck Point',\n    medicalTerm: 'Throat Point',\n    description: 'A point on the front of the neck below the chin',\n    x: 0.4,\n    y: 0.88,\n    category: 'Neck',\n  },\n];\n\n// ============================================\n// MediaPipe Face Mesh Index Mapping\n// ============================================\n// NOTE: MEDIAPIPE_FRONT_MAPPING is defined in mediapipeDetection.ts (single source of truth)\n// Import from there if needed: import { MEDIAPIPE_FRONT_MAPPING } from './mediapipeDetection';\n\n// Helper to get category color for a landmark\nexport function getLandmarkColor(\n  landmarkId: string,\n  categories: LandmarkCategory[]\n): string {\n  for (const category of categories) {\n    if (category.landmarks.includes(landmarkId)) {\n      return category.color;\n    }\n  }\n  return '#00f3ff'; // Default cyan\n}\n\n// ============================================\n// Side Profile Landmark Indices (106 points)\n// Reverse-engineered from PROJECT CASSANOVA API\n// ============================================\n\nexport const SIDE_LANDMARKS = {\n  // Face Contour (0-16) - Jaw/Chin outline\n  MENTON: 0, // Chin bottom (lowest point)\n  POGONION: 2, // Chin prominence\n  GNATHION: 3, // Chin point\n  MANDIBLE_CONTOUR: [2, 3, 4, 5, 6, 7, 8], // Jaw line\n\n  // Posterior Points (1, 9-16) - Ear/Back of head\n  TRAGION: 1, // Ear point\n  EAR_CONTOUR: [9, 10, 11, 12, 13, 14, 15, 16],\n\n  // Forehead/Hairline (17)\n  TRICHION: 17, // Hairline\n\n  // Nose Profile (18-32)\n  NASION: 25, // Bridge of nose (deepest point)\n  PRONASALE: 32, // Nose tip\n  SUBNASALE: 52, // Base of nose\n  COLUMELLA: 53, // Nose columella\n  NOSE_BRIDGE: [25, 26, 27, 28, 29, 30, 31, 32],\n  NOSE_TIP_CONTOUR: [52, 53, 54, 55, 56, 57, 58, 59, 60],\n\n  // Eye Region (33-51)\n  EYE_LATERAL_CANTHUS: 33, // Outer eye corner\n  EYE_MEDIAL_CANTHUS: 35, // Inner eye corner\n  UPPER_EYELID: [37, 38, 39],\n  LOWER_EYELID: [40, 41, 42],\n  PUPIL: 34,\n  BROW_HEAD: 44, // Inner brow\n  BROW_ARCH: 45, // Brow peak\n  BROW_TAIL: 46, // Outer brow\n\n  // Lip Region (52-75)\n  LABRALE_SUPERIUS: 63, // Upper lip top\n  LABRALE_INFERIUS: 66, // Lower lip bottom\n  STOMION: 65, // Lip meeting point\n  UPPER_LIP_CONTOUR: [63, 64, 65],\n  LOWER_LIP_CONTOUR: [66, 67, 68],\n\n  // Additional Profile Points (76-105)\n  GLABELLA: 76, // Between eyebrows\n  SELLION: 77, // Deepest point of nasal bridge\n  SOFT_TISSUE_NASION: 78,\n  ORBITALE: 79, // Lowest point of eye socket\n  GONION: 85, // Jaw angle\n  CONDYLION: 86, // Top of jaw joint\n};\n\n// ============================================\n// Front Face Landmark Indices (MediaPipe 478 points)\n// ============================================\n\nexport const FRONT_LANDMARKS = {\n  // Key points from MediaPipe Face Mesh\n  NOSE_TIP: 1,\n  LEFT_EYE_INNER: 133,\n  LEFT_EYE_OUTER: 33,\n  RIGHT_EYE_INNER: 362,\n  RIGHT_EYE_OUTER: 263,\n  LEFT_CHEEK: 234,\n  RIGHT_CHEEK: 454,\n  UPPER_LIP: 13,\n  LOWER_LIP: 14,\n  CHIN: 152,\n  FOREHEAD: 10,\n  LEFT_EAR: 234,\n  RIGHT_EAR: 454,\n  LEFT_BROW_INNER: 107,\n  LEFT_BROW_OUTER: 70,\n  RIGHT_BROW_INNER: 336,\n  RIGHT_BROW_OUTER: 300,\n  NOSE_BRIDGE: 6,\n  LEFT_NOSTRIL: 129,\n  RIGHT_NOSTRIL: 358,\n};\n\n// ============================================\n// Scoring Configuration Types\n// ============================================\n\nexport interface ScoringConfig {\n  idealValue: number;\n  standardDeviation: number;\n  minScore: number;\n  maxScore: number;\n  weight: number;\n}\n\nexport interface GenderSpecificValues {\n  male: { ideal: number; range: [number, number] };\n  female: { ideal: number; range: [number, number] };\n}\n\n// ============================================\n// Ideal Values (Gender-Specific)\n// ============================================\n\nexport const IDEAL_VALUES: Record<string, GenderSpecificValues> = {\n  fwhr: {\n    male: { ideal: 1.9, range: [1.8, 2.1] },\n    female: { ideal: 1.75, range: [1.6, 1.9] },\n  },\n  canthalTilt: {\n    male: { ideal: 4, range: [2, 7] },\n    female: { ideal: 6, range: [4, 10] },\n  },\n  nasolabialAngle: {\n    male: { ideal: 95, range: [90, 100] },\n    female: { ideal: 105, range: [100, 115] },\n  },\n  gonialAngle: {\n    male: { ideal: 125, range: [120, 130] },\n    female: { ideal: 128, range: [125, 135] },\n  },\n  nasalIndex: {\n    male: { ideal: 0.7, range: [0.65, 0.75] },\n    female: { ideal: 0.65, range: [0.6, 0.7] },\n  },\n  lipRatio: {\n    male: { ideal: 0.5, range: [0.4, 0.6] },\n    female: { ideal: 0.5, range: [0.45, 0.55] },\n  },\n  facialConvexity: {\n    male: { ideal: 170, range: [165, 175] },\n    female: { ideal: 168, range: [163, 173] },\n  },\n  chinProjection: {\n    male: { ideal: 0, range: [-3, 3] },\n    female: { ideal: -2, range: [-5, 1] },\n  },\n};\n\n// ============================================\n// Scoring Configurations\n// ============================================\n\nexport const SCORING_CONFIGS: Record<string, ScoringConfig> = {\n  fwhr: {\n    idealValue: 1.9,\n    standardDeviation: 0.15,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.15,\n  },\n  canthalTilt: {\n    idealValue: 6,\n    standardDeviation: 3,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.1,\n  },\n  facialThirds: {\n    idealValue: 33.33,\n    standardDeviation: 3,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.1,\n  },\n  nasolabialAngle: {\n    idealValue: 102,\n    standardDeviation: 8,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.08,\n  },\n  gonialAngle: {\n    idealValue: 125,\n    standardDeviation: 5,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.08,\n  },\n  overallSymmetry: {\n    idealValue: 100,\n    standardDeviation: 5,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.15,\n  },\n  goldenRatio: {\n    idealValue: 1.618,\n    standardDeviation: 0.1,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.12,\n  },\n  nasalIndex: {\n    idealValue: 0.7,\n    standardDeviation: 0.08,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.06,\n  },\n  lipRatio: {\n    idealValue: 0.5,\n    standardDeviation: 0.1,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.06,\n  },\n  chinProjection: {\n    idealValue: 0,\n    standardDeviation: 3,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.05,\n  },\n  noseProjection: {\n    idealValue: 0.67,\n    standardDeviation: 0.05,\n    minScore: 0,\n    maxScore: 100,\n    weight: 0.05,\n  },\n};\n\n// ============================================\n// Population Statistics for Percentile Ranking\n// ============================================\n\nexport interface PopulationStats {\n  mean: number;\n  standardDeviation: number;\n  sampleSize: number;\n}\n\nexport const POPULATION_STATS: Record<string, PopulationStats> = {\n  harmonyScore: { mean: 65, standardDeviation: 12, sampleSize: 10000 },\n  fwhr: { mean: 1.85, standardDeviation: 0.2, sampleSize: 10000 },\n  canthalTilt: { mean: 4, standardDeviation: 4, sampleSize: 10000 },\n  symmetry: { mean: 85, standardDeviation: 8, sampleSize: 10000 },\n  goldenRatioMatch: { mean: 70, standardDeviation: 15, sampleSize: 10000 },\n};\n","numLines":1257,"startLine":1,"totalLines":1257}}}
{"parentUuid":"8b176a8c-6390-4940-aee9-3cfdebdd53ee","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016fgYfU7wqgzYX5xjzKedok","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me search for the core mathematical calculation files to analyze angle, distance, and ratio formulas:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13075,"cache_creation_input_tokens":22572,"cache_read_input_tokens":41603,"cache_creation":{"ephemeral_5m_input_tokens":22572,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd6xwhyeHyH9uXpSrXVi","type":"assistant","uuid":"c8835542-9a77-41cb-bf09-8be13f9710cd","timestamp":"2025-12-30T15:24:58.106Z"}
{"parentUuid":"c8835542-9a77-41cb-bf09-8be13f9710cd","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016fgYfU7wqgzYX5xjzKedok","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019qL2DRi35dTtHa8936asTM","name":"Grep","input":{"pattern":"Math\\.(atan2|acos|sqrt|pow)\\(","path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13075,"cache_creation_input_tokens":22572,"cache_read_input_tokens":41603,"cache_creation":{"ephemeral_5m_input_tokens":22572,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd6xwhyeHyH9uXpSrXVi","type":"assistant","uuid":"7a8cf5d8-1584-473c-aa4d-93c1316f8b0c","timestamp":"2025-12-30T15:25:00.389Z"}
{"parentUuid":"7a8cf5d8-1584-473c-aa4d-93c1316f8b0c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016fgYfU7wqgzYX5xjzKedok","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013JB3hWgdYwbPRAGrY7Ai1S","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/scoring.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13075,"cache_creation_input_tokens":22572,"cache_read_input_tokens":41603,"cache_creation":{"ephemeral_5m_input_tokens":22572,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd6xwhyeHyH9uXpSrXVi","type":"assistant","uuid":"27f8428e-b86d-4ebc-8e44-e3f5fa1fcfc6","timestamp":"2025-12-30T15:25:01.115Z"}
{"parentUuid":"27f8428e-b86d-4ebc-8e44-e3f5fa1fcfc6","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016fgYfU7wqgzYX5xjzKedok","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012bn3527vWzuDWBA2cuzxJx","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/calculator.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13075,"cache_creation_input_tokens":22572,"cache_read_input_tokens":41603,"cache_creation":{"ephemeral_5m_input_tokens":22572,"ephemeral_1h_input_tokens":0},"output_tokens":283,"service_tier":"standard"}},"requestId":"req_011CWd6xwhyeHyH9uXpSrXVi","type":"assistant","uuid":"7be87070-7a96-49bd-9880-cd9060adb151","timestamp":"2025-12-30T15:25:01.625Z"}
{"parentUuid":"7be87070-7a96-49bd-9880-cd9060adb151","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013JB3hWgdYwbPRAGrY7Ai1S","type":"tool_result","content":"     1→/**\n     2→ * FaceIQ Parity - Scoring Algorithm\n     3→ *\n     4→ * Exact implementation of FaceIQ's scoring formula for 100% parity.\n     5→ *\n     6→ * FaceIQ Scoring Formula (reverse-engineered):\n     7→ * - If value is within [idealMin, idealMax]: return maxScore (10)\n     8→ * - Otherwise: score = baseScore + (maxScore - baseScore) * exp(-decayRate * deviation)\n     9→ * - Where deviation = value < idealMin ? idealMin - value : value - idealMax\n    10→ * - Default decayRate = 0.2\n    11→ * - baseScore is usually 0 (can be negative for harsher penalties)\n    12→ *\n    13→ * Color Gradient (score 1-10):\n    14→ * 1: rgb(185, 28, 28)   - deep red\n    15→ * 2: rgb(220, 53, 53)   - red\n    16→ * 3: rgb(239, 88, 88)   - light red\n    17→ * 4: rgb(245, 130, 75)  - orange\n    18→ * 5: rgb(251, 175, 60)  - yellow-orange\n    19→ * 6: rgb(220, 200, 80)  - yellow\n    20→ * 7: rgb(140, 215, 100) - yellow-green\n    21→ * 8: rgb(74, 222, 128)  - green\n    22→ * 9: rgb(40, 205, 170)  - teal\n    23→ * 10: rgb(6, 182, 212)  - cyan\n    24→ */\n    25→\n    26→export interface FaceIQScoringConfig {\n    27→  idealMin: number;\n    28→  idealMax: number;\n    29→  maxScore?: number;      // Default: 10\n    30→  baseScore?: number;     // Default: 0\n    31→  decayRate?: number;     // Default: 0.2\n    32→  customPoints?: FaceIQCurvePoint[];  // Custom Bezier curve\n    33→}\n    34→\n    35→export interface FaceIQCurvePoint {\n    36→  x: number;\n    37→  y: number;\n    38→}\n    39→\n    40→export interface FaceIQScoreResult {\n    41→  score: number;\n    42→  deviation: 'below' | 'above' | 'ideal';\n    43→  deviationAmount: number;\n    44→  idealRange: string;\n    45→  percentile?: number;\n    46→}\n    47→\n    48→/**\n    49→ * FaceIQ color stops for score gradient\n    50→ */\n    51→export const FACEIQ_COLOR_STOPS: readonly { threshold: number; color: readonly [number, number, number] }[] = [\n    52→  { threshold: 1, color: [185, 28, 28] },\n    53→  { threshold: 2, color: [220, 53, 53] },\n    54→  { threshold: 3, color: [239, 88, 88] },\n    55→  { threshold: 4, color: [245, 130, 75] },\n    56→  { threshold: 5, color: [251, 175, 60] },\n    57→  { threshold: 6, color: [220, 200, 80] },\n    58→  { threshold: 7, color: [140, 215, 100] },\n    59→  { threshold: 8, color: [74, 222, 128] },\n    60→  { threshold: 9, color: [40, 205, 170] },\n    61→  { threshold: 10, color: [6, 182, 212] },\n    62→];\n    63→\n    64→/**\n    65→ * Calculate score using FaceIQ's exact algorithm\n    66→ *\n    67→ * FaceIQ formula:\n    68→ * ```javascript\n    69→ * if (value >= idealMin && value <= idealMax) return maxScore;\n    70→ * let deviation = value < idealMin ? idealMin - value : value - idealMax;\n    71→ * return baseScore + (maxScore - baseScore) * Math.exp(-decayRate * deviation);\n    72→ * ```\n    73→ */\n    74→export function calculateFaceIQScore(\n    75→  value: number,\n    76→  config: FaceIQScoringConfig\n    77→): FaceIQScoreResult {\n    78→  const {\n    79→    idealMin,\n    80→    idealMax,\n    81→    maxScore = 10,\n    82→    baseScore = 0,\n    83→    decayRate = 0.2,\n    84→    customPoints,\n    85→  } = config;\n    86→\n    87→  // Check for custom curve first\n    88→  if (customPoints && customPoints.length > 0) {\n    89→    const score = interpolateFaceIQCurve(value, customPoints);\n    90→    return {\n    91→      score: Math.max(0, Math.min(maxScore, score)),\n    92→      deviation: value < idealMin ? 'below' : value > idealMax ? 'above' : 'ideal',\n    93→      deviationAmount: value < idealMin ? idealMin - value : value > idealMax ? value - idealMax : 0,\n    94→      idealRange: `${idealMin}-${idealMax}`,\n    95→    };\n    96→  }\n    97→\n    98→  // Within ideal range - return max score\n    99→  if (value >= idealMin && value <= idealMax) {\n   100→    return {\n   101→      score: maxScore,\n   102→      deviation: 'ideal',\n   103→      deviationAmount: 0,\n   104→      idealRange: `${idealMin}-${idealMax}`,\n   105→    };\n   106→  }\n   107→\n   108→  // Calculate deviation\n   109→  const deviation = value < idealMin ? idealMin - value : value - idealMax;\n   110→\n   111→  // FaceIQ exponential decay formula\n   112→  const score = baseScore + (maxScore - baseScore) * Math.exp(-decayRate * deviation);\n   113→\n   114→  return {\n   115→    score: Math.max(0, Math.min(maxScore, score)),\n   116→    deviation: value < idealMin ? 'below' : 'above',\n   117→    deviationAmount: deviation,\n   118→    idealRange: `${idealMin}-${idealMax}`,\n   119→  };\n   120→}\n   121→\n   122→/**\n   123→ * Interpolate custom curve points (FaceIQ's Bezier interpolation)\n   124→ */\n   125→export function interpolateFaceIQCurve(\n   126→  value: number,\n   127→  points: FaceIQCurvePoint[]\n   128→): number {\n   129→  if (points.length === 0) return 0;\n   130→\n   131→  // Sort points by x\n   132→  const sorted = [...points].sort((a, b) => a.x - b.x);\n   133→\n   134→  // Handle out of range\n   135→  if (value <= sorted[0].x) return sorted[0].y;\n   136→  if (value >= sorted[sorted.length - 1].x) return sorted[sorted.length - 1].y;\n   137→\n   138→  // Find bracketing points\n   139→  for (let i = 0; i < sorted.length - 1; i++) {\n   140→    if (value >= sorted[i].x && value <= sorted[i + 1].x) {\n   141→      const p0 = sorted[i];\n   142→      const p1 = sorted[i + 1];\n   143→\n   144→      // Linear interpolation (FaceIQ uses this for simple curves)\n   145→      const t = (value - p0.x) / (p1.x - p0.x);\n   146→      return p0.y + t * (p1.y - p0.y);\n   147→    }\n   148→  }\n   149→\n   150→  return 0;\n   151→}\n   152→\n   153→/**\n   154→ * Get RGB color for a score using FaceIQ's color gradient\n   155→ */\n   156→export function getFaceIQScoreColor(score: number): string {\n   157→  const clampedScore = Math.max(1, Math.min(10, score));\n   158→\n   159→  // Find the two color stops to interpolate between\n   160→  let lowerStop = FACEIQ_COLOR_STOPS[0];\n   161→  let upperStop = FACEIQ_COLOR_STOPS[FACEIQ_COLOR_STOPS.length - 1];\n   162→\n   163→  for (let i = 0; i < FACEIQ_COLOR_STOPS.length - 1; i++) {\n   164→    if (clampedScore >= FACEIQ_COLOR_STOPS[i].threshold &&\n   165→        clampedScore <= FACEIQ_COLOR_STOPS[i + 1].threshold) {\n   166→      lowerStop = FACEIQ_COLOR_STOPS[i];\n   167→      upperStop = FACEIQ_COLOR_STOPS[i + 1];\n   168→      break;\n   169→    }\n   170→  }\n   171→\n   172→  // Interpolate between the two colors\n   173→  const t = (clampedScore - lowerStop.threshold) / (upperStop.threshold - lowerStop.threshold);\n   174→\n   175→  const r = Math.round(lowerStop.color[0] + t * (upperStop.color[0] - lowerStop.color[0]));\n   176→  const g = Math.round(lowerStop.color[1] + t * (upperStop.color[1] - lowerStop.color[1]));\n   177→  const b = Math.round(lowerStop.color[2] + t * (upperStop.color[2] - lowerStop.color[2]));\n   178→\n   179→  return `rgb(${r}, ${g}, ${b})`;\n   180→}\n   181→\n   182→/**\n   183→ * Calculate score boundaries for UI visualization\n   184→ * This determines the min/max display range for the slider\n   185→ *\n   186→ * FaceIQ formula:\n   187→ * - If using custom curve, use curve min/max\n   188→ * - Otherwise, calculate where score reaches ~0.1 (practically 0)\n   189→ */\n   190→export function calculateFaceIQScoreBoundaries(\n   191→  idealMin: number,\n   192→  idealMax: number,\n   193→  decayRate: number = 0.2,\n   194→  customPoints?: FaceIQCurvePoint[]\n   195→): { min: number; max: number } {\n   196→  // If custom curve, use curve boundaries\n   197→  if (customPoints && customPoints.length > 0) {\n   198→    const sorted = [...customPoints].sort((a, b) => a.x - b.x);\n   199→    return {\n   200→      min: sorted[0].x,\n   201→      max: sorted[sorted.length - 1].x,\n   202→    };\n   203→  }\n   204→\n   205→  // Calculate deviation needed for score to drop to ~0.1\n   206→  // 0.1 = 10 * exp(-decayRate * deviation)\n   207→  // log(0.01) = -decayRate * deviation\n   208→  // deviation = -log(0.01) / decayRate = log(100) / decayRate\n   209→  const maxDeviation = Math.log(100) / decayRate;  // ≈ 23 for decayRate=0.2\n   210→\n   211→  return {\n   212→    min: idealMin - maxDeviation,\n   213→    max: idealMax + maxDeviation,\n   214→  };\n   215→}\n   216→\n   217→/**\n   218→ * Create a CSS gradient string for ratio visualization\n   219→ * Matches FaceIQ's slider gradient\n   220→ */\n   221→export function createFaceIQScoreGradient(\n   222→  displayMin: number,\n   223→  displayMax: number,\n   224→  idealMin: number,\n   225→  idealMax: number,\n   226→  decayRate: number = 0.2,\n   227→  customPoints?: FaceIQCurvePoint[]\n   228→): string {\n   229→  const stops: string[] = [];\n   230→  const numStops = 20;  // Number of gradient stops\n   231→\n   232→  for (let i = 0; i <= numStops; i++) {\n   233→    const value = displayMin + (i / numStops) * (displayMax - displayMin);\n   234→    const result = calculateFaceIQScore(value, {\n   235→      idealMin,\n   236→      idealMax,\n   237→      decayRate,\n   238→      customPoints,\n   239→    });\n   240→\n   241→    const color = getFaceIQScoreColor(result.score);\n   242→    const position = (i / numStops) * 100;\n   243→    stops.push(`${color} ${position.toFixed(1)}%`);\n   244→  }\n   245→\n   246→  return `linear-gradient(to right, ${stops.join(', ')})`;\n   247→}\n   248→\n   249→/**\n   250→ * Calculate deviation description for display\n   251→ * Matches FaceIQ's format: \"X.XX° above ideal\" / \"X.XX° below ideal\" / \"within ideal range\"\n   252→ */\n   253→export function getFaceIQDeviationDescription(\n   254→  result: FaceIQScoreResult,\n   255→  unit: string = ''\n   256→): string {\n   257→  if (result.deviation === 'ideal') {\n   258→    return 'within ideal range';\n   259→  }\n   260→\n   261→  const amount = result.deviationAmount.toFixed(2);\n   262→  return `${amount}${unit} ${result.deviation} ideal`;\n   263→}\n   264→\n   265→/**\n   266→ * Severity classification based on score\n   267→ * Matches FaceIQ's severity tiers\n   268→ */\n   269→export function getFaceIQSeverity(score: number): 'minor' | 'moderate' | 'severe' | 'extremely severe' {\n   270→  if (score >= 8) return 'minor';\n   271→  if (score >= 7) return 'moderate';\n   272→  if (score > 3) return 'severe';\n   273→  return 'extremely severe';\n   274→}\n   275→\n   276→/**\n   277→ * FaceIQ's obfuscated slider position for locked ratios\n   278→ * Returns a semi-random position that looks plausible\n   279→ */\n   280→export function getObfuscatedSliderPosition(\n   281→  score: number | null,\n   282→  ratioName: string\n   283→): number | null {\n   284→  if (score === null) return null;\n   285→\n   286→  // Use ratio name as seed for consistent \"random\" position\n   287→  const seed = ratioName.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n   288→  const pseudoRandom = (Math.sin(seed) + 1) / 2;  // 0-1 range\n   289→\n   290→  // Return a position between 20% and 80%\n   291→  return 20 + pseudoRandom * 60;\n   292→}\n   293→\n\n</system-reminder>\n"}]},"uuid":"1c94a74d-5c8d-4cbe-90b5-49efd0b78153","timestamp":"2025-12-30T15:25:01.769Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/scoring.ts","content":"/**\n * FaceIQ Parity - Scoring Algorithm\n *\n * Exact implementation of FaceIQ's scoring formula for 100% parity.\n *\n * FaceIQ Scoring Formula (reverse-engineered):\n * - If value is within [idealMin, idealMax]: return maxScore (10)\n * - Otherwise: score = baseScore + (maxScore - baseScore) * exp(-decayRate * deviation)\n * - Where deviation = value < idealMin ? idealMin - value : value - idealMax\n * - Default decayRate = 0.2\n * - baseScore is usually 0 (can be negative for harsher penalties)\n *\n * Color Gradient (score 1-10):\n * 1: rgb(185, 28, 28)   - deep red\n * 2: rgb(220, 53, 53)   - red\n * 3: rgb(239, 88, 88)   - light red\n * 4: rgb(245, 130, 75)  - orange\n * 5: rgb(251, 175, 60)  - yellow-orange\n * 6: rgb(220, 200, 80)  - yellow\n * 7: rgb(140, 215, 100) - yellow-green\n * 8: rgb(74, 222, 128)  - green\n * 9: rgb(40, 205, 170)  - teal\n * 10: rgb(6, 182, 212)  - cyan\n */\n\nexport interface FaceIQScoringConfig {\n  idealMin: number;\n  idealMax: number;\n  maxScore?: number;      // Default: 10\n  baseScore?: number;     // Default: 0\n  decayRate?: number;     // Default: 0.2\n  customPoints?: FaceIQCurvePoint[];  // Custom Bezier curve\n}\n\nexport interface FaceIQCurvePoint {\n  x: number;\n  y: number;\n}\n\nexport interface FaceIQScoreResult {\n  score: number;\n  deviation: 'below' | 'above' | 'ideal';\n  deviationAmount: number;\n  idealRange: string;\n  percentile?: number;\n}\n\n/**\n * FaceIQ color stops for score gradient\n */\nexport const FACEIQ_COLOR_STOPS: readonly { threshold: number; color: readonly [number, number, number] }[] = [\n  { threshold: 1, color: [185, 28, 28] },\n  { threshold: 2, color: [220, 53, 53] },\n  { threshold: 3, color: [239, 88, 88] },\n  { threshold: 4, color: [245, 130, 75] },\n  { threshold: 5, color: [251, 175, 60] },\n  { threshold: 6, color: [220, 200, 80] },\n  { threshold: 7, color: [140, 215, 100] },\n  { threshold: 8, color: [74, 222, 128] },\n  { threshold: 9, color: [40, 205, 170] },\n  { threshold: 10, color: [6, 182, 212] },\n];\n\n/**\n * Calculate score using FaceIQ's exact algorithm\n *\n * FaceIQ formula:\n * ```javascript\n * if (value >= idealMin && value <= idealMax) return maxScore;\n * let deviation = value < idealMin ? idealMin - value : value - idealMax;\n * return baseScore + (maxScore - baseScore) * Math.exp(-decayRate * deviation);\n * ```\n */\nexport function calculateFaceIQScore(\n  value: number,\n  config: FaceIQScoringConfig\n): FaceIQScoreResult {\n  const {\n    idealMin,\n    idealMax,\n    maxScore = 10,\n    baseScore = 0,\n    decayRate = 0.2,\n    customPoints,\n  } = config;\n\n  // Check for custom curve first\n  if (customPoints && customPoints.length > 0) {\n    const score = interpolateFaceIQCurve(value, customPoints);\n    return {\n      score: Math.max(0, Math.min(maxScore, score)),\n      deviation: value < idealMin ? 'below' : value > idealMax ? 'above' : 'ideal',\n      deviationAmount: value < idealMin ? idealMin - value : value > idealMax ? value - idealMax : 0,\n      idealRange: `${idealMin}-${idealMax}`,\n    };\n  }\n\n  // Within ideal range - return max score\n  if (value >= idealMin && value <= idealMax) {\n    return {\n      score: maxScore,\n      deviation: 'ideal',\n      deviationAmount: 0,\n      idealRange: `${idealMin}-${idealMax}`,\n    };\n  }\n\n  // Calculate deviation\n  const deviation = value < idealMin ? idealMin - value : value - idealMax;\n\n  // FaceIQ exponential decay formula\n  const score = baseScore + (maxScore - baseScore) * Math.exp(-decayRate * deviation);\n\n  return {\n    score: Math.max(0, Math.min(maxScore, score)),\n    deviation: value < idealMin ? 'below' : 'above',\n    deviationAmount: deviation,\n    idealRange: `${idealMin}-${idealMax}`,\n  };\n}\n\n/**\n * Interpolate custom curve points (FaceIQ's Bezier interpolation)\n */\nexport function interpolateFaceIQCurve(\n  value: number,\n  points: FaceIQCurvePoint[]\n): number {\n  if (points.length === 0) return 0;\n\n  // Sort points by x\n  const sorted = [...points].sort((a, b) => a.x - b.x);\n\n  // Handle out of range\n  if (value <= sorted[0].x) return sorted[0].y;\n  if (value >= sorted[sorted.length - 1].x) return sorted[sorted.length - 1].y;\n\n  // Find bracketing points\n  for (let i = 0; i < sorted.length - 1; i++) {\n    if (value >= sorted[i].x && value <= sorted[i + 1].x) {\n      const p0 = sorted[i];\n      const p1 = sorted[i + 1];\n\n      // Linear interpolation (FaceIQ uses this for simple curves)\n      const t = (value - p0.x) / (p1.x - p0.x);\n      return p0.y + t * (p1.y - p0.y);\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Get RGB color for a score using FaceIQ's color gradient\n */\nexport function getFaceIQScoreColor(score: number): string {\n  const clampedScore = Math.max(1, Math.min(10, score));\n\n  // Find the two color stops to interpolate between\n  let lowerStop = FACEIQ_COLOR_STOPS[0];\n  let upperStop = FACEIQ_COLOR_STOPS[FACEIQ_COLOR_STOPS.length - 1];\n\n  for (let i = 0; i < FACEIQ_COLOR_STOPS.length - 1; i++) {\n    if (clampedScore >= FACEIQ_COLOR_STOPS[i].threshold &&\n        clampedScore <= FACEIQ_COLOR_STOPS[i + 1].threshold) {\n      lowerStop = FACEIQ_COLOR_STOPS[i];\n      upperStop = FACEIQ_COLOR_STOPS[i + 1];\n      break;\n    }\n  }\n\n  // Interpolate between the two colors\n  const t = (clampedScore - lowerStop.threshold) / (upperStop.threshold - lowerStop.threshold);\n\n  const r = Math.round(lowerStop.color[0] + t * (upperStop.color[0] - lowerStop.color[0]));\n  const g = Math.round(lowerStop.color[1] + t * (upperStop.color[1] - lowerStop.color[1]));\n  const b = Math.round(lowerStop.color[2] + t * (upperStop.color[2] - lowerStop.color[2]));\n\n  return `rgb(${r}, ${g}, ${b})`;\n}\n\n/**\n * Calculate score boundaries for UI visualization\n * This determines the min/max display range for the slider\n *\n * FaceIQ formula:\n * - If using custom curve, use curve min/max\n * - Otherwise, calculate where score reaches ~0.1 (practically 0)\n */\nexport function calculateFaceIQScoreBoundaries(\n  idealMin: number,\n  idealMax: number,\n  decayRate: number = 0.2,\n  customPoints?: FaceIQCurvePoint[]\n): { min: number; max: number } {\n  // If custom curve, use curve boundaries\n  if (customPoints && customPoints.length > 0) {\n    const sorted = [...customPoints].sort((a, b) => a.x - b.x);\n    return {\n      min: sorted[0].x,\n      max: sorted[sorted.length - 1].x,\n    };\n  }\n\n  // Calculate deviation needed for score to drop to ~0.1\n  // 0.1 = 10 * exp(-decayRate * deviation)\n  // log(0.01) = -decayRate * deviation\n  // deviation = -log(0.01) / decayRate = log(100) / decayRate\n  const maxDeviation = Math.log(100) / decayRate;  // ≈ 23 for decayRate=0.2\n\n  return {\n    min: idealMin - maxDeviation,\n    max: idealMax + maxDeviation,\n  };\n}\n\n/**\n * Create a CSS gradient string for ratio visualization\n * Matches FaceIQ's slider gradient\n */\nexport function createFaceIQScoreGradient(\n  displayMin: number,\n  displayMax: number,\n  idealMin: number,\n  idealMax: number,\n  decayRate: number = 0.2,\n  customPoints?: FaceIQCurvePoint[]\n): string {\n  const stops: string[] = [];\n  const numStops = 20;  // Number of gradient stops\n\n  for (let i = 0; i <= numStops; i++) {\n    const value = displayMin + (i / numStops) * (displayMax - displayMin);\n    const result = calculateFaceIQScore(value, {\n      idealMin,\n      idealMax,\n      decayRate,\n      customPoints,\n    });\n\n    const color = getFaceIQScoreColor(result.score);\n    const position = (i / numStops) * 100;\n    stops.push(`${color} ${position.toFixed(1)}%`);\n  }\n\n  return `linear-gradient(to right, ${stops.join(', ')})`;\n}\n\n/**\n * Calculate deviation description for display\n * Matches FaceIQ's format: \"X.XX° above ideal\" / \"X.XX° below ideal\" / \"within ideal range\"\n */\nexport function getFaceIQDeviationDescription(\n  result: FaceIQScoreResult,\n  unit: string = ''\n): string {\n  if (result.deviation === 'ideal') {\n    return 'within ideal range';\n  }\n\n  const amount = result.deviationAmount.toFixed(2);\n  return `${amount}${unit} ${result.deviation} ideal`;\n}\n\n/**\n * Severity classification based on score\n * Matches FaceIQ's severity tiers\n */\nexport function getFaceIQSeverity(score: number): 'minor' | 'moderate' | 'severe' | 'extremely severe' {\n  if (score >= 8) return 'minor';\n  if (score >= 7) return 'moderate';\n  if (score > 3) return 'severe';\n  return 'extremely severe';\n}\n\n/**\n * FaceIQ's obfuscated slider position for locked ratios\n * Returns a semi-random position that looks plausible\n */\nexport function getObfuscatedSliderPosition(\n  score: number | null,\n  ratioName: string\n): number | null {\n  if (score === null) return null;\n\n  // Use ratio name as seed for consistent \"random\" position\n  const seed = ratioName.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n  const pseudoRandom = (Math.sin(seed) + 1) / 2;  // 0-1 range\n\n  // Return a position between 20% and 80%\n  return 20 + pseudoRandom * 60;\n}\n","numLines":293,"startLine":1,"totalLines":293}}}
{"parentUuid":"1c94a74d-5c8d-4cbe-90b5-49efd0b78153","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019qL2DRi35dTtHa8936asTM","type":"tool_result","content":"Found 11 files\nsrc/lib/mediapipeDetection.ts\nsrc/lib/serverSideDetection.ts\nsrc/lib/faceiq-parity/potential.ts\nsrc/lib/sideProfileNormalization.ts\nsrc/lib/scoring/analyzer.ts\nsrc/lib/insights-engine.ts\nsrc/lib/sideProfileDetection.ts\nsrc/lib/looksmax-scoring.ts\nsrc/lib/scoring/calculator.ts\nsrc/lib/recommendations/severity.ts\nsrc/lib/scoring.ts"}]},"uuid":"2884e35f-1ce9-4da5-8178-684339b55448","timestamp":"2025-12-30T15:25:01.812Z","toolUseResult":{"mode":"files_with_matches","filenames":["src/lib/mediapipeDetection.ts","src/lib/serverSideDetection.ts","src/lib/faceiq-parity/potential.ts","src/lib/sideProfileNormalization.ts","src/lib/scoring/analyzer.ts","src/lib/insights-engine.ts","src/lib/sideProfileDetection.ts","src/lib/looksmax-scoring.ts","src/lib/scoring/calculator.ts","src/lib/recommendations/severity.ts","src/lib/scoring.ts"],"numFiles":11}}
{"parentUuid":"2884e35f-1ce9-4da5-8178-684339b55448","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012bn3527vWzuDWBA2cuzxJx","type":"tool_result","content":"     1→/**\n     2→ * Scoring Calculator\n     3→ * Core scoring algorithm functions extracted from harmony-scoring.ts\n     4→ *\n     5→ * Features:\n     6→ * - Exponential decay scoring with per-metric decay rates\n     7→ * - Bezier curve custom scoring for non-linear measurements\n     8→ * - Directional/Dimorphic scoring (polarity support)\n     9→ * - Quality tiers and severity levels\n    10→ */\n    11→\n    12→import {\n    13→  Point,\n    14→  QualityTier,\n    15→  SeverityLevel,\n    16→  MeasurementUnit,\n    17→  MetricConfig,\n    18→  CurvePoint,\n    19→  FlawMapping,\n    20→} from './types';\n    21→import { BEZIER_CURVES } from '@/lib/bezier-curves';\n    22→\n    23→// ============================================\n    24→// FLAW MAPPINGS\n    25→// ============================================\n    26→\n    27→export const METRIC_FLAW_MAPPINGS: Record<string, FlawMapping[]> = {\n    28→  anteriorFacialDepth: [\n    29→    { category: 'Midface/Face Shape', flawName: 'Underprojected midface', confidence: 'confirmed', reasoning: 'The Anterior Facial Depth measurement is above the ideal range. This disrupts facial harmony by creating a sunken and unprominent appearance to the midface.' },\n    30→  ],\n    31→  bitemporalWidth: [\n    32→    { category: 'Upper Third', flawName: 'Narrow forehead', confidence: 'confirmed', reasoning: 'Reduced bitemporal width indicates a narrower than ideal forehead relative to the cheekbones. This disrupts facial harmony by creating a compressed hairline and forehead, altering the overall shape of the face.' },\n    33→  ],\n    34→  cheekboneHeight: [\n    35→    { category: 'Midface/Face Shape', flawName: 'Low-set cheekbones', confidence: 'confirmed', reasoning: 'Reduced cheekbone height indicates that the cheekbones are positioned lower than ideal. This disrupts facial harmony by creating an unpronounced appearance to the cheekbones and facial structure.' },\n    36→  ],\n    37→  cheekFullness: [\n    38→    { category: 'Midface/Face Shape', flawName: 'Hollow/Gaunt midface', confidence: 'confirmed', reasoning: 'Reduced cheek fullness indicates volume loss or hollow cheeks. This disrupts facial harmony by creating a gaunt or aged appearance, particularly important in South Asian and East Asian beauty standards.' },\n    39→  ],\n    40→  eyeAspectRatio: [\n    41→    { category: 'Eyes', flawName: 'Overly round eye shape', confidence: 'confirmed', reasoning: 'A reduced eye aspect ratio indicates overly narrow eyes relative to their height. This disrupts facial harmony by creating an overly surprised appearance and reducing angular definition.' },\n    42→  ],\n    43→  eyeSeparationRatio: [\n    44→    { category: 'Eyes', flawName: 'Close-set eyes', confidence: 'confirmed', reasoning: 'Reduced eye separation indicates close-set eyes. This disrupts facial harmony by making the eye area appear too compressed.' },\n    45→  ],\n    46→  eyebrowLowSetedness: [\n    47→    { category: 'Eyes', flawName: 'Medium-set eyebrows', confidence: 'confirmed', reasoning: 'Increased eyebrow low setedness indicates eyebrows that are positioned higher than ideal. This disrupts facial harmony by reducing the overall visual impact of the eyebrows and framing of the eyes.' },\n    48→  ],\n    49→  faceWidthToHeight: [\n    50→    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A reduced face width to height ratio indicates an overly long midface relative to its height. This disrupts facial harmony by overemphasizing the middle of the face.' },\n    51→  ],\n    52→  facialDepthToHeight: [\n    53→    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'Reduced facial depth to height ratio indicates insufficient mid-face projection relative to height. This disrupts facial harmony by creating the appearance of a flat midface.' },\n    54→  ],\n    55→  gonialAngle: [\n    56→    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'A wider gonial angle indicates a softer, less defined jawline with reduced angularity. This disrupts facial harmony in the lower face.' },\n    57→    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A wider gonial angle indicates a softer, less defined jawline with reduced angularity. This disrupts facial harmony by creating a narrow or pointed chin effect.' },\n    58→  ],\n    59→  holdawayHLine: [\n    60→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'Decreased H-line indicates the lips are positioned too far in front of the line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },\n    61→  ],\n    62→  interiorMidfaceProjectionAngle: [\n    63→    { category: 'Midface/Face Shape', flawName: 'Underprojected midface', confidence: 'confirmed', reasoning: 'The Interior Midface Projection Angle measurement is above the ideal range. This disrupts facial harmony by creating a sunken and unprominent appearance to the midface.' },\n    64→  ],\n    65→  ipsilateralAlarAngle: [\n    66→    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A decreased ipsilateral alar angle indicates an overly narrow interior midface. This disrupts facial harmony by overemphasizing the middle of the face.' },\n    67→  ],\n    68→  jawFrontalAngle: [\n    69→    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A narrower jaw frontal angle indicates a steeper jawline or overly wide chin. This disrupts facial harmony by creating a narrow or pointed chin effect.' },\n    70→  ],\n    71→  jawSlope: [\n    72→    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'The Jaw Slope measurement is above the ideal range. This disrupts facial harmony in the lower face.' },\n    73→  ],\n    74→  lateralCanthalTilt: [\n    75→    { category: 'Eyes', flawName: 'Insufficient eye tilt', confidence: 'confirmed', reasoning: 'A decreased lateral canthal tilt indicates insufficiently upturned eyes. This disrupts facial harmony by creating a less alert and youthful appearance.' },\n    76→  ],\n    77→  burstoneLowerLip: [\n    78→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned excessively in front of the Burstone line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },\n    79→  ],\n    80→  eLineLowerLip: [\n    81→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned too far in front of the E-line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },\n    82→  ],\n    83→  sLineLowerLip: [\n    84→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned excessively in front of the S-line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },\n    85→  ],\n    86→  lowerThirdProportion: [\n    87→    { category: 'Midface/Face Shape', flawName: 'Long upper jaw', confidence: 'confirmed', reasoning: 'The upper jaw is too long relative to lower jaw, possibly from a long upper jaw or short lower jaw, or a combination of both. This disrupts facial harmony by overemphasizing the upper jaw relative to the lower jaw.' },\n    88→  ],\n    89→  mandibularPlaneAngle: [\n    90→    { category: 'Occlusion/Jaw Growth', flawName: 'Hyper-divergent jaw growth', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony by elongating the lower face.' },\n    91→    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony in the lower face.' },\n    92→    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony by creating a narrow or pointed chin effect.' },\n    93→  ],\n    94→  midfaceRatio: [\n    95→    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A reduced midface ratio indicates an overly narrow interior midface relative to its height. This disrupts facial harmony by overemphasizing the middle of the face.' },\n    96→    { category: 'Midface/Face Shape', flawName: 'Long upper jaw', confidence: 'confirmed', reasoning: 'A reduced midface ratio indicates an overly narrow interior midface relative to its height. This disrupts facial harmony by overemphasizing the upper jaw relative to the lower jaw.' },\n    97→  ],\n    98→  nasofacialAngle: [\n    99→    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'A smaller nasofacial angle suggests reduced projection of the nose and midface region, or an overprojected chin. This disrupts facial harmony by creating the appearance of a flat midface.' },\n   100→  ],\n   101→  nasofrontalAngle: [\n   102→    { category: 'Upper Third', flawName: 'Soft and weak brow ridge', confidence: 'confirmed', reasoning: 'An increased nasofrontal angle indicates reduced brow ridge prominence and angularity. This disrupts facial harmony by creating a less defined upper face.' },\n   103→  ],\n   104→  nasomentaAngle: [\n   105→    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'A larger nasomental angle suggests reduced projection of the nose and midface region, or an overprojected chin. This disrupts facial harmony by creating the appearance of a flat midface.' },\n   106→  ],\n   107→  noseBridgeWidth: [\n   108→    { category: 'Nose', flawName: 'Overly narrow nose bridge', confidence: 'confirmed', reasoning: 'The Nose Bridge to Nose Width measurement is above the ideal range. This disrupts facial harmony by creating an unbalanced nasal profile.' },\n   109→  ],\n   110→  orbitalVector: [\n   111→    { category: 'Eyes', flawName: 'Sunken orbital region', confidence: 'confirmed', reasoning: 'A decreased orbital vector indicates insufficient projection and volume underneath the eye. This disrupts facial harmony due to the lacking volume underneath the eyes, reducing vibrancy and youthfulness.' },\n   112→  ],\n   113→  ramusToMandibleRatio: [\n   114→    { category: 'Jaw Shape', flawName: 'Short ramus', confidence: 'confirmed', reasoning: 'A reduced ramus-to-mandible ratio indicates a shorter than ideal vertical jawbone (ramus) when compared to the mandible. This disrupts facial harmony by reducing jaw height and definition.' },\n   115→  ],\n   116→  submentalCervicalAngle: [\n   117→    { category: 'Neck', flawName: 'Round neck region', confidence: 'confirmed', reasoning: 'An increased submental cervical angle indicates a round neck region, possibly from excess submental fat or tissue. This disrupts facial harmony by reducing neck definition.' },\n   118→  ],\n   119→  totalFacialWidthToHeight: [\n   120→    { category: 'Midface/Face Shape', flawName: 'Overly long face shape', confidence: 'confirmed', reasoning: 'An increased total facial width to height ratio indicates an overly long face relative to its height. This disrupts facial harmony by creating a vertically stretched appearance to the face.' },\n   121→  ],\n   122→};\n   123→\n   124→// ============================================\n   125→// CUSTOM BEZIER CURVES (Ethnicity-specific override)\n   126→// ============================================\n   127→\n   128→export const METRIC_CUSTOM_CURVES: Record<string, CurvePoint[]> = {\n   129→  faceWidthToHeight: [\n   130→    { x: 1.49, y: 0, leftHandleX: 1.44, leftHandleY: 0, rightHandleX: 1.55, rightHandleY: 0 },\n   131→    { x: 1.68, y: 1.05, leftHandleX: 1.62, leftHandleY: 0.36, rightHandleX: 1.71, rightHandleY: 1.58 },\n   132→    { x: 1.77, y: 3.07, leftHandleX: 1.74, leftHandleY: 2.15, rightHandleX: 1.79, rightHandleY: 3.88 },\n   133→    { x: 1.83, y: 5.83, leftHandleX: 1.8, leftHandleY: 4.64, rightHandleX: 1.84, rightHandleY: 6.85 },\n   134→    { x: 1.89, y: 8.7, leftHandleX: 1.88, leftHandleY: 8.3, rightHandleX: 1.92, rightHandleY: 9.5 },\n   135→    { x: 1.96, y: 10, leftHandleX: 1.96, leftHandleY: 10, rightHandleX: 1.96, rightHandleY: 10, fixed: true },\n   136→    { x: 2, y: 10, leftHandleX: 2, leftHandleY: 10, rightHandleX: 2, rightHandleY: 10 },\n   137→    { x: 2.07, y: 8.7, leftHandleX: 2.04, leftHandleY: 9.5, rightHandleX: 2.08, rightHandleY: 8.3 },\n   138→    { x: 2.13, y: 5.83, leftHandleX: 2.12, leftHandleY: 6.85, rightHandleX: 2.16, rightHandleY: 4.64 },\n   139→    { x: 2.19, y: 3.07, leftHandleX: 2.17, leftHandleY: 3.88, rightHandleX: 2.22, rightHandleY: 2.15 },\n   140→    { x: 2.28, y: 1.05, leftHandleX: 2.25, leftHandleY: 1.58, rightHandleX: 2.34, rightHandleY: 0.36 },\n   141→    { x: 2.47, y: 0, leftHandleX: 2.41, leftHandleY: 0, rightHandleX: 2.52, rightHandleY: 0 },\n   142→  ],\n   143→  lowerThirdProportion: [\n   144→    { x: 25.6, y: 0, leftHandleX: 24.8, leftHandleY: 0, rightHandleX: 26.4, rightHandleY: 0 },\n   145→    { x: 28.01, y: 1.58, leftHandleX: 27.23, leftHandleY: 0.53, rightHandleX: 28.27, rightHandleY: 1.97 },\n   146→    { x: 28.83, y: 3.21, leftHandleX: 28.62, leftHandleY: 2.59, rightHandleX: 29.03, rightHandleY: 3.76 },\n   147→    { x: 29.63, y: 5.85, leftHandleX: 29.38, leftHandleY: 4.64, rightHandleX: 29.84, rightHandleY: 6.61 },\n   148→    { x: 30.27, y: 8.56, leftHandleX: 30.1, leftHandleY: 7.71, rightHandleX: 30.52, rightHandleY: 9.42 },\n   149→    { x: 31, y: 10, leftHandleX: 30.88, leftHandleY: 10, rightHandleX: 31.13, rightHandleY: 10, fixed: true },\n   150→    { x: 33.5, y: 10, leftHandleX: 33.38, leftHandleY: 10, rightHandleX: 33.63, rightHandleY: 10 },\n   151→    { x: 34.23, y: 8.56, leftHandleX: 33.98, leftHandleY: 9.42, rightHandleX: 34.4, rightHandleY: 7.71 },\n   152→    { x: 34.87, y: 5.85, leftHandleX: 34.66, leftHandleY: 6.61, rightHandleX: 35.12, rightHandleY: 4.64 },\n   153→    { x: 35.67, y: 3.21, leftHandleX: 35.47, leftHandleY: 3.76, rightHandleX: 35.88, rightHandleY: 2.59 },\n   154→    { x: 36.49, y: 1.58, leftHandleX: 36.23, leftHandleY: 1.97, rightHandleX: 37.27, rightHandleY: 0.53 },\n   155→    { x: 38.9, y: 0, leftHandleX: 38.1, leftHandleY: 0, rightHandleX: 39.7, rightHandleY: 0 },\n   156→  ],\n   157→  eyeAspectRatio: [\n   158→    { x: 1.44, y: 0, leftHandleX: 1.18, leftHandleY: 0, rightHandleX: 1.75, rightHandleY: 0.38 },\n   159→    { x: 2.07, y: 1.66, leftHandleX: 1.96, leftHandleY: 1.08, rightHandleX: 2.24, rightHandleY: 2.63 },\n   160→    { x: 2.42, y: 4.34, leftHandleX: 2.35, leftHandleY: 3.6, rightHandleX: 2.52, rightHandleY: 5.5 },\n   161→    { x: 2.71, y: 7.96, leftHandleX: 2.65, leftHandleY: 7.13, rightHandleX: 2.8, rightHandleY: 9.08 },\n   162→    { x: 3, y: 10, leftHandleX: 2.98, leftHandleY: 10, rightHandleX: 3.03, rightHandleY: 10, fixed: true },\n   163→    { x: 3.5, y: 10, leftHandleX: 3.48, leftHandleY: 10, rightHandleX: 3.53, rightHandleY: 10 },\n   164→    { x: 3.79, y: 7.96, leftHandleX: 3.7, leftHandleY: 9.08, rightHandleX: 3.85, rightHandleY: 7.13 },\n   165→    { x: 4.08, y: 4.34, leftHandleX: 3.98, leftHandleY: 5.5, rightHandleX: 4.15, rightHandleY: 3.6 },\n   166→    { x: 4.43, y: 1.66, leftHandleX: 4.26, leftHandleY: 2.63, rightHandleX: 4.54, rightHandleY: 1.08 },\n   167→    { x: 5.06, y: 0, leftHandleX: 4.75, leftHandleY: 0.38, rightHandleX: 5.32, rightHandleY: 0 },\n   168→  ],\n   169→  // Note: Additional curves can be added from METRIC_CUSTOM_CURVES in harmony-scoring.ts\n   170→};\n   171→\n   172→// ============================================\n   173→// CORE SCORING FUNCTIONS\n   174→// ============================================\n   175→\n   176→/**\n   177→ * Exponential Decay Scoring Algorithm with Directional/Dimorphic Support\n   178→ *\n   179→ * Standard: score = maxScore * e^(-decayRate * deviation)\n   180→ *\n   181→ * Directional scoring (polarity):\n   182→ * - 'higher_is_better': Values above safeFloor but below ideal get softZoneScore\n   183→ *   Example: Canthal Tilt of 3 degrees is still positive/good, just not peak ideal (6-8 degrees)\n   184→ * - 'lower_is_better': Values below safeCeiling but above ideal get softZoneScore\n   185→ *   Example: Short philtrum is still attractive even if shorter than \"ideal\"\n   186→ */\n   187→export function calculateMetricScore(\n   188→  value: number,\n   189→  config: MetricConfig\n   190→): number {\n   191→  const {\n   192→    id,\n   193→    idealMin,\n   194→    idealMax,\n   195→    decayRate,\n   196→    maxScore,\n   197→    customCurve,\n   198→    polarity = 'balanced',\n   199→    safeFloor,\n   200→    safeCeiling,\n   201→    softZoneScore = 8.0, // Default \"Good\" score for acceptable-but-not-ideal values\n   202→  } = config;\n   203→\n   204→  // IMPORTANT: Check demographic-adjusted ideal range FIRST\n   205→  // This ensures that demographic overrides are respected even when Bezier curves exist\n   206→  // (Bezier curves are optimized for base ranges and don't auto-adjust for demographics)\n   207→  if (value >= idealMin && value <= idealMax) {\n   208→    return maxScore;\n   209→  }\n   210→\n   211→  // Use custom curve if available in config\n   212→  if (customCurve && customCurve.mode === 'custom') {\n   213→    const bezierScore = interpolateCustomCurve(value, customCurve.points, maxScore);\n   214→    // If Bezier returns -1, it means value is out of range with edge y=0\n   215→    // Fall through to exponential decay instead of returning 0\n   216→    if (bezierScore >= 0) {\n   217→      // Clamp to valid range [0, maxScore] to prevent Bezier overshoot\n   218→      return Math.max(0, Math.min(maxScore, bezierScore));\n   219→    }\n   220→  }\n   221→\n   222→  // Check for pre-defined Bezier curve from harmony curves (66 metrics)\n   223→  const bezierCurve = BEZIER_CURVES[id];\n   224→  if (bezierCurve && bezierCurve.mode === 'custom') {\n   225→    const bezierScore = interpolateCustomCurve(value, bezierCurve.points, maxScore);\n   226→    // If Bezier returns -1, it means value is out of range with edge y=0\n   227→    // Fall through to exponential decay instead of returning 0\n   228→    if (bezierScore >= 0) {\n   229→      // Clamp to valid range [0, maxScore] to prevent Bezier overshoot\n   230→      return Math.max(0, Math.min(maxScore, bezierScore));\n   231→    }\n   232→  }\n   233→\n   234→  // Handle directional/dimorphic scoring\n   235→  if (polarity === 'higher_is_better' && safeFloor !== undefined) {\n   236→    // Higher values are good. Only values below safeFloor are true weaknesses.\n   237→    if (value >= safeFloor && value < idealMin) {\n   238→      // Value is in the \"acceptable but not ideal\" zone\n   239→      // Give a passing score that decreases linearly as we approach the floor\n   240→      const zoneRange = idealMin - safeFloor;\n   241→      const distanceFromIdeal = idealMin - value;\n   242→      const t = zoneRange > 0 ? distanceFromIdeal / zoneRange : 0;\n   243→      // Linear interpolation: idealMin -> maxScore, safeFloor -> softZoneScore\n   244→      return maxScore - t * (maxScore - softZoneScore);\n   245→    }\n   246→    if (value >= idealMax) {\n   247→      // Values above ideal are still excellent for 'higher_is_better'\n   248→      // Apply gentler decay (1/3 the normal rate)\n   249→      const deviation = value - idealMax;\n   250→      const gentleDecay = decayRate / 3;\n   251→      return Math.max(softZoneScore, maxScore * Math.exp(-gentleDecay * deviation));\n   252→    }\n   253→    // Below safeFloor - apply normal (or harsher) exponential decay\n   254→    if (value < safeFloor) {\n   255→      const deviation = safeFloor - value;\n   256→      return Math.max(0, softZoneScore * Math.exp(-decayRate * deviation));\n   257→    }\n   258→  }\n   259→\n   260→  if (polarity === 'lower_is_better' && safeCeiling !== undefined) {\n   261→    // Lower values are good. Only values above safeCeiling are true weaknesses.\n   262→    if (value <= safeCeiling && value > idealMax) {\n   263→      // Value is in the \"acceptable but not ideal\" zone\n   264→      const zoneRange = safeCeiling - idealMax;\n   265→      const distanceFromIdeal = value - idealMax;\n   266→      const t = zoneRange > 0 ? distanceFromIdeal / zoneRange : 0;\n   267→      // Linear interpolation: idealMax -> maxScore, safeCeiling -> softZoneScore\n   268→      return maxScore - t * (maxScore - softZoneScore);\n   269→    }\n   270→    if (value <= idealMin) {\n   271→      // Values below ideal are still excellent for 'lower_is_better'\n   272→      // Apply gentler decay (1/3 the normal rate)\n   273→      const deviation = idealMin - value;\n   274→      const gentleDecay = decayRate / 3;\n   275→      return Math.max(softZoneScore, maxScore * Math.exp(-gentleDecay * deviation));\n   276→    }\n   277→    // Above safeCeiling - apply normal exponential decay\n   278→    if (value > safeCeiling) {\n   279→      const deviation = value - safeCeiling;\n   280→      return Math.max(0, softZoneScore * Math.exp(-decayRate * deviation));\n   281→    }\n   282→  }\n   283→\n   284→  // Default balanced scoring: deviation in either direction is equally bad\n   285→  const deviation = value < idealMin\n   286→    ? idealMin - value\n   287→    : value - idealMax;\n   288→\n   289→  // Exponential decay\n   290→  const score = maxScore * Math.exp(-decayRate * deviation);\n   291→\n   292→  return Math.max(0, Math.min(maxScore, score));\n   293→}\n   294→\n   295→/**\n   296→ * Check if a metric value is in an \"acceptable\" zone (not a true weakness).\n   297→ * Used by InsightsEngine to prevent false positives.\n   298→ */\n   299→export function isValueAcceptable(\n   300→  value: number,\n   301→  config: MetricConfig\n   302→): { acceptable: boolean; reason: string } {\n   303→  const {\n   304→    idealMin,\n   305→    idealMax,\n   306→    polarity = 'balanced',\n   307→    safeFloor,\n   308→    safeCeiling,\n   309→  } = config;\n   310→\n   311→  // Within ideal range is always acceptable\n   312→  if (value >= idealMin && value <= idealMax) {\n   313→    return { acceptable: true, reason: 'within_ideal' };\n   314→  }\n   315→\n   316→  // Check directional acceptability\n   317→  if (polarity === 'higher_is_better') {\n   318→    if (value >= idealMax) {\n   319→      return { acceptable: true, reason: 'above_ideal_higher_is_better' };\n   320→    }\n   321→    if (safeFloor !== undefined && value >= safeFloor) {\n   322→      return { acceptable: true, reason: 'above_safe_floor' };\n   323→    }\n   324→    // Below safe floor - true weakness\n   325→    return { acceptable: false, reason: 'below_safe_floor' };\n   326→  }\n   327→\n   328→  if (polarity === 'lower_is_better') {\n   329→    if (value <= idealMin) {\n   330→      return { acceptable: true, reason: 'below_ideal_lower_is_better' };\n   331→    }\n   332→    if (safeCeiling !== undefined && value <= safeCeiling) {\n   333→      return { acceptable: true, reason: 'below_safe_ceiling' };\n   334→    }\n   335→    // Above safe ceiling - true weakness\n   336→    return { acceptable: false, reason: 'above_safe_ceiling' };\n   337→  }\n   338→\n   339→  // Balanced polarity - outside ideal is not acceptable\n   340→  return { acceptable: false, reason: 'outside_ideal_balanced' };\n   341→}\n   342→\n   343→/**\n   344→ * Interpolate custom Bezier curve for scoring\n   345→ * Uses cubic Bezier interpolation with control handles for smooth curves\n   346→ *\n   347→ * IMPORTANT: When value is outside the curve range and the edge y-value is 0,\n   348→ * returns -1 to signal the caller should use exponential decay fallback.\n   349→ * This prevents artificially returning 0 for values just outside the curve.\n   350→ */\n   351→export function interpolateCustomCurve(\n   352→  value: number,\n   353→  points: CurvePoint[],\n   354→  maxScore: number\n   355→): number {\n   356→  void maxScore; // Reserved for future custom curve implementations\n   357→  if (points.length === 0) return -1; // Signal to use fallback\n   358→\n   359→  // Sort points by x value\n   360→  const sortedPoints = [...points].sort((a, b) => a.x - b.x);\n   361→\n   362→  // Handle out-of-range values\n   363→  // If edge y-value is 0, return -1 to signal exponential decay fallback should be used\n   364→  if (value <= sortedPoints[0].x) {\n   365→    const edgeY = sortedPoints[0].y;\n   366→    // If edge score is 0, signal to use exponential decay fallback\n   367→    return edgeY <= 0 ? -1 : edgeY;\n   368→  }\n   369→  if (value >= sortedPoints[sortedPoints.length - 1].x) {\n   370→    const edgeY = sortedPoints[sortedPoints.length - 1].y;\n   371→    // If edge score is 0, signal to use exponential decay fallback\n   372→    return edgeY <= 0 ? -1 : edgeY;\n   373→  }\n   374→\n   375→  // Find bracketing points\n   376→  let lowerIndex = 0;\n   377→  for (let i = 0; i < sortedPoints.length - 1; i++) {\n   378→    if (value >= sortedPoints[i].x && value <= sortedPoints[i + 1].x) {\n   379→      lowerIndex = i;\n   380→      break;\n   381→    }\n   382→  }\n   383→\n   384→  const p0 = sortedPoints[lowerIndex];\n   385→  const p3 = sortedPoints[lowerIndex + 1];\n   386→\n   387→  // Check if we have Bezier control handles\n   388→  const hasHandles = p0.rightHandleX !== undefined && p3.leftHandleX !== undefined;\n   389→\n   390→  if (hasHandles) {\n   391→    // Cubic Bezier interpolation with control points\n   392→    const p1x = p0.rightHandleX!;\n   393→    const p1y = p0.rightHandleY ?? p0.y;\n   394→    const p2x = p3.leftHandleX!;\n   395→    const p2y = p3.leftHandleY ?? p3.y;\n   396→\n   397→    // Find t parameter for given x value using Newton-Raphson iteration\n   398→    let t = (value - p0.x) / (p3.x - p0.x); // Initial guess\n   399→\n   400→    // Newton-Raphson iterations to find t where B_x(t) = value\n   401→    for (let iter = 0; iter < 10; iter++) {\n   402→      const bx = cubicBezier(p0.x, p1x, p2x, p3.x, t);\n   403→      const bxDerivative = cubicBezierDerivative(p0.x, p1x, p2x, p3.x, t);\n   404→\n   405→      if (Math.abs(bxDerivative) < 1e-10) break;\n   406→\n   407→      const newT = t - (bx - value) / bxDerivative;\n   408→      if (Math.abs(newT - t) < 1e-10) break;\n   409→      t = Math.max(0, Math.min(1, newT));\n   410→    }\n   411→\n   412→    // Calculate y using the found t parameter\n   413→    return cubicBezier(p0.y, p1y, p2y, p3.y, t);\n   414→  } else {\n   415→    // Smooth interpolation using Catmull-Rom spline\n   416→    // This provides smoother curves than linear interpolation\n   417→    const t = (value - p0.x) / (p3.x - p0.x);\n   418→\n   419→    // Get neighboring points for spline calculation\n   420→    const pMinus1 = lowerIndex > 0 ? sortedPoints[lowerIndex - 1] : p0;\n   421→    const p4 = lowerIndex + 2 < sortedPoints.length ? sortedPoints[lowerIndex + 2] : p3;\n   422→\n   423→    // Catmull-Rom spline interpolation\n   424→    return catmullRomSpline(pMinus1.y, p0.y, p3.y, p4.y, t);\n   425→  }\n   426→}\n   427→\n   428→/**\n   429→ * Cubic Bezier curve evaluation: B(t) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3\n   430→ */\n   431→export function cubicBezier(p0: number, p1: number, p2: number, p3: number, t: number): number {\n   432→  const mt = 1 - t;\n   433→  const mt2 = mt * mt;\n   434→  const mt3 = mt2 * mt;\n   435→  const t2 = t * t;\n   436→  const t3 = t2 * t;\n   437→  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;\n   438→}\n   439→\n   440→/**\n   441→ * Cubic Bezier derivative: B'(t) = 3*(1-t)^2*(P1-P0) + 6*(1-t)*t*(P2-P1) + 3*t^2*(P3-P2)\n   442→ */\n   443→export function cubicBezierDerivative(p0: number, p1: number, p2: number, p3: number, t: number): number {\n   444→  const mt = 1 - t;\n   445→  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);\n   446→}\n   447→\n   448→/**\n   449→ * Catmull-Rom spline interpolation for smooth curves without explicit handles\n   450→ */\n   451→export function catmullRomSpline(p0: number, p1: number, p2: number, p3: number, t: number): number {\n   452→  const t2 = t * t;\n   453→  const t3 = t2 * t;\n   454→\n   455→  // Catmull-Rom coefficients with tension = 0.5\n   456→  const a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;\n   457→  const b = p0 - 2.5 * p1 + 2 * p2 - 0.5 * p3;\n   458→  const c = -0.5 * p0 + 0.5 * p2;\n   459→  const d = p1;\n   460→\n   461→  return a * t3 + b * t2 + c * t + d;\n   462→}\n   463→\n   464→/**\n   465→ * Calculate standardized score (0-10 normalized)\n   466→ * Clamps output to [0, 10] to prevent display issues from scoring edge cases\n   467→ */\n   468→export function standardizeScore(score: number, maxScore: number): number {\n   469→  const normalized = (score / maxScore) * 10;\n   470→  return Math.max(0, Math.min(10, normalized));\n   471→}\n   472→\n   473→/**\n   474→ * Determine quality tier based on score\n   475→ */\n   476→export function getQualityTier(score: number, maxScore: number = 10): QualityTier {\n   477→  const normalized = (score / maxScore) * 100;\n   478→\n   479→  if (normalized >= 90) return 'ideal';\n   480→  if (normalized >= 70) return 'excellent';\n   481→  if (normalized >= 50) return 'good';\n   482→  return 'below_average';\n   483→}\n   484→\n   485→/**\n   486→ * Determine severity level based on score\n   487→ */\n   488→export function getSeverityLevel(score: number, maxScore: number = 10): SeverityLevel {\n   489→  const normalized = (score / maxScore) * 100;\n   490→\n   491→  if (normalized >= 85) return 'optimal';\n   492→  if (normalized >= 70) return 'minor';\n   493→  if (normalized >= 50) return 'moderate';\n   494→  if (normalized >= 30) return 'major';\n   495→  if (normalized >= 15) return 'severe';\n   496→  return 'extremely_severe';\n   497→}\n   498→\n   499→/**\n   500→ * Calculate deviation description\n   501→ */\n   502→export function getDeviationDescription(\n   503→  value: number,\n   504→  idealMin: number,\n   505→  idealMax: number,\n   506→  unit: MeasurementUnit\n   507→): { deviation: number; direction: 'above' | 'below' | 'within'; description: string } {\n   508→  if (value >= idealMin && value <= idealMax) {\n   509→    return { deviation: 0, direction: 'within', description: 'within ideal range' };\n   510→  }\n   511→\n   512→  const unitLabel = getUnitLabel(unit);\n   513→\n   514→  if (value < idealMin) {\n   515→    const dev = idealMin - value;\n   516→    return {\n   517→      deviation: dev,\n   518→      direction: 'below',\n   519→      description: `${dev.toFixed(2)}${unitLabel} below ideal`,\n   520→    };\n   521→  }\n   522→\n   523→  const dev = value - idealMax;\n   524→  return {\n   525→    deviation: dev,\n   526→    direction: 'above',\n   527→    description: `${dev.toFixed(2)}${unitLabel} above ideal`,\n   528→  };\n   529→}\n   530→\n   531→/**\n   532→ * Get unit label for display\n   533→ */\n   534→export function getUnitLabel(unit: MeasurementUnit): string {\n   535→  switch (unit) {\n   536→    case 'ratio': return 'x';\n   537→    case 'percent': return '%';\n   538→    case 'degrees': return '\\u00B0';\n   539→    case 'mm': return 'mm';\n   540→    default: return '';\n   541→  }\n   542→}\n   543→\n   544→// ============================================\n   545→// GEOMETRY HELPERS\n   546→// ============================================\n   547→\n   548→/**\n   549→ * Calculate distance between two points\n   550→ */\n   551→export function distance(p1: Point, p2: Point): number {\n   552→  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n   553→}\n   554→\n   555→/**\n   556→ * Calculate angle at vertex point (in degrees)\n   557→ */\n   558→export function calculateAngle(p1: Point, vertex: Point, p2: Point): number {\n   559→  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };\n   560→  const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };\n   561→\n   562→  const dot = v1.x * v2.x + v1.y * v2.y;\n   563→  const cross = v1.x * v2.y - v1.y * v2.x;\n   564→\n   565→  const angle = Math.atan2(cross, dot) * (180 / Math.PI);\n   566→  return Math.abs(angle);\n   567→}\n   568→\n   569→/**\n   570→ * Calculate perpendicular distance from point to line (signed)\n   571→ */\n   572→export function perpendicularDistance(\n   573→  point: Point,\n   574→  lineStart: Point,\n   575→  lineEnd: Point\n   576→): number {\n   577→  const A = point.x - lineStart.x;\n   578→  const B = point.y - lineStart.y;\n   579→  const C = lineEnd.x - lineStart.x;\n   580→  const D = lineEnd.y - lineStart.y;\n   581→\n   582→  const dot = A * C + B * D;\n   583→  const lenSq = C * C + D * D;\n   584→  const param = lenSq !== 0 ? dot / lenSq : -1;\n   585→\n   586→  let xx: number, yy: number;\n   587→\n   588→  if (param < 0) {\n   589→    xx = lineStart.x;\n   590→    yy = lineStart.y;\n   591→  } else if (param > 1) {\n   592→    xx = lineEnd.x;\n   593→    yy = lineEnd.y;\n   594→  } else {\n   595→    xx = lineStart.x + param * C;\n   596→    yy = lineStart.y + param * D;\n   597→  }\n   598→\n   599→  const dx = point.x - xx;\n   600→  const dy = point.y - yy;\n   601→\n   602→  const sign =\n   603→    (lineEnd.y - lineStart.y) * point.x -\n   604→      (lineEnd.x - lineStart.x) * point.y +\n   605→      lineEnd.x * lineStart.y -\n   606→      lineEnd.y * lineStart.x >=\n   607→    0\n   608→      ? 1\n   609→      : -1;\n   610→\n   611→  return sign * Math.sqrt(dx * dx + dy * dy);\n   612→}\n   613→\n   614→// ============================================\n   615→// PERCENTILE & PSL CONVERSION\n   616→// ============================================\n   617→\n   618→/**\n   619→ * Calculate percentile from harmony score\n   620→ */\n   621→export function calculateHarmonyPercentile(score: number): number {\n   622→  // Based on normal distribution with mean=5, stdDev=1.5\n   623→  const mean = 5;\n   624→  const stdDev = 1.5;\n   625→  const z = (score - mean) / stdDev;\n   626→  return normalCDF(z) * 100;\n   627→}\n   628→\n   629→/**\n   630→ * Standard normal CDF approximation\n   631→ */\n   632→export function normalCDF(z: number): number {\n   633→  const a1 = 0.254829592;\n   634→  const a2 = -0.284496736;\n   635→  const a3 = 1.421413741;\n   636→  const a4 = -1.453152027;\n   637→  const a5 = 1.061405429;\n   638→  const p = 0.3275911;\n   639→\n   640→  const sign = z < 0 ? -1 : 1;\n   641→  const absZ = Math.abs(z) / Math.sqrt(2);\n   642→\n   643→  const t = 1.0 / (1.0 + p * absZ);\n   644→  const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-absZ * absZ);\n   645→\n   646→  return 0.5 * (1.0 + sign * y);\n   647→}\n   648→\n   649→// ============================================\n   650→// PSL RATING CONVERSION\n   651→// ============================================\n   652→\n   653→export interface PSLRating {\n   654→  score: number;\n   655→  tier: string;\n   656→  percentile: number;\n   657→  description: string;\n   658→}\n   659→\n   660→/**\n   661→ * Convert harmony score to PSL rating\n   662→ */\n   663→export function convertToPSL(harmonyScore: number): PSLRating {\n   664→  // Convert 0-10 harmony to 3.0-7.5 PSL range\n   665→  const psl = 3.0 + (harmonyScore / 10) * 4.5;\n   666→  const clampedPSL = Math.max(3.0, Math.min(7.5, psl));\n   667→\n   668→  let tier: string;\n   669→  let percentile: number;\n   670→\n   671→  if (clampedPSL >= 7.5) {\n   672→    tier = 'Top Model';\n   673→    percentile = 99.99;\n   674→  } else if (clampedPSL >= 7.0) {\n   675→    tier = 'Chad';\n   676→    percentile = 99.87;\n   677→  } else if (clampedPSL >= 6.5) {\n   678→    tier = 'Chadlite';\n   679→    percentile = 99.0;\n   680→  } else if (clampedPSL >= 6.0) {\n   681→    tier = 'High Tier Normie+';\n   682→    percentile = 97.25;\n   683→  } else if (clampedPSL >= 5.5) {\n   684→    tier = 'High Tier Normie';\n   685→    percentile = 90.0;\n   686→  } else if (clampedPSL >= 5.0) {\n   687→    tier = 'Mid Tier Normie+';\n   688→    percentile = 84.15;\n   689→  } else if (clampedPSL >= 4.5) {\n   690→    tier = 'Mid Tier Normie';\n   691→    percentile = 65.0;\n   692→  } else if (clampedPSL >= 4.0) {\n   693→    tier = 'Low Tier Normie';\n   694→    percentile = 50.0;\n   695→  } else if (clampedPSL >= 3.5) {\n   696→    tier = 'Below Average';\n   697→    percentile = 30.0;\n   698→  } else {\n   699→    tier = 'Subpar';\n   700→    percentile = 15.0;\n   701→  }\n   702→\n   703→  return {\n   704→    score: clampedPSL,\n   705→    tier,\n   706→    percentile,\n   707→    description: `${tier} (top ${(100 - percentile).toFixed(1)}%)`,\n   708→  };\n   709→}\n   710→\n\n</system-reminder>\n"}]},"uuid":"7130e1e0-172c-45dd-9076-1a667c0c2129","timestamp":"2025-12-30T15:25:01.943Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/calculator.ts","content":"/**\n * Scoring Calculator\n * Core scoring algorithm functions extracted from harmony-scoring.ts\n *\n * Features:\n * - Exponential decay scoring with per-metric decay rates\n * - Bezier curve custom scoring for non-linear measurements\n * - Directional/Dimorphic scoring (polarity support)\n * - Quality tiers and severity levels\n */\n\nimport {\n  Point,\n  QualityTier,\n  SeverityLevel,\n  MeasurementUnit,\n  MetricConfig,\n  CurvePoint,\n  FlawMapping,\n} from './types';\nimport { BEZIER_CURVES } from '@/lib/bezier-curves';\n\n// ============================================\n// FLAW MAPPINGS\n// ============================================\n\nexport const METRIC_FLAW_MAPPINGS: Record<string, FlawMapping[]> = {\n  anteriorFacialDepth: [\n    { category: 'Midface/Face Shape', flawName: 'Underprojected midface', confidence: 'confirmed', reasoning: 'The Anterior Facial Depth measurement is above the ideal range. This disrupts facial harmony by creating a sunken and unprominent appearance to the midface.' },\n  ],\n  bitemporalWidth: [\n    { category: 'Upper Third', flawName: 'Narrow forehead', confidence: 'confirmed', reasoning: 'Reduced bitemporal width indicates a narrower than ideal forehead relative to the cheekbones. This disrupts facial harmony by creating a compressed hairline and forehead, altering the overall shape of the face.' },\n  ],\n  cheekboneHeight: [\n    { category: 'Midface/Face Shape', flawName: 'Low-set cheekbones', confidence: 'confirmed', reasoning: 'Reduced cheekbone height indicates that the cheekbones are positioned lower than ideal. This disrupts facial harmony by creating an unpronounced appearance to the cheekbones and facial structure.' },\n  ],\n  cheekFullness: [\n    { category: 'Midface/Face Shape', flawName: 'Hollow/Gaunt midface', confidence: 'confirmed', reasoning: 'Reduced cheek fullness indicates volume loss or hollow cheeks. This disrupts facial harmony by creating a gaunt or aged appearance, particularly important in South Asian and East Asian beauty standards.' },\n  ],\n  eyeAspectRatio: [\n    { category: 'Eyes', flawName: 'Overly round eye shape', confidence: 'confirmed', reasoning: 'A reduced eye aspect ratio indicates overly narrow eyes relative to their height. This disrupts facial harmony by creating an overly surprised appearance and reducing angular definition.' },\n  ],\n  eyeSeparationRatio: [\n    { category: 'Eyes', flawName: 'Close-set eyes', confidence: 'confirmed', reasoning: 'Reduced eye separation indicates close-set eyes. This disrupts facial harmony by making the eye area appear too compressed.' },\n  ],\n  eyebrowLowSetedness: [\n    { category: 'Eyes', flawName: 'Medium-set eyebrows', confidence: 'confirmed', reasoning: 'Increased eyebrow low setedness indicates eyebrows that are positioned higher than ideal. This disrupts facial harmony by reducing the overall visual impact of the eyebrows and framing of the eyes.' },\n  ],\n  faceWidthToHeight: [\n    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A reduced face width to height ratio indicates an overly long midface relative to its height. This disrupts facial harmony by overemphasizing the middle of the face.' },\n  ],\n  facialDepthToHeight: [\n    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'Reduced facial depth to height ratio indicates insufficient mid-face projection relative to height. This disrupts facial harmony by creating the appearance of a flat midface.' },\n  ],\n  gonialAngle: [\n    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'A wider gonial angle indicates a softer, less defined jawline with reduced angularity. This disrupts facial harmony in the lower face.' },\n    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A wider gonial angle indicates a softer, less defined jawline with reduced angularity. This disrupts facial harmony by creating a narrow or pointed chin effect.' },\n  ],\n  holdawayHLine: [\n    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'Decreased H-line indicates the lips are positioned too far in front of the line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },\n  ],\n  interiorMidfaceProjectionAngle: [\n    { category: 'Midface/Face Shape', flawName: 'Underprojected midface', confidence: 'confirmed', reasoning: 'The Interior Midface Projection Angle measurement is above the ideal range. This disrupts facial harmony by creating a sunken and unprominent appearance to the midface.' },\n  ],\n  ipsilateralAlarAngle: [\n    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A decreased ipsilateral alar angle indicates an overly narrow interior midface. This disrupts facial harmony by overemphasizing the middle of the face.' },\n  ],\n  jawFrontalAngle: [\n    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A narrower jaw frontal angle indicates a steeper jawline or overly wide chin. This disrupts facial harmony by creating a narrow or pointed chin effect.' },\n  ],\n  jawSlope: [\n    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'The Jaw Slope measurement is above the ideal range. This disrupts facial harmony in the lower face.' },\n  ],\n  lateralCanthalTilt: [\n    { category: 'Eyes', flawName: 'Insufficient eye tilt', confidence: 'confirmed', reasoning: 'A decreased lateral canthal tilt indicates insufficiently upturned eyes. This disrupts facial harmony by creating a less alert and youthful appearance.' },\n  ],\n  burstoneLowerLip: [\n    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned excessively in front of the Burstone line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },\n  ],\n  eLineLowerLip: [\n    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned too far in front of the E-line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },\n  ],\n  sLineLowerLip: [\n    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned excessively in front of the S-line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },\n  ],\n  lowerThirdProportion: [\n    { category: 'Midface/Face Shape', flawName: 'Long upper jaw', confidence: 'confirmed', reasoning: 'The upper jaw is too long relative to lower jaw, possibly from a long upper jaw or short lower jaw, or a combination of both. This disrupts facial harmony by overemphasizing the upper jaw relative to the lower jaw.' },\n  ],\n  mandibularPlaneAngle: [\n    { category: 'Occlusion/Jaw Growth', flawName: 'Hyper-divergent jaw growth', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony by elongating the lower face.' },\n    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony in the lower face.' },\n    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony by creating a narrow or pointed chin effect.' },\n  ],\n  midfaceRatio: [\n    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A reduced midface ratio indicates an overly narrow interior midface relative to its height. This disrupts facial harmony by overemphasizing the middle of the face.' },\n    { category: 'Midface/Face Shape', flawName: 'Long upper jaw', confidence: 'confirmed', reasoning: 'A reduced midface ratio indicates an overly narrow interior midface relative to its height. This disrupts facial harmony by overemphasizing the upper jaw relative to the lower jaw.' },\n  ],\n  nasofacialAngle: [\n    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'A smaller nasofacial angle suggests reduced projection of the nose and midface region, or an overprojected chin. This disrupts facial harmony by creating the appearance of a flat midface.' },\n  ],\n  nasofrontalAngle: [\n    { category: 'Upper Third', flawName: 'Soft and weak brow ridge', confidence: 'confirmed', reasoning: 'An increased nasofrontal angle indicates reduced brow ridge prominence and angularity. This disrupts facial harmony by creating a less defined upper face.' },\n  ],\n  nasomentaAngle: [\n    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'A larger nasomental angle suggests reduced projection of the nose and midface region, or an overprojected chin. This disrupts facial harmony by creating the appearance of a flat midface.' },\n  ],\n  noseBridgeWidth: [\n    { category: 'Nose', flawName: 'Overly narrow nose bridge', confidence: 'confirmed', reasoning: 'The Nose Bridge to Nose Width measurement is above the ideal range. This disrupts facial harmony by creating an unbalanced nasal profile.' },\n  ],\n  orbitalVector: [\n    { category: 'Eyes', flawName: 'Sunken orbital region', confidence: 'confirmed', reasoning: 'A decreased orbital vector indicates insufficient projection and volume underneath the eye. This disrupts facial harmony due to the lacking volume underneath the eyes, reducing vibrancy and youthfulness.' },\n  ],\n  ramusToMandibleRatio: [\n    { category: 'Jaw Shape', flawName: 'Short ramus', confidence: 'confirmed', reasoning: 'A reduced ramus-to-mandible ratio indicates a shorter than ideal vertical jawbone (ramus) when compared to the mandible. This disrupts facial harmony by reducing jaw height and definition.' },\n  ],\n  submentalCervicalAngle: [\n    { category: 'Neck', flawName: 'Round neck region', confidence: 'confirmed', reasoning: 'An increased submental cervical angle indicates a round neck region, possibly from excess submental fat or tissue. This disrupts facial harmony by reducing neck definition.' },\n  ],\n  totalFacialWidthToHeight: [\n    { category: 'Midface/Face Shape', flawName: 'Overly long face shape', confidence: 'confirmed', reasoning: 'An increased total facial width to height ratio indicates an overly long face relative to its height. This disrupts facial harmony by creating a vertically stretched appearance to the face.' },\n  ],\n};\n\n// ============================================\n// CUSTOM BEZIER CURVES (Ethnicity-specific override)\n// ============================================\n\nexport const METRIC_CUSTOM_CURVES: Record<string, CurvePoint[]> = {\n  faceWidthToHeight: [\n    { x: 1.49, y: 0, leftHandleX: 1.44, leftHandleY: 0, rightHandleX: 1.55, rightHandleY: 0 },\n    { x: 1.68, y: 1.05, leftHandleX: 1.62, leftHandleY: 0.36, rightHandleX: 1.71, rightHandleY: 1.58 },\n    { x: 1.77, y: 3.07, leftHandleX: 1.74, leftHandleY: 2.15, rightHandleX: 1.79, rightHandleY: 3.88 },\n    { x: 1.83, y: 5.83, leftHandleX: 1.8, leftHandleY: 4.64, rightHandleX: 1.84, rightHandleY: 6.85 },\n    { x: 1.89, y: 8.7, leftHandleX: 1.88, leftHandleY: 8.3, rightHandleX: 1.92, rightHandleY: 9.5 },\n    { x: 1.96, y: 10, leftHandleX: 1.96, leftHandleY: 10, rightHandleX: 1.96, rightHandleY: 10, fixed: true },\n    { x: 2, y: 10, leftHandleX: 2, leftHandleY: 10, rightHandleX: 2, rightHandleY: 10 },\n    { x: 2.07, y: 8.7, leftHandleX: 2.04, leftHandleY: 9.5, rightHandleX: 2.08, rightHandleY: 8.3 },\n    { x: 2.13, y: 5.83, leftHandleX: 2.12, leftHandleY: 6.85, rightHandleX: 2.16, rightHandleY: 4.64 },\n    { x: 2.19, y: 3.07, leftHandleX: 2.17, leftHandleY: 3.88, rightHandleX: 2.22, rightHandleY: 2.15 },\n    { x: 2.28, y: 1.05, leftHandleX: 2.25, leftHandleY: 1.58, rightHandleX: 2.34, rightHandleY: 0.36 },\n    { x: 2.47, y: 0, leftHandleX: 2.41, leftHandleY: 0, rightHandleX: 2.52, rightHandleY: 0 },\n  ],\n  lowerThirdProportion: [\n    { x: 25.6, y: 0, leftHandleX: 24.8, leftHandleY: 0, rightHandleX: 26.4, rightHandleY: 0 },\n    { x: 28.01, y: 1.58, leftHandleX: 27.23, leftHandleY: 0.53, rightHandleX: 28.27, rightHandleY: 1.97 },\n    { x: 28.83, y: 3.21, leftHandleX: 28.62, leftHandleY: 2.59, rightHandleX: 29.03, rightHandleY: 3.76 },\n    { x: 29.63, y: 5.85, leftHandleX: 29.38, leftHandleY: 4.64, rightHandleX: 29.84, rightHandleY: 6.61 },\n    { x: 30.27, y: 8.56, leftHandleX: 30.1, leftHandleY: 7.71, rightHandleX: 30.52, rightHandleY: 9.42 },\n    { x: 31, y: 10, leftHandleX: 30.88, leftHandleY: 10, rightHandleX: 31.13, rightHandleY: 10, fixed: true },\n    { x: 33.5, y: 10, leftHandleX: 33.38, leftHandleY: 10, rightHandleX: 33.63, rightHandleY: 10 },\n    { x: 34.23, y: 8.56, leftHandleX: 33.98, leftHandleY: 9.42, rightHandleX: 34.4, rightHandleY: 7.71 },\n    { x: 34.87, y: 5.85, leftHandleX: 34.66, leftHandleY: 6.61, rightHandleX: 35.12, rightHandleY: 4.64 },\n    { x: 35.67, y: 3.21, leftHandleX: 35.47, leftHandleY: 3.76, rightHandleX: 35.88, rightHandleY: 2.59 },\n    { x: 36.49, y: 1.58, leftHandleX: 36.23, leftHandleY: 1.97, rightHandleX: 37.27, rightHandleY: 0.53 },\n    { x: 38.9, y: 0, leftHandleX: 38.1, leftHandleY: 0, rightHandleX: 39.7, rightHandleY: 0 },\n  ],\n  eyeAspectRatio: [\n    { x: 1.44, y: 0, leftHandleX: 1.18, leftHandleY: 0, rightHandleX: 1.75, rightHandleY: 0.38 },\n    { x: 2.07, y: 1.66, leftHandleX: 1.96, leftHandleY: 1.08, rightHandleX: 2.24, rightHandleY: 2.63 },\n    { x: 2.42, y: 4.34, leftHandleX: 2.35, leftHandleY: 3.6, rightHandleX: 2.52, rightHandleY: 5.5 },\n    { x: 2.71, y: 7.96, leftHandleX: 2.65, leftHandleY: 7.13, rightHandleX: 2.8, rightHandleY: 9.08 },\n    { x: 3, y: 10, leftHandleX: 2.98, leftHandleY: 10, rightHandleX: 3.03, rightHandleY: 10, fixed: true },\n    { x: 3.5, y: 10, leftHandleX: 3.48, leftHandleY: 10, rightHandleX: 3.53, rightHandleY: 10 },\n    { x: 3.79, y: 7.96, leftHandleX: 3.7, leftHandleY: 9.08, rightHandleX: 3.85, rightHandleY: 7.13 },\n    { x: 4.08, y: 4.34, leftHandleX: 3.98, leftHandleY: 5.5, rightHandleX: 4.15, rightHandleY: 3.6 },\n    { x: 4.43, y: 1.66, leftHandleX: 4.26, leftHandleY: 2.63, rightHandleX: 4.54, rightHandleY: 1.08 },\n    { x: 5.06, y: 0, leftHandleX: 4.75, leftHandleY: 0.38, rightHandleX: 5.32, rightHandleY: 0 },\n  ],\n  // Note: Additional curves can be added from METRIC_CUSTOM_CURVES in harmony-scoring.ts\n};\n\n// ============================================\n// CORE SCORING FUNCTIONS\n// ============================================\n\n/**\n * Exponential Decay Scoring Algorithm with Directional/Dimorphic Support\n *\n * Standard: score = maxScore * e^(-decayRate * deviation)\n *\n * Directional scoring (polarity):\n * - 'higher_is_better': Values above safeFloor but below ideal get softZoneScore\n *   Example: Canthal Tilt of 3 degrees is still positive/good, just not peak ideal (6-8 degrees)\n * - 'lower_is_better': Values below safeCeiling but above ideal get softZoneScore\n *   Example: Short philtrum is still attractive even if shorter than \"ideal\"\n */\nexport function calculateMetricScore(\n  value: number,\n  config: MetricConfig\n): number {\n  const {\n    id,\n    idealMin,\n    idealMax,\n    decayRate,\n    maxScore,\n    customCurve,\n    polarity = 'balanced',\n    safeFloor,\n    safeCeiling,\n    softZoneScore = 8.0, // Default \"Good\" score for acceptable-but-not-ideal values\n  } = config;\n\n  // IMPORTANT: Check demographic-adjusted ideal range FIRST\n  // This ensures that demographic overrides are respected even when Bezier curves exist\n  // (Bezier curves are optimized for base ranges and don't auto-adjust for demographics)\n  if (value >= idealMin && value <= idealMax) {\n    return maxScore;\n  }\n\n  // Use custom curve if available in config\n  if (customCurve && customCurve.mode === 'custom') {\n    const bezierScore = interpolateCustomCurve(value, customCurve.points, maxScore);\n    // If Bezier returns -1, it means value is out of range with edge y=0\n    // Fall through to exponential decay instead of returning 0\n    if (bezierScore >= 0) {\n      // Clamp to valid range [0, maxScore] to prevent Bezier overshoot\n      return Math.max(0, Math.min(maxScore, bezierScore));\n    }\n  }\n\n  // Check for pre-defined Bezier curve from harmony curves (66 metrics)\n  const bezierCurve = BEZIER_CURVES[id];\n  if (bezierCurve && bezierCurve.mode === 'custom') {\n    const bezierScore = interpolateCustomCurve(value, bezierCurve.points, maxScore);\n    // If Bezier returns -1, it means value is out of range with edge y=0\n    // Fall through to exponential decay instead of returning 0\n    if (bezierScore >= 0) {\n      // Clamp to valid range [0, maxScore] to prevent Bezier overshoot\n      return Math.max(0, Math.min(maxScore, bezierScore));\n    }\n  }\n\n  // Handle directional/dimorphic scoring\n  if (polarity === 'higher_is_better' && safeFloor !== undefined) {\n    // Higher values are good. Only values below safeFloor are true weaknesses.\n    if (value >= safeFloor && value < idealMin) {\n      // Value is in the \"acceptable but not ideal\" zone\n      // Give a passing score that decreases linearly as we approach the floor\n      const zoneRange = idealMin - safeFloor;\n      const distanceFromIdeal = idealMin - value;\n      const t = zoneRange > 0 ? distanceFromIdeal / zoneRange : 0;\n      // Linear interpolation: idealMin -> maxScore, safeFloor -> softZoneScore\n      return maxScore - t * (maxScore - softZoneScore);\n    }\n    if (value >= idealMax) {\n      // Values above ideal are still excellent for 'higher_is_better'\n      // Apply gentler decay (1/3 the normal rate)\n      const deviation = value - idealMax;\n      const gentleDecay = decayRate / 3;\n      return Math.max(softZoneScore, maxScore * Math.exp(-gentleDecay * deviation));\n    }\n    // Below safeFloor - apply normal (or harsher) exponential decay\n    if (value < safeFloor) {\n      const deviation = safeFloor - value;\n      return Math.max(0, softZoneScore * Math.exp(-decayRate * deviation));\n    }\n  }\n\n  if (polarity === 'lower_is_better' && safeCeiling !== undefined) {\n    // Lower values are good. Only values above safeCeiling are true weaknesses.\n    if (value <= safeCeiling && value > idealMax) {\n      // Value is in the \"acceptable but not ideal\" zone\n      const zoneRange = safeCeiling - idealMax;\n      const distanceFromIdeal = value - idealMax;\n      const t = zoneRange > 0 ? distanceFromIdeal / zoneRange : 0;\n      // Linear interpolation: idealMax -> maxScore, safeCeiling -> softZoneScore\n      return maxScore - t * (maxScore - softZoneScore);\n    }\n    if (value <= idealMin) {\n      // Values below ideal are still excellent for 'lower_is_better'\n      // Apply gentler decay (1/3 the normal rate)\n      const deviation = idealMin - value;\n      const gentleDecay = decayRate / 3;\n      return Math.max(softZoneScore, maxScore * Math.exp(-gentleDecay * deviation));\n    }\n    // Above safeCeiling - apply normal exponential decay\n    if (value > safeCeiling) {\n      const deviation = value - safeCeiling;\n      return Math.max(0, softZoneScore * Math.exp(-decayRate * deviation));\n    }\n  }\n\n  // Default balanced scoring: deviation in either direction is equally bad\n  const deviation = value < idealMin\n    ? idealMin - value\n    : value - idealMax;\n\n  // Exponential decay\n  const score = maxScore * Math.exp(-decayRate * deviation);\n\n  return Math.max(0, Math.min(maxScore, score));\n}\n\n/**\n * Check if a metric value is in an \"acceptable\" zone (not a true weakness).\n * Used by InsightsEngine to prevent false positives.\n */\nexport function isValueAcceptable(\n  value: number,\n  config: MetricConfig\n): { acceptable: boolean; reason: string } {\n  const {\n    idealMin,\n    idealMax,\n    polarity = 'balanced',\n    safeFloor,\n    safeCeiling,\n  } = config;\n\n  // Within ideal range is always acceptable\n  if (value >= idealMin && value <= idealMax) {\n    return { acceptable: true, reason: 'within_ideal' };\n  }\n\n  // Check directional acceptability\n  if (polarity === 'higher_is_better') {\n    if (value >= idealMax) {\n      return { acceptable: true, reason: 'above_ideal_higher_is_better' };\n    }\n    if (safeFloor !== undefined && value >= safeFloor) {\n      return { acceptable: true, reason: 'above_safe_floor' };\n    }\n    // Below safe floor - true weakness\n    return { acceptable: false, reason: 'below_safe_floor' };\n  }\n\n  if (polarity === 'lower_is_better') {\n    if (value <= idealMin) {\n      return { acceptable: true, reason: 'below_ideal_lower_is_better' };\n    }\n    if (safeCeiling !== undefined && value <= safeCeiling) {\n      return { acceptable: true, reason: 'below_safe_ceiling' };\n    }\n    // Above safe ceiling - true weakness\n    return { acceptable: false, reason: 'above_safe_ceiling' };\n  }\n\n  // Balanced polarity - outside ideal is not acceptable\n  return { acceptable: false, reason: 'outside_ideal_balanced' };\n}\n\n/**\n * Interpolate custom Bezier curve for scoring\n * Uses cubic Bezier interpolation with control handles for smooth curves\n *\n * IMPORTANT: When value is outside the curve range and the edge y-value is 0,\n * returns -1 to signal the caller should use exponential decay fallback.\n * This prevents artificially returning 0 for values just outside the curve.\n */\nexport function interpolateCustomCurve(\n  value: number,\n  points: CurvePoint[],\n  maxScore: number\n): number {\n  void maxScore; // Reserved for future custom curve implementations\n  if (points.length === 0) return -1; // Signal to use fallback\n\n  // Sort points by x value\n  const sortedPoints = [...points].sort((a, b) => a.x - b.x);\n\n  // Handle out-of-range values\n  // If edge y-value is 0, return -1 to signal exponential decay fallback should be used\n  if (value <= sortedPoints[0].x) {\n    const edgeY = sortedPoints[0].y;\n    // If edge score is 0, signal to use exponential decay fallback\n    return edgeY <= 0 ? -1 : edgeY;\n  }\n  if (value >= sortedPoints[sortedPoints.length - 1].x) {\n    const edgeY = sortedPoints[sortedPoints.length - 1].y;\n    // If edge score is 0, signal to use exponential decay fallback\n    return edgeY <= 0 ? -1 : edgeY;\n  }\n\n  // Find bracketing points\n  let lowerIndex = 0;\n  for (let i = 0; i < sortedPoints.length - 1; i++) {\n    if (value >= sortedPoints[i].x && value <= sortedPoints[i + 1].x) {\n      lowerIndex = i;\n      break;\n    }\n  }\n\n  const p0 = sortedPoints[lowerIndex];\n  const p3 = sortedPoints[lowerIndex + 1];\n\n  // Check if we have Bezier control handles\n  const hasHandles = p0.rightHandleX !== undefined && p3.leftHandleX !== undefined;\n\n  if (hasHandles) {\n    // Cubic Bezier interpolation with control points\n    const p1x = p0.rightHandleX!;\n    const p1y = p0.rightHandleY ?? p0.y;\n    const p2x = p3.leftHandleX!;\n    const p2y = p3.leftHandleY ?? p3.y;\n\n    // Find t parameter for given x value using Newton-Raphson iteration\n    let t = (value - p0.x) / (p3.x - p0.x); // Initial guess\n\n    // Newton-Raphson iterations to find t where B_x(t) = value\n    for (let iter = 0; iter < 10; iter++) {\n      const bx = cubicBezier(p0.x, p1x, p2x, p3.x, t);\n      const bxDerivative = cubicBezierDerivative(p0.x, p1x, p2x, p3.x, t);\n\n      if (Math.abs(bxDerivative) < 1e-10) break;\n\n      const newT = t - (bx - value) / bxDerivative;\n      if (Math.abs(newT - t) < 1e-10) break;\n      t = Math.max(0, Math.min(1, newT));\n    }\n\n    // Calculate y using the found t parameter\n    return cubicBezier(p0.y, p1y, p2y, p3.y, t);\n  } else {\n    // Smooth interpolation using Catmull-Rom spline\n    // This provides smoother curves than linear interpolation\n    const t = (value - p0.x) / (p3.x - p0.x);\n\n    // Get neighboring points for spline calculation\n    const pMinus1 = lowerIndex > 0 ? sortedPoints[lowerIndex - 1] : p0;\n    const p4 = lowerIndex + 2 < sortedPoints.length ? sortedPoints[lowerIndex + 2] : p3;\n\n    // Catmull-Rom spline interpolation\n    return catmullRomSpline(pMinus1.y, p0.y, p3.y, p4.y, t);\n  }\n}\n\n/**\n * Cubic Bezier curve evaluation: B(t) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3\n */\nexport function cubicBezier(p0: number, p1: number, p2: number, p3: number, t: number): number {\n  const mt = 1 - t;\n  const mt2 = mt * mt;\n  const mt3 = mt2 * mt;\n  const t2 = t * t;\n  const t3 = t2 * t;\n  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;\n}\n\n/**\n * Cubic Bezier derivative: B'(t) = 3*(1-t)^2*(P1-P0) + 6*(1-t)*t*(P2-P1) + 3*t^2*(P3-P2)\n */\nexport function cubicBezierDerivative(p0: number, p1: number, p2: number, p3: number, t: number): number {\n  const mt = 1 - t;\n  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);\n}\n\n/**\n * Catmull-Rom spline interpolation for smooth curves without explicit handles\n */\nexport function catmullRomSpline(p0: number, p1: number, p2: number, p3: number, t: number): number {\n  const t2 = t * t;\n  const t3 = t2 * t;\n\n  // Catmull-Rom coefficients with tension = 0.5\n  const a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;\n  const b = p0 - 2.5 * p1 + 2 * p2 - 0.5 * p3;\n  const c = -0.5 * p0 + 0.5 * p2;\n  const d = p1;\n\n  return a * t3 + b * t2 + c * t + d;\n}\n\n/**\n * Calculate standardized score (0-10 normalized)\n * Clamps output to [0, 10] to prevent display issues from scoring edge cases\n */\nexport function standardizeScore(score: number, maxScore: number): number {\n  const normalized = (score / maxScore) * 10;\n  return Math.max(0, Math.min(10, normalized));\n}\n\n/**\n * Determine quality tier based on score\n */\nexport function getQualityTier(score: number, maxScore: number = 10): QualityTier {\n  const normalized = (score / maxScore) * 100;\n\n  if (normalized >= 90) return 'ideal';\n  if (normalized >= 70) return 'excellent';\n  if (normalized >= 50) return 'good';\n  return 'below_average';\n}\n\n/**\n * Determine severity level based on score\n */\nexport function getSeverityLevel(score: number, maxScore: number = 10): SeverityLevel {\n  const normalized = (score / maxScore) * 100;\n\n  if (normalized >= 85) return 'optimal';\n  if (normalized >= 70) return 'minor';\n  if (normalized >= 50) return 'moderate';\n  if (normalized >= 30) return 'major';\n  if (normalized >= 15) return 'severe';\n  return 'extremely_severe';\n}\n\n/**\n * Calculate deviation description\n */\nexport function getDeviationDescription(\n  value: number,\n  idealMin: number,\n  idealMax: number,\n  unit: MeasurementUnit\n): { deviation: number; direction: 'above' | 'below' | 'within'; description: string } {\n  if (value >= idealMin && value <= idealMax) {\n    return { deviation: 0, direction: 'within', description: 'within ideal range' };\n  }\n\n  const unitLabel = getUnitLabel(unit);\n\n  if (value < idealMin) {\n    const dev = idealMin - value;\n    return {\n      deviation: dev,\n      direction: 'below',\n      description: `${dev.toFixed(2)}${unitLabel} below ideal`,\n    };\n  }\n\n  const dev = value - idealMax;\n  return {\n    deviation: dev,\n    direction: 'above',\n    description: `${dev.toFixed(2)}${unitLabel} above ideal`,\n  };\n}\n\n/**\n * Get unit label for display\n */\nexport function getUnitLabel(unit: MeasurementUnit): string {\n  switch (unit) {\n    case 'ratio': return 'x';\n    case 'percent': return '%';\n    case 'degrees': return '\\u00B0';\n    case 'mm': return 'mm';\n    default: return '';\n  }\n}\n\n// ============================================\n// GEOMETRY HELPERS\n// ============================================\n\n/**\n * Calculate distance between two points\n */\nexport function distance(p1: Point, p2: Point): number {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\n\n/**\n * Calculate angle at vertex point (in degrees)\n */\nexport function calculateAngle(p1: Point, vertex: Point, p2: Point): number {\n  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };\n  const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };\n\n  const dot = v1.x * v2.x + v1.y * v2.y;\n  const cross = v1.x * v2.y - v1.y * v2.x;\n\n  const angle = Math.atan2(cross, dot) * (180 / Math.PI);\n  return Math.abs(angle);\n}\n\n/**\n * Calculate perpendicular distance from point to line (signed)\n */\nexport function perpendicularDistance(\n  point: Point,\n  lineStart: Point,\n  lineEnd: Point\n): number {\n  const A = point.x - lineStart.x;\n  const B = point.y - lineStart.y;\n  const C = lineEnd.x - lineStart.x;\n  const D = lineEnd.y - lineStart.y;\n\n  const dot = A * C + B * D;\n  const lenSq = C * C + D * D;\n  const param = lenSq !== 0 ? dot / lenSq : -1;\n\n  let xx: number, yy: number;\n\n  if (param < 0) {\n    xx = lineStart.x;\n    yy = lineStart.y;\n  } else if (param > 1) {\n    xx = lineEnd.x;\n    yy = lineEnd.y;\n  } else {\n    xx = lineStart.x + param * C;\n    yy = lineStart.y + param * D;\n  }\n\n  const dx = point.x - xx;\n  const dy = point.y - yy;\n\n  const sign =\n    (lineEnd.y - lineStart.y) * point.x -\n      (lineEnd.x - lineStart.x) * point.y +\n      lineEnd.x * lineStart.y -\n      lineEnd.y * lineStart.x >=\n    0\n      ? 1\n      : -1;\n\n  return sign * Math.sqrt(dx * dx + dy * dy);\n}\n\n// ============================================\n// PERCENTILE & PSL CONVERSION\n// ============================================\n\n/**\n * Calculate percentile from harmony score\n */\nexport function calculateHarmonyPercentile(score: number): number {\n  // Based on normal distribution with mean=5, stdDev=1.5\n  const mean = 5;\n  const stdDev = 1.5;\n  const z = (score - mean) / stdDev;\n  return normalCDF(z) * 100;\n}\n\n/**\n * Standard normal CDF approximation\n */\nexport function normalCDF(z: number): number {\n  const a1 = 0.254829592;\n  const a2 = -0.284496736;\n  const a3 = 1.421413741;\n  const a4 = -1.453152027;\n  const a5 = 1.061405429;\n  const p = 0.3275911;\n\n  const sign = z < 0 ? -1 : 1;\n  const absZ = Math.abs(z) / Math.sqrt(2);\n\n  const t = 1.0 / (1.0 + p * absZ);\n  const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-absZ * absZ);\n\n  return 0.5 * (1.0 + sign * y);\n}\n\n// ============================================\n// PSL RATING CONVERSION\n// ============================================\n\nexport interface PSLRating {\n  score: number;\n  tier: string;\n  percentile: number;\n  description: string;\n}\n\n/**\n * Convert harmony score to PSL rating\n */\nexport function convertToPSL(harmonyScore: number): PSLRating {\n  // Convert 0-10 harmony to 3.0-7.5 PSL range\n  const psl = 3.0 + (harmonyScore / 10) * 4.5;\n  const clampedPSL = Math.max(3.0, Math.min(7.5, psl));\n\n  let tier: string;\n  let percentile: number;\n\n  if (clampedPSL >= 7.5) {\n    tier = 'Top Model';\n    percentile = 99.99;\n  } else if (clampedPSL >= 7.0) {\n    tier = 'Chad';\n    percentile = 99.87;\n  } else if (clampedPSL >= 6.5) {\n    tier = 'Chadlite';\n    percentile = 99.0;\n  } else if (clampedPSL >= 6.0) {\n    tier = 'High Tier Normie+';\n    percentile = 97.25;\n  } else if (clampedPSL >= 5.5) {\n    tier = 'High Tier Normie';\n    percentile = 90.0;\n  } else if (clampedPSL >= 5.0) {\n    tier = 'Mid Tier Normie+';\n    percentile = 84.15;\n  } else if (clampedPSL >= 4.5) {\n    tier = 'Mid Tier Normie';\n    percentile = 65.0;\n  } else if (clampedPSL >= 4.0) {\n    tier = 'Low Tier Normie';\n    percentile = 50.0;\n  } else if (clampedPSL >= 3.5) {\n    tier = 'Below Average';\n    percentile = 30.0;\n  } else {\n    tier = 'Subpar';\n    percentile = 15.0;\n  }\n\n  return {\n    score: clampedPSL,\n    tier,\n    percentile,\n    description: `${tier} (top ${(100 - percentile).toFixed(1)}%)`,\n  };\n}\n","numLines":710,"startLine":1,"totalLines":710}}}
{"parentUuid":"7130e1e0-172c-45dd-9076-1a667c0c2129","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SUELSv4nHC9pJq5FMM3bFc","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me search for the actual measurement calculation functions to see how angles, distances, and ratios are computed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":31130,"cache_read_input_tokens":64175,"cache_creation":{"ephemeral_5m_input_tokens":31130,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd6ycjjskzCRrCTohWgH","type":"assistant","uuid":"635efebb-d51f-49a7-9319-8ea95378363b","timestamp":"2025-12-30T15:25:06.750Z"}
{"parentUuid":"635efebb-d51f-49a7-9319-8ea95378363b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SUELSv4nHC9pJq5FMM3bFc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SZjwQnCHFEecYM6pbTKvfk","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts","limit":300}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":31130,"cache_read_input_tokens":64175,"cache_creation":{"ephemeral_5m_input_tokens":31130,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd6ycjjskzCRrCTohWgH","type":"assistant","uuid":"79d3bf96-9642-4d1a-b56b-e7e1f8564c7f","timestamp":"2025-12-30T15:25:08.345Z"}
{"parentUuid":"79d3bf96-9642-4d1a-b56b-e7e1f8564c7f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SUELSv4nHC9pJq5FMM3bFc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0156RJKFNsiU6FH4hXJcQgJN","name":"Grep","input":{"pattern":"function calculate.*Angle|function calculate.*Distance|function calculate.*Ratio","path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":31130,"cache_read_input_tokens":64175,"cache_creation":{"ephemeral_5m_input_tokens":31130,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd6ycjjskzCRrCTohWgH","type":"assistant","uuid":"9a171538-177c-4f0b-8c6b-5ab860ccd348","timestamp":"2025-12-30T15:25:09.818Z"}
{"parentUuid":"9a171538-177c-4f0b-8c6b-5ab860ccd348","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SZjwQnCHFEecYM6pbTKvfk","type":"tool_result","content":"     1→/**\n     2→ * Facial Profile Analyzer\n     3→ * High-level analysis functions for front and side profile measurements\n     4→ *\n     5→ * Features:\n     6→ * - 32+ front profile measurements\n     7→ * - 30+ side profile measurements\n     8→ * - Ethnicity-specific ideal ranges\n     9→ * - Combined harmony analysis\n    10→ */\n    11→\n    12→import {\n    13→  Point,\n    14→  MetricScoreResult,\n    15→  HarmonyAnalysis,\n    16→  FlawAssessment,\n    17→  StrengthAssessment,\n    18→  DemographicOptions,\n    19→  FrontProfileResults,\n    20→  SideProfileResults,\n    21→  Gender,\n    22→  Ethnicity,\n    23→} from './types';\n    24→\n    25→import {\n    26→  calculateMetricScore,\n    27→  getQualityTier,\n    28→  getSeverityLevel,\n    29→  distance,\n    30→  calculateAngle,\n    31→  perpendicularDistance,\n    32→  standardizeScore,\n    33→  calculateHarmonyPercentile,\n    34→  getDeviationDescription,\n    35→} from './calculator';\n    36→\n    37→import { METRIC_CONFIGS } from '@/lib/data/metric-configs';\n    38→import { getMetricConfigForDemographics } from '@/lib/data/demographic-overrides';\n    39→import { LandmarkPoint } from '@/lib/landmarks';\n    40→\n    41→// ============================================\n    42→// HELPER FUNCTIONS\n    43→// ============================================\n    44→\n    45→/**\n    46→ * Helper to get landmark by ID\n    47→ */\n    48→export function getLandmark(landmarks: LandmarkPoint[], id: string): Point | null {\n    49→  const lm = landmarks.find((l) => l.id === id);\n    50→  return lm ? { x: lm.x, y: lm.y } : null;\n    51→}\n    52→\n    53→// ============================================\n    54→// SCORE A SINGLE MEASUREMENT\n    55→// ============================================\n    56→\n    57→/**\n    58→ * Calculate complete score result for a measurement.\n    59→ * If demographics provided, uses demographic-specific ideal ranges.\n    60→ */\n    61→export function scoreMeasurement(\n    62→  metricId: string,\n    63→  value: number,\n    64→  demographics?: DemographicOptions\n    65→): MetricScoreResult | null {\n    66→  // Get config with demographic overrides if provided\n    67→  const config = demographics?.gender\n    68→    ? getMetricConfigForDemographics(metricId, demographics.gender, demographics.ethnicity || 'other', METRIC_CONFIGS)\n    69→    : METRIC_CONFIGS[metricId];\n    70→\n    71→  if (!config) return null;\n    72→\n    73→  const score = calculateMetricScore(value, config);\n    74→  const standardizedScore = standardizeScore(score, config.maxScore);\n    75→  const qualityTier = getQualityTier(score, config.maxScore);\n    76→  const severity = getSeverityLevel(score, config.maxScore);\n    77→  const { deviation, direction } = getDeviationDescription(\n    78→    value,\n    79→    config.idealMin,\n    80→    config.idealMax,\n    81→    config.unit\n    82→  );\n    83→\n    84→  return {\n    85→    metricId,\n    86→    name: config.name,\n    87→    value,\n    88→    score,\n    89→    standardizedScore,\n    90→    qualityTier,\n    91→    severity,\n    92→    idealMin: config.idealMin,\n    93→    idealMax: config.idealMax,\n    94→    deviation,\n    95→    deviationDirection: direction,\n    96→    unit: config.unit,\n    97→    category: config.category,\n    98→  };\n    99→}\n   100→\n   101→// ============================================\n   102→// FRONT PROFILE ANALYSIS\n   103→// ============================================\n   104→\n   105→/**\n   106→ * Calculate all front profile measurements from landmarks.\n   107→ * Now supports ethnicity-specific ideal ranges for more accurate scoring.\n   108→ */\n   109→export function analyzeFrontProfile(\n   110→  landmarks: LandmarkPoint[],\n   111→  gender: Gender = 'male',\n   112→  ethnicity: Ethnicity = 'other'\n   113→): FrontProfileResults {\n   114→  const measurements: MetricScoreResult[] = [];\n   115→  const demographics: DemographicOptions = { gender, ethnicity };\n   116→\n   117→  // Helper to add measurement if landmarks available\n   118→  const addMeasurement = (metricId: string, value: number | null) => {\n   119→    if (value !== null) {\n   120→      const result = scoreMeasurement(metricId, value, demographics);\n   121→      if (result) measurements.push(result);\n   122→    }\n   123→  };\n   124→\n   125→  // Get key landmarks\n   126→  const trichion = getLandmark(landmarks, 'trichion');\n   127→  const nasalBase = getLandmark(landmarks, 'nasal_base');\n   128→  const subnasale = getLandmark(landmarks, 'subnasale');\n   129→  const menton = getLandmark(landmarks, 'menton');\n   130→  const leftZygion = getLandmark(landmarks, 'left_zygion');\n   131→  const rightZygion = getLandmark(landmarks, 'right_zygion');\n   132→  const leftGonion = getLandmark(landmarks, 'left_gonion_inferior');\n   133→  const rightGonion = getLandmark(landmarks, 'right_gonion_inferior');\n   134→  const leftPupil = getLandmark(landmarks, 'left_pupila');\n   135→  const rightPupil = getLandmark(landmarks, 'right_pupila');\n   136→  const leftCanthusM = getLandmark(landmarks, 'left_canthus_medialis');\n   137→  const leftCanthusL = getLandmark(landmarks, 'left_canthus_lateralis');\n   138→  const rightCanthusM = getLandmark(landmarks, 'right_canthus_medialis');\n   139→  const rightCanthusL = getLandmark(landmarks, 'right_canthus_lateralis');\n   140→  void rightCanthusL; // Will be used for asymmetry measurements\n   141→  const leftAlaNasi = getLandmark(landmarks, 'left_ala_nasi');\n   142→  const rightAlaNasi = getLandmark(landmarks, 'right_ala_nasi');\n   143→  const leftCheilion = getLandmark(landmarks, 'left_cheilion');\n   144→  const rightCheilion = getLandmark(landmarks, 'right_cheilion');\n   145→  const labraleSuperius = getLandmark(landmarks, 'labrale_superius');\n   146→  const labraleInferius = getLandmark(landmarks, 'labrale_inferius');\n   147→  const nasion = getLandmark(landmarks, 'nasion'); // For FWHR calculation\n   148→\n   149→  // FACIAL THIRDS\n   150→  if (trichion && nasalBase && subnasale && menton) {\n   151→    const totalHeight = distance(trichion, menton);\n   152→    if (totalHeight > 0) {\n   153→      const upperThird = (distance(trichion, nasalBase) / totalHeight) * 100;\n   154→      const middleThird = (distance(nasalBase, subnasale) / totalHeight) * 100;\n   155→      const lowerThird = (distance(subnasale, menton) / totalHeight) * 100;\n   156→\n   157→      addMeasurement('upperThirdProportion', upperThird);\n   158→      addMeasurement('middleThirdProportion', middleThird);\n   159→      addMeasurement('lowerThirdProportion', lowerThird);\n   160→\n   161→      // Lower Third Internal Ratio (subnasale to stomion / subnasale to menton)\n   162→      const stomion = getLandmark(landmarks, 'mouth_middle');\n   163→      if (stomion) {\n   164→        const subnasaleToStomion = distance(subnasale, stomion);\n   165→        const subnasaleToMenton = distance(subnasale, menton);\n   166→        if (subnasaleToMenton > 0) {\n   167→          const lowerThirdAlt = (subnasaleToStomion / subnasaleToMenton) * 100;\n   168→          addMeasurement('lowerThirdProportionAlt', lowerThirdAlt);\n   169→        }\n   170→      }\n   171→    }\n   172→  }\n   173→\n   174→  // FACE WIDTH TO HEIGHT RATIO (FWHR)\n   175→  // Uses Nasion to Upper Lip (standard cephalometric definition)\n   176→  if (leftZygion && rightZygion && nasion && labraleSuperius) {\n   177→    const bizygomaticWidth = distance(leftZygion, rightZygion);\n   178→    const upperFaceHeight = distance(nasion, labraleSuperius);\n   179→    if (upperFaceHeight > 0) {\n   180→      addMeasurement('faceWidthToHeight', bizygomaticWidth / upperFaceHeight);\n   181→    }\n   182→  }\n   183→\n   184→  // TOTAL FACIAL WIDTH TO HEIGHT\n   185→  if (leftZygion && rightZygion && trichion && menton) {\n   186→    const cheekWidth = distance(leftZygion, rightZygion);\n   187→    const totalHeight = distance(trichion, menton);\n   188→    if (cheekWidth > 0) {\n   189→      addMeasurement('totalFacialWidthToHeight', totalHeight / cheekWidth);\n   190→    }\n   191→  }\n   192→\n   193→  // JAW WIDTH RATIO\n   194→  if (leftGonion && rightGonion && leftZygion && rightZygion) {\n   195→    const bigonialWidth = distance(leftGonion, rightGonion);\n   196→    const bizygomaticWidth = distance(leftZygion, rightZygion);\n   197→    if (bizygomaticWidth > 0) {\n   198→      const ratio = bigonialWidth / bizygomaticWidth;\n   199→      addMeasurement('jawWidthRatio', ratio);\n   200→      addMeasurement('bigonialWidth', ratio * 100);\n   201→    }\n   202→  }\n   203→\n   204→  // CANTHAL TILT\n   205→  // Positive tilt = lateral canthus is higher than medial (lower y in screen coords)\n   206→  // Use abs(deltaX) to avoid sign issues between left/right eye\n   207→  if (leftCanthusM && leftCanthusL) {\n   208→    const deltaY = leftCanthusM.y - leftCanthusL.y;  // positive if lateral is higher\n   209→    const deltaX = Math.abs(leftCanthusM.x - leftCanthusL.x);  // eye width (always positive)\n   210→    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n   211→    addMeasurement('lateralCanthalTilt', angle);\n   212→  }\n   213→\n   214→  // EYE ASPECT RATIO\n   215→  if (leftCanthusM && leftCanthusL) {\n   216→    const leftPalpSup = getLandmark(landmarks, 'left_palpebra_superior');\n   217→    const leftPalpInf = getLandmark(landmarks, 'left_palpebra_inferior');\n   218→    if (leftPalpSup && leftPalpInf) {\n   219→      const eyeWidth = distance(leftCanthusM, leftCanthusL);\n   220→      const eyeHeight = distance(leftPalpSup, leftPalpInf);\n   221→      if (eyeHeight > 0) {\n   222→        // Eye aspect ratio = width / height (ideal ~3.0-3.5 for almond shape)\n   223→        addMeasurement('eyeAspectRatio', eyeWidth / eyeHeight);\n   224→      }\n   225→    }\n   226→  }\n   227→\n   228→  // EYE SEPARATION RATIO\n   229→  // IPD / Bizygomatic Width * 100 (ideal ~46%)\n   230→  if (leftPupil && rightPupil && leftZygion && rightZygion) {\n   231→    const bizygomatic = distance(leftZygion, rightZygion);\n   232→    const ipd = distance(leftPupil, rightPupil);\n   233→    if (bizygomatic > 0) {\n   234→      addMeasurement('eyeSeparationRatio', (ipd / bizygomatic) * 100);\n   235→    }\n   236→  }\n   237→\n   238→  // IPD RATIO\n   239→  if (leftPupil && rightPupil && leftZygion && rightZygion) {\n   240→    const ipd = distance(leftPupil, rightPupil);\n   241→    const bizygomatic = distance(leftZygion, rightZygion);\n   242→    if (bizygomatic > 0) {\n   243→      addMeasurement('interpupillaryRatio', (ipd / bizygomatic) * 100);\n   244→    }\n   245→  }\n   246→\n   247→  // ONE EYE APART TEST\n   248→  if (leftCanthusM && rightCanthusM && leftCanthusL) {\n   249→    const intercanthal = distance(leftCanthusM, rightCanthusM);\n   250→    const eyeWidth = distance(leftCanthusM, leftCanthusL);\n   251→    if (eyeWidth > 0) {\n   252→      addMeasurement('oneEyeApartTest', intercanthal / eyeWidth);\n   253→    }\n   254→  }\n   255→\n   256→  // NASAL INDEX\n   257→  if (leftAlaNasi && rightAlaNasi && nasalBase && subnasale) {\n   258→    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);\n   259→    const nasalHeight = distance(nasalBase, subnasale);\n   260→    if (nasalHeight > 0) {\n   261→      addMeasurement('nasalIndex', (nasalWidth / nasalHeight) * 100);\n   262→    }\n   263→  }\n   264→\n   265→  // INTERCANTHAL-NASAL WIDTH RATIO\n   266→  if (leftCanthusM && rightCanthusM && leftAlaNasi && rightAlaNasi) {\n   267→    const intercanthal = distance(leftCanthusM, rightCanthusM);\n   268→    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);\n   269→    if (nasalWidth > 0) {\n   270→      addMeasurement('intercanthalNasalRatio', intercanthal / nasalWidth);\n   271→    }\n   272→  }\n   273→\n   274→  // MOUTH TO NOSE RATIO\n   275→  if (leftCheilion && rightCheilion && leftAlaNasi && rightAlaNasi) {\n   276→    const mouthWidth = distance(leftCheilion, rightCheilion);\n   277→    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);\n   278→    if (nasalWidth > 0) {\n   279→      addMeasurement('mouthWidthToNoseRatio', mouthWidth / nasalWidth);\n   280→    }\n   281→  }\n   282→\n   283→  // IPD TO MOUTH WIDTH RATIO\n   284→  if (leftPupil && rightPupil && leftCheilion && rightCheilion) {\n   285→    const ipd = distance(leftPupil, rightPupil);\n   286→    const mouthWidth = distance(leftCheilion, rightCheilion);\n   287→    if (ipd > 0) {\n   288→      addMeasurement('interpupillaryMouthWidthRatio', mouthWidth / ipd);\n   289→    }\n   290→  }\n   291→\n   292→  // LIP RATIO\n   293→  if (labraleSuperius && labraleInferius && subnasale) {\n   294→    const mouthMiddle = getLandmark(landmarks, 'mouth_middle');\n   295→    if (mouthMiddle) {\n   296→      const upperLipHeight = distance(subnasale, labraleSuperius);\n   297→      const lowerLipHeight = distance(mouthMiddle, labraleInferius);\n   298→      if (upperLipHeight > 0) {\n   299→        addMeasurement('lowerToUpperLipRatio', lowerLipHeight / upperLipHeight);\n   300→      }\n\n</system-reminder>\n"}]},"uuid":"35734848-1383-4488-9c52-d9826b9f180f","timestamp":"2025-12-30T15:25:09.898Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts","content":"/**\n * Facial Profile Analyzer\n * High-level analysis functions for front and side profile measurements\n *\n * Features:\n * - 32+ front profile measurements\n * - 30+ side profile measurements\n * - Ethnicity-specific ideal ranges\n * - Combined harmony analysis\n */\n\nimport {\n  Point,\n  MetricScoreResult,\n  HarmonyAnalysis,\n  FlawAssessment,\n  StrengthAssessment,\n  DemographicOptions,\n  FrontProfileResults,\n  SideProfileResults,\n  Gender,\n  Ethnicity,\n} from './types';\n\nimport {\n  calculateMetricScore,\n  getQualityTier,\n  getSeverityLevel,\n  distance,\n  calculateAngle,\n  perpendicularDistance,\n  standardizeScore,\n  calculateHarmonyPercentile,\n  getDeviationDescription,\n} from './calculator';\n\nimport { METRIC_CONFIGS } from '@/lib/data/metric-configs';\nimport { getMetricConfigForDemographics } from '@/lib/data/demographic-overrides';\nimport { LandmarkPoint } from '@/lib/landmarks';\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\n/**\n * Helper to get landmark by ID\n */\nexport function getLandmark(landmarks: LandmarkPoint[], id: string): Point | null {\n  const lm = landmarks.find((l) => l.id === id);\n  return lm ? { x: lm.x, y: lm.y } : null;\n}\n\n// ============================================\n// SCORE A SINGLE MEASUREMENT\n// ============================================\n\n/**\n * Calculate complete score result for a measurement.\n * If demographics provided, uses demographic-specific ideal ranges.\n */\nexport function scoreMeasurement(\n  metricId: string,\n  value: number,\n  demographics?: DemographicOptions\n): MetricScoreResult | null {\n  // Get config with demographic overrides if provided\n  const config = demographics?.gender\n    ? getMetricConfigForDemographics(metricId, demographics.gender, demographics.ethnicity || 'other', METRIC_CONFIGS)\n    : METRIC_CONFIGS[metricId];\n\n  if (!config) return null;\n\n  const score = calculateMetricScore(value, config);\n  const standardizedScore = standardizeScore(score, config.maxScore);\n  const qualityTier = getQualityTier(score, config.maxScore);\n  const severity = getSeverityLevel(score, config.maxScore);\n  const { deviation, direction } = getDeviationDescription(\n    value,\n    config.idealMin,\n    config.idealMax,\n    config.unit\n  );\n\n  return {\n    metricId,\n    name: config.name,\n    value,\n    score,\n    standardizedScore,\n    qualityTier,\n    severity,\n    idealMin: config.idealMin,\n    idealMax: config.idealMax,\n    deviation,\n    deviationDirection: direction,\n    unit: config.unit,\n    category: config.category,\n  };\n}\n\n// ============================================\n// FRONT PROFILE ANALYSIS\n// ============================================\n\n/**\n * Calculate all front profile measurements from landmarks.\n * Now supports ethnicity-specific ideal ranges for more accurate scoring.\n */\nexport function analyzeFrontProfile(\n  landmarks: LandmarkPoint[],\n  gender: Gender = 'male',\n  ethnicity: Ethnicity = 'other'\n): FrontProfileResults {\n  const measurements: MetricScoreResult[] = [];\n  const demographics: DemographicOptions = { gender, ethnicity };\n\n  // Helper to add measurement if landmarks available\n  const addMeasurement = (metricId: string, value: number | null) => {\n    if (value !== null) {\n      const result = scoreMeasurement(metricId, value, demographics);\n      if (result) measurements.push(result);\n    }\n  };\n\n  // Get key landmarks\n  const trichion = getLandmark(landmarks, 'trichion');\n  const nasalBase = getLandmark(landmarks, 'nasal_base');\n  const subnasale = getLandmark(landmarks, 'subnasale');\n  const menton = getLandmark(landmarks, 'menton');\n  const leftZygion = getLandmark(landmarks, 'left_zygion');\n  const rightZygion = getLandmark(landmarks, 'right_zygion');\n  const leftGonion = getLandmark(landmarks, 'left_gonion_inferior');\n  const rightGonion = getLandmark(landmarks, 'right_gonion_inferior');\n  const leftPupil = getLandmark(landmarks, 'left_pupila');\n  const rightPupil = getLandmark(landmarks, 'right_pupila');\n  const leftCanthusM = getLandmark(landmarks, 'left_canthus_medialis');\n  const leftCanthusL = getLandmark(landmarks, 'left_canthus_lateralis');\n  const rightCanthusM = getLandmark(landmarks, 'right_canthus_medialis');\n  const rightCanthusL = getLandmark(landmarks, 'right_canthus_lateralis');\n  void rightCanthusL; // Will be used for asymmetry measurements\n  const leftAlaNasi = getLandmark(landmarks, 'left_ala_nasi');\n  const rightAlaNasi = getLandmark(landmarks, 'right_ala_nasi');\n  const leftCheilion = getLandmark(landmarks, 'left_cheilion');\n  const rightCheilion = getLandmark(landmarks, 'right_cheilion');\n  const labraleSuperius = getLandmark(landmarks, 'labrale_superius');\n  const labraleInferius = getLandmark(landmarks, 'labrale_inferius');\n  const nasion = getLandmark(landmarks, 'nasion'); // For FWHR calculation\n\n  // FACIAL THIRDS\n  if (trichion && nasalBase && subnasale && menton) {\n    const totalHeight = distance(trichion, menton);\n    if (totalHeight > 0) {\n      const upperThird = (distance(trichion, nasalBase) / totalHeight) * 100;\n      const middleThird = (distance(nasalBase, subnasale) / totalHeight) * 100;\n      const lowerThird = (distance(subnasale, menton) / totalHeight) * 100;\n\n      addMeasurement('upperThirdProportion', upperThird);\n      addMeasurement('middleThirdProportion', middleThird);\n      addMeasurement('lowerThirdProportion', lowerThird);\n\n      // Lower Third Internal Ratio (subnasale to stomion / subnasale to menton)\n      const stomion = getLandmark(landmarks, 'mouth_middle');\n      if (stomion) {\n        const subnasaleToStomion = distance(subnasale, stomion);\n        const subnasaleToMenton = distance(subnasale, menton);\n        if (subnasaleToMenton > 0) {\n          const lowerThirdAlt = (subnasaleToStomion / subnasaleToMenton) * 100;\n          addMeasurement('lowerThirdProportionAlt', lowerThirdAlt);\n        }\n      }\n    }\n  }\n\n  // FACE WIDTH TO HEIGHT RATIO (FWHR)\n  // Uses Nasion to Upper Lip (standard cephalometric definition)\n  if (leftZygion && rightZygion && nasion && labraleSuperius) {\n    const bizygomaticWidth = distance(leftZygion, rightZygion);\n    const upperFaceHeight = distance(nasion, labraleSuperius);\n    if (upperFaceHeight > 0) {\n      addMeasurement('faceWidthToHeight', bizygomaticWidth / upperFaceHeight);\n    }\n  }\n\n  // TOTAL FACIAL WIDTH TO HEIGHT\n  if (leftZygion && rightZygion && trichion && menton) {\n    const cheekWidth = distance(leftZygion, rightZygion);\n    const totalHeight = distance(trichion, menton);\n    if (cheekWidth > 0) {\n      addMeasurement('totalFacialWidthToHeight', totalHeight / cheekWidth);\n    }\n  }\n\n  // JAW WIDTH RATIO\n  if (leftGonion && rightGonion && leftZygion && rightZygion) {\n    const bigonialWidth = distance(leftGonion, rightGonion);\n    const bizygomaticWidth = distance(leftZygion, rightZygion);\n    if (bizygomaticWidth > 0) {\n      const ratio = bigonialWidth / bizygomaticWidth;\n      addMeasurement('jawWidthRatio', ratio);\n      addMeasurement('bigonialWidth', ratio * 100);\n    }\n  }\n\n  // CANTHAL TILT\n  // Positive tilt = lateral canthus is higher than medial (lower y in screen coords)\n  // Use abs(deltaX) to avoid sign issues between left/right eye\n  if (leftCanthusM && leftCanthusL) {\n    const deltaY = leftCanthusM.y - leftCanthusL.y;  // positive if lateral is higher\n    const deltaX = Math.abs(leftCanthusM.x - leftCanthusL.x);  // eye width (always positive)\n    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n    addMeasurement('lateralCanthalTilt', angle);\n  }\n\n  // EYE ASPECT RATIO\n  if (leftCanthusM && leftCanthusL) {\n    const leftPalpSup = getLandmark(landmarks, 'left_palpebra_superior');\n    const leftPalpInf = getLandmark(landmarks, 'left_palpebra_inferior');\n    if (leftPalpSup && leftPalpInf) {\n      const eyeWidth = distance(leftCanthusM, leftCanthusL);\n      const eyeHeight = distance(leftPalpSup, leftPalpInf);\n      if (eyeHeight > 0) {\n        // Eye aspect ratio = width / height (ideal ~3.0-3.5 for almond shape)\n        addMeasurement('eyeAspectRatio', eyeWidth / eyeHeight);\n      }\n    }\n  }\n\n  // EYE SEPARATION RATIO\n  // IPD / Bizygomatic Width * 100 (ideal ~46%)\n  if (leftPupil && rightPupil && leftZygion && rightZygion) {\n    const bizygomatic = distance(leftZygion, rightZygion);\n    const ipd = distance(leftPupil, rightPupil);\n    if (bizygomatic > 0) {\n      addMeasurement('eyeSeparationRatio', (ipd / bizygomatic) * 100);\n    }\n  }\n\n  // IPD RATIO\n  if (leftPupil && rightPupil && leftZygion && rightZygion) {\n    const ipd = distance(leftPupil, rightPupil);\n    const bizygomatic = distance(leftZygion, rightZygion);\n    if (bizygomatic > 0) {\n      addMeasurement('interpupillaryRatio', (ipd / bizygomatic) * 100);\n    }\n  }\n\n  // ONE EYE APART TEST\n  if (leftCanthusM && rightCanthusM && leftCanthusL) {\n    const intercanthal = distance(leftCanthusM, rightCanthusM);\n    const eyeWidth = distance(leftCanthusM, leftCanthusL);\n    if (eyeWidth > 0) {\n      addMeasurement('oneEyeApartTest', intercanthal / eyeWidth);\n    }\n  }\n\n  // NASAL INDEX\n  if (leftAlaNasi && rightAlaNasi && nasalBase && subnasale) {\n    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);\n    const nasalHeight = distance(nasalBase, subnasale);\n    if (nasalHeight > 0) {\n      addMeasurement('nasalIndex', (nasalWidth / nasalHeight) * 100);\n    }\n  }\n\n  // INTERCANTHAL-NASAL WIDTH RATIO\n  if (leftCanthusM && rightCanthusM && leftAlaNasi && rightAlaNasi) {\n    const intercanthal = distance(leftCanthusM, rightCanthusM);\n    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);\n    if (nasalWidth > 0) {\n      addMeasurement('intercanthalNasalRatio', intercanthal / nasalWidth);\n    }\n  }\n\n  // MOUTH TO NOSE RATIO\n  if (leftCheilion && rightCheilion && leftAlaNasi && rightAlaNasi) {\n    const mouthWidth = distance(leftCheilion, rightCheilion);\n    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);\n    if (nasalWidth > 0) {\n      addMeasurement('mouthWidthToNoseRatio', mouthWidth / nasalWidth);\n    }\n  }\n\n  // IPD TO MOUTH WIDTH RATIO\n  if (leftPupil && rightPupil && leftCheilion && rightCheilion) {\n    const ipd = distance(leftPupil, rightPupil);\n    const mouthWidth = distance(leftCheilion, rightCheilion);\n    if (ipd > 0) {\n      addMeasurement('interpupillaryMouthWidthRatio', mouthWidth / ipd);\n    }\n  }\n\n  // LIP RATIO\n  if (labraleSuperius && labraleInferius && subnasale) {\n    const mouthMiddle = getLandmark(landmarks, 'mouth_middle');\n    if (mouthMiddle) {\n      const upperLipHeight = distance(subnasale, labraleSuperius);\n      const lowerLipHeight = distance(mouthMiddle, labraleInferius);\n      if (upperLipHeight > 0) {\n        addMeasurement('lowerToUpperLipRatio', lowerLipHeight / upperLipHeight);\n      }","numLines":300,"startLine":1,"totalLines":790}}}
{"parentUuid":"35734848-1383-4488-9c52-d9826b9f180f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0156RJKFNsiU6FH4hXJcQgJN","type":"tool_result","content":"src/lib/sideProfileNormalization.ts:76:export function calculateFaceIQRotationAngle(\nsrc/lib/scoring/calculator.ts:558:export function calculateAngle(p1: Point, vertex: Point, p2: Point): number {\nsrc/lib/scoring.ts:746:export function calculateGonialAngle(\nsrc/lib/scoring.ts:758:export function calculateNasolabialAngle(\nsrc/lib/scoring.ts:792:export function calculateJawRatio(\nsrc/lib/faceiq-parity/categoryScores.ts:131:export function calculateCategoryScores(ratios: Ratio[]): CategoryScoreResult {"}]},"uuid":"d5b0ed7d-ef14-4ac7-9758-0b4e6e7f66b1","timestamp":"2025-12-30T15:25:09.909Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"src/lib/sideProfileNormalization.ts:76:export function calculateFaceIQRotationAngle(\nsrc/lib/scoring/calculator.ts:558:export function calculateAngle(p1: Point, vertex: Point, p2: Point): number {\nsrc/lib/scoring.ts:746:export function calculateGonialAngle(\nsrc/lib/scoring.ts:758:export function calculateNasolabialAngle(\nsrc/lib/scoring.ts:792:export function calculateJawRatio(\nsrc/lib/faceiq-parity/categoryScores.ts:131:export function calculateCategoryScores(ratios: Ratio[]): CategoryScoreResult {","numLines":6}}
{"parentUuid":"d5b0ed7d-ef14-4ac7-9758-0b4e6e7f66b1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01NP31HncSi657vgAEemRv49","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BxD5jmKrfym89wApucmCXC","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring.ts","offset":740,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5141,"cache_read_input_tokens":95305,"cache_creation":{"ephemeral_5m_input_tokens":5141,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWd6zDGPQwAPKvVArbb7z","type":"assistant","uuid":"f2bd3f10-dda3-4d78-8426-baa13b671ac5","timestamp":"2025-12-30T15:25:14.234Z"}
{"parentUuid":"f2bd3f10-dda3-4d78-8426-baa13b671ac5","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01NP31HncSi657vgAEemRv49","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017D9Zm2wu1qPrNvWeHs5nqe","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sideProfileNormalization.ts","offset":70,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":5141,"cache_read_input_tokens":95305,"cache_creation":{"ephemeral_5m_input_tokens":5141,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWd6zDGPQwAPKvVArbb7z","type":"assistant","uuid":"8d3836f2-311a-4c32-903b-6d052cb4a8da","timestamp":"2025-12-30T15:25:15.007Z"}
{"parentUuid":"8d3836f2-311a-4c32-903b-6d052cb4a8da","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BxD5jmKrfym89wApucmCXC","type":"tool_result","content":"   740→  return m ? toScoreResult(m) : null;\n   741→}\n   742→\n   743→/**\n   744→ * @deprecated Use analyzeSideProfile or METRIC_CONFIGS directly\n   745→ */\n   746→export function calculateGonialAngle(\n   747→  sideLandmarks: LandmarkPoint[],\n   748→  gender: 'male' | 'female' = 'male'\n   749→): ScoreResult | null {\n   750→  const results = sideAnalysis(sideLandmarks, gender);\n   751→  const m = results.measurements.find(m => m.metricId === 'gonialAngle');\n   752→  return m ? toScoreResult(m) : null;\n   753→}\n   754→\n   755→/**\n   756→ * @deprecated Use analyzeSideProfile or METRIC_CONFIGS directly\n   757→ */\n   758→export function calculateNasolabialAngle(\n   759→  sideLandmarks: LandmarkPoint[],\n   760→  gender: 'male' | 'female' = 'male'\n   761→): ScoreResult | null {\n   762→  const results = sideAnalysis(sideLandmarks, gender);\n   763→  const m = results.measurements.find(m => m.metricId === 'nasolabialAngle');\n   764→  return m ? toScoreResult(m) : null;\n   765→}\n   766→\n   767→/**\n   768→ * @deprecated Use analyzeFrontProfile or METRIC_CONFIGS directly\n   769→ */\n   770→export function calculateCanthalTilt(\n   771→  frontLandmarks: LandmarkPoint[],\n   772→  _side: 'left' | 'right' = 'left'\n   773→): ScoreResult | null {\n   774→  void _side; // Parameter kept for backward compatibility\n   775→  const results = frontAnalysis(frontLandmarks);\n   776→  const m = results.measurements.find(m => m.metricId === 'lateralCanthalTilt');\n   777→  return m ? toScoreResult(m) : null;\n   778→}\n   779→\n   780→/**\n   781→ * @deprecated Use analyzeFrontProfile or METRIC_CONFIGS directly\n   782→ */\n   783→export function calculateNasalIndex(frontLandmarks: LandmarkPoint[]): ScoreResult | null {\n   784→  const results = frontAnalysis(frontLandmarks);\n   785→  const m = results.measurements.find(m => m.metricId === 'nasalIndex');\n   786→  return m ? toScoreResult(m) : null;\n   787→}\n   788→\n   789→/**\n   790→ * @deprecated Use analyzeFrontProfile or METRIC_CONFIGS directly\n   791→ */\n   792→export function calculateJawRatio(\n   793→  frontLandmarks: LandmarkPoint[],\n   794→  gender: 'male' | 'female' = 'male'\n   795→): ScoreResult | null {\n   796→  const results = frontAnalysis(frontLandmarks, gender);\n   797→  const m = results.measurements.find(m => m.metricId === 'jawWidthRatio');\n   798→  return m ? toScoreResult(m) : null;\n   799→}\n   800→\n   801→// Re-export types\n   802→export type {\n   803→  LandmarkPoint,\n   804→  ScoringConfig,\n   805→  PopulationStats,\n   806→};\n   807→\n   808→export {\n   809→  SCORING_CONFIGS,\n   810→  IDEAL_VALUES,\n   811→  POPULATION_STATS,\n   812→};\n   813→\n\n</system-reminder>\n"}]},"uuid":"2ca53b63-e321-4fc1-87e3-ca9158796817","timestamp":"2025-12-30T15:25:15.072Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring.ts","content":"  return m ? toScoreResult(m) : null;\n}\n\n/**\n * @deprecated Use analyzeSideProfile or METRIC_CONFIGS directly\n */\nexport function calculateGonialAngle(\n  sideLandmarks: LandmarkPoint[],\n  gender: 'male' | 'female' = 'male'\n): ScoreResult | null {\n  const results = sideAnalysis(sideLandmarks, gender);\n  const m = results.measurements.find(m => m.metricId === 'gonialAngle');\n  return m ? toScoreResult(m) : null;\n}\n\n/**\n * @deprecated Use analyzeSideProfile or METRIC_CONFIGS directly\n */\nexport function calculateNasolabialAngle(\n  sideLandmarks: LandmarkPoint[],\n  gender: 'male' | 'female' = 'male'\n): ScoreResult | null {\n  const results = sideAnalysis(sideLandmarks, gender);\n  const m = results.measurements.find(m => m.metricId === 'nasolabialAngle');\n  return m ? toScoreResult(m) : null;\n}\n\n/**\n * @deprecated Use analyzeFrontProfile or METRIC_CONFIGS directly\n */\nexport function calculateCanthalTilt(\n  frontLandmarks: LandmarkPoint[],\n  _side: 'left' | 'right' = 'left'\n): ScoreResult | null {\n  void _side; // Parameter kept for backward compatibility\n  const results = frontAnalysis(frontLandmarks);\n  const m = results.measurements.find(m => m.metricId === 'lateralCanthalTilt');\n  return m ? toScoreResult(m) : null;\n}\n\n/**\n * @deprecated Use analyzeFrontProfile or METRIC_CONFIGS directly\n */\nexport function calculateNasalIndex(frontLandmarks: LandmarkPoint[]): ScoreResult | null {\n  const results = frontAnalysis(frontLandmarks);\n  const m = results.measurements.find(m => m.metricId === 'nasalIndex');\n  return m ? toScoreResult(m) : null;\n}\n\n/**\n * @deprecated Use analyzeFrontProfile or METRIC_CONFIGS directly\n */\nexport function calculateJawRatio(\n  frontLandmarks: LandmarkPoint[],\n  gender: 'male' | 'female' = 'male'\n): ScoreResult | null {\n  const results = frontAnalysis(frontLandmarks, gender);\n  const m = results.measurements.find(m => m.metricId === 'jawWidthRatio');\n  return m ? toScoreResult(m) : null;\n}\n\n// Re-export types\nexport type {\n  LandmarkPoint,\n  ScoringConfig,\n  PopulationStats,\n};\n\nexport {\n  SCORING_CONFIGS,\n  IDEAL_VALUES,\n  POPULATION_STATS,\n};\n","numLines":74,"startLine":740,"totalLines":813}}}
{"parentUuid":"2ca53b63-e321-4fc1-87e3-ca9158796817","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017D9Zm2wu1qPrNvWeHs5nqe","type":"tool_result","content":"    70→ * Calculate rotation angle using FaceIQ's exact algorithm\n    71→ * \n    72→ * @param landmarks - Raw landmarks array from API\n    73→ * @param direction - Face direction (\"left\" or \"right\")\n    74→ * @returns Rotation angle in radians\n    75→ */\n    76→export function calculateFaceIQRotationAngle(\n    77→    landmarks: Array<{ x: number; y: number }>,\n    78→    direction: 'left' | 'right'\n    79→): number {\n    80→    // FaceIQ algorithm:\n    81→    // anchor = (direction === \"left\") ? landmarks[75] : landmarks[10];\n    82→    // reference = landmarks[26];\n    83→    // angle = Math.atan2(reference.y - anchor.y, reference.x - anchor.x);\n    84→\n    85→    const anchor = direction === 'left' ? landmarks[75] : landmarks[10];\n    86→    const reference = landmarks[26];\n    87→\n    88→    if (!anchor || !reference) {\n    89→        console.warn('[FaceIQ Normalization] Missing landmark indices 10, 26, or 75');\n    90→        return 0;\n    91→    }\n    92→\n    93→    const angle = Math.atan2(reference.y - anchor.y, reference.x - anchor.x);\n    94→    return angle;\n    95→}\n    96→\n    97→/**\n    98→ * Get the rotation pivot point using FaceIQ's logic\n    99→ * \n   100→ * @param landmarks - Raw landmarks array\n   101→ * @param direction - Face direction\n   102→ * @returns Pivot point coordinates\n   103→ */\n   104→export function getFaceIQPivot(\n   105→    landmarks: Array<{ x: number; y: number }>,\n   106→    direction: 'left' | 'right'\n   107→): Point2D {\n   108→    // FaceIQ: pivot = (direction === \"right\") ? landmarks[10] : landmarks[26]\n   109→    const pivotLandmark = direction === 'right' ? landmarks[10] : landmarks[26];\n   110→\n   111→    if (!pivotLandmark) {\n   112→        return { x: 0.5, y: 0.5 };\n   113→    }\n   114→\n   115→    return { x: pivotLandmark.x, y: pivotLandmark.y };\n   116→}\n   117→\n   118→/**\n   119→ * Rotate a point around a pivot using FaceIQ's formula\n   120→ * \n   121→ * FaceIQ's rotation function:\n   122→ * ```\n   123→ * let j = e => {\n   124→ *   let t = Math.sin(-g), i = Math.cos(-g), a = e.x - f, s = e.y - b;\n   125→ *   return { x: f + a * i - s * t, y: b + a * t + s * i };\n   126→ * };\n   127→ * ```\n   128→ */\n   129→export function rotatePointFaceIQ(\n   130→    point: Point2D,\n   131→    pivot: Point2D,\n   132→    angleRad: number\n   133→): Point2D {\n   134→    // FaceIQ rotates by NEGATIVE angle\n   135→    const negAngle = -angleRad;\n   136→    const sin = Math.sin(negAngle);\n   137→    const cos = Math.cos(negAngle);\n   138→\n   139→    const dx = point.x - pivot.x;\n   140→    const dy = point.y - pivot.y;\n   141→\n   142→    return {\n   143→        x: pivot.x + dx * cos - dy * sin,\n   144→        y: pivot.y + dx * sin + dy * cos,\n   145→    };\n   146→}\n   147→\n   148→/**\n   149→ * Calculate crop dimensions using FaceIQ's formula\n   150→ * \n   151→ * FaceIQ algorithm:\n   152→ * - croppedHeight = bboxHeight * 1.12\n   153→ * - cropSize = croppedHeight / 0.65\n   154→ * - Constrained between 32 and 2 * max(width, height)\n   155→ */\n   156→export function calculateFaceIQCropSize(\n   157→    bboxHeight: number,\n   158→    imageWidth: number,\n   159→    imageHeight: number\n   160→): number {\n   161→    const scaledHeight = bboxHeight * 1.12;\n   162→    const cropSize = scaledHeight / 0.65;\n   163→\n   164→    // FaceIQ constraints\n   165→    const minSize = 32;\n   166→    const maxSize = 2 * Math.max(imageWidth, imageHeight);\n   167→\n   168→    return Math.min(Math.max(minSize, cropSize), maxSize);\n   169→}\n\n</system-reminder>\n"}]},"uuid":"55dfd519-37b4-4aaf-ae86-856f9ae4b935","timestamp":"2025-12-30T15:25:15.072Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sideProfileNormalization.ts","content":" * Calculate rotation angle using FaceIQ's exact algorithm\n * \n * @param landmarks - Raw landmarks array from API\n * @param direction - Face direction (\"left\" or \"right\")\n * @returns Rotation angle in radians\n */\nexport function calculateFaceIQRotationAngle(\n    landmarks: Array<{ x: number; y: number }>,\n    direction: 'left' | 'right'\n): number {\n    // FaceIQ algorithm:\n    // anchor = (direction === \"left\") ? landmarks[75] : landmarks[10];\n    // reference = landmarks[26];\n    // angle = Math.atan2(reference.y - anchor.y, reference.x - anchor.x);\n\n    const anchor = direction === 'left' ? landmarks[75] : landmarks[10];\n    const reference = landmarks[26];\n\n    if (!anchor || !reference) {\n        console.warn('[FaceIQ Normalization] Missing landmark indices 10, 26, or 75');\n        return 0;\n    }\n\n    const angle = Math.atan2(reference.y - anchor.y, reference.x - anchor.x);\n    return angle;\n}\n\n/**\n * Get the rotation pivot point using FaceIQ's logic\n * \n * @param landmarks - Raw landmarks array\n * @param direction - Face direction\n * @returns Pivot point coordinates\n */\nexport function getFaceIQPivot(\n    landmarks: Array<{ x: number; y: number }>,\n    direction: 'left' | 'right'\n): Point2D {\n    // FaceIQ: pivot = (direction === \"right\") ? landmarks[10] : landmarks[26]\n    const pivotLandmark = direction === 'right' ? landmarks[10] : landmarks[26];\n\n    if (!pivotLandmark) {\n        return { x: 0.5, y: 0.5 };\n    }\n\n    return { x: pivotLandmark.x, y: pivotLandmark.y };\n}\n\n/**\n * Rotate a point around a pivot using FaceIQ's formula\n * \n * FaceIQ's rotation function:\n * ```\n * let j = e => {\n *   let t = Math.sin(-g), i = Math.cos(-g), a = e.x - f, s = e.y - b;\n *   return { x: f + a * i - s * t, y: b + a * t + s * i };\n * };\n * ```\n */\nexport function rotatePointFaceIQ(\n    point: Point2D,\n    pivot: Point2D,\n    angleRad: number\n): Point2D {\n    // FaceIQ rotates by NEGATIVE angle\n    const negAngle = -angleRad;\n    const sin = Math.sin(negAngle);\n    const cos = Math.cos(negAngle);\n\n    const dx = point.x - pivot.x;\n    const dy = point.y - pivot.y;\n\n    return {\n        x: pivot.x + dx * cos - dy * sin,\n        y: pivot.y + dx * sin + dy * cos,\n    };\n}\n\n/**\n * Calculate crop dimensions using FaceIQ's formula\n * \n * FaceIQ algorithm:\n * - croppedHeight = bboxHeight * 1.12\n * - cropSize = croppedHeight / 0.65\n * - Constrained between 32 and 2 * max(width, height)\n */\nexport function calculateFaceIQCropSize(\n    bboxHeight: number,\n    imageWidth: number,\n    imageHeight: number\n): number {\n    const scaledHeight = bboxHeight * 1.12;\n    const cropSize = scaledHeight / 0.65;\n\n    // FaceIQ constraints\n    const minSize = 32;\n    const maxSize = 2 * Math.max(imageWidth, imageHeight);\n\n    return Math.min(Math.max(minSize, cropSize), maxSize);\n}","numLines":100,"startLine":70,"totalLines":400}}}
{"parentUuid":"55dfd519-37b4-4aaf-ae86-856f9ae4b935","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MNqxvGqdNVQ5JLoLoJgoTU","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the complete side profile measurement calculations:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2568,"cache_read_input_tokens":100446,"cache_creation":{"ephemeral_5m_input_tokens":2568,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWd6zbPALJA98mmsxZCBd","type":"assistant","uuid":"6b88d871-c678-4d74-9e59-8f733c1c282c","timestamp":"2025-12-30T15:25:18.710Z"}
{"parentUuid":"6b88d871-c678-4d74-9e59-8f733c1c282c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MNqxvGqdNVQ5JLoLoJgoTU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013zKY8BbYqYceQpeR57D2Ud","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts","offset":500,"limit":400}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2568,"cache_read_input_tokens":100446,"cache_creation":{"ephemeral_5m_input_tokens":2568,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWd6zbPALJA98mmsxZCBd","type":"assistant","uuid":"65dedf4c-f8d6-4fab-8358-24e66460baf0","timestamp":"2025-12-30T15:25:20.327Z"}
{"parentUuid":"65dedf4c-f8d6-4fab-8358-24e66460baf0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MNqxvGqdNVQ5JLoLoJgoTU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PKRX4XxgkyvGvVdaJMVXdN","name":"Grep","input":{"pattern":"Math\\.atan2|Math\\.acos|Math\\.sqrt|perpendicular","path":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts","output_mode":"content","-n":true,"-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2568,"cache_read_input_tokens":100446,"cache_creation":{"ephemeral_5m_input_tokens":2568,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWd6zbPALJA98mmsxZCBd","type":"assistant","uuid":"b00c2610-1163-4843-bfc6-dfcce64987eb","timestamp":"2025-12-30T15:25:22.157Z"}
{"parentUuid":"b00c2610-1163-4843-bfc6-dfcce64987eb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013zKY8BbYqYceQpeR57D2Ud","type":"tool_result","content":"   500→  const labraleSuperius = getLandmark(landmarks, 'labraleSuperius');\n   501→  const labraleInferius = getLandmark(landmarks, 'labraleInferius');\n   502→  const sublabiale = getLandmark(landmarks, 'sublabiale');\n   503→  const pogonion = getLandmark(landmarks, 'pogonion');\n   504→  const menton = getLandmark(landmarks, 'menton');\n   505→  const tragus = getLandmark(landmarks, 'tragus');\n   506→  const gonionBottom = getLandmark(landmarks, 'gonionBottom');\n   507→  const cervicalPoint = getLandmark(landmarks, 'cervicalPoint');\n   508→  const orbitale = getLandmark(landmarks, 'orbitale');\n   509→  const porion = getLandmark(landmarks, 'porion');\n   510→  const gonionTop = getLandmark(landmarks, 'gonionTop'); // Articulare equivalent for gonial angle\n   511→\n   512→  // GONIAL ANGLE\n   513→  // Uses gonionTop (Articulare) if available, falls back to tragus\n   514→  const ramusTop = gonionTop || tragus;\n   515→  if (ramusTop && gonionBottom && menton) {\n   516→    const angle = calculateAngle(ramusTop, gonionBottom, menton);\n   517→    addMeasurement('gonialAngle', angle);\n   518→  }\n   519→\n   520→  // NASOLABIAL ANGLE\n   521→  if (columella && subnasale && labraleSuperius) {\n   522→    const angle = calculateAngle(columella, subnasale, labraleSuperius);\n   523→    addMeasurement('nasolabialAngle', angle);\n   524→  }\n   525→\n   526→  // NASOFRONTAL ANGLE\n   527→  if (glabella && nasion && rhinion) {\n   528→    const angle = calculateAngle(glabella, nasion, rhinion);\n   529→    addMeasurement('nasofrontalAngle', angle);\n   530→  }\n   531→\n   532→  // MENTOLABIAL ANGLE\n   533→  if (labraleInferius && sublabiale && pogonion) {\n   534→    const angle = calculateAngle(labraleInferius, sublabiale, pogonion);\n   535→    addMeasurement('mentolabialAngle', angle);\n   536→  }\n   537→\n   538→  // E-LINE MEASUREMENTS (Ricketts)\n   539→  // E-line runs from pronasale (nose tip) to soft tissue pogonion (chin)\n   540→  // Sign convention: positive = in front of line, negative = behind\n   541→  // perpendicularDistance returns positive for behind, so we negate\n   542→  if (pronasale && pogonion && labraleSuperius && labraleInferius) {\n   543→    const upperLipDist = perpendicularDistance(labraleSuperius, pronasale, pogonion);\n   544→    const lowerLipDist = perpendicularDistance(labraleInferius, pronasale, pogonion);\n   545→    // Negate to match sign convention (positive = protruding/in front)\n   546→    addMeasurement('eLineUpperLip', -upperLipDist);\n   547→    addMeasurement('eLineLowerLip', -lowerLipDist);\n   548→  }\n   549→\n   550→  // BURSTONE LINE MEASUREMENTS\n   551→  // Burstone line runs from subnasale to soft tissue pogonion\n   552→  // Sign convention: negative = behind line (ideal is -4.7 to -2.3 for upper, -2.8 to -1.2 for lower)\n   553→  if (subnasale && pogonion && labraleSuperius && labraleInferius) {\n   554→    const upperLipBurstone = perpendicularDistance(labraleSuperius, subnasale, pogonion);\n   555→    const lowerLipBurstone = perpendicularDistance(labraleInferius, subnasale, pogonion);\n   556→    // Negate to match sign convention (negative = behind)\n   557→    addMeasurement('burstoneUpperLip', -upperLipBurstone);\n   558→    addMeasurement('burstoneLowerLip', -lowerLipBurstone);\n   559→  }\n   560→\n   561→  // S-LINE MEASUREMENTS (Steiner)\n   562→  // S-line runs from columella (or subnasale) to soft tissue pogonion\n   563→  // Sign convention: positive = in front of line, negative = behind\n   564→  const sLineStart = columella || subnasale;\n   565→  if (sLineStart && pogonion && labraleSuperius && labraleInferius) {\n   566→    const upperLipSLine = perpendicularDistance(labraleSuperius, sLineStart, pogonion);\n   567→    const lowerLipSLine = perpendicularDistance(labraleInferius, sLineStart, pogonion);\n   568→    // Negate to match sign convention (positive = protruding/in front)\n   569→    addMeasurement('sLineUpperLip', -upperLipSLine);\n   570→    addMeasurement('sLineLowerLip', -lowerLipSLine);\n   571→  }\n   572→\n   573→  // HOLDAWAY H-LINE MEASUREMENT\n   574→  // H-line runs from upper lip (labrale superius) to soft tissue pogonion\n   575→  // Measures lower lip distance from this line\n   576→  // Sign convention: positive = in front of line (ideal 0-4mm)\n   577→  if (labraleSuperius && pogonion && labraleInferius) {\n   578→    const lowerLipHLine = perpendicularDistance(labraleInferius, labraleSuperius, pogonion);\n   579→    // Negate to match sign convention (positive = protruding/in front)\n   580→    addMeasurement('holdawayHLine', -lowerLipHLine);\n   581→  }\n   582→\n   583→  // NASOMENTAL ANGLE\n   584→  if (nasion && pronasale && pogonion) {\n   585→    const angle = calculateAngle(nasion, pronasale, pogonion);\n   586→    addMeasurement('nasomentaAngle', angle);\n   587→  }\n   588→\n   589→  // FACIAL CONVEXITY (GLABELLA)\n   590→  if (glabella && subnasale && pogonion) {\n   591→    const angle = calculateAngle(glabella, subnasale, pogonion);\n   592→    addMeasurement('facialConvexityGlabella', angle);\n   593→  }\n   594→\n   595→  // FACIAL CONVEXITY (NASION)\n   596→  if (nasion && subnasale && pogonion) {\n   597→    const angle = calculateAngle(nasion, subnasale, pogonion);\n   598→    addMeasurement('facialConvexityNasion', angle);\n   599→  }\n   600→\n   601→  // TOTAL FACIAL CONVEXITY\n   602→  if (glabella && pronasale && pogonion) {\n   603→    const angle = calculateAngle(glabella, pronasale, pogonion);\n   604→    addMeasurement('totalFacialConvexity', angle);\n   605→  }\n   606→\n   607→  // SUBMENTAL CERVICAL ANGLE\n   608→  if (menton && cervicalPoint && pogonion) {\n   609→    const neckPoint = getLandmark(landmarks, 'neckPoint');\n   610→    if (neckPoint) {\n   611→      const angle = calculateAngle(pogonion, menton, neckPoint);\n   612→      addMeasurement('submentalCervicalAngle', angle);\n   613→    }\n   614→  }\n   615→\n   616→  // NASAL PROJECTION (Goode ratio)\n   617→  if (pronasale && subnasale && nasion) {\n   618→    const projection = distance(pronasale, subnasale);\n   619→    const nasalLength = distance(nasion, pronasale);\n   620→    if (nasalLength > 0) {\n   621→      addMeasurement('nasalProjection', projection / nasalLength);\n   622→    }\n   623→  }\n   624→\n   625→  // NASOFACIAL ANGLE\n   626→  if (nasion && pronasale && pogonion) {\n   627→    // Angle between nose dorsum and facial plane\n   628→    const nasalDorsum = { x: pronasale.x - nasion.x, y: pronasale.y - nasion.y };\n   629→    const facialPlane = { x: pogonion.x - nasion.x, y: pogonion.y - nasion.y };\n   630→\n   631→    const dot = nasalDorsum.x * facialPlane.x + nasalDorsum.y * facialPlane.y;\n   632→    const mag1 = Math.sqrt(nasalDorsum.x ** 2 + nasalDorsum.y ** 2);\n   633→    const mag2 = Math.sqrt(facialPlane.x ** 2 + facialPlane.y ** 2);\n   634→\n   635→    if (mag1 > 0 && mag2 > 0) {\n   636→      const angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);\n   637→      addMeasurement('nasofacialAngle', angle);\n   638→    }\n   639→  }\n   640→\n   641→  // MANDIBULAR PLANE ANGLE (using Frankfort horizontal)\n   642→  if (porion && orbitale && gonionBottom && menton) {\n   643→    // Frankfort horizontal is porion to orbitale\n   644→    // Mandibular plane is gonion to menton\n   645→    const fhAngle = Math.atan2(orbitale.y - porion.y, orbitale.x - porion.x);\n   646→    const mpAngle = Math.atan2(menton.y - gonionBottom.y, menton.x - gonionBottom.x);\n   647→    const angle = Math.abs(fhAngle - mpAngle) * (180 / Math.PI);\n   648→    addMeasurement('mandibularPlaneAngle', angle);\n   649→  }\n   650→\n   651→  // CHIN PROJECTION\n   652→  if (pogonion && subnasale) {\n   653→    // Distance from pogonion to vertical line through subnasale\n   654→    const projection = pogonion.x - subnasale.x;\n   655→    addMeasurement('chinProjection', projection);\n   656→  }\n   657→\n   658→  // Calculate category scores\n   659→  const categoryScores: Record<string, { total: number; count: number }> = {};\n   660→  for (const m of measurements) {\n   661→    if (!categoryScores[m.category]) {\n   662→      categoryScores[m.category] = { total: 0, count: 0 };\n   663→    }\n   664→    categoryScores[m.category].total += m.standardizedScore;\n   665→    categoryScores[m.category].count++;\n   666→  }\n   667→\n   668→  const categoryAvg: Record<string, number> = {};\n   669→  for (const [cat, data] of Object.entries(categoryScores)) {\n   670→    categoryAvg[cat] = data.count > 0 ? data.total / data.count : 0;\n   671→  }\n   672→\n   673→  // Calculate overall score\n   674→  let totalWeight = 0;\n   675→  let weightedSum = 0;\n   676→  for (const m of measurements) {\n   677→    const config = METRIC_CONFIGS[m.metricId];\n   678→    if (config) {\n   679→      weightedSum += m.standardizedScore * config.weight;\n   680→      totalWeight += config.weight;\n   681→    }\n   682→  }\n   683→\n   684→  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;\n   685→\n   686→  return {\n   687→    measurements,\n   688→    overallScore,\n   689→    standardizedScore: overallScore,\n   690→    qualityTier: getQualityTier(overallScore),\n   691→    categoryScores: categoryAvg,\n   692→  };\n   693→}\n   694→\n   695→// ============================================\n   696→// COMPLETE HARMONY ANALYSIS\n   697→// ============================================\n   698→\n   699→/**\n   700→ * Run complete facial harmony analysis.\n   701→ * Now supports ethnicity-specific ideal ranges for more accurate scoring.\n   702→ */\n   703→export function analyzeHarmony(\n   704→  frontLandmarks: LandmarkPoint[],\n   705→  sideLandmarks: LandmarkPoint[],\n   706→  gender: Gender = 'male',\n   707→  ethnicity: Ethnicity = 'other'\n   708→): HarmonyAnalysis {\n   709→  const frontResults = analyzeFrontProfile(frontLandmarks, gender, ethnicity);\n   710→  const sideResults = analyzeSideProfile(sideLandmarks, gender, ethnicity);\n   711→\n   712→  const allMeasurements = [...frontResults.measurements, ...sideResults.measurements];\n   713→\n   714→  // Combined category scores\n   715→  const allCategories: Record<string, { total: number; count: number }> = {};\n   716→  for (const m of allMeasurements) {\n   717→    if (!allCategories[m.category]) {\n   718→      allCategories[m.category] = { total: 0, count: 0 };\n   719→    }\n   720→    allCategories[m.category].total += m.standardizedScore;\n   721→    allCategories[m.category].count++;\n   722→  }\n   723→\n   724→  const categoryScores: Record<string, number> = {};\n   725→  for (const [cat, data] of Object.entries(allCategories)) {\n   726→    categoryScores[cat] = data.count > 0 ? data.total / data.count : 0;\n   727→  }\n   728→\n   729→  // Overall weighted score\n   730→  let totalWeight = 0;\n   731→  let weightedSum = 0;\n   732→  for (const m of allMeasurements) {\n   733→    const config = METRIC_CONFIGS[m.metricId];\n   734→    if (config) {\n   735→      weightedSum += m.standardizedScore * config.weight;\n   736→      totalWeight += config.weight;\n   737→    }\n   738→  }\n   739→\n   740→  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;\n   741→\n   742→  // Identify flaws (below average measurements)\n   743→  const flaws: FlawAssessment[] = allMeasurements\n   744→    .filter((m) => m.severity !== 'optimal' && m.severity !== 'minor')\n   745→    .map((m) => ({\n   746→      category: m.category,\n   747→      metricId: m.metricId,\n   748→      metricName: m.name,\n   749→      severity: m.severity,\n   750→      deviation: `${m.deviation.toFixed(2)} ${m.deviationDirection} ideal`,\n   751→      reasoning: `${m.name} is outside the ideal range`,\n   752→      confidence: m.severity === 'extremely_severe' || m.severity === 'severe'\n   753→        ? 'confirmed' as const\n   754→        : 'likely' as const,\n   755→    }))\n   756→    .sort((a, b) => {\n   757→      const severityOrder = { extremely_severe: 0, severe: 1, major: 2, moderate: 3 };\n   758→      return (severityOrder[a.severity as keyof typeof severityOrder] ?? 4) -\n   759→        (severityOrder[b.severity as keyof typeof severityOrder] ?? 4);\n   760→    });\n   761→\n   762→  // Identify strengths (ideal measurements)\n   763→  const strengths: StrengthAssessment[] = allMeasurements\n   764→    .filter((m) => m.qualityTier === 'ideal' || m.qualityTier === 'excellent')\n   765→    .map((m) => ({\n   766→      category: m.category,\n   767→      metricId: m.metricId,\n   768→      metricName: m.name,\n   769→      qualityTier: m.qualityTier,\n   770→      value: m.value,\n   771→      reasoning: `${m.name} is within the ${m.qualityTier} range`,\n   772→    }));\n   773→\n   774→  // Calculate percentile (based on population stats)\n   775→  const percentile = calculateHarmonyPercentile(overallScore);\n   776→\n   777→  return {\n   778→    overallScore,\n   779→    standardizedScore: overallScore,\n   780→    qualityTier: getQualityTier(overallScore),\n   781→    percentile,\n   782→    frontScore: frontResults.overallScore,\n   783→    sideScore: sideResults.overallScore,\n   784→    categoryScores,\n   785→    measurements: allMeasurements,\n   786→    flaws,\n   787→    strengths,\n   788→  };\n   789→}\n   790→\n\n</system-reminder>\n"}]},"uuid":"c680195c-b51e-4d0d-81cc-162157b86c4a","timestamp":"2025-12-30T15:25:22.263Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts","content":"  const labraleSuperius = getLandmark(landmarks, 'labraleSuperius');\n  const labraleInferius = getLandmark(landmarks, 'labraleInferius');\n  const sublabiale = getLandmark(landmarks, 'sublabiale');\n  const pogonion = getLandmark(landmarks, 'pogonion');\n  const menton = getLandmark(landmarks, 'menton');\n  const tragus = getLandmark(landmarks, 'tragus');\n  const gonionBottom = getLandmark(landmarks, 'gonionBottom');\n  const cervicalPoint = getLandmark(landmarks, 'cervicalPoint');\n  const orbitale = getLandmark(landmarks, 'orbitale');\n  const porion = getLandmark(landmarks, 'porion');\n  const gonionTop = getLandmark(landmarks, 'gonionTop'); // Articulare equivalent for gonial angle\n\n  // GONIAL ANGLE\n  // Uses gonionTop (Articulare) if available, falls back to tragus\n  const ramusTop = gonionTop || tragus;\n  if (ramusTop && gonionBottom && menton) {\n    const angle = calculateAngle(ramusTop, gonionBottom, menton);\n    addMeasurement('gonialAngle', angle);\n  }\n\n  // NASOLABIAL ANGLE\n  if (columella && subnasale && labraleSuperius) {\n    const angle = calculateAngle(columella, subnasale, labraleSuperius);\n    addMeasurement('nasolabialAngle', angle);\n  }\n\n  // NASOFRONTAL ANGLE\n  if (glabella && nasion && rhinion) {\n    const angle = calculateAngle(glabella, nasion, rhinion);\n    addMeasurement('nasofrontalAngle', angle);\n  }\n\n  // MENTOLABIAL ANGLE\n  if (labraleInferius && sublabiale && pogonion) {\n    const angle = calculateAngle(labraleInferius, sublabiale, pogonion);\n    addMeasurement('mentolabialAngle', angle);\n  }\n\n  // E-LINE MEASUREMENTS (Ricketts)\n  // E-line runs from pronasale (nose tip) to soft tissue pogonion (chin)\n  // Sign convention: positive = in front of line, negative = behind\n  // perpendicularDistance returns positive for behind, so we negate\n  if (pronasale && pogonion && labraleSuperius && labraleInferius) {\n    const upperLipDist = perpendicularDistance(labraleSuperius, pronasale, pogonion);\n    const lowerLipDist = perpendicularDistance(labraleInferius, pronasale, pogonion);\n    // Negate to match sign convention (positive = protruding/in front)\n    addMeasurement('eLineUpperLip', -upperLipDist);\n    addMeasurement('eLineLowerLip', -lowerLipDist);\n  }\n\n  // BURSTONE LINE MEASUREMENTS\n  // Burstone line runs from subnasale to soft tissue pogonion\n  // Sign convention: negative = behind line (ideal is -4.7 to -2.3 for upper, -2.8 to -1.2 for lower)\n  if (subnasale && pogonion && labraleSuperius && labraleInferius) {\n    const upperLipBurstone = perpendicularDistance(labraleSuperius, subnasale, pogonion);\n    const lowerLipBurstone = perpendicularDistance(labraleInferius, subnasale, pogonion);\n    // Negate to match sign convention (negative = behind)\n    addMeasurement('burstoneUpperLip', -upperLipBurstone);\n    addMeasurement('burstoneLowerLip', -lowerLipBurstone);\n  }\n\n  // S-LINE MEASUREMENTS (Steiner)\n  // S-line runs from columella (or subnasale) to soft tissue pogonion\n  // Sign convention: positive = in front of line, negative = behind\n  const sLineStart = columella || subnasale;\n  if (sLineStart && pogonion && labraleSuperius && labraleInferius) {\n    const upperLipSLine = perpendicularDistance(labraleSuperius, sLineStart, pogonion);\n    const lowerLipSLine = perpendicularDistance(labraleInferius, sLineStart, pogonion);\n    // Negate to match sign convention (positive = protruding/in front)\n    addMeasurement('sLineUpperLip', -upperLipSLine);\n    addMeasurement('sLineLowerLip', -lowerLipSLine);\n  }\n\n  // HOLDAWAY H-LINE MEASUREMENT\n  // H-line runs from upper lip (labrale superius) to soft tissue pogonion\n  // Measures lower lip distance from this line\n  // Sign convention: positive = in front of line (ideal 0-4mm)\n  if (labraleSuperius && pogonion && labraleInferius) {\n    const lowerLipHLine = perpendicularDistance(labraleInferius, labraleSuperius, pogonion);\n    // Negate to match sign convention (positive = protruding/in front)\n    addMeasurement('holdawayHLine', -lowerLipHLine);\n  }\n\n  // NASOMENTAL ANGLE\n  if (nasion && pronasale && pogonion) {\n    const angle = calculateAngle(nasion, pronasale, pogonion);\n    addMeasurement('nasomentaAngle', angle);\n  }\n\n  // FACIAL CONVEXITY (GLABELLA)\n  if (glabella && subnasale && pogonion) {\n    const angle = calculateAngle(glabella, subnasale, pogonion);\n    addMeasurement('facialConvexityGlabella', angle);\n  }\n\n  // FACIAL CONVEXITY (NASION)\n  if (nasion && subnasale && pogonion) {\n    const angle = calculateAngle(nasion, subnasale, pogonion);\n    addMeasurement('facialConvexityNasion', angle);\n  }\n\n  // TOTAL FACIAL CONVEXITY\n  if (glabella && pronasale && pogonion) {\n    const angle = calculateAngle(glabella, pronasale, pogonion);\n    addMeasurement('totalFacialConvexity', angle);\n  }\n\n  // SUBMENTAL CERVICAL ANGLE\n  if (menton && cervicalPoint && pogonion) {\n    const neckPoint = getLandmark(landmarks, 'neckPoint');\n    if (neckPoint) {\n      const angle = calculateAngle(pogonion, menton, neckPoint);\n      addMeasurement('submentalCervicalAngle', angle);\n    }\n  }\n\n  // NASAL PROJECTION (Goode ratio)\n  if (pronasale && subnasale && nasion) {\n    const projection = distance(pronasale, subnasale);\n    const nasalLength = distance(nasion, pronasale);\n    if (nasalLength > 0) {\n      addMeasurement('nasalProjection', projection / nasalLength);\n    }\n  }\n\n  // NASOFACIAL ANGLE\n  if (nasion && pronasale && pogonion) {\n    // Angle between nose dorsum and facial plane\n    const nasalDorsum = { x: pronasale.x - nasion.x, y: pronasale.y - nasion.y };\n    const facialPlane = { x: pogonion.x - nasion.x, y: pogonion.y - nasion.y };\n\n    const dot = nasalDorsum.x * facialPlane.x + nasalDorsum.y * facialPlane.y;\n    const mag1 = Math.sqrt(nasalDorsum.x ** 2 + nasalDorsum.y ** 2);\n    const mag2 = Math.sqrt(facialPlane.x ** 2 + facialPlane.y ** 2);\n\n    if (mag1 > 0 && mag2 > 0) {\n      const angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);\n      addMeasurement('nasofacialAngle', angle);\n    }\n  }\n\n  // MANDIBULAR PLANE ANGLE (using Frankfort horizontal)\n  if (porion && orbitale && gonionBottom && menton) {\n    // Frankfort horizontal is porion to orbitale\n    // Mandibular plane is gonion to menton\n    const fhAngle = Math.atan2(orbitale.y - porion.y, orbitale.x - porion.x);\n    const mpAngle = Math.atan2(menton.y - gonionBottom.y, menton.x - gonionBottom.x);\n    const angle = Math.abs(fhAngle - mpAngle) * (180 / Math.PI);\n    addMeasurement('mandibularPlaneAngle', angle);\n  }\n\n  // CHIN PROJECTION\n  if (pogonion && subnasale) {\n    // Distance from pogonion to vertical line through subnasale\n    const projection = pogonion.x - subnasale.x;\n    addMeasurement('chinProjection', projection);\n  }\n\n  // Calculate category scores\n  const categoryScores: Record<string, { total: number; count: number }> = {};\n  for (const m of measurements) {\n    if (!categoryScores[m.category]) {\n      categoryScores[m.category] = { total: 0, count: 0 };\n    }\n    categoryScores[m.category].total += m.standardizedScore;\n    categoryScores[m.category].count++;\n  }\n\n  const categoryAvg: Record<string, number> = {};\n  for (const [cat, data] of Object.entries(categoryScores)) {\n    categoryAvg[cat] = data.count > 0 ? data.total / data.count : 0;\n  }\n\n  // Calculate overall score\n  let totalWeight = 0;\n  let weightedSum = 0;\n  for (const m of measurements) {\n    const config = METRIC_CONFIGS[m.metricId];\n    if (config) {\n      weightedSum += m.standardizedScore * config.weight;\n      totalWeight += config.weight;\n    }\n  }\n\n  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;\n\n  return {\n    measurements,\n    overallScore,\n    standardizedScore: overallScore,\n    qualityTier: getQualityTier(overallScore),\n    categoryScores: categoryAvg,\n  };\n}\n\n// ============================================\n// COMPLETE HARMONY ANALYSIS\n// ============================================\n\n/**\n * Run complete facial harmony analysis.\n * Now supports ethnicity-specific ideal ranges for more accurate scoring.\n */\nexport function analyzeHarmony(\n  frontLandmarks: LandmarkPoint[],\n  sideLandmarks: LandmarkPoint[],\n  gender: Gender = 'male',\n  ethnicity: Ethnicity = 'other'\n): HarmonyAnalysis {\n  const frontResults = analyzeFrontProfile(frontLandmarks, gender, ethnicity);\n  const sideResults = analyzeSideProfile(sideLandmarks, gender, ethnicity);\n\n  const allMeasurements = [...frontResults.measurements, ...sideResults.measurements];\n\n  // Combined category scores\n  const allCategories: Record<string, { total: number; count: number }> = {};\n  for (const m of allMeasurements) {\n    if (!allCategories[m.category]) {\n      allCategories[m.category] = { total: 0, count: 0 };\n    }\n    allCategories[m.category].total += m.standardizedScore;\n    allCategories[m.category].count++;\n  }\n\n  const categoryScores: Record<string, number> = {};\n  for (const [cat, data] of Object.entries(allCategories)) {\n    categoryScores[cat] = data.count > 0 ? data.total / data.count : 0;\n  }\n\n  // Overall weighted score\n  let totalWeight = 0;\n  let weightedSum = 0;\n  for (const m of allMeasurements) {\n    const config = METRIC_CONFIGS[m.metricId];\n    if (config) {\n      weightedSum += m.standardizedScore * config.weight;\n      totalWeight += config.weight;\n    }\n  }\n\n  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;\n\n  // Identify flaws (below average measurements)\n  const flaws: FlawAssessment[] = allMeasurements\n    .filter((m) => m.severity !== 'optimal' && m.severity !== 'minor')\n    .map((m) => ({\n      category: m.category,\n      metricId: m.metricId,\n      metricName: m.name,\n      severity: m.severity,\n      deviation: `${m.deviation.toFixed(2)} ${m.deviationDirection} ideal`,\n      reasoning: `${m.name} is outside the ideal range`,\n      confidence: m.severity === 'extremely_severe' || m.severity === 'severe'\n        ? 'confirmed' as const\n        : 'likely' as const,\n    }))\n    .sort((a, b) => {\n      const severityOrder = { extremely_severe: 0, severe: 1, major: 2, moderate: 3 };\n      return (severityOrder[a.severity as keyof typeof severityOrder] ?? 4) -\n        (severityOrder[b.severity as keyof typeof severityOrder] ?? 4);\n    });\n\n  // Identify strengths (ideal measurements)\n  const strengths: StrengthAssessment[] = allMeasurements\n    .filter((m) => m.qualityTier === 'ideal' || m.qualityTier === 'excellent')\n    .map((m) => ({\n      category: m.category,\n      metricId: m.metricId,\n      metricName: m.name,\n      qualityTier: m.qualityTier,\n      value: m.value,\n      reasoning: `${m.name} is within the ${m.qualityTier} range`,\n    }));\n\n  // Calculate percentile (based on population stats)\n  const percentile = calculateHarmonyPercentile(overallScore);\n\n  return {\n    overallScore,\n    standardizedScore: overallScore,\n    qualityTier: getQualityTier(overallScore),\n    percentile,\n    frontScore: frontResults.overallScore,\n    sideScore: sideResults.overallScore,\n    categoryScores,\n    measurements: allMeasurements,\n    flaws,\n    strengths,\n  };\n}\n","numLines":291,"startLine":500,"totalLines":790}}}
{"parentUuid":"c680195c-b51e-4d0d-81cc-162157b86c4a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PKRX4XxgkyvGvVdaJMVXdN","type":"tool_result","content":"28-  getSeverityLevel,\n29-  distance,\n30-  calculateAngle,\n31:  perpendicularDistance,\n32-  standardizeScore,\n33-  calculateHarmonyPercentile,\n34-  getDeviationDescription,\n--\n207-  if (leftCanthusM && leftCanthusL) {\n208-    const deltaY = leftCanthusM.y - leftCanthusL.y;  // positive if lateral is higher\n209-    const deltaX = Math.abs(leftCanthusM.x - leftCanthusL.x);  // eye width (always positive)\n210:    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n211-    addMeasurement('lateralCanthalTilt', angle);\n212-  }\n213-\n--\n341-  const rightMalar = getLandmark(landmarks, 'right_malar');\n342-\n343-  if (leftZygion && rightZygion && leftGonion && rightGonion && leftMalar && rightMalar) {\n344:    // Helper: Calculate signed perpendicular distance from point to line\n345-    const pointLineDistance = (p: Point, a: Point, b: Point): number => {\n346-      / Cross product: (bx - ax)(py - ay) - (by - ay)(px - ax)\n347-      const cross = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n348:      const lineLength = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n349-      return cross / lineLength;\n350-    };\n351-\n--\n538-  // E-LINE MEASUREMENTS (Ricketts)\n539-  // E-line runs from pronasale (nose tip) to soft tissue pogonion (chin)\n540-  / Sign convention: positive = in front of line, negative = behind\n541:  // perpendicularDistance returns positive for behind, so we negate\n542-  if (pronasale && pogonion && labraleSuperius && labraleInferius) {\n543:    const upperLipDist = perpendicularDistance(labraleSuperius, pronasale, pogonion);\n544:    const lowerLipDist = perpendicularDistance(labraleInferius, pronasale, pogonion);\n545-    // Negate to match sign convention (positive = protruding/in front)\n546-    addMeasurement('eLineUpperLip', -upperLipDist);\n547-    addMeasurement('eLineLowerLip', -lowerLipDist);\n--\n551-  // Burstone line runs from subnasale to soft tissue pogonion\n552-  / Sign convention: negative = behind line (ideal is -4.7 to -2.3 for upper, -2.8 to -1.2 for lower)\n553-  if (subnasale && pogonion && labraleSuperius && labraleInferius) {\n554:    const upperLipBurstone = perpendicularDistance(labraleSuperius, subnasale, pogonion);\n555:    const lowerLipBurstone = perpendicularDistance(labraleInferius, subnasale, pogonion);\n556-    // Negate to match sign convention (negative = behind)\n557-    addMeasurement('burstoneUpperLip', -upperLipBurstone);\n558-    addMeasurement('burstoneLowerLip', -lowerLipBurstone);\n--\n563-  / Sign convention: positive = in front of line, negative = behind\n564-  const sLineStart = columella || subnasale;\n565-  if (sLineStart && pogonion && labraleSuperius && labraleInferius) {\n566:    const upperLipSLine = perpendicularDistance(labraleSuperius, sLineStart, pogonion);\n567:    const lowerLipSLine = perpendicularDistance(labraleInferius, sLineStart, pogonion);\n568-    // Negate to match sign convention (positive = protruding/in front)\n569-    addMeasurement('sLineUpperLip', -upperLipSLine);\n570-    addMeasurement('sLineLowerLip', -lowerLipSLine);\n--\n575-  // Measures lower lip distance from this line\n576-  / Sign convention: positive = in front of line (ideal 0-4mm)\n577-  if (labraleSuperius && pogonion && labraleInferius) {\n578:    const lowerLipHLine = perpendicularDistance(labraleInferius, labraleSuperius, pogonion);\n579-    // Negate to match sign convention (positive = protruding/in front)\n580-    addMeasurement('holdawayHLine', -lowerLipHLine);\n581-  }\n--\n629-    const facialPlane = { x: pogonion.x - nasion.x, y: pogonion.y - nasion.y };\n630-\n631-    const dot = nasalDorsum.x * facialPlane.x + nasalDorsum.y * facialPlane.y;\n632:    const mag1 = Math.sqrt(nasalDorsum.x ** 2 + nasalDorsum.y ** 2);\n633:    const mag2 = Math.sqrt(facialPlane.x ** 2 + facialPlane.y ** 2);\n634-\n635-    if (mag1 > 0 && mag2 > 0) {\n636:      const angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);\n637-      addMeasurement('nasofacialAngle', angle);\n638-    }\n639-  }\n--\n642-  if (porion && orbitale && gonionBottom && menton) {\n643-    // Frankfort horizontal is porion to orbitale\n644-    // Mandibular plane is gonion to menton\n645:    const fhAngle = Math.atan2(orbitale.y - porion.y, orbitale.x - porion.x);\n646:    const mpAngle = Math.atan2(menton.y - gonionBottom.y, menton.x - gonionBottom.x);\n647-    const angle = Math.abs(fhAngle - mpAngle) * (180 / Math.PI);\n648-    addMeasurement('mandibularPlaneAngle', angle);\n649-  }"}]},"uuid":"bd3be0da-b9bb-4d39-ac2a-555c3daeaf09","timestamp":"2025-12-30T15:25:22.285Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"28-  getSeverityLevel,\n29-  distance,\n30-  calculateAngle,\n31:  perpendicularDistance,\n32-  standardizeScore,\n33-  calculateHarmonyPercentile,\n34-  getDeviationDescription,\n--\n207-  if (leftCanthusM && leftCanthusL) {\n208-    const deltaY = leftCanthusM.y - leftCanthusL.y;  // positive if lateral is higher\n209-    const deltaX = Math.abs(leftCanthusM.x - leftCanthusL.x);  // eye width (always positive)\n210:    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n211-    addMeasurement('lateralCanthalTilt', angle);\n212-  }\n213-\n--\n341-  const rightMalar = getLandmark(landmarks, 'right_malar');\n342-\n343-  if (leftZygion && rightZygion && leftGonion && rightGonion && leftMalar && rightMalar) {\n344:    // Helper: Calculate signed perpendicular distance from point to line\n345-    const pointLineDistance = (p: Point, a: Point, b: Point): number => {\n346-      / Cross product: (bx - ax)(py - ay) - (by - ay)(px - ax)\n347-      const cross = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n348:      const lineLength = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n349-      return cross / lineLength;\n350-    };\n351-\n--\n538-  // E-LINE MEASUREMENTS (Ricketts)\n539-  // E-line runs from pronasale (nose tip) to soft tissue pogonion (chin)\n540-  / Sign convention: positive = in front of line, negative = behind\n541:  // perpendicularDistance returns positive for behind, so we negate\n542-  if (pronasale && pogonion && labraleSuperius && labraleInferius) {\n543:    const upperLipDist = perpendicularDistance(labraleSuperius, pronasale, pogonion);\n544:    const lowerLipDist = perpendicularDistance(labraleInferius, pronasale, pogonion);\n545-    // Negate to match sign convention (positive = protruding/in front)\n546-    addMeasurement('eLineUpperLip', -upperLipDist);\n547-    addMeasurement('eLineLowerLip', -lowerLipDist);\n--\n551-  // Burstone line runs from subnasale to soft tissue pogonion\n552-  / Sign convention: negative = behind line (ideal is -4.7 to -2.3 for upper, -2.8 to -1.2 for lower)\n553-  if (subnasale && pogonion && labraleSuperius && labraleInferius) {\n554:    const upperLipBurstone = perpendicularDistance(labraleSuperius, subnasale, pogonion);\n555:    const lowerLipBurstone = perpendicularDistance(labraleInferius, subnasale, pogonion);\n556-    // Negate to match sign convention (negative = behind)\n557-    addMeasurement('burstoneUpperLip', -upperLipBurstone);\n558-    addMeasurement('burstoneLowerLip', -lowerLipBurstone);\n--\n563-  / Sign convention: positive = in front of line, negative = behind\n564-  const sLineStart = columella || subnasale;\n565-  if (sLineStart && pogonion && labraleSuperius && labraleInferius) {\n566:    const upperLipSLine = perpendicularDistance(labraleSuperius, sLineStart, pogonion);\n567:    const lowerLipSLine = perpendicularDistance(labraleInferius, sLineStart, pogonion);\n568-    // Negate to match sign convention (positive = protruding/in front)\n569-    addMeasurement('sLineUpperLip', -upperLipSLine);\n570-    addMeasurement('sLineLowerLip', -lowerLipSLine);\n--\n575-  // Measures lower lip distance from this line\n576-  / Sign convention: positive = in front of line (ideal 0-4mm)\n577-  if (labraleSuperius && pogonion && labraleInferius) {\n578:    const lowerLipHLine = perpendicularDistance(labraleInferius, labraleSuperius, pogonion);\n579-    // Negate to match sign convention (positive = protruding/in front)\n580-    addMeasurement('holdawayHLine', -lowerLipHLine);\n581-  }\n--\n629-    const facialPlane = { x: pogonion.x - nasion.x, y: pogonion.y - nasion.y };\n630-\n631-    const dot = nasalDorsum.x * facialPlane.x + nasalDorsum.y * facialPlane.y;\n632:    const mag1 = Math.sqrt(nasalDorsum.x ** 2 + nasalDorsum.y ** 2);\n633:    const mag2 = Math.sqrt(facialPlane.x ** 2 + facialPlane.y ** 2);\n634-\n635-    if (mag1 > 0 && mag2 > 0) {\n636:      const angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);\n637-      addMeasurement('nasofacialAngle', angle);\n638-    }\n639-  }\n--\n642-  if (porion && orbitale && gonionBottom && menton) {\n643-    // Frankfort horizontal is porion to orbitale\n644-    // Mandibular plane is gonion to menton\n645:    const fhAngle = Math.atan2(orbitale.y - porion.y, orbitale.x - porion.x);\n646:    const mpAngle = Math.atan2(menton.y - gonionBottom.y, menton.x - gonionBottom.x);\n647-    const angle = Math.abs(fhAngle - mpAngle) * (180 / Math.PI);\n648-    addMeasurement('mandibularPlaneAngle', angle);\n649-  }","numLines":85}}
{"parentUuid":"bd3be0da-b9bb-4d39-ac2a-555c3daeaf09","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"988cde7a-9586-4ca8-910d-50a828b2fa2d","version":"2.0.76","gitBranch":"main","agentId":"a2f80b0","slug":"fizzy-singing-bird","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015gW4aP7TdETRvX7fhhLrPh","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me create a comprehensive comparison document analyzing the mathematical calculations:\n\n## LOOKSMAXX vs FACEIQPAID: Mathematical Calculation Comparison\n\nBased on my analysis of the LOOKSMAXX codebase, here is a detailed comparison of metric calculation mathematics:\n\n---\n\n### 1. ANGLE CALCULATIONS\n\n#### **Gonial Angle (Jaw Angle)**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts:512-518`\n- **Method**: Law of Cosines via `calculateAngle()` helper\n- **Formula**:\n```typescript\n// calculateAngle(p1: Point, vertex: Point, p2: Point)\nconst v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };\nconst v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };\nconst dot = v1.x * v2.x + v1.y * v2.y;\nconst cross = v1.x * v2.y - v1.y * v2.x;\nconst angle = Math.atan2(cross, dot) * (180 / Math.PI);\nreturn Math.abs(angle);\n```\n- **Landmarks**: `gonionTop`, `gonionBottom`, `menton`\n- **Precision**: Uses `Math.atan2(cross, dot)` which handles all quadrants correctly\n- **Potential Issues**: None - robust implementation\n\n#### **Canthal Tilt (Eye Angle)**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts:207-212`\n- **Method**: Arc tangent of slope\n- **Formula**:\n```typescript\nconst deltaY = leftCanthusM.y - leftCanthusL.y;  // positive if lateral is higher\nconst deltaX = Math.abs(leftCanthusM.x - leftCanthusL.x);  // eye width\nconst angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n```\n- **Sign Convention**: Positive = lateral canthus higher (upward tilt)\n- **Precision**: Correct - uses `Math.abs()` on deltaX to ensure positive eye width\n- **Potential Issues**: None\n\n#### **Nasolabial Angle**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts:520-524`\n- **Method**: Same `calculateAngle()` function\n- **Landmarks**: `columella`, `subnasale`, `labraleSuperius`\n- **Precision**: Standard 3-point angle calculation\n- **Potential Issues**: None\n\n#### **Mandibular Plane Angle**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts:641-649`\n- **Method**: Angle difference between two lines (Frankfort Horizontal vs Mandibular Plane)\n- **Formula**:\n```typescript\nconst fhAngle = Math.atan2(orbitale.y - porion.y, orbitale.x - porion.x);\nconst mpAngle = Math.atan2(menton.y - gonionBottom.y, menton.x - gonionBottom.x);\nconst angle = Math.abs(fhAngle - mpAngle) * (180 / Math.PI);\n```\n- **Precision**: Correct - calculates slope angles, then takes absolute difference\n- **Potential Issues**: None\n\n---\n\n### 2. DISTANCE CALCULATIONS\n\n#### **Euclidean Distance Formula**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/calculator.ts:551-553`\n- **Formula**:\n```typescript\nexport function distance(p1: Point, p2: Point): number {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\n```\n- **Precision**: Standard Euclidean distance - correct\n- **Potential Issues**: None\n\n#### **Perpendicular Distance (Point to Line)**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/calculator.ts:572-612`\n- **Method**: Projection + cross product for signed distance\n- **Formula**:\n```typescript\nconst A = point.x - lineStart.x;\nconst B = point.y - lineStart.y;\nconst C = lineEnd.x - lineStart.x;\nconst D = lineEnd.y - lineStart.y;\n\nconst dot = A * C + B * D;\nconst lenSq = C * C + D * D;\nconst param = lenSq !== 0 ? dot / lenSq : -1;\n\n// Find closest point on line\nlet xx, yy;\nif (param < 0) {\n  xx = lineStart.x; yy = lineStart.y;\n} else if (param > 1) {\n  xx = lineEnd.x; yy = lineEnd.y;\n} else {\n  xx = lineStart.x + param * C;\n  yy = lineStart.y + param * D;\n}\n\n// Calculate distance with sign\nconst dx = point.x - xx;\nconst dy = point.y - yy;\nconst sign = (lineEnd.y - lineStart.y) * point.x -\n  (lineEnd.x - lineStart.x) * point.y +\n  lineEnd.x * lineStart.y -\n  lineEnd.y * lineStart.x >= 0 ? 1 : -1;\n\nreturn sign * Math.sqrt(dx * dx + dy * dy);\n```\n- **Sign Convention**: Used for E-line, Burstone, S-line, H-line measurements\n- **Precision**: Correct - handles edge cases (param < 0, param > 1)\n- **Potential Issues**: None - robust implementation\n\n---\n\n### 3. RATIO CALCULATIONS\n\n#### **Face Width to Height Ratio (FWHR)**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts:174-182`\n- **Formula**:\n```typescript\nconst bizygomaticWidth = distance(leftZygion, rightZygion);\nconst upperFaceHeight = distance(nasion, labraleSuperius);\nif (upperFaceHeight > 0) {\n  addMeasurement('faceWidthToHeight', bizygomaticWidth / upperFaceHeight);\n}\n```\n- **Landmarks**: `leftZygion`, `rightZygion`, `nasion`, `labraleSuperius`\n- **Division by Zero**: Protected with `if (upperFaceHeight > 0)`\n- **Potential Issues**: None\n\n#### **Nasal Index**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts:256-263`\n- **Formula**:\n```typescript\nconst nasalWidth = distance(leftAlaNasi, rightAlaNasi);\nconst nasalHeight = distance(nasalBase, subnasale);\nif (nasalHeight > 0) {\n  addMeasurement('nasalIndex', (nasalWidth / nasalHeight) * 100);\n}\n```\n- **Division by Zero**: Protected\n- **Potential Issues**: None\n\n#### **Eye Aspect Ratio**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts:214-226`\n- **Formula**:\n```typescript\nconst eyeWidth = distance(leftCanthusM, leftCanthusL);\nconst eyeHeight = distance(leftPalpSup, leftPalpInf);\nif (eyeHeight > 0) {\n  addMeasurement('eyeAspectRatio', eyeWidth / eyeHeight);\n}\n```\n- **Division by Zero**: Protected\n- **Potential Issues**: None\n\n---\n\n### 4. MATHEMATICAL PRECISION\n\n#### **Floating Point Handling**\n- **Rounding**: No explicit rounding during calculations (preserves precision)\n- **Final Display**: Rounding only at display layer via `.toFixed(2)` for UI\n- **Clamping**: Score clamping to [0, 10] in `standardizeScore()`:\n```typescript\nexport function standardizeScore(score: number, maxScore: number): number {\n  const normalized = (score / maxScore) * 10;\n  return Math.max(0, Math.min(10, normalized));\n}\n```\n\n#### **Coordinate Accuracy**\n- **Front Profile**: MediaPipe provides normalized coordinates (0-1) with sub-pixel accuracy\n- **Side Profile**: InsightFace provides pixel coordinates, normalized after FaceIQ rotation\n- **Landmark Offsets**: Cephalometric offsets applied for 12 front landmarks:\n```typescript\nconst LANDMARK_OFFSETS: Record<string, { xOffset?: number; yOffset?: number }> = {\n  trichion: { yOffset: -0.06 },\n  left_pupila: { xOffset: 0.0015, yOffset: -0.005 },\n  right_pupila: { xOffset: -0.0015, yOffset: -0.005 },\n  left_ala_nasi: { xOffset: 0.0025 },\n  right_ala_nasi: { xOffset: -0.0025 },\n  // ... etc\n};\n```\n\n#### **Degree vs Radian Handling**\n- **Internal Calculations**: Radians (via `Math.atan2()`, `Math.acos()`)\n- **Final Conversion**: Always `* (180 / Math.PI)` before storage\n- **Consistency**: All angles stored in degrees for user-facing metrics\n\n---\n\n### 5. ADVANCED CALCULATIONS\n\n#### **Nasofacial Angle (Law of Cosines)**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts:625-639`\n- **Method**: Dot product + arc cosine\n- **Formula**:\n```typescript\nconst nasalDorsum = { x: pronasale.x - nasion.x, y: pronasale.y - nasion.y };\nconst facialPlane = { x: pogonion.x - nasion.x, y: pogonion.y - nasion.y };\n\nconst dot = nasalDorsum.x * facialPlane.x + nasalDorsum.y * facialPlane.y;\nconst mag1 = Math.sqrt(nasalDorsum.x ** 2 + nasalDorsum.y ** 2);\nconst mag2 = Math.sqrt(facialPlane.x ** 2 + facialPlane.y ** 2);\n\nif (mag1 > 0 && mag2 > 0) {\n  const angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);\n  addMeasurement('nasofacialAngle', angle);\n}\n```\n- **Division by Zero**: Protected with `if (mag1 > 0 && mag2 > 0)`\n- **Domain Error Protection**: `Math.acos()` requires input in [-1, 1] - potential issue if dot/(mag1*mag2) exceeds this range due to floating point errors\n- **Recommendation**: Add clamping:\n```typescript\nconst cosAngle = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));\nconst angle = Math.acos(cosAngle) * (180 / Math.PI);\n```\n\n#### **FaceIQ Rotation (Side Profile Normalization)**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sideProfileNormalization.ts:76-169`\n- **Method**: Rotation matrix with negative angle (FaceIQ parity)\n- **Formula**:\n```typescript\n// Calculate rotation angle using anchor landmarks\nconst anchor = direction === 'left' ? landmarks[75] : landmarks[10];\nconst reference = landmarks[26];\nconst angle = Math.atan2(reference.y - anchor.y, reference.x - anchor.x);\n\n// Rotate point using NEGATIVE angle (FaceIQ convention)\nconst negAngle = -angleRad;\nconst sin = Math.sin(negAngle);\nconst cos = Math.cos(negAngle);\nconst dx = point.x - pivot.x;\nconst dy = point.y - pivot.y;\n\nreturn {\n  x: pivot.x + dx * cos - dy * sin,\n  y: pivot.y + dx * sin + dy * cos,\n};\n```\n- **Precision**: Standard 2D rotation matrix - correct\n- **Potential Issues**: None\n\n---\n\n### 6. SCORING ALGORITHM COMPARISON\n\n#### **LOOKSMAXX Scoring**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/calculator.ts:187-293`\n- **Method**: Exponential decay with Bezier curve fallback\n- **Formula**:\n```typescript\nif (value >= idealMin && value <= idealMax) {\n  return maxScore;\n}\n\n// Check for custom Bezier curve\nif (customCurve) {\n  return interpolateCustomCurve(value, customCurve.points, maxScore);\n}\n\n// Exponential decay\nconst deviation = value < idealMin ? idealMin - value : value - idealMax;\nconst score = maxScore * Math.exp(-decayRate * deviation);\nreturn Math.max(0, Math.min(maxScore, score));\n```\n\n#### **FaceIQ Scoring (Parity Implementation)**\n- **File**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/scoring.ts:74-120`\n- **Method**: Identical exponential decay formula\n- **Formula**:\n```typescript\nif (value >= idealMin && value <= idealMax) return maxScore;\n\nconst deviation = value < idealMin ? idealMin - value : value - idealMax;\nconst score = baseScore + (maxScore - baseScore) * Math.exp(-decayRate * deviation);\nreturn Math.max(0, Math.min(maxScore, score));\n```\n\n**Difference**: FaceIQ includes `baseScore` parameter (usually 0), LOOKSMAXX assumes baseScore=0\n\n---\n\n### 7. IDENTIFIED MATHEMATICAL ERRORS\n\n#### **1. Nasofacial Angle - Potential Domain Error**\n- **Location**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts:636`\n- **Issue**: `Math.acos(dot / (mag1 * mag2))` can fail if argument exceeds [-1, 1] due to floating point errors\n- **Fix**: Clamp input to valid domain:\n```typescript\nconst cosAngle = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));\nconst angle = Math.acos(cosAngle) * (180 / Math.PI);\n```\n- **Impact**: LOW - rare edge case, but could cause NaN propagation\n\n#### **2. Bezier Curve Edge Case Handling**\n- **Location**: `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/calculator.ts:351-426`\n- **Issue**: When value is outside curve range and edge y=0, returns -1 as signal for exponential fallback. This is intentional but complex logic.\n- **Recommendation**: Document this behavior more clearly in comments\n- **Impact**: NONE - working as designed\n\n---\n\n### 8. MATHEMATICAL IMPROVEMENTS OVER FACEIQ\n\n#### **1. Bezier Curve Interpolation**\n- **LOOKSMAXX**: 67 custom Bezier curves with cubic interpolation\n- **FaceIQ**: Linear interpolation between points\n- **Advantage**: Smoother, more realistic scoring curves\n\n#### **2. Demographic-Specific Ranges**\n- **LOOKSMAXX**: 8 ethnicities × 2 genders = 16 demographic combinations\n- **FaceIQ**: Single ideal range (Caucasian-centric)\n- **Advantage**: Fairer scoring across diverse populations\n\n#### **3. Directional Polarity Scoring**\n- **LOOKSMAXX**: `polarity: 'higher_is_better' | 'lower_is_better' | 'balanced'`\n- **FaceIQ**: Symmetric scoring only\n- **Advantage**: Handles sexually dimorphic traits correctly (e.g., canthal tilt higher for females)\n\n---\n\n### 9. SUMMARY\n\n| Category | LOOKSMAXX Implementation | Accuracy | Notes |\n|----------|-------------------------|----------|-------|\n| **Angle Calculations** | Law of Cosines via atan2 | ✅ Excellent | Handles all quadrants correctly |\n| **Distance Calculations** | Euclidean + Perpendicular | ✅ Excellent | Robust edge case handling |\n| **Ratio Calculations** | Division with zero checks | ✅ Excellent | All divisions protected |\n| **Floating Point Precision** | Sub-pixel coordinate accuracy | ✅ Excellent | No premature rounding |\n| **Degree/Radian Handling** | Consistent conversion | ✅ Excellent | Always converts to degrees for storage |\n| **Division by Zero** | Protected throughout | ✅ Excellent | All ratios/angles check denominators |\n| **Domain Errors** | 1 potential issue (nasofacial) | ⚠️ Minor Fix Needed | Clamp acos input to [-1, 1] |\n| **Coordinate Normalization** | MediaPipe: 0-1, InsightFace: pixels | ✅ Excellent | Normalized after FaceIQ rotation |\n\n**Overall Assessment**: The mathematical calculations in LOOKSMAXX are **highly accurate** with robust error handling. The only identified issue is a potential `Math.acos()` domain error in nasofacial angle calculation, which is easily fixed with input clamping.\n\n**Key Files Analyzed**:\n- `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/calculator.ts` (Core math functions)\n- `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/scoring/analyzer.ts` (Measurement calculations)\n- `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/faceiq-parity/scoring.ts` (FaceIQ comparison)\n- `/Users/imorgado/LOOKSMAXX/looksmaxx-app/src/lib/sideProfileNormalization.ts` (Rotation mathematics)"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6823,"cache_read_input_tokens":103014,"cache_creation":{"ephemeral_5m_input_tokens":6823,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWd717vCgRg4SLdKxxEHq","type":"assistant","uuid":"4c761cd4-76cb-43c1-af01-9050502bca49","timestamp":"2025-12-30T15:26:35.217Z"}
