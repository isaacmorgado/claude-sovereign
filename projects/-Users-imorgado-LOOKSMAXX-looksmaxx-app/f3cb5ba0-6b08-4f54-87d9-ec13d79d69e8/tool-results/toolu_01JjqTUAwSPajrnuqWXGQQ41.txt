     1→/**
     2→ * FaceIQ-Style Facial Analysis Scoring System
     3→ * Complete replication of FaceIQ Labs scoring algorithms
     4→ *
     5→ * Features:
     6→ * - Exponential decay scoring with per-metric decay rates
     7→ * - Bezier curve custom scoring for non-linear measurements
     8→ * - 70+ facial measurements (front + side profiles)
     9→ * - Quality tiers: Ideal, Excellent, Good
    10→ * - 5-tier severity: Extremely Severe, Severe, Major, Moderate, Minor
    11→ */
    12→
    13→import { LandmarkPoint } from './landmarks';
    14→
    15→// ============================================
    16→// CORE TYPES
    17→// ============================================
    18→
    19→export interface Point {
    20→  x: number;
    21→  y: number;
    22→}
    23→
    24→export type QualityTier = 'ideal' | 'excellent' | 'good' | 'below_average';
    25→export type SeverityLevel = 'extremely_severe' | 'severe' | 'major' | 'moderate' | 'minor' | 'optimal';
    26→export type MeasurementUnit = 'ratio' | 'percent' | 'degrees' | 'mm' | 'none';
    27→
    28→export interface MetricConfig {
    29→  id: string;
    30→  name: string;
    31→  category: string;
    32→  unit: MeasurementUnit;
    33→  idealMin: number;
    34→  idealMax: number;
    35→  rangeMin: number;
    36→  rangeMax: number;
    37→  decayRate: number;
    38→  maxScore: number;
    39→  weight: number;
    40→  description: string;
    41→  profileType: 'front' | 'side';
    42→  customCurve?: BezierCurveConfig;
    43→}
    44→
    45→export interface BezierCurveConfig {
    46→  mode: 'custom' | 'exponential';
    47→  points: CurvePoint[];
    48→}
    49→
    50→export interface CurvePoint {
    51→  x: number;
    52→  y: number;
    53→  leftHandleX?: number;
    54→  leftHandleY?: number;
    55→  rightHandleX?: number;
    56→  rightHandleY?: number;
    57→  fixed?: boolean;
    58→}
    59→
    60→export interface FaceIQScoreResult {
    61→  metricId: string;
    62→  name: string;
    63→  value: number;
    64→  score: number;  // 0-10 scale
    65→  standardizedScore: number;
    66→  qualityTier: QualityTier;
    67→  severity: SeverityLevel;
    68→  idealMin: number;
    69→  idealMax: number;
    70→  deviation: number;
    71→  deviationDirection: 'above' | 'below' | 'within';
    72→  unit: MeasurementUnit;
    73→  category: string;
    74→  percentile?: number;
    75→}
    76→
    77→export interface HarmonyAnalysis {
    78→  overallScore: number;  // 0-10 scale
    79→  standardizedScore: number;
    80→  qualityTier: QualityTier;
    81→  percentile: number;
    82→  frontScore: number;
    83→  sideScore: number;
    84→  categoryScores: Record<string, number>;
    85→  measurements: FaceIQScoreResult[];
    86→  flaws: FlawAssessment[];
    87→  strengths: StrengthAssessment[];
    88→}
    89→
    90→export interface FlawAssessment {
    91→  category: string;
    92→  metricId: string;
    93→  metricName: string;
    94→  severity: SeverityLevel;
    95→  deviation: string;
    96→  reasoning: string;
    97→  confidence: 'confirmed' | 'likely' | 'possible';
    98→}
    99→
   100→export interface StrengthAssessment {
   101→  category: string;
   102→  metricId: string;
   103→  metricName: string;
   104→  qualityTier: QualityTier;
   105→  value: number;
   106→  reasoning: string;
   107→}
   108→
   109→// ============================================
   110→// FACEIQ MEASUREMENT CONFIGURATIONS (70+)
   111→// ============================================
   112→
   113→export const FACEIQ_METRICS: Record<string, MetricConfig> = {
   114→  // ==========================================
   115→  // FRONT PROFILE - FACIAL PROPORTIONS (32)
   116→  // ==========================================
   117→
   118→  faceWidthToHeight: {
   119→    id: 'faceWidthToHeight',
   120→    name: 'Face Width to Height Ratio',
   121→    category: 'Midface/Face Shape',
   122→    unit: 'ratio',
   123→    idealMin: 1.96,
   124→    idealMax: 2.0,
   125→    rangeMin: 1.5,
   126→    rangeMax: 2.5,
   127→    decayRate: 15.0,
   128→    maxScore: 10,
   129→    weight: 0.04,
   130→    description: 'Ratio of bizygomatic width to upper face height',
   131→    profileType: 'front',
   132→  },
   133→
   134→  lowerThirdProportion: {
   135→    id: 'lowerThirdProportion',
   136→    name: 'Lower Third Proportion',
   137→    category: 'Midface/Face Shape',
   138→    unit: 'percent',
   139→    idealMin: 31,
   140→    idealMax: 33.5,
   141→    rangeMin: 24,
   142→    rangeMax: 40,
   143→    decayRate: 1.86,
   144→    maxScore: 10,
   145→    weight: 0.03,
   146→    description: 'Percentage of face occupied by lower third (subnasale to menton)',
   147→    profileType: 'front',
   148→  },
   149→
   150→  middleThirdProportion: {
   151→    id: 'middleThirdProportion',
   152→    name: 'Middle Third Proportion',
   153→    category: 'Midface/Face Shape',
   154→    unit: 'percent',
   155→    idealMin: 31,
   156→    idealMax: 34,
   157→    rangeMin: 24,
   158→    rangeMax: 42,
   159→    decayRate: 1.5,
   160→    maxScore: 10,
   161→    weight: 0.03,
   162→    description: 'Percentage of face occupied by middle third',
   163→    profileType: 'front',
   164→  },
   165→
   166→  upperThirdProportion: {
   167→    id: 'upperThirdProportion',
   168→    name: 'Upper Third Proportion',
   169→    category: 'Midface/Face Shape',
   170→    unit: 'percent',
   171→    idealMin: 31,
   172→    idealMax: 35,
   173→    rangeMin: 24,
   174→    rangeMax: 42,
   175→    decayRate: 1.2,
   176→    maxScore: 10,
   177→    weight: 0.02,
   178→    description: 'Percentage of face occupied by upper third (trichion to glabella)',
   179→    profileType: 'front',
   180→  },
   181→
   182→  bitemporalWidth: {
   183→    id: 'bitemporalWidth',
   184→    name: 'Bitemporal Width',
   185→    category: 'Midface/Face Shape',
   186→    unit: 'percent',
   187→    idealMin: 86.5,
   188→    idealMax: 92.5,
   189→    rangeMin: 75,
   190→    rangeMax: 100,
   191→    decayRate: 0.8,
   192→    maxScore: 10,
   193→    weight: 0.02,
   194→    description: 'Temple width as percentage of bizygomatic width',
   195→    profileType: 'front',
   196→  },
   197→
   198→  cheekboneHeight: {
   199→    id: 'cheekboneHeight',
   200→    name: 'Cheekbone Height',
   201→    category: 'Midface/Face Shape',
   202→    unit: 'percent',
   203→    idealMin: 83,
   204→    idealMax: 100,
   205→    rangeMin: 60,
   206→    rangeMax: 110,
   207→    decayRate: 0.5,
   208→    maxScore: 10,
   209→    weight: 0.02,
   210→    description: 'Vertical position of cheekbones relative to face height',
   211→    profileType: 'front',
   212→  },
   213→
   214→  totalFacialWidthToHeight: {
   215→    id: 'totalFacialWidthToHeight',
   216→    name: 'Total Facial Width to Height Ratio',
   217→    category: 'Midface/Face Shape',
   218→    unit: 'ratio',
   219→    idealMin: 1.34,
   220→    idealMax: 1.37,
   221→    rangeMin: 1.0,
   222→    rangeMax: 1.7,
   223→    decayRate: 13.2,
   224→    maxScore: 25,  // Special: higher max score
   225→    weight: 0.05,
   226→    description: 'Total face height divided by cheek width',
   227→    profileType: 'front',
   228→    customCurve: {
   229→      mode: 'custom',
   230→      points: [
   231→        { x: 1.05, y: 0 },
   232→        { x: 1.17, y: 1.41 },
   233→        { x: 1.25, y: 3.86 },
   234→        { x: 1.29, y: 6.01 },
   235→        { x: 1.32, y: 8.88 },
   236→        { x: 1.34, y: 10, fixed: true },
   237→        { x: 1.37, y: 10, fixed: true },
   238→        { x: 1.39, y: 8.88 },
   239→        { x: 1.42, y: 6.01 },
   240→        { x: 1.46, y: 3.86 },
   241→        { x: 1.54, y: 1.41 },
   242→        { x: 1.66, y: 0 },
   243→      ],
   244→    },
   245→  },
   246→
   247→  midfaceRatio: {
   248→    id: 'midfaceRatio',
   249→    name: 'Midface Ratio',
   250→    category: 'Midface/Face Shape',
   251→    unit: 'ratio',
   252→    idealMin: 0.97,
   253→    idealMax: 1.0,
   254→    rangeMin: 0.7,
   255→    rangeMax: 1.3,
   256→    decayRate: 31.6,
   257→    maxScore: 10,
   258→    weight: 0.04,
   259→    description: 'Midface width to height ratio for facial balance',
   260→    profileType: 'front',
   261→  },
   262→
   263→  // JAW MEASUREMENTS
   264→  jawSlope: {
   265→    id: 'jawSlope',
   266→    name: 'Jaw Slope',
   267→    category: 'Jaw Shape',
   268→    unit: 'degrees',
   269→    idealMin: 140,
   270→    idealMax: 142.5,
   271→    rangeMin: 120,
   272→    rangeMax: 160,
   273→    decayRate: 0.8,
   274→    maxScore: 10,
   275→    weight: 0.03,
   276→    description: 'Angle of the jawline from gonion to chin',
   277→    profileType: 'front',
   278→  },
   279→
   280→  jawFrontalAngle: {
   281→    id: 'jawFrontalAngle',
   282→    name: 'Jaw Frontal Angle',
   283→    category: 'Jaw Shape',
   284→    unit: 'degrees',
   285→    idealMin: 86.5,
   286→    idealMax: 92.5,
   287→    rangeMin: 70,
   288→    rangeMax: 110,
   289→    decayRate: 0.6,
   290→    maxScore: 10,
   291→    weight: 0.03,
   292→    description: 'Angle of jaw corners from frontal view',
   293→    profileType: 'front',
   294→  },
   295→
   296→  bigonialWidth: {
   297→    id: 'bigonialWidth',
   298→    name: 'Bigonial Width',
   299→    category: 'Jaw Shape',
   300→    unit: 'percent',
   301→    idealMin: 75,
   302→    idealMax: 82,
   303→    rangeMin: 60,
   304→    rangeMax: 95,
   305→    decayRate: 0.9,
   306→    maxScore: 10,
   307→    weight: 0.03,
   308→    description: 'Jaw width as percentage of bizygomatic width',
   309→    profileType: 'front',
   310→  },
   311→
   312→  jawWidthRatio: {
   313→    id: 'jawWidthRatio',
   314→    name: 'Jaw Width to Face Width Ratio',
   315→    category: 'Jaw Shape',
   316→    unit: 'ratio',
   317→    idealMin: 0.75,
   318→    idealMax: 0.82,
   319→    rangeMin: 0.6,
   320→    rangeMax: 0.95,
   321→    decayRate: 25.0,
   322→    maxScore: 10,
   323→    weight: 0.03,
   324→    description: 'Bigonial width divided by bizygomatic width',
   325→    profileType: 'front',
   326→  },
   327→
   328→  // EYE MEASUREMENTS
   329→  lateralCanthalTilt: {
   330→    id: 'lateralCanthalTilt',
   331→    name: 'Lateral Canthal Tilt',
   332→    category: 'Eyes',
   333→    unit: 'degrees',
   334→    idealMin: 4,
   335→    idealMax: 8,
   336→    rangeMin: -5,
   337→    rangeMax: 15,
   338→    decayRate: 2.5,
   339→    maxScore: 10,
   340→    weight: 0.04,
   341→    description: 'Angle of eye from inner to outer canthus',
   342→    profileType: 'front',
   343→  },
   344→
   345→  eyeAspectRatio: {
   346→    id: 'eyeAspectRatio',
   347→    name: 'Eye Aspect Ratio',
   348→    category: 'Eyes',
   349→    unit: 'ratio',
   350→    idealMin: 0.28,
   351→    idealMax: 0.32,
   352→    rangeMin: 0.2,
   353→    rangeMax: 0.45,
   354→    decayRate: 40.0,
   355→    maxScore: 10,
   356→    weight: 0.03,
   357→    description: 'Eye height divided by eye width',
   358→    profileType: 'front',
   359→  },
   360→
   361→  eyeSeparationRatio: {
   362→    id: 'eyeSeparationRatio',
   363→    name: 'Eye Separation Ratio',
   364→    category: 'Eyes',
   365→    unit: 'ratio',
   366→    idealMin: 0.28,
   367→    idealMax: 0.32,
   368→    rangeMin: 0.22,
   369→    rangeMax: 0.38,
   370→    decayRate: 35.0,
   371→    maxScore: 10,
   372→    weight: 0.03,
   373→    description: 'Intercanthal distance divided by bizygomatic width',
   374→    profileType: 'front',
   375→  },
   376→
   377→  interpupillaryRatio: {
   378→    id: 'interpupillaryRatio',
   379→    name: 'Interpupillary Distance Ratio',
   380→    category: 'Eyes',
   381→    unit: 'percent',
   382→    idealMin: 44,
   383→    idealMax: 48,
   384→    rangeMin: 38,
   385→    rangeMax: 54,
   386→    decayRate: 1.8,
   387→    maxScore: 10,
   388→    weight: 0.02,
   389→    description: 'IPD as percentage of bizygomatic width',
   390→    profileType: 'front',
   391→  },
   392→
   393→  interpupillaryMouthWidthRatio: {
   394→    id: 'interpupillaryMouthWidthRatio',
   395→    name: 'Interpupillary-Mouth Width Ratio',
   396→    category: 'Eyes',
   397→    unit: 'ratio',
   398→    idealMin: 0.8,
   399→    idealMax: 0.9,
   400→    rangeMin: 0.6,
   401→    rangeMax: 1.1,
   402→    decayRate: 12.0,
   403→    maxScore: 10,
   404→    weight: 0.02,
   405→    description: 'Mouth width divided by interpupillary distance',
   406→    profileType: 'front',
   407→  },
   408→
   409→  oneEyeApartTest: {
   410→    id: 'oneEyeApartTest',
   411→    name: 'One Eye Apart Test',
   412→    category: 'Eyes',
   413→    unit: 'ratio',
   414→    idealMin: 0.95,
   415→    idealMax: 1.05,
   416→    rangeMin: 0.7,
   417→    rangeMax: 1.3,
   418→    decayRate: 20.0,
   419→    maxScore: 10,
   420→    weight: 0.02,
   421→    description: 'Intercanthal distance should equal one eye width',
   422→    profileType: 'front',
   423→  },
   424→
   425→  // EYEBROW MEASUREMENTS
   426→  browLengthRatio: {
   427→    id: 'browLengthRatio',
   428→    name: 'Brow Length to Face Width Ratio',
   429→    category: 'Upper Third',
   430→    unit: 'percent',
   431→    idealMin: 28,
   432→    idealMax: 32,
   433→    rangeMin: 20,
   434→    rangeMax: 40,
   435→    decayRate: 1.5,
   436→    maxScore: 10,
   437→    weight: 0.02,
   438→    description: 'Eyebrow length as percentage of face width',
   439→    profileType: 'front',
   440→  },
   441→
   442→  eyebrowTilt: {
   443→    id: 'eyebrowTilt',
   444→    name: 'Eyebrow Tilt',
   445→    category: 'Upper Third',
   446→    unit: 'degrees',
   447→    idealMin: 8,
   448→    idealMax: 15,
   449→    rangeMin: 0,
   450→    rangeMax: 25,
   451→    decayRate: 1.2,
   452→    maxScore: 10,
   453→    weight: 0.02,
   454→    description: 'Angle of eyebrow from head to tail',
   455→    profileType: 'front',
   456→  },
   457→
   458→  eyebrowLowSetedness: {
   459→    id: 'eyebrowLowSetedness',
   460→    name: 'Eyebrow Low Setedness',
   461→    category: 'Upper Third',
   462→    unit: 'ratio',
   463→    idealMin: 0.18,
   464→    idealMax: 0.24,
   465→    rangeMin: 0.1,
   466→    rangeMax: 0.35,
   467→    decayRate: 30.0,
   468→    maxScore: 10,
   469→    weight: 0.02,
   470→    description: 'Distance from brow to eye relative to eye height',
   471→    profileType: 'front',
   472→  },
   473→
   474→  // NOSE MEASUREMENTS (FRONT)
   475→  nasalIndex: {
   476→    id: 'nasalIndex',
   477→    name: 'Nasal Index',
   478→    category: 'Nose',
   479→    unit: 'percent',
   480→    idealMin: 70,
   481→    idealMax: 85,
   482→    rangeMin: 55,
   483→    rangeMax: 100,
   484→    decayRate: 0.5,
   485→    maxScore: 10,
   486→    weight: 0.02,
   487→    description: 'Nose width divided by nose height × 100',
   488→    profileType: 'front',
   489→  },
   490→
   491→  intercanthalNasalRatio: {
   492→    id: 'intercanthalNasalRatio',
   493→    name: 'Intercanthal-Nasal Width Ratio',
   494→    category: 'Nose',
   495→    unit: 'ratio',
   496→    idealMin: 1.0,
   497→    idealMax: 1.2,
   498→    rangeMin: 0.7,
   499→    rangeMax: 1.5,
   500→    decayRate: 12.0,
   501→    maxScore: 10,
   502→    weight: 0.02,
   503→    description: 'Alar width should roughly equal intercanthal distance',
   504→    profileType: 'front',
   505→  },
   506→
   507→  noseBridgeWidth: {
   508→    id: 'noseBridgeWidth',
   509→    name: 'Nose Bridge to Nose Width',
   510→    category: 'Nose',
   511→    unit: 'ratio',
   512→    idealMin: 0.6,
   513→    idealMax: 0.75,
   514→    rangeMin: 0.4,
   515→    rangeMax: 0.9,
   516→    decayRate: 15.0,
   517→    maxScore: 10,
   518→    weight: 0.01,
   519→    description: 'Ratio of nose bridge width to alar base width',
   520→    profileType: 'front',
   521→  },
   522→
   523→  noseTipPosition: {
   524→    id: 'noseTipPosition',
   525→    name: 'Nose Tip Position',
   526→    category: 'Nose',
   527→    unit: 'ratio',
   528→    idealMin: 0.48,
   529→    idealMax: 0.52,
   530→    rangeMin: 0.4,
   531→    rangeMax: 0.6,
   532→    decayRate: 25.0,
   533→    maxScore: 10,
   534→    weight: 0.01,
   535→    description: 'Nose tip position relative to face centerline',
   536→    profileType: 'front',
   537→  },
   538→
   539→  // MOUTH/LIP MEASUREMENTS
   540→  mouthWidthToNoseRatio: {
   541→    id: 'mouthWidthToNoseRatio',
   542→    name: 'Mouth Width to Nose Width Ratio',
   543→    category: 'Lips',
   544→    unit: 'ratio',
   545→    idealMin: 1.44,
   546→    idealMax: 1.52,
   547→    rangeMin: 1.2,
   548→    rangeMax: 1.8,
   549→    decayRate: 18.0,
   550→    maxScore: 10,
   551→    weight: 0.03,
   552→    description: 'Mouth width divided by nose width',
   553→    profileType: 'front',
   554→  },
   555→
   556→  lowerToUpperLipRatio: {
   557→    id: 'lowerToUpperLipRatio',
   558→    name: 'Lower Lip to Upper Lip Ratio',
   559→    category: 'Lips',
   560→    unit: 'ratio',
   561→    idealMin: 1.4,
   562→    idealMax: 1.8,
   563→    rangeMin: 1.0,
   564→    rangeMax: 2.5,
   565→    decayRate: 8.0,
   566→    maxScore: 10,
   567→    weight: 0.02,
   568→    description: 'Lower lip height divided by upper lip height',
   569→    profileType: 'front',
   570→  },
   571→
   572→  cupidsBowDepth: {
   573→    id: 'cupidsBowDepth',
   574→    name: "Cupid's Bow Depth",
   575→    category: 'Lips',
   576→    unit: 'mm',
   577→    idealMin: 2,
   578→    idealMax: 4,
   579→    rangeMin: 0,
   580→    rangeMax: 7,
   581→    decayRate: 2.0,
   582→    maxScore: 10,
   583→    weight: 0.01,
   584→    description: "Depth of the cupid's bow curve",
   585→    profileType: 'front',
   586→  },
   587→
   588→  mouthCornerPosition: {
   589→    id: 'mouthCornerPosition',
   590→    name: 'Mouth Corner Position',
   591→    category: 'Lips',
   592→    unit: 'ratio',
   593→    idealMin: -0.02,
   594→    idealMax: 0.02,
   595→    rangeMin: -0.1,
   596→    rangeMax: 0.1,
   597→    decayRate: 50.0,
   598→    maxScore: 10,
   599→    weight: 0.01,
   600→    description: 'Mouth corner vertical position relative to lip center',
   601→    profileType: 'front',
   602→  },
   603→
   604→  // CHIN MEASUREMENTS (FRONT)
   605→  chinToPhiltrumRatio: {
   606→    id: 'chinToPhiltrumRatio',
   607→    name: 'Chin to Philtrum Ratio',
   608→    category: 'Chin',
   609→    unit: 'ratio',
   610→    idealMin: 1.8,
   611→    idealMax: 2.2,
   612→    rangeMin: 1.3,
   613→    rangeMax: 2.8,
   614→    decayRate: 10.0,
   615→    maxScore: 10,
   616→    weight: 0.02,
   617→    description: 'Chin height divided by philtrum length',
   618→    profileType: 'front',
   619→  },
   620→
   621→  // OTHER FRONT MEASUREMENTS
   622→  iaaJfaDeviation: {
   623→    id: 'iaaJfaDeviation',
   624→    name: 'Deviation of IAA & JFA',
   625→    category: 'Jaw Shape',
   626→    unit: 'degrees',
   627→    idealMin: -3,
   628→    idealMax: 3,
   629→    rangeMin: -15,
   630→    rangeMax: 15,
   631→    decayRate: 1.5,
   632→    maxScore: 10,
   633→    weight: 0.02,
   634→    description: 'Deviation between Ipsilateral Alar Angle and Jaw Frontal Angle',
   635→    profileType: 'front',
   636→  },
   637→
   638→  neckWidth: {
   639→    id: 'neckWidth',
   640→    name: 'Neck Width',
   641→    category: 'Neck',
   642→    unit: 'percent',
   643→    idealMin: 70,
   644→    idealMax: 85,
   645→    rangeMin: 55,
   646→    rangeMax: 100,
   647→    decayRate: 0.6,
   648→    maxScore: 10,
   649→    weight: 0.01,
   650→    description: 'Neck width as percentage of jaw width',
   651→    profileType: 'front',
   652→  },
   653→
   654→  // ==========================================
   655→  // SIDE PROFILE MEASUREMENTS (38)
   656→  // ==========================================
   657→
   658→  gonialAngle: {
   659→    id: 'gonialAngle',
   660→    name: 'Gonial Angle',
   661→    category: 'Occlusion/Jaw Growth',
   662→    unit: 'degrees',
   663→    idealMin: 120,
   664→    idealMax: 130,
   665→    rangeMin: 105,
   666→    rangeMax: 145,
   667→    decayRate: 0.8,
   668→    maxScore: 10,
   669→    weight: 0.04,
   670→    description: 'Angle at the jaw corner (gonion)',
   671→    profileType: 'side',
   672→  },
   673→
   674→  nasolabialAngle: {
   675→    id: 'nasolabialAngle',
   676→    name: 'Nasolabial Angle',
   677→    category: 'Nose',
   678→    unit: 'degrees',
   679→    idealMin: 90,
   680→    idealMax: 105,
   681→    rangeMin: 75,
   682→    rangeMax: 120,
   683→    decayRate: 0.6,
   684→    maxScore: 10,
   685→    weight: 0.03,
   686→    description: 'Angle between columella and upper lip',
   687→    profileType: 'side',
   688→  },
   689→
   690→  nasofrontalAngle: {
   691→    id: 'nasofrontalAngle',
   692→    name: 'Nasofrontal Angle',
   693→    category: 'Nose',
   694→    unit: 'degrees',
   695→    idealMin: 115,
   696→    idealMax: 135,
   697→    rangeMin: 100,
   698→    rangeMax: 150,
   699→    decayRate: 0.5,
   700→    maxScore: 10,
   701→    weight: 0.02,
   702→    description: 'Angle at the bridge of nose (nasion)',
   703→    profileType: 'side',
   704→  },
   705→
   706→  nasofacialAngle: {
   707→    id: 'nasofacialAngle',
   708→    name: 'Nasofacial Angle',
   709→    category: 'Nose',
   710→    unit: 'degrees',
   711→    idealMin: 30,
   712→    idealMax: 40,
   713→    rangeMin: 20,
   714→    rangeMax: 50,
   715→    decayRate: 1.2,
   716→    maxScore: 10,
   717→    weight: 0.02,
   718→    description: 'Angle between nose and face plane',
   719→    profileType: 'side',
   720→  },
   721→
   722→  nasomentaAngle: {
   723→    id: 'nasomentaAngle',
   724→    name: 'Nasomental Angle',
   725→    category: 'Nose',
   726→    unit: 'degrees',
   727→    idealMin: 120,
   728→    idealMax: 132,
   729→    rangeMin: 105,
   730→    rangeMax: 145,
   731→    decayRate: 0.7,
   732→    maxScore: 10,
   733→    weight: 0.02,
   734→    description: 'Angle from nasion to nose tip to chin',
   735→    profileType: 'side',
   736→  },
   737→
   738→  nasalTipAngle: {
   739→    id: 'nasalTipAngle',
   740→    name: 'Nasal Tip Angle',
   741→    category: 'Nose',
   742→    unit: 'degrees',
   743→    idealMin: 85,
   744→    idealMax: 105,
   745→    rangeMin: 70,
   746→    rangeMax: 120,
   747→    decayRate: 0.8,
   748→    maxScore: 10,
   749→    weight: 0.02,
   750→    description: 'Angle of the nose tip',
   751→    profileType: 'side',
   752→  },
   753→
   754→  nasalProjection: {
   755→    id: 'nasalProjection',
   756→    name: 'Nasal Projection',
   757→    category: 'Nose',
   758→    unit: 'ratio',
   759→    idealMin: 0.55,
   760→    idealMax: 0.6,
   761→    rangeMin: 0.4,
   762→    rangeMax: 0.75,
   763→    decayRate: 20.0,
   764→    maxScore: 10,
   765→    weight: 0.02,
   766→    description: 'Nose projection relative to nasal length (Goode ratio)',
   767→    profileType: 'side',
   768→  },
   769→
   770→  nasalWToHRatio: {
   771→    id: 'nasalWToHRatio',
   772→    name: 'Nasal W to H Ratio',
   773→    category: 'Nose',
   774→    unit: 'ratio',
   775→    idealMin: 0.67,
   776→    idealMax: 0.78,
   777→    rangeMin: 0.5,
   778→    rangeMax: 0.95,
   779→    decayRate: 15.0,
   780→    maxScore: 10,
   781→    weight: 0.01,
   782→    description: 'Nose width to height ratio from side view',
   783→    profileType: 'side',
   784→  },
   785→
   786→  noseTipRotationAngle: {
   787→    id: 'noseTipRotationAngle',
   788→    name: 'Nose Tip Rotation Angle',
   789→    category: 'Nose',
   790→    unit: 'degrees',
   791→    idealMin: 95,
   792→    idealMax: 110,
   793→    rangeMin: 80,
   794→    rangeMax: 125,
   795→    decayRate: 0.8,
   796→    maxScore: 10,
   797→    weight: 0.01,
   798→    description: 'Angle of nose tip rotation',
   799→    profileType: 'side',
   800→  },
   801→
   802→  frankfortTipAngle: {
   803→    id: 'frankfortTipAngle',
   804→    name: 'Frankfort-Tip Angle',
   805→    category: 'Nose',
   806→    unit: 'degrees',
   807→    idealMin: 28,
   808→    idealMax: 34,
   809→    rangeMin: 20,
   810→    rangeMax: 42,
   811→    decayRate: 1.0,
   812→    maxScore: 10,
   813→    weight: 0.01,
   814→    description: 'Angle between Frankfort plane and nose tip',
   815→    profileType: 'side',
   816→  },
   817→
   818→  mentolabialAngle: {
   819→    id: 'mentolabialAngle',
   820→    name: 'Mentolabial Angle',
   821→    category: 'Lips',
   822→    unit: 'degrees',
   823→    idealMin: 120,
   824→    idealMax: 140,
   825→    rangeMin: 100,
   826→    rangeMax: 160,
   827→    decayRate: 0.5,
   828→    maxScore: 10,
   829→    weight: 0.02,
   830→    description: 'Angle at the labiomental fold',
   831→    profileType: 'side',
   832→  },
   833→
   834→  zAngle: {
   835→    id: 'zAngle',
   836→    name: 'Z Angle',
   837→    category: 'Occlusion/Jaw Growth',
   838→    unit: 'degrees',
   839→    idealMin: 75,
   840→    idealMax: 85,
   841→    rangeMin: 60,
   842→    rangeMax: 100,
   843→    decayRate: 0.8,
   844→    maxScore: 10,
   845→    weight: 0.02,
   846→    description: 'Merrifield Z-Angle for profile assessment',
   847→    profileType: 'side',
   848→  },
   849→
   850→  submentalCervicalAngle: {
   851→    id: 'submentalCervicalAngle',
   852→    name: 'Submental Cervical Angle',
   853→    category: 'Neck',
   854→    unit: 'degrees',
   855→    idealMin: 105,
   856→    idealMax: 120,
   857→    rangeMin: 90,
   858→    rangeMax: 140,
   859→    decayRate: 0.6,
   860→    maxScore: 10,
   861→    weight: 0.02,
   862→    description: 'Angle between chin and neck',
   863→    profileType: 'side',
   864→  },
   865→
   866→  facialConvexityGlabella: {
   867→    id: 'facialConvexityGlabella',
   868→    name: 'Facial Convexity (Glabella)',
   869→    category: 'Midface/Face Shape',
   870→    unit: 'degrees',
   871→    idealMin: 165,
   872→    idealMax: 175,
   873→    rangeMin: 150,
   874→    rangeMax: 185,
   875→    decayRate: 0.4,
   876→    maxScore: 10,
   877→    weight: 0.03,
   878→    description: 'Facial convexity angle using glabella',
   879→    profileType: 'side',
   880→  },
   881→
   882→  facialConvexityNasion: {
   883→    id: 'facialConvexityNasion',
   884→    name: 'Facial Convexity (Nasion)',
   885→    category: 'Midface/Face Shape',
   886→    unit: 'degrees',
   887→    idealMin: 168,
   888→    idealMax: 178,
   889→    rangeMin: 155,
   890→    rangeMax: 190,
   891→    decayRate: 0.4,
   892→    maxScore: 10,
   893→    weight: 0.02,
   894→    description: 'Facial convexity angle using nasion',
   895→    profileType: 'side',
   896→  },
   897→
   898→  totalFacialConvexity: {
   899→    id: 'totalFacialConvexity',
   900→    name: 'Total Facial Convexity',
   901→    category: 'Midface/Face Shape',
   902→    unit: 'degrees',
   903→    idealMin: 135,
   904→    idealMax: 145,
   905→    rangeMin: 120,
   906→    rangeMax: 160,
   907→    decayRate: 0.5,
   908→    maxScore: 10,
   909→    weight: 0.03,
   910→    description: 'Complete facial profile convexity measurement',
   911→    profileType: 'side',
   912→  },
   913→
   914→  facialDepthToHeight: {
   915→    id: 'facialDepthToHeight',
   916→    name: 'Facial Depth to Height Ratio',
   917→    category: 'Midface/Face Shape',
   918→    unit: 'ratio',
   919→    idealMin: 0.85,
   920→    idealMax: 0.95,
   921→    rangeMin: 0.7,
   922→    rangeMax: 1.1,
   923→    decayRate: 15.0,
   924→    maxScore: 10,
   925→    weight: 0.02,
   926→    description: 'Facial depth divided by facial height',
   927→    profileType: 'side',
   928→  },
   929→
   930→  anteriorFacialDepth: {
   931→    id: 'anteriorFacialDepth',
   932→    name: 'Anterior Facial Depth',
   933→    category: 'Midface/Face Shape',
   934→    unit: 'mm',
   935→    idealMin: 85,
   936→    idealMax: 100,
   937→    rangeMin: 70,
   938→    rangeMax: 115,
   939→    decayRate: 0.3,
   940→    maxScore: 10,
   941→    weight: 0.01,
   942→    description: 'Depth of the anterior face',
   943→    profileType: 'side',
   944→  },
   945→
   946→  mandibularPlaneAngle: {
   947→    id: 'mandibularPlaneAngle',
   948→    name: 'Mandibular Plane Angle',
   949→    category: 'Occlusion/Jaw Growth',
   950→    unit: 'degrees',
   951→    idealMin: 22,
   952→    idealMax: 28,
   953→    rangeMin: 15,
   954→    rangeMax: 38,
   955→    decayRate: 0.8,
   956→    maxScore: 10,
   957→    weight: 0.03,
   958→    description: 'Angle of mandibular plane to Frankfort plane',
   959→    profileType: 'side',
   960→  },
   961→
   962→  ramusToMandibleRatio: {
   963→    id: 'ramusToMandibleRatio',
   964→    name: 'Ramus to Mandible Ratio',
   965→    category: 'Occlusion/Jaw Growth',
   966→    unit: 'ratio',
   967→    idealMin: 0.65,
   968→    idealMax: 0.75,
   969→    rangeMin: 0.5,
   970→    rangeMax: 0.9,
   971→    decayRate: 15.0,
   972→    maxScore: 10,
   973→    weight: 0.02,
   974→    description: 'Ramus height divided by mandible length',
   975→    profileType: 'side',
   976→  },
   977→
   978→  gonionToMouthLine: {
   979→    id: 'gonionToMouthLine',
   980→    name: 'Gonion to Mouth Line',
   981→    category: 'Jaw Shape',
   982→    unit: 'mm',
   983→    idealMin: -5,
   984→    idealMax: 5,
   985→    rangeMin: -20,
   986→    rangeMax: 20,
   987→    decayRate: 0.5,
   988→    maxScore: 10,
   989→    weight: 0.02,
   990→    description: 'Distance from gonion to mouth level line',
   991→    profileType: 'side',
   992→  },
   993→
   994→  // E-LINE MEASUREMENTS
   995→  eLineUpperLip: {
   996→    id: 'eLineUpperLip',
   997→    name: 'Upper Lip E-Line Position',
   998→    category: 'Lips',
   999→    unit: 'mm',
  1000→    idealMin: -4,
  1001→    idealMax: -2,
  1002→    rangeMin: -10,
  1003→    rangeMax: 4,
  1004→    decayRate: 1.0,
  1005→    maxScore: 10,
  1006→    weight: 0.02,
  1007→    description: 'Upper lip distance from E-line (Ricketts)',
  1008→    profileType: 'side',
  1009→  },
  1010→
  1011→  eLineLowerLip: {
  1012→    id: 'eLineLowerLip',
  1013→    name: 'Lower Lip E-Line Position',
  1014→    category: 'Lips',
  1015→    unit: 'mm',
  1016→    idealMin: -2,
  1017→    idealMax: 0,
  1018→    rangeMin: -8,
  1019→    rangeMax: 6,
  1020→    decayRate: 1.0,
  1021→    maxScore: 10,
  1022→    weight: 0.02,
  1023→    description: 'Lower lip distance from E-line (Ricketts)',
  1024→    profileType: 'side',
  1025→  },
  1026→
  1027→  // S-LINE MEASUREMENTS
  1028→  sLineUpperLip: {
  1029→    id: 'sLineUpperLip',
  1030→    name: 'Upper Lip S-Line Position',
  1031→    category: 'Lips',
  1032→    unit: 'mm',
  1033→    idealMin: 0,
  1034→    idealMax: 3,
  1035→    rangeMin: -5,
  1036→    rangeMax: 8,
  1037→    decayRate: 1.2,
  1038→    maxScore: 10,
  1039→    weight: 0.01,
  1040→    description: 'Upper lip distance from S-line (Steiner)',
  1041→    profileType: 'side',
  1042→  },
  1043→
  1044→  sLineLowerLip: {
  1045→    id: 'sLineLowerLip',
  1046→    name: 'Lower Lip S-Line Position',
  1047→    category: 'Lips',
  1048→    unit: 'mm',
  1049→    idealMin: 0,
  1050→    idealMax: 2,
  1051→    rangeMin: -4,
  1052→    rangeMax: 6,
  1053→    decayRate: 1.2,
  1054→    maxScore: 10,
  1055→    weight: 0.01,
  1056→    description: 'Lower lip distance from S-line (Steiner)',
  1057→    profileType: 'side',
  1058→  },
  1059→
  1060→  // BURSTONE LINE
  1061→  burstoneUpperLip: {
  1062→    id: 'burstoneUpperLip',
  1063→    name: 'Upper Lip Burstone Line',
  1064→    category: 'Lips',
  1065→    unit: 'mm',
  1066→    idealMin: 2,
  1067→    idealMax: 4,
  1068→    rangeMin: -2,
  1069→    rangeMax: 8,
  1070→    decayRate: 1.0,
  1071→    maxScore: 10,
  1072→    weight: 0.01,
  1073→    description: 'Upper lip to Burstone line distance',
  1074→    profileType: 'side',
  1075→  },
  1076→
  1077→  burstoneLowerLip: {
  1078→    id: 'burstoneLowerLip',
  1079→    name: 'Lower Lip Burstone Line',
  1080→    category: 'Lips',
  1081→    unit: 'mm',
  1082→    idealMin: 1,
  1083→    idealMax: 3,
  1084→    rangeMin: -3,
  1085→    rangeMax: 7,
  1086→    decayRate: 1.0,
  1087→    maxScore: 10,
  1088→    weight: 0.01,
  1089→    description: 'Lower lip to Burstone line distance',
  1090→    profileType: 'side',
  1091→  },
  1092→
  1093→  // H LINE
  1094→  holdawayHLine: {
  1095→    id: 'holdawayHLine',
  1096→    name: 'Holdaway H Line',
  1097→    category: 'Lips',
  1098→    unit: 'mm',
  1099→    idealMin: 0,
  1100→    idealMax: 4,
  1101→    rangeMin: -5,
  1102→    rangeMax: 10,
  1103→    decayRate: 0.8,
  1104→    maxScore: 10,
  1105→    weight: 0.01,
  1106→    description: 'Holdaway H-line soft tissue assessment',
  1107→    profileType: 'side',
  1108→  },
  1109→
  1110→  // CHIN MEASUREMENTS (SIDE)
  1111→  chinProjection: {
  1112→    id: 'chinProjection',
  1113→    name: 'Chin Projection',
  1114→    category: 'Chin',
  1115→    unit: 'mm',
  1116→    idealMin: -3,
  1117→    idealMax: 3,
  1118→    rangeMin: -12,
  1119→    rangeMax: 12,
  1120→    decayRate: 0.8,
  1121→    maxScore: 10,
  1122→    weight: 0.02,
  1123→    description: 'Chin projection relative to ideal position',
  1124→    profileType: 'side',
  1125→  },
  1126→
  1127→  recessionRelativeToFrankfort: {
  1128→    id: 'recessionRelativeToFrankfort',
  1129→    name: 'Recession Relative to Frankfort Plane',
  1130→    category: 'Chin',
  1131→    unit: 'mm',
  1132→    idealMin: -2,
  1133→    idealMax: 2,
  1134→    rangeMin: -10,
  1135→    rangeMax: 10,
  1136→    decayRate: 0.8,
  1137→    maxScore: 10,
  1138→    weight: 0.02,
  1139→    description: 'Chin recession relative to Frankfort horizontal',
  1140→    profileType: 'side',
  1141→  },
  1142→
  1143→  // FOREHEAD
  1144→  browridgeInclinationAngle: {
  1145→    id: 'browridgeInclinationAngle',
  1146→    name: 'Browridge Inclination Angle',
  1147→    category: 'Upper Third',
  1148→    unit: 'degrees',
  1149→    idealMin: 10,
  1150→    idealMax: 18,
  1151→    rangeMin: 0,
  1152→    rangeMax: 28,
  1153→    decayRate: 1.0,
  1154→    maxScore: 10,
  1155→    weight: 0.02,
  1156→    description: 'Angle of the brow ridge from profile',
  1157→    profileType: 'side',
  1158→  },
  1159→
  1160→  upperForeheadSlope: {
  1161→    id: 'upperForeheadSlope',
  1162→    name: 'Upper Forehead Slope',
  1163→    category: 'Upper Third',
  1164→    unit: 'degrees',
  1165→    idealMin: 5,
  1166→    idealMax: 12,
  1167→    rangeMin: 0,
  1168→    rangeMax: 20,
  1169→    decayRate: 1.2,
  1170→    maxScore: 10,
  1171→    weight: 0.01,
  1172→    description: 'Slope angle of the upper forehead',
  1173→    profileType: 'side',
  1174→  },
  1175→
  1176→  // MIDFACE PROJECTION
  1177→  midfaceProjectionAngle: {
  1178→    id: 'midfaceProjectionAngle',
  1179→    name: 'Interior Midface Projection Angle',
  1180→    category: 'Midface/Face Shape',
  1181→    unit: 'degrees',
  1182→    idealMin: 85,
  1183→    idealMax: 95,
  1184→    rangeMin: 75,
  1185→    rangeMax: 105,
  1186→    decayRate: 0.8,
  1187→    maxScore: 10,
  1188→    weight: 0.02,
  1189→    description: 'Angle of midface projection from profile',
  1190→    profileType: 'side',
  1191→  },
  1192→
  1193→  orbitalVector: {
  1194→    id: 'orbitalVector',
  1195→    name: 'Orbital Vector',
  1196→    category: 'Eyes',
  1197→    unit: 'mm',
  1198→    idealMin: 0,
  1199→    idealMax: 4,
  1200→    rangeMin: -6,
  1201→    rangeMax: 10,
  1202→    decayRate: 1.0,
  1203→    maxScore: 10,
  1204→    weight: 0.02,
  1205→    description: 'Relationship of globe to orbital rim',
  1206→    profileType: 'side',
  1207→  },
  1208→
  1209→  // EAR MEASUREMENTS
  1210→  earProtrusionAngle: {
  1211→    id: 'earProtrusionAngle',
  1212→    name: 'Ear Protrusion Angle',
  1213→    category: 'Other',
  1214→    unit: 'degrees',
  1215→    idealMin: 15,
  1216→    idealMax: 25,
  1217→    rangeMin: 5,
  1218→    rangeMax: 40,
  1219→    decayRate: 1.0,
  1220→    maxScore: 10,
  1221→    weight: 0.01,
  1222→    description: 'Angle of ear protrusion from head',
  1223→    profileType: 'front',
  1224→  },
  1225→
  1226→  earProtrusionRatio: {
  1227→    id: 'earProtrusionRatio',
  1228→    name: 'Ear Protrusion Ratio',
  1229→    category: 'Other',
  1230→    unit: 'percent',
  1231→    idealMin: 15,
  1232→    idealMax: 25,
  1233→    rangeMin: 8,
  1234→    rangeMax: 40,
  1235→    decayRate: 1.5,
  1236→    maxScore: 10,
  1237→    weight: 0.01,
  1238→    description: 'Ear protrusion as percentage of ear height',
  1239→    profileType: 'front',
  1240→  },
  1241→};
  1242→
  1243→// ============================================
  1244→// CATEGORY DEFINITIONS
  1245→// ============================================
  1246→
  1247→export const MEASUREMENT_CATEGORIES = {
  1248→  'Midface/Face Shape': { color: '#67e8f9', weight: 0.20 },
  1249→  'Occlusion/Jaw Growth': { color: '#a78bfa', weight: 0.15 },
  1250→  'Jaw Shape': { color: '#f97316', weight: 0.13 },
  1251→  'Upper Third': { color: '#84cc16', weight: 0.08 },
  1252→  'Eyes': { color: '#06b6d4', weight: 0.12 },
  1253→  'Nose': { color: '#fbbf24', weight: 0.10 },
  1254→  'Lips': { color: '#ec4899', weight: 0.10 },
  1255→  'Chin': { color: '#ef4444', weight: 0.06 },
  1256→  'Neck': { color: '#14b8a6', weight: 0.03 },
  1257→  'Other': { color: '#6b7280', weight: 0.03 },
  1258→};
  1259→
  1260→// ============================================
  1261→// CORE SCORING FUNCTIONS
  1262→// ============================================
  1263→
  1264→/**
  1265→ * FaceIQ Exponential Decay Scoring Algorithm
  1266→ * score = maxScore × e^(-decayRate × deviation)
  1267→ */
  1268→export function calculateFaceIQScore(
  1269→  value: number,
  1270→  config: MetricConfig
  1271→): number {
  1272→  const { idealMin, idealMax, decayRate, maxScore, customCurve } = config;
  1273→
  1274→  // Use custom curve if available
  1275→  if (customCurve && customCurve.mode === 'custom') {
  1276→    return interpolateCustomCurve(value, customCurve.points, maxScore);
  1277→  }
  1278→
  1279→  // Perfect score within ideal range
  1280→  if (value >= idealMin && value <= idealMax) {
  1281→    return maxScore;
  1282→  }
  1283→
  1284→  // Calculate deviation from ideal range
  1285→  const deviation = value < idealMin
  1286→    ? idealMin - value
  1287→    : value - idealMax;
  1288→
  1289→  // Exponential decay
  1290→  const score = maxScore * Math.exp(-decayRate * deviation);
  1291→
  1292→  return Math.max(0, Math.min(maxScore, score));
  1293→}
  1294→
  1295→/**
  1296→ * Interpolate custom Bezier curve for scoring
  1297→ * Uses cubic Bezier interpolation with control handles for smooth curves
  1298→ */
  1299→function interpolateCustomCurve(
  1300→  value: number,
  1301→  points: CurvePoint[],
  1302→  maxScore: number
  1303→): number {
  1304→  if (points.length === 0) return 0;
  1305→
  1306→  // Sort points by x value
  1307→  const sortedPoints = [...points].sort((a, b) => a.x - b.x);
  1308→
  1309→  // Clamp to range
  1310→  if (value <= sortedPoints[0].x) return sortedPoints[0].y;
  1311→  if (value >= sortedPoints[sortedPoints.length - 1].x) {
  1312→    return sortedPoints[sortedPoints.length - 1].y;
  1313→  }
  1314→
  1315→  // Find bracketing points
  1316→  let lowerIndex = 0;
  1317→  for (let i = 0; i < sortedPoints.length - 1; i++) {
  1318→    if (value >= sortedPoints[i].x && value <= sortedPoints[i + 1].x) {
  1319→      lowerIndex = i;
  1320→      break;
  1321→    }
  1322→  }
  1323→
  1324→  const p0 = sortedPoints[lowerIndex];
  1325→  const p3 = sortedPoints[lowerIndex + 1];
  1326→
  1327→  // Check if we have Bezier control handles
  1328→  const hasHandles = p0.rightHandleX !== undefined && p3.leftHandleX !== undefined;
  1329→
  1330→  if (hasHandles) {
  1331→    // Cubic Bezier interpolation with control points
  1332→    const p1x = p0.rightHandleX!;
  1333→    const p1y = p0.rightHandleY ?? p0.y;
  1334→    const p2x = p3.leftHandleX!;
  1335→    const p2y = p3.leftHandleY ?? p3.y;
  1336→
  1337→    // Find t parameter for given x value using Newton-Raphson iteration
  1338→    let t = (value - p0.x) / (p3.x - p0.x); // Initial guess
  1339→
  1340→    // Newton-Raphson iterations to find t where B_x(t) = value
  1341→    for (let iter = 0; iter < 10; iter++) {
  1342→      const bx = cubicBezier(p0.x, p1x, p2x, p3.x, t);
  1343→      const bxDerivative = cubicBezierDerivative(p0.x, p1x, p2x, p3.x, t);
  1344→
  1345→      if (Math.abs(bxDerivative) < 1e-10) break;
  1346→
  1347→      const newT = t - (bx - value) / bxDerivative;
  1348→      if (Math.abs(newT - t) < 1e-10) break;
  1349→      t = Math.max(0, Math.min(1, newT));
  1350→    }
  1351→
  1352→    // Calculate y using the found t parameter
  1353→    return cubicBezier(p0.y, p1y, p2y, p3.y, t);
  1354→  } else {
  1355→    // Smooth interpolation using Catmull-Rom spline
  1356→    // This provides smoother curves than linear interpolation
  1357→    const t = (value - p0.x) / (p3.x - p0.x);
  1358→
  1359→    // Get neighboring points for spline calculation
  1360→    const pMinus1 = lowerIndex > 0 ? sortedPoints[lowerIndex - 1] : p0;
  1361→    const p4 = lowerIndex + 2 < sortedPoints.length ? sortedPoints[lowerIndex + 2] : p3;
  1362→
  1363→    // Catmull-Rom spline interpolation
  1364→    return catmullRomSpline(pMinus1.y, p0.y, p3.y, p4.y, t);
  1365→  }
  1366→}
  1367→
  1368→/**
  1369→ * Cubic Bezier curve evaluation: B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3
  1370→ */
  1371→function cubicBezier(p0: number, p1: number, p2: number, p3: number, t: number): number {
  1372→  const mt = 1 - t;
  1373→  const mt2 = mt * mt;
  1374→  const mt3 = mt2 * mt;
  1375→  const t2 = t * t;
  1376→  const t3 = t2 * t;
  1377→  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
  1378→}
  1379→
  1380→/**
  1381→ * Cubic Bezier derivative: B'(t) = 3(1-t)²(P1-P0) + 6(1-t)t(P2-P1) + 3t²(P3-P2)
  1382→ */
  1383→function cubicBezierDerivative(p0: number, p1: number, p2: number, p3: number, t: number): number {
  1384→  const mt = 1 - t;
  1385→  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
  1386→}
  1387→
  1388→/**
  1389→ * Catmull-Rom spline interpolation for smooth curves without explicit handles
  1390→ */
  1391→function catmullRomSpline(p0: number, p1: number, p2: number, p3: number, t: number): number {
  1392→  const t2 = t * t;
  1393→  const t3 = t2 * t;
  1394→
  1395→  // Catmull-Rom coefficients with tension = 0.5
  1396→  const a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;
  1397→  const b = p0 - 2.5 * p1 + 2 * p2 - 0.5 * p3;
  1398→  const c = -0.5 * p0 + 0.5 * p2;
  1399→  const d = p1;
  1400→
  1401→  return a * t3 + b * t2 + c * t + d;
  1402→}
  1403→
  1404→/**
  1405→ * Calculate standardized score (0-10 normalized)
  1406→ */
  1407→export function standardizeScore(score: number, maxScore: number): number {
  1408→  return (score / maxScore) * 10;
  1409→}
  1410→
  1411→/**
  1412→ * Determine quality tier based on score
  1413→ */
  1414→export function getQualityTier(score: number, maxScore: number = 10): QualityTier {
  1415→  const normalized = (score / maxScore) * 100;
  1416→
  1417→  if (normalized >= 90) return 'ideal';
  1418→  if (normalized >= 70) return 'excellent';
  1419→  if (normalized >= 50) return 'good';
  1420→  return 'below_average';
  1421→}
  1422→
  1423→/**
  1424→ * Determine severity level based on score
  1425→ */
  1426→export function getSeverityLevel(score: number, maxScore: number = 10): SeverityLevel {
  1427→  const normalized = (score / maxScore) * 100;
  1428→
  1429→  if (normalized >= 85) return 'optimal';
  1430→  if (normalized >= 70) return 'minor';
  1431→  if (normalized >= 50) return 'moderate';
  1432→  if (normalized >= 30) return 'major';
  1433→  if (normalized >= 15) return 'severe';
  1434→  return 'extremely_severe';
  1435→}
  1436→
  1437→/**
  1438→ * Calculate deviation description
  1439→ */
  1440→export function getDeviationDescription(
  1441→  value: number,
  1442→  idealMin: number,
  1443→  idealMax: number,
  1444→  unit: MeasurementUnit
  1445→): { deviation: number; direction: 'above' | 'below' | 'within'; description: string } {
  1446→  if (value >= idealMin && value <= idealMax) {
  1447→    return { deviation: 0, direction: 'within', description: 'within ideal range' };
  1448→  }
  1449→
  1450→  const unitLabel = getUnitLabel(unit);
  1451→
  1452→  if (value < idealMin) {
  1453→    const dev = idealMin - value;
  1454→    return {
  1455→      deviation: dev,
  1456→      direction: 'below',
  1457→      description: `${dev.toFixed(2)}${unitLabel} below ideal`,
  1458→    };
  1459→  }
  1460→
  1461→  const dev = value - idealMax;
  1462→  return {
  1463→    deviation: dev,
  1464→    direction: 'above',
  1465→    description: `${dev.toFixed(2)}${unitLabel} above ideal`,
  1466→  };
  1467→}
  1468→
  1469→function getUnitLabel(unit: MeasurementUnit): string {
  1470→  switch (unit) {
  1471→    case 'ratio': return 'x';
  1472→    case 'percent': return '%';
  1473→    case 'degrees': return '°';
  1474→    case 'mm': return 'mm';
  1475→    default: return '';
  1476→  }
  1477→}
  1478→
  1479→// ============================================
  1480→// MEASUREMENT CALCULATION UTILITIES
  1481→// ============================================
  1482→
  1483→/**
  1484→ * Calculate distance between two points
  1485→ */
  1486→export function distance(p1: Point, p2: Point): number {
  1487→  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
  1488→}
  1489→
  1490→/**
  1491→ * Calculate angle at vertex point (in degrees)
  1492→ */
  1493→export function calculateAngle(p1: Point, vertex: Point, p2: Point): number {
  1494→  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
  1495→  const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };
  1496→
  1497→  const dot = v1.x * v2.x + v1.y * v2.y;
  1498→  const cross = v1.x * v2.y - v1.y * v2.x;
  1499→
  1500→  const angle = Math.atan2(cross, dot) * (180 / Math.PI);
  1501→  return Math.abs(angle);
  1502→}
  1503→
  1504→/**
  1505→ * Calculate perpendicular distance from point to line (signed)
  1506→ */
  1507→export function perpendicularDistance(
  1508→  point: Point,
  1509→  lineStart: Point,
  1510→  lineEnd: Point
  1511→): number {
  1512→  const A = point.x - lineStart.x;
  1513→  const B = point.y - lineStart.y;
  1514→  const C = lineEnd.x - lineStart.x;
  1515→  const D = lineEnd.y - lineStart.y;
  1516→
  1517→  const dot = A * C + B * D;
  1518→  const lenSq = C * C + D * D;
  1519→  const param = lenSq !== 0 ? dot / lenSq : -1;
  1520→
  1521→  let xx: number, yy: number;
  1522→
  1523→  if (param < 0) {
  1524→    xx = lineStart.x;
  1525→    yy = lineStart.y;
  1526→  } else if (param > 1) {
  1527→    xx = lineEnd.x;
  1528→    yy = lineEnd.y;
  1529→  } else {
  1530→    xx = lineStart.x + param * C;
  1531→    yy = lineStart.y + param * D;
  1532→  }
  1533→
  1534→  const dx = point.x - xx;
  1535→  const dy = point.y - yy;
  1536→
  1537→  const sign =
  1538→    (lineEnd.y - lineStart.y) * point.x -
  1539→      (lineEnd.x - lineStart.x) * point.y +
  1540→      lineEnd.x * lineStart.y -
  1541→      lineEnd.y * lineStart.x >=
  1542→    0
  1543→      ? 1
  1544→      : -1;
  1545→
  1546→  return sign * Math.sqrt(dx * dx + dy * dy);
  1547→}
  1548→
  1549→/**
  1550→ * Helper to get landmark by ID
  1551→ */
  1552→function getLandmark(landmarks: LandmarkPoint[], id: string): Point | null {
  1553→  const lm = landmarks.find((l) => l.id === id);
  1554→  return lm ? { x: lm.x, y: lm.y } : null;
  1555→}
  1556→
  1557→// ============================================
  1558→// SCORE A SINGLE MEASUREMENT
  1559→// ============================================
  1560→
  1561→/**
  1562→ * Calculate complete score result for a measurement
  1563→ */
  1564→export function scoreMeasurement(
  1565→  metricId: string,
  1566→  value: number
  1567→): FaceIQScoreResult | null {
  1568→  const config = FACEIQ_METRICS[metricId];
  1569→  if (!config) return null;
  1570→
  1571→  const score = calculateFaceIQScore(value, config);
  1572→  const standardizedScore = standardizeScore(score, config.maxScore);
  1573→  const qualityTier = getQualityTier(score, config.maxScore);
  1574→  const severity = getSeverityLevel(score, config.maxScore);
  1575→  const { deviation, direction, description } = getDeviationDescription(
  1576→    value,
  1577→    config.idealMin,
  1578→    config.idealMax,
  1579→    config.unit
  1580→  );
  1581→
  1582→  return {
  1583→    metricId,
  1584→    name: config.name,
  1585→    value,
  1586→    score,
  1587→    standardizedScore,
  1588→    qualityTier,
  1589→    severity,
  1590→    idealMin: config.idealMin,
  1591→    idealMax: config.idealMax,
  1592→    deviation,
  1593→    deviationDirection: direction,
  1594→    unit: config.unit,
  1595→    category: config.category,
  1596→  };
  1597→}
  1598→
  1599→// ============================================
  1600→// FRONT PROFILE ANALYSIS
  1601→// ============================================
  1602→
  1603→export interface FrontProfileResults {
  1604→  measurements: FaceIQScoreResult[];
  1605→  overallScore: number;
  1606→  standardizedScore: number;
  1607→  qualityTier: QualityTier;
  1608→  categoryScores: Record<string, number>;
  1609→}
  1610→
  1611→/**
  1612→ * Calculate all front profile measurements from landmarks
  1613→ */
  1614→export function analyzeFrontProfile(
  1615→  landmarks: LandmarkPoint[],
  1616→  gender: 'male' | 'female' = 'male'
  1617→): FrontProfileResults {
  1618→  const measurements: FaceIQScoreResult[] = [];
  1619→
  1620→  // Helper to add measurement if landmarks available
  1621→  const addMeasurement = (metricId: string, value: number | null) => {
  1622→    if (value !== null) {
  1623→      const result = scoreMeasurement(metricId, value);
  1624→      if (result) measurements.push(result);
  1625→    }
  1626→  };
  1627→
  1628→  // Get key landmarks
  1629→  const trichion = getLandmark(landmarks, 'trichion');
  1630→  const nasalBase = getLandmark(landmarks, 'nasal_base');
  1631→  const subnasale = getLandmark(landmarks, 'subnasale');
  1632→  const menton = getLandmark(landmarks, 'menton');
  1633→  const leftZygion = getLandmark(landmarks, 'left_zygion');
  1634→  const rightZygion = getLandmark(landmarks, 'right_zygion');
  1635→  const leftGonion = getLandmark(landmarks, 'left_gonion_inferior');
  1636→  const rightGonion = getLandmark(landmarks, 'right_gonion_inferior');
  1637→  const leftPupil = getLandmark(landmarks, 'left_pupila');
  1638→  const rightPupil = getLandmark(landmarks, 'right_pupila');
  1639→  const leftCanthusM = getLandmark(landmarks, 'left_canthus_medialis');
  1640→  const leftCanthusL = getLandmark(landmarks, 'left_canthus_lateralis');
  1641→  const rightCanthusM = getLandmark(landmarks, 'right_canthus_medialis');
  1642→  const rightCanthusL = getLandmark(landmarks, 'right_canthus_lateralis');
  1643→  const leftAlaNasi = getLandmark(landmarks, 'left_ala_nasi');
  1644→  const rightAlaNasi = getLandmark(landmarks, 'right_ala_nasi');
  1645→  const leftCheilion = getLandmark(landmarks, 'left_cheilion');
  1646→  const rightCheilion = getLandmark(landmarks, 'right_cheilion');
  1647→  const labraleSuperius = getLandmark(landmarks, 'labrale_superius');
  1648→  const labraleInferius = getLandmark(landmarks, 'labrale_inferius');
  1649→
  1650→  // FACIAL THIRDS
  1651→  if (trichion && nasalBase && subnasale && menton) {
  1652→    const totalHeight = distance(trichion, menton);
  1653→    if (totalHeight > 0) {
  1654→      const upperThird = (distance(trichion, nasalBase) / totalHeight) * 100;
  1655→      const middleThird = (distance(nasalBase, subnasale) / totalHeight) * 100;
  1656→      const lowerThird = (distance(subnasale, menton) / totalHeight) * 100;
  1657→
  1658→      addMeasurement('upperThirdProportion', upperThird);
  1659→      addMeasurement('middleThirdProportion', middleThird);
  1660→      addMeasurement('lowerThirdProportion', lowerThird);
  1661→    }
  1662→  }
  1663→
  1664→  // FACE WIDTH TO HEIGHT RATIO (FWHR)
  1665→  if (leftZygion && rightZygion && nasalBase && labraleSuperius) {
  1666→    const bizygomaticWidth = distance(leftZygion, rightZygion);
  1667→    const upperFaceHeight = distance(nasalBase, labraleSuperius);
  1668→    if (upperFaceHeight > 0) {
  1669→      addMeasurement('faceWidthToHeight', bizygomaticWidth / upperFaceHeight);
  1670→    }
  1671→  }
  1672→
  1673→  // TOTAL FACIAL WIDTH TO HEIGHT
  1674→  if (leftZygion && rightZygion && trichion && menton) {
  1675→    const cheekWidth = distance(leftZygion, rightZygion);
  1676→    const totalHeight = distance(trichion, menton);
  1677→    if (cheekWidth > 0) {
  1678→      addMeasurement('totalFacialWidthToHeight', totalHeight / cheekWidth);
  1679→    }
  1680→  }
  1681→
  1682→  // JAW WIDTH RATIO
  1683→  if (leftGonion && rightGonion && leftZygion && rightZygion) {
  1684→    const bigonialWidth = distance(leftGonion, rightGonion);
  1685→    const bizygomaticWidth = distance(leftZygion, rightZygion);
  1686→    if (bizygomaticWidth > 0) {
  1687→      const ratio = bigonialWidth / bizygomaticWidth;
  1688→      addMeasurement('jawWidthRatio', ratio);
  1689→      addMeasurement('bigonialWidth', ratio * 100);
  1690→    }
  1691→  }
  1692→
  1693→  // CANTHAL TILT
  1694→  if (leftCanthusM && leftCanthusL) {
  1695→    const deltaY = leftCanthusM.y - leftCanthusL.y;
  1696→    const deltaX = leftCanthusL.x - leftCanthusM.x;
  1697→    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
  1698→    addMeasurement('lateralCanthalTilt', angle);
  1699→  }
  1700→
  1701→  // EYE ASPECT RATIO
  1702→  if (leftCanthusM && leftCanthusL) {
  1703→    const leftPalpSup = getLandmark(landmarks, 'left_palpebra_superior');
  1704→    const leftPalpInf = getLandmark(landmarks, 'left_palpebra_inferior');
  1705→    if (leftPalpSup && leftPalpInf) {
  1706→      const eyeWidth = distance(leftCanthusM, leftCanthusL);
  1707→      const eyeHeight = distance(leftPalpSup, leftPalpInf);
  1708→      if (eyeWidth > 0) {
  1709→        addMeasurement('eyeAspectRatio', eyeHeight / eyeWidth);
  1710→      }
  1711→    }
  1712→  }
  1713→
  1714→  // EYE SEPARATION RATIO
  1715→  if (leftCanthusM && rightCanthusM && leftZygion && rightZygion) {
  1716→    const intercanthal = distance(leftCanthusM, rightCanthusM);
  1717→    const bizygomatic = distance(leftZygion, rightZygion);
  1718→    if (bizygomatic > 0) {
  1719→      addMeasurement('eyeSeparationRatio', intercanthal / bizygomatic);
  1720→    }
  1721→  }
  1722→
  1723→  // IPD RATIO
  1724→  if (leftPupil && rightPupil && leftZygion && rightZygion) {
  1725→    const ipd = distance(leftPupil, rightPupil);
  1726→    const bizygomatic = distance(leftZygion, rightZygion);
  1727→    if (bizygomatic > 0) {
  1728→      addMeasurement('interpupillaryRatio', (ipd / bizygomatic) * 100);
  1729→    }
  1730→  }
  1731→
  1732→  // ONE EYE APART TEST
  1733→  if (leftCanthusM && rightCanthusM && leftCanthusL) {
  1734→    const intercanthal = distance(leftCanthusM, rightCanthusM);
  1735→    const eyeWidth = distance(leftCanthusM, leftCanthusL);
  1736→    if (eyeWidth > 0) {
  1737→      addMeasurement('oneEyeApartTest', intercanthal / eyeWidth);
  1738→    }
  1739→  }
  1740→
  1741→  // NASAL INDEX
  1742→  if (leftAlaNasi && rightAlaNasi && nasalBase && subnasale) {
  1743→    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);
  1744→    const nasalHeight = distance(nasalBase, subnasale);
  1745→    if (nasalHeight > 0) {
  1746→      addMeasurement('nasalIndex', (nasalWidth / nasalHeight) * 100);
  1747→    }
  1748→  }
  1749→
  1750→  // INTERCANTHAL-NASAL WIDTH RATIO
  1751→  if (leftCanthusM && rightCanthusM && leftAlaNasi && rightAlaNasi) {
  1752→    const intercanthal = distance(leftCanthusM, rightCanthusM);
  1753→    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);
  1754→    if (nasalWidth > 0) {
  1755→      addMeasurement('intercanthalNasalRatio', intercanthal / nasalWidth);
  1756→    }
  1757→  }
  1758→
  1759→  // MOUTH TO NOSE RATIO
  1760→  if (leftCheilion && rightCheilion && leftAlaNasi && rightAlaNasi) {
  1761→    const mouthWidth = distance(leftCheilion, rightCheilion);
  1762→    const nasalWidth = distance(leftAlaNasi, rightAlaNasi);
  1763→    if (nasalWidth > 0) {
  1764→      addMeasurement('mouthWidthToNoseRatio', mouthWidth / nasalWidth);
  1765→    }
  1766→  }
  1767→
  1768→  // IPD TO MOUTH WIDTH RATIO
  1769→  if (leftPupil && rightPupil && leftCheilion && rightCheilion) {
  1770→    const ipd = distance(leftPupil, rightPupil);
  1771→    const mouthWidth = distance(leftCheilion, rightCheilion);
  1772→    if (ipd > 0) {
  1773→      addMeasurement('interpupillaryMouthWidthRatio', mouthWidth / ipd);
  1774→    }
  1775→  }
  1776→
  1777→  // LIP RATIO
  1778→  if (labraleSuperius && labraleInferius && subnasale) {
  1779→    const mouthMiddle = getLandmark(landmarks, 'mouth_middle');
  1780→    if (mouthMiddle) {
  1781→      const upperLipHeight = distance(subnasale, labraleSuperius);
  1782→      const lowerLipHeight = distance(mouthMiddle, labraleInferius);
  1783→      if (upperLipHeight > 0) {
  1784→        addMeasurement('lowerToUpperLipRatio', lowerLipHeight / upperLipHeight);
  1785→      }
  1786→    }
  1787→  }
  1788→
  1789→  // MIDFACE RATIO
  1790→  if (leftZygion && rightZygion && nasalBase && subnasale) {
  1791→    const midfaceWidth = distance(leftZygion, rightZygion);
  1792→    const midfaceHeight = distance(nasalBase, subnasale);
  1793→    if (midfaceHeight > 0) {
  1794→      addMeasurement('midfaceRatio', midfaceWidth / midfaceHeight / 10); // Normalized
  1795→    }
  1796→  }
  1797→
  1798→  // Calculate category scores
  1799→  const categoryScores: Record<string, { total: number; count: number }> = {};
  1800→  for (const m of measurements) {
  1801→    if (!categoryScores[m.category]) {
  1802→      categoryScores[m.category] = { total: 0, count: 0 };
  1803→    }
  1804→    categoryScores[m.category].total += m.standardizedScore;
  1805→    categoryScores[m.category].count++;
  1806→  }
  1807→
  1808→  const categoryAvg: Record<string, number> = {};
  1809→  for (const [cat, data] of Object.entries(categoryScores)) {
  1810→    categoryAvg[cat] = data.count > 0 ? data.total / data.count : 0;
  1811→  }
  1812→
  1813→  // Calculate overall score (weighted average)
  1814→  let totalWeight = 0;
  1815→  let weightedSum = 0;
  1816→  for (const m of measurements) {
  1817→    const config = FACEIQ_METRICS[m.metricId];
  1818→    if (config) {
  1819→      weightedSum += m.standardizedScore * config.weight;
  1820→      totalWeight += config.weight;
  1821→    }
  1822→  }
  1823→
  1824→  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;
  1825→  const standardizedScore = overallScore;
  1826→
  1827→  return {
  1828→    measurements,
  1829→    overallScore,
  1830→    standardizedScore,
  1831→    qualityTier: getQualityTier(overallScore),
  1832→    categoryScores: categoryAvg,
  1833→  };
  1834→}
  1835→
  1836→// ============================================
  1837→// SIDE PROFILE ANALYSIS
  1838→// ============================================
  1839→
  1840→export interface SideProfileResults {
  1841→  measurements: FaceIQScoreResult[];
  1842→  overallScore: number;
  1843→  standardizedScore: number;
  1844→  qualityTier: QualityTier;
  1845→  categoryScores: Record<string, number>;
  1846→}
  1847→
  1848→/**
  1849→ * Calculate all side profile measurements from landmarks
  1850→ */
  1851→export function analyzeSideProfile(
  1852→  landmarks: LandmarkPoint[],
  1853→  gender: 'male' | 'female' = 'male'
  1854→): SideProfileResults {
  1855→  const measurements: FaceIQScoreResult[] = [];
  1856→
  1857→  const addMeasurement = (metricId: string, value: number | null) => {
  1858→    if (value !== null) {
  1859→      const result = scoreMeasurement(metricId, value);
  1860→      if (result) measurements.push(result);
  1861→    }
  1862→  };
  1863→
  1864→  // Get key landmarks
  1865→  const glabella = getLandmark(landmarks, 'glabella');
  1866→  const nasion = getLandmark(landmarks, 'nasion');
  1867→  const rhinion = getLandmark(landmarks, 'rhinion');
  1868→  const pronasale = getLandmark(landmarks, 'pronasale');
  1869→  const columella = getLandmark(landmarks, 'columella');
  1870→  const subnasale = getLandmark(landmarks, 'subnasale');
  1871→  const labraleSuperius = getLandmark(landmarks, 'labraleSuperius');
  1872→  const labraleInferius = getLandmark(landmarks, 'labraleInferius');
  1873→  const sublabiale = getLandmark(landmarks, 'sublabiale');
  1874→  const pogonion = getLandmark(landmarks, 'pogonion');
  1875→  const menton = getLandmark(landmarks, 'menton');
  1876→  const tragus = getLandmark(landmarks, 'tragus');
  1877→  const gonionBottom = getLandmark(landmarks, 'gonionBottom');
  1878→  const cervicalPoint = getLandmark(landmarks, 'cervicalPoint');
  1879→  const orbitale = getLandmark(landmarks, 'orbitale');
  1880→  const porion = getLandmark(landmarks, 'porion');
  1881→
  1882→  // GONIAL ANGLE
  1883→  if (tragus && gonionBottom && menton) {
  1884→    const angle = calculateAngle(tragus, gonionBottom, menton);
  1885→    addMeasurement('gonialAngle', angle);
  1886→  }
  1887→
  1888→  // NASOLABIAL ANGLE
  1889→  if (columella && subnasale && labraleSuperius) {
  1890→    const angle = calculateAngle(columella, subnasale, labraleSuperius);
  1891→    addMeasurement('nasolabialAngle', angle);
  1892→  }
  1893→
  1894→  // NASOFRONTAL ANGLE
  1895→  if (glabella && nasion && rhinion) {
  1896→    const angle = calculateAngle(glabella, nasion, rhinion);
  1897→    addMeasurement('nasofrontalAngle', angle);
  1898→  }
  1899→
  1900→  // MENTOLABIAL ANGLE
  1901→  if (labraleInferius && sublabiale && pogonion) {
  1902→    const angle = calculateAngle(labraleInferius, sublabiale, pogonion);
  1903→    addMeasurement('mentolabialAngle', angle);
  1904→  }
  1905→
  1906→  // E-LINE MEASUREMENTS
  1907→  if (pronasale && pogonion && labraleSuperius && labraleInferius) {
  1908→    const upperLipDist = perpendicularDistance(labraleSuperius, pronasale, pogonion);
  1909→    const lowerLipDist = perpendicularDistance(labraleInferius, pronasale, pogonion);
  1910→    addMeasurement('eLineUpperLip', upperLipDist);
  1911→    addMeasurement('eLineLowerLip', lowerLipDist);
  1912→  }
  1913→
  1914→  // NASOMENTAL ANGLE
  1915→  if (nasion && pronasale && pogonion) {
  1916→    const angle = calculateAngle(nasion, pronasale, pogonion);
  1917→    addMeasurement('nasomentaAngle', angle);
  1918→  }
  1919→
  1920→  // FACIAL CONVEXITY (GLABELLA)
  1921→  if (glabella && subnasale && pogonion) {
  1922→    const angle = calculateAngle(glabella, subnasale, pogonion);
  1923→    addMeasurement('facialConvexityGlabella', angle);
  1924→  }
  1925→
  1926→  // FACIAL CONVEXITY (NASION)
  1927→  if (nasion && subnasale && pogonion) {
  1928→    const angle = calculateAngle(nasion, subnasale, pogonion);
  1929→    addMeasurement('facialConvexityNasion', angle);
  1930→  }
  1931→
  1932→  // TOTAL FACIAL CONVEXITY
  1933→  if (glabella && pronasale && pogonion) {
  1934→    const angle = calculateAngle(glabella, pronasale, pogonion);
  1935→    addMeasurement('totalFacialConvexity', angle);
  1936→  }
  1937→
  1938→  // SUBMENTAL CERVICAL ANGLE
  1939→  if (menton && cervicalPoint && pogonion) {
  1940→    const neckPoint = getLandmark(landmarks, 'neckPoint');
  1941→    if (neckPoint) {
  1942→      const angle = calculateAngle(pogonion, menton, neckPoint);
  1943→      addMeasurement('submentalCervicalAngle', angle);
  1944→    }
  1945→  }
  1946→
  1947→  // NASAL PROJECTION (Goode ratio)
  1948→  if (pronasale && subnasale && nasion) {
  1949→    const projection = distance(pronasale, subnasale);
  1950→    const nasalLength = distance(nasion, pronasale);
  1951→    if (nasalLength > 0) {
  1952→      addMeasurement('nasalProjection', projection / nasalLength);
  1953→    }
  1954→  }
  1955→
  1956→  // NASOFACIAL ANGLE
  1957→  if (nasion && pronasale && pogonion) {
  1958→    // Angle between nose dorsum and facial plane
  1959→    const nasalDorsum = { x: pronasale.x - nasion.x, y: pronasale.y - nasion.y };
  1960→    const facialPlane = { x: pogonion.x - nasion.x, y: pogonion.y - nasion.y };
  1961→
  1962→    const dot = nasalDorsum.x * facialPlane.x + nasalDorsum.y * facialPlane.y;
  1963→    const mag1 = Math.sqrt(nasalDorsum.x ** 2 + nasalDorsum.y ** 2);
  1964→    const mag2 = Math.sqrt(facialPlane.x ** 2 + facialPlane.y ** 2);
  1965→
  1966→    if (mag1 > 0 && mag2 > 0) {
  1967→      const angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
  1968→      addMeasurement('nasofacialAngle', angle);
  1969→    }
  1970→  }
  1971→
  1972→  // MANDIBULAR PLANE ANGLE (using Frankfort horizontal)
  1973→  if (porion && orbitale && gonionBottom && menton) {
  1974→    // Frankfort horizontal is porion to orbitale
  1975→    // Mandibular plane is gonion to menton
  1976→    const fhAngle = Math.atan2(orbitale.y - porion.y, orbitale.x - porion.x);
  1977→    const mpAngle = Math.atan2(menton.y - gonionBottom.y, menton.x - gonionBottom.x);
  1978→    const angle = Math.abs(fhAngle - mpAngle) * (180 / Math.PI);
  1979→    addMeasurement('mandibularPlaneAngle', angle);
  1980→  }
  1981→
  1982→  // CHIN PROJECTION
  1983→  if (pogonion && subnasale) {
  1984→    // Distance from pogonion to vertical line through subnasale
  1985→    const projection = pogonion.x - subnasale.x;
  1986→    addMeasurement('chinProjection', projection);
  1987→  }
  1988→
  1989→  // Calculate category scores
  1990→  const categoryScores: Record<string, { total: number; count: number }> = {};
  1991→  for (const m of measurements) {
  1992→    if (!categoryScores[m.category]) {
  1993→      categoryScores[m.category] = { total: 0, count: 0 };
  1994→    }
  1995→    categoryScores[m.category].total += m.standardizedScore;
  1996→    categoryScores[m.category].count++;
  1997→  }
  1998→
  1999→  const categoryAvg: Record<string, number> = {};
  2000→  for (const [cat, data] of Object.entries(categoryScores)) {
  2001→    categoryAvg[cat] = data.count > 0 ? data.total / data.count : 0;
  2002→  }
  2003→
  2004→  // Calculate overall score
  2005→  let totalWeight = 0;
  2006→  let weightedSum = 0;
  2007→  for (const m of measurements) {
  2008→    const config = FACEIQ_METRICS[m.metricId];
  2009→    if (config) {
  2010→      weightedSum += m.standardizedScore * config.weight;
  2011→      totalWeight += config.weight;
  2012→    }
  2013→  }
  2014→
  2015→  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;
  2016→
  2017→  return {
  2018→    measurements,
  2019→    overallScore,
  2020→    standardizedScore: overallScore,
  2021→    qualityTier: getQualityTier(overallScore),
  2022→    categoryScores: categoryAvg,
  2023→  };
  2024→}
  2025→
  2026→// ============================================
  2027→// COMPLETE HARMONY ANALYSIS
  2028→// ============================================
  2029→
  2030→/**
  2031→ * Run complete facial harmony analysis
  2032→ */
  2033→export function analyzeHarmony(
  2034→  frontLandmarks: LandmarkPoint[],
  2035→  sideLandmarks: LandmarkPoint[],
  2036→  gender: 'male' | 'female' = 'male'
  2037→): HarmonyAnalysis {
  2038→  const frontResults = analyzeFrontProfile(frontLandmarks, gender);
  2039→  const sideResults = analyzeSideProfile(sideLandmarks, gender);
  2040→
  2041→  const allMeasurements = [...frontResults.measurements, ...sideResults.measurements];
  2042→
  2043→  // Combined category scores
  2044→  const allCategories: Record<string, { total: number; count: number }> = {};
  2045→  for (const m of allMeasurements) {
  2046→    if (!allCategories[m.category]) {
  2047→      allCategories[m.category] = { total: 0, count: 0 };
  2048→    }
  2049→    allCategories[m.category].total += m.standardizedScore;
  2050→    allCategories[m.category].count++;
  2051→  }
  2052→
  2053→  const categoryScores: Record<string, number> = {};
  2054→  for (const [cat, data] of Object.entries(allCategories)) {
  2055→    categoryScores[cat] = data.count > 0 ? data.total / data.count : 0;
  2056→  }
  2057→
  2058→  // Overall weighted score
  2059→  let totalWeight = 0;
  2060→  let weightedSum = 0;
  2061→  for (const m of allMeasurements) {
  2062→    const config = FACEIQ_METRICS[m.metricId];
  2063→    if (config) {
  2064→      weightedSum += m.standardizedScore * config.weight;
  2065→      totalWeight += config.weight;
  2066→    }
  2067→  }
  2068→
  2069→  const overallScore = totalWeight > 0 ? weightedSum / totalWeight : 0;
  2070→
  2071→  // Identify flaws (below average measurements)
  2072→  const flaws: FlawAssessment[] = allMeasurements
  2073→    .filter((m) => m.severity !== 'optimal' && m.severity !== 'minor')
  2074→    .map((m) => ({
  2075→      category: m.category,
  2076→      metricId: m.metricId,
  2077→      metricName: m.name,
  2078→      severity: m.severity,
  2079→      deviation: `${m.deviation.toFixed(2)} ${m.deviationDirection} ideal`,
  2080→      reasoning: `${m.name} is outside the ideal range`,
  2081→      confidence: m.severity === 'extremely_severe' || m.severity === 'severe'
  2082→        ? 'confirmed' as const
  2083→        : 'likely' as const,
  2084→    }))
  2085→    .sort((a, b) => {
  2086→      const severityOrder = { extremely_severe: 0, severe: 1, major: 2, moderate: 3 };
  2087→      return (severityOrder[a.severity as keyof typeof severityOrder] ?? 4) -
  2088→             (severityOrder[b.severity as keyof typeof severityOrder] ?? 4);
  2089→    });
  2090→
  2091→  // Identify strengths (ideal measurements)
  2092→  const strengths: StrengthAssessment[] = allMeasurements
  2093→    .filter((m) => m.qualityTier === 'ideal' || m.qualityTier === 'excellent')
  2094→    .map((m) => ({
  2095→      category: m.category,
  2096→      metricId: m.metricId,
  2097→      metricName: m.name,
  2098→      qualityTier: m.qualityTier,
  2099→      value: m.value,
  2100→      reasoning: `${m.name} is within the ${m.qualityTier} range`,
  2101→    }));
  2102→
  2103→  // Calculate percentile (based on population stats)
  2104→  const percentile = calculateHarmonyPercentile(overallScore);
  2105→
  2106→  return {
  2107→    overallScore,
  2108→    standardizedScore: overallScore,
  2109→    qualityTier: getQualityTier(overallScore),
  2110→    percentile,
  2111→    frontScore: frontResults.overallScore,
  2112→    sideScore: sideResults.overallScore,
  2113→    categoryScores,
  2114→    measurements: allMeasurements,
  2115→    flaws,
  2116→    strengths,
  2117→  };
  2118→}
  2119→
  2120→/**
  2121→ * Calculate percentile from harmony score
  2122→ */
  2123→function calculateHarmonyPercentile(score: number): number {
  2124→  // Based on normal distribution with mean=5, stdDev=1.5
  2125→  const mean = 5;
  2126→  const stdDev = 1.5;
  2127→  const z = (score - mean) / stdDev;
  2128→  return normalCDF(z) * 100;
  2129→}
  2130→
  2131→/**
  2132→ * Standard normal CDF approximation
  2133→ */
  2134→function normalCDF(z: number): number {
  2135→  const a1 = 0.254829592;
  2136→  const a2 = -0.284496736;
  2137→  const a3 = 1.421413741;
  2138→  const a4 = -1.453152027;
  2139→  const a5 = 1.061405429;
  2140→  const p = 0.3275911;
  2141→
  2142→  const sign = z < 0 ? -1 : 1;
  2143→  const absZ = Math.abs(z) / Math.sqrt(2);
  2144→
  2145→  const t = 1.0 / (1.0 + p * absZ);
  2146→  const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-absZ * absZ);
  2147→
  2148→  return 0.5 * (1.0 + sign * y);
  2149→}
  2150→
  2151→// ============================================
  2152→// PSL RATING CONVERSION
  2153→// ============================================
  2154→
  2155→export interface PSLRating {
  2156→  score: number;
  2157→  tier: string;
  2158→  percentile: number;
  2159→  description: string;
  2160→}
  2161→
  2162→/**
  2163→ * Convert harmony score to PSL rating
  2164→ */
  2165→export function convertToPSL(harmonyScore: number): PSLRating {
  2166→  // Convert 0-10 harmony to 3.0-7.5 PSL range
  2167→  const psl = 3.0 + (harmonyScore / 10) * 4.5;
  2168→  const clampedPSL = Math.max(3.0, Math.min(7.5, psl));
  2169→
  2170→  let tier: string;
  2171→  let percentile: number;
  2172→
  2173→  if (clampedPSL >= 7.5) {
  2174→    tier = 'Top Model';
  2175→    percentile = 99.99;
  2176→  } else if (clampedPSL >= 7.0) {
  2177→    tier = 'Chad';
  2178→    percentile = 99.87;
  2179→  } else if (clampedPSL >= 6.5) {
  2180→    tier = 'Chadlite';
  2181→    percentile = 99.0;
  2182→  } else if (clampedPSL >= 6.0) {
  2183→    tier = 'High Tier Normie+';
  2184→    percentile = 97.25;
  2185→  } else if (clampedPSL >= 5.5) {
  2186→    tier = 'High Tier Normie';
  2187→    percentile = 90.0;
  2188→  } else if (clampedPSL >= 5.0) {
  2189→    tier = 'Mid Tier Normie+';
  2190→    percentile = 84.15;
  2191→  } else if (clampedPSL >= 4.5) {
  2192→    tier = 'Mid Tier Normie';
  2193→    percentile = 65.0;
  2194→  } else if (clampedPSL >= 4.0) {
  2195→    tier = 'Low Tier Normie';
  2196→    percentile = 50.0;
  2197→  } else if (clampedPSL >= 3.5) {
  2198→    tier = 'Below Average';
  2199→    percentile = 30.0;
  2200→  } else {
  2201→    tier = 'Subpar';
  2202→    percentile = 15.0;
  2203→  }
  2204→
  2205→  return {
  2206→    score: clampedPSL,
  2207→    tier,
  2208→    percentile,
  2209→    description: `${tier} (top ${(100 - percentile).toFixed(1)}%)`,
  2210→  };
  2211→}
  2212→
  2213→// ============================================
  2214→// EXPORTS FOR BACKWARD COMPATIBILITY
  2215→// ============================================
  2216→
  2217→export type { LandmarkPoint } from './landmarks';
  2218→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
