     1→/**
     2→ * Scoring Calculator
     3→ * Core scoring algorithm functions extracted from harmony-scoring.ts
     4→ *
     5→ * Features:
     6→ * - Exponential decay scoring with per-metric decay rates
     7→ * - Bezier curve custom scoring for non-linear measurements
     8→ * - Directional/Dimorphic scoring (polarity support)
     9→ * - Quality tiers and severity levels
    10→ */
    11→
    12→import {
    13→  Point,
    14→  QualityTier,
    15→  SeverityLevel,
    16→  MeasurementUnit,
    17→  MetricConfig,
    18→  CurvePoint,
    19→  FlawMapping,
    20→} from './types';
    21→import { BEZIER_CURVES } from '@/lib/bezier-curves';
    22→
    23→// ============================================
    24→// FLAW MAPPINGS
    25→// ============================================
    26→
    27→export const METRIC_FLAW_MAPPINGS: Record<string, FlawMapping[]> = {
    28→  anteriorFacialDepth: [
    29→    { category: 'Midface/Face Shape', flawName: 'Underprojected midface', confidence: 'confirmed', reasoning: 'The Anterior Facial Depth measurement is above the ideal range. This disrupts facial harmony by creating a sunken and unprominent appearance to the midface.' },
    30→  ],
    31→  bitemporalWidth: [
    32→    { category: 'Upper Third', flawName: 'Narrow forehead', confidence: 'confirmed', reasoning: 'Reduced bitemporal width indicates a narrower than ideal forehead relative to the cheekbones. This disrupts facial harmony by creating a compressed hairline and forehead, altering the overall shape of the face.' },
    33→  ],
    34→  cheekboneHeight: [
    35→    { category: 'Midface/Face Shape', flawName: 'Low-set cheekbones', confidence: 'confirmed', reasoning: 'Reduced cheekbone height indicates that the cheekbones are positioned lower than ideal. This disrupts facial harmony by creating an unpronounced appearance to the cheekbones and facial structure.' },
    36→  ],
    37→  cheekFullness: [
    38→    { category: 'Midface/Face Shape', flawName: 'Hollow/Gaunt midface', confidence: 'confirmed', reasoning: 'Reduced cheek fullness indicates volume loss or hollow cheeks. This disrupts facial harmony by creating a gaunt or aged appearance, particularly important in South Asian and East Asian beauty standards.' },
    39→  ],
    40→  eyeAspectRatio: [
    41→    { category: 'Eyes', flawName: 'Overly round eye shape', confidence: 'confirmed', reasoning: 'A reduced eye aspect ratio indicates overly narrow eyes relative to their height. This disrupts facial harmony by creating an overly surprised appearance and reducing angular definition.' },
    42→  ],
    43→  eyeSeparationRatio: [
    44→    { category: 'Eyes', flawName: 'Close-set eyes', confidence: 'confirmed', reasoning: 'Reduced eye separation indicates close-set eyes. This disrupts facial harmony by making the eye area appear too compressed.' },
    45→  ],
    46→  eyebrowLowSetedness: [
    47→    { category: 'Eyes', flawName: 'Medium-set eyebrows', confidence: 'confirmed', reasoning: 'Increased eyebrow low setedness indicates eyebrows that are positioned higher than ideal. This disrupts facial harmony by reducing the overall visual impact of the eyebrows and framing of the eyes.' },
    48→  ],
    49→  faceWidthToHeight: [
    50→    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A reduced face width to height ratio indicates an overly long midface relative to its height. This disrupts facial harmony by overemphasizing the middle of the face.' },
    51→  ],
    52→  facialDepthToHeight: [
    53→    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'Reduced facial depth to height ratio indicates insufficient mid-face projection relative to height. This disrupts facial harmony by creating the appearance of a flat midface.' },
    54→  ],
    55→  gonialAngle: [
    56→    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'A wider gonial angle indicates a softer, less defined jawline with reduced angularity. This disrupts facial harmony in the lower face.' },
    57→    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A wider gonial angle indicates a softer, less defined jawline with reduced angularity. This disrupts facial harmony by creating a narrow or pointed chin effect.' },
    58→  ],
    59→  holdawayHLine: [
    60→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'Decreased H-line indicates the lips are positioned too far in front of the line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },
    61→  ],
    62→  interiorMidfaceProjectionAngle: [
    63→    { category: 'Midface/Face Shape', flawName: 'Underprojected midface', confidence: 'confirmed', reasoning: 'The Interior Midface Projection Angle measurement is above the ideal range. This disrupts facial harmony by creating a sunken and unprominent appearance to the midface.' },
    64→  ],
    65→  ipsilateralAlarAngle: [
    66→    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A decreased ipsilateral alar angle indicates an overly narrow interior midface. This disrupts facial harmony by overemphasizing the middle of the face.' },
    67→  ],
    68→  jawFrontalAngle: [
    69→    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A narrower jaw frontal angle indicates a steeper jawline or overly wide chin. This disrupts facial harmony by creating a narrow or pointed chin effect.' },
    70→  ],
    71→  jawSlope: [
    72→    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'The Jaw Slope measurement is above the ideal range. This disrupts facial harmony in the lower face.' },
    73→  ],
    74→  lateralCanthalTilt: [
    75→    { category: 'Eyes', flawName: 'Insufficient eye tilt', confidence: 'confirmed', reasoning: 'A decreased lateral canthal tilt indicates insufficiently upturned eyes. This disrupts facial harmony by creating a less alert and youthful appearance.' },
    76→  ],
    77→  burstoneLowerLip: [
    78→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned excessively in front of the Burstone line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },
    79→  ],
    80→  eLineLowerLip: [
    81→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned too far in front of the E-line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },
    82→  ],
    83→  sLineLowerLip: [
    84→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned excessively in front of the S-line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },
    85→  ],
    86→  lowerThirdProportion: [
    87→    { category: 'Midface/Face Shape', flawName: 'Long upper jaw', confidence: 'confirmed', reasoning: 'The upper jaw is too long relative to lower jaw, possibly from a long upper jaw or short lower jaw, or a combination of both. This disrupts facial harmony by overemphasizing the upper jaw relative to the lower jaw.' },
    88→  ],
    89→  mandibularPlaneAngle: [
    90→    { category: 'Occlusion/Jaw Growth', flawName: 'Hyper-divergent jaw growth', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony by elongating the lower face.' },
    91→    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony in the lower face.' },
    92→    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony by creating a narrow or pointed chin effect.' },
    93→  ],
    94→  midfaceRatio: [
    95→    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A reduced midface ratio indicates an overly narrow interior midface relative to its height. This disrupts facial harmony by overemphasizing the middle of the face.' },
    96→    { category: 'Midface/Face Shape', flawName: 'Long upper jaw', confidence: 'confirmed', reasoning: 'A reduced midface ratio indicates an overly narrow interior midface relative to its height. This disrupts facial harmony by overemphasizing the upper jaw relative to the lower jaw.' },
    97→  ],
    98→  nasofacialAngle: [
    99→    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'A smaller nasofacial angle suggests reduced projection of the nose and midface region, or an overprojected chin. This disrupts facial harmony by creating the appearance of a flat midface.' },
   100→  ],
   101→  nasofrontalAngle: [
   102→    { category: 'Upper Third', flawName: 'Soft and weak brow ridge', confidence: 'confirmed', reasoning: 'An increased nasofrontal angle indicates reduced brow ridge prominence and angularity. This disrupts facial harmony by creating a less defined upper face.' },
   103→  ],
   104→  nasomentaAngle: [
   105→    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'A larger nasomental angle suggests reduced projection of the nose and midface region, or an overprojected chin. This disrupts facial harmony by creating the appearance of a flat midface.' },
   106→  ],
   107→  noseBridgeWidth: [
   108→    { category: 'Nose', flawName: 'Overly narrow nose bridge', confidence: 'confirmed', reasoning: 'The Nose Bridge to Nose Width measurement is above the ideal range. This disrupts facial harmony by creating an unbalanced nasal profile.' },
   109→  ],
   110→  orbitalVector: [
   111→    { category: 'Eyes', flawName: 'Sunken orbital region', confidence: 'confirmed', reasoning: 'A decreased orbital vector indicates insufficient projection and volume underneath the eye. This disrupts facial harmony due to the lacking volume underneath the eyes, reducing vibrancy and youthfulness.' },
   112→  ],
   113→  ramusToMandibleRatio: [
   114→    { category: 'Jaw Shape', flawName: 'Short ramus', confidence: 'confirmed', reasoning: 'A reduced ramus-to-mandible ratio indicates a shorter than ideal vertical jawbone (ramus) when compared to the mandible. This disrupts facial harmony by reducing jaw height and definition.' },
   115→  ],
   116→  submentalCervicalAngle: [
   117→    { category: 'Neck', flawName: 'Round neck region', confidence: 'confirmed', reasoning: 'An increased submental cervical angle indicates a round neck region, possibly from excess submental fat or tissue. This disrupts facial harmony by reducing neck definition.' },
   118→  ],
   119→  totalFacialWidthToHeight: [
   120→    { category: 'Midface/Face Shape', flawName: 'Overly long face shape', confidence: 'confirmed', reasoning: 'An increased total facial width to height ratio indicates an overly long face relative to its height. This disrupts facial harmony by creating a vertically stretched appearance to the face.' },
   121→  ],
   122→};
   123→
   124→// ============================================
   125→// CUSTOM BEZIER CURVES (Ethnicity-specific override)
   126→// ============================================
   127→
   128→export const METRIC_CUSTOM_CURVES: Record<string, CurvePoint[]> = {
   129→  faceWidthToHeight: [
   130→    { x: 1.49, y: 0, leftHandleX: 1.44, leftHandleY: 0, rightHandleX: 1.55, rightHandleY: 0 },
   131→    { x: 1.68, y: 1.05, leftHandleX: 1.62, leftHandleY: 0.36, rightHandleX: 1.71, rightHandleY: 1.58 },
   132→    { x: 1.77, y: 3.07, leftHandleX: 1.74, leftHandleY: 2.15, rightHandleX: 1.79, rightHandleY: 3.88 },
   133→    { x: 1.83, y: 5.83, leftHandleX: 1.8, leftHandleY: 4.64, rightHandleX: 1.84, rightHandleY: 6.85 },
   134→    { x: 1.89, y: 8.7, leftHandleX: 1.88, leftHandleY: 8.3, rightHandleX: 1.92, rightHandleY: 9.5 },
   135→    { x: 1.96, y: 10, leftHandleX: 1.96, leftHandleY: 10, rightHandleX: 1.96, rightHandleY: 10, fixed: true },
   136→    { x: 2, y: 10, leftHandleX: 2, leftHandleY: 10, rightHandleX: 2, rightHandleY: 10 },
   137→    { x: 2.07, y: 8.7, leftHandleX: 2.04, leftHandleY: 9.5, rightHandleX: 2.08, rightHandleY: 8.3 },
   138→    { x: 2.13, y: 5.83, leftHandleX: 2.12, leftHandleY: 6.85, rightHandleX: 2.16, rightHandleY: 4.64 },
   139→    { x: 2.19, y: 3.07, leftHandleX: 2.17, leftHandleY: 3.88, rightHandleX: 2.22, rightHandleY: 2.15 },
   140→    { x: 2.28, y: 1.05, leftHandleX: 2.25, leftHandleY: 1.58, rightHandleX: 2.34, rightHandleY: 0.36 },
   141→    { x: 2.47, y: 0, leftHandleX: 2.41, leftHandleY: 0, rightHandleX: 2.52, rightHandleY: 0 },
   142→  ],
   143→  lowerThirdProportion: [
   144→    { x: 25.6, y: 0, leftHandleX: 24.8, leftHandleY: 0, rightHandleX: 26.4, rightHandleY: 0 },
   145→    { x: 28.01, y: 1.58, leftHandleX: 27.23, leftHandleY: 0.53, rightHandleX: 28.27, rightHandleY: 1.97 },
   146→    { x: 28.83, y: 3.21, leftHandleX: 28.62, leftHandleY: 2.59, rightHandleX: 29.03, rightHandleY: 3.76 },
   147→    { x: 29.63, y: 5.85, leftHandleX: 29.38, leftHandleY: 4.64, rightHandleX: 29.84, rightHandleY: 6.61 },
   148→    { x: 30.27, y: 8.56, leftHandleX: 30.1, leftHandleY: 7.71, rightHandleX: 30.52, rightHandleY: 9.42 },
   149→    { x: 31, y: 10, leftHandleX: 30.88, leftHandleY: 10, rightHandleX: 31.13, rightHandleY: 10, fixed: true },
   150→    { x: 33.5, y: 10, leftHandleX: 33.38, leftHandleY: 10, rightHandleX: 33.63, rightHandleY: 10 },
   151→    { x: 34.23, y: 8.56, leftHandleX: 33.98, leftHandleY: 9.42, rightHandleX: 34.4, rightHandleY: 7.71 },
   152→    { x: 34.87, y: 5.85, leftHandleX: 34.66, leftHandleY: 6.61, rightHandleX: 35.12, rightHandleY: 4.64 },
   153→    { x: 35.67, y: 3.21, leftHandleX: 35.47, leftHandleY: 3.76, rightHandleX: 35.88, rightHandleY: 2.59 },
   154→    { x: 36.49, y: 1.58, leftHandleX: 36.23, leftHandleY: 1.97, rightHandleX: 37.27, rightHandleY: 0.53 },
   155→    { x: 38.9, y: 0, leftHandleX: 38.1, leftHandleY: 0, rightHandleX: 39.7, rightHandleY: 0 },
   156→  ],
   157→  eyeAspectRatio: [
   158→    { x: 1.44, y: 0, leftHandleX: 1.18, leftHandleY: 0, rightHandleX: 1.75, rightHandleY: 0.38 },
   159→    { x: 2.07, y: 1.66, leftHandleX: 1.96, leftHandleY: 1.08, rightHandleX: 2.24, rightHandleY: 2.63 },
   160→    { x: 2.42, y: 4.34, leftHandleX: 2.35, leftHandleY: 3.6, rightHandleX: 2.52, rightHandleY: 5.5 },
   161→    { x: 2.71, y: 7.96, leftHandleX: 2.65, leftHandleY: 7.13, rightHandleX: 2.8, rightHandleY: 9.08 },
   162→    { x: 3, y: 10, leftHandleX: 2.98, leftHandleY: 10, rightHandleX: 3.03, rightHandleY: 10, fixed: true },
   163→    { x: 3.5, y: 10, leftHandleX: 3.48, leftHandleY: 10, rightHandleX: 3.53, rightHandleY: 10 },
   164→    { x: 3.79, y: 7.96, leftHandleX: 3.7, leftHandleY: 9.08, rightHandleX: 3.85, rightHandleY: 7.13 },
   165→    { x: 4.08, y: 4.34, leftHandleX: 3.98, leftHandleY: 5.5, rightHandleX: 4.15, rightHandleY: 3.6 },
   166→    { x: 4.43, y: 1.66, leftHandleX: 4.26, leftHandleY: 2.63, rightHandleX: 4.54, rightHandleY: 1.08 },
   167→    { x: 5.06, y: 0, leftHandleX: 4.75, leftHandleY: 0.38, rightHandleX: 5.32, rightHandleY: 0 },
   168→  ],
   169→  // Note: Additional curves can be added from METRIC_CUSTOM_CURVES in harmony-scoring.ts
   170→};
   171→
   172→// ============================================
   173→// CORE SCORING FUNCTIONS
   174→// ============================================
   175→
   176→/**
   177→ * Exponential Decay Scoring Algorithm with Directional/Dimorphic Support
   178→ *
   179→ * Standard: score = maxScore * e^(-decayRate * deviation)
   180→ *
   181→ * Directional scoring (polarity):
   182→ * - 'higher_is_better': Values above safeFloor but below ideal get softZoneScore
   183→ *   Example: Canthal Tilt of 3 degrees is still positive/good, just not peak ideal (6-8 degrees)
   184→ * - 'lower_is_better': Values below safeCeiling but above ideal get softZoneScore
   185→ *   Example: Short philtrum is still attractive even if shorter than "ideal"
   186→ */
   187→export function calculateMetricScore(
   188→  value: number,
   189→  config: MetricConfig
   190→): number {
   191→  const {
   192→    id,
   193→    idealMin,
   194→    idealMax,
   195→    decayRate,
   196→    maxScore,
   197→    customCurve,
   198→    polarity = 'balanced',
   199→    safeFloor,
   200→    safeCeiling,
   201→    softZoneScore = 8.0, // Default "Good" score for acceptable-but-not-ideal values
   202→  } = config;
   203→
   204→  // IMPORTANT: Check demographic-adjusted ideal range FIRST
   205→  // This ensures that demographic overrides are respected even when Bezier curves exist
   206→  // (Bezier curves are optimized for base ranges and don't auto-adjust for demographics)
   207→  if (value >= idealMin && value <= idealMax) {
   208→    return maxScore;
   209→  }
   210→
   211→  // Use custom curve if available in config
   212→  if (customCurve && customCurve.mode === 'custom') {
   213→    const bezierScore = interpolateCustomCurve(value, customCurve.points, maxScore);
   214→    // If Bezier returns -1, it means value is out of range with edge y=0
   215→    // Fall through to exponential decay instead of returning 0
   216→    if (bezierScore >= 0) {
   217→      return bezierScore;
   218→    }
   219→  }
   220→
   221→  // Check for pre-defined Bezier curve from harmony curves (66 metrics)
   222→  const bezierCurve = BEZIER_CURVES[id];
   223→  if (bezierCurve && bezierCurve.mode === 'custom') {
   224→    const bezierScore = interpolateCustomCurve(value, bezierCurve.points, maxScore);
   225→    // If Bezier returns -1, it means value is out of range with edge y=0
   226→    // Fall through to exponential decay instead of returning 0
   227→    if (bezierScore >= 0) {
   228→      return bezierScore;
   229→    }
   230→  }
   231→
   232→  // Handle directional/dimorphic scoring
   233→  if (polarity === 'higher_is_better' && safeFloor !== undefined) {
   234→    // Higher values are good. Only values below safeFloor are true weaknesses.
   235→    if (value >= safeFloor && value < idealMin) {
   236→      // Value is in the "acceptable but not ideal" zone
   237→      // Give a passing score that decreases linearly as we approach the floor
   238→      const zoneRange = idealMin - safeFloor;
   239→      const distanceFromIdeal = idealMin - value;
   240→      const t = zoneRange > 0 ? distanceFromIdeal / zoneRange : 0;
   241→      // Linear interpolation: idealMin -> maxScore, safeFloor -> softZoneScore
   242→      return maxScore - t * (maxScore - softZoneScore);
   243→    }
   244→    if (value >= idealMax) {
   245→      // Values above ideal are still excellent for 'higher_is_better'
   246→      // Apply gentler decay (1/3 the normal rate)
   247→      const deviation = value - idealMax;
   248→      const gentleDecay = decayRate / 3;
   249→      return Math.max(softZoneScore, maxScore * Math.exp(-gentleDecay * deviation));
   250→    }
   251→    // Below safeFloor - apply normal (or harsher) exponential decay
   252→    if (value < safeFloor) {
   253→      const deviation = safeFloor - value;
   254→      return Math.max(0, softZoneScore * Math.exp(-decayRate * deviation));
   255→    }
   256→  }
   257→
   258→  if (polarity === 'lower_is_better' && safeCeiling !== undefined) {
   259→    // Lower values are good. Only values above safeCeiling are true weaknesses.
   260→    if (value <= safeCeiling && value > idealMax) {
   261→      // Value is in the "acceptable but not ideal" zone
   262→      const zoneRange = safeCeiling - idealMax;
   263→      const distanceFromIdeal = value - idealMax;
   264→      const t = zoneRange > 0 ? distanceFromIdeal / zoneRange : 0;
   265→      // Linear interpolation: idealMax -> maxScore, safeCeiling -> softZoneScore
   266→      return maxScore - t * (maxScore - softZoneScore);
   267→    }
   268→    if (value <= idealMin) {
   269→      // Values below ideal are still excellent for 'lower_is_better'
   270→      // Apply gentler decay (1/3 the normal rate)
   271→      const deviation = idealMin - value;
   272→      const gentleDecay = decayRate / 3;
   273→      return Math.max(softZoneScore, maxScore * Math.exp(-gentleDecay * deviation));
   274→    }
   275→    // Above safeCeiling - apply normal exponential decay
   276→    if (value > safeCeiling) {
   277→      const deviation = value - safeCeiling;
   278→      return Math.max(0, softZoneScore * Math.exp(-decayRate * deviation));
   279→    }
   280→  }
   281→
   282→  // Default balanced scoring: deviation in either direction is equally bad
   283→  const deviation = value < idealMin
   284→    ? idealMin - value
   285→    : value - idealMax;
   286→
   287→  // Exponential decay
   288→  const score = maxScore * Math.exp(-decayRate * deviation);
   289→
   290→  return Math.max(0, Math.min(maxScore, score));
   291→}
   292→
   293→/**
   294→ * Check if a metric value is in an "acceptable" zone (not a true weakness).
   295→ * Used by InsightsEngine to prevent false positives.
   296→ */
   297→export function isValueAcceptable(
   298→  value: number,
   299→  config: MetricConfig
   300→): { acceptable: boolean; reason: string } {
   301→  const {
   302→    idealMin,
   303→    idealMax,
   304→    polarity = 'balanced',
   305→    safeFloor,
   306→    safeCeiling,
   307→  } = config;
   308→
   309→  // Within ideal range is always acceptable
   310→  if (value >= idealMin && value <= idealMax) {
   311→    return { acceptable: true, reason: 'within_ideal' };
   312→  }
   313→
   314→  // Check directional acceptability
   315→  if (polarity === 'higher_is_better') {
   316→    if (value >= idealMax) {
   317→      return { acceptable: true, reason: 'above_ideal_higher_is_better' };
   318→    }
   319→    if (safeFloor !== undefined && value >= safeFloor) {
   320→      return { acceptable: true, reason: 'above_safe_floor' };
   321→    }
   322→    // Below safe floor - true weakness
   323→    return { acceptable: false, reason: 'below_safe_floor' };
   324→  }
   325→
   326→  if (polarity === 'lower_is_better') {
   327→    if (value <= idealMin) {
   328→      return { acceptable: true, reason: 'below_ideal_lower_is_better' };
   329→    }
   330→    if (safeCeiling !== undefined && value <= safeCeiling) {
   331→      return { acceptable: true, reason: 'below_safe_ceiling' };
   332→    }
   333→    // Above safe ceiling - true weakness
   334→    return { acceptable: false, reason: 'above_safe_ceiling' };
   335→  }
   336→
   337→  // Balanced polarity - outside ideal is not acceptable
   338→  return { acceptable: false, reason: 'outside_ideal_balanced' };
   339→}
   340→
   341→/**
   342→ * Interpolate custom Bezier curve for scoring
   343→ * Uses cubic Bezier interpolation with control handles for smooth curves
   344→ *
   345→ * IMPORTANT: When value is outside the curve range and the edge y-value is 0,
   346→ * returns -1 to signal the caller should use exponential decay fallback.
   347→ * This prevents artificially returning 0 for values just outside the curve.
   348→ */
   349→export function interpolateCustomCurve(
   350→  value: number,
   351→  points: CurvePoint[],
   352→  maxScore: number
   353→): number {
   354→  void maxScore; // Reserved for future custom curve implementations
   355→  if (points.length === 0) return -1; // Signal to use fallback
   356→
   357→  // Sort points by x value
   358→  const sortedPoints = [...points].sort((a, b) => a.x - b.x);
   359→
   360→  // Handle out-of-range values
   361→  // If edge y-value is 0, return -1 to signal exponential decay fallback should be used
   362→  if (value <= sortedPoints[0].x) {
   363→    const edgeY = sortedPoints[0].y;
   364→    // If edge score is 0, signal to use exponential decay fallback
   365→    return edgeY <= 0 ? -1 : edgeY;
   366→  }
   367→  if (value >= sortedPoints[sortedPoints.length - 1].x) {
   368→    const edgeY = sortedPoints[sortedPoints.length - 1].y;
   369→    // If edge score is 0, signal to use exponential decay fallback
   370→    return edgeY <= 0 ? -1 : edgeY;
   371→  }
   372→
   373→  // Find bracketing points
   374→  let lowerIndex = 0;
   375→  for (let i = 0; i < sortedPoints.length - 1; i++) {
   376→    if (value >= sortedPoints[i].x && value <= sortedPoints[i + 1].x) {
   377→      lowerIndex = i;
   378→      break;
   379→    }
   380→  }
   381→
   382→  const p0 = sortedPoints[lowerIndex];
   383→  const p3 = sortedPoints[lowerIndex + 1];
   384→
   385→  // Check if we have Bezier control handles
   386→  const hasHandles = p0.rightHandleX !== undefined && p3.leftHandleX !== undefined;
   387→
   388→  if (hasHandles) {
   389→    // Cubic Bezier interpolation with control points
   390→    const p1x = p0.rightHandleX!;
   391→    const p1y = p0.rightHandleY ?? p0.y;
   392→    const p2x = p3.leftHandleX!;
   393→    const p2y = p3.leftHandleY ?? p3.y;
   394→
   395→    // Find t parameter for given x value using Newton-Raphson iteration
   396→    let t = (value - p0.x) / (p3.x - p0.x); // Initial guess
   397→
   398→    // Newton-Raphson iterations to find t where B_x(t) = value
   399→    for (let iter = 0; iter < 10; iter++) {
   400→      const bx = cubicBezier(p0.x, p1x, p2x, p3.x, t);
   401→      const bxDerivative = cubicBezierDerivative(p0.x, p1x, p2x, p3.x, t);
   402→
   403→      if (Math.abs(bxDerivative) < 1e-10) break;
   404→
   405→      const newT = t - (bx - value) / bxDerivative;
   406→      if (Math.abs(newT - t) < 1e-10) break;
   407→      t = Math.max(0, Math.min(1, newT));
   408→    }
   409→
   410→    // Calculate y using the found t parameter
   411→    return cubicBezier(p0.y, p1y, p2y, p3.y, t);
   412→  } else {
   413→    // Smooth interpolation using Catmull-Rom spline
   414→    // This provides smoother curves than linear interpolation
   415→    const t = (value - p0.x) / (p3.x - p0.x);
   416→
   417→    // Get neighboring points for spline calculation
   418→    const pMinus1 = lowerIndex > 0 ? sortedPoints[lowerIndex - 1] : p0;
   419→    const p4 = lowerIndex + 2 < sortedPoints.length ? sortedPoints[lowerIndex + 2] : p3;
   420→
   421→    // Catmull-Rom spline interpolation
   422→    return catmullRomSpline(pMinus1.y, p0.y, p3.y, p4.y, t);
   423→  }
   424→}
   425→
   426→/**
   427→ * Cubic Bezier curve evaluation: B(t) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3
   428→ */
   429→export function cubicBezier(p0: number, p1: number, p2: number, p3: number, t: number): number {
   430→  const mt = 1 - t;
   431→  const mt2 = mt * mt;
   432→  const mt3 = mt2 * mt;
   433→  const t2 = t * t;
   434→  const t3 = t2 * t;
   435→  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
   436→}
   437→
   438→/**
   439→ * Cubic Bezier derivative: B'(t) = 3*(1-t)^2*(P1-P0) + 6*(1-t)*t*(P2-P1) + 3*t^2*(P3-P2)
   440→ */
   441→export function cubicBezierDerivative(p0: number, p1: number, p2: number, p3: number, t: number): number {
   442→  const mt = 1 - t;
   443→  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
   444→}
   445→
   446→/**
   447→ * Catmull-Rom spline interpolation for smooth curves without explicit handles
   448→ */
   449→export function catmullRomSpline(p0: number, p1: number, p2: number, p3: number, t: number): number {
   450→  const t2 = t * t;
   451→  const t3 = t2 * t;
   452→
   453→  // Catmull-Rom coefficients with tension = 0.5
   454→  const a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;
   455→  const b = p0 - 2.5 * p1 + 2 * p2 - 0.5 * p3;
   456→  const c = -0.5 * p0 + 0.5 * p2;
   457→  const d = p1;
   458→
   459→  return a * t3 + b * t2 + c * t + d;
   460→}
   461→
   462→/**
   463→ * Calculate standardized score (0-10 normalized)
   464→ */
   465→export function standardizeScore(score: number, maxScore: number): number {
   466→  return (score / maxScore) * 10;
   467→}
   468→
   469→/**
   470→ * Determine quality tier based on score
   471→ */
   472→export function getQualityTier(score: number, maxScore: number = 10): QualityTier {
   473→  const normalized = (score / maxScore) * 100;
   474→
   475→  if (normalized >= 90) return 'ideal';
   476→  if (normalized >= 70) return 'excellent';
   477→  if (normalized >= 50) return 'good';
   478→  return 'below_average';
   479→}
   480→
   481→/**
   482→ * Determine severity level based on score
   483→ */
   484→export function getSeverityLevel(score: number, maxScore: number = 10): SeverityLevel {
   485→  const normalized = (score / maxScore) * 100;
   486→
   487→  if (normalized >= 85) return 'optimal';
   488→  if (normalized >= 70) return 'minor';
   489→  if (normalized >= 50) return 'moderate';
   490→  if (normalized >= 30) return 'major';
   491→  if (normalized >= 15) return 'severe';
   492→  return 'extremely_severe';
   493→}
   494→
   495→/**
   496→ * Calculate deviation description
   497→ */
   498→export function getDeviationDescription(
   499→  value: number,
   500→  idealMin: number,
   501→  idealMax: number,
   502→  unit: MeasurementUnit
   503→): { deviation: number; direction: 'above' | 'below' | 'within'; description: string } {
   504→  if (value >= idealMin && value <= idealMax) {
   505→    return { deviation: 0, direction: 'within', description: 'within ideal range' };
   506→  }
   507→
   508→  const unitLabel = getUnitLabel(unit);
   509→
   510→  if (value < idealMin) {
   511→    const dev = idealMin - value;
   512→    return {
   513→      deviation: dev,
   514→      direction: 'below',
   515→      description: `${dev.toFixed(2)}${unitLabel} below ideal`,
   516→    };
   517→  }
   518→
   519→  const dev = value - idealMax;
   520→  return {
   521→    deviation: dev,
   522→    direction: 'above',
   523→    description: `${dev.toFixed(2)}${unitLabel} above ideal`,
   524→  };
   525→}
   526→
   527→/**
   528→ * Get unit label for display
   529→ */
   530→export function getUnitLabel(unit: MeasurementUnit): string {
   531→  switch (unit) {
   532→    case 'ratio': return 'x';
   533→    case 'percent': return '%';
   534→    case 'degrees': return '\u00B0';
   535→    case 'mm': return 'mm';
   536→    default: return '';
   537→  }
   538→}
   539→
   540→// ============================================
   541→// GEOMETRY HELPERS
   542→// ============================================
   543→
   544→/**
   545→ * Calculate distance between two points
   546→ */
   547→export function distance(p1: Point, p2: Point): number {
   548→  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
   549→}
   550→
   551→/**
   552→ * Calculate angle at vertex point (in degrees)
   553→ */
   554→export function calculateAngle(p1: Point, vertex: Point, p2: Point): number {
   555→  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
   556→  const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };
   557→
   558→  const dot = v1.x * v2.x + v1.y * v2.y;
   559→  const cross = v1.x * v2.y - v1.y * v2.x;
   560→
   561→  const angle = Math.atan2(cross, dot) * (180 / Math.PI);
   562→  return Math.abs(angle);
   563→}
   564→
   565→/**
   566→ * Calculate perpendicular distance from point to line (signed)
   567→ */
   568→export function perpendicularDistance(
   569→  point: Point,
   570→  lineStart: Point,
   571→  lineEnd: Point
   572→): number {
   573→  const A = point.x - lineStart.x;
   574→  const B = point.y - lineStart.y;
   575→  const C = lineEnd.x - lineStart.x;
   576→  const D = lineEnd.y - lineStart.y;
   577→
   578→  const dot = A * C + B * D;
   579→  const lenSq = C * C + D * D;
   580→  const param = lenSq !== 0 ? dot / lenSq : -1;
   581→
   582→  let xx: number, yy: number;
   583→
   584→  if (param < 0) {
   585→    xx = lineStart.x;
   586→    yy = lineStart.y;
   587→  } else if (param > 1) {
   588→    xx = lineEnd.x;
   589→    yy = lineEnd.y;
   590→  } else {
   591→    xx = lineStart.x + param * C;
   592→    yy = lineStart.y + param * D;
   593→  }
   594→
   595→  const dx = point.x - xx;
   596→  const dy = point.y - yy;
   597→
   598→  const sign =
   599→    (lineEnd.y - lineStart.y) * point.x -
   600→      (lineEnd.x - lineStart.x) * point.y +
   601→      lineEnd.x * lineStart.y -
   602→      lineEnd.y * lineStart.x >=
   603→    0
   604→      ? 1
   605→      : -1;
   606→
   607→  return sign * Math.sqrt(dx * dx + dy * dy);
   608→}
   609→
   610→// ============================================
   611→// PERCENTILE & PSL CONVERSION
   612→// ============================================
   613→
   614→/**
   615→ * Calculate percentile from harmony score
   616→ */
   617→export function calculateHarmonyPercentile(score: number): number {
   618→  // Based on normal distribution with mean=5, stdDev=1.5
   619→  const mean = 5;
   620→  const stdDev = 1.5;
   621→  const z = (score - mean) / stdDev;
   622→  return normalCDF(z) * 100;
   623→}
   624→
   625→/**
   626→ * Standard normal CDF approximation
   627→ */
   628→export function normalCDF(z: number): number {
   629→  const a1 = 0.254829592;
   630→  const a2 = -0.284496736;
   631→  const a3 = 1.421413741;
   632→  const a4 = -1.453152027;
   633→  const a5 = 1.061405429;
   634→  const p = 0.3275911;
   635→
   636→  const sign = z < 0 ? -1 : 1;
   637→  const absZ = Math.abs(z) / Math.sqrt(2);
   638→
   639→  const t = 1.0 / (1.0 + p * absZ);
   640→  const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-absZ * absZ);
   641→
   642→  return 0.5 * (1.0 + sign * y);
   643→}
   644→
   645→// ============================================
   646→// PSL RATING CONVERSION
   647→// ============================================
   648→
   649→export interface PSLRating {
   650→  score: number;
   651→  tier: string;
   652→  percentile: number;
   653→  description: string;
   654→}
   655→
   656→/**
   657→ * Convert harmony score to PSL rating
   658→ */
   659→export function convertToPSL(harmonyScore: number): PSLRating {
   660→  // Convert 0-10 harmony to 3.0-7.5 PSL range
   661→  const psl = 3.0 + (harmonyScore / 10) * 4.5;
   662→  const clampedPSL = Math.max(3.0, Math.min(7.5, psl));
   663→
   664→  let tier: string;
   665→  let percentile: number;
   666→
   667→  if (clampedPSL >= 7.5) {
   668→    tier = 'Top Model';
   669→    percentile = 99.99;
   670→  } else if (clampedPSL >= 7.0) {
   671→    tier = 'Chad';
   672→    percentile = 99.87;
   673→  } else if (clampedPSL >= 6.5) {
   674→    tier = 'Chadlite';
   675→    percentile = 99.0;
   676→  } else if (clampedPSL >= 6.0) {
   677→    tier = 'High Tier Normie+';
   678→    percentile = 97.25;
   679→  } else if (clampedPSL >= 5.5) {
   680→    tier = 'High Tier Normie';
   681→    percentile = 90.0;
   682→  } else if (clampedPSL >= 5.0) {
   683→    tier = 'Mid Tier Normie+';
   684→    percentile = 84.15;
   685→  } else if (clampedPSL >= 4.5) {
   686→    tier = 'Mid Tier Normie';
   687→    percentile = 65.0;
   688→  } else if (clampedPSL >= 4.0) {
   689→    tier = 'Low Tier Normie';
   690→    percentile = 50.0;
   691→  } else if (clampedPSL >= 3.5) {
   692→    tier = 'Below Average';
   693→    percentile = 30.0;
   694→  } else {
   695→    tier = 'Subpar';
   696→    percentile = 15.0;
   697→  }
   698→
   699→  return {
   700→    score: clampedPSL,
   701→    tier,
   702→    percentile,
   703→    description: `${tier} (top ${(100 - percentile).toFixed(1)}%)`,
   704→  };
   705→}
   706→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
