     1→'use client';
     2→
     3→import { useEffect, useRef, useState, useCallback } from 'react';
     4→import {
     5→  FaceLandmarker,
     6→  FilesetResolver,
     7→  FaceLandmarkerResult,
     8→} from '@mediapipe/tasks-vision';
     9→
    10→const MODEL_URL =
    11→  'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task';
    12→
    13→const VISION_WASM_URL =
    14→  'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm';
    15→
    16→export interface FaceLandmark {
    17→  x: number;
    18→  y: number;
    19→  z: number;
    20→}
    21→
    22→export interface DetectionResult {
    23→  landmarks: FaceLandmark[][];
    24→  faceLandmarkerResult: FaceLandmarkerResult;
    25→}
    26→
    27→export interface UseFaceLandmarkerReturn {
    28→  isLoading: boolean;
    29→  isReady: boolean;
    30→  error: Error | null;
    31→  detect: (
    32→    image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement
    33→  ) => Promise<DetectionResult | null>;
    34→}
    35→
    36→export function useFaceLandmarker(): UseFaceLandmarkerReturn {
    37→  const faceLandmarkerRef = useRef<FaceLandmarker | null>(null);
    38→  const [isLoading, setIsLoading] = useState(true);
    39→  const [isReady, setIsReady] = useState(false);
    40→  const [error, setError] = useState<Error | null>(null);
    41→
    42→  useEffect(() => {
    43→    let isMounted = true;
    44→
    45→    async function initializeFaceLandmarker() {
    46→      try {
    47→        setIsLoading(true);
    48→        setError(null);
    49→
    50→        const vision = await FilesetResolver.forVisionTasks(VISION_WASM_URL);
    51→
    52→        const landmarker = await FaceLandmarker.createFromOptions(vision, {
    53→          baseOptions: {
    54→            modelAssetPath: MODEL_URL,
    55→            delegate: 'GPU',
    56→          },
    57→          runningMode: 'IMAGE',
    58→          numFaces: 1,
    59→          outputFaceBlendshapes: false,
    60→          outputFacialTransformationMatrixes: false,
    61→        });
    62→
    63→        if (isMounted) {
    64→          faceLandmarkerRef.current = landmarker;
    65→          setIsReady(true);
    66→          setIsLoading(false);
    67→        } else {
    68→          landmarker.close();
    69→        }
    70→      } catch (err) {
    71→        if (isMounted) {
    72→          const errorMessage =
    73→            err instanceof Error ? err.message : 'Failed to initialize FaceLandmarker';
    74→          setError(new Error(errorMessage));
    75→          setIsLoading(false);
    76→          setIsReady(false);
    77→        }
    78→      }
    79→    }
    80→
    81→    initializeFaceLandmarker();
    82→
    83→    return () => {
    84→      isMounted = false;
    85→      if (faceLandmarkerRef.current) {
    86→        faceLandmarkerRef.current.close();
    87→        faceLandmarkerRef.current = null;
    88→      }
    89→    };
    90→  }, []);
    91→
    92→  const detect = useCallback(
    93→    async (
    94→      image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement
    95→    ): Promise<DetectionResult | null> => {
    96→      if (!faceLandmarkerRef.current) {
    97→        throw new Error('FaceLandmarker is not initialized');
    98→      }
    99→
   100→      if (!isReady) {
   101→        throw new Error('FaceLandmarker is not ready');
   102→      }
   103→
   104→      try {
   105→        const result = faceLandmarkerRef.current.detect(image);
   106→
   107→        if (!result.faceLandmarks || result.faceLandmarks.length === 0) {
   108→          return null;
   109→        }
   110→
   111→        const landmarks: FaceLandmark[][] = result.faceLandmarks.map((face) =>
   112→          face.map((point) => ({
   113→            x: point.x,
   114→            y: point.y,
   115→            z: point.z,
   116→          }))
   117→        );
   118→
   119→        return {
   120→          landmarks,
   121→          faceLandmarkerResult: result,
   122→        };
   123→      } catch (err) {
   124→        const errorMessage =
   125→          err instanceof Error ? err.message : 'Face detection failed';
   126→        throw new Error(errorMessage);
   127→      }
   128→    },
   129→    [isReady]
   130→  );
   131→
   132→  return {
   133→    isLoading,
   134→    isReady,
   135→    error,
   136→    detect,
   137→  };
   138→}
   139→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
