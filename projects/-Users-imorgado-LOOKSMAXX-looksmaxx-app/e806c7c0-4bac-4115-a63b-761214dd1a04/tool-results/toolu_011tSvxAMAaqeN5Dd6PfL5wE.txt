     1→# FaceIQ Labs - Technical Specification Document
     2→## Reverse-Engineered Facial Analysis System
     3→
     4→**Document Version:** 1.0
     5→**Date:** December 2024
     6→**Source:** Reverse-engineered from beta.faceiqlabs.com
     7→
     8→---
     9→
    10→## Table of Contents
    11→
    12→1. [System Architecture](#1-system-architecture)
    13→2. [Data Flow Pipeline](#2-data-flow-pipeline)
    14→3. [Core Scoring Engine](#3-core-scoring-engine)
    15→4. [Landmark Detection System](#4-landmark-detection-system)
    16→5. [Ratio Calculation Functions](#5-ratio-calculation-functions)
    17→6. [Decoded Scoring Standards Database](#6-decoded-scoring-standards-database)
    18→7. [Implementation Strategy](#7-implementation-strategy)
    19→8. [API Reference](#8-api-reference)
    20→
    21→---
    22→
    23→## 1. System Architecture
    24→
    25→### 1.1 Hybrid Processing Model
    26→
    27→The system uses a **hybrid architecture** that splits processing between client and server:
    28→
    29→```
    30→┌─────────────────────────────────────────────────────────────────────────────┐
    31→│                           FACIAL ANALYSIS SYSTEM                            │
    32→├─────────────────────────────────────────────────────────────────────────────┤
    33→│                                                                             │
    34→│  ┌─────────────────────────────┐    ┌─────────────────────────────────┐   │
    35→│  │     CLIENT-SIDE (Browser)   │    │      SERVER-SIDE (API)          │   │
    36→│  ├─────────────────────────────┤    ├─────────────────────────────────┤   │
    37→│  │                             │    │                                 │   │
    38→│  │  ┌───────────────────────┐  │    │  ┌───────────────────────────┐ │   │
    39→│  │  │   MediaPipe WASM      │  │    │  │  Custom Landmark Model    │ │   │
    40→│  │  │   FaceLandmarker      │  │    │  │  (Side Profile)           │ │   │
    41→│  │  └───────────────────────┘  │    │  └───────────────────────────┘ │   │
    42→│  │            │                │    │              │                 │   │
    43→│  │            ▼                │    │              ▼                 │   │
    44→│  │  ┌───────────────────────┐  │    │  ┌───────────────────────────┐ │   │
    45→│  │  │  478 Facial Landmarks │  │    │  │  106 Side Landmarks       │ │   │
    46→│  │  │  (Front Profile)      │  │    │  │  + Rotation Data          │ │   │
    47→│  │  └───────────────────────┘  │    │  └───────────────────────────┘ │   │
    48→│  │            │                │    │              │                 │   │
    49→│  │            ▼                │    │              ▼                 │   │
    50→│  │  ┌───────────────────────┐  │    │  ┌───────────────────────────┐ │   │
    51→│  │  │  Ratio Calculations   │  │    │  │  Scoring Engine           │ │   │
    52→│  │  │  (JavaScript)         │  │    │  │  (Server-side)            │ │   │
    53→│  │  └───────────────────────┘  │    │  └───────────────────────────┘ │   │
    54→│  │                             │    │                                 │   │
    55→│  └─────────────────────────────┘    └─────────────────────────────────┘   │
    56→│                                                                             │
    57→└─────────────────────────────────────────────────────────────────────────────┘
    58→```
    59→
    60→### 1.2 Component Responsibilities
    61→
    62→| Component | Location | Responsibility |
    63→|-----------|----------|----------------|
    64→| MediaPipe FaceLandmarker | Client (WASM) | Detect 478 landmarks on front-facing images |
    65→| Side Landmark API | Server | Detect landmarks on side profile images |
    66→| Landmark Mapper | Client | Convert raw indices to named anatomical points |
    67→| Ratio Calculator | Client | Compute facial ratios from landmark coordinates |
    68→| Scoring Engine | Server | Apply exponential decay scoring with ideal ranges |
    69→| Standards Database | Server | Store ideal min/max values for all ratios |
    70→
    71→---
    72→
    73→## 2. Data Flow Pipeline
    74→
    75→### 2.1 Complete Processing Flow
    76→
    77→```
    78→┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
    79→│   CAPTURE    │────▶│   DETECT     │────▶│  CALCULATE   │────▶│    SCORE     │
    80→│   Image      │     │  Landmarks   │     │   Ratios     │     │   Results    │
    81→└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
    82→       │                    │                    │                    │
    83→       ▼                    ▼                    ▼                    ▼
    84→  Front Photo         478 Points            50+ Ratios          0-10 Scores
    85→  Side Photo          106 Points           (angles, %)         + Deviation
    86→```
    87→
    88→### 2.2 Front Profile Pipeline
    89→
    90→```javascript
    91→// Step 1: Initialize MediaPipe FaceLandmarker
    92→const faceLandmarker = await FaceLandmarker.createFromModelPath(
    93→    wasmFileset,
    94→    "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
    95→);
    96→
    97→// Step 2: Detect landmarks
    98→const results = faceLandmarker.detect(imageElement);
    99→const landmarks = results.faceLandmarks[0]; // Array of 478 {x, y, z} points
   100→
   101→// Step 3: Map to named points
   102→const namedLandmarks = mapLandmarksToNames(landmarks, imageWidth, imageHeight);
   103→
   104→// Step 4: Calculate ratios
   105→const ratios = calculateAllRatios(namedLandmarks, "front");
   106→
   107→// Step 5: Score each ratio
   108→const scores = ratios.map(r => ({
   109→    name: r.name,
   110→    value: r.value,
   111→    score: calculateScore(r.value, r.idealMin, r.idealMax, r.decayRate)
   112→}));
   113→```
   114→
   115→### 2.3 Side Profile Pipeline
   116→
   117→```javascript
   118→// Step 1: Upload image to server
   119→const formData = new FormData();
   120→formData.append("image", imageBlob, "side.jpg");
   121→
   122→// Step 2: Server detects landmarks
   123→const response = await fetch("/api/side-landmarks", {
   124→    method: "POST",
   125→    body: formData
   126→});
   127→
   128→// Step 3: Receive landmark data
   129→const { landmarks, direction, rotationAngle, bbox } = await response.json();
   130→
   131→// Step 4: Map to named anatomical points
   132→const namedLandmarks = mapSideLandmarksToNames(landmarks, imageWidth, imageHeight);
   133→
   134→// Step 5: Calculate side-specific ratios
   135→const ratios = calculateAllRatios(namedLandmarks, "side");
   136→```
   137→
   138→---
   139→
   140→## 3. Core Scoring Engine
   141→
   142→### 3.1 The Exponential Decay Scoring Function
   143→
   144→This is the exact scoring algorithm extracted from the application:
   145→
   146→```javascript
   147→/**
   148→ * Calculate a score (0-10) based on how close a value is to the ideal range.
   149→ * Uses exponential decay for values outside the ideal range.
   150→ *
   151→ * @param {number} value - The measured ratio value
   152→ * @param {number} idealMin - Minimum of ideal range
   153→ * @param {number} idealMax - Maximum of ideal range
   154→ * @param {number} decayRate - Rate of score decay (default 0.2)
   155→ * @param {number} maxScore - Maximum possible score (default 10)
   156→ * @returns {number} Score from 0 to 10
   157→ */
   158→function calculateScore(value, idealMin, idealMax, decayRate = 0.2, maxScore = 10) {
   159→    const minScore = -maxScore;
   160→
   161→    let rawScore;
   162→
   163→    if (value >= idealMin && value <= idealMax) {
   164→        // Value is within ideal range - perfect score
   165→        rawScore = maxScore;
   166→    } else {
   167→        // Calculate distance from ideal range
   168→        const distance = value < idealMin
   169→            ? (idealMin - value)
   170→            : (value - idealMax);
   171→
   172→        // Apply exponential decay
   173→        // Score decreases exponentially the further from ideal
   174→        rawScore = minScore + (maxScore - minScore) * Math.exp(-decayRate * distance);
   175→    }
   176→
   177→    // Normalize to 0-10 scale
   178→    const range = maxScore - minScore;
   179→    const normalizedScore = (rawScore - minScore) / range * 10;
   180→
   181→    return Math.max(0, Math.min(10, normalizedScore));
   182→}
   183→```
   184→
   185→### 3.2 Mathematical Explanation
   186→
   187→The exponential decay formula:
   188→
   189→```
   190→                    ┌─ maxScore                          if idealMin ≤ value ≤ idealMax
   191→                    │
   192→score(value) = ─────┤
   193→                    │
   194→                    └─ minScore + (maxScore - minScore) × e^(-decay × distance)    otherwise
   195→```
   196→
   197→Where:
   198→- `distance = |value - nearest_ideal_boundary|`
   199→- `decay` = 0.2 (default rate)
   200→- `e` = Euler's number (≈2.718)
   201→
   202→**Visualization of Score Curve:**
   203→
   204→```
   205→Score
   206→  10 │          ┌──────────────┐
   207→     │         ╱                ╲
   208→   8 │        ╱                  ╲
   209→     │       ╱                    ╲
   210→   6 │      ╱                      ╲
   211→     │     ╱                        ╲
   212→   4 │    ╱                          ╲
   213→     │   ╱                            ╲
   214→   2 │  ╱                              ╲
   215→     │ ╱                                ╲
   216→   0 │╱                                  ╲______________
   217→     └────────────────────────────────────────────────── Value
   218→              │        │        │
   219→           idealMin   ideal   idealMax
   220→                     range
   221→```
   222→
   223→### 3.3 Custom Curve Support
   224→
   225→For ratios with non-standard scoring curves:
   226→
   227→```javascript
   228→/**
   229→ * Calculate score using custom interpolation points
   230→ *
   231→ * @param {number} value - The measured value
   232→ * @param {Array} customPoints - Array of {x, y} points defining the curve
   233→ * @returns {number} Interpolated score (0-10)
   234→ */
   235→function calculateScoreFromCurve(value, customPoints) {
   236→    // Sort points by x value
   237→    const sorted = [...customPoints].sort((a, b) => a.x - b.x);
   238→
   239→    // Find surrounding points for interpolation
   240→    for (let i = 0; i < sorted.length - 1; i++) {
   241→        if (value >= sorted[i].x && value <= sorted[i + 1].x) {
   242→            // Linear interpolation between points
   243→            const t = (value - sorted[i].x) / (sorted[i + 1].x - sorted[i].x);
   244→            return sorted[i].y + t * (sorted[i + 1].y - sorted[i].y);
   245→        }
   246→    }
   247→
   248→    // Extrapolate if outside range
   249→    if (value < sorted[0].x) return sorted[0].y;
   250→    return sorted[sorted.length - 1].y;
   251→}
   252→```
   253→
   254→---
   255→
   256→## 4. Landmark Detection System
   257→
   258→### 4.1 MediaPipe FaceLandmarker Setup
   259→
   260→```javascript
   261→import { FaceLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";
   262→
   263→async function initializeFaceLandmarker() {
   264→    const wasmFileset = await FilesetResolver.forVisionTasks(
   265→        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
   266→    );
   267→
   268→    const faceLandmarker = await FaceLandmarker.createFromOptions(wasmFileset, {
   269→        baseOptions: {
   270→            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
   271→            delegate: "GPU"
   272→        },
   273→        runningMode: "IMAGE",
   274→        numFaces: 1,
   275→        outputFacialTransformationMatrixes: true,
   276→        outputFaceBlendshapes: false
   277→    });
   278→
   279→    return faceLandmarker;
   280→}
   281→```
   282→
   283→### 4.2 Front Profile Landmark Index Map
   284→
   285→```javascript
   286→/**
   287→ * MediaPipe FaceLandmarker index to anatomical point mapping
   288→ * Based on MediaPipe's 478-point face mesh
   289→ */
   290→const FRONT_LANDMARK_INDICES = {
   291→    // Facial outline
   292→    chinBottom: 152,
   293→    chinLeft: 172,
   294→    chinRight: 397,
   295→
   296→    // Forehead
   297→    hairline: 10,        // Top of forehead
   298→    glabella: 9,         // Between eyebrows
   299→
   300→    // Eyes - Left
   301→    leftEyePupil: 468,   // Iris center (if available) or approximate
   302→    leftEyeMedialCanthus: 133,
   303→    leftEyeLateralCanthus: 33,
   304→    leftEyeUpperEyelid: 159,
   305→    leftEyeLowerEyelid: 145,
   306→    leftEyelidHoodEnd: 130,
   307→
   308→    // Eyes - Right
   309→    rightEyePupil: 473,
   310→    rightEyeMedialCanthus: 362,
   311→    rightEyeLateralCanthus: 263,
   312→    rightEyeUpperEyelid: 386,
   313→    rightEyeLowerEyelid: 374,
   314→    rightEyelidHoodEnd: 359,
   315→
   316→    // Eyebrows - Left
   317→    leftBrowInnerCorner: 107,
   318→    leftBrowHead: 66,
   319→    leftBrowPeak: 105,
   320→    leftBrowArch: 70,
   321→
   322→    // Eyebrows - Right
   323→    rightBrowInnerCorner: 336,
   324→    rightBrowHead: 296,
   325→    rightBrowPeak: 334,
   326→    rightBrowArch: 300,
   327→
   328→    // Nose
   329→    nasion: 6,           // Bridge of nose
   330→    noseBottom: 4,       // Tip of nose
   331→    nasalBase: 2,        // Base of nose
   332→    noseLeft: 129,       // Left nostril
   333→    noseRight: 358,      // Right nostril
   334→
   335→    // Mouth
   336→    cupidsBow: 0,        // Center upper lip
   337→    mouthMiddle: 13,     // Center of mouth
   338→    lowerLip: 14,        // Center lower lip
   339→    mouthLeft: 61,       // Left corner
   340→    mouthRight: 291,     // Right corner
   341→
   342→    // Cheeks
   343→    leftCheek: 234,      // Widest point left
   344→    rightCheek: 454,     // Widest point right
   345→
   346→    // Jaw
   347→    leftTopGonion: 172,  // Left jaw angle
   348→    rightTopGonion: 397, // Right jaw angle
   349→    leftBottomGonion: 140,
   350→    rightBottomGonion: 369,
   351→
   352→    // Temples
   353→    leftTemple: 127,
   354→    rightTemple: 356,
   355→
   356→    // Ears
   357→    leftOuterEar: 234,
   358→    rightOuterEar: 454,
   359→
   360→    // Neck
   361→    neckLeft: 177,
   362→    neckRight: 401
   363→};
   364→```
   365→
   366→### 4.3 Side Profile Landmark Index Map
   367→
   368→```javascript
   369→/**
   370→ * Side profile landmark indices (custom model)
   371→ * Used after /api/side-landmarks detection
   372→ */
   373→const SIDE_LANDMARK_INDICES = {
   374→    // Cranial
   375→    vertex: "calculated",    // Top of head (calculated)
   376→    occiput: "calculated",   // Back of head (calculated)
   377→
   378→    // Forehead
   379→    trichion: "calculated",  // Hairline
   380→    glabella: 104,           // Between brows
   381→
   382→    // Nose
   383→    nasion: 72,              // Bridge
   384→    rhinion: "calculated",   // Nasal bridge midpoint
   385→    supratip: "calculated",  // Above tip
   386→    pronasale: 83,           // Tip of nose
   387→    infratip: "calculated",  // Below tip
   388→    columella: "calculated", // Columella base
   389→    subnasale: "calculated", // Below nose
   390→    subalare: 77,            // Nostril base
   391→
   392→    // Lips
   393→    labraleSuperius: 67,     // Upper lip
   394→    labraleInferius: 59,     // Lower lip
   395→    sublabiale: "calculated",// Below lower lip
   396→    cheilion: 52,            // Corner of mouth
   397→
   398→    // Chin
   399→    pogonion: 24,            // Chin point
   400→    menton: "calculated",    // Chin bottom
   401→
   402→    // Jaw
   403→    gonionTop: "calculated", // Upper jaw angle
   404→    gonionBottom: 2,         // Lower jaw angle
   405→
   406→    // Ear
   407→    porion: "calculated",    // Ear canal
   408→    tragus: "calculated",    // Ear tragus
   409→    intertragicNotch: "calculated",
   410→
   411→    // Eye
   412→    orbitale: "calculated",  // Lower orbit
   413→    cornealApex: 40,         // Eye center
   414→
   415→    // Neck
   416→    cervicalPoint: "calculated",
   417→    neckPoint: "calculated",
   418→
   419→    // Cheek
   420→    cheekbone: "calculated"
   421→};
   422→```
   423→
   424→### 4.4 Calculated Landmark Functions
   425→
   426→```javascript
   427→/**
   428→ * Calculate derived landmarks from raw detected points
   429→ */
   430→const CALCULATED_LANDMARKS = {
   431→    vertex: (landmarks) => {
   432→        const glabella = getLandmark(landmarks, 10);
   433→        const occiput = getLandmark(landmarks, 8);
   434→        const nasion = getLandmark(landmarks, 1);
   435→        const hairline = getLandmark(landmarks, 12);
   436→        const distance = euclidean(glabella, occiput);
   437→        return translatePoint(glabella, {
   438→            along: { from: nasion, to: hairline },
   439→            by: -distance
   440→        });
   441→    },
   442→
   443→    occiput: (landmarks) => {
   444→        const vertex = getLandmark(landmarks, 9);
   445→        const pronasale = getLandmark(landmarks, 83);
   446→        const distance = euclidean(vertex, pronasale);
   447→        return translatePoint(vertex, {
   448→            along: { from: pronasale, to: vertex },
   449→            by: distance
   450→        });
   451→    },
   452→
   453→    menton: (landmarks) => {
   454→        const chinFront = getLandmark(landmarks, 0);
   455→        const chinBottom = getLandmark(landmarks, 8);
   456→        return {
   457→            x: (chinFront.x + chinBottom.x) / 2,
   458→            y: (chinFront.y + chinBottom.y) / 2
   459→        };
   460→    },
   461→
   462→    rhinion: (landmarks, namedPoints) => {
   463→        if (!namedPoints.pronasale || !namedPoints.nasion) return null;
   464→        const pronasale = toPixels(namedPoints.pronasale, landmarks.imageWidth, landmarks.imageHeight);
   465→        return translatePoint(pronasale, {
   466→            along: { from: pronasale, to: toPixels(namedPoints.nasion, landmarks.imageWidth, landmarks.imageHeight) },
   467→            by: euclidean(getLandmark(landmarks, 74), getLandmark(landmarks, 72))
   468→        });
   469→    }
   470→    // ... additional calculated points
   471→};
   472→```
   473→
   474→---
   475→
   476→## 5. Ratio Calculation Functions
   477→
   478→### 5.1 Core Utility Functions
   479→
   480→```javascript
   481→/**
   482→ * Calculate Euclidean distance between two points
   483→ */
   484→function euclidean(point1, point2) {
   485→    const dx = point2.x - point1.x;
   486→    const dy = point2.y - point1.y;
   487→    return Math.sqrt(dx * dx + dy * dy);
   488→}
   489→
   490→/**
   491→ * Calculate midpoint between two points
   492→ */
   493→function midpoint(point1, point2) {
   494→    return {
   495→        x: (point1.x + point2.x) / 2,
   496→        y: (point1.y + point2.y) / 2
   497→    };
   498→}
   499→
   500→/**
   501→ * Safe division with fallback
   502→ */
   503→function ratio(numerator, denominator, fallback = 0) {
   504→    if (!isFinite(numerator) || !isFinite(denominator) || Math.abs(denominator) < 1e-10) {
   505→        return fallback;
   506→    }
   507→    const result = numerator / denominator;
   508→    return isFinite(result) ? result : fallback;
   509→}
   510→
   511→/**
   512→ * Calculate angle at vertex (in degrees)
   513→ * Returns angle ABC where B is the vertex
   514→ */
   515→function angle(pointA, vertex, pointC) {
   516→    const vectorBA = { x: pointA.x - vertex.x, y: pointA.y - vertex.y };
   517→    const vectorBC = { x: pointC.x - vertex.x, y: pointC.y - vertex.y };
   518→
   519→    const dotProduct = vectorBA.x * vectorBC.x + vectorBA.y * vectorBC.y;
   520→    const magnitudeProduct = Math.sqrt(vectorBA.x ** 2 + vectorBA.y ** 2) *
   521→                             Math.sqrt(vectorBC.x ** 2 + vectorBC.y ** 2);
   522→
   523→    if (Math.abs(magnitudeProduct) < 1e-10) return 0;
   524→
   525→    const cosAngle = Math.max(-1, Math.min(1, dotProduct / magnitudeProduct));
   526→    return (180 / Math.PI) * Math.acos(cosAngle);
   527→}
   528→```
   529→
   530→### 5.2 Front Profile Ratio Calculations
   531→
   532→```javascript
   533→const FRONT_RATIO_CALCULATIONS = {
   534→    "Midface Ratio": (landmarks) => {
   535→        const leftPupil = landmarks.leftEyePupil;
   536→        const rightPupil = landmarks.rightEyePupil;
   537→        const cupidsBow = landmarks.cupidsBow;
   538→        if (!leftPupil || !rightPupil || !cupidsBow) return null;
   539→
   540→        const eyeWidth = Math.abs(rightPupil.x - leftPupil.x);
   541→        const eyeCenterY = (leftPupil.y + rightPupil.y) / 2;
   542→        return ratio(eyeWidth, Math.abs(cupidsBow.y - eyeCenterY));
   543→    },
   544→
   545→    "Eye Separation Ratio": (landmarks) => {
   546→        const leftPupil = landmarks.leftEyePupil;
   547→        const rightPupil = landmarks.rightEyePupil;
   548→        const leftCheek = landmarks.leftCheek;
   549→        const rightCheek = landmarks.rightCheek;
   550→        if (!leftPupil || !rightPupil || !leftCheek || !rightCheek) return null;
   551→
   552→        return 100 * ratio(
   553→            Math.abs(rightPupil.x - leftPupil.x),
   554→            Math.abs(rightCheek.x - leftCheek.x)
   555→        );
   556→    },
   557→
   558→    "Total Facial Width to Height Ratio": (landmarks) => {
   559→        const leftCheek = landmarks.leftCheek;
   560→        const rightCheek = landmarks.rightCheek;
   561→        const hairline = landmarks.hairline;
   562→        const chinBottom = landmarks.chinBottom;
   563→        if (!leftCheek || !rightCheek || !hairline || !chinBottom) return null;
   564→
   565→        return ratio(
   566→            Math.abs(chinBottom.y - hairline.y),
   567→            Math.abs(rightCheek.x - leftCheek.x)
   568→        );
   569→    },
   570→
   571→    "Bigonial Width": (landmarks) => {
   572→        const leftGonion = landmarks.leftTopGonion;
   573→        const rightGonion = landmarks.rightTopGonion;
   574→        const leftCheek = landmarks.leftCheek;
   575→        const rightCheek = landmarks.rightCheek;
   576→        if (!leftGonion || !rightGonion || !leftCheek || !rightCheek) return null;
   577→
   578→        return 100 * ratio(
   579→            Math.abs(rightGonion.x - leftGonion.x),
   580→            Math.abs(rightCheek.x - leftCheek.x)
   581→        );
   582→    },
   583→
   584→    "Lateral Canthal Tilt": (landmarks) => {
   585→        const leftMedial = landmarks.leftEyeMedialCanthus;
   586→        const leftLateral = landmarks.leftEyeLateralCanthus;
   587→        const rightMedial = landmarks.rightEyeMedialCanthus;
   588→        const rightLateral = landmarks.rightEyeLateralCanthus;
   589→        if (!leftMedial || !leftLateral || !rightMedial || !rightLateral) return null;
   590→
   591→        const leftTilt = (180 / Math.PI) * Math.atan2(
   592→            leftMedial.y - leftLateral.y,
   593→            leftMedial.x - leftLateral.x
   594→        );
   595→        const rightTilt = (180 / Math.PI) * Math.atan2(
   596→            rightMedial.y - rightLateral.y,
   597→            rightLateral.x - rightMedial.x
   598→        );
   599→        return (leftTilt + rightTilt) / 2;
   600→    },
   601→
   602→    "Lower Third": (landmarks) => {
   603→        const hairline = landmarks.hairline;
   604→        const noseBottom = landmarks.noseBottom;
   605→        const chinBottom = landmarks.chinBottom;
   606→        const leftBrowInner = landmarks.leftBrowInnerCorner;
   607→        const leftBrowHead = landmarks.leftBrowHead;
   608→        const rightBrowInner = landmarks.rightBrowInnerCorner;
   609→        const rightBrowHead = landmarks.rightBrowHead;
   610→        if (!hairline || !noseBottom || !chinBottom || !leftBrowInner ||
   611→            !leftBrowHead || !rightBrowInner || !rightBrowHead) return null;
   612→
   613→        const faceHeight = Math.abs(chinBottom.y - hairline.y);
   614→        return ((chinBottom.y - noseBottom.y) / faceHeight) * 100;
   615→    },
   616→
   617→    "Middle Third": (landmarks) => {
   618→        const hairline = landmarks.hairline;
   619→        const noseBottom = landmarks.noseBottom;
   620→        const chinBottom = landmarks.chinBottom;
   621→        const leftBrowInner = landmarks.leftBrowInnerCorner;
   622→        const leftBrowHead = landmarks.leftBrowHead;
   623→        const rightBrowInner = landmarks.rightBrowInnerCorner;
   624→        const rightBrowHead = landmarks.rightBrowHead;
   625→        if (!hairline || !noseBottom || !chinBottom || !leftBrowInner ||
   626→            !leftBrowHead || !rightBrowInner || !rightBrowHead) return null;
   627→
   628→        const faceHeight = Math.abs(chinBottom.y - hairline.y);
   629→        const browMid = midpoint(midpoint(leftBrowInner, leftBrowHead),
   630→                                  midpoint(rightBrowInner, rightBrowHead));
   631→        return ((noseBottom.y - browMid.y) / faceHeight) * 100;
   632→    },
   633→
   634→    "Top Third": (landmarks) => {
   635→        const hairline = landmarks.hairline;
   636→        const chinBottom = landmarks.chinBottom;
   637→        const leftBrowInner = landmarks.leftBrowInnerCorner;
   638→        const leftBrowHead = landmarks.leftBrowHead;
   639→        const rightBrowInner = landmarks.rightBrowInnerCorner;
   640→        const rightBrowHead = landmarks.rightBrowHead;
   641→        if (!hairline || !chinBottom || !leftBrowInner || !leftBrowHead ||
   642→            !rightBrowInner || !rightBrowHead) return null;
   643→
   644→        const faceHeight = Math.abs(chinBottom.y - hairline.y);
   645→        const browMid = midpoint(midpoint(leftBrowInner, leftBrowHead),
   646→                                  midpoint(rightBrowInner, rightBrowHead));
   647→        return ((browMid.y - hairline.y) / faceHeight) * 100;
   648→    },
   649→
   650→    "Eye Aspect Ratio": (landmarks) => {
   651→        const leftMedial = landmarks.leftEyeMedialCanthus;
   652→        const leftLateral = landmarks.leftEyeLateralCanthus;
   653→        const leftUpper = landmarks.leftEyeUpperEyelid;
   654→        const leftLower = landmarks.leftEyeLowerEyelid;
   655→        const rightMedial = landmarks.rightEyeMedialCanthus;
   656→        const rightLateral = landmarks.rightEyeLateralCanthus;
   657→        const rightUpper = landmarks.rightEyeUpperEyelid;
   658→        const rightLower = landmarks.rightEyeLowerEyelid;
   659→        if (!leftMedial || !leftLateral || !leftUpper || !leftLower ||
   660→            !rightMedial || !rightLateral || !rightUpper || !rightLower) return null;
   661→
   662→        const leftRatio = ratio(Math.abs(leftLateral.x - leftMedial.x),
   663→                                Math.abs(leftLower.y - leftUpper.y));
   664→        const rightRatio = ratio(Math.abs(rightLateral.x - rightMedial.x),
   665→                                 Math.abs(rightLower.y - rightUpper.y));
   666→        return (leftRatio + rightRatio) / 2;
   667→    },
   668→
   669→    "Jaw Frontal Angle": (landmarks) => {
   670→        const leftGonion = landmarks.leftBottomGonion;
   671→        const rightGonion = landmarks.rightBottomGonion;
   672→        const chinLeft = landmarks.chinLeft;
   673→        const chinRight = landmarks.chinRight;
   674→        if (!leftGonion || !rightGonion || !chinLeft || !chinRight) return null;
   675→
   676→        // Calculate angle between jaw lines
   677→        return 180 - angle(leftGonion, chinLeft, chinRight, rightGonion);
   678→    }
   679→};
   680→```
   681→
   682→### 5.3 Side Profile Ratio Calculations
   683→
   684→```javascript
   685→const SIDE_RATIO_CALCULATIONS = {
   686→    "Gonial Angle": (landmarks) => {
   687→        const gonionTop = landmarks.gonionTop;
   688→        const gonionBottom = landmarks.gonionBottom;
   689→        const menton = landmarks.menton;
   690→        const tragus = landmarks.intertragicNotch;
   691→        if (!gonionTop || !gonionBottom || !menton || !tragus) return null;
   692→
   693→        const angle1 = Math.atan2(gonionTop.y - tragus.y, gonionTop.x - tragus.x);
   694→        const angle2 = Math.atan2(gonionBottom.y - menton.y, gonionBottom.x - menton.x);
   695→        let angleDiff = (180 / Math.PI) * Math.abs(angle1 - angle2);
   696→        return angleDiff > 180 ? 360 - angleDiff : angleDiff;
   697→    },
   698→
   699→    "Nasolabial Angle": (landmarks) => {
   700→        const columella = landmarks.columella;
   701→        const subnasale = landmarks.subnasale;
   702→        const labraleSuperius = landmarks.labraleSuperius;
   703→        if (!columella || !subnasale || !labraleSuperius) return null;
   704→
   705→        return angle(columella, subnasale, labraleSuperius);
   706→    },
   707→
   708→    "Nasofrontal Angle": (landmarks) => {
   709→        const glabella = landmarks.glabella;
   710→        const nasion = landmarks.nasion;
   711→        const supratip = landmarks.supratip;
   712→        if (!glabella || !nasion || !supratip) return null;
   713→
   714→        return angle(glabella, nasion, supratip);
   715→    },
   716→
   717→    "Mentolabial Angle": (landmarks) => {
   718→        const labraleInferius = landmarks.labraleInferius;
   719→        const sublabiale = landmarks.sublabiale;
   720→        const pogonion = landmarks.pogonion;
   721→        if (!labraleInferius || !sublabiale || !pogonion) return null;
   722→
   723→        return angle(labraleInferius, sublabiale, pogonion);
   724→    },
   725→
   726→    "Facial Convexity (Glabella)": (landmarks) => {
   727→        const glabella = landmarks.glabella;
   728→        const subnasale = landmarks.subnasale;
   729→        const pogonion = landmarks.pogonion;
   730→        if (!glabella || !subnasale || !pogonion) return null;
   731→
   732→        return angle(glabella, subnasale, pogonion);
   733→    },
   734→
   735→    "Total Facial Convexity": (landmarks) => {
   736→        const glabella = landmarks.glabella;
   737→        const pronasale = landmarks.pronasale;
   738→        const pogonion = landmarks.pogonion;
   739→        if (!glabella || !pronasale || !pogonion) return null;
   740→
   741→        const baseAngle = angle(glabella, pronasale, pogonion);
   742→
   743→        // Determine if convex or concave
   744→        const v1 = { x: glabella.x - pronasale.x, y: glabella.y - pronasale.y };
   745→        const v2 = { x: pogonion.x - pronasale.x, y: pogonion.y - pronasale.y };
   746→        const cross = v1.x * v2.y - v1.y * v2.x;
   747→
   748→        return cross < 0 ? baseAngle : 360 - baseAngle;
   749→    },
   750→
   751→    "Submental Cervical Angle": (landmarks) => {
   752→        const menton = landmarks.menton;
   753→        const cervicalPoint = landmarks.cervicalPoint;
   754→        const neckPoint = landmarks.neckPoint;
   755→        if (!menton || !cervicalPoint || !neckPoint) return null;
   756→
   757→        return angle(menton, cervicalPoint, neckPoint);
   758→    },
   759→
   760→    "Nasal Tip Angle": (landmarks) => {
   761→        const supratip = landmarks.supratip;
   762→        const pronasale = landmarks.pronasale;
   763→        const infratip = landmarks.infratip;
   764→        if (!supratip || !pronasale || !infratip) return null;
   765→
   766→        return angle(supratip, pronasale, infratip);
   767→    },
   768→
   769→    "Nasofacial Angle": (landmarks) => {
   770→        const nasion = landmarks.nasion;
   771→        const pronasale = landmarks.pronasale;
   772→        const pogonion = landmarks.pogonion;
   773→        if (!nasion || !pronasale || !pogonion) return null;
   774→
   775→        const baseAngle = angle(pronasale, nasion, pogonion);
   776→        return baseAngle > 90 ? 180 - baseAngle : baseAngle;
   777→    },
   778→
   779→    "Mandibular Plane Angle": (landmarks) => {
   780→        const gonionTop = landmarks.gonionTop;
   781→        const gonionBottom = landmarks.gonionBottom;
   782→        const menton = landmarks.menton;
   783→        const tragus = landmarks.tragus;
   784→        if (!gonionTop || !gonionBottom || !menton || !tragus) return null;
   785→
   786→        // Calculate intersection of mandibular plane with Frankfort horizontal
   787→        // Complex geometric calculation...
   788→        // Returns angle in degrees
   789→    }
   790→};
   791→```
   792→
   793→---
   794→
   795→## 6. Decoded Scoring Standards Database
   796→
   797→### 6.1 Confirmed Ratios (Clear Names)
   798→
   799→| Ratio Name | Ideal Min | Ideal Max | Unit | Profile | Decay Rate |
   800→|------------|-----------|-----------|------|---------|------------|
   801→| Top Third | 29.00 | 33.00 | % | Front | 0.2 |
   802→| Middle Third | 31.00 | 34.00 | % | Front | 0.2 |
   803→| Lower Third | 33.40 | 37.50 | % | Front | 0.2 |
   804→| Eye Separation Ratio | 45.00 | 47.50 | % | Front | 0.2 |
   805→| Eyebrow Low Setedness | 0.00 | 0.66 | x | Front | 0.2 |
   806→| Total Facial Width to Height Ratio | 1.33 | 1.38 | x | Front | 0.2 |
   807→| Gonial Angle | 113.00 | 123.00 | ° | Side | 0.2 |
   808→| Facial Convexity (Glabella) | 167.00 | 176.00 | ° | Side | 0.2 |
   809→| Submental Cervical Angle | 92.00 | 110.00 | ° | Side | 0.2 |
   810→| Recession relative to Frankfort plane | 0.00 | 15.00 | mm | Side | 0.2 |
   811→
   812→### 6.2 Fingerprinted Ratios (Decoded from Obfuscation)
   813→
   814→Based on anthropometric analysis matching ideal ranges to scientific literature:
   815→
   816→| Predicted Ratio Name | Ideal Min | Ideal Max | Unit | Confidence | Evidence |
   817→|---------------------|-----------|-----------|------|------------|----------|
   818→| **Nasolabial Angle** | 60.54 | 105.97 | ° | 95% | Matches Farkas 90-105° standard |
   819→| **Nasofrontal Angle** | 142.50 | 150.12 | ° | 95% | Matches Powell 130-140° (scaled) |
   820→| **Mentolabial Angle** | 65.19 | 101.55 | ° | 85% | Matches standard 80-120° |
   821→| **Eye Aspect Ratio** | 2.44 | 2.89 | x | 85% | Matches Farkas palpebral fissure 2.5-3.0 |
   822→| **Lower Lip E-Line Position** | -25.61 | -11.04 | DW | 90% | Ricketts E-line standard (scaled) |
   823→| **Upper Lip E-Line Position** | -18.63 | -8.83 | DW | 90% | Upper lip E-line standard (scaled) |
   824→| **Upper Lip S-Line Position** | -4.66 | 0.00 | DW | 75% | Steiner S-line standard |
   825→| **Lower Lip S-Line Position** | -2.33 | 2.21 | DW | 75% | S-line balanced position |
   826→| **Upper Lip Burstone Line** | -2.33 | 2.21 | DW | 70% | Burstone line standard |
   827→| **Deviation of IAA & JFA** | 0.00 | 11.04 | DW | 85% | Zero = perfect symmetry |
   828→| **Ear Protrusion Angle** | 0.00 | 17.66 | ° | 80% | Standard 15-20° from head |
   829→| **Bigonial Width %** | 37.25 | 57.40 | % | 80% | Jaw-to-face width ratio |
   830→| **Bitemporal Width %** | 46.57 | 52.98 | % | 80% | Temple-to-cheek ratio |
   831→| **Chin to Philtrum Ratio** | 4.42 | 4.50 | DW | 80% | Very tight range (critical ratio) |
   832→| **Total Facial Convexity** | 135.05 | 172.19 | ° | 85% | Standard 140-150° |
   833→| **Nasal Tip Angle** | 139.70 | 158.95 | ° | 70% | Nasal tip definition |
   834→| **Mouth Width to Nose Width** | 2.77 | 3.78 | x | 65% | Powell 1.5x (scaled ~3.0) |
   835→| **Lower Lip to Upper Lip Ratio** | 4.19 | 4.46 | DW | 70% | Standard 1:1.6-2.0 (scaled) |
   836→| **Ipsilateral Alar Angle** | 26.08 | 36.65 | ° | 60% | Midface width relationship |
   837→| **Cheekbone Height %** | 23.28 | 57.40 | % | 65% | Position as % of face height |
   838→| **Mandibular Plane Angle** | 41.91 | 97.13 | DW | 65% | Wide range (scaled 20-30°) |
   839→
   840→### 6.3 Understanding the "DW" Unit
   841→
   842→The "DW" (Digital Width) unit appears to be a **normalized measurement system**:
   843→
   844→```
   845→DW = Actual_Measurement × Scale_Factor
   846→
   847→Where Scale_Factor ≈ 10 for mm measurements
   848→      Scale_Factor ≈ 100 for small ratios
   849→```
   850→
   851→**Conversion Guide:**
   852→- Values 0-50 DW → Likely percentages or small ratios
   853→- Values 50-200 DW → Likely angles in degrees or scaled mm
   854→- Values 300-800 DW → Likely mm measurements × 10 or complex scaled ratios
   855→
   856→### 6.4 Complete Ratio Configuration Schema
   857→
   858→```javascript
   859→const RATIO_CONFIG = {
   860→    "Top Third": {
   861→        name: "Top Third",
   862→        profileType: "front",
   863→        idealMin: 29.00,
   864→        idealMax: 33.00,
   865→        unit: "%",
   866→        decayRate: 0.2,
   867→        category: "Facial Proportions",
   868→        description: "Percentage of face height from hairline to brow line",
   869→        landmarks: ["hairline", "leftBrowHead", "leftBrowInnerCorner",
   870→                   "rightBrowHead", "rightBrowInnerCorner", "chinBottom"]
   871→    },
   872→    "Nasolabial Angle": {
   873→        name: "Nasolabial Angle",
   874→        profileType: "side",
   875→        idealMin: 90.00,  // Unscaled standard value
   876→        idealMax: 105.00,
   877→        unit: "°",
   878→        decayRate: 0.2,
   879→        category: "Nasal Angles",
   880→        description: "Angle between columella and upper lip",
   881→        landmarks: ["columella", "subnasale", "labraleSuperius"],
   882→        scientificReference: "Farkas LG, 1994"
   883→    },
   884→    // ... additional configurations
   885→};
   886→```
   887→
   888→---
   889→
   890→## 7. Implementation Strategy
   891→
   892→### 7.1 Required Libraries
   893→
   894→```json
   895→{
   896→  "dependencies": {
   897→    "@mediapipe/tasks-vision": "^0.10.0",
   898→    "react": "^18.0.0",
   899→    "next": "^14.0.0"
   900→  },
   901→  "devDependencies": {
   902→    "typescript": "^5.0.0"
   903→  }
   904→}
   905→```
   906→
   907→**Python Backend (Alternative):**
   908→```
   909→mediapipe>=0.10.0
   910→opencv-python>=4.8.0
   911→numpy>=1.24.0
   912→flask>=2.3.0  # or fastapi
   913→```
   914→
   915→### 7.2 Project Structure
   916→
   917→```
   918→facial-analysis/
   919→├── src/
   920→│   ├── lib/
   921→│   │   ├── mediapipe/
   922→│   │   │   ├── faceLandmarker.ts      # MediaPipe initialization
   923→│   │   │   └── landmarkMapper.ts       # Index to name mapping
   924→│   │   ├── calculations/
   925→│   │   │   ├── ratios.ts              # Ratio calculation functions
   926→│   │   │   ├── scoring.ts             # Score calculation engine
   927→│   │   │   └── utilities.ts           # Math helper functions
   928→│   │   ├── standards/
   929→│   │   │   ├── idealRanges.ts         # Ideal min/max database
   930→│   │   │   └── ratioConfig.ts         # Full ratio configurations
   931→│   │   └── types/
   932→│   │       └── index.ts               # TypeScript interfaces
   933→│   ├── components/
   934→│   │   ├── FaceCapture.tsx            # Camera/upload component
   935→│   │   ├── AnalysisResults.tsx        # Score display
   936→│   │   └── RatioVisualization.tsx     # Overlay visualization
   937→│   └── api/
   938→│       └── side-landmarks/
   939→│           └── route.ts               # Side profile API
   940→├── public/
   941→│   └── models/                        # MediaPipe model files
   942→└── package.json
   943→```
   944→
   945→### 7.3 TypeScript Interfaces
   946→
   947→```typescript
   948→interface Point {
   949→    x: number;
   950→    y: number;
   951→    z?: number;
   952→}
   953→
   954→interface NamedLandmarks {
   955→    [key: string]: Point | null;
   956→}
   957→
   958→interface RatioConfig {
   959→    name: string;
   960→    profileType: "front" | "side";
   961→    idealMin: number;
   962→    idealMax: number;
   963→    unit: string;
   964→    decayRate: number;
   965→    category: string;
   966→    description: string;
   967→    landmarks: string[];
   968→    calculationFn?: (landmarks: NamedLandmarks) => number | null;
   969→}
   970→
   971→interface RatioResult {
   972→    name: string;
   973→    value: number | null;
   974→    score: number | null;
   975→    standardizedScore: number;
   976→    idealMin: number;
   977→    idealMax: number;
   978→    unit: string;
   979→    deviation: "below" | "ideal" | "above";
   980→    isIdeal: boolean;
   981→}
   982→
   983→interface AnalysisResult {
   984→    frontRatios: RatioResult[];
   985→    sideRatios: RatioResult[];
   986→    overallScore: number;
   987→    categoryScores: { [category: string]: number };
   988→    landmarks: {
   989→        front: NamedLandmarks;
   990→        side: NamedLandmarks;
   991→    };
   992→}
   993→```
   994→
   995→### 7.4 Quick Start Implementation
   996→
   997→```typescript
   998→// main.ts - Minimal implementation
   999→
  1000→import { FaceLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";
  1001→import { FRONT_LANDMARK_INDICES, FRONT_RATIO_CALCULATIONS, RATIO_CONFIG } from "./config";
  1002→
  1003→class FacialAnalyzer {
  1004→    private faceLandmarker: FaceLandmarker | null = null;
  1005→
  1006→    async initialize() {
  1007→        const wasmFileset = await FilesetResolver.forVisionTasks(
  1008→            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
  1009→        );
  1010→
  1011→        this.faceLandmarker = await FaceLandmarker.createFromModelPath(
  1012→            wasmFileset,
  1013→            "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
  1014→        );
  1015→    }
  1016→
  1017→    analyzeFrontProfile(imageElement: HTMLImageElement): AnalysisResult {
  1018→        if (!this.faceLandmarker) throw new Error("Not initialized");
  1019→
  1020→        // Detect landmarks
  1021→        const results = this.faceLandmarker.detect(imageElement);
  1022→        if (!results.faceLandmarks.length) throw new Error("No face detected");
  1023→
  1024→        const rawLandmarks = results.faceLandmarks[0];
  1025→
  1026→        // Map to named points
  1027→        const namedLandmarks = this.mapLandmarks(rawLandmarks, imageElement);
  1028→
  1029→        // Calculate ratios
  1030→        const ratios = this.calculateRatios(namedLandmarks, "front");
  1031→
  1032→        // Score ratios
  1033→        const scoredRatios = this.scoreRatios(ratios);
  1034→
  1035→        return {
  1036→            frontRatios: scoredRatios,
  1037→            sideRatios: [],
  1038→            overallScore: this.calculateOverallScore(scoredRatios),
  1039→            categoryScores: this.calculateCategoryScores(scoredRatios),
  1040→            landmarks: { front: namedLandmarks, side: {} }
  1041→        };
  1042→    }
  1043→
  1044→    private mapLandmarks(raw: Point[], image: HTMLImageElement): NamedLandmarks {
  1045→        const named: NamedLandmarks = {};
  1046→
  1047→        for (const [name, index] of Object.entries(FRONT_LANDMARK_INDICES)) {
  1048→            if (typeof index === "number" && raw[index]) {
  1049→                named[name] = {
  1050→                    x: raw[index].x * image.width,
  1051→                    y: raw[index].y * image.height
  1052→                };
  1053→            }
  1054→        }
  1055→
  1056→        return named;
  1057→    }
  1058→
  1059→    private calculateRatios(landmarks: NamedLandmarks, profile: "front" | "side") {
  1060→        const calculations = profile === "front"
  1061→            ? FRONT_RATIO_CALCULATIONS
  1062→            : SIDE_RATIO_CALCULATIONS;
  1063→
  1064→        return Object.entries(calculations).map(([name, fn]) => ({
  1065→            name,
  1066→            value: fn(landmarks),
  1067→            config: RATIO_CONFIG[name]
  1068→        }));
  1069→    }
  1070→
  1071→    private scoreRatios(ratios: any[]): RatioResult[] {
  1072→        return ratios.map(r => {
  1073→            const score = r.value !== null
  1074→                ? this.calculateScore(r.value, r.config.idealMin, r.config.idealMax, r.config.decayRate)
  1075→                : null;
  1076→
  1077→            return {
  1078→                name: r.name,
  1079→                value: r.value,
  1080→                score,
  1081→                standardizedScore: score ?? 0,
  1082→                idealMin: r.config.idealMin,
  1083→                idealMax: r.config.idealMax,
  1084→                unit: r.config.unit,
  1085→                deviation: this.getDeviation(r.value, r.config.idealMin, r.config.idealMax),
  1086→                isIdeal: r.value !== null && r.value >= r.config.idealMin && r.value <= r.config.idealMax
  1087→            };
  1088→        });
  1089→    }
  1090→
  1091→    private calculateScore(value: number, min: number, max: number, decay: number = 0.2): number {
  1092→        const maxScore = 10;
  1093→        const minScore = -maxScore;
  1094→
  1095→        let rawScore: number;
  1096→        if (value >= min && value <= max) {
  1097→            rawScore = maxScore;
  1098→        } else {
  1099→            const distance = value < min ? (min - value) : (value - max);
  1100→            rawScore = minScore + (maxScore - minScore) * Math.exp(-decay * distance);
  1101→        }
  1102→
  1103→        const range = maxScore - minScore;
  1104→        return Math.max(0, Math.min(10, ((rawScore - minScore) / range) * 10));
  1105→    }
  1106→
  1107→    private getDeviation(value: number | null, min: number, max: number): "below" | "ideal" | "above" {
  1108→        if (value === null) return "ideal";
  1109→        if (value < min) return "below";
  1110→        if (value > max) return "above";
  1111→        return "ideal";
  1112→    }
  1113→
  1114→    private calculateOverallScore(ratios: RatioResult[]): number {
  1115→        const validScores = ratios.filter(r => r.score !== null).map(r => r.score!);
  1116→        return validScores.length ? validScores.reduce((a, b) => a + b, 0) / validScores.length : 0;
  1117→    }
  1118→
  1119→    private calculateCategoryScores(ratios: RatioResult[]): { [key: string]: number } {
  1120→        const categories: { [key: string]: number[] } = {};
  1121→
  1122→        for (const ratio of ratios) {
  1123→            const category = RATIO_CONFIG[ratio.name]?.category || "Other";
  1124→            if (!categories[category]) categories[category] = [];
  1125→            if (ratio.score !== null) categories[category].push(ratio.score);
  1126→        }
  1127→
  1128→        const scores: { [key: string]: number } = {};
  1129→        for (const [cat, values] of Object.entries(categories)) {
  1130→            scores[cat] = values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;
  1131→        }
  1132→
  1133→        return scores;
  1134→    }
  1135→}
  1136→
  1137→export default FacialAnalyzer;
  1138→```
  1139→
  1140→---
  1141→
  1142→## 8. API Reference
  1143→
  1144→### 8.1 Side Landmarks API
  1145→
  1146→**Endpoint:** `POST /api/side-landmarks`
  1147→
  1148→**Request:**
  1149→```
  1150→Content-Type: multipart/form-data
  1151→
  1152→Fields:
  1153→- image: JPEG/PNG file (side profile photo)
  1154→```
  1155→
  1156→**Response:**
  1157→```json
  1158→{
  1159→    "success": true,
  1160→    "data": {
  1161→        "landmarks": [
  1162→            { "x": 0.123, "y": 0.456 },
  1163→            // ... 106 landmark points
  1164→        ],
  1165→        "direction": "left",  // or "right"
  1166→        "rotationAngle": 2.5,
  1167→        "center": { "x": 0.5, "y": 0.5 },
  1168→        "crop": {
  1169→            "x": 100,
  1170→            "y": 50,
  1171→            "width": 400,
  1172→            "height": 500,
  1173→            "scale": 1.2
  1174→        },
  1175→        "bbox": {
  1176→            "minX": 100,
  1177→            "minY": 50,
  1178→            "maxX": 500,
  1179→            "maxY": 550
  1180→        }
  1181→    }
  1182→}
  1183→```
  1184→
  1185→### 8.2 Analysis API
  1186→
  1187→**Endpoint:** `POST /api/faces`
  1188→
  1189→**Request:**
  1190→```json
  1191→{
  1192→    "frontPhotoUrl": "data:image/jpeg;base64,...",
  1193→    "sidePhotoUrl": "data:image/jpeg;base64,...",
  1194→    "gender": "male",
  1195→    "ethnicity": "caucasian"
  1196→}
  1197→```
  1198→
  1199→**Response:**
  1200→```json
  1201→{
  1202→    "success": true,
  1203→    "faceId": "abc123",
  1204→    "frontRatios": [
  1205→        {
  1206→            "name": "Eye Separation Ratio",
  1207→            "value": 46.5,
  1208→            "score": 9.2,
  1209→            "standardizedScore": 9.2,
  1210→            "unit": "%",
  1211→            "idealMin": 45.0,
  1212→            "idealMax": 47.5
  1213→        }
  1214→    ],
  1215→    "sideRatios": [...],
  1216→    "overallScore": 7.8
  1217→}
  1218→```
  1219→
  1220→---
  1221→
  1222→## Appendix A: Scientific References
  1223→
  1224→1. **Farkas LG** (1994). "Anthropometry of the Head and Face" - Primary source for facial proportions
  1225→2. **Powell N, Humphreys B** (1984). "Proportions of the Aesthetic Face" - Golden ratio applications
  1226→3. **Ricketts RM** (1968). "The Esthetic E-Plane" - E-line lip position standards
  1227→4. **Steiner CC** (1959). "Cephalometrics for You and Me" - S-line standards
  1228→5. **Burstone CJ** (1967). "Lip Posture and Its Significance" - Burstone line
  1229→
  1230→---
  1231→
  1232→## Appendix B: Changelog
  1233→
  1234→| Version | Date | Changes |
  1235→|---------|------|---------|
  1236→| 1.0 | Dec 2024 | Initial reverse-engineering documentation |
  1237→
  1238→---
  1239→
  1240→*This document was created through reverse-engineering of publicly accessible web application code for educational and research purposes.*
  1241→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
