     1→'use client';
     2→
     3→import { useMemo, useState, useEffect, useRef } from 'react';
     4→import { motion, AnimatePresence } from 'framer-motion';
     5→import Image from 'next/image';
     6→import { Eye, ZoomIn, ZoomOut, Maximize2, Crosshair, Scan } from 'lucide-react';
     7→import { LandmarkPoint } from '@/lib/landmarks';
     8→import { Ratio, getScoreColor, getCategoryColor } from '@/types/results';
     9→
    10→interface FaceOverlayProps {
    11→  photo: string;
    12→  landmarks: LandmarkPoint[];
    13→  selectedRatio: Ratio | null;
    14→  profileType: 'front' | 'side';
    15→  showAllLandmarks?: boolean;
    16→  compact?: boolean;
    17→}
    18→
    19→interface ImageDimensions {
    20→  naturalWidth: number;
    21→  naturalHeight: number;
    22→  aspectRatio: number;
    23→}
    24→
    25→function getLabelPosition(
    26→  x1: number, y1: number, x2: number, y2: number,
    27→  position: 'start' | 'middle' | 'end' = 'middle'
    28→): { x: number; y: number; anchor: string } {
    29→  const t = position === 'start' ? 0.15 : position === 'end' ? 0.85 : 0.5;
    30→  const x = x1 + (x2 - x1) * t;
    31→  const y = y1 + (y2 - y1) * t;
    32→
    33→  const dx = x2 - x1;
    34→  const dy = y2 - y1;
    35→  const len = Math.sqrt(dx * dx + dy * dy);
    36→  const offsetX = len > 0 ? (-dy / len) * 2.5 : 0;
    37→  const offsetY = len > 0 ? (dx / len) * 2.5 : 0;
    38→
    39→  return {
    40→    x: x + offsetX,
    41→    y: y + offsetY,
    42→    anchor: dx > 0 ? 'start' : 'end'
    43→  };
    44→}
    45→
    46→function calculateAngle(p1: { x: number; y: number }, vertex: { x: number; y: number }, p3: { x: number; y: number }): number {
    47→  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
    48→  const v2 = { x: p3.x - vertex.x, y: p3.y - vertex.y };
    49→
    50→  const dot = v1.x * v2.x + v1.y * v2.y;
    51→  const cross = v1.x * v2.y - v1.y * v2.x;
    52→
    53→  return Math.atan2(Math.abs(cross), dot) * (180 / Math.PI);
    54→}
    55→
    56→export function FaceOverlay({
    57→  photo,
    58→  landmarks,
    59→  selectedRatio,
    60→  profileType,
    61→  showAllLandmarks: initialShowAllLandmarks = false,
    62→  compact = false,
    63→}: FaceOverlayProps) {
    64→  const [zoom, setZoom] = useState(1);
    65→  const [transformOrigin, setTransformOrigin] = useState({ x: 50, y: 50 });
    66→  const [showAllLandmarks, setShowAllLandmarks] = useState(initialShowAllLandmarks);
    67→  const [imageDimensions, setImageDimensions] = useState<ImageDimensions | null>(null);
    68→  const containerRef = useRef<HTMLDivElement>(null);
    69→  const hasAutoZoomed = useRef(false);
    70→
    71→  useEffect(() => {
    72→    // Reset auto-zoom flag when photo changes
    73→    hasAutoZoomed.current = false;
    74→  }, [photo]);
    75→
    76→  useEffect(() => {
    77→    // Auto-zoom to face when landmarks are available and we haven't zoomed yet
    78→    if (landmarks.length > 0 && !hasAutoZoomed.current && !compact) {
    79→      // Calculate face bounding box
    80→      let minX = 1, minY = 1, maxX = 0, maxY = 0;
    81→      landmarks.forEach(l => {
    82→        if (l.x < minX) minX = l.x;
    83→        if (l.y < minY) minY = l.y;
    84→        if (l.x > maxX) maxX = l.x;
    85→        if (l.y > maxY) maxY = l.y;
    86→      });
    87→
    88→      // Add padding
    89→      const padding = 0.2; // 20% padding
    90→      const width = maxX - minX;
    91→      const height = maxY - minY;
    92→
    93→      // Calculate center
    94→      const centerX = minX + width / 2;
    95→      const centerY = minY + height / 2;
    96→
    97→      // Calculate needed zoom to fit face with padding
    98→      // We want the face (plus padding) to fill the viewport
    99→      // scale = 1 / (size + padding)
   100→      const scaleX = 1 / (width + padding);
   101→      const scaleY = 1 / (height + padding);
   102→
   103→      // Use the smaller scale to ensure fit, capped at 2x and min 1x
   104→      const targetZoom = Math.min(Math.max(Math.min(scaleX, scaleY), 1), 2.5);
   105→
   106→      setTransformOrigin({ x: centerX * 100, y: centerY * 100 });
   107→      setZoom(targetZoom);
   108→      hasAutoZoomed.current = true;
   109→    }
   110→  }, [landmarks, compact, photo]);
   111→
   112→  useEffect(() => {
   113→    setShowAllLandmarks(initialShowAllLandmarks);
   114→  }, [initialShowAllLandmarks]);
   115→
   116→  useEffect(() => {
   117→    const img = new window.Image();
   118→    img.onload = () => {
   119→      setImageDimensions({
   120→        naturalWidth: img.naturalWidth,
   121→        naturalHeight: img.naturalHeight,
   122→        aspectRatio: img.naturalWidth / img.naturalHeight,
   123→      });
   124→    };
   125→    img.src = photo;
   126→  }, [photo]);
   127→
   128→  const landmarkMap = useMemo(() => {
   129→    const map: Record<string, LandmarkPoint> = {};
   130→    landmarks.forEach(l => {
   131→      map[l.id] = l;
   132→    });
   133→    return map;
   134→  }, [landmarks]);
   135→
   136→  const viewBoxDimensions = useMemo(() => {
   137→    if (!imageDimensions) {
   138→      return { width: 75, height: 100, viewBox: '0 0 75 100' };
   139→    }
   140→    const ar = imageDimensions.aspectRatio;
   141→    if (ar >= 1) {
   142→      const width = 100;
   143→      const height = 100 / ar;
   144→      return { width, height, viewBox: `0 0 ${width} ${height}` };
   145→    } else {
   146→      const width = 100 * ar;
   147→      const height = 100;
   148→      return { width, height, viewBox: `0 0 ${width} ${height}` };
   149→    }
   150→  }, [imageDimensions]);
   151→
   152→  const visualizationData = useMemo(() => {
   153→    if (!selectedRatio?.illustration) return null;
   154→
   155→    const { width: vbW, height: vbH } = viewBoxDimensions;
   156→
   157→    const points: Array<{ x: number; y: number; id: string; label?: string }> = [];
   158→    const lines: Array<{
   159→      x1: number; y1: number; x2: number; y2: number;
   160→      color: string; label?: string; labelPosition?: 'start' | 'middle' | 'end'
   161→    }> = [];
   162→    const angles: Array<{
   163→      vertex: { x: number; y: number };
   164→      p1: { x: number; y: number };
   165→      p2: { x: number; y: number };
   166→      color: string;
   167→      angle: number;
   168→    }> = [];
   169→
   170→    Object.entries(selectedRatio.illustration.points).forEach(([key, point]) => {
   171→      if (point.type === 'landmark' && point.landmarkId) {
   172→        const landmark = landmarkMap[point.landmarkId];
   173→        if (landmark) {
   174→          points.push({
   175→            x: landmark.x * vbW,
   176→            y: landmark.y * vbH,
   177→            id: point.landmarkId,
   178→            label: landmark.label,
   179→          });
   180→        }
   181→      } else if (point.x !== undefined && point.y !== undefined) {
   182→        points.push({
   183→          x: point.x * vbW,
   184→          y: point.y * vbH,
   185→          id: key,
   186→          label: point.label,
   187→        });
   188→      }
   189→    });
   190→
   191→    Object.entries(selectedRatio.illustration.lines).forEach(([, line]) => {
   192→      const fromLandmark = landmarkMap[line.from];
   193→      const toLandmark = landmarkMap[line.to];
   194→
   195→      if (fromLandmark && toLandmark) {
   196→        lines.push({
   197→          x1: fromLandmark.x * vbW,
   198→          y1: fromLandmark.y * vbH,
   199→          x2: toLandmark.x * vbW,
   200→          y2: toLandmark.y * vbH,
   201→          color: line.color || getCategoryColor(selectedRatio.category),
   202→          label: line.label,
   203→          labelPosition: line.labelPosition,
   204→        });
   205→      }
   206→    });
   207→
   208→    const tolerance = Math.max(vbW, vbH) * 0.01;
   209→
   210→    if (lines.length === 2) {
   211→      const l1 = lines[0];
   212→      const l2 = lines[1];
   213→
   214→      let sharedVertex: { x: number; y: number } | null = null;
   215→      let p1: { x: number; y: number } | null = null;
   216→      let p2: { x: number; y: number } | null = null;
   217→
   218→      if (Math.abs(l1.x2 - l2.x1) < tolerance && Math.abs(l1.y2 - l2.y1) < tolerance) {
   219→        sharedVertex = { x: l1.x2, y: l1.y2 };
   220→        p1 = { x: l1.x1, y: l1.y1 };
   221→        p2 = { x: l2.x2, y: l2.y2 };
   222→      }
   223→      else if (Math.abs(l1.x1 - l2.x1) < tolerance && Math.abs(l1.y1 - l2.y1) < tolerance) {
   224→        sharedVertex = { x: l1.x1, y: l1.y1 };
   225→        p1 = { x: l1.x2, y: l1.y2 };
   226→        p2 = { x: l2.x2, y: l2.y2 };
   227→      }
   228→      else if (Math.abs(l1.x2 - l2.x2) < tolerance && Math.abs(l1.y2 - l2.y2) < tolerance) {
   229→        sharedVertex = { x: l1.x2, y: l1.y2 };
   230→        p1 = { x: l1.x1, y: l1.y1 };
   231→        p2 = { x: l2.x1, y: l2.y1 };
   232→      }
   233→      else if (Math.abs(l1.x1 - l2.x2) < tolerance && Math.abs(l1.y1 - l2.y2) < tolerance) {
   234→        sharedVertex = { x: l1.x1, y: l1.y1 };
   235→        p1 = { x: l1.x2, y: l1.y2 };
   236→        p2 = { x: l2.x1, y: l2.y1 };
   237→      }
   238→
   239→      if (sharedVertex && p1 && p2) {
   240→        const angle = calculateAngle(p1, sharedVertex, p2);
   241→        angles.push({
   242→          vertex: sharedVertex,
   243→          p1,
   244→          p2,
   245→          color: l1.color,
   246→          angle,
   247→        });
   248→      }
   249→    }
   250→
   251→    return { points, lines, angles };
   252→  }, [selectedRatio, landmarkMap, viewBoxDimensions]);
   253→
   254→  const generateArcPath = (
   255→    vertex: { x: number; y: number },
   256→    p1: { x: number; y: number },
   257→    p2: { x: number; y: number },
   258→    radius: number = 4
   259→  ): string => {
   260→    const angle1 = Math.atan2(p1.y - vertex.y, p1.x - vertex.x);
   261→    const angle2 = Math.atan2(p2.y - vertex.y, p2.x - vertex.x);
   262→
   263→    const x1 = vertex.x + radius * Math.cos(angle1);
   264→    const y1 = vertex.y + radius * Math.sin(angle1);
   265→    const x2 = vertex.x + radius * Math.cos(angle2);
   266→    const y2 = vertex.y + radius * Math.sin(angle2);
   267→
   268→    let angleDiff = angle2 - angle1;
   269→    if (angleDiff < 0) angleDiff += 2 * Math.PI;
   270→    const largeArc = angleDiff > Math.PI ? 1 : 0;
   271→
   272→    return `M ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}`;
   273→  };
   274→
   275→  if (compact) {
   276→    return (
   277→      <div className="rounded-2xl bg-neutral-900/40 border border-white/5 overflow-hidden">
   278→        <div
   279→          ref={containerRef}
   280→          className="relative aspect-square bg-neutral-950"
   281→        >
   282→          <Image
   283→            src={photo}
   284→            alt={`${profileType} profile`}
   285→            fill
   286→            className="object-contain"
   287→            unoptimized
   288→          />
   289→          <svg
   290→            className="absolute inset-0 w-full h-full pointer-events-none"
   291→            viewBox={viewBoxDimensions.viewBox}
   292→            preserveAspectRatio="xMidYMid meet"
   293→          >
   294→            <defs>
   295→              <filter id="glow-compact" x="-50%" y="-50%" width="200%" height="200%">
   296→                <feGaussianBlur stdDeviation="0.5" result="coloredBlur" />
   297→                <feMerge>
   298→                  <feMergeNode in="coloredBlur" />
   299→                  <feMergeNode in="SourceGraphic" />
   300→                </feMerge>
   301→              </filter>
   302→            </defs>
   303→            <AnimatePresence>
   304→              {visualizationData && (() => {
   305→                const { width: vbW, height: vbH } = viewBoxDimensions;
   306→                const baseSize = Math.max(vbW, vbH);
   307→                const strokeGlow = baseSize * 0.012;
   308→                const strokeMain = baseSize * 0.005;
   309→                const pointRadiusOuter = baseSize * 0.02;
   310→                const pointRadiusRing = baseSize * 0.012;
   311→                const pointRadiusInner = baseSize * 0.006;
   312→
   313→                return (
   314→                  <g filter="url(#glow-compact)">
   315→                    {visualizationData.lines.map((line, i) => (
   316→                      <g key={`line-${i}`}>
   317→                        <motion.line
   318→                          x1={line.x1} y1={line.y1} x2={line.x2} y2={line.y2}
   319→                          stroke={line.color} strokeWidth={strokeGlow} strokeLinecap="round"
   320→                          opacity="0.3"
   321→                          initial={{ pathLength: 0 }} animate={{ pathLength: 1 }}
   322→                          transition={{ duration: 0.5 }}
   323→                        />
   324→                        <motion.line
   325→                          x1={line.x1} y1={line.y1} x2={line.x2} y2={line.y2}
   326→                          stroke={line.color} strokeWidth={strokeMain} strokeLinecap="round"
   327→                          initial={{ pathLength: 0, opacity: 0 }} animate={{ pathLength: 1, opacity: 1 }}
   328→                          transition={{ duration: 0.5 }}
   329→                        />
   330→                      </g>
   331→                    ))}
   332→                    {visualizationData.points.map((point, i) => (
   333→                      <motion.g
   334→                        key={`point-${i}`}
   335→                        initial={{ scale: 0, opacity: 0 }}
   336→                        animate={{ scale: 1, opacity: 1 }}
   337→                        transition={{ duration: 0.3, delay: i * 0.05 }}
   338→                      >
   339→                        <circle cx={point.x} cy={point.y} r={pointRadiusOuter}
   340→                          fill={getCategoryColor(selectedRatio?.category || '')} opacity="0.15" />
   341→                        <circle cx={point.x} cy={point.y} r={pointRadiusRing}
   342→                          fill="none" stroke={getCategoryColor(selectedRatio?.category || '')}
   343→                          strokeWidth={pointRadiusInner * 0.3} opacity="0.5" />
   344→                        <circle cx={point.x} cy={point.y} r={pointRadiusInner}
   345→                          fill="#fff" stroke={getCategoryColor(selectedRatio?.category || '')}
   346→                          strokeWidth={pointRadiusInner * 0.25} />
   347→                      </motion.g>
   348→                    ))}
   349→                  </g>
   350→                );
   351→              })()}
   352→            </AnimatePresence>
   353→          </svg>
   354→          {!selectedRatio && (
   355→            <div className="absolute inset-0 flex items-center justify-center bg-black/50">
   356→              <div className="text-center p-4">
   357→                <Eye size={24} className="mx-auto text-neutral-600 mb-2" />
   358→                <p className="text-[10px] text-neutral-500 uppercase tracking-widest font-medium">
   359→                  Select ratio
   360→                </p>
   361→              </div>
   362→            </div>
   363→          )}
   364→        </div>
   365→        {selectedRatio && (
   366→          <div className="px-3 py-2 border-t border-white/5 flex items-center justify-between">
   367→            <span className="text-xs font-bold text-white truncate">{selectedRatio.name}</span>
   368→            <span
   369→              className="text-xs font-black"
   370→              style={{ color: getScoreColor(typeof selectedRatio.score === 'number' ? selectedRatio.score : 0) }}
   371→            >
   372→              {typeof selectedRatio.score === 'number' ? selectedRatio.score.toFixed(1) : selectedRatio.score}
   373→            </span>
   374→          </div>
   375→        )}
   376→      </div>
   377→    );
   378→  }
   379→
   380→  return (
   381→    <div className="rounded-[2rem] bg-neutral-900/40 border border-white/5 overflow-hidden shadow-2xl">
   382→      {/* Header */}
   383→      <div className="p-5 border-b border-white/5 flex items-center justify-between">
   384→        <div className="flex items-center gap-3">
   385→          <div className="w-10 h-10 rounded-xl bg-neutral-900 border border-white/10 flex items-center justify-center">
   386→            <Scan size={18} className="text-cyan-400" />
   387→          </div>
   388→          <div>
   389→            <h4 className="text-sm font-black uppercase tracking-wider text-white">
   390→              {profileType === 'front' ? 'Frontal' : 'Lateral'} <span className="text-cyan-400">Scan</span>
   391→            </h4>
   392→            <p className="text-[10px] text-neutral-500 uppercase tracking-widest font-medium">
   393→              {landmarks.length} landmarks detected
   394→            </p>
   395→          </div>
   396→        </div>
   397→
   398→        {/* Controls */}
   399→        <div className="flex items-center gap-1">
   400→          <button
   401→            onClick={() => setShowAllLandmarks(!showAllLandmarks)}
   402→            className={`w-8 h-8 rounded-lg flex items-center justify-center transition-all ${showAllLandmarks
   403→              ? 'bg-cyan-500/20 text-cyan-400 border border-cyan-500/30'
   404→              : 'bg-neutral-800/50 text-neutral-500 border border-white/5 hover:border-white/10'
   405→              }`}
   406→            title={showAllLandmarks ? 'Hide landmarks' : 'Show landmarks'}
   407→          >
   408→            <Crosshair size={14} />
   409→          </button>
   410→
   411→          <div className="w-px h-6 bg-white/5 mx-1" />
   412→
   413→          <button
   414→            onClick={() => setZoom(z => Math.max(1, z - 0.25))}
   415→            disabled={zoom <= 1}
   416→            className="w-8 h-8 rounded-lg bg-neutral-800/50 border border-white/5 flex items-center justify-center hover:border-white/10 transition-all disabled:opacity-30"
   417→          >
   418→            <ZoomOut size={14} className="text-neutral-400" />
   419→          </button>
   420→          <span className="text-[10px] font-black text-neutral-500 w-10 text-center tracking-wider">
   421→            {Math.round(zoom * 100)}%
   422→          </span>
   423→          <button
   424→            onClick={() => setZoom(z => Math.min(2, z + 0.25))}
   425→            disabled={zoom >= 2}
   426→            className="w-8 h-8 rounded-lg bg-neutral-800/50 border border-white/5 flex items-center justify-center hover:border-white/10 transition-all disabled:opacity-30"
   427→          >
   428→            <ZoomIn size={14} className="text-neutral-400" />
   429→          </button>
   430→          {zoom !== 1 && (
   431→            <button
   432→              onClick={() => setZoom(1)}
   433→              className="w-8 h-8 rounded-lg bg-neutral-800/50 border border-white/5 flex items-center justify-center hover:border-white/10 transition-all ml-1"
   434→            >
   435→              <Maximize2 size={14} className="text-neutral-400" />
   436→            </button>
   437→          )}
   438→        </div>
   439→      </div>
   440→
   441→      {/* Image Container */}
   442→      <div
   443→        ref={containerRef}
   444→        className="relative aspect-[3/4] bg-neutral-950 overflow-hidden"
   445→      >
   446→        <div
   447→          className="absolute inset-0 transition-transform duration-200 ease-out"
   448→          style={{
   449→            transform: `scale(${zoom})`,
   450→            transformOrigin: `${transformOrigin.x}% ${transformOrigin.y}%`
   451→          }}
   452→        >
   453→          <Image
   454→            src={photo}
   455→            alt={`${profileType} profile`}
   456→            fill
   457→            className="object-contain"
   458→            unoptimized
   459→          />
   460→
   461→          <svg
   462→            className="absolute inset-0 w-full h-full pointer-events-none"
   463→            viewBox={viewBoxDimensions.viewBox}
   464→            preserveAspectRatio="xMidYMid meet"
   465→          >
   466→            <defs>
   467→              <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
   468→                <feGaussianBlur stdDeviation="0.5" result="coloredBlur" />
   469→                <feMerge>
   470→                  <feMergeNode in="coloredBlur" />
   471→                  <feMergeNode in="SourceGraphic" />
   472→                </feMerge>
   473→              </filter>
   474→            </defs>
   475→
   476→            {/* All landmarks */}
   477→            {showAllLandmarks && landmarks.map((landmark) => {
   478→              const { width: vbW, height: vbH } = viewBoxDimensions;
   479→              const baseSize = Math.max(vbW, vbH);
   480→
   481→              return (
   482→                <g key={landmark.id}>
   483→                  <circle
   484→                    cx={landmark.x * vbW}
   485→                    cy={landmark.y * vbH}
   486→                    r={baseSize * 0.012}
   487→                    fill="#67e8f9"
   488→                    opacity="0.25"
   489→                  />
   490→                  <circle
   491→                    cx={landmark.x * vbW}
   492→                    cy={landmark.y * vbH}
   493→                    r={baseSize * 0.005}
   494→                    fill="#67e8f9"
   495→                    stroke="#0e7490"
   496→                    strokeWidth={baseSize * 0.002}
   497→                  />
   498→                </g>
   499→              );
   500→            })}
   501→
   502→            {/* Selected ratio visualization */}
   503→            <AnimatePresence>
   504→              {visualizationData && (() => {
   505→                const { width: vbW, height: vbH } = viewBoxDimensions;
   506→                const baseSize = Math.max(vbW, vbH);
   507→                const strokeGlow = baseSize * 0.012;
   508→                const strokeMain = baseSize * 0.005;
   509→                const fontSize = baseSize * 0.02;
   510→                const pointRadiusOuter = baseSize * 0.02;
   511→                const pointRadiusRing = baseSize * 0.012;
   512→                const pointRadiusInner = baseSize * 0.006;
   513→                const arcRadius = baseSize * 0.05;
   514→
   515→                return (
   516→                  <g filter="url(#glow)">
   517→                    {/* Lines */}
   518→                    {visualizationData.lines.map((line, i) => (
   519→                      <g key={`line-group-${i}`}>
   520→                        <motion.line
   521→                          x1={line.x1} y1={line.y1} x2={line.x2} y2={line.y2}
   522→                          stroke={line.color} strokeWidth={strokeGlow} strokeLinecap="round"
   523→                          opacity="0.3"
   524→                          initial={{ pathLength: 0 }} animate={{ pathLength: 1 }} exit={{ pathLength: 0 }}
   525→                          transition={{ duration: 0.5 }}
   526→                        />
   527→                        <motion.line
   528→                          x1={line.x1} y1={line.y1} x2={line.x2} y2={line.y2}
   529→                          stroke={line.color} strokeWidth={strokeMain} strokeLinecap="round"
   530→                          initial={{ pathLength: 0, opacity: 0 }} animate={{ pathLength: 1, opacity: 1 }}
   531→                          exit={{ pathLength: 0, opacity: 0 }}
   532→                          transition={{ duration: 0.5 }}
   533→                        />
   534→                        {line.label && (
   535→                          <motion.g
   536→                            initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
   537→                            transition={{ delay: 0.3 }}
   538→                          >
   539→                            {(() => {
   540→                              const labelPos = getLabelPosition(
   541→                                line.x1, line.y1, line.x2, line.y2,
   542→                                line.labelPosition || 'middle'
   543→                              );
   544→                              const labelPadding = fontSize * 0.5;
   545→                              return (
   546→                                <>
   547→                                  <rect
   548→                                    x={labelPos.x - labelPadding}
   549→                                    y={labelPos.y - fontSize * 0.7}
   550→                                    width={line.label.length * fontSize * 0.65 + labelPadding * 2}
   551→                                    height={fontSize * 1.4}
   552→                                    fill="rgba(0,0,0,0.85)"
   553→                                    rx={fontSize * 0.3}
   554→                                  />
   555→                                  <text
   556→                                    x={labelPos.x}
   557→                                    y={labelPos.y}
   558→                                    fill={line.color}
   559→                                    fontSize={fontSize}
   560→                                    fontWeight="700"
   561→                                    fontFamily="system-ui, sans-serif"
   562→                                    dominantBaseline="middle"
   563→                                    textAnchor="start"
   564→                                  >
   565→                                    {line.label}
   566→                                  </text>
   567→                                </>
   568→                              );
   569→                            })()}
   570→                          </motion.g>
   571→                        )}
   572→                      </g>
   573→                    ))}
   574→
   575→                    {/* Angle arcs */}
   576→                    {visualizationData.angles.map((angle, i) => (
   577→                      <motion.g key={`angle-${i}`}>
   578→                        <motion.path
   579→                          d={generateArcPath(angle.vertex, angle.p1, angle.p2, arcRadius)}
   580→                          fill="none"
   581→                          stroke={angle.color}
   582→                          strokeWidth={strokeMain * 0.8}
   583→                          strokeDasharray={`${baseSize * 0.01} ${baseSize * 0.005}`}
   584→                          initial={{ pathLength: 0, opacity: 0 }}
   585→                          animate={{ pathLength: 1, opacity: 0.8 }}
   586→                          exit={{ pathLength: 0, opacity: 0 }}
   587→                          transition={{ duration: 0.5, delay: 0.2 }}
   588→                        />
   589→                        <motion.g
   590→                          initial={{ opacity: 0, scale: 0 }}
   591→                          animate={{ opacity: 1, scale: 1 }}
   592→                          exit={{ opacity: 0, scale: 0 }}
   593→                          transition={{ delay: 0.5 }}
   594→                        >
   595→                          <rect
   596→                            x={angle.vertex.x + fontSize}
   597→                            y={angle.vertex.y - fontSize * 1.5}
   598→                            width={fontSize * 2.8}
   599→                            height={fontSize * 1.4}
   600→                            fill="rgba(0,0,0,0.9)"
   601→                            rx={fontSize * 0.3}
   602→                          />
   603→                          <text
   604→                            x={angle.vertex.x + fontSize * 2.4}
   605→                            y={angle.vertex.y - fontSize * 0.8}
   606→                            fill={angle.color}
   607→                            fontSize={fontSize}
   608→                            fontWeight="bold"
   609→                            fontFamily="system-ui, sans-serif"
   610→                            textAnchor="middle"
   611→                            dominantBaseline="middle"
   612→                          >
   613→                            {Math.round(angle.angle)}°
   614→                          </text>
   615→                        </motion.g>
   616→                      </motion.g>
   617→                    ))}
   618→
   619→                    {/* Points */}
   620→                    {visualizationData.points.map((point, i) => (
   621→                      <motion.g
   622→                        key={`point-${i}`}
   623→                        initial={{ scale: 0, opacity: 0 }}
   624→                        animate={{ scale: 1, opacity: 1 }}
   625→                        exit={{ scale: 0, opacity: 0 }}
   626→                        transition={{ duration: 0.3, delay: i * 0.05 }}
   627→                      >
   628→                        <motion.circle
   629→                          cx={point.x} cy={point.y} r={pointRadiusOuter}
   630→                          fill={getCategoryColor(selectedRatio?.category || '')}
   631→                          opacity="0.15"
   632→                          animate={{
   633→                            r: [pointRadiusOuter, pointRadiusOuter * 1.25, pointRadiusOuter],
   634→                            opacity: [0.15, 0.25, 0.15]
   635→                          }}
   636→                          transition={{ duration: 2, repeat: Infinity, ease: "easeInOut" }}
   637→                        />
   638→                        <circle cx={point.x} cy={point.y} r={pointRadiusRing}
   639→                          fill="none" stroke={getCategoryColor(selectedRatio?.category || '')}
   640→                          strokeWidth={pointRadiusInner * 0.3} opacity="0.5" />
   641→                        <circle cx={point.x} cy={point.y} r={pointRadiusInner}
   642→                          fill="#fff" stroke={getCategoryColor(selectedRatio?.category || '')}
   643→                          strokeWidth={pointRadiusInner * 0.25} />
   644→                      </motion.g>
   645→                    ))}
   646→                  </g>
   647→                );
   648→              })()}
   649→            </AnimatePresence>
   650→          </svg>
   651→        </div>
   652→
   653→        {/* No selection message */}
   654→        {!selectedRatio && (
   655→          <div className="absolute inset-0 flex items-center justify-center bg-black/60 backdrop-blur-sm">
   656→            <div className="text-center p-8">
   657→              <div className="w-16 h-16 rounded-2xl bg-neutral-900 border border-white/10 flex items-center justify-center mx-auto mb-4">
   658→                <Eye size={28} className="text-neutral-600" />
   659→              </div>
   660→              <p className="text-[10px] text-neutral-500 uppercase tracking-[0.2em] font-black">
   661→                Select a measurement to visualize
   662→              </p>
   663→            </div>
   664→          </div>
   665→        )}
   666→      </div>
   667→
   668→      {/* Selected ratio info footer */}
   669→      {selectedRatio && (
   670→        <motion.div
   671→          className="p-5 border-t border-white/5"
   672→          initial={{ opacity: 0, y: 10 }}
   673→          animate={{ opacity: 1, y: 0 }}
   674→        >
   675→          <div className="flex items-center justify-between mb-4">
   676→            <div>
   677→              <h5 className="text-base font-black uppercase tracking-tight text-white italic">
   678→                {selectedRatio.name}
   679→              </h5>
   680→              <p className="text-[10px] text-neutral-500 uppercase tracking-[0.2em] font-medium mt-1">
   681→                {selectedRatio.category}
   682→              </p>
   683→            </div>
   684→            <div
   685→              className="px-4 py-2 rounded-xl text-lg font-black"
   686→              style={{
   687→                backgroundColor: `${getScoreColor(typeof selectedRatio.score === 'number' ? selectedRatio.score : 0)}15`,
   688→                color: getScoreColor(typeof selectedRatio.score === 'number' ? selectedRatio.score : 0),
   689→              }}
   690→            >
   691→              {typeof selectedRatio.score === 'number' ? selectedRatio.score.toFixed(1) : selectedRatio.score}
   692→            </div>
   693→          </div>
   694→
   695→          {/* Landmarks used */}
   696→          {selectedRatio.usedLandmarks && selectedRatio.usedLandmarks.length > 0 && (
   697→            <div>
   698→              <p className="text-[10px] font-black uppercase tracking-[0.3em] text-neutral-600 mb-2 flex items-center gap-3">
   699→                Landmarks Used
   700→                <span className="flex-1 h-px bg-neutral-800" />
   701→              </p>
   702→              <div className="flex flex-wrap gap-1.5">
   703→                {selectedRatio.usedLandmarks.slice(0, 4).map(id => {
   704→                  const landmark = landmarkMap[id];
   705→                  return (
   706→                    <span
   707→                      key={id}
   708→                      className="px-2 py-1 bg-neutral-800/50 border border-white/5 rounded-lg text-[10px] font-medium text-neutral-400"
   709→                    >
   710→                      {landmark?.label || id}
   711→                    </span>
   712→                  );
   713→                })}
   714→                {selectedRatio.usedLandmarks.length > 4 && (
   715→                  <span className="px-2 py-1 text-[10px] text-neutral-600 font-medium">
   716→                    +{selectedRatio.usedLandmarks.length - 4} more
   717→                  </span>
   718→                )}
   719→              </div>
   720→            </div>
   721→          )}
   722→        </motion.div>
   723→      )}
   724→    </div>
   725→  );
   726→}
   727→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
