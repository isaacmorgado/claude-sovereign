The file /Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/auth.py has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
    20→
    21→router = APIRouter(prefix="/auth", tags=["auth"])
    22→
    23→
    24→@router.post("/register", response_model=Token)
    25→async def register(user_data: UserCreate, db: AsyncSession = Depends(get_db)):
    26→    """Register a new user"""
    27→    import traceback
    28→    try:
    29→        print(f"[AUTH] Starting registration for {user_data.email}", flush=True)
    30→
    31→        # Check if email exists - only select id to avoid loading full model
    32→        result = await db.execute(select(User.id).where(User.email == user_data.email))
    33→        existing_user = result.scalar_one_or_none()
    34→        print(f"[AUTH] Email check complete: exists={existing_user is not None}", flush=True)
    35→
    36→        if existing_user:
    37→            raise HTTPException(
    38→                status_code=status.HTTP_400_BAD_REQUEST,
    39→                detail="Email already registered"
    40→            )
    41→
    42→        # Check if username already exists (case-insensitive) - only select id
    43→        result = await db.execute(
    44→            select(User.id).where(func.lower(User.username) == user_data.username.lower())
    45→        )
    46→        existing_username = result.scalar_one_or_none()
    47→        print(f"[AUTH] Username check complete: exists={existing_username is not None}", flush=True)
    48→
    49→        if existing_username:
    50→            raise HTTPException(
    51→                status_code=status.HTTP_400_BAD_REQUEST,
    52→                detail="Username already taken"
    53→            )
    54→
    55→        # Validate referral code if provided
    56→        stripe_promo_id = None
    57→        if user_data.referral_code:
    58→            result = await db.execute(
    59→                select(ReferralCode).where(
    60→                    func.upper(ReferralCode.code) == user_data.referral_code.upper(),
    61→                    ReferralCode.is_active == True
    62→                )
    63→            )
    64→            referral = result.scalar_one_or_none()
    65→            if referral:
    66→                stripe_promo_id = referral.stripe_promotion_code_id
    67→                # Increment usage count
    68→                referral.total_uses += 1
    69→            print(f"[AUTH] Referral check complete: valid={referral is not None}", flush=True)
    70→
    71→        # Create user with explicit defaults (avoid db.refresh which causes schema issues)
    72→        hashed_password = AuthService.hash_password(user_data.password)
    73→        now = datetime.utcnow()
    74→        user = User(
    75→            id=uuid4(),
    76→            email=user_data.email,
    77→            password_hash=hashed_password,
    78→            name=user_data.name,
    79→            username=user_data.username,
    80→            terms_accepted_at=now if user_data.terms_accepted else None,
    81→            referral_code=user_data.referral_code,
    82→            referred_by=stripe_promo_id,
    83→            plan=PlanType.FREE,
    84→            created_at=now,
    85→            updated_at=now,
    86→        )
    87→        print(f"[AUTH] User object created: id={user.id}", flush=True)
    88→
    89→        db.add(user)
    90→        await db.commit()
    91→        print(f"[AUTH] User committed to database", flush=True)
    92→        # Skip refresh - we already have all values and don't need DB-generated ones
    93→
    94→        # Send welcome email (non-blocking, don't fail registration if email fails)
    95→        try:
    96→            await email_service.send_welcome_email(user.email, user.username)
    97→            print(f"[AUTH] Welcome email sent", flush=True)
    98→        except Exception as e:
    99→            print(f"[AUTH] Failed to send welcome email: {e}", flush=True)
   100→
   101→        # Generate token
   102→        access_token = AuthService.create_access_token(str(user.id))
   103→        print(f"[AUTH] Token generated", flush=True)
   104→
   105→        # Explicitly create UserResponse to avoid serialization issues
   106→        user_response = UserResponse(
   107→            id=user.id,
   108→            email=user.email,
   109→            name=user.name,
   110→            username=user.username,
   111→            plan=user.plan.value if hasattr(user.plan, 'value') else str(user.plan),
   112→            created_at=user.created_at,
   113→        )
   114→        print(f"[AUTH] UserResponse created, registration complete", flush=True)
   115→
   116→        return Token(access_token=access_token, token_type="bearer", user=user_response)
   117→    except HTTPException:
   118→        raise
   119→    except Exception as e:
   120→        print(f"[AUTH] Registration failed with error: {e}", flush=True)
   121→        print(f"[AUTH] Traceback: {traceback.format_exc()}", flush=True)
   122→        raise HTTPException(
   123→            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
   124→            detail=f"Registration failed: {str(e)}"
   125→        )
   126→
   127→
   128→@router.post("/login", response_model=Token)
   129→async def login(credentials: UserLogin, db: AsyncSession = Depends(get_db)):