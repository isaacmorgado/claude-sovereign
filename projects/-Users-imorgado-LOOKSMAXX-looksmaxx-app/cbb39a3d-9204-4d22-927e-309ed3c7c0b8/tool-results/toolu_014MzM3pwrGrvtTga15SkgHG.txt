     1→"""
     2→Authentication service - JWT tokens and password hashing
     3→"""
     4→
     5→from datetime import datetime, timedelta
     6→from typing import Optional
     7→from jose import JWTError, jwt
     8→from passlib.context import CryptContext
     9→from fastapi import Depends, HTTPException, status, Request
    10→from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials, APIKeyHeader
    11→from sqlalchemy.ext.asyncio import AsyncSession
    12→from sqlalchemy import select
    13→
    14→from app.config import get_settings
    15→from app.database import get_db
    16→from app.models.user import User
    17→
    18→settings = get_settings()
    19→pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
    20→security = HTTPBearer()
    21→optional_security = HTTPBearer(auto_error=False)
    22→
    23→
    24→class AuthService:
    25→    @staticmethod
    26→    def hash_password(password: str) -> str:
    27→        """Hash a password using bcrypt"""
    28→        return pwd_context.hash(password)
    29→
    30→    @staticmethod
    31→    def verify_password(plain_password: str, hashed_password: str) -> bool:
    32→        """Verify a password against its hash"""
    33→        return pwd_context.verify(plain_password, hashed_password)
    34→
    35→    @staticmethod
    36→    def create_access_token(user_id: str, expires_delta: Optional[timedelta] = None) -> str:
    37→        """Create a JWT access token"""
    38→        if expires_delta:
    39→            expire = datetime.utcnow() + expires_delta
    40→        else:
    41→            expire = datetime.utcnow() + timedelta(minutes=settings.jwt_expire_minutes)
    42→
    43→        to_encode = {
    44→            "sub": user_id,
    45→            "exp": expire,
    46→            "iat": datetime.utcnow(),
    47→        }
    48→        return jwt.encode(to_encode, settings.jwt_secret, algorithm=settings.jwt_algorithm)
    49→
    50→    @staticmethod
    51→    def decode_token(token: str) -> Optional[str]:
    52→        """Decode and validate a JWT token, return user_id"""
    53→        try:
    54→            payload = jwt.decode(
    55→                token,
    56→                settings.jwt_secret,
    57→                algorithms=[settings.jwt_algorithm]
    58→            )
    59→            user_id: str = payload.get("sub")
    60→            if user_id is None:
    61→                return None
    62→            return user_id
    63→        except JWTError:
    64→            return None
    65→
    66→
    67→async def get_current_user(
    68→    credentials: HTTPAuthorizationCredentials = Depends(security),
    69→    db: AsyncSession = Depends(get_db)
    70→) -> User:
    71→    """Dependency to get the current authenticated user"""
    72→    credentials_exception = HTTPException(
    73→        status_code=status.HTTP_401_UNAUTHORIZED,
    74→        detail="Could not validate credentials",
    75→        headers={"WWW-Authenticate": "Bearer"},
    76→    )
    77→
    78→    token = credentials.credentials
    79→    user_id = AuthService.decode_token(token)
    80→
    81→    if user_id is None:
    82→        raise credentials_exception
    83→
    84→    result = await db.execute(select(User).where(User.id == user_id))
    85→    user = result.scalar_one_or_none()
    86→
    87→    if user is None:
    88→        raise credentials_exception
    89→
    90→    return user
    91→
    92→
    93→async def get_current_user_optional(
    94→    credentials: Optional[HTTPAuthorizationCredentials] = Depends(optional_security),
    95→    db: AsyncSession = Depends(get_db)
    96→) -> Optional[User]:
    97→    """Dependency to optionally get the current authenticated user.
    98→    Returns None if no valid token is provided instead of raising an exception.
    99→    """
   100→    if credentials is None:
   101→        return None
   102→
   103→    token = credentials.credentials
   104→    user_id = AuthService.decode_token(token)
   105→
   106→    if user_id is None:
   107→        return None
   108→
   109→    result = await db.execute(select(User).where(User.id == user_id))
   110→    user = result.scalar_one_or_none()
   111→
   112→    return user
   113→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
