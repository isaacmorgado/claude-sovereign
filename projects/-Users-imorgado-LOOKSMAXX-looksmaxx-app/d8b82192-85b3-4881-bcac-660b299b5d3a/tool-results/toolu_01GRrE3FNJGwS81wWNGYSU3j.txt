     1→/**
     2→ * PSL (Pretty Scale Level) Calculator
     3→ *
     4→ * Implements the PSL scoring formula:
     5→ * PSL = (Face × 0.75) + (Height × 0.20) + (Body × 0.05) + Bonuses - Penalties
     6→ */
     7→
     8→import {
     9→  PSLInput,
    10→  PSLResult,
    11→  PSLBreakdown,
    12→  PSLTier,
    13→  Gender,
    14→  MuscleLevel,
    15→  PSL_WEIGHTS,
    16→  THRESHOLD_BONUSES,
    17→  SYNERGY_BONUSES,
    18→  TIER_DEFINITIONS,
    19→  MALE_HEIGHT_RATINGS,
    20→  FEMALE_HEIGHT_RATINGS,
    21→  BODY_RATINGS,
    22→  TierInfo,
    23→} from '@/types/psl';
    24→
    25→// ============================================
    26→// HEIGHT RATING
    27→// ============================================
    28→
    29→/**
    30→ * Get height rating (0-10) based on height in cm and gender
    31→ * Uses linear interpolation between defined points
    32→ */
    33→export function getHeightRating(heightCm: number, gender: Gender): number {
    34→  const table = gender === 'male' ? MALE_HEIGHT_RATINGS : FEMALE_HEIGHT_RATINGS;
    35→
    36→  // Handle below minimum
    37→  if (heightCm <= table[0].heightCm) {
    38→    return table[0].rating;
    39→  }
    40→
    41→  // Handle above maximum
    42→  const lastEntry = table[table.length - 1];
    43→  if (heightCm >= lastEntry.heightCm) {
    44→    return lastEntry.rating;
    45→  }
    46→
    47→  // Find the two entries to interpolate between
    48→  for (let i = 0; i < table.length - 1; i++) {
    49→    const lower = table[i];
    50→    const upper = table[i + 1];
    51→
    52→    if (heightCm >= lower.heightCm && heightCm < upper.heightCm) {
    53→      // Linear interpolation
    54→      const ratio = (heightCm - lower.heightCm) / (upper.heightCm - lower.heightCm);
    55→      return lower.rating + ratio * (upper.rating - lower.rating);
    56→    }
    57→  }
    58→
    59→  return 5.0; // Default fallback
    60→}
    61→
    62→/**
    63→ * Get display string for height
    64→ */
    65→export function formatHeightDisplay(heightCm: number, gender: Gender): string {
    66→  const table = gender === 'male' ? MALE_HEIGHT_RATINGS : FEMALE_HEIGHT_RATINGS;
    67→
    68→  // Find closest entry
    69→  let closest = table[0];
    70→  let minDiff = Math.abs(heightCm - table[0].heightCm);
    71→
    72→  for (const entry of table) {
    73→    const diff = Math.abs(heightCm - entry.heightCm);
    74→    if (diff < minDiff) {
    75→      minDiff = diff;
    76→      closest = entry;
    77→    }
    78→  }
    79→
    80→  return closest.displayHeight;
    81→}
    82→
    83→// ============================================
    84→// BODY RATING
    85→// ============================================
    86→
    87→/**
    88→ * Get body rating (0-10) based on body fat % and muscle level
    89→ */
    90→export function getBodyRating(bodyFatPercent: number, muscleLevel: MuscleLevel): number {
    91→  // Default if no body analysis available
    92→  if (bodyFatPercent === undefined || muscleLevel === undefined) {
    93→    return 5.0;
    94→  }
    95→
    96→  // Find matching entry based on body fat and muscle level
    97→  const matchingEntry = BODY_RATINGS.find(
    98→    (entry) =>
    99→      bodyFatPercent >= entry.bodyFatMin &&
   100→      bodyFatPercent < entry.bodyFatMax &&
   101→      entry.muscleLevel === muscleLevel
   102→  );
   103→
   104→  if (matchingEntry) {
   105→    return matchingEntry.rating;
   106→  }
   107→
   108→  // Fallback: find by body fat only
   109→  const byBodyFat = BODY_RATINGS.find(
   110→    (entry) => bodyFatPercent >= entry.bodyFatMin && bodyFatPercent < entry.bodyFatMax
   111→  );
   112→
   113→  if (byBodyFat) {
   114→    return byBodyFat.rating;
   115→  }
   116→
   117→  // Default average
   118→  return 5.0;
   119→}
   120→
   121→// ============================================
   122→// TIER CLASSIFICATION
   123→// ============================================
   124→
   125→/**
   126→ * Classify score into PSL tier
   127→ */
   128→export function classifyTier(
   129→  score: number,
   130→  heightRating: number,
   131→  failos?: string[]
   132→): TierInfo {
   133→  // Apply constraints
   134→  let effectiveScore = score;
   135→
   136→  // Height constraint: Cannot reach Gigachad without height rating >= 8.0
   137→  if (heightRating < 8.0 && score >= 9.0) {
   138→    effectiveScore = Math.min(effectiveScore, 8.75);
   139→  }
   140→
   141→  // Major failo constraint: caps tier
   142→  const hasMajorFailo = failos?.some((f) =>
   143→    ['severe_asymmetry', 'deformed', 'major_recession'].includes(f)
   144→  );
   145→  if (hasMajorFailo && effectiveScore >= 7.0) {
   146→    effectiveScore = Math.min(effectiveScore, 6.5);
   147→  }
   148→
   149→  // Find matching tier
   150→  for (const tier of [...TIER_DEFINITIONS].reverse()) {
   151→    if (effectiveScore >= tier.minScore) {
   152→      return tier;
   153→    }
   154→  }
   155→
   156→  return TIER_DEFINITIONS[0]; // Lowest tier
   157→}
   158→
   159→/**
   160→ * Get tier color for UI
   161→ */
   162→export function getTierColor(tier: PSLTier): string {
   163→  const tierInfo = TIER_DEFINITIONS.find((t) => t.name === tier);
   164→  return tierInfo?.color || '#6b7280';
   165→}
   166→
   167→/**
   168→ * Get tier percentile
   169→ */
   170→export function getTierPercentile(tier: PSLTier): number {
   171→  const tierInfo = TIER_DEFINITIONS.find((t) => t.name === tier);
   172→  return tierInfo?.percentile || 50;
   173→}
   174→
   175→// ============================================
   176→// PSL CALCULATION
   177→// ============================================
   178→
   179→/**
   180→ * Calculate threshold bonuses
   181→ */
   182→function calculateThresholdBonuses(
   183→  faceScore: number,
   184→  heightRating: number,
   185→  bodyRating: number
   186→): number {
   187→  let bonus = 0;
   188→
   189→  if (faceScore >= 8.5) bonus += THRESHOLD_BONUSES.face;
   190→  if (heightRating >= 8.5) bonus += THRESHOLD_BONUSES.height;
   191→  if (bodyRating >= 8.5) bonus += THRESHOLD_BONUSES.body;
   192→
   193→  return bonus;
   194→}
   195→
   196→/**
   197→ * Calculate synergy bonuses
   198→ */
   199→function calculateSynergyBonuses(
   200→  faceScore: number,
   201→  heightRating: number,
   202→  bodyRating: number
   203→): number {
   204→  const highScores = [faceScore, heightRating, bodyRating].filter((s) => s >= 8.5);
   205→  const highCount = highScores.length;
   206→
   207→  if (highCount === 3) {
   208→    // Triple synergy replaces pair bonuses
   209→    return SYNERGY_BONUSES.triple;
   210→  }
   211→
   212→  let bonus = 0;
   213→  if (highCount >= 2) {
   214→    if (faceScore >= 8.5 && heightRating >= 8.5) bonus += SYNERGY_BONUSES.faceHeight;
   215→    if (faceScore >= 8.5 && bodyRating >= 8.5) bonus += SYNERGY_BONUSES.faceBody;
   216→    if (heightRating >= 8.5 && bodyRating >= 8.5) bonus += SYNERGY_BONUSES.heightBody;
   217→  }
   218→
   219→  return bonus;
   220→}
   221→
   222→/**
   223→ * Calculate penalties from failos and low body score
   224→ */
   225→function calculatePenalties(bodyRating: number, failos?: string[]): number {
   226→  let penalty = 0;
   227→
   228→  // Body below 5.0 penalty
   229→  if (bodyRating < 5.0) {
   230→    penalty += 0.3;
   231→  }
   232→
   233→  // Failo penalties
   234→  if (failos) {
   235→    if (failos.includes('severe_asymmetry')) penalty += 0.5;
   236→    if (failos.includes('negative_canthal_tilt')) penalty += 0.3;
   237→    if (failos.includes('receding_chin')) penalty += 0.4;
   238→  }
   239→
   240→  return penalty;
   241→}
   242→
   243→/**
   244→ * Estimate potential score with improvements
   245→ */
   246→function estimatePotential(input: PSLInput): number {
   247→  const { faceScore, heightCm, gender, bodyAnalysis } = input;
   248→
   249→  // Face potential: assume minor improvements (skincare, grooming) = +0.3-0.5
   250→  const facePotential = Math.min(10, faceScore + 0.4);
   251→
   252→  // Height is fixed
   253→  const heightRating = getHeightRating(heightCm, gender);
   254→
   255→  // Body potential: assume optimal physique = 8.0
   256→  const currentBodyRating = bodyAnalysis
   257→    ? getBodyRating(bodyAnalysis.bodyFatPercent, bodyAnalysis.muscleLevel)
   258→    : 5.0;
   259→  const bodyPotential = Math.max(currentBodyRating, 7.5);
   260→
   261→  // Calculate potential PSL
   262→  const basePotential =
   263→    facePotential * PSL_WEIGHTS.face +
   264→    heightRating * PSL_WEIGHTS.height +
   265→    bodyPotential * PSL_WEIGHTS.body;
   266→
   267→  // Add potential bonuses (optimistic)
   268→  const thresholdBonus = calculateThresholdBonuses(facePotential, heightRating, bodyPotential);
   269→  const synergyBonus = calculateSynergyBonuses(facePotential, heightRating, bodyPotential);
   270→
   271→  return Math.min(10, basePotential + thresholdBonus + synergyBonus);
   272→}
   273→
   274→/**
   275→ * Main PSL calculation function
   276→ */
   277→export function calculatePSL(input: PSLInput): PSLResult {
   278→  const { faceScore, heightCm, gender, bodyAnalysis, failos } = input;
   279→
   280→  // 1. Get component ratings
   281→  const heightRating = getHeightRating(heightCm, gender);
   282→  const bodyRating = bodyAnalysis
   283→    ? getBodyRating(bodyAnalysis.bodyFatPercent, bodyAnalysis.muscleLevel)
   284→    : 5.0;
   285→
   286→  // 2. Calculate weighted scores
   287→  const faceWeighted = faceScore * PSL_WEIGHTS.face;
   288→  const heightWeighted = heightRating * PSL_WEIGHTS.height;
   289→  const bodyWeighted = bodyRating * PSL_WEIGHTS.body;
   290→  const baseScore = faceWeighted + heightWeighted + bodyWeighted;
   291→
   292→  // 3. Calculate bonuses
   293→  const thresholdBonus = calculateThresholdBonuses(faceScore, heightRating, bodyRating);
   294→  const synergyBonus = calculateSynergyBonuses(faceScore, heightRating, bodyRating);
   295→  const totalBonus = thresholdBonus + synergyBonus;
   296→
   297→  // 4. Calculate penalties
   298→  const penalties = calculatePenalties(bodyRating, failos);
   299→
   300→  // 5. Final score (clamped 0-10)
   301→  const finalScore = Math.min(10, Math.max(0, baseScore + totalBonus - penalties));
   302→
   303→  // 6. Classify tier
   304→  const tierInfo = classifyTier(finalScore, heightRating, failos);
   305→
   306→  // 7. Build breakdown
   307→  const breakdown: PSLBreakdown = {
   308→    face: { raw: faceScore, weighted: faceWeighted },
   309→    height: { raw: heightRating, weighted: heightWeighted },
   310→    body: { raw: bodyRating, weighted: bodyWeighted },
   311→    bonuses: {
   312→      threshold: thresholdBonus,
   313→      synergy: synergyBonus,
   314→      total: totalBonus,
   315→    },
   316→    penalties,
   317→  };
   318→
   319→  // 8. Calculate potential
   320→  const potential = estimatePotential(input);
   321→
   322→  return {
   323→    score: Math.round(finalScore * 100) / 100,
   324→    tier: tierInfo.name,
   325→    percentile: tierInfo.percentile,
   326→    breakdown,
   327→    potential: Math.round(potential * 100) / 100,
   328→  };
   329→}
   330→
   331→// ============================================
   332→// UTILITY FUNCTIONS
   333→// ============================================
   334→
   335→/**
   336→ * Convert height from feet/inches to cm
   337→ */
   338→export function feetInchesToCm(feet: number, inches: number): number {
   339→  const totalInches = feet * 12 + inches;
   340→  return Math.round(totalInches * 2.54);
   341→}
   342→
   343→/**
   344→ * Convert height from cm to feet/inches
   345→ */
   346→export function cmToFeetInches(cm: number): { feet: number; inches: number } {
   347→  const totalInches = cm / 2.54;
   348→  const feet = Math.floor(totalInches / 12);
   349→  const inches = Math.round(totalInches % 12);
   350→  return { feet, inches: inches === 12 ? 0 : inches };
   351→}
   352→
   353→/**
   354→ * Get a descriptive label for the tier
   355→ */
   356→export function getTierDescription(tier: PSLTier): string {
   357→  const tierInfo = TIER_DEFINITIONS.find((t) => t.name === tier);
   358→  return tierInfo?.description || '';
   359→}
   360→
   361→/**
   362→ * Check if a tier is above average
   363→ */
   364→export function isAboveAverage(tier: PSLTier): boolean {
   365→  const aboveAverageTiers: PSLTier[] = ['HTN', 'Chadlite', 'Chad', 'Gigachad', 'True Mogger'];
   366→  return aboveAverageTiers.includes(tier);
   367→}
   368→
   369→/**
   370→ * Get tier rank (1 = lowest, 10 = highest)
   371→ */
   372→export function getTierRank(tier: PSLTier): number {
   373→  const tierIndex = TIER_DEFINITIONS.findIndex((t) => t.name === tier);
   374→  return tierIndex + 1;
   375→}
   376→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
