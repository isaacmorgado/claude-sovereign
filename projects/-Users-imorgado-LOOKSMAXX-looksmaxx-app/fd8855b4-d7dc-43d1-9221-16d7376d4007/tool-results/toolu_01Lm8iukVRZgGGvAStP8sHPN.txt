     1→/**
     2→ * PSL (Pretty Scale Level) Calculator
     3→ *
     4→ * Implements the PSL scoring formula:
     5→ * PSL = (Face × 0.75) + (Height × 0.20) + (Body × 0.05) + Bonuses - Penalties
     6→ */
     7→
     8→import {
     9→  PSLInput,
    10→  PSLResult,
    11→  PSLBreakdown,
    12→  PSLTier,
    13→  Gender,
    14→  MuscleLevel,
    15→  PSL_WEIGHTS,
    16→  THRESHOLD_BONUSES,
    17→  SYNERGY_BONUSES,
    18→  TIER_DEFINITIONS,
    19→  MALE_HEIGHT_RATINGS,
    20→  FEMALE_HEIGHT_RATINGS,
    21→  BODY_RATINGS,
    22→  TierInfo,
    23→} from '@/types/psl';
    24→import { calculateFFMI, FFMIResult } from './ffmi-calculator';
    25→
    26→// ============================================
    27→// HEIGHT RATING
    28→// ============================================
    29→
    30→/**
    31→ * Get height rating (0-10) based on height in cm and gender
    32→ * Uses linear interpolation between defined points
    33→ */
    34→export function getHeightRating(heightCm: number, gender: Gender): number {
    35→  const table = gender === 'male' ? MALE_HEIGHT_RATINGS : FEMALE_HEIGHT_RATINGS;
    36→
    37→  // Handle below minimum
    38→  if (heightCm <= table[0].heightCm) {
    39→    return table[0].rating;
    40→  }
    41→
    42→  // Handle above maximum
    43→  const lastEntry = table[table.length - 1];
    44→  if (heightCm >= lastEntry.heightCm) {
    45→    return lastEntry.rating;
    46→  }
    47→
    48→  // Find the two entries to interpolate between
    49→  for (let i = 0; i < table.length - 1; i++) {
    50→    const lower = table[i];
    51→    const upper = table[i + 1];
    52→
    53→    if (heightCm >= lower.heightCm && heightCm < upper.heightCm) {
    54→      // Linear interpolation
    55→      const ratio = (heightCm - lower.heightCm) / (upper.heightCm - lower.heightCm);
    56→      return lower.rating + ratio * (upper.rating - lower.rating);
    57→    }
    58→  }
    59→
    60→  return 5.0; // Default fallback
    61→}
    62→
    63→/**
    64→ * Get display string for height
    65→ */
    66→export function formatHeightDisplay(heightCm: number, gender: Gender): string {
    67→  const table = gender === 'male' ? MALE_HEIGHT_RATINGS : FEMALE_HEIGHT_RATINGS;
    68→
    69→  // Find closest entry
    70→  let closest = table[0];
    71→  let minDiff = Math.abs(heightCm - table[0].heightCm);
    72→
    73→  for (const entry of table) {
    74→    const diff = Math.abs(heightCm - entry.heightCm);
    75→    if (diff < minDiff) {
    76→      minDiff = diff;
    77→      closest = entry;
    78→    }
    79→  }
    80→
    81→  return closest.displayHeight;
    82→}
    83→
    84→// ============================================
    85→// BODY RATING
    86→// ============================================
    87→
    88→/**
    89→ * Get body rating (0-10) based on body fat % and muscle level
    90→ */
    91→export function getBodyRating(bodyFatPercent: number, muscleLevel: MuscleLevel): number {
    92→  // Default if no body analysis available
    93→  if (bodyFatPercent === undefined || muscleLevel === undefined) {
    94→    return 5.0;
    95→  }
    96→
    97→  // Find matching entry based on body fat and muscle level
    98→  const matchingEntry = BODY_RATINGS.find(
    99→    (entry) =>
   100→      bodyFatPercent >= entry.bodyFatMin &&
   101→      bodyFatPercent < entry.bodyFatMax &&
   102→      entry.muscleLevel === muscleLevel
   103→  );
   104→
   105→  if (matchingEntry) {
   106→    return matchingEntry.rating;
   107→  }
   108→
   109→  // Fallback: find by body fat only
   110→  const byBodyFat = BODY_RATINGS.find(
   111→    (entry) => bodyFatPercent >= entry.bodyFatMin && bodyFatPercent < entry.bodyFatMax
   112→  );
   113→
   114→  if (byBodyFat) {
   115→    return byBodyFat.rating;
   116→  }
   117→
   118→  // Default average
   119→  return 5.0;
   120→}
   121→
   122→/**
   123→ * Get body rating using FFMI calculation (more accurate when weight is available)
   124→ * Returns the FFMI result along with the rating for display purposes
   125→ */
   126→export function getBodyRatingFromFFMI(
   127→  heightCm: number,
   128→  weightKg: number,
   129→  bodyFatPercent: number,
   130→  gender: Gender
   131→): { rating: number; ffmiResult: FFMIResult } {
   132→  const ffmiResult = calculateFFMI(heightCm, weightKg, bodyFatPercent, gender);
   133→  return {
   134→    rating: ffmiResult.rating,
   135→    ffmiResult,
   136→  };
   137→}
   138→
   139→/**
   140→ * Calculate body score with FFMI when possible, fallback to body fat/muscle level
   141→ * Returns both the rating and optional FFMI data for display
   142→ */
   143→export function calculateBodyScore(
   144→  heightCm: number,
   145→  gender: Gender,
   146→  bodyFatPercent?: number,
   147→  muscleLevel?: MuscleLevel,
   148→  weightKg?: number
   149→): { rating: number; ffmiResult?: FFMIResult; method: 'ffmi' | 'table' | 'default' } {
   150→  // Priority 1: Use FFMI if we have all required data
   151→  if (weightKg !== undefined && bodyFatPercent !== undefined) {
   152→    const { rating, ffmiResult } = getBodyRatingFromFFMI(
   153→      heightCm,
   154→      weightKg,
   155→      bodyFatPercent,
   156→      gender
   157→    );
   158→    return { rating, ffmiResult, method: 'ffmi' };
   159→  }
   160→
   161→  // Priority 2: Use body fat + muscle level table
   162→  if (bodyFatPercent !== undefined && muscleLevel !== undefined) {
   163→    const rating = getBodyRating(bodyFatPercent, muscleLevel);
   164→    return { rating, method: 'table' };
   165→  }
   166→
   167→  // Default: 5.0 (average)
   168→  return { rating: 5.0, method: 'default' };
   169→}
   170→
   171→// ============================================
   172→// TIER CLASSIFICATION
   173→// ============================================
   174→
   175→/**
   176→ * Classify score into PSL tier
   177→ */
   178→export function classifyTier(
   179→  score: number,
   180→  heightRating: number,
   181→  failos?: string[]
   182→): TierInfo {
   183→  // Apply constraints
   184→  let effectiveScore = score;
   185→
   186→  // Height constraint: Cannot reach Gigachad without height rating >= 8.0
   187→  if (heightRating < 8.0 && score >= 9.0) {
   188→    effectiveScore = Math.min(effectiveScore, 8.75);
   189→  }
   190→
   191→  // Major failo constraint: caps tier
   192→  const hasMajorFailo = failos?.some((f) =>
   193→    ['severe_asymmetry', 'deformed', 'major_recession'].includes(f)
   194→  );
   195→  if (hasMajorFailo && effectiveScore >= 7.0) {
   196→    effectiveScore = Math.min(effectiveScore, 6.5);
   197→  }
   198→
   199→  // Find matching tier
   200→  for (const tier of [...TIER_DEFINITIONS].reverse()) {
   201→    if (effectiveScore >= tier.minScore) {
   202→      return tier;
   203→    }
   204→  }
   205→
   206→  return TIER_DEFINITIONS[0]; // Lowest tier
   207→}
   208→
   209→/**
   210→ * Get tier color for UI
   211→ */
   212→export function getTierColor(tier: PSLTier): string {
   213→  const tierInfo = TIER_DEFINITIONS.find((t) => t.name === tier);
   214→  return tierInfo?.color || '#6b7280';
   215→}
   216→
   217→/**
   218→ * Get tier percentile
   219→ */
   220→export function getTierPercentile(tier: PSLTier): number {
   221→  const tierInfo = TIER_DEFINITIONS.find((t) => t.name === tier);
   222→  return tierInfo?.percentile || 50;
   223→}
   224→
   225→// ============================================
   226→// PSL CALCULATION
   227→// ============================================
   228→
   229→/**
   230→ * Calculate threshold bonuses
   231→ */
   232→function calculateThresholdBonuses(
   233→  faceScore: number,
   234→  heightRating: number,
   235→  bodyRating: number
   236→): number {
   237→  let bonus = 0;
   238→
   239→  if (faceScore >= 8.5) bonus += THRESHOLD_BONUSES.face;
   240→  if (heightRating >= 8.5) bonus += THRESHOLD_BONUSES.height;
   241→  if (bodyRating >= 8.5) bonus += THRESHOLD_BONUSES.body;
   242→
   243→  return bonus;
   244→}
   245→
   246→/**
   247→ * Calculate synergy bonuses
   248→ */
   249→function calculateSynergyBonuses(
   250→  faceScore: number,
   251→  heightRating: number,
   252→  bodyRating: number
   253→): number {
   254→  const highScores = [faceScore, heightRating, bodyRating].filter((s) => s >= 8.5);
   255→  const highCount = highScores.length;
   256→
   257→  if (highCount === 3) {
   258→    // Triple synergy replaces pair bonuses
   259→    return SYNERGY_BONUSES.triple;
   260→  }
   261→
   262→  let bonus = 0;
   263→  if (highCount >= 2) {
   264→    if (faceScore >= 8.5 && heightRating >= 8.5) bonus += SYNERGY_BONUSES.faceHeight;
   265→    if (faceScore >= 8.5 && bodyRating >= 8.5) bonus += SYNERGY_BONUSES.faceBody;
   266→    if (heightRating >= 8.5 && bodyRating >= 8.5) bonus += SYNERGY_BONUSES.heightBody;
   267→  }
   268→
   269→  return bonus;
   270→}
   271→
   272→/**
   273→ * Calculate penalties from failos and low body score
   274→ */
   275→function calculatePenalties(bodyRating: number, failos?: string[]): number {
   276→  let penalty = 0;
   277→
   278→  // Body below 5.0 penalty
   279→  if (bodyRating < 5.0) {
   280→    penalty += 0.3;
   281→  }
   282→
   283→  // Failo penalties
   284→  if (failos) {
   285→    if (failos.includes('severe_asymmetry')) penalty += 0.5;
   286→    if (failos.includes('negative_canthal_tilt')) penalty += 0.3;
   287→    if (failos.includes('receding_chin')) penalty += 0.4;
   288→  }
   289→
   290→  return penalty;
   291→}
   292→
   293→/**
   294→ * Estimate potential score with improvements
   295→ */
   296→function estimatePotential(input: PSLInput): number {
   297→  const { faceScore, heightCm, gender, bodyAnalysis } = input;
   298→
   299→  // Face potential: assume minor improvements (skincare, grooming) = +0.3-0.5
   300→  const facePotential = Math.min(10, faceScore + 0.4);
   301→
   302→  // Height is fixed
   303→  const heightRating = getHeightRating(heightCm, gender);
   304→
   305→  // Body potential: assume optimal physique = 8.0
   306→  const currentBodyRating = bodyAnalysis
   307→    ? getBodyRating(bodyAnalysis.bodyFatPercent, bodyAnalysis.muscleLevel)
   308→    : 5.0;
   309→  const bodyPotential = Math.max(currentBodyRating, 7.5);
   310→
   311→  // Calculate potential PSL
   312→  const basePotential =
   313→    facePotential * PSL_WEIGHTS.face +
   314→    heightRating * PSL_WEIGHTS.height +
   315→    bodyPotential * PSL_WEIGHTS.body;
   316→
   317→  // Add potential bonuses (optimistic)
   318→  const thresholdBonus = calculateThresholdBonuses(facePotential, heightRating, bodyPotential);
   319→  const synergyBonus = calculateSynergyBonuses(facePotential, heightRating, bodyPotential);
   320→
   321→  return Math.min(10, basePotential + thresholdBonus + synergyBonus);
   322→}
   323→
   324→/**
   325→ * Main PSL calculation function
   326→ */
   327→export function calculatePSL(input: PSLInput): PSLResult {
   328→  const { faceScore, heightCm, gender, bodyAnalysis, weightKg, failos } = input;
   329→
   330→  // 1. Get component ratings
   331→  const heightRating = getHeightRating(heightCm, gender);
   332→
   333→  // Calculate body score using FFMI when weight is available
   334→  const effectiveWeight = weightKg ?? bodyAnalysis?.weightKg;
   335→  const bodyScoreResult = calculateBodyScore(
   336→    heightCm,
   337→    gender,
   338→    bodyAnalysis?.bodyFatPercent,
   339→    bodyAnalysis?.muscleLevel,
   340→    effectiveWeight
   341→  );
   342→  const bodyRating = bodyScoreResult.rating;
   343→
   344→  // 2. Calculate weighted scores
   345→  const faceWeighted = faceScore * PSL_WEIGHTS.face;
   346→  const heightWeighted = heightRating * PSL_WEIGHTS.height;
   347→  const bodyWeighted = bodyRating * PSL_WEIGHTS.body;
   348→  const baseScore = faceWeighted + heightWeighted + bodyWeighted;
   349→
   350→  // 3. Calculate bonuses
   351→  const thresholdBonus = calculateThresholdBonuses(faceScore, heightRating, bodyRating);
   352→  const synergyBonus = calculateSynergyBonuses(faceScore, heightRating, bodyRating);
   353→  const totalBonus = thresholdBonus + synergyBonus;
   354→
   355→  // 4. Calculate penalties
   356→  const penalties = calculatePenalties(bodyRating, failos);
   357→
   358→  // 5. Final score (clamped 0-10)
   359→  const finalScore = Math.min(10, Math.max(0, baseScore + totalBonus - penalties));
   360→
   361→  // 6. Classify tier
   362→  const tierInfo = classifyTier(finalScore, heightRating, failos);
   363→
   364→  // 7. Build breakdown with FFMI data if available
   365→  const breakdown: PSLBreakdown = {
   366→    face: { raw: faceScore, weighted: faceWeighted },
   367→    height: { raw: heightRating, weighted: heightWeighted },
   368→    body: { raw: bodyRating, weighted: bodyWeighted },
   369→    bodyInfo: {
   370→      method: bodyScoreResult.method,
   371→      ffmiData: bodyScoreResult.ffmiResult
   372→        ? {
   373→            ffmi: bodyScoreResult.ffmiResult.ffmi,
   374→            normalizedFFMI: bodyScoreResult.ffmiResult.normalizedFFMI,
   375→            leanMassKg: bodyScoreResult.ffmiResult.leanMassKg,
   376→            rating: bodyScoreResult.ffmiResult.rating,
   377→            category: bodyScoreResult.ffmiResult.category,
   378→          }
   379→        : undefined,
   380→    },
   381→    bonuses: {
   382→      threshold: thresholdBonus,
   383→      synergy: synergyBonus,
   384→      total: totalBonus,
   385→    },
   386→    penalties,
   387→  };
   388→
   389→  // 8. Calculate potential
   390→  const potential = estimatePotential(input);
   391→
   392→  return {
   393→    score: Math.round(finalScore * 100) / 100,
   394→    tier: tierInfo.name,
   395→    percentile: tierInfo.percentile,
   396→    breakdown,
   397→    potential: Math.round(potential * 100) / 100,
   398→  };
   399→}
   400→
   401→// ============================================
   402→// UTILITY FUNCTIONS
   403→// ============================================
   404→
   405→/**
   406→ * Convert height from feet/inches to cm
   407→ */
   408→export function feetInchesToCm(feet: number, inches: number): number {
   409→  const totalInches = feet * 12 + inches;
   410→  return Math.round(totalInches * 2.54);
   411→}
   412→
   413→/**
   414→ * Convert height from cm to feet/inches (supports half-inch precision)
   415→ */
   416→export function cmToFeetInches(cm: number): { feet: number; inches: number } {
   417→  const totalInches = cm / 2.54;
   418→  const feet = Math.floor(totalInches / 12);
   419→  // Round to nearest 0.5 inch
   420→  const rawInches = totalInches % 12;
   421→  const inches = Math.round(rawInches * 2) / 2;
   422→  // Handle case where rounding pushes to 12
   423→  if (inches >= 12) {
   424→    return { feet: feet + 1, inches: 0 };
   425→  }
   426→  return { feet, inches };
   427→}
   428→
   429→/**
   430→ * Get a descriptive label for the tier
   431→ */
   432→export function getTierDescription(tier: PSLTier): string {
   433→  const tierInfo = TIER_DEFINITIONS.find((t) => t.name === tier);
   434→  return tierInfo?.description || '';
   435→}
   436→
   437→/**
   438→ * Check if a tier is above average
   439→ */
   440→export function isAboveAverage(tier: PSLTier): boolean {
   441→  const aboveAverageTiers: PSLTier[] = ['HTN', 'Chadlite', 'Chad', 'Gigachad', 'True Mogger'];
   442→  return aboveAverageTiers.includes(tier);
   443→}
   444→
   445→/**
   446→ * Get tier rank (1 = lowest, 10 = highest)
   447→ */
   448→export function getTierRank(tier: PSLTier): number {
   449→  const tierIndex = TIER_DEFINITIONS.findIndex((t) => t.name === tier);
   450→  return tierIndex + 1;
   451→}
   452→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
