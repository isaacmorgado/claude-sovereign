     1→/**
     2→ * LOOKSMAX Scoring Engine
     3→ * Ported from looksmax_engine.py - Presentation Layer
     4→ *
     5→ * Features:
     6→ * - Weighted Harmony Score calculation (3.0x, 2.0x, 1.0x tiers)
     7→ * - Metric-specific advice generation
     8→ * - Gaussian scoring with exponential decay
     9→ */
    10→
    11→import type { MetricScoreResult, QualityTier, SeverityLevel } from './harmony-scoring';
    12→
    13→// =============================================================================
    14→// HARMONY SCORE WEIGHTS
    15→// =============================================================================
    16→
    17→/**
    18→ * High Impact Metrics (3.0x weight)
    19→ * Core facial harmony indicators that have the greatest effect on overall attractiveness
    20→ */
    21→export const HIGH_IMPACT_METRICS = new Set([
    22→  'faceWidthToHeight',
    23→  'midfaceRatio',
    24→  'lateralCanthalTilt',
    25→  'gonialAngle',
    26→  'mandibularPlaneAngle',
    27→  'chinToPhiltrumRatio',
    28→]);
    29→
    30→/**
    31→ * Medium Impact Metrics (2.0x weight)
    32→ * Secondary aesthetic factors
    33→ */
    34→export const MEDIUM_IMPACT_METRICS = new Set([
    35→  'noseBridgeToNoseWidth',
    36→  'nasolabialAngle',
    37→  'cheekboneHeight',
    38→  'ramusToMandibleRatio',
    39→]);
    40→
    41→/**
    42→ * Get the weight multiplier for a metric
    43→ */
    44→export function getMetricWeight(metricId: string): number {
    45→  if (HIGH_IMPACT_METRICS.has(metricId)) return 3.0;
    46→  if (MEDIUM_IMPACT_METRICS.has(metricId)) return 2.0;
    47→  return 1.0;
    48→}
    49→
    50→/**
    51→ * Get weight tier name for display
    52→ */
    53→export function getWeightTier(metricId: string): 'high' | 'medium' | 'standard' {
    54→  if (HIGH_IMPACT_METRICS.has(metricId)) return 'high';
    55→  if (MEDIUM_IMPACT_METRICS.has(metricId)) return 'medium';
    56→  return 'standard';
    57→}
    58→
    59→// =============================================================================
    60→// WEIGHTED HARMONY SCORE CALCULATION
    61→// =============================================================================
    62→
    63→export interface HarmonyScoreResult {
    64→  /** Weighted harmony percentage (0-100%) */
    65→  harmonyPercentage: number;
    66→  /** Weighted average score (0-10 scale) */
    67→  weightedAverage: number;
    68→  /** Unweighted average for comparison */
    69→  unweightedAverage: number;
    70→  /** Breakdown by weight tier */
    71→  weightDistribution: {
    72→    highImpact: { count: number; avgScore: number };
    73→    mediumImpact: { count: number; avgScore: number };
    74→    standard: { count: number; avgScore: number };
    75→  };
    76→}
    77→
    78→/**
    79→ * Calculate the weighted Harmony Score from scored measurements.
    80→ * Uses 3-tier weighting: High (3x), Medium (2x), Standard (1x)
    81→ *
    82→ * Formula: Σ(Score × Weight) / Σ(Weights) → percentage
    83→ */
    84→export function calculateHarmonyScore(
    85→  measurements: Array<{ metricId: string; standardizedScore: number }>
    86→): HarmonyScoreResult {
    87→  let totalWeightedScore = 0;
    88→  let totalWeight = 0;
    89→  let unweightedTotal = 0;
    90→
    91→  const tiers = {
    92→    high: { total: 0, count: 0 },
    93→    medium: { total: 0, count: 0 },
    94→    standard: { total: 0, count: 0 },
    95→  };
    96→
    97→  for (const m of measurements) {
    98→    const weight = getMetricWeight(m.metricId);
    99→    const tier = getWeightTier(m.metricId);
   100→
   101→    totalWeightedScore += m.standardizedScore * weight;
   102→    totalWeight += weight;
   103→    unweightedTotal += m.standardizedScore;
   104→
   105→    tiers[tier].total += m.standardizedScore;
   106→    tiers[tier].count++;
   107→  }
   108→
   109→  const weightedAverage = totalWeight > 0 ? totalWeightedScore / totalWeight : 0;
   110→  const unweightedAverage = measurements.length > 0 ? unweightedTotal / measurements.length : 0;
   111→  const harmonyPercentage = (weightedAverage / 10) * 100;
   112→
   113→  return {
   114→    harmonyPercentage,
   115→    weightedAverage,
   116→    unweightedAverage,
   117→    weightDistribution: {
   118→      highImpact: {
   119→        count: tiers.high.count,
   120→        avgScore: tiers.high.count > 0 ? tiers.high.total / tiers.high.count : 0,
   121→      },
   122→      mediumImpact: {
   123→        count: tiers.medium.count,
   124→        avgScore: tiers.medium.count > 0 ? tiers.medium.total / tiers.medium.count : 0,
   125→      },
   126→      standard: {
   127→        count: tiers.standard.count,
   128→        avgScore: tiers.standard.count > 0 ? tiers.standard.total / tiers.standard.count : 0,
   129→      },
   130→    },
   131→  };
   132→}
   133→
   134→// =============================================================================
   135→// ADVICE ENGINE - METRIC-SPECIFIC FEEDBACK STRINGS
   136→// =============================================================================
   137→
   138→interface AdviceEntry {
   139→  tooHigh: string;
   140→  tooLow: string;
   141→}
   142→
   143→/**
   144→ * Comprehensive advice database for all metrics
   145→ * Keys match metric IDs from harmony-scoring.ts
   146→ */
   147→export const ADVICE_DATABASE: Record<string, AdviceEntry> = {
   148→  // === HIGH IMPACT METRICS ===
   149→  faceWidthToHeight: {
   150→    tooHigh: "Face appears wider. Consider hairstyles that add vertical length.",
   151→    tooLow: "Face is elongated. Hairstyles with side volume can add balance.",
   152→  },
   153→  midfaceRatio: {
   154→    tooHigh: "Midface is elongated. This can project maturity but may benefit from framing.",
   155→    tooLow: "Midface is compact. This is often a dimorphic and youthful trait.",
   156→  },
   157→  lateralCanthalTilt: {
   158→    tooHigh: "Eyes have significant positive tilt. Very dimorphic - no action needed.",
   159→    tooLow: "Eyes have negative tilt. Consider brow-maxxing or temporal area work.",
   160→  },
   161→  gonialAngle: {
   162→    tooHigh: "Jaw angle is steep (obtuse). Lowering body fat or chewing hard gum may improve definition.",
   163→    tooLow: "Jaw angle is very sharp. Strong masculine trait - no action typically needed.",
   164→  },
   165→  mandibularPlaneAngle: {
   166→    tooHigh: "Steep mandibular plane (long face type). May benefit from mewing or jaw work.",
   167→    tooLow: "Flat mandibular plane. This is typically a favorable trait.",
   168→  },
   169→  chinToPhiltrumRatio: {
   170→    tooHigh: "Chin is long relative to philtrum. Generally masculine; no action needed.",
   171→    tooLow: "Philtrum is long relative to chin. Upper lip lifting or chin augmentation options exist.",
   172→  },
   173→
   174→  // === MEDIUM IMPACT METRICS ===
   175→  noseBridgeToNoseWidth: {
   176→    tooHigh: "Nose appears narrow relative to bridge. This is typically favorable.",
   177→    tooLow: "Nose is wide relative to bridge. Nostril work can refine proportions.",
   178→  },
   179→  nasolabialAngle: {
   180→    tooHigh: "Nose tip points upward. Can appear more feminine; tip refinement may help.",
   181→    tooLow: "Nose tip points downward (droopy). Tip rotation procedures can improve profile.",
   182→  },
   183→  cheekboneHeight: {
   184→    tooHigh: "Cheekbones are exceptionally high. Very aesthetic - no action needed.",
   185→    tooLow: "Cheekbones are lower set. Malar augmentation or filler can enhance projection.",
   186→  },
   187→  cheekFullness: {
   188→    tooHigh: "Very full cheeks. Consider facial contouring if seeking a leaner look.",
   189→    tooLow: "Hollow or gaunt cheeks. Malar filler or fat grafting can restore volume.",
   190→  },
   191→  ramusToMandibleRatio: {
   192→    tooHigh: "Short mandibular body. Jaw angle implants may improve proportions.",
   193→    tooLow: "Long mandibular body. This is typically favorable for facial width.",
   194→  },
   195→
   196→  // === FRONT PROFILE METRICS ===
   197→  jawSlope: {
   198→    tooHigh: "Jaw slopes steeply. Consider gonial angle enhancement.",
   199→    tooLow: "Jaw has minimal slope. Strong horizontal projection is present.",
   200→  },
   201→  totalFacialWidthToHeight: {
   202→    tooHigh: "Face is very wide relative to height. Can appear robust/masculine.",
   203→    tooLow: "Face is very tall relative to width. Hairstyles with width can balance.",
   204→  },
   205→  mouthWidthToNoseRatio: {
   206→    tooHigh: "Wide mouth relative to nose. Typically attractive; no action needed.",
   207→    tooLow: "Narrow mouth relative to nose. Lip exercises may help.",
   208→  },
   209→  lowerThirdProportion: {
   210→    tooHigh: "Lower face is long. May benefit from vertical reduction options.",
   211→    tooLow: "Lower face is short. Chin augmentation can add vertical height.",
   212→  },
   213→  ipsilateralAlarAngle: {
   214→    tooHigh: "Nostril angle is wide. Alar reduction may refine the nose.",
   215→    tooLow: "Nostril angle is narrow. Typically favorable; no action needed.",
   216→  },
   217→  jawFrontalAngle: {
   218→    tooHigh: "Jaw is V-shaped. Gonial angle widening may add presence.",
   219→    tooLow: "Jaw is very U-shaped/wide. Strong masculine trait.",
   220→  },
   221→  eyeAspectRatio: {
   222→    tooHigh: "Eyes are horizontally elongated. Hunter eyes are typically desirable.",
   223→    tooLow: "Eyes are more round. Lateral canthoplasty can elongate.",
   224→  },
   225→  bitemporalWidth: {
   226→    tooHigh: "Wide temples relative to face. Full head of hair can balance.",
   227→    tooLow: "Narrow temples. Can appear more refined/gracile.",
   228→  },
   229→  eyebrowLowSetedness: {
   230→    tooHigh: "Brows are low-set (hooded). Creates intense look; browlift if too heavy.",
   231→    tooLow: "Brows are high-set. More open look; brow products can add fullness.",
   232→  },
   233→  eyeSeparationRatio: {
   234→    tooHigh: "Eyes are widely set. Creates softer look; no action typically needed.",
   235→    tooLow: "Eyes are closely set. Can appear intense; glasses can balance.",
   236→  },
   237→  bigonialWidth: {
   238→    tooHigh: "Wide jaw relative to cheekbones. Strong masculine trait.",
   239→    tooLow: "Narrow jaw relative to cheekbones. Jaw angle widening may add presence.",
   240→  },
   241→  lowerToUpperLipRatio: {
   242→    tooHigh: "Lower lip is much fuller. Very aesthetic; no action needed.",
   243→    tooLow: "Upper lip is fuller. Standard proportion; lip flip may balance.",
   244→  },
   245→  eyebrowTilt: {
   246→    tooHigh: "Brows tilt significantly upward. Can appear expressive.",
   247→    tooLow: "Brows are flat or downturned. Can appear more stoic.",
   248→  },
   249→
   250→  // === SIDE PROFILE METRICS ===
   251→  recessionRelativeToFrankfort: {
   252→    tooHigh: "Significant lower jaw recession. Advancement surgery may help.",
   253→    tooLow: "Jaw projects forward strongly. Very masculine; monitor overbite.",
   254→  },
   255→  facialDepthToHeightRatio: {
   256→    tooHigh: "Face is very deep relative to height. Strong forward growth.",
   257→    tooLow: "Face is flat relative to height. May benefit from midface/chin work.",
   258→  },
   259→  interiorMidfaceProjectionAngle: {
   260→    tooHigh: "Midface projects significantly. Strong forward growth.",
   261→    tooLow: "Flat midface. Cheekbone augmentation may improve profile.",
   262→  },
   263→  nasofrontalAngle: {
   264→    tooHigh: "Deep nasofrontal angle. Creates dramatic brow/nose transition.",
   265→    tooLow: "Shallow nasofrontal angle. Brow work may add definition.",
   266→  },
   267→  gonionToMouthLine: {
   268→    tooHigh: "Gonion is low relative to mouth. May appear long-faced.",
   269→    tooLow: "Gonion is high relative to mouth. Compact proportions.",
   270→  },
   271→  lowerLipSLinePosition: {
   272→    tooHigh: "Lower lip protrudes past S-line. May indicate maxillary retrusion.",
   273→    tooLow: "Lower lip is behind S-line. Well-balanced profile.",
   274→  },
   275→  zAngle: {
   276→    tooHigh: "Profile is very upright/vertical. May appear flat.",
   277→    tooLow: "Profile is convex. Standard Western ideal.",
   278→  },
   279→  nasomentaAngle: {
   280→    tooHigh: "Nose-chin line is obtuse. May indicate weak chin.",
   281→    tooLow: "Nose-chin line is acute. Strong chin projection.",
   282→  },
   283→  submentalCervicalAngle: {
   284→    tooHigh: "Weak chin-neck angle. May benefit from submental lipo or implant.",
   285→    tooLow: "Sharp chin-neck angle. Excellent definition.",
   286→  },
   287→  nasofacialAngle: {
   288→    tooHigh: "Large angle between nose and face. Strong nose or recessed face.",
   289→    tooLow: "Small angle. Well-integrated nose.",
   290→  },
   291→  holdawayHLine: {
   292→    tooHigh: "Lips project significantly. Monitor for bimax protrusion.",
   293→    tooLow: "Flat lip line. May appear retruded; filler can add volume.",
   294→  },
   295→  mentolabialAngle: {
   296→    tooHigh: "Deep mentolabial fold. Can appear aged; filler can soften.",
   297→    tooLow: "Shallow mentolabial fold. Youthful and balanced.",
   298→  },
   299→  eLineLowerLip: {
   300→    tooHigh: "Lower lip protrudes past E-line. May benefit from orthodontics.",
   301→    tooLow: "Lower lip is behind E-line. Balanced or retruded.",
   302→  },
   303→  eLineUpperLip: {
   304→    tooHigh: "Upper lip protrudes past E-line. May benefit from orthodontics.",
   305→    tooLow: "Upper lip is behind E-line. Balanced or retruded.",
   306→  },
   307→  nasalTipAngle: {
   308→    tooHigh: "Nose tip is rotated upward. Can appear feminine.",
   309→    tooLow: "Nose tip droops. Tip rotation surgery can improve.",
   310→  },
   311→  nasalProjection: {
   312→    tooHigh: "Large nose projection. Reduction rhinoplasty may refine.",
   313→    tooLow: "Minimal nose projection. Augmentation rhinoplasty may enhance.",
   314→  },
   315→  nasalWToHRatio: {
   316→    tooHigh: "Wide nose relative to height. Narrowing procedures exist.",
   317→    tooLow: "Narrow nose. Typically favorable; no action needed.",
   318→  },
   319→  facialConvexityGlabella: {
   320→    tooHigh: "Convex profile. Strong midface projection.",
   321→    tooLow: "Flat or concave profile. May benefit from augmentation.",
   322→  },
   323→  facialConvexityNasion: {
   324→    tooHigh: "Convex profile from nasion. Good forward growth.",
   325→    tooLow: "Straight or concave profile. May appear flat.",
   326→  },
   327→  totalFacialConvexity: {
   328→    tooHigh: "Very convex total profile. Midface is prominent.",
   329→    tooLow: "Flat total profile. Forward growth options may help.",
   330→  },
   331→  upperForeheadSlope: {
   332→    tooHigh: "Sloped forehead. More masculine/primal appearance.",
   333→    tooLow: "Upright forehead. More neotenous appearance.",
   334→  },
   335→  browridgeInclinationAngle: {
   336→    tooHigh: "Prominent browridge angle. Strong masculine trait.",
   337→    tooLow: "Flat browridge. Implants can add definition.",
   338→  },
   339→  upperThirdProportion: {
   340→    tooHigh: "Upper third is long. Large forehead; can be offset with hair styling.",
   341→    tooLow: "Upper third is short. Compact proportions.",
   342→  },
   343→  middleThirdProportion: {
   344→    tooHigh: "Middle third is long. May appear long-faced.",
   345→    tooLow: "Middle third is short. Compact midface.",
   346→  },
   347→  chinProjection: {
   348→    tooHigh: "Strong chin projection. Very masculine trait.",
   349→    tooLow: "Weak chin projection. Genioplasty or implant can improve.",
   350→  },
   351→  lipRatio: {
   352→    tooHigh: "Full lips. Typically attractive; no action needed.",
   353→    tooLow: "Thin lips. Filler can add volume if desired.",
   354→  },
   355→};
   356→
   357→/**
   358→ * Generate personalized advice based on metric score and value position.
   359→ *
   360→ * @param metricId - The metric identifier
   361→ * @param score - Score from 0-10
   362→ * @param value - Actual measured value
   363→ * @param idealMin - Minimum of ideal range
   364→ * @param idealMax - Maximum of ideal range
   365→ * @returns Advice string for the metric
   366→ */
   367→export function generateAdvice(
   368→  metricId: string,
   369→  score: number,
   370→  value: number,
   371→  idealMin: number,
   372→  idealMax: number
   373→): string {
   374→  // Perfect score - no action needed
   375→  if (score >= 9.0) {
   376→    return "Ideal proportions. No action needed.";
   377→  }
   378→
   379→  // Get advice from database
   380→  const advice = ADVICE_DATABASE[metricId];
   381→  if (advice) {
   382→    if (value > idealMax) {
   383→      return advice.tooHigh;
   384→    } else if (value < idealMin) {
   385→      return advice.tooLow;
   386→    }
   387→  }
   388→
   389→  // Default fallback
   390→  if (value > idealMax) {
   391→    return `Value (${value.toFixed(2)}) is above the ideal range of ${idealMin.toFixed(1)}-${idealMax.toFixed(1)}.`;
   392→  } else if (value < idealMin) {
   393→    return `Value (${value.toFixed(2)}) is below the ideal range of ${idealMin.toFixed(1)}-${idealMax.toFixed(1)}.`;
   394→  } else {
   395→    return "Value is within acceptable range but not optimal.";
   396→  }
   397→}
   398→
   399→/**
   400→ * Generate advice for a metric score result
   401→ */
   402→export function generateAdviceFromResult(result: MetricScoreResult): string {
   403→  return generateAdvice(
   404→    result.metricId,
   405→    result.standardizedScore,
   406→    result.value,
   407→    result.idealMin,
   408→    result.idealMax
   409→  );
   410→}
   411→
   412→// =============================================================================
   413→// GAUSSIAN SCORING (matches Python implementation)
   414→// =============================================================================
   415→
   416→/**
   417→ * Calculate a score from 0-10 using Gaussian decay.
   418→ * Matches the Python looksmax_engine.py implementation.
   419→ *
   420→ * @param value - The measured value
   421→ * @param minRange - Minimum of ideal range
   422→ * @param maxRange - Maximum of ideal range
   423→ * @returns Score from 0-10
   424→ */
   425→export function calculateGaussianScore(
   426→  value: number,
   427→  minRange: number,
   428→  maxRange: number
   429→): number {
   430→  // Within ideal range = perfect score
   431→  if (value >= minRange && value <= maxRange) {
   432→    return 10.0;
   433→  }
   434→
   435→  let deviation: number;
   436→  let target: number;
   437→
   438→  if (value < minRange) {
   439→    deviation = minRange - value;
   440→    target = minRange;
   441→  } else {
   442→    deviation = value - maxRange;
   443→    target = maxRange;
   444→  }
   445→
   446→  // Prevent division by zero
   447→  if (target === 0) target = 1.0;
   448→
   449→  // Sigma is 10% of target value
   450→  let sigma = Math.abs(target) * 0.1;
   451→  if (sigma === 0) sigma = 1.0;
   452→
   453→  // Gaussian decay
   454→  const score = 10.0 * Math.exp(-0.5 * Math.pow(deviation / sigma, 2));
   455→  return Math.max(0.0, Math.min(10.0, score));
   456→}
   457→
   458→// =============================================================================
   459→// TOP/BOTTOM METRICS IDENTIFICATION
   460→// =============================================================================
   461→
   462→export interface RankedMetric {
   463→  metricId: string;
   464→  name: string;
   465→  value: number;
   466→  score: number;
   467→  idealMin: number;
   468→  idealMax: number;
   469→  advice: string;
   470→  weightTier: 'high' | 'medium' | 'standard';
   471→  category: string;
   472→}
   473→
   474→/**
   475→ * Get the top N metrics (strengths) sorted by score descending
   476→ */
   477→export function getTopMetrics(
   478→  measurements: MetricScoreResult[],
   479→  count: number = 3
   480→): RankedMetric[] {
   481→  return [...measurements]
   482→    .sort((a, b) => b.standardizedScore - a.standardizedScore)
   483→    .slice(0, count)
   484→    .map((m) => ({
   485→      metricId: m.metricId,
   486→      name: m.name,
   487→      value: m.value,
   488→      score: m.standardizedScore,
   489→      idealMin: m.idealMin,
   490→      idealMax: m.idealMax,
   491→      advice: generateAdviceFromResult(m),
   492→      weightTier: getWeightTier(m.metricId),
   493→      category: m.category,
   494→    }));
   495→}
   496→
   497→/**
   498→ * Get the bottom N metrics (areas to improve) sorted by score ascending
   499→ */
   500→export function getBottomMetrics(
   501→  measurements: MetricScoreResult[],
   502→  count: number = 3
   503→): RankedMetric[] {
   504→  return [...measurements]
   505→    .sort((a, b) => a.standardizedScore - b.standardizedScore)
   506→    .slice(0, count)
   507→    .map((m) => ({
   508→      metricId: m.metricId,
   509→      name: m.name,
   510→      value: m.value,
   511→      score: m.standardizedScore,
   512→      idealMin: m.idealMin,
   513→      idealMax: m.idealMax,
   514→      advice: generateAdviceFromResult(m),
   515→      weightTier: getWeightTier(m.metricId),
   516→      category: m.category,
   517→    }));
   518→}
   519→
   520→// =============================================================================
   521→// QUALITY & SEVERITY HELPERS
   522→// =============================================================================
   523→
   524→/**
   525→ * Get a human-readable quality description
   526→ */
   527→export function getQualityDescription(tier: QualityTier): string {
   528→  switch (tier) {
   529→    case 'ideal': return 'Ideal';
   530→    case 'excellent': return 'Excellent';
   531→    case 'good': return 'Good';
   532→    case 'below_average': return 'Below Average';
   533→  }
   534→}
   535→
   536→/**
   537→ * Get a human-readable severity description
   538→ */
   539→export function getSeverityDescription(severity: SeverityLevel): string {
   540→  switch (severity) {
   541→    case 'optimal': return 'Optimal';
   542→    case 'minor': return 'Minor Deviation';
   543→    case 'moderate': return 'Moderate Deviation';
   544→    case 'major': return 'Major Deviation';
   545→    case 'severe': return 'Severe Deviation';
   546→    case 'extremely_severe': return 'Extremely Severe';
   547→  }
   548→}
   549→
   550→/**
   551→ * Get severity color for UI display
   552→ */
   553→export function getSeverityColor(severity: SeverityLevel): string {
   554→  switch (severity) {
   555→    case 'optimal': return 'text-green-400';
   556→    case 'minor': return 'text-lime-400';
   557→    case 'moderate': return 'text-yellow-400';
   558→    case 'major': return 'text-orange-400';
   559→    case 'severe': return 'text-red-400';
   560→    case 'extremely_severe': return 'text-red-600';
   561→  }
   562→}
   563→
   564→/**
   565→ * Get weight tier badge color
   566→ */
   567→export function getWeightTierColor(tier: 'high' | 'medium' | 'standard'): string {
   568→  switch (tier) {
   569→    case 'high': return 'bg-purple-500/20 text-purple-400 border-purple-500/30';
   570→    case 'medium': return 'bg-blue-500/20 text-blue-400 border-blue-500/30';
   571→    case 'standard': return 'bg-gray-500/20 text-gray-400 border-gray-500/30';
   572→  }
   573→}
   574→
   575→/**
   576→ * Get weight tier label
   577→ */
   578→export function getWeightTierLabel(tier: 'high' | 'medium' | 'standard'): string {
   579→  switch (tier) {
   580→    case 'high': return 'High Impact (3x)';
   581→    case 'medium': return 'Medium Impact (2x)';
   582→    case 'standard': return 'Standard';
   583→  }
   584→}
   585→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
