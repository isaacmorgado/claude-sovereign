{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":"## Task: Implement Rate Limiting for Forum API\n\n### Context\nThe LOOKSMAXX forum API needs rate limiting to prevent DoS attacks, spam flooding, and database strain.\n\n### Requirements\nFrom the SAAS audit:\n```\n# Recommended limits:\n# Posts: 5 per minute per user\n# Comments: 20 per minute per user\n# Votes: 30 per minute per user\n# Reports: 10 per hour per user\n```\n\n### Files to Modify\n1. `looksmaxx-api/requirements.txt` - Add slowapi dependency\n2. `looksmaxx-api/app/main.py` - Add slowapi middleware setup\n3. `looksmaxx-api/app/routers/forum.py` - Add rate limit decorators to endpoints\n\n### Implementation Steps\n\n1. **Add slowapi to requirements.txt**\n   - Add `slowapi>=0.1.9`\n   - Add `python-multipart` if not present (needed by slowapi)\n\n2. **Setup slowapi in main.py**\n   ```python\n   from slowapi import Limiter, _rate_limit_exceeded_handler\n   from slowapi.util import get_remote_address\n   from slowapi.errors import RateLimitExceeded\n   from slowapi.middleware import SlowAPIMiddleware\n   \n   limiter = Limiter(key_func=get_remote_address)\n   app.state.limiter = limiter\n   app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n   app.add_middleware(SlowAPIMiddleware)\n   ```\n\n3. **Add rate limits to forum.py endpoints**\n   - Import the limiter from main.py\n   - Add decorators:\n     - `@limiter.limit(\"5/minute\")` for create_post\n     - `@limiter.limit(\"20/minute\")` for create_comment\n     - `@limiter.limit(\"30/minute\")` for vote_post and vote_comment\n     - `@limiter.limit(\"10/hour\")` for report_post and report_comment\n\n### Key Considerations\n- Use user ID for authenticated rate limiting (better than IP for logged-in users)\n- Make limiter accessible as a shared instance\n- Handle RateLimitExceeded exception gracefully with 429 status\n- Consider adding custom key function that uses user_id when available, IP as fallback\n\nIMPORTANT: Actually implement this - write the code, modify the files. Don't just plan.\n"},"uuid":"e9a14028-6dab-4689-b52c-61d32afc4e1d","timestamp":"2025-12-27T16:53:39.333Z"}
{"parentUuid":"e9a14028-6dab-4689-b52c-61d32afc4e1d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NWXDk2FQUBFqeYnUk6qhNz","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement rate limiting for the Forum API. Let me start by reading the existing files to understand the current structure."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":37260,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":37260,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"}},"requestId":"req_011CWXYJqJhv9agvZ4TkP3dS","type":"assistant","uuid":"03be0851-2857-4c94-bff9-aee882fa4562","timestamp":"2025-12-27T16:53:45.567Z"}
{"parentUuid":"03be0851-2857-4c94-bff9-aee882fa4562","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NWXDk2FQUBFqeYnUk6qhNz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0135xDRFNwPiWXaQG2CYP53D","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/requirements.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":37260,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":37260,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"}},"requestId":"req_011CWXYJqJhv9agvZ4TkP3dS","type":"assistant","uuid":"c28fd390-8e93-4cc6-9720-fd81f93623ac","timestamp":"2025-12-27T16:53:46.160Z"}
{"parentUuid":"c28fd390-8e93-4cc6-9720-fd81f93623ac","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NWXDk2FQUBFqeYnUk6qhNz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QPvSQ6PvNvfhAcFd1ENqac","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/main.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":37260,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":37260,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"}},"requestId":"req_011CWXYJqJhv9agvZ4TkP3dS","type":"assistant","uuid":"7abcb960-1316-4c63-85de-4c5790eddc16","timestamp":"2025-12-27T16:53:46.651Z"}
{"parentUuid":"7abcb960-1316-4c63-85de-4c5790eddc16","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NWXDk2FQUBFqeYnUk6qhNz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013KFHZMoGgnENWuNEnwt2rk","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":37260,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":37260,"ephemeral_1h_input_tokens":0},"output_tokens":223,"service_tier":"standard"}},"requestId":"req_011CWXYJqJhv9agvZ4TkP3dS","type":"assistant","uuid":"08b2ba17-b40c-4cf4-aed8-679a876fb062","timestamp":"2025-12-27T16:53:47.152Z"}
{"parentUuid":"08b2ba17-b40c-4cf4-aed8-679a876fb062","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0135xDRFNwPiWXaQG2CYP53D","type":"tool_result","content":"     1→# API Framework\n     2→fastapi==0.109.0\n     3→uvicorn[standard]==0.27.0\n     4→\n     5→# Database\n     6→sqlalchemy==2.0.25\n     7→asyncpg==0.29.0\n     8→alembic==1.13.1\n     9→\n    10→# Authentication\n    11→python-jose[cryptography]==3.3.0\n    12→passlib[bcrypt]==1.7.4\n    13→bcrypt==4.0.1\n    14→\n    15→# Payments\n    16→stripe==11.5.0\n    17→\n    18→# Face Detection - InsightFace for side profile\n    19→insightface==0.7.3\n    20→onnxruntime==1.16.3\n    21→opencv-python-headless==4.9.0.80\n    22→numpy==1.26.3\n    23→Pillow==10.2.0\n    24→\n    25→# Storage\n    26→boto3==1.34.25\n    27→\n    28→# Email\n    29→sendgrid==6.11.0\n    30→\n    31→# AI (Claude Vision for body analysis)\n    32→anthropic==0.40.0\n    33→httpx==0.27.0\n    34→\n    35→# Rate Limiting\n    36→slowapi==0.1.9\n    37→redis==5.0.1\n    38→\n    39→# Security\n    40→bleach==6.1.0\n    41→\n    42→# Utilities\n    43→python-multipart==0.0.6\n    44→pydantic==2.5.3\n    45→pydantic-settings==2.1.0\n    46→email-validator==2.1.0\n    47→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7bd30e8f-e478-4b29-9c0f-da07f27281c7","timestamp":"2025-12-27T16:53:47.227Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/requirements.txt","content":"# API Framework\nfastapi==0.109.0\nuvicorn[standard]==0.27.0\n\n# Database\nsqlalchemy==2.0.25\nasyncpg==0.29.0\nalembic==1.13.1\n\n# Authentication\npython-jose[cryptography]==3.3.0\npasslib[bcrypt]==1.7.4\nbcrypt==4.0.1\n\n# Payments\nstripe==11.5.0\n\n# Face Detection - InsightFace for side profile\ninsightface==0.7.3\nonnxruntime==1.16.3\nopencv-python-headless==4.9.0.80\nnumpy==1.26.3\nPillow==10.2.0\n\n# Storage\nboto3==1.34.25\n\n# Email\nsendgrid==6.11.0\n\n# AI (Claude Vision for body analysis)\nanthropic==0.40.0\nhttpx==0.27.0\n\n# Rate Limiting\nslowapi==0.1.9\nredis==5.0.1\n\n# Security\nbleach==6.1.0\n\n# Utilities\npython-multipart==0.0.6\npydantic==2.5.3\npydantic-settings==2.1.0\nemail-validator==2.1.0\n","numLines":47,"startLine":1,"totalLines":47}}}
{"parentUuid":"7bd30e8f-e478-4b29-9c0f-da07f27281c7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QPvSQ6PvNvfhAcFd1ENqac","type":"tool_result","content":"     1→\"\"\"\n     2→LOOKSMAXX API - Unified backend for facial analysis\n     3→\"\"\"\n     4→import sys\n     5→print(\"[STARTUP] Loading main.py...\", flush=True)\n     6→\n     7→from contextlib import asynccontextmanager\n     8→from fastapi import FastAPI\n     9→from fastapi.middleware.cors import CORSMiddleware\n    10→from slowapi import _rate_limit_exceeded_handler\n    11→from slowapi.errors import RateLimitExceeded\n    12→\n    13→print(\"[STARTUP] Imports done, loading config...\", flush=True)\n    14→\n    15→from app.config import get_settings\n    16→print(\"[STARTUP] Config loaded, loading database...\", flush=True)\n    17→\n    18→from app.database import engine, Base\n    19→print(\"[STARTUP] Database loaded, loading services...\", flush=True)\n    20→\n    21→from app.services.detection import detection_service\n    22→from app.routers import auth_router, detection_router, analyses_router, payments_router, leaderboard_router, referrals_router, forum_router, psl_router, archetype_router, physique_router, supplements_router, users_router, admin_router\n    23→from app.core.rate_limit import limiter\n    24→\n    25→print(\"[STARTUP] All imports complete!\", flush=True)\n    26→\n    27→settings = get_settings()\n    28→print(f\"[STARTUP] Settings: frontend_url={settings.frontend_url}\", flush=True)\n    29→\n    30→\n    31→@asynccontextmanager\n    32→async def lifespan(app: FastAPI):\n    33→    \"\"\"Startup and shutdown events\"\"\"\n    34→    # Startup\n    35→    print(\"[API] Starting up...\", flush=True)\n    36→\n    37→    try:\n    38→        # Create database tables\n    39→        async with engine.begin() as conn:\n    40→            await conn.run_sync(Base.metadata.create_all)\n    41→        print(\"[API] Database tables created\", flush=True)\n    42→    except Exception as e:\n    43→        print(f\"[API] Database error (non-fatal): {e}\", flush=True)\n    44→\n    45→    # Note: InsightFace model is lazy-loaded on first detection request\n    46→    # This reduces startup memory usage and prevents OOM on Railway\n    47→    print(\"[API] Detection service ready (lazy-load enabled)\", flush=True)\n    48→\n    49→    yield\n    50→\n    51→    # Shutdown\n    52→    print(\"[API] Shutting down...\", flush=True)\n    53→    await engine.dispose()\n    54→\n    55→\n    56→app = FastAPI(\n    57→    title=\"LOOKSMAXX API\",\n    58→    description=\"Facial analysis and metrics API\",\n    59→    version=\"1.0.0\",\n    60→    lifespan=lifespan,\n    61→)\n    62→\n    63→# Add rate limiter state and exception handler\n    64→app.state.limiter = limiter\n    65→app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n    66→\n    67→# CORS middleware\n    68→app.add_middleware(\n    69→    CORSMiddleware,\n    70→    allow_origins=[\n    71→        settings.frontend_url,\n    72→        \"http://localhost:3000\",\n    73→        \"http://localhost:3001\",\n    74→        \"https://frontend-production-7ea5.up.railway.app\",  # Added explicit allow for production frontend\n    75→    ],\n    76→    allow_credentials=True,\n    77→    allow_methods=[\"*\"],\n    78→    allow_headers=[\"*\"],\n    79→)\n    80→\n    81→# Include routers\n    82→app.include_router(auth_router)\n    83→app.include_router(detection_router)\n    84→app.include_router(analyses_router)\n    85→app.include_router(payments_router)\n    86→app.include_router(leaderboard_router)\n    87→app.include_router(referrals_router)\n    88→app.include_router(forum_router)\n    89→app.include_router(psl_router)\n    90→app.include_router(archetype_router)\n    91→app.include_router(physique_router)\n    92→app.include_router(supplements_router)\n    93→app.include_router(users_router)\n    94→app.include_router(admin_router)\n    95→\n    96→\n    97→@app.get(\"/\")\n    98→async def root():\n    99→    \"\"\"Root endpoint - API info\"\"\"\n   100→    return {\n   101→        \"name\": \"LOOKSMAXX API\",\n   102→        \"version\": \"1.0.0\",\n   103→        \"status\": \"running\",\n   104→        \"docs\": \"/docs\",\n   105→    }\n   106→\n   107→\n   108→@app.get(\"/health\")\n   109→async def health():\n   110→    \"\"\"Health check endpoint\"\"\"\n   111→    return {\n   112→        \"status\": \"healthy\",\n   113→        \"detection_ready\": detection_service._face_analyzer is not None,\n   114→    }\n   115→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"73d10f35-af8a-4ee3-b50e-1118ec1ba1d2","timestamp":"2025-12-27T16:53:47.227Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/main.py","content":"\"\"\"\nLOOKSMAXX API - Unified backend for facial analysis\n\"\"\"\nimport sys\nprint(\"[STARTUP] Loading main.py...\", flush=True)\n\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom slowapi import _rate_limit_exceeded_handler\nfrom slowapi.errors import RateLimitExceeded\n\nprint(\"[STARTUP] Imports done, loading config...\", flush=True)\n\nfrom app.config import get_settings\nprint(\"[STARTUP] Config loaded, loading database...\", flush=True)\n\nfrom app.database import engine, Base\nprint(\"[STARTUP] Database loaded, loading services...\", flush=True)\n\nfrom app.services.detection import detection_service\nfrom app.routers import auth_router, detection_router, analyses_router, payments_router, leaderboard_router, referrals_router, forum_router, psl_router, archetype_router, physique_router, supplements_router, users_router, admin_router\nfrom app.core.rate_limit import limiter\n\nprint(\"[STARTUP] All imports complete!\", flush=True)\n\nsettings = get_settings()\nprint(f\"[STARTUP] Settings: frontend_url={settings.frontend_url}\", flush=True)\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Startup and shutdown events\"\"\"\n    # Startup\n    print(\"[API] Starting up...\", flush=True)\n\n    try:\n        # Create database tables\n        async with engine.begin() as conn:\n            await conn.run_sync(Base.metadata.create_all)\n        print(\"[API] Database tables created\", flush=True)\n    except Exception as e:\n        print(f\"[API] Database error (non-fatal): {e}\", flush=True)\n\n    # Note: InsightFace model is lazy-loaded on first detection request\n    # This reduces startup memory usage and prevents OOM on Railway\n    print(\"[API] Detection service ready (lazy-load enabled)\", flush=True)\n\n    yield\n\n    # Shutdown\n    print(\"[API] Shutting down...\", flush=True)\n    await engine.dispose()\n\n\napp = FastAPI(\n    title=\"LOOKSMAXX API\",\n    description=\"Facial analysis and metrics API\",\n    version=\"1.0.0\",\n    lifespan=lifespan,\n)\n\n# Add rate limiter state and exception handler\napp.state.limiter = limiter\napp.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\n        settings.frontend_url,\n        \"http://localhost:3000\",\n        \"http://localhost:3001\",\n        \"https://frontend-production-7ea5.up.railway.app\",  # Added explicit allow for production frontend\n    ],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Include routers\napp.include_router(auth_router)\napp.include_router(detection_router)\napp.include_router(analyses_router)\napp.include_router(payments_router)\napp.include_router(leaderboard_router)\napp.include_router(referrals_router)\napp.include_router(forum_router)\napp.include_router(psl_router)\napp.include_router(archetype_router)\napp.include_router(physique_router)\napp.include_router(supplements_router)\napp.include_router(users_router)\napp.include_router(admin_router)\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint - API info\"\"\"\n    return {\n        \"name\": \"LOOKSMAXX API\",\n        \"version\": \"1.0.0\",\n        \"status\": \"running\",\n        \"docs\": \"/docs\",\n    }\n\n\n@app.get(\"/health\")\nasync def health():\n    \"\"\"Health check endpoint\"\"\"\n    return {\n        \"status\": \"healthy\",\n        \"detection_ready\": detection_service._face_analyzer is not None,\n    }\n","numLines":115,"startLine":1,"totalLines":115}}}
{"parentUuid":"73d10f35-af8a-4ee3-b50e-1118ec1ba1d2","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013KFHZMoGgnENWuNEnwt2rk","type":"tool_result","content":"     1→\"\"\"\n     2→Forum router - Categories, Sub-Forums, Posts, Comments, Votes, Reports\n     3→\n     4→Rate Limits:\n     5→- Posts: 5 per minute per user\n     6→- Comments: 20 per minute per user\n     7→- Votes: 30 per minute per user\n     8→- Reports: 10 per hour per user\n     9→\"\"\"\n    10→\n    11→from fastapi import APIRouter, Depends, HTTPException, Query, Request, status\n    12→from sqlalchemy.ext.asyncio import AsyncSession\n    13→from sqlalchemy import select, func, and_, or_, desc\n    14→from sqlalchemy.orm import selectinload\n    15→from uuid import UUID\n    16→from typing import Optional, List\n    17→from datetime import datetime, timezone\n    18→\n    19→from app.database import get_db\n    20→from app.core.rate_limit import limiter, ForumRateLimits\n    21→from app.models.user import User, UserRole\n    22→from app.models.forum import (\n    23→    ForumIssueCategory, ForumSubForum, ForumPost, ForumComment,\n    24→    ForumVote, ForumReport, FlawToForumMapping, ArchetypeForumMapping,\n    25→    ForumBookmark, VoteType, TargetType, ReportStatus, ReportReason\n    26→)\n    27→from app.services.auth import get_current_user, get_current_user_optional\n    28→from app.schemas.forum import (\n    29→    CategoryResponse, CategoryListResponse, SubForumResponse,\n    30→    PostCreate, PostUpdate, PostResponse, PostListItem,\n    31→    PostListResponse, CommentCreate, CommentUpdate, CommentResponse,\n    32→    VoteRequest, VoteResponse, ReportCreate, ReportResponse,\n    33→    GuideSectionResponse, SortOrder, PostAuthor, RecommendedForumResponse,\n    34→    ArchetypeForumRecommendation, ForumSearchResult, ForumSearchResponse,\n    35→    SearchResultType, BookmarkToggleResponse, BookmarkedPostsResponse\n    36→)\n    37→\n    38→router = APIRouter(prefix=\"/forum\", tags=[\"forum\"])\n    39→\n    40→PAGE_SIZE = 20\n    41→MAX_COMMENT_DEPTH = 5\n    42→\n    43→\n    44→# === CATEGORIES ===\n    45→\n    46→@router.get(\"/categories\", response_model=List[CategoryResponse])\n    47→async def list_categories(db: AsyncSession = Depends(get_db)):\n    48→    \"\"\"List all active forum categories with sub-forums and post counts.\n    49→\n    50→    Optimized to use only 2 queries instead of N+1 pattern.\n    51→    \"\"\"\n    52→    # Query 1: Get all categories with sub-forums\n    53→    query = (\n    54→        select(ForumIssueCategory)\n    55→        .options(selectinload(ForumIssueCategory.sub_forums))\n    56→        .where(ForumIssueCategory.is_active == True)\n    57→        .order_by(ForumIssueCategory.display_order)\n    58→    )\n    59→    result = await db.execute(query)\n    60→    categories = result.scalars().all()\n    61→\n    62→    # Query 2: Get ALL sub-forum post counts in ONE query (batched)\n    63→    sf_counts_query = (\n    64→        select(\n    65→            ForumPost.sub_forum_id,\n    66→            func.count(ForumPost.id).label('post_count')\n    67→        )\n    68→        .where(\n    69→            ForumPost.is_deleted == False,\n    70→            ForumPost.is_approved == True\n    71→        )\n    72→        .group_by(ForumPost.sub_forum_id)\n    73→    )\n    74→    sf_counts_result = await db.execute(sf_counts_query)\n    75→    sf_counts = {row[0]: row[1] for row in sf_counts_result}\n    76→\n    77→    # Build response using pre-fetched counts (no additional queries)\n    78→    response = []\n    79→    for cat in categories:\n    80→        cat_post_count = 0\n    81→        sub_forums = []\n    82→\n    83→        for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n    84→            if sf.is_active:\n    85→                sf_post_count = sf_counts.get(sf.id, 0)\n    86→                cat_post_count += sf_post_count\n    87→\n    88→                sub_forums.append(SubForumResponse(\n    89→                    id=sf.id,\n    90→                    name=sf.name,\n    91→                    slug=sf.slug,\n    92→                    description=sf.description,\n    93→                    icon=sf.icon,\n    94→                    display_order=sf.display_order,\n    95→                    post_count=sf_post_count\n    96→                ))\n    97→\n    98→        response.append(CategoryResponse(\n    99→            id=cat.id,\n   100→            name=cat.name,\n   101→            slug=cat.slug,\n   102→            description=cat.description,\n   103→            icon=cat.icon,\n   104→            display_order=cat.display_order,\n   105→            post_count=cat_post_count,\n   106→            sub_forums=sub_forums\n   107→        ))\n   108→\n   109→    return response\n   110→\n   111→\n   112→@router.get(\"/categories/{slug}\", response_model=CategoryResponse)\n   113→async def get_category(\n   114→    slug: str,\n   115→    db: AsyncSession = Depends(get_db)\n   116→):\n   117→    \"\"\"Get a single category by slug with its sub-forums.\n   118→\n   119→    Optimized to use only 2 queries instead of N+1 pattern.\n   120→    \"\"\"\n   121→    # Query 1: Get category with sub-forums\n   122→    query = (\n   123→        select(ForumIssueCategory)\n   124→        .options(selectinload(ForumIssueCategory.sub_forums))\n   125→        .where(ForumIssueCategory.slug == slug, ForumIssueCategory.is_active == True)\n   126→    )\n   127→    result = await db.execute(query)\n   128→    cat = result.scalar_one_or_none()\n   129→\n   130→    if not cat:\n   131→        raise HTTPException(status_code=404, detail=\"Category not found\")\n   132→\n   133→    # Get sub-forum IDs for this category\n   134→    sf_ids = [sf.id for sf in cat.sub_forums if sf.is_active]\n   135→\n   136→    # Query 2: Get post counts for all sub-forums in this category (batched)\n   137→    sf_counts = {}\n   138→    if sf_ids:\n   139→        sf_counts_query = (\n   140→            select(\n   141→                ForumPost.sub_forum_id,\n   142→                func.count(ForumPost.id).label('post_count')\n   143→            )\n   144→            .where(\n   145→                ForumPost.sub_forum_id.in_(sf_ids),\n   146→                ForumPost.is_deleted == False,\n   147→                ForumPost.is_approved == True\n   148→            )\n   149→            .group_by(ForumPost.sub_forum_id)\n   150→        )\n   151→        sf_counts_result = await db.execute(sf_counts_query)\n   152→        sf_counts = {row[0]: row[1] for row in sf_counts_result}\n   153→\n   154→    # Build sub-forums list using pre-fetched counts\n   155→    cat_post_count = 0\n   156→    sub_forums = []\n   157→    for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n   158→        if sf.is_active:\n   159→            sf_post_count = sf_counts.get(sf.id, 0)\n   160→            cat_post_count += sf_post_count\n   161→\n   162→            sub_forums.append(SubForumResponse(\n   163→                id=sf.id,\n   164→                name=sf.name,\n   165→                slug=sf.slug,\n   166→                description=sf.description,\n   167→                icon=sf.icon,\n   168→                display_order=sf.display_order,\n   169→                post_count=sf_post_count\n   170→            ))\n   171→\n   172→    return CategoryResponse(\n   173→        id=cat.id,\n   174→        name=cat.name,\n   175→        slug=cat.slug,\n   176→        description=cat.description,\n   177→        icon=cat.icon,\n   178→        display_order=cat.display_order,\n   179→        post_count=cat_post_count,\n   180→        sub_forums=sub_forums\n   181→    )\n   182→\n   183→\n   184→# === SEARCH ===\n   185→\n   186→@router.get(\"/search\", response_model=ForumSearchResponse)\n   187→async def search_forum(\n   188→    q: str = Query(..., min_length=2, max_length=100, description=\"Search query\"),\n   189→    type: str = Query(\"all\", description=\"Search type: posts, comments, or all\"),\n   190→    limit: int = Query(20, ge=1, le=50),\n   191→    offset: int = Query(0, ge=0),\n   192→    db: AsyncSession = Depends(get_db)\n   193→):\n   194→    \"\"\"Search forum posts and comments using ILIKE pattern matching.\n   195→\n   196→    - Search by title, content for posts\n   197→    - Search by content for comments\n   198→    - Results sorted by vote_count DESC, created_at DESC\n   199→    \"\"\"\n   200→    search_pattern = f\"%{q}%\"\n   201→    results = []\n   202→    total_count = 0\n   203→\n   204→    if type in (\"posts\", \"all\"):\n   205→        # Search posts by title and content\n   206→        post_query = (\n   207→            select(ForumPost)\n   208→            .options(\n   209→                selectinload(ForumPost.author),\n   210→                selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n   211→            )\n   212→            .where(\n   213→                ForumPost.is_deleted == False,\n   214→                ForumPost.is_approved == True,\n   215→                or_(\n   216→                    ForumPost.title.ilike(search_pattern),\n   217→                    ForumPost.content.ilike(search_pattern)\n   218→                )\n   219→            )\n   220→            .order_by(ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n   221→        )\n   222→\n   223→        # Count posts\n   224→        post_count_query = (\n   225→            select(func.count(ForumPost.id))\n   226→            .where(\n   227→                ForumPost.is_deleted == False,\n   228→                ForumPost.is_approved == True,\n   229→                or_(\n   230→                    ForumPost.title.ilike(search_pattern),\n   231→                    ForumPost.content.ilike(search_pattern)\n   232→                )\n   233→            )\n   234→        )\n   235→        post_count_result = await db.execute(post_count_query)\n   236→        post_count = post_count_result.scalar() or 0\n   237→\n   238→        if type == \"posts\":\n   239→            total_count = post_count\n   240→            post_query = post_query.offset(offset).limit(limit)\n   241→        else:\n   242→            total_count += post_count\n   243→            # For \"all\", we get all posts first then merge with comments\n   244→            post_query = post_query.limit(limit * 2)  # Get more to merge\n   245→\n   246→        post_result = await db.execute(post_query)\n   247→        posts = post_result.scalars().all()\n   248→\n   249→        for post in posts:\n   250→            content_preview = post.content[:200] + \"...\" if len(post.content) > 200 else post.content\n   251→            results.append(ForumSearchResult(\n   252→                id=post.id,\n   253→                type=SearchResultType.POST,\n   254→                title=post.title,\n   255→                content_preview=content_preview,\n   256→                post_id=None,\n   257→                post_title=None,\n   258→                author=PostAuthor(id=post.author.id, username=post.author.username),\n   259→                vote_count=post.vote_count,\n   260→                category_slug=post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\",\n   261→                sub_forum_slug=post.sub_forum.slug if post.sub_forum else \"\",\n   262→                created_at=post.created_at\n   263→            ))\n   264→\n   265→    if type in (\"comments\", \"all\"):\n   266→        # Search comments by content\n   267→        comment_query = (\n   268→            select(ForumComment)\n   269→            .options(\n   270→                selectinload(ForumComment.author),\n   271→                selectinload(ForumComment.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n   272→            )\n   273→            .where(\n   274→                ForumComment.is_deleted == False,\n   275→                ForumComment.content.ilike(search_pattern)\n   276→            )\n   277→            .order_by(ForumComment.vote_count.desc(), ForumComment.created_at.desc())\n   278→        )\n   279→\n   280→        # Count comments\n   281→        comment_count_query = (\n   282→            select(func.count(ForumComment.id))\n   283→            .where(\n   284→                ForumComment.is_deleted == False,\n   285→                ForumComment.content.ilike(search_pattern)\n   286→            )\n   287→        )\n   288→        comment_count_result = await db.execute(comment_count_query)\n   289→        comment_count = comment_count_result.scalar() or 0\n   290→\n   291→        if type == \"comments\":\n   292→            total_count = comment_count\n   293→            comment_query = comment_query.offset(offset).limit(limit)\n   294→        else:\n   295→            total_count += comment_count\n   296→            comment_query = comment_query.limit(limit * 2)\n   297→\n   298→        comment_result = await db.execute(comment_query)\n   299→        comments = comment_result.scalars().all()\n   300→\n   301→        for comment in comments:\n   302→            content_preview = comment.content[:200] + \"...\" if len(comment.content) > 200 else comment.content\n   303→            post = comment.post\n   304→            if post and post.sub_forum:\n   305→                category_slug = post.sub_forum.issue_category.slug if post.sub_forum.issue_category else \"\"\n   306→                sub_forum_slug = post.sub_forum.slug\n   307→            else:\n   308→                category_slug = \"\"\n   309→                sub_forum_slug = \"\"\n   310→\n   311→            results.append(ForumSearchResult(\n   312→                id=comment.id,\n   313→                type=SearchResultType.COMMENT,\n   314→                title=None,\n   315→                content_preview=content_preview,\n   316→                post_id=comment.post_id,\n   317→                post_title=post.title if post else None,\n   318→                author=PostAuthor(id=comment.author.id, username=comment.author.username),\n   319→                vote_count=comment.vote_count,\n   320→                category_slug=category_slug,\n   321→                sub_forum_slug=sub_forum_slug,\n   322→                created_at=comment.created_at\n   323→            ))\n   324→\n   325→    # For \"all\" type, sort merged results by vote_count and created_at, then paginate\n   326→    if type == \"all\":\n   327→        results.sort(key=lambda x: (-x.vote_count, x.created_at), reverse=False)\n   328→        results.sort(key=lambda x: x.vote_count, reverse=True)\n   329→        results = results[offset:offset + limit]\n   330→\n   331→    return ForumSearchResponse(\n   332→        results=results,\n   333→        total_count=total_count,\n   334→        query=q,\n   335→        search_type=type,\n   336→        has_more=offset + limit < total_count\n   337→    )\n   338→\n   339→\n   340→@router.get(\"/recommended\", response_model=List[RecommendedForumResponse])\n   341→async def get_recommended_forums(\n   342→    flaws: str = Query(..., description=\"Comma-separated list of flaw IDs\"),\n   343→    db: AsyncSession = Depends(get_db)\n   344→):\n   345→    \"\"\"Get recommended forums based on detected flaws.\"\"\"\n   346→    flaw_list = [f.strip() for f in flaws.split(\",\") if f.strip()]\n   347→\n   348→    if not flaw_list:\n   349→        return []\n   350→\n   351→    # Find mappings for these flaws\n   352→    query = (\n   353→        select(FlawToForumMapping)\n   354→        .options(selectinload(FlawToForumMapping.issue_category))\n   355→        .where(FlawToForumMapping.flaw_id.in_(flaw_list))\n   356→        .order_by(FlawToForumMapping.priority)\n   357→    )\n   358→\n   359→    result = await db.execute(query)\n   360→    mappings = result.scalars().all()\n   361→\n   362→    # Group by category\n   363→    category_flaws = {}\n   364→    for mapping in mappings:\n   365→        cat_id = mapping.issue_category_id\n   366→        if cat_id not in category_flaws:\n   367→            category_flaws[cat_id] = {\n   368→                \"category\": mapping.issue_category,\n   369→                \"flaws\": [],\n   370→                \"priority\": mapping.priority\n   371→            }\n   372→        category_flaws[cat_id][\"flaws\"].append(mapping.flaw_id)\n   373→        # Use lowest priority (1 = primary)\n   374→        if mapping.priority < category_flaws[cat_id][\"priority\"]:\n   375→            category_flaws[cat_id][\"priority\"] = mapping.priority\n   376→\n   377→    # Build response sorted by priority\n   378→    response = []\n   379→    for cat_data in sorted(category_flaws.values(), key=lambda x: x[\"priority\"]):\n   380→        cat = cat_data[\"category\"]\n   381→        response.append(RecommendedForumResponse(\n   382→            category=CategoryListResponse(\n   383→                id=cat.id,\n   384→                name=cat.name,\n   385→                slug=cat.slug,\n   386→                description=cat.description,\n   387→                icon=cat.icon,\n   388→                display_order=cat.display_order,\n   389→                post_count=0\n   390→            ),\n   391→            matched_flaws=cat_data[\"flaws\"],\n   392→            priority=cat_data[\"priority\"]\n   393→        ))\n   394→\n   395→    return response\n   396→\n   397→\n   398→@router.get(\"/archetype-recommendations\", response_model=List[ArchetypeForumRecommendation])\n   399→async def get_archetype_forum_recommendations(\n   400→    archetype: str = Query(..., description=\"Archetype category (Softboy, Prettyboy, RobustPrettyboy, Chad, Hypermasculine, Exotic)\"),\n   401→    db: AsyncSession = Depends(get_db)\n   402→):\n   403→    \"\"\"Get recommended forums based on user's archetype classification.\"\"\"\n   404→    # Normalize archetype name (handle case variations)\n   405→    archetype = archetype.strip()\n   406→\n   407→    # Valid archetypes\n   408→    valid_archetypes = [\"Softboy\", \"Prettyboy\", \"RobustPrettyboy\", \"Chad\", \"Hypermasculine\", \"Exotic\"]\n   409→\n   410→    # Case-insensitive match\n   411→    matched_archetype = None\n   412→    for valid in valid_archetypes:\n   413→        if archetype.lower() == valid.lower():\n   414→            matched_archetype = valid\n   415→            break\n   416→\n   417→    if not matched_archetype:\n   418→        # Return empty list for invalid archetype (not an error)\n   419→        return []\n   420→\n   421→    # Find mappings for this archetype, ordered by priority (highest first)\n   422→    query = (\n   423→        select(ArchetypeForumMapping)\n   424→        .options(selectinload(ArchetypeForumMapping.issue_category))\n   425→        .where(ArchetypeForumMapping.archetype_category == matched_archetype)\n   426→        .order_by(ArchetypeForumMapping.priority.desc())\n   427→    )\n   428→\n   429→    result = await db.execute(query)\n   430→    mappings = result.scalars().all()\n   431→\n   432→    # Build response\n   433→    response = []\n   434→    for mapping in mappings:\n   435→        cat = mapping.issue_category\n   436→        if cat and cat.is_active:\n   437→            response.append(ArchetypeForumRecommendation(\n   438→                category=CategoryListResponse(\n   439→                    id=cat.id,\n   440→                    name=cat.name,\n   441→                    slug=cat.slug,\n   442→                    description=cat.description,\n   443→                    icon=cat.icon,\n   444→                    display_order=cat.display_order,\n   445→                    post_count=0  # Could be optimized with a count query if needed\n   446→                ),\n   447→                archetype=matched_archetype,\n   448→                reason=mapping.reason,\n   449→                priority=mapping.priority\n   450→            ))\n   451→\n   452→    return response\n   453→\n   454→\n   455→@router.get(\"/guides\", response_model=List[GuideSectionResponse])\n   456→async def get_guides_section(db: AsyncSession = Depends(get_db)):\n   457→    \"\"\"Get pinned guides grouped by category for the top section.\"\"\"\n   458→    # Get categories\n   459→    cat_query = (\n   460→        select(ForumIssueCategory)\n   461→        .where(ForumIssueCategory.is_active == True)\n   462→        .order_by(ForumIssueCategory.display_order)\n   463→    )\n   464→    cat_result = await db.execute(cat_query)\n   465→    categories = cat_result.scalars().all()\n   466→\n   467→    response = []\n   468→    for cat in categories:\n   469→        # Get top 5 guides (pinned or marked as guide) per category\n   470→        guide_query = (\n   471→            select(ForumPost)\n   472→            .options(\n   473→                selectinload(ForumPost.author),\n   474→                selectinload(ForumPost.sub_forum)\n   475→            )\n   476→            .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n   477→            .where(\n   478→                ForumSubForum.issue_category_id == cat.id,\n   479→                ForumPost.is_deleted == False,\n   480→                ForumPost.is_approved == True,\n   481→                or_(ForumPost.is_pinned == True, ForumPost.is_guide == True)\n   482→            )\n   483→            .order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n   484→            .limit(5)\n   485→        )\n   486→        guide_result = await db.execute(guide_query)\n   487→        guides = guide_result.scalars().all()\n   488→\n   489→        if guides:  # Only include categories that have guides\n   490→            response.append(GuideSectionResponse(\n   491→                category=CategoryListResponse(\n   492→                    id=cat.id,\n   493→                    name=cat.name,\n   494→                    slug=cat.slug,\n   495→                    description=cat.description,\n   496→                    icon=cat.icon,\n   497→                    display_order=cat.display_order,\n   498→                    post_count=0\n   499→                ),\n   500→                guides=[_post_to_list_item(g, cat.slug, None) for g in guides]\n   501→            ))\n   502→\n   503→    return response\n   504→\n   505→\n   506→# === POSTS ===\n   507→\n   508→@router.get(\"/sub-forums/{sub_forum_id}/posts\", response_model=PostListResponse)\n   509→async def list_sub_forum_posts(\n   510→    sub_forum_id: UUID,\n   511→    sort: SortOrder = Query(SortOrder.HOT),\n   512→    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n   513→    offset: int = Query(0, ge=0),\n   514→    current_user: Optional[User] = Depends(get_current_user_optional),\n   515→    db: AsyncSession = Depends(get_db),\n   516→):\n   517→    \"\"\"List posts in a sub-forum with sorting and pagination.\"\"\"\n   518→    # Verify sub-forum exists and get category\n   519→    sf_result = await db.execute(\n   520→        select(ForumSubForum)\n   521→        .options(selectinload(ForumSubForum.issue_category))\n   522→        .where(ForumSubForum.id == sub_forum_id)\n   523→    )\n   524→    sub_forum = sf_result.scalar_one_or_none()\n   525→    if not sub_forum:\n   526→        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n   527→\n   528→    category_slug = sub_forum.issue_category.slug\n   529→\n   530→    # Base query\n   531→    query = (\n   532→        select(ForumPost)\n   533→        .options(selectinload(ForumPost.author))\n   534→        .where(\n   535→            ForumPost.sub_forum_id == sub_forum_id,\n   536→            ForumPost.is_deleted == False,\n   537→            ForumPost.is_approved == True\n   538→        )\n   539→    )\n   540→\n   541→    # Sorting - pinned always first\n   542→    if sort == SortOrder.NEW:\n   543→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n   544→    elif sort == SortOrder.TOP:\n   545→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n   546→    else:  # HOT - combination of votes and recency\n   547→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n   548→\n   549→    # Get total count\n   550→    count_query = (\n   551→        select(func.count(ForumPost.id))\n   552→        .where(\n   553→            ForumPost.sub_forum_id == sub_forum_id,\n   554→            ForumPost.is_deleted == False,\n   555→            ForumPost.is_approved == True\n   556→        )\n   557→    )\n   558→    total_result = await db.execute(count_query)\n   559→    total_count = total_result.scalar() or 0\n   560→\n   561→    # Paginate\n   562→    query = query.offset(offset).limit(limit)\n   563→    result = await db.execute(query)\n   564→    posts = result.scalars().all()\n   565→\n   566→    # Get user votes if authenticated\n   567→    user_votes = {}\n   568→    if current_user:\n   569→        post_ids = [p.id for p in posts]\n   570→        if post_ids:\n   571→            votes_query = select(ForumVote).where(\n   572→                ForumVote.user_id == current_user.id,\n   573→                ForumVote.target_type == TargetType.POST,\n   574→                ForumVote.target_id.in_(post_ids)\n   575→            )\n   576→            votes_result = await db.execute(votes_query)\n   577→            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n   578→\n   579→    return PostListResponse(\n   580→        posts=[_post_to_list_item(p, category_slug, user_votes.get(p.id)) for p in posts],\n   581→        total_count=total_count,\n   582→        has_more=offset + limit < total_count\n   583→    )\n   584→\n   585→\n   586→@router.get(\"/categories/{slug}/posts\", response_model=PostListResponse)\n   587→async def list_category_posts(\n   588→    slug: str,\n   589→    sort: SortOrder = Query(SortOrder.HOT),\n   590→    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n   591→    offset: int = Query(0, ge=0),\n   592→    current_user: Optional[User] = Depends(get_current_user_optional),\n   593→    db: AsyncSession = Depends(get_db),\n   594→):\n   595→    \"\"\"List all posts in a category (across all sub-forums) with sorting and pagination.\"\"\"\n   596→    # Verify category exists\n   597→    cat_result = await db.execute(\n   598→        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n   599→    )\n   600→    category = cat_result.scalar_one_or_none()\n   601→    if not category:\n   602→        raise HTTPException(status_code=404, detail=\"Category not found\")\n   603→\n   604→    # Base query - join with sub-forums to filter by category\n   605→    query = (\n   606→        select(ForumPost)\n   607→        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n   608→        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n   609→        .where(\n   610→            ForumSubForum.issue_category_id == category.id,\n   611→            ForumPost.is_deleted == False,\n   612→            ForumPost.is_approved == True\n   613→        )\n   614→    )\n   615→\n   616→    # Sorting\n   617→    if sort == SortOrder.NEW:\n   618→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n   619→    elif sort == SortOrder.TOP:\n   620→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n   621→    else:\n   622→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n   623→\n   624→    # Get total count\n   625→    count_query = (\n   626→        select(func.count(ForumPost.id))\n   627→        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n   628→        .where(\n   629→            ForumSubForum.issue_category_id == category.id,\n   630→            ForumPost.is_deleted == False,\n   631→            ForumPost.is_approved == True\n   632→        )\n   633→    )\n   634→    total_result = await db.execute(count_query)\n   635→    total_count = total_result.scalar() or 0\n   636→\n   637→    # Paginate\n   638→    query = query.offset(offset).limit(limit)\n   639→    result = await db.execute(query)\n   640→    posts = result.scalars().all()\n   641→\n   642→    # Get user votes\n   643→    user_votes = {}\n   644→    if current_user:\n   645→        post_ids = [p.id for p in posts]\n   646→        if post_ids:\n   647→            votes_query = select(ForumVote).where(\n   648→                ForumVote.user_id == current_user.id,\n   649→                ForumVote.target_type == TargetType.POST,\n   650→                ForumVote.target_id.in_(post_ids)\n   651→            )\n   652→            votes_result = await db.execute(votes_query)\n   653→            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n   654→\n   655→    return PostListResponse(\n   656→        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n   657→        total_count=total_count,\n   658→        has_more=offset + limit < total_count\n   659→    )\n   660→\n   661→\n   662→@router.get(\"/categories/{slug}/{sub_forum_slug}/posts\", response_model=PostListResponse)\n   663→async def list_sub_forum_posts(\n   664→    slug: str,\n   665→    sub_forum_slug: str,\n   666→    sort: SortOrder = Query(SortOrder.HOT),\n   667→    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n   668→    offset: int = Query(0, ge=0),\n   669→    current_user: Optional[User] = Depends(get_current_user_optional),\n   670→    db: AsyncSession = Depends(get_db),\n   671→):\n   672→    \"\"\"List all posts in a specific sub-forum with sorting and pagination.\"\"\"\n   673→    # Verify category and sub-forum exist\n   674→    cat_result = await db.execute(\n   675→        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n   676→    )\n   677→    category = cat_result.scalar_one_or_none()\n   678→    if not category:\n   679→        raise HTTPException(status_code=404, detail=\"Category not found\")\n   680→\n   681→    sf_result = await db.execute(\n   682→        select(ForumSubForum).where(\n   683→            ForumSubForum.slug == sub_forum_slug,\n   684→            ForumSubForum.issue_category_id == category.id\n   685→        )\n   686→    )\n   687→    sub_forum = sf_result.scalar_one_or_none()\n   688→    if not sub_forum:\n   689→        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n   690→\n   691→    # Base query\n   692→    query = (\n   693→        select(ForumPost)\n   694→        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n   695→        .where(\n   696→            ForumPost.sub_forum_id == sub_forum.id,\n   697→            ForumPost.is_deleted == False,\n   698→            ForumPost.is_approved == True\n   699→        )\n   700→    )\n   701→\n   702→    # Sorting\n   703→    if sort == SortOrder.NEW:\n   704→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n   705→    elif sort == SortOrder.TOP:\n   706→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n   707→    else:\n   708→        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n   709→\n   710→    # Get total count\n   711→    count_query = (\n   712→        select(func.count(ForumPost.id))\n   713→        .where(\n   714→            ForumPost.sub_forum_id == sub_forum.id,\n   715→            ForumPost.is_deleted == False,\n   716→            ForumPost.is_approved == True\n   717→        )\n   718→    )\n   719→    total_result = await db.execute(count_query)\n   720→    total_count = total_result.scalar() or 0\n   721→\n   722→    # Paginate\n   723→    query = query.offset(offset).limit(limit)\n   724→    result = await db.execute(query)\n   725→    posts = result.scalars().all()\n   726→\n   727→    # Get user votes\n   728→    user_votes = {}\n   729→    if current_user:\n   730→        post_ids = [p.id for p in posts]\n   731→        if post_ids:\n   732→            votes_query = select(ForumVote).where(\n   733→                ForumVote.user_id == current_user.id,\n   734→                ForumVote.target_type == TargetType.POST,\n   735→                ForumVote.target_id.in_(post_ids)\n   736→            )\n   737→            votes_result = await db.execute(votes_query)\n   738→            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n   739→\n   740→    return PostListResponse(\n   741→        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n   742→        total_count=total_count,\n   743→        has_more=offset + limit < total_count\n   744→    )\n   745→\n   746→\n   747→@router.post(\"/posts\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\n   748→@limiter.limit(ForumRateLimits.POSTS)\n   749→async def create_post(\n   750→    request: Request,\n   751→    data: PostCreate,\n   752→    current_user: User = Depends(get_current_user),\n   753→    db: AsyncSession = Depends(get_db),\n   754→):\n   755→    \"\"\"Create a new post.\n   756→\n   757→    Rate limit: 5 posts per minute per user.\n   758→    \"\"\"\n   759→    # Verify sub-forum exists\n   760→    sf_result = await db.execute(\n   761→        select(ForumSubForum)\n   762→        .options(selectinload(ForumSubForum.issue_category))\n   763→        .where(ForumSubForum.id == data.sub_forum_id)\n   764→    )\n   765→    sub_forum = sf_result.scalar_one_or_none()\n   766→    if not sub_forum:\n   767→        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n   768→\n   769→    post = ForumPost(\n   770→        title=data.title,\n   771→        content=data.content,\n   772→        sub_forum_id=data.sub_forum_id,\n   773→        author_id=current_user.id,\n   774→    )\n   775→\n   776→    db.add(post)\n   777→    await db.commit()\n   778→    await db.refresh(post)\n   779→\n   780→    return _post_to_response(post, sub_forum.slug, sub_forum.issue_category.slug, None)\n   781→\n   782→\n   783→@router.get(\"/posts/{post_id}\", response_model=PostResponse)\n   784→async def get_post(\n   785→    post_id: UUID,\n   786→    current_user: Optional[User] = Depends(get_current_user_optional),\n   787→    db: AsyncSession = Depends(get_db),\n   788→):\n   789→    \"\"\"Get a single post with full details.\"\"\"\n   790→    query = (\n   791→        select(ForumPost)\n   792→        .options(\n   793→            selectinload(ForumPost.author),\n   794→            selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n   795→        )\n   796→        .where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n   797→    )\n   798→    result = await db.execute(query)\n   799→    post = result.scalar_one_or_none()\n   800→\n   801→    if not post:\n   802→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   803→\n   804→    # Get user's vote\n   805→    user_vote = None\n   806→    if current_user:\n   807→        vote_result = await db.execute(\n   808→            select(ForumVote).where(\n   809→                ForumVote.user_id == current_user.id,\n   810→                ForumVote.target_type == TargetType.POST,\n   811→                ForumVote.target_id == post_id\n   812→            )\n   813→        )\n   814→        vote = vote_result.scalar_one_or_none()\n   815→        user_vote = vote.vote_type if vote else None\n   816→\n   817→    return _post_to_response(\n   818→        post,\n   819→        post.sub_forum.slug,\n   820→        post.sub_forum.issue_category.slug,\n   821→        user_vote\n   822→    )\n   823→\n   824→\n   825→@router.post(\"/posts/{post_id}/vote\", response_model=VoteResponse)\n   826→@limiter.limit(ForumRateLimits.VOTES)\n   827→async def vote_on_post(\n   828→    request: Request,\n   829→    post_id: UUID,\n   830→    data: VoteRequest,\n   831→    current_user: User = Depends(get_current_user),\n   832→    db: AsyncSession = Depends(get_db),\n   833→):\n   834→    \"\"\"Vote on a post (upvote/downvote). Voting again removes vote, changing vote type switches it.\n   835→\n   836→    Rate limit: 30 votes per minute per user.\n   837→    \"\"\"\n   838→    # Verify post exists\n   839→    post_result = await db.execute(\n   840→        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n   841→    )\n   842→    post = post_result.scalar_one_or_none()\n   843→    if not post:\n   844→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   845→\n   846→    # Prevent self-voting\n   847→    if post.author_id == current_user.id:\n   848→        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")\n   849→\n   850→    # Check existing vote\n   851→    vote_result = await db.execute(\n   852→        select(ForumVote).where(\n   853→            ForumVote.user_id == current_user.id,\n   854→            ForumVote.target_type == TargetType.POST,\n   855→            ForumVote.target_id == post_id\n   856→        )\n   857→    )\n   858→    existing_vote = vote_result.scalar_one_or_none()\n   859→\n   860→    new_user_vote = None\n   861→    if existing_vote:\n   862→        # Robustly get value (handle if DB returns string or Enum)\n   863→        current_val = existing_vote.vote_type.value if hasattr(existing_vote.vote_type, 'value') else existing_vote.vote_type\n   864→        # Request is from Pydantic Schema Enum\n   865→        request_val = data.vote_type.value\n   866→\n   867→        if current_val == request_val:\n   868→            # Same vote - remove it\n   869→            await db.delete(existing_vote)\n   870→            post.vote_count += -1 if request_val == \"up\" else 1\n   871→        else:\n   872→            # Different vote - switch it\n   873→            # Ensure we assign the Model Enum (or string if that's what it wants, but Model Enum is safer if Typed)\n   874→            existing_vote.vote_type = VoteType(request_val)\n   875→            # Swing by 2 (remove old, add new)\n   876→            post.vote_count += 2 if request_val == \"up\" else -2\n   877→            new_user_vote = data.vote_type\n   878→    else:\n   879→        # New vote\n   880→        vote = ForumVote(\n   881→            user_id=current_user.id,\n   882→            target_type=TargetType.POST,\n   883→            target_id=post_id,\n   884→            # Explicitly cast to Model Enum\n   885→            vote_type=VoteType(data.vote_type.value)\n   886→        )\n   887→        db.add(vote)\n   888→        post.vote_count += 1 if data.vote_type.value == \"up\" else -1\n   889→        new_user_vote = data.vote_type\n   890→\n   891→    await db.commit()\n   892→\n   893→    return VoteResponse(success=True, new_vote_count=post.vote_count, user_vote=new_user_vote)\n   894→\n   895→\n   896→@router.delete(\"/posts/{post_id}\")\n   897→async def delete_post(\n   898→    post_id: UUID,\n   899→    current_user: User = Depends(get_current_user),\n   900→    db: AsyncSession = Depends(get_db),\n   901→):\n   902→    \"\"\"Delete a post (author or moderator).\"\"\"\n   903→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n   904→    post = post_result.scalar_one_or_none()\n   905→    if not post:\n   906→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   907→\n   908→    is_author = post.author_id == current_user.id\n   909→    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n   910→\n   911→    if not is_author and not is_mod:\n   912→        raise HTTPException(status_code=403, detail=\"Not authorized\")\n   913→\n   914→    post.is_deleted = True\n   915→    post.deleted_at = datetime.now(timezone.utc)\n   916→    post.deleted_by = current_user.id\n   917→    await db.commit()\n   918→\n   919→    return {\"success\": True}\n   920→\n   921→\n   922→@router.put(\"/posts/{post_id}\", response_model=PostResponse)\n   923→async def update_post(\n   924→    post_id: UUID,\n   925→    data: PostUpdate,\n   926→    current_user: User = Depends(get_current_user),\n   927→    db: AsyncSession = Depends(get_db),\n   928→):\n   929→    \"\"\"Update a post (author only).\"\"\"\n   930→    post_result = await db.execute(\n   931→        select(ForumPost)\n   932→        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n   933→        .where(ForumPost.id == post_id)\n   934→    )\n   935→    post = post_result.scalar_one_or_none()\n   936→    if not post:\n   937→        raise HTTPException(status_code=404, detail=\"Post not found\")\n   938→\n   939→    if post.author_id != current_user.id:\n   940→        raise HTTPException(status_code=403, detail=\"Not authorized to edit this post\")\n   941→\n   942→    if data.title is not None:\n   943→        post.title = data.title\n   944→    if data.content is not None:\n   945→        post.content = data.content\n   946→    post.updated_at = datetime.utcnow()\n   947→\n   948→    await db.commit()\n   949→    await db.refresh(post)\n   950→\n   951→    # Get user vote\n   952→    vote_result = await db.execute(\n   953→        select(ForumVote).where(\n   954→            ForumVote.user_id == current_user.id,\n   955→            ForumVote.target_type == TargetType.POST,\n   956→            ForumVote.target_id == post_id\n   957→        )\n   958→    )\n   959→    user_vote = vote_result.scalar_one_or_none()\n   960→\n   961→    # Get category slug\n   962→    sf = post.sub_forum\n   963→    cat_result = await db.execute(\n   964→        select(ForumIssueCategory).where(ForumIssueCategory.id == sf.issue_category_id)\n   965→    )\n   966→    cat = cat_result.scalar_one()\n   967→\n   968→    return PostResponse(\n   969→        id=post.id,\n   970→        title=post.title,\n   971→        content=post.content,\n   972→        vote_count=post.vote_count,\n   973→        comment_count=post.comment_count,\n   974→        is_pinned=post.is_pinned,\n   975→        is_guide=post.is_guide,\n   976→        created_at=post.created_at,\n   977→        updated_at=post.updated_at,\n   978→        author=PostAuthor(\n   979→            id=post.author.id,\n   980→            username=post.author.username,\n   981→            avatar_url=None\n   982→        ),\n   983→        sub_forum=SubForumResponse(\n   984→            id=sf.id,\n   985→            name=sf.name,\n   986→            slug=sf.slug,\n   987→            description=sf.description,\n   988→            icon=sf.icon,\n   989→            display_order=sf.display_order,\n   990→            post_count=0\n   991→        ),\n   992→        category_slug=cat.slug,\n   993→        user_vote=user_vote.vote_type if user_vote else None\n   994→    )\n   995→\n   996→\n   997→# === COMMENTS ===\n   998→\n   999→@router.get(\"/posts/{post_id}/comments\", response_model=List[CommentResponse])\n  1000→async def get_post_comments(\n  1001→    post_id: UUID,\n  1002→    current_user: Optional[User] = Depends(get_current_user_optional),\n  1003→    db: AsyncSession = Depends(get_db),\n  1004→):\n  1005→    \"\"\"Get all comments for a post in a threaded structure.\"\"\"\n  1006→    # Verify post exists\n  1007→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n  1008→    if not post_result.scalar_one_or_none():\n  1009→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1010→\n  1011→    # Get all comments for post\n  1012→    query = (\n  1013→        select(ForumComment)\n  1014→        .options(selectinload(ForumComment.author))\n  1015→        .where(ForumComment.post_id == post_id, ForumComment.is_deleted == False)\n  1016→        .order_by(ForumComment.created_at)\n  1017→    )\n  1018→    result = await db.execute(query)\n  1019→    comments = result.scalars().all()\n  1020→\n  1021→    # Get user votes\n  1022→    user_votes = {}\n  1023→    if current_user:\n  1024→        comment_ids = [c.id for c in comments]\n  1025→        if comment_ids:\n  1026→            votes_query = select(ForumVote).where(\n  1027→                ForumVote.user_id == current_user.id,\n  1028→                ForumVote.target_type == TargetType.COMMENT,\n  1029→                ForumVote.target_id.in_(comment_ids)\n  1030→            )\n  1031→            votes_result = await db.execute(votes_query)\n  1032→            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n  1033→\n  1034→    # Build tree structure\n  1035→    return _build_comment_tree(comments, user_votes)\n  1036→\n  1037→\n  1038→@router.post(\"/posts/{post_id}/comments\", response_model=CommentResponse, status_code=status.HTTP_201_CREATED)\n  1039→@limiter.limit(ForumRateLimits.COMMENTS)\n  1040→async def create_comment(\n  1041→    request: Request,\n  1042→    post_id: UUID,\n  1043→    data: CommentCreate,\n  1044→    current_user: User = Depends(get_current_user),\n  1045→    db: AsyncSession = Depends(get_db),\n  1046→):\n  1047→    \"\"\"Create a comment on a post.\n  1048→\n  1049→    Rate limit: 20 comments per minute per user.\n  1050→    \"\"\"\n  1051→    # Verify post exists\n  1052→    post_result = await db.execute(\n  1053→        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n  1054→    )\n  1055→    post = post_result.scalar_one_or_none()\n  1056→    if not post:\n  1057→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1058→\n  1059→    depth = 0\n  1060→    if data.parent_id:\n  1061→        # Verify parent comment exists\n  1062→        parent_result = await db.execute(\n  1063→            select(ForumComment).where(\n  1064→                ForumComment.id == data.parent_id,\n  1065→                ForumComment.post_id == post_id\n  1066→            )\n  1067→        )\n  1068→        parent = parent_result.scalar_one_or_none()\n  1069→        if not parent:\n  1070→            raise HTTPException(status_code=404, detail=\"Parent comment not found\")\n  1071→        depth = min(parent.depth + 1, MAX_COMMENT_DEPTH)\n  1072→\n  1073→    comment = ForumComment(\n  1074→        content=data.content,\n  1075→        post_id=post_id,\n  1076→        author_id=current_user.id,\n  1077→        parent_id=data.parent_id,\n  1078→        depth=depth,\n  1079→    )\n  1080→\n  1081→    db.add(comment)\n  1082→    await db.commit()\n  1083→    await db.refresh(comment)\n  1084→\n  1085→    # Load author relationship\n  1086→    await db.refresh(comment, [\"author\"])\n  1087→\n  1088→    return _comment_to_response(comment, None)\n  1089→\n  1090→\n  1091→@router.post(\"/comments/{comment_id}/vote\", response_model=VoteResponse)\n  1092→@limiter.limit(ForumRateLimits.VOTES)\n  1093→async def vote_on_comment(\n  1094→    request: Request,\n  1095→    comment_id: UUID,\n  1096→    data: VoteRequest,\n  1097→    current_user: User = Depends(get_current_user),\n  1098→    db: AsyncSession = Depends(get_db),\n  1099→):\n  1100→    \"\"\"Vote on a comment.\n  1101→\n  1102→    Rate limit: 30 votes per minute per user.\n  1103→    \"\"\"\n  1104→    comment_result = await db.execute(\n  1105→        select(ForumComment).where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n  1106→    )\n  1107→    comment = comment_result.scalar_one_or_none()\n  1108→    if not comment:\n  1109→        raise HTTPException(status_code=404, detail=\"Comment not found\")\n  1110→\n  1111→    # Prevent self-voting\n  1112→    if comment.author_id == current_user.id:\n  1113→        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")\n  1114→\n  1115→    vote_result = await db.execute(\n  1116→        select(ForumVote).where(\n  1117→            ForumVote.user_id == current_user.id,\n  1118→            ForumVote.target_type == TargetType.COMMENT,\n  1119→            ForumVote.target_id == comment_id\n  1120→        )\n  1121→    )\n  1122→    existing_vote = vote_result.scalar_one_or_none()\n  1123→\n  1124→    new_user_vote = None\n  1125→    if existing_vote:\n  1126→        if existing_vote.vote_type == data.vote_type:\n  1127→            await db.delete(existing_vote)\n  1128→            comment.vote_count += -1 if data.vote_type == VoteType.UP else 1\n  1129→        else:\n  1130→            existing_vote.vote_type = data.vote_type\n  1131→            comment.vote_count += 2 if data.vote_type == VoteType.UP else -2\n  1132→            new_user_vote = data.vote_type\n  1133→    else:\n  1134→        vote = ForumVote(\n  1135→            user_id=current_user.id,\n  1136→            target_type=TargetType.COMMENT,\n  1137→            target_id=comment_id,\n  1138→            vote_type=data.vote_type\n  1139→        )\n  1140→        db.add(vote)\n  1141→        comment.vote_count += 1 if data.vote_type == VoteType.UP else -1\n  1142→        new_user_vote = data.vote_type\n  1143→\n  1144→    await db.commit()\n  1145→\n  1146→    return VoteResponse(success=True, new_vote_count=comment.vote_count, user_vote=new_user_vote)\n  1147→\n  1148→\n  1149→@router.put(\"/comments/{comment_id}\", response_model=CommentResponse)\n  1150→async def update_comment(\n  1151→    comment_id: UUID,\n  1152→    data: CommentUpdate,\n  1153→    current_user: User = Depends(get_current_user),\n  1154→    db: AsyncSession = Depends(get_db),\n  1155→):\n  1156→    \"\"\"Update a comment (author only).\"\"\"\n  1157→    comment_result = await db.execute(\n  1158→        select(ForumComment)\n  1159→        .options(selectinload(ForumComment.author))\n  1160→        .where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n  1161→    )\n  1162→    comment = comment_result.scalar_one_or_none()\n  1163→    if not comment:\n  1164→        raise HTTPException(status_code=404, detail=\"Comment not found\")\n  1165→\n  1166→    if comment.author_id != current_user.id:\n  1167→        raise HTTPException(status_code=403, detail=\"Not authorized to edit this comment\")\n  1168→\n  1169→    comment.content = data.content\n  1170→    comment.updated_at = datetime.utcnow()\n  1171→\n  1172→    await db.commit()\n  1173→    await db.refresh(comment)\n  1174→\n  1175→    # Get user vote\n  1176→    vote_result = await db.execute(\n  1177→        select(ForumVote).where(\n  1178→            ForumVote.user_id == current_user.id,\n  1179→            ForumVote.target_type == TargetType.COMMENT,\n  1180→            ForumVote.target_id == comment_id\n  1181→        )\n  1182→    )\n  1183→    user_vote = vote_result.scalar_one_or_none()\n  1184→\n  1185→    return _comment_to_response(comment, user_vote.vote_type if user_vote else None)\n  1186→\n  1187→\n  1188→@router.delete(\"/comments/{comment_id}\")\n  1189→async def delete_comment(\n  1190→    comment_id: UUID,\n  1191→    current_user: User = Depends(get_current_user),\n  1192→    db: AsyncSession = Depends(get_db),\n  1193→):\n  1194→    \"\"\"Delete a comment (author or moderator).\"\"\"\n  1195→    comment_result = await db.execute(select(ForumComment).where(ForumComment.id == comment_id))\n  1196→    comment = comment_result.scalar_one_or_none()\n  1197→    if not comment:\n  1198→        raise HTTPException(status_code=404, detail=\"Comment not found\")\n  1199→\n  1200→    is_author = comment.author_id == current_user.id\n  1201→    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n  1202→\n  1203→    if not is_author and not is_mod:\n  1204→        raise HTTPException(status_code=403, detail=\"Not authorized\")\n  1205→\n  1206→    comment.is_deleted = True\n  1207→    comment.deleted_at = datetime.now(timezone.utc)\n  1208→    comment.deleted_by = current_user.id\n  1209→\n  1210→    # Decrement comment count on the parent post\n  1211→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == comment.post_id))\n  1212→    post = post_result.scalar_one_or_none()\n  1213→    if post and post.comment_count > 0:\n  1214→        post.comment_count -= 1\n  1215→\n  1216→    await db.commit()\n  1217→\n  1218→    return {\"success\": True}\n  1219→\n  1220→\n  1221→# === REPORTS ===\n  1222→\n  1223→@router.post(\"/reports\", response_model=ReportResponse, status_code=status.HTTP_201_CREATED)\n  1224→@limiter.limit(ForumRateLimits.REPORTS)\n  1225→async def create_report(\n  1226→    request: Request,\n  1227→    data: ReportCreate,\n  1228→    current_user: User = Depends(get_current_user),\n  1229→    db: AsyncSession = Depends(get_db),\n  1230→):\n  1231→    \"\"\"Report a post or comment.\n  1232→\n  1233→    Rate limit: 10 reports per hour per user.\n  1234→    \"\"\"\n  1235→    # Verify target exists\n  1236→    if data.target_type == TargetType.POST:\n  1237→        target_result = await db.execute(select(ForumPost).where(ForumPost.id == data.target_id))\n  1238→    else:\n  1239→        target_result = await db.execute(select(ForumComment).where(ForumComment.id == data.target_id))\n  1240→\n  1241→    if not target_result.scalar_one_or_none():\n  1242→        raise HTTPException(status_code=404, detail=\"Target not found\")\n  1243→\n  1244→    # Check for duplicate report\n  1245→    existing = await db.execute(\n  1246→        select(ForumReport).where(\n  1247→            ForumReport.reporter_id == current_user.id,\n  1248→            ForumReport.target_type == data.target_type,\n  1249→            ForumReport.target_id == data.target_id,\n  1250→            ForumReport.status == ReportStatus.PENDING\n  1251→        )\n  1252→    )\n  1253→    if existing.scalar_one_or_none():\n  1254→        raise HTTPException(status_code=400, detail=\"You have already reported this content\")\n  1255→\n  1256→    report = ForumReport(\n  1257→        reporter_id=current_user.id,\n  1258→        target_type=data.target_type,\n  1259→        target_id=data.target_id,\n  1260→        reason=data.reason,\n  1261→        details=data.details,\n  1262→    )\n  1263→\n  1264→    db.add(report)\n  1265→    await db.commit()\n  1266→    await db.refresh(report)\n  1267→\n  1268→    return ReportResponse(\n  1269→        id=report.id,\n  1270→        target_type=report.target_type,\n  1271→        target_id=report.target_id,\n  1272→        reason=report.reason,\n  1273→        status=report.status.value,\n  1274→        created_at=report.created_at\n  1275→    )\n  1276→\n  1277→\n  1278→# === MODERATION (Admin/Moderator only) ===\n  1279→\n  1280→@router.post(\"/posts/{post_id}/pin\")\n  1281→async def pin_post(\n  1282→    post_id: UUID,\n  1283→    current_user: User = Depends(get_current_user),\n  1284→    db: AsyncSession = Depends(get_db),\n  1285→):\n  1286→    \"\"\"Pin/unpin a post (moderator only).\"\"\"\n  1287→    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n  1288→        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n  1289→\n  1290→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n  1291→    post = post_result.scalar_one_or_none()\n  1292→    if not post:\n  1293→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1294→\n  1295→    post.is_pinned = not post.is_pinned\n  1296→    await db.commit()\n  1297→\n  1298→    return {\"success\": True, \"is_pinned\": post.is_pinned}\n  1299→\n  1300→\n  1301→@router.post(\"/posts/{post_id}/mark-guide\")\n  1302→async def mark_as_guide(\n  1303→    post_id: UUID,\n  1304→    current_user: User = Depends(get_current_user),\n  1305→    db: AsyncSession = Depends(get_db),\n  1306→):\n  1307→    \"\"\"Mark/unmark a post as a guide (moderator only).\"\"\"\n  1308→    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n  1309→        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n  1310→\n  1311→    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n  1312→    post = post_result.scalar_one_or_none()\n  1313→    if not post:\n  1314→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1315→\n  1316→    post.is_guide = not post.is_guide\n  1317→    await db.commit()\n  1318→\n  1319→    return {\"success\": True, \"is_guide\": post.is_guide}\n  1320→\n  1321→\n  1322→@router.get(\"/reports\", response_model=List[ReportResponse])\n  1323→async def list_reports(\n  1324→    status_filter: Optional[ReportStatus] = Query(None, alias=\"status\"),\n  1325→    limit: int = Query(50, ge=1, le=100),\n  1326→    offset: int = Query(0, ge=0),\n  1327→    current_user: User = Depends(get_current_user),\n  1328→    db: AsyncSession = Depends(get_db),\n  1329→):\n  1330→    \"\"\"List reports (moderator only).\"\"\"\n  1331→    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n  1332→        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n  1333→\n  1334→    query = select(ForumReport).order_by(ForumReport.created_at.desc())\n  1335→\n  1336→    if status_filter:\n  1337→        query = query.where(ForumReport.status == status_filter)\n  1338→\n  1339→    query = query.offset(offset).limit(limit)\n  1340→    result = await db.execute(query)\n  1341→    reports = result.scalars().all()\n  1342→\n  1343→    return [\n  1344→        ReportResponse(\n  1345→            id=r.id,\n  1346→            target_type=r.target_type,\n  1347→            target_id=r.target_id,\n  1348→            reason=r.reason,\n  1349→            status=r.status.value,\n  1350→            created_at=r.created_at\n  1351→        )\n  1352→        for r in reports\n  1353→    ]\n  1354→\n  1355→\n  1356→@router.patch(\"/reports/{report_id}\")\n  1357→async def update_report_status(\n  1358→    report_id: UUID,\n  1359→    new_status: ReportStatus,\n  1360→    current_user: User = Depends(get_current_user),\n  1361→    db: AsyncSession = Depends(get_db),\n  1362→):\n  1363→    \"\"\"Update report status (moderator only).\"\"\"\n  1364→    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n  1365→        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n  1366→\n  1367→    report_result = await db.execute(select(ForumReport).where(ForumReport.id == report_id))\n  1368→    report = report_result.scalar_one_or_none()\n  1369→    if not report:\n  1370→        raise HTTPException(status_code=404, detail=\"Report not found\")\n  1371→\n  1372→    report.status = new_status\n  1373→    report.reviewed_by = current_user.id\n  1374→    report.reviewed_at = datetime.utcnow()\n  1375→\n  1376→    await db.commit()\n  1377→\n  1378→    return {\"success\": True, \"status\": new_status.value}\n  1379→\n  1380→\n  1381→# === BOOKMARKS ===\n  1382→\n  1383→@router.post(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\n  1384→async def toggle_bookmark(\n  1385→    post_id: UUID,\n  1386→    current_user: User = Depends(get_current_user),\n  1387→    db: AsyncSession = Depends(get_db),\n  1388→):\n  1389→    \"\"\"Toggle bookmark status for a post.\n  1390→\n  1391→    If the post is not bookmarked, it will be bookmarked.\n  1392→    If the post is already bookmarked, the bookmark will be removed.\n  1393→    \"\"\"\n  1394→    # Verify post exists\n  1395→    post_result = await db.execute(\n  1396→        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n  1397→    )\n  1398→    post = post_result.scalar_one_or_none()\n  1399→    if not post:\n  1400→        raise HTTPException(status_code=404, detail=\"Post not found\")\n  1401→\n  1402→    # Check if already bookmarked\n  1403→    existing = await db.execute(\n  1404→        select(ForumBookmark).where(\n  1405→            ForumBookmark.user_id == current_user.id,\n  1406→            ForumBookmark.post_id == post_id\n  1407→        )\n  1408→    )\n  1409→    existing_bookmark = existing.scalar_one_or_none()\n  1410→\n  1411→    if existing_bookmark:\n  1412→        # Remove bookmark\n  1413→        await db.delete(existing_bookmark)\n  1414→        await db.commit()\n  1415→        return BookmarkToggleResponse(\n  1416→            is_bookmarked=False,\n  1417→            message=\"Bookmark removed\"\n  1418→        )\n  1419→    else:\n  1420→        # Add bookmark\n  1421→        bookmark = ForumBookmark(\n  1422→            user_id=current_user.id,\n  1423→            post_id=post_id\n  1424→        )\n  1425→        db.add(bookmark)\n  1426→        await db.commit()\n  1427→        return BookmarkToggleResponse(\n  1428→            is_bookmarked=True,\n  1429→            message=\"Post bookmarked\"\n  1430→        )\n  1431→\n  1432→\n  1433→@router.delete(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\n  1434→async def remove_bookmark(\n  1435→    post_id: UUID,\n  1436→    current_user: User = Depends(get_current_user),\n  1437→    db: AsyncSession = Depends(get_db),\n  1438→):\n  1439→    \"\"\"Remove a bookmark from a post.\"\"\"\n  1440→    # Check if bookmark exists\n  1441→    existing = await db.execute(\n  1442→        select(ForumBookmark).where(\n  1443→            ForumBookmark.user_id == current_user.id,\n  1444→            ForumBookmark.post_id == post_id\n  1445→        )\n  1446→    )\n  1447→    existing_bookmark = existing.scalar_one_or_none()\n  1448→\n  1449→    if not existing_bookmark:\n  1450→        raise HTTPException(status_code=404, detail=\"Bookmark not found\")\n  1451→\n  1452→    await db.delete(existing_bookmark)\n  1453→    await db.commit()\n  1454→\n  1455→    return BookmarkToggleResponse(\n  1456→        is_bookmarked=False,\n  1457→        message=\"Bookmark removed\"\n  1458→    )\n  1459→\n  1460→\n  1461→@router.get(\"/bookmarks\", response_model=BookmarkedPostsResponse)\n  1462→async def get_bookmarked_posts(\n  1463→    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n  1464→    offset: int = Query(0, ge=0),\n  1465→    current_user: User = Depends(get_current_user),\n  1466→    db: AsyncSession = Depends(get_db),\n  1467→):\n  1468→    \"\"\"Get all bookmarked posts for the current user, sorted by bookmark date (newest first).\"\"\"\n  1469→    # Get total count\n  1470→    count_query = (\n  1471→        select(func.count(ForumBookmark.id))\n  1472→        .where(ForumBookmark.user_id == current_user.id)\n  1473→    )\n  1474→    total_result = await db.execute(count_query)\n  1475→    total_count = total_result.scalar() or 0\n  1476→\n  1477→    # Get bookmarked posts with pagination\n  1478→    query = (\n  1479→        select(ForumBookmark)\n  1480→        .options(\n  1481→            selectinload(ForumBookmark.post).selectinload(ForumPost.author),\n  1482→            selectinload(ForumBookmark.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n  1483→        )\n  1484→        .where(ForumBookmark.user_id == current_user.id)\n  1485→        .order_by(ForumBookmark.created_at.desc())\n  1486→        .offset(offset)\n  1487→        .limit(limit)\n  1488→    )\n  1489→    result = await db.execute(query)\n  1490→    bookmarks = result.scalars().all()\n  1491→\n  1492→    # Filter out any bookmarks for deleted posts\n  1493→    valid_bookmarks = [b for b in bookmarks if b.post and not b.post.is_deleted]\n  1494→\n  1495→    # Get user votes for these posts\n  1496→    post_ids = [b.post.id for b in valid_bookmarks]\n  1497→    user_votes = {}\n  1498→    if post_ids:\n  1499→        votes_query = select(ForumVote).where(\n  1500→            ForumVote.user_id == current_user.id,\n  1501→            ForumVote.target_type == TargetType.POST,\n  1502→            ForumVote.target_id.in_(post_ids)\n  1503→        )\n  1504→        votes_result = await db.execute(votes_query)\n  1505→        user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n  1506→\n  1507→    # Build response\n  1508→    posts = []\n  1509→    for bookmark in valid_bookmarks:\n  1510→        post = bookmark.post\n  1511→        category_slug = post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\"\n  1512→        posts.append(_post_to_list_item(post, category_slug, user_votes.get(post.id)))\n  1513→\n  1514→    return BookmarkedPostsResponse(\n  1515→        posts=posts,\n  1516→        total_count=total_count,\n  1517→        has_more=offset + limit < total_count\n  1518→    )\n  1519→\n  1520→\n  1521→@router.get(\"/posts/{post_id}/bookmark-status\")\n  1522→async def get_bookmark_status(\n  1523→    post_id: UUID,\n  1524→    current_user: User = Depends(get_current_user),\n  1525→    db: AsyncSession = Depends(get_db),\n  1526→):\n  1527→    \"\"\"Check if a post is bookmarked by the current user.\"\"\"\n  1528→    existing = await db.execute(\n  1529→        select(ForumBookmark).where(\n  1530→            ForumBookmark.user_id == current_user.id,\n  1531→            ForumBookmark.post_id == post_id\n  1532→        )\n  1533→    )\n  1534→    bookmark = existing.scalar_one_or_none()\n  1535→\n  1536→    return {\n  1537→        \"post_id\": str(post_id),\n  1538→        \"is_bookmarked\": bookmark is not None,\n  1539→        \"bookmarked_at\": bookmark.created_at.isoformat() if bookmark else None\n  1540→    }\n  1541→\n  1542→\n  1543→@router.get(\"/bookmarks/ids\")\n  1544→async def get_bookmarked_post_ids(\n  1545→    current_user: User = Depends(get_current_user),\n  1546→    db: AsyncSession = Depends(get_db),\n  1547→):\n  1548→    \"\"\"Get all bookmarked post IDs for the current user.\n  1549→\n  1550→    Useful for efficiently checking bookmark status on post lists.\n  1551→    \"\"\"\n  1552→    query = (\n  1553→        select(ForumBookmark.post_id)\n  1554→        .where(ForumBookmark.user_id == current_user.id)\n  1555→    )\n  1556→    result = await db.execute(query)\n  1557→    post_ids = [str(row[0]) for row in result.all()]\n  1558→\n  1559→    return {\"bookmarked_post_ids\": post_ids}\n  1560→\n  1561→\n  1562→# === HELPER FUNCTIONS ===\n  1563→\n  1564→def _post_to_list_item(post: ForumPost, category_slug: str, user_vote: Optional[VoteType]) -> PostListItem:\n  1565→    sub_forum_slug = post.sub_forum.slug if post.sub_forum else \"\"\n  1566→    return PostListItem(\n  1567→        id=post.id,\n  1568→        title=post.title,\n  1569→        content_preview=post.content[:200] + \"...\" if len(post.content) > 200 else post.content,\n  1570→        sub_forum_slug=sub_forum_slug,\n  1571→        category_slug=category_slug,\n  1572→        author=PostAuthor(id=post.author.id, username=post.author.username),\n  1573→        is_pinned=post.is_pinned,\n  1574→        is_guide=post.is_guide,\n  1575→        vote_count=post.vote_count,\n  1576→        comment_count=post.comment_count,\n  1577→        user_vote=user_vote,\n  1578→        created_at=post.created_at,\n  1579→    )\n  1580→\n  1581→\n  1582→def _post_to_response(\n  1583→    post: ForumPost,\n  1584→    sub_forum_slug: str,\n  1585→    category_slug: str,\n  1586→    user_vote: Optional[VoteType]\n  1587→) -> PostResponse:\n  1588→    return PostResponse(\n  1589→        id=post.id,\n  1590→        title=post.title,\n  1591→        content=post.content,\n  1592→        sub_forum_id=post.sub_forum_id,\n  1593→        sub_forum_slug=sub_forum_slug,\n  1594→        category_slug=category_slug,\n  1595→        author=PostAuthor(id=post.author.id, username=post.author.username),\n  1596→        is_pinned=post.is_pinned,\n  1597→        is_guide=post.is_guide,\n  1598→        vote_count=post.vote_count,\n  1599→        comment_count=post.comment_count,\n  1600→        user_vote=user_vote,\n  1601→        created_at=post.created_at,\n  1602→        updated_at=post.updated_at,\n  1603→    )\n  1604→\n  1605→\n  1606→def _comment_to_response(comment: ForumComment, user_vote: Optional[VoteType]) -> CommentResponse:\n  1607→    return CommentResponse(\n  1608→        id=comment.id,\n  1609→        content=comment.content,\n  1610→        post_id=comment.post_id,\n  1611→        author=PostAuthor(id=comment.author.id, username=comment.author.username),\n  1612→        parent_id=comment.parent_id,\n  1613→        vote_count=comment.vote_count,\n  1614→        user_vote=user_vote,\n  1615→        depth=comment.depth,\n  1616→        replies=[],\n  1617→        created_at=comment.created_at,\n  1618→        updated_at=comment.updated_at,\n  1619→    )\n  1620→\n  1621→\n  1622→def _build_comment_tree(comments: List[ForumComment], user_votes: dict) -> List[CommentResponse]:\n  1623→    \"\"\"Build a tree structure from flat comment list.\"\"\"\n  1624→    comment_map = {}\n  1625→    roots = []\n  1626→\n  1627→    # First pass: create all response objects\n  1628→    for c in comments:\n  1629→        comment_map[c.id] = _comment_to_response(c, user_votes.get(c.id))\n  1630→\n  1631→    # Second pass: build tree\n  1632→    for c in comments:\n  1633→        response = comment_map[c.id]\n  1634→        if c.parent_id and c.parent_id in comment_map:\n  1635→            comment_map[c.parent_id].replies.append(response)\n  1636→        else:\n  1637→            roots.append(response)\n  1638→\n  1639→    return roots\n  1640→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"bb3013eb-0d75-48e6-a851-a7fa56798237","timestamp":"2025-12-27T16:53:47.469Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","content":"\"\"\"\nForum router - Categories, Sub-Forums, Posts, Comments, Votes, Reports\n\nRate Limits:\n- Posts: 5 per minute per user\n- Comments: 20 per minute per user\n- Votes: 30 per minute per user\n- Reports: 10 per hour per user\n\"\"\"\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query, Request, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func, and_, or_, desc\nfrom sqlalchemy.orm import selectinload\nfrom uuid import UUID\nfrom typing import Optional, List\nfrom datetime import datetime, timezone\n\nfrom app.database import get_db\nfrom app.core.rate_limit import limiter, ForumRateLimits\nfrom app.models.user import User, UserRole\nfrom app.models.forum import (\n    ForumIssueCategory, ForumSubForum, ForumPost, ForumComment,\n    ForumVote, ForumReport, FlawToForumMapping, ArchetypeForumMapping,\n    ForumBookmark, VoteType, TargetType, ReportStatus, ReportReason\n)\nfrom app.services.auth import get_current_user, get_current_user_optional\nfrom app.schemas.forum import (\n    CategoryResponse, CategoryListResponse, SubForumResponse,\n    PostCreate, PostUpdate, PostResponse, PostListItem,\n    PostListResponse, CommentCreate, CommentUpdate, CommentResponse,\n    VoteRequest, VoteResponse, ReportCreate, ReportResponse,\n    GuideSectionResponse, SortOrder, PostAuthor, RecommendedForumResponse,\n    ArchetypeForumRecommendation, ForumSearchResult, ForumSearchResponse,\n    SearchResultType, BookmarkToggleResponse, BookmarkedPostsResponse\n)\n\nrouter = APIRouter(prefix=\"/forum\", tags=[\"forum\"])\n\nPAGE_SIZE = 20\nMAX_COMMENT_DEPTH = 5\n\n\n# === CATEGORIES ===\n\n@router.get(\"/categories\", response_model=List[CategoryResponse])\nasync def list_categories(db: AsyncSession = Depends(get_db)):\n    \"\"\"List all active forum categories with sub-forums and post counts.\n\n    Optimized to use only 2 queries instead of N+1 pattern.\n    \"\"\"\n    # Query 1: Get all categories with sub-forums\n    query = (\n        select(ForumIssueCategory)\n        .options(selectinload(ForumIssueCategory.sub_forums))\n        .where(ForumIssueCategory.is_active == True)\n        .order_by(ForumIssueCategory.display_order)\n    )\n    result = await db.execute(query)\n    categories = result.scalars().all()\n\n    # Query 2: Get ALL sub-forum post counts in ONE query (batched)\n    sf_counts_query = (\n        select(\n            ForumPost.sub_forum_id,\n            func.count(ForumPost.id).label('post_count')\n        )\n        .where(\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n        .group_by(ForumPost.sub_forum_id)\n    )\n    sf_counts_result = await db.execute(sf_counts_query)\n    sf_counts = {row[0]: row[1] for row in sf_counts_result}\n\n    # Build response using pre-fetched counts (no additional queries)\n    response = []\n    for cat in categories:\n        cat_post_count = 0\n        sub_forums = []\n\n        for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n            if sf.is_active:\n                sf_post_count = sf_counts.get(sf.id, 0)\n                cat_post_count += sf_post_count\n\n                sub_forums.append(SubForumResponse(\n                    id=sf.id,\n                    name=sf.name,\n                    slug=sf.slug,\n                    description=sf.description,\n                    icon=sf.icon,\n                    display_order=sf.display_order,\n                    post_count=sf_post_count\n                ))\n\n        response.append(CategoryResponse(\n            id=cat.id,\n            name=cat.name,\n            slug=cat.slug,\n            description=cat.description,\n            icon=cat.icon,\n            display_order=cat.display_order,\n            post_count=cat_post_count,\n            sub_forums=sub_forums\n        ))\n\n    return response\n\n\n@router.get(\"/categories/{slug}\", response_model=CategoryResponse)\nasync def get_category(\n    slug: str,\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get a single category by slug with its sub-forums.\n\n    Optimized to use only 2 queries instead of N+1 pattern.\n    \"\"\"\n    # Query 1: Get category with sub-forums\n    query = (\n        select(ForumIssueCategory)\n        .options(selectinload(ForumIssueCategory.sub_forums))\n        .where(ForumIssueCategory.slug == slug, ForumIssueCategory.is_active == True)\n    )\n    result = await db.execute(query)\n    cat = result.scalar_one_or_none()\n\n    if not cat:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    # Get sub-forum IDs for this category\n    sf_ids = [sf.id for sf in cat.sub_forums if sf.is_active]\n\n    # Query 2: Get post counts for all sub-forums in this category (batched)\n    sf_counts = {}\n    if sf_ids:\n        sf_counts_query = (\n            select(\n                ForumPost.sub_forum_id,\n                func.count(ForumPost.id).label('post_count')\n            )\n            .where(\n                ForumPost.sub_forum_id.in_(sf_ids),\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True\n            )\n            .group_by(ForumPost.sub_forum_id)\n        )\n        sf_counts_result = await db.execute(sf_counts_query)\n        sf_counts = {row[0]: row[1] for row in sf_counts_result}\n\n    # Build sub-forums list using pre-fetched counts\n    cat_post_count = 0\n    sub_forums = []\n    for sf in sorted(cat.sub_forums, key=lambda x: x.display_order):\n        if sf.is_active:\n            sf_post_count = sf_counts.get(sf.id, 0)\n            cat_post_count += sf_post_count\n\n            sub_forums.append(SubForumResponse(\n                id=sf.id,\n                name=sf.name,\n                slug=sf.slug,\n                description=sf.description,\n                icon=sf.icon,\n                display_order=sf.display_order,\n                post_count=sf_post_count\n            ))\n\n    return CategoryResponse(\n        id=cat.id,\n        name=cat.name,\n        slug=cat.slug,\n        description=cat.description,\n        icon=cat.icon,\n        display_order=cat.display_order,\n        post_count=cat_post_count,\n        sub_forums=sub_forums\n    )\n\n\n# === SEARCH ===\n\n@router.get(\"/search\", response_model=ForumSearchResponse)\nasync def search_forum(\n    q: str = Query(..., min_length=2, max_length=100, description=\"Search query\"),\n    type: str = Query(\"all\", description=\"Search type: posts, comments, or all\"),\n    limit: int = Query(20, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Search forum posts and comments using ILIKE pattern matching.\n\n    - Search by title, content for posts\n    - Search by content for comments\n    - Results sorted by vote_count DESC, created_at DESC\n    \"\"\"\n    search_pattern = f\"%{q}%\"\n    results = []\n    total_count = 0\n\n    if type in (\"posts\", \"all\"):\n        # Search posts by title and content\n        post_query = (\n            select(ForumPost)\n            .options(\n                selectinload(ForumPost.author),\n                selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n            )\n            .where(\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(\n                    ForumPost.title.ilike(search_pattern),\n                    ForumPost.content.ilike(search_pattern)\n                )\n            )\n            .order_by(ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n        )\n\n        # Count posts\n        post_count_query = (\n            select(func.count(ForumPost.id))\n            .where(\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(\n                    ForumPost.title.ilike(search_pattern),\n                    ForumPost.content.ilike(search_pattern)\n                )\n            )\n        )\n        post_count_result = await db.execute(post_count_query)\n        post_count = post_count_result.scalar() or 0\n\n        if type == \"posts\":\n            total_count = post_count\n            post_query = post_query.offset(offset).limit(limit)\n        else:\n            total_count += post_count\n            # For \"all\", we get all posts first then merge with comments\n            post_query = post_query.limit(limit * 2)  # Get more to merge\n\n        post_result = await db.execute(post_query)\n        posts = post_result.scalars().all()\n\n        for post in posts:\n            content_preview = post.content[:200] + \"...\" if len(post.content) > 200 else post.content\n            results.append(ForumSearchResult(\n                id=post.id,\n                type=SearchResultType.POST,\n                title=post.title,\n                content_preview=content_preview,\n                post_id=None,\n                post_title=None,\n                author=PostAuthor(id=post.author.id, username=post.author.username),\n                vote_count=post.vote_count,\n                category_slug=post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\",\n                sub_forum_slug=post.sub_forum.slug if post.sub_forum else \"\",\n                created_at=post.created_at\n            ))\n\n    if type in (\"comments\", \"all\"):\n        # Search comments by content\n        comment_query = (\n            select(ForumComment)\n            .options(\n                selectinload(ForumComment.author),\n                selectinload(ForumComment.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n            )\n            .where(\n                ForumComment.is_deleted == False,\n                ForumComment.content.ilike(search_pattern)\n            )\n            .order_by(ForumComment.vote_count.desc(), ForumComment.created_at.desc())\n        )\n\n        # Count comments\n        comment_count_query = (\n            select(func.count(ForumComment.id))\n            .where(\n                ForumComment.is_deleted == False,\n                ForumComment.content.ilike(search_pattern)\n            )\n        )\n        comment_count_result = await db.execute(comment_count_query)\n        comment_count = comment_count_result.scalar() or 0\n\n        if type == \"comments\":\n            total_count = comment_count\n            comment_query = comment_query.offset(offset).limit(limit)\n        else:\n            total_count += comment_count\n            comment_query = comment_query.limit(limit * 2)\n\n        comment_result = await db.execute(comment_query)\n        comments = comment_result.scalars().all()\n\n        for comment in comments:\n            content_preview = comment.content[:200] + \"...\" if len(comment.content) > 200 else comment.content\n            post = comment.post\n            if post and post.sub_forum:\n                category_slug = post.sub_forum.issue_category.slug if post.sub_forum.issue_category else \"\"\n                sub_forum_slug = post.sub_forum.slug\n            else:\n                category_slug = \"\"\n                sub_forum_slug = \"\"\n\n            results.append(ForumSearchResult(\n                id=comment.id,\n                type=SearchResultType.COMMENT,\n                title=None,\n                content_preview=content_preview,\n                post_id=comment.post_id,\n                post_title=post.title if post else None,\n                author=PostAuthor(id=comment.author.id, username=comment.author.username),\n                vote_count=comment.vote_count,\n                category_slug=category_slug,\n                sub_forum_slug=sub_forum_slug,\n                created_at=comment.created_at\n            ))\n\n    # For \"all\" type, sort merged results by vote_count and created_at, then paginate\n    if type == \"all\":\n        results.sort(key=lambda x: (-x.vote_count, x.created_at), reverse=False)\n        results.sort(key=lambda x: x.vote_count, reverse=True)\n        results = results[offset:offset + limit]\n\n    return ForumSearchResponse(\n        results=results,\n        total_count=total_count,\n        query=q,\n        search_type=type,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/recommended\", response_model=List[RecommendedForumResponse])\nasync def get_recommended_forums(\n    flaws: str = Query(..., description=\"Comma-separated list of flaw IDs\"),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get recommended forums based on detected flaws.\"\"\"\n    flaw_list = [f.strip() for f in flaws.split(\",\") if f.strip()]\n\n    if not flaw_list:\n        return []\n\n    # Find mappings for these flaws\n    query = (\n        select(FlawToForumMapping)\n        .options(selectinload(FlawToForumMapping.issue_category))\n        .where(FlawToForumMapping.flaw_id.in_(flaw_list))\n        .order_by(FlawToForumMapping.priority)\n    )\n\n    result = await db.execute(query)\n    mappings = result.scalars().all()\n\n    # Group by category\n    category_flaws = {}\n    for mapping in mappings:\n        cat_id = mapping.issue_category_id\n        if cat_id not in category_flaws:\n            category_flaws[cat_id] = {\n                \"category\": mapping.issue_category,\n                \"flaws\": [],\n                \"priority\": mapping.priority\n            }\n        category_flaws[cat_id][\"flaws\"].append(mapping.flaw_id)\n        # Use lowest priority (1 = primary)\n        if mapping.priority < category_flaws[cat_id][\"priority\"]:\n            category_flaws[cat_id][\"priority\"] = mapping.priority\n\n    # Build response sorted by priority\n    response = []\n    for cat_data in sorted(category_flaws.values(), key=lambda x: x[\"priority\"]):\n        cat = cat_data[\"category\"]\n        response.append(RecommendedForumResponse(\n            category=CategoryListResponse(\n                id=cat.id,\n                name=cat.name,\n                slug=cat.slug,\n                description=cat.description,\n                icon=cat.icon,\n                display_order=cat.display_order,\n                post_count=0\n            ),\n            matched_flaws=cat_data[\"flaws\"],\n            priority=cat_data[\"priority\"]\n        ))\n\n    return response\n\n\n@router.get(\"/archetype-recommendations\", response_model=List[ArchetypeForumRecommendation])\nasync def get_archetype_forum_recommendations(\n    archetype: str = Query(..., description=\"Archetype category (Softboy, Prettyboy, RobustPrettyboy, Chad, Hypermasculine, Exotic)\"),\n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Get recommended forums based on user's archetype classification.\"\"\"\n    # Normalize archetype name (handle case variations)\n    archetype = archetype.strip()\n\n    # Valid archetypes\n    valid_archetypes = [\"Softboy\", \"Prettyboy\", \"RobustPrettyboy\", \"Chad\", \"Hypermasculine\", \"Exotic\"]\n\n    # Case-insensitive match\n    matched_archetype = None\n    for valid in valid_archetypes:\n        if archetype.lower() == valid.lower():\n            matched_archetype = valid\n            break\n\n    if not matched_archetype:\n        # Return empty list for invalid archetype (not an error)\n        return []\n\n    # Find mappings for this archetype, ordered by priority (highest first)\n    query = (\n        select(ArchetypeForumMapping)\n        .options(selectinload(ArchetypeForumMapping.issue_category))\n        .where(ArchetypeForumMapping.archetype_category == matched_archetype)\n        .order_by(ArchetypeForumMapping.priority.desc())\n    )\n\n    result = await db.execute(query)\n    mappings = result.scalars().all()\n\n    # Build response\n    response = []\n    for mapping in mappings:\n        cat = mapping.issue_category\n        if cat and cat.is_active:\n            response.append(ArchetypeForumRecommendation(\n                category=CategoryListResponse(\n                    id=cat.id,\n                    name=cat.name,\n                    slug=cat.slug,\n                    description=cat.description,\n                    icon=cat.icon,\n                    display_order=cat.display_order,\n                    post_count=0  # Could be optimized with a count query if needed\n                ),\n                archetype=matched_archetype,\n                reason=mapping.reason,\n                priority=mapping.priority\n            ))\n\n    return response\n\n\n@router.get(\"/guides\", response_model=List[GuideSectionResponse])\nasync def get_guides_section(db: AsyncSession = Depends(get_db)):\n    \"\"\"Get pinned guides grouped by category for the top section.\"\"\"\n    # Get categories\n    cat_query = (\n        select(ForumIssueCategory)\n        .where(ForumIssueCategory.is_active == True)\n        .order_by(ForumIssueCategory.display_order)\n    )\n    cat_result = await db.execute(cat_query)\n    categories = cat_result.scalars().all()\n\n    response = []\n    for cat in categories:\n        # Get top 5 guides (pinned or marked as guide) per category\n        guide_query = (\n            select(ForumPost)\n            .options(\n                selectinload(ForumPost.author),\n                selectinload(ForumPost.sub_forum)\n            )\n            .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n            .where(\n                ForumSubForum.issue_category_id == cat.id,\n                ForumPost.is_deleted == False,\n                ForumPost.is_approved == True,\n                or_(ForumPost.is_pinned == True, ForumPost.is_guide == True)\n            )\n            .order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n            .limit(5)\n        )\n        guide_result = await db.execute(guide_query)\n        guides = guide_result.scalars().all()\n\n        if guides:  # Only include categories that have guides\n            response.append(GuideSectionResponse(\n                category=CategoryListResponse(\n                    id=cat.id,\n                    name=cat.name,\n                    slug=cat.slug,\n                    description=cat.description,\n                    icon=cat.icon,\n                    display_order=cat.display_order,\n                    post_count=0\n                ),\n                guides=[_post_to_list_item(g, cat.slug, None) for g in guides]\n            ))\n\n    return response\n\n\n# === POSTS ===\n\n@router.get(\"/sub-forums/{sub_forum_id}/posts\", response_model=PostListResponse)\nasync def list_sub_forum_posts(\n    sub_forum_id: UUID,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List posts in a sub-forum with sorting and pagination.\"\"\"\n    # Verify sub-forum exists and get category\n    sf_result = await db.execute(\n        select(ForumSubForum)\n        .options(selectinload(ForumSubForum.issue_category))\n        .where(ForumSubForum.id == sub_forum_id)\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    category_slug = sub_forum.issue_category.slug\n\n    # Base query\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author))\n        .where(\n            ForumPost.sub_forum_id == sub_forum_id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting - pinned always first\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:  # HOT - combination of votes and recency\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .where(\n            ForumPost.sub_forum_id == sub_forum_id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes if authenticated\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, category_slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/categories/{slug}/posts\", response_model=PostListResponse)\nasync def list_category_posts(\n    slug: str,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List all posts in a category (across all sub-forums) with sorting and pagination.\"\"\"\n    # Verify category exists\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n    )\n    category = cat_result.scalar_one_or_none()\n    if not category:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    # Base query - join with sub-forums to filter by category\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n        .where(\n            ForumSubForum.issue_category_id == category.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .join(ForumSubForum, ForumPost.sub_forum_id == ForumSubForum.id)\n        .where(\n            ForumSubForum.issue_category_id == category.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/categories/{slug}/{sub_forum_slug}/posts\", response_model=PostListResponse)\nasync def list_sub_forum_posts(\n    slug: str,\n    sub_forum_slug: str,\n    sort: SortOrder = Query(SortOrder.HOT),\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List all posts in a specific sub-forum with sorting and pagination.\"\"\"\n    # Verify category and sub-forum exist\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.slug == slug)\n    )\n    category = cat_result.scalar_one_or_none()\n    if not category:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n\n    sf_result = await db.execute(\n        select(ForumSubForum).where(\n            ForumSubForum.slug == sub_forum_slug,\n            ForumSubForum.issue_category_id == category.id\n        )\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    # Base query\n    query = (\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .where(\n            ForumPost.sub_forum_id == sub_forum.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n\n    # Sorting\n    if sort == SortOrder.NEW:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.created_at.desc())\n    elif sort == SortOrder.TOP:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc())\n    else:\n        query = query.order_by(ForumPost.is_pinned.desc(), ForumPost.vote_count.desc(), ForumPost.created_at.desc())\n\n    # Get total count\n    count_query = (\n        select(func.count(ForumPost.id))\n        .where(\n            ForumPost.sub_forum_id == sub_forum.id,\n            ForumPost.is_deleted == False,\n            ForumPost.is_approved == True\n        )\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Paginate\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    posts = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        post_ids = [p.id for p in posts]\n        if post_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id.in_(post_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    return PostListResponse(\n        posts=[_post_to_list_item(p, slug, user_votes.get(p.id)) for p in posts],\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.post(\"/posts\", response_model=PostResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.POSTS)\nasync def create_post(\n    request: Request,\n    data: PostCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a new post.\n\n    Rate limit: 5 posts per minute per user.\n    \"\"\"\n    # Verify sub-forum exists\n    sf_result = await db.execute(\n        select(ForumSubForum)\n        .options(selectinload(ForumSubForum.issue_category))\n        .where(ForumSubForum.id == data.sub_forum_id)\n    )\n    sub_forum = sf_result.scalar_one_or_none()\n    if not sub_forum:\n        raise HTTPException(status_code=404, detail=\"Sub-forum not found\")\n\n    post = ForumPost(\n        title=data.title,\n        content=data.content,\n        sub_forum_id=data.sub_forum_id,\n        author_id=current_user.id,\n    )\n\n    db.add(post)\n    await db.commit()\n    await db.refresh(post)\n\n    return _post_to_response(post, sub_forum.slug, sub_forum.issue_category.slug, None)\n\n\n@router.get(\"/posts/{post_id}\", response_model=PostResponse)\nasync def get_post(\n    post_id: UUID,\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get a single post with full details.\"\"\"\n    query = (\n        select(ForumPost)\n        .options(\n            selectinload(ForumPost.author),\n            selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n        )\n        .where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    result = await db.execute(query)\n    post = result.scalar_one_or_none()\n\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Get user's vote\n    user_vote = None\n    if current_user:\n        vote_result = await db.execute(\n            select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.POST,\n                ForumVote.target_id == post_id\n            )\n        )\n        vote = vote_result.scalar_one_or_none()\n        user_vote = vote.vote_type if vote else None\n\n    return _post_to_response(\n        post,\n        post.sub_forum.slug,\n        post.sub_forum.issue_category.slug,\n        user_vote\n    )\n\n\n@router.post(\"/posts/{post_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_post(\n    request: Request,\n    post_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a post (upvote/downvote). Voting again removes vote, changing vote type switches it.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Prevent self-voting\n    if post.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own post\")\n\n    # Check existing vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id == post_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        # Robustly get value (handle if DB returns string or Enum)\n        current_val = existing_vote.vote_type.value if hasattr(existing_vote.vote_type, 'value') else existing_vote.vote_type\n        # Request is from Pydantic Schema Enum\n        request_val = data.vote_type.value\n\n        if current_val == request_val:\n            # Same vote - remove it\n            await db.delete(existing_vote)\n            post.vote_count += -1 if request_val == \"up\" else 1\n        else:\n            # Different vote - switch it\n            # Ensure we assign the Model Enum (or string if that's what it wants, but Model Enum is safer if Typed)\n            existing_vote.vote_type = VoteType(request_val)\n            # Swing by 2 (remove old, add new)\n            post.vote_count += 2 if request_val == \"up\" else -2\n            new_user_vote = data.vote_type\n    else:\n        # New vote\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.POST,\n            target_id=post_id,\n            # Explicitly cast to Model Enum\n            vote_type=VoteType(data.vote_type.value)\n        )\n        db.add(vote)\n        post.vote_count += 1 if data.vote_type.value == \"up\" else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=post.vote_count, user_vote=new_user_vote)\n\n\n@router.delete(\"/posts/{post_id}\")\nasync def delete_post(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Delete a post (author or moderator).\"\"\"\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    is_author = post.author_id == current_user.id\n    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n\n    if not is_author and not is_mod:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    post.is_deleted = True\n    post.deleted_at = datetime.now(timezone.utc)\n    post.deleted_by = current_user.id\n    await db.commit()\n\n    return {\"success\": True}\n\n\n@router.put(\"/posts/{post_id}\", response_model=PostResponse)\nasync def update_post(\n    post_id: UUID,\n    data: PostUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update a post (author only).\"\"\"\n    post_result = await db.execute(\n        select(ForumPost)\n        .options(selectinload(ForumPost.author), selectinload(ForumPost.sub_forum))\n        .where(ForumPost.id == post_id)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    if post.author_id != current_user.id:\n        raise HTTPException(status_code=403, detail=\"Not authorized to edit this post\")\n\n    if data.title is not None:\n        post.title = data.title\n    if data.content is not None:\n        post.content = data.content\n    post.updated_at = datetime.utcnow()\n\n    await db.commit()\n    await db.refresh(post)\n\n    # Get user vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id == post_id\n        )\n    )\n    user_vote = vote_result.scalar_one_or_none()\n\n    # Get category slug\n    sf = post.sub_forum\n    cat_result = await db.execute(\n        select(ForumIssueCategory).where(ForumIssueCategory.id == sf.issue_category_id)\n    )\n    cat = cat_result.scalar_one()\n\n    return PostResponse(\n        id=post.id,\n        title=post.title,\n        content=post.content,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        created_at=post.created_at,\n        updated_at=post.updated_at,\n        author=PostAuthor(\n            id=post.author.id,\n            username=post.author.username,\n            avatar_url=None\n        ),\n        sub_forum=SubForumResponse(\n            id=sf.id,\n            name=sf.name,\n            slug=sf.slug,\n            description=sf.description,\n            icon=sf.icon,\n            display_order=sf.display_order,\n            post_count=0\n        ),\n        category_slug=cat.slug,\n        user_vote=user_vote.vote_type if user_vote else None\n    )\n\n\n# === COMMENTS ===\n\n@router.get(\"/posts/{post_id}/comments\", response_model=List[CommentResponse])\nasync def get_post_comments(\n    post_id: UUID,\n    current_user: Optional[User] = Depends(get_current_user_optional),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all comments for a post in a threaded structure.\"\"\"\n    # Verify post exists\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    if not post_result.scalar_one_or_none():\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Get all comments for post\n    query = (\n        select(ForumComment)\n        .options(selectinload(ForumComment.author))\n        .where(ForumComment.post_id == post_id, ForumComment.is_deleted == False)\n        .order_by(ForumComment.created_at)\n    )\n    result = await db.execute(query)\n    comments = result.scalars().all()\n\n    # Get user votes\n    user_votes = {}\n    if current_user:\n        comment_ids = [c.id for c in comments]\n        if comment_ids:\n            votes_query = select(ForumVote).where(\n                ForumVote.user_id == current_user.id,\n                ForumVote.target_type == TargetType.COMMENT,\n                ForumVote.target_id.in_(comment_ids)\n            )\n            votes_result = await db.execute(votes_query)\n            user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    # Build tree structure\n    return _build_comment_tree(comments, user_votes)\n\n\n@router.post(\"/posts/{post_id}/comments\", response_model=CommentResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.COMMENTS)\nasync def create_comment(\n    request: Request,\n    post_id: UUID,\n    data: CommentCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a comment on a post.\n\n    Rate limit: 20 comments per minute per user.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    depth = 0\n    if data.parent_id:\n        # Verify parent comment exists\n        parent_result = await db.execute(\n            select(ForumComment).where(\n                ForumComment.id == data.parent_id,\n                ForumComment.post_id == post_id\n            )\n        )\n        parent = parent_result.scalar_one_or_none()\n        if not parent:\n            raise HTTPException(status_code=404, detail=\"Parent comment not found\")\n        depth = min(parent.depth + 1, MAX_COMMENT_DEPTH)\n\n    comment = ForumComment(\n        content=data.content,\n        post_id=post_id,\n        author_id=current_user.id,\n        parent_id=data.parent_id,\n        depth=depth,\n    )\n\n    db.add(comment)\n    await db.commit()\n    await db.refresh(comment)\n\n    # Load author relationship\n    await db.refresh(comment, [\"author\"])\n\n    return _comment_to_response(comment, None)\n\n\n@router.post(\"/comments/{comment_id}/vote\", response_model=VoteResponse)\n@limiter.limit(ForumRateLimits.VOTES)\nasync def vote_on_comment(\n    request: Request,\n    comment_id: UUID,\n    data: VoteRequest,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Vote on a comment.\n\n    Rate limit: 30 votes per minute per user.\n    \"\"\"\n    comment_result = await db.execute(\n        select(ForumComment).where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n    )\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    # Prevent self-voting\n    if comment.author_id == current_user.id:\n        raise HTTPException(status_code=400, detail=\"You cannot vote on your own comment\")\n\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.COMMENT,\n            ForumVote.target_id == comment_id\n        )\n    )\n    existing_vote = vote_result.scalar_one_or_none()\n\n    new_user_vote = None\n    if existing_vote:\n        if existing_vote.vote_type == data.vote_type:\n            await db.delete(existing_vote)\n            comment.vote_count += -1 if data.vote_type == VoteType.UP else 1\n        else:\n            existing_vote.vote_type = data.vote_type\n            comment.vote_count += 2 if data.vote_type == VoteType.UP else -2\n            new_user_vote = data.vote_type\n    else:\n        vote = ForumVote(\n            user_id=current_user.id,\n            target_type=TargetType.COMMENT,\n            target_id=comment_id,\n            vote_type=data.vote_type\n        )\n        db.add(vote)\n        comment.vote_count += 1 if data.vote_type == VoteType.UP else -1\n        new_user_vote = data.vote_type\n\n    await db.commit()\n\n    return VoteResponse(success=True, new_vote_count=comment.vote_count, user_vote=new_user_vote)\n\n\n@router.put(\"/comments/{comment_id}\", response_model=CommentResponse)\nasync def update_comment(\n    comment_id: UUID,\n    data: CommentUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update a comment (author only).\"\"\"\n    comment_result = await db.execute(\n        select(ForumComment)\n        .options(selectinload(ForumComment.author))\n        .where(ForumComment.id == comment_id, ForumComment.is_deleted == False)\n    )\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    if comment.author_id != current_user.id:\n        raise HTTPException(status_code=403, detail=\"Not authorized to edit this comment\")\n\n    comment.content = data.content\n    comment.updated_at = datetime.utcnow()\n\n    await db.commit()\n    await db.refresh(comment)\n\n    # Get user vote\n    vote_result = await db.execute(\n        select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.COMMENT,\n            ForumVote.target_id == comment_id\n        )\n    )\n    user_vote = vote_result.scalar_one_or_none()\n\n    return _comment_to_response(comment, user_vote.vote_type if user_vote else None)\n\n\n@router.delete(\"/comments/{comment_id}\")\nasync def delete_comment(\n    comment_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Delete a comment (author or moderator).\"\"\"\n    comment_result = await db.execute(select(ForumComment).where(ForumComment.id == comment_id))\n    comment = comment_result.scalar_one_or_none()\n    if not comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n\n    is_author = comment.author_id == current_user.id\n    is_mod = current_user.role in [UserRole.MODERATOR, UserRole.ADMIN]\n\n    if not is_author and not is_mod:\n        raise HTTPException(status_code=403, detail=\"Not authorized\")\n\n    comment.is_deleted = True\n    comment.deleted_at = datetime.now(timezone.utc)\n    comment.deleted_by = current_user.id\n\n    # Decrement comment count on the parent post\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == comment.post_id))\n    post = post_result.scalar_one_or_none()\n    if post and post.comment_count > 0:\n        post.comment_count -= 1\n\n    await db.commit()\n\n    return {\"success\": True}\n\n\n# === REPORTS ===\n\n@router.post(\"/reports\", response_model=ReportResponse, status_code=status.HTTP_201_CREATED)\n@limiter.limit(ForumRateLimits.REPORTS)\nasync def create_report(\n    request: Request,\n    data: ReportCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Report a post or comment.\n\n    Rate limit: 10 reports per hour per user.\n    \"\"\"\n    # Verify target exists\n    if data.target_type == TargetType.POST:\n        target_result = await db.execute(select(ForumPost).where(ForumPost.id == data.target_id))\n    else:\n        target_result = await db.execute(select(ForumComment).where(ForumComment.id == data.target_id))\n\n    if not target_result.scalar_one_or_none():\n        raise HTTPException(status_code=404, detail=\"Target not found\")\n\n    # Check for duplicate report\n    existing = await db.execute(\n        select(ForumReport).where(\n            ForumReport.reporter_id == current_user.id,\n            ForumReport.target_type == data.target_type,\n            ForumReport.target_id == data.target_id,\n            ForumReport.status == ReportStatus.PENDING\n        )\n    )\n    if existing.scalar_one_or_none():\n        raise HTTPException(status_code=400, detail=\"You have already reported this content\")\n\n    report = ForumReport(\n        reporter_id=current_user.id,\n        target_type=data.target_type,\n        target_id=data.target_id,\n        reason=data.reason,\n        details=data.details,\n    )\n\n    db.add(report)\n    await db.commit()\n    await db.refresh(report)\n\n    return ReportResponse(\n        id=report.id,\n        target_type=report.target_type,\n        target_id=report.target_id,\n        reason=report.reason,\n        status=report.status.value,\n        created_at=report.created_at\n    )\n\n\n# === MODERATION (Admin/Moderator only) ===\n\n@router.post(\"/posts/{post_id}/pin\")\nasync def pin_post(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Pin/unpin a post (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    post.is_pinned = not post.is_pinned\n    await db.commit()\n\n    return {\"success\": True, \"is_pinned\": post.is_pinned}\n\n\n@router.post(\"/posts/{post_id}/mark-guide\")\nasync def mark_as_guide(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Mark/unmark a post as a guide (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    post_result = await db.execute(select(ForumPost).where(ForumPost.id == post_id))\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    post.is_guide = not post.is_guide\n    await db.commit()\n\n    return {\"success\": True, \"is_guide\": post.is_guide}\n\n\n@router.get(\"/reports\", response_model=List[ReportResponse])\nasync def list_reports(\n    status_filter: Optional[ReportStatus] = Query(None, alias=\"status\"),\n    limit: int = Query(50, ge=1, le=100),\n    offset: int = Query(0, ge=0),\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List reports (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    query = select(ForumReport).order_by(ForumReport.created_at.desc())\n\n    if status_filter:\n        query = query.where(ForumReport.status == status_filter)\n\n    query = query.offset(offset).limit(limit)\n    result = await db.execute(query)\n    reports = result.scalars().all()\n\n    return [\n        ReportResponse(\n            id=r.id,\n            target_type=r.target_type,\n            target_id=r.target_id,\n            reason=r.reason,\n            status=r.status.value,\n            created_at=r.created_at\n        )\n        for r in reports\n    ]\n\n\n@router.patch(\"/reports/{report_id}\")\nasync def update_report_status(\n    report_id: UUID,\n    new_status: ReportStatus,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update report status (moderator only).\"\"\"\n    if current_user.role not in [UserRole.MODERATOR, UserRole.ADMIN]:\n        raise HTTPException(status_code=403, detail=\"Moderator access required\")\n\n    report_result = await db.execute(select(ForumReport).where(ForumReport.id == report_id))\n    report = report_result.scalar_one_or_none()\n    if not report:\n        raise HTTPException(status_code=404, detail=\"Report not found\")\n\n    report.status = new_status\n    report.reviewed_by = current_user.id\n    report.reviewed_at = datetime.utcnow()\n\n    await db.commit()\n\n    return {\"success\": True, \"status\": new_status.value}\n\n\n# === BOOKMARKS ===\n\n@router.post(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\nasync def toggle_bookmark(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Toggle bookmark status for a post.\n\n    If the post is not bookmarked, it will be bookmarked.\n    If the post is already bookmarked, the bookmark will be removed.\n    \"\"\"\n    # Verify post exists\n    post_result = await db.execute(\n        select(ForumPost).where(ForumPost.id == post_id, ForumPost.is_deleted == False)\n    )\n    post = post_result.scalar_one_or_none()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n\n    # Check if already bookmarked\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    existing_bookmark = existing.scalar_one_or_none()\n\n    if existing_bookmark:\n        # Remove bookmark\n        await db.delete(existing_bookmark)\n        await db.commit()\n        return BookmarkToggleResponse(\n            is_bookmarked=False,\n            message=\"Bookmark removed\"\n        )\n    else:\n        # Add bookmark\n        bookmark = ForumBookmark(\n            user_id=current_user.id,\n            post_id=post_id\n        )\n        db.add(bookmark)\n        await db.commit()\n        return BookmarkToggleResponse(\n            is_bookmarked=True,\n            message=\"Post bookmarked\"\n        )\n\n\n@router.delete(\"/posts/{post_id}/bookmark\", response_model=BookmarkToggleResponse)\nasync def remove_bookmark(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Remove a bookmark from a post.\"\"\"\n    # Check if bookmark exists\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    existing_bookmark = existing.scalar_one_or_none()\n\n    if not existing_bookmark:\n        raise HTTPException(status_code=404, detail=\"Bookmark not found\")\n\n    await db.delete(existing_bookmark)\n    await db.commit()\n\n    return BookmarkToggleResponse(\n        is_bookmarked=False,\n        message=\"Bookmark removed\"\n    )\n\n\n@router.get(\"/bookmarks\", response_model=BookmarkedPostsResponse)\nasync def get_bookmarked_posts(\n    limit: int = Query(PAGE_SIZE, ge=1, le=50),\n    offset: int = Query(0, ge=0),\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all bookmarked posts for the current user, sorted by bookmark date (newest first).\"\"\"\n    # Get total count\n    count_query = (\n        select(func.count(ForumBookmark.id))\n        .where(ForumBookmark.user_id == current_user.id)\n    )\n    total_result = await db.execute(count_query)\n    total_count = total_result.scalar() or 0\n\n    # Get bookmarked posts with pagination\n    query = (\n        select(ForumBookmark)\n        .options(\n            selectinload(ForumBookmark.post).selectinload(ForumPost.author),\n            selectinload(ForumBookmark.post).selectinload(ForumPost.sub_forum).selectinload(ForumSubForum.issue_category)\n        )\n        .where(ForumBookmark.user_id == current_user.id)\n        .order_by(ForumBookmark.created_at.desc())\n        .offset(offset)\n        .limit(limit)\n    )\n    result = await db.execute(query)\n    bookmarks = result.scalars().all()\n\n    # Filter out any bookmarks for deleted posts\n    valid_bookmarks = [b for b in bookmarks if b.post and not b.post.is_deleted]\n\n    # Get user votes for these posts\n    post_ids = [b.post.id for b in valid_bookmarks]\n    user_votes = {}\n    if post_ids:\n        votes_query = select(ForumVote).where(\n            ForumVote.user_id == current_user.id,\n            ForumVote.target_type == TargetType.POST,\n            ForumVote.target_id.in_(post_ids)\n        )\n        votes_result = await db.execute(votes_query)\n        user_votes = {v.target_id: v.vote_type for v in votes_result.scalars()}\n\n    # Build response\n    posts = []\n    for bookmark in valid_bookmarks:\n        post = bookmark.post\n        category_slug = post.sub_forum.issue_category.slug if post.sub_forum and post.sub_forum.issue_category else \"\"\n        posts.append(_post_to_list_item(post, category_slug, user_votes.get(post.id)))\n\n    return BookmarkedPostsResponse(\n        posts=posts,\n        total_count=total_count,\n        has_more=offset + limit < total_count\n    )\n\n\n@router.get(\"/posts/{post_id}/bookmark-status\")\nasync def get_bookmark_status(\n    post_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Check if a post is bookmarked by the current user.\"\"\"\n    existing = await db.execute(\n        select(ForumBookmark).where(\n            ForumBookmark.user_id == current_user.id,\n            ForumBookmark.post_id == post_id\n        )\n    )\n    bookmark = existing.scalar_one_or_none()\n\n    return {\n        \"post_id\": str(post_id),\n        \"is_bookmarked\": bookmark is not None,\n        \"bookmarked_at\": bookmark.created_at.isoformat() if bookmark else None\n    }\n\n\n@router.get(\"/bookmarks/ids\")\nasync def get_bookmarked_post_ids(\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get all bookmarked post IDs for the current user.\n\n    Useful for efficiently checking bookmark status on post lists.\n    \"\"\"\n    query = (\n        select(ForumBookmark.post_id)\n        .where(ForumBookmark.user_id == current_user.id)\n    )\n    result = await db.execute(query)\n    post_ids = [str(row[0]) for row in result.all()]\n\n    return {\"bookmarked_post_ids\": post_ids}\n\n\n# === HELPER FUNCTIONS ===\n\ndef _post_to_list_item(post: ForumPost, category_slug: str, user_vote: Optional[VoteType]) -> PostListItem:\n    sub_forum_slug = post.sub_forum.slug if post.sub_forum else \"\"\n    return PostListItem(\n        id=post.id,\n        title=post.title,\n        content_preview=post.content[:200] + \"...\" if len(post.content) > 200 else post.content,\n        sub_forum_slug=sub_forum_slug,\n        category_slug=category_slug,\n        author=PostAuthor(id=post.author.id, username=post.author.username),\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        user_vote=user_vote,\n        created_at=post.created_at,\n    )\n\n\ndef _post_to_response(\n    post: ForumPost,\n    sub_forum_slug: str,\n    category_slug: str,\n    user_vote: Optional[VoteType]\n) -> PostResponse:\n    return PostResponse(\n        id=post.id,\n        title=post.title,\n        content=post.content,\n        sub_forum_id=post.sub_forum_id,\n        sub_forum_slug=sub_forum_slug,\n        category_slug=category_slug,\n        author=PostAuthor(id=post.author.id, username=post.author.username),\n        is_pinned=post.is_pinned,\n        is_guide=post.is_guide,\n        vote_count=post.vote_count,\n        comment_count=post.comment_count,\n        user_vote=user_vote,\n        created_at=post.created_at,\n        updated_at=post.updated_at,\n    )\n\n\ndef _comment_to_response(comment: ForumComment, user_vote: Optional[VoteType]) -> CommentResponse:\n    return CommentResponse(\n        id=comment.id,\n        content=comment.content,\n        post_id=comment.post_id,\n        author=PostAuthor(id=comment.author.id, username=comment.author.username),\n        parent_id=comment.parent_id,\n        vote_count=comment.vote_count,\n        user_vote=user_vote,\n        depth=comment.depth,\n        replies=[],\n        created_at=comment.created_at,\n        updated_at=comment.updated_at,\n    )\n\n\ndef _build_comment_tree(comments: List[ForumComment], user_votes: dict) -> List[CommentResponse]:\n    \"\"\"Build a tree structure from flat comment list.\"\"\"\n    comment_map = {}\n    roots = []\n\n    # First pass: create all response objects\n    for c in comments:\n        comment_map[c.id] = _comment_to_response(c, user_votes.get(c.id))\n\n    # Second pass: build tree\n    for c in comments:\n        response = comment_map[c.id]\n        if c.parent_id and c.parent_id in comment_map:\n            comment_map[c.parent_id].replies.append(response)\n        else:\n            roots.append(response)\n\n    return roots\n","numLines":1640,"startLine":1,"totalLines":1640}}}
{"parentUuid":"bb3013eb-0d75-48e6-a851-a7fa56798237","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AsiwUNRoRWL29MQNiAkUAQ","type":"message","role":"assistant","content":[{"type":"text","text":"I can see that rate limiting is already partially set up. The `slowapi` dependency exists in requirements.txt, and the forum.py already imports the limiter and has rate limit decorators. Let me check the existing rate_limit module to understand its current implementation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":25088,"cache_read_input_tokens":37260,"cache_creation":{"ephemeral_5m_input_tokens":25088,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWXYKSACdEV7okuaDpmF4","type":"assistant","uuid":"284f4ca9-99d5-413b-8cab-0e451113c1df","timestamp":"2025-12-27T16:53:54.624Z"}
{"parentUuid":"284f4ca9-99d5-413b-8cab-0e451113c1df","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AsiwUNRoRWL29MQNiAkUAQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C5MU1LV4KsR8EWdqRJGGmz","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/core/rate_limit.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":25088,"cache_read_input_tokens":37260,"cache_creation":{"ephemeral_5m_input_tokens":25088,"ephemeral_1h_input_tokens":0},"output_tokens":138,"service_tier":"standard"}},"requestId":"req_011CWXYKSACdEV7okuaDpmF4","type":"assistant","uuid":"d2f5a063-2684-4264-bb56-996297052e02","timestamp":"2025-12-27T16:53:55.835Z"}
{"parentUuid":"d2f5a063-2684-4264-bb56-996297052e02","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C5MU1LV4KsR8EWdqRJGGmz","type":"tool_result","content":"     1→\"\"\"\n     2→Rate limiting configuration for the LOOKSMAXX API.\n     3→\n     4→Uses slowapi with Redis backend when available, falls back to in-memory storage.\n     5→\"\"\"\n     6→\n     7→import os\n     8→import logging\n     9→\n    10→from fastapi import Request\n    11→from slowapi import Limiter\n    12→from slowapi.util import get_remote_address\n    13→\n    14→logger = logging.getLogger(__name__)\n    15→\n    16→\n    17→def get_user_identifier(request: Request) -> str:\n    18→    \"\"\"\n    19→    Get rate limit key based on authenticated user or IP address.\n    20→\n    21→    For authenticated users, uses user ID for more accurate per-user limiting.\n    22→    For anonymous users, falls back to IP address.\n    23→    \"\"\"\n    24→    # Check if user is authenticated (set by auth middleware/dependency)\n    25→    if hasattr(request.state, \"user\") and request.state.user:\n    26→        return f\"user:{request.state.user.id}\"\n    27→\n    28→    # Check authorization header for JWT token presence\n    29→    auth_header = request.headers.get(\"authorization\", \"\")\n    30→    if auth_header.startswith(\"Bearer \"):\n    31→        # Token exists but user not loaded yet - use token hash as key\n    32→        # This handles cases where rate limit runs before auth dependency\n    33→        token = auth_header[7:]\n    34→        # Use first 16 chars of token as identifier (enough for uniqueness)\n    35→        return f\"token:{token[:16]}\"\n    36→\n    37→    # Fall back to IP address for anonymous users\n    38→    return get_remote_address(request)\n    39→\n    40→\n    41→def create_limiter() -> Limiter:\n    42→    \"\"\"\n    43→    Create a rate limiter with Redis backend if available, otherwise in-memory.\n    44→\n    45→    Redis URL is read from REDIS_URL environment variable.\n    46→    \"\"\"\n    47→    redis_url = os.environ.get(\"REDIS_URL\")\n    48→\n    49→    if redis_url:\n    50→        try:\n    51→            # Use Redis backend for distributed rate limiting\n    52→            limiter = Limiter(\n    53→                key_func=get_user_identifier,\n    54→                storage_uri=redis_url,\n    55→                strategy=\"fixed-window\",  # More predictable than moving-window\n    56→            )\n    57→            logger.info(\"[RATE_LIMIT] Using Redis backend for rate limiting\")\n    58→            return limiter\n    59→        except Exception as e:\n    60→            logger.warning(f\"[RATE_LIMIT] Failed to connect to Redis: {e}, falling back to in-memory\")\n    61→\n    62→    # Fall back to in-memory storage (single-instance only)\n    63→    limiter = Limiter(\n    64→        key_func=get_user_identifier,\n    65→        strategy=\"fixed-window\",\n    66→    )\n    67→    logger.info(\"[RATE_LIMIT] Using in-memory backend for rate limiting\")\n    68→    return limiter\n    69→\n    70→\n    71→# Create global limiter instance\n    72→limiter = create_limiter()\n    73→\n    74→\n    75→# Rate limit constants for forum endpoints\n    76→class ForumRateLimits:\n    77→    \"\"\"Rate limits for forum operations.\"\"\"\n    78→\n    79→    # Posts: 5 per minute per user\n    80→    POSTS = \"5/minute\"\n    81→\n    82→    # Comments: 20 per minute per user\n    83→    COMMENTS = \"20/minute\"\n    84→\n    85→    # Votes: 30 per minute per user\n    86→    VOTES = \"30/minute\"\n    87→\n    88→    # Reports: 10 per hour per user (to prevent spam reports)\n    89→    REPORTS = \"10/hour\"\n    90→\n    91→    # Read operations: Higher limits for browsing\n    92→    READ = \"60/minute\"\n    93→\n    94→    # Moderation: Reasonable limit for mod actions\n    95→    MODERATION = \"30/minute\"\n    96→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5c4a5879-9086-4a08-a4ba-c3a34fc51930","timestamp":"2025-12-27T16:53:55.893Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/core/rate_limit.py","content":"\"\"\"\nRate limiting configuration for the LOOKSMAXX API.\n\nUses slowapi with Redis backend when available, falls back to in-memory storage.\n\"\"\"\n\nimport os\nimport logging\n\nfrom fastapi import Request\nfrom slowapi import Limiter\nfrom slowapi.util import get_remote_address\n\nlogger = logging.getLogger(__name__)\n\n\ndef get_user_identifier(request: Request) -> str:\n    \"\"\"\n    Get rate limit key based on authenticated user or IP address.\n\n    For authenticated users, uses user ID for more accurate per-user limiting.\n    For anonymous users, falls back to IP address.\n    \"\"\"\n    # Check if user is authenticated (set by auth middleware/dependency)\n    if hasattr(request.state, \"user\") and request.state.user:\n        return f\"user:{request.state.user.id}\"\n\n    # Check authorization header for JWT token presence\n    auth_header = request.headers.get(\"authorization\", \"\")\n    if auth_header.startswith(\"Bearer \"):\n        # Token exists but user not loaded yet - use token hash as key\n        # This handles cases where rate limit runs before auth dependency\n        token = auth_header[7:]\n        # Use first 16 chars of token as identifier (enough for uniqueness)\n        return f\"token:{token[:16]}\"\n\n    # Fall back to IP address for anonymous users\n    return get_remote_address(request)\n\n\ndef create_limiter() -> Limiter:\n    \"\"\"\n    Create a rate limiter with Redis backend if available, otherwise in-memory.\n\n    Redis URL is read from REDIS_URL environment variable.\n    \"\"\"\n    redis_url = os.environ.get(\"REDIS_URL\")\n\n    if redis_url:\n        try:\n            # Use Redis backend for distributed rate limiting\n            limiter = Limiter(\n                key_func=get_user_identifier,\n                storage_uri=redis_url,\n                strategy=\"fixed-window\",  # More predictable than moving-window\n            )\n            logger.info(\"[RATE_LIMIT] Using Redis backend for rate limiting\")\n            return limiter\n        except Exception as e:\n            logger.warning(f\"[RATE_LIMIT] Failed to connect to Redis: {e}, falling back to in-memory\")\n\n    # Fall back to in-memory storage (single-instance only)\n    limiter = Limiter(\n        key_func=get_user_identifier,\n        strategy=\"fixed-window\",\n    )\n    logger.info(\"[RATE_LIMIT] Using in-memory backend for rate limiting\")\n    return limiter\n\n\n# Create global limiter instance\nlimiter = create_limiter()\n\n\n# Rate limit constants for forum endpoints\nclass ForumRateLimits:\n    \"\"\"Rate limits for forum operations.\"\"\"\n\n    # Posts: 5 per minute per user\n    POSTS = \"5/minute\"\n\n    # Comments: 20 per minute per user\n    COMMENTS = \"20/minute\"\n\n    # Votes: 30 per minute per user\n    VOTES = \"30/minute\"\n\n    # Reports: 10 per hour per user (to prevent spam reports)\n    REPORTS = \"10/hour\"\n\n    # Read operations: Higher limits for browsing\n    READ = \"60/minute\"\n\n    # Moderation: Reasonable limit for mod actions\n    MODERATION = \"30/minute\"\n","numLines":96,"startLine":1,"totalLines":96}}}
{"parentUuid":"5c4a5879-9086-4a08-a4ba-c3a34fc51930","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QLtXy4jTvktdf4umSxmWGz","type":"message","role":"assistant","content":[{"type":"text","text":"The rate limiting is already fully implemented. Let me verify the complete setup by checking:\n\n1. The `main.py` setup (already read - limiter is properly configured)\n2. The forum.py decorators (already read - decorators are applied)\n3. The rate_limit.py module (just read - fully implemented)\n\nLet me do a quick check to see which forum endpoints have rate limiting applied and which don't:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1322,"cache_read_input_tokens":62348,"cache_creation":{"ephemeral_5m_input_tokens":1322,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYL43TBv3st1XgzDfHd","type":"assistant","uuid":"04472361-3d04-4a26-a933-45ecf518e6cf","timestamp":"2025-12-27T16:54:02.904Z"}
{"parentUuid":"04472361-3d04-4a26-a933-45ecf518e6cf","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QLtXy4jTvktdf4umSxmWGz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WNLU6CYiKgsNmfERQo551y","name":"Grep","input":{"pattern":"@limiter\\.limit","path":"/Users/imorgado/LOOKSMAXX/looksmaxx-api/app/routers/forum.py","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1322,"cache_read_input_tokens":62348,"cache_creation":{"ephemeral_5m_input_tokens":1322,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYL43TBv3st1XgzDfHd","type":"assistant","uuid":"c98e7f12-3083-46ac-8a41-8b0f6eb48a80","timestamp":"2025-12-27T16:54:03.808Z"}
{"parentUuid":"c98e7f12-3083-46ac-8a41-8b0f6eb48a80","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WNLU6CYiKgsNmfERQo551y","type":"tool_result","content":"749:@limiter.limit(ForumRateLimits.POSTS)\n827:@limiter.limit(ForumRateLimits.VOTES)\n1040:@limiter.limit(ForumRateLimits.COMMENTS)\n1093:@limiter.limit(ForumRateLimits.VOTES)\n1225:@limiter.limit(ForumRateLimits.REPORTS)"}]},"uuid":"43567359-4460-4c8e-a181-8ca02a32a248","timestamp":"2025-12-27T16:54:04.371Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"749:@limiter.limit(ForumRateLimits.POSTS)\n827:@limiter.limit(ForumRateLimits.VOTES)\n1040:@limiter.limit(ForumRateLimits.COMMENTS)\n1093:@limiter.limit(ForumRateLimits.VOTES)\n1225:@limiter.limit(ForumRateLimits.REPORTS)","numLines":5}}
{"parentUuid":"43567359-4460-4c8e-a181-8ca02a32a248","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX/looksmaxx-app","sessionId":"f69fd6e4-d652-488a-80e9-d77c34a15154","version":"2.0.76","gitBranch":"main","agentId":"afe641c","slug":"polymorphic-coalescing-bumblebee","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KBRdShzdTvp7MLRLZJSayP","type":"message","role":"assistant","content":[{"type":"text","text":"The rate limiting is already implemented. Let me create a summary of what's already in place:\n\n**Rate Limiting Implementation Status: COMPLETE**\n\nThe rate limiting for the Forum API is already fully implemented:\n\n### 1. Dependencies (requirements.txt)\n- `slowapi==0.1.9` - Rate limiting library\n- `redis==5.0.1` - For distributed rate limiting (optional)\n\n### 2. Rate Limit Module (`app/core/rate_limit.py`)\n- Custom `get_user_identifier()` function that:\n  - Uses user ID for authenticated users (`user:{user_id}`)\n  - Falls back to token prefix for JWT-authenticated requests (`token:{first_16_chars}`)\n  - Uses IP address for anonymous users\n- `create_limiter()` function with Redis backend support (falls back to in-memory)\n- `ForumRateLimits` class with constants:\n  - `POSTS = \"5/minute\"` - 5 posts per minute per user\n  - `COMMENTS = \"20/minute\"` - 20 comments per minute per user\n  - `VOTES = \"30/minute\"` - 30 votes per minute per user\n  - `REPORTS = \"10/hour\"` - 10 reports per hour per user\n  - `READ = \"60/minute\"` - Read operations\n  - `MODERATION = \"30/minute\"` - Moderation actions\n\n### 3. Main App Setup (`app/main.py`)\n- Imports limiter from `app/core/rate_limit`\n- Sets `app.state.limiter = limiter`\n- Adds exception handler for `RateLimitExceeded`\n\n### 4. Forum Router (`app/routers/forum.py`)\nRate-limited endpoints:\n- `POST /posts` - `@limiter.limit(ForumRateLimits.POSTS)` - 5/minute\n- `POST /posts/{post_id}/vote` - `@limiter.limit(ForumRateLimits.VOTES)` - 30/minute\n- `POST /posts/{post_id}/comments` - `@limiter.limit(ForumRateLimits.COMMENTS)` - 20/minute\n- `POST /comments/{comment_id}/vote` - `@limiter.limit(ForumRateLimits.VOTES)` - 30/minute\n- `POST /reports` - `@limiter.limit(ForumRateLimits.REPORTS)` - 10/hour\n\nThe implementation matches exactly what was requested in the SAAS audit requirements. No additional changes are needed."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":430,"cache_read_input_tokens":63670,"cache_creation":{"ephemeral_5m_input_tokens":430,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWXYLhdefxWMk1opYT3kS","type":"assistant","uuid":"80747cb9-60f8-4d69-9fbc-eb52d2c7bb26","timestamp":"2025-12-27T16:54:17.193Z"}
