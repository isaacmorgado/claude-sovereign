     1→"""
     2→Notification Service - Handles creating, fetching, and managing notifications
     3→"""
     4→
     5→from uuid import UUID
     6→from typing import Optional, List
     7→from datetime import datetime
     8→from sqlalchemy.ext.asyncio import AsyncSession
     9→from sqlalchemy import select, func, update, delete
    10→
    11→from app.models.notification import Notification, NotificationType, NotificationSourceType
    12→
    13→
    14→class NotificationService:
    15→    """Service for managing user notifications"""
    16→
    17→    @staticmethod
    18→    async def create_notification(
    19→        db: AsyncSession,
    20→        user_id: UUID,
    21→        notification_type: NotificationType,
    22→        title: str,
    23→        content: Optional[str] = None,
    24→        source_type: Optional[NotificationSourceType] = None,
    25→        source_id: Optional[UUID] = None,
    26→        post_id: Optional[UUID] = None,
    27→        actor_id: Optional[UUID] = None,
    28→        link: Optional[str] = None
    29→    ) -> Optional[Notification]:
    30→        """
    31→        Create a new notification for a user.
    32→
    33→        Args:
    34→            db: Database session
    35→            user_id: The user who will receive the notification
    36→            notification_type: Type of notification (reply, mention, vote, system, milestone)
    37→            title: Short title for the notification
    38→            content: Preview of the content (optional)
    39→            source_type: Type of source (post, comment, or system)
    40→            source_id: ID of the source (post or comment ID)
    41→            post_id: ID of the related post (for navigation)
    42→            actor_id: ID of the user who triggered the notification
    43→            link: Link to navigate to when clicked
    44→        """
    45→        # Don't notify yourself
    46→        if actor_id and actor_id == user_id:
    47→            return None
    48→
    49→        notification = Notification(
    50→            user_id=user_id,
    51→            type=notification_type,
    52→            title=title,
    53→            content=content,
    54→            source_type=source_type,
    55→            source_id=source_id,
    56→            post_id=post_id,
    57→            actor_id=actor_id,
    58→            link=link,
    59→            read=False
    60→        )
    61→
    62→        db.add(notification)
    63→        await db.commit()
    64→        await db.refresh(notification)
    65→
    66→        return notification
    67→
    68→    @staticmethod
    69→    async def get_user_notifications(
    70→        db: AsyncSession,
    71→        user_id: UUID,
    72→        unread_only: bool = False,
    73→        limit: int = 20,
    74→        offset: int = 0
    75→    ) -> tuple[List[Notification], int]:
    76→        """
    77→        Get notifications for a user with pagination.
    78→
    79→        Returns:
    80→            Tuple of (notifications list, total count)
    81→        """
    82→        # Base query
    83→        query = select(Notification).where(Notification.user_id == user_id)
    84→
    85→        if unread_only:
    86→            query = query.where(Notification.read == False)
    87→
    88→        # Get total count
    89→        count_query = select(func.count(Notification.id)).where(Notification.user_id == user_id)
    90→        if unread_only:
    91→            count_query = count_query.where(Notification.read == False)
    92→        count_result = await db.execute(count_query)
    93→        total_count = count_result.scalar() or 0
    94→
    95→        # Get paginated notifications
    96→        query = query.order_by(Notification.created_at.desc()).offset(offset).limit(limit)
    97→        result = await db.execute(query)
    98→        notifications = result.scalars().all()
    99→
   100→        return notifications, total_count
   101→
   102→    @staticmethod
   103→    async def get_unread_count(db: AsyncSession, user_id: UUID) -> int:
   104→        """Get count of unread notifications for a user."""
   105→        query = select(func.count(Notification.id)).where(
   106→            Notification.user_id == user_id,
   107→            Notification.read == False
   108→        )
   109→        result = await db.execute(query)
   110→        return result.scalar() or 0
   111→
   112→    @staticmethod
   113→    async def mark_read(db: AsyncSession, notification_id: UUID, user_id: UUID) -> bool:
   114→        """
   115→        Mark a single notification as read.
   116→
   117→        Returns:
   118→            True if notification was found and updated, False otherwise.
   119→        """
   120→        query = (
   121→            update(Notification)
   122→            .where(Notification.id == notification_id, Notification.user_id == user_id)
   123→            .values(read=True, read_at=datetime.utcnow())
   124→        )
   125→        result = await db.execute(query)
   126→        await db.commit()
   127→        return result.rowcount > 0
   128→
   129→    @staticmethod
   130→    async def mark_all_read(db: AsyncSession, user_id: UUID) -> int:
   131→        """
   132→        Mark all notifications for a user as read.
   133→
   134→        Returns:
   135→            Number of notifications updated.
   136→        """
   137→        query = (
   138→            update(Notification)
   139→            .where(Notification.user_id == user_id, Notification.read == False)
   140→            .values(read=True, read_at=datetime.utcnow())
   141→        )
   142→        result = await db.execute(query)
   143→        await db.commit()
   144→        return result.rowcount
   145→
   146→    @staticmethod
   147→    async def delete_notification(db: AsyncSession, notification_id: UUID, user_id: UUID) -> bool:
   148→        """
   149→        Delete a notification.
   150→
   151→        Returns:
   152→            True if notification was found and deleted, False otherwise.
   153→        """
   154→        query = delete(Notification).where(
   155→            Notification.id == notification_id,
   156→            Notification.user_id == user_id
   157→        )
   158→        result = await db.execute(query)
   159→        await db.commit()
   160→        return result.rowcount > 0
   161→
   162→    @staticmethod
   163→    async def get_notification(db: AsyncSession, notification_id: UUID, user_id: UUID) -> Optional[Notification]:
   164→        """Get a single notification by ID."""
   165→        query = select(Notification).where(
   166→            Notification.id == notification_id,
   167→            Notification.user_id == user_id
   168→        )
   169→        result = await db.execute(query)
   170→        return result.scalar_one_or_none()
   171→
   172→    # === HELPER METHODS FOR SPECIFIC NOTIFICATION TYPES ===
   173→
   174→    @staticmethod
   175→    async def notify_reply(
   176→        db: AsyncSession,
   177→        user_id: UUID,
   178→        actor_id: UUID,
   179→        actor_username: str,
   180→        post_id: UUID,
   181→        post_title: str,
   182→        comment_id: UUID,
   183→        content_preview: str,
   184→        is_post_reply: bool = True
   185→    ) -> Optional[Notification]:
   186→        """
   187→        Notify user when someone replies to their post or comment.
   188→
   189→        Args:
   190→            is_post_reply: True if reply is to a post, False if to a comment
   191→        """
   192→        if is_post_reply:
   193→            title = f"{actor_username} replied to your post"
   194→        else:
   195→            title = f"{actor_username} replied to your comment"
   196→
   197→        return await NotificationService.create_notification(
   198→            db=db,
   199→            user_id=user_id,
   200→            notification_type=NotificationType.REPLY,
   201→            title=title,
   202→            content=content_preview[:200] if content_preview else None,
   203→            source_type=NotificationSourceType.COMMENT,
   204→            source_id=comment_id,
   205→            post_id=post_id,
   206→            actor_id=actor_id,
   207→            link=f"/forum/post/{post_id}"
   208→        )
   209→
   210→    @staticmethod
   211→    async def notify_mention(
   212→        db: AsyncSession,
   213→        user_id: UUID,
   214→        actor_id: UUID,
   215→        actor_username: str,
   216→        post_id: UUID,
   217→        source_type: NotificationSourceType,
   218→        source_id: UUID,
   219→        content_preview: str
   220→    ) -> Optional[Notification]:
   221→        """Notify user when they are mentioned in a post or comment."""
   222→        title = f"{actor_username} mentioned you"
   223→
   224→        return await NotificationService.create_notification(
   225→            db=db,
   226→            user_id=user_id,
   227→            notification_type=NotificationType.MENTION,
   228→            title=title,
   229→            content=content_preview[:200] if content_preview else None,
   230→            source_type=source_type,
   231→            source_id=source_id,
   232→            post_id=post_id,
   233→            actor_id=actor_id,
   234→            link=f"/forum/post/{post_id}"
   235→        )
   236→
   237→    @staticmethod
   238→    async def notify_vote(
   239→        db: AsyncSession,
   240→        user_id: UUID,
   241→        actor_id: UUID,
   242→        post_id: UUID,
   243→        source_type: NotificationSourceType,
   244→        source_id: UUID,
   245→        is_upvote: bool = True
   246→    ) -> Optional[Notification]:
   247→        """Notify user when their content receives an upvote."""
   248→        if not is_upvote:
   249→            return None  # Don't notify on downvotes
   250→
   251→        content_type = "post" if source_type == NotificationSourceType.POST else "comment"
   252→        title = f"Your {content_type} received an upvote"
   253→
   254→        return await NotificationService.create_notification(
   255→            db=db,
   256→            user_id=user_id,
   257→            notification_type=NotificationType.VOTE,
   258→            title=title,
   259→            source_type=source_type,
   260→            source_id=source_id,
   261→            post_id=post_id,
   262→            actor_id=actor_id,
   263→            link=f"/forum/post/{post_id}"
   264→        )
   265→
   266→    @staticmethod
   267→    async def notify_system(
   268→        db: AsyncSession,
   269→        user_id: UUID,
   270→        title: str,
   271→        content: Optional[str] = None,
   272→        link: Optional[str] = None
   273→    ) -> Optional[Notification]:
   274→        """Create a system notification for a user."""
   275→        return await NotificationService.create_notification(
   276→            db=db,
   277→            user_id=user_id,
   278→            notification_type=NotificationType.SYSTEM,
   279→            title=title,
   280→            content=content,
   281→            source_type=NotificationSourceType.SYSTEM,
   282→            link=link
   283→        )
   284→
   285→    @staticmethod
   286→    async def notify_milestone(
   287→        db: AsyncSession,
   288→        user_id: UUID,
   289→        milestone_type: str,
   290→        milestone_value: int
   291→    ) -> Optional[Notification]:
   292→        """Notify user when they reach a karma milestone."""
   293→        title = f"You reached {milestone_value} karma!"
   294→        content = f"Congratulations! Your contributions have earned you {milestone_value} karma points."
   295→
   296→        return await NotificationService.create_notification(
   297→            db=db,
   298→            user_id=user_id,
   299→            notification_type=NotificationType.MILESTONE,
   300→            title=title,
   301→            content=content,
   302→            source_type=NotificationSourceType.SYSTEM,
   303→            link="/forum"
   304→        )
   305→
   306→
   307→# Singleton instance
   308→notification_service = NotificationService()
   309→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
