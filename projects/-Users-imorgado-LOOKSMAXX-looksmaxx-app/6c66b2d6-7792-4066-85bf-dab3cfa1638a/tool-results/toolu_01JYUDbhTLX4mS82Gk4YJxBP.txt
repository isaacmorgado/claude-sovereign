     1→'use client';
     2→
     3→import { useState, useMemo, useRef, useEffect, useCallback } from 'react';
     4→import { createPortal } from 'react-dom';
     5→import { motion, AnimatePresence } from 'framer-motion';
     6→import { X, ChevronLeft, ChevronRight, AlertTriangle, Sparkles, Info, BarChart3 } from 'lucide-react';
     7→import { FaceIQScoreResult, Gender, Ethnicity, FACEIQ_METRICS } from '@/lib/faceiq-scoring';
     8→import { generateAIDescription, getSeverityFromScore } from '@/lib/aiDescriptions';
     9→import { getScoreColor } from '@/types/results';
    10→import { GradientRangeBar } from '../visualization/GradientRangeBar';
    11→
    12→// ============================================
    13→// TYPES
    14→// ============================================
    15→
    16→interface RatioDetailModalProps {
    17→  isOpen: boolean;
    18→  onClose: () => void;
    19→  ratio: FaceIQScoreResult | null;
    20→  onPrevious?: () => void;
    21→  onNext?: () => void;
    22→  hasPrevious?: boolean;
    23→  hasNext?: boolean;
    24→  facePhoto?: string;
    25→  gender?: Gender;
    26→  ethnicity?: Ethnicity;
    27→}
    28→
    29→// ============================================
    30→// STAT CARD (FaceIQ Style)
    31→// ============================================
    32→
    33→interface StatCardProps {
    34→  label: string;
    35→  value: string;
    36→  subtext?: string;
    37→  variant?: 'default' | 'ideal' | 'score';
    38→  scoreColor?: string;
    39→  subtextColor?: string;
    40→}
    41→
    42→function StatCard({ label, value, subtext, variant = 'default', scoreColor, subtextColor }: StatCardProps) {
    43→  const variants = {
    44→    default: 'bg-neutral-800/80 border-neutral-700',
    45→    ideal: 'bg-cyan-500/10 border-cyan-500/30',
    46→    score: 'bg-blue-500/10 border-blue-500/30',
    47→  };
    48→
    49→  const labelColors = {
    50→    default: 'text-neutral-500',
    51→    ideal: 'text-cyan-400',
    52→    score: 'text-neutral-500',
    53→  };
    54→
    55→  return (
    56→    <div className={`rounded-xl border p-3 md:p-4 ${variants[variant]}`}>
    57→      <div className={`text-[10px] font-medium uppercase tracking-wider mb-1 ${labelColors[variant]}`}>
    58→        {label}
    59→      </div>
    60→      <div
    61→        className="text-lg md:text-xl font-semibold"
    62→        style={scoreColor ? { color: scoreColor } : { color: variant === 'ideal' ? 'rgb(34, 211, 238)' : 'white' }}
    63→      >
    64→        {value}
    65→      </div>
    66→      {subtext && (
    67→        <div
    68→          className="text-[10px] mt-0.5 md:mt-1"
    69→          style={{ color: subtextColor || 'rgb(115, 115, 115)' }}
    70→        >
    71→          {subtext}
    72→        </div>
    73→      )}
    74→    </div>
    75→  );
    76→}
    77→
    78→// ============================================
    79→// SCORING METHODOLOGY CHART (FaceIQ Style)
    80→// ============================================
    81→
    82→interface ScoringMethodologyChartProps {
    83→  value: number;
    84→  score: number;
    85→  idealMin: number;
    86→  idealMax: number;
    87→  rangeMin: number;
    88→  rangeMax: number;
    89→  unit: string;
    90→  decayRate?: number;
    91→}
    92→
    93→interface HoverState {
    94→  visible: boolean;
    95→  x: number;
    96→  y: number;
    97→  value: number;
    98→  score: number;
    99→}
   100→
   101→function ScoringMethodologyChart({
   102→  value,
   103→  score,
   104→  idealMin,
   105→  idealMax,
   106→  rangeMin,
   107→  rangeMax,
   108→  unit,
   109→  decayRate = 4,
   110→}: ScoringMethodologyChartProps) {
   111→  const canvasRef = useRef<HTMLCanvasElement>(null);
   112→  const containerRef = useRef<HTMLDivElement>(null);
   113→  const [hover, setHover] = useState<HoverState>({ visible: false, x: 0, y: 0, value: 0, score: 0 });
   114→  const paddingRef = useRef({ top: 20, right: 20, bottom: 35, left: 35 });
   115→  const chartDimensionsRef = useRef({ width: 0, height: 0, chartWidth: 0, chartHeight: 0 });
   116→
   117→  // Calculate score for any x value using exponential decay
   118→  const calculateScore = useCallback((x: number): number => {
   119→    const idealRangeHalf = (idealMax - idealMin) / 2;
   120→    if (idealRangeHalf === 0) return x === idealMin ? 10 : 1;
   121→
   122→    if (x >= idealMin && x <= idealMax) {
   123→      return 10;
   124→    }
   125→
   126→    const deviation = x < idealMin
   127→      ? (idealMin - x) / idealRangeHalf
   128→      : (x - idealMax) / idealRangeHalf;
   129→
   130→    return Math.max(1, 10 * Math.exp(-decayRate * Math.pow(deviation, 2)));
   131→  }, [idealMin, idealMax, decayRate]);
   132→
   133→  // Get color for a score value (FaceIQ gradient)
   134→  const getColorForScore = (s: number): string => {
   135→    if (s >= 9) return 'rgb(34, 197, 94)';   // Green - Excellent
   136→    if (s >= 7) return 'rgb(6, 182, 212)';   // Cyan - Good
   137→    if (s >= 5) return 'rgb(250, 204, 21)';  // Yellow - Average
   138→    if (s >= 3) return 'rgb(249, 115, 22)';  // Orange - Below average
   139→    return 'rgb(239, 68, 68)';                // Red - Poor
   140→  };
   141→
   142→  useEffect(() => {
   143→    const canvas = canvasRef.current;
   144→    if (!canvas) return;
   145→
   146→    const ctx = canvas.getContext('2d');
   147→    if (!ctx) return;
   148→
   149→    const dpr = window.devicePixelRatio || 1;
   150→    const rect = canvas.getBoundingClientRect();
   151→    canvas.width = rect.width * dpr;
   152→    canvas.height = rect.height * dpr;
   153→    ctx.scale(dpr, dpr);
   154→
   155→    const width = rect.width;
   156→    const height = rect.height;
   157→    const padding = paddingRef.current;
   158→    const chartWidth = width - padding.left - padding.right;
   159→    const chartHeight = height - padding.top - padding.bottom;
   160→
   161→    // Store dimensions for mouse handler
   162→    chartDimensionsRef.current = { width, height, chartWidth, chartHeight };
   163→
   164→    // Clear canvas
   165→    ctx.clearRect(0, 0, width, height);
   166→
   167→    // X-axis scale
   168→    const xScale = (val: number) => padding.left + ((val - rangeMin) / (rangeMax - rangeMin)) * chartWidth;
   169→    const yScale = (val: number) => padding.top + (1 - val / 10) * chartHeight;
   170→
   171→    // Calculate positions for gradient
   172→    const idealMinPos = Math.max(0, Math.min(1, (idealMin - rangeMin) / (rangeMax - rangeMin)));
   173→    const idealMaxPos = Math.max(0, Math.min(1, (idealMax - rangeMin) / (rangeMax - rangeMin)));
   174→
   175→    // Draw horizontal grid lines (FaceIQ style - subtle)
   176→    ctx.strokeStyle = 'rgba(64, 64, 64, 0.5)';
   177→    ctx.lineWidth = 1;
   178→    for (let i = 0; i <= 10; i += 2) {
   179→      const y = yScale(i);
   180→      ctx.beginPath();
   181→      ctx.moveTo(padding.left, y);
   182→      ctx.lineTo(padding.left + chartWidth, y);
   183→      ctx.stroke();
   184→    }
   185→
   186→    // Draw ideal range highlight zone
   187→    const idealLeftX = xScale(idealMin);
   188→    const idealRightX = xScale(idealMax);
   189→    ctx.fillStyle = 'rgba(34, 197, 94, 0.08)';
   190→    ctx.fillRect(idealLeftX, padding.top, idealRightX - idealLeftX, chartHeight);
   191→
   192→    // Draw ideal range border lines
   193→    ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
   194→    ctx.lineWidth = 1;
   195→    ctx.setLineDash([4, 4]);
   196→    ctx.beginPath();
   197→    ctx.moveTo(idealLeftX, padding.top);
   198→    ctx.lineTo(idealLeftX, padding.top + chartHeight);
   199→    ctx.stroke();
   200→    ctx.beginPath();
   201→    ctx.moveTo(idealRightX, padding.top);
   202→    ctx.lineTo(idealRightX, padding.top + chartHeight);
   203→    ctx.stroke();
   204→    ctx.setLineDash([]);
   205→
   206→    // Draw gradient fill under curve
   207→    // Colors: Red (1-3) → Orange (3-5) → Yellow (5-7) → Cyan (7-9) → Green (9-10)
   208→    const fillGradient = ctx.createLinearGradient(padding.left, 0, padding.left + chartWidth, 0);
   209→    fillGradient.addColorStop(0, 'rgba(239, 68, 68, 0.15)');                              // Red - Poor
   210→    fillGradient.addColorStop(Math.max(0, idealMinPos - 0.20), 'rgba(249, 115, 22, 0.15)'); // Orange - Below avg
   211→    fillGradient.addColorStop(Math.max(0, idealMinPos - 0.10), 'rgba(250, 204, 21, 0.15)'); // Yellow - Average
   212→    fillGradient.addColorStop(Math.max(0, idealMinPos - 0.03), 'rgba(6, 182, 212, 0.18)');  // Cyan - Good
   213→    fillGradient.addColorStop(idealMinPos, 'rgba(34, 197, 94, 0.2)');                      // Green - Ideal
   214→    fillGradient.addColorStop(idealMaxPos, 'rgba(34, 197, 94, 0.2)');                      // Green - Ideal
   215→    fillGradient.addColorStop(Math.min(1, idealMaxPos + 0.03), 'rgba(6, 182, 212, 0.18)');  // Cyan - Good
   216→    fillGradient.addColorStop(Math.min(1, idealMaxPos + 0.10), 'rgba(250, 204, 21, 0.15)'); // Yellow - Average
   217→    fillGradient.addColorStop(Math.min(1, idealMaxPos + 0.20), 'rgba(249, 115, 22, 0.15)'); // Orange - Below avg
   218→    fillGradient.addColorStop(1, 'rgba(239, 68, 68, 0.15)');                              // Red - Poor
   219→
   220→    // Draw fill
   221→    ctx.beginPath();
   222→    ctx.moveTo(xScale(rangeMin), yScale(0));
   223→    for (let i = 0; i <= 200; i++) {
   224→      const x = rangeMin + (rangeMax - rangeMin) * (i / 200);
   225→      const y = calculateScore(x);
   226→      ctx.lineTo(xScale(x), yScale(y));
   227→    }
   228→    ctx.lineTo(xScale(rangeMax), yScale(0));
   229→    ctx.closePath();
   230→    ctx.fillStyle = fillGradient;
   231→    ctx.fill();
   232→
   233→    // Draw curve with gradient stroke
   234→    // Colors: Red (1-3) → Orange (3-5) → Yellow (5-7) → Cyan (7-9) → Green (9-10)
   235→    const lineGradient = ctx.createLinearGradient(padding.left, 0, padding.left + chartWidth, 0);
   236→    lineGradient.addColorStop(0, 'rgb(239, 68, 68)');                              // Red - Poor
   237→    lineGradient.addColorStop(Math.max(0, idealMinPos - 0.20), 'rgb(249, 115, 22)'); // Orange - Below avg
   238→    lineGradient.addColorStop(Math.max(0, idealMinPos - 0.10), 'rgb(250, 204, 21)'); // Yellow - Average
   239→    lineGradient.addColorStop(Math.max(0, idealMinPos - 0.03), 'rgb(6, 182, 212)');  // Cyan - Good
   240→    lineGradient.addColorStop(idealMinPos, 'rgb(34, 197, 94)');                      // Green - Ideal
   241→    lineGradient.addColorStop(idealMaxPos, 'rgb(34, 197, 94)');                      // Green - Ideal
   242→    lineGradient.addColorStop(Math.min(1, idealMaxPos + 0.03), 'rgb(6, 182, 212)');  // Cyan - Good
   243→    lineGradient.addColorStop(Math.min(1, idealMaxPos + 0.10), 'rgb(250, 204, 21)'); // Yellow - Average
   244→    lineGradient.addColorStop(Math.min(1, idealMaxPos + 0.20), 'rgb(249, 115, 22)'); // Orange - Below avg
   245→    lineGradient.addColorStop(1, 'rgb(239, 68, 68)');                              // Red - Poor
   246→
   247→    ctx.beginPath();
   248→    for (let i = 0; i <= 200; i++) {
   249→      const x = rangeMin + (rangeMax - rangeMin) * (i / 200);
   250→      const y = calculateScore(x);
   251→      if (i === 0) {
   252→        ctx.moveTo(xScale(x), yScale(y));
   253→      } else {
   254→        ctx.lineTo(xScale(x), yScale(y));
   255→      }
   256→    }
   257→    ctx.strokeStyle = lineGradient;
   258→    ctx.lineWidth = 2.5;
   259→    ctx.lineCap = 'round';
   260→    ctx.lineJoin = 'round';
   261→    ctx.stroke();
   262→
   263→    // Draw axes
   264→    ctx.strokeStyle = 'rgb(82, 82, 82)';
   265→    ctx.lineWidth = 1;
   266→
   267→    // Y-axis
   268→    ctx.beginPath();
   269→    ctx.moveTo(padding.left, padding.top);
   270→    ctx.lineTo(padding.left, padding.top + chartHeight);
   271→    ctx.stroke();
   272→
   273→    // X-axis
   274→    ctx.beginPath();
   275→    ctx.moveTo(padding.left, padding.top + chartHeight);
   276→    ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
   277→    ctx.stroke();
   278→
   279→    // Y-axis labels
   280→    ctx.fillStyle = 'rgb(115, 115, 115)';
   281→    ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
   282→    ctx.textAlign = 'right';
   283→    ctx.textBaseline = 'middle';
   284→    for (let i = 0; i <= 10; i += 2) {
   285→      ctx.fillText(i.toString(), padding.left - 8, yScale(i));
   286→    }
   287→
   288→    // X-axis labels
   289→    ctx.textAlign = 'center';
   290→    ctx.textBaseline = 'top';
   291→    const steps = 5;
   292→    for (let i = 0; i <= steps; i++) {
   293→      const val = rangeMin + (rangeMax - rangeMin) * (i / steps);
   294→      let formatted: string;
   295→      if (unit === 'percent' || unit === '%') {
   296→        formatted = val.toFixed(0) + '%';
   297→      } else if (unit === 'degrees') {
   298→        formatted = val.toFixed(0) + '°';
   299→      } else {
   300→        formatted = val.toFixed(2);
   301→      }
   302→      ctx.fillText(formatted, xScale(val), padding.top + chartHeight + 8);
   303→    }
   304→
   305→    // Draw "Ideal" label in the ideal zone
   306→    if (idealRightX - idealLeftX > 40) {
   307→      ctx.fillStyle = 'rgba(34, 197, 94, 0.6)';
   308→      ctx.font = '9px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
   309→      ctx.textAlign = 'center';
   310→      ctx.textBaseline = 'top';
   311→      ctx.fillText('IDEAL', (idealLeftX + idealRightX) / 2, padding.top + 4);
   312→    }
   313→
   314→    // Draw current value marker
   315→    // Use calculateScore to ensure marker sits ON the curve
   316→    const currentX = xScale(value);
   317→    const curveScore = calculateScore(value);
   318→    const currentY = yScale(curveScore);
   319→
   320→    // Vertical dashed line from point to x-axis
   321→    ctx.setLineDash([3, 3]);
   322→    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
   323→    ctx.lineWidth = 1;
   324→    ctx.beginPath();
   325→    ctx.moveTo(currentX, currentY);
   326→    ctx.lineTo(currentX, padding.top + chartHeight);
   327→    ctx.stroke();
   328→    ctx.setLineDash([]);
   329→
   330→    // Outer glow circle
   331→    const markerColor = getColorForScore(curveScore);
   332→    ctx.beginPath();
   333→    ctx.arc(currentX, currentY, 10, 0, Math.PI * 2);
   334→    ctx.fillStyle = markerColor.replace('rgb', 'rgba').replace(')', ', 0.2)');
   335→    ctx.fill();
   336→
   337→    // Main marker circle
   338→    ctx.beginPath();
   339→    ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);
   340→    ctx.fillStyle = '#ffffff';
   341→    ctx.fill();
   342→    ctx.strokeStyle = markerColor;
   343→    ctx.lineWidth = 2.5;
   344→    ctx.stroke();
   345→
   346→    // Inner dot
   347→    ctx.beginPath();
   348→    ctx.arc(currentX, currentY, 2, 0, Math.PI * 2);
   349→    ctx.fillStyle = markerColor;
   350→    ctx.fill();
   351→
   352→  }, [value, score, idealMin, idealMax, rangeMin, rangeMax, unit, decayRate, calculateScore]);
   353→
   354→  // Mouse move handler for hover tooltip
   355→  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
   356→    const canvas = canvasRef.current;
   357→    if (!canvas) return;
   358→
   359→    const rect = canvas.getBoundingClientRect();
   360→    const mouseX = e.clientX - rect.left;
   361→    const mouseY = e.clientY - rect.top;
   362→
   363→    const padding = paddingRef.current;
   364→    const { chartWidth, chartHeight } = chartDimensionsRef.current;
   365→
   366→    // Check if mouse is within chart area
   367→    if (
   368→      mouseX >= padding.left &&
   369→      mouseX <= padding.left + chartWidth &&
   370→      mouseY >= padding.top &&
   371→      mouseY <= padding.top + chartHeight
   372→    ) {
   373→      // Convert mouse X to data value
   374→      const dataX = rangeMin + ((mouseX - padding.left) / chartWidth) * (rangeMax - rangeMin);
   375→      const dataScore = calculateScore(dataX);
   376→
   377→      setHover({
   378→        visible: true,
   379→        x: mouseX,
   380→        y: padding.top + (1 - dataScore / 10) * chartHeight,
   381→        value: dataX,
   382→        score: dataScore,
   383→      });
   384→    } else {
   385→      setHover(prev => ({ ...prev, visible: false }));
   386→    }
   387→  };
   388→
   389→  const handleMouseLeave = () => {
   390→    setHover(prev => ({ ...prev, visible: false }));
   391→  };
   392→
   393→  // Calculate the curve score (what the chart's formula gives for this value)
   394→  const curveScore = useMemo(() => calculateScore(value), [calculateScore, value]);
   395→
   396→  // Format value with unit
   397→  const formatWithUnit = (val: number): string => {
   398→    if (unit === 'percent' || unit === '%') {
   399→      return val.toFixed(1) + '%';
   400→    } else if (unit === 'degrees') {
   401→      return val.toFixed(1) + '°';
   402→    } else if (unit === 'mm') {
   403→      return val.toFixed(1) + 'mm';
   404→    }
   405→    return val.toFixed(2);
   406→  };
   407→
   408→  return (
   409→    <div className="rounded-xl bg-neutral-800/50 border border-neutral-700 p-4">
   410→      <div className="mb-3">
   411→        <div className="flex items-start justify-between">
   412→          <div>
   413→            <div className="flex items-center gap-1.5 mb-1">
   414→              <BarChart3 size={14} className="text-neutral-400" />
   415→              <span className="text-[10px] font-medium text-neutral-400 uppercase tracking-wider">
   416→                Scoring Methodology
   417→              </span>
   418→            </div>
   419→            <div className="text-[10px] text-neutral-500">Hover to explore the curve</div>
   420→          </div>
   421→          <div className="text-right bg-neutral-900/80 px-3 py-1.5 rounded-lg border border-neutral-700">
   422→            <div className="text-[10px] text-neutral-500 mb-0.5">Your Value</div>
   423→            <div className="text-xs font-medium" style={{ color: getColorForScore(curveScore) }}>
   424→              {formatWithUnit(value)} = {curveScore.toFixed(1)}/10
   425→            </div>
   426→          </div>
   427→        </div>
   428→      </div>
   429→      <div ref={containerRef} className="relative h-56 sm:h-64">
   430→        <canvas
   431→          ref={canvasRef}
   432→          className="w-full h-full cursor-crosshair"
   433→          style={{ display: 'block' }}
   434→          onMouseMove={handleMouseMove}
   435→          onMouseLeave={handleMouseLeave}
   436→        />
   437→
   438→        {/* Hover Tooltip */}
   439→        <AnimatePresence>
   440→          {hover.visible && (
   441→            <motion.div
   442→              initial={{ opacity: 0, scale: 0.9 }}
   443→              animate={{ opacity: 1, scale: 1 }}
   444→              exit={{ opacity: 0, scale: 0.9 }}
   445→              transition={{ duration: 0.1 }}
   446→              className="absolute pointer-events-none z-10"
   447→              style={{
   448→                left: hover.x,
   449→                top: hover.y - 50,
   450→                transform: 'translateX(-50%)',
   451→              }}
   452→            >
   453→              <div
   454→                className="px-3 py-2 rounded-lg shadow-xl border backdrop-blur-sm"
   455→                style={{
   456→                  backgroundColor: 'rgba(23, 23, 23, 0.95)',
   457→                  borderColor: getColorForScore(hover.score),
   458→                }}
   459→              >
   460→                <div className="text-[10px] text-neutral-400 mb-0.5">Value</div>
   461→                <div className="text-sm font-semibold text-white">
   462→                  {formatWithUnit(hover.value)}
   463→                </div>
   464→                <div className="mt-1 pt-1 border-t border-neutral-700">
   465→                  <div className="text-[10px] text-neutral-400 mb-0.5">Score</div>
   466→                  <div
   467→                    className="text-sm font-bold"
   468→                    style={{ color: getColorForScore(hover.score) }}
   469→                  >
   470→                    {hover.score.toFixed(1)}/10
   471→                  </div>
   472→                </div>
   473→              </div>
   474→              {/* Tooltip arrow */}
   475→              <div
   476→                className="absolute left-1/2 -translate-x-1/2 -bottom-1.5 w-3 h-3 rotate-45"
   477→                style={{
   478→                  backgroundColor: 'rgba(23, 23, 23, 0.95)',
   479→                  borderRight: `1px solid ${getColorForScore(hover.score)}`,
   480→                  borderBottom: `1px solid ${getColorForScore(hover.score)}`,
   481→                }}
   482→              />
   483→            </motion.div>
   484→          )}
   485→        </AnimatePresence>
   486→
   487→        {/* Hover vertical line indicator */}
   488→        {hover.visible && (
   489→          <div
   490→            className="absolute top-5 pointer-events-none"
   491→            style={{
   492→              left: hover.x,
   493→              height: chartDimensionsRef.current.chartHeight,
   494→              width: 1,
   495→              background: `linear-gradient(to bottom, ${getColorForScore(hover.score)}40, transparent)`,
   496→            }}
   497→          />
   498→        )}
   499→
   500→        {/* Hover point indicator */}
   501→        {hover.visible && (
   502→          <motion.div
   503→            initial={{ scale: 0 }}
   504→            animate={{ scale: 1 }}
   505→            className="absolute pointer-events-none"
   506→            style={{
   507→              left: hover.x - 5,
   508→              top: hover.y - 5,
   509→              width: 10,
   510→              height: 10,
   511→              borderRadius: '50%',
   512→              backgroundColor: getColorForScore(hover.score),
   513→              boxShadow: `0 0 10px ${getColorForScore(hover.score)}`,
   514→            }}
   515→          />
   516→        )}
   517→      </div>
   518→
   519→      {/* Legend - Responsive */}
   520→      <div className="mt-3 flex flex-wrap items-center justify-center gap-x-4 gap-y-2 text-[10px]">
   521→        <div className="flex items-center gap-1.5">
   522→          <div className="w-2.5 h-2.5 rounded-full bg-green-500" />
   523→          <span className="text-neutral-400">Ideal (9-10)</span>
   524→        </div>
   525→        <div className="flex items-center gap-1.5">
   526→          <div className="w-2.5 h-2.5 rounded-full bg-cyan-500" />
   527→          <span className="text-neutral-400">Good (7-9)</span>
   528→        </div>
   529→        <div className="flex items-center gap-1.5">
   530→          <div className="w-2.5 h-2.5 rounded-full bg-yellow-400" />
   531→          <span className="text-neutral-400">Average (5-7)</span>
   532→        </div>
   533→        <div className="flex items-center gap-1.5">
   534→          <div className="w-2.5 h-2.5 rounded-full bg-orange-500" />
   535→          <span className="text-neutral-400">Below (3-5)</span>
   536→        </div>
   537→        <div className="flex items-center gap-1.5">
   538→          <div className="w-2.5 h-2.5 rounded-full bg-red-500" />
   539→          <span className="text-neutral-400">Poor (1-3)</span>
   540→        </div>
   541→      </div>
   542→    </div>
   543→  );
   544→}
   545→
   546→// ============================================
   547→// ABOUT DESCRIPTIONS
   548→// ============================================
   549→
   550→// eslint-disable-next-line @typescript-eslint/no-unused-vars
   551→function getAboutDescription(name: string, category: string, gender?: Gender, ethnicity?: Ethnicity): string {
   552→  const descriptions: Record<string, string> = {
   553→    'Face Width to Height Ratio': 'Facial Width-to-Height Ratio evaluates midface compactness by comparing its width to height. Balanced proportions suit most faces; higher ratios (shorter midfaces) are preferred for males.',
   554→    'Lower Third': 'Facial thirds assess the vertical height of facial thirds relative to total facial height, favoring a balanced proportion with a slightly taller Lower Third in males.',
   555→    'Middle Third': 'The middle third spans from the brow line to the base of the nose. A balanced middle third contributes to overall facial harmony.',
   556→    'Upper Third': 'The upper third spans from the hairline to the brow line. Its proportion affects forehead prominence and hairline positioning.',
   557→    'Lateral Canthal Tilt': 'Canthal tilt measures the angle of the eye from inner to outer corner. A positive tilt (outer corner higher) is generally considered more attractive and youthful.',
   558→    'Gonial Angle': 'The gonial angle measures the angle at the jaw corner. A well-defined angle contributes to jaw prominence and facial structure.',
   559→    'Bigonial Width': 'Bigonial width measures the distance between the jaw angles. It contributes to the perception of jaw strength and facial width.',
   560→    'Eye Aspect Ratio': 'Eye aspect ratio compares eye height to width. Almond-shaped eyes with balanced proportions are often considered ideal.',
   561→    'Nasal Index': 'The nasal index compares nose width to height. Balanced proportions contribute to facial harmony.',
   562→    'Chin Philtrum Ratio': 'This ratio compares chin height to philtrum length. Proper balance contributes to lower face harmony.',
   563→    'Submental Cervical Angle': 'This angle measures the definition between chin and neck. A well-defined angle creates a clean jawline profile.',
   564→    'Nose Bridge Width': 'Compares nose bridge width to the overall nose width. Ideal proportions create a refined nasal appearance.',
   565→    'Eyebrow Tilt': 'Measures the angle of the eyebrows. Balanced tilt contributes to a harmonious eye region.',
   566→    'Brow Length Ratio': 'Compares eyebrow length to face width. Appropriately proportioned eyebrows create better facial framing.',
   567→  };
   568→
   569→  let baseDescription = descriptions[name] ||
   570→    `This measurement evaluates your ${category.toLowerCase()} proportions and contributes to overall facial harmony.`;
   571→
   572→  // Add gender-specific context if available
   573→  if (gender) {
   574→    const genderContext = gender === 'male'
   575→      ? ' Ideal ranges for males tend to favor more angular and defined features.'
   576→      : ' Ideal ranges for females tend to favor softer, more balanced proportions.';
   577→    baseDescription += genderContext;
   578→  }
   579→
   580→  return baseDescription;
   581→}
   582→
   583→// ============================================
   584→// MAIN MODAL COMPONENT
   585→// ============================================
   586→
   587→export function RatioDetailModal({
   588→  isOpen,
   589→  onClose,
   590→  ratio,
   591→  onPrevious,
   592→  onNext,
   593→  hasPrevious = false,
   594→  hasNext = false,
   595→  facePhoto,
   596→  gender,
   597→  ethnicity,
   598→}: RatioDetailModalProps) {
   599→  // Handle client-side mounting for portal
   600→  const [mounted, setMounted] = useState(false);
   601→
   602→  useEffect(() => {
   603→    setMounted(true);
   604→  }, []);
   605→
   606→  // Generate AI description from ratio data
   607→  const flawDetail = useMemo(() => {
   608→    if (!ratio) return null;
   609→
   610→    return generateAIDescription(
   611→      ratio.metricId.toLowerCase().replace(/\s+/g, ''),
   612→      ratio.name,
   613→      ratio.value,
   614→      ratio.idealMin,
   615→      ratio.idealMax,
   616→      ratio.score,
   617→      ratio.unit,
   618→      ratio.category
   619→    );
   620→  }, [ratio]);
   621→
   622→  // Early returns
   623→  if (!mounted) return null;
   624→  if (!ratio || !flawDetail) return null;
   625→
   626→  const scoreColor = getScoreColor(ratio.score);
   627→  const isWithinIdeal = ratio.value >= ratio.idealMin && ratio.value <= ratio.idealMax;
   628→  const severity = getSeverityFromScore(ratio.score);
   629→
   630→  // Get metric config for decay rate
   631→  const metricConfig = FACEIQ_METRICS[ratio.metricId];
   632→  const decayRate = metricConfig?.decayRate || 4;
   633→
   634→  // Format values with units
   635→  const formatUnit = (v: number) => {
   636→    const formatted = v.toFixed(ratio.unit === 'percent' ? 1 : 2);
   637→    let suffix = '';
   638→    switch (ratio.unit) {
   639→      case 'percent':
   640→        suffix = ' %';
   641→        break;
   642→      case 'degrees':
   643→        suffix = '\u00B0';
   644→        break;
   645→      case 'mm':
   646→        suffix = ' mm';
   647→        break;
   648→      case 'ratio':
   649→      default:
   650→        suffix = '';
   651→    }
   652→    return `${formatted}${suffix}`;
   653→  };
   654→
   655→  // Calculate range for visualization
   656→  const idealRange = ratio.idealMax - ratio.idealMin;
   657→  const rangeMin = ratio.idealMin - idealRange * 1.5;
   658→  const rangeMax = ratio.idealMax + idealRange * 1.5;
   659→
   660→  // Use portal to render modal at document body level
   661→  const modalContent = (
   662→    <AnimatePresence>
   663→      {isOpen && (
   664→        <>
   665→          {/* Backdrop */}
   666→          <motion.div
   667→            initial={{ opacity: 0 }}
   668→            animate={{ opacity: 1 }}
   669→            exit={{ opacity: 0 }}
   670→            onClick={onClose}
   671→            className="fixed inset-0 bg-black/80 backdrop-blur-sm z-[9998]"
   672→          />
   673→
   674→          {/* Navigation Arrows - Desktop */}
   675→          {hasPrevious && onPrevious && (
   676→            <motion.button
   677→              initial={{ opacity: 0, x: -10 }}
   678→              animate={{ opacity: 1, x: 0 }}
   679→              exit={{ opacity: 0, x: -10 }}
   680→              onClick={onPrevious}
   681→              className="hidden lg:flex fixed left-4 xl:left-8 top-1/2 -translate-y-1/2 z-[10001] w-12 h-12 rounded-full bg-neutral-800 border border-neutral-600 shadow-xl hover:bg-neutral-700 hover:border-neutral-500 transition-all items-center justify-center group"
   682→              aria-label="Previous measurement"
   683→            >
   684→              <ChevronLeft className="w-6 h-6 text-neutral-300 group-hover:text-white" />
   685→            </motion.button>
   686→          )}
   687→
   688→          {hasNext && onNext && (
   689→            <motion.button
   690→              initial={{ opacity: 0, x: 10 }}
   691→              animate={{ opacity: 1, x: 0 }}
   692→              exit={{ opacity: 0, x: 10 }}
   693→              onClick={onNext}
   694→              className="hidden lg:flex fixed right-4 xl:right-8 top-1/2 -translate-y-1/2 z-[10001] w-12 h-12 rounded-full bg-neutral-800 border border-neutral-600 shadow-xl hover:bg-neutral-700 hover:border-neutral-500 transition-all items-center justify-center group"
   695→              aria-label="Next measurement"
   696→            >
   697→              <ChevronRight className="w-6 h-6 text-neutral-300 group-hover:text-white" />
   698→            </motion.button>
   699→          )}
   700→
   701→          {/* Modal Container - Full screen flex centering */}
   702→          <div className="fixed inset-0 z-[9999] flex items-center justify-center p-4 pointer-events-none">
   703→            <motion.div
   704→              initial={{ opacity: 0, scale: 0.95, y: 20 }}
   705→              animate={{ opacity: 1, scale: 1, y: 0 }}
   706→              exit={{ opacity: 0, scale: 0.95, y: 20 }}
   707→              transition={{ type: 'spring', damping: 25, stiffness: 300 }}
   708→              className="relative w-full max-w-5xl max-h-[90vh] overflow-hidden bg-neutral-900 border border-neutral-700 rounded-2xl shadow-2xl pointer-events-auto"
   709→            >
   710→            {/* Header */}
   711→            <div className="sticky top-0 bg-neutral-900/95 backdrop-blur-sm border-b border-neutral-800 px-4 py-4 md:px-6 z-10">
   712→              <div className="flex items-center justify-between">
   713→                <div className="flex items-center gap-3 flex-1 min-w-0">
   714→                  {/* Mobile nav */}
   715→                  {hasPrevious && onPrevious && (
   716→                    <button
   717→                      onClick={onPrevious}
   718→                      className="lg:hidden flex-shrink-0 p-1.5 rounded-lg hover:bg-neutral-800 transition-colors text-neutral-400"
   719→                      aria-label="Previous measurement"
   720→                    >
   721→                      <ChevronLeft className="w-5 h-5" />
   722→                    </button>
   723→                  )}
   724→
   725→                  <h2 className="text-lg md:text-xl font-semibold text-white truncate">
   726→                    {ratio.name}
   727→                  </h2>
   728→
   729→                  {hasNext && onNext && (
   730→                    <button
   731→                      onClick={onNext}
   732→                      className="lg:hidden flex-shrink-0 p-1.5 rounded-lg hover:bg-neutral-800 transition-colors text-neutral-400"
   733→                      aria-label="Next measurement"
   734→                    >
   735→                      <ChevronRight className="w-5 h-5" />
   736→                    </button>
   737→                  )}
   738→                </div>
   739→
   740→                <button
   741→                  onClick={onClose}
   742→                  className="flex-shrink-0 ml-4 p-2 rounded-lg hover:bg-neutral-800 transition-colors text-neutral-400 hover:text-white"
   743→                >
   744→                  <X className="w-5 h-5" />
   745→                </button>
   746→              </div>
   747→            </div>
   748→
   749→            {/* Content */}
   750→            <div className="p-4 md:p-6 space-y-4 overflow-y-auto max-h-[calc(90vh-72px)]">
   751→              {/* Stats Grid */}
   752→              <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
   753→                <StatCard
   754→                  label="Your Value"
   755→                  value={formatUnit(ratio.value)}
   756→                  subtext={isWithinIdeal ? 'Within ideal' : 'Outside ideal'}
   757→                  variant="default"
   758→                  subtextColor={isWithinIdeal ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)'}
   759→                />
   760→                <StatCard
   761→                  label="Ideal Range"
   762→                  value={`${formatUnit(ratio.idealMin)} - ${formatUnit(ratio.idealMax)}`}
   763→                  subtext="Target range"
   764→                  variant="ideal"
   765→                />
   766→                <StatCard
   767→                  label="Score"
   768→                  value={`${ratio.score.toFixed(2)}/10`}
   769→                  subtext="Normalized score (1-10)"
   770→                  variant="score"
   771→                  scoreColor={scoreColor}
   772→                />
   773→              </div>
   774→
   775→              {/* Gradient Range Bar */}
   776→              <GradientRangeBar
   777→                value={ratio.value}
   778→                idealMin={ratio.idealMin}
   779→                idealMax={ratio.idealMax}
   780→                rangeMin={rangeMin}
   781→                rangeMax={rangeMax}
   782→                unit={ratio.unit}
   783→              />
   784→
   785→              {/* Two Column Layout */}
   786→              <div className="grid lg:grid-cols-2 gap-4">
   787→                {/* Face Image (if available) */}
   788→                {facePhoto && (
   789→                  <div>
   790→                    <div className="relative rounded-xl overflow-hidden border border-neutral-700 bg-neutral-800">
   791→                      <div className="relative w-full" style={{ aspectRatio: '1/1' }}>
   792→                        <img
   793→                          src={facePhoto}
   794→                          alt="Face"
   795→                          className="w-full h-full object-contain"
   796→                        />
   797→                      </div>
   798→                    </div>
   799→                  </div>
   800→                )}
   801→
   802→                {/* Info Sections */}
   803→                <div className={`space-y-4 ${!facePhoto ? 'lg:col-span-2' : ''}`}>
   804→                  {/* May Indicate Strengths - Only show if score is >= 7 */}
   805→                  {ratio.score >= 7 && (
   806→                    <div className="rounded-xl bg-cyan-500/10 border border-cyan-500/30 p-4">
   807→                      <div className="flex items-center gap-2 mb-3">
   808→                        <Sparkles size={14} className="text-cyan-400" />
   809→                        <span className="text-[10px] font-medium text-cyan-400 uppercase tracking-wider">
   810→                          May Indicate Strengths
   811→                        </span>
   812→                      </div>
   813→                      <div className="space-y-3">
   814→                        <div className="pb-3 last:border-0 last:pb-0">
   815→                          <div className="text-sm font-semibold text-white mb-1">
   816→                            {ratio.score >= 9 ? 'Ideal ' : 'Good '}{ratio.name.toLowerCase()}
   817→                          </div>
   818→                          <div className="text-xs text-neutral-300 leading-relaxed">
   819→                            The {ratio.name} measurement is {isWithinIdeal ? 'within' : 'close to'} the ideal range.
   820→                            This contributes to a harmonious {ratio.category.toLowerCase()} appearance.
   821→                          </div>
   822→                        </div>
   823→                      </div>
   824→                    </div>
   825→                  )}
   826→
   827→                  {/* May Indicate Flaws - Only show if score is below 7 */}
   828→                  {ratio.score < 7 && (
   829→                    <div className="rounded-xl bg-amber-500/10 border border-amber-500/30 p-4">
   830→                      <div className="flex items-center gap-2 mb-3">
   831→                        <AlertTriangle size={14} className="text-amber-400" />
   832→                        <span className="text-[10px] font-medium text-amber-400 uppercase tracking-wider">
   833→                          May Indicate Flaws
   834→                        </span>
   835→                      </div>
   836→                      <div className="space-y-3">
   837→                        <div className="pb-3 last:border-0 last:pb-0">
   838→                          <div className="text-sm font-semibold text-white mb-1">
   839→                            {flawDetail.flawName}
   840→                          </div>
   841→                          <div className="text-xs text-neutral-300 leading-relaxed">
   842→                            {flawDetail.reasoning}
   843→                          </div>
   844→                        </div>
   845→                      </div>
   846→                    </div>
   847→                  )}
   848→
   849→                  {/* About This Ratio */}
   850→                  <div className="rounded-xl bg-neutral-800/50 border border-neutral-700 p-4">
   851→                    <div className="flex items-center gap-2 mb-3">
   852→                      <Info size={14} className="text-neutral-400" />
   853→                      <span className="text-[10px] font-medium text-neutral-400 uppercase tracking-wider">
   854→                        About This Ratio
   855→                      </span>
   856→                    </div>
   857→                    <div className="text-sm text-neutral-300 leading-relaxed">
   858→                      {getAboutDescription(ratio.name, ratio.category, gender, ethnicity)}
   859→                    </div>
   860→                  </div>
   861→
   862→                  {/* Scoring Methodology Chart */}
   863→                  <ScoringMethodologyChart
   864→                    value={ratio.value}
   865→                    score={ratio.score}
   866→                    idealMin={ratio.idealMin}
   867→                    idealMax={ratio.idealMax}
   868→                    rangeMin={rangeMin}
   869→                    rangeMax={rangeMax}
   870→                    unit={ratio.unit}
   871→                    decayRate={decayRate}
   872→                  />
   873→
   874→                  {/* Category Badge */}
   875→                  <div className="flex flex-wrap items-center gap-2">
   876→                    <span className="px-3 py-1.5 rounded-lg bg-neutral-800 border border-neutral-700 text-xs font-medium text-neutral-300">
   877→                      {ratio.category}
   878→                    </span>
   879→                    <span
   880→                      className="px-3 py-1.5 rounded-lg text-xs font-medium capitalize"
   881→                      style={{
   882→                        backgroundColor: `${scoreColor}20`,
   883→                        color: scoreColor,
   884→                        border: `1px solid ${scoreColor}40`,
   885→                      }}
   886→                    >
   887→                      {severity.replace('_', ' ')}
   888→                    </span>
   889→                    {gender && (
   890→                      <span className="px-3 py-1.5 rounded-lg bg-neutral-800 border border-neutral-700 text-xs font-medium text-neutral-300 capitalize">
   891→                        {gender}
   892→                      </span>
   893→                    )}
   894→                    {ethnicity && ethnicity !== 'other' && (
   895→                      <span className="px-3 py-1.5 rounded-lg bg-neutral-800 border border-neutral-700 text-xs font-medium text-neutral-300 capitalize">
   896→                        {ethnicity.replace('_', ' ')}
   897→                      </span>
   898→                    )}
   899→                  </div>
   900→                </div>
   901→              </div>
   902→            </div>
   903→            </motion.div>
   904→          </div>
   905→        </>
   906→      )}
   907→    </AnimatePresence>
   908→  );
   909→
   910→  return createPortal(modalContent, document.body);
   911→}
   912→
   913→export default RatioDetailModal;
   914→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
