     1→'use client';
     2→
     3→import { useMemo } from 'react';
     4→import { motion, AnimatePresence } from 'framer-motion';
     5→import { Eye, ZoomIn, ZoomOut } from 'lucide-react';
     6→import { LandmarkPoint } from '@/lib/landmarks';
     7→import { Ratio, getScoreColor, getCategoryColor } from '@/types/results';
     8→
     9→interface FaceOverlayProps {
    10→  photo: string;
    11→  landmarks: LandmarkPoint[];
    12→  selectedRatio: Ratio | null;
    13→  profileType: 'front' | 'side';
    14→  showAllLandmarks?: boolean;
    15→}
    16→
    17→export function FaceOverlay({
    18→  photo,
    19→  landmarks,
    20→  selectedRatio,
    21→  profileType,
    22→  showAllLandmarks = false,
    23→}: FaceOverlayProps) {
    24→  // Get landmark positions by ID
    25→  const landmarkMap = useMemo(() => {
    26→    const map: Record<string, LandmarkPoint> = {};
    27→    landmarks.forEach(l => {
    28→      map[l.id] = l;
    29→    });
    30→    return map;
    31→  }, [landmarks]);
    32→
    33→  // Get lines and points to draw for selected ratio
    34→  const visualizationData = useMemo(() => {
    35→    if (!selectedRatio?.illustration) return null;
    36→
    37→    const points: Array<{ x: number; y: number; id: string; label?: string }> = [];
    38→    const lines: Array<{ x1: number; y1: number; x2: number; y2: number; color: string }> = [];
    39→
    40→    // Process points
    41→    Object.entries(selectedRatio.illustration.points).forEach(([key, point]) => {
    42→      if (point.type === 'landmark' && point.landmarkId) {
    43→        const landmark = landmarkMap[point.landmarkId];
    44→        if (landmark) {
    45→          points.push({
    46→            x: landmark.x * 100,
    47→            y: landmark.y * 100,
    48→            id: point.landmarkId,
    49→            label: landmark.label,
    50→          });
    51→        }
    52→      } else if (point.x !== undefined && point.y !== undefined) {
    53→        points.push({
    54→          x: point.x * 100,
    55→          y: point.y * 100,
    56→          id: key,
    57→          label: point.label,
    58→        });
    59→      }
    60→    });
    61→
    62→    // Process lines
    63→    Object.entries(selectedRatio.illustration.lines).forEach(([, line]) => {
    64→      const fromLandmark = landmarkMap[line.from];
    65→      const toLandmark = landmarkMap[line.to];
    66→
    67→      if (fromLandmark && toLandmark) {
    68→        lines.push({
    69→          x1: fromLandmark.x * 100,
    70→          y1: fromLandmark.y * 100,
    71→          x2: toLandmark.x * 100,
    72→          y2: toLandmark.y * 100,
    73→          color: line.color || getCategoryColor(selectedRatio.category),
    74→        });
    75→      }
    76→    });
    77→
    78→    return { points, lines };
    79→  }, [selectedRatio, landmarkMap]);
    80→
    81→  return (
    82→    <div className="bg-neutral-900/80 border border-neutral-800 rounded-xl overflow-hidden">
    83→      {/* Header */}
    84→      <div className="p-3 border-b border-neutral-800 flex items-center justify-between">
    85→        <h4 className="text-sm font-medium text-white">
    86→          {profileType === 'front' ? 'Front' : 'Side'} Profile
    87→        </h4>
    88→        <div className="flex items-center gap-2">
    89→          <button className="p-1.5 hover:bg-neutral-800 rounded transition-colors">
    90→            <ZoomIn size={16} className="text-neutral-500" />
    91→          </button>
    92→          <button className="p-1.5 hover:bg-neutral-800 rounded transition-colors">
    93→            <ZoomOut size={16} className="text-neutral-500" />
    94→          </button>
    95→        </div>
    96→      </div>
    97→
    98→      {/* Image container */}
    99→      <div className="relative aspect-[3/4] bg-neutral-950">
   100→        {/* Photo */}
   101→        <img
   102→          src={photo}
   103→          alt={`${profileType} profile`}
   104→          className="w-full h-full object-cover"
   105→        />
   106→
   107→        {/* SVG Overlay */}
   108→        <svg
   109→          className="absolute inset-0 w-full h-full"
   110→          viewBox="0 0 100 100"
   111→          preserveAspectRatio="none"
   112→        >
   113→          {/* All landmarks (optional) */}
   114→          {showAllLandmarks && landmarks.map((landmark) => (
   115→            <circle
   116→              key={landmark.id}
   117→              cx={landmark.x * 100}
   118→              cy={landmark.y * 100}
   119→              r="0.5"
   120→              fill="#67e8f9"
   121→              opacity="0.3"
   122→            />
   123→          ))}
   124→
   125→          {/* Selected ratio visualization */}
   126→          <AnimatePresence>
   127→            {visualizationData && (
   128→              <g>
   129→                {/* Lines */}
   130→                {visualizationData.lines.map((line, i) => (
   131→                  <motion.line
   132→                    key={`line-${i}`}
   133→                    x1={line.x1}
   134→                    y1={line.y1}
   135→                    x2={line.x2}
   136→                    y2={line.y2}
   137→                    stroke={line.color}
   138→                    strokeWidth="0.4"
   139→                    strokeLinecap="round"
   140→                    initial={{ pathLength: 0, opacity: 0 }}
   141→                    animate={{ pathLength: 1, opacity: 1 }}
   142→                    exit={{ pathLength: 0, opacity: 0 }}
   143→                    transition={{ duration: 0.5 }}
   144→                  />
   145→                ))}
   146→
   147→                {/* Points */}
   148→                {visualizationData.points.map((point, i) => (
   149→                  <motion.g
   150→                    key={`point-${i}`}
   151→                    initial={{ scale: 0, opacity: 0 }}
   152→                    animate={{ scale: 1, opacity: 1 }}
   153→                    exit={{ scale: 0, opacity: 0 }}
   154→                    transition={{ duration: 0.3, delay: i * 0.1 }}
   155→                  >
   156→                    {/* Outer glow */}
   157→                    <circle
   158→                      cx={point.x}
   159→                      cy={point.y}
   160→                      r="1.5"
   161→                      fill={getCategoryColor(selectedRatio?.category || '')}
   162→                      opacity="0.3"
   163→                    />
   164→                    {/* Inner dot */}
   165→                    <circle
   166→                      cx={point.x}
   167→                      cy={point.y}
   168→                      r="0.8"
   169→                      fill="#fff"
   170→                      stroke={getCategoryColor(selectedRatio?.category || '')}
   171→                      strokeWidth="0.2"
   172→                    />
   173→                  </motion.g>
   174→                ))}
   175→              </g>
   176→            )}
   177→          </AnimatePresence>
   178→        </svg>
   179→
   180→        {/* No selection message */}
   181→        {!selectedRatio && (
   182→          <div className="absolute inset-0 flex items-center justify-center bg-black/40">
   183→            <div className="text-center p-4">
   184→              <Eye size={32} className="mx-auto text-neutral-600 mb-2" />
   185→              <p className="text-sm text-neutral-500">
   186→                Expand a measurement card<br />to see it visualized here
   187→              </p>
   188→            </div>
   189→          </div>
   190→        )}
   191→      </div>
   192→
   193→      {/* Selected ratio info */}
   194→      {selectedRatio && (
   195→        <motion.div
   196→          className="p-3 border-t border-neutral-800"
   197→          initial={{ opacity: 0, y: 10 }}
   198→          animate={{ opacity: 1, y: 0 }}
   199→        >
   200→          <div className="flex items-center justify-between">
   201→            <div>
   202→              <h5 className="text-sm font-medium text-white">{selectedRatio.name}</h5>
   203→              <p className="text-xs text-neutral-500">{selectedRatio.category}</p>
   204→            </div>
   205→            <div
   206→              className="px-2 py-1 rounded text-sm font-bold"
   207→              style={{
   208→                backgroundColor: `${getScoreColor(selectedRatio.score)}15`,
   209→                color: getScoreColor(selectedRatio.score),
   210→              }}
   211→            >
   212→              {selectedRatio.score.toFixed(1)}
   213→            </div>
   214→          </div>
   215→
   216→          {/* Landmarks used */}
   217→          {selectedRatio.usedLandmarks.length > 0 && (
   218→            <div className="mt-2">
   219→              <p className="text-xs text-neutral-500 mb-1">Landmarks used:</p>
   220→              <div className="flex flex-wrap gap-1">
   221→                {selectedRatio.usedLandmarks.slice(0, 4).map(id => {
   222→                  const landmark = landmarkMap[id];
   223→                  return (
   224→                    <span
   225→                      key={id}
   226→                      className="px-1.5 py-0.5 bg-neutral-800 rounded text-[10px] text-neutral-400"
   227→                    >
   228→                      {landmark?.label || id}
   229→                    </span>
   230→                  );
   231→                })}
   232→                {selectedRatio.usedLandmarks.length > 4 && (
   233→                  <span className="px-1.5 py-0.5 text-[10px] text-neutral-500">
   234→                    +{selectedRatio.usedLandmarks.length - 4} more
   235→                  </span>
   236→                )}
   237→              </div>
   238→            </div>
   239→          )}
   240→        </motion.div>
   241→      )}
   242→    </div>
   243→  );
   244→}
   245→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
