     1→# FaceIQ Labs Rebuild Plan
     2→
     3→## Architecture Overview
     4→
     5→```
     6→┌─────────────────────────────────────────────────────────────────┐
     7→│                         FRONTEND                                 │
     8→│  Next.js 14+ App Router                                         │
     9→│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │
    10→│  │   Auth      │  │  Dashboard  │  │  Analysis   │              │
    11→│  │  (NextAuth) │  │   Pages     │  │   Views     │              │
    12→│  └─────────────┘  └─────────────┘  └─────────────┘              │
    13→│         │                │                │                      │
    14→│  ┌──────┴────────────────┴────────────────┴──────┐              │
    15→│  │              MediaPipe Integration             │              │
    16→│  │  - FaceLandmarker (478 points front)          │              │
    17→│  │  - Side profile detection (106 points)         │              │
    18→│  └───────────────────────────────────────────────┘              │
    19→│         │                                                        │
    20→│  ┌──────┴──────────────────────────────────────┐                │
    21→│  │         Landmark Editor Canvas               │                │
    22→│  │  - Auto-detect overlay                       │                │
    23→│  │  - Draggable points                          │                │
    24→│  │  - Zoom/Pan controls                         │                │
    25→│  └──────────────────────────────────────────────┘                │
    26→└─────────────────────────────────────────────────────────────────┘
    27→                              │
    28→                              ▼
    29→┌─────────────────────────────────────────────────────────────────┐
    30→│                         BACKEND                                  │
    31→│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │
    32→│  │  /api/faces │  │ /api/side-  │  │ /api/sub-   │              │
    33→│  │   CRUD      │  │  landmarks  │  │  scription  │              │
    34→│  └─────────────┘  └─────────────┘  └─────────────┘              │
    35→│         │                │                │                      │
    36→│  ┌──────┴────────────────┴────────────────┴──────┐              │
    37→│  │              Calculation Engine               │              │
    38→│  │  - Facial ratios (FWHR, golden ratio)        │              │
    39→│  │  - Angles (nasolabial, gonial, canthal)      │              │
    40→│  │  - Symmetry scores                            │              │
    41→│  └───────────────────────────────────────────────┘              │
    42→└─────────────────────────────────────────────────────────────────┘
    43→                              │
    44→                              ▼
    45→┌─────────────────────────────────────────────────────────────────┐
    46→│                        DATABASE                                  │
    47→│  Prisma + PostgreSQL (or PlanetScale)                           │
    48→│  - Users, Faces, Landmarks, Measurements, Subscriptions         │
    49→└─────────────────────────────────────────────────────────────────┘
    50→```
    51→
    52→---
    53→
    54→## Phase 1: Project Setup
    55→
    56→### 1.1 Initialize Project
    57→```bash
    58→npx create-next-app@latest faceiq-clone --typescript --tailwind --app --src-dir
    59→cd faceiq-clone
    60→
    61→# Install dependencies
    62→npm install @mediapipe/tasks-vision
    63→npm install next-auth @auth/prisma-adapter
    64→npm install @vercel/blob
    65→npm install prisma @prisma/client
    66→npm install framer-motion  # For smooth animations
    67→npm install zustand        # State management
    68→npm install react-zoom-pan-pinch  # For image zoom/pan
    69→```
    70→
    71→### 1.2 Database Schema (prisma/schema.prisma)
    72→```prisma
    73→generator client {
    74→  provider = "prisma-client-js"
    75→}
    76→
    77→datasource db {
    78→  provider = "postgresql"
    79→  url      = env("DATABASE_URL")
    80→}
    81→
    82→model User {
    83→  id            String    @id @default(cuid())
    84→  email         String    @unique
    85→  name          String?
    86→  image         String?
    87→  createdAt     DateTime  @default(now())
    88→  faces         Face[]
    89→  subscription  Subscription?
    90→}
    91→
    92→model Face {
    93→  id              String    @id @default(cuid())
    94→  userId          String
    95→  user            User      @relation(fields: [userId], references: [id])
    96→
    97→  // Images
    98→  frontUrl        String?
    99→  sideUrl         String?
   100→
   101→  // Raw landmarks from MediaPipe
   102→  frontLandmarks  Json?     // Array of {x, y, z?} - 478 points
   103→  sideLandmarks   Json?     // Array of {x, y} - 106 points
   104→
   105→  // User-adjusted landmarks (after manual correction)
   106→  adjustedFrontLandmarks  Json?
   107→  adjustedSideLandmarks   Json?
   108→
   109→  // Calculated measurements
   110→  measurements    Json?     // All facial ratios and angles
   111→
   112→  // Metadata
   113→  createdAt       DateTime  @default(now())
   114→  updatedAt       DateTime  @updatedAt
   115→  status          FaceStatus @default(PENDING)
   116→}
   117→
   118→enum FaceStatus {
   119→  PENDING
   120→  FRONT_UPLOADED
   121→  FRONT_ANALYZED
   122→  SIDE_UPLOADED
   123→  SIDE_ANALYZED
   124→  COMPLETE
   125→}
   126→
   127→model Subscription {
   128→  id        String   @id @default(cuid())
   129→  userId    String   @unique
   130→  user      User     @relation(fields: [userId], references: [id])
   131→  plan      Plan     @default(FREE)
   132→  expiresAt DateTime?
   133→}
   134→
   135→enum Plan {
   136→  FREE
   137→  PRO
   138→  PREMIUM
   139→}
   140→```
   141→
   142→---
   143→
   144→## Phase 2: MediaPipe Integration
   145→
   146→### 2.1 Create MediaPipe Hook (src/hooks/useFaceLandmarker.ts)
   147→```typescript
   148→import { useEffect, useRef, useState } from 'react';
   149→import { FaceLandmarker, FilesetResolver, DrawingUtils } from '@mediapipe/tasks-vision';
   150→
   151→interface Landmark {
   152→  x: number;
   153→  y: number;
   154→  z?: number;
   155→}
   156→
   157→export function useFaceLandmarker() {
   158→  const [landmarker, setLandmarker] = useState<FaceLandmarker | null>(null);
   159→  const [isLoading, setIsLoading] = useState(true);
   160→  const [error, setError] = useState<Error | null>(null);
   161→
   162→  useEffect(() => {
   163→    async function initLandmarker() {
   164→      try {
   165→        const vision = await FilesetResolver.forVisionTasks(
   166→          'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'
   167→        );
   168→
   169→        const faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
   170→          baseOptions: {
   171→            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
   172→            delegate: 'GPU'
   173→          },
   174→          runningMode: 'IMAGE',
   175→          numFaces: 1,
   176→          outputFacialTransformationMatrixes: true,
   177→          outputFaceBlendshapes: true
   178→        });
   179→
   180→        setLandmarker(faceLandmarker);
   181→        setIsLoading(false);
   182→      } catch (err) {
   183→        setError(err as Error);
   184→        setIsLoading(false);
   185→      }
   186→    }
   187→
   188→    initLandmarker();
   189→  }, []);
   190→
   191→  const detectLandmarks = async (imageElement: HTMLImageElement): Promise<Landmark[]> => {
   192→    if (!landmarker) throw new Error('Landmarker not initialized');
   193→
   194→    const result = landmarker.detect(imageElement);
   195→
   196→    if (result.faceLandmarks.length === 0) {
   197→      throw new Error('No face detected');
   198→    }
   199→
   200→    // Convert normalized coordinates to pixel coordinates
   201→    const landmarks = result.faceLandmarks[0].map(point => ({
   202→      x: point.x * imageElement.width,
   203→      y: point.y * imageElement.height,
   204→      z: point.z
   205→    }));
   206→
   207→    return landmarks;
   208→  };
   209→
   210→  return { detectLandmarks, isLoading, error };
   211→}
   212→```
   213→
   214→### 2.2 Key Landmark Indices (src/lib/landmarks.ts)
   215→```typescript
   216→// MediaPipe Face Landmarker - 478 points
   217→// These are the key indices for facial measurements
   218→
   219→export const FRONT_LANDMARKS = {
   220→  // Face oval (silhouette)
   221→  faceOval: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109],
   222→
   223→  // Eyes
   224→  leftEye: {
   225→    outer: 33,
   226→    inner: 133,
   227→    top: 159,
   228→    bottom: 145,
   229→    center: 468  // iris center
   230→  },
   231→  rightEye: {
   232→    outer: 263,
   233→    inner: 362,
   234→    top: 386,
   235→    bottom: 374,
   236→    center: 473  // iris center
   237→  },
   238→
   239→  // Eyebrows
   240→  leftEyebrow: [70, 63, 105, 66, 107],
   241→  rightEyebrow: [300, 293, 334, 296, 336],
   242→
   243→  // Nose
   244→  nose: {
   245→    tip: 4,
   246→    bridge: 6,
   247→    leftAla: 129,
   248→    rightAla: 358,
   249→    base: 2
   250→  },
   251→
   252→  // Lips
   253→  lips: {
   254→    upperTop: 13,
   255→    upperBottom: 14,
   256→    lowerTop: 17,
   257→    lowerBottom: 0,
   258→    leftCorner: 61,
   259→    rightCorner: 291
   260→  },
   261→
   262→  // Face structure
   263→  structure: {
   264→    chin: 152,
   265→    leftCheekbone: 234,
   266→    rightCheekbone: 454,
   267→    leftJaw: 172,
   268→    rightJaw: 397,
   269→    forehead: 10,
   270→    glabella: 9  // between eyebrows
   271→  }
   272→};
   273→
   274→// Side profile landmarks (from their API - 106 points)
   275→export const SIDE_LANDMARKS = {
   276→  forehead: { start: 0, end: 15 },
   277→  nasion: 16,           // bridge of nose between eyes
   278→  noseBridge: { start: 17, end: 25 },
   279→  pronasale: 30,        // tip of nose
   280→  subnasale: 35,        // base of nose
   281→  upperLip: { start: 40, end: 50 },
   282→  lowerLip: { start: 51, end: 60 },
   283→  pogonion: 65,         // most anterior point of chin
   284→  menton: 70,           // lowest point of chin
   285→  gonion: 85,           // angle of jaw
   286→  tragus: 95            // ear reference point
   287→};
   288→```
   289→
   290→---
   291→
   292→## Phase 3: Landmark Editor Component
   293→
   294→### 3.1 The Core Editor (src/components/LandmarkEditor.tsx)
   295→```typescript
   296→'use client';
   297→
   298→import { useState, useRef, useCallback, useEffect } from 'react';
   299→import { TransformWrapper, TransformComponent } from 'react-zoom-pan-pinch';
   300→
   301→interface Point {
   302→  x: number;
   303→  y: number;
   304→  id: number;
   305→}
   306→
   307→interface LandmarkEditorProps {
   308→  imageUrl: string;
   309→  landmarks: Point[];
   310→  onLandmarksChange: (landmarks: Point[]) => void;
   311→  editableIndices?: number[];  // Which landmarks can be edited
   312→}
   313→
   314→export function LandmarkEditor({
   315→  imageUrl,
   316→  landmarks,
   317→  onLandmarksChange,
   318→  editableIndices
   319→}: LandmarkEditorProps) {
   320→  const [selectedPoint, setSelectedPoint] = useState<number | null>(null);
   321→  const [isDragging, setIsDragging] = useState(false);
   322→  const containerRef = useRef<HTMLDivElement>(null);
   323→  const imageRef = useRef<HTMLImageElement>(null);
   324→
   325→  const isEditable = (index: number) => {
   326→    if (!editableIndices) return true;
   327→    return editableIndices.includes(index);
   328→  };
   329→
   330→  const handlePointMouseDown = (index: number, e: React.MouseEvent) => {
   331→    if (!isEditable(index)) return;
   332→    e.stopPropagation();
   333→    setSelectedPoint(index);
   334→    setIsDragging(true);
   335→  };
   336→
   337→  const handleMouseMove = useCallback((e: React.MouseEvent) => {
   338→    if (!isDragging || selectedPoint === null || !containerRef.current) return;
   339→
   340→    const rect = containerRef.current.getBoundingClientRect();
   341→    const x = e.clientX - rect.left;
   342→    const y = e.clientY - rect.top;
   343→
   344→    const newLandmarks = [...landmarks];
   345→    newLandmarks[selectedPoint] = { ...newLandmarks[selectedPoint], x, y };
   346→    onLandmarksChange(newLandmarks);
   347→  }, [isDragging, selectedPoint, landmarks, onLandmarksChange]);
   348→
   349→  const handleMouseUp = useCallback(() => {
   350→    setIsDragging(false);
   351→    setSelectedPoint(null);
   352→  }, []);
   353→
   354→  // Key landmark groups for visualization
   355→  const landmarkGroups = {
   356→    eyes: [33, 133, 362, 263, 468, 473],
   357→    nose: [4, 6, 2, 129, 358],
   358→    lips: [13, 14, 61, 291],
   359→    jaw: [152, 172, 397, 234, 454]
   360→  };
   361→
   362→  const getPointColor = (index: number) => {
   363→    if (landmarkGroups.eyes.includes(index)) return '#3B82F6';  // blue
   364→    if (landmarkGroups.nose.includes(index)) return '#10B981';  // green
   365→    if (landmarkGroups.lips.includes(index)) return '#EF4444';  // red
   366→    if (landmarkGroups.jaw.includes(index)) return '#F59E0B';   // amber
   367→    return '#6B7280';  // gray
   368→  };
   369→
   370→  return (
   371→    <div className="relative w-full h-full bg-gray-900 rounded-lg overflow-hidden">
   372→      <TransformWrapper
   373→        disabled={isDragging}
   374→        minScale={0.5}
   375→        maxScale={4}
   376→        centerOnInit
   377→      >
   378→        {({ zoomIn, zoomOut, resetTransform }) => (
   379→          <>
   380→            {/* Controls */}
   381→            <div className="absolute top-4 right-4 z-10 flex gap-2">
   382→              <button
   383→                onClick={() => zoomIn()}
   384→                className="p-2 bg-white/10 rounded-lg hover:bg-white/20"
   385→              >
   386→                +
   387→              </button>
   388→              <button
   389→                onClick={() => zoomOut()}
   390→                className="p-2 bg-white/10 rounded-lg hover:bg-white/20"
   391→              >
   392→                -
   393→              </button>
   394→              <button
   395→                onClick={() => resetTransform()}
   396→                className="p-2 bg-white/10 rounded-lg hover:bg-white/20"
   397→              >
   398→                Reset
   399→              </button>
   400→            </div>
   401→
   402→            <TransformComponent>
   403→              <div
   404→                ref={containerRef}
   405→                className="relative"
   406→                onMouseMove={handleMouseMove}
   407→                onMouseUp={handleMouseUp}
   408→                onMouseLeave={handleMouseUp}
   409→              >
   410→                {/* Face Image */}
   411→                <img
   412→                  ref={imageRef}
   413→                  src={imageUrl}
   414→                  alt="Face"
   415→                  className="max-w-full h-auto"
   416→                  draggable={false}
   417→                />
   418→
   419→                {/* Landmark Points */}
   420→                <svg
   421→                  className="absolute inset-0 w-full h-full pointer-events-none"
   422→                  style={{ overflow: 'visible' }}
   423→                >
   424→                  {/* Connection lines for face mesh */}
   425→                  {/* Add lines between related landmarks */}
   426→
   427→                  {/* Points */}
   428→                  {landmarks.map((point, index) => (
   429→                    <g key={index}>
   430→                      <circle
   431→                        cx={point.x}
   432→                        cy={point.y}
   433→                        r={selectedPoint === index ? 8 : 5}
   434→                        fill={getPointColor(index)}
   435→                        stroke="white"
   436→                        strokeWidth={2}
   437→                        className={`
   438→                          ${isEditable(index) ? 'cursor-grab pointer-events-auto' : 'opacity-50'}
   439→                          ${selectedPoint === index ? 'cursor-grabbing' : ''}
   440→                          transition-all duration-150
   441→                        `}
   442→                        onMouseDown={(e) => handlePointMouseDown(index, e)}
   443→                      />
   444→                      {/* Label on hover */}
   445→                      {selectedPoint === index && (
   446→                        <text
   447→                          x={point.x + 10}
   448→                          y={point.y - 10}
   449→                          fill="white"
   450→                          fontSize={12}
   451→                          className="pointer-events-none"
   452→                        >
   453→                          Point {index}
   454→                        </text>
   455→                      )}
   456→                    </g>
   457→                  ))}
   458→                </svg>
   459→              </div>
   460→            </TransformComponent>
   461→          </>
   462→        )}
   463→      </TransformWrapper>
   464→
   465→      {/* Instructions */}
   466→      <div className="absolute bottom-4 left-4 text-white/60 text-sm">
   467→        Drag points to adjust • Scroll to zoom • Click and drag to pan
   468→      </div>
   469→    </div>
   470→  );
   471→}
   472→```
   473→
   474→---
   475→
   476→## Phase 4: Facial Calculations
   477→
   478→### 4.1 Measurement Functions (src/lib/calculations.ts)
   479→```typescript
   480→interface Point {
   481→  x: number;
   482→  y: number;
   483→}
   484→
   485→// Basic geometry
   486→export function distance(p1: Point, p2: Point): number {
   487→  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
   488→}
   489→
   490→export function angle(p1: Point, vertex: Point, p2: Point): number {
   491→  const a = distance(vertex, p1);
   492→  const b = distance(vertex, p2);
   493→  const c = distance(p1, p2);
   494→  const radians = Math.acos((a * a + b * b - c * c) / (2 * a * b));
   495→  return radians * (180 / Math.PI);  // Convert to degrees
   496→}
   497→
   498→export function midpoint(p1: Point, p2: Point): Point {
   499→  return {
   500→    x: (p1.x + p2.x) / 2,
   501→    y: (p1.y + p2.y) / 2
   502→  };
   503→}
   504→
   505→// FACIAL MEASUREMENTS
   506→
   507→export function calculateFWHR(landmarks: Point[]): number {
   508→  // Face Width-to-Height Ratio
   509→  // Width: bizygomatic (cheekbone to cheekbone)
   510→  // Height: upper face height (eyebrow to upper lip)
   511→
   512→  const leftCheekbone = landmarks[234];
   513→  const rightCheekbone = landmarks[454];
   514→  const eyebrowCenter = landmarks[10];
   515→  const upperLip = landmarks[13];
   516→
   517→  const width = distance(leftCheekbone, rightCheekbone);
   518→  const height = distance(eyebrowCenter, upperLip);
   519→
   520→  return width / height;
   521→}
   522→
   523→export function calculateFacialThirds(landmarks: Point[]): {
   524→  upper: number;
   525→  middle: number;
   526→  lower: number;
   527→  isBalanced: boolean;
   528→} {
   529→  // Ideal: Each third should be ~33%
   530→  const hairline = landmarks[10];  // approximation
   531→  const glabella = landmarks[9];   // between eyebrows
   532→  const subnasale = landmarks[2];  // base of nose
   533→  const menton = landmarks[152];   // chin
   534→
   535→  const upperThird = distance(hairline, glabella);
   536→  const middleThird = distance(glabella, subnasale);
   537→  const lowerThird = distance(subnasale, menton);
   538→  const total = upperThird + middleThird + lowerThird;
   539→
   540→  const upper = (upperThird / total) * 100;
   541→  const middle = (middleThird / total) * 100;
   542→  const lower = (lowerThird / total) * 100;
   543→
   544→  // Balanced if each is within 5% of 33.33%
   545→  const isBalanced = [upper, middle, lower].every(
   546→    v => Math.abs(v - 33.33) < 5
   547→  );
   548→
   549→  return { upper, middle, lower, isBalanced };
   550→}
   551→
   552→export function calculateCanthalTilt(landmarks: Point[]): number {
   553→  // Positive = upward tilt (considered attractive)
   554→  // Negative = downward tilt
   555→
   556→  const leftEyeOuter = landmarks[33];
   557→  const leftEyeInner = landmarks[133];
   558→  const rightEyeInner = landmarks[362];
   559→  const rightEyeOuter = landmarks[263];
   560→
   561→  // Calculate angle from horizontal for each eye
   562→  const leftAngle = Math.atan2(
   563→    leftEyeInner.y - leftEyeOuter.y,
   564→    leftEyeInner.x - leftEyeOuter.x
   565→  ) * (180 / Math.PI);
   566→
   567→  const rightAngle = Math.atan2(
   568→    rightEyeOuter.y - rightEyeInner.y,
   569→    rightEyeOuter.x - rightEyeInner.x
   570→  ) * (180 / Math.PI);
   571→
   572→  return (leftAngle + rightAngle) / 2;
   573→}
   574→
   575→export function calculateSymmetry(landmarks: Point[]): number {
   576→  // Compare left vs right side of face
   577→  // 100 = perfect symmetry
   578→
   579→  const pairs = [
   580→    [33, 263],   // eye outer corners
   581→    [133, 362],  // eye inner corners
   582→    [70, 300],   // eyebrow peaks
   583→    [234, 454],  // cheekbones
   584→    [172, 397],  // jaw angles
   585→    [129, 358],  // nose ala
   586→    [61, 291],   // lip corners
   587→  ];
   588→
   589→  // Get face center (nose tip as reference)
   590→  const center = landmarks[4];
   591→
   592→  let totalDifference = 0;
   593→
   594→  pairs.forEach(([leftIdx, rightIdx]) => {
   595→    const left = landmarks[leftIdx];
   596→    const right = landmarks[rightIdx];
   597→
   598→    const leftDist = distance(center, left);
   599→    const rightDist = distance(center, right);
   600→
   601→    const diff = Math.abs(leftDist - rightDist) / ((leftDist + rightDist) / 2);
   602→    totalDifference += diff;
   603→  });
   604→
   605→  const avgDifference = totalDifference / pairs.length;
   606→  return Math.max(0, 100 - (avgDifference * 100));
   607→}
   608→
   609→export function calculateGoldenRatio(landmarks: Point[]): number {
   610→  // Phi (φ) = 1.618
   611→  // Compare face proportions to golden ratio
   612→
   613→  const phi = 1.618;
   614→
   615→  const faceWidth = distance(landmarks[234], landmarks[454]);
   616→  const faceHeight = distance(landmarks[10], landmarks[152]);
   617→  const ratio = faceHeight / faceWidth;
   618→
   619→  // How close to phi (percentage)
   620→  const deviation = Math.abs(ratio - phi) / phi;
   621→  return Math.max(0, 100 - (deviation * 100));
   622→}
   623→
   624→// SIDE PROFILE MEASUREMENTS
   625→
   626→export function calculateNasofrontalAngle(sideLandmarks: Point[]): number {
   627→  // Angle between forehead and nose bridge
   628→  // Ideal: 115-130 degrees
   629→
   630→  const glabella = sideLandmarks[16];
   631→  const nasion = sideLandmarks[17];
   632→  const pronasale = sideLandmarks[30];
   633→
   634→  return angle(glabella, nasion, pronasale);
   635→}
   636→
   637→export function calculateNasolabialAngle(sideLandmarks: Point[]): number {
   638→  // Angle between nose and upper lip
   639→  // Ideal: 90-120 degrees (varies by gender)
   640→  // Male: 90-95, Female: 95-110
   641→
   642→  const columella = sideLandmarks[32];  // between nostrils
   643→  const subnasale = sideLandmarks[35];
   644→  const upperLip = sideLandmarks[42];
   645→
   646→  return angle(columella, subnasale, upperLip);
   647→}
   648→
   649→export function calculateGonialAngle(sideLandmarks: Point[]): number {
   650→  // Jaw angle
   651→  // Ideal: 120-130 degrees
   652→
   653→  const tragus = sideLandmarks[95];
   654→  const gonion = sideLandmarks[85];
   655→  const menton = sideLandmarks[70];
   656→
   657→  return angle(tragus, gonion, menton);
   658→}
   659→
   660→export function calculateChinProjection(sideLandmarks: Point[]): {
   661→  value: number;
   662→  assessment: string;
   663→} {
   664→  // Distance from subnasale vertical line to pogonion
   665→
   666→  const subnasale = sideLandmarks[35];
   667→  const pogonion = sideLandmarks[65];
   668→
   669→  // Positive = prominent chin, Negative = recessed
   670→  const projection = pogonion.x - subnasale.x;
   671→
   672→  let assessment = 'Normal';
   673→  if (projection > 10) assessment = 'Prominent';
   674→  if (projection < -5) assessment = 'Recessed';
   675→
   676→  return { value: projection, assessment };
   677→}
   678→
   679→// COMPREHENSIVE ANALYSIS
   680→
   681→export function analyzeFullFace(
   682→  frontLandmarks: Point[],
   683→  sideLandmarks?: Point[]
   684→): FaceAnalysis {
   685→  const analysis: FaceAnalysis = {
   686→    // Front face measurements
   687→    fwhr: calculateFWHR(frontLandmarks),
   688→    facialThirds: calculateFacialThirds(frontLandmarks),
   689→    canthalTilt: calculateCanthalTilt(frontLandmarks),
   690→    symmetry: calculateSymmetry(frontLandmarks),
   691→    goldenRatioScore: calculateGoldenRatio(frontLandmarks),
   692→
   693→    // Side profile measurements (if available)
   694→    sideProfile: sideLandmarks ? {
   695→      nasofrontalAngle: calculateNasofrontalAngle(sideLandmarks),
   696→      nasolabialAngle: calculateNasolabialAngle(sideLandmarks),
   697→      gonialAngle: calculateGonialAngle(sideLandmarks),
   698→      chinProjection: calculateChinProjection(sideLandmarks)
   699→    } : null
   700→  };
   701→
   702→  return analysis;
   703→}
   704→
   705→interface FaceAnalysis {
   706→  fwhr: number;
   707→  facialThirds: { upper: number; middle: number; lower: number; isBalanced: boolean };
   708→  canthalTilt: number;
   709→  symmetry: number;
   710→  goldenRatioScore: number;
   711→  sideProfile: {
   712→    nasofrontalAngle: number;
   713→    nasolabialAngle: number;
   714→    gonialAngle: number;
   715→    chinProjection: { value: number; assessment: string };
   716→  } | null;
   717→}
   718→```
   719→
   720→---
   721→
   722→## Phase 5: API Routes
   723→
   724→### 5.1 Face Analysis API (src/app/api/faces/route.ts)
   725→```typescript
   726→import { NextRequest, NextResponse } from 'next/server';
   727→import { getServerSession } from 'next-auth';
   728→import { prisma } from '@/lib/prisma';
   729→import { put } from '@vercel/blob';
   730→
   731→export async function POST(req: NextRequest) {
   732→  const session = await getServerSession();
   733→  if (!session?.user?.email) {
   734→    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
   735→  }
   736→
   737→  const formData = await req.formData();
   738→  const frontImage = formData.get('frontImage') as File;
   739→  const sideImage = formData.get('sideImage') as File | null;
   740→
   741→  // Upload to Vercel Blob
   742→  const frontBlob = await put(`faces/${Date.now()}-front.webp`, frontImage, {
   743→    access: 'public',
   744→  });
   745→
   746→  let sideBlob = null;
   747→  if (sideImage) {
   748→    sideBlob = await put(`faces/${Date.now()}-side.webp`, sideImage, {
   749→      access: 'public',
   750→    });
   751→  }
   752→
   753→  // Create face record
   754→  const user = await prisma.user.findUnique({
   755→    where: { email: session.user.email }
   756→  });
   757→
   758→  const face = await prisma.face.create({
   759→    data: {
   760→      userId: user!.id,
   761→      frontUrl: frontBlob.url,
   762→      sideUrl: sideBlob?.url,
   763→      status: 'FRONT_UPLOADED'
   764→    }
   765→  });
   766→
   767→  return NextResponse.json({
   768→    success: true,
   769→    face: {
   770→      id: face.id,
   771→      images: {
   772→        frontUrl: face.frontUrl,
   773→        sideUrl: face.sideUrl
   774→      }
   775→    }
   776→  });
   777→}
   778→```
   779→
   780→---
   781→
   782→## Next Steps After Capture
   783→
   784→Once you have the full capture:
   785→
   786→1. **Analyze the HAR** - Extract exact API request/response formats
   787→2. **Study the Screenshots** - Match UI to component structure
   788→3. **Watch the Recording** - Note timing and transitions
   789→4. **Compare React Tree** - Match their components to your implementation
   790→
   791→Would you like me to create any specific component in detail?
   792→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
