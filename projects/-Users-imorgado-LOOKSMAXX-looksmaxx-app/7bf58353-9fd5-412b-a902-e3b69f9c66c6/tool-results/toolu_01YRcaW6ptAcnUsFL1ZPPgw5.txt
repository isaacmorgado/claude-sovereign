     1→'use client';
     2→
     3→import React, { createContext, useContext, useState, useCallback, useRef, ReactNode, useEffect } from 'react';
     4→import { api } from '@/lib/api';
     5→import type {
     6→  Category,
     7→  Post,
     8→  PostListItem,
     9→  Comment,
    10→  SortOrder,
    11→  VoteType,
    12→  GuideSection,
    13→  RecommendedForum,
    14→} from '@/types/forum';
    15→
    16→// === BOOKMARK CONTEXT ===
    17→
    18→interface BookmarkContextType {
    19→  bookmarkedIds: Set<string>;
    20→  isBookmarked: (postId: string) => boolean;
    21→  toggleBookmark: (postId: string) => Promise<void>;
    22→  refreshBookmarks: () => Promise<void>;
    23→  isLoading: boolean;
    24→}
    25→
    26→const BookmarkContext = createContext<BookmarkContextType | null>(null);
    27→
    28→export function useBookmarks(): BookmarkContextType | null {
    29→  return useContext(BookmarkContext);
    30→}
    31→
    32→export function BookmarkProvider({ children }: { children: ReactNode }) {
    33→  const [bookmarkedIds, setBookmarkedIds] = useState<Set<string>>(new Set());
    34→  const [isLoading, setIsLoading] = useState(false);
    35→  const hasFetchedRef = useRef(false);
    36→
    37→  const refreshBookmarks = useCallback(async () => {
    38→    // Only fetch if user is logged in
    39→    const token = typeof window !== 'undefined' ? localStorage.getItem('auth_token') : null;
    40→    if (!token) {
    41→      setBookmarkedIds(new Set());
    42→      return;
    43→    }
    44→
    45→    setIsLoading(true);
    46→    try {
    47→      const ids = await api.getBookmarkedPostIds();
    48→      setBookmarkedIds(new Set(ids));
    49→    } catch (err) {
    50→      console.error('Failed to fetch bookmarked posts:', err);
    51→      setBookmarkedIds(new Set());
    52→    } finally {
    53→      setIsLoading(false);
    54→    }
    55→  }, []);
    56→
    57→  // Fetch bookmarks on mount
    58→  useEffect(() => {
    59→    if (!hasFetchedRef.current) {
    60→      hasFetchedRef.current = true;
    61→      refreshBookmarks();
    62→    }
    63→  }, [refreshBookmarks]);
    64→
    65→  const isBookmarked = useCallback((postId: string) => {
    66→    return bookmarkedIds.has(postId);
    67→  }, [bookmarkedIds]);
    68→
    69→  const toggleBookmark = useCallback(async (postId: string) => {
    70→    try {
    71→      const result = await api.toggleBookmark(postId);
    72→      setBookmarkedIds(prev => {
    73→        const newSet = new Set(prev);
    74→        if (result.isBookmarked) {
    75→          newSet.add(postId);
    76→        } else {
    77→          newSet.delete(postId);
    78→        }
    79→        return newSet;
    80→      });
    81→    } catch (err) {
    82→      console.error('Failed to toggle bookmark:', err);
    83→      throw err;
    84→    }
    85→  }, []);
    86→
    87→  return (
    88→    <BookmarkContext.Provider
    89→      value={{
    90→        bookmarkedIds,
    91→        isBookmarked,
    92→        toggleBookmark,
    93→        refreshBookmarks,
    94→        isLoading,
    95→      }}
    96→    >
    97→      {children}
    98→    </BookmarkContext.Provider>
    99→  );
   100→}
   101→
   102→
   103→// === FORUM CONTEXT ===
   104→
   105→interface ForumContextType {
   106→  // Categories
   107→  categories: Category[];
   108→  currentCategory: Category | null;
   109→  isLoadingCategories: boolean;
   110→  fetchCategories: () => Promise<void>;
   111→  fetchCategory: (slug: string) => Promise<void>;
   112→
   113→  // Posts
   114→  posts: PostListItem[];
   115→  currentPost: Post | null;
   116→  totalPosts: number;
   117→  hasMorePosts: boolean;
   118→  isLoadingPosts: boolean;
   119→  sortOrder: SortOrder;
   120→  setSortOrder: (sort: SortOrder) => void;
   121→  fetchPosts: (categorySlug: string, subForumSlug?: string, reset?: boolean) => Promise<void>;
   122→  loadMorePosts: (categorySlug: string, subForumSlug?: string) => Promise<void>;
   123→  fetchPost: (postId: string) => Promise<void>;
   124→  createPost: (title: string, content: string, subForumId: string) => Promise<Post>;
   125→  updatePost: (postId: string, title?: string, content?: string) => Promise<void>;
   126→  deletePost: (postId: string) => Promise<void>;
   127→
   128→  // Comments
   129→  comments: Comment[];
   130→  isLoadingComments: boolean;
   131→  fetchComments: (postId: string) => Promise<void>;
   132→  createComment: (postId: string, content: string, parentId?: string) => Promise<Comment>;
   133→  updateComment: (commentId: string, content: string) => Promise<void>;
   134→  deleteComment: (commentId: string) => Promise<void>;
   135→
   136→  // Voting
   137→  votePost: (postId: string, voteType: VoteType) => Promise<void>;
   138→  voteComment: (commentId: string, voteType: VoteType) => Promise<void>;
   139→
   140→  // Guides & Recommendations
   141→  guideSections: GuideSection[];
   142→  recommendedForums: RecommendedForum[];
   143→  isLoadingGuides: boolean;
   144→  fetchGuides: () => Promise<void>;
   145→  fetchRecommended: (flaws: string[]) => Promise<void>;
   146→
   147→  // Error state
   148→  error: string | null;
   149→  clearError: () => void;
   150→}
   151→
   152→const ForumContext = createContext<ForumContextType | null>(null);
   153→
   154→export function useForum(): ForumContextType {
   155→  const context = useContext(ForumContext);
   156→  if (!context) {
   157→    throw new Error('useForum must be used within a ForumProvider');
   158→  }
   159→  return context;
   160→}
   161→
   162→export function useForumOptional(): ForumContextType | null {
   163→  return useContext(ForumContext);
   164→}
   165→
   166→const PAGE_SIZE = 20;
   167→
   168→export function ForumProvider({ children }: { children: ReactNode }) {
   169→  // Categories
   170→  const [categories, setCategories] = useState<Category[]>([]);
   171→  const [currentCategory, setCurrentCategory] = useState<Category | null>(null);
   172→  const [isLoadingCategories, setIsLoadingCategories] = useState(false);
   173→
   174→  // Posts
   175→  const [posts, setPosts] = useState<PostListItem[]>([]);
   176→  const [currentPost, setCurrentPost] = useState<Post | null>(null);
   177→  const [totalPosts, setTotalPosts] = useState(0);
   178→  const [hasMorePosts, setHasMorePosts] = useState(true);
   179→  const [isLoadingPosts, setIsLoadingPosts] = useState(false);
   180→  const [sortOrder, setSortOrder] = useState<SortOrder>('hot');
   181→  const offsetRef = useRef(0);
   182→
   183→  // Comments
   184→  const [comments, setComments] = useState<Comment[]>([]);
   185→  const [isLoadingComments, setIsLoadingComments] = useState(false);
   186→
   187→  // Guides & Recommendations
   188→  const [guideSections, setGuideSections] = useState<GuideSection[]>([]);
   189→  const [recommendedForums, setRecommendedForums] = useState<RecommendedForum[]>([]);
   190→  const [isLoadingGuides, setIsLoadingGuides] = useState(false);
   191→
   192→  // Error state
   193→  const [error, setError] = useState<string | null>(null);
   194→
   195→  const clearError = useCallback(() => setError(null), []);
   196→
   197→  // === CATEGORIES ===
   198→
   199→  const fetchCategories = useCallback(async () => {
   200→    setIsLoadingCategories(true);
   201→    setError(null);
   202→    try {
   203→      const data = await api.getForumCategories();
   204→      setCategories(data);
   205→    } catch (err) {
   206→      setError(err instanceof Error ? err.message : 'Failed to fetch categories');
   207→    } finally {
   208→      setIsLoadingCategories(false);
   209→    }
   210→  }, []);
   211→
   212→  const fetchCategory = useCallback(async (slug: string) => {
   213→    setIsLoadingCategories(true);
   214→    setError(null);
   215→    try {
   216→      const data = await api.getForumCategory(slug);
   217→      setCurrentCategory(data);
   218→    } catch (err) {
   219→      setError(err instanceof Error ? err.message : 'Failed to fetch category');
   220→    } finally {
   221→      setIsLoadingCategories(false);
   222→    }
   223→  }, []);
   224→
   225→  // === POSTS ===
   226→
   227→  const fetchPosts = useCallback(async (
   228→    categorySlug: string,
   229→    subForumSlug?: string,
   230→    reset = true
   231→  ) => {
   232→    setIsLoadingPosts(true);
   233→    setError(null);
   234→    try {
   235→      const offset = reset ? 0 : offsetRef.current;
   236→      const data = await api.getForumPosts(categorySlug, {
   237→        subForumSlug,
   238→        sort: sortOrder,
   239→        limit: PAGE_SIZE,
   240→        offset,
   241→      });
   242→
   243→      if (reset) {
   244→        setPosts(data.posts);
   245→        offsetRef.current = PAGE_SIZE;
   246→      } else {
   247→        setPosts(prev => [...prev, ...data.posts]);
   248→        offsetRef.current += PAGE_SIZE;
   249→      }
   250→
   251→      setTotalPosts(data.totalCount);
   252→      setHasMorePosts(data.hasMore);
   253→    } catch (err) {
   254→      setError(err instanceof Error ? err.message : 'Failed to fetch posts');
   255→    } finally {
   256→      setIsLoadingPosts(false);
   257→    }
   258→  }, [sortOrder]);
   259→
   260→  const loadMorePosts = useCallback(async (
   261→    categorySlug: string,
   262→    subForumSlug?: string
   263→  ) => {
   264→    if (!hasMorePosts || isLoadingPosts) return;
   265→    await fetchPosts(categorySlug, subForumSlug, false);
   266→  }, [fetchPosts, hasMorePosts, isLoadingPosts]);
   267→
   268→  const fetchPost = useCallback(async (postId: string) => {
   269→    setIsLoadingPosts(true);
   270→    setError(null);
   271→    try {
   272→      const data = await api.getForumPost(postId);
   273→      setCurrentPost(data);
   274→    } catch (err) {
   275→      setError(err instanceof Error ? err.message : 'Failed to fetch post');
   276→    } finally {
   277→      setIsLoadingPosts(false);
   278→    }
   279→  }, []);
   280→
   281→  const createPost = useCallback(async (
   282→    title: string,
   283→    content: string,
   284→    subForumId: string
   285→  ): Promise<Post> => {
   286→    setError(null);
   287→    try {
   288→      const post = await api.createForumPost({ title, content, subForumId });
   289→      return post;
   290→    } catch (err) {
   291→      const message = err instanceof Error ? err.message : 'Failed to create post';
   292→      setError(message);
   293→      throw err;
   294→    }
   295→  }, []);
   296→
   297→  const updatePost = useCallback(async (
   298→    postId: string,
   299→    title?: string,
   300→    content?: string
   301→  ) => {
   302→    setError(null);
   303→    try {
   304→      const updated = await api.updateForumPost(postId, { title, content });
   305→      setCurrentPost(updated);
   306→      // Update in posts list if present
   307→      setPosts(prev => prev.map(p =>
   308→        p.id === postId
   309→          ? { ...p, title: title ?? p.title }
   310→          : p
   311→      ));
   312→    } catch (err) {
   313→      setError(err instanceof Error ? err.message : 'Failed to update post');
   314→      throw err;
   315→    }
   316→  }, []);
   317→
   318→  const deletePost = useCallback(async (postId: string) => {
   319→    setError(null);
   320→    try {
   321→      await api.deleteForumPost(postId);
   322→      setPosts(prev => prev.filter(p => p.id !== postId));
   323→      if (currentPost?.id === postId) {
   324→        setCurrentPost(null);
   325→      }
   326→    } catch (err) {
   327→      setError(err instanceof Error ? err.message : 'Failed to delete post');
   328→      throw err;
   329→    }
   330→  }, [currentPost?.id]);
   331→
   332→  // === COMMENTS ===
   333→
   334→  const fetchComments = useCallback(async (postId: string) => {
   335→    setIsLoadingComments(true);
   336→    setError(null);
   337→    try {
   338→      const data = await api.getForumComments(postId);
   339→      setComments(data);
   340→    } catch (err) {
   341→      setError(err instanceof Error ? err.message : 'Failed to fetch comments');
   342→    } finally {
   343→      setIsLoadingComments(false);
   344→    }
   345→  }, []);
   346→
   347→  const createComment = useCallback(async (
   348→    postId: string,
   349→    content: string,
   350→    parentId?: string
   351→  ): Promise<Comment> => {
   352→    setError(null);
   353→    try {
   354→      const comment = await api.createForumComment(postId, { content, parentId });
   355→      // Add to comments list (append for top-level, insert in replies for nested)
   356→      if (!parentId) {
   357→        setComments(prev => [...prev, comment]);
   358→      } else {
   359→        // Add reply to parent comment's replies array
   360→        const addReplyToParent = (list: Comment[]): Comment[] =>
   361→          list.map(c => c.id === parentId
   362→            ? { ...c, replies: [...c.replies, comment] }
   363→            : { ...c, replies: addReplyToParent(c.replies) }
   364→          );
   365→        setComments(prev => addReplyToParent(prev));
   366→      }
   367→      // Update comment count in current post
   368→      if (currentPost?.id === postId) {
   369→        setCurrentPost(prev => prev ? { ...prev, commentCount: prev.commentCount + 1 } : null);
   370→      }
   371→      return comment;
   372→    } catch (err) {
   373→      const message = err instanceof Error ? err.message : 'Failed to create comment';
   374→      setError(message);
   375→      throw err;
   376→    }
   377→  }, [currentPost?.id]);
   378→
   379→  const updateComment = useCallback(async (commentId: string, content: string) => {
   380→    setError(null);
   381→    try {
   382→      const updated = await api.updateForumComment(commentId, content);
   383→      // Update in comments list
   384→      const updateInList = (list: Comment[]): Comment[] =>
   385→        list.map(c => c.id === commentId
   386→          ? { ...c, content: updated.content, updatedAt: updated.updatedAt }
   387→          : { ...c, replies: updateInList(c.replies) }
   388→        );
   389→      setComments(prev => updateInList(prev));
   390→    } catch (err) {
   391→      setError(err instanceof Error ? err.message : 'Failed to update comment');
   392→      throw err;
   393→    }
   394→  }, []);
   395→
   396→  const deleteComment = useCallback(async (commentId: string) => {
   397→    setError(null);
   398→    try {
   399→      await api.deleteForumComment(commentId);
   400→      // Remove from comments list
   401→      const removeFromList = (list: Comment[]): Comment[] =>
   402→        list.filter(c => c.id !== commentId).map(c => ({
   403→          ...c,
   404→          replies: removeFromList(c.replies),
   405→        }));
   406→      setComments(prev => removeFromList(prev));
   407→      // Update comment count
   408→      if (currentPost) {
   409→        setCurrentPost(prev => prev ? { ...prev, commentCount: Math.max(0, prev.commentCount - 1) } : null);
   410→      }
   411→    } catch (err) {
   412→      setError(err instanceof Error ? err.message : 'Failed to delete comment');
   413→      throw err;
   414→    }
   415→  }, [currentPost]);
   416→
   417→  // === VOTING ===
   418→
   419→  const votePost = useCallback(async (postId: string, voteType: VoteType) => {
   420→    setError(null);
   421→    try {
   422→      const result = await api.voteForumPost(postId, voteType);
   423→      // Update in current post
   424→      if (currentPost?.id === postId) {
   425→        setCurrentPost(prev => prev ? {
   426→          ...prev,
   427→          voteCount: result.newVoteCount,
   428→          userVote: result.userVote,
   429→        } : null);
   430→      }
   431→      // Update in posts list
   432→      setPosts(prev => prev.map(p =>
   433→        p.id === postId
   434→          ? { ...p, voteCount: result.newVoteCount, userVote: result.userVote }
   435→          : p
   436→      ));
   437→    } catch (err) {
   438→      setError(err instanceof Error ? err.message : 'Failed to vote');
   439→      throw err;
   440→    }
   441→  }, [currentPost?.id]);
   442→
   443→  const voteComment = useCallback(async (commentId: string, voteType: VoteType) => {
   444→    setError(null);
   445→    try {
   446→      const result = await api.voteForumComment(commentId, voteType);
   447→      // Update in comments list
   448→      const updateVote = (list: Comment[]): Comment[] =>
   449→        list.map(c => c.id === commentId
   450→          ? { ...c, voteCount: result.newVoteCount, userVote: result.userVote }
   451→          : { ...c, replies: updateVote(c.replies) }
   452→        );
   453→      setComments(prev => updateVote(prev));
   454→    } catch (err) {
   455→      setError(err instanceof Error ? err.message : 'Failed to vote');
   456→      throw err;
   457→    }
   458→  }, []);
   459→
   460→  // === GUIDES & RECOMMENDATIONS ===
   461→
   462→  const fetchGuides = useCallback(async () => {
   463→    setIsLoadingGuides(true);
   464→    setError(null);
   465→    try {
   466→      const data = await api.getForumGuides();
   467→      setGuideSections(data);
   468→    } catch (err) {
   469→      setError(err instanceof Error ? err.message : 'Failed to fetch guides');
   470→    } finally {
   471→      setIsLoadingGuides(false);
   472→    }
   473→  }, []);
   474→
   475→  const fetchRecommended = useCallback(async (flaws: string[]) => {
   476→    setError(null);
   477→    try {
   478→      const data = await api.getRecommendedForums(flaws);
   479→      setRecommendedForums(data);
   480→    } catch (err) {
   481→      setError(err instanceof Error ? err.message : 'Failed to fetch recommendations');
   482→    }
   483→  }, []);
   484→
   485→  return (
   486→    <ForumContext.Provider
   487→      value={{
   488→        // Categories
   489→        categories,
   490→        currentCategory,
   491→        isLoadingCategories,
   492→        fetchCategories,
   493→        fetchCategory,
   494→
   495→        // Posts
   496→        posts,
   497→        currentPost,
   498→        totalPosts,
   499→        hasMorePosts,
   500→        isLoadingPosts,
   501→        sortOrder,
   502→        setSortOrder,
   503→        fetchPosts,
   504→        loadMorePosts,
   505→        fetchPost,
   506→        createPost,
   507→        updatePost,
   508→        deletePost,
   509→
   510→        // Comments
   511→        comments,
   512→        isLoadingComments,
   513→        fetchComments,
   514→        createComment,
   515→        updateComment,
   516→        deleteComment,
   517→
   518→        // Voting
   519→        votePost,
   520→        voteComment,
   521→
   522→        // Guides & Recommendations
   523→        guideSections,
   524→        recommendedForums,
   525→        isLoadingGuides,
   526→        fetchGuides,
   527→        fetchRecommended,
   528→
   529→        // Error
   530→        error,
   531→        clearError,
   532→      }}
   533→    >
   534→      <BookmarkProvider>
   535→        {children}
   536→      </BookmarkProvider>
   537→    </ForumContext.Provider>
   538→  );
   539→}
   540→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
