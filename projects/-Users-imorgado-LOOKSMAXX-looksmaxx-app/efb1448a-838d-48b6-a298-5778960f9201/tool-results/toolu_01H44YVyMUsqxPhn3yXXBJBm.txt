     1→/**
     2→ * Scoring System Type Definitions
     3→ * Extracted from harmony-scoring.ts for better modularity
     4→ */
     5→
     6→// Re-export LandmarkPoint from landmarks module
     7→export type { LandmarkPoint } from '@/lib/landmarks';
     8→
     9→// ============================================
    10→// CORE TYPES
    11→// ============================================
    12→
    13→export interface Point {
    14→  x: number;
    15→  y: number;
    16→}
    17→
    18→export type QualityTier = 'ideal' | 'excellent' | 'good' | 'below_average';
    19→export type SeverityLevel = 'extremely_severe' | 'severe' | 'major' | 'moderate' | 'minor' | 'optimal';
    20→export type MeasurementUnit = 'ratio' | 'percent' | 'degrees' | 'mm' | 'none';
    21→
    22→/**
    23→ * Confidence level for flaw/strength detection based on Z-score magnitude
    24→ * - confirmed: |z| >= 2 (high statistical certainty, 2+ standard deviations from mean)
    25→ * - likely: 1 <= |z| < 2 (moderate certainty, 1-2 standard deviations)
    26→ * - possible: 0.5 <= |z| < 1 (low certainty, 0.5-1 standard deviation)
    27→ */
    28→export type ConfidenceLevel = 'confirmed' | 'likely' | 'possible';
    29→
    30→/**
    31→ * Polarity defines how deviation from the ideal range is interpreted:
    32→ * - 'balanced': Default. Deviation in either direction is equally bad.
    33→ * - 'higher_is_better': Values above the ideal are still good. Only values below
    34→ *   the 'safeFloor' are true weaknesses. E.g., Canthal Tilt (positive tilt is good)
    35→ * - 'lower_is_better': Values below the ideal are still good. Only values above
    36→ *   the 'safeCeiling' are true weaknesses. E.g., Philtrum length (shorter is better)
    37→ */
    38→export type MetricPolarity = 'balanced' | 'higher_is_better' | 'lower_is_better';
    39→
    40→export interface MetricConfig {
    41→  id: string;
    42→  name: string;
    43→  category: string;
    44→  unit: MeasurementUnit;
    45→  idealMin: number;
    46→  idealMax: number;
    47→  rangeMin: number;
    48→  rangeMax: number;
    49→  decayRate: number;
    50→  maxScore: number;
    51→  weight: number;
    52→  description: string;
    53→  profileType: 'front' | 'side';
    54→  customCurve?: BezierCurveConfig;
    55→  /**
    56→   * Polarity for directional/dimorphic scoring.
    57→   * Defaults to 'balanced' if not specified.
    58→   */
    59→  polarity?: MetricPolarity;
    60→  /**
    61→   * For 'higher_is_better': minimum value that's still acceptable.
    62→   * Values above this but below idealMin get a passing score (softFloorScore).
    63→   * Values below this are true weaknesses.
    64→   */
    65→  safeFloor?: number;
    66→  /**
    67→   * For 'lower_is_better': maximum value that's still acceptable.
    68→   * Values below this but above idealMax get a passing score (softCeilingScore).
    69→   * Values above this are true weaknesses.
    70→   */
    71→  safeCeiling?: number;
    72→  /**
    73→   * Score given to values in the "acceptable but not ideal" zone.
    74→   * Defaults to 8.0 (Good). Range: 6.0-9.0
    75→   */
    76→  softZoneScore?: number;
    77→  /**
    78→   * Facial landmarks used to calculate this metric.
    79→   * For documentation/debugging purposes - references landmark IDs from landmarks.ts
    80→   * Front profile landmarks: trichion, left_zygion, right_zygion, menton, etc.
    81→   * Side profile landmarks: gonionTop, gonionBottom, nasion, pronasale, etc.
    82→   */
    83→  usedLandmarks?: string[];
    84→}
    85→
    86→/**
    87→ * Dual Curve System Configuration
    88→ *
    89→ * The dual curve system allows for separate curves for scoring vs display:
    90→ * - `points` (required): The scoring curve used for actual score calculation
    91→ * - `displayPoints` (optional): A separate curve for UI visualization
    92→ *
    93→ * Use cases for separate display curves:
    94→ * 1. Smoother visualization: Scoring may use sharp cutoffs, but display shows gradual transitions
    95→ * 2. Marketing/UX: Show more forgiving curves to users while maintaining strict internal scoring
    96→ * 3. A/B testing: Test different visual representations without affecting actual scores
    97→ * 4. Simplified UI: Complex multi-segment scoring curves may need simpler display versions
    98→ *
    99→ * If `displayPoints` is not provided, the `points` curve is used for both scoring and display.
   100→ */
   101→export interface BezierCurveConfig {
   102→  mode: 'custom' | 'exponential';
   103→  /** Scoring curve points - used for actual score calculation */
   104→  points: CurvePoint[];
   105→  /** Optional display curve points - used for UI visualization only */
   106→  displayPoints?: CurvePoint[];
   107→}
   108→
   109→export interface CurvePoint {
   110→  x: number;
   111→  y: number;
   112→  leftHandleX?: number;
   113→  leftHandleY?: number;
   114→  rightHandleX?: number;
   115→  rightHandleY?: number;
   116→  fixed?: boolean;
   117→}
   118→
   119→export interface MetricScoreResult {
   120→  metricId: string;
   121→  name: string;
   122→  value: number;
   123→  score: number;  // 0-10 scale
   124→  standardizedScore: number;
   125→  qualityTier: QualityTier;
   126→  severity: SeverityLevel;
   127→  idealMin: number;
   128→  idealMax: number;
   129→  deviation: number;
   130→  deviationDirection: 'above' | 'below' | 'within';
   131→  unit: MeasurementUnit;
   132→  category: string;
   133→  percentile?: number;
   134→}
   135→
   136→export interface HarmonyAnalysis {
   137→  overallScore: number;  // 0-10 scale
   138→  standardizedScore: number;
   139→  qualityTier: QualityTier;
   140→  percentile: number;
   141→  frontScore: number;
   142→  sideScore: number;
   143→  categoryScores: Record<string, number>;
   144→  measurements: MetricScoreResult[];
   145→  flaws: FlawAssessment[];
   146→  strengths: StrengthAssessment[];
   147→}
   148→
   149→export interface FlawAssessment {
   150→  category: string;
   151→  metricId: string;
   152→  metricName: string;
   153→  severity: SeverityLevel;
   154→  deviation: string;
   155→  reasoning: string;
   156→  confidence: ConfidenceLevel;
   157→}
   158→
   159→export interface StrengthAssessment {
   160→  category: string;
   161→  metricId: string;
   162→  metricName: string;
   163→  qualityTier: QualityTier;
   164→  value: number;
   165→  reasoning: string;
   166→}
   167→
   168→// ============================================
   169→// DEMOGRAPHIC TYPES
   170→// ============================================
   171→
   172→export type Ethnicity =
   173→  | 'east_asian'
   174→  | 'south_asian'
   175→  | 'black'
   176→  | 'hispanic'
   177→  | 'middle_eastern'
   178→  | 'native_american'
   179→  | 'pacific_islander'
   180→  | 'white'
   181→  | 'other';
   182→
   183→export type Gender = 'male' | 'female';
   184→
   185→export type DemographicKey = `${Ethnicity}_${Gender}` | Gender | Ethnicity;
   186→
   187→export interface DemographicOverride {
   188→  idealMin: number;
   189→  idealMax: number;
   190→}
   191→
   192→export interface DemographicOptions {
   193→  gender?: Gender;
   194→  ethnicity?: Ethnicity;
   195→}
   196→
   197→// ============================================
   198→// FLAW MAPPING TYPES
   199→// ============================================
   200→
   201→export interface FlawMapping {
   202→  category: string;
   203→  flawName: string;
   204→  confidence: ConfidenceLevel;
   205→  reasoning: string;
   206→}
   207→
   208→// ============================================
   209→// PROFILE RESULT TYPES
   210→// ============================================
   211→
   212→export interface FrontProfileResults {
   213→  measurements: MetricScoreResult[];
   214→  overallScore: number;
   215→  standardizedScore: number;
   216→  qualityTier: QualityTier;
   217→  categoryScores: Record<string, number>;
   218→}
   219→
   220→export interface SideProfileResults {
   221→  measurements: MetricScoreResult[];
   222→  overallScore: number;
   223→  standardizedScore: number;
   224→  qualityTier: QualityTier;
   225→  categoryScores: Record<string, number>;
   226→}
   227→
   228→// ============================================
   229→// PSL RATING TYPES
   230→// ============================================
   231→
   232→export interface PSLRating {
   233→  score: number;
   234→  tier: string;
   235→  percentile: number;
   236→  description: string;
   237→}
   238→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
