     1→/**
     2→ * Harmony-Style Results Page Types
     3→ * Complete type definitions for the results UI
     4→ */
     5→
     6→import { QualityTier, SeverityLevel, MeasurementUnit, ConfidenceLevel } from '@/lib/harmony-scoring';
     7→
     8→// ============================================
     9→// ILLUSTRATION TYPES
    10→// ============================================
    11→
    12→export interface IllustrationPoint {
    13→  type: 'landmark' | 'calculated';
    14→  landmarkId?: string;
    15→  x?: number;
    16→  y?: number;
    17→  label?: string;
    18→}
    19→
    20→export interface IllustrationLine {
    21→  from: string;
    22→  to: string;
    23→  color: string;
    24→  style?: 'solid' | 'dashed';
    25→  label?: string;
    26→  labelColor?: string;
    27→  labelPosition?: 'start' | 'middle' | 'end';
    28→}
    29→
    30→export interface RatioIllustration {
    31→  points: Record<string, IllustrationPoint>;
    32→  lines: Record<string, IllustrationLine>;
    33→}
    34→
    35→// ============================================
    36→// RATIO/MEASUREMENT TYPES
    37→// ============================================
    38→
    39→export interface Ratio {
    40→  id: string;
    41→  name: string;
    42→  value: number | string;
    43→  score: number | string;  // 0-10 scale or Greek text
    44→  standardizedScore: number | string;
    45→  unit: 'x' | 'mm' | '%' | '°';
    46→  idealMin: number;
    47→  idealMax: number;
    48→  rangeMin: number;
    49→  rangeMax: number;
    50→  description: string;
    51→  category: string;
    52→  qualityLevel: QualityTier;
    53→  severity: SeverityLevel;
    54→  illustration: RatioIllustration;
    55→  mayIndicateFlaws: string[];
    56→  mayIndicateStrengths: string[];
    57→  usedLandmarks: string[];
    58→  scoringCurveConfig?: {
    59→    decayRate: number;
    60→    maxScore: number;
    61→  };
    62→  // Harmony Taxonomy classification
    63→  taxonomyPrimary?: string;    // 'harmony' | 'dimorphism' | 'angularity' | 'features'
    64→  taxonomySecondary?: string;  // Subcategory ID
    65→}
    66→
    67→// ============================================
    68→// STRENGTH/FLAW TYPES
    69→// ============================================
    70→
    71→export interface ResponsibleRatio {
    72→  ratioName: string;
    73→  ratioId: string;
    74→  score: number | string;
    75→  value: number | string;
    76→  isObfuscated?: boolean;
    77→  // Additional properties for AI descriptions
    78→  idealMin: number;
    79→  idealMax: number;
    80→  unit: string;
    81→  category?: string;
    82→}
    83→
    84→export interface Strength {
    85→  id: string;
    86→  strengthName: string;
    87→  summary: string;
    88→  avgScore: number | string;
    89→  qualityLevel: QualityTier;
    90→  categoryName: string;
    91→  responsibleRatios: ResponsibleRatio[];
    92→}
    93→
    94→export interface Flaw {
    95→  id: string;
    96→  flawName: string;
    97→  summary: string;
    98→  harmonyPercentageLost: number;
    99→  standardizedImpact: number;
   100→  categoryName: string;
   101→  isOther?: boolean;
   102→  responsibleRatios: ResponsibleRatio[];
   103→  rollingPointsDeducted?: number;
   104→  rollingHarmonyPercentageLost?: number;
   105→  rollingStandardizedImpact?: number;
   106→  /**
   107→   * Confidence level based on Z-score magnitude:
   108→   * - confirmed: |z| >= 2 (statistically significant)
   109→   * - likely: 1 <= |z| < 2
   110→   * - possible: 0.5 <= |z| < 1
   111→   */
   112→  confidence?: ConfidenceLevel;
   113→}
   114→
   115→// ============================================
   116→// RECOMMENDATION TYPES
   117→// ============================================
   118→
   119→export type RecommendationPhase = 'Surgical' | 'Minimally Invasive' | 'Foundational';
   120→
   121→export interface RecommendationTimeline {
   122→  effect_start: 'immediate' | 'delayed' | 'gradual';
   123→  full_results_weeks: number;
   124→  full_results_weeks_max?: number;
   125→}
   126→
   127→export interface RecommendationCost {
   128→  type: 'flat' | 'per_month' | 'per_session';
   129→  min: number;
   130→  max: number;
   131→  currency: string;
   132→}
   133→
   134→export interface RatioImpact {
   135→  ratioId: string;
   136→  ratioName: string;
   137→  direction: 'increase' | 'decrease' | 'both';
   138→  percentageEffect: number;
   139→}
   140→
   141→export interface Recommendation {
   142→  ref_id: string;
   143→  name: string;
   144→  description: string;
   145→  phase: RecommendationPhase;
   146→  impact: number;  // 0-1 effectiveness score
   147→  coverage: number;  // Number of metrics improved
   148→  percentage: string;  // e.g., "10-20%"
   149→  expectedImprovementRange?: { min: number; max: number };
   150→  matchedFlaws: string[];
   151→  matchedRatios: string[];
   152→  ratios_impacted: RatioImpact[];
   153→  timeline: RecommendationTimeline;
   154→  cost: RecommendationCost;
   155→  risks_side_effects: string | null;
   156→  warnings: string[];
   157→  gender: 'male' | 'female' | 'both';
   158→}
   159→
   160→// ============================================
   161→// HARMONY ANALYSIS TYPES
   162→// ============================================
   163→
   164→export interface ProfileAnalysis {
   165→  standardizedScore: number;
   166→  ratios: Ratio[];
   167→  overallAIDescription?: string | null;
   168→}
   169→
   170→export interface FullHarmonyAnalysis {
   171→  standardizedScore: number;
   172→  front: ProfileAnalysis;
   173→  side: ProfileAnalysis;
   174→  strengths: Strength[];
   175→  flaws: Flaw[];
   176→}
   177→
   178→// ============================================
   179→// FACE DATA TYPES
   180→// ============================================
   181→
   182→export interface FaceData {
   183→  id: string;
   184→  userId?: string;
   185→  frontPhotoUrl: string;
   186→  sidePhotoUrl?: string;
   187→  harmonyScore: number | null;
   188→  frontHarmonyScore: number | null;
   189→  sideHarmonyScore: number | null;
   190→  gender: 'male' | 'female';
   191→  race?: string;
   192→  unlocked: boolean;
   193→  actionPlanUnlocked: boolean;
   194→  harmonyAnalysis: FullHarmonyAnalysis;
   195→}
   196→
   197→// ============================================
   198→// UI STATE TYPES
   199→// ============================================
   200→
   201→export type ResultsTab =
   202→  | 'overview'
   203→  | 'front-ratios'
   204→  | 'side-ratios'
   205→  | 'leaderboard'
   206→  | 'psl'
   207→  | 'archetype'
   208→  | 'plan'
   209→  | 'guides'
   210→  | 'shop'
   211→  | 'community'
   212→  | 'referrals'
   213→  | 'options'
   214→  | 'support';
   215→
   216→// ============================================
   217→// LEADERBOARD TYPES
   218→// ============================================
   219→
   220→export interface UserRank {
   221→  userId: string;
   222→  score: number;
   223→  globalRank: number;
   224→  genderRank: number;
   225→  percentile: number;
   226→  totalUsers: number;
   227→  genderTotal: number;
   228→  anonymousName: string;
   229→  updatedAt: string;
   230→}
   231→
   232→export interface LeaderboardEntry {
   233→  userId: string;
   234→  rank: number;
   235→  score: number;
   236→  anonymousName: string;
   237→  gender: 'male' | 'female';
   238→  facePhotoUrl: string | null;
   239→  isCurrentUser: boolean;
   240→  topStrengths: string[];
   241→  topImprovements: string[];
   242→}
   243→
   244→export interface UserProfile extends Omit<LeaderboardEntry, 'isCurrentUser'> {
   245→  topStrengths: string[];
   246→  topImprovements: string[];
   247→}
   248→
   249→export interface LeaderboardData {
   250→  entries: LeaderboardEntry[];
   251→  totalCount: number;
   252→  userRank: UserRank | null;
   253→}
   254→
   255→export interface ResultsUIState {
   256→  activeTab: ResultsTab;
   257→  expandedMeasurementId: string | null;
   258→  selectedVisualizationMetric: string | null;
   259→  categoryFilter: string | null;
   260→  showLandmarkOverlay: boolean;
   261→}
   262→
   263→// ============================================
   264→// CATEGORY TYPES
   265→// ============================================
   266→
   267→export interface MeasurementCategory {
   268→  id: string;
   269→  name: string;
   270→  color: string;
   271→  description: string;
   272→}
   273→
   274→export const MEASUREMENT_CATEGORIES: MeasurementCategory[] = [
   275→  { id: 'midface', name: 'Midface/Face Shape', color: '#67e8f9', description: 'Facial proportions and overall shape' },
   276→  { id: 'jaw-growth', name: 'Occlusion/Jaw Growth', color: '#a78bfa', description: 'Jaw development and bite alignment' },
   277→  { id: 'jaw-shape', name: 'Jaw Shape', color: '#f97316', description: 'Jawline contour and angles' },
   278→  { id: 'upper-third', name: 'Upper Third', color: '#84cc16', description: 'Forehead and hairline proportions' },
   279→  { id: 'eyes', name: 'Eyes', color: '#06b6d4', description: 'Eye shape, spacing, and canthal tilt' },
   280→  { id: 'nose', name: 'Nose', color: '#fbbf24', description: 'Nasal proportions and angles' },
   281→  { id: 'lips', name: 'Lips', color: '#ec4899', description: 'Lip proportions and projection' },
   282→  { id: 'chin', name: 'Chin', color: '#ef4444', description: 'Chin projection and shape' },
   283→  { id: 'neck', name: 'Neck', color: '#14b8a6', description: 'Neck angle and throat definition' },
   284→  { id: 'other', name: 'Other', color: '#6b7280', description: 'Additional measurements' },
   285→];
   286→
   287→// ============================================
   288→// SCORE COLOR HELPERS
   289→// ============================================
   290→
   291→export function getScoreColor(score: number): string {
   292→  if (score >= 8) return '#67e8f9';  // Cyan - ideal
   293→  if (score >= 6) return '#22c55e';  // Green - good
   294→  if (score >= 4) return '#fbbf24';  // Yellow - fair
   295→  return 'rgb(227, 67, 67)';         // Red - poor
   296→}
   297→
   298→export function getQualityColor(quality: QualityTier): string {
   299→  switch (quality) {
   300→    case 'ideal': return '#67e8f9';
   301→    case 'excellent': return '#22c55e';
   302→    case 'good': return '#fbbf24';
   303→    case 'below_average': return 'rgb(227, 67, 67)';
   304→    default: return '#6b7280';
   305→  }
   306→}
   307→
   308→export function getSeverityColor(severity: SeverityLevel): string {
   309→  switch (severity) {
   310→    case 'optimal': return '#67e8f9';
   311→    case 'minor': return '#22c55e';
   312→    case 'moderate': return '#fbbf24';
   313→    case 'major': return '#f97316';
   314→    case 'severe': return '#ef4444';
   315→    case 'extremely_severe': return '#dc2626';
   316→    default: return '#6b7280';
   317→  }
   318→}
   319→
   320→export function getCategoryColor(categoryName: string): string {
   321→  const cat = MEASUREMENT_CATEGORIES.find(c =>
   322→    c.name.toLowerCase().includes(categoryName.toLowerCase()) ||
   323→    categoryName.toLowerCase().includes(c.name.toLowerCase())
   324→  );
   325→  return cat?.color || '#6b7280';
   326→}
   327→
   328→// ============================================
   329→// UNIT FORMATTING
   330→// ============================================
   331→
   332→export function formatUnit(unit: 'x' | 'mm' | '%' | '°' | MeasurementUnit): string {
   333→  switch (unit) {
   334→    case 'x':
   335→    case 'ratio': return 'x';
   336→    case 'mm': return 'mm';
   337→    case '%':
   338→    case 'percent': return '%';
   339→    case '°':
   340→    case 'degrees': return '°';
   341→    default: return '';
   342→  }
   343→}
   344→
   345→export function formatValue(value: number | string, unit: 'x' | 'mm' | '%' | '°' | MeasurementUnit): string {
   346→  // Handle obfuscated string values
   347→  if (typeof value === 'string') {
   348→    return value;
   349→  }
   350→  const unitStr = formatUnit(unit);
   351→  if (unit === '%' || unit === 'percent') {
   352→    return `${value.toFixed(1)}${unitStr}`;
   353→  }
   354→  if (unit === '°' || unit === 'degrees') {
   355→    return `${value.toFixed(1)}${unitStr}`;
   356→  }
   357→  return `${value.toFixed(2)}${unitStr}`;
   358→}
   359→
   360→// ============================================
   361→// PRODUCT & SUPPLEMENT TYPES
   362→// ============================================
   363→
   364→export interface Product {
   365→  id: string;
   366→  name: string;
   367→  brand: string;
   368→  category: "skin" | "hair" | "anti-aging" | "hormonal" | "bone" | "general" | "jawline" | "tools" | "dental";
   369→  affiliateLink: string;
   370→  affiliateType: "amazon" | "direct";
   371→  supplementId: string;
   372→  priority: number;
   373→  baseStackItem?: boolean;
   374→  description?: string;
   375→}
   376→
   377→export interface ProductRecommendation {
   378→  product: Product;
   379→  state: "flaw" | "ideal";
   380→  targetMetric: string;
   381→  message: string;
   382→  urgency: "high" | "medium" | "low";
   383→  matchedMetrics: string[];
   384→}
   385→
   386→export interface DailyStack {
   387→  products: Product[];
   388→  totalCostPerMonth: { min: number; max: number };
   389→  timing: {
   390→    morning: Product[];
   391→    evening: Product[];
   392→    anytime: Product[];
   393→  };
   394→  rationale: string;
   395→}
   396→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
