     1→/**
     2→ * Scoring Calculator
     3→ * Core scoring algorithm functions extracted from harmony-scoring.ts
     4→ *
     5→ * Features:
     6→ * - Exponential decay scoring with per-metric decay rates
     7→ * - Bezier curve custom scoring for non-linear measurements
     8→ * - Directional/Dimorphic scoring (polarity support)
     9→ * - Quality tiers and severity levels
    10→ */
    11→
    12→import {
    13→  Point,
    14→  QualityTier,
    15→  SeverityLevel,
    16→  MeasurementUnit,
    17→  MetricConfig,
    18→  CurvePoint,
    19→  FlawMapping,
    20→} from './types';
    21→import { BEZIER_CURVES } from '@/lib/bezier-curves';
    22→
    23→// ============================================
    24→// FLAW MAPPINGS
    25→// ============================================
    26→
    27→export const METRIC_FLAW_MAPPINGS: Record<string, FlawMapping[]> = {
    28→  anteriorFacialDepth: [
    29→    { category: 'Midface/Face Shape', flawName: 'Underprojected midface', confidence: 'confirmed', reasoning: 'The Anterior Facial Depth measurement is above the ideal range. This disrupts facial harmony by creating a sunken and unprominent appearance to the midface.' },
    30→  ],
    31→  bitemporalWidth: [
    32→    { category: 'Upper Third', flawName: 'Narrow forehead', confidence: 'confirmed', reasoning: 'Reduced bitemporal width indicates a narrower than ideal forehead relative to the cheekbones. This disrupts facial harmony by creating a compressed hairline and forehead, altering the overall shape of the face.' },
    33→  ],
    34→  cheekboneHeight: [
    35→    { category: 'Midface/Face Shape', flawName: 'Low-set cheekbones', confidence: 'confirmed', reasoning: 'Reduced cheekbone height indicates that the cheekbones are positioned lower than ideal. This disrupts facial harmony by creating an unpronounced appearance to the cheekbones and facial structure.' },
    36→  ],
    37→  cheekFullness: [
    38→    { category: 'Midface/Face Shape', flawName: 'Hollow/Gaunt midface', confidence: 'confirmed', reasoning: 'Reduced cheek fullness indicates volume loss or hollow cheeks. This disrupts facial harmony by creating a gaunt or aged appearance, particularly important in South Asian and East Asian beauty standards.' },
    39→  ],
    40→  eyeAspectRatio: [
    41→    { category: 'Eyes', flawName: 'Overly round eye shape', confidence: 'confirmed', reasoning: 'A reduced eye aspect ratio indicates overly narrow eyes relative to their height. This disrupts facial harmony by creating an overly surprised appearance and reducing angular definition.' },
    42→  ],
    43→  eyeSeparationRatio: [
    44→    { category: 'Eyes', flawName: 'Close-set eyes', confidence: 'confirmed', reasoning: 'Reduced eye separation indicates close-set eyes. This disrupts facial harmony by making the eye area appear too compressed.' },
    45→  ],
    46→  eyebrowLowSetedness: [
    47→    { category: 'Eyes', flawName: 'Medium-set eyebrows', confidence: 'confirmed', reasoning: 'Increased eyebrow low setedness indicates eyebrows that are positioned higher than ideal. This disrupts facial harmony by reducing the overall visual impact of the eyebrows and framing of the eyes.' },
    48→  ],
    49→  faceWidthToHeight: [
    50→    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A reduced face width to height ratio indicates an overly long midface relative to its height. This disrupts facial harmony by overemphasizing the middle of the face.' },
    51→  ],
    52→  facialDepthToHeight: [
    53→    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'Reduced facial depth to height ratio indicates insufficient mid-face projection relative to height. This disrupts facial harmony by creating the appearance of a flat midface.' },
    54→  ],
    55→  gonialAngle: [
    56→    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'A wider gonial angle indicates a softer, less defined jawline with reduced angularity. This disrupts facial harmony in the lower face.' },
    57→    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A wider gonial angle indicates a softer, less defined jawline with reduced angularity. This disrupts facial harmony by creating a narrow or pointed chin effect.' },
    58→  ],
    59→  holdawayHLine: [
    60→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'Decreased H-line indicates the lips are positioned too far in front of the line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },
    61→  ],
    62→  interiorMidfaceProjectionAngle: [
    63→    { category: 'Midface/Face Shape', flawName: 'Underprojected midface', confidence: 'confirmed', reasoning: 'The Interior Midface Projection Angle measurement is above the ideal range. This disrupts facial harmony by creating a sunken and unprominent appearance to the midface.' },
    64→  ],
    65→  ipsilateralAlarAngle: [
    66→    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A decreased ipsilateral alar angle indicates an overly narrow interior midface. This disrupts facial harmony by overemphasizing the middle of the face.' },
    67→  ],
    68→  jawFrontalAngle: [
    69→    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A narrower jaw frontal angle indicates a steeper jawline or overly wide chin. This disrupts facial harmony by creating a narrow or pointed chin effect.' },
    70→  ],
    71→  jawSlope: [
    72→    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'The Jaw Slope measurement is above the ideal range. This disrupts facial harmony in the lower face.' },
    73→  ],
    74→  lateralCanthalTilt: [
    75→    { category: 'Eyes', flawName: 'Insufficient eye tilt', confidence: 'confirmed', reasoning: 'A decreased lateral canthal tilt indicates insufficiently upturned eyes. This disrupts facial harmony by creating a less alert and youthful appearance.' },
    76→  ],
    77→  burstoneLowerLip: [
    78→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned excessively in front of the Burstone line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },
    79→  ],
    80→  eLineLowerLip: [
    81→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned too far in front of the E-line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },
    82→  ],
    83→  sLineLowerLip: [
    84→    { category: 'Lips', flawName: 'Overly full lower lip', confidence: 'confirmed', reasoning: 'The lower lip is positioned excessively in front of the S-line. This disrupts facial harmony by drawing attention to the lower lip and creating an imbalance between the lower lip, chin, and nose.' },
    85→  ],
    86→  lowerThirdProportion: [
    87→    { category: 'Midface/Face Shape', flawName: 'Long upper jaw', confidence: 'confirmed', reasoning: 'The upper jaw is too long relative to lower jaw, possibly from a long upper jaw or short lower jaw, or a combination of both. This disrupts facial harmony by overemphasizing the upper jaw relative to the lower jaw.' },
    88→  ],
    89→  mandibularPlaneAngle: [
    90→    { category: 'Occlusion/Jaw Growth', flawName: 'Hyper-divergent jaw growth', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony by elongating the lower face.' },
    91→    { category: 'Jaw Shape', flawName: 'Weak/soft jaw structure', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony in the lower face.' },
    92→    { category: 'Jaw Shape', flawName: 'Steep jaw', confidence: 'confirmed', reasoning: 'A steeper mandibular plane angle indicates vertical overgrowth, elongating the lower face and potentially indicating malocclusion. This disrupts facial harmony by creating a narrow or pointed chin effect.' },
    93→  ],
    94→  midfaceRatio: [
    95→    { category: 'Midface/Face Shape', flawName: 'Long midface', confidence: 'confirmed', reasoning: 'A reduced midface ratio indicates an overly narrow interior midface relative to its height. This disrupts facial harmony by overemphasizing the middle of the face.' },
    96→    { category: 'Midface/Face Shape', flawName: 'Long upper jaw', confidence: 'confirmed', reasoning: 'A reduced midface ratio indicates an overly narrow interior midface relative to its height. This disrupts facial harmony by overemphasizing the upper jaw relative to the lower jaw.' },
    97→  ],
    98→  nasofacialAngle: [
    99→    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'A smaller nasofacial angle suggests reduced projection of the nose and midface region, or an overprojected chin. This disrupts facial harmony by creating the appearance of a flat midface.' },
   100→  ],
   101→  nasofrontalAngle: [
   102→    { category: 'Upper Third', flawName: 'Soft and weak brow ridge', confidence: 'confirmed', reasoning: 'An increased nasofrontal angle indicates reduced brow ridge prominence and angularity. This disrupts facial harmony by creating a less defined upper face.' },
   103→  ],
   104→  nasomentaAngle: [
   105→    { category: 'Occlusion/Jaw Growth', flawName: 'Maxillary recession', confidence: 'confirmed', reasoning: 'A larger nasomental angle suggests reduced projection of the nose and midface region, or an overprojected chin. This disrupts facial harmony by creating the appearance of a flat midface.' },
   106→  ],
   107→  noseBridgeWidth: [
   108→    { category: 'Nose', flawName: 'Overly narrow nose bridge', confidence: 'confirmed', reasoning: 'The Nose Bridge to Nose Width measurement is above the ideal range. This disrupts facial harmony by creating an unbalanced nasal profile.' },
   109→  ],
   110→  orbitalVector: [
   111→    { category: 'Eyes', flawName: 'Sunken orbital region', confidence: 'confirmed', reasoning: 'A decreased orbital vector indicates insufficient projection and volume underneath the eye. This disrupts facial harmony due to the lacking volume underneath the eyes, reducing vibrancy and youthfulness.' },
   112→  ],
   113→  ramusToMandibleRatio: [
   114→    { category: 'Jaw Shape', flawName: 'Short ramus', confidence: 'confirmed', reasoning: 'A reduced ramus-to-mandible ratio indicates a shorter than ideal vertical jawbone (ramus) when compared to the mandible. This disrupts facial harmony by reducing jaw height and definition.' },
   115→  ],
   116→  submentalCervicalAngle: [
   117→    { category: 'Neck', flawName: 'Round neck region', confidence: 'confirmed', reasoning: 'An increased submental cervical angle indicates a round neck region, possibly from excess submental fat or tissue. This disrupts facial harmony by reducing neck definition.' },
   118→  ],
   119→  totalFacialWidthToHeight: [
   120→    { category: 'Midface/Face Shape', flawName: 'Overly long face shape', confidence: 'confirmed', reasoning: 'An increased total facial width to height ratio indicates an overly long face relative to its height. This disrupts facial harmony by creating a vertically stretched appearance to the face.' },
   121→  ],
   122→};
   123→
   124→// ============================================
   125→// CUSTOM BEZIER CURVES (Ethnicity-specific override)
   126→// ============================================
   127→
   128→export const METRIC_CUSTOM_CURVES: Record<string, CurvePoint[]> = {
   129→  faceWidthToHeight: [
   130→    { x: 1.49, y: 0, leftHandleX: 1.44, leftHandleY: 0, rightHandleX: 1.55, rightHandleY: 0 },
   131→    { x: 1.68, y: 1.05, leftHandleX: 1.62, leftHandleY: 0.36, rightHandleX: 1.71, rightHandleY: 1.58 },
   132→    { x: 1.77, y: 3.07, leftHandleX: 1.74, leftHandleY: 2.15, rightHandleX: 1.79, rightHandleY: 3.88 },
   133→    { x: 1.83, y: 5.83, leftHandleX: 1.8, leftHandleY: 4.64, rightHandleX: 1.84, rightHandleY: 6.85 },
   134→    { x: 1.89, y: 8.7, leftHandleX: 1.88, leftHandleY: 8.3, rightHandleX: 1.92, rightHandleY: 9.5 },
   135→    { x: 1.96, y: 10, leftHandleX: 1.96, leftHandleY: 10, rightHandleX: 1.96, rightHandleY: 10, fixed: true },
   136→    { x: 2, y: 10, leftHandleX: 2, leftHandleY: 10, rightHandleX: 2, rightHandleY: 10 },
   137→    { x: 2.07, y: 8.7, leftHandleX: 2.04, leftHandleY: 9.5, rightHandleX: 2.08, rightHandleY: 8.3 },
   138→    { x: 2.13, y: 5.83, leftHandleX: 2.12, leftHandleY: 6.85, rightHandleX: 2.16, rightHandleY: 4.64 },
   139→    { x: 2.19, y: 3.07, leftHandleX: 2.17, leftHandleY: 3.88, rightHandleX: 2.22, rightHandleY: 2.15 },
   140→    { x: 2.28, y: 1.05, leftHandleX: 2.25, leftHandleY: 1.58, rightHandleX: 2.34, rightHandleY: 0.36 },
   141→    { x: 2.47, y: 0, leftHandleX: 2.41, leftHandleY: 0, rightHandleX: 2.52, rightHandleY: 0 },
   142→  ],
   143→  lowerThirdProportion: [
   144→    { x: 25.6, y: 0, leftHandleX: 24.8, leftHandleY: 0, rightHandleX: 26.4, rightHandleY: 0 },
   145→    { x: 28.01, y: 1.58, leftHandleX: 27.23, leftHandleY: 0.53, rightHandleX: 28.27, rightHandleY: 1.97 },
   146→    { x: 28.83, y: 3.21, leftHandleX: 28.62, leftHandleY: 2.59, rightHandleX: 29.03, rightHandleY: 3.76 },
   147→    { x: 29.63, y: 5.85, leftHandleX: 29.38, leftHandleY: 4.64, rightHandleX: 29.84, rightHandleY: 6.61 },
   148→    { x: 30.27, y: 8.56, leftHandleX: 30.1, leftHandleY: 7.71, rightHandleX: 30.52, rightHandleY: 9.42 },
   149→    { x: 31, y: 10, leftHandleX: 30.88, leftHandleY: 10, rightHandleX: 31.13, rightHandleY: 10, fixed: true },
   150→    { x: 33.5, y: 10, leftHandleX: 33.38, leftHandleY: 10, rightHandleX: 33.63, rightHandleY: 10 },
   151→    { x: 34.23, y: 8.56, leftHandleX: 33.98, leftHandleY: 9.42, rightHandleX: 34.4, rightHandleY: 7.71 },
   152→    { x: 34.87, y: 5.85, leftHandleX: 34.66, leftHandleY: 6.61, rightHandleX: 35.12, rightHandleY: 4.64 },
   153→    { x: 35.67, y: 3.21, leftHandleX: 35.47, leftHandleY: 3.76, rightHandleX: 35.88, rightHandleY: 2.59 },
   154→    { x: 36.49, y: 1.58, leftHandleX: 36.23, leftHandleY: 1.97, rightHandleX: 37.27, rightHandleY: 0.53 },
   155→    { x: 38.9, y: 0, leftHandleX: 38.1, leftHandleY: 0, rightHandleX: 39.7, rightHandleY: 0 },
   156→  ],
   157→  eyeAspectRatio: [
   158→    { x: 1.44, y: 0, leftHandleX: 1.18, leftHandleY: 0, rightHandleX: 1.75, rightHandleY: 0.38 },
   159→    { x: 2.07, y: 1.66, leftHandleX: 1.96, leftHandleY: 1.08, rightHandleX: 2.24, rightHandleY: 2.63 },
   160→    { x: 2.42, y: 4.34, leftHandleX: 2.35, leftHandleY: 3.6, rightHandleX: 2.52, rightHandleY: 5.5 },
   161→    { x: 2.71, y: 7.96, leftHandleX: 2.65, leftHandleY: 7.13, rightHandleX: 2.8, rightHandleY: 9.08 },
   162→    { x: 3, y: 10, leftHandleX: 2.98, leftHandleY: 10, rightHandleX: 3.03, rightHandleY: 10, fixed: true },
   163→    { x: 3.5, y: 10, leftHandleX: 3.48, leftHandleY: 10, rightHandleX: 3.53, rightHandleY: 10 },
   164→    { x: 3.79, y: 7.96, leftHandleX: 3.7, leftHandleY: 9.08, rightHandleX: 3.85, rightHandleY: 7.13 },
   165→    { x: 4.08, y: 4.34, leftHandleX: 3.98, leftHandleY: 5.5, rightHandleX: 4.15, rightHandleY: 3.6 },
   166→    { x: 4.43, y: 1.66, leftHandleX: 4.26, leftHandleY: 2.63, rightHandleX: 4.54, rightHandleY: 1.08 },
   167→    { x: 5.06, y: 0, leftHandleX: 4.75, leftHandleY: 0.38, rightHandleX: 5.32, rightHandleY: 0 },
   168→  ],
   169→  // Note: Additional curves can be added from METRIC_CUSTOM_CURVES in harmony-scoring.ts
   170→};
   171→
   172→// ============================================
   173→// CORE SCORING FUNCTIONS
   174→// ============================================
   175→
   176→/**
   177→ * Exponential Decay Scoring Algorithm with Directional/Dimorphic Support
   178→ *
   179→ * Standard: score = maxScore * e^(-decayRate * deviation)
   180→ *
   181→ * Directional scoring (polarity):
   182→ * - 'higher_is_better': Values above safeFloor but below ideal get softZoneScore
   183→ *   Example: Canthal Tilt of 3 degrees is still positive/good, just not peak ideal (6-8 degrees)
   184→ * - 'lower_is_better': Values below safeCeiling but above ideal get softZoneScore
   185→ *   Example: Short philtrum is still attractive even if shorter than "ideal"
   186→ */
   187→export function calculateMetricScore(
   188→  value: number,
   189→  config: MetricConfig
   190→): number {
   191→  const {
   192→    id,
   193→    idealMin,
   194→    idealMax,
   195→    decayRate,
   196→    maxScore,
   197→    customCurve,
   198→    polarity = 'balanced',
   199→    safeFloor,
   200→    safeCeiling,
   201→    softZoneScore = 8.0, // Default "Good" score for acceptable-but-not-ideal values
   202→  } = config;
   203→
   204→  // IMPORTANT: Check demographic-adjusted ideal range FIRST
   205→  // This ensures that demographic overrides are respected even when Bezier curves exist
   206→  // (Bezier curves are optimized for base ranges and don't auto-adjust for demographics)
   207→  if (value >= idealMin && value <= idealMax) {
   208→    return maxScore;
   209→  }
   210→
   211→  // Use custom curve if available in config
   212→  if (customCurve && customCurve.mode === 'custom') {
   213→    const bezierScore = interpolateCustomCurve(value, customCurve.points, maxScore);
   214→    // If Bezier returns -1, it means value is out of range with edge y=0
   215→    // Fall through to exponential decay instead of returning 0
   216→    if (bezierScore >= 0) {
   217→      // Clamp to valid range [0, maxScore] to prevent Bezier overshoot
   218→      return Math.max(0, Math.min(maxScore, bezierScore));
   219→    }
   220→  }
   221→
   222→  // Check for pre-defined Bezier curve from harmony curves (66 metrics)
   223→  const bezierCurve = BEZIER_CURVES[id];
   224→  if (bezierCurve && bezierCurve.mode === 'custom') {
   225→    const bezierScore = interpolateCustomCurve(value, bezierCurve.points, maxScore);
   226→    // If Bezier returns -1, it means value is out of range with edge y=0
   227→    // Fall through to exponential decay instead of returning 0
   228→    if (bezierScore >= 0) {
   229→      // Clamp to valid range [0, maxScore] to prevent Bezier overshoot
   230→      return Math.max(0, Math.min(maxScore, bezierScore));
   231→    }
   232→  }
   233→
   234→  // Handle directional/dimorphic scoring
   235→  if (polarity === 'higher_is_better' && safeFloor !== undefined) {
   236→    // Higher values are good. Only values below safeFloor are true weaknesses.
   237→    if (value >= safeFloor && value < idealMin) {
   238→      // Value is in the "acceptable but not ideal" zone
   239→      // Give a passing score that decreases linearly as we approach the floor
   240→      const zoneRange = idealMin - safeFloor;
   241→      const distanceFromIdeal = idealMin - value;
   242→      const t = zoneRange > 0 ? distanceFromIdeal / zoneRange : 0;
   243→      // Linear interpolation: idealMin -> maxScore, safeFloor -> softZoneScore
   244→      return maxScore - t * (maxScore - softZoneScore);
   245→    }
   246→    if (value >= idealMax) {
   247→      // Values above ideal are still excellent for 'higher_is_better'
   248→      // Apply gentler decay (1/3 the normal rate)
   249→      const deviation = value - idealMax;
   250→      const gentleDecay = decayRate / 3;
   251→      return Math.max(softZoneScore, maxScore * Math.exp(-gentleDecay * deviation));
   252→    }
   253→    // Below safeFloor - apply normal (or harsher) exponential decay
   254→    if (value < safeFloor) {
   255→      const deviation = safeFloor - value;
   256→      return Math.max(0, softZoneScore * Math.exp(-decayRate * deviation));
   257→    }
   258→  }
   259→
   260→  if (polarity === 'lower_is_better' && safeCeiling !== undefined) {
   261→    // Lower values are good. Only values above safeCeiling are true weaknesses.
   262→    if (value <= safeCeiling && value > idealMax) {
   263→      // Value is in the "acceptable but not ideal" zone
   264→      const zoneRange = safeCeiling - idealMax;
   265→      const distanceFromIdeal = value - idealMax;
   266→      const t = zoneRange > 0 ? distanceFromIdeal / zoneRange : 0;
   267→      // Linear interpolation: idealMax -> maxScore, safeCeiling -> softZoneScore
   268→      return maxScore - t * (maxScore - softZoneScore);
   269→    }
   270→    if (value <= idealMin) {
   271→      // Values below ideal are still excellent for 'lower_is_better'
   272→      // Apply gentler decay (1/3 the normal rate)
   273→      const deviation = idealMin - value;
   274→      const gentleDecay = decayRate / 3;
   275→      return Math.max(softZoneScore, maxScore * Math.exp(-gentleDecay * deviation));
   276→    }
   277→    // Above safeCeiling - apply normal exponential decay
   278→    if (value > safeCeiling) {
   279→      const deviation = value - safeCeiling;
   280→      return Math.max(0, softZoneScore * Math.exp(-decayRate * deviation));
   281→    }
   282→  }
   283→
   284→  // Default balanced scoring: deviation in either direction is equally bad
   285→  const deviation = value < idealMin
   286→    ? idealMin - value
   287→    : value - idealMax;
   288→
   289→  // Exponential decay
   290→  const score = maxScore * Math.exp(-decayRate * deviation);
   291→
   292→  return Math.max(0, Math.min(maxScore, score));
   293→}
   294→
   295→/**
   296→ * Check if a metric value is in an "acceptable" zone (not a true weakness).
   297→ * Used by InsightsEngine to prevent false positives.
   298→ */
   299→export function isValueAcceptable(
   300→  value: number,
   301→  config: MetricConfig
   302→): { acceptable: boolean; reason: string } {
   303→  const {
   304→    idealMin,
   305→    idealMax,
   306→    polarity = 'balanced',
   307→    safeFloor,
   308→    safeCeiling,
   309→  } = config;
   310→
   311→  // Within ideal range is always acceptable
   312→  if (value >= idealMin && value <= idealMax) {
   313→    return { acceptable: true, reason: 'within_ideal' };
   314→  }
   315→
   316→  // Check directional acceptability
   317→  if (polarity === 'higher_is_better') {
   318→    if (value >= idealMax) {
   319→      return { acceptable: true, reason: 'above_ideal_higher_is_better' };
   320→    }
   321→    if (safeFloor !== undefined && value >= safeFloor) {
   322→      return { acceptable: true, reason: 'above_safe_floor' };
   323→    }
   324→    // Below safe floor - true weakness
   325→    return { acceptable: false, reason: 'below_safe_floor' };
   326→  }
   327→
   328→  if (polarity === 'lower_is_better') {
   329→    if (value <= idealMin) {
   330→      return { acceptable: true, reason: 'below_ideal_lower_is_better' };
   331→    }
   332→    if (safeCeiling !== undefined && value <= safeCeiling) {
   333→      return { acceptable: true, reason: 'below_safe_ceiling' };
   334→    }
   335→    // Above safe ceiling - true weakness
   336→    return { acceptable: false, reason: 'above_safe_ceiling' };
   337→  }
   338→
   339→  // Balanced polarity - outside ideal is not acceptable
   340→  return { acceptable: false, reason: 'outside_ideal_balanced' };
   341→}
   342→
   343→/**
   344→ * Interpolate custom Bezier curve for scoring
   345→ * Uses cubic Bezier interpolation with control handles for smooth curves
   346→ *
   347→ * IMPORTANT: When value is outside the curve range and the edge y-value is 0,
   348→ * returns -1 to signal the caller should use exponential decay fallback.
   349→ * This prevents artificially returning 0 for values just outside the curve.
   350→ */
   351→export function interpolateCustomCurve(
   352→  value: number,
   353→  points: CurvePoint[],
   354→  maxScore: number
   355→): number {
   356→  void maxScore; // Reserved for future custom curve implementations
   357→  if (points.length === 0) return -1; // Signal to use fallback
   358→
   359→  // Sort points by x value
   360→  const sortedPoints = [...points].sort((a, b) => a.x - b.x);
   361→
   362→  // Handle out-of-range values
   363→  // If edge y-value is 0, return -1 to signal exponential decay fallback should be used
   364→  if (value <= sortedPoints[0].x) {
   365→    const edgeY = sortedPoints[0].y;
   366→    // If edge score is 0, signal to use exponential decay fallback
   367→    return edgeY <= 0 ? -1 : edgeY;
   368→  }
   369→  if (value >= sortedPoints[sortedPoints.length - 1].x) {
   370→    const edgeY = sortedPoints[sortedPoints.length - 1].y;
   371→    // If edge score is 0, signal to use exponential decay fallback
   372→    return edgeY <= 0 ? -1 : edgeY;
   373→  }
   374→
   375→  // Find bracketing points
   376→  let lowerIndex = 0;
   377→  for (let i = 0; i < sortedPoints.length - 1; i++) {
   378→    if (value >= sortedPoints[i].x && value <= sortedPoints[i + 1].x) {
   379→      lowerIndex = i;
   380→      break;
   381→    }
   382→  }
   383→
   384→  const p0 = sortedPoints[lowerIndex];
   385→  const p3 = sortedPoints[lowerIndex + 1];
   386→
   387→  // Check if we have Bezier control handles
   388→  const hasHandles = p0.rightHandleX !== undefined && p3.leftHandleX !== undefined;
   389→
   390→  if (hasHandles) {
   391→    // Cubic Bezier interpolation with control points
   392→    const p1x = p0.rightHandleX!;
   393→    const p1y = p0.rightHandleY ?? p0.y;
   394→    const p2x = p3.leftHandleX!;
   395→    const p2y = p3.leftHandleY ?? p3.y;
   396→
   397→    // Find t parameter for given x value using Newton-Raphson iteration
   398→    let t = (value - p0.x) / (p3.x - p0.x); // Initial guess
   399→
   400→    // Newton-Raphson iterations to find t where B_x(t) = value
   401→    for (let iter = 0; iter < 10; iter++) {
   402→      const bx = cubicBezier(p0.x, p1x, p2x, p3.x, t);
   403→      const bxDerivative = cubicBezierDerivative(p0.x, p1x, p2x, p3.x, t);
   404→
   405→      if (Math.abs(bxDerivative) < 1e-10) break;
   406→
   407→      const newT = t - (bx - value) / bxDerivative;
   408→      if (Math.abs(newT - t) < 1e-10) break;
   409→      t = Math.max(0, Math.min(1, newT));
   410→    }
   411→
   412→    // Calculate y using the found t parameter
   413→    return cubicBezier(p0.y, p1y, p2y, p3.y, t);
   414→  } else {
   415→    // Smooth interpolation using Catmull-Rom spline
   416→    // This provides smoother curves than linear interpolation
   417→    const t = (value - p0.x) / (p3.x - p0.x);
   418→
   419→    // Get neighboring points for spline calculation
   420→    const pMinus1 = lowerIndex > 0 ? sortedPoints[lowerIndex - 1] : p0;
   421→    const p4 = lowerIndex + 2 < sortedPoints.length ? sortedPoints[lowerIndex + 2] : p3;
   422→
   423→    // Catmull-Rom spline interpolation
   424→    return catmullRomSpline(pMinus1.y, p0.y, p3.y, p4.y, t);
   425→  }
   426→}
   427→
   428→/**
   429→ * Cubic Bezier curve evaluation: B(t) = (1-t)^3*P0 + 3*(1-t)^2*t*P1 + 3*(1-t)*t^2*P2 + t^3*P3
   430→ */
   431→export function cubicBezier(p0: number, p1: number, p2: number, p3: number, t: number): number {
   432→  const mt = 1 - t;
   433→  const mt2 = mt * mt;
   434→  const mt3 = mt2 * mt;
   435→  const t2 = t * t;
   436→  const t3 = t2 * t;
   437→  return mt3 * p0 + 3 * mt2 * t * p1 + 3 * mt * t2 * p2 + t3 * p3;
   438→}
   439→
   440→/**
   441→ * Cubic Bezier derivative: B'(t) = 3*(1-t)^2*(P1-P0) + 6*(1-t)*t*(P2-P1) + 3*t^2*(P3-P2)
   442→ */
   443→export function cubicBezierDerivative(p0: number, p1: number, p2: number, p3: number, t: number): number {
   444→  const mt = 1 - t;
   445→  return 3 * mt * mt * (p1 - p0) + 6 * mt * t * (p2 - p1) + 3 * t * t * (p3 - p2);
   446→}
   447→
   448→/**
   449→ * Catmull-Rom spline interpolation for smooth curves without explicit handles
   450→ */
   451→export function catmullRomSpline(p0: number, p1: number, p2: number, p3: number, t: number): number {
   452→  const t2 = t * t;
   453→  const t3 = t2 * t;
   454→
   455→  // Catmull-Rom coefficients with tension = 0.5
   456→  const a = -0.5 * p0 + 1.5 * p1 - 1.5 * p2 + 0.5 * p3;
   457→  const b = p0 - 2.5 * p1 + 2 * p2 - 0.5 * p3;
   458→  const c = -0.5 * p0 + 0.5 * p2;
   459→  const d = p1;
   460→
   461→  return a * t3 + b * t2 + c * t + d;
   462→}
   463→
   464→/**
   465→ * Calculate standardized score (0-10 normalized)
   466→ * Clamps output to [0, 10] to prevent display issues from scoring edge cases
   467→ */
   468→export function standardizeScore(score: number, maxScore: number): number {
   469→  const normalized = (score / maxScore) * 10;
   470→  return Math.max(0, Math.min(10, normalized));
   471→}
   472→
   473→/**
   474→ * Determine quality tier based on score
   475→ */
   476→export function getQualityTier(score: number, maxScore: number = 10): QualityTier {
   477→  const normalized = (score / maxScore) * 100;
   478→
   479→  if (normalized >= 90) return 'ideal';
   480→  if (normalized >= 70) return 'excellent';
   481→  if (normalized >= 50) return 'good';
   482→  return 'below_average';
   483→}
   484→
   485→/**
   486→ * Determine severity level based on score
   487→ */
   488→export function getSeverityLevel(score: number, maxScore: number = 10): SeverityLevel {
   489→  const normalized = (score / maxScore) * 100;
   490→
   491→  if (normalized >= 85) return 'optimal';
   492→  if (normalized >= 70) return 'minor';
   493→  if (normalized >= 50) return 'moderate';
   494→  if (normalized >= 30) return 'major';
   495→  if (normalized >= 15) return 'severe';
   496→  return 'extremely_severe';
   497→}
   498→
   499→/**
   500→ * Calculate deviation description
   501→ */
   502→export function getDeviationDescription(
   503→  value: number,
   504→  idealMin: number,
   505→  idealMax: number,
   506→  unit: MeasurementUnit
   507→): { deviation: number; direction: 'above' | 'below' | 'within'; description: string } {
   508→  if (value >= idealMin && value <= idealMax) {
   509→    return { deviation: 0, direction: 'within', description: 'within ideal range' };
   510→  }
   511→
   512→  const unitLabel = getUnitLabel(unit);
   513→
   514→  if (value < idealMin) {
   515→    const dev = idealMin - value;
   516→    return {
   517→      deviation: dev,
   518→      direction: 'below',
   519→      description: `${dev.toFixed(2)}${unitLabel} below ideal`,
   520→    };
   521→  }
   522→
   523→  const dev = value - idealMax;
   524→  return {
   525→    deviation: dev,
   526→    direction: 'above',
   527→    description: `${dev.toFixed(2)}${unitLabel} above ideal`,
   528→  };
   529→}
   530→
   531→/**
   532→ * Get unit label for display
   533→ */
   534→export function getUnitLabel(unit: MeasurementUnit): string {
   535→  switch (unit) {
   536→    case 'ratio': return 'x';
   537→    case 'percent': return '%';
   538→    case 'degrees': return '\u00B0';
   539→    case 'mm': return 'mm';
   540→    default: return '';
   541→  }
   542→}
   543→
   544→// ============================================
   545→// GEOMETRY HELPERS
   546→// ============================================
   547→
   548→/**
   549→ * Calculate distance between two points
   550→ */
   551→export function distance(p1: Point, p2: Point): number {
   552→  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
   553→}
   554→
   555→/**
   556→ * Calculate angle at vertex point (in degrees)
   557→ */
   558→export function calculateAngle(p1: Point, vertex: Point, p2: Point): number {
   559→  const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
   560→  const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };
   561→
   562→  const dot = v1.x * v2.x + v1.y * v2.y;
   563→  const cross = v1.x * v2.y - v1.y * v2.x;
   564→
   565→  const angle = Math.atan2(cross, dot) * (180 / Math.PI);
   566→  return Math.abs(angle);
   567→}
   568→
   569→/**
   570→ * Calculate perpendicular distance from point to line (signed)
   571→ */
   572→export function perpendicularDistance(
   573→  point: Point,
   574→  lineStart: Point,
   575→  lineEnd: Point
   576→): number {
   577→  const A = point.x - lineStart.x;
   578→  const B = point.y - lineStart.y;
   579→  const C = lineEnd.x - lineStart.x;
   580→  const D = lineEnd.y - lineStart.y;
   581→
   582→  const dot = A * C + B * D;
   583→  const lenSq = C * C + D * D;
   584→  const param = lenSq !== 0 ? dot / lenSq : -1;
   585→
   586→  let xx: number, yy: number;
   587→
   588→  if (param < 0) {
   589→    xx = lineStart.x;
   590→    yy = lineStart.y;
   591→  } else if (param > 1) {
   592→    xx = lineEnd.x;
   593→    yy = lineEnd.y;
   594→  } else {
   595→    xx = lineStart.x + param * C;
   596→    yy = lineStart.y + param * D;
   597→  }
   598→
   599→  const dx = point.x - xx;
   600→  const dy = point.y - yy;
   601→
   602→  const sign =
   603→    (lineEnd.y - lineStart.y) * point.x -
   604→      (lineEnd.x - lineStart.x) * point.y +
   605→      lineEnd.x * lineStart.y -
   606→      lineEnd.y * lineStart.x >=
   607→    0
   608→      ? 1
   609→      : -1;
   610→
   611→  return sign * Math.sqrt(dx * dx + dy * dy);
   612→}
   613→
   614→// ============================================
   615→// PERCENTILE & PSL CONVERSION
   616→// ============================================
   617→
   618→/**
   619→ * Calculate percentile from harmony score
   620→ */
   621→export function calculateHarmonyPercentile(score: number): number {
   622→  // Based on normal distribution with mean=5, stdDev=1.5
   623→  const mean = 5;
   624→  const stdDev = 1.5;
   625→  const z = (score - mean) / stdDev;
   626→  return normalCDF(z) * 100;
   627→}
   628→
   629→/**
   630→ * Standard normal CDF approximation
   631→ */
   632→export function normalCDF(z: number): number {
   633→  const a1 = 0.254829592;
   634→  const a2 = -0.284496736;
   635→  const a3 = 1.421413741;
   636→  const a4 = -1.453152027;
   637→  const a5 = 1.061405429;
   638→  const p = 0.3275911;
   639→
   640→  const sign = z < 0 ? -1 : 1;
   641→  const absZ = Math.abs(z) / Math.sqrt(2);
   642→
   643→  const t = 1.0 / (1.0 + p * absZ);
   644→  const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-absZ * absZ);
   645→
   646→  return 0.5 * (1.0 + sign * y);
   647→}
   648→
   649→// ============================================
   650→// PSL RATING CONVERSION
   651→// ============================================
   652→
   653→export interface PSLRating {
   654→  score: number;
   655→  tier: string;
   656→  percentile: number;
   657→  description: string;
   658→}
   659→
   660→/**
   661→ * Convert harmony score to PSL rating
   662→ */
   663→export function convertToPSL(harmonyScore: number): PSLRating {
   664→  // Convert 0-10 harmony to 3.0-7.5 PSL range
   665→  const psl = 3.0 + (harmonyScore / 10) * 4.5;
   666→  const clampedPSL = Math.max(3.0, Math.min(7.5, psl));
   667→
   668→  let tier: string;
   669→  let percentile: number;
   670→
   671→  if (clampedPSL >= 7.5) {
   672→    tier = 'Top Model';
   673→    percentile = 99.99;
   674→  } else if (clampedPSL >= 7.0) {
   675→    tier = 'Chad';
   676→    percentile = 99.87;
   677→  } else if (clampedPSL >= 6.5) {
   678→    tier = 'Chadlite';
   679→    percentile = 99.0;
   680→  } else if (clampedPSL >= 6.0) {
   681→    tier = 'High Tier Normie+';
   682→    percentile = 97.25;
   683→  } else if (clampedPSL >= 5.5) {
   684→    tier = 'High Tier Normie';
   685→    percentile = 90.0;
   686→  } else if (clampedPSL >= 5.0) {
   687→    tier = 'Mid Tier Normie+';
   688→    percentile = 84.15;
   689→  } else if (clampedPSL >= 4.5) {
   690→    tier = 'Mid Tier Normie';
   691→    percentile = 65.0;
   692→  } else if (clampedPSL >= 4.0) {
   693→    tier = 'Low Tier Normie';
   694→    percentile = 50.0;
   695→  } else if (clampedPSL >= 3.5) {
   696→    tier = 'Below Average';
   697→    percentile = 30.0;
   698→  } else {
   699→    tier = 'Subpar';
   700→    percentile = 15.0;
   701→  }
   702→
   703→  return {
   704→    score: clampedPSL,
   705→    tier,
   706→    percentile,
   707→    description: `${tier} (top ${(100 - percentile).toFixed(1)}%)`,
   708→  };
   709→}
   710→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
