     1→/**
     2→ * PSL (Pretty Scale Level) Calculator
     3→ *
     4→ * Implements the PSL scoring formula:
     5→ * PSL = (Face × 0.75) + (Height × 0.20) + (Body × 0.05) + Bonuses - Penalties
     6→ */
     7→
     8→import {
     9→  PSLInput,
    10→  PSLResult,
    11→  PSLBreakdown,
    12→  PSLTier,
    13→  Gender,
    14→  MuscleLevel,
    15→  PSL_WEIGHTS,
    16→  THRESHOLD_BONUSES,
    17→  SYNERGY_BONUSES,
    18→  TIER_DEFINITIONS,
    19→  MALE_HEIGHT_RATINGS,
    20→  FEMALE_HEIGHT_RATINGS,
    21→  BODY_RATINGS,
    22→  TierInfo,
    23→  PSLVisionData,
    24→} from '@/types/psl';
    25→import { calculateFFMI, FFMIResult } from './ffmi-calculator';
    26→
    27→// ============================================
    28→// HEIGHT RATING
    29→// ============================================
    30→
    31→/**
    32→ * Get height rating (0-10) based on height in cm and gender
    33→ * Uses linear interpolation between defined points
    34→ */
    35→export function getHeightRating(heightCm: number, gender: Gender): number {
    36→  const table = gender === 'male' ? MALE_HEIGHT_RATINGS : FEMALE_HEIGHT_RATINGS;
    37→
    38→  // Handle below minimum
    39→  if (heightCm <= table[0].heightCm) {
    40→    return table[0].rating;
    41→  }
    42→
    43→  // Handle above maximum
    44→  const lastEntry = table[table.length - 1];
    45→  if (heightCm >= lastEntry.heightCm) {
    46→    return lastEntry.rating;
    47→  }
    48→
    49→  // Find the two entries to interpolate between
    50→  for (let i = 0; i < table.length - 1; i++) {
    51→    const lower = table[i];
    52→    const upper = table[i + 1];
    53→
    54→    if (heightCm >= lower.heightCm && heightCm < upper.heightCm) {
    55→      // Linear interpolation
    56→      const ratio = (heightCm - lower.heightCm) / (upper.heightCm - lower.heightCm);
    57→      return lower.rating + ratio * (upper.rating - lower.rating);
    58→    }
    59→  }
    60→
    61→  return 5.0; // Default fallback
    62→}
    63→
    64→/**
    65→ * Get display string for height
    66→ */
    67→export function formatHeightDisplay(heightCm: number, gender: Gender): string {
    68→  const table = gender === 'male' ? MALE_HEIGHT_RATINGS : FEMALE_HEIGHT_RATINGS;
    69→
    70→  // Find closest entry
    71→  let closest = table[0];
    72→  let minDiff = Math.abs(heightCm - table[0].heightCm);
    73→
    74→  for (const entry of table) {
    75→    const diff = Math.abs(heightCm - entry.heightCm);
    76→    if (diff < minDiff) {
    77→      minDiff = diff;
    78→      closest = entry;
    79→    }
    80→  }
    81→
    82→  return closest.displayHeight;
    83→}
    84→
    85→// ============================================
    86→// BODY RATING
    87→// ============================================
    88→
    89→/**
    90→ * Get body rating (0-10) based on body fat % and muscle level
    91→ */
    92→export function getBodyRating(bodyFatPercent: number, muscleLevel: MuscleLevel): number {
    93→  // Default if no body analysis available
    94→  if (bodyFatPercent === undefined || muscleLevel === undefined) {
    95→    return 5.0;
    96→  }
    97→
    98→  // Find matching entry based on body fat and muscle level
    99→  const matchingEntry = BODY_RATINGS.find(
   100→    (entry) =>
   101→      bodyFatPercent >= entry.bodyFatMin &&
   102→      bodyFatPercent < entry.bodyFatMax &&
   103→      entry.muscleLevel === muscleLevel
   104→  );
   105→
   106→  if (matchingEntry) {
   107→    return matchingEntry.rating;
   108→  }
   109→
   110→  // Fallback: find by body fat only
   111→  const byBodyFat = BODY_RATINGS.find(
   112→    (entry) => bodyFatPercent >= entry.bodyFatMin && bodyFatPercent < entry.bodyFatMax
   113→  );
   114→
   115→  if (byBodyFat) {
   116→    return byBodyFat.rating;
   117→  }
   118→
   119→  // Default average
   120→  return 5.0;
   121→}
   122→
   123→/**
   124→ * Get body rating using FFMI calculation (more accurate when weight is available)
   125→ * Returns the FFMI result along with the rating for display purposes
   126→ */
   127→export function getBodyRatingFromFFMI(
   128→  heightCm: number,
   129→  weightKg: number,
   130→  bodyFatPercent: number,
   131→  gender: Gender
   132→): { rating: number; ffmiResult: FFMIResult } {
   133→  const ffmiResult = calculateFFMI(heightCm, weightKg, bodyFatPercent, gender);
   134→  return {
   135→    rating: ffmiResult.rating,
   136→    ffmiResult,
   137→  };
   138→}
   139→
   140→/**
   141→ * Calculate body score with FFMI when possible, fallback to body fat/muscle level
   142→ * Returns both the rating and optional FFMI data for display
   143→ */
   144→export function calculateBodyScore(
   145→  heightCm: number,
   146→  gender: Gender,
   147→  bodyFatPercent?: number,
   148→  muscleLevel?: MuscleLevel,
   149→  weightKg?: number
   150→): { rating: number; ffmiResult?: FFMIResult; method: 'ffmi' | 'table' | 'default' } {
   151→  // Priority 1: Use FFMI if we have all required data
   152→  if (weightKg !== undefined && bodyFatPercent !== undefined) {
   153→    const { rating, ffmiResult } = getBodyRatingFromFFMI(
   154→      heightCm,
   155→      weightKg,
   156→      bodyFatPercent,
   157→      gender
   158→    );
   159→    return { rating, ffmiResult, method: 'ffmi' };
   160→  }
   161→
   162→  // Priority 2: Use body fat + muscle level table
   163→  if (bodyFatPercent !== undefined && muscleLevel !== undefined) {
   164→    const rating = getBodyRating(bodyFatPercent, muscleLevel);
   165→    return { rating, method: 'table' };
   166→  }
   167→
   168→  // Default: 5.0 (average)
   169→  return { rating: 5.0, method: 'default' };
   170→}
   171→
   172→// ============================================
   173→// TIER CLASSIFICATION
   174→// ============================================
   175→
   176→/**
   177→ * Classify score into PSL tier
   178→ */
   179→export function classifyTier(
   180→  score: number,
   181→  heightRating: number,
   182→  failos?: string[]
   183→): TierInfo {
   184→  // Apply constraints
   185→  let effectiveScore = score;
   186→
   187→  // Height constraint: Cannot reach Gigachad without height rating >= 8.0
   188→  if (heightRating < 8.0 && score >= 9.0) {
   189→    effectiveScore = Math.min(effectiveScore, 8.75);
   190→  }
   191→
   192→  // Major failo constraint: caps tier
   193→  const hasMajorFailo = failos?.some((f) =>
   194→    ['severe_asymmetry', 'deformed', 'major_recession'].includes(f)
   195→  );
   196→  if (hasMajorFailo && effectiveScore >= 7.0) {
   197→    effectiveScore = Math.min(effectiveScore, 6.5);
   198→  }
   199→
   200→  // Find matching tier
   201→  for (const tier of [...TIER_DEFINITIONS].reverse()) {
   202→    if (effectiveScore >= tier.minScore) {
   203→      return tier;
   204→    }
   205→  }
   206→
   207→  return TIER_DEFINITIONS[0]; // Lowest tier
   208→}
   209→
   210→/**
   211→ * Get tier color for UI
   212→ */
   213→export function getTierColor(tier: PSLTier): string {
   214→  const tierInfo = TIER_DEFINITIONS.find((t) => t.name === tier);
   215→  return tierInfo?.color || '#6b7280';
   216→}
   217→
   218→/**
   219→ * Get tier percentile
   220→ */
   221→export function getTierPercentile(tier: PSLTier): number {
   222→  const tierInfo = TIER_DEFINITIONS.find((t) => t.name === tier);
   223→  return tierInfo?.percentile || 50;
   224→}
   225→
   226→// ============================================
   227→// PSL CALCULATION
   228→// ============================================
   229→
   230→/**
   231→ * Calculate threshold bonuses
   232→ */
   233→function calculateThresholdBonuses(
   234→  faceScore: number,
   235→  heightRating: number,
   236→  bodyRating: number,
   237→  vision?: PSLVisionData
   238→): number {
   239→  let bonus = 0;
   240→
   241→  if (faceScore >= 8.5) bonus += THRESHOLD_BONUSES.face;
   242→  if (heightRating >= 8.5) bonus += THRESHOLD_BONUSES.height;
   243→  if (bodyRating >= 8.5) bonus += THRESHOLD_BONUSES.body;
   244→
   245→  // Vision specific bonuses
   246→  if (vision) {
   247→    // NW0/NW1 hairline bonus (High attractiveness marker)
   248→    const hairlineNW = vision.hair?.hairline_nw;
   249→    if (hairlineNW !== undefined && hairlineNW <= 1) bonus += 0.15;
   250→    // Flawless skin bonus
   251→    const skinClarity = vision.skin?.clarity;
   252→    if (skinClarity !== undefined && skinClarity >= 9) bonus += 0.10;
   253→  }
   254→
   255→  return bonus;
   256→}
   257→
   258→/**
   259→ * Calculate synergy bonuses
   260→ */
   261→function calculateSynergyBonuses(
   262→  faceScore: number,
   263→  heightRating: number,
   264→  bodyRating: number
   265→): number {
   266→  const highScores = [faceScore, heightRating, bodyRating].filter((s) => s >= 8.5);
   267→  const highCount = highScores.length;
   268→
   269→  if (highCount === 3) {
   270→    // Triple synergy replaces pair bonuses
   271→    return SYNERGY_BONUSES.triple;
   272→  }
   273→
   274→  let bonus = 0;
   275→  if (highCount >= 2) {
   276→    if (faceScore >= 8.5 && heightRating >= 8.5) bonus += SYNERGY_BONUSES.faceHeight;
   277→    if (faceScore >= 8.5 && bodyRating >= 8.5) bonus += SYNERGY_BONUSES.faceBody;
   278→    if (heightRating >= 8.5 && bodyRating >= 8.5) bonus += SYNERGY_BONUSES.heightBody;
   279→  }
   280→
   281→  return bonus;
   282→}
   283→
   284→/**
   285→ * Calculate penalties from failos and low body score
   286→ */
   287→function calculatePenalties(bodyRating: number, failos?: string[], vision?: PSLVisionData): number {
   288→  let penalty = 0;
   289→
   290→  // Body below 5.0 penalty
   291→  if (bodyRating < 5.0) {
   292→    penalty += 0.3;
   293→  }
   294→
   295→  // Failo penalties
   296→  if (failos) {
   297→    if (failos.includes('severe_asymmetry')) penalty += 0.5;
   298→    if (failos.includes('negative_canthal_tilt')) penalty += 0.3;
   299→    if (failos.includes('receding_chin')) penalty += 0.4;
   300→  }
   301→
   302→  // Vision specific penalties
   303→  if (vision) {
   304→    // Hairline recession penalty
   305→    const hairlineNW = vision.hair?.hairline_nw;
   306→    if (hairlineNW !== undefined && hairlineNW >= 3) {
   307→      penalty += (hairlineNW - 2) * 0.2; // Progressive penalty
   308→    }
   309→    // Severe skin issues
   310→    const skinClarity = vision.skin?.clarity;
   311→    if (skinClarity !== undefined && skinClarity <= 4) {
   312→      penalty += 0.25;
   313→    }
   314→  }
   315→
   316→  return penalty;
   317→}
   318→
   319→/**
   320→ * Estimate potential score with improvements
   321→ */
   322→function estimatePotential(input: PSLInput): number {
   323→  const { faceScore, heightCm, gender, bodyAnalysis } = input;
   324→
   325→  // Face potential: assume minor improvements (skincare, grooming) = +0.3-0.5
   326→  const facePotential = Math.min(10, faceScore + 0.4);
   327→
   328→  // Height is fixed
   329→  const heightRating = getHeightRating(heightCm, gender);
   330→
   331→  // Body potential: assume optimal physique = 8.0
   332→  const currentBodyRating = bodyAnalysis
   333→    ? getBodyRating(bodyAnalysis.bodyFatPercent, bodyAnalysis.muscleLevel)
   334→    : 5.0;
   335→  const bodyPotential = Math.max(currentBodyRating, 7.5);
   336→
   337→  // Calculate potential PSL
   338→  const basePotential =
   339→    facePotential * PSL_WEIGHTS.face +
   340→    heightRating * PSL_WEIGHTS.height +
   341→    bodyPotential * PSL_WEIGHTS.body;
   342→
   343→  // Add potential bonuses (optimistic)
   344→  const thresholdBonus = calculateThresholdBonuses(facePotential, heightRating, bodyPotential);
   345→  const synergyBonus = calculateSynergyBonuses(facePotential, heightRating, bodyPotential);
   346→
   347→  return Math.min(10, basePotential + thresholdBonus + synergyBonus);
   348→}
   349→
   350→/**
   351→ * Main PSL calculation function
   352→ */
   353→export function calculatePSL(input: PSLInput): PSLResult {
   354→  const { faceScore, heightCm, gender, bodyAnalysis, weightKg, failos } = input;
   355→
   356→  // 1. Get component ratings
   357→  const heightRating = getHeightRating(heightCm, gender);
   358→
   359→  // Calculate body score using FFMI when weight is available
   360→  const effectiveWeight = weightKg ?? bodyAnalysis?.weightKg;
   361→  const bodyScoreResult = calculateBodyScore(
   362→    heightCm,
   363→    gender,
   364→    bodyAnalysis?.bodyFatPercent,
   365→    bodyAnalysis?.muscleLevel,
   366→    effectiveWeight
   367→  );
   368→  const bodyRating = bodyScoreResult.rating;
   369→
   370→  // 2. Calculate weighted scores
   371→  const faceWeighted = faceScore * PSL_WEIGHTS.face;
   372→  const heightWeighted = heightRating * PSL_WEIGHTS.height;
   373→  const bodyWeighted = bodyRating * PSL_WEIGHTS.body;
   374→  const baseScore = faceWeighted + heightWeighted + bodyWeighted;
   375→
   376→  // 3. Calculate bonuses
   377→  const thresholdBonus = calculateThresholdBonuses(faceScore, heightRating, bodyRating, input.vision);
   378→  const synergyBonus = calculateSynergyBonuses(faceScore, heightRating, bodyRating);
   379→  const totalBonus = thresholdBonus + synergyBonus;
   380→
   381→  // 4. Calculate penalties
   382→  const penalties = calculatePenalties(bodyRating, failos, input.vision);
   383→
   384→  // 5. Final score (clamped 0-10)
   385→  const finalScore = Math.min(10, Math.max(0, baseScore + totalBonus - penalties));
   386→
   387→  // 6. Classify tier
   388→  const tierInfo = classifyTier(finalScore, heightRating, failos);
   389→
   390→  // 7. Build breakdown with FFMI data if available
   391→  const breakdown: PSLBreakdown = {
   392→    face: { raw: faceScore, weighted: faceWeighted },
   393→    height: { raw: heightRating, weighted: heightWeighted },
   394→    body: { raw: bodyRating, weighted: bodyWeighted },
   395→    bodyInfo: {
   396→      method: bodyScoreResult.method,
   397→      ffmiData: bodyScoreResult.ffmiResult
   398→        ? {
   399→          ffmi: bodyScoreResult.ffmiResult.ffmi,
   400→          normalizedFFMI: bodyScoreResult.ffmiResult.normalizedFFMI,
   401→          leanMassKg: bodyScoreResult.ffmiResult.leanMassKg,
   402→          rating: bodyScoreResult.ffmiResult.rating,
   403→          category: bodyScoreResult.ffmiResult.category,
   404→        }
   405→        : undefined,
   406→    },
   407→    bonuses: {
   408→      threshold: thresholdBonus,
   409→      synergy: synergyBonus,
   410→      total: totalBonus,
   411→    },
   412→    penalties,
   413→  };
   414→
   415→  // 8. Calculate potential
   416→  const potential = estimatePotential(input);
   417→
   418→  return {
   419→    score: Math.round(finalScore * 100) / 100,
   420→    tier: tierInfo.name,
   421→    percentile: tierInfo.percentile,
   422→    breakdown,
   423→    potential: Math.round(potential * 100) / 100,
   424→  };
   425→}
   426→
   427→// ============================================
   428→// UTILITY FUNCTIONS
   429→// ============================================
   430→
   431→/**
   432→ * Convert height from feet/inches to cm
   433→ */
   434→export function feetInchesToCm(feet: number, inches: number): number {
   435→  const totalInches = feet * 12 + inches;
   436→  return Math.round(totalInches * 2.54);
   437→}
   438→
   439→/**
   440→ * Convert height from cm to feet/inches (supports half-inch precision)
   441→ */
   442→export function cmToFeetInches(cm: number): { feet: number; inches: number } {
   443→  const totalInches = cm / 2.54;
   444→  const feet = Math.floor(totalInches / 12);
   445→  // Round to nearest 0.5 inch
   446→  const rawInches = totalInches % 12;
   447→  const inches = Math.round(rawInches * 2) / 2;
   448→  // Handle case where rounding pushes to 12
   449→  if (inches >= 12) {
   450→    return { feet: feet + 1, inches: 0 };
   451→  }
   452→  return { feet, inches };
   453→}
   454→
   455→/**
   456→ * Get a descriptive label for the tier
   457→ */
   458→export function getTierDescription(tier: PSLTier): string {
   459→  const tierInfo = TIER_DEFINITIONS.find((t) => t.name === tier);
   460→  return tierInfo?.description || '';
   461→}
   462→
   463→/**
   464→ * Check if a tier is above average
   465→ */
   466→export function isAboveAverage(tier: PSLTier): boolean {
   467→  const aboveAverageTiers: PSLTier[] = ['HTN', 'Chadlite', 'Chad', 'Gigachad', 'True Mogger'];
   468→  return aboveAverageTiers.includes(tier);
   469→}
   470→
   471→/**
   472→ * Get tier rank (1 = lowest, 10 = highest)
   473→ */
   474→export function getTierRank(tier: PSLTier): number {
   475→  const tierIndex = TIER_DEFINITIONS.findIndex((t) => t.name === tier);
   476→  return tierIndex + 1;
   477→}
   478→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
