     1→'use client';
     2→
     3→import React, { createContext, useContext, useState, useCallback, useRef, ReactNode } from 'react';
     4→import { api } from '@/lib/api';
     5→import type {
     6→  Category,
     7→  Post,
     8→  PostListItem,
     9→  Comment,
    10→  SortOrder,
    11→  VoteType,
    12→  GuideSection,
    13→  RecommendedForum,
    14→} from '@/types/forum';
    15→
    16→interface ForumContextType {
    17→  // Categories
    18→  categories: Category[];
    19→  currentCategory: Category | null;
    20→  isLoadingCategories: boolean;
    21→  fetchCategories: () => Promise<void>;
    22→  fetchCategory: (slug: string) => Promise<void>;
    23→
    24→  // Posts
    25→  posts: PostListItem[];
    26→  currentPost: Post | null;
    27→  totalPosts: number;
    28→  hasMorePosts: boolean;
    29→  isLoadingPosts: boolean;
    30→  sortOrder: SortOrder;
    31→  setSortOrder: (sort: SortOrder) => void;
    32→  fetchPosts: (categorySlug: string, subForumSlug?: string, reset?: boolean) => Promise<void>;
    33→  loadMorePosts: (categorySlug: string, subForumSlug?: string) => Promise<void>;
    34→  fetchPost: (postId: string) => Promise<void>;
    35→  createPost: (title: string, content: string, subForumId: string) => Promise<Post>;
    36→  updatePost: (postId: string, title?: string, content?: string) => Promise<void>;
    37→  deletePost: (postId: string) => Promise<void>;
    38→
    39→  // Comments
    40→  comments: Comment[];
    41→  isLoadingComments: boolean;
    42→  fetchComments: (postId: string) => Promise<void>;
    43→  createComment: (postId: string, content: string, parentId?: string) => Promise<Comment>;
    44→  updateComment: (commentId: string, content: string) => Promise<void>;
    45→  deleteComment: (commentId: string) => Promise<void>;
    46→
    47→  // Voting
    48→  votePost: (postId: string, voteType: VoteType) => Promise<void>;
    49→  voteComment: (commentId: string, voteType: VoteType) => Promise<void>;
    50→
    51→  // Guides & Recommendations
    52→  guideSections: GuideSection[];
    53→  recommendedForums: RecommendedForum[];
    54→  isLoadingGuides: boolean;
    55→  fetchGuides: () => Promise<void>;
    56→  fetchRecommended: (flaws: string[]) => Promise<void>;
    57→
    58→  // Error state
    59→  error: string | null;
    60→  clearError: () => void;
    61→}
    62→
    63→const ForumContext = createContext<ForumContextType | null>(null);
    64→
    65→export function useForum(): ForumContextType {
    66→  const context = useContext(ForumContext);
    67→  if (!context) {
    68→    throw new Error('useForum must be used within a ForumProvider');
    69→  }
    70→  return context;
    71→}
    72→
    73→export function useForumOptional(): ForumContextType | null {
    74→  return useContext(ForumContext);
    75→}
    76→
    77→const PAGE_SIZE = 20;
    78→
    79→export function ForumProvider({ children }: { children: ReactNode }) {
    80→  // Categories
    81→  const [categories, setCategories] = useState<Category[]>([]);
    82→  const [currentCategory, setCurrentCategory] = useState<Category | null>(null);
    83→  const [isLoadingCategories, setIsLoadingCategories] = useState(false);
    84→
    85→  // Posts
    86→  const [posts, setPosts] = useState<PostListItem[]>([]);
    87→  const [currentPost, setCurrentPost] = useState<Post | null>(null);
    88→  const [totalPosts, setTotalPosts] = useState(0);
    89→  const [hasMorePosts, setHasMorePosts] = useState(true);
    90→  const [isLoadingPosts, setIsLoadingPosts] = useState(false);
    91→  const [sortOrder, setSortOrder] = useState<SortOrder>('hot');
    92→  const offsetRef = useRef(0);
    93→
    94→  // Comments
    95→  const [comments, setComments] = useState<Comment[]>([]);
    96→  const [isLoadingComments, setIsLoadingComments] = useState(false);
    97→
    98→  // Guides & Recommendations
    99→  const [guideSections, setGuideSections] = useState<GuideSection[]>([]);
   100→  const [recommendedForums, setRecommendedForums] = useState<RecommendedForum[]>([]);
   101→  const [isLoadingGuides, setIsLoadingGuides] = useState(false);
   102→
   103→  // Error state
   104→  const [error, setError] = useState<string | null>(null);
   105→
   106→  const clearError = useCallback(() => setError(null), []);
   107→
   108→  // === CATEGORIES ===
   109→
   110→  const fetchCategories = useCallback(async () => {
   111→    setIsLoadingCategories(true);
   112→    setError(null);
   113→    try {
   114→      const data = await api.getForumCategories();
   115→      setCategories(data);
   116→    } catch (err) {
   117→      setError(err instanceof Error ? err.message : 'Failed to fetch categories');
   118→    } finally {
   119→      setIsLoadingCategories(false);
   120→    }
   121→  }, []);
   122→
   123→  const fetchCategory = useCallback(async (slug: string) => {
   124→    setIsLoadingCategories(true);
   125→    setError(null);
   126→    try {
   127→      const data = await api.getForumCategory(slug);
   128→      setCurrentCategory(data);
   129→    } catch (err) {
   130→      setError(err instanceof Error ? err.message : 'Failed to fetch category');
   131→    } finally {
   132→      setIsLoadingCategories(false);
   133→    }
   134→  }, []);
   135→
   136→  // === POSTS ===
   137→
   138→  const fetchPosts = useCallback(async (
   139→    categorySlug: string,
   140→    subForumSlug?: string,
   141→    reset = true
   142→  ) => {
   143→    setIsLoadingPosts(true);
   144→    setError(null);
   145→    try {
   146→      const offset = reset ? 0 : offsetRef.current;
   147→      const data = await api.getForumPosts(categorySlug, {
   148→        subForumSlug,
   149→        sort: sortOrder,
   150→        limit: PAGE_SIZE,
   151→        offset,
   152→      });
   153→
   154→      if (reset) {
   155→        setPosts(data.posts);
   156→        offsetRef.current = PAGE_SIZE;
   157→      } else {
   158→        setPosts(prev => [...prev, ...data.posts]);
   159→        offsetRef.current += PAGE_SIZE;
   160→      }
   161→
   162→      setTotalPosts(data.totalCount);
   163→      setHasMorePosts(data.hasMore);
   164→    } catch (err) {
   165→      setError(err instanceof Error ? err.message : 'Failed to fetch posts');
   166→    } finally {
   167→      setIsLoadingPosts(false);
   168→    }
   169→  }, [sortOrder]);
   170→
   171→  const loadMorePosts = useCallback(async (
   172→    categorySlug: string,
   173→    subForumSlug?: string
   174→  ) => {
   175→    if (!hasMorePosts || isLoadingPosts) return;
   176→    await fetchPosts(categorySlug, subForumSlug, false);
   177→  }, [fetchPosts, hasMorePosts, isLoadingPosts]);
   178→
   179→  const fetchPost = useCallback(async (postId: string) => {
   180→    setIsLoadingPosts(true);
   181→    setError(null);
   182→    try {
   183→      const data = await api.getForumPost(postId);
   184→      setCurrentPost(data);
   185→    } catch (err) {
   186→      setError(err instanceof Error ? err.message : 'Failed to fetch post');
   187→    } finally {
   188→      setIsLoadingPosts(false);
   189→    }
   190→  }, []);
   191→
   192→  const createPost = useCallback(async (
   193→    title: string,
   194→    content: string,
   195→    subForumId: string
   196→  ): Promise<Post> => {
   197→    setError(null);
   198→    try {
   199→      const post = await api.createForumPost({ title, content, subForumId });
   200→      return post;
   201→    } catch (err) {
   202→      const message = err instanceof Error ? err.message : 'Failed to create post';
   203→      setError(message);
   204→      throw err;
   205→    }
   206→  }, []);
   207→
   208→  const updatePost = useCallback(async (
   209→    postId: string,
   210→    title?: string,
   211→    content?: string
   212→  ) => {
   213→    setError(null);
   214→    try {
   215→      const updated = await api.updateForumPost(postId, { title, content });
   216→      setCurrentPost(updated);
   217→      // Update in posts list if present
   218→      setPosts(prev => prev.map(p =>
   219→        p.id === postId
   220→          ? { ...p, title: title ?? p.title }
   221→          : p
   222→      ));
   223→    } catch (err) {
   224→      setError(err instanceof Error ? err.message : 'Failed to update post');
   225→      throw err;
   226→    }
   227→  }, []);
   228→
   229→  const deletePost = useCallback(async (postId: string) => {
   230→    setError(null);
   231→    try {
   232→      await api.deleteForumPost(postId);
   233→      setPosts(prev => prev.filter(p => p.id !== postId));
   234→      if (currentPost?.id === postId) {
   235→        setCurrentPost(null);
   236→      }
   237→    } catch (err) {
   238→      setError(err instanceof Error ? err.message : 'Failed to delete post');
   239→      throw err;
   240→    }
   241→  }, [currentPost?.id]);
   242→
   243→  // === COMMENTS ===
   244→
   245→  const fetchComments = useCallback(async (postId: string) => {
   246→    setIsLoadingComments(true);
   247→    setError(null);
   248→    try {
   249→      const data = await api.getForumComments(postId);
   250→      setComments(data);
   251→    } catch (err) {
   252→      setError(err instanceof Error ? err.message : 'Failed to fetch comments');
   253→    } finally {
   254→      setIsLoadingComments(false);
   255→    }
   256→  }, []);
   257→
   258→  const createComment = useCallback(async (
   259→    postId: string,
   260→    content: string,
   261→    parentId?: string
   262→  ): Promise<Comment> => {
   263→    setError(null);
   264→    try {
   265→      const comment = await api.createForumComment(postId, { content, parentId });
   266→      // Add to comments list (append for top-level, insert in replies for nested)
   267→      if (!parentId) {
   268→        setComments(prev => [...prev, comment]);
   269→      } else {
   270→        // Add reply to parent comment's replies array
   271→        const addReplyToParent = (list: Comment[]): Comment[] =>
   272→          list.map(c => c.id === parentId
   273→            ? { ...c, replies: [...c.replies, comment] }
   274→            : { ...c, replies: addReplyToParent(c.replies) }
   275→          );
   276→        setComments(prev => addReplyToParent(prev));
   277→      }
   278→      // Update comment count in current post
   279→      if (currentPost?.id === postId) {
   280→        setCurrentPost(prev => prev ? { ...prev, commentCount: prev.commentCount + 1 } : null);
   281→      }
   282→      return comment;
   283→    } catch (err) {
   284→      const message = err instanceof Error ? err.message : 'Failed to create comment';
   285→      setError(message);
   286→      throw err;
   287→    }
   288→  }, [currentPost?.id]);
   289→
   290→  const updateComment = useCallback(async (commentId: string, content: string) => {
   291→    setError(null);
   292→    try {
   293→      const updated = await api.updateForumComment(commentId, content);
   294→      // Update in comments list
   295→      const updateInList = (list: Comment[]): Comment[] =>
   296→        list.map(c => c.id === commentId
   297→          ? { ...c, content: updated.content, updatedAt: updated.updatedAt }
   298→          : { ...c, replies: updateInList(c.replies) }
   299→        );
   300→      setComments(prev => updateInList(prev));
   301→    } catch (err) {
   302→      setError(err instanceof Error ? err.message : 'Failed to update comment');
   303→      throw err;
   304→    }
   305→  }, []);
   306→
   307→  const deleteComment = useCallback(async (commentId: string) => {
   308→    setError(null);
   309→    try {
   310→      await api.deleteForumComment(commentId);
   311→      // Remove from comments list
   312→      const removeFromList = (list: Comment[]): Comment[] =>
   313→        list.filter(c => c.id !== commentId).map(c => ({
   314→          ...c,
   315→          replies: removeFromList(c.replies),
   316→        }));
   317→      setComments(prev => removeFromList(prev));
   318→      // Update comment count
   319→      if (currentPost) {
   320→        setCurrentPost(prev => prev ? { ...prev, commentCount: Math.max(0, prev.commentCount - 1) } : null);
   321→      }
   322→    } catch (err) {
   323→      setError(err instanceof Error ? err.message : 'Failed to delete comment');
   324→      throw err;
   325→    }
   326→  }, [currentPost]);
   327→
   328→  // === VOTING ===
   329→
   330→  const votePost = useCallback(async (postId: string, voteType: VoteType) => {
   331→    setError(null);
   332→    try {
   333→      const result = await api.voteForumPost(postId, voteType);
   334→      // Update in current post
   335→      if (currentPost?.id === postId) {
   336→        setCurrentPost(prev => prev ? {
   337→          ...prev,
   338→          voteCount: result.newVoteCount,
   339→          userVote: result.userVote,
   340→        } : null);
   341→      }
   342→      // Update in posts list
   343→      setPosts(prev => prev.map(p =>
   344→        p.id === postId
   345→          ? { ...p, voteCount: result.newVoteCount, userVote: result.userVote }
   346→          : p
   347→      ));
   348→    } catch (err) {
   349→      setError(err instanceof Error ? err.message : 'Failed to vote');
   350→      throw err;
   351→    }
   352→  }, [currentPost?.id]);
   353→
   354→  const voteComment = useCallback(async (commentId: string, voteType: VoteType) => {
   355→    setError(null);
   356→    try {
   357→      const result = await api.voteForumComment(commentId, voteType);
   358→      // Update in comments list
   359→      const updateVote = (list: Comment[]): Comment[] =>
   360→        list.map(c => c.id === commentId
   361→          ? { ...c, voteCount: result.newVoteCount, userVote: result.userVote }
   362→          : { ...c, replies: updateVote(c.replies) }
   363→        );
   364→      setComments(prev => updateVote(prev));
   365→    } catch (err) {
   366→      setError(err instanceof Error ? err.message : 'Failed to vote');
   367→      throw err;
   368→    }
   369→  }, []);
   370→
   371→  // === GUIDES & RECOMMENDATIONS ===
   372→
   373→  const fetchGuides = useCallback(async () => {
   374→    setIsLoadingGuides(true);
   375→    setError(null);
   376→    try {
   377→      const data = await api.getForumGuides();
   378→      setGuideSections(data);
   379→    } catch (err) {
   380→      setError(err instanceof Error ? err.message : 'Failed to fetch guides');
   381→    } finally {
   382→      setIsLoadingGuides(false);
   383→    }
   384→  }, []);
   385→
   386→  const fetchRecommended = useCallback(async (flaws: string[]) => {
   387→    setError(null);
   388→    try {
   389→      const data = await api.getRecommendedForums(flaws);
   390→      setRecommendedForums(data);
   391→    } catch (err) {
   392→      setError(err instanceof Error ? err.message : 'Failed to fetch recommendations');
   393→    }
   394→  }, []);
   395→
   396→  return (
   397→    <ForumContext.Provider
   398→      value={{
   399→        // Categories
   400→        categories,
   401→        currentCategory,
   402→        isLoadingCategories,
   403→        fetchCategories,
   404→        fetchCategory,
   405→
   406→        // Posts
   407→        posts,
   408→        currentPost,
   409→        totalPosts,
   410→        hasMorePosts,
   411→        isLoadingPosts,
   412→        sortOrder,
   413→        setSortOrder,
   414→        fetchPosts,
   415→        loadMorePosts,
   416→        fetchPost,
   417→        createPost,
   418→        updatePost,
   419→        deletePost,
   420→
   421→        // Comments
   422→        comments,
   423→        isLoadingComments,
   424→        fetchComments,
   425→        createComment,
   426→        updateComment,
   427→        deleteComment,
   428→
   429→        // Voting
   430→        votePost,
   431→        voteComment,
   432→
   433→        // Guides & Recommendations
   434→        guideSections,
   435→        recommendedForums,
   436→        isLoadingGuides,
   437→        fetchGuides,
   438→        fetchRecommended,
   439→
   440→        // Error
   441→        error,
   442→        clearError,
   443→      }}
   444→    >
   445→      {children}
   446→    </ForumContext.Provider>
   447→  );
   448→}
   449→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
