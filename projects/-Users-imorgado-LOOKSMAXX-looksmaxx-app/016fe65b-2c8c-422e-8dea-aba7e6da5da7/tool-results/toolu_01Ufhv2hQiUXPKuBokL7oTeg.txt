     1→/**
     2→ * Severity Classification System
     3→ * Classifies metric deviations into severity levels with treatment recommendations
     4→ */
     5→
     6→import { Severity, SeverityResult, SeverityThreshold, MetricIssueMapping, Gender } from './types';
     7→
     8→// ============================================
     9→// SEVERITY THRESHOLDS BY METRIC
    10→// ============================================
    11→
    12→export const SEVERITY_THRESHOLDS: SeverityThreshold[] = [
    13→  // FRONT PROFILE METRICS
    14→  {
    15→    metric: 'fwhr',
    16→    optimal: { min: 1.80, max: 2.00 },
    17→    mild: { min: 1.65, max: 2.15 },
    18→    moderate: { min: 1.55, max: 2.25 },
    19→    severe: { min: 0, max: Infinity },
    20→    unit: 'ratio',
    21→    higherIsBetter: false, // mid-range is ideal
    22→  },
    23→  {
    24→    metric: 'canthalTilt',
    25→    optimal: { min: 4, max: 8 },
    26→    mild: { min: 0, max: 10 },
    27→    moderate: { min: -2, max: 12 },
    28→    severe: { min: -Infinity, max: Infinity },
    29→    unit: 'degrees',
    30→    higherIsBetter: true,
    31→  },
    32→  {
    33→    metric: 'facialThirdsUpper',
    34→    optimal: { min: 30, max: 36 },
    35→    mild: { min: 27, max: 39 },
    36→    moderate: { min: 24, max: 42 },
    37→    severe: { min: 0, max: Infinity },
    38→    unit: 'percent',
    39→  },
    40→  {
    41→    metric: 'facialThirdsMiddle',
    42→    optimal: { min: 30, max: 36 },
    43→    mild: { min: 27, max: 39 },
    44→    moderate: { min: 24, max: 42 },
    45→    severe: { min: 0, max: Infinity },
    46→    unit: 'percent',
    47→  },
    48→  {
    49→    metric: 'facialThirdsLower',
    50→    optimal: { min: 30, max: 36 },
    51→    mild: { min: 27, max: 39 },
    52→    moderate: { min: 24, max: 42 },
    53→    severe: { min: 0, max: Infinity },
    54→    unit: 'percent',
    55→  },
    56→  {
    57→    metric: 'nasalIndex',
    58→    optimal: { min: 70, max: 85 },
    59→    mild: { min: 65, max: 90 },
    60→    moderate: { min: 60, max: 95 },
    61→    severe: { min: 0, max: Infinity },
    62→    unit: 'ratio',
    63→  },
    64→  {
    65→    metric: 'interpupillaryDistance',
    66→    optimal: { min: 44, max: 48 },
    67→    mild: { min: 42, max: 50 },
    68→    moderate: { min: 40, max: 52 },
    69→    severe: { min: 0, max: Infinity },
    70→    unit: 'percent',
    71→  },
    72→  {
    73→    metric: 'mouthWidth',
    74→    optimal: { min: 48, max: 54 },
    75→    mild: { min: 44, max: 58 },
    76→    moderate: { min: 40, max: 62 },
    77→    severe: { min: 0, max: Infinity },
    78→    unit: 'percent',
    79→  },
    80→  {
    81→    metric: 'lipRatio',
    82→    optimal: { min: 1.5, max: 2.0 },
    83→    mild: { min: 1.2, max: 2.3 },
    84→    moderate: { min: 1.0, max: 2.6 },
    85→    severe: { min: 0, max: Infinity },
    86→    unit: 'ratio',
    87→  },
    88→  {
    89→    metric: 'jawWidthRatio',
    90→    optimal: { min: 0.75, max: 0.80 },
    91→    mild: { min: 0.72, max: 0.83 },
    92→    moderate: { min: 0.68, max: 0.87 },
    93→    severe: { min: 0, max: Infinity },
    94→    unit: 'ratio',
    95→  },
    96→  {
    97→    metric: 'facialSymmetry',
    98→    optimal: { min: 95, max: 100 },
    99→    mild: { min: 90, max: 100 },
   100→    moderate: { min: 85, max: 100 },
   101→    severe: { min: 0, max: 100 },
   102→    unit: 'percent',
   103→    higherIsBetter: true,
   104→  },
   105→  {
   106→    metric: 'eyeSpacing',
   107→    optimal: { min: 0.95, max: 1.05 },
   108→    mild: { min: 0.90, max: 1.10 },
   109→    moderate: { min: 0.85, max: 1.15 },
   110→    severe: { min: 0, max: Infinity },
   111→    unit: 'ratio',
   112→  },
   113→  {
   114→    metric: 'noseWidth',
   115→    optimal: { min: 0.95, max: 1.05 },
   116→    mild: { min: 0.90, max: 1.10 },
   117→    moderate: { min: 0.85, max: 1.15 },
   118→    severe: { min: 0, max: Infinity },
   119→    unit: 'ratio',
   120→  },
   121→  {
   122→    metric: 'cheekboneWidth',
   123→    optimal: { min: 0.85, max: 0.92 },
   124→    mild: { min: 0.80, max: 0.97 },
   125→    moderate: { min: 0.75, max: 1.02 },
   126→    severe: { min: 0, max: Infinity },
   127→    unit: 'ratio',
   128→  },
   129→
   130→  // SIDE PROFILE METRICS
   131→  {
   132→    metric: 'gonialAngle',
   133→    optimal: { min: 120, max: 130 },
   134→    mild: { min: 115, max: 135 },
   135→    moderate: { min: 110, max: 140 },
   136→    severe: { min: 0, max: Infinity },
   137→    unit: 'degrees',
   138→  },
   139→  {
   140→    metric: 'nasolabialAngle',
   141→    optimal: { min: 95, max: 110 }, // Gender-adjusted in functions
   142→    mild: { min: 85, max: 115 },
   143→    moderate: { min: 80, max: 120 },
   144→    severe: { min: 0, max: Infinity },
   145→    unit: 'degrees',
   146→  },
   147→  {
   148→    metric: 'nasofrontalAngle',
   149→    optimal: { min: 130, max: 140 },
   150→    mild: { min: 125, max: 145 },
   151→    moderate: { min: 120, max: 150 },
   152→    severe: { min: 0, max: Infinity },
   153→    unit: 'degrees',
   154→  },
   155→  {
   156→    metric: 'chinProjection',
   157→    optimal: { min: -4, max: 2 },
   158→    mild: { min: -6, max: 4 },
   159→    moderate: { min: -8, max: 6 },
   160→    severe: { min: -Infinity, max: Infinity },
   161→    unit: 'mm',
   162→  },
   163→  {
   164→    metric: 'mentoLabialAngle',
   165→    optimal: { min: 110, max: 130 },
   166→    mild: { min: 100, max: 140 },
   167→    moderate: { min: 90, max: 150 },
   168→    severe: { min: 0, max: Infinity },
   169→    unit: 'degrees',
   170→  },
   171→  {
   172→    metric: 'facialConvexity',
   173→    optimal: { min: 165, max: 175 },
   174→    mild: { min: 160, max: 180 },
   175→    moderate: { min: 155, max: 185 },
   176→    severe: { min: 0, max: Infinity },
   177→    unit: 'degrees',
   178→  },
   179→  {
   180→    metric: 'eLineUpperLip',
   181→    optimal: { min: -4, max: -1 },
   182→    mild: { min: -6, max: 1 },
   183→    moderate: { min: -8, max: 3 },
   184→    severe: { min: -Infinity, max: Infinity },
   185→    unit: 'mm',
   186→  },
   187→  {
   188→    metric: 'eLineLowerLip',
   189→    optimal: { min: -2, max: 1 },
   190→    mild: { min: -4, max: 3 },
   191→    moderate: { min: -6, max: 5 },
   192→    severe: { min: -Infinity, max: Infinity },
   193→    unit: 'mm',
   194→  },
   195→  {
   196→    metric: 'submCervicalAngle',
   197→    optimal: { min: 100, max: 120 },
   198→    mild: { min: 90, max: 130 },
   199→    moderate: { min: 80, max: 140 },
   200→    severe: { min: 0, max: Infinity },
   201→    unit: 'degrees',
   202→  },
   203→  {
   204→    metric: 'totalFacialConvexity',
   205→    optimal: { min: 135, max: 145 },
   206→    mild: { min: 130, max: 150 },
   207→    moderate: { min: 125, max: 155 },
   208→    severe: { min: 0, max: Infinity },
   209→    unit: 'degrees',
   210→  },
   211→];
   212→
   213→// ============================================
   214→// METRIC TO ISSUE MAPPINGS
   215→// ============================================
   216→
   217→export const METRIC_ISSUE_MAPPINGS: MetricIssueMapping[] = [
   218→  // Front Profile
   219→  {
   220→    metric: 'fwhr',
   221→    lowIssue: 'narrow_face',
   222→    highIssue: 'wide_face',
   223→    lowTreatments: ['cheek_filler', 'cheek_implants', 'jaw_implants'],
   224→    highTreatments: ['botox_masseter', 'buccal_fat_removal', 'zygoma_reduction', 'mandible_reduction'],
   225→  },
   226→  {
   227→    metric: 'canthalTilt',
   228→    lowIssue: 'negative_canthal_tilt',
   229→    highIssue: 'excessive_positive_tilt',
   230→    lowTreatments: ['canthoplasty', 'pdo_threads', 'botox_brow_lift'],
   231→    highTreatments: [], // Rarely treated
   232→  },
   233→  {
   234→    metric: 'nasalIndex',
   235→    lowIssue: 'narrow_nose',
   236→    highIssue: 'wide_nose',
   237→    lowTreatments: ['nose_filler'],
   238→    highTreatments: ['rhinoplasty_reduction', 'nose_filler'],
   239→  },
   240→  {
   241→    metric: 'lipRatio',
   242→    lowIssue: 'thin_lower_lip',
   243→    highIssue: 'thin_upper_lip',
   244→    lowTreatments: ['lip_filler'],
   245→    highTreatments: ['lip_filler', 'lip_lift'],
   246→  },
   247→  {
   248→    metric: 'jawWidthRatio',
   249→    lowIssue: 'narrow_jaw',
   250→    highIssue: 'wide_jaw',
   251→    lowTreatments: ['jaw_implants', 'jawline_filler'],
   252→    highTreatments: ['botox_masseter', 'mandible_reduction'],
   253→  },
   254→  {
   255→    metric: 'facialSymmetry',
   256→    lowIssue: 'facial_asymmetry',
   257→    highIssue: 'optimal',
   258→    lowTreatments: ['filler_correction', 'botox_asymmetry', 'bimax'],
   259→    highTreatments: [],
   260→  },
   261→  {
   262→    metric: 'cheekboneWidth',
   263→    lowIssue: 'flat_cheeks',
   264→    highIssue: 'wide_cheekbones',
   265→    lowTreatments: ['cheek_filler', 'cheek_implants'],
   266→    highTreatments: ['zygoma_reduction'],
   267→  },
   268→
   269→  // Side Profile
   270→  {
   271→    metric: 'gonialAngle',
   272→    lowIssue: 'over_prominent_jaw',
   273→    highIssue: 'weak_jaw',
   274→    lowTreatments: ['mandible_reduction'],
   275→    highTreatments: ['jaw_implants', 'jawline_filler', 'bsso'],
   276→  },
   277→  {
   278→    metric: 'nasolabialAngle',
   279→    lowIssue: 'droopy_nose_tip',
   280→    highIssue: 'over_rotated_tip',
   281→    lowTreatments: ['rhinoplasty_tip', 'nose_filler'],
   282→    highTreatments: ['rhinoplasty_tip', 'rhinoplasty_reduction'],
   283→  },
   284→  {
   285→    metric: 'chinProjection',
   286→    lowIssue: 'recessed_chin',
   287→    highIssue: 'prominent_chin',
   288→    lowTreatments: ['genioplasty', 'chin_implant', 'chin_filler'],
   289→    highTreatments: ['genioplasty'],
   290→  },
   291→  {
   292→    metric: 'eLineUpperLip',
   293→    lowIssue: 'lips_retrude',
   294→    highIssue: 'lips_protrude',
   295→    lowTreatments: ['lip_filler', 'bimax'],
   296→    highTreatments: ['bimax', 'lip_reduction'],
   297→  },
   298→  {
   299→    metric: 'eLineLowerLip',
   300→    lowIssue: 'lips_retrude',
   301→    highIssue: 'lips_protrude',
   302→    lowTreatments: ['lip_filler', 'bimax'],
   303→    highTreatments: ['bimax', 'lip_reduction'],
   304→  },
   305→  {
   306→    metric: 'facialConvexity',
   307→    lowIssue: 'concave_profile',
   308→    highIssue: 'convex_profile',
   309→    lowTreatments: ['bimax', 'chin_filler', 'lefort_1'],
   310→    highTreatments: ['bimax', 'rhinoplasty_reduction'],
   311→  },
   312→  {
   313→    metric: 'mentoLabialAngle',
   314→    lowIssue: 'deep_mentolabial_fold',
   315→    highIssue: 'flat_mentolabial_fold',
   316→    lowTreatments: ['chin_filler', 'genioplasty'],
   317→    highTreatments: [],
   318→  },
   319→  {
   320→    metric: 'submCervicalAngle',
   321→    lowIssue: 'undefined_neck_jaw',
   322→    highIssue: 'excessive_neck_angle',
   323→    lowTreatments: ['kybella', 'posture_correction', 'leanmaxxing'],
   324→    highTreatments: [],
   325→  },
   326→];
   327→
   328→// ============================================
   329→// SEVERITY CLASSIFICATION FUNCTIONS
   330→// ============================================
   331→
   332→/**
   333→ * Classify a score into a severity level
   334→ */
   335→export function classifyByScore(score: number): SeverityResult {
   336→  if (score >= 85) {
   337→    return {
   338→      severity: 'optimal',
   339→      label: 'Optimal',
   340→      color: '#22c55e',
   341→      icon: '✓',
   342→      description: 'Excellent - within ideal range',
   343→    };
   344→  }
   345→  if (score >= 70) {
   346→    return {
   347→      severity: 'mild',
   348→      label: 'Good',
   349→      color: '#84cc16',
   350→      icon: '○',
   351→      description: 'Good - minor deviation from ideal',
   352→    };
   353→  }
   354→  if (score >= 50) {
   355→    return {
   356→      severity: 'moderate',
   357→      label: 'Average',
   358→      color: '#f59e0b',
   359→      icon: '△',
   360→      description: 'Average - noticeable deviation',
   361→    };
   362→  }
   363→  return {
   364→    severity: 'severe',
   365→    label: 'Below Average',
   366→    color: '#ef4444',
   367→    icon: '✗',
   368→    description: 'Below average - significant deviation',
   369→  };
   370→}
   371→
   372→/**
   373→ * Get severity threshold for a specific metric
   374→ */
   375→export function getSeverityThreshold(metric: string): SeverityThreshold | undefined {
   376→  return SEVERITY_THRESHOLDS.find(t => t.metric === metric);
   377→}
   378→
   379→/**
   380→ * Classify a metric value based on its specific thresholds
   381→ */
   382→export function classifyMetricValue(
   383→  metric: string,
   384→  value: number,
   385→  gender?: Gender
   386→): SeverityResult {
   387→  const threshold = getSeverityThreshold(metric);
   388→
   389→  if (!threshold) {
   390→    // Fallback to score-based classification if no threshold defined
   391→    return classifyByScore(value);
   392→  }
   393→
   394→  // Apply gender-specific adjustments
   395→  const adjustedThreshold = { ...threshold };
   396→  if (gender && metric === 'nasolabialAngle') {
   397→    if (gender === 'male') {
   398→      adjustedThreshold.optimal = { min: 90, max: 105 };
   399→    } else {
   400→      adjustedThreshold.optimal = { min: 100, max: 115 };
   401→    }
   402→  }
   403→
   404→  // Check which range the value falls into
   405→  if (value >= adjustedThreshold.optimal.min && value <= adjustedThreshold.optimal.max) {
   406→    return {
   407→      severity: 'optimal',
   408→      label: 'Optimal',
   409→      color: '#22c55e',
   410→      icon: '✓',
   411→      description: `Within ideal range (${adjustedThreshold.optimal.min}-${adjustedThreshold.optimal.max}${adjustedThreshold.unit})`,
   412→    };
   413→  }
   414→
   415→  if (value >= adjustedThreshold.mild.min && value <= adjustedThreshold.mild.max) {
   416→    return {
   417→      severity: 'mild',
   418→      label: 'Good',
   419→      color: '#84cc16',
   420→      icon: '○',
   421→      description: 'Minor deviation from ideal',
   422→    };
   423→  }
   424→
   425→  if (value >= adjustedThreshold.moderate.min && value <= adjustedThreshold.moderate.max) {
   426→    return {
   427→      severity: 'moderate',
   428→      label: 'Average',
   429→      color: '#f59e0b',
   430→      icon: '△',
   431→      description: 'Noticeable deviation from ideal',
   432→    };
   433→  }
   434→
   435→  return {
   436→    severity: 'severe',
   437→    label: 'Below Average',
   438→    color: '#ef4444',
   439→    icon: '✗',
   440→    description: 'Significant deviation from ideal',
   441→  };
   442→}
   443→
   444→/**
   445→ * Calculate deviation from ideal for a metric
   446→ */
   447→export function calculateDeviation(
   448→  metric: string,
   449→  value: number
   450→): { deviation: number; deviationPercent: number; direction: 'low' | 'high' | 'optimal' } {
   451→  const threshold = getSeverityThreshold(metric);
   452→
   453→  if (!threshold) {
   454→    return { deviation: 0, deviationPercent: 0, direction: 'optimal' };
   455→  }
   456→
   457→  const idealMidpoint = (threshold.optimal.min + threshold.optimal.max) / 2;
   458→  const deviation = value - idealMidpoint;
   459→  const idealRange = threshold.optimal.max - threshold.optimal.min;
   460→  const deviationPercent = (Math.abs(deviation) / idealRange) * 100;
   461→
   462→  let direction: 'low' | 'high' | 'optimal';
   463→  if (value >= threshold.optimal.min && value <= threshold.optimal.max) {
   464→    direction = 'optimal';
   465→  } else if (value < threshold.optimal.min) {
   466→    direction = 'low';
   467→  } else {
   468→    direction = 'high';
   469→  }
   470→
   471→  return { deviation, deviationPercent, direction };
   472→}
   473→
   474→/**
   475→ * Get the issue name for a metric deviation
   476→ */
   477→export function getIssueForMetric(
   478→  metric: string,
   479→  direction: 'low' | 'high' | 'optimal'
   480→): string | null {
   481→  if (direction === 'optimal') return null;
   482→
   483→  const mapping = METRIC_ISSUE_MAPPINGS.find(m => m.metric === metric);
   484→  if (!mapping) return null;
   485→
   486→  return direction === 'low' ? mapping.lowIssue : mapping.highIssue;
   487→}
   488→
   489→/**
   490→ * Get treatment IDs for a metric deviation
   491→ */
   492→export function getTreatmentIdsForMetric(
   493→  metric: string,
   494→  direction: 'low' | 'high' | 'optimal'
   495→): string[] {
   496→  if (direction === 'optimal') return [];
   497→
   498→  const mapping = METRIC_ISSUE_MAPPINGS.find(m => m.metric === metric);
   499→  if (!mapping) return [];
   500→
   501→  return direction === 'low' ? mapping.lowTreatments : mapping.highTreatments;
   502→}
   503→
   504→/**
   505→ * Get overall severity from multiple metric analyses
   506→ */
   507→export function getOverallSeverity(severities: Severity[]): SeverityResult {
   508→  const severeCount = severities.filter(s => s === 'severe').length;
   509→  const moderateCount = severities.filter(s => s === 'moderate').length;
   510→  const mildCount = severities.filter(s => s === 'mild').length;
   511→
   512→  // Weighted scoring
   513→  const score = (
   514→    (severities.filter(s => s === 'optimal').length * 100) +
   515→    (mildCount * 75) +
   516→    (moderateCount * 50) +
   517→    (severeCount * 25)
   518→  ) / severities.length;
   519→
   520→  return classifyByScore(score);
   521→}
   522→
   523→/**
   524→ * Prioritize metrics by severity and impact
   525→ */
   526→export function prioritizeMetrics(
   527→  metricSeverities: Array<{ metric: string; severity: Severity; impact: number }>
   528→): Array<{ metric: string; severity: Severity; priority: 'high' | 'medium' | 'low' }> {
   529→  const severityWeight: Record<Severity, number> = {
   530→    severe: 4,
   531→    moderate: 3,
   532→    mild: 2,
   533→    optimal: 1,
   534→  };
   535→
   536→  return metricSeverities
   537→    .map(m => ({
   538→      ...m,
   539→      score: severityWeight[m.severity] * m.impact,
   540→    }))
   541→    .sort((a, b) => b.score - a.score)
   542→    .map((m, index) => ({
   543→      metric: m.metric,
   544→      severity: m.severity,
   545→      priority: index < 3 ? 'high' as const :
   546→                index < 7 ? 'medium' as const :
   547→                'low' as const,
   548→    }));
   549→}
   550→
   551→// ============================================
   552→// PSL RATING CONVERSION
   553→// ============================================
   554→
   555→/**
   556→ * Convert harmony score to PSL rating using a non-linear transformation.
   557→ *
   558→ * PSL (Pretty Scale Level) is a different scale from harmony:
   559→ * - Harmony: 0-100% based on weighted metric averages
   560→ * - PSL: 3.0-7.5 scale with compressed distribution reflecting real-world attractiveness
   561→ *
   562→ * The transformation uses a power curve that:
   563→ * 1. Makes high PSL scores harder to achieve (exponential difficulty at top)
   564→ * 2. Creates better separation in the middle ranges
   565→ * 3. Reflects that most people cluster in the 4.0-5.5 range
   566→ */
   567→export function harmonyToPSL(harmonyPercent: number): {
   568→  psl: number;
   569→  tier: string;
   570→  percentile: number;
   571→  description: string;
   572→} {
   573→  // Handle edge cases: NaN, Infinity, undefined, null
   574→  // Treat invalid inputs as 0 (minimum harmony)
   575→  let safeHarmonyPercent = harmonyPercent;
   576→  if (
   577→    typeof harmonyPercent !== 'number' ||
   578→    !Number.isFinite(harmonyPercent) ||
   579→    Number.isNaN(harmonyPercent)
   580→  ) {
   581→    safeHarmonyPercent = 0;
   582→  }
   583→
   584→  // Clamp to valid range 0-100
   585→  safeHarmonyPercent = Math.max(0, Math.min(100, safeHarmonyPercent));
   586→
   587→  // Non-linear transformation using a modified power curve
   588→  // This creates a more realistic PSL distribution where:
   589→  // - Low harmony maps to PSL 3.0-4.0 range (compressed)
   590→  // - Mid harmony maps to PSL 4.0-5.5 range (expanded - most people here)
   591→  // - High harmony maps to PSL 5.5-7.5 range (compressed - hard to achieve)
   592→  //
   593→  // Formula: PSL = 3.0 + 4.5 * ((harmony/100)^0.7)
   594→  // The 0.7 exponent compresses high scores, making top PSL harder to achieve
   595→  const normalizedHarmony = safeHarmonyPercent / 100;
   596→  const transformedScore = Math.pow(normalizedHarmony, 0.7);
   597→  const psl = 3.0 + transformedScore * 4.5;
   598→  const clampedPSL = Math.max(3.0, Math.min(7.5, psl));
   599→
   600→  // Determine tier
   601→  let tier: string;
   602→  let percentile: number;
   603→  let description: string;
   604→
   605→  if (clampedPSL >= 7.5) {
   606→    tier = 'Top Model';
   607→    percentile = 99.99;
   608→    description = 'Near perfection - world-class genetics';
   609→  } else if (clampedPSL >= 7.0) {
   610→    tier = 'Chad';
   611→    percentile = 99.87;
   612→    description = 'Exceptional - top 0.1%';
   613→  } else if (clampedPSL >= 6.5) {
   614→    tier = 'Chadlite';
   615→    percentile = 99.0;
   616→    description = 'Very attractive - top 1%';
   617→  } else if (clampedPSL >= 6.0) {
   618→    tier = 'High Tier Normie+';
   619→    percentile = 97.25;
   620→    description = 'Notably attractive - top 3%';
   621→  } else if (clampedPSL >= 5.5) {
   622→    tier = 'High Tier Normie';
   623→    percentile = 90.0;
   624→    description = 'Above average - top 10%';
   625→  } else if (clampedPSL >= 5.0) {
   626→    tier = 'Mid Tier Normie+';
   627→    percentile = 84.15;
   628→    description = 'Slightly above average';
   629→  } else if (clampedPSL >= 4.5) {
   630→    tier = 'Mid Tier Normie';
   631→    percentile = 65.0;
   632→    description = 'Average';
   633→  } else if (clampedPSL >= 4.0) {
   634→    tier = 'Low Tier Normie';
   635→    percentile = 50.0;
   636→    description = 'Median';
   637→  } else if (clampedPSL >= 3.5) {
   638→    tier = 'Below Average';
   639→    percentile = 30.0;
   640→    description = 'Below average';
   641→  } else {
   642→    tier = 'Subpar';
   643→    percentile = 15.0;
   644→    description = 'Noticeably below average';
   645→  }
   646→
   647→  return {
   648→    psl: Math.round(clampedPSL * 10) / 10,
   649→    tier,
   650→    percentile,
   651→    description,
   652→  };
   653→}
   654→
   655→/**
   656→ * Estimate potential PSL improvement from treatments
   657→ */
   658→export function estimatePotentialPSL(
   659→  currentPSL: number,
   660→  treatmentImprovements: number[]
   661→): { potentialPSL: number; totalImprovement: number } {
   662→  // Handle edge cases for currentPSL
   663→  let safePSL = currentPSL;
   664→  if (typeof currentPSL !== 'number' || !Number.isFinite(currentPSL) || Number.isNaN(currentPSL)) {
   665→    safePSL = 3.0; // Default to minimum PSL
   666→  }
   667→  safePSL = Math.max(3.0, Math.min(7.5, safePSL));
   668→
   669→  // Handle edge cases for treatmentImprovements array
   670→  if (!Array.isArray(treatmentImprovements) || treatmentImprovements.length === 0) {
   671→    return {
   672→      potentialPSL: Math.round(safePSL * 10) / 10,
   673→      totalImprovement: 0,
   674→    };
   675→  }
   676→
   677→  // Filter out invalid improvement values
   678→  const validImprovements = treatmentImprovements.filter(
   679→    (imp) => typeof imp === 'number' && Number.isFinite(imp) && !Number.isNaN(imp) && imp > 0
   680→  );
   681→
   682→  if (validImprovements.length === 0) {
   683→    return {
   684→      potentialPSL: Math.round(safePSL * 10) / 10,
   685→      totalImprovement: 0,
   686→    };
   687→  }
   688→
   689→  // Sum improvements with diminishing returns
   690→  const sortedImprovements = validImprovements.sort((a, b) => b - a);
   691→
   692→  let totalImprovement = 0;
   693→  sortedImprovements.forEach((improvement, index) => {
   694→    // Each subsequent improvement is reduced by 20%
   695→    const diminishingFactor = Math.pow(0.8, index);
   696→    totalImprovement += improvement * diminishingFactor;
   697→  });
   698→
   699→  // Cap total improvement at realistic level
   700→  const cappedImprovement = Math.min(totalImprovement, 2.5);
   701→  const potentialPSL = Math.min(7.5, safePSL + cappedImprovement);
   702→
   703→  return {
   704→    potentialPSL: Math.round(potentialPSL * 10) / 10,
   705→    totalImprovement: Math.round(cappedImprovement * 10) / 10,
   706→  };
   707→}
   708→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
