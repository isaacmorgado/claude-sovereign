     1→'use client';
     2→
     3→import React, { createContext, useContext, useState, useMemo, useCallback, ReactNode } from 'react';
     4→import { LandmarkPoint } from '@/lib/landmarks';
     5→import {
     6→  analyzeFrontProfile,
     7→  analyzeSideProfile,
     8→  analyzeHarmony,
     9→  HarmonyAnalysis,
    10→  FaceIQScoreResult,
    11→  FACEIQ_METRICS,
    12→  Ethnicity,
    13→  Gender,
    14→} from '@/lib/faceiq-scoring';
    15→import {
    16→  Ratio,
    17→  Strength,
    18→  Flaw,
    19→  Recommendation,
    20→  ResultsTab,
    21→  FullHarmonyAnalysis,
    22→} from '@/types/results';
    23→
    24→// ============================================
    25→// CONTEXT TYPES
    26→// ============================================
    27→
    28→interface ResultsContextType {
    29→  // Raw data
    30→  frontLandmarks: LandmarkPoint[];
    31→  sideLandmarks: LandmarkPoint[];
    32→  gender: Gender;
    33→  ethnicity: Ethnicity;
    34→  frontPhoto: string;
    35→  sidePhoto: string | null;
    36→
    37→  // Computed results
    38→  harmonyAnalysis: FullHarmonyAnalysis | null;
    39→  frontRatios: Ratio[];
    40→  sideRatios: Ratio[];
    41→  strengths: Strength[];
    42→  flaws: Flaw[];
    43→  recommendations: Recommendation[];
    44→
    45→  // Scores
    46→  overallScore: number;
    47→  frontScore: number;
    48→  sideScore: number;
    49→
    50→  // UI state
    51→  activeTab: ResultsTab;
    52→  setActiveTab: (tab: ResultsTab) => void;
    53→  expandedMeasurementId: string | null;
    54→  setExpandedMeasurementId: (id: string | null) => void;
    55→  selectedVisualizationMetric: string | null;
    56→  setSelectedVisualizationMetric: (id: string | null) => void;
    57→  categoryFilter: string | null;
    58→  setCategoryFilter: (category: string | null) => void;
    59→  showLandmarkOverlay: boolean;
    60→  setShowLandmarkOverlay: (show: boolean) => void;
    61→
    62→  // Actions
    63→  setResultsData: (data: ResultsInputData) => void;
    64→}
    65→
    66→interface ResultsInputData {
    67→  frontLandmarks: LandmarkPoint[];
    68→  sideLandmarks: LandmarkPoint[];
    69→  frontPhoto: string;
    70→  sidePhoto?: string;
    71→  gender: Gender;
    72→  ethnicity?: Ethnicity;
    73→}
    74→
    75→// ============================================
    76→// HELPER FUNCTIONS
    77→// ============================================
    78→
    79→function convertUnitToRatioUnit(unit: string): 'x' | 'mm' | '%' | '°' {
    80→  switch (unit) {
    81→    case 'ratio': return 'x';
    82→    case 'percent': return '%';
    83→    case 'degrees': return '°';
    84→    case 'mm': return 'mm';
    85→    default: return 'x';
    86→  }
    87→}
    88→
    89→function transformToRatio(result: FaceIQScoreResult, landmarks: LandmarkPoint[]): Ratio {
    90→  const metricConfig = FACEIQ_METRICS[result.metricId];
    91→
    92→  // Generate illustration based on metric
    93→  const illustration = generateIllustration(result.metricId, landmarks);
    94→
    95→  // Get flaw/strength mappings
    96→  const { mayIndicateFlaws, mayIndicateStrengths } = getFlawStrengthMappings(result);
    97→
    98→  return {
    99→    id: result.metricId,
   100→    name: result.name,
   101→    value: result.value,
   102→    score: result.score,
   103→    standardizedScore: result.standardizedScore,
   104→    unit: convertUnitToRatioUnit(result.unit),
   105→    idealMin: result.idealMin,
   106→    idealMax: result.idealMax,
   107→    rangeMin: metricConfig?.rangeMin || result.idealMin - 0.5,
   108→    rangeMax: metricConfig?.rangeMax || result.idealMax + 0.5,
   109→    description: metricConfig?.description || '',
   110→    category: result.category,
   111→    qualityLevel: result.qualityTier,
   112→    severity: result.severity,
   113→    illustration,
   114→    mayIndicateFlaws,
   115→    mayIndicateStrengths,
   116→    usedLandmarks: getUsedLandmarks(result.metricId),
   117→    scoringCurveConfig: metricConfig ? {
   118→      decayRate: metricConfig.decayRate,
   119→      maxScore: metricConfig.maxScore,
   120→    } : undefined,
   121→  };
   122→}
   123→
   124→function generateIllustration(metricId: string, landmarks: LandmarkPoint[]): Ratio['illustration'] {
   125→  // Default illustration - will be enhanced with metric-specific data
   126→  const landmarkMap: Record<string, LandmarkPoint> = {};
   127→  landmarks.forEach(l => { landmarkMap[l.id] = l; });
   128→
   129→  // Metric-specific illustration configurations
   130→  const illustrationConfigs: Record<string, { points: string[]; lines: Array<{ from: string; to: string }> }> = {
   131→    faceWidthToHeight: {
   132→      points: ['left_zygion', 'right_zygion', 'trichion', 'menton'],
   133→      lines: [
   134→        { from: 'left_zygion', to: 'right_zygion' },
   135→        { from: 'trichion', to: 'menton' },
   136→      ],
   137→    },
   138→    lateralCanthalTilt: {
   139→      points: ['left_canthus_medialis', 'left_canthus_lateralis', 'right_canthus_medialis', 'right_canthus_lateralis'],
   140→      lines: [
   141→        { from: 'left_canthus_medialis', to: 'left_canthus_lateralis' },
   142→        { from: 'right_canthus_medialis', to: 'right_canthus_lateralis' },
   143→      ],
   144→    },
   145→    nasalIndex: {
   146→      points: ['left_ala_nasi', 'right_ala_nasi', 'nasal_base', 'subnasale'],
   147→      lines: [
   148→        { from: 'left_ala_nasi', to: 'right_ala_nasi' },
   149→        { from: 'nasal_base', to: 'subnasale' },
   150→      ],
   151→    },
   152→    mouthWidth: {
   153→      points: ['left_cheilion', 'right_cheilion'],
   154→      lines: [{ from: 'left_cheilion', to: 'right_cheilion' }],
   155→    },
   156→    jawWidth: {
   157→      points: ['left_gonion_inferior', 'right_gonion_inferior'],
   158→      lines: [{ from: 'left_gonion_inferior', to: 'right_gonion_inferior' }],
   159→    },
   160→    chinHeight: {
   161→      points: ['labrale_inferius', 'menton'],
   162→      lines: [{ from: 'labrale_inferius', to: 'menton' }],
   163→    },
   164→  };
   165→
   166→  const config = illustrationConfigs[metricId];
   167→  const points: Record<string, { type: 'landmark'; landmarkId: string }> = {};
   168→  const lines: Record<string, { from: string; to: string; color: string }> = {};
   169→
   170→  if (config) {
   171→    config.points.forEach((pointId, i) => {
   172→      if (landmarkMap[pointId]) {
   173→        points[`point_${i}`] = { type: 'landmark', landmarkId: pointId };
   174→      }
   175→    });
   176→    config.lines.forEach((line, i) => {
   177→      lines[`line_${i}`] = { from: line.from, to: line.to, color: '#67e8f9' };
   178→    });
   179→  }
   180→
   181→  return { points, lines };
   182→}
   183→
   184→function getUsedLandmarks(metricId: string): string[] {
   185→  const landmarkMappings: Record<string, string[]> = {
   186→    faceWidthToHeight: ['left_zygion', 'right_zygion', 'trichion', 'menton'],
   187→    lateralCanthalTilt: ['left_canthus_medialis', 'left_canthus_lateralis'],
   188→    nasalIndex: ['left_ala_nasi', 'right_ala_nasi', 'nasal_base', 'subnasale'],
   189→    ipd: ['left_pupila', 'right_pupila'],
   190→    mouthWidth: ['left_cheilion', 'right_cheilion'],
   191→    jawWidth: ['left_gonion_inferior', 'right_gonion_inferior'],
   192→    chinHeight: ['labrale_inferius', 'menton'],
   193→    gonialAngle: ['tragus', 'gonionBottom', 'menton'],
   194→  };
   195→  return landmarkMappings[metricId] || [];
   196→}
   197→
   198→function getFlawStrengthMappings(result: FaceIQScoreResult): { mayIndicateFlaws: string[]; mayIndicateStrengths: string[] } {
   199→  const flawMappings: Record<string, { low: string[]; high: string[] }> = {
   200→    faceWidthToHeight: {
   201→      low: ['Narrow face', 'Vertically elongated face'],
   202→      high: ['Wide face', 'Horizontally expanded face'],
   203→    },
   204→    lowerThirdProportion: {
   205→      low: ['Short lower third', 'Deficient mandible'],
   206→      high: ['Long lower third', 'Mandibular excess'],
   207→    },
   208→    lateralCanthalTilt: {
   209→      low: ['Negative canthal tilt', 'Drooping eyes'],
   210→      high: ['Excessive positive canthal tilt'],
   211→    },
   212→    nasalIndex: {
   213→      low: ['Narrow nose', 'Leptorrhine nose'],
   214→      high: ['Wide nose', 'Platyrrhine nose'],
   215→    },
   216→    gonialAngle: {
   217→      low: ['Steep mandibular plane'],
   218→      high: ['Flat mandibular plane', 'Weak jaw definition'],
   219→    },
   220→  };
   221→
   222→  const strengthMappings: Record<string, { ideal: string[] }> = {
   223→    faceWidthToHeight: { ideal: ['Balanced facial proportions', 'Harmonious face shape'] },
   224→    lateralCanthalTilt: { ideal: ['Attractive eye shape', 'Positive canthal tilt'] },
   225→    nasalIndex: { ideal: ['Well-proportioned nose', 'Balanced nasal width'] },
   226→    gonialAngle: { ideal: ['Well-defined jawline', 'Strong jaw structure'] },
   227→  };
   228→
   229→  const mapping = flawMappings[result.metricId];
   230→  const strengthMapping = strengthMappings[result.metricId];
   231→
   232→  let mayIndicateFlaws: string[] = [];
   233→  let mayIndicateStrengths: string[] = [];
   234→
   235→  if (result.qualityTier === 'ideal' || result.qualityTier === 'excellent') {
   236→    mayIndicateStrengths = strengthMapping?.ideal || [];
   237→  } else if (mapping) {
   238→    mayIndicateFlaws = result.deviationDirection === 'below' ? mapping.low : mapping.high;
   239→  }
   240→
   241→  return { mayIndicateFlaws, mayIndicateStrengths };
   242→}
   243→
   244→function generateStrengthsFromAnalysis(analysis: HarmonyAnalysis): Strength[] {
   245→  const strengths: Strength[] = [];
   246→
   247→  analysis.strengths.forEach((s, i) => {
   248→    const matchingMeasurement = analysis.measurements.find(m => m.metricId === s.metricId);
   249→
   250→    strengths.push({
   251→      id: `strength_${i}`,
   252→      strengthName: s.metricName,
   253→      summary: s.reasoning,
   254→      avgScore: matchingMeasurement?.score || 8,
   255→      qualityLevel: s.qualityTier,
   256→      categoryName: s.category,
   257→      responsibleRatios: [{
   258→        ratioName: s.metricName,
   259→        ratioId: s.metricId,
   260→        score: matchingMeasurement?.score || 8,
   261→        value: s.value,
   262→      }],
   263→    });
   264→  });
   265→
   266→  return strengths;
   267→}
   268→
   269→function generateFlawsFromAnalysis(analysis: HarmonyAnalysis): Flaw[] {
   270→  const flaws: Flaw[] = [];
   271→  let rollingLost = 0;
   272→
   273→  analysis.flaws.forEach((f, i) => {
   274→    const matchingMeasurement = analysis.measurements.find(m => m.metricId === f.metricId);
   275→    const impact = matchingMeasurement ? (10 - matchingMeasurement.score) * 0.5 : 2;
   276→    rollingLost += impact;
   277→
   278→    flaws.push({
   279→      id: `flaw_${i}`,
   280→      flawName: f.metricName,
   281→      summary: f.reasoning,
   282→      harmonyPercentageLost: impact,
   283→      standardizedImpact: impact / 10,
   284→      categoryName: f.category,
   285→      responsibleRatios: [{
   286→        ratioName: f.metricName,
   287→        ratioId: f.metricId,
   288→        score: matchingMeasurement?.score || 3,
   289→        value: matchingMeasurement?.value || 0,
   290→      }],
   291→      rollingPointsDeducted: rollingLost,
   292→      rollingHarmonyPercentageLost: rollingLost,
   293→      rollingStandardizedImpact: rollingLost / 10,
   294→    });
   295→  });
   296→
   297→  return flaws.sort((a, b) => b.harmonyPercentageLost - a.harmonyPercentageLost);
   298→}
   299→
   300→function generateRecommendations(flaws: Flaw[]): Recommendation[] {
   301→  // Generate recommendations based on detected flaws
   302→  const recommendations: Recommendation[] = [];
   303→
   304→  const procedureDatabase: Array<Omit<Recommendation, 'matchedFlaws' | 'matchedRatios' | 'ratios_impacted'> & { targetFlaws: string[] }> = [
   305→    {
   306→      ref_id: 'SUR-01',
   307→      name: 'Genioplasty',
   308→      description: 'Surgical chin repositioning to improve chin projection and facial harmony. Can move the chin forward, backward, up, or down.',
   309→      phase: 'Surgical',
   310→      impact: 0.85,
   311→      coverage: 8,
   312→      percentage: '15-25%',
   313→      expectedImprovementRange: { min: 0.5, max: 1.5 },
   314→      targetFlaws: ['Weak chin', 'Recessed chin', 'Short chin', 'chin'],
   315→      timeline: { effect_start: 'delayed', full_results_weeks: 12, full_results_weeks_max: 24 },
   316→      cost: { type: 'flat', min: 5000, max: 15000, currency: 'USD' },
   317→      risks_side_effects: 'Temporary numbness, swelling, bruising. Rare: infection, nerve damage.',
   318→      warnings: [],
   319→      gender: 'both',
   320→    },
   321→    {
   322→      ref_id: 'SUR-02',
   323→      name: 'Rhinoplasty',
   324→      description: 'Nose reshaping surgery to improve nasal proportions, reduce or increase size, change angle, or correct breathing issues.',
   325→      phase: 'Surgical',
   326→      impact: 0.8,
   327→      coverage: 6,
   328→      percentage: '10-20%',
   329→      targetFlaws: ['Wide nose', 'Long nose', 'Crooked nose', 'nose', 'nasal'],
   330→      timeline: { effect_start: 'delayed', full_results_weeks: 24, full_results_weeks_max: 52 },
   331→      cost: { type: 'flat', min: 8000, max: 20000, currency: 'USD' },
   332→      risks_side_effects: 'Swelling for 6-12 months, numbness, possible revision needed.',
   333→      warnings: [],
   334→      gender: 'both',
   335→    },
   336→    {
   337→      ref_id: 'SUR-03',
   338→      name: 'Jaw Implants',
   339→      description: 'Custom or standard implants to enhance jaw width and definition. Creates a more angular, masculine jawline.',
   340→      phase: 'Surgical',
   341→      impact: 0.75,
   342→      coverage: 5,
   343→      percentage: '10-15%',
   344→      targetFlaws: ['Narrow jaw', 'Weak jaw', 'jaw'],
   345→      timeline: { effect_start: 'delayed', full_results_weeks: 8, full_results_weeks_max: 16 },
   346→      cost: { type: 'flat', min: 8000, max: 25000, currency: 'USD' },
   347→      risks_side_effects: 'Swelling, asymmetry risk, implant migration, infection.',
   348→      warnings: [],
   349→      gender: 'both',
   350→    },
   351→    {
   352→      ref_id: 'MIN-01',
   353→      name: 'Dermal Fillers',
   354→      description: 'Hyaluronic acid injections to add volume to chin, jawline, or cheeks. Non-permanent and reversible.',
   355→      phase: 'Minimally Invasive',
   356→      impact: 0.4,
   357→      coverage: 4,
   358→      percentage: '5-10%',
   359→      targetFlaws: ['Weak chin', 'Flat cheeks', 'chin', 'midface'],
   360→      timeline: { effect_start: 'immediate', full_results_weeks: 1 },
   361→      cost: { type: 'per_session', min: 600, max: 2000, currency: 'USD' },
   362→      risks_side_effects: 'Bruising, swelling, rare vascular occlusion.',
   363→      warnings: ['Results temporary (6-18 months)'],
   364→      gender: 'both',
   365→    },
   366→    {
   367→      ref_id: 'MIN-02',
   368→      name: 'Orthodontic Treatment',
   369→      description: 'Braces or clear aligners to correct bite alignment and tooth positioning. Can impact facial profile over time.',
   370→      phase: 'Minimally Invasive',
   371→      impact: 0.5,
   372→      coverage: 3,
   373→      percentage: '5-15%',
   374→      targetFlaws: ['Bite issues', 'Midface recession', 'jaw'],
   375→      timeline: { effect_start: 'gradual', full_results_weeks: 52, full_results_weeks_max: 104 },
   376→      cost: { type: 'flat', min: 3000, max: 10000, currency: 'USD' },
   377→      risks_side_effects: 'Temporary discomfort, requires compliance.',
   378→      warnings: [],
   379→      gender: 'both',
   380→    },
   381→    {
   382→      ref_id: 'FND-01',
   383→      name: 'Mewing / Proper Tongue Posture',
   384→      description: 'Maintaining correct tongue posture on the palate to potentially influence facial development over time.',
   385→      phase: 'Foundational',
   386→      impact: 0.2,
   387→      coverage: 4,
   388→      percentage: '2-5%',
   389→      targetFlaws: ['Midface recession', 'Narrow palate', 'jaw', 'midface'],
   390→      timeline: { effect_start: 'gradual', full_results_weeks: 104, full_results_weeks_max: 260 },
   391→      cost: { type: 'flat', min: 0, max: 0, currency: 'USD' },
   392→      risks_side_effects: 'None if done correctly. Jaw pain if excessive.',
   393→      warnings: ['Results vary significantly', 'Most effective in younger individuals'],
   394→      gender: 'both',
   395→    },
   396→    {
   397→      ref_id: 'FND-02',
   398→      name: 'Body Recomposition',
   399→      description: 'Reducing body fat percentage to enhance facial definition and reveal underlying bone structure.',
   400→      phase: 'Foundational',
   401→      impact: 0.3,
   402→      coverage: 6,
   403→      percentage: '5-10%',
   404→      targetFlaws: ['Undefined jawline', 'Soft features', 'jaw', 'face'],
   405→      timeline: { effect_start: 'gradual', full_results_weeks: 12, full_results_weeks_max: 52 },
   406→      cost: { type: 'per_month', min: 50, max: 200, currency: 'USD' },
   407→      risks_side_effects: 'None if done healthily.',
   408→      warnings: [],
   409→      gender: 'both',
   410→    },
   411→  ];
   412→
   413→  flaws.forEach(flaw => {
   414→    procedureDatabase.forEach(proc => {
   415→      const flawLower = flaw.flawName.toLowerCase();
   416→      const matches = proc.targetFlaws.some(target =>
   417→        flawLower.includes(target.toLowerCase()) || target.toLowerCase().includes(flawLower)
   418→      );
   419→
   420→      if (matches && !recommendations.find(r => r.ref_id === proc.ref_id)) {
   421→        recommendations.push({
   422→          ...proc,
   423→          matchedFlaws: [flaw.flawName],
   424→          matchedRatios: flaw.responsibleRatios.map(r => r.ratioName),
   425→          ratios_impacted: flaw.responsibleRatios.map(r => ({
   426→            ratioId: r.ratioId,
   427→            ratioName: r.ratioName,
   428→            direction: 'both' as const,
   429→            percentageEffect: 1.0,
   430→          })),
   431→        });
   432→      }
   433→    });
   434→  });
   435→
   436→  return recommendations.sort((a, b) => b.impact - a.impact);
   437→}
   438→
   439→// ============================================
   440→// CONTEXT CREATION
   441→// ============================================
   442→
   443→const ResultsContext = createContext<ResultsContextType | null>(null);
   444→
   445→export function useResults(): ResultsContextType {
   446→  const context = useContext(ResultsContext);
   447→  if (!context) {
   448→    throw new Error('useResults must be used within a ResultsProvider');
   449→  }
   450→  return context;
   451→}
   452→
   453→interface ResultsProviderProps {
   454→  children: ReactNode;
   455→  initialData?: ResultsInputData;
   456→}
   457→
   458→export function ResultsProvider({ children, initialData }: ResultsProviderProps) {
   459→  // Raw data state
   460→  const [frontLandmarks, setFrontLandmarks] = useState<LandmarkPoint[]>(initialData?.frontLandmarks || []);
   461→  const [sideLandmarks, setSideLandmarks] = useState<LandmarkPoint[]>(initialData?.sideLandmarks || []);
   462→  const [gender, setGender] = useState<Gender>(initialData?.gender || 'male');
   463→  const [ethnicity, setEthnicity] = useState<Ethnicity>(initialData?.ethnicity || 'other');
   464→  const [frontPhoto, setFrontPhoto] = useState<string>(initialData?.frontPhoto || '');
   465→  const [sidePhoto, setSidePhoto] = useState<string | null>(initialData?.sidePhoto || null);
   466→
   467→  // UI state
   468→  const [activeTab, setActiveTab] = useState<ResultsTab>('overview');
   469→  const [expandedMeasurementId, setExpandedMeasurementId] = useState<string | null>(null);
   470→  const [selectedVisualizationMetric, setSelectedVisualizationMetric] = useState<string | null>(null);
   471→  const [categoryFilter, setCategoryFilter] = useState<string | null>(null);
   472→  const [showLandmarkOverlay, setShowLandmarkOverlay] = useState(true);
   473→
   474→  // Compute analysis results (now with demographic-specific scoring)
   475→  const analysisResults = useMemo(() => {
   476→    if (frontLandmarks.length === 0) {
   477→      return null;
   478→    }
   479→
   480→    try {
   481→      const frontAnalysis = analyzeFrontProfile(frontLandmarks, gender, ethnicity);
   482→      const sideAnalysis = sideLandmarks.length > 0
   483→        ? analyzeSideProfile(sideLandmarks, gender, ethnicity)
   484→        : null;
   485→      // analyzeHarmony expects landmarks directly, not analysis results
   486→      const harmony = analyzeHarmony(frontLandmarks, sideLandmarks, gender, ethnicity);
   487→
   488→      return { frontAnalysis, sideAnalysis, harmony };
   489→    } catch (error) {
   490→      console.error('Analysis error:', error);
   491→      return null;
   492→    }
   493→  }, [frontLandmarks, sideLandmarks, gender, ethnicity]);
   494→
   495→  // Transform to Ratio format
   496→  const frontRatios = useMemo(() => {
   497→    if (!analysisResults?.frontAnalysis) return [];
   498→    return analysisResults.frontAnalysis.measurements.map(m => transformToRatio(m, frontLandmarks));
   499→  }, [analysisResults, frontLandmarks]);
   500→
   501→  const sideRatios = useMemo(() => {
   502→    if (!analysisResults?.sideAnalysis) return [];
   503→    return analysisResults.sideAnalysis.measurements.map(m => transformToRatio(m, sideLandmarks));
   504→  }, [analysisResults, sideLandmarks]);
   505→
   506→  // Generate strengths and flaws
   507→  const strengths = useMemo(() => {
   508→    if (!analysisResults?.harmony) return [];
   509→    return generateStrengthsFromAnalysis(analysisResults.harmony);
   510→  }, [analysisResults]);
   511→
   512→  const flaws = useMemo(() => {
   513→    if (!analysisResults?.harmony) return [];
   514→    return generateFlawsFromAnalysis(analysisResults.harmony);
   515→  }, [analysisResults]);
   516→
   517→  // Generate recommendations
   518→  const recommendations = useMemo(() => {
   519→    return generateRecommendations(flaws);
   520→  }, [flaws]);
   521→
   522→  // Build full harmony analysis
   523→  const harmonyAnalysis = useMemo((): FullHarmonyAnalysis | null => {
   524→    if (!analysisResults?.harmony) return null;
   525→
   526→    return {
   527→      standardizedScore: analysisResults.harmony.overallScore,
   528→      front: {
   529→        standardizedScore: analysisResults.harmony.frontScore,
   530→        ratios: frontRatios,
   531→      },
   532→      side: {
   533→        standardizedScore: analysisResults.harmony.sideScore,
   534→        ratios: sideRatios,
   535→      },
   536→      strengths,
   537→      flaws,
   538→    };
   539→  }, [analysisResults, frontRatios, sideRatios, strengths, flaws]);
   540→
   541→  // Scores
   542→  const overallScore = analysisResults?.harmony?.overallScore || 0;
   543→  const frontScore = analysisResults?.harmony?.frontScore || 0;
   544→  const sideScore = analysisResults?.harmony?.sideScore || 0;
   545→
   546→  // Action to set all results data
   547→  const setResultsData = useCallback((data: ResultsInputData) => {
   548→    setFrontLandmarks(data.frontLandmarks);
   549→    setSideLandmarks(data.sideLandmarks);
   550→    setFrontPhoto(data.frontPhoto);
   551→    setSidePhoto(data.sidePhoto || null);
   552→    setGender(data.gender);
   553→    setEthnicity(data.ethnicity || 'other');
   554→  }, []);
   555→
   556→  const value: ResultsContextType = {
   557→    frontLandmarks,
   558→    sideLandmarks,
   559→    gender,
   560→    ethnicity,
   561→    frontPhoto,
   562→    sidePhoto,
   563→    harmonyAnalysis,
   564→    frontRatios,
   565→    sideRatios,
   566→    strengths,
   567→    flaws,
   568→    recommendations,
   569→    overallScore,
   570→    frontScore,
   571→    sideScore,
   572→    activeTab,
   573→    setActiveTab,
   574→    expandedMeasurementId,
   575→    setExpandedMeasurementId,
   576→    selectedVisualizationMetric,
   577→    setSelectedVisualizationMetric,
   578→    categoryFilter,
   579→    setCategoryFilter,
   580→    showLandmarkOverlay,
   581→    setShowLandmarkOverlay,
   582→    setResultsData,
   583→  };
   584→
   585→  return (
   586→    <ResultsContext.Provider value={value}>
   587→      {children}
   588→    </ResultsContext.Provider>
   589→  );
   590→}
   591→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
