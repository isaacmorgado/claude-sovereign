The file /Users/imorgado/LOOKSMAXX/looksmaxx-app/src/components/results/modals/RatioDetailModal.tsx has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
    74→    </div>
    75→  );
    76→}
    77→
    78→// ============================================
    79→// SCORING METHODOLOGY CHART (FaceIQ Style)
    80→// ============================================
    81→
    82→interface ScoringMethodologyChartProps {
    83→  value: number;
    84→  score: number;
    85→  idealMin: number;
    86→  idealMax: number;
    87→  rangeMin: number;
    88→  rangeMax: number;
    89→  unit: string;
    90→  decayRate?: number;
    91→}
    92→
    93→interface HoverState {
    94→  visible: boolean;
    95→  x: number;
    96→  y: number;
    97→  value: number;
    98→  score: number;
    99→}
   100→
   101→function ScoringMethodologyChart({
   102→  value,
   103→  score,
   104→  idealMin,
   105→  idealMax,
   106→  rangeMin,
   107→  rangeMax,
   108→  unit,
   109→  decayRate = 4,
   110→}: ScoringMethodologyChartProps) {
   111→  const canvasRef = useRef<HTMLCanvasElement>(null);
   112→  const containerRef = useRef<HTMLDivElement>(null);
   113→  const [hover, setHover] = useState<HoverState>({ visible: false, x: 0, y: 0, value: 0, score: 0 });
   114→  const paddingRef = useRef({ top: 20, right: 20, bottom: 35, left: 35 });
   115→  const chartDimensionsRef = useRef({ width: 0, height: 0, chartWidth: 0, chartHeight: 0 });
   116→
   117→  // Calculate score for any x value using exponential decay
   118→  const calculateScore = (x: number): number => {
   119→    const idealRangeHalf = (idealMax - idealMin) / 2;
   120→    if (idealRangeHalf === 0) return x === idealMin ? 10 : 1;
   121→
   122→    if (x >= idealMin && x <= idealMax) {
   123→      return 10;
   124→    }
   125→
   126→    const deviation = x < idealMin
   127→      ? (idealMin - x) / idealRangeHalf
   128→      : (x - idealMax) / idealRangeHalf;
   129→
   130→    return Math.max(1, 10 * Math.exp(-decayRate * Math.pow(deviation, 2)));
   131→  };
   132→
   133→  // Get color for a score value (FaceIQ gradient)
   134→  const getColorForScore = (s: number): string => {
   135→    if (s >= 9) return 'rgb(34, 197, 94)';   // Green - Excellent
   136→    if (s >= 7) return 'rgb(6, 182, 212)';   // Cyan - Good
   137→    if (s >= 5) return 'rgb(250, 204, 21)';  // Yellow - Average
   138→    if (s >= 3) return 'rgb(249, 115, 22)';  // Orange - Below average
   139→    return 'rgb(239, 68, 68)';                // Red - Poor
   140→  };
   141→
   142→  useEffect(() => {
   143→    const canvas = canvasRef.current;
   144→    if (!canvas) return;
   145→
   146→    const ctx = canvas.getContext('2d');
   147→    if (!ctx) return;
   148→
   149→    const dpr = window.devicePixelRatio || 1;
   150→    const rect = canvas.getBoundingClientRect();
   151→    canvas.width = rect.width * dpr;
   152→    canvas.height = rect.height * dpr;
   153→    ctx.scale(dpr, dpr);
   154→
   155→    const width = rect.width;
   156→    const height = rect.height;
   157→    const padding = paddingRef.current;
   158→    const chartWidth = width - padding.left - padding.right;
   159→    const chartHeight = height - padding.top - padding.bottom;
   160→
   161→    // Store dimensions for mouse handler
   162→    chartDimensionsRef.current = { width, height, chartWidth, chartHeight };
   163→
   164→    // Clear canvas
   165→    ctx.clearRect(0, 0, width, height);
   166→
   167→    // X-axis scale
   168→    const xScale = (val: number) => padding.left + ((val - rangeMin) / (rangeMax - rangeMin)) * chartWidth;
   169→    const yScale = (val: number) => padding.top + (1 - val / 10) * chartHeight;
   170→
   171→    // Calculate positions for gradient
   172→    const idealMinPos = Math.max(0, Math.min(1, (idealMin - rangeMin) / (rangeMax - rangeMin)));
   173→    const idealMaxPos = Math.max(0, Math.min(1, (idealMax - rangeMin) / (rangeMax - rangeMin)));
   174→
   175→    // Draw horizontal grid lines (FaceIQ style - subtle)
   176→    ctx.strokeStyle = 'rgba(64, 64, 64, 0.5)';
   177→    ctx.lineWidth = 1;
   178→    for (let i = 0; i <= 10; i += 2) {
   179→      const y = yScale(i);
   180→      ctx.beginPath();
   181→      ctx.moveTo(padding.left, y);
   182→      ctx.lineTo(padding.left + chartWidth, y);
   183→      ctx.stroke();
   184→    }
   185→
   186→    // Draw ideal range highlight zone
   187→    const idealLeftX = xScale(idealMin);
   188→    const idealRightX = xScale(idealMax);
   189→    ctx.fillStyle = 'rgba(34, 197, 94, 0.08)';
   190→    ctx.fillRect(idealLeftX, padding.top, idealRightX - idealLeftX, chartHeight);
   191→
   192→    // Draw ideal range border lines
   193→    ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
   194→    ctx.lineWidth = 1;
   195→    ctx.setLineDash([4, 4]);
   196→    ctx.beginPath();
   197→    ctx.moveTo(idealLeftX, padding.top);
   198→    ctx.lineTo(idealLeftX, padding.top + chartHeight);
   199→    ctx.stroke();
   200→    ctx.beginPath();
   201→    ctx.moveTo(idealRightX, padding.top);
   202→    ctx.lineTo(idealRightX, padding.top + chartHeight);
   203→    ctx.stroke();
   204→    ctx.setLineDash([]);
   205→
   206→    // Draw gradient fill under curve
   207→    const fillGradient = ctx.createLinearGradient(padding.left, 0, padding.left + chartWidth, 0);
   208→    fillGradient.addColorStop(0, 'rgba(239, 68, 68, 0.15)');
   209→    fillGradient.addColorStop(Math.max(0, idealMinPos - 0.15), 'rgba(249, 115, 22, 0.15)');
   210→    fillGradient.addColorStop(Math.max(0, idealMinPos - 0.05), 'rgba(250, 204, 21, 0.15)');
   211→    fillGradient.addColorStop(idealMinPos, 'rgba(34, 197, 94, 0.2)');
   212→    fillGradient.addColorStop(idealMaxPos, 'rgba(34, 197, 94, 0.2)');
   213→    fillGradient.addColorStop(Math.min(1, idealMaxPos + 0.05), 'rgba(250, 204, 21, 0.15)');
   214→    fillGradient.addColorStop(Math.min(1, idealMaxPos + 0.15), 'rgba(249, 115, 22, 0.15)');
   215→    fillGradient.addColorStop(1, 'rgba(239, 68, 68, 0.15)');
   216→
   217→    // Draw fill
   218→    ctx.beginPath();
   219→    ctx.moveTo(xScale(rangeMin), yScale(0));
   220→    for (let i = 0; i <= 200; i++) {
   221→      const x = rangeMin + (rangeMax - rangeMin) * (i / 200);
   222→      const y = calculateScore(x);
   223→      ctx.lineTo(xScale(x), yScale(y));
   224→    }
   225→    ctx.lineTo(xScale(rangeMax), yScale(0));
   226→    ctx.closePath();
   227→    ctx.fillStyle = fillGradient;
   228→    ctx.fill();
   229→
   230→    // Draw curve with gradient stroke
   231→    const lineGradient = ctx.createLinearGradient(padding.left, 0, padding.left + chartWidth, 0);
   232→    lineGradient.addColorStop(0, 'rgb(239, 68, 68)');
   233→    lineGradient.addColorStop(Math.max(0, idealMinPos - 0.15), 'rgb(249, 115, 22)');
   234→    lineGradient.addColorStop(Math.max(0, idealMinPos - 0.05), 'rgb(250, 204, 21)');
   235→    lineGradient.addColorStop(idealMinPos, 'rgb(34, 197, 94)');
   236→    lineGradient.addColorStop(idealMaxPos, 'rgb(34, 197, 94)');
   237→    lineGradient.addColorStop(Math.min(1, idealMaxPos + 0.05), 'rgb(250, 204, 21)');
   238→    lineGradient.addColorStop(Math.min(1, idealMaxPos + 0.15), 'rgb(249, 115, 22)');
   239→    lineGradient.addColorStop(1, 'rgb(239, 68, 68)');
   240→
   241→    ctx.beginPath();
   242→    for (let i = 0; i <= 200; i++) {
   243→      const x = rangeMin + (rangeMax - rangeMin) * (i / 200);
   244→      const y = calculateScore(x);
   245→      if (i === 0) {
   246→        ctx.moveTo(xScale(x), yScale(y));
   247→      } else {
   248→        ctx.lineTo(xScale(x), yScale(y));
   249→      }
   250→    }
   251→    ctx.strokeStyle = lineGradient;
   252→    ctx.lineWidth = 2.5;
   253→    ctx.lineCap = 'round';
   254→    ctx.lineJoin = 'round';
   255→    ctx.stroke();
   256→
   257→    // Draw axes
   258→    ctx.strokeStyle = 'rgb(82, 82, 82)';
   259→    ctx.lineWidth = 1;
   260→
   261→    // Y-axis
   262→    ctx.beginPath();
   263→    ctx.moveTo(padding.left, padding.top);
   264→    ctx.lineTo(padding.left, padding.top + chartHeight);
   265→    ctx.stroke();
   266→
   267→    // X-axis
   268→    ctx.beginPath();
   269→    ctx.moveTo(padding.left, padding.top + chartHeight);
   270→    ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
   271→    ctx.stroke();
   272→
   273→    // Y-axis labels
   274→    ctx.fillStyle = 'rgb(115, 115, 115)';
   275→    ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
   276→    ctx.textAlign = 'right';
   277→    ctx.textBaseline = 'middle';
   278→    for (let i = 0; i <= 10; i += 2) {
   279→      ctx.fillText(i.toString(), padding.left - 8, yScale(i));
   280→    }
   281→
   282→    // X-axis labels
   283→    ctx.textAlign = 'center';
   284→    ctx.textBaseline = 'top';
   285→    const steps = 5;
   286→    for (let i = 0; i <= steps; i++) {
   287→      const val = rangeMin + (rangeMax - rangeMin) * (i / steps);
   288→      let formatted: string;
   289→      if (unit === 'percent' || unit === '%') {
   290→        formatted = val.toFixed(0) + '%';
   291→      } else if (unit === 'degrees') {
   292→        formatted = val.toFixed(0) + '°';
   293→      } else {
   294→        formatted = val.toFixed(2);
   295→      }
   296→      ctx.fillText(formatted, xScale(val), padding.top + chartHeight + 8);
   297→    }
   298→
   299→    // Draw "Ideal" label in the ideal zone
   300→    if (idealRightX - idealLeftX > 40) {
   301→      ctx.fillStyle = 'rgba(34, 197, 94, 0.6)';
   302→      ctx.font = '9px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
   303→      ctx.textAlign = 'center';
   304→      ctx.textBaseline = 'top';
   305→      ctx.fillText('IDEAL', (idealLeftX + idealRightX) / 2, padding.top + 4);
   306→    }
   307→
   308→    // Draw current value marker
   309→    const currentX = xScale(value);
   310→    const currentY = yScale(score);
   311→
   312→    // Vertical dashed line from point to x-axis
   313→    ctx.setLineDash([3, 3]);
   314→    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
   315→    ctx.lineWidth = 1;
   316→    ctx.beginPath();
   317→    ctx.moveTo(currentX, currentY);
   318→    ctx.lineTo(currentX, padding.top + chartHeight);
   319→    ctx.stroke();
   320→    ctx.setLineDash([]);
   321→
   322→    // Outer glow circle
   323→    const markerColor = getColorForScore(score);
   324→    ctx.beginPath();
   325→    ctx.arc(currentX, currentY, 10, 0, Math.PI * 2);
   326→    ctx.fillStyle = markerColor.replace('rgb', 'rgba').replace(')', ', 0.2)');
   327→    ctx.fill();
   328→
   329→    // Main marker circle
   330→    ctx.beginPath();
   331→    ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);
   332→    ctx.fillStyle = '#ffffff';
   333→    ctx.fill();
   334→    ctx.strokeStyle = markerColor;
   335→    ctx.lineWidth = 2.5;
   336→    ctx.stroke();
   337→
   338→    // Inner dot
   339→    ctx.beginPath();
   340→    ctx.arc(currentX, currentY, 2, 0, Math.PI * 2);
   341→    ctx.fillStyle = markerColor;
   342→    ctx.fill();
   343→
   344→  }, [value, score, idealMin, idealMax, rangeMin, rangeMax, unit, decayRate, calculateScore]);
   345→
   346→  // Mouse move handler for hover tooltip
   347→  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
   348→    const canvas = canvasRef.current;
   349→    if (!canvas) return;
   350→
   351→    const rect = canvas.getBoundingClientRect();
   352→    const mouseX = e.clientX - rect.left;
   353→    const mouseY = e.clientY - rect.top;
   354→
   355→    const padding = paddingRef.current;
   356→    const { chartWidth, chartHeight } = chartDimensionsRef.current;
   357→
   358→    // Check if mouse is within chart area
   359→    if (
   360→      mouseX >= padding.left &&
   361→      mouseX <= padding.left + chartWidth &&
   362→      mouseY >= padding.top &&
   363→      mouseY <= padding.top + chartHeight
   364→    ) {
   365→      // Convert mouse X to data value
   366→      const dataX = rangeMin + ((mouseX - padding.left) / chartWidth) * (rangeMax - rangeMin);
   367→      const dataScore = calculateScore(dataX);
   368→
   369→      setHover({
   370→        visible: true,
   371→        x: mouseX,
   372→        y: padding.top + (1 - dataScore / 10) * chartHeight,
   373→        value: dataX,
   374→        score: dataScore,
   375→      });
   376→    } else {
   377→      setHover(prev => ({ ...prev, visible: false }));
   378→    }
   379→  };
   380→
   381→  const handleMouseLeave = () => {
   382→    setHover(prev => ({ ...prev, visible: false }));
   383→  };
   384→
   385→  // Format value with unit
   386→  const formatWithUnit = (val: number): string => {
   387→    if (unit === 'percent' || unit === '%') {
   388→      return val.toFixed(1) + '%';
   389→    } else if (unit === 'degrees') {
   390→      return val.toFixed(1) + '°';
   391→    } else if (unit === 'mm') {
   392→      return val.toFixed(1) + 'mm';
   393→    }
   394→    return val.toFixed(2);
   395→  };
   396→
   397→  return (
   398→    <div className="rounded-xl bg-neutral-800/50 border border-neutral-700 p-4">
   399→      <div className="mb-3">
   400→        <div className="flex items-start justify-between">
   401→          <div>
   402→            <div className="flex items-center gap-1.5 mb-1">
   403→              <BarChart3 size={14} className="text-neutral-400" />
   404→              <span className="text-[10px] font-medium text-neutral-400 uppercase tracking-wider">
   405→                Scoring Methodology
   406→              </span>
   407→            </div>
   408→            <div className="text-[10px] text-neutral-500">Hover to explore the curve</div>
   409→          </div>
   410→          <div className="text-right bg-neutral-900/80 px-3 py-1.5 rounded-lg border border-neutral-700">
   411→            <div className="text-[10px] text-neutral-500 mb-0.5">Your Value</div>
   412→            <div className="text-xs font-medium" style={{ color: getScoreColor(score) }}>
   413→              {formatWithUnit(value)} = {score.toFixed(1)}/10
   414→            </div>
   415→          </div>
   416→        </div>
   417→      </div>
   418→      <div ref={containerRef} className="relative h-56 sm:h-64">
   419→        <canvas
   420→          ref={canvasRef}
   421→          className="w-full h-full cursor-crosshair"
   422→          style={{ display: 'block' }}
   423→          onMouseMove={handleMouseMove}
   424→          onMouseLeave={handleMouseLeave}
   425→        />
   426→
   427→        {/* Hover Tooltip */}
   428→        <AnimatePresence>
   429→          {hover.visible && (
   430→            <motion.div
   431→              initial={{ opacity: 0, scale: 0.9 }}
   432→              animate={{ opacity: 1, scale: 1 }}
   433→              exit={{ opacity: 0, scale: 0.9 }}
   434→              transition={{ duration: 0.1 }}
   435→              className="absolute pointer-events-none z-10"
   436→              style={{
   437→                left: hover.x,
   438→                top: hover.y - 50,
   439→                transform: 'translateX(-50%)',
   440→              }}
   441→            >
   442→              <div
   443→                className="px-3 py-2 rounded-lg shadow-xl border backdrop-blur-sm"
   444→                style={{
   445→                  backgroundColor: 'rgba(23, 23, 23, 0.95)',
   446→                  borderColor: getColorForScore(hover.score),
   447→                }}
   448→              >
   449→                <div className="text-[10px] text-neutral-400 mb-0.5">Value</div>
   450→                <div className="text-sm font-semibold text-white">
   451→                  {formatWithUnit(hover.value)}
   452→                </div>
   453→                <div className="mt-1 pt-1 border-t border-neutral-700">
   454→                  <div className="text-[10px] text-neutral-400 mb-0.5">Score</div>
   455→                  <div
   456→                    className="text-sm font-bold"
   457→                    style={{ color: getColorForScore(hover.score) }}
   458→                  >
   459→                    {hover.score.toFixed(1)}/10
   460→                  </div>
   461→                </div>
   462→              </div>
   463→              {/* Tooltip arrow */}
   464→              <div
   465→                className="absolute left-1/2 -translate-x-1/2 -bottom-1.5 w-3 h-3 rotate-45"
   466→                style={{
   467→                  backgroundColor: 'rgba(23, 23, 23, 0.95)',
   468→                  borderRight: `1px solid ${getColorForScore(hover.score)}`,
   469→                  borderBottom: `1px solid ${getColorForScore(hover.score)}`,
   470→                }}
   471→              />
   472→            </motion.div>
   473→          )}
   474→        </AnimatePresence>
   475→
   476→        {/* Hover vertical line indicator */}
   477→        {hover.visible && (
   478→          <div
   479→            className="absolute top-5 pointer-events-none"
   480→            style={{
   481→              left: hover.x,
   482→              height: chartDimensionsRef.current.chartHeight,
   483→              width: 1,
   484→              background: `linear-gradient(to bottom, ${getColorForScore(hover.score)}40, transparent)`,
   485→            }}
   486→          />
   487→        )}
   488→
   489→        {/* Hover point indicator */}
   490→        {hover.visible && (
   491→          <motion.div
   492→            initial={{ scale: 0 }}
   493→            animate={{ scale: 1 }}
   494→            className="absolute pointer-events-none"
   495→            style={{
   496→              left: hover.x - 5,
   497→              top: hover.y - 5,
   498→              width: 10,
   499→              height: 10,
   500→              borderRadius: '50%',
   501→              backgroundColor: getColorForScore(hover.score),
   502→              boxShadow: `0 0 10px ${getColorForScore(hover.score)}`,
   503→            }}
   504→          />
   505→        )}
   506→      </div>
   507→
   508→      {/* Legend */}
   509→      <div className="mt-3 flex items-center justify-center gap-4 text-[10px]">
   510→        <div className="flex items-center gap-1.5">
   511→          <div className="w-2.5 h-2.5 rounded-full bg-green-500" />
   512→          <span className="text-neutral-400">Ideal (9-10)</span>
   513→        </div>
   514→        <div className="flex items-center gap-1.5">
   515→          <div className="w-2.5 h-2.5 rounded-full bg-cyan-500" />
   516→          <span className="text-neutral-400">Good (7-9)</span>
   517→        </div>
   518→        <div className="flex items-center gap-1.5">
   519→          <div className="w-2.5 h-2.5 rounded-full bg-yellow-400" />
   520→          <span className="text-neutral-400">Average (5-7)</span>
   521→        </div>
   522→        <div className="flex items-center gap-1.5">
   523→          <div className="w-2.5 h-2.5 rounded-full bg-orange-500" />
   524→          <span className="text-neutral-400">Below (3-5)</span>
   525→        </div>
   526→        <div className="flex items-center gap-1.5">
   527→          <div className="w-2.5 h-2.5 rounded-full bg-red-500" />
   528→          <span className="text-neutral-400">Poor (1-3)</span>
   529→        </div>
   530→      </div>
   531→    </div>
   532→  );
   533→}
   534→
   535→// ============================================
   536→// ABOUT DESCRIPTIONS
   537→// ============================================