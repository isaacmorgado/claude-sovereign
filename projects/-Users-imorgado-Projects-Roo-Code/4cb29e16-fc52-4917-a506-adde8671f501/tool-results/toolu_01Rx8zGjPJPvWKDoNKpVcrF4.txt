     1→import * as vscode from "vscode"
     2→import * as http from "http"
     3→import { EventEmitter } from "events"
     4→import { WebSocketServer, WebSocket } from "ws"
     5→import { v4 as uuidv4 } from "uuid"
     6→
     7→import type {
     8→	BridgeConnectionState,
     9→	BridgeMessage,
    10→	BridgeMessageType,
    11→	BridgeConfig,
    12→	BridgeEvents,
    13→	HandshakePayload,
    14→	DOMElementInfo,
    15→	PageInfo,
    16→	NetworkRequestInfo,
    17→	ConsoleMessageInfo,
    18→	TabInfo,
    19→} from "./types"
    20→import { DEFAULT_BRIDGE_CONFIG, BridgeMessageSchema } from "./types"
    21→
    22→/**
    23→ * Manages WebSocket communication between VS Code extension and Chrome companion extension.
    24→ *
    25→ * Features:
    26→ * - WebSocket server for browser extension connection
    27→ * - DOM inspection tools
    28→ * - Network request monitoring
    29→ * - Console message capture
    30→ * - Tab management
    31→ * - Heartbeat/ping-pong for connection health
    32→ *
    33→ * Architecture:
    34→ * ```
    35→ * VS Code Extension (this)
    36→ *        ↕ WebSocket
    37→ * Chrome Extension (companion)
    38→ *        ↕ Chrome APIs
    39→ * Browser Tab (content script)
    40→ * ```
    41→ */
    42→export class BrowserExtensionBridge extends EventEmitter implements vscode.Disposable {
    43→	private static instance: BrowserExtensionBridge | null = null
    44→	private context: vscode.ExtensionContext
    45→	private config: BridgeConfig
    46→	private server: http.Server | null = null
    47→	private wss: WebSocketServer | null = null
    48→	private client: WebSocket | null = null
    49→	private connectionState: BridgeConnectionState = "disconnected"
    50→	private extensionInfo: HandshakePayload | null = null
    51→	private heartbeatTimer: NodeJS.Timeout | null = null
    52→	private connectionTimeoutTimer: NodeJS.Timeout | null = null
    53→	private pendingRequests: Map<string, { resolve: (value: unknown) => void; reject: (error: Error) => void }> =
    54→		new Map()
    55→	private networkRequests: NetworkRequestInfo[] = []
    56→	private consoleMessages: ConsoleMessageInfo[] = []
    57→	private disposables: vscode.Disposable[] = []
    58→
    59→	private constructor(context: vscode.ExtensionContext, config?: Partial<BridgeConfig>) {
    60→		super()
    61→		this.context = context
    62→		this.config = { ...DEFAULT_BRIDGE_CONFIG, ...config }
    63→	}
    64→
    65→	/**
    66→	 * Get the singleton instance of BrowserExtensionBridge
    67→	 */
    68→	static getInstance(context: vscode.ExtensionContext, config?: Partial<BridgeConfig>): BrowserExtensionBridge {
    69→		if (!BrowserExtensionBridge.instance) {
    70→			BrowserExtensionBridge.instance = new BrowserExtensionBridge(context, config)
    71→		}
    72→		return BrowserExtensionBridge.instance
    73→	}
    74→
    75→	/**
    76→	 * Check if instance exists
    77→	 */
    78→	static hasInstance(): boolean {
    79→		return BrowserExtensionBridge.instance !== null
    80→	}
    81→
    82→	/**
    83→	 * Cleanup the singleton instance
    84→	 */
    85→	static cleanup(): void {
    86→		if (BrowserExtensionBridge.instance) {
    87→			BrowserExtensionBridge.instance.dispose()
    88→			BrowserExtensionBridge.instance = null
    89→		}
    90→	}
    91→
    92→	/**
    93→	 * Start the WebSocket server
    94→	 */
    95→	async start(): Promise<void> {
    96→		if (this.server) {
    97→			console.log("[BrowserExtensionBridge] Server already running")
    98→			return
    99→		}
   100→
   101→		return new Promise((resolve, reject) => {
   102→			try {
   103→				this.server = http.createServer()
   104→				this.wss = new WebSocketServer({ server: this.server })
   105→
   106→				this.wss.on("connection", (ws: WebSocket) => {
   107→					this.handleConnection(ws)
   108→				})
   109→
   110→				this.wss.on("error", (error) => {
   111→					console.error("[BrowserExtensionBridge] WebSocket server error:", error)
   112→					this.emit("error", error)
   113→				})
   114→
   115→				this.server.listen(this.config.port, this.config.host, () => {
   116→					console.log(`[BrowserExtensionBridge] Server started on ws://${this.config.host}:${this.config.port}`)
   117→					resolve()
   118→				})
   119→
   120→				this.server.on("error", (error: NodeJS.ErrnoException) => {
   121→					if (error.code === "EADDRINUSE") {
   122→						console.error(`[BrowserExtensionBridge] Port ${this.config.port} is already in use`)
   123→					}
   124→					reject(error)
   125→				})
   126→			} catch (error) {
   127→				reject(error)
   128→			}
   129→		})
   130→	}
   131→
   132→	/**
   133→	 * Stop the WebSocket server
   134→	 */
   135→	async stop(): Promise<void> {
   136→		this.clearTimers()
   137→
   138→		if (this.client) {
   139→			this.client.close()
   140→			this.client = null
   141→		}
   142→
   143→		if (this.wss) {
   144→			this.wss.close()
   145→			this.wss = null
   146→		}
   147→
   148→		if (this.server) {
   149→			return new Promise((resolve) => {
   150→				this.server!.close(() => {
   151→					this.server = null
   152→					this.setConnectionState("disconnected")
   153→					console.log("[BrowserExtensionBridge] Server stopped")
   154→					resolve()
   155→				})
   156→			})
   157→		}
   158→	}
   159→
   160→	/**
   161→	 * Handle new WebSocket connection from Chrome extension
   162→	 */
   163→	private handleConnection(ws: WebSocket): void {
   164→		// Only allow one connection at a time
   165→		if (this.client) {
   166→			ws.close(1000, "Another client already connected")
   167→			return
   168→		}
   169→
   170→		this.client = ws
   171→		this.setConnectionState("connecting")
   172→
   173→		// Set connection timeout
   174→		this.connectionTimeoutTimer = setTimeout(() => {
   175→			if (this.connectionState === "connecting") {
   176→				console.error("[BrowserExtensionBridge] Connection timeout - no handshake received")
   177→				ws.close(1000, "Handshake timeout")
   178→				this.setConnectionState("disconnected")
   179→			}
   180→		}, this.config.connectionTimeout)
   181→
   182→		ws.on("message", (data: Buffer) => {
   183→			try {
   184→				const message = JSON.parse(data.toString()) as BridgeMessage
   185→				this.handleMessage(message)
   186→			} catch (error) {
   187→				console.error("[BrowserExtensionBridge] Failed to parse message:", error)
   188→			}
   189→		})
   190→
   191→		ws.on("close", (code, reason) => {
   192→			console.log(`[BrowserExtensionBridge] Client disconnected: ${code} - ${reason.toString()}`)
   193→			this.client = null
   194→			this.extensionInfo = null
   195→			this.clearTimers()
   196→			this.setConnectionState("disconnected")
   197→			this.emit("disconnected", reason.toString())
   198→		})
   199→
   200→		ws.on("error", (error) => {
   201→			console.error("[BrowserExtensionBridge] WebSocket error:", error)
   202→			this.emit("error", error)
   203→			this.setConnectionState("error")
   204→		})
   205→
   206→		ws.on("pong", () => {
   207→			// Connection is alive
   208→		})
   209→	}
   210→
   211→	/**
   212→	 * Handle incoming message from Chrome extension
   213→	 */
   214→	private handleMessage(message: BridgeMessage): void {
   215→		// Validate message structure
   216→		const parseResult = BridgeMessageSchema.safeParse(message)
   217→		if (!parseResult.success) {
   218→			console.error("[BrowserExtensionBridge] Invalid message:", parseResult.error)
   219→			return
   220→		}
   221→
   222→		switch (message.type) {
   223→			case "handshake":
   224→				this.handleHandshake(message)
   225→				break
   226→
   227→			case "pong":
   228→				// Heartbeat response - connection is alive
   229→				break
   230→
   231→			case "network_request":
   232→				this.handleNetworkRequest(message)
   233→				break
   234→
   235→			case "network_response":
   236→				this.handleNetworkResponse(message)
   237→				break
   238→
   239→			case "console_message":
   240→				this.handleConsoleMessage(message)
   241→				break
   242→
   243→			default:
   244→				// Check if this is a response to a pending request
   245→				if (this.pendingRequests.has(message.id)) {
   246→					const { resolve } = this.pendingRequests.get(message.id)!
   247→					this.pendingRequests.delete(message.id)
   248→					resolve(message.payload)
   249→				}
   250→				break
   251→		}
   252→	}
   253→
   254→	/**
   255→	 * Handle handshake message from Chrome extension
   256→	 */
   257→	private handleHandshake(message: BridgeMessage): void {
   258→		if (this.connectionTimeoutTimer) {
   259→			clearTimeout(this.connectionTimeoutTimer)
   260→			this.connectionTimeoutTimer = null
   261→		}
   262→
   263→		this.extensionInfo = message.payload as unknown as HandshakePayload
   264→		this.setConnectionState("connected")
   265→
   266→		// Send handshake acknowledgment
   267→		this.send({
   268→			id: uuidv4(),
   269→			type: "handshake_ack",
   270→			timestamp: Date.now(),
   271→			payload: {
   272→				serverVersion: "1.0.0",
   273→				capabilities: ["dom_inspection", "network_monitoring", "console_monitoring", "tab_management"],
   274→			},
   275→		})
   276→
   277→		// Start heartbeat
   278→		this.startHeartbeat()
   279→
   280→		// Enable monitoring if configured
   281→		if (this.config.enableNetworkMonitoring) {
   282→			this.enableNetworkMonitoring()
   283→		}
   284→		if (this.config.enableConsoleMonitoring) {
   285→			this.enableConsoleMonitoring()
   286→		}
   287→
   288→		console.log(
   289→			`[BrowserExtensionBridge] Connected to ${this.extensionInfo.browserName} v${this.extensionInfo.browserVersion}`,
   290→		)
   291→		this.emit("connected", this.extensionInfo)
   292→	}
   293→
   294→	/**
   295→	 * Handle network request event
   296→	 */
   297→	private handleNetworkRequest(message: BridgeMessage): void {
   298→		const request = message.payload as unknown as NetworkRequestInfo
   299→		this.networkRequests.push(request)
   300→
   301→		// Trim if exceeds max
   302→		if (this.networkRequests.length > this.config.maxNetworkRequests) {
   303→			this.networkRequests.shift()
   304→		}
   305→
   306→		this.emit("network-request", request)
   307→	}
   308→
   309→	/**
   310→	 * Handle network response event
   311→	 */
   312→	private handleNetworkResponse(message: BridgeMessage): void {
   313→		const response = message.payload as unknown as NetworkRequestInfo
   314→
   315→		// Find and update the corresponding request
   316→		const index = this.networkRequests.findIndex((r) => r.requestId === response.requestId)
   317→		if (index !== -1) {
   318→			this.networkRequests[index] = { ...this.networkRequests[index], ...response }
   319→		}
   320→
   321→		this.emit("network-response", response)
   322→	}
   323→
   324→	/**
   325→	 * Handle console message event
   326→	 */
   327→	private handleConsoleMessage(message: BridgeMessage): void {
   328→		const consoleMsg = message.payload as unknown as ConsoleMessageInfo
   329→		this.consoleMessages.push(consoleMsg)
   330→
   331→		// Trim if exceeds max
   332→		if (this.consoleMessages.length > this.config.maxConsoleMessages) {
   333→			this.consoleMessages.shift()
   334→		}
   335→
   336→		this.emit("console-message", consoleMsg)
   337→	}
   338→
   339→	/**
   340→	 * Send a message to the Chrome extension
   341→	 */
   342→	private send(message: BridgeMessage): boolean {
   343→		if (!this.client || this.client.readyState !== WebSocket.OPEN) {
   344→			console.warn("[BrowserExtensionBridge] Cannot send - not connected")
   345→			return false
   346→		}
   347→
   348→		try {
   349→			this.client.send(JSON.stringify(message))
   350→			return true
   351→		} catch (error) {
   352→			console.error("[BrowserExtensionBridge] Send error:", error)
   353→			return false
   354→		}
   355→	}
   356→
   357→	/**
   358→	 * Send a request and wait for response
   359→	 */
   360→	private async sendRequest<T>(
   361→		type: BridgeMessageType,
   362→		payload?: Record<string, unknown>,
   363→		tabId?: number,
   364→		timeout = 30000,
   365→	): Promise<T> {
   366→		return new Promise((resolve, reject) => {
   367→			const id = uuidv4()
   368→
   369→			const timer = setTimeout(() => {
   370→				this.pendingRequests.delete(id)
   371→				reject(new Error(`Request timeout: ${type}`))
   372→			}, timeout)
   373→
   374→			this.pendingRequests.set(id, {
   375→				resolve: (value) => {
   376→					clearTimeout(timer)
   377→					resolve(value as T)
   378→				},
   379→				reject: (error) => {
   380→					clearTimeout(timer)
   381→					reject(error)
   382→				},
   383→			})
   384→
   385→			const success = this.send({
   386→				id,
   387→				type,
   388→				timestamp: Date.now(),
   389→				tabId,
   390→				payload,
   391→			})
   392→
   393→			if (!success) {
   394→				this.pendingRequests.delete(id)
   395→				clearTimeout(timer)
   396→				reject(new Error("Failed to send request"))
   397→			}
   398→		})
   399→	}
   400→
   401→	/**
   402→	 * Start heartbeat to maintain connection
   403→	 */
   404→	private startHeartbeat(): void {
   405→		this.heartbeatTimer = setInterval(() => {
   406→			if (this.client && this.client.readyState === WebSocket.OPEN) {
   407→				this.client.ping()
   408→			}
   409→		}, this.config.heartbeatInterval)
   410→	}
   411→
   412→	/**
   413→	 * Clear all timers
   414→	 */
   415→	private clearTimers(): void {
   416→		if (this.heartbeatTimer) {
   417→			clearInterval(this.heartbeatTimer)
   418→			this.heartbeatTimer = null
   419→		}
   420→		if (this.connectionTimeoutTimer) {
   421→			clearTimeout(this.connectionTimeoutTimer)
   422→			this.connectionTimeoutTimer = null
   423→		}
   424→	}
   425→
   426→	/**
   427→	 * Set connection state and emit event
   428→	 */
   429→	private setConnectionState(state: BridgeConnectionState): void {
   430→		if (this.connectionState !== state) {
   431→			this.connectionState = state
   432→			this.emit("connection-state-changed", state)
   433→		}
   434→	}
   435→
   436→	// ==================== Public API ====================
   437→
   438→	/**
   439→	 * Get current connection state
   440→	 */
   441→	getConnectionState(): BridgeConnectionState {
   442→		return this.connectionState
   443→	}
   444→
   445→	/**
   446→	 * Check if connected to Chrome extension
   447→	 */
   448→	isConnected(): boolean {
   449→		return this.connectionState === "connected"
   450→	}
   451→
   452→	/**
   453→	 * Get connected extension info
   454→	 */
   455→	getExtensionInfo(): HandshakePayload | null {
   456→		return this.extensionInfo
   457→	}
   458→
   459→	/**
   460→	 * Get server URL for the Chrome extension to connect
   461→	 */
   462→	getServerUrl(): string {
   463→		return `ws://${this.config.host}:${this.config.port}`
   464→	}
   465→
   466→	// ==================== DOM Inspection ====================
   467→
   468→	/**
   469→	 * Inspect DOM element at coordinates
   470→	 */
   471→	async inspectElementAt(tabId: number, x: number, y: number): Promise<DOMElementInfo | null> {
   472→		if (!this.isConnected()) {
   473→			throw new Error("Not connected to browser extension")
   474→		}
   475→
   476→		return this.sendRequest<DOMElementInfo | null>("dom_inspect_request", { x, y }, tabId)
   477→	}
   478→
   479→	/**
   480→	 * Query DOM elements by CSS selector
   481→	 */
   482→	async querySelectorAll(tabId: number, selector: string, includeChildren = false): Promise<DOMElementInfo[]> {
   483→		if (!this.isConnected()) {
   484→			throw new Error("Not connected to browser extension")
   485→		}
   486→
   487→		return this.sendRequest<DOMElementInfo[]>("dom_query_selector", { selector, includeChildren }, tabId)
   488→	}
   489→
   490→	/**
   491→	 * Get computed styles for an element
   492→	 */
   493→	async getComputedStyles(tabId: number, selector: string): Promise<Record<string, string> | null> {
   494→		if (!this.isConnected()) {
   495→			throw new Error("Not connected to browser extension")
   496→		}
   497→
   498→		return this.sendRequest<Record<string, string> | null>("dom_get_computed_styles", { selector }, tabId)
   499→	}
   500→
   501→	/**
   502→	 * Highlight an element on the page
   503→	 */
   504→	async highlightElement(tabId: number, selector: string, color = "rgba(255, 0, 0, 0.3)"): Promise<void> {
   505→		if (!this.isConnected()) {
   506→			throw new Error("Not connected to browser extension")
   507→		}
   508→
   509→		await this.sendRequest<void>("dom_highlight_element", { selector, color }, tabId)
   510→	}
   511→
   512→	/**
   513→	 * Clear element highlights
   514→	 */
   515→	async clearHighlights(tabId: number): Promise<void> {
   516→		if (!this.isConnected()) {
   517→			throw new Error("Not connected to browser extension")
   518→		}
   519→
   520→		await this.sendRequest<void>("dom_highlight_clear", {}, tabId)
   521→	}
   522→
   523→	// ==================== Page Interaction ====================
   524→
   525→	/**
   526→	 * Take a screenshot of the page
   527→	 */
   528→	async takeScreenshot(
   529→		tabId: number,
   530→		options?: { format?: "png" | "jpeg"; quality?: number; fullPage?: boolean },
   531→	): Promise<string> {
   532→		if (!this.isConnected()) {
   533→			throw new Error("Not connected to browser extension")
   534→		}
   535→
   536→		return this.sendRequest<string>("page_screenshot", options ?? {}, tabId)
   537→	}
   538→
   539→	/**
   540→	 * Navigate to a URL
   541→	 */
   542→	async navigateTo(tabId: number, url: string): Promise<void> {
   543→		if (!this.isConnected()) {
   544→			throw new Error("Not connected to browser extension")
   545→		}
   546→
   547→		await this.sendRequest<void>("page_navigate", { url }, tabId)
   548→	}
   549→
   550→	/**
   551→	 * Reload the page
   552→	 */
   553→	async reloadPage(tabId: number, ignoreCache = false): Promise<void> {
   554→		if (!this.isConnected()) {
   555→			throw new Error("Not connected to browser extension")
   556→		}
   557→
   558→		await this.sendRequest<void>("page_reload", { ignoreCache }, tabId)
   559→	}
   560→
   561→	/**
   562→	 * Execute JavaScript in the page context
   563→	 */
   564→	async executeScript<T>(tabId: number, script: string): Promise<T> {
   565→		if (!this.isConnected()) {
   566→			throw new Error("Not connected to browser extension")
   567→		}
   568→
   569→		return this.sendRequest<T>("page_execute_script", { script }, tabId)
   570→	}
   571→
   572→	/**
   573→	 * Get current page info
   574→	 */
   575→	async getPageInfo(tabId: number): Promise<PageInfo> {
   576→		if (!this.isConnected()) {
   577→			throw new Error("Not connected to browser extension")
   578→		}
   579→
   580→		return this.sendRequest<PageInfo>("page_get_info", {}, tabId)
   581→	}
   582→
   583→	// ==================== Network Monitoring ====================
   584→
   585→	/**
   586→	 * Enable network request monitoring
   587→	 */
   588→	async enableNetworkMonitoring(): Promise<void> {
   589→		if (!this.isConnected()) {
   590→			return
   591→		}
   592→
   593→		this.send({
   594→			id: uuidv4(),
   595→			type: "network_enable",
   596→			timestamp: Date.now(),
   597→		})
   598→	}
   599→
   600→	/**
   601→	 * Disable network request monitoring
   602→	 */
   603→	async disableNetworkMonitoring(): Promise<void> {
   604→		if (!this.isConnected()) {
   605→			return
   606→		}
   607→
   608→		this.send({
   609→			id: uuidv4(),
   610→			type: "network_disable",
   611→			timestamp: Date.now(),
   612→		})
   613→	}
   614→
   615→	/**
   616→	 * Get captured network requests
   617→	 */
   618→	getNetworkRequests(): NetworkRequestInfo[] {
   619→		return [...this.networkRequests]
   620→	}
   621→
   622→	/**
   623→	 * Clear captured network requests
   624→	 */
   625→	clearNetworkRequests(): void {
   626→		this.networkRequests = []
   627→	}
   628→
   629→	// ==================== Console Monitoring ====================
   630→
   631→	/**
   632→	 * Enable console message monitoring
   633→	 */
   634→	async enableConsoleMonitoring(): Promise<void> {
   635→		if (!this.isConnected()) {
   636→			return
   637→		}
   638→
   639→		this.send({
   640→			id: uuidv4(),
   641→			type: "console_enable",
   642→			timestamp: Date.now(),
   643→		})
   644→	}
   645→
   646→	/**
   647→	 * Disable console message monitoring
   648→	 */
   649→	async disableConsoleMonitoring(): Promise<void> {
   650→		if (!this.isConnected()) {
   651→			return
   652→		}
   653→
   654→		this.send({
   655→			id: uuidv4(),
   656→			type: "console_disable",
   657→			timestamp: Date.now(),
   658→		})
   659→	}
   660→
   661→	/**
   662→	 * Get captured console messages
   663→	 */
   664→	getConsoleMessages(): ConsoleMessageInfo[] {
   665→		return [...this.consoleMessages]
   666→	}
   667→
   668→	/**
   669→	 * Clear captured console messages
   670→	 */
   671→	clearConsoleMessages(): void {
   672→		this.consoleMessages = []
   673→	}
   674→
   675→	// ==================== Tab Management ====================
   676→
   677→	/**
   678→	 * List all browser tabs
   679→	 */
   680→	async listTabs(): Promise<TabInfo[]> {
   681→		if (!this.isConnected()) {
   682→			throw new Error("Not connected to browser extension")
   683→		}
   684→
   685→		return this.sendRequest<TabInfo[]>("tabs_list", {})
   686→	}
   687→
   688→	/**
   689→	 * Activate a tab
   690→	 */
   691→	async activateTab(tabId: number): Promise<void> {
   692→		if (!this.isConnected()) {
   693→			throw new Error("Not connected to browser extension")
   694→		}
   695→
   696→		await this.sendRequest<void>("tabs_activate", { tabId })
   697→	}
   698→
   699→	/**
   700→	 * Close a tab
   701→	 */
   702→	async closeTab(tabId: number): Promise<void> {
   703→		if (!this.isConnected()) {
   704→			throw new Error("Not connected to browser extension")
   705→		}
   706→
   707→		await this.sendRequest<void>("tabs_close", { tabId })
   708→	}
   709→
   710→	/**
   711→	 * Create a new tab
   712→	 */
   713→	async createTab(url?: string): Promise<TabInfo> {
   714→		if (!this.isConnected()) {
   715→			throw new Error("Not connected to browser extension")
   716→		}
   717→
   718→		return this.sendRequest<TabInfo>("tabs_create", { url })
   719→	}
   720→
   721→	// ==================== Dispose ====================
   722→
   723→	/**
   724→	 * Dispose of resources
   725→	 */
   726→	dispose(): void {
   727→		// Reject all pending requests
   728→		for (const [id, { reject }] of this.pendingRequests) {
   729→			reject(new Error("Bridge disposed"))
   730→		}
   731→		this.pendingRequests.clear()
   732→
   733→		// Stop server
   734→		this.stop().catch(console.error)
   735→
   736→		// Dispose subscriptions
   737→		for (const disposable of this.disposables) {
   738→			disposable.dispose()
   739→		}
   740→		this.disposables = []
   741→
   742→		// Clear data
   743→		this.networkRequests = []
   744→		this.consoleMessages = []
   745→
   746→		this.removeAllListeners()
   747→	}
   748→}
   749→

</system-reminder>
