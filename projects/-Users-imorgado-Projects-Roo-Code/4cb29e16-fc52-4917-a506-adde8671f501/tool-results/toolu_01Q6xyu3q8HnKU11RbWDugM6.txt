     1→import * as crypto from "crypto"
     2→import * as http from "http"
     3→import { URL } from "url"
     4→import type { ExtensionContext } from "vscode"
     5→import { z } from "zod"
     6→
     7→// OAuth Configuration
     8→export const CLAUDE_CODE_OAUTH_CONFIG = {
     9→	authorizationEndpoint: "https://claude.ai/oauth/authorize",
    10→	tokenEndpoint: "https://console.anthropic.com/v1/oauth/token",
    11→	clientId: "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
    12→	redirectUri: "http://localhost:54545/callback",
    13→	scopes: "org:create_api_key user:profile user:inference",
    14→	callbackPort: 54545,
    15→} as const
    16→
    17→// Token storage key
    18→const CLAUDE_CODE_CREDENTIALS_KEY = "claude-code-oauth-credentials"
    19→
    20→// Credentials schema
    21→const claudeCodeCredentialsSchema = z.object({
    22→	type: z.literal("claude"),
    23→	access_token: z.string().min(1),
    24→	refresh_token: z.string().min(1),
    25→	expired: z.string(), // RFC3339 datetime
    26→	email: z.string().optional(),
    27→})
    28→
    29→export type ClaudeCodeCredentials = z.infer<typeof claudeCodeCredentialsSchema>
    30→
    31→// Token response schema from Anthropic
    32→const tokenResponseSchema = z.object({
    33→	access_token: z.string(),
    34→	refresh_token: z.string(),
    35→	expires_in: z.number(),
    36→	email: z.string().optional(),
    37→	token_type: z.string().optional(),
    38→})
    39→
    40→/**
    41→ * Generates a cryptographically random PKCE code verifier
    42→ * Must be 43-128 characters long using unreserved characters
    43→ */
    44→export function generateCodeVerifier(): string {
    45→	// Generate 32 random bytes and encode as base64url (will be 43 characters)
    46→	const buffer = crypto.randomBytes(32)
    47→	return buffer.toString("base64url")
    48→}
    49→
    50→/**
    51→ * Generates the PKCE code challenge from the verifier using S256 method
    52→ */
    53→export function generateCodeChallenge(verifier: string): string {
    54→	const hash = crypto.createHash("sha256").update(verifier).digest()
    55→	return hash.toString("base64url")
    56→}
    57→
    58→/**
    59→ * Generates a random state parameter for CSRF protection
    60→ */
    61→export function generateState(): string {
    62→	return crypto.randomBytes(16).toString("hex")
    63→}
    64→
    65→/**
    66→ * Generates a user_id in the format required by Claude Code API
    67→ * Format: user_<hash>_account_<uuid>_session_<uuid>
    68→ */
    69→export function generateUserId(email?: string): string {
    70→	// Generate user hash from email or random bytes
    71→	const userHash = email
    72→		? crypto.createHash("sha256").update(email).digest("hex").slice(0, 16)
    73→		: crypto.randomBytes(8).toString("hex")
    74→
    75→	// Generate account UUID (persistent per email or random)
    76→	const accountUuid = email
    77→		? crypto.createHash("sha256").update(`account:${email}`).digest("hex").slice(0, 32)
    78→		: crypto.randomUUID().replace(/-/g, "")
    79→
    80→	// Generate session UUID (always random for each request)
    81→	const sessionUuid = crypto.randomUUID().replace(/-/g, "")
    82→
    83→	return `user_${userHash}_account_${accountUuid}_session_${sessionUuid}`
    84→}
    85→
    86→/**
    87→ * Builds the authorization URL for OAuth flow
    88→ */
    89→export function buildAuthorizationUrl(codeChallenge: string, state: string): string {
    90→	const params = new URLSearchParams({
    91→		client_id: CLAUDE_CODE_OAUTH_CONFIG.clientId,
    92→		redirect_uri: CLAUDE_CODE_OAUTH_CONFIG.redirectUri,
    93→		scope: CLAUDE_CODE_OAUTH_CONFIG.scopes,
    94→		code_challenge: codeChallenge,
    95→		code_challenge_method: "S256",
    96→		response_type: "code",
    97→		state,
    98→	})
    99→
   100→	return `${CLAUDE_CODE_OAUTH_CONFIG.authorizationEndpoint}?${params.toString()}`
   101→}
   102→
   103→/**
   104→ * Exchanges the authorization code for tokens
   105→ */
   106→export async function exchangeCodeForTokens(
   107→	code: string,
   108→	codeVerifier: string,
   109→	state: string,
   110→): Promise<ClaudeCodeCredentials> {
   111→	const body = {
   112→		code,
   113→		state,
   114→		grant_type: "authorization_code",
   115→		client_id: CLAUDE_CODE_OAUTH_CONFIG.clientId,
   116→		redirect_uri: CLAUDE_CODE_OAUTH_CONFIG.redirectUri,
   117→		code_verifier: codeVerifier,
   118→	}
   119→
   120→	const response = await fetch(CLAUDE_CODE_OAUTH_CONFIG.tokenEndpoint, {
   121→		method: "POST",
   122→		headers: {
   123→			"Content-Type": "application/json",
   124→		},
   125→		body: JSON.stringify(body),
   126→		signal: AbortSignal.timeout(30000),
   127→	})
   128→
   129→	if (!response.ok) {
   130→		const errorText = await response.text()
   131→		throw new Error(`Token exchange failed: ${response.status} ${response.statusText} - ${errorText}`)
   132→	}
   133→
   134→	const data = await response.json()
   135→	const tokenResponse = tokenResponseSchema.parse(data)
   136→
   137→	// Calculate expiry time
   138→	const expiresAt = new Date(Date.now() + tokenResponse.expires_in * 1000)
   139→
   140→	return {
   141→		type: "claude",
   142→		access_token: tokenResponse.access_token,
   143→		refresh_token: tokenResponse.refresh_token,
   144→		expired: expiresAt.toISOString(),
   145→		email: tokenResponse.email,
   146→	}
   147→}
   148→
   149→/**
   150→ * Refreshes the access token using the refresh token
   151→ */
   152→export async function refreshAccessToken(refreshToken: string): Promise<ClaudeCodeCredentials> {
   153→	const body = {
   154→		grant_type: "refresh_token",
   155→		client_id: CLAUDE_CODE_OAUTH_CONFIG.clientId,
   156→		refresh_token: refreshToken,
   157→	}
   158→
   159→	const response = await fetch(CLAUDE_CODE_OAUTH_CONFIG.tokenEndpoint, {
   160→		method: "POST",
   161→		headers: {
   162→			"Content-Type": "application/json",
   163→		},
   164→		body: JSON.stringify(body),
   165→		signal: AbortSignal.timeout(30000),
   166→	})
   167→
   168→	if (!response.ok) {
   169→		const errorText = await response.text()
   170→		throw new Error(`Token refresh failed: ${response.status} ${response.statusText} - ${errorText}`)
   171→	}
   172→
   173→	const data = await response.json()
   174→	const tokenResponse = tokenResponseSchema.parse(data)
   175→
   176→	// Calculate expiry time
   177→	const expiresAt = new Date(Date.now() + tokenResponse.expires_in * 1000)
   178→
   179→	return {
   180→		type: "claude",
   181→		access_token: tokenResponse.access_token,
   182→		refresh_token: tokenResponse.refresh_token,
   183→		expired: expiresAt.toISOString(),
   184→		email: tokenResponse.email,
   185→	}
   186→}
   187→
   188→/**
   189→ * Checks if the credentials are expired (with 5 minute buffer)
   190→ */
   191→export function isTokenExpired(credentials: ClaudeCodeCredentials): boolean {
   192→	const expiryTime = new Date(credentials.expired).getTime()
   193→	const bufferMs = 5 * 60 * 1000 // 5 minutes buffer
   194→	return Date.now() >= expiryTime - bufferMs
   195→}
   196→
   197→/**
   198→ * ClaudeCodeOAuthManager - Handles OAuth flow and token management
   199→ */
   200→export class ClaudeCodeOAuthManager {
   201→	private context: ExtensionContext | null = null
   202→	private credentials: ClaudeCodeCredentials | null = null
   203→	private pendingAuth: {
   204→		codeVerifier: string
   205→		state: string
   206→		server?: http.Server
   207→	} | null = null
   208→
   209→	/**
   210→	 * Initialize the OAuth manager with VS Code extension context
   211→	 */
   212→	initialize(context: ExtensionContext): void {
   213→		this.context = context
   214→	}
   215→
   216→	/**
   217→	 * Load credentials from storage
   218→	 */
   219→	async loadCredentials(): Promise<ClaudeCodeCredentials | null> {
   220→		if (!this.context) {
   221→			return null
   222→		}
   223→
   224→		try {
   225→			const credentialsJson = await this.context.secrets.get(CLAUDE_CODE_CREDENTIALS_KEY)
   226→			if (!credentialsJson) {
   227→				return null
   228→			}
   229→
   230→			const parsed = JSON.parse(credentialsJson)
   231→			this.credentials = claudeCodeCredentialsSchema.parse(parsed)
   232→			return this.credentials
   233→		} catch (error) {
   234→			console.error("[claude-code-oauth] Failed to load credentials:", error)
   235→			return null
   236→		}
   237→	}
   238→
   239→	/**
   240→	 * Save credentials to storage
   241→	 */
   242→	async saveCredentials(credentials: ClaudeCodeCredentials): Promise<void> {
   243→		if (!this.context) {
   244→			throw new Error("OAuth manager not initialized")
   245→		}
   246→
   247→		await this.context.secrets.store(CLAUDE_CODE_CREDENTIALS_KEY, JSON.stringify(credentials))
   248→		this.credentials = credentials
   249→	}
   250→
   251→	/**
   252→	 * Clear credentials from storage
   253→	 */
   254→	async clearCredentials(): Promise<void> {
   255→		if (!this.context) {
   256→			return
   257→		}
   258→
   259→		await this.context.secrets.delete(CLAUDE_CODE_CREDENTIALS_KEY)
   260→		this.credentials = null
   261→	}
   262→
   263→	/**
   264→	 * Get a valid access token, refreshing if necessary
   265→	 */
   266→	async getAccessToken(): Promise<string | null> {
   267→		// Try to load credentials if not already loaded
   268→		if (!this.credentials) {
   269→			await this.loadCredentials()
   270→		}
   271→
   272→		if (!this.credentials) {
   273→			return null
   274→		}
   275→
   276→		// Check if token is expired and refresh if needed
   277→		if (isTokenExpired(this.credentials)) {
   278→			try {
   279→				const newCredentials = await refreshAccessToken(this.credentials.refresh_token)
   280→				await this.saveCredentials(newCredentials)
   281→			} catch (error) {
   282→				console.error("[claude-code-oauth] Failed to refresh token:", error)
   283→				// Clear invalid credentials
   284→				await this.clearCredentials()
   285→				return null
   286→			}
   287→		}
   288→
   289→		return this.credentials.access_token
   290→	}
   291→
   292→	/**
   293→	 * Get the user's email from credentials
   294→	 */
   295→	async getEmail(): Promise<string | null> {
   296→		if (!this.credentials) {
   297→			await this.loadCredentials()
   298→		}
   299→		return this.credentials?.email || null
   300→	}
   301→
   302→	/**
   303→	 * Check if the user is authenticated
   304→	 */
   305→	async isAuthenticated(): Promise<boolean> {
   306→		const token = await this.getAccessToken()
   307→		return token !== null
   308→	}
   309→
   310→	/**
   311→	 * Start the OAuth authorization flow
   312→	 * Returns the authorization URL to open in browser
   313→	 */
   314→	startAuthorizationFlow(): string {
   315→		// Cancel any existing authorization flow before starting a new one
   316→		this.cancelAuthorizationFlow()
   317→
   318→		const codeVerifier = generateCodeVerifier()
   319→		const codeChallenge = generateCodeChallenge(codeVerifier)
   320→		const state = generateState()
   321→
   322→		this.pendingAuth = {
   323→			codeVerifier,
   324→			state,
   325→		}
   326→
   327→		return buildAuthorizationUrl(codeChallenge, state)
   328→	}
   329→
   330→	/**
   331→	 * Start a local server to receive the OAuth callback
   332→	 * Returns a promise that resolves when authentication is complete
   333→	 */
   334→	async waitForCallback(): Promise<ClaudeCodeCredentials> {
   335→		if (!this.pendingAuth) {
   336→			throw new Error("No pending authorization flow")
   337→		}
   338→
   339→		// Close any existing server before starting a new one
   340→		if (this.pendingAuth.server) {
   341→			try {
   342→				this.pendingAuth.server.close()
   343→			} catch {
   344→				// Ignore errors when closing
   345→			}
   346→			this.pendingAuth.server = undefined
   347→		}
   348→
   349→		return new Promise((resolve, reject) => {
   350→			const server = http.createServer(async (req, res) => {
   351→				try {
   352→					const url = new URL(req.url || "", `http://localhost:${CLAUDE_CODE_OAUTH_CONFIG.callbackPort}`)
   353→
   354→					if (url.pathname !== "/callback") {
   355→						res.writeHead(404)
   356→						res.end("Not Found")
   357→						return
   358→					}
   359→
   360→					const code = url.searchParams.get("code")
   361→					const state = url.searchParams.get("state")
   362→					const error = url.searchParams.get("error")
   363→
   364→					if (error) {
   365→						res.writeHead(400)
   366→						res.end(`Authentication failed: ${error}`)
   367→						reject(new Error(`OAuth error: ${error}`))
   368→						server.close()
   369→						return
   370→					}
   371→
   372→					if (!code || !state) {
   373→						res.writeHead(400)
   374→						res.end("Missing code or state parameter")
   375→						reject(new Error("Missing code or state parameter"))
   376→						server.close()
   377→						return
   378→					}
   379→
   380→					if (state !== this.pendingAuth?.state) {
   381→						res.writeHead(400)
   382→						res.end("State mismatch - possible CSRF attack")
   383→						reject(new Error("State mismatch"))
   384→						server.close()
   385→						return
   386→					}
   387→
   388→					try {
   389→						const credentials = await exchangeCodeForTokens(code, this.pendingAuth.codeVerifier, state)
   390→
   391→						await this.saveCredentials(credentials)
   392→
   393→						res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" })
   394→						res.end(`<!DOCTYPE html>
   395→<html>
   396→<head>
   397→<meta charset="utf-8">
   398→<title>Authentication Successful</title>
   399→</head>
   400→<body style="font-family: system-ui; text-align: center; padding: 50px;">
   401→<h1>&#10003; Authentication Successful</h1>
   402→<p>You can close this window and return to VS Code.</p>
   403→<script>window.close();</script>
   404→</body>
   405→</html>`)
   406→
   407→						this.pendingAuth = null
   408→						server.close()
   409→						resolve(credentials)
   410→					} catch (exchangeError) {
   411→						res.writeHead(500)
   412→						res.end(`Token exchange failed: ${exchangeError}`)
   413→						reject(exchangeError)
   414→						server.close()
   415→					}
   416→				} catch (err) {
   417→					res.writeHead(500)
   418→					res.end("Internal server error")
   419→					reject(err)
   420→					server.close()
   421→				}
   422→			})
   423→
   424→			server.on("error", (err: NodeJS.ErrnoException) => {
   425→				this.pendingAuth = null
   426→				if (err.code === "EADDRINUSE") {
   427→					reject(
   428→						new Error(
   429→							`Port ${CLAUDE_CODE_OAUTH_CONFIG.callbackPort} is already in use. ` +
   430→								`Please close any other applications using this port and try again.`,
   431→						),
   432→					)
   433→				} else {
   434→					reject(err)
   435→				}
   436→			})
   437→
   438→			// Set a timeout for the callback
   439→			const timeout = setTimeout(
   440→				() => {
   441→					server.close()
   442→					reject(new Error("Authentication timed out"))
   443→				},
   444→				5 * 60 * 1000,
   445→			) // 5 minutes
   446→
   447→			server.listen(CLAUDE_CODE_OAUTH_CONFIG.callbackPort, () => {
   448→				if (this.pendingAuth) {
   449→					this.pendingAuth.server = server
   450→				}
   451→			})
   452→
   453→			// Clear timeout when server closes
   454→			server.on("close", () => {
   455→				clearTimeout(timeout)
   456→			})
   457→		})
   458→	}
   459→
   460→	/**
   461→	 * Cancel any pending authorization flow
   462→	 */
   463→	cancelAuthorizationFlow(): void {
   464→		if (this.pendingAuth?.server) {
   465→			this.pendingAuth.server.close()
   466→		}
   467→		this.pendingAuth = null
   468→	}
   469→
   470→	/**
   471→	 * Get the current credentials (for display purposes)
   472→	 */
   473→	getCredentials(): ClaudeCodeCredentials | null {
   474→		return this.credentials
   475→	}
   476→}
   477→
   478→// Singleton instance
   479→export const claudeCodeOAuthManager = new ClaudeCodeOAuthManager()
   480→

</system-reminder>
