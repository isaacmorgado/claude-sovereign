.claude/hooks/enhanced-audit-trail.sh.backup:1:#!/bin/bash
.claude/hooks/enhanced-audit-trail.sh.backup:2:# Enhanced Audit Trail - Reasoning logs with alternatives
.claude/hooks/enhanced-audit-trail.sh.backup:3:# Provides transparent decision-making trail
.claude/hooks/enhanced-audit-trail.sh.backup:4:
.claude/hooks/enhanced-audit-trail.sh.backup:5:set -eo pipefail
.claude/hooks/enhanced-audit-trail.sh.backup:6:
.claude/hooks/enhanced-audit-trail.sh.backup:7:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/enhanced-audit-trail.sh.backup:8:AUDIT_LOG="${CLAUDE_DIR}/.audit/decisions.jsonl"
.claude/hooks/enhanced-audit-trail.sh.backup:9:LOG_FILE="${CLAUDE_DIR}/audit-trail.log"
.claude/hooks/enhanced-audit-trail.sh.backup:10:
.claude/hooks/enhanced-audit-trail.sh.backup:11:mkdir -p "$(dirname "$AUDIT_LOG")"
.claude/hooks/enhanced-audit-trail.sh.backup:12:
.claude/hooks/enhanced-audit-trail.sh.backup:13:log() {
.claude/hooks/enhanced-audit-trail.sh.backup:14:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/enhanced-audit-trail.sh.backup:15:}
.claude/hooks/enhanced-audit-trail.sh.backup:16:
.claude/hooks/enhanced-audit-trail.sh.backup:17:# Log decision with reasoning
.claude/hooks/enhanced-audit-trail.sh.backup:18:log_decision() {
.claude/hooks/enhanced-audit-trail.sh.backup:19:    local action="$1"
.claude/hooks/enhanced-audit-trail.sh.backup:20:    local reasoning="$2"
.claude/hooks/enhanced-audit-trail.sh.backup:21:    local alternatives="$3"
.claude/hooks/enhanced-audit-trail.sh.backup:22:    local why_chosen="$4"
.claude/hooks/enhanced-audit-trail.sh.backup:23:    local confidence="${5:-0.8}"
.claude/hooks/enhanced-audit-trail.sh.backup:24:
.claude/hooks/enhanced-audit-trail.sh.backup:25:    local record
.claude/hooks/enhanced-audit-trail.sh.backup:26:    record=$(jq -n \
.claude/hooks/enhanced-audit-trail.sh.backup:27:        --arg action "$action" \
.claude/hooks/enhanced-audit-trail.sh.backup:28:        --arg reasoning "$reasoning" \
.claude/hooks/enhanced-audit-trail.sh.backup:29:        --arg alternatives "$alternatives" \
.claude/hooks/enhanced-audit-trail.sh.backup:30:        --arg why "$why_chosen" \
.claude/hooks/enhanced-audit-trail.sh.backup:31:        --arg conf "$confidence" \
.claude/hooks/enhanced-audit-trail.sh.backup:32:        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/enhanced-audit-trail.sh.backup:33:        '{
.claude/hooks/enhanced-audit-trail.sh.backup:34:            timestamp: $ts,
.claude/hooks/enhanced-audit-trail.sh.backup:35:            action: $action,
.claude/hooks/enhanced-audit-trail.sh.backup:36:            reasoning: $reasoning,
.claude/hooks/enhanced-audit-trail.sh.backup:37:            alternatives_considered: $alternatives,
.claude/hooks/enhanced-audit-trail.sh.backup:38:            why_chosen: $why,
.claude/hooks/enhanced-audit-trail.sh.backup:39:            confidence: ($conf | tonumber)
.claude/hooks/enhanced-audit-trail.sh.backup:40:        }')
.claude/hooks/enhanced-audit-trail.sh.backup:41:
.claude/hooks/enhanced-audit-trail.sh.backup:42:    echo "$record" >> "$AUDIT_LOG"
.claude/hooks/enhanced-audit-trail.sh.backup:43:
.claude/hooks/enhanced-audit-trail.sh.backup:44:    log "Logged decision: $action (confidence: $confidence)"
.claude/hooks/enhanced-audit-trail.sh.backup:45:}
.claude/hooks/enhanced-audit-trail.sh.backup:46:
.claude/hooks/enhanced-audit-trail.sh.backup:47:# Get decision history
.claude/hooks/enhanced-audit-trail.sh.backup:48:get_history() {
.claude/hooks/enhanced-audit-trail.sh.backup:49:    local limit="${1:-10}"
.claude/hooks/enhanced-audit-trail.sh.backup:50:
.claude/hooks/enhanced-audit-trail.sh.backup:51:    if [[ ! -f "$AUDIT_LOG" ]]; then
.claude/hooks/enhanced-audit-trail.sh.backup:52:        echo '[]'
.claude/hooks/enhanced-audit-trail.sh.backup:53:        return
.claude/hooks/enhanced-audit-trail.sh.backup:54:    fi
.claude/hooks/enhanced-audit-trail.sh.backup:55:
.claude/hooks/enhanced-audit-trail.sh.backup:56:    tail -n "$limit" "$AUDIT_LOG" | jq -s '.'
.claude/hooks/enhanced-audit-trail.sh.backup:57:}
.claude/hooks/enhanced-audit-trail.sh.backup:58:
.claude/hooks/enhanced-audit-trail.sh.backup:59:case "${1:-help}" in
.claude/hooks/enhanced-audit-trail.sh.backup:60:    log)
.claude/hooks/enhanced-audit-trail.sh.backup:61:        log_decision "${2:-action}" "${3:-reasoning}" "${4:-alternatives}" "${5:-why}" "${6:-0.8}"
.claude/hooks/enhanced-audit-trail.sh.backup:62:        ;;
.claude/hooks/enhanced-audit-trail.sh.backup:63:    history)
.claude/hooks/enhanced-audit-trail.sh.backup:64:        get_history "${2:-10}"
.claude/hooks/enhanced-audit-trail.sh.backup:65:        ;;
.claude/hooks/enhanced-audit-trail.sh.backup:66:    help|*)
.claude/hooks/enhanced-audit-trail.sh.backup:67:        echo "Enhanced Audit Trail"
.claude/hooks/enhanced-audit-trail.sh.backup:68:        echo "Usage: $0 <command> [args]"
.claude/hooks/enhanced-audit-trail.sh.backup:69:        echo "  log <action> <reasoning> <alternatives> <why> [confidence]"
.claude/hooks/enhanced-audit-trail.sh.backup:70:        echo "  history [limit]"
.claude/hooks/enhanced-audit-trail.sh.backup:71:        ;;
.claude/hooks/enhanced-audit-trail.sh.backup:72:esac
.claude/hooks/risk-predictor.sh:1:#!/bin/bash
.claude/hooks/risk-predictor.sh:2:# Risk Predictor - Pre-execution risk assessment
.claude/hooks/risk-predictor.sh:3:# Predicts failure probability before executing operations
.claude/hooks/risk-predictor.sh:4:
.claude/hooks/risk-predictor.sh:5:set -uo pipefail
.claude/hooks/risk-predictor.sh:6:
.claude/hooks/risk-predictor.sh:7:RISK_DIR="${HOME}/.claude/risk"
.claude/hooks/risk-predictor.sh:8:RISK_MODELS="$RISK_DIR/models.json"
.claude/hooks/risk-predictor.sh:9:LOG_FILE="${HOME}/.claude/risk-predictor.log"
.claude/hooks/risk-predictor.sh:10:
.claude/hooks/risk-predictor.sh:11:# Integration
.claude/hooks/risk-predictor.sh:12:LEARNING_ENGINE="${HOME}/.claude/hooks/learning-engine.sh"
.claude/hooks/risk-predictor.sh:13:MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/risk-predictor.sh:14:
.claude/hooks/risk-predictor.sh:15:log() {
.claude/hooks/risk-predictor.sh:16:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/risk-predictor.sh:17:}
.claude/hooks/risk-predictor.sh:18:
.claude/hooks/risk-predictor.sh:19:init_risk() {
.claude/hooks/risk-predictor.sh:20:    mkdir -p "$RISK_DIR"
.claude/hooks/risk-predictor.sh:21:    [[ -f "$RISK_MODELS" ]] || echo '{"codeComplexity":{},"historicalFailures":{},"dependencies":{}}' > "$RISK_MODELS"
.claude/hooks/risk-predictor.sh:22:}
.claude/hooks/risk-predictor.sh:23:
.claude/hooks/risk-predictor.sh:24:# =============================================================================
.claude/hooks/risk-predictor.sh:25:# CODE COMPLEXITY ANALYSIS
.claude/hooks/risk-predictor.sh:26:# =============================================================================
.claude/hooks/risk-predictor.sh:27:
.claude/hooks/risk-predictor.sh:28:analyze_code_complexity() {
.claude/hooks/risk-predictor.sh:29:    local file_path="$1"
.claude/hooks/risk-predictor.sh:30:
.claude/hooks/risk-predictor.sh:31:    if [[ ! -f "$file_path" ]]; then
.claude/hooks/risk-predictor.sh:32:        echo '{"complexity":0,"risk":"low"}'
.claude/hooks/risk-predictor.sh:33:        return
.claude/hooks/risk-predictor.sh:34:    fi
.claude/hooks/risk-predictor.sh:35:
.claude/hooks/risk-predictor.sh:36:    local lines
.claude/hooks/risk-predictor.sh:37:    lines=$(wc -l < "$file_path" 2>/dev/null || echo "0")
.claude/hooks/risk-predictor.sh:38:
.claude/hooks/risk-predictor.sh:39:    local functions
.claude/hooks/risk-predictor.sh:40:    functions=$(grep -c "function\|def \|fn \|func " "$file_path" 2>/dev/null || echo "0")
.claude/hooks/risk-predictor.sh:41:
.claude/hooks/risk-predictor.sh:42:    local nesting
.claude/hooks/risk-predictor.sh:43:    nesting=$(grep -o "{" "$file_path" 2>/dev/null | wc -l | tr -d ' ')
.claude/hooks/risk-predictor.sh:44:
.claude/hooks/risk-predictor.sh:45:    # Calculate complexity score (0-100)
.claude/hooks/risk-predictor.sh:46:    local complexity
.claude/hooks/risk-predictor.sh:47:    complexity=$(( (lines / 10) + (functions * 5) + (nesting / 2) ))
.claude/hooks/risk-predictor.sh:48:    [[ $complexity -gt 100 ]] && complexity=100
.claude/hooks/risk-predictor.sh:49:
.claude/hooks/risk-predictor.sh:50:    local risk="low"
.claude/hooks/risk-predictor.sh:51:    [[ $complexity -gt 30 ]] && risk="medium"
.claude/hooks/risk-predictor.sh:52:    [[ $complexity -gt 60 ]] && risk="high"
.claude/hooks/risk-predictor.sh:53:
.claude/hooks/risk-predictor.sh:54:    echo "{\"complexity\":$complexity,\"lines\":$lines,\"functions\":$functions,\"risk\":\"$risk\"}"
.claude/hooks/risk-predictor.sh:55:}
.claude/hooks/risk-predictor.sh:56:
.claude/hooks/risk-predictor.sh:57:# =============================================================================
.claude/hooks/risk-predictor.sh:58:# HISTORICAL FAILURE ANALYSIS
.claude/hooks/risk-predictor.sh:59:# =============================================================================
.claude/hooks/risk-predictor.sh:60:
.claude/hooks/risk-predictor.sh:61:check_historical_failures() {
.claude/hooks/risk-predictor.sh:62:    local operation_type="$1"
.claude/hooks/risk-predictor.sh:63:    local context="${2:-}"
.claude/hooks/risk-predictor.sh:64:
.claude/hooks/risk-predictor.sh:65:    # Query learning engine for historical failures
.claude/hooks/risk-predictor.sh:66:    if [[ -x "$LEARNING_ENGINE" ]]; then
.claude/hooks/risk-predictor.sh:67:        "$LEARNING_ENGINE" predict-risk "$operation_type" "$context" 2>/dev/null
.claude/hooks/risk-predictor.sh:68:    else
.claude/hooks/risk-predictor.sh:69:        echo '{"riskScore":10,"riskLevel":"low"}'
.claude/hooks/risk-predictor.sh:70:    fi
.claude/hooks/risk-predictor.sh:71:}
.claude/hooks/risk-predictor.sh:72:
.claude/hooks/risk-predictor.sh:73:# =============================================================================
.claude/hooks/risk-predictor.sh:74:# DEPENDENCY RISK ANALYSIS
.claude/hooks/risk-predictor.sh:75:# =============================================================================
.claude/hooks/risk-predictor.sh:76:
.claude/hooks/risk-predictor.sh:77:analyze_dependency_risk() {
.claude/hooks/risk-predictor.sh:78:    local project_dir="${1:-.}"
.claude/hooks/risk-predictor.sh:79:
.claude/hooks/risk-predictor.sh:80:    local risk_score=0
.claude/hooks/risk-predictor.sh:81:
.claude/hooks/risk-predictor.sh:82:    # Check for package.json
.claude/hooks/risk-predictor.sh:83:    if [[ -f "$project_dir/package.json" ]]; then
.claude/hooks/risk-predictor.sh:84:        local dep_count
.claude/hooks/risk-predictor.sh:85:        dep_count=$(jq -r '.dependencies // {} | length' "$project_dir/package.json" 2>/dev/null || echo "0")
.claude/hooks/risk-predictor.sh:86:        risk_score=$((risk_score + dep_count / 5))
.claude/hooks/risk-predictor.sh:87:    fi
.claude/hooks/risk-predictor.sh:88:
.claude/hooks/risk-predictor.sh:89:    # Check for requirements.txt
.claude/hooks/risk-predictor.sh:90:    if [[ -f "$project_dir/requirements.txt" ]]; then
.claude/hooks/risk-predictor.sh:91:        local req_count
.claude/hooks/risk-predictor.sh:92:        req_count=$(wc -l < "$project_dir/requirements.txt" 2>/dev/null || echo "0")
.claude/hooks/risk-predictor.sh:93:        risk_score=$((risk_score + req_count / 3))
.claude/hooks/risk-predictor.sh:94:    fi
.claude/hooks/risk-predictor.sh:95:
.claude/hooks/risk-predictor.sh:96:    # Check for go.mod
.claude/hooks/risk-predictor.sh:97:    if [[ -f "$project_dir/go.mod" ]]; then
.claude/hooks/risk-predictor.sh:98:        local mod_count
.claude/hooks/risk-predictor.sh:99:        mod_count=$(grep "require" "$project_dir/go.mod" 2>/dev/null | wc -l | tr -d ' ')
.claude/hooks/risk-predictor.sh:100:        risk_score=$((risk_score + mod_count / 4))
.claude/hooks/risk-predictor.sh:101:    fi
.claude/hooks/risk-predictor.sh:102:
.claude/hooks/risk-predictor.sh:103:    [[ $risk_score -gt 100 ]] && risk_score=100
.claude/hooks/risk-predictor.sh:104:
.claude/hooks/risk-predictor.sh:105:    local risk_level="low"
.claude/hooks/risk-predictor.sh:106:    [[ $risk_score -gt 30 ]] && risk_level="medium"
.claude/hooks/risk-predictor.sh:107:    [[ $risk_score -gt 60 ]] && risk_level="high"
.claude/hooks/risk-predictor.sh:108:
.claude/hooks/risk-predictor.sh:109:    echo "{\"dependencyRisk\":$risk_score,\"riskLevel\":\"$risk_level\"}"
.claude/hooks/risk-predictor.sh:110:}
.claude/hooks/risk-predictor.sh:111:
.claude/hooks/risk-predictor.sh:112:# =============================================================================
.claude/hooks/risk-predictor.sh:113:# COMPREHENSIVE RISK ASSESSMENT
.claude/hooks/risk-predictor.sh:114:# =============================================================================
.claude/hooks/risk-predictor.sh:115:
.claude/hooks/risk-predictor.sh:116:assess_risk() {
.claude/hooks/risk-predictor.sh:117:    local operation="$1"
.claude/hooks/risk-predictor.sh:118:    local task_type="${2:-general}"
.claude/hooks/risk-predictor.sh:119:    local file_path="${3:-}"
.claude/hooks/risk-predictor.sh:120:    local context="${4:-}"
.claude/hooks/risk-predictor.sh:121:
.claude/hooks/risk-predictor.sh:122:    init_risk
.claude/hooks/risk-predictor.sh:123:
.claude/hooks/risk-predictor.sh:124:    # Component risks
.claude/hooks/risk-predictor.sh:125:    local code_risk='{"complexity":0,"risk":"low"}'
.claude/hooks/risk-predictor.sh:126:    [[ -n "$file_path" && -f "$file_path" ]] && code_risk=$(analyze_code_complexity "$file_path")
.claude/hooks/risk-predictor.sh:127:
.claude/hooks/risk-predictor.sh:128:    local historical_risk
.claude/hooks/risk-predictor.sh:129:    historical_risk=$(check_historical_failures "$task_type" "$context")
.claude/hooks/risk-predictor.sh:130:
.claude/hooks/risk-predictor.sh:131:    local dep_risk
.claude/hooks/risk-predictor.sh:132:    dep_risk=$(analyze_dependency_risk ".")
.claude/hooks/risk-predictor.sh:133:
.claude/hooks/risk-predictor.sh:134:    # Combine risks (weighted average)
.claude/hooks/risk-predictor.sh:135:    local code_score
.claude/hooks/risk-predictor.sh:136:    code_score=$(echo "$code_risk" | jq -r '.complexity')
.claude/hooks/risk-predictor.sh:137:    local hist_score
.claude/hooks/risk-predictor.sh:138:    hist_score=$(echo "$historical_risk" | jq -r '.riskScore')
.claude/hooks/risk-predictor.sh:139:    local dep_score
.claude/hooks/risk-predictor.sh:140:    dep_score=$(echo "$dep_risk" | jq -r '.dependencyRisk')
.claude/hooks/risk-predictor.sh:141:
.claude/hooks/risk-predictor.sh:142:    local total_risk
.claude/hooks/risk-predictor.sh:143:    total_risk=$(( (code_score * 30 + hist_score * 50 + dep_score * 20) / 100 ))
.claude/hooks/risk-predictor.sh:144:
.claude/hooks/risk-predictor.sh:145:    local risk_level="low"
.claude/hooks/risk-predictor.sh:146:    [[ $total_risk -gt 30 ]] && risk_level="medium"
.claude/hooks/risk-predictor.sh:147:    [[ $total_risk -gt 60 ]] && risk_level="high"
.claude/hooks/risk-predictor.sh:148:
.claude/hooks/risk-predictor.sh:149:    # Generate recommendations
.claude/hooks/risk-predictor.sh:150:    local recommendations=()
.claude/hooks/risk-predictor.sh:151:    [[ $code_score -gt 60 ]] && recommendations+=("High code complexity - consider refactoring")
.claude/hooks/risk-predictor.sh:152:    [[ $hist_score -gt 50 ]] && recommendations+=("High historical failure rate - review past errors")
.claude/hooks/risk-predictor.sh:153:    [[ $dep_score -gt 50 ]] && recommendations+=("Many dependencies - verify compatibility")
.claude/hooks/risk-predictor.sh:154:
.claude/hooks/risk-predictor.sh:155:    local recs_json="[]"
.claude/hooks/risk-predictor.sh:156:    if [[ ${#recommendations[@]} -gt 0 ]]; then
.claude/hooks/risk-predictor.sh:157:        recs_json=$(printf '%s\n' "${recommendations[@]}" | jq -R . | jq -s .)
.claude/hooks/risk-predictor.sh:158:    fi
.claude/hooks/risk-predictor.sh:159:
.claude/hooks/risk-predictor.sh:160:    jq -n \
.claude/hooks/risk-predictor.sh:161:        --arg op "$operation" \
.claude/hooks/risk-predictor.sh:162:        --arg type "$task_type" \
.claude/hooks/risk-predictor.sh:163:        --argjson total "$total_risk" \
.claude/hooks/risk-predictor.sh:164:        --arg level "$risk_level" \
.claude/hooks/risk-predictor.sh:165:        --argjson code "$code_risk" \
.claude/hooks/risk-predictor.sh:166:        --argjson hist "$historical_risk" \
.claude/hooks/risk-predictor.sh:167:        --argjson dep "$dep_risk" \
.claude/hooks/risk-predictor.sh:168:        --argjson recs "$recs_json" \
.claude/hooks/risk-predictor.sh:169:        '{
.claude/hooks/risk-predictor.sh:170:            operation: $op,
.claude/hooks/risk-predictor.sh:171:            taskType: $type,
.claude/hooks/risk-predictor.sh:172:            totalRisk: $total,
.claude/hooks/risk-predictor.sh:173:            riskLevel: $level,
.claude/hooks/risk-predictor.sh:174:            components: {
.claude/hooks/risk-predictor.sh:175:                codeComplexity: $code,
.claude/hooks/risk-predictor.sh:176:                historicalFailures: $hist,
.claude/hooks/risk-predictor.sh:177:                dependencies: $dep
.claude/hooks/risk-predictor.sh:178:            },
.claude/hooks/risk-predictor.sh:179:            recommendations: $recs
.claude/hooks/risk-predictor.sh:180:        }'
.claude/hooks/risk-predictor.sh:181:
.claude/hooks/risk-predictor.sh:182:    log "Risk assessment for $operation: $risk_level ($total_risk/100)"
.claude/hooks/risk-predictor.sh:183:}
.claude/hooks/risk-predictor.sh:184:
.claude/hooks/risk-predictor.sh:185:# =============================================================================
.claude/hooks/risk-predictor.sh:186:# COMMAND INTERFACE
.claude/hooks/risk-predictor.sh:187:# =============================================================================
.claude/hooks/risk-predictor.sh:188:
.claude/hooks/risk-predictor.sh:189:case "${1:-help}" in
.claude/hooks/risk-predictor.sh:190:    assess)
.claude/hooks/risk-predictor.sh:191:        assess_risk "${2:-operation}" "${3:-general}" "${4:-}" "${5:-}"
.claude/hooks/risk-predictor.sh:192:        ;;
.claude/hooks/risk-predictor.sh:193:    code-complexity)
.claude/hooks/risk-predictor.sh:194:        analyze_code_complexity "${2:-.}"
.claude/hooks/risk-predictor.sh:195:        ;;
.claude/hooks/risk-predictor.sh:196:    historical)
.claude/hooks/risk-predictor.sh:197:        check_historical_failures "${2:-general}" "${3:-}"
.claude/hooks/risk-predictor.sh:198:        ;;
.claude/hooks/risk-predictor.sh:199:    dependencies)
.claude/hooks/risk-predictor.sh:200:        analyze_dependency_risk "${2:-.}"
.claude/hooks/risk-predictor.sh:201:        ;;
.claude/hooks/risk-predictor.sh:202:    help|*)
.claude/hooks/risk-predictor.sh:203:        echo "Risk Predictor - Pre-execution Risk Assessment"
.claude/hooks/risk-predictor.sh:204:        echo ""
.claude/hooks/risk-predictor.sh:205:        echo "Usage: $0 <command> [args]"
.claude/hooks/risk-predictor.sh:206:        echo ""
.claude/hooks/risk-predictor.sh:207:        echo "Commands:"
.claude/hooks/risk-predictor.sh:208:        echo "  assess <op> <type> [file] [ctx] - Comprehensive risk assessment"
.claude/hooks/risk-predictor.sh:209:        echo "  code-complexity <file>          - Analyze code complexity"
.claude/hooks/risk-predictor.sh:210:        echo "  historical <type> [ctx]         - Check historical failures"
.claude/hooks/risk-predictor.sh:211:        echo "  dependencies [dir]              - Analyze dependency risk"
.claude/hooks/risk-predictor.sh:212:        echo ""
.claude/hooks/risk-predictor.sh:213:        echo "Examples:"
.claude/hooks/risk-predictor.sh:214:        echo "  $0 assess build_auth feature src/auth.ts"
.claude/hooks/risk-predictor.sh:215:        echo "  $0 code-complexity src/complex.ts"
.claude/hooks/risk-predictor.sh:216:        echo "  $0 historical bugfix"
.claude/hooks/risk-predictor.sh:217:        ;;
.claude/hooks/risk-predictor.sh:218:esac
.claude/hooks/hypothesis-tester.sh:1:#!/bin/bash
.claude/hooks/hypothesis-tester.sh:2:# Hypothesis Tester - Test hypotheses before implementation
.claude/hooks/hypothesis-tester.sh:3:
.claude/hooks/hypothesis-tester.sh:4:set -uo pipefail
.claude/hooks/hypothesis-tester.sh:5:
.claude/hooks/hypothesis-tester.sh:6:HYPOTHESIS_DIR="${HOME}/.claude/hypotheses"
.claude/hooks/hypothesis-tester.sh:7:ACTIVE_HYPOTHESES="$HYPOTHESIS_DIR/active.json"
.claude/hooks/hypothesis-tester.sh:8:RESULTS="$HYPOTHESIS_DIR/results.jsonl"
.claude/hooks/hypothesis-tester.sh:9:LOG_FILE="${HOME}/.claude/hypothesis-tester.log"
.claude/hooks/hypothesis-tester.sh:10:
.claude/hooks/hypothesis-tester.sh:11:log() {
.claude/hooks/hypothesis-tester.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/hypothesis-tester.sh:13:}
.claude/hooks/hypothesis-tester.sh:14:
.claude/hooks/hypothesis-tester.sh:15:init_hypothesis() {
.claude/hooks/hypothesis-tester.sh:16:    mkdir -p "$HYPOTHESIS_DIR"
.claude/hooks/hypothesis-tester.sh:17:    [[ -f "$ACTIVE_HYPOTHESES" ]] || echo '{"hypotheses":[]}' > "$ACTIVE_HYPOTHESES"
.claude/hooks/hypothesis-tester.sh:18:    [[ -f "$RESULTS" ]] || touch "$RESULTS"
.claude/hooks/hypothesis-tester.sh:19:}
.claude/hooks/hypothesis-tester.sh:20:
.claude/hooks/hypothesis-tester.sh:21:# State a hypothesis
.claude/hooks/hypothesis-tester.sh:22:state_hypothesis() {
.claude/hooks/hypothesis-tester.sh:23:    local hypothesis="$1"
.claude/hooks/hypothesis-tester.sh:24:    local expected_outcome="$2"
.claude/hooks/hypothesis-tester.sh:25:    local task="${3:-}"
.claude/hooks/hypothesis-tester.sh:26:
.claude/hooks/hypothesis-tester.sh:27:    init_hypothesis
.claude/hooks/hypothesis-tester.sh:28:
.claude/hooks/hypothesis-tester.sh:29:    local hypothesis_id
.claude/hooks/hypothesis-tester.sh:30:    hypothesis_id="hyp_$(date +%s)"
.claude/hooks/hypothesis-tester.sh:31:    local timestamp
.claude/hooks/hypothesis-tester.sh:32:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/hypothesis-tester.sh:33:
.claude/hooks/hypothesis-tester.sh:34:    local temp_file
.claude/hooks/hypothesis-tester.sh:35:    temp_file=$(mktemp)
.claude/hooks/hypothesis-tester.sh:36:
.claude/hooks/hypothesis-tester.sh:37:    jq --arg id "$hypothesis_id" \
.claude/hooks/hypothesis-tester.sh:38:       --arg hyp "$hypothesis" \
.claude/hooks/hypothesis-tester.sh:39:       --arg expected "$expected_outcome" \
.claude/hooks/hypothesis-tester.sh:40:       --arg task "$task" \
.claude/hooks/hypothesis-tester.sh:41:       --arg ts "$timestamp" \
.claude/hooks/hypothesis-tester.sh:42:       '.hypotheses += [{
.claude/hooks/hypothesis-tester.sh:43:           id: $id,
.claude/hooks/hypothesis-tester.sh:44:           hypothesis: $hyp,
.claude/hooks/hypothesis-tester.sh:45:           expectedOutcome: $expected,
.claude/hooks/hypothesis-tester.sh:46:           task: $task,
.claude/hooks/hypothesis-tester.sh:47:           status: "pending",
.claude/hooks/hypothesis-tester.sh:48:           createdAt: $ts
.claude/hooks/hypothesis-tester.sh:49:       }]' "$ACTIVE_HYPOTHESES" > "$temp_file"
.claude/hooks/hypothesis-tester.sh:50:
.claude/hooks/hypothesis-tester.sh:51:    mv "$temp_file" "$ACTIVE_HYPOTHESES"
.claude/hooks/hypothesis-tester.sh:52:
.claude/hooks/hypothesis-tester.sh:53:    log "Stated hypothesis: $hypothesis_id"
.claude/hooks/hypothesis-tester.sh:54:    echo "{\"id\":\"$hypothesis_id\",\"hypothesis\":\"$hypothesis\"}"
.claude/hooks/hypothesis-tester.sh:55:}
.claude/hooks/hypothesis-tester.sh:56:
.claude/hooks/hypothesis-tester.sh:57:# Verify hypothesis against actual outcome
.claude/hooks/hypothesis-tester.sh:58:verify_hypothesis() {
.claude/hooks/hypothesis-tester.sh:59:    local hypothesis_id="$1"
.claude/hooks/hypothesis-tester.sh:60:    local actual_outcome="$2"
.claude/hooks/hypothesis-tester.sh:61:    local details="${3:-}"
.claude/hooks/hypothesis-tester.sh:62:
.claude/hooks/hypothesis-tester.sh:63:    init_hypothesis
.claude/hooks/hypothesis-tester.sh:64:
.claude/hooks/hypothesis-tester.sh:65:    local hypothesis
.claude/hooks/hypothesis-tester.sh:66:    hypothesis=$(jq -r --arg id "$hypothesis_id" '.hypotheses[] | select(.id == $id)' "$ACTIVE_HYPOTHESES")
.claude/hooks/hypothesis-tester.sh:67:
.claude/hooks/hypothesis-tester.sh:68:    if [[ -z "$hypothesis" || "$hypothesis" == "null" ]]; then
.claude/hooks/hypothesis-tester.sh:69:        echo "{\"error\":\"Hypothesis not found\"}"
.claude/hooks/hypothesis-tester.sh:70:        return 1
.claude/hooks/hypothesis-tester.sh:71:    fi
.claude/hooks/hypothesis-tester.sh:72:
.claude/hooks/hypothesis-tester.sh:73:    local expected
.claude/hooks/hypothesis-tester.sh:74:    expected=$(echo "$hypothesis" | jq -r '.expectedOutcome')
.claude/hooks/hypothesis-tester.sh:75:
.claude/hooks/hypothesis-tester.sh:76:    local result
.claude/hooks/hypothesis-tester.sh:77:    if [[ "$expected" == "$actual_outcome" ]]; then
.claude/hooks/hypothesis-tester.sh:78:        result="correct"
.claude/hooks/hypothesis-tester.sh:79:    else
.claude/hooks/hypothesis-tester.sh:80:        result="incorrect"
.claude/hooks/hypothesis-tester.sh:81:    fi
.claude/hooks/hypothesis-tester.sh:82:
.claude/hooks/hypothesis-tester.sh:83:    # Record result
.claude/hooks/hypothesis-tester.sh:84:    local timestamp
.claude/hooks/hypothesis-tester.sh:85:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/hypothesis-tester.sh:86:    local record
.claude/hooks/hypothesis-tester.sh:87:    record=$(echo "$hypothesis" | jq --arg result "$result" \
.claude/hooks/hypothesis-tester.sh:88:        --arg actual "$actual_outcome" \
.claude/hooks/hypothesis-tester.sh:89:        --arg details "$details" \
.claude/hooks/hypothesis-tester.sh:90:        --arg ts "$timestamp" \
.claude/hooks/hypothesis-tester.sh:91:        '. + {result: $result, actualOutcome: $actual, details: $details, verifiedAt: $ts}')
.claude/hooks/hypothesis-tester.sh:92:
.claude/hooks/hypothesis-tester.sh:93:    echo "$record" >> "$RESULTS"
.claude/hooks/hypothesis-tester.sh:94:
.claude/hooks/hypothesis-tester.sh:95:    # Remove from active
.claude/hooks/hypothesis-tester.sh:96:    local temp_file
.claude/hooks/hypothesis-tester.sh:97:    temp_file=$(mktemp)
.claude/hooks/hypothesis-tester.sh:98:    jq --arg id "$hypothesis_id" '.hypotheses = [.hypotheses[] | select(.id != $id)]' \
.claude/hooks/hypothesis-tester.sh:99:        "$ACTIVE_HYPOTHESES" > "$temp_file"
.claude/hooks/hypothesis-tester.sh:100:    mv "$temp_file" "$ACTIVE_HYPOTHESES"
.claude/hooks/hypothesis-tester.sh:101:
.claude/hooks/hypothesis-tester.sh:102:    log "Verified hypothesis $hypothesis_id: $result"
.claude/hooks/hypothesis-tester.sh:103:    echo "$record"
.claude/hooks/hypothesis-tester.sh:104:}
.claude/hooks/hypothesis-tester.sh:105:
.claude/hooks/hypothesis-tester.sh:106:# Get accuracy of hypotheses
.claude/hooks/hypothesis-tester.sh:107:get_accuracy() {
.claude/hooks/hypothesis-tester.sh:108:    init_hypothesis
.claude/hooks/hypothesis-tester.sh:109:
.claude/hooks/hypothesis-tester.sh:110:    local total
.claude/hooks/hypothesis-tester.sh:111:    total=$(wc -l < "$RESULTS" 2>/dev/null || echo "0")
.claude/hooks/hypothesis-tester.sh:112:    [[ $total -eq 0 ]] && echo '{"accuracy":0,"total":0}' && return
.claude/hooks/hypothesis-tester.sh:113:
.claude/hooks/hypothesis-tester.sh:114:    local correct
.claude/hooks/hypothesis-tester.sh:115:    correct=$(grep '"result":"correct"' "$RESULTS" 2>/dev/null | wc -l | tr -d ' ')
.claude/hooks/hypothesis-tester.sh:116:
.claude/hooks/hypothesis-tester.sh:117:    local accuracy
.claude/hooks/hypothesis-tester.sh:118:    accuracy=$((correct * 100 / total))
.claude/hooks/hypothesis-tester.sh:119:
.claude/hooks/hypothesis-tester.sh:120:    echo "{\"accuracy\":$accuracy,\"correct\":$correct,\"total\":$total}"
.claude/hooks/hypothesis-tester.sh:121:}
.claude/hooks/hypothesis-tester.sh:122:
.claude/hooks/hypothesis-tester.sh:123:case "${1:-help}" in
.claude/hooks/hypothesis-tester.sh:124:    state) state_hypothesis "${2:-hypothesis}" "${3:-outcome}" "${4:-}" ;;
.claude/hooks/hypothesis-tester.sh:125:    verify) verify_hypothesis "${2:-hyp_id}" "${3:-outcome}" "${4:-}" ;;
.claude/hooks/hypothesis-tester.sh:126:    accuracy) get_accuracy ;;
.claude/hooks/hypothesis-tester.sh:127:    *) echo "Usage: $0 {state|verify|accuracy} [args]" ;;
.claude/hooks/hypothesis-tester.sh:128:esac
.claude/hooks/learning-engine.sh:1:#!/bin/bash
.claude/hooks/learning-engine.sh:2:# Learning Engine - Continuous learning from patterns and outcomes
.claude/hooks/learning-engine.sh:3:# Implements: Reinforcement learning, pattern aggregation, predictive modeling
.claude/hooks/learning-engine.sh:4:# Based on patterns from: agent-loop, memory-manager, error-handler
.claude/hooks/learning-engine.sh:5:
.claude/hooks/learning-engine.sh:6:set -uo pipefail
.claude/hooks/learning-engine.sh:7:
.claude/hooks/learning-engine.sh:8:LEARNING_DIR="${HOME}/.claude/learning"
.claude/hooks/learning-engine.sh:9:MODELS_FILE="$LEARNING_DIR/models.json"
.claude/hooks/learning-engine.sh:10:STATISTICS_FILE="$LEARNING_DIR/statistics.json"
.claude/hooks/learning-engine.sh:11:PREDICTIONS_FILE="$LEARNING_DIR/predictions.json"
.claude/hooks/learning-engine.sh:12:LOG_FILE="${HOME}/.claude/learning-engine.log"
.claude/hooks/learning-engine.sh:13:
.claude/hooks/learning-engine.sh:14:# Memory integration
.claude/hooks/learning-engine.sh:15:MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/learning-engine.sh:16:
.claude/hooks/learning-engine.sh:17:log() {
.claude/hooks/learning-engine.sh:18:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/learning-engine.sh:19:}
.claude/hooks/learning-engine.sh:20:
.claude/hooks/learning-engine.sh:21:init_learning() {
.claude/hooks/learning-engine.sh:22:    mkdir -p "$LEARNING_DIR"
.claude/hooks/learning-engine.sh:23:
.claude/hooks/learning-engine.sh:24:    if [[ ! -f "$MODELS_FILE" ]]; then
.claude/hooks/learning-engine.sh:25:        cat > "$MODELS_FILE" << 'EOF'
.claude/hooks/learning-engine.sh:26:{
.claude/hooks/learning-engine.sh:27:    "strategies": {},
.claude/hooks/learning-engine.sh:28:    "errorPatterns": {},
.claude/hooks/learning-engine.sh:29:    "successPatterns": {},
.claude/hooks/learning-engine.sh:30:    "taskTypes": {},
.claude/hooks/learning-engine.sh:31:    "version": "1.0"
.claude/hooks/learning-engine.sh:32:}
.claude/hooks/learning-engine.sh:33:EOF
.claude/hooks/learning-engine.sh:34:    fi
.claude/hooks/learning-engine.sh:35:
.claude/hooks/learning-engine.sh:36:    if [[ ! -f "$STATISTICS_FILE" ]]; then
.claude/hooks/learning-engine.sh:37:        cat > "$STATISTICS_FILE" << 'EOF'
.claude/hooks/learning-engine.sh:38:{
.claude/hooks/learning-engine.sh:39:    "totalTasks": 0,
.claude/hooks/learning-engine.sh:40:    "successfulTasks": 0,
.claude/hooks/learning-engine.sh:41:    "failedTasks": 0,
.claude/hooks/learning-engine.sh:42:    "strategiesUsed": {},
.claude/hooks/learning-engine.sh:43:    "errorTypes": {},
.claude/hooks/learning-engine.sh:44:    "averageTime": {},
.claude/hooks/learning-engine.sh:45:    "lastUpdated": null
.claude/hooks/learning-engine.sh:46:}
.claude/hooks/learning-engine.sh:47:EOF
.claude/hooks/learning-engine.sh:48:    fi
.claude/hooks/learning-engine.sh:49:
.claude/hooks/learning-engine.sh:50:    if [[ ! -f "$PREDICTIONS_FILE" ]]; then
.claude/hooks/learning-engine.sh:51:        echo '{"predictions":[]}' > "$PREDICTIONS_FILE"
.claude/hooks/learning-engine.sh:52:    fi
.claude/hooks/learning-engine.sh:53:
.claude/hooks/learning-engine.sh:54:    log "Learning engine initialized"
.claude/hooks/learning-engine.sh:55:}
.claude/hooks/learning-engine.sh:56:
.claude/hooks/learning-engine.sh:57:# =============================================================================
.claude/hooks/learning-engine.sh:58:# PATTERN LEARNING (from memory and execution history)
.claude/hooks/learning-engine.sh:59:# =============================================================================
.claude/hooks/learning-engine.sh:60:
.claude/hooks/learning-engine.sh:61:# Learn from successful execution
.claude/hooks/learning-engine.sh:62:learn_success() {
.claude/hooks/learning-engine.sh:63:    local task_type="$1"
.claude/hooks/learning-engine.sh:64:    local strategy="$2"
.claude/hooks/learning-engine.sh:65:    local duration="${3:-0}"
.claude/hooks/learning-engine.sh:66:    local context="${4:-}"
.claude/hooks/learning-engine.sh:67:
.claude/hooks/learning-engine.sh:68:    init_learning
.claude/hooks/learning-engine.sh:69:
.claude/hooks/learning-engine.sh:70:    local temp_file
.claude/hooks/learning-engine.sh:71:    temp_file=$(mktemp)
.claude/hooks/learning-engine.sh:72:
.claude/hooks/learning-engine.sh:73:    local timestamp
.claude/hooks/learning-engine.sh:74:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/learning-engine.sh:75:
.claude/hooks/learning-engine.sh:76:    # Update success patterns
.claude/hooks/learning-engine.sh:77:    jq --arg type "$task_type" \
.claude/hooks/learning-engine.sh:78:       --arg strategy "$strategy" \
.claude/hooks/learning-engine.sh:79:       --argjson duration "$duration" \
.claude/hooks/learning-engine.sh:80:       --arg ts "$timestamp" \
.claude/hooks/learning-engine.sh:81:       --arg ctx "$context" \
.claude/hooks/learning-engine.sh:82:       '
.claude/hooks/learning-engine.sh:83:       .successPatterns[$type] = (.successPatterns[$type] // {
.claude/hooks/learning-engine.sh:84:           "count": 0,
.claude/hooks/learning-engine.sh:85:           "strategies": {},
.claude/hooks/learning-engine.sh:86:           "avgDuration": 0,
.claude/hooks/learning-engine.sh:87:           "totalDuration": 0
.claude/hooks/learning-engine.sh:88:       }) |
.claude/hooks/learning-engine.sh:89:       .successPatterns[$type].count += 1 |
.claude/hooks/learning-engine.sh:90:       .successPatterns[$type].strategies[$strategy] = (
.claude/hooks/learning-engine.sh:91:           (.successPatterns[$type].strategies[$strategy] // 0) + 1
.claude/hooks/learning-engine.sh:92:       ) |
.claude/hooks/learning-engine.sh:93:       .successPatterns[$type].totalDuration += $duration |
.claude/hooks/learning-engine.sh:94:       .successPatterns[$type].avgDuration = (
.claude/hooks/learning-engine.sh:95:           .successPatterns[$type].totalDuration / .successPatterns[$type].count
.claude/hooks/learning-engine.sh:96:       ) |
.claude/hooks/learning-engine.sh:97:       .successPatterns[$type].lastSuccess = $ts
.claude/hooks/learning-engine.sh:98:       ' "$MODELS_FILE" > "$temp_file"
.claude/hooks/learning-engine.sh:99:
.claude/hooks/learning-engine.sh:100:    mv "$temp_file" "$MODELS_FILE"
.claude/hooks/learning-engine.sh:101:
.claude/hooks/learning-engine.sh:102:    # Update statistics
.claude/hooks/learning-engine.sh:103:    update_statistics "success" "$task_type" "$strategy" "$duration"
.claude/hooks/learning-engine.sh:104:
.claude/hooks/learning-engine.sh:105:    log "Learned success: $task_type using $strategy (${duration}ms)"
.claude/hooks/learning-engine.sh:106:}
.claude/hooks/learning-engine.sh:107:
.claude/hooks/learning-engine.sh:108:# Learn from failure
.claude/hooks/learning-engine.sh:109:learn_failure() {
.claude/hooks/learning-engine.sh:110:    local task_type="$1"
.claude/hooks/learning-engine.sh:111:    local strategy="$2"
.claude/hooks/learning-engine.sh:112:    local error_class="$3"
.claude/hooks/learning-engine.sh:113:    local error_msg="${4:-}"
.claude/hooks/learning-engine.sh:114:
.claude/hooks/learning-engine.sh:115:    init_learning
.claude/hooks/learning-engine.sh:116:
.claude/hooks/learning-engine.sh:117:    local temp_file
.claude/hooks/learning-engine.sh:118:    temp_file=$(mktemp)
.claude/hooks/learning-engine.sh:119:
.claude/hooks/learning-engine.sh:120:    local timestamp
.claude/hooks/learning-engine.sh:121:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/learning-engine.sh:122:
.claude/hooks/learning-engine.sh:123:    # Update error patterns
.claude/hooks/learning-engine.sh:124:    jq --arg type "$task_type" \
.claude/hooks/learning-engine.sh:125:       --arg strategy "$strategy" \
.claude/hooks/learning-engine.sh:126:       --arg errorClass "$error_class" \
.claude/hooks/learning-engine.sh:127:       --arg errorMsg "$error_msg" \
.claude/hooks/learning-engine.sh:128:       --arg ts "$timestamp" \
.claude/hooks/learning-engine.sh:129:       '
.claude/hooks/learning-engine.sh:130:       .errorPatterns[$type] = (.errorPatterns[$type] // {
.claude/hooks/learning-engine.sh:131:           "count": 0,
.claude/hooks/learning-engine.sh:132:           "errors": {},
.claude/hooks/learning-engine.sh:133:           "failedStrategies": {}
.claude/hooks/learning-engine.sh:134:       }) |
.claude/hooks/learning-engine.sh:135:       .errorPatterns[$type].count += 1 |
.claude/hooks/learning-engine.sh:136:       .errorPatterns[$type].errors[$errorClass] = (
.claude/hooks/learning-engine.sh:137:           (.errorPatterns[$type].errors[$errorClass] // 0) + 1
.claude/hooks/learning-engine.sh:138:       ) |
.claude/hooks/learning-engine.sh:139:       .errorPatterns[$type].failedStrategies[$strategy] = (
.claude/hooks/learning-engine.sh:140:           (.errorPatterns[$type].failedStrategies[$strategy] // 0) + 1
.claude/hooks/learning-engine.sh:141:       ) |
.claude/hooks/learning-engine.sh:142:       .errorPatterns[$type].lastError = {
.claude/hooks/learning-engine.sh:143:           "class": $errorClass,
.claude/hooks/learning-engine.sh:144:           "message": $errorMsg,
.claude/hooks/learning-engine.sh:145:           "timestamp": $ts
.claude/hooks/learning-engine.sh:146:       }
.claude/hooks/learning-engine.sh:147:       ' "$MODELS_FILE" > "$temp_file"
.claude/hooks/learning-engine.sh:148:
.claude/hooks/learning-engine.sh:149:    mv "$temp_file" "$MODELS_FILE"
.claude/hooks/learning-engine.sh:150:
.claude/hooks/learning-engine.sh:151:    # Update statistics
.claude/hooks/learning-engine.sh:152:    update_statistics "failure" "$task_type" "$strategy" "0"
.claude/hooks/learning-engine.sh:153:
.claude/hooks/learning-engine.sh:154:    log "Learned failure: $task_type using $strategy (error: $error_class)"
.claude/hooks/learning-engine.sh:155:}
.claude/hooks/learning-engine.sh:156:
.claude/hooks/learning-engine.sh:157:# Update overall statistics
.claude/hooks/learning-engine.sh:158:update_statistics() {
.claude/hooks/learning-engine.sh:159:    local outcome="$1"  # success or failure
.claude/hooks/learning-engine.sh:160:    local task_type="$2"
.claude/hooks/learning-engine.sh:161:    local strategy="$3"
.claude/hooks/learning-engine.sh:162:    local duration="$4"
.claude/hooks/learning-engine.sh:163:
.claude/hooks/learning-engine.sh:164:    local temp_file
.claude/hooks/learning-engine.sh:165:    temp_file=$(mktemp)
.claude/hooks/learning-engine.sh:166:
.claude/hooks/learning-engine.sh:167:    local timestamp
.claude/hooks/learning-engine.sh:168:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/learning-engine.sh:169:
.claude/hooks/learning-engine.sh:170:    jq --arg outcome "$outcome" \
.claude/hooks/learning-engine.sh:171:       --arg type "$task_type" \
.claude/hooks/learning-engine.sh:172:       --arg strategy "$strategy" \
.claude/hooks/learning-engine.sh:173:       --argjson duration "$duration" \
.claude/hooks/learning-engine.sh:174:       --arg ts "$timestamp" \
.claude/hooks/learning-engine.sh:175:       '
.claude/hooks/learning-engine.sh:176:       .totalTasks += 1 |
.claude/hooks/learning-engine.sh:177:       if $outcome == "success" then
.claude/hooks/learning-engine.sh:178:           .successfulTasks += 1
.claude/hooks/learning-engine.sh:179:       else
.claude/hooks/learning-engine.sh:180:           .failedTasks += 1
.claude/hooks/learning-engine.sh:181:       end |
.claude/hooks/learning-engine.sh:182:       .strategiesUsed[$strategy] = ((.strategiesUsed[$strategy] // 0) + 1) |
.claude/hooks/learning-engine.sh:183:       .averageTime[$type] = (
.claude/hooks/learning-engine.sh:184:           if .averageTime[$type] then
.claude/hooks/learning-engine.sh:185:               ((.averageTime[$type].total + $duration) / (.averageTime[$type].count + 1))
.claude/hooks/learning-engine.sh:186:           else
.claude/hooks/learning-engine.sh:187:               $duration
.claude/hooks/learning-engine.sh:188:           end
.claude/hooks/learning-engine.sh:189:       ) |
.claude/hooks/learning-engine.sh:190:       .lastUpdated = $ts
.claude/hooks/learning-engine.sh:191:       ' "$STATISTICS_FILE" > "$temp_file"
.claude/hooks/learning-engine.sh:192:
.claude/hooks/learning-engine.sh:193:    mv "$temp_file" "$STATISTICS_FILE"
.claude/hooks/learning-engine.sh:194:}
.claude/hooks/learning-engine.sh:195:
.claude/hooks/learning-engine.sh:196:# =============================================================================
.claude/hooks/learning-engine.sh:197:# STRATEGY RECOMMENDATION (predictive)
.claude/hooks/learning-engine.sh:198:# =============================================================================
.claude/hooks/learning-engine.sh:199:
.claude/hooks/learning-engine.sh:200:# Recommend best strategy for task type
.claude/hooks/learning-engine.sh:201:recommend_strategy() {
.claude/hooks/learning-engine.sh:202:    local task_type="$1"
.claude/hooks/learning-engine.sh:203:    local context="${2:-}"
.claude/hooks/learning-engine.sh:204:
.claude/hooks/learning-engine.sh:205:    init_learning
.claude/hooks/learning-engine.sh:206:
.claude/hooks/learning-engine.sh:207:    # Get success patterns for this task type
.claude/hooks/learning-engine.sh:208:    local strategies
.claude/hooks/learning-engine.sh:209:    strategies=$(jq -r --arg type "$task_type" '
.claude/hooks/learning-engine.sh:210:        .successPatterns[$type].strategies // {} |
.claude/hooks/learning-engine.sh:211:        to_entries |
.claude/hooks/learning-engine.sh:212:        sort_by(-.value) |
.claude/hooks/learning-engine.sh:213:        map({strategy: .key, count: .value}) |
.claude/hooks/learning-engine.sh:214:        if length > 0 then
.claude/hooks/learning-engine.sh:215:            .[0].strategy
.claude/hooks/learning-engine.sh:216:        else
.claude/hooks/learning-engine.sh:217:            "default"
.claude/hooks/learning-engine.sh:218:        end
.claude/hooks/learning-engine.sh:219:    ' "$MODELS_FILE")
.claude/hooks/learning-engine.sh:220:
.claude/hooks/learning-engine.sh:221:    if [[ "$strategies" == "null" || "$strategies" == "default" ]]; then
.claude/hooks/learning-engine.sh:222:        # No learned patterns, use memory
.claude/hooks/learning-engine.sh:223:        if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/learning-engine.sh:224:            local memories
.claude/hooks/learning-engine.sh:225:            memories=$("$MEMORY_MANAGER" find-patterns "$task_type" 3 2>/dev/null)
.claude/hooks/learning-engine.sh:226:            if [[ -n "$memories" && "$memories" != "[]" ]]; then
.claude/hooks/learning-engine.sh:227:                strategies=$(echo "$memories" | jq -r '.[0].solution // "default"')
.claude/hooks/learning-engine.sh:228:            fi
.claude/hooks/learning-engine.sh:229:        fi
.claude/hooks/learning-engine.sh:230:    fi
.claude/hooks/learning-engine.sh:231:
.claude/hooks/learning-engine.sh:232:    # Calculate confidence
.claude/hooks/learning-engine.sh:233:    local confidence
.claude/hooks/learning-engine.sh:234:    confidence=$(jq -r --arg type "$task_type" '
.claude/hooks/learning-engine.sh:235:        .successPatterns[$type] as $pattern |
.claude/hooks/learning-engine.sh:236:        .totalTasks as $total |
.claude/hooks/learning-engine.sh:237:        if $pattern and $total and $total > 0 then
.claude/hooks/learning-engine.sh:238:            ($pattern.count / $total * 100) | floor
.claude/hooks/learning-engine.sh:239:        else
.claude/hooks/learning-engine.sh:240:            0
.claude/hooks/learning-engine.sh:241:        end
.claude/hooks/learning-engine.sh:242:    ' "$STATISTICS_FILE" 2>/dev/null || echo "0")
.claude/hooks/learning-engine.sh:243:
.claude/hooks/learning-engine.sh:244:    # Ensure confidence is a valid number
.claude/hooks/learning-engine.sh:245:    [[ -z "$confidence" || "$confidence" == "null" ]] && confidence=0
.claude/hooks/learning-engine.sh:246:
.claude/hooks/learning-engine.sh:247:    jq -n --arg strategy "$strategies" --argjson confidence "$confidence" \
.claude/hooks/learning-engine.sh:248:        '{strategy: $strategy, confidence: $confidence}'
.claude/hooks/learning-engine.sh:249:    log "Recommended strategy for $task_type: $strategies (confidence: $confidence%)"
.claude/hooks/learning-engine.sh:250:}
.claude/hooks/learning-engine.sh:251:
.claude/hooks/learning-engine.sh:252:# =============================================================================
.claude/hooks/learning-engine.sh:253:# RISK ASSESSMENT (predictive)
.claude/hooks/learning-engine.sh:254:# =============================================================================
.claude/hooks/learning-engine.sh:255:
.claude/hooks/learning-engine.sh:256:# Predict failure risk for task/strategy combination
.claude/hooks/learning-engine.sh:257:predict_risk() {
.claude/hooks/learning-engine.sh:258:    local task_type="$1"
.claude/hooks/learning-engine.sh:259:    local strategy="$2"
.claude/hooks/learning-engine.sh:260:
.claude/hooks/learning-engine.sh:261:    init_learning
.claude/hooks/learning-engine.sh:262:
.claude/hooks/learning-engine.sh:263:    # Calculate failure rate for this combination
.claude/hooks/learning-engine.sh:264:    local risk_score
.claude/hooks/learning-engine.sh:265:    risk_score=$(jq -r --arg type "$task_type" --arg strategy "$strategy" '
.claude/hooks/learning-engine.sh:266:        .errorPatterns[$type] as $errors |
.claude/hooks/learning-engine.sh:267:        .successPatterns[$type] as $success |
.claude/hooks/learning-engine.sh:268:        if $errors and $success then
.claude/hooks/learning-engine.sh:269:            # Calculate failure rate for this strategy
.claude/hooks/learning-engine.sh:270:            ($errors.failedStrategies[$strategy] // 0) as $failures |
.claude/hooks/learning-engine.sh:271:            ($success.strategies[$strategy] // 0) as $successes |
.claude/hooks/learning-engine.sh:272:            ($failures + $successes) as $total |
.claude/hooks/learning-engine.sh:273:            if $total > 0 then
.claude/hooks/learning-engine.sh:274:                ($failures / $total * 100) | floor
.claude/hooks/learning-engine.sh:275:            else
.claude/hooks/learning-engine.sh:276:                10  # Default low risk for unknown
.claude/hooks/learning-engine.sh:277:            end
.claude/hooks/learning-engine.sh:278:        elif $errors then
.claude/hooks/learning-engine.sh:279:            # Only failures known
.claude/hooks/learning-engine.sh:280:            50
.claude/hooks/learning-engine.sh:281:        else
.claude/hooks/learning-engine.sh:282:            # No data
.claude/hooks/learning-engine.sh:283:            10
.claude/hooks/learning-engine.sh:284:        end
.claude/hooks/learning-engine.sh:285:    ' "$MODELS_FILE")
.claude/hooks/learning-engine.sh:286:
.claude/hooks/learning-engine.sh:287:    # Categorize risk
.claude/hooks/learning-engine.sh:288:    local risk_level
.claude/hooks/learning-engine.sh:289:    if [[ $risk_score -lt 20 ]]; then
.claude/hooks/learning-engine.sh:290:        risk_level="low"
.claude/hooks/learning-engine.sh:291:    elif [[ $risk_score -lt 50 ]]; then
.claude/hooks/learning-engine.sh:292:        risk_level="medium"
.claude/hooks/learning-engine.sh:293:    else
.claude/hooks/learning-engine.sh:294:        risk_level="high"
.claude/hooks/learning-engine.sh:295:    fi
.claude/hooks/learning-engine.sh:296:
.claude/hooks/learning-engine.sh:297:    echo "{\"riskScore\":$risk_score,\"riskLevel\":\"$risk_level\"}"
.claude/hooks/learning-engine.sh:298:    log "Risk prediction for $task_type/$strategy: $risk_level ($risk_score%)"
.claude/hooks/learning-engine.sh:299:}
.claude/hooks/learning-engine.sh:300:
.claude/hooks/learning-engine.sh:301:# =============================================================================
.claude/hooks/learning-engine.sh:302:# PATTERN MINING (from memory)
.claude/hooks/learning-engine.sh:303:# =============================================================================
.claude/hooks/learning-engine.sh:304:
.claude/hooks/learning-engine.sh:305:# Mine memory for successful patterns
.claude/hooks/learning-engine.sh:306:mine_patterns() {
.claude/hooks/learning-engine.sh:307:    local task_query="$1"
.claude/hooks/learning-engine.sh:308:    local limit="${2:-5}"
.claude/hooks/learning-engine.sh:309:
.claude/hooks/learning-engine.sh:310:    if [[ ! -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/learning-engine.sh:311:        echo "[]"
.claude/hooks/learning-engine.sh:312:        return
.claude/hooks/learning-engine.sh:313:    fi
.claude/hooks/learning-engine.sh:314:
.claude/hooks/learning-engine.sh:315:    # Query episodic memory for successful similar tasks
.claude/hooks/learning-engine.sh:316:    local similar_tasks
.claude/hooks/learning-engine.sh:317:    similar_tasks=$("$MEMORY_MANAGER" remember-scored "$task_query" "$limit" 2>/dev/null || echo "[]")
.claude/hooks/learning-engine.sh:318:
.claude/hooks/learning-engine.sh:319:    # Extract patterns from successful tasks
.claude/hooks/learning-engine.sh:320:    local patterns
.claude/hooks/learning-engine.sh:321:    patterns=$(echo "$similar_tasks" | jq -c '
.claude/hooks/learning-engine.sh:322:        [.[] | select(.type == "episode" and .metadata.outcome == "success")] |
.claude/hooks/learning-engine.sh:323:        map({
.claude/hooks/learning-engine.sh:324:            description: .content,
.claude/hooks/learning-engine.sh:325:            approach: .metadata.action_type,
.claude/hooks/learning-engine.sh:326:            context: .metadata.details,
.claude/hooks/learning-engine.sh:327:            timestamp: .timestamp
.claude/hooks/learning-engine.sh:328:        })
.claude/hooks/learning-engine.sh:329:    ')
.claude/hooks/learning-engine.sh:330:
.claude/hooks/learning-engine.sh:331:    log "Mined $(echo "$patterns" | jq 'length') patterns for: $task_query"
.claude/hooks/learning-engine.sh:332:    echo "$patterns"
.claude/hooks/learning-engine.sh:333:}
.claude/hooks/learning-engine.sh:334:
.claude/hooks/learning-engine.sh:335:# =============================================================================
.claude/hooks/learning-engine.sh:336:# QUALITY SCORING (adaptive)
.claude/hooks/learning-engine.sh:337:# =============================================================================
.claude/hooks/learning-engine.sh:338:
.claude/hooks/learning-engine.sh:339:# Calculate quality score for a completed task
.claude/hooks/learning-engine.sh:340:calculate_quality() {
.claude/hooks/learning-engine.sh:341:    local task_type="$1"
.claude/hooks/learning-engine.sh:342:    local duration="$2"
.claude/hooks/learning-engine.sh:343:    local errors_encountered="$3"
.claude/hooks/learning-engine.sh:344:    local retries="$4"
.claude/hooks/learning-engine.sh:345:
.claude/hooks/learning-engine.sh:346:    init_learning
.claude/hooks/learning-engine.sh:347:
.claude/hooks/learning-engine.sh:348:    # Get average duration for this task type
.claude/hooks/learning-engine.sh:349:    local avg_duration
.claude/hooks/learning-engine.sh:350:    avg_duration=$(jq -r --arg type "$task_type" '
.claude/hooks/learning-engine.sh:351:        .averageTime[$type] // 10000
.claude/hooks/learning-engine.sh:352:    ' "$STATISTICS_FILE")
.claude/hooks/learning-engine.sh:353:
.claude/hooks/learning-engine.sh:354:    # Score components (0-100 each)
.claude/hooks/learning-engine.sh:355:    local speed_score
.claude/hooks/learning-engine.sh:356:    if [[ $duration -le $avg_duration ]]; then
.claude/hooks/learning-engine.sh:357:        speed_score=100
.claude/hooks/learning-engine.sh:358:    else
.claude/hooks/learning-engine.sh:359:        speed_score=$(( 100 - (duration - avg_duration) * 100 / avg_duration ))
.claude/hooks/learning-engine.sh:360:        [[ $speed_score -lt 0 ]] && speed_score=0
.claude/hooks/learning-engine.sh:361:    fi
.claude/hooks/learning-engine.sh:362:
.claude/hooks/learning-engine.sh:363:    local error_score
.claude/hooks/learning-engine.sh:364:    error_score=$(( 100 - errors_encountered * 20 ))
.claude/hooks/learning-engine.sh:365:    [[ $error_score -lt 0 ]] && error_score=0
.claude/hooks/learning-engine.sh:366:
.claude/hooks/learning-engine.sh:367:    local retry_score
.claude/hooks/learning-engine.sh:368:    retry_score=$(( 100 - retries * 15 ))
.claude/hooks/learning-engine.sh:369:    [[ $retry_score -lt 0 ]] && retry_score=0
.claude/hooks/learning-engine.sh:370:
.claude/hooks/learning-engine.sh:371:    # Weighted average
.claude/hooks/learning-engine.sh:372:    local quality_score
.claude/hooks/learning-engine.sh:373:    quality_score=$(( (speed_score * 30 + error_score * 40 + retry_score * 30) / 100 ))
.claude/hooks/learning-engine.sh:374:
.claude/hooks/learning-engine.sh:375:    echo "{\"qualityScore\":$quality_score,\"speedScore\":$speed_score,\"errorScore\":$error_score,\"retryScore\":$retry_score}"
.claude/hooks/learning-engine.sh:376:    log "Quality score for $task_type: $quality_score/100"
.claude/hooks/learning-engine.sh:377:}
.claude/hooks/learning-engine.sh:378:
.claude/hooks/learning-engine.sh:379:# =============================================================================
.claude/hooks/learning-engine.sh:380:# LEARNING ANALYTICS
.claude/hooks/learning-engine.sh:381:# =============================================================================
.claude/hooks/learning-engine.sh:382:
.claude/hooks/learning-engine.sh:383:# Get learning statistics
.claude/hooks/learning-engine.sh:384:get_statistics() {
.claude/hooks/learning-engine.sh:385:    init_learning
.claude/hooks/learning-engine.sh:386:
.claude/hooks/learning-engine.sh:387:    local stats
.claude/hooks/learning-engine.sh:388:    stats=$(jq '.' "$STATISTICS_FILE")
.claude/hooks/learning-engine.sh:389:
.claude/hooks/learning-engine.sh:390:    # Add success rate
.claude/hooks/learning-engine.sh:391:    stats=$(echo "$stats" | jq '
.claude/hooks/learning-engine.sh:392:        .successRate = (
.claude/hooks/learning-engine.sh:393:            if .totalTasks > 0 then
.claude/hooks/learning-engine.sh:394:                (.successfulTasks / .totalTasks * 100) | floor
.claude/hooks/learning-engine.sh:395:            else
.claude/hooks/learning-engine.sh:396:                0
.claude/hooks/learning-engine.sh:397:            end
.claude/hooks/learning-engine.sh:398:        )
.claude/hooks/learning-engine.sh:399:    ')
.claude/hooks/learning-engine.sh:400:
.claude/hooks/learning-engine.sh:401:    echo "$stats"
.claude/hooks/learning-engine.sh:402:}
.claude/hooks/learning-engine.sh:403:
.claude/hooks/learning-engine.sh:404:# Get best performing strategies
.claude/hooks/learning-engine.sh:405:get_best_strategies() {
.claude/hooks/learning-engine.sh:406:    local limit="${1:-10}"
.claude/hooks/learning-engine.sh:407:
.claude/hooks/learning-engine.sh:408:    init_learning
.claude/hooks/learning-engine.sh:409:
.claude/hooks/learning-engine.sh:410:    jq -r --argjson limit "$limit" '
.claude/hooks/learning-engine.sh:411:        .successPatterns |
.claude/hooks/learning-engine.sh:412:        to_entries |
.claude/hooks/learning-engine.sh:413:        map({
.claude/hooks/learning-engine.sh:414:            taskType: .key,
.claude/hooks/learning-engine.sh:415:            totalSuccesses: .value.count,
.claude/hooks/learning-engine.sh:416:            avgDuration: .value.avgDuration,
.claude/hooks/learning-engine.sh:417:            topStrategy: (
.claude/hooks/learning-engine.sh:418:                .value.strategies |
.claude/hooks/learning-engine.sh:419:                to_entries |
.claude/hooks/learning-engine.sh:420:                sort_by(-.value) |
.claude/hooks/learning-engine.sh:421:                .[0].key
.claude/hooks/learning-engine.sh:422:            )
.claude/hooks/learning-engine.sh:423:        }) |
.claude/hooks/learning-engine.sh:424:        sort_by(-.totalSuccesses) |
.claude/hooks/learning-engine.sh:425:        .[:$limit]
.claude/hooks/learning-engine.sh:426:    ' "$MODELS_FILE"
.claude/hooks/learning-engine.sh:427:}
.claude/hooks/learning-engine.sh:428:
.claude/hooks/learning-engine.sh:429:# Export learning data for analysis
.claude/hooks/learning-engine.sh:430:export_learning_data() {
.claude/hooks/learning-engine.sh:431:    local output_file="${1:-$LEARNING_DIR/export_$(date +%Y%m%d_%H%M%S).json}"
.claude/hooks/learning-engine.sh:432:
.claude/hooks/learning-engine.sh:433:    init_learning
.claude/hooks/learning-engine.sh:434:
.claude/hooks/learning-engine.sh:435:    jq -n \
.claude/hooks/learning-engine.sh:436:        --slurpfile models "$MODELS_FILE" \
.claude/hooks/learning-engine.sh:437:        --slurpfile stats "$STATISTICS_FILE" \
.claude/hooks/learning-engine.sh:438:        '{
.claude/hooks/learning-engine.sh:439:            models: $models[0],
.claude/hooks/learning-engine.sh:440:            statistics: $stats[0],
.claude/hooks/learning-engine.sh:441:            exportedAt: (now | todate)
.claude/hooks/learning-engine.sh:442:        }' > "$output_file"
.claude/hooks/learning-engine.sh:443:
.claude/hooks/learning-engine.sh:444:    log "Exported learning data to: $output_file"
.claude/hooks/learning-engine.sh:445:    echo "$output_file"
.claude/hooks/learning-engine.sh:446:}
.claude/hooks/learning-engine.sh:447:
.claude/hooks/learning-engine.sh:448:# =============================================================================
.claude/hooks/learning-engine.sh:449:# COMMAND INTERFACE
.claude/hooks/learning-engine.sh:450:# =============================================================================
.claude/hooks/learning-engine.sh:451:
.claude/hooks/learning-engine.sh:452:case "${1:-help}" in
.claude/hooks/learning-engine.sh:453:    init)
.claude/hooks/learning-engine.sh:454:        init_learning
.claude/hooks/learning-engine.sh:455:        ;;
.claude/hooks/learning-engine.sh:456:    learn-success)
.claude/hooks/learning-engine.sh:457:        learn_success "${2:-general}" "${3:-default}" "${4:-0}" "${5:-}"
.claude/hooks/learning-engine.sh:458:        ;;
.claude/hooks/learning-engine.sh:459:    learn-failure)
.claude/hooks/learning-engine.sh:460:        learn_failure "${2:-general}" "${3:-default}" "${4:-UNKNOWN}" "${5:-}"
.claude/hooks/learning-engine.sh:461:        ;;
.claude/hooks/learning-engine.sh:462:    recommend)
.claude/hooks/learning-engine.sh:463:        recommend_strategy "${2:-general}" "${3:-}"
.claude/hooks/learning-engine.sh:464:        ;;
.claude/hooks/learning-engine.sh:465:    predict-risk)
.claude/hooks/learning-engine.sh:466:        predict_risk "${2:-general}" "${3:-default}"
.claude/hooks/learning-engine.sh:467:        ;;
.claude/hooks/learning-engine.sh:468:    mine-patterns)
.claude/hooks/learning-engine.sh:469:        mine_patterns "${2:-}" "${3:-5}"
.claude/hooks/learning-engine.sh:470:        ;;
.claude/hooks/learning-engine.sh:471:    calculate-quality)
.claude/hooks/learning-engine.sh:472:        calculate_quality "${2:-general}" "${3:-0}" "${4:-0}" "${5:-0}"
.claude/hooks/learning-engine.sh:473:        ;;
.claude/hooks/learning-engine.sh:474:    statistics)
.claude/hooks/learning-engine.sh:475:        get_statistics
.claude/hooks/learning-engine.sh:476:        ;;
.claude/hooks/learning-engine.sh:477:    best-strategies)
.claude/hooks/learning-engine.sh:478:        get_best_strategies "${2:-10}"
.claude/hooks/learning-engine.sh:479:        ;;
.claude/hooks/learning-engine.sh:480:    export)
.claude/hooks/learning-engine.sh:481:        export_learning_data "${2:-}"
.claude/hooks/learning-engine.sh:482:        ;;
.claude/hooks/learning-engine.sh:483:    help|*)
.claude/hooks/learning-engine.sh:484:        echo "Learning Engine - Continuous Learning System"
.claude/hooks/learning-engine.sh:485:        echo ""
.claude/hooks/learning-engine.sh:486:        echo "Usage: $0 <command> [args]"
.claude/hooks/learning-engine.sh:487:        echo ""
.claude/hooks/learning-engine.sh:488:        echo "Learning Commands:"
.claude/hooks/learning-engine.sh:489:        echo "  learn-success <type> <strategy> [duration] [context]"
.claude/hooks/learning-engine.sh:490:        echo "                                  - Learn from successful execution"
.claude/hooks/learning-engine.sh:491:        echo "  learn-failure <type> <strategy> <error> [msg]"
.claude/hooks/learning-engine.sh:492:        echo "                                  - Learn from failure"
.claude/hooks/learning-engine.sh:493:        echo ""
.claude/hooks/learning-engine.sh:494:        echo "Prediction Commands:"
.claude/hooks/learning-engine.sh:495:        echo "  recommend <task_type> [context] - Recommend best strategy"
.claude/hooks/learning-engine.sh:496:        echo "  predict-risk <type> <strategy>  - Predict failure risk (0-100)"
.claude/hooks/learning-engine.sh:497:        echo "  mine-patterns <query> [limit]   - Mine memory for patterns"
.claude/hooks/learning-engine.sh:498:        echo "  calculate-quality <type> <dur> <errors> <retries>"
.claude/hooks/learning-engine.sh:499:        echo "                                  - Calculate quality score"
.claude/hooks/learning-engine.sh:500:        echo ""
.claude/hooks/learning-engine.sh:501:        echo "Analytics Commands:"
.claude/hooks/learning-engine.sh:502:        echo "  statistics                      - Get learning statistics"
.claude/hooks/learning-engine.sh:503:        echo "  best-strategies [limit]         - Get top performing strategies"
.claude/hooks/learning-engine.sh:504:        echo "  export [file]                   - Export learning data"
.claude/hooks/learning-engine.sh:505:        echo ""
.claude/hooks/learning-engine.sh:506:        echo "Examples:"
.claude/hooks/learning-engine.sh:507:        echo "  $0 recommend feature_implementation"
.claude/hooks/learning-engine.sh:508:        echo "  $0 predict-risk bugfix incremental"
.claude/hooks/learning-engine.sh:509:        echo "  $0 mine-patterns 'authentication fix'"
.claude/hooks/learning-engine.sh:510:        ;;
.claude/hooks/learning-engine.sh:511:esac
.claude/hooks/file-change-tracker.sh:1:#!/bin/bash
.claude/hooks/file-change-tracker.sh:2:# File Change Tracker - Tracks file modifications for auto-checkpoint
.claude/hooks/file-change-tracker.sh:3:# Auto-triggers /checkpoint every 10 file changes
.claude/hooks/file-change-tracker.sh:4:
.claude/hooks/file-change-tracker.sh:5:set -e
.claude/hooks/file-change-tracker.sh:6:
.claude/hooks/file-change-tracker.sh:7:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/file-change-tracker.sh:8:PROJECT_DIR="${PWD}"
.claude/hooks/file-change-tracker.sh:9:TRACKER_FILE="${PROJECT_DIR}/.claude/file-changes.json"
.claude/hooks/file-change-tracker.sh:10:LOG_FILE="${CLAUDE_DIR}/file-change-tracker.log"
.claude/hooks/file-change-tracker.sh:11:CHECKPOINT_THRESHOLD=${CHECKPOINT_FILE_THRESHOLD:-10}
.claude/hooks/file-change-tracker.sh:12:
.claude/hooks/file-change-tracker.sh:13:log() {
.claude/hooks/file-change-tracker.sh:14:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/file-change-tracker.sh:15:}
.claude/hooks/file-change-tracker.sh:16:
.claude/hooks/file-change-tracker.sh:17:init_tracker() {
.claude/hooks/file-change-tracker.sh:18:    mkdir -p "${PROJECT_DIR}/.claude"
.claude/hooks/file-change-tracker.sh:19:    if [[ ! -f "$TRACKER_FILE" ]]; then
.claude/hooks/file-change-tracker.sh:20:        cat > "$TRACKER_FILE" <<'EOF'
.claude/hooks/file-change-tracker.sh:21:{
.claude/hooks/file-change-tracker.sh:22:  "session_start": "",
.claude/hooks/file-change-tracker.sh:23:  "last_checkpoint": "",
.claude/hooks/file-change-tracker.sh:24:  "files_changed": [],
.claude/hooks/file-change-tracker.sh:25:  "change_count": 0,
.claude/hooks/file-change-tracker.sh:26:  "checkpoint_count": 0
.claude/hooks/file-change-tracker.sh:27:}
.claude/hooks/file-change-tracker.sh:28:EOF
.claude/hooks/file-change-tracker.sh:29:    fi
.claude/hooks/file-change-tracker.sh:30:}
.claude/hooks/file-change-tracker.sh:31:
.claude/hooks/file-change-tracker.sh:32:# Record a file change
.claude/hooks/file-change-tracker.sh:33:record_change() {
.claude/hooks/file-change-tracker.sh:34:    local file_path="$1"
.claude/hooks/file-change-tracker.sh:35:    local change_type="${2:-modified}"  # created, modified, deleted
.claude/hooks/file-change-tracker.sh:36:
.claude/hooks/file-change-tracker.sh:37:    init_tracker
.claude/hooks/file-change-tracker.sh:38:
.claude/hooks/file-change-tracker.sh:39:    local timestamp
.claude/hooks/file-change-tracker.sh:40:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/file-change-tracker.sh:41:
.claude/hooks/file-change-tracker.sh:42:    # Check if session just started
.claude/hooks/file-change-tracker.sh:43:    local session_start
.claude/hooks/file-change-tracker.sh:44:    session_start=$(jq -r '.session_start' "$TRACKER_FILE")
.claude/hooks/file-change-tracker.sh:45:    if [[ -z "$session_start" || "$session_start" == "null" || "$session_start" == "" ]]; then
.claude/hooks/file-change-tracker.sh:46:        jq --arg ts "$timestamp" '.session_start = $ts' "$TRACKER_FILE" > "${TRACKER_FILE}.tmp"
.claude/hooks/file-change-tracker.sh:47:        mv "${TRACKER_FILE}.tmp" "$TRACKER_FILE"
.claude/hooks/file-change-tracker.sh:48:    fi
.claude/hooks/file-change-tracker.sh:49:
.claude/hooks/file-change-tracker.sh:50:    # Add file change
.claude/hooks/file-change-tracker.sh:51:    jq --arg file "$file_path" \
.claude/hooks/file-change-tracker.sh:52:       --arg type "$change_type" \
.claude/hooks/file-change-tracker.sh:53:       --arg ts "$timestamp" \
.claude/hooks/file-change-tracker.sh:54:       '
.claude/hooks/file-change-tracker.sh:55:       .files_changed += [{
.claude/hooks/file-change-tracker.sh:56:           file: $file,
.claude/hooks/file-change-tracker.sh:57:           type: $type,
.claude/hooks/file-change-tracker.sh:58:           timestamp: $ts
.claude/hooks/file-change-tracker.sh:59:       }] |
.claude/hooks/file-change-tracker.sh:60:       .change_count += 1
.claude/hooks/file-change-tracker.sh:61:       ' "$TRACKER_FILE" > "${TRACKER_FILE}.tmp"
.claude/hooks/file-change-tracker.sh:62:
.claude/hooks/file-change-tracker.sh:63:    mv "${TRACKER_FILE}.tmp" "$TRACKER_FILE"
.claude/hooks/file-change-tracker.sh:64:
.claude/hooks/file-change-tracker.sh:65:    local count
.claude/hooks/file-change-tracker.sh:66:    count=$(jq -r '.change_count' "$TRACKER_FILE")
.claude/hooks/file-change-tracker.sh:67:
.claude/hooks/file-change-tracker.sh:68:    log "Recorded change: $file_path ($change_type) - Total: $count"
.claude/hooks/file-change-tracker.sh:69:
.claude/hooks/file-change-tracker.sh:70:    # Check if threshold reached
.claude/hooks/file-change-tracker.sh:71:    if [[ $count -ge $CHECKPOINT_THRESHOLD ]]; then
.claude/hooks/file-change-tracker.sh:72:        echo "CHECKPOINT_NEEDED:${count}"
.claude/hooks/file-change-tracker.sh:73:        return 0
.claude/hooks/file-change-tracker.sh:74:    fi
.claude/hooks/file-change-tracker.sh:75:
.claude/hooks/file-change-tracker.sh:76:    echo "OK:${count}"
.claude/hooks/file-change-tracker.sh:77:}
.claude/hooks/file-change-tracker.sh:78:
.claude/hooks/file-change-tracker.sh:79:# Check if checkpoint needed
.claude/hooks/file-change-tracker.sh:80:should_checkpoint() {
.claude/hooks/file-change-tracker.sh:81:    init_tracker
.claude/hooks/file-change-tracker.sh:82:
.claude/hooks/file-change-tracker.sh:83:    local count
.claude/hooks/file-change-tracker.sh:84:    count=$(jq -r '.change_count' "$TRACKER_FILE")
.claude/hooks/file-change-tracker.sh:85:
.claude/hooks/file-change-tracker.sh:86:    if [[ $count -ge $CHECKPOINT_THRESHOLD ]]; then
.claude/hooks/file-change-tracker.sh:87:        echo "true:${count}"
.claude/hooks/file-change-tracker.sh:88:    else
.claude/hooks/file-change-tracker.sh:89:        echo "false:${count}"
.claude/hooks/file-change-tracker.sh:90:    fi
.claude/hooks/file-change-tracker.sh:91:}
.claude/hooks/file-change-tracker.sh:92:
.claude/hooks/file-change-tracker.sh:93:# Reset counter after checkpoint
.claude/hooks/file-change-tracker.sh:94:reset_counter() {
.claude/hooks/file-change-tracker.sh:95:    init_tracker
.claude/hooks/file-change-tracker.sh:96:
.claude/hooks/file-change-tracker.sh:97:    local timestamp
.claude/hooks/file-change-tracker.sh:98:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/file-change-tracker.sh:99:
.claude/hooks/file-change-tracker.sh:100:    local checkpoint_count
.claude/hooks/file-change-tracker.sh:101:    checkpoint_count=$(jq -r '.checkpoint_count' "$TRACKER_FILE")
.claude/hooks/file-change-tracker.sh:102:    checkpoint_count=$((checkpoint_count + 1))
.claude/hooks/file-change-tracker.sh:103:
.claude/hooks/file-change-tracker.sh:104:    jq --arg ts "$timestamp" \
.claude/hooks/file-change-tracker.sh:105:       --argjson count "$checkpoint_count" \
.claude/hooks/file-change-tracker.sh:106:       '
.claude/hooks/file-change-tracker.sh:107:       .last_checkpoint = $ts |
.claude/hooks/file-change-tracker.sh:108:       .checkpoint_count = $count |
.claude/hooks/file-change-tracker.sh:109:       .change_count = 0 |
.claude/hooks/file-change-tracker.sh:110:       .files_changed = []
.claude/hooks/file-change-tracker.sh:111:       ' "$TRACKER_FILE" > "${TRACKER_FILE}.tmp"
.claude/hooks/file-change-tracker.sh:112:
.claude/hooks/file-change-tracker.sh:113:    mv "${TRACKER_FILE}.tmp" "$TRACKER_FILE"
.claude/hooks/file-change-tracker.sh:114:
.claude/hooks/file-change-tracker.sh:115:    log "Counter reset after checkpoint (checkpoint #${checkpoint_count})"
.claude/hooks/file-change-tracker.sh:116:}
.claude/hooks/file-change-tracker.sh:117:
.claude/hooks/file-change-tracker.sh:118:# Get status
.claude/hooks/file-change-tracker.sh:119:get_status() {
.claude/hooks/file-change-tracker.sh:120:    init_tracker
.claude/hooks/file-change-tracker.sh:121:
.claude/hooks/file-change-tracker.sh:122:    local count
.claude/hooks/file-change-tracker.sh:123:    count=$(jq -r '.change_count' "$TRACKER_FILE")
.claude/hooks/file-change-tracker.sh:124:
.claude/hooks/file-change-tracker.sh:125:    local last_checkpoint
.claude/hooks/file-change-tracker.sh:126:    last_checkpoint=$(jq -r '.last_checkpoint // "never"' "$TRACKER_FILE")
.claude/hooks/file-change-tracker.sh:127:
.claude/hooks/file-change-tracker.sh:128:    local checkpoint_count
.claude/hooks/file-change-tracker.sh:129:    checkpoint_count=$(jq -r '.checkpoint_count' "$TRACKER_FILE")
.claude/hooks/file-change-tracker.sh:130:
.claude/hooks/file-change-tracker.sh:131:    cat <<EOF
.claude/hooks/file-change-tracker.sh:132:File Change Tracker Status:
.claude/hooks/file-change-tracker.sh:133:  Changes since last checkpoint: $count / $CHECKPOINT_THRESHOLD
.claude/hooks/file-change-tracker.sh:134:  Last checkpoint: $last_checkpoint
.claude/hooks/file-change-tracker.sh:135:  Total checkpoints this session: $checkpoint_count
.claude/hooks/file-change-tracker.sh:136:  Checkpoint needed: $(if [[ $count -ge $CHECKPOINT_THRESHOLD ]]; then echo "YES"; else echo "no"; fi)
.claude/hooks/file-change-tracker.sh:137:EOF
.claude/hooks/file-change-tracker.sh:138:}
.claude/hooks/file-change-tracker.sh:139:
.claude/hooks/file-change-tracker.sh:140:# Get recent changes
.claude/hooks/file-change-tracker.sh:141:get_recent() {
.claude/hooks/file-change-tracker.sh:142:    init_tracker
.claude/hooks/file-change-tracker.sh:143:
.claude/hooks/file-change-tracker.sh:144:    jq -r '.files_changed[-10:] | .[] | "  \(.timestamp) [\(.type)] \(.file)"' "$TRACKER_FILE"
.claude/hooks/file-change-tracker.sh:145:}
.claude/hooks/file-change-tracker.sh:146:
.claude/hooks/file-change-tracker.sh:147:# Command interface
.claude/hooks/file-change-tracker.sh:148:case "${1:-help}" in
.claude/hooks/file-change-tracker.sh:149:    record)
.claude/hooks/file-change-tracker.sh:150:        record_change "${2:-unknown}" "${3:-modified}"
.claude/hooks/file-change-tracker.sh:151:        ;;
.claude/hooks/file-change-tracker.sh:152:    check)
.claude/hooks/file-change-tracker.sh:153:        should_checkpoint
.claude/hooks/file-change-tracker.sh:154:        ;;
.claude/hooks/file-change-tracker.sh:155:    reset)
.claude/hooks/file-change-tracker.sh:156:        reset_counter
.claude/hooks/file-change-tracker.sh:157:        ;;
.claude/hooks/file-change-tracker.sh:158:    status)
.claude/hooks/file-change-tracker.sh:159:        get_status
.claude/hooks/file-change-tracker.sh:160:        ;;
.claude/hooks/file-change-tracker.sh:161:    recent)
.claude/hooks/file-change-tracker.sh:162:        get_recent
.claude/hooks/file-change-tracker.sh:163:        ;;
.claude/hooks/file-change-tracker.sh:164:    init)
.claude/hooks/file-change-tracker.sh:165:        init_tracker
.claude/hooks/file-change-tracker.sh:166:        echo "Tracker initialized"
.claude/hooks/file-change-tracker.sh:167:        ;;
.claude/hooks/file-change-tracker.sh:168:    *)
.claude/hooks/file-change-tracker.sh:169:        echo "File Change Tracker - Auto-checkpoint trigger"
.claude/hooks/file-change-tracker.sh:170:        echo ""
.claude/hooks/file-change-tracker.sh:171:        echo "Usage: $0 <command> [args]"
.claude/hooks/file-change-tracker.sh:172:        echo ""
.claude/hooks/file-change-tracker.sh:173:        echo "Commands:"
.claude/hooks/file-change-tracker.sh:174:        echo "  record <file> [type]  - Record a file change (type: created|modified|deleted)"
.claude/hooks/file-change-tracker.sh:175:        echo "  check                 - Check if checkpoint is needed"
.claude/hooks/file-change-tracker.sh:176:        echo "  reset                 - Reset counter after checkpoint"
.claude/hooks/file-change-tracker.sh:177:        echo "  status                - Show current status"
.claude/hooks/file-change-tracker.sh:178:        echo "  recent                - Show recent changes"
.claude/hooks/file-change-tracker.sh:179:        echo "  init                  - Initialize tracker"
.claude/hooks/file-change-tracker.sh:180:        echo ""
.claude/hooks/file-change-tracker.sh:181:        echo "Threshold: $CHECKPOINT_THRESHOLD files (set CHECKPOINT_FILE_THRESHOLD to change)"
.claude/hooks/file-change-tracker.sh:182:        ;;
.claude/hooks/file-change-tracker.sh:183:esac
.claude/hooks/graceful-shutdown.sh:1:#!/bin/bash
.claude/hooks/graceful-shutdown.sh:2:# Graceful Shutdown Handler - Clean shutdown with state preservation
.claude/hooks/graceful-shutdown.sh:3:# Based on patterns from: medusa GracefulShutdownServer, n8n, firecrawl, backstage
.claude/hooks/graceful-shutdown.sh:4:
.claude/hooks/graceful-shutdown.sh:5:set -uo pipefail
.claude/hooks/graceful-shutdown.sh:6:
.claude/hooks/graceful-shutdown.sh:7:STATE_DIR=".claude"
.claude/hooks/graceful-shutdown.sh:8:SHUTDOWN_FILE="$STATE_DIR/shutdown.json"
.claude/hooks/graceful-shutdown.sh:9:LOG_FILE="${HOME}/.claude/graceful-shutdown.log"
.claude/hooks/graceful-shutdown.sh:10:
.claude/hooks/graceful-shutdown.sh:11:# Shutdown timeout in seconds
.claude/hooks/graceful-shutdown.sh:12:SHUTDOWN_TIMEOUT="${SHUTDOWN_TIMEOUT:-30}"
.claude/hooks/graceful-shutdown.sh:13:
.claude/hooks/graceful-shutdown.sh:14:log() {
.claude/hooks/graceful-shutdown.sh:15:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/graceful-shutdown.sh:16:}
.claude/hooks/graceful-shutdown.sh:17:
.claude/hooks/graceful-shutdown.sh:18:# =============================================================================
.claude/hooks/graceful-shutdown.sh:19:# SHUTDOWN MANAGEMENT (from medusa/n8n patterns)
.claude/hooks/graceful-shutdown.sh:20:# =============================================================================
.claude/hooks/graceful-shutdown.sh:21:
.claude/hooks/graceful-shutdown.sh:22:# Register shutdown handler
.claude/hooks/graceful-shutdown.sh:23:register_handler() {
.claude/hooks/graceful-shutdown.sh:24:    local callback="${1:-}"
.claude/hooks/graceful-shutdown.sh:25:
.claude/hooks/graceful-shutdown.sh:26:    # Create shutdown state
.claude/hooks/graceful-shutdown.sh:27:    mkdir -p "$STATE_DIR"
.claude/hooks/graceful-shutdown.sh:28:
.claude/hooks/graceful-shutdown.sh:29:    local timestamp
.claude/hooks/graceful-shutdown.sh:30:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/graceful-shutdown.sh:31:
.claude/hooks/graceful-shutdown.sh:32:    cat > "$SHUTDOWN_FILE" << EOF
.claude/hooks/graceful-shutdown.sh:33:{
.claude/hooks/graceful-shutdown.sh:34:    "registered": true,
.claude/hooks/graceful-shutdown.sh:35:    "pid": $$,
.claude/hooks/graceful-shutdown.sh:36:    "registeredAt": "$timestamp",
.claude/hooks/graceful-shutdown.sh:37:    "callback": "$callback",
.claude/hooks/graceful-shutdown.sh:38:    "status": "running"
.claude/hooks/graceful-shutdown.sh:39:}
.claude/hooks/graceful-shutdown.sh:40:EOF
.claude/hooks/graceful-shutdown.sh:41:
.claude/hooks/graceful-shutdown.sh:42:    log "Registered shutdown handler for PID $$"
.claude/hooks/graceful-shutdown.sh:43:}
.claude/hooks/graceful-shutdown.sh:44:
.claude/hooks/graceful-shutdown.sh:45:# Save current state before shutdown
.claude/hooks/graceful-shutdown.sh:46:save_state() {
.claude/hooks/graceful-shutdown.sh:47:    local state_name="${1:-auto}"
.claude/hooks/graceful-shutdown.sh:48:    local state_data="${2:-}"
.claude/hooks/graceful-shutdown.sh:49:
.claude/hooks/graceful-shutdown.sh:50:    mkdir -p "$STATE_DIR/shutdown-states"
.claude/hooks/graceful-shutdown.sh:51:
.claude/hooks/graceful-shutdown.sh:52:    local timestamp
.claude/hooks/graceful-shutdown.sh:53:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/graceful-shutdown.sh:54:
.claude/hooks/graceful-shutdown.sh:55:    local state_file="$STATE_DIR/shutdown-states/${state_name}_$(date +%Y%m%d_%H%M%S).json"
.claude/hooks/graceful-shutdown.sh:56:
.claude/hooks/graceful-shutdown.sh:57:    # Gather current state from various sources
.claude/hooks/graceful-shutdown.sh:58:    local build_state="{}"
.claude/hooks/graceful-shutdown.sh:59:    if [[ -f "$STATE_DIR/current-build.local.md" ]]; then
.claude/hooks/graceful-shutdown.sh:60:        # Extract YAML frontmatter
.claude/hooks/graceful-shutdown.sh:61:        build_state=$(sed -n '/^---$/,/^---$/p' "$STATE_DIR/current-build.local.md" | grep -v "^---$" | yq -o json 2>/dev/null || echo '{}')
.claude/hooks/graceful-shutdown.sh:62:    fi
.claude/hooks/graceful-shutdown.sh:63:
.claude/hooks/graceful-shutdown.sh:64:    local progress_state="{}"
.claude/hooks/graceful-shutdown.sh:65:    if [[ -f "${HOME}/.claude/progress/current.json" ]]; then
.claude/hooks/graceful-shutdown.sh:66:        progress_state=$(cat "${HOME}/.claude/progress/current.json")
.claude/hooks/graceful-shutdown.sh:67:    fi
.claude/hooks/graceful-shutdown.sh:68:
.claude/hooks/graceful-shutdown.sh:69:    local queue_state="{}"
.claude/hooks/graceful-shutdown.sh:70:    if [[ -f "${HOME}/.claude/queue/tasks.json" ]]; then
.claude/hooks/graceful-shutdown.sh:71:        queue_state=$(jq '{pending: [.tasks[] | select(.status == "pending")] | length, in_progress: [.tasks[] | select(.status == "in_progress")] | length}' "${HOME}/.claude/queue/tasks.json")
.claude/hooks/graceful-shutdown.sh:72:    fi
.claude/hooks/graceful-shutdown.sh:73:
.claude/hooks/graceful-shutdown.sh:74:    # Create state snapshot
.claude/hooks/graceful-shutdown.sh:75:    jq -n \
.claude/hooks/graceful-shutdown.sh:76:        --arg name "$state_name" \
.claude/hooks/graceful-shutdown.sh:77:        --arg ts "$timestamp" \
.claude/hooks/graceful-shutdown.sh:78:        --arg data "$state_data" \
.claude/hooks/graceful-shutdown.sh:79:        --argjson build "$build_state" \
.claude/hooks/graceful-shutdown.sh:80:        --argjson progress "$progress_state" \
.claude/hooks/graceful-shutdown.sh:81:        --argjson queue "$queue_state" \
.claude/hooks/graceful-shutdown.sh:82:        '{
.claude/hooks/graceful-shutdown.sh:83:            name: $name,
.claude/hooks/graceful-shutdown.sh:84:            timestamp: $ts,
.claude/hooks/graceful-shutdown.sh:85:            customData: $data,
.claude/hooks/graceful-shutdown.sh:86:            build: $build,
.claude/hooks/graceful-shutdown.sh:87:            progress: $progress,
.claude/hooks/graceful-shutdown.sh:88:            queue: $queue
.claude/hooks/graceful-shutdown.sh:89:        }' > "$state_file"
.claude/hooks/graceful-shutdown.sh:90:
.claude/hooks/graceful-shutdown.sh:91:    log "Saved state: $state_file"
.claude/hooks/graceful-shutdown.sh:92:    echo "$state_file"
.claude/hooks/graceful-shutdown.sh:93:}
.claude/hooks/graceful-shutdown.sh:94:
.claude/hooks/graceful-shutdown.sh:95:# Initiate graceful shutdown
.claude/hooks/graceful-shutdown.sh:96:initiate_shutdown() {
.claude/hooks/graceful-shutdown.sh:97:    local reason="${1:-user_request}"
.claude/hooks/graceful-shutdown.sh:98:    local force="${2:-false}"
.claude/hooks/graceful-shutdown.sh:99:
.claude/hooks/graceful-shutdown.sh:100:    if [[ ! -f "$SHUTDOWN_FILE" ]]; then
.claude/hooks/graceful-shutdown.sh:101:        log "No shutdown handler registered"
.claude/hooks/graceful-shutdown.sh:102:        return 1
.claude/hooks/graceful-shutdown.sh:103:    fi
.claude/hooks/graceful-shutdown.sh:104:
.claude/hooks/graceful-shutdown.sh:105:    local temp_file
.claude/hooks/graceful-shutdown.sh:106:    temp_file=$(mktemp)
.claude/hooks/graceful-shutdown.sh:107:
.claude/hooks/graceful-shutdown.sh:108:    local timestamp
.claude/hooks/graceful-shutdown.sh:109:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/graceful-shutdown.sh:110:
.claude/hooks/graceful-shutdown.sh:111:    jq --arg reason "$reason" \
.claude/hooks/graceful-shutdown.sh:112:       --arg ts "$timestamp" \
.claude/hooks/graceful-shutdown.sh:113:       --arg force "$force" \
.claude/hooks/graceful-shutdown.sh:114:       '
.claude/hooks/graceful-shutdown.sh:115:       .status = "shutting_down" |
.claude/hooks/graceful-shutdown.sh:116:       .reason = $reason |
.claude/hooks/graceful-shutdown.sh:117:       .initiatedAt = $ts |
.claude/hooks/graceful-shutdown.sh:118:       .force = ($force == "true")
.claude/hooks/graceful-shutdown.sh:119:       ' "$SHUTDOWN_FILE" > "$temp_file"
.claude/hooks/graceful-shutdown.sh:120:
.claude/hooks/graceful-shutdown.sh:121:    mv "$temp_file" "$SHUTDOWN_FILE"
.claude/hooks/graceful-shutdown.sh:122:
.claude/hooks/graceful-shutdown.sh:123:    log "Initiated shutdown: $reason (force: $force)"
.claude/hooks/graceful-shutdown.sh:124:
.claude/hooks/graceful-shutdown.sh:125:    # Run cleanup tasks
.claude/hooks/graceful-shutdown.sh:126:    cleanup_tasks "$force"
.claude/hooks/graceful-shutdown.sh:127:}
.claude/hooks/graceful-shutdown.sh:128:
.claude/hooks/graceful-shutdown.sh:129:# Run cleanup tasks
.claude/hooks/graceful-shutdown.sh:130:cleanup_tasks() {
.claude/hooks/graceful-shutdown.sh:131:    local force="${1:-false}"
.claude/hooks/graceful-shutdown.sh:132:
.claude/hooks/graceful-shutdown.sh:133:    log "Running cleanup tasks..."
.claude/hooks/graceful-shutdown.sh:134:
.claude/hooks/graceful-shutdown.sh:135:    # 1. Save current state
.claude/hooks/graceful-shutdown.sh:136:    save_state "shutdown" "graceful_shutdown" 2>/dev/null || true
.claude/hooks/graceful-shutdown.sh:137:
.claude/hooks/graceful-shutdown.sh:138:    # 2. Release any held locks
.claude/hooks/graceful-shutdown.sh:139:    if [[ -x "${HOME}/.claude/hooks/lock-manager.sh" ]]; then
.claude/hooks/graceful-shutdown.sh:140:        "${HOME}/.claude/hooks/lock-manager.sh" cleanup 2>/dev/null || true
.claude/hooks/graceful-shutdown.sh:141:        log "Released locks"
.claude/hooks/graceful-shutdown.sh:142:    fi
.claude/hooks/graceful-shutdown.sh:143:
.claude/hooks/graceful-shutdown.sh:144:    # 3. End metrics session
.claude/hooks/graceful-shutdown.sh:145:    if [[ -x "${HOME}/.claude/hooks/metrics-collector.sh" ]]; then
.claude/hooks/graceful-shutdown.sh:146:        "${HOME}/.claude/hooks/metrics-collector.sh" end 2>/dev/null || true
.claude/hooks/graceful-shutdown.sh:147:        log "Ended metrics session"
.claude/hooks/graceful-shutdown.sh:148:    fi
.claude/hooks/graceful-shutdown.sh:149:
.claude/hooks/graceful-shutdown.sh:150:    # 4. Finish progress tracking
.claude/hooks/graceful-shutdown.sh:151:    if [[ -x "${HOME}/.claude/hooks/progress-tracker.sh" ]]; then
.claude/hooks/graceful-shutdown.sh:152:        "${HOME}/.claude/hooks/progress-tracker.sh" finish "interrupted" "Graceful shutdown" 2>/dev/null || true
.claude/hooks/graceful-shutdown.sh:153:        log "Finished progress tracking"
.claude/hooks/graceful-shutdown.sh:154:    fi
.claude/hooks/graceful-shutdown.sh:155:
.claude/hooks/graceful-shutdown.sh:156:    # 5. Save checkpoint
.claude/hooks/graceful-shutdown.sh:157:    if [[ -x "${HOME}/.claude/hooks/self-healing.sh" ]]; then
.claude/hooks/graceful-shutdown.sh:158:        "${HOME}/.claude/hooks/self-healing.sh" checkpoint "shutdown" 2>/dev/null || true
.claude/hooks/graceful-shutdown.sh:159:        log "Saved checkpoint"
.claude/hooks/graceful-shutdown.sh:160:    fi
.claude/hooks/graceful-shutdown.sh:161:
.claude/hooks/graceful-shutdown.sh:162:    # 6. Update debug log
.claude/hooks/graceful-shutdown.sh:163:    if [[ -f "$STATE_DIR/docs/debug-log.md" ]]; then
.claude/hooks/graceful-shutdown.sh:164:        echo "" >> "$STATE_DIR/docs/debug-log.md"
.claude/hooks/graceful-shutdown.sh:165:        echo "### Shutdown: $(date '+%Y-%m-%d %H:%M:%S')" >> "$STATE_DIR/docs/debug-log.md"
.claude/hooks/graceful-shutdown.sh:166:        echo "Session ended via graceful shutdown" >> "$STATE_DIR/docs/debug-log.md"
.claude/hooks/graceful-shutdown.sh:167:    fi
.claude/hooks/graceful-shutdown.sh:168:
.claude/hooks/graceful-shutdown.sh:169:    log "Cleanup tasks complete"
.claude/hooks/graceful-shutdown.sh:170:}
.claude/hooks/graceful-shutdown.sh:171:
.claude/hooks/graceful-shutdown.sh:172:# Check if shutdown is in progress
.claude/hooks/graceful-shutdown.sh:173:is_shutting_down() {
.claude/hooks/graceful-shutdown.sh:174:    if [[ ! -f "$SHUTDOWN_FILE" ]]; then
.claude/hooks/graceful-shutdown.sh:175:        echo "false"
.claude/hooks/graceful-shutdown.sh:176:        return 1
.claude/hooks/graceful-shutdown.sh:177:    fi
.claude/hooks/graceful-shutdown.sh:178:
.claude/hooks/graceful-shutdown.sh:179:    local status
.claude/hooks/graceful-shutdown.sh:180:    status=$(jq -r '.status // "unknown"' "$SHUTDOWN_FILE")
.claude/hooks/graceful-shutdown.sh:181:
.claude/hooks/graceful-shutdown.sh:182:    if [[ "$status" == "shutting_down" ]]; then
.claude/hooks/graceful-shutdown.sh:183:        echo "true"
.claude/hooks/graceful-shutdown.sh:184:        return 0
.claude/hooks/graceful-shutdown.sh:185:    fi
.claude/hooks/graceful-shutdown.sh:186:
.claude/hooks/graceful-shutdown.sh:187:    echo "false"
.claude/hooks/graceful-shutdown.sh:188:    return 1
.claude/hooks/graceful-shutdown.sh:189:}
.claude/hooks/graceful-shutdown.sh:190:
.claude/hooks/graceful-shutdown.sh:191:# Get shutdown status
.claude/hooks/graceful-shutdown.sh:192:get_status() {
.claude/hooks/graceful-shutdown.sh:193:    if [[ -f "$SHUTDOWN_FILE" ]]; then
.claude/hooks/graceful-shutdown.sh:194:        jq '.' "$SHUTDOWN_FILE"
.claude/hooks/graceful-shutdown.sh:195:    else
.claude/hooks/graceful-shutdown.sh:196:        echo '{"registered":false,"status":"not_registered"}'
.claude/hooks/graceful-shutdown.sh:197:    fi
.claude/hooks/graceful-shutdown.sh:198:}
.claude/hooks/graceful-shutdown.sh:199:
.claude/hooks/graceful-shutdown.sh:200:# Create continuation prompt for next session
.claude/hooks/graceful-shutdown.sh:201:create_continuation() {
.claude/hooks/graceful-shutdown.sh:202:    local state_file="${1:-}"
.claude/hooks/graceful-shutdown.sh:203:
.claude/hooks/graceful-shutdown.sh:204:    mkdir -p "$STATE_DIR"
.claude/hooks/graceful-shutdown.sh:205:
.claude/hooks/graceful-shutdown.sh:206:    local timestamp
.claude/hooks/graceful-shutdown.sh:207:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/graceful-shutdown.sh:208:
.claude/hooks/graceful-shutdown.sh:209:    # Load saved state if provided
.claude/hooks/graceful-shutdown.sh:210:    local context=""
.claude/hooks/graceful-shutdown.sh:211:    if [[ -n "$state_file" ]] && [[ -f "$state_file" ]]; then
.claude/hooks/graceful-shutdown.sh:212:        context=$(jq -r '
.claude/hooks/graceful-shutdown.sh:213:            "Previous session ended at \(.timestamp).\n" +
.claude/hooks/graceful-shutdown.sh:214:            "Build state: \(.build | tostring)\n" +
.claude/hooks/graceful-shutdown.sh:215:            "Progress: \(.progress.progress // 0)% complete\n" +
.claude/hooks/graceful-shutdown.sh:216:            "Pending tasks: \(.queue.pending // 0)"
.claude/hooks/graceful-shutdown.sh:217:        ' "$state_file")
.claude/hooks/graceful-shutdown.sh:218:    fi
.claude/hooks/graceful-shutdown.sh:219:
.claude/hooks/graceful-shutdown.sh:220:    cat > "$STATE_DIR/continue.md" << EOF
.claude/hooks/graceful-shutdown.sh:221:# Continuation Prompt
.claude/hooks/graceful-shutdown.sh:222:
.claude/hooks/graceful-shutdown.sh:223:> Generated: $timestamp
.claude/hooks/graceful-shutdown.sh:224:
.claude/hooks/graceful-shutdown.sh:225:## Previous Session State
.claude/hooks/graceful-shutdown.sh:226:
.claude/hooks/graceful-shutdown.sh:227:$context
.claude/hooks/graceful-shutdown.sh:228:
.claude/hooks/graceful-shutdown.sh:229:## Resume Instructions
.claude/hooks/graceful-shutdown.sh:230:
.claude/hooks/graceful-shutdown.sh:231:To continue from where you left off:
.claude/hooks/graceful-shutdown.sh:232:1. Run \`/build\` to resume the current build
.claude/hooks/graceful-shutdown.sh:233:2. Check \`.claude/current-build.local.md\` for build state
.claude/hooks/graceful-shutdown.sh:234:3. Review \`.claude/docs/debug-log.md\` for any stuck issues
.claude/hooks/graceful-shutdown.sh:235:
.claude/hooks/graceful-shutdown.sh:236:## Quick Actions
.claude/hooks/graceful-shutdown.sh:237:
.claude/hooks/graceful-shutdown.sh:238:- Resume build: \`/build\`
.claude/hooks/graceful-shutdown.sh:239:- Check health: Run \`~/.claude/hooks/self-healing.sh status\`
.claude/hooks/graceful-shutdown.sh:240:- View progress: Run \`~/.claude/hooks/progress-tracker.sh summary\`
.claude/hooks/graceful-shutdown.sh:241:EOF
.claude/hooks/graceful-shutdown.sh:242:
.claude/hooks/graceful-shutdown.sh:243:    log "Created continuation prompt"
.claude/hooks/graceful-shutdown.sh:244:    echo "$STATE_DIR/continue.md"
.claude/hooks/graceful-shutdown.sh:245:}
.claude/hooks/graceful-shutdown.sh:246:
.claude/hooks/graceful-shutdown.sh:247:# Restore from last state
.claude/hooks/graceful-shutdown.sh:248:restore_state() {
.claude/hooks/graceful-shutdown.sh:249:    local state_dir="$STATE_DIR/shutdown-states"
.claude/hooks/graceful-shutdown.sh:250:
.claude/hooks/graceful-shutdown.sh:251:    if [[ ! -d "$state_dir" ]]; then
.claude/hooks/graceful-shutdown.sh:252:        log "No saved states found"
.claude/hooks/graceful-shutdown.sh:253:        return 1
.claude/hooks/graceful-shutdown.sh:254:    fi
.claude/hooks/graceful-shutdown.sh:255:
.claude/hooks/graceful-shutdown.sh:256:    # Find most recent state file
.claude/hooks/graceful-shutdown.sh:257:    local latest_state
.claude/hooks/graceful-shutdown.sh:258:    latest_state=$(ls -t "$state_dir"/*.json 2>/dev/null | head -1)
.claude/hooks/graceful-shutdown.sh:259:
.claude/hooks/graceful-shutdown.sh:260:    if [[ -z "$latest_state" ]]; then
.claude/hooks/graceful-shutdown.sh:261:        log "No state files found"
.claude/hooks/graceful-shutdown.sh:262:        return 1
.claude/hooks/graceful-shutdown.sh:263:    fi
.claude/hooks/graceful-shutdown.sh:264:
.claude/hooks/graceful-shutdown.sh:265:    log "Found state to restore: $latest_state"
.claude/hooks/graceful-shutdown.sh:266:    cat "$latest_state"
.claude/hooks/graceful-shutdown.sh:267:}
.claude/hooks/graceful-shutdown.sh:268:
.claude/hooks/graceful-shutdown.sh:269:# Clear shutdown state
.claude/hooks/graceful-shutdown.sh:270:clear() {
.claude/hooks/graceful-shutdown.sh:271:    rm -f "$SHUTDOWN_FILE"
.claude/hooks/graceful-shutdown.sh:272:    log "Cleared shutdown state"
.claude/hooks/graceful-shutdown.sh:273:}
.claude/hooks/graceful-shutdown.sh:274:
.claude/hooks/graceful-shutdown.sh:275:# =============================================================================
.claude/hooks/graceful-shutdown.sh:276:# SIGNAL HANDLERS (from firecrawl pattern)
.claude/hooks/graceful-shutdown.sh:277:# =============================================================================
.claude/hooks/graceful-shutdown.sh:278:
.claude/hooks/graceful-shutdown.sh:279:# Setup signal handlers (call from main script)
.claude/hooks/graceful-shutdown.sh:280:setup_signals() {
.claude/hooks/graceful-shutdown.sh:281:    trap 'handle_signal SIGINT' SIGINT
.claude/hooks/graceful-shutdown.sh:282:    trap 'handle_signal SIGTERM' SIGTERM
.claude/hooks/graceful-shutdown.sh:283:    trap 'handle_signal SIGHUP' SIGHUP
.claude/hooks/graceful-shutdown.sh:284:
.claude/hooks/graceful-shutdown.sh:285:    log "Signal handlers registered"
.claude/hooks/graceful-shutdown.sh:286:}
.claude/hooks/graceful-shutdown.sh:287:
.claude/hooks/graceful-shutdown.sh:288:# Handle incoming signal
.claude/hooks/graceful-shutdown.sh:289:handle_signal() {
.claude/hooks/graceful-shutdown.sh:290:    local signal="$1"
.claude/hooks/graceful-shutdown.sh:291:    log "Received signal: $signal"
.claude/hooks/graceful-shutdown.sh:292:
.claude/hooks/graceful-shutdown.sh:293:    case "$signal" in
.claude/hooks/graceful-shutdown.sh:294:        SIGINT|SIGTERM)
.claude/hooks/graceful-shutdown.sh:295:            initiate_shutdown "signal:$signal"
.claude/hooks/graceful-shutdown.sh:296:            ;;
.claude/hooks/graceful-shutdown.sh:297:        SIGHUP)
.claude/hooks/graceful-shutdown.sh:298:            # Reload configuration
.claude/hooks/graceful-shutdown.sh:299:            log "Reload requested (SIGHUP)"
.claude/hooks/graceful-shutdown.sh:300:            ;;
.claude/hooks/graceful-shutdown.sh:301:    esac
.claude/hooks/graceful-shutdown.sh:302:}
.claude/hooks/graceful-shutdown.sh:303:
.claude/hooks/graceful-shutdown.sh:304:# =============================================================================
.claude/hooks/graceful-shutdown.sh:305:# COMMAND INTERFACE
.claude/hooks/graceful-shutdown.sh:306:# =============================================================================
.claude/hooks/graceful-shutdown.sh:307:
.claude/hooks/graceful-shutdown.sh:308:case "${1:-help}" in
.claude/hooks/graceful-shutdown.sh:309:    register)
.claude/hooks/graceful-shutdown.sh:310:        register_handler "${2:-}"
.claude/hooks/graceful-shutdown.sh:311:        ;;
.claude/hooks/graceful-shutdown.sh:312:    save)
.claude/hooks/graceful-shutdown.sh:313:        save_state "${2:-auto}" "${3:-}"
.claude/hooks/graceful-shutdown.sh:314:        ;;
.claude/hooks/graceful-shutdown.sh:315:    shutdown)
.claude/hooks/graceful-shutdown.sh:316:        initiate_shutdown "${2:-user_request}" "${3:-false}"
.claude/hooks/graceful-shutdown.sh:317:        ;;
.claude/hooks/graceful-shutdown.sh:318:    is-shutting-down)
.claude/hooks/graceful-shutdown.sh:319:        is_shutting_down
.claude/hooks/graceful-shutdown.sh:320:        ;;
.claude/hooks/graceful-shutdown.sh:321:    status)
.claude/hooks/graceful-shutdown.sh:322:        get_status
.claude/hooks/graceful-shutdown.sh:323:        ;;
.claude/hooks/graceful-shutdown.sh:324:    continue)
.claude/hooks/graceful-shutdown.sh:325:        create_continuation "${2:-}"
.claude/hooks/graceful-shutdown.sh:326:        ;;
.claude/hooks/graceful-shutdown.sh:327:    restore)
.claude/hooks/graceful-shutdown.sh:328:        restore_state
.claude/hooks/graceful-shutdown.sh:329:        ;;
.claude/hooks/graceful-shutdown.sh:330:    clear)
.claude/hooks/graceful-shutdown.sh:331:        clear
.claude/hooks/graceful-shutdown.sh:332:        ;;
.claude/hooks/graceful-shutdown.sh:333:    setup-signals)
.claude/hooks/graceful-shutdown.sh:334:        setup_signals
.claude/hooks/graceful-shutdown.sh:335:        ;;
.claude/hooks/graceful-shutdown.sh:336:    help|*)
.claude/hooks/graceful-shutdown.sh:337:        echo "Graceful Shutdown Handler"
.claude/hooks/graceful-shutdown.sh:338:        echo ""
.claude/hooks/graceful-shutdown.sh:339:        echo "Usage: $0 <command> [args]"
.claude/hooks/graceful-shutdown.sh:340:        echo ""
.claude/hooks/graceful-shutdown.sh:341:        echo "Commands:"
.claude/hooks/graceful-shutdown.sh:342:        echo "  register [callback]        - Register shutdown handler"
.claude/hooks/graceful-shutdown.sh:343:        echo "  save [name] [data]         - Save current state"
.claude/hooks/graceful-shutdown.sh:344:        echo "  shutdown [reason] [force]  - Initiate graceful shutdown"
.claude/hooks/graceful-shutdown.sh:345:        echo "  is-shutting-down           - Check if shutdown in progress"
.claude/hooks/graceful-shutdown.sh:346:        echo "  status                     - Get shutdown status"
.claude/hooks/graceful-shutdown.sh:347:        echo "  continue [state_file]      - Create continuation prompt"
.claude/hooks/graceful-shutdown.sh:348:        echo "  restore                    - Restore from last saved state"
.claude/hooks/graceful-shutdown.sh:349:        echo "  clear                      - Clear shutdown state"
.claude/hooks/graceful-shutdown.sh:350:        echo "  setup-signals              - Setup signal handlers"
.claude/hooks/graceful-shutdown.sh:351:        echo ""
.claude/hooks/graceful-shutdown.sh:352:        echo "Environment:"
.claude/hooks/graceful-shutdown.sh:353:        echo "  SHUTDOWN_TIMEOUT - Shutdown timeout in seconds (default: 30)"
.claude/hooks/graceful-shutdown.sh:354:        ;;
.claude/hooks/graceful-shutdown.sh:355:esac
.claude/hooks/enhanced-audit-trail.sh:1:#!/bin/bash
.claude/hooks/enhanced-audit-trail.sh:2:# Enhanced Audit Trail - Simple working version
.claude/hooks/enhanced-audit-trail.sh:3:set -eo pipefail
.claude/hooks/enhanced-audit-trail.sh:4:
.claude/hooks/enhanced-audit-trail.sh:5:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/enhanced-audit-trail.sh:6:AUDIT_LOG="${CLAUDE_DIR}/.audit/decisions.jsonl"
.claude/hooks/enhanced-audit-trail.sh:7:LOG_FILE="${CLAUDE_DIR}/audit-trail.log"
.claude/hooks/enhanced-audit-trail.sh:8:
.claude/hooks/enhanced-audit-trail.sh:9:mkdir -p "$(dirname "$AUDIT_LOG")"
.claude/hooks/enhanced-audit-trail.sh:10:
.claude/hooks/enhanced-audit-trail.sh:11:log() {
.claude/hooks/enhanced-audit-trail.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/enhanced-audit-trail.sh:13:}
.claude/hooks/enhanced-audit-trail.sh:14:
.claude/hooks/enhanced-audit-trail.sh:15:log_decision() {
.claude/hooks/enhanced-audit-trail.sh:16:    local action="$1"
.claude/hooks/enhanced-audit-trail.sh:17:    local reasoning="$2"
.claude/hooks/enhanced-audit-trail.sh:18:    local alternatives="$3"
.claude/hooks/enhanced-audit-trail.sh:19:    local why_chosen="$4"
.claude/hooks/enhanced-audit-trail.sh:20:    local confidence="${5:-0.8}"
.claude/hooks/enhanced-audit-trail.sh:21:
.claude/hooks/enhanced-audit-trail.sh:22:    local record
.claude/hooks/enhanced-audit-trail.sh:23:    record=$(jq -n \
.claude/hooks/enhanced-audit-trail.sh:24:        --arg action "$action" \
.claude/hooks/enhanced-audit-trail.sh:25:        --arg reasoning "$reasoning" \
.claude/hooks/enhanced-audit-trail.sh:26:        --arg alternatives "$alternatives" \
.claude/hooks/enhanced-audit-trail.sh:27:        --arg why "$why_chosen" \
.claude/hooks/enhanced-audit-trail.sh:28:        --arg conf "$confidence" \
.claude/hooks/enhanced-audit-trail.sh:29:        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/enhanced-audit-trail.sh:30:        '{
.claude/hooks/enhanced-audit-trail.sh:31:            timestamp: $ts,
.claude/hooks/enhanced-audit-trail.sh:32:            action: $action,
.claude/hooks/enhanced-audit-trail.sh:33:            reasoning: $reasoning,
.claude/hooks/enhanced-audit-trail.sh:34:            alternatives_considered: $alternatives,
.claude/hooks/enhanced-audit-trail.sh:35:            why_chosen: $why,
.claude/hooks/enhanced-audit-trail.sh:36:            confidence: ($conf | tonumber)
.claude/hooks/enhanced-audit-trail.sh:37:        }')
.claude/hooks/enhanced-audit-trail.sh:38:
.claude/hooks/enhanced-audit-trail.sh:39:    echo "$record" >> "$AUDIT_LOG"
.claude/hooks/enhanced-audit-trail.sh:40:
.claude/hooks/enhanced-audit-trail.sh:41:    log "Logged decision: $action (confidence: $confidence)"
.claude/hooks/enhanced-audit-trail.sh:42:    echo "$record"
.claude/hooks/enhanced-audit-trail.sh:43:}
.claude/hooks/enhanced-audit-trail.sh:44:
.claude/hooks/enhanced-audit-trail.sh:45:get_history() {
.claude/hooks/enhanced-audit-trail.sh:46:    local limit="${1:-10}"
.claude/hooks/enhanced-audit-trail.sh:47:
.claude/hooks/enhanced-audit-trail.sh:48:    if [[ ! -f "$AUDIT_LOG" ]]; then
.claude/hooks/enhanced-audit-trail.sh:49:        echo '[]'
.claude/hooks/enhanced-audit-trail.sh:50:        return
.claude/hooks/enhanced-audit-trail.sh:51:    fi
.claude/hooks/enhanced-audit-trail.sh:52:
.claude/hooks/enhanced-audit-trail.sh:53:    tail -n "$limit" "$AUDIT_LOG" | jq -s '.'
.claude/hooks/enhanced-audit-trail.sh:54:}
.claude/hooks/enhanced-audit-trail.sh:55:
.claude/hooks/enhanced-audit-trail.sh:56:case "${1:-help}" in
.claude/hooks/enhanced-audit-trail.sh:57:    log)
.claude/hooks/enhanced-audit-trail.sh:58:        log_decision "${2:-action}" "${3:-reasoning}" "${4:-alternatives}" "${5:-why}" "${6:-0.8}"
.claude/hooks/enhanced-audit-trail.sh:59:        ;;
.claude/hooks/enhanced-audit-trail.sh:60:    history)
.claude/hooks/enhanced-audit-trail.sh:61:        get_history "${2:-10}"
.claude/hooks/enhanced-audit-trail.sh:62:        ;;
.claude/hooks/enhanced-audit-trail.sh:63:    *)
.claude/hooks/enhanced-audit-trail.sh:64:        echo "Usage: $0 {log|history}"
.claude/hooks/enhanced-audit-trail.sh:65:        ;;
.claude/hooks/enhanced-audit-trail.sh:66:esac
.claude/hooks/constitutional-ai.sh:1:#!/bin/bash
.claude/hooks/constitutional-ai.sh:2:# Constitutional AI - Ethical guardrails and principles
.claude/hooks/constitutional-ai.sh:3:# Based on: LangChain Constitutional AI, Anthropic Constitutional AI papers
.claude/hooks/constitutional-ai.sh:4:# Ensures agent behavior aligns with defined principles
.claude/hooks/constitutional-ai.sh:5:
.claude/hooks/constitutional-ai.sh:6:set -eo pipefail
.claude/hooks/constitutional-ai.sh:7:
.claude/hooks/constitutional-ai.sh:8:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/constitutional-ai.sh:9:LOG_FILE="${CLAUDE_DIR}/constitutional-ai.log"
.claude/hooks/constitutional-ai.sh:10:
.claude/hooks/constitutional-ai.sh:11:log() {
.claude/hooks/constitutional-ai.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/constitutional-ai.sh:13:}
.claude/hooks/constitutional-ai.sh:14:
.claude/hooks/constitutional-ai.sh:15:# Define constitutional principles
.claude/hooks/constitutional-ai.sh:16:get_principles() {
.claude/hooks/constitutional-ai.sh:17:    cat << 'EOF'
.claude/hooks/constitutional-ai.sh:18:{
.claude/hooks/constitutional-ai.sh:19:    "principles": [
.claude/hooks/constitutional-ai.sh:20:        {
.claude/hooks/constitutional-ai.sh:21:            "name": "code_quality",
.claude/hooks/constitutional-ai.sh:22:            "critique": "Identify ways the code could be improved for readability, maintainability, or performance",
.claude/hooks/constitutional-ai.sh:23:            "revision": "Revise the code to be more readable, maintainable, and performant"
.claude/hooks/constitutional-ai.sh:24:        },
.claude/hooks/constitutional-ai.sh:25:        {
.claude/hooks/constitutional-ai.sh:26:            "name": "security_first",
.claude/hooks/constitutional-ai.sh:27:            "critique": "Identify potential security vulnerabilities such as XSS, SQL injection, command injection, or exposed secrets",
.claude/hooks/constitutional-ai.sh:28:            "revision": "Revise to eliminate security vulnerabilities and follow security best practices"
.claude/hooks/constitutional-ai.sh:29:        },
.claude/hooks/constitutional-ai.sh:30:        {
.claude/hooks/constitutional-ai.sh:31:            "name": "test_coverage",
.claude/hooks/constitutional-ai.sh:32:            "critique": "Identify missing test cases, edge cases not covered, or inadequate assertions",
.claude/hooks/constitutional-ai.sh:33:            "revision": "Revise to include comprehensive test coverage for all scenarios"
.claude/hooks/constitutional-ai.sh:34:        },
.claude/hooks/constitutional-ai.sh:35:        {
.claude/hooks/constitutional-ai.sh:36:            "name": "error_handling",
.claude/hooks/constitutional-ai.sh:37:            "critique": "Identify missing error handling, uncaught exceptions, or inadequate error messages",
.claude/hooks/constitutional-ai.sh:38:            "revision": "Revise to include proper error handling with clear, actionable error messages"
.claude/hooks/constitutional-ai.sh:39:        },
.claude/hooks/constitutional-ai.sh:40:        {
.claude/hooks/constitutional-ai.sh:41:            "name": "backwards_compatibility",
.claude/hooks/constitutional-ai.sh:42:            "critique": "Identify changes that could break existing functionality or APIs",
.claude/hooks/constitutional-ai.sh:43:            "revision": "Revise to maintain backwards compatibility or clearly document breaking changes"
.claude/hooks/constitutional-ai.sh:44:        },
.claude/hooks/constitutional-ai.sh:45:        {
.claude/hooks/constitutional-ai.sh:46:            "name": "documentation",
.claude/hooks/constitutional-ai.sh:47:            "critique": "Identify missing documentation, unclear explanations, or outdated comments",
.claude/hooks/constitutional-ai.sh:48:            "revision": "Revise to include clear, accurate documentation"
.claude/hooks/constitutional-ai.sh:49:        },
.claude/hooks/constitutional-ai.sh:50:        {
.claude/hooks/constitutional-ai.sh:51:            "name": "simplicity",
.claude/hooks/constitutional-ai.sh:52:            "critique": "Identify over-engineering, unnecessary complexity, or premature optimization",
.claude/hooks/constitutional-ai.sh:53:            "revision": "Revise to use the simplest approach that meets requirements"
.claude/hooks/constitutional-ai.sh:54:        },
.claude/hooks/constitutional-ai.sh:55:        {
.claude/hooks/constitutional-ai.sh:56:            "name": "no_data_loss",
.claude/hooks/constitutional-ai.sh:57:            "critique": "Identify operations that could result in data loss or corruption",
.claude/hooks/constitutional-ai.sh:58:            "revision": "Revise to protect against data loss with appropriate safeguards"
.claude/hooks/constitutional-ai.sh:59:        }
.claude/hooks/constitutional-ai.sh:60:    ]
.claude/hooks/constitutional-ai.sh:61:}
.claude/hooks/constitutional-ai.sh:62:EOF
.claude/hooks/constitutional-ai.sh:63:}
.claude/hooks/constitutional-ai.sh:64:
.claude/hooks/constitutional-ai.sh:65:# Critique output against principles
.claude/hooks/constitutional-ai.sh:66:critique_output() {
.claude/hooks/constitutional-ai.sh:67:    local output="$1"
.claude/hooks/constitutional-ai.sh:68:    local principles="${2:-all}"
.claude/hooks/constitutional-ai.sh:69:
.claude/hooks/constitutional-ai.sh:70:    log "Critiquing output against principles: $principles"
.claude/hooks/constitutional-ai.sh:71:
.claude/hooks/constitutional-ai.sh:72:    local principles_json
.claude/hooks/constitutional-ai.sh:73:    principles_json=$(get_principles)
.claude/hooks/constitutional-ai.sh:74:
.claude/hooks/constitutional-ai.sh:75:    if [[ "$principles" != "all" ]]; then
.claude/hooks/constitutional-ai.sh:76:        principles_json=$(echo "$principles_json" | jq --arg p "$principles" '{principles: [.principles[] | select(.name == $p)]}')
.claude/hooks/constitutional-ai.sh:77:    fi
.claude/hooks/constitutional-ai.sh:78:
.claude/hooks/constitutional-ai.sh:79:    cat << EOF
.claude/hooks/constitutional-ai.sh:80:{
.claude/hooks/constitutional-ai.sh:81:    "critique_prompt": "Review this output against our constitutional principles:
.claude/hooks/constitutional-ai.sh:82:
.claude/hooks/constitutional-ai.sh:83:**Output to Review:**
.claude/hooks/constitutional-ai.sh:84:\`\`\`
.claude/hooks/constitutional-ai.sh:85:$output
.claude/hooks/constitutional-ai.sh:86:\`\`\`
.claude/hooks/constitutional-ai.sh:87:
.claude/hooks/constitutional-ai.sh:88:**Principles to Check:**
.claude/hooks/constitutional-ai.sh:89:$(echo "$principles_json" | jq -r '.principles[] | "**\(.name)**: \(.critique)"')
.claude/hooks/constitutional-ai.sh:90:
.claude/hooks/constitutional-ai.sh:91:For each principle, provide:
.claude/hooks/constitutional-ai.sh:92:1. **Violations Found**: Specific issues (or \"None\")
.claude/hooks/constitutional-ai.sh:93:2. **Severity**: low/medium/high
.claude/hooks/constitutional-ai.sh:94:3. **Location**: Where in the output
.claude/hooks/constitutional-ai.sh:95:4. **Recommendation**: How to fix
.claude/hooks/constitutional-ai.sh:96:
.claude/hooks/constitutional-ai.sh:97:Format as JSON:
.claude/hooks/constitutional-ai.sh:98:{
.claude/hooks/constitutional-ai.sh:99:    \"critiques\": [
.claude/hooks/constitutional-ai.sh:100:        {
.claude/hooks/constitutional-ai.sh:101:            \"principle\": \"security_first\",
.claude/hooks/constitutional-ai.sh:102:            \"violations\": [\"SQL injection risk in query builder\"],
.claude/hooks/constitutional-ai.sh:103:            \"severity\": \"high\",
.claude/hooks/constitutional-ai.sh:104:            \"locations\": [\"line 42\"],
.claude/hooks/constitutional-ai.sh:105:            \"recommendations\": [\"Use parameterized queries\"]
.claude/hooks/constitutional-ai.sh:106:        }
.claude/hooks/constitutional-ai.sh:107:    ],
.claude/hooks/constitutional-ai.sh:108:    \"overall_assessment\": \"safe|needs_revision|unsafe\",
.claude/hooks/constitutional-ai.sh:109:    \"revision_required\": false
.claude/hooks/constitutional-ai.sh:110:}",
.claude/hooks/constitutional-ai.sh:111:    "principles": $(echo "$principles_json" | jq -c '.')
.claude/hooks/constitutional-ai.sh:112:}
.claude/hooks/constitutional-ai.sh:113:EOF
.claude/hooks/constitutional-ai.sh:114:}
.claude/hooks/constitutional-ai.sh:115:
.claude/hooks/constitutional-ai.sh:116:# Generate revision prompt
.claude/hooks/constitutional-ai.sh:117:generate_revision_prompt() {
.claude/hooks/constitutional-ai.sh:118:    local output="$1"
.claude/hooks/constitutional-ai.sh:119:    local critique="$2"
.claude/hooks/constitutional-ai.sh:120:
.claude/hooks/constitutional-ai.sh:121:    log "Generating revision prompt"
.claude/hooks/constitutional-ai.sh:122:
.claude/hooks/constitutional-ai.sh:123:    cat << EOF
.claude/hooks/constitutional-ai.sh:124:{
.claude/hooks/constitutional-ai.sh:125:    "revision_prompt": "Revise this output to address the constitutional violations:
.claude/hooks/constitutional-ai.sh:126:
.claude/hooks/constitutional-ai.sh:127:**Original Output:**
.claude/hooks/constitutional-ai.sh:128:\`\`\`
.claude/hooks/constitutional-ai.sh:129:$output
.claude/hooks/constitutional-ai.sh:130:\`\`\`
.claude/hooks/constitutional-ai.sh:131:
.claude/hooks/constitutional-ai.sh:132:**Violations to Address:**
.claude/hooks/constitutional-ai.sh:133:$(echo "$critique" | jq -r '.critiques[] | "**\(.principle)**: \(.violations | join(", "))"')
.claude/hooks/constitutional-ai.sh:134:
.claude/hooks/constitutional-ai.sh:135:**Revision Instructions:**
.claude/hooks/constitutional-ai.sh:136:$(echo "$critique" | jq -r '.critiques[] | "- \(.recommendations | join(". "))"')
.claude/hooks/constitutional-ai.sh:137:
.claude/hooks/constitutional-ai.sh:138:Provide the complete revised version that addresses ALL violations while maintaining functionality.",
.claude/hooks/constitutional-ai.sh:139:    "critique": $(echo "$critique" | jq -c '.')
.claude/hooks/constitutional-ai.sh:140:}
.claude/hooks/constitutional-ai.sh:141:EOF
.claude/hooks/constitutional-ai.sh:142:}
.claude/hooks/constitutional-ai.sh:143:
.claude/hooks/constitutional-ai.sh:144:case "${1:-help}" in
.claude/hooks/constitutional-ai.sh:145:    principles)
.claude/hooks/constitutional-ai.sh:146:        get_principles
.claude/hooks/constitutional-ai.sh:147:        ;;
.claude/hooks/constitutional-ai.sh:148:    critique)
.claude/hooks/constitutional-ai.sh:149:        critique_output "${2:-output}" "${3:-all}"
.claude/hooks/constitutional-ai.sh:150:        ;;
.claude/hooks/constitutional-ai.sh:151:    revise)
.claude/hooks/constitutional-ai.sh:152:        generate_revision_prompt "${2:-output}" "${3:-{}}"
.claude/hooks/constitutional-ai.sh:153:        ;;
.claude/hooks/constitutional-ai.sh:154:    help|*)
.claude/hooks/constitutional-ai.sh:155:        echo "Constitutional AI - Ethical Guardrails"
.claude/hooks/constitutional-ai.sh:156:        echo "Usage: $0 <command> [args]"
.claude/hooks/constitutional-ai.sh:157:        echo "  principles                - List all principles"
.claude/hooks/constitutional-ai.sh:158:        echo "  critique <output> [principle] - Critique against principles"
.claude/hooks/constitutional-ai.sh:159:        echo "  revise <output> <critique> - Generate revision prompt"
.claude/hooks/constitutional-ai.sh:160:        ;;
.claude/hooks/constitutional-ai.sh:161:esac
.claude/hooks/pre-compact.sh:1:#!/bin/bash
.claude/hooks/pre-compact.sh:2:# Pre-compact hook - saves state before context compaction
.claude/hooks/pre-compact.sh:3:# This ensures CLAUDE.md and continuation prompt are always up-to-date
.claude/hooks/pre-compact.sh:4:
.claude/hooks/pre-compact.sh:5:LOG_FILE="${HOME}/.claude/auto-checkpoint.log"
.claude/hooks/pre-compact.sh:6:TRIGGER=$(cat | jq -r '.trigger // "unknown"')
.claude/hooks/pre-compact.sh:7:
.claude/hooks/pre-compact.sh:8:echo "[$(date)] Pre-compact triggered (${TRIGGER})" >> "$LOG_FILE"
.claude/hooks/pre-compact.sh:9:
.claude/hooks/pre-compact.sh:10:# Signal to Claude to checkpoint before compacting
.claude/hooks/pre-compact.sh:11:# The prompt type hook is more effective here - this just logs
.claude/hooks/pre-compact.sh:12:exit 0
.claude/hooks/pattern-miner.sh:1:#!/bin/bash
.claude/hooks/pattern-miner.sh:2:# Pattern Miner - Mines successful patterns from memory and history
.claude/hooks/pattern-miner.sh:3:# Uses: memory, learning-engine, feedback-loop
.claude/hooks/pattern-miner.sh:4:
.claude/hooks/pattern-miner.sh:5:set -uo pipefail
.claude/hooks/pattern-miner.sh:6:
.claude/hooks/pattern-miner.sh:7:PATTERNS_DIR="${HOME}/.claude/patterns"
.claude/hooks/pattern-miner.sh:8:MINED_PATTERNS="$PATTERNS_DIR/mined.json"
.claude/hooks/pattern-miner.sh:9:LOG_FILE="${HOME}/.claude/pattern-miner.log"
.claude/hooks/pattern-miner.sh:10:
.claude/hooks/pattern-miner.sh:11:MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/pattern-miner.sh:12:LEARNING_ENGINE="${HOME}/.claude/hooks/learning-engine.sh"
.claude/hooks/pattern-miner.sh:13:
.claude/hooks/pattern-miner.sh:14:log() {
.claude/hooks/pattern-miner.sh:15:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/pattern-miner.sh:16:}
.claude/hooks/pattern-miner.sh:17:
.claude/hooks/pattern-miner.sh:18:init_patterns() {
.claude/hooks/pattern-miner.sh:19:    mkdir -p "$PATTERNS_DIR"
.claude/hooks/pattern-miner.sh:20:    [[ -f "$MINED_PATTERNS" ]] || echo '{"patterns":[]}' > "$MINED_PATTERNS"
.claude/hooks/pattern-miner.sh:21:}
.claude/hooks/pattern-miner.sh:22:
.claude/hooks/pattern-miner.sh:23:# Mine patterns from memory
.claude/hooks/pattern-miner.sh:24:mine_from_memory() {
.claude/hooks/pattern-miner.sh:25:    local query="$1"
.claude/hooks/pattern-miner.sh:26:    local limit="${2:-10}"
.claude/hooks/pattern-miner.sh:27:
.claude/hooks/pattern-miner.sh:28:    [[ ! -x "$MEMORY_MANAGER" ]] && echo '[]' && return
.claude/hooks/pattern-miner.sh:29:
.claude/hooks/pattern-miner.sh:30:    # Query episodic memory for successful tasks
.claude/hooks/pattern-miner.sh:31:    local episodes
.claude/hooks/pattern-miner.sh:32:    episodes=$("$MEMORY_MANAGER" remember-scored "$query" "$limit" 2>/dev/null || echo '[]')
.claude/hooks/pattern-miner.sh:33:
.claude/hooks/pattern-miner.sh:34:    # Extract patterns
.claude/hooks/pattern-miner.sh:35:    echo "$episodes" | jq '[
.claude/hooks/pattern-miner.sh:36:        .[] |
.claude/hooks/pattern-miner.sh:37:        select(.type == "episode" and (.metadata.outcome // "unknown") == "success") |
.claude/hooks/pattern-miner.sh:38:        {
.claude/hooks/pattern-miner.sh:39:            description: .content,
.claude/hooks/pattern-miner.sh:40:            approach: .metadata.action_type,
.claude/hooks/pattern-miner.sh:41:            details: .metadata.details,
.claude/hooks/pattern-miner.sh:42:            timestamp: .timestamp,
.claude/hooks/pattern-miner.sh:43:            source: "memory"
.claude/hooks/pattern-miner.sh:44:        }
.claude/hooks/pattern-miner.sh:45:    ]'
.claude/hooks/pattern-miner.sh:46:}
.claude/hooks/pattern-miner.sh:47:
.claude/hooks/pattern-miner.sh:48:# Mine patterns from learning engine
.claude/hooks/pattern-miner.sh:49:mine_from_learning() {
.claude/hooks/pattern-miner.sh:50:    local task_type="$1"
.claude/hooks/pattern-miner.sh:51:
.claude/hooks/pattern-miner.sh:52:    [[ ! -x "$LEARNING_ENGINE" ]] && echo '[]' && return
.claude/hooks/pattern-miner.sh:53:
.claude/hooks/pattern-miner.sh:54:    "$LEARNING_ENGINE" mine-patterns "$task_type" 10 2>/dev/null || echo '[]'
.claude/hooks/pattern-miner.sh:55:}
.claude/hooks/pattern-miner.sh:56:
.claude/hooks/pattern-miner.sh:57:# Mine all patterns
.claude/hooks/pattern-miner.sh:58:mine_all() {
.claude/hooks/pattern-miner.sh:59:    local task_type="${1:-}"
.claude/hooks/pattern-miner.sh:60:
.claude/hooks/pattern-miner.sh:61:    init_patterns
.claude/hooks/pattern-miner.sh:62:
.claude/hooks/pattern-miner.sh:63:    local memory_patterns
.claude/hooks/pattern-miner.sh:64:    memory_patterns=$(mine_from_memory "$task_type" 10)
.claude/hooks/pattern-miner.sh:65:
.claude/hooks/pattern-miner.sh:66:    local learning_patterns
.claude/hooks/pattern-miner.sh:67:    learning_patterns=$(mine_from_learning "$task_type")
.claude/hooks/pattern-miner.sh:68:
.claude/hooks/pattern-miner.sh:69:    # Combine and deduplicate
.claude/hooks/pattern-miner.sh:70:    jq -s '.[0] + .[1] | unique_by(.description)' \
.claude/hooks/pattern-miner.sh:71:        <(echo "$memory_patterns") \
.claude/hooks/pattern-miner.sh:72:        <(echo "$learning_patterns")
.claude/hooks/pattern-miner.sh:73:}
.claude/hooks/pattern-miner.sh:74:
.claude/hooks/pattern-miner.sh:75:# Get best practices for task type
.claude/hooks/pattern-miner.sh:76:get_best_practices() {
.claude/hooks/pattern-miner.sh:77:    local task_type="$1"
.claude/hooks/pattern-miner.sh:78:
.claude/hooks/pattern-miner.sh:79:    local patterns
.claude/hooks/pattern-miner.sh:80:    patterns=$(mine_all "$task_type")
.claude/hooks/pattern-miner.sh:81:
.claude/hooks/pattern-miner.sh:82:    # Score patterns by frequency and recency
.claude/hooks/pattern-miner.sh:83:    echo "$patterns" | jq '
.claude/hooks/pattern-miner.sh:84:        group_by(.approach) |
.claude/hooks/pattern-miner.sh:85:        map({
.claude/hooks/pattern-miner.sh:86:            approach: .[0].approach,
.claude/hooks/pattern-miner.sh:87:            count: length,
.claude/hooks/pattern-miner.sh:88:            examples: [.[] | {description, details}] | .[:3],
.claude/hooks/pattern-miner.sh:89:            recommendation: "Use \(.[0].approach) approach - successful in \(length) cases"
.claude/hooks/pattern-miner.sh:90:        }) |
.claude/hooks/pattern-miner.sh:91:        sort_by(-.count)
.claude/hooks/pattern-miner.sh:92:    '
.claude/hooks/pattern-miner.sh:93:}
.claude/hooks/pattern-miner.sh:94:
.claude/hooks/pattern-miner.sh:95:case "${1:-help}" in
.claude/hooks/pattern-miner.sh:96:    mine) mine_all "${2:-}" ;;
.claude/hooks/pattern-miner.sh:97:    best-practices) get_best_practices "${2:-general}" ;;
.claude/hooks/pattern-miner.sh:98:    *) echo "Usage: $0 {mine|best-practices} [task_type]" ;;
.claude/hooks/pattern-miner.sh:99:esac
.claude/hooks/validation-gate.sh:1:#!/bin/bash
.claude/hooks/validation-gate.sh:2:# Validation Gate - Pre-execution checks and safety validation
.claude/hooks/validation-gate.sh:3:# Based on patterns from: oracle validateBeforeExecute, langchain guardrails, codegen safety checks
.claude/hooks/validation-gate.sh:4:
.claude/hooks/validation-gate.sh:5:set -uo pipefail
.claude/hooks/validation-gate.sh:6:
.claude/hooks/validation-gate.sh:7:GATE_DIR="${HOME}/.claude/gates"
.claude/hooks/validation-gate.sh:8:GATE_RESULTS="$GATE_DIR/results.json"
.claude/hooks/validation-gate.sh:9:LOG_FILE="${HOME}/.claude/validation-gate.log"
.claude/hooks/validation-gate.sh:10:
.claude/hooks/validation-gate.sh:11:log() {
.claude/hooks/validation-gate.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/validation-gate.sh:13:}
.claude/hooks/validation-gate.sh:14:
.claude/hooks/validation-gate.sh:15:init_gates() {
.claude/hooks/validation-gate.sh:16:    mkdir -p "$GATE_DIR"
.claude/hooks/validation-gate.sh:17:    if [[ ! -f "$GATE_RESULTS" ]]; then
.claude/hooks/validation-gate.sh:18:        echo '{"checks":[]}' > "$GATE_RESULTS"
.claude/hooks/validation-gate.sh:19:    fi
.claude/hooks/validation-gate.sh:20:}
.claude/hooks/validation-gate.sh:21:
.claude/hooks/validation-gate.sh:22:# =============================================================================
.claude/hooks/validation-gate.sh:23:# PRE-EXECUTION VALIDATION
.claude/hooks/validation-gate.sh:24:# =============================================================================
.claude/hooks/validation-gate.sh:25:
.claude/hooks/validation-gate.sh:26:# Validate before executing a command
.claude/hooks/validation-gate.sh:27:validate_command() {
.claude/hooks/validation-gate.sh:28:    local command="$1"
.claude/hooks/validation-gate.sh:29:    local context="${2:-}"
.claude/hooks/validation-gate.sh:30:
.claude/hooks/validation-gate.sh:31:    local issues=()
.claude/hooks/validation-gate.sh:32:    local warnings=()
.claude/hooks/validation-gate.sh:33:
.claude/hooks/validation-gate.sh:34:    # Check for dangerous patterns
.claude/hooks/validation-gate.sh:35:    if [[ "$command" =~ rm[[:space:]]+-rf[[:space:]]+(\/|~|\$HOME|\*) ]]; then
.claude/hooks/validation-gate.sh:36:        issues+=("DANGEROUS: Recursive delete on critical path detected")
.claude/hooks/validation-gate.sh:37:    fi
.claude/hooks/validation-gate.sh:38:
.claude/hooks/validation-gate.sh:39:    if [[ "$command" =~ sudo[[:space:]] ]]; then
.claude/hooks/validation-gate.sh:40:        warnings+=("Command requires sudo privileges")
.claude/hooks/validation-gate.sh:41:    fi
.claude/hooks/validation-gate.sh:42:
.claude/hooks/validation-gate.sh:43:    if [[ "$command" =~ \>\>[[:space:]]*(\/etc|\/usr|\/bin|\/sbin) ]]; then
.claude/hooks/validation-gate.sh:44:        issues+=("DANGEROUS: Writing to system directory")
.claude/hooks/validation-gate.sh:45:    fi
.claude/hooks/validation-gate.sh:46:
.claude/hooks/validation-gate.sh:47:    if [[ "$command" =~ chmod[[:space:]]+(777|666) ]]; then
.claude/hooks/validation-gate.sh:48:        warnings+=("Insecure permissions detected")
.claude/hooks/validation-gate.sh:49:    fi
.claude/hooks/validation-gate.sh:50:
.claude/hooks/validation-gate.sh:51:    if [[ "$command" =~ curl.*\|.*sh ]] || [[ "$command" =~ wget.*\|.*sh ]]; then
.claude/hooks/validation-gate.sh:52:        issues+=("DANGEROUS: Pipe to shell detected")
.claude/hooks/validation-gate.sh:53:    fi
.claude/hooks/validation-gate.sh:54:
.claude/hooks/validation-gate.sh:55:    if [[ "$command" =~ eval[[:space:]] ]]; then
.claude/hooks/validation-gate.sh:56:        warnings+=("eval usage detected - verify input is trusted")
.claude/hooks/validation-gate.sh:57:    fi
.claude/hooks/validation-gate.sh:58:
.claude/hooks/validation-gate.sh:59:    if [[ "$command" =~ \$\( ]] && [[ "$command" =~ rm|del|format ]]; then
.claude/hooks/validation-gate.sh:60:        warnings+=("Command substitution with destructive command")
.claude/hooks/validation-gate.sh:61:    fi
.claude/hooks/validation-gate.sh:62:
.claude/hooks/validation-gate.sh:63:    # Output results
.claude/hooks/validation-gate.sh:64:    if [[ ${#issues[@]} -gt 0 ]]; then
.claude/hooks/validation-gate.sh:65:        echo "BLOCKED"
.claude/hooks/validation-gate.sh:66:        for issue in "${issues[@]}"; do
.claude/hooks/validation-gate.sh:67:            echo "  ERROR: $issue"
.claude/hooks/validation-gate.sh:68:        done
.claude/hooks/validation-gate.sh:69:        log "BLOCKED command: $command"
.claude/hooks/validation-gate.sh:70:        return 1
.claude/hooks/validation-gate.sh:71:    elif [[ ${#warnings[@]} -gt 0 ]]; then
.claude/hooks/validation-gate.sh:72:        echo "WARNING"
.claude/hooks/validation-gate.sh:73:        for warning in "${warnings[@]}"; do
.claude/hooks/validation-gate.sh:74:            echo "  WARN: $warning"
.claude/hooks/validation-gate.sh:75:        done
.claude/hooks/validation-gate.sh:76:        log "WARNING for command: $command"
.claude/hooks/validation-gate.sh:77:        return 0
.claude/hooks/validation-gate.sh:78:    else
.claude/hooks/validation-gate.sh:79:        echo "PASS"
.claude/hooks/validation-gate.sh:80:        return 0
.claude/hooks/validation-gate.sh:81:    fi
.claude/hooks/validation-gate.sh:82:}
.claude/hooks/validation-gate.sh:83:
.claude/hooks/validation-gate.sh:84:# Validate file operation
.claude/hooks/validation-gate.sh:85:validate_file_op() {
.claude/hooks/validation-gate.sh:86:    local operation="$1"  # read, write, delete, execute
.claude/hooks/validation-gate.sh:87:    local path="$2"
.claude/hooks/validation-gate.sh:88:
.claude/hooks/validation-gate.sh:89:    local issues=()
.claude/hooks/validation-gate.sh:90:    local warnings=()
.claude/hooks/validation-gate.sh:91:
.claude/hooks/validation-gate.sh:92:    # Resolve path
.claude/hooks/validation-gate.sh:93:    local resolved_path
.claude/hooks/validation-gate.sh:94:    resolved_path=$(realpath -m "$path" 2>/dev/null || echo "$path")
.claude/hooks/validation-gate.sh:95:
.claude/hooks/validation-gate.sh:96:    # Check protected paths
.claude/hooks/validation-gate.sh:97:    local protected_paths=(
.claude/hooks/validation-gate.sh:98:        "/etc/passwd" "/etc/shadow" "/etc/sudoers"
.claude/hooks/validation-gate.sh:99:        "/boot" "/proc" "/sys"
.claude/hooks/validation-gate.sh:100:        "$HOME/.ssh/id_rsa" "$HOME/.ssh/id_ed25519"
.claude/hooks/validation-gate.sh:101:        "$HOME/.gnupg"
.claude/hooks/validation-gate.sh:102:    )
.claude/hooks/validation-gate.sh:103:
.claude/hooks/validation-gate.sh:104:    for protected in "${protected_paths[@]}"; do
.claude/hooks/validation-gate.sh:105:        if [[ "$resolved_path" == "$protected"* ]]; then
.claude/hooks/validation-gate.sh:106:            if [[ "$operation" != "read" ]]; then
.claude/hooks/validation-gate.sh:107:                issues+=("PROTECTED: Cannot $operation protected path: $protected")
.claude/hooks/validation-gate.sh:108:            else
.claude/hooks/validation-gate.sh:109:                warnings+=("Reading from sensitive path: $protected")
.claude/hooks/validation-gate.sh:110:            fi
.claude/hooks/validation-gate.sh:111:        fi
.claude/hooks/validation-gate.sh:112:    done
.claude/hooks/validation-gate.sh:113:
.claude/hooks/validation-gate.sh:114:    # Check for dotfile modifications
.claude/hooks/validation-gate.sh:115:    if [[ "$operation" == "write" || "$operation" == "delete" ]]; then
.claude/hooks/validation-gate.sh:116:        if [[ "$resolved_path" == "$HOME/."* ]]; then
.claude/hooks/validation-gate.sh:117:            warnings+=("Modifying dotfile: $resolved_path")
.claude/hooks/validation-gate.sh:118:        fi
.claude/hooks/validation-gate.sh:119:    fi
.claude/hooks/validation-gate.sh:120:
.claude/hooks/validation-gate.sh:121:    # Check file existence for reads
.claude/hooks/validation-gate.sh:122:    if [[ "$operation" == "read" ]] && [[ ! -e "$path" ]]; then
.claude/hooks/validation-gate.sh:123:        issues+=("File does not exist: $path")
.claude/hooks/validation-gate.sh:124:    fi
.claude/hooks/validation-gate.sh:125:
.claude/hooks/validation-gate.sh:126:    # Check directory traversal
.claude/hooks/validation-gate.sh:127:    if [[ "$path" =~ \.\. ]]; then
.claude/hooks/validation-gate.sh:128:        warnings+=("Path contains directory traversal: $path")
.claude/hooks/validation-gate.sh:129:    fi
.claude/hooks/validation-gate.sh:130:
.claude/hooks/validation-gate.sh:131:    # Output results
.claude/hooks/validation-gate.sh:132:    if [[ ${#issues[@]} -gt 0 ]]; then
.claude/hooks/validation-gate.sh:133:        echo "BLOCKED"
.claude/hooks/validation-gate.sh:134:        for issue in "${issues[@]}"; do
.claude/hooks/validation-gate.sh:135:            echo "  ERROR: $issue"
.claude/hooks/validation-gate.sh:136:        done
.claude/hooks/validation-gate.sh:137:        return 1
.claude/hooks/validation-gate.sh:138:    elif [[ ${#warnings[@]} -gt 0 ]]; then
.claude/hooks/validation-gate.sh:139:        echo "WARNING"
.claude/hooks/validation-gate.sh:140:        for warning in "${warnings[@]}"; do
.claude/hooks/validation-gate.sh:141:            echo "  WARN: $warning"
.claude/hooks/validation-gate.sh:142:        done
.claude/hooks/validation-gate.sh:143:        return 0
.claude/hooks/validation-gate.sh:144:    else
.claude/hooks/validation-gate.sh:145:        echo "PASS"
.claude/hooks/validation-gate.sh:146:        return 0
.claude/hooks/validation-gate.sh:147:    fi
.claude/hooks/validation-gate.sh:148:}
.claude/hooks/validation-gate.sh:149:
.claude/hooks/validation-gate.sh:150:# =============================================================================
.claude/hooks/validation-gate.sh:151:# CODE VALIDATION
.claude/hooks/validation-gate.sh:152:# =============================================================================
.claude/hooks/validation-gate.sh:153:
.claude/hooks/validation-gate.sh:154:# Validate code before writing
.claude/hooks/validation-gate.sh:155:validate_code() {
.claude/hooks/validation-gate.sh:156:    local code="$1"
.claude/hooks/validation-gate.sh:157:    local language="${2:-auto}"
.claude/hooks/validation-gate.sh:158:
.claude/hooks/validation-gate.sh:159:    local issues=()
.claude/hooks/validation-gate.sh:160:    local warnings=()
.claude/hooks/validation-gate.sh:161:
.claude/hooks/validation-gate.sh:162:    # Auto-detect language if needed
.claude/hooks/validation-gate.sh:163:    if [[ "$language" == "auto" ]]; then
.claude/hooks/validation-gate.sh:164:        if [[ "$code" =~ ^import[[:space:]] ]] || [[ "$code" =~ ^from[[:space:]] ]]; then
.claude/hooks/validation-gate.sh:165:            language="python"
.claude/hooks/validation-gate.sh:166:        elif [[ "$code" =~ ^const[[:space:]] ]] || [[ "$code" =~ ^import[[:space:]]\{ ]]; then
.claude/hooks/validation-gate.sh:167:            language="javascript"
.claude/hooks/validation-gate.sh:168:        elif [[ "$code" =~ ^package[[:space:]] ]]; then
.claude/hooks/validation-gate.sh:169:            language="go"
.claude/hooks/validation-gate.sh:170:        fi
.claude/hooks/validation-gate.sh:171:    fi
.claude/hooks/validation-gate.sh:172:
.claude/hooks/validation-gate.sh:173:    # Common security patterns
.claude/hooks/validation-gate.sh:174:    if [[ "$code" =~ eval\( ]]; then
.claude/hooks/validation-gate.sh:175:        warnings+=("eval() usage - potential code injection")
.claude/hooks/validation-gate.sh:176:    fi
.claude/hooks/validation-gate.sh:177:
.claude/hooks/validation-gate.sh:178:    if [[ "$code" =~ exec\( ]]; then
.claude/hooks/validation-gate.sh:179:        warnings+=("exec() usage - verify input sanitization")
.claude/hooks/validation-gate.sh:180:    fi
.claude/hooks/validation-gate.sh:181:
.claude/hooks/validation-gate.sh:182:    # SQL injection patterns
.claude/hooks/validation-gate.sh:183:    if [[ "$code" =~ \+[[:space:]]*[\"\'](SELECT|INSERT|UPDATE|DELETE) ]]; then
.claude/hooks/validation-gate.sh:184:        issues+=("Potential SQL injection: string concatenation in query")
.claude/hooks/validation-gate.sh:185:    fi
.claude/hooks/validation-gate.sh:186:
.claude/hooks/validation-gate.sh:187:    # Hardcoded credentials
.claude/hooks/validation-gate.sh:188:    if [[ "$code" =~ password[[:space:]]*=[[:space:]]*[\"\'][^\"\'\$] ]]; then
.claude/hooks/validation-gate.sh:189:        issues+=("Hardcoded password detected")
.claude/hooks/validation-gate.sh:190:    fi
.claude/hooks/validation-gate.sh:191:
.claude/hooks/validation-gate.sh:192:    if [[ "$code" =~ (api_key|apikey|secret)[[:space:]]*=[[:space:]]*[\"\'][a-zA-Z0-9] ]]; then
.claude/hooks/validation-gate.sh:193:        issues+=("Hardcoded API key/secret detected")
.claude/hooks/validation-gate.sh:194:    fi
.claude/hooks/validation-gate.sh:195:
.claude/hooks/validation-gate.sh:196:    # Language-specific checks
.claude/hooks/validation-gate.sh:197:    case "$language" in
.claude/hooks/validation-gate.sh:198:        python)
.claude/hooks/validation-gate.sh:199:            if [[ "$code" =~ subprocess\.call.*shell=True ]]; then
.claude/hooks/validation-gate.sh:200:                warnings+=("subprocess with shell=True - potential command injection")
.claude/hooks/validation-gate.sh:201:            fi
.claude/hooks/validation-gate.sh:202:            if [[ "$code" =~ pickle\.load ]]; then
.claude/hooks/validation-gate.sh:203:                warnings+=("pickle.load - potential arbitrary code execution")
.claude/hooks/validation-gate.sh:204:            fi
.claude/hooks/validation-gate.sh:205:            ;;
.claude/hooks/validation-gate.sh:206:        javascript|typescript)
.claude/hooks/validation-gate.sh:207:            if [[ "$code" =~ innerHTML[[:space:]]*= ]]; then
.claude/hooks/validation-gate.sh:208:                warnings+=("innerHTML assignment - potential XSS")
.claude/hooks/validation-gate.sh:209:            fi
.claude/hooks/validation-gate.sh:210:            if [[ "$code" =~ dangerouslySetInnerHTML ]]; then
.claude/hooks/validation-gate.sh:211:                warnings+=("dangerouslySetInnerHTML - verify content is sanitized")
.claude/hooks/validation-gate.sh:212:            fi
.claude/hooks/validation-gate.sh:213:            ;;
.claude/hooks/validation-gate.sh:214:        go)
.claude/hooks/validation-gate.sh:215:            if [[ "$code" =~ os/exec.*Command ]]; then
.claude/hooks/validation-gate.sh:216:                warnings+=("Command execution - verify input sanitization")
.claude/hooks/validation-gate.sh:217:            fi
.claude/hooks/validation-gate.sh:218:            ;;
.claude/hooks/validation-gate.sh:219:    esac
.claude/hooks/validation-gate.sh:220:
.claude/hooks/validation-gate.sh:221:    # Output results
.claude/hooks/validation-gate.sh:222:    if [[ ${#issues[@]} -gt 0 ]]; then
.claude/hooks/validation-gate.sh:223:        echo "BLOCKED"
.claude/hooks/validation-gate.sh:224:        for issue in "${issues[@]}"; do
.claude/hooks/validation-gate.sh:225:            echo "  ERROR: $issue"
.claude/hooks/validation-gate.sh:226:        done
.claude/hooks/validation-gate.sh:227:        return 1
.claude/hooks/validation-gate.sh:228:    elif [[ ${#warnings[@]} -gt 0 ]]; then
.claude/hooks/validation-gate.sh:229:        echo "WARNING"
.claude/hooks/validation-gate.sh:230:        for warning in "${warnings[@]}"; do
.claude/hooks/validation-gate.sh:231:            echo "  WARN: $warning"
.claude/hooks/validation-gate.sh:232:        done
.claude/hooks/validation-gate.sh:233:        return 0
.claude/hooks/validation-gate.sh:234:    else
.claude/hooks/validation-gate.sh:235:        echo "PASS"
.claude/hooks/validation-gate.sh:236:        return 0
.claude/hooks/validation-gate.sh:237:    fi
.claude/hooks/validation-gate.sh:238:}
.claude/hooks/validation-gate.sh:239:
.claude/hooks/validation-gate.sh:240:# =============================================================================
.claude/hooks/validation-gate.sh:241:# GATE CHECKS
.claude/hooks/validation-gate.sh:242:# =============================================================================
.claude/hooks/validation-gate.sh:243:
.claude/hooks/validation-gate.sh:244:# Run all gates for an action
.claude/hooks/validation-gate.sh:245:run_gates() {
.claude/hooks/validation-gate.sh:246:    local action_type="$1"  # command, file, code
.claude/hooks/validation-gate.sh:247:    local action_data="$2"
.claude/hooks/validation-gate.sh:248:    local context="${3:-}"
.claude/hooks/validation-gate.sh:249:
.claude/hooks/validation-gate.sh:250:    init_gates
.claude/hooks/validation-gate.sh:251:
.claude/hooks/validation-gate.sh:252:    local gate_id
.claude/hooks/validation-gate.sh:253:    gate_id="gate_$(date +%s%N | cut -c1-13)"
.claude/hooks/validation-gate.sh:254:
.claude/hooks/validation-gate.sh:255:    local timestamp
.claude/hooks/validation-gate.sh:256:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/validation-gate.sh:257:
.claude/hooks/validation-gate.sh:258:    local result
.claude/hooks/validation-gate.sh:259:    local status="pass"
.claude/hooks/validation-gate.sh:260:    local details=""
.claude/hooks/validation-gate.sh:261:
.claude/hooks/validation-gate.sh:262:    case "$action_type" in
.claude/hooks/validation-gate.sh:263:        command)
.claude/hooks/validation-gate.sh:264:            result=$(validate_command "$action_data" "$context")
.claude/hooks/validation-gate.sh:265:            ;;
.claude/hooks/validation-gate.sh:266:        file)
.claude/hooks/validation-gate.sh:267:            local operation="${context:-read}"
.claude/hooks/validation-gate.sh:268:            result=$(validate_file_op "$operation" "$action_data")
.claude/hooks/validation-gate.sh:269:            ;;
.claude/hooks/validation-gate.sh:270:        code)
.claude/hooks/validation-gate.sh:271:            local language="${context:-auto}"
.claude/hooks/validation-gate.sh:272:            result=$(validate_code "$action_data" "$language")
.claude/hooks/validation-gate.sh:273:            ;;
.claude/hooks/validation-gate.sh:274:        *)
.claude/hooks/validation-gate.sh:275:            result="PASS"
.claude/hooks/validation-gate.sh:276:            ;;
.claude/hooks/validation-gate.sh:277:    esac
.claude/hooks/validation-gate.sh:278:
.claude/hooks/validation-gate.sh:279:    # Parse result
.claude/hooks/validation-gate.sh:280:    if [[ "$result" == BLOCKED* ]]; then
.claude/hooks/validation-gate.sh:281:        status="blocked"
.claude/hooks/validation-gate.sh:282:        details=$(echo "$result" | tail -n +2)
.claude/hooks/validation-gate.sh:283:    elif [[ "$result" == WARNING* ]]; then
.claude/hooks/validation-gate.sh:284:        status="warning"
.claude/hooks/validation-gate.sh:285:        details=$(echo "$result" | tail -n +2)
.claude/hooks/validation-gate.sh:286:    fi
.claude/hooks/validation-gate.sh:287:
.claude/hooks/validation-gate.sh:288:    # Record result
.claude/hooks/validation-gate.sh:289:    local temp_file
.claude/hooks/validation-gate.sh:290:    temp_file=$(mktemp)
.claude/hooks/validation-gate.sh:291:
.claude/hooks/validation-gate.sh:292:    jq --arg id "$gate_id" \
.claude/hooks/validation-gate.sh:293:       --arg type "$action_type" \
.claude/hooks/validation-gate.sh:294:       --arg data "$action_data" \
.claude/hooks/validation-gate.sh:295:       --arg status "$status" \
.claude/hooks/validation-gate.sh:296:       --arg details "$details" \
.claude/hooks/validation-gate.sh:297:       --arg ts "$timestamp" \
.claude/hooks/validation-gate.sh:298:       '
.claude/hooks/validation-gate.sh:299:       .checks = [{
.claude/hooks/validation-gate.sh:300:           id: $id,
.claude/hooks/validation-gate.sh:301:           type: $type,
.claude/hooks/validation-gate.sh:302:           data: ($data | .[0:500]),
.claude/hooks/validation-gate.sh:303:           status: $status,
.claude/hooks/validation-gate.sh:304:           details: $details,
.claude/hooks/validation-gate.sh:305:           timestamp: $ts
.claude/hooks/validation-gate.sh:306:       }] + .checks |
.claude/hooks/validation-gate.sh:307:       .checks = .checks[:100]
.claude/hooks/validation-gate.sh:308:       ' "$GATE_RESULTS" > "$temp_file"
.claude/hooks/validation-gate.sh:309:
.claude/hooks/validation-gate.sh:310:    mv "$temp_file" "$GATE_RESULTS"
.claude/hooks/validation-gate.sh:311:
.claude/hooks/validation-gate.sh:312:    log "Gate check: $action_type -> $status"
.claude/hooks/validation-gate.sh:313:
.claude/hooks/validation-gate.sh:314:    echo "$status"
.claude/hooks/validation-gate.sh:315:    if [[ -n "$details" ]]; then
.claude/hooks/validation-gate.sh:316:        echo "$details"
.claude/hooks/validation-gate.sh:317:    fi
.claude/hooks/validation-gate.sh:318:
.claude/hooks/validation-gate.sh:319:    [[ "$status" != "blocked" ]]
.claude/hooks/validation-gate.sh:320:}
.claude/hooks/validation-gate.sh:321:
.claude/hooks/validation-gate.sh:322:# Pre-flight check for a build/task
.claude/hooks/validation-gate.sh:323:preflight_check() {
.claude/hooks/validation-gate.sh:324:    local project_dir="${1:-.}"
.claude/hooks/validation-gate.sh:325:
.claude/hooks/validation-gate.sh:326:    local issues=()
.claude/hooks/validation-gate.sh:327:    local warnings=()
.claude/hooks/validation-gate.sh:328:
.claude/hooks/validation-gate.sh:329:    # Check if in git repo
.claude/hooks/validation-gate.sh:330:    if ! git -C "$project_dir" rev-parse --git-dir >/dev/null 2>&1; then
.claude/hooks/validation-gate.sh:331:        warnings+=("Not in a git repository")
.claude/hooks/validation-gate.sh:332:    else
.claude/hooks/validation-gate.sh:333:        # Check for uncommitted changes
.claude/hooks/validation-gate.sh:334:        if [[ -n $(git -C "$project_dir" status --porcelain 2>/dev/null) ]]; then
.claude/hooks/validation-gate.sh:335:            warnings+=("Uncommitted changes in repository")
.claude/hooks/validation-gate.sh:336:        fi
.claude/hooks/validation-gate.sh:337:    fi
.claude/hooks/validation-gate.sh:338:
.claude/hooks/validation-gate.sh:339:    # Check for required files
.claude/hooks/validation-gate.sh:340:    local required_files=("package.json" "requirements.txt" "go.mod" "Cargo.toml" "pom.xml")
.claude/hooks/validation-gate.sh:341:    local found_config=false
.claude/hooks/validation-gate.sh:342:
.claude/hooks/validation-gate.sh:343:    for file in "${required_files[@]}"; do
.claude/hooks/validation-gate.sh:344:        if [[ -f "$project_dir/$file" ]]; then
.claude/hooks/validation-gate.sh:345:            found_config=true
.claude/hooks/validation-gate.sh:346:            break
.claude/hooks/validation-gate.sh:347:        fi
.claude/hooks/validation-gate.sh:348:    done
.claude/hooks/validation-gate.sh:349:
.claude/hooks/validation-gate.sh:350:    if [[ "$found_config" == "false" ]]; then
.claude/hooks/validation-gate.sh:351:        warnings+=("No recognized project configuration found")
.claude/hooks/validation-gate.sh:352:    fi
.claude/hooks/validation-gate.sh:353:
.claude/hooks/validation-gate.sh:354:    # Check disk space
.claude/hooks/validation-gate.sh:355:    local available_space
.claude/hooks/validation-gate.sh:356:    available_space=$(df -k "$project_dir" | awk 'NR==2 {print $4}')
.claude/hooks/validation-gate.sh:357:    if [[ $available_space -lt 1048576 ]]; then  # Less than 1GB
.claude/hooks/validation-gate.sh:358:        warnings+=("Low disk space: $(( available_space / 1024 )) MB available")
.claude/hooks/validation-gate.sh:359:    fi
.claude/hooks/validation-gate.sh:360:
.claude/hooks/validation-gate.sh:361:    # Check for .env file (secrets exposure)
.claude/hooks/validation-gate.sh:362:    if [[ -f "$project_dir/.env" ]]; then
.claude/hooks/validation-gate.sh:363:        if ! grep -q "^\.env$" "$project_dir/.gitignore" 2>/dev/null; then
.claude/hooks/validation-gate.sh:364:            issues+=(".env file exists but may not be in .gitignore")
.claude/hooks/validation-gate.sh:365:        fi
.claude/hooks/validation-gate.sh:366:    fi
.claude/hooks/validation-gate.sh:367:
.claude/hooks/validation-gate.sh:368:    # Output results
.claude/hooks/validation-gate.sh:369:    echo "=== Preflight Check ==="
.claude/hooks/validation-gate.sh:370:
.claude/hooks/validation-gate.sh:371:    if [[ ${#issues[@]} -gt 0 ]]; then
.claude/hooks/validation-gate.sh:372:        echo "ISSUES:"
.claude/hooks/validation-gate.sh:373:        for issue in "${issues[@]}"; do
.claude/hooks/validation-gate.sh:374:            echo "  - $issue"
.claude/hooks/validation-gate.sh:375:        done
.claude/hooks/validation-gate.sh:376:    fi
.claude/hooks/validation-gate.sh:377:
.claude/hooks/validation-gate.sh:378:    if [[ ${#warnings[@]} -gt 0 ]]; then
.claude/hooks/validation-gate.sh:379:        echo "WARNINGS:"
.claude/hooks/validation-gate.sh:380:        for warning in "${warnings[@]}"; do
.claude/hooks/validation-gate.sh:381:            echo "  - $warning"
.claude/hooks/validation-gate.sh:382:        done
.claude/hooks/validation-gate.sh:383:    fi
.claude/hooks/validation-gate.sh:384:
.claude/hooks/validation-gate.sh:385:    if [[ ${#issues[@]} -eq 0 ]] && [[ ${#warnings[@]} -eq 0 ]]; then
.claude/hooks/validation-gate.sh:386:        echo "All checks passed"
.claude/hooks/validation-gate.sh:387:    fi
.claude/hooks/validation-gate.sh:388:
.claude/hooks/validation-gate.sh:389:    [[ ${#issues[@]} -eq 0 ]]
.claude/hooks/validation-gate.sh:390:}
.claude/hooks/validation-gate.sh:391:
.claude/hooks/validation-gate.sh:392:# =============================================================================
.claude/hooks/validation-gate.sh:393:# GUARDRAILS
.claude/hooks/validation-gate.sh:394:# =============================================================================
.claude/hooks/validation-gate.sh:395:
.claude/hooks/validation-gate.sh:396:# Check resource limits
.claude/hooks/validation-gate.sh:397:check_resources() {
.claude/hooks/validation-gate.sh:398:    local max_memory="${1:-4096}"  # MB
.claude/hooks/validation-gate.sh:399:    local max_cpu="${2:-80}"       # percent
.claude/hooks/validation-gate.sh:400:
.claude/hooks/validation-gate.sh:401:    local issues=()
.claude/hooks/validation-gate.sh:402:
.claude/hooks/validation-gate.sh:403:    # Check memory
.claude/hooks/validation-gate.sh:404:    local used_memory
.claude/hooks/validation-gate.sh:405:    if [[ "$(uname)" == "Darwin" ]]; then
.claude/hooks/validation-gate.sh:406:        used_memory=$(vm_stat | awk '/Pages active/ {print $3}' | tr -d '.')
.claude/hooks/validation-gate.sh:407:        used_memory=$((used_memory * 4096 / 1024 / 1024))  # Convert to MB
.claude/hooks/validation-gate.sh:408:    else
.claude/hooks/validation-gate.sh:409:        used_memory=$(free -m | awk 'NR==2 {print $3}')
.claude/hooks/validation-gate.sh:410:    fi
.claude/hooks/validation-gate.sh:411:
.claude/hooks/validation-gate.sh:412:    if [[ $used_memory -gt $max_memory ]]; then
.claude/hooks/validation-gate.sh:413:        issues+=("Memory usage high: ${used_memory}MB > ${max_memory}MB limit")
.claude/hooks/validation-gate.sh:414:    fi
.claude/hooks/validation-gate.sh:415:
.claude/hooks/validation-gate.sh:416:    # Check CPU (simplified)
.claude/hooks/validation-gate.sh:417:    local cpu_usage
.claude/hooks/validation-gate.sh:418:    if [[ "$(uname)" == "Darwin" ]]; then
.claude/hooks/validation-gate.sh:419:        cpu_usage=$(top -l 1 | grep "CPU usage" | awk '{print $3}' | tr -d '%')
.claude/hooks/validation-gate.sh:420:    else
.claude/hooks/validation-gate.sh:421:        cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | tr -d '%')
.claude/hooks/validation-gate.sh:422:    fi
.claude/hooks/validation-gate.sh:423:
.claude/hooks/validation-gate.sh:424:    if [[ -n "$cpu_usage" ]] && (( $(echo "$cpu_usage > $max_cpu" | bc -l 2>/dev/null || echo 0) )); then
.claude/hooks/validation-gate.sh:425:        issues+=("CPU usage high: ${cpu_usage}% > ${max_cpu}% limit")
.claude/hooks/validation-gate.sh:426:    fi
.claude/hooks/validation-gate.sh:427:
.claude/hooks/validation-gate.sh:428:    if [[ ${#issues[@]} -gt 0 ]]; then
.claude/hooks/validation-gate.sh:429:        echo "RESOURCE_LIMIT"
.claude/hooks/validation-gate.sh:430:        for issue in "${issues[@]}"; do
.claude/hooks/validation-gate.sh:431:            echo "  $issue"
.claude/hooks/validation-gate.sh:432:        done
.claude/hooks/validation-gate.sh:433:        return 1
.claude/hooks/validation-gate.sh:434:    fi
.claude/hooks/validation-gate.sh:435:
.claude/hooks/validation-gate.sh:436:    echo "RESOURCES_OK"
.claude/hooks/validation-gate.sh:437:    return 0
.claude/hooks/validation-gate.sh:438:}
.claude/hooks/validation-gate.sh:439:
.claude/hooks/validation-gate.sh:440:# Get gate statistics
.claude/hooks/validation-gate.sh:441:get_stats() {
.claude/hooks/validation-gate.sh:442:    if [[ ! -f "$GATE_RESULTS" ]]; then
.claude/hooks/validation-gate.sh:443:        echo '{"total":0,"passed":0,"warnings":0,"blocked":0}'
.claude/hooks/validation-gate.sh:444:        return
.claude/hooks/validation-gate.sh:445:    fi
.claude/hooks/validation-gate.sh:446:
.claude/hooks/validation-gate.sh:447:    jq '
.claude/hooks/validation-gate.sh:448:        .checks | length as $total |
.claude/hooks/validation-gate.sh:449:        [.[] | select(.status == "pass")] | length as $passed |
.claude/hooks/validation-gate.sh:450:        [.[] | select(.status == "warning")] | length as $warnings |
.claude/hooks/validation-gate.sh:451:        [.[] | select(.status == "blocked")] | length as $blocked |
.claude/hooks/validation-gate.sh:452:        {
.claude/hooks/validation-gate.sh:453:            total: $total,
.claude/hooks/validation-gate.sh:454:            passed: $passed,
.claude/hooks/validation-gate.sh:455:            warnings: $warnings,
.claude/hooks/validation-gate.sh:456:            blocked: $blocked,
.claude/hooks/validation-gate.sh:457:            passRate: (if $total > 0 then (($passed + $warnings) * 100 / $total | floor) else 100 end)
.claude/hooks/validation-gate.sh:458:        }
.claude/hooks/validation-gate.sh:459:    ' "$GATE_RESULTS"
.claude/hooks/validation-gate.sh:460:}
.claude/hooks/validation-gate.sh:461:
.claude/hooks/validation-gate.sh:462:# =============================================================================
.claude/hooks/validation-gate.sh:463:# COMMAND INTERFACE
.claude/hooks/validation-gate.sh:464:# =============================================================================
.claude/hooks/validation-gate.sh:465:
.claude/hooks/validation-gate.sh:466:case "${1:-help}" in
.claude/hooks/validation-gate.sh:467:    command)
.claude/hooks/validation-gate.sh:468:        validate_command "${2:-echo test}" "${3:-}"
.claude/hooks/validation-gate.sh:469:        ;;
.claude/hooks/validation-gate.sh:470:    file)
.claude/hooks/validation-gate.sh:471:        validate_file_op "${2:-read}" "${3:-.}"
.claude/hooks/validation-gate.sh:472:        ;;
.claude/hooks/validation-gate.sh:473:    code)
.claude/hooks/validation-gate.sh:474:        validate_code "${2:-print('hello')}" "${3:-auto}"
.claude/hooks/validation-gate.sh:475:        ;;
.claude/hooks/validation-gate.sh:476:    gate)
.claude/hooks/validation-gate.sh:477:        run_gates "${2:-command}" "${3:-echo test}" "${4:-}"
.claude/hooks/validation-gate.sh:478:        ;;
.claude/hooks/validation-gate.sh:479:    preflight)
.claude/hooks/validation-gate.sh:480:        preflight_check "${2:-.}"
.claude/hooks/validation-gate.sh:481:        ;;
.claude/hooks/validation-gate.sh:482:    resources)
.claude/hooks/validation-gate.sh:483:        check_resources "${2:-4096}" "${3:-80}"
.claude/hooks/validation-gate.sh:484:        ;;
.claude/hooks/validation-gate.sh:485:    stats)
.claude/hooks/validation-gate.sh:486:        get_stats
.claude/hooks/validation-gate.sh:487:        ;;
.claude/hooks/validation-gate.sh:488:    help|*)
.claude/hooks/validation-gate.sh:489:        echo "Validation Gate - Pre-execution Safety Checks"
.claude/hooks/validation-gate.sh:490:        echo ""
.claude/hooks/validation-gate.sh:491:        echo "Usage: $0 <command> [args]"
.claude/hooks/validation-gate.sh:492:        echo ""
.claude/hooks/validation-gate.sh:493:        echo "Validation Commands:"
.claude/hooks/validation-gate.sh:494:        echo "  command <cmd> [context]           - Validate shell command"
.claude/hooks/validation-gate.sh:495:        echo "  file <operation> <path>           - Validate file operation"
.claude/hooks/validation-gate.sh:496:        echo "    Operations: read, write, delete, execute"
.claude/hooks/validation-gate.sh:497:        echo "  code <code> [language]            - Validate code snippet"
.claude/hooks/validation-gate.sh:498:        echo "    Languages: python, javascript, go, auto"
.claude/hooks/validation-gate.sh:499:        echo ""
.claude/hooks/validation-gate.sh:500:        echo "Gate Commands:"
.claude/hooks/validation-gate.sh:501:        echo "  gate <type> <data> [context]      - Run full gate check"
.claude/hooks/validation-gate.sh:502:        echo "  preflight [dir]                   - Run preflight checks"
.claude/hooks/validation-gate.sh:503:        echo "  resources [max_mem] [max_cpu]     - Check resource limits"
.claude/hooks/validation-gate.sh:504:        echo ""
.claude/hooks/validation-gate.sh:505:        echo "Status:"
.claude/hooks/validation-gate.sh:506:        echo "  stats                             - Get gate statistics"
.claude/hooks/validation-gate.sh:507:        ;;
.claude/hooks/validation-gate.sh:508:esac
.claude/hooks/post-edit-quality.sh:1:#!/bin/bash
.claude/hooks/post-edit-quality.sh:2:# PostToolUse Hook: Auto-lint and typecheck after file edits
.claude/hooks/post-edit-quality.sh:3:# Runs silently, fixes what it can, reports issues
.claude/hooks/post-edit-quality.sh:4:
.claude/hooks/post-edit-quality.sh:5:set -euo pipefail
.claude/hooks/post-edit-quality.sh:6:
.claude/hooks/post-edit-quality.sh:7:LOG_FILE="${HOME}/.claude/quality.log"
.claude/hooks/post-edit-quality.sh:8:
.claude/hooks/post-edit-quality.sh:9:log() {
.claude/hooks/post-edit-quality.sh:10:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/post-edit-quality.sh:11:}
.claude/hooks/post-edit-quality.sh:12:
.claude/hooks/post-edit-quality.sh:13:# Read hook input
.claude/hooks/post-edit-quality.sh:14:HOOK_INPUT=$(cat)
.claude/hooks/post-edit-quality.sh:15:
.claude/hooks/post-edit-quality.sh:16:# Extract tool info
.claude/hooks/post-edit-quality.sh:17:TOOL_NAME=$(echo "$HOOK_INPUT" | jq -r '.tool_name // ""')
.claude/hooks/post-edit-quality.sh:18:TOOL_INPUT=$(echo "$HOOK_INPUT" | jq -r '.tool_input // {}')
.claude/hooks/post-edit-quality.sh:19:
.claude/hooks/post-edit-quality.sh:20:# Only run for file modification tools
.claude/hooks/post-edit-quality.sh:21:case "$TOOL_NAME" in
.claude/hooks/post-edit-quality.sh:22:    Write|Edit|MultiEdit|NotebookEdit)
.claude/hooks/post-edit-quality.sh:23:        ;;
.claude/hooks/post-edit-quality.sh:24:    *)
.claude/hooks/post-edit-quality.sh:25:        exit 0
.claude/hooks/post-edit-quality.sh:26:        ;;
.claude/hooks/post-edit-quality.sh:27:esac
.claude/hooks/post-edit-quality.sh:28:
.claude/hooks/post-edit-quality.sh:29:# Extract file path
.claude/hooks/post-edit-quality.sh:30:FILE_PATH=$(echo "$TOOL_INPUT" | jq -r '.file_path // .path // ""')
.claude/hooks/post-edit-quality.sh:31:
.claude/hooks/post-edit-quality.sh:32:if [[ -z "$FILE_PATH" ]] || [[ ! -f "$FILE_PATH" ]]; then
.claude/hooks/post-edit-quality.sh:33:    exit 0
.claude/hooks/post-edit-quality.sh:34:fi
.claude/hooks/post-edit-quality.sh:35:
.claude/hooks/post-edit-quality.sh:36:# Get file extension
.claude/hooks/post-edit-quality.sh:37:EXT="${FILE_PATH##*.}"
.claude/hooks/post-edit-quality.sh:38:
.claude/hooks/post-edit-quality.sh:39:log "Quality check triggered for: $FILE_PATH (.$EXT)"
.claude/hooks/post-edit-quality.sh:40:
.claude/hooks/post-edit-quality.sh:41:# Run appropriate linter based on file type
.claude/hooks/post-edit-quality.sh:42:case "$EXT" in
.claude/hooks/post-edit-quality.sh:43:    ts|tsx|js|jsx|mjs|cjs)
.claude/hooks/post-edit-quality.sh:44:        # TypeScript/JavaScript - run eslint fix
.claude/hooks/post-edit-quality.sh:45:        if command -v npx &> /dev/null && [[ -f "package.json" ]]; then
.claude/hooks/post-edit-quality.sh:46:            # Check if eslint is available
.claude/hooks/post-edit-quality.sh:47:            if npx eslint --version &> /dev/null 2>&1; then
.claude/hooks/post-edit-quality.sh:48:                LINT_OUTPUT=$(npx eslint --fix "$FILE_PATH" 2>&1) || true
.claude/hooks/post-edit-quality.sh:49:                if [[ -n "$LINT_OUTPUT" ]]; then
.claude/hooks/post-edit-quality.sh:50:                    log "ESLint output: $LINT_OUTPUT"
.claude/hooks/post-edit-quality.sh:51:                    # Return lint issues as advisory (don't block)
.claude/hooks/post-edit-quality.sh:52:                    echo "{\"advisory\": \"ESLint: $(echo "$LINT_OUTPUT" | head -5 | tr '\n' ' ')\"}"
.claude/hooks/post-edit-quality.sh:53:                fi
.claude/hooks/post-edit-quality.sh:54:            fi
.claude/hooks/post-edit-quality.sh:55:        fi
.claude/hooks/post-edit-quality.sh:56:        ;;
.claude/hooks/post-edit-quality.sh:57:
.claude/hooks/post-edit-quality.sh:58:    py)
.claude/hooks/post-edit-quality.sh:59:        # Python - run ruff or black
.claude/hooks/post-edit-quality.sh:60:        if command -v ruff &> /dev/null; then
.claude/hooks/post-edit-quality.sh:61:            ruff check --fix "$FILE_PATH" 2>&1 || true
.claude/hooks/post-edit-quality.sh:62:            ruff format "$FILE_PATH" 2>&1 || true
.claude/hooks/post-edit-quality.sh:63:            log "Ruff applied to $FILE_PATH"
.claude/hooks/post-edit-quality.sh:64:        elif command -v black &> /dev/null; then
.claude/hooks/post-edit-quality.sh:65:            black "$FILE_PATH" 2>&1 || true
.claude/hooks/post-edit-quality.sh:66:            log "Black applied to $FILE_PATH"
.claude/hooks/post-edit-quality.sh:67:        fi
.claude/hooks/post-edit-quality.sh:68:        ;;
.claude/hooks/post-edit-quality.sh:69:
.claude/hooks/post-edit-quality.sh:70:    go)
.claude/hooks/post-edit-quality.sh:71:        # Go - run gofmt
.claude/hooks/post-edit-quality.sh:72:        if command -v gofmt &> /dev/null; then
.claude/hooks/post-edit-quality.sh:73:            gofmt -w "$FILE_PATH" 2>&1 || true
.claude/hooks/post-edit-quality.sh:74:            log "gofmt applied to $FILE_PATH"
.claude/hooks/post-edit-quality.sh:75:        fi
.claude/hooks/post-edit-quality.sh:76:        ;;
.claude/hooks/post-edit-quality.sh:77:
.claude/hooks/post-edit-quality.sh:78:    rs)
.claude/hooks/post-edit-quality.sh:79:        # Rust - run rustfmt
.claude/hooks/post-edit-quality.sh:80:        if command -v rustfmt &> /dev/null; then
.claude/hooks/post-edit-quality.sh:81:            rustfmt "$FILE_PATH" 2>&1 || true
.claude/hooks/post-edit-quality.sh:82:            log "rustfmt applied to $FILE_PATH"
.claude/hooks/post-edit-quality.sh:83:        fi
.claude/hooks/post-edit-quality.sh:84:        ;;
.claude/hooks/post-edit-quality.sh:85:
.claude/hooks/post-edit-quality.sh:86:    json)
.claude/hooks/post-edit-quality.sh:87:        # JSON - validate and format with jq
.claude/hooks/post-edit-quality.sh:88:        if command -v jq &> /dev/null; then
.claude/hooks/post-edit-quality.sh:89:            if ! jq empty "$FILE_PATH" 2>&1; then
.claude/hooks/post-edit-quality.sh:90:                log "Invalid JSON in $FILE_PATH"
.claude/hooks/post-edit-quality.sh:91:                echo "{\"advisory\": \"Invalid JSON syntax in $FILE_PATH\"}"
.claude/hooks/post-edit-quality.sh:92:            fi
.claude/hooks/post-edit-quality.sh:93:        fi
.claude/hooks/post-edit-quality.sh:94:        ;;
.claude/hooks/post-edit-quality.sh:95:
.claude/hooks/post-edit-quality.sh:96:    *)
.claude/hooks/post-edit-quality.sh:97:        # Unknown file type - skip
.claude/hooks/post-edit-quality.sh:98:        ;;
.claude/hooks/post-edit-quality.sh:99:esac
.claude/hooks/post-edit-quality.sh:100:
.claude/hooks/post-edit-quality.sh:101:# ============================================================================
.claude/hooks/post-edit-quality.sh:102:# PHASE 1 INTEGRATION: File Change Detection + Auto-checkpoint
.claude/hooks/post-edit-quality.sh:103:# ============================================================================
.claude/hooks/post-edit-quality.sh:104:
.claude/hooks/post-edit-quality.sh:105:# 1. Cache file hash after successful edit
.claude/hooks/post-edit-quality.sh:106:MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/post-edit-quality.sh:107:
.claude/hooks/post-edit-quality.sh:108:if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/post-edit-quality.sh:109:    # Cache file hash for change detection
.claude/hooks/post-edit-quality.sh:110:    hash_result=$("$MEMORY_MANAGER" cache-file "$FILE_PATH" 2>/dev/null || echo "")
.claude/hooks/post-edit-quality.sh:111:    if [[ -n "$hash_result" ]]; then
.claude/hooks/post-edit-quality.sh:112:        log " Cached file hash: $FILE_PATH (${hash_result:0:8}...)"
.claude/hooks/post-edit-quality.sh:113:    fi
.claude/hooks/post-edit-quality.sh:114:fi
.claude/hooks/post-edit-quality.sh:115:
.claude/hooks/post-edit-quality.sh:116:# 2. Track file changes and auto-checkpoint every 10 files
.claude/hooks/post-edit-quality.sh:117:FILE_CHANGE_TRACKER="${HOME}/.claude/hooks/file-change-tracker.sh"
.claude/hooks/post-edit-quality.sh:118:
.claude/hooks/post-edit-quality.sh:119:if [[ -x "$FILE_CHANGE_TRACKER" ]]; then
.claude/hooks/post-edit-quality.sh:120:    # Record file change
.claude/hooks/post-edit-quality.sh:121:    result=$("$FILE_CHANGE_TRACKER" record "$FILE_PATH" "modified" 2>/dev/null || echo "")
.claude/hooks/post-edit-quality.sh:122:
.claude/hooks/post-edit-quality.sh:123:    # Check if checkpoint needed
.claude/hooks/post-edit-quality.sh:124:    if echo "$result" | grep -q "CHECKPOINT_NEEDED"; then
.claude/hooks/post-edit-quality.sh:125:        count=$(echo "$result" | cut -d':' -f2)
.claude/hooks/post-edit-quality.sh:126:        log "  File change tracker: $count files changed - creating checkpoint"
.claude/hooks/post-edit-quality.sh:127:
.claude/hooks/post-edit-quality.sh:128:        # Get list of changed files for advisory
.claude/hooks/post-edit-quality.sh:129:        changed_files=""
.claude/hooks/post-edit-quality.sh:130:        if [[ -x "$FILE_CHANGE_TRACKER" ]]; then
.claude/hooks/post-edit-quality.sh:131:            changed_files=$("$FILE_CHANGE_TRACKER" recent 2>/dev/null | tail -10 | awk '{print $NF}' | tr '\n' ', ' | sed 's/,$//')
.claude/hooks/post-edit-quality.sh:132:        fi
.claude/hooks/post-edit-quality.sh:133:
.claude/hooks/post-edit-quality.sh:134:        # Create memory checkpoint automatically
.claude/hooks/post-edit-quality.sh:135:        if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/post-edit-quality.sh:136:            checkpoint_id=$("$MEMORY_MANAGER" checkpoint "Auto-checkpoint after ${count} file changes" 2>/dev/null || echo "")
.claude/hooks/post-edit-quality.sh:137:
.claude/hooks/post-edit-quality.sh:138:            if [[ -n "$checkpoint_id" ]]; then
.claude/hooks/post-edit-quality.sh:139:                log " Memory checkpoint created: $checkpoint_id"
.claude/hooks/post-edit-quality.sh:140:
.claude/hooks/post-edit-quality.sh:141:                # Include file list in advisory
.claude/hooks/post-edit-quality.sh:142:                if [[ -n "$changed_files" ]]; then
.claude/hooks/post-edit-quality.sh:143:                    echo "{\"advisory\": \" Checkpoint created after ${count} files: $checkpoint_id\\n\\nFiles: ${changed_files}\"}"
.claude/hooks/post-edit-quality.sh:144:                else
.claude/hooks/post-edit-quality.sh:145:                    echo "{\"advisory\": \" Checkpoint created after ${count} files: $checkpoint_id\"}"
.claude/hooks/post-edit-quality.sh:146:                fi
.claude/hooks/post-edit-quality.sh:147:            else
.claude/hooks/post-edit-quality.sh:148:                log "  Failed to create checkpoint"
.claude/hooks/post-edit-quality.sh:149:                echo "{\"advisory\": \" Checkpoint failed after ${count} files changed\"}"
.claude/hooks/post-edit-quality.sh:150:            fi
.claude/hooks/post-edit-quality.sh:151:        else
.claude/hooks/post-edit-quality.sh:152:            # Fallback: recommend manual checkpoint
.claude/hooks/post-edit-quality.sh:153:            echo "{\"advisory\": \" Checkpoint recommended: ${count} files changed. Run /checkpoint to save progress.\"}"
.claude/hooks/post-edit-quality.sh:154:        fi
.claude/hooks/post-edit-quality.sh:155:
.claude/hooks/post-edit-quality.sh:156:        # Reset counter after checkpoint
.claude/hooks/post-edit-quality.sh:157:        "$FILE_CHANGE_TRACKER" reset 2>/dev/null || true
.claude/hooks/post-edit-quality.sh:158:    fi
.claude/hooks/post-edit-quality.sh:159:fi
.claude/hooks/post-edit-quality.sh:160:
.claude/hooks/post-edit-quality.sh:161:# ============================================================================
.claude/hooks/post-edit-quality.sh:162:# UI TESTING - Auto-test after UI component changes
.claude/hooks/post-edit-quality.sh:163:# ============================================================================
.claude/hooks/post-edit-quality.sh:164:UI_TEST_FRAMEWORK="${HOME}/.claude/hooks/ui-test-framework.sh"
.claude/hooks/post-edit-quality.sh:165:
.claude/hooks/post-edit-quality.sh:166:if [[ -x "$UI_TEST_FRAMEWORK" ]] && echo "$FILE_PATH" | grep -qE "(components?|pages?|views?)/.*\.(tsx|jsx)$"; then
.claude/hooks/post-edit-quality.sh:167:    log "UI component modified: $FILE_PATH - checking for test suite"
.claude/hooks/post-edit-quality.sh:168:
.claude/hooks/post-edit-quality.sh:169:    # Extract component name
.claude/hooks/post-edit-quality.sh:170:    component_name=$(basename "$FILE_PATH" | sed 's/\.(tsx|jsx)$//')
.claude/hooks/post-edit-quality.sh:171:    suite_name="${component_name}_tests"
.claude/hooks/post-edit-quality.sh:172:
.claude/hooks/post-edit-quality.sh:173:    # Check if test suite exists
.claude/hooks/post-edit-quality.sh:174:    if "$UI_TEST_FRAMEWORK" list-suites 2>/dev/null | grep -q "$suite_name"; then
.claude/hooks/post-edit-quality.sh:175:        log "Running UI test suite: $suite_name"
.claude/hooks/post-edit-quality.sh:176:
.claude/hooks/post-edit-quality.sh:177:        # Run test suite (no GIF for auto-tests to save time)
.claude/hooks/post-edit-quality.sh:178:        test_result=$("$UI_TEST_FRAMEWORK" run-suite "$suite_name" false 2>&1 || echo "")
.claude/hooks/post-edit-quality.sh:179:
.claude/hooks/post-edit-quality.sh:180:        if echo "$test_result" | grep -q "PASS"; then
.claude/hooks/post-edit-quality.sh:181:            log " UI tests passed for $component_name"
.claude/hooks/post-edit-quality.sh:182:        elif echo "$test_result" | grep -q "FAIL"; then
.claude/hooks/post-edit-quality.sh:183:            log " UI tests failed for $component_name"
.claude/hooks/post-edit-quality.sh:184:            echo "{\"advisory\": \"  UI tests failed for $component_name - check test results\"}"
.claude/hooks/post-edit-quality.sh:185:        fi
.claude/hooks/post-edit-quality.sh:186:    else
.claude/hooks/post-edit-quality.sh:187:        log "No test suite found for $component_name (would be: $suite_name)"
.claude/hooks/post-edit-quality.sh:188:    fi
.claude/hooks/post-edit-quality.sh:189:fi
.claude/hooks/post-edit-quality.sh:190:
.claude/hooks/post-edit-quality.sh:191:exit 0
.claude/hooks/reinforcement-learning.sh.backup:1:#!/bin/bash
.claude/hooks/reinforcement-learning.sh.backup:2:# Reinforcement Learning Tracker - Learn from outcomes
.claude/hooks/reinforcement-learning.sh.backup:3:# Based on: DB-GPT retry patterns, swarms RL patterns
.claude/hooks/reinforcement-learning.sh.backup:4:# Tracks success/failure patterns and adjusts strategies
.claude/hooks/reinforcement-learning.sh.backup:5:
.claude/hooks/reinforcement-learning.sh.backup:6:set -eo pipefail
.claude/hooks/reinforcement-learning.sh.backup:7:
.claude/hooks/reinforcement-learning.sh.backup:8:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/reinforcement-learning.sh.backup:9:MEMORY_MANAGER="${CLAUDE_DIR}/hooks/memory-manager.sh"
.claude/hooks/reinforcement-learning.sh.backup:10:RL_DATA="${CLAUDE_DIR}/.rl/outcomes.jsonl"
.claude/hooks/reinforcement-learning.sh.backup:11:LOG_FILE="${CLAUDE_DIR}/rl-tracker.log"
.claude/hooks/reinforcement-learning.sh.backup:12:
.claude/hooks/reinforcement-learning.sh.backup:13:mkdir -p "$(dirname "$RL_DATA")"
.claude/hooks/reinforcement-learning.sh.backup:14:
.claude/hooks/reinforcement-learning.sh.backup:15:log() {
.claude/hooks/reinforcement-learning.sh.backup:16:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/reinforcement-learning.sh.backup:17:}
.claude/hooks/reinforcement-learning.sh.backup:18:
.claude/hooks/reinforcement-learning.sh.backup:19:# Record outcome
.claude/hooks/reinforcement-learning.sh.backup:20:record_outcome() {
.claude/hooks/reinforcement-learning.sh.backup:21:    local action_type="$1"
.claude/hooks/reinforcement-learning.sh.backup:22:    local context="$2"
.claude/hooks/reinforcement-learning.sh.backup:23:    local outcome="$3"  # success/failure
.claude/hooks/reinforcement-learning.sh.backup:24:    local reward="${4:-0}"  # -1 to 1
.claude/hooks/reinforcement-learning.sh.backup:25:
.claude/hooks/reinforcement-learning.sh.backup:26:    log "Recording outcome: $action_type -> $outcome (reward: $reward)"
.claude/hooks/reinforcement-learning.sh.backup:27:
.claude/hooks/reinforcement-learning.sh.backup:28:    local record
.claude/hooks/reinforcement-learning.sh.backup:29:    record=$(jq -n \
.claude/hooks/reinforcement-learning.sh.backup:30:        --arg type "$action_type" \
.claude/hooks/reinforcement-learning.sh.backup:31:        --arg context "$context" \
.claude/hooks/reinforcement-learning.sh.backup:32:        --arg outcome "$outcome" \
.claude/hooks/reinforcement-learning.sh.backup:33:        --arg reward "$reward" \
.claude/hooks/reinforcement-learning.sh.backup:34:        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/reinforcement-learning.sh.backup:35:        '{
.claude/hooks/reinforcement-learning.sh.backup:36:            timestamp: $ts,
.claude/hooks/reinforcement-learning.sh.backup:37:            action_type: $type,
.claude/hooks/reinforcement-learning.sh.backup:38:            context: $context,
.claude/hooks/reinforcement-learning.sh.backup:39:            outcome: $outcome,
.claude/hooks/reinforcement-learning.sh.backup:40:            reward: ($reward | tonumber)
.claude/hooks/reinforcement-learning.sh.backup:41:        }')
.claude/hooks/reinforcement-learning.sh.backup:42:
.claude/hooks/reinforcement-learning.sh.backup:43:    echo "$record" >> "$RL_DATA"
.claude/hooks/reinforcement-learning.sh.backup:44:
.claude/hooks/reinforcement-learning.sh.backup:45:    # Update memory with pattern
.claude/hooks/reinforcement-learning.sh.backup:46:    if [[ -x "$MEMORY_MANAGER" && "$outcome" == "success" ]]; then
.claude/hooks/reinforcement-learning.sh.backup:47:        "$MEMORY_MANAGER" add-pattern "successful_action" "$action_type in $context" "led to success" "$(echo "scale=2; ($reward + 1) / 2" | bc)" 2>/dev/null || true
.claude/hooks/reinforcement-learning.sh.backup:48:    fi
.claude/hooks/reinforcement-learning.sh.backup:49:}
.claude/hooks/reinforcement-learning.sh.backup:50:
.claude/hooks/reinforcement-learning.sh.backup:51:# Get success rate for action type
.claude/hooks/reinforcement-learning.sh.backup:52:get_success_rate() {
.claude/hooks/reinforcement-learning.sh.backup:53:    local action_type="$1"
.claude/hooks/reinforcement-learning.sh.backup:54:    local window="${2:-20}"
.claude/hooks/reinforcement-learning.sh.backup:55:
.claude/hooks/reinforcement-learning.sh.backup:56:    if [[ ! -f "$RL_DATA" ]]; then
.claude/hooks/reinforcement-learning.sh.backup:57:        echo '{"success_rate":0.5,"confidence":"low","sample_size":0}'
.claude/hooks/reinforcement-learning.sh.backup:58:        return
.claude/hooks/reinforcement-learning.sh.backup:59:    fi
.claude/hooks/reinforcement-learning.sh.backup:60:
.claude/hooks/reinforcement-learning.sh.backup:61:    local stats
.claude/hooks/reinforcement-learning.sh.backup:62:    stats=$(tail -n 100 "$RL_DATA" | jq -s --arg type "$action_type" --argjson window "$window" '
.claude/hooks/reinforcement-learning.sh.backup:63:        map(select(.action_type == $type)) | .[-$window:] | {
.claude/hooks/reinforcement-learning.sh.backup:64:            total: length,
.claude/hooks/reinforcement-learning.sh.backup:65:            successes: (map(select(.outcome == "success")) | length),
.claude/hooks/reinforcement-learning.sh.backup:66:            avg_reward: (map(.reward) | add / length)
.claude/hooks/reinforcement-learning.sh.backup:67:        } | . + {
.claude/hooks/reinforcement-learning.sh.backup:68:            success_rate: (if .total > 0 then .successes / .total else 0.5 end),
.claude/hooks/reinforcement-learning.sh.backup:69:            confidence: (if .total >= 10 then "high" elif .total >= 5 then "medium" else "low" end),
.claude/hooks/reinforcement-learning.sh.backup:70:            sample_size: .total
.claude/hooks/reinforcement-learning.sh.backup:71:        }
.claude/hooks/reinforcement-learning.sh.backup:72:    ')
.claude/hooks/reinforcement-learning.sh.backup:73:
.claude/hooks/reinforcement-learning.sh.backup:74:    echo "$stats"
.claude/hooks/reinforcement-learning.sh.backup:75:}
.claude/hooks/reinforcement-learning.sh.backup:76:
.claude/hooks/reinforcement-learning.sh.backup:77:# Recommend action based on learned patterns
.claude/hooks/reinforcement-learning.sh.backup:78:recommend_action() {
.claude/hooks/reinforcement-learning.sh.backup:79:    local context="$1"
.claude/hooks/reinforcement-learning.sh.backup:80:    local options="$2"  # JSON array of action options
.claude/hooks/reinforcement-learning.sh.backup:81:
.claude/hooks/reinforcement-learning.sh.backup:82:    log "Recommending action for context: $context"
.claude/hooks/reinforcement-learning.sh.backup:83:
.claude/hooks/reinforcement-learning.sh.backup:84:    if [[ ! -f "$RL_DATA" ]]; then
.claude/hooks/reinforcement-learning.sh.backup:85:        echo '{"recommendation":"insufficient_data","confidence":0}'
.claude/hooks/reinforcement-learning.sh.backup:86:        return
.claude/hooks/reinforcement-learning.sh.backup:87:    fi
.claude/hooks/reinforcement-learning.sh.backup:88:
.claude/hooks/reinforcement-learning.sh.backup:89:    # Score each option
.claude/hooks/reinforcement-learning.sh.backup:90:    local recommendations
.claude/hooks/reinforcement-learning.sh.backup:91:    recommendations=$(echo "$options" | jq -r '.[]' | while read -r action; do
.claude/hooks/reinforcement-learning.sh.backup:92:        local stats
.claude/hooks/reinforcement-learning.sh.backup:93:        stats=$(get_success_rate "$action")
.claude/hooks/reinforcement-learning.sh.backup:94:        echo "$stats" | jq --arg action "$action" '. + {action: $action}'
.claude/hooks/reinforcement-learning.sh.backup:95:    done | jq -s 'sort_by(-.success_rate)')
.claude/hooks/reinforcement-learning.sh.backup:96:
.claude/hooks/reinforcement-learning.sh.backup:97:    local best
.claude/hooks/reinforcement-learning.sh.backup:98:    best=$(echo "$recommendations" | jq '.[0]')
.claude/hooks/reinforcement-learning.sh.backup:99:
.claude/hooks/reinforcement-learning.sh.backup:100:    echo "$best"
.claude/hooks/reinforcement-learning.sh.backup:101:}
.claude/hooks/reinforcement-learning.sh.backup:102:
.claude/hooks/reinforcement-learning.sh.backup:103:case "${1:-help}" in
.claude/hooks/reinforcement-learning.sh.backup:104:    record)
.claude/hooks/reinforcement-learning.sh.backup:105:        record_outcome "${2:-action}" "${3:-context}" "${4:-success}" "${5:-0}"
.claude/hooks/reinforcement-learning.sh.backup:106:        ;;
.claude/hooks/reinforcement-learning.sh.backup:107:    success-rate)
.claude/hooks/reinforcement-learning.sh.backup:108:        get_success_rate "${2:-action}" "${3:-20}"
.claude/hooks/reinforcement-learning.sh.backup:109:        ;;
.claude/hooks/reinforcement-learning.sh.backup:110:    recommend)
.claude/hooks/reinforcement-learning.sh.backup:111:        recommend_action "${2:-context}" "${3:-[]}"
.claude/hooks/reinforcement-learning.sh.backup:112:        ;;
.claude/hooks/reinforcement-learning.sh.backup:113:    help|*)
.claude/hooks/reinforcement-learning.sh.backup:114:        echo "Reinforcement Learning Tracker"
.claude/hooks/reinforcement-learning.sh.backup:115:        echo "Usage: $0 <command> [args]"
.claude/hooks/reinforcement-learning.sh.backup:116:        echo "  record <action> <context> <outcome> [reward]"
.claude/hooks/reinforcement-learning.sh.backup:117:        echo "  success-rate <action> [window]"
.claude/hooks/reinforcement-learning.sh.backup:118:        echo "  recommend <context> <options_json>"
.claude/hooks/reinforcement-learning.sh.backup:119:        ;;
.claude/hooks/reinforcement-learning.sh.backup:120:esac
.claude/hooks/reinforcement-learning.sh:1:#!/bin/bash
.claude/hooks/reinforcement-learning.sh:2:set -eo pipefail
.claude/hooks/reinforcement-learning.sh:3:
.claude/hooks/reinforcement-learning.sh:4:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/reinforcement-learning.sh:5:RL_DATA="${CLAUDE_DIR}/.rl/outcomes.jsonl"
.claude/hooks/reinforcement-learning.sh:6:LOG_FILE="${CLAUDE_DIR}/rl-tracker.log"
.claude/hooks/reinforcement-learning.sh:7:
.claude/hooks/reinforcement-learning.sh:8:mkdir -p "$(dirname "$RL_DATA")"
.claude/hooks/reinforcement-learning.sh:9:
.claude/hooks/reinforcement-learning.sh:10:log() {
.claude/hooks/reinforcement-learning.sh:11:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/reinforcement-learning.sh:12:}
.claude/hooks/reinforcement-learning.sh:13:
.claude/hooks/reinforcement-learning.sh:14:record_outcome() {
.claude/hooks/reinforcement-learning.sh:15:    local action_type="$1"
.claude/hooks/reinforcement-learning.sh:16:    local context="$2"
.claude/hooks/reinforcement-learning.sh:17:    local outcome="$3"
.claude/hooks/reinforcement-learning.sh:18:    local reward="${4:-0}"
.claude/hooks/reinforcement-learning.sh:19:    
.claude/hooks/reinforcement-learning.sh:20:    log "Recording: $action_type -> $outcome"
.claude/hooks/reinforcement-learning.sh:21:    
.claude/hooks/reinforcement-learning.sh:22:    jq -n \
.claude/hooks/reinforcement-learning.sh:23:        --arg type "$action_type" \
.claude/hooks/reinforcement-learning.sh:24:        --arg ctx "$context" \
.claude/hooks/reinforcement-learning.sh:25:        --arg outcome "$outcome" \
.claude/hooks/reinforcement-learning.sh:26:        --arg reward "$reward" \
.claude/hooks/reinforcement-learning.sh:27:        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/reinforcement-learning.sh:28:        '{timestamp: $ts, action_type: $type, context: $ctx, outcome: $outcome, reward: ($reward | tonumber)}' >> "$RL_DATA"
.claude/hooks/reinforcement-learning.sh:29:    
.claude/hooks/reinforcement-learning.sh:30:    echo '{"status":"recorded"}'
.claude/hooks/reinforcement-learning.sh:31:}
.claude/hooks/reinforcement-learning.sh:32:
.claude/hooks/reinforcement-learning.sh:33:get_success_rate() {
.claude/hooks/reinforcement-learning.sh:34:    local action_type="$1"
.claude/hooks/reinforcement-learning.sh:35:    local window="${2:-20}"
.claude/hooks/reinforcement-learning.sh:36:    
.claude/hooks/reinforcement-learning.sh:37:    if [[ ! -f "$RL_DATA" ]]; then
.claude/hooks/reinforcement-learning.sh:38:        echo '{"success_rate":0.5,"confidence":"low","sample_size":0}'
.claude/hooks/reinforcement-learning.sh:39:        return
.claude/hooks/reinforcement-learning.sh:40:    fi
.claude/hooks/reinforcement-learning.sh:41:    
.claude/hooks/reinforcement-learning.sh:42:    tail -n 100 "$RL_DATA" | jq -s --arg type "$action_type" --argjson window "$window" '
.claude/hooks/reinforcement-learning.sh:43:        map(select(.action_type == $type)) | .[-$window:] | 
.claude/hooks/reinforcement-learning.sh:44:        {total: length, successes: (map(select(.outcome == "success")) | length)} |
.claude/hooks/reinforcement-learning.sh:45:        . + {success_rate: (if .total > 0 then .successes / .total else 0.5 end), 
.claude/hooks/reinforcement-learning.sh:46:             confidence: (if .total >= 10 then "high" elif .total >= 5 then "medium" else "low" end),
.claude/hooks/reinforcement-learning.sh:47:             sample_size: .total}'
.claude/hooks/reinforcement-learning.sh:48:}
.claude/hooks/reinforcement-learning.sh:49:
.claude/hooks/reinforcement-learning.sh:50:case "${1:-help}" in
.claude/hooks/reinforcement-learning.sh:51:    record) record_outcome "${2:-action}" "${3:-ctx}" "${4:-success}" "${5:-0}" ;;
.claude/hooks/reinforcement-learning.sh:52:    success-rate) get_success_rate "${2:-action}" "${3:-20}" ;;
.claude/hooks/reinforcement-learning.sh:53:    *) echo "Usage: $0 {record|success-rate}" ;;
.claude/hooks/reinforcement-learning.sh:54:esac
.claude/hooks/reasoning-mode-switcher.sh:1:#!/bin/bash
.claude/hooks/reasoning-mode-switcher.sh:2:# Dynamic Reasoning Mode Switcher - Context-aware reasoning strategy selection
.claude/hooks/reasoning-mode-switcher.sh:3:# Based on: servicesground agentic patterns, emergentmind ReAct architectures
.claude/hooks/reasoning-mode-switcher.sh:4:# Switches between reflexive, deliberate, and reactive modes
.claude/hooks/reasoning-mode-switcher.sh:5:
.claude/hooks/reasoning-mode-switcher.sh:6:set -eo pipefail
.claude/hooks/reasoning-mode-switcher.sh:7:
.claude/hooks/reasoning-mode-switcher.sh:8:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/reasoning-mode-switcher.sh:9:LOG_FILE="${CLAUDE_DIR}/reasoning-modes.log"
.claude/hooks/reasoning-mode-switcher.sh:10:
.claude/hooks/reasoning-mode-switcher.sh:11:log() {
.claude/hooks/reasoning-mode-switcher.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/reasoning-mode-switcher.sh:13:}
.claude/hooks/reasoning-mode-switcher.sh:14:
.claude/hooks/reasoning-mode-switcher.sh:15:# Reasoning mode definitions
.claude/hooks/reasoning-mode-switcher.sh:16:get_reasoning_modes() {
.claude/hooks/reasoning-mode-switcher.sh:17:    cat << 'EOF'
.claude/hooks/reasoning-mode-switcher.sh:18:{
.claude/hooks/reasoning-mode-switcher.sh:19:    "modes": {
.claude/hooks/reasoning-mode-switcher.sh:20:        "reflexive": {
.claude/hooks/reasoning-mode-switcher.sh:21:            "description": "Fast, intuitive decision-making for simple tasks",
.claude/hooks/reasoning-mode-switcher.sh:22:            "use_when": [
.claude/hooks/reasoning-mode-switcher.sh:23:                "Task is straightforward",
.claude/hooks/reasoning-mode-switcher.sh:24:                "Similar task succeeded before",
.claude/hooks/reasoning-mode-switcher.sh:25:                "Low risk/impact",
.claude/hooks/reasoning-mode-switcher.sh:26:                "Time-critical"
.claude/hooks/reasoning-mode-switcher.sh:27:            ],
.claude/hooks/reasoning-mode-switcher.sh:28:            "characteristics": {
.claude/hooks/reasoning-mode-switcher.sh:29:                "speed": "fast",
.claude/hooks/reasoning-mode-switcher.sh:30:                "thoroughness": "low",
.claude/hooks/reasoning-mode-switcher.sh:31:                "exploration": "minimal"
.claude/hooks/reasoning-mode-switcher.sh:32:            },
.claude/hooks/reasoning-mode-switcher.sh:33:            "tools": ["direct_execution", "pattern_matching"]
.claude/hooks/reasoning-mode-switcher.sh:34:        },
.claude/hooks/reasoning-mode-switcher.sh:35:        "deliberate": {
.claude/hooks/reasoning-mode-switcher.sh:36:            "description": "Careful, step-by-step reasoning with verification",
.claude/hooks/reasoning-mode-switcher.sh:37:            "use_when": [
.claude/hooks/reasoning-mode-switcher.sh:38:                "Complex problem",
.claude/hooks/reasoning-mode-switcher.sh:39:                "Multiple valid approaches",
.claude/hooks/reasoning-mode-switcher.sh:40:                "High risk/impact",
.claude/hooks/reasoning-mode-switcher.sh:41:                "Novel situation"
.claude/hooks/reasoning-mode-switcher.sh:42:            ],
.claude/hooks/reasoning-mode-switcher.sh:43:            "characteristics": {
.claude/hooks/reasoning-mode-switcher.sh:44:                "speed": "slow",
.claude/hooks/reasoning-mode-switcher.sh:45:                "thoroughness": "high",
.claude/hooks/reasoning-mode-switcher.sh:46:                "exploration": "extensive"
.claude/hooks/reasoning-mode-switcher.sh:47:            },
.claude/hooks/reasoning-mode-switcher.sh:48:            "tools": ["tree_of_thoughts", "chain_of_thought", "self_reflection"]
.claude/hooks/reasoning-mode-switcher.sh:49:        },
.claude/hooks/reasoning-mode-switcher.sh:50:        "reactive": {
.claude/hooks/reasoning-mode-switcher.sh:51:            "description": "Rapid response to immediate needs",
.claude/hooks/reasoning-mode-switcher.sh:52:            "use_when": [
.claude/hooks/reasoning-mode-switcher.sh:53:                "Emergency/urgent",
.claude/hooks/reasoning-mode-switcher.sh:54:                "Clear single path forward",
.claude/hooks/reasoning-mode-switcher.sh:55:                "Undo-able action",
.claude/hooks/reasoning-mode-switcher.sh:56:                "Low complexity"
.claude/hooks/reasoning-mode-switcher.sh:57:            ],
.claude/hooks/reasoning-mode-switcher.sh:58:            "characteristics": {
.claude/hooks/reasoning-mode-switcher.sh:59:                "speed": "very_fast",
.claude/hooks/reasoning-mode-switcher.sh:60:                "thoroughness": "minimal",
.claude/hooks/reasoning-mode-switcher.sh:61:                "exploration": "none"
.claude/hooks/reasoning-mode-switcher.sh:62:            },
.claude/hooks/reasoning-mode-switcher.sh:63:            "tools": ["direct_action"]
.claude/hooks/reasoning-mode-switcher.sh:64:        }
.claude/hooks/reasoning-mode-switcher.sh:65:    }
.claude/hooks/reasoning-mode-switcher.sh:66:}
.claude/hooks/reasoning-mode-switcher.sh:67:EOF
.claude/hooks/reasoning-mode-switcher.sh:68:}
.claude/hooks/reasoning-mode-switcher.sh:69:
.claude/hooks/reasoning-mode-switcher.sh:70:# Select reasoning mode based on context
.claude/hooks/reasoning-mode-switcher.sh:71:select_mode() {
.claude/hooks/reasoning-mode-switcher.sh:72:    local task="$1"
.claude/hooks/reasoning-mode-switcher.sh:73:    local context="$2"
.claude/hooks/reasoning-mode-switcher.sh:74:    local urgency="${3:-normal}"
.claude/hooks/reasoning-mode-switcher.sh:75:    local complexity="${4:-medium}"
.claude/hooks/reasoning-mode-switcher.sh:76:    local risk="${5:-medium}"
.claude/hooks/reasoning-mode-switcher.sh:77:
.claude/hooks/reasoning-mode-switcher.sh:78:    log "Selecting reasoning mode for: $task (urgency=$urgency, complexity=$complexity, risk=$risk)"
.claude/hooks/reasoning-mode-switcher.sh:79:
.claude/hooks/reasoning-mode-switcher.sh:80:    local selected_mode="deliberate"
.claude/hooks/reasoning-mode-switcher.sh:81:
.claude/hooks/reasoning-mode-switcher.sh:82:    # Decision logic
.claude/hooks/reasoning-mode-switcher.sh:83:    if [[ "$urgency" == "high" || "$urgency" == "critical" ]]; then
.claude/hooks/reasoning-mode-switcher.sh:84:        selected_mode="reactive"
.claude/hooks/reasoning-mode-switcher.sh:85:    elif [[ "$complexity" == "low" && "$risk" == "low" ]]; then
.claude/hooks/reasoning-mode-switcher.sh:86:        selected_mode="reflexive"
.claude/hooks/reasoning-mode-switcher.sh:87:    elif [[ "$complexity" == "high" || "$risk" == "high" ]]; then
.claude/hooks/reasoning-mode-switcher.sh:88:        selected_mode="deliberate"
.claude/hooks/reasoning-mode-switcher.sh:89:    fi
.claude/hooks/reasoning-mode-switcher.sh:90:
.claude/hooks/reasoning-mode-switcher.sh:91:    local modes
.claude/hooks/reasoning-mode-switcher.sh:92:    modes=$(get_reasoning_modes)
.claude/hooks/reasoning-mode-switcher.sh:93:
.claude/hooks/reasoning-mode-switcher.sh:94:    echo "$modes" | jq --arg mode "$selected_mode" '{
.claude/hooks/reasoning-mode-switcher.sh:95:        selected_mode: $mode,
.claude/hooks/reasoning-mode-switcher.sh:96:        mode_info: .modes[$mode],
.claude/hooks/reasoning-mode-switcher.sh:97:        decision_factors: {
.claude/hooks/reasoning-mode-switcher.sh:98:            urgency: "'"$urgency"'",
.claude/hooks/reasoning-mode-switcher.sh:99:            complexity: "'"$complexity"'",
.claude/hooks/reasoning-mode-switcher.sh:100:            risk: "'"$risk"'"
.claude/hooks/reasoning-mode-switcher.sh:101:        }
.claude/hooks/reasoning-mode-switcher.sh:102:    }'
.claude/hooks/reasoning-mode-switcher.sh:103:}
.claude/hooks/reasoning-mode-switcher.sh:104:
.claude/hooks/reasoning-mode-switcher.sh:105:# Analyze task to determine characteristics
.claude/hooks/reasoning-mode-switcher.sh:106:analyze_task_characteristics() {
.claude/hooks/reasoning-mode-switcher.sh:107:    local task="$1"
.claude/hooks/reasoning-mode-switcher.sh:108:
.claude/hooks/reasoning-mode-switcher.sh:109:    cat << EOF
.claude/hooks/reasoning-mode-switcher.sh:110:{
.claude/hooks/reasoning-mode-switcher.sh:111:    "analysis_prompt": "Analyze this task to determine reasoning mode:
.claude/hooks/reasoning-mode-switcher.sh:112:
.claude/hooks/reasoning-mode-switcher.sh:113:**Task:** $task
.claude/hooks/reasoning-mode-switcher.sh:114:
.claude/hooks/reasoning-mode-switcher.sh:115:Rate each dimension (low/medium/high):
.claude/hooks/reasoning-mode-switcher.sh:116:
.claude/hooks/reasoning-mode-switcher.sh:117:1. **Complexity**: How complex is this task?
.claude/hooks/reasoning-mode-switcher.sh:118:   - Low: Simple, well-defined
.claude/hooks/reasoning-mode-switcher.sh:119:   - Medium: Moderate difficulty, some unknowns
.claude/hooks/reasoning-mode-switcher.sh:120:   - High: Complex, multiple approaches, many unknowns
.claude/hooks/reasoning-mode-switcher.sh:121:
.claude/hooks/reasoning-mode-switcher.sh:122:2. **Risk**: What's the impact if we get it wrong?
.claude/hooks/reasoning-mode-switcher.sh:123:   - Low: Easy to undo, minimal impact
.claude/hooks/reasoning-mode-switcher.sh:124:   - Medium: Some rework needed, moderate impact
.claude/hooks/reasoning-mode-switcher.sh:125:   - High: Hard to undo, significant impact
.claude/hooks/reasoning-mode-switcher.sh:126:
.claude/hooks/reasoning-mode-switcher.sh:127:3. **Urgency**: How time-critical is this?
.claude/hooks/reasoning-mode-switcher.sh:128:   - Low: Can take time to do it right
.claude/hooks/reasoning-mode-switcher.sh:129:   - Normal: Standard timeframe
.claude/hooks/reasoning-mode-switcher.sh:130:   - High/Critical: Immediate action needed
.claude/hooks/reasoning-mode-switcher.sh:131:
.claude/hooks/reasoning-mode-switcher.sh:132:4. **Novelty**: How familiar is this task?
.claude/hooks/reasoning-mode-switcher.sh:133:   - Familiar: Done similar tasks before
.claude/hooks/reasoning-mode-switcher.sh:134:   - Somewhat_novel: Some new aspects
.claude/hooks/reasoning-mode-switcher.sh:135:   - Novel: Completely new situation
.claude/hooks/reasoning-mode-switcher.sh:136:
.claude/hooks/reasoning-mode-switcher.sh:137:Return JSON:
.claude/hooks/reasoning-mode-switcher.sh:138:{
.claude/hooks/reasoning-mode-switcher.sh:139:    \"complexity\": \"low|medium|high\",
.claude/hooks/reasoning-mode-switcher.sh:140:    \"risk\": \"low|medium|high\",
.claude/hooks/reasoning-mode-switcher.sh:141:    \"urgency\": \"low|normal|high|critical\",
.claude/hooks/reasoning-mode-switcher.sh:142:    \"novelty\": \"familiar|somewhat_novel|novel\",
.claude/hooks/reasoning-mode-switcher.sh:143:    \"recommended_mode\": \"reflexive|deliberate|reactive\",
.claude/hooks/reasoning-mode-switcher.sh:144:    \"reasoning\": \"Why this mode is appropriate\"
.claude/hooks/reasoning-mode-switcher.sh:145:}"
.claude/hooks/reasoning-mode-switcher.sh:146:}
.claude/hooks/reasoning-mode-switcher.sh:147:EOF
.claude/hooks/reasoning-mode-switcher.sh:148:}
.claude/hooks/reasoning-mode-switcher.sh:149:
.claude/hooks/reasoning-mode-switcher.sh:150:case "${1:-help}" in
.claude/hooks/reasoning-mode-switcher.sh:151:    modes)
.claude/hooks/reasoning-mode-switcher.sh:152:        get_reasoning_modes
.claude/hooks/reasoning-mode-switcher.sh:153:        ;;
.claude/hooks/reasoning-mode-switcher.sh:154:    select)
.claude/hooks/reasoning-mode-switcher.sh:155:        select_mode "${2:-task}" "${3:-context}" "${4:-normal}" "${5:-medium}" "${6:-medium}"
.claude/hooks/reasoning-mode-switcher.sh:156:        ;;
.claude/hooks/reasoning-mode-switcher.sh:157:    analyze)
.claude/hooks/reasoning-mode-switcher.sh:158:        analyze_task_characteristics "${2:-task}"
.claude/hooks/reasoning-mode-switcher.sh:159:        ;;
.claude/hooks/reasoning-mode-switcher.sh:160:    help|*)
.claude/hooks/reasoning-mode-switcher.sh:161:        echo "Dynamic Reasoning Mode Switcher"
.claude/hooks/reasoning-mode-switcher.sh:162:        echo "Usage: $0 <command> [args]"
.claude/hooks/reasoning-mode-switcher.sh:163:        echo "  modes                     - List all reasoning modes"
.claude/hooks/reasoning-mode-switcher.sh:164:        echo "  select <task> <context> [urgency] [complexity] [risk]"
.claude/hooks/reasoning-mode-switcher.sh:165:        echo "  analyze <task>            - Analyze task characteristics"
.claude/hooks/reasoning-mode-switcher.sh:166:        ;;
.claude/hooks/reasoning-mode-switcher.sh:167:esac
.claude/hooks/parallel-execution-planner.sh.backup:1:#!/bin/bash
.claude/hooks/parallel-execution-planner.sh.backup:2:# Parallel Execution Planner - Detect and execute independent tasks in parallel
.claude/hooks/parallel-execution-planner.sh.backup:3:# Based on: swarms parallel patterns, agno workflow parallel execution
.claude/hooks/parallel-execution-planner.sh.backup:4:# Analyzes task dependencies and parallelizes where possible
.claude/hooks/parallel-execution-planner.sh.backup:5:
.claude/hooks/parallel-execution-planner.sh.backup:6:set -eo pipefail
.claude/hooks/parallel-execution-planner.sh.backup:7:
.claude/hooks/parallel-execution-planner.sh.backup:8:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/parallel-execution-planner.sh.backup:9:LOG_FILE="${CLAUDE_DIR}/parallel-planner.log"
.claude/hooks/parallel-execution-planner.sh.backup:10:
.claude/hooks/parallel-execution-planner.sh.backup:11:log() {
.claude/hooks/parallel-execution-planner.sh.backup:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/parallel-execution-planner.sh.backup:13:}
.claude/hooks/parallel-execution-planner.sh.backup:14:
.claude/hooks/parallel-execution-planner.sh.backup:15:# Analyze task dependencies
.claude/hooks/parallel-execution-planner.sh.backup:16:analyze_dependencies() {
.claude/hooks/parallel-execution-planner.sh.backup:17:    local tasks_json="$1"
.claude/hooks/parallel-execution-planner.sh.backup:18:
.claude/hooks/parallel-execution-planner.sh.backup:19:    log "Analyzing task dependencies"
.claude/hooks/parallel-execution-planner.sh.backup:20:
.claude/hooks/parallel-execution-planner.sh.backup:21:    cat << EOF
.claude/hooks/parallel-execution-planner.sh.backup:22:{
.claude/hooks/parallel-execution-planner.sh.backup:23:    "analysis_prompt": "Analyze these tasks for dependencies:
.claude/hooks/parallel-execution-planner.sh.backup:24:
.claude/hooks/parallel-execution-planner.sh.backup:25:Tasks:
.claude/hooks/parallel-execution-planner.sh.backup:26:$(echo "$tasks_json" | jq -r '.tasks[] | "- \(.id): \(.description)"')
.claude/hooks/parallel-execution-planner.sh.backup:27:
.claude/hooks/parallel-execution-planner.sh.backup:28:For each task, identify:
.claude/hooks/parallel-execution-planner.sh.backup:29:1. **Prerequisites**: Which tasks must complete BEFORE this one?
.claude/hooks/parallel-execution-planner.sh.backup:30:2. **Independencies**: Which tasks can run in parallel with this one?
.claude/hooks/parallel-execution-planner.sh.backup:31:3. **File conflicts**: Does this task modify files that another task reads/writes?
.claude/hooks/parallel-execution-planner.sh.backup:32:
.claude/hooks/parallel-execution-planner.sh.backup:33:Return JSON:
.claude/hooks/parallel-execution-planner.sh.backup:34:{
.claude/hooks/parallel-execution-planner.sh.backup:35:    \"tasks\": [
.claude/hooks/parallel-execution-planner.sh.backup:36:        {
.claude/hooks/parallel-execution-planner.sh.backup:37:            \"id\": \"task_1\",
.claude/hooks/parallel-execution-planner.sh.backup:38:            \"depends_on\": [],
.claude/hooks/parallel-execution-planner.sh.backup:39:            \"can_parallel_with\": [\"task_2\", \"task_3\"],
.claude/hooks/parallel-execution-planner.sh.backup:40:            \"file_dependencies\": [\"file1.js\"]
.claude/hooks/parallel-execution-planner.sh.backup:41:        }
.claude/hooks/parallel-execution-planner.sh.backup:42:    ],
.claude/hooks/parallel-execution-planner.sh.backup:43:    \"execution_groups\": [
.claude/hooks/parallel-execution-planner.sh.backup:44:        {
.claude/hooks/parallel-execution-planner.sh.backup:45:            \"group\": 1,
.claude/hooks/parallel-execution-planner.sh.backup:46:            \"parallel\": [\"task_1\", \"task_2\"],
.claude/hooks/parallel-execution-planner.sh.backup:47:            \"reason\": \"Independent tasks, no shared files\"
.claude/hooks/parallel-execution-planner.sh.backup:48:        },
.claude/hooks/parallel-execution-planner.sh.backup:49:        {
.claude/hooks/parallel-execution-planner.sh.backup:50:            \"group\": 2,
.claude/hooks/parallel-execution-planner.sh.backup:51:            \"parallel\": [\"task_3\"],
.claude/hooks/parallel-execution-planner.sh.backup:52:            \"reason\": \"Depends on group 1 completion\"
.claude/hooks/parallel-execution-planner.sh.backup:53:        }
.claude/hooks/parallel-execution-planner.sh.backup:54:    ]
.claude/hooks/parallel-execution-planner.sh.backup:55:}",
.claude/hooks/parallel-execution-planner.sh.backup:56:    "tasks": $(echo "$tasks_json" | jq -c '.')
.claude/hooks/parallel-execution-planner.sh.backup:57:}
.claude/hooks/parallel-execution-planner.sh.backup:58:EOF
.claude/hooks/parallel-execution-planner.sh.backup:59:}
.claude/hooks/parallel-execution-planner.sh.backup:60:
.claude/hooks/parallel-execution-planner.sh.backup:61:# Generate execution plan
.claude/hooks/parallel-execution-planner.sh.backup:62:generate_execution_plan() {
.claude/hooks/parallel-execution-planner.sh.backup:63:    local dependency_analysis="$1"
.claude/hooks/parallel-execution-planner.sh.backup:64:
.claude/hooks/parallel-execution-planner.sh.backup:65:    log "Generating parallel execution plan"
.claude/hooks/parallel-execution-planner.sh.backup:66:
.claude/hooks/parallel-execution-planner.sh.backup:67:    echo "$dependency_analysis" | jq '{
.claude/hooks/parallel-execution-planner.sh.backup:68:        strategy: "parallel_execution",
.claude/hooks/parallel-execution-planner.sh.backup:69:        groups: .execution_groups,
.claude/hooks/parallel-execution-planner.sh.backup:70:        estimated_speedup: ((.tasks | length) / (.execution_groups | length)),
.claude/hooks/parallel-execution-planner.sh.backup:71:        instructions: "Execute each group in sequence, but tasks within a group run in parallel"
.claude/hooks/parallel-execution-planner.sh.backup:72:    }'
.claude/hooks/parallel-execution-planner.sh.backup:73:}
.claude/hooks/parallel-execution-planner.sh.backup:74:
.claude/hooks/parallel-execution-planner.sh.backup:75:case "${1:-help}" in
.claude/hooks/parallel-execution-planner.sh.backup:76:    analyze)
.claude/hooks/parallel-execution-planner.sh.backup:77:        analyze_dependencies "${2:-{}}"
.claude/hooks/parallel-execution-planner.sh.backup:78:        ;;
.claude/hooks/parallel-execution-planner.sh.backup:79:    plan)
.claude/hooks/parallel-execution-planner.sh.backup:80:        generate_execution_plan "${2:-{}}"
.claude/hooks/parallel-execution-planner.sh.backup:81:        ;;
.claude/hooks/parallel-execution-planner.sh.backup:82:    help|*)
.claude/hooks/parallel-execution-planner.sh.backup:83:        echo "Parallel Execution Planner"
.claude/hooks/parallel-execution-planner.sh.backup:84:        echo "Usage: $0 <command> [args]"
.claude/hooks/parallel-execution-planner.sh.backup:85:        echo "  analyze <tasks_json>      - Analyze dependencies"
.claude/hooks/parallel-execution-planner.sh.backup:86:        echo "  plan <analysis_json>      - Generate execution plan"
.claude/hooks/parallel-execution-planner.sh.backup:87:        ;;
.claude/hooks/parallel-execution-planner.sh.backup:88:esac
.claude/hooks/retry-command.sh:1:#!/bin/bash
.claude/hooks/retry-command.sh:2:# Retry Command with Backoff - Wraps any command with smart retry logic
.claude/hooks/retry-command.sh:3:# Usage: retry-command.sh [max_retries] [command...]
.claude/hooks/retry-command.sh:4:# Example: retry-command.sh 3 npm test
.claude/hooks/retry-command.sh:5:
.claude/hooks/retry-command.sh:6:set -uo pipefail
.claude/hooks/retry-command.sh:7:
.claude/hooks/retry-command.sh:8:SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
.claude/hooks/retry-command.sh:9:ERROR_HANDLER="$SCRIPT_DIR/error-handler.sh"
.claude/hooks/retry-command.sh:10:LOG_FILE="${HOME}/.claude/retry-command.log"
.claude/hooks/retry-command.sh:11:
.claude/hooks/retry-command.sh:12:log() {
.claude/hooks/retry-command.sh:13:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/retry-command.sh:14:}
.claude/hooks/retry-command.sh:15:
.claude/hooks/retry-command.sh:16:# Parse arguments
.claude/hooks/retry-command.sh:17:MAX_RETRIES="${1:-3}"
.claude/hooks/retry-command.sh:18:shift
.claude/hooks/retry-command.sh:19:COMMAND=("$@")
.claude/hooks/retry-command.sh:20:
.claude/hooks/retry-command.sh:21:if [[ ${#COMMAND[@]} -eq 0 ]]; then
.claude/hooks/retry-command.sh:22:    echo "Usage: retry-command.sh [max_retries] [command...]"
.claude/hooks/retry-command.sh:23:    exit 1
.claude/hooks/retry-command.sh:24:fi
.claude/hooks/retry-command.sh:25:
.claude/hooks/retry-command.sh:26:ATTEMPT=0
.claude/hooks/retry-command.sh:27:LAST_ERROR=""
.claude/hooks/retry-command.sh:28:
.claude/hooks/retry-command.sh:29:while [[ $ATTEMPT -lt $MAX_RETRIES ]]; do
.claude/hooks/retry-command.sh:30:    log "Attempt $((ATTEMPT + 1))/$MAX_RETRIES: ${COMMAND[*]}"
.claude/hooks/retry-command.sh:31:
.claude/hooks/retry-command.sh:32:    # Run command and capture output
.claude/hooks/retry-command.sh:33:    set +e
.claude/hooks/retry-command.sh:34:    OUTPUT=$("${COMMAND[@]}" 2>&1)
.claude/hooks/retry-command.sh:35:    EXIT_CODE=$?
.claude/hooks/retry-command.sh:36:    set -e
.claude/hooks/retry-command.sh:37:
.claude/hooks/retry-command.sh:38:    if [[ $EXIT_CODE -eq 0 ]]; then
.claude/hooks/retry-command.sh:39:        echo "$OUTPUT"
.claude/hooks/retry-command.sh:40:        log "Success on attempt $((ATTEMPT + 1))"
.claude/hooks/retry-command.sh:41:        exit 0
.claude/hooks/retry-command.sh:42:    fi
.claude/hooks/retry-command.sh:43:
.claude/hooks/retry-command.sh:44:    LAST_ERROR="$OUTPUT"
.claude/hooks/retry-command.sh:45:    log "Failed with exit code $EXIT_CODE"
.claude/hooks/retry-command.sh:46:
.claude/hooks/retry-command.sh:47:    # Use error handler to classify and determine retry
.claude/hooks/retry-command.sh:48:    if [[ -x "$ERROR_HANDLER" ]]; then
.claude/hooks/retry-command.sh:49:        HANDLER_OUTPUT=$("$ERROR_HANDLER" "$LAST_ERROR" "$ATTEMPT" "$MAX_RETRIES" "${COMMAND[*]}")
.claude/hooks/retry-command.sh:50:
.claude/hooks/retry-command.sh:51:        SHOULD_RETRY=$(echo "$HANDLER_OUTPUT" | jq -r '.shouldRetry')
.claude/hooks/retry-command.sh:52:        BACKOFF_MS=$(echo "$HANDLER_OUTPUT" | jq -r '.backoffMs')
.claude/hooks/retry-command.sh:53:        CLASSIFICATION=$(echo "$HANDLER_OUTPUT" | jq -r '.classification')
.claude/hooks/retry-command.sh:54:
.claude/hooks/retry-command.sh:55:        log "Classification: $CLASSIFICATION, Retry: $SHOULD_RETRY, Backoff: ${BACKOFF_MS}ms"
.claude/hooks/retry-command.sh:56:
.claude/hooks/retry-command.sh:57:        if [[ "$SHOULD_RETRY" != "true" ]]; then
.claude/hooks/retry-command.sh:58:            echo "Error not retryable ($CLASSIFICATION):"
.claude/hooks/retry-command.sh:59:            echo "$LAST_ERROR"
.claude/hooks/retry-command.sh:60:            exit $EXIT_CODE
.claude/hooks/retry-command.sh:61:        fi
.claude/hooks/retry-command.sh:62:
.claude/hooks/retry-command.sh:63:        # Wait with backoff
.claude/hooks/retry-command.sh:64:        BACKOFF_SEC=$((BACKOFF_MS / 1000))
.claude/hooks/retry-command.sh:65:        if [[ $BACKOFF_SEC -gt 0 ]]; then
.claude/hooks/retry-command.sh:66:            log "Waiting ${BACKOFF_SEC}s before retry..."
.claude/hooks/retry-command.sh:67:            sleep $BACKOFF_SEC
.claude/hooks/retry-command.sh:68:        fi
.claude/hooks/retry-command.sh:69:    else
.claude/hooks/retry-command.sh:70:        # Fallback: simple retry with fixed delay
.claude/hooks/retry-command.sh:71:        sleep $((2 ** ATTEMPT))
.claude/hooks/retry-command.sh:72:    fi
.claude/hooks/retry-command.sh:73:
.claude/hooks/retry-command.sh:74:    ATTEMPT=$((ATTEMPT + 1))
.claude/hooks/retry-command.sh:75:done
.claude/hooks/retry-command.sh:76:
.claude/hooks/retry-command.sh:77:# All retries exhausted
.claude/hooks/retry-command.sh:78:echo "All $MAX_RETRIES attempts failed:"
.claude/hooks/retry-command.sh:79:echo "$LAST_ERROR"
.claude/hooks/retry-command.sh:80:log "All retries exhausted for: ${COMMAND[*]}"
.claude/hooks/retry-command.sh:81:exit 1
.claude/hooks/feedback-loop.sh:1:#!/bin/bash
.claude/hooks/feedback-loop.sh:2:# Feedback Loop - Captures outcomes and feeds back to learning
.claude/hooks/feedback-loop.sh:3:# Continuously improves system by learning from every operation
.claude/hooks/feedback-loop.sh:4:
.claude/hooks/feedback-loop.sh:5:set -uo pipefail
.claude/hooks/feedback-loop.sh:6:
.claude/hooks/feedback-loop.sh:7:FEEDBACK_DIR="${HOME}/.claude/feedback"
.claude/hooks/feedback-loop.sh:8:OUTCOMES_FILE="$FEEDBACK_DIR/outcomes.jsonl"
.claude/hooks/feedback-loop.sh:9:AGGREGATED_FILE="$FEEDBACK_DIR/aggregated.json"
.claude/hooks/feedback-loop.sh:10:LOG_FILE="${HOME}/.claude/feedback-loop.log"
.claude/hooks/feedback-loop.sh:11:
.claude/hooks/feedback-loop.sh:12:# Integration with other hooks
.claude/hooks/feedback-loop.sh:13:LEARNING_ENGINE="${HOME}/.claude/hooks/learning-engine.sh"
.claude/hooks/feedback-loop.sh:14:MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/feedback-loop.sh:15:
.claude/hooks/feedback-loop.sh:16:log() {
.claude/hooks/feedback-loop.sh:17:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/feedback-loop.sh:18:}
.claude/hooks/feedback-loop.sh:19:
.claude/hooks/feedback-loop.sh:20:init_feedback() {
.claude/hooks/feedback-loop.sh:21:    mkdir -p "$FEEDBACK_DIR"
.claude/hooks/feedback-loop.sh:22:    [[ -f "$OUTCOMES_FILE" ]] || touch "$OUTCOMES_FILE"
.claude/hooks/feedback-loop.sh:23:
.claude/hooks/feedback-loop.sh:24:    if [[ ! -f "$AGGREGATED_FILE" ]]; then
.claude/hooks/feedback-loop.sh:25:        echo '{"total":0,"successes":0,"failures":0,"improvements":[]}' > "$AGGREGATED_FILE"
.claude/hooks/feedback-loop.sh:26:    fi
.claude/hooks/feedback-loop.sh:27:}
.claude/hooks/feedback-loop.sh:28:
.claude/hooks/feedback-loop.sh:29:# =============================================================================
.claude/hooks/feedback-loop.sh:30:# OUTCOME CAPTURE
.claude/hooks/feedback-loop.sh:31:# =============================================================================
.claude/hooks/feedback-loop.sh:32:
.claude/hooks/feedback-loop.sh:33:# Record an outcome (success or failure)
.claude/hooks/feedback-loop.sh:34:record_outcome() {
.claude/hooks/feedback-loop.sh:35:    local operation="$1"
.claude/hooks/feedback-loop.sh:36:    local task_type="$2"
.claude/hooks/feedback-loop.sh:37:    local strategy="$3"
.claude/hooks/feedback-loop.sh:38:    local result="$4"  # success or failure
.claude/hooks/feedback-loop.sh:39:    local duration="${5:-0}"
.claude/hooks/feedback-loop.sh:40:    local error_class="${6:-}"
.claude/hooks/feedback-loop.sh:41:    local context="${7:-}"
.claude/hooks/feedback-loop.sh:42:
.claude/hooks/feedback-loop.sh:43:    init_feedback
.claude/hooks/feedback-loop.sh:44:
.claude/hooks/feedback-loop.sh:45:    local timestamp
.claude/hooks/feedback-loop.sh:46:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/feedback-loop.sh:47:
.claude/hooks/feedback-loop.sh:48:    local outcome_id
.claude/hooks/feedback-loop.sh:49:    outcome_id="outcome_$(date +%s%N | cut -c1-13)"
.claude/hooks/feedback-loop.sh:50:
.claude/hooks/feedback-loop.sh:51:    # Create outcome record
.claude/hooks/feedback-loop.sh:52:    local outcome
.claude/hooks/feedback-loop.sh:53:    outcome=$(jq -n \
.claude/hooks/feedback-loop.sh:54:        --arg id "$outcome_id" \
.claude/hooks/feedback-loop.sh:55:        --arg op "$operation" \
.claude/hooks/feedback-loop.sh:56:        --arg type "$task_type" \
.claude/hooks/feedback-loop.sh:57:        --arg strategy "$strategy" \
.claude/hooks/feedback-loop.sh:58:        --arg result "$result" \
.claude/hooks/feedback-loop.sh:59:        --argjson duration "$duration" \
.claude/hooks/feedback-loop.sh:60:        --arg error "$error_class" \
.claude/hooks/feedback-loop.sh:61:        --arg ctx "$context" \
.claude/hooks/feedback-loop.sh:62:        --arg ts "$timestamp" \
.claude/hooks/feedback-loop.sh:63:        '{
.claude/hooks/feedback-loop.sh:64:            id: $id,
.claude/hooks/feedback-loop.sh:65:            operation: $op,
.claude/hooks/feedback-loop.sh:66:            taskType: $type,
.claude/hooks/feedback-loop.sh:67:            strategy: $strategy,
.claude/hooks/feedback-loop.sh:68:            result: $result,
.claude/hooks/feedback-loop.sh:69:            duration: $duration,
.claude/hooks/feedback-loop.sh:70:            errorClass: $error,
.claude/hooks/feedback-loop.sh:71:            context: $ctx,
.claude/hooks/feedback-loop.sh:72:            timestamp: $ts
.claude/hooks/feedback-loop.sh:73:        }')
.claude/hooks/feedback-loop.sh:74:
.claude/hooks/feedback-loop.sh:75:    # Append to outcomes log (JSONL format)
.claude/hooks/feedback-loop.sh:76:    echo "$outcome" >> "$OUTCOMES_FILE"
.claude/hooks/feedback-loop.sh:77:
.claude/hooks/feedback-loop.sh:78:    log "Recorded $result outcome: $operation ($task_type/$strategy)"
.claude/hooks/feedback-loop.sh:79:
.claude/hooks/feedback-loop.sh:80:    # Trigger learning
.claude/hooks/feedback-loop.sh:81:    feed_to_learning "$outcome"
.claude/hooks/feedback-loop.sh:82:
.claude/hooks/feedback-loop.sh:83:    # Update aggregated statistics
.claude/hooks/feedback-loop.sh:84:    update_aggregated "$result"
.claude/hooks/feedback-loop.sh:85:
.claude/hooks/feedback-loop.sh:86:    echo "$outcome_id"
.claude/hooks/feedback-loop.sh:87:}
.claude/hooks/feedback-loop.sh:88:
.claude/hooks/feedback-loop.sh:89:# =============================================================================
.claude/hooks/feedback-loop.sh:90:# LEARNING INTEGRATION
.claude/hooks/feedback-loop.sh:91:# =============================================================================
.claude/hooks/feedback-loop.sh:92:
.claude/hooks/feedback-loop.sh:93:# Feed outcome to learning engine
.claude/hooks/feedback-loop.sh:94:feed_to_learning() {
.claude/hooks/feedback-loop.sh:95:    local outcome="$1"
.claude/hooks/feedback-loop.sh:96:
.claude/hooks/feedback-loop.sh:97:    if [[ ! -x "$LEARNING_ENGINE" ]]; then
.claude/hooks/feedback-loop.sh:98:        return
.claude/hooks/feedback-loop.sh:99:    fi
.claude/hooks/feedback-loop.sh:100:
.claude/hooks/feedback-loop.sh:101:    local task_type
.claude/hooks/feedback-loop.sh:102:    task_type=$(echo "$outcome" | jq -r '.taskType')
.claude/hooks/feedback-loop.sh:103:    local strategy
.claude/hooks/feedback-loop.sh:104:    strategy=$(echo "$outcome" | jq -r '.strategy')
.claude/hooks/feedback-loop.sh:105:    local result
.claude/hooks/feedback-loop.sh:106:    result=$(echo "$outcome" | jq -r '.result')
.claude/hooks/feedback-loop.sh:107:    local duration
.claude/hooks/feedback-loop.sh:108:    duration=$(echo "$outcome" | jq -r '.duration')
.claude/hooks/feedback-loop.sh:109:    local error_class
.claude/hooks/feedback-loop.sh:110:    error_class=$(echo "$outcome" | jq -r '.errorClass // empty')
.claude/hooks/feedback-loop.sh:111:    local context
.claude/hooks/feedback-loop.sh:112:    context=$(echo "$outcome" | jq -r '.context // empty')
.claude/hooks/feedback-loop.sh:113:
.claude/hooks/feedback-loop.sh:114:    if [[ "$result" == "success" ]]; then
.claude/hooks/feedback-loop.sh:115:        "$LEARNING_ENGINE" learn-success "$task_type" "$strategy" "$duration" "$context" 2>/dev/null || true
.claude/hooks/feedback-loop.sh:116:        log "Fed success to learning engine"
.claude/hooks/feedback-loop.sh:117:    else
.claude/hooks/feedback-loop.sh:118:        "$LEARNING_ENGINE" learn-failure "$task_type" "$strategy" "$error_class" "$context" 2>/dev/null || true
.claude/hooks/feedback-loop.sh:119:        log "Fed failure to learning engine"
.claude/hooks/feedback-loop.sh:120:    fi
.claude/hooks/feedback-loop.sh:121:}
.claude/hooks/feedback-loop.sh:122:
.claude/hooks/feedback-loop.sh:123:# Feed outcome to memory as episodic memory
.claude/hooks/feedback-loop.sh:124:feed_to_memory() {
.claude/hooks/feedback-loop.sh:125:    local outcome="$1"
.claude/hooks/feedback-loop.sh:126:
.claude/hooks/feedback-loop.sh:127:    if [[ ! -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/feedback-loop.sh:128:        return
.claude/hooks/feedback-loop.sh:129:    fi
.claude/hooks/feedback-loop.sh:130:
.claude/hooks/feedback-loop.sh:131:    local operation
.claude/hooks/feedback-loop.sh:132:    operation=$(echo "$outcome" | jq -r '.operation')
.claude/hooks/feedback-loop.sh:133:    local task_type
.claude/hooks/feedback-loop.sh:134:    task_type=$(echo "$outcome" | jq -r '.taskType')
.claude/hooks/feedback-loop.sh:135:    local result
.claude/hooks/feedback-loop.sh:136:    result=$(echo "$outcome" | jq -r '.result')
.claude/hooks/feedback-loop.sh:137:    local context
.claude/hooks/feedback-loop.sh:138:    context=$(echo "$outcome" | jq -r '.context // empty')
.claude/hooks/feedback-loop.sh:139:
.claude/hooks/feedback-loop.sh:140:    local description="$operation ($task_type): $result"
.claude/hooks/feedback-loop.sh:141:
.claude/hooks/feedback-loop.sh:142:    "$MEMORY_MANAGER" record "$task_type" "$description" "$result" "$context" 2>/dev/null || true
.claude/hooks/feedback-loop.sh:143:    log "Fed outcome to memory"
.claude/hooks/feedback-loop.sh:144:}
.claude/hooks/feedback-loop.sh:145:
.claude/hooks/feedback-loop.sh:146:# =============================================================================
.claude/hooks/feedback-loop.sh:147:# AGGREGATION & ANALYSIS
.claude/hooks/feedback-loop.sh:148:# =============================================================================
.claude/hooks/feedback-loop.sh:149:
.claude/hooks/feedback-loop.sh:150:# Update aggregated statistics
.claude/hooks/feedback-loop.sh:151:update_aggregated() {
.claude/hooks/feedback-loop.sh:152:    local result="$1"
.claude/hooks/feedback-loop.sh:153:
.claude/hooks/feedback-loop.sh:154:    init_feedback
.claude/hooks/feedback-loop.sh:155:
.claude/hooks/feedback-loop.sh:156:    local temp_file
.claude/hooks/feedback-loop.sh:157:    temp_file=$(mktemp)
.claude/hooks/feedback-loop.sh:158:
.claude/hooks/feedback-loop.sh:159:    jq --arg result "$result" '
.claude/hooks/feedback-loop.sh:160:        .total += 1 |
.claude/hooks/feedback-loop.sh:161:        if $result == "success" then
.claude/hooks/feedback-loop.sh:162:            .successes += 1
.claude/hooks/feedback-loop.sh:163:        else
.claude/hooks/feedback-loop.sh:164:            .failures += 1
.claude/hooks/feedback-loop.sh:165:        end |
.claude/hooks/feedback-loop.sh:166:        .successRate = (
.claude/hooks/feedback-loop.sh:167:            if .total > 0 then
.claude/hooks/feedback-loop.sh:168:                (.successes / .total * 100) | floor
.claude/hooks/feedback-loop.sh:169:            else
.claude/hooks/feedback-loop.sh:170:                0
.claude/hooks/feedback-loop.sh:171:            end
.claude/hooks/feedback-loop.sh:172:        )
.claude/hooks/feedback-loop.sh:173:    ' "$AGGREGATED_FILE" > "$temp_file"
.claude/hooks/feedback-loop.sh:174:
.claude/hooks/feedback-loop.sh:175:    mv "$temp_file" "$AGGREGATED_FILE"
.claude/hooks/feedback-loop.sh:176:}
.claude/hooks/feedback-loop.sh:177:
.claude/hooks/feedback-loop.sh:178:# Analyze recent outcomes for patterns
.claude/hooks/feedback-loop.sh:179:analyze_recent() {
.claude/hooks/feedback-loop.sh:180:    local limit="${1:-100}"
.claude/hooks/feedback-loop.sh:181:
.claude/hooks/feedback-loop.sh:182:    init_feedback
.claude/hooks/feedback-loop.sh:183:
.claude/hooks/feedback-loop.sh:184:    # Check if file has content
.claude/hooks/feedback-loop.sh:185:    if [[ ! -s "$OUTCOMES_FILE" ]]; then
.claude/hooks/feedback-loop.sh:186:        echo '{"total":0,"successes":0,"failures":0,"successRate":0,"avgDuration":0,"topErrors":[],"topStrategies":[]}'
.claude/hooks/feedback-loop.sh:187:        return
.claude/hooks/feedback-loop.sh:188:    fi
.claude/hooks/feedback-loop.sh:189:
.claude/hooks/feedback-loop.sh:190:    # Get last N outcomes
.claude/hooks/feedback-loop.sh:191:    local recent
.claude/hooks/feedback-loop.sh:192:    recent=$(tail -n "$limit" "$OUTCOMES_FILE" | jq -s '.' 2>/dev/null || echo '[]')
.claude/hooks/feedback-loop.sh:193:
.claude/hooks/feedback-loop.sh:194:    # If empty or invalid, return empty stats
.claude/hooks/feedback-loop.sh:195:    if [[ "$recent" == "[]" || -z "$recent" ]]; then
.claude/hooks/feedback-loop.sh:196:        echo '{"total":0,"successes":0,"failures":0,"successRate":0,"avgDuration":0,"topErrors":[],"topStrategies":[]}'
.claude/hooks/feedback-loop.sh:197:        return
.claude/hooks/feedback-loop.sh:198:    fi
.claude/hooks/feedback-loop.sh:199:
.claude/hooks/feedback-loop.sh:200:    # Calculate statistics
.claude/hooks/feedback-loop.sh:201:    local stats
.claude/hooks/feedback-loop.sh:202:    stats=$(echo "$recent" | jq '{
.claude/hooks/feedback-loop.sh:203:        total: length,
.claude/hooks/feedback-loop.sh:204:        successes: [.[] | select(.result == "success")] | length,
.claude/hooks/feedback-loop.sh:205:        failures: [.[] | select(.result == "failure")] | length,
.claude/hooks/feedback-loop.sh:206:        successRate: (
.claude/hooks/feedback-loop.sh:207:            if length > 0 then
.claude/hooks/feedback-loop.sh:208:                ([.[] | select(.result == "success")] | length) / length * 100 | floor
.claude/hooks/feedback-loop.sh:209:            else
.claude/hooks/feedback-loop.sh:210:                0
.claude/hooks/feedback-loop.sh:211:            end
.claude/hooks/feedback-loop.sh:212:        ),
.claude/hooks/feedback-loop.sh:213:        avgDuration: (
.claude/hooks/feedback-loop.sh:214:            if length > 0 and ([.[] | .duration] | length) > 0 then
.claude/hooks/feedback-loop.sh:215:                [.[] | .duration] | add / length | floor
.claude/hooks/feedback-loop.sh:216:            else
.claude/hooks/feedback-loop.sh:217:                0
.claude/hooks/feedback-loop.sh:218:            end
.claude/hooks/feedback-loop.sh:219:        ),
.claude/hooks/feedback-loop.sh:220:        topErrors: (
.claude/hooks/feedback-loop.sh:221:            [.[] | select(.result == "failure") | .errorClass] |
.claude/hooks/feedback-loop.sh:222:            group_by(.) |
.claude/hooks/feedback-loop.sh:223:            map({error: .[0], count: length}) |
.claude/hooks/feedback-loop.sh:224:            sort_by(-.count) |
.claude/hooks/feedback-loop.sh:225:            .[:5]
.claude/hooks/feedback-loop.sh:226:        ),
.claude/hooks/feedback-loop.sh:227:        topStrategies: (
.claude/hooks/feedback-loop.sh:228:            [.[] | .strategy] |
.claude/hooks/feedback-loop.sh:229:            group_by(.) |
.claude/hooks/feedback-loop.sh:230:            map({strategy: .[0], count: length}) |
.claude/hooks/feedback-loop.sh:231:            sort_by(-.count) |
.claude/hooks/feedback-loop.sh:232:            .[:5]
.claude/hooks/feedback-loop.sh:233:        )
.claude/hooks/feedback-loop.sh:234:    }' 2>/dev/null || echo '{"total":0,"successes":0,"failures":0,"successRate":0,"avgDuration":0,"topErrors":[],"topStrategies":[]}')
.claude/hooks/feedback-loop.sh:235:
.claude/hooks/feedback-loop.sh:236:    echo "$stats"
.claude/hooks/feedback-loop.sh:237:}
.claude/hooks/feedback-loop.sh:238:
.claude/hooks/feedback-loop.sh:239:# Identify improvements needed
.claude/hooks/feedback-loop.sh:240:identify_improvements() {
.claude/hooks/feedback-loop.sh:241:    init_feedback
.claude/hooks/feedback-loop.sh:242:
.claude/hooks/feedback-loop.sh:243:    local recent_stats
.claude/hooks/feedback-loop.sh:244:    recent_stats=$(analyze_recent 50)
.claude/hooks/feedback-loop.sh:245:
.claude/hooks/feedback-loop.sh:246:    local improvements=()
.claude/hooks/feedback-loop.sh:247:
.claude/hooks/feedback-loop.sh:248:    # Check success rate
.claude/hooks/feedback-loop.sh:249:    local success_rate
.claude/hooks/feedback-loop.sh:250:    success_rate=$(echo "$recent_stats" | jq -r '.successRate')
.claude/hooks/feedback-loop.sh:251:    if [[ $success_rate -lt 70 ]]; then
.claude/hooks/feedback-loop.sh:252:        improvements+=("{\"type\":\"low_success_rate\",\"value\":$success_rate,\"recommendation\":\"Review failed strategies and error patterns\"}")
.claude/hooks/feedback-loop.sh:253:    fi
.claude/hooks/feedback-loop.sh:254:
.claude/hooks/feedback-loop.sh:255:    # Check for repeated errors
.claude/hooks/feedback-loop.sh:256:    local top_error_count
.claude/hooks/feedback-loop.sh:257:    top_error_count=$(echo "$recent_stats" | jq -r '.topErrors[0].count // 0')
.claude/hooks/feedback-loop.sh:258:    if [[ $top_error_count -gt 5 ]]; then
.claude/hooks/feedback-loop.sh:259:        local top_error
.claude/hooks/feedback-loop.sh:260:        top_error=$(echo "$recent_stats" | jq -r '.topErrors[0].error')
.claude/hooks/feedback-loop.sh:261:        improvements+=("{\"type\":\"repeated_error\",\"error\":\"$top_error\",\"count\":$top_error_count,\"recommendation\":\"Add specific handling for $top_error\"}")
.claude/hooks/feedback-loop.sh:262:    fi
.claude/hooks/feedback-loop.sh:263:
.claude/hooks/feedback-loop.sh:264:    # Check average duration trend
.claude/hooks/feedback-loop.sh:265:    local avg_duration
.claude/hooks/feedback-loop.sh:266:    avg_duration=$(echo "$recent_stats" | jq -r '.avgDuration')
.claude/hooks/feedback-loop.sh:267:    if [[ $avg_duration -gt 30000 ]]; then
.claude/hooks/feedback-loop.sh:268:        improvements+=("{\"type\":\"slow_execution\",\"avgDuration\":$avg_duration,\"recommendation\":\"Optimize commonly used operations\"}")
.claude/hooks/feedback-loop.sh:269:    fi
.claude/hooks/feedback-loop.sh:270:
.claude/hooks/feedback-loop.sh:271:    # Output improvements
.claude/hooks/feedback-loop.sh:272:    if [[ ${#improvements[@]} -gt 0 ]]; then
.claude/hooks/feedback-loop.sh:273:        printf '%s\n' "${improvements[@]}" | jq -s '.'
.claude/hooks/feedback-loop.sh:274:    else
.claude/hooks/feedback-loop.sh:275:        echo '[]'
.claude/hooks/feedback-loop.sh:276:    fi
.claude/hooks/feedback-loop.sh:277:}
.claude/hooks/feedback-loop.sh:278:
.claude/hooks/feedback-loop.sh:279:# =============================================================================
.claude/hooks/feedback-loop.sh:280:# CONTINUOUS IMPROVEMENT
.claude/hooks/feedback-loop.sh:281:# =============================================================================
.claude/hooks/feedback-loop.sh:282:
.claude/hooks/feedback-loop.sh:283:# Suggest strategy changes based on feedback
.claude/hooks/feedback-loop.sh:284:suggest_strategy_changes() {
.claude/hooks/feedback-loop.sh:285:    local task_type="$1"
.claude/hooks/feedback-loop.sh:286:
.claude/hooks/feedback-loop.sh:287:    init_feedback
.claude/hooks/feedback-loop.sh:288:
.claude/hooks/feedback-loop.sh:289:    # Get outcomes for this task type
.claude/hooks/feedback-loop.sh:290:    local task_outcomes
.claude/hooks/feedback-loop.sh:291:    task_outcomes=$(grep "\"taskType\":\"$task_type\"" "$OUTCOMES_FILE" | jq -s '.')
.claude/hooks/feedback-loop.sh:292:
.claude/hooks/feedback-loop.sh:293:    # Find best and worst strategies
.claude/hooks/feedback-loop.sh:294:    local strategy_analysis
.claude/hooks/feedback-loop.sh:295:    strategy_analysis=$(echo "$task_outcomes" | jq '
.claude/hooks/feedback-loop.sh:296:        group_by(.strategy) |
.claude/hooks/feedback-loop.sh:297:        map({
.claude/hooks/feedback-loop.sh:298:            strategy: .[0].strategy,
.claude/hooks/feedback-loop.sh:299:            total: length,
.claude/hooks/feedback-loop.sh:300:            successes: [.[] | select(.result == "success")] | length,
.claude/hooks/feedback-loop.sh:301:            failures: [.[] | select(.result == "failure")] | length,
.claude/hooks/feedback-loop.sh:302:            successRate: (
.claude/hooks/feedback-loop.sh:303:                ([.[] | select(.result == "success")] | length) / length * 100 | floor
.claude/hooks/feedback-loop.sh:304:            ),
.claude/hooks/feedback-loop.sh:305:            avgDuration: (
.claude/hooks/feedback-loop.sh:306:                [.[] | select(.result == "success") | .duration] |
.claude/hooks/feedback-loop.sh:307:                if length > 0 then (add / length | floor) else 0 end
.claude/hooks/feedback-loop.sh:308:            )
.claude/hooks/feedback-loop.sh:309:        }) |
.claude/hooks/feedback-loop.sh:310:        sort_by(-.successRate)
.claude/hooks/feedback-loop.sh:311:    ')
.claude/hooks/feedback-loop.sh:312:
.claude/hooks/feedback-loop.sh:313:    echo "$strategy_analysis"
.claude/hooks/feedback-loop.sh:314:}
.claude/hooks/feedback-loop.sh:315:
.claude/hooks/feedback-loop.sh:316:# Auto-correct strategies that consistently fail
.claude/hooks/feedback-loop.sh:317:auto_correct() {
.claude/hooks/feedback-loop.sh:318:    init_feedback
.claude/hooks/feedback-loop.sh:319:
.claude/hooks/feedback-loop.sh:320:    local corrections=0
.claude/hooks/feedback-loop.sh:321:
.claude/hooks/feedback-loop.sh:322:    # Get task types with low success rates
.claude/hooks/feedback-loop.sh:323:    local problem_tasks
.claude/hooks/feedback-loop.sh:324:    problem_tasks=$(grep "\"result\":\"failure\"" "$OUTCOMES_FILE" | tail -100 | jq -s '
.claude/hooks/feedback-loop.sh:325:        group_by(.taskType) |
.claude/hooks/feedback-loop.sh:326:        map({
.claude/hooks/feedback-loop.sh:327:            taskType: .[0].taskType,
.claude/hooks/feedback-loop.sh:328:            failures: length
.claude/hooks/feedback-loop.sh:329:        }) |
.claude/hooks/feedback-loop.sh:330:        sort_by(-.failures) |
.claude/hooks/feedback-loop.sh:331:        .[:5]
.claude/hooks/feedback-loop.sh:332:    ')
.claude/hooks/feedback-loop.sh:333:
.claude/hooks/feedback-loop.sh:334:    # For each problem task, find alternative strategies
.claude/hooks/feedback-loop.sh:335:    echo "$problem_tasks" | jq -r '.[].taskType' | while read -r task_type; do
.claude/hooks/feedback-loop.sh:336:        local suggestions
.claude/hooks/feedback-loop.sh:337:        suggestions=$(suggest_strategy_changes "$task_type")
.claude/hooks/feedback-loop.sh:338:
.claude/hooks/feedback-loop.sh:339:        local best_strategy
.claude/hooks/feedback-loop.sh:340:        best_strategy=$(echo "$suggestions" | jq -r '.[0].strategy // empty')
.claude/hooks/feedback-loop.sh:341:
.claude/hooks/feedback-loop.sh:342:        if [[ -n "$best_strategy" && "$best_strategy" != "null" ]]; then
.claude/hooks/feedback-loop.sh:343:            log "Auto-correction: Recommend $best_strategy for $task_type"
.claude/hooks/feedback-loop.sh:344:            corrections=$((corrections + 1))
.claude/hooks/feedback-loop.sh:345:
.claude/hooks/feedback-loop.sh:346:            # Update learning engine
.claude/hooks/feedback-loop.sh:347:            if [[ -x "$LEARNING_ENGINE" ]]; then
.claude/hooks/feedback-loop.sh:348:                # This is informational - learning engine will pick it up from future successes
.claude/hooks/feedback-loop.sh:349:                log "Learning engine will adapt based on feedback"
.claude/hooks/feedback-loop.sh:350:            fi
.claude/hooks/feedback-loop.sh:351:        fi
.claude/hooks/feedback-loop.sh:352:    done
.claude/hooks/feedback-loop.sh:353:
.claude/hooks/feedback-loop.sh:354:    echo "{\"corrections\":$corrections}"
.claude/hooks/feedback-loop.sh:355:}
.claude/hooks/feedback-loop.sh:356:
.claude/hooks/feedback-loop.sh:357:# =============================================================================
.claude/hooks/feedback-loop.sh:358:# REPORTING
.claude/hooks/feedback-loop.sh:359:# =============================================================================
.claude/hooks/feedback-loop.sh:360:
.claude/hooks/feedback-loop.sh:361:# Generate feedback report
.claude/hooks/feedback-loop.sh:362:generate_report() {
.claude/hooks/feedback-loop.sh:363:    local period="${1:-7}"  # days
.claude/hooks/feedback-loop.sh:364:
.claude/hooks/feedback-loop.sh:365:    init_feedback
.claude/hooks/feedback-loop.sh:366:
.claude/hooks/feedback-loop.sh:367:    local since_date
.claude/hooks/feedback-loop.sh:368:    since_date=$(date -u -v-${period}d +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u --date="$period days ago" +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/feedback-loop.sh:369:
.claude/hooks/feedback-loop.sh:370:    # Get outcomes since date
.claude/hooks/feedback-loop.sh:371:    local period_outcomes
.claude/hooks/feedback-loop.sh:372:    period_outcomes=$(jq -s --arg since "$since_date" '
.claude/hooks/feedback-loop.sh:373:        [.[] | select(.timestamp >= $since)]
.claude/hooks/feedback-loop.sh:374:    ' "$OUTCOMES_FILE")
.claude/hooks/feedback-loop.sh:375:
.claude/hooks/feedback-loop.sh:376:    # Generate report
.claude/hooks/feedback-loop.sh:377:    echo "$period_outcomes" | jq --arg period "$period" '{
.claude/hooks/feedback-loop.sh:378:        period: ($period + " days"),
.claude/hooks/feedback-loop.sh:379:        summary: {
.claude/hooks/feedback-loop.sh:380:            total: length,
.claude/hooks/feedback-loop.sh:381:            successes: [.[] | select(.result == "success")] | length,
.claude/hooks/feedback-loop.sh:382:            failures: [.[] | select(.result == "failure")] | length,
.claude/hooks/feedback-loop.sh:383:            successRate: (
.claude/hooks/feedback-loop.sh:384:                if length > 0 then
.claude/hooks/feedback-loop.sh:385:                    ([.[] | select(.result == "success")] | length) / length * 100 | floor
.claude/hooks/feedback-loop.sh:386:                else
.claude/hooks/feedback-loop.sh:387:                    0
.claude/hooks/feedback-loop.sh:388:                end
.claude/hooks/feedback-loop.sh:389:            )
.claude/hooks/feedback-loop.sh:390:        },
.claude/hooks/feedback-loop.sh:391:        byTaskType: (
.claude/hooks/feedback-loop.sh:392:            group_by(.taskType) |
.claude/hooks/feedback-loop.sh:393:            map({
.claude/hooks/feedback-loop.sh:394:                taskType: .[0].taskType,
.claude/hooks/feedback-loop.sh:395:                total: length,
.claude/hooks/feedback-loop.sh:396:                successes: [.[] | select(.result == "success")] | length,
.claude/hooks/feedback-loop.sh:397:                successRate: (
.claude/hooks/feedback-loop.sh:398:                    ([.[] | select(.result == "success")] | length) / length * 100 | floor
.claude/hooks/feedback-loop.sh:399:                )
.claude/hooks/feedback-loop.sh:400:            }) |
.claude/hooks/feedback-loop.sh:401:            sort_by(-.total)
.claude/hooks/feedback-loop.sh:402:        ),
.claude/hooks/feedback-loop.sh:403:        topErrors: (
.claude/hooks/feedback-loop.sh:404:            [.[] | select(.result == "failure") | .errorClass] |
.claude/hooks/feedback-loop.sh:405:            group_by(.) |
.claude/hooks/feedback-loop.sh:406:            map({error: .[0], count: length}) |
.claude/hooks/feedback-loop.sh:407:            sort_by(-.count) |
.claude/hooks/feedback-loop.sh:408:            .[:10]
.claude/hooks/feedback-loop.sh:409:        ),
.claude/hooks/feedback-loop.sh:410:        improvements: (
.claude/hooks/feedback-loop.sh:411:            [.[] | select(.result == "success")] |
.claude/hooks/feedback-loop.sh:412:            [.[].duration] |
.claude/hooks/feedback-loop.sh:413:            if length > 0 then {
.claude/hooks/feedback-loop.sh:414:                avgDuration: (add / length | floor),
.claude/hooks/feedback-loop.sh:415:                trend: "improving"
.claude/hooks/feedback-loop.sh:416:            } else {} end
.claude/hooks/feedback-loop.sh:417:        )
.claude/hooks/feedback-loop.sh:418:    }'
.claude/hooks/feedback-loop.sh:419:}
.claude/hooks/feedback-loop.sh:420:
.claude/hooks/feedback-loop.sh:421:# =============================================================================
.claude/hooks/feedback-loop.sh:422:# COMMAND INTERFACE
.claude/hooks/feedback-loop.sh:423:# =============================================================================
.claude/hooks/feedback-loop.sh:424:
.claude/hooks/feedback-loop.sh:425:case "${1:-help}" in
.claude/hooks/feedback-loop.sh:426:    record)
.claude/hooks/feedback-loop.sh:427:        record_outcome "${2:-operation}" "${3:-general}" "${4:-default}" "${5:-success}" "${6:-0}" "${7:-}" "${8:-}"
.claude/hooks/feedback-loop.sh:428:        ;;
.claude/hooks/feedback-loop.sh:429:    analyze)
.claude/hooks/feedback-loop.sh:430:        analyze_recent "${2:-100}"
.claude/hooks/feedback-loop.sh:431:        ;;
.claude/hooks/feedback-loop.sh:432:    improvements)
.claude/hooks/feedback-loop.sh:433:        identify_improvements
.claude/hooks/feedback-loop.sh:434:        ;;
.claude/hooks/feedback-loop.sh:435:    suggest)
.claude/hooks/feedback-loop.sh:436:        suggest_strategy_changes "${2:-general}"
.claude/hooks/feedback-loop.sh:437:        ;;
.claude/hooks/feedback-loop.sh:438:    auto-correct)
.claude/hooks/feedback-loop.sh:439:        auto_correct
.claude/hooks/feedback-loop.sh:440:        ;;
.claude/hooks/feedback-loop.sh:441:    report)
.claude/hooks/feedback-loop.sh:442:        generate_report "${2:-7}"
.claude/hooks/feedback-loop.sh:443:        ;;
.claude/hooks/feedback-loop.sh:444:    statistics)
.claude/hooks/feedback-loop.sh:445:        cat "$AGGREGATED_FILE"
.claude/hooks/feedback-loop.sh:446:        ;;
.claude/hooks/feedback-loop.sh:447:    help|*)
.claude/hooks/feedback-loop.sh:448:        echo "Feedback Loop - Outcome Capture & Continuous Improvement"
.claude/hooks/feedback-loop.sh:449:        echo ""
.claude/hooks/feedback-loop.sh:450:        echo "Usage: $0 <command> [args]"
.claude/hooks/feedback-loop.sh:451:        echo ""
.claude/hooks/feedback-loop.sh:452:        echo "Capture Commands:"
.claude/hooks/feedback-loop.sh:453:        echo "  record <op> <type> <strategy> <result> [dur] [error] [ctx]"
.claude/hooks/feedback-loop.sh:454:        echo "                                  - Record operation outcome"
.claude/hooks/feedback-loop.sh:455:        echo "    result: success or failure"
.claude/hooks/feedback-loop.sh:456:        echo ""
.claude/hooks/feedback-loop.sh:457:        echo "Analysis Commands:"
.claude/hooks/feedback-loop.sh:458:        echo "  analyze [limit]                 - Analyze recent outcomes"
.claude/hooks/feedback-loop.sh:459:        echo "  improvements                    - Identify needed improvements"
.claude/hooks/feedback-loop.sh:460:        echo "  suggest <task_type>             - Suggest strategy changes"
.claude/hooks/feedback-loop.sh:461:        echo "  auto-correct                    - Auto-correct failing strategies"
.claude/hooks/feedback-loop.sh:462:        echo ""
.claude/hooks/feedback-loop.sh:463:        echo "Reporting Commands:"
.claude/hooks/feedback-loop.sh:464:        echo "  report [days]                   - Generate feedback report"
.claude/hooks/feedback-loop.sh:465:        echo "  statistics                      - Get aggregated statistics"
.claude/hooks/feedback-loop.sh:466:        echo ""
.claude/hooks/feedback-loop.sh:467:        echo "Examples:"
.claude/hooks/feedback-loop.sh:468:        echo "  $0 record build_feature feature incremental success 5000"
.claude/hooks/feedback-loop.sh:469:        echo "  $0 analyze 50                   # Analyze last 50 outcomes"
.claude/hooks/feedback-loop.sh:470:        echo "  $0 suggest bugfix               # Get strategy suggestions"
.claude/hooks/feedback-loop.sh:471:        ;;
.claude/hooks/feedback-loop.sh:472:esac
.claude/hooks/.claude/docs/debug-log.md:1:# Debug Log
.claude/hooks/.claude/docs/debug-log.md:2:
.claude/hooks/.claude/docs/debug-log.md:3:## Active Issues
.claude/hooks/.claude/docs/debug-log.md:4:
.claude/hooks/.claude/docs/debug-log.md:5:## Session Log
.claude/hooks/.claude/docs/debug-log.md:6:
.claude/hooks/.claude/docs/debug-log.md:7:---
.claude/hooks/.claude/docs/debug-log.md:8:
.claude/hooks/.claude/docs/debug-log.md:9:## Resolved Issues
.claude/hooks/.claude/docs/debug-log.md:10:
.claude/hooks/.claude/docs/debug-log.md:11:## Patterns Discovered
.claude/hooks/.claude/docs/debug-log.md:12:
.claude/hooks/.claude/docs/debug-log.md:13:## Research Cache
.claude/hooks/.claude/docs/debug-log.md:14:
.claude/hooks/.claude/docs/debug-log.md:15:### Issue: UNKNOWN (Attempt 0)
.claude/hooks/.claude/docs/debug-log.md:16:**Time**: 2026-01-12 04:08:37
.claude/hooks/.claude/docs/debug-log.md:17:**Classification**: UNKNOWN
.claude/hooks/.claude/docs/debug-log.md:18:**File**: unknown
.claude/hooks/.claude/docs/debug-log.md:19:**Code**: none
.claude/hooks/.claude/docs/debug-log.md:20:**Error**: `help`
.claude/hooks/.claude/docs/debug-log.md:21:**Context**: none
.claude/hooks/.claude/docs/debug-log.md:22:**Retryable**: true
.claude/hooks/.claude/docs/debug-log.md:23:
.claude/hooks/.claude/docs/debug-log.md:24:### Issue: TRANSIENT (Attempt 0)
.claude/hooks/.claude/docs/debug-log.md:25:**Time**: 2026-01-12 10:53:13
.claude/hooks/.claude/docs/debug-log.md:26:**Classification**: TRANSIENT
.claude/hooks/.claude/docs/debug-log.md:27:**File**: unknown
.claude/hooks/.claude/docs/debug-log.md:28:**Code**: none
.claude/hooks/.claude/docs/debug-log.md:29:**Error**: `ECONNREFUSED: connection refused`
.claude/hooks/.claude/docs/debug-log.md:30:**Context**: test
.claude/hooks/.claude/docs/debug-log.md:31:**Retryable**: true
.claude/hooks/.claude/docs/debug-log.md:32:
.claude/hooks/.claude/docs/debug-log.md:33:### Issue: TRANSIENT (Attempt 0)
.claude/hooks/.claude/docs/debug-log.md:34:**Time**: 2026-01-12 10:53:16
.claude/hooks/.claude/docs/debug-log.md:35:**Classification**: TRANSIENT
.claude/hooks/.claude/docs/debug-log.md:36:**File**: unknown
.claude/hooks/.claude/docs/debug-log.md:37:**Code**: none
.claude/hooks/.claude/docs/debug-log.md:38:**Error**: `ECONNREFUSED: connection refused`
.claude/hooks/.claude/docs/debug-log.md:39:**Context**: test
.claude/hooks/.claude/docs/debug-log.md:40:**Retryable**: true
.claude/hooks/.claude/docs/debug-log.md:41:
.claude/hooks/.claude/docs/debug-log.md:42:### Issue: TRANSIENT (Attempt 0)
.claude/hooks/.claude/docs/debug-log.md:43:**Time**: 2026-01-12 10:57:46
.claude/hooks/.claude/docs/debug-log.md:44:**Classification**: TRANSIENT
.claude/hooks/.claude/docs/debug-log.md:45:**File**: unknown
.claude/hooks/.claude/docs/debug-log.md:46:**Code**: none
.claude/hooks/.claude/docs/debug-log.md:47:**Error**: `Connection refused ECONNREFUSED`
.claude/hooks/.claude/docs/debug-log.md:48:**Context**: test context
.claude/hooks/.claude/docs/debug-log.md:49:**Retryable**: true
.claude/hooks/autonomous-orchestrator-v2.sh:1:#!/bin/bash
.claude/hooks/autonomous-orchestrator-v2.sh:2:# Autonomous Orchestrator V2 - Smart orchestration with learning and auto-execution
.claude/hooks/autonomous-orchestrator-v2.sh:3:# Integrates: learning-engine, task-queue, agent-loop, plan-execute
.claude/hooks/autonomous-orchestrator-v2.sh:4:
.claude/hooks/autonomous-orchestrator-v2.sh:5:set -e
.claude/hooks/autonomous-orchestrator-v2.sh:6:
.claude/hooks/autonomous-orchestrator-v2.sh:7:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/autonomous-orchestrator-v2.sh:8:MEMORY_MANAGER="${CLAUDE_DIR}/hooks/memory-manager.sh"
.claude/hooks/autonomous-orchestrator-v2.sh:9:LEARNING_ENGINE="${CLAUDE_DIR}/hooks/learning-engine.sh"
.claude/hooks/autonomous-orchestrator-v2.sh:10:TASK_QUEUE="${CLAUDE_DIR}/hooks/task-queue.sh"
.claude/hooks/autonomous-orchestrator-v2.sh:11:AGENT_LOOP="${CLAUDE_DIR}/hooks/agent-loop.sh"
.claude/hooks/autonomous-orchestrator-v2.sh:12:PLAN_EXECUTE="${CLAUDE_DIR}/hooks/plan-execute.sh"
.claude/hooks/autonomous-orchestrator-v2.sh:13:SELF_HEALING="${CLAUDE_DIR}/hooks/self-healing.sh"
.claude/hooks/autonomous-orchestrator-v2.sh:14:PROJECT_DIR="${PWD}"
.claude/hooks/autonomous-orchestrator-v2.sh:15:LOG_FILE="${CLAUDE_DIR}/orchestrator.log"
.claude/hooks/autonomous-orchestrator-v2.sh:16:
.claude/hooks/autonomous-orchestrator-v2.sh:17:log() {
.claude/hooks/autonomous-orchestrator-v2.sh:18:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/autonomous-orchestrator-v2.sh:19:}
.claude/hooks/autonomous-orchestrator-v2.sh:20:
.claude/hooks/autonomous-orchestrator-v2.sh:21:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:22:# STATE DETECTION (same as v1)
.claude/hooks/autonomous-orchestrator-v2.sh:23:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:24:
.claude/hooks/autonomous-orchestrator-v2.sh:25:check_buildguide() {
.claude/hooks/autonomous-orchestrator-v2.sh:26:    if [[ -f "${PROJECT_DIR}/buildguide.md" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:27:        if grep -q '^\s*- \[ \]' "${PROJECT_DIR}/buildguide.md" 2>/dev/null; then
.claude/hooks/autonomous-orchestrator-v2.sh:28:            echo "buildguide_found"
.claude/hooks/autonomous-orchestrator-v2.sh:29:            return 0
.claude/hooks/autonomous-orchestrator-v2.sh:30:        fi
.claude/hooks/autonomous-orchestrator-v2.sh:31:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:32:    echo "no_buildguide"
.claude/hooks/autonomous-orchestrator-v2.sh:33:    return 1
.claude/hooks/autonomous-orchestrator-v2.sh:34:}
.claude/hooks/autonomous-orchestrator-v2.sh:35:
.claude/hooks/autonomous-orchestrator-v2.sh:36:check_current_build() {
.claude/hooks/autonomous-orchestrator-v2.sh:37:    local build_file="${PROJECT_DIR}/.claude/current-build.local.md"
.claude/hooks/autonomous-orchestrator-v2.sh:38:    if [[ -f "$build_file" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:39:        local phase=$(grep -o 'phase: [a-z]*' "$build_file" 2>/dev/null | cut -d' ' -f2)
.claude/hooks/autonomous-orchestrator-v2.sh:40:        if [[ "$phase" != "complete" && -n "$phase" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:41:            echo "resume_build:${phase}"
.claude/hooks/autonomous-orchestrator-v2.sh:42:            return 0
.claude/hooks/autonomous-orchestrator-v2.sh:43:        fi
.claude/hooks/autonomous-orchestrator-v2.sh:44:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:45:    echo "no_current_build"
.claude/hooks/autonomous-orchestrator-v2.sh:46:    return 1
.claude/hooks/autonomous-orchestrator-v2.sh:47:}
.claude/hooks/autonomous-orchestrator-v2.sh:48:
.claude/hooks/autonomous-orchestrator-v2.sh:49:check_continuation() {
.claude/hooks/autonomous-orchestrator-v2.sh:50:    local cont_file="${PROJECT_DIR}/.claude/continuation-prompt.md"
.claude/hooks/autonomous-orchestrator-v2.sh:51:    if [[ -f "$cont_file" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:52:        echo "continuation_found"
.claude/hooks/autonomous-orchestrator-v2.sh:53:        return 0
.claude/hooks/autonomous-orchestrator-v2.sh:54:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:55:
.claude/hooks/autonomous-orchestrator-v2.sh:56:    if [[ -f "${CLAUDE_DIR}/continuation-prompt.md" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:57:        echo "global_continuation_found"
.claude/hooks/autonomous-orchestrator-v2.sh:58:        return 0
.claude/hooks/autonomous-orchestrator-v2.sh:59:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:60:
.claude/hooks/autonomous-orchestrator-v2.sh:61:    echo "no_continuation"
.claude/hooks/autonomous-orchestrator-v2.sh:62:    return 1
.claude/hooks/autonomous-orchestrator-v2.sh:63:}
.claude/hooks/autonomous-orchestrator-v2.sh:64:
.claude/hooks/autonomous-orchestrator-v2.sh:65:check_active_task() {
.claude/hooks/autonomous-orchestrator-v2.sh:66:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:67:        local task=$("$MEMORY_MANAGER" get-working 2>/dev/null | jq -r '.currentTask // empty' 2>/dev/null)
.claude/hooks/autonomous-orchestrator-v2.sh:68:        if [[ -n "$task" && "$task" != "null" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:69:            echo "active_task:${task}"
.claude/hooks/autonomous-orchestrator-v2.sh:70:            return 0
.claude/hooks/autonomous-orchestrator-v2.sh:71:        fi
.claude/hooks/autonomous-orchestrator-v2.sh:72:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:73:    echo "no_active_task"
.claude/hooks/autonomous-orchestrator-v2.sh:74:    return 1
.claude/hooks/autonomous-orchestrator-v2.sh:75:}
.claude/hooks/autonomous-orchestrator-v2.sh:76:
.claude/hooks/autonomous-orchestrator-v2.sh:77:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:78:# SMART TASK ANALYSIS (NEW)
.claude/hooks/autonomous-orchestrator-v2.sh:79:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:80:
.claude/hooks/autonomous-orchestrator-v2.sh:81:# Extract tasks from buildguide and populate task queue
.claude/hooks/autonomous-orchestrator-v2.sh:82:populate_task_queue() {
.claude/hooks/autonomous-orchestrator-v2.sh:83:    if [[ ! -f "${PROJECT_DIR}/buildguide.md" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:84:        return
.claude/hooks/autonomous-orchestrator-v2.sh:85:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:86:
.claude/hooks/autonomous-orchestrator-v2.sh:87:    if [[ ! -x "$TASK_QUEUE" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:88:        return
.claude/hooks/autonomous-orchestrator-v2.sh:89:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:90:
.claude/hooks/autonomous-orchestrator-v2.sh:91:    # Extract unchecked sections
.claude/hooks/autonomous-orchestrator-v2.sh:92:    local tasks
.claude/hooks/autonomous-orchestrator-v2.sh:93:    tasks=$(grep '^\s*- \[ \]' "${PROJECT_DIR}/buildguide.md" | sed 's/- \[ \] //' || true)
.claude/hooks/autonomous-orchestrator-v2.sh:94:
.claude/hooks/autonomous-orchestrator-v2.sh:95:    if [[ -z "$tasks" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:96:        return
.claude/hooks/autonomous-orchestrator-v2.sh:97:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:98:
.claude/hooks/autonomous-orchestrator-v2.sh:99:    # Add each task to queue with priority
.claude/hooks/autonomous-orchestrator-v2.sh:100:    local priority=2
.claude/hooks/autonomous-orchestrator-v2.sh:101:    while IFS= read -r task; do
.claude/hooks/autonomous-orchestrator-v2.sh:102:        # Check if task already in queue
.claude/hooks/autonomous-orchestrator-v2.sh:103:        local existing
.claude/hooks/autonomous-orchestrator-v2.sh:104:        existing=$("$TASK_QUEUE" list pending 2>/dev/null | jq -r --arg name "$task" '.[] | select(.name == $name) | .id' 2>/dev/null || echo "")
.claude/hooks/autonomous-orchestrator-v2.sh:105:
.claude/hooks/autonomous-orchestrator-v2.sh:106:        if [[ -z "$existing" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:107:            "$TASK_QUEUE" add "$task" "$priority" "from buildguide.md" "" 2>/dev/null || true
.claude/hooks/autonomous-orchestrator-v2.sh:108:            log "Added task to queue: $task"
.claude/hooks/autonomous-orchestrator-v2.sh:109:        fi
.claude/hooks/autonomous-orchestrator-v2.sh:110:
.claude/hooks/autonomous-orchestrator-v2.sh:111:        # Increment priority (lower number = higher priority)
.claude/hooks/autonomous-orchestrator-v2.sh:112:        priority=$((priority + 1))
.claude/hooks/autonomous-orchestrator-v2.sh:113:        [[ $priority -gt 5 ]] && priority=5
.claude/hooks/autonomous-orchestrator-v2.sh:114:    done <<< "$tasks"
.claude/hooks/autonomous-orchestrator-v2.sh:115:}
.claude/hooks/autonomous-orchestrator-v2.sh:116:
.claude/hooks/autonomous-orchestrator-v2.sh:117:# Analyze task and get recommended strategy
.claude/hooks/autonomous-orchestrator-v2.sh:118:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:119:# AUTO-RESEARCH: Detect unfamiliar libraries and recommend GitHub search
.claude/hooks/autonomous-orchestrator-v2.sh:120:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:121:
.claude/hooks/autonomous-orchestrator-v2.sh:122:detect_unfamiliar_library() {
.claude/hooks/autonomous-orchestrator-v2.sh:123:    local task="$1"
.claude/hooks/autonomous-orchestrator-v2.sh:124:
.claude/hooks/autonomous-orchestrator-v2.sh:125:    # Common library/framework/API keywords that suggest research needed
.claude/hooks/autonomous-orchestrator-v2.sh:126:    # Pattern: (action).*(library) where action = implement|integrate|use|add|create|build|setup
.claude/hooks/autonomous-orchestrator-v2.sh:127:    local unfamiliar_patterns=(
.claude/hooks/autonomous-orchestrator-v2.sh:128:        "(implement|integrate|use|add|create|build|setup).*(stripe|payment)"
.claude/hooks/autonomous-orchestrator-v2.sh:129:        "(implement|integrate|use|add|create|build|setup).*(oauth|auth|authentication)"
.claude/hooks/autonomous-orchestrator-v2.sh:130:        "(implement|integrate|use|add|create|build|setup).*(firebase)"
.claude/hooks/autonomous-orchestrator-v2.sh:131:        "(implement|integrate|use|add|create|build|setup).*(graphql)"
.claude/hooks/autonomous-orchestrator-v2.sh:132:        "(implement|integrate|use|add|create|build|setup).*(websocket|ws)"
.claude/hooks/autonomous-orchestrator-v2.sh:133:        "(implement|integrate|use|add|create|build|setup).*(redis)"
.claude/hooks/autonomous-orchestrator-v2.sh:134:        "(implement|integrate|use|add|create|build|setup).*(jwt|token)"
.claude/hooks/autonomous-orchestrator-v2.sh:135:        "(implement|integrate|use|add|create|build|setup).*(postgres|postgresql)"
.claude/hooks/autonomous-orchestrator-v2.sh:136:        "(implement|integrate|use|add|create|build|setup).*(mongodb|mongo)"
.claude/hooks/autonomous-orchestrator-v2.sh:137:        "(implement|integrate|use|add|create|build|setup).*(grpc)"
.claude/hooks/autonomous-orchestrator-v2.sh:138:        "(implement|integrate|use|add|create|build|setup).*(kafka)"
.claude/hooks/autonomous-orchestrator-v2.sh:139:        "(implement|integrate|use|add|create|build|setup).*(twilio)"
.claude/hooks/autonomous-orchestrator-v2.sh:140:        "(implement|integrate|use|add|create|build|setup).*(sendgrid)"
.claude/hooks/autonomous-orchestrator-v2.sh:141:        "(implement|integrate|use|add|create|build|setup).*(s3|aws)"
.claude/hooks/autonomous-orchestrator-v2.sh:142:        "(implement|integrate|use|add|create|build|setup).*(lambda)"
.claude/hooks/autonomous-orchestrator-v2.sh:143:    )
.claude/hooks/autonomous-orchestrator-v2.sh:144:
.claude/hooks/autonomous-orchestrator-v2.sh:145:    for pattern in "${unfamiliar_patterns[@]}"; do
.claude/hooks/autonomous-orchestrator-v2.sh:146:        if echo "$task" | grep -qiE "$pattern"; then
.claude/hooks/autonomous-orchestrator-v2.sh:147:            # Extract library name (expanded list)
.claude/hooks/autonomous-orchestrator-v2.sh:148:            local library
.claude/hooks/autonomous-orchestrator-v2.sh:149:            library=$(echo "$task" | grep -oiE "(stripe|payment|oauth|auth|authentication|firebase|graphql|websocket|ws|redis|jwt|token|postgres|postgresql|mongodb|mongo|grpc|kafka|twilio|sendgrid|s3|aws|lambda)" | head -1)
.claude/hooks/autonomous-orchestrator-v2.sh:150:            if [[ -n "$library" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:151:                # Normalize library names
.claude/hooks/autonomous-orchestrator-v2.sh:152:                case "$library" in
.claude/hooks/autonomous-orchestrator-v2.sh:153:                    auth|authentication) library="oauth" ;;
.claude/hooks/autonomous-orchestrator-v2.sh:154:                    ws) library="websocket" ;;
.claude/hooks/autonomous-orchestrator-v2.sh:155:                    token) library="jwt" ;;
.claude/hooks/autonomous-orchestrator-v2.sh:156:                    postgresql) library="postgres" ;;
.claude/hooks/autonomous-orchestrator-v2.sh:157:                    mongo) library="mongodb" ;;
.claude/hooks/autonomous-orchestrator-v2.sh:158:                    aws) library="s3" ;;
.claude/hooks/autonomous-orchestrator-v2.sh:159:                esac
.claude/hooks/autonomous-orchestrator-v2.sh:160:                echo "{\"needsResearch\":true,\"library\":\"$library\",\"reason\":\"Unfamiliar library detected\"}"
.claude/hooks/autonomous-orchestrator-v2.sh:161:                return 0
.claude/hooks/autonomous-orchestrator-v2.sh:162:            fi
.claude/hooks/autonomous-orchestrator-v2.sh:163:        fi
.claude/hooks/autonomous-orchestrator-v2.sh:164:    done
.claude/hooks/autonomous-orchestrator-v2.sh:165:
.claude/hooks/autonomous-orchestrator-v2.sh:166:    echo '{"needsResearch":false}'
.claude/hooks/autonomous-orchestrator-v2.sh:167:    return 1
.claude/hooks/autonomous-orchestrator-v2.sh:168:}
.claude/hooks/autonomous-orchestrator-v2.sh:169:
.claude/hooks/autonomous-orchestrator-v2.sh:170:analyze_task() {
.claude/hooks/autonomous-orchestrator-v2.sh:171:    local task="$1"
.claude/hooks/autonomous-orchestrator-v2.sh:172:
.claude/hooks/autonomous-orchestrator-v2.sh:173:    if [[ ! -x "$LEARNING_ENGINE" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:174:        echo '{"strategy":"default","confidence":0,"risk":10,"needsResearch":false}'
.claude/hooks/autonomous-orchestrator-v2.sh:175:        return
.claude/hooks/autonomous-orchestrator-v2.sh:176:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:177:
.claude/hooks/autonomous-orchestrator-v2.sh:178:    # Determine task type
.claude/hooks/autonomous-orchestrator-v2.sh:179:    local task_type="general"
.claude/hooks/autonomous-orchestrator-v2.sh:180:    if echo "$task" | grep -qiE "implement|add|create|build"; then
.claude/hooks/autonomous-orchestrator-v2.sh:181:        task_type="feature"
.claude/hooks/autonomous-orchestrator-v2.sh:182:    elif echo "$task" | grep -qiE "fix|bug|error|issue"; then
.claude/hooks/autonomous-orchestrator-v2.sh:183:        task_type="bugfix"
.claude/hooks/autonomous-orchestrator-v2.sh:184:    elif echo "$task" | grep -qiE "refactor|clean|improve"; then
.claude/hooks/autonomous-orchestrator-v2.sh:185:        task_type="refactor"
.claude/hooks/autonomous-orchestrator-v2.sh:186:    elif echo "$task" | grep -qiE "test|spec|coverage"; then
.claude/hooks/autonomous-orchestrator-v2.sh:187:        task_type="test"
.claude/hooks/autonomous-orchestrator-v2.sh:188:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:189:
.claude/hooks/autonomous-orchestrator-v2.sh:190:    # Check if task involves unfamiliar libraries (auto-research recommendation)
.claude/hooks/autonomous-orchestrator-v2.sh:191:    local research_recommendation
.claude/hooks/autonomous-orchestrator-v2.sh:192:    research_recommendation=$(detect_unfamiliar_library "$task")
.claude/hooks/autonomous-orchestrator-v2.sh:193:
.claude/hooks/autonomous-orchestrator-v2.sh:194:    # AUTO-SEARCH: If unfamiliar library detected, automatically search GitHub
.claude/hooks/autonomous-orchestrator-v2.sh:195:    local github_examples="[]"
.claude/hooks/autonomous-orchestrator-v2.sh:196:    local needs_research=$(echo "$research_recommendation" | jq -r '.needsResearch // false')
.claude/hooks/autonomous-orchestrator-v2.sh:197:
.claude/hooks/autonomous-orchestrator-v2.sh:198:    if [[ "$needs_research" == "true" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:199:        local library=$(echo "$research_recommendation" | jq -r '.library')
.claude/hooks/autonomous-orchestrator-v2.sh:200:        log "Auto-searching GitHub for $library code examples..."
.claude/hooks/autonomous-orchestrator-v2.sh:201:
.claude/hooks/autonomous-orchestrator-v2.sh:202:        # Construct search queries based on library
.claude/hooks/autonomous-orchestrator-v2.sh:203:        local search_query=""
.claude/hooks/autonomous-orchestrator-v2.sh:204:        case "$library" in
.claude/hooks/autonomous-orchestrator-v2.sh:205:            stripe)
.claude/hooks/autonomous-orchestrator-v2.sh:206:                search_query="stripe.checkout.sessions.create|stripe.paymentIntents"
.claude/hooks/autonomous-orchestrator-v2.sh:207:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:208:            oauth|authentication|auth)
.claude/hooks/autonomous-orchestrator-v2.sh:209:                search_query="OAuth2|passport.authenticate|NextAuth"
.claude/hooks/autonomous-orchestrator-v2.sh:210:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:211:            firebase)
.claude/hooks/autonomous-orchestrator-v2.sh:212:                search_query="firebase.initializeApp|firestore.collection"
.claude/hooks/autonomous-orchestrator-v2.sh:213:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:214:            graphql)
.claude/hooks/autonomous-orchestrator-v2.sh:215:                search_query="GraphQLSchema|makeExecutableSchema"
.claude/hooks/autonomous-orchestrator-v2.sh:216:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:217:            websocket|ws)
.claude/hooks/autonomous-orchestrator-v2.sh:218:                search_query="new WebSocket|ws.on.connection"
.claude/hooks/autonomous-orchestrator-v2.sh:219:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:220:            redis)
.claude/hooks/autonomous-orchestrator-v2.sh:221:                search_query="redis.createClient|RedisClient.connect"
.claude/hooks/autonomous-orchestrator-v2.sh:222:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:223:            jwt)
.claude/hooks/autonomous-orchestrator-v2.sh:224:                search_query="jwt.sign|jwt.verify|jsonwebtoken"
.claude/hooks/autonomous-orchestrator-v2.sh:225:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:226:            postgres|postgresql)
.claude/hooks/autonomous-orchestrator-v2.sh:227:                search_query="pg.Pool|PostgreSQL.query"
.claude/hooks/autonomous-orchestrator-v2.sh:228:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:229:            mongodb|mongo)
.claude/hooks/autonomous-orchestrator-v2.sh:230:                search_query="MongoClient.connect|mongoose.model"
.claude/hooks/autonomous-orchestrator-v2.sh:231:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:232:            grpc)
.claude/hooks/autonomous-orchestrator-v2.sh:233:                search_query="grpc.Server|@grpc/grpc-js"
.claude/hooks/autonomous-orchestrator-v2.sh:234:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:235:            kafka)
.claude/hooks/autonomous-orchestrator-v2.sh:236:                search_query="KafkaProducer|KafkaConsumer"
.claude/hooks/autonomous-orchestrator-v2.sh:237:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:238:            twilio)
.claude/hooks/autonomous-orchestrator-v2.sh:239:                search_query="twilio.messages.create"
.claude/hooks/autonomous-orchestrator-v2.sh:240:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:241:            sendgrid)
.claude/hooks/autonomous-orchestrator-v2.sh:242:                search_query="sendgrid.send|@sendgrid/mail"
.claude/hooks/autonomous-orchestrator-v2.sh:243:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:244:            s3)
.claude/hooks/autonomous-orchestrator-v2.sh:245:                search_query="S3Client|s3.putObject"
.claude/hooks/autonomous-orchestrator-v2.sh:246:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:247:            lambda)
.claude/hooks/autonomous-orchestrator-v2.sh:248:                search_query="lambda.invoke|AWS.Lambda"
.claude/hooks/autonomous-orchestrator-v2.sh:249:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:250:            *)
.claude/hooks/autonomous-orchestrator-v2.sh:251:                search_query="$library implementation"
.claude/hooks/autonomous-orchestrator-v2.sh:252:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:253:        esac
.claude/hooks/autonomous-orchestrator-v2.sh:254:
.claude/hooks/autonomous-orchestrator-v2.sh:255:        # Call mcp__grep__searchGitHub via Claude (this will be available in autonomous mode)
.claude/hooks/autonomous-orchestrator-v2.sh:256:        # Note: This creates a recommendation for Claude to execute the search
.claude/hooks/autonomous-orchestrator-v2.sh:257:        local search_recommendation=$(jq -n \
.claude/hooks/autonomous-orchestrator-v2.sh:258:            --arg lib "$library" \
.claude/hooks/autonomous-orchestrator-v2.sh:259:            --arg query "$search_query" \
.claude/hooks/autonomous-orchestrator-v2.sh:260:            '{
.claude/hooks/autonomous-orchestrator-v2.sh:261:                action: "search_github",
.claude/hooks/autonomous-orchestrator-v2.sh:262:                tool: "mcp__grep__searchGitHub",
.claude/hooks/autonomous-orchestrator-v2.sh:263:                library: $lib,
.claude/hooks/autonomous-orchestrator-v2.sh:264:                query: $query,
.claude/hooks/autonomous-orchestrator-v2.sh:265:                parameters: {
.claude/hooks/autonomous-orchestrator-v2.sh:266:                    query: $query,
.claude/hooks/autonomous-orchestrator-v2.sh:267:                    useRegexp: true,
.claude/hooks/autonomous-orchestrator-v2.sh:268:                    language: ["TypeScript", "JavaScript", "Python", "Go"]
.claude/hooks/autonomous-orchestrator-v2.sh:269:                },
.claude/hooks/autonomous-orchestrator-v2.sh:270:                instruction: "Search GitHub for \($lib) implementation examples using query: \($query)"
.claude/hooks/autonomous-orchestrator-v2.sh:271:            }')
.claude/hooks/autonomous-orchestrator-v2.sh:272:
.claude/hooks/autonomous-orchestrator-v2.sh:273:        log "GitHub search prepared for $library (query: $search_query)"
.claude/hooks/autonomous-orchestrator-v2.sh:274:        github_examples="$search_recommendation"
.claude/hooks/autonomous-orchestrator-v2.sh:275:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:276:
.claude/hooks/autonomous-orchestrator-v2.sh:277:    # Get recommendation from learning engine
.claude/hooks/autonomous-orchestrator-v2.sh:278:    local recommendation
.claude/hooks/autonomous-orchestrator-v2.sh:279:    recommendation=$("$LEARNING_ENGINE" recommend "$task_type" "$task" 2>/dev/null || echo '{"strategy":"default","confidence":0}')
.claude/hooks/autonomous-orchestrator-v2.sh:280:
.claude/hooks/autonomous-orchestrator-v2.sh:281:    # Get risk assessment
.claude/hooks/autonomous-orchestrator-v2.sh:282:    local strategy
.claude/hooks/autonomous-orchestrator-v2.sh:283:    strategy=$(echo "$recommendation" | jq -r '.strategy')
.claude/hooks/autonomous-orchestrator-v2.sh:284:    local risk
.claude/hooks/autonomous-orchestrator-v2.sh:285:    risk=$("$LEARNING_ENGINE" predict-risk "$task_type" "$strategy" 2>/dev/null || echo '{"riskScore":10,"riskLevel":"low"}')
.claude/hooks/autonomous-orchestrator-v2.sh:286:
.claude/hooks/autonomous-orchestrator-v2.sh:287:    # Combine with research recommendation and GitHub search
.claude/hooks/autonomous-orchestrator-v2.sh:288:    echo "$recommendation" | jq --argjson risk "$risk" --argjson research "$research_recommendation" --argjson github "$github_examples" \
.claude/hooks/autonomous-orchestrator-v2.sh:289:        '. + {risk: $risk.riskScore, riskLevel: $risk.riskLevel, taskType: "'"$task_type"'", research: $research, githubSearch: $github}'
.claude/hooks/autonomous-orchestrator-v2.sh:290:}
.claude/hooks/autonomous-orchestrator-v2.sh:291:
.claude/hooks/autonomous-orchestrator-v2.sh:292:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:293:# AUTO-EXECUTION (NEW)
.claude/hooks/autonomous-orchestrator-v2.sh:294:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:295:
.claude/hooks/autonomous-orchestrator-v2.sh:296:# Start agent loop for a task
.claude/hooks/autonomous-orchestrator-v2.sh:297:start_agent_loop() {
.claude/hooks/autonomous-orchestrator-v2.sh:298:    local task="$1"
.claude/hooks/autonomous-orchestrator-v2.sh:299:    local context="${2:-}"
.claude/hooks/autonomous-orchestrator-v2.sh:300:
.claude/hooks/autonomous-orchestrator-v2.sh:301:    if [[ ! -x "$AGENT_LOOP" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:302:        log "Agent loop not available"
.claude/hooks/autonomous-orchestrator-v2.sh:303:        return 1
.claude/hooks/autonomous-orchestrator-v2.sh:304:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:305:
.claude/hooks/autonomous-orchestrator-v2.sh:306:    # Check system health first
.claude/hooks/autonomous-orchestrator-v2.sh:307:    if [[ -x "$SELF_HEALING" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:308:        local health
.claude/hooks/autonomous-orchestrator-v2.sh:309:        health=$("$SELF_HEALING" health 2>/dev/null || echo "unknown")
.claude/hooks/autonomous-orchestrator-v2.sh:310:        if [[ "$health" == "unhealthy" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:311:            log "System unhealthy, attempting recovery before agent loop"
.claude/hooks/autonomous-orchestrator-v2.sh:312:            "$SELF_HEALING" recover 2>/dev/null || true
.claude/hooks/autonomous-orchestrator-v2.sh:313:        fi
.claude/hooks/autonomous-orchestrator-v2.sh:314:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:315:
.claude/hooks/autonomous-orchestrator-v2.sh:316:    # Start agent loop
.claude/hooks/autonomous-orchestrator-v2.sh:317:    log "Starting agent loop for: $task"
.claude/hooks/autonomous-orchestrator-v2.sh:318:    local agent_id
.claude/hooks/autonomous-orchestrator-v2.sh:319:    agent_id=$("$AGENT_LOOP" start "$task" "$context" 2>/dev/null)
.claude/hooks/autonomous-orchestrator-v2.sh:320:
.claude/hooks/autonomous-orchestrator-v2.sh:321:    echo "$agent_id"
.claude/hooks/autonomous-orchestrator-v2.sh:322:}
.claude/hooks/autonomous-orchestrator-v2.sh:323:
.claude/hooks/autonomous-orchestrator-v2.sh:324:# Create execution plan for task
.claude/hooks/autonomous-orchestrator-v2.sh:325:create_execution_plan() {
.claude/hooks/autonomous-orchestrator-v2.sh:326:    local task="$1"
.claude/hooks/autonomous-orchestrator-v2.sh:327:    local task_type="${2:-general}"
.claude/hooks/autonomous-orchestrator-v2.sh:328:
.claude/hooks/autonomous-orchestrator-v2.sh:329:    if [[ ! -x "$PLAN_EXECUTE" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:330:        return
.claude/hooks/autonomous-orchestrator-v2.sh:331:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:332:
.claude/hooks/autonomous-orchestrator-v2.sh:333:    # Create plan
.claude/hooks/autonomous-orchestrator-v2.sh:334:    local plan_id
.claude/hooks/autonomous-orchestrator-v2.sh:335:    plan_id=$("$PLAN_EXECUTE" create "$task" "autonomous execution" 2>/dev/null)
.claude/hooks/autonomous-orchestrator-v2.sh:336:
.claude/hooks/autonomous-orchestrator-v2.sh:337:    # Decompose task into steps
.claude/hooks/autonomous-orchestrator-v2.sh:338:    local steps
.claude/hooks/autonomous-orchestrator-v2.sh:339:    steps=$("$PLAN_EXECUTE" decompose "$task" "$task_type" 2>/dev/null)
.claude/hooks/autonomous-orchestrator-v2.sh:340:
.claude/hooks/autonomous-orchestrator-v2.sh:341:    # Add steps to plan
.claude/hooks/autonomous-orchestrator-v2.sh:342:    while IFS= read -r step; do
.claude/hooks/autonomous-orchestrator-v2.sh:343:        if [[ -n "$step" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:344:            local description
.claude/hooks/autonomous-orchestrator-v2.sh:345:            description=$(echo "$step" | sed 's/^[0-9]*\. //')
.claude/hooks/autonomous-orchestrator-v2.sh:346:            "$PLAN_EXECUTE" add-step "$description" "shell" "" "" 2>/dev/null || true
.claude/hooks/autonomous-orchestrator-v2.sh:347:        fi
.claude/hooks/autonomous-orchestrator-v2.sh:348:    done <<< "$steps"
.claude/hooks/autonomous-orchestrator-v2.sh:349:
.claude/hooks/autonomous-orchestrator-v2.sh:350:    log "Created execution plan: $plan_id for $task"
.claude/hooks/autonomous-orchestrator-v2.sh:351:    echo "$plan_id"
.claude/hooks/autonomous-orchestrator-v2.sh:352:}
.claude/hooks/autonomous-orchestrator-v2.sh:353:
.claude/hooks/autonomous-orchestrator-v2.sh:354:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:355:# SMART ORCHESTRATION (UPGRADED)
.claude/hooks/autonomous-orchestrator-v2.sh:356:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:357:
.claude/hooks/autonomous-orchestrator-v2.sh:358:orchestrate_smart() {
.claude/hooks/autonomous-orchestrator-v2.sh:359:    local decisions=()
.claude/hooks/autonomous-orchestrator-v2.sh:360:    local actions=()
.claude/hooks/autonomous-orchestrator-v2.sh:361:    local recommendations=()
.claude/hooks/autonomous-orchestrator-v2.sh:362:
.claude/hooks/autonomous-orchestrator-v2.sh:363:    # Initialize learning engine
.claude/hooks/autonomous-orchestrator-v2.sh:364:    [[ -x "$LEARNING_ENGINE" ]] && "$LEARNING_ENGINE" init 2>/dev/null || true
.claude/hooks/autonomous-orchestrator-v2.sh:365:
.claude/hooks/autonomous-orchestrator-v2.sh:366:    # Priority 1: Check for continuation prompt
.claude/hooks/autonomous-orchestrator-v2.sh:367:    local cont_status=$(check_continuation)
.claude/hooks/autonomous-orchestrator-v2.sh:368:    if [[ "$cont_status" == "continuation_found" || "$cont_status" == "global_continuation_found" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:369:        decisions+=("RESUME_CONTINUATION")
.claude/hooks/autonomous-orchestrator-v2.sh:370:        actions+=("execute_continuation")
.claude/hooks/autonomous-orchestrator-v2.sh:371:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:372:
.claude/hooks/autonomous-orchestrator-v2.sh:373:    # Priority 2: Check for in-progress build
.claude/hooks/autonomous-orchestrator-v2.sh:374:    local build_status=$(check_current_build)
.claude/hooks/autonomous-orchestrator-v2.sh:375:    if [[ "$build_status" == resume_build:* ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:376:        local phase="${build_status#resume_build:}"
.claude/hooks/autonomous-orchestrator-v2.sh:377:        decisions+=("RESUME_BUILD:${phase}")
.claude/hooks/autonomous-orchestrator-v2.sh:378:        actions+=("resume_build:$phase")
.claude/hooks/autonomous-orchestrator-v2.sh:379:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:380:
.claude/hooks/autonomous-orchestrator-v2.sh:381:    # Priority 3: Check for buildguide with unchecked items
.claude/hooks/autonomous-orchestrator-v2.sh:382:    local guide_status=$(check_buildguide)
.claude/hooks/autonomous-orchestrator-v2.sh:383:    if [[ "$guide_status" == "buildguide_found" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:384:        decisions+=("START_BUILD")
.claude/hooks/autonomous-orchestrator-v2.sh:385:
.claude/hooks/autonomous-orchestrator-v2.sh:386:        # Populate task queue from buildguide
.claude/hooks/autonomous-orchestrator-v2.sh:387:        populate_task_queue
.claude/hooks/autonomous-orchestrator-v2.sh:388:
.claude/hooks/autonomous-orchestrator-v2.sh:389:        # Get next task from queue
.claude/hooks/autonomous-orchestrator-v2.sh:390:        if [[ -x "$TASK_QUEUE" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:391:            local next_task_id
.claude/hooks/autonomous-orchestrator-v2.sh:392:            next_task_id=$("$TASK_QUEUE" next 2>/dev/null || echo "")
.claude/hooks/autonomous-orchestrator-v2.sh:393:            if [[ -n "$next_task_id" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:394:                local task_info
.claude/hooks/autonomous-orchestrator-v2.sh:395:                task_info=$("$TASK_QUEUE" get "$next_task_id" 2>/dev/null)
.claude/hooks/autonomous-orchestrator-v2.sh:396:                local task_name
.claude/hooks/autonomous-orchestrator-v2.sh:397:                task_name=$(echo "$task_info" | jq -r '.name' 2>/dev/null || echo "")
.claude/hooks/autonomous-orchestrator-v2.sh:398:
.claude/hooks/autonomous-orchestrator-v2.sh:399:                if [[ -n "$task_name" ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:400:                    # Analyze task
.claude/hooks/autonomous-orchestrator-v2.sh:401:                    local analysis
.claude/hooks/autonomous-orchestrator-v2.sh:402:                    analysis=$(analyze_task "$task_name")
.claude/hooks/autonomous-orchestrator-v2.sh:403:                    recommendations+=("$analysis")
.claude/hooks/autonomous-orchestrator-v2.sh:404:
.claude/hooks/autonomous-orchestrator-v2.sh:405:                    actions+=("start_task:$next_task_id:$task_name")
.claude/hooks/autonomous-orchestrator-v2.sh:406:                fi
.claude/hooks/autonomous-orchestrator-v2.sh:407:            fi
.claude/hooks/autonomous-orchestrator-v2.sh:408:        fi
.claude/hooks/autonomous-orchestrator-v2.sh:409:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:410:
.claude/hooks/autonomous-orchestrator-v2.sh:411:    # Priority 4: Check for active task in memory
.claude/hooks/autonomous-orchestrator-v2.sh:412:    local task_status=$(check_active_task)
.claude/hooks/autonomous-orchestrator-v2.sh:413:    if [[ "$task_status" == active_task:* ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:414:        local task="${task_status#active_task:}"
.claude/hooks/autonomous-orchestrator-v2.sh:415:        decisions+=("CONTINUE_TASK:${task}")
.claude/hooks/autonomous-orchestrator-v2.sh:416:        actions+=("continue_task:$task")
.claude/hooks/autonomous-orchestrator-v2.sh:417:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:418:
.claude/hooks/autonomous-orchestrator-v2.sh:419:    # Output comprehensive JSON
.claude/hooks/autonomous-orchestrator-v2.sh:420:    local decisions_json="[]"
.claude/hooks/autonomous-orchestrator-v2.sh:421:    if [[ ${#decisions[@]} -gt 0 ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:422:        decisions_json=$(printf '%s\n' "${decisions[@]}" | jq -R . | jq -s .)
.claude/hooks/autonomous-orchestrator-v2.sh:423:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:424:
.claude/hooks/autonomous-orchestrator-v2.sh:425:    local actions_json="[]"
.claude/hooks/autonomous-orchestrator-v2.sh:426:    if [[ ${#actions[@]} -gt 0 ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:427:        actions_json=$(printf '%s\n' "${actions[@]}" | jq -R . | jq -s .)
.claude/hooks/autonomous-orchestrator-v2.sh:428:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:429:
.claude/hooks/autonomous-orchestrator-v2.sh:430:    local recommendations_json="[]"
.claude/hooks/autonomous-orchestrator-v2.sh:431:    if [[ ${#recommendations[@]} -gt 0 ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:432:        recommendations_json=$(printf '%s\n' "${recommendations[@]}" | jq -s .)
.claude/hooks/autonomous-orchestrator-v2.sh:433:    fi
.claude/hooks/autonomous-orchestrator-v2.sh:434:
.claude/hooks/autonomous-orchestrator-v2.sh:435:    jq -n \
.claude/hooks/autonomous-orchestrator-v2.sh:436:        --argjson decisions "$decisions_json" \
.claude/hooks/autonomous-orchestrator-v2.sh:437:        --argjson actions "$actions_json" \
.claude/hooks/autonomous-orchestrator-v2.sh:438:        --argjson recommendations "$recommendations_json" \
.claude/hooks/autonomous-orchestrator-v2.sh:439:        --arg project "$PROJECT_DIR" \
.claude/hooks/autonomous-orchestrator-v2.sh:440:        --argjson has_guide "$([ "$guide_status" == "buildguide_found" ] && echo "true" || echo "false")" \
.claude/hooks/autonomous-orchestrator-v2.sh:441:        --argjson has_cont "$([ "$cont_status" != "no_continuation" ] && echo "true" || echo "false")" \
.claude/hooks/autonomous-orchestrator-v2.sh:442:        --argjson has_build "$([ "$build_status" != "no_current_build" ] && echo "true" || echo "false")" \
.claude/hooks/autonomous-orchestrator-v2.sh:443:        '{
.claude/hooks/autonomous-orchestrator-v2.sh:444:            decisions: $decisions,
.claude/hooks/autonomous-orchestrator-v2.sh:445:            actions: $actions,
.claude/hooks/autonomous-orchestrator-v2.sh:446:            recommendations: $recommendations,
.claude/hooks/autonomous-orchestrator-v2.sh:447:            project_dir: $project,
.claude/hooks/autonomous-orchestrator-v2.sh:448:            has_buildguide: $has_guide,
.claude/hooks/autonomous-orchestrator-v2.sh:449:            has_continuation: $has_cont,
.claude/hooks/autonomous-orchestrator-v2.sh:450:            has_active_build: $has_build,
.claude/hooks/autonomous-orchestrator-v2.sh:451:            version: "2.0"
.claude/hooks/autonomous-orchestrator-v2.sh:452:        }'
.claude/hooks/autonomous-orchestrator-v2.sh:453:}
.claude/hooks/autonomous-orchestrator-v2.sh:454:
.claude/hooks/autonomous-orchestrator-v2.sh:455:# Execute actions autonomously
.claude/hooks/autonomous-orchestrator-v2.sh:456:execute_actions() {
.claude/hooks/autonomous-orchestrator-v2.sh:457:    local actions_json="$1"
.claude/hooks/autonomous-orchestrator-v2.sh:458:
.claude/hooks/autonomous-orchestrator-v2.sh:459:    # Parse and execute each action
.claude/hooks/autonomous-orchestrator-v2.sh:460:    echo "$actions_json" | jq -r '.actions[]' | while read -r action; do
.claude/hooks/autonomous-orchestrator-v2.sh:461:        case "$action" in
.claude/hooks/autonomous-orchestrator-v2.sh:462:            start_task:*)
.claude/hooks/autonomous-orchestrator-v2.sh:463:                # Extract task ID and name
.claude/hooks/autonomous-orchestrator-v2.sh:464:                local task_id
.claude/hooks/autonomous-orchestrator-v2.sh:465:                task_id=$(echo "$action" | cut -d: -f2)
.claude/hooks/autonomous-orchestrator-v2.sh:466:                local task_name
.claude/hooks/autonomous-orchestrator-v2.sh:467:                task_name=$(echo "$action" | cut -d: -f3-)
.claude/hooks/autonomous-orchestrator-v2.sh:468:
.claude/hooks/autonomous-orchestrator-v2.sh:469:                # Mark task as started
.claude/hooks/autonomous-orchestrator-v2.sh:470:                [[ -x "$TASK_QUEUE" ]] && "$TASK_QUEUE" start "$task_id" 2>/dev/null || true
.claude/hooks/autonomous-orchestrator-v2.sh:471:
.claude/hooks/autonomous-orchestrator-v2.sh:472:                # Get task analysis
.claude/hooks/autonomous-orchestrator-v2.sh:473:                local analysis
.claude/hooks/autonomous-orchestrator-v2.sh:474:                analysis=$(analyze_task "$task_name")
.claude/hooks/autonomous-orchestrator-v2.sh:475:                local task_type
.claude/hooks/autonomous-orchestrator-v2.sh:476:                task_type=$(echo "$analysis" | jq -r '.taskType')
.claude/hooks/autonomous-orchestrator-v2.sh:477:
.claude/hooks/autonomous-orchestrator-v2.sh:478:                # Create plan
.claude/hooks/autonomous-orchestrator-v2.sh:479:                local plan_id
.claude/hooks/autonomous-orchestrator-v2.sh:480:                plan_id=$(create_execution_plan "$task_name" "$task_type")
.claude/hooks/autonomous-orchestrator-v2.sh:481:
.claude/hooks/autonomous-orchestrator-v2.sh:482:                # Start agent loop
.claude/hooks/autonomous-orchestrator-v2.sh:483:                local agent_id
.claude/hooks/autonomous-orchestrator-v2.sh:484:                agent_id=$(start_agent_loop "$task_name" "plan:$plan_id")
.claude/hooks/autonomous-orchestrator-v2.sh:485:
.claude/hooks/autonomous-orchestrator-v2.sh:486:                log "Executed start_task: $task_name (agent: $agent_id, plan: $plan_id)"
.claude/hooks/autonomous-orchestrator-v2.sh:487:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:488:
.claude/hooks/autonomous-orchestrator-v2.sh:489:            resume_build:*)
.claude/hooks/autonomous-orchestrator-v2.sh:490:                local phase="${action#resume_build:}"
.claude/hooks/autonomous-orchestrator-v2.sh:491:                log "Resuming build at phase: $phase"
.claude/hooks/autonomous-orchestrator-v2.sh:492:                # Agent loop will be started by Claude based on decision
.claude/hooks/autonomous-orchestrator-v2.sh:493:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:494:
.claude/hooks/autonomous-orchestrator-v2.sh:495:            continue_task:*)
.claude/hooks/autonomous-orchestrator-v2.sh:496:                local task="${action#continue_task:}"
.claude/hooks/autonomous-orchestrator-v2.sh:497:                log "Continuing task: $task"
.claude/hooks/autonomous-orchestrator-v2.sh:498:                # Agent loop will be started by Claude based on decision
.claude/hooks/autonomous-orchestrator-v2.sh:499:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:500:
.claude/hooks/autonomous-orchestrator-v2.sh:501:            execute_continuation)
.claude/hooks/autonomous-orchestrator-v2.sh:502:                log "Executing continuation prompt"
.claude/hooks/autonomous-orchestrator-v2.sh:503:                # Handled by Claude
.claude/hooks/autonomous-orchestrator-v2.sh:504:                ;;
.claude/hooks/autonomous-orchestrator-v2.sh:505:        esac
.claude/hooks/autonomous-orchestrator-v2.sh:506:    done
.claude/hooks/autonomous-orchestrator-v2.sh:507:}
.claude/hooks/autonomous-orchestrator-v2.sh:508:
.claude/hooks/autonomous-orchestrator-v2.sh:509:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:510:# COMMAND INTERFACE
.claude/hooks/autonomous-orchestrator-v2.sh:511:# =============================================================================
.claude/hooks/autonomous-orchestrator-v2.sh:512:
.claude/hooks/autonomous-orchestrator-v2.sh:513:case "${1:-orchestrate}" in
.claude/hooks/autonomous-orchestrator-v2.sh:514:    orchestrate)
.claude/hooks/autonomous-orchestrator-v2.sh:515:        # Original simple orchestration
.claude/hooks/autonomous-orchestrator-v2.sh:516:        local decisions=()
.claude/hooks/autonomous-orchestrator-v2.sh:517:        local cont_status=$(check_continuation)
.claude/hooks/autonomous-orchestrator-v2.sh:518:        [[ "$cont_status" != "no_continuation" ]] && decisions+=("RESUME_CONTINUATION")
.claude/hooks/autonomous-orchestrator-v2.sh:519:
.claude/hooks/autonomous-orchestrator-v2.sh:520:        local build_status=$(check_current_build)
.claude/hooks/autonomous-orchestrator-v2.sh:521:        [[ "$build_status" == resume_build:* ]] && decisions+=("RESUME_BUILD:${build_status#resume_build:}")
.claude/hooks/autonomous-orchestrator-v2.sh:522:
.claude/hooks/autonomous-orchestrator-v2.sh:523:        local guide_status=$(check_buildguide)
.claude/hooks/autonomous-orchestrator-v2.sh:524:        [[ "$guide_status" == "buildguide_found" ]] && decisions+=("START_BUILD")
.claude/hooks/autonomous-orchestrator-v2.sh:525:
.claude/hooks/autonomous-orchestrator-v2.sh:526:        local task_status=$(check_active_task)
.claude/hooks/autonomous-orchestrator-v2.sh:527:        [[ "$task_status" == active_task:* ]] && decisions+=("CONTINUE_TASK:${task_status#active_task:}")
.claude/hooks/autonomous-orchestrator-v2.sh:528:
.claude/hooks/autonomous-orchestrator-v2.sh:529:        # Simple JSON output for backward compatibility
.claude/hooks/autonomous-orchestrator-v2.sh:530:        local decisions_json="[]"
.claude/hooks/autonomous-orchestrator-v2.sh:531:        if [[ ${#decisions[@]} -gt 0 ]]; then
.claude/hooks/autonomous-orchestrator-v2.sh:532:            decisions_json=$(printf '%s\n' "${decisions[@]}" | jq -R . | jq -s .)
.claude/hooks/autonomous-orchestrator-v2.sh:533:        fi
.claude/hooks/autonomous-orchestrator-v2.sh:534:
.claude/hooks/autonomous-orchestrator-v2.sh:535:        jq -n --argjson decisions "$decisions_json" \
.claude/hooks/autonomous-orchestrator-v2.sh:536:            --arg project "$PROJECT_DIR" \
.claude/hooks/autonomous-orchestrator-v2.sh:537:            '{decisions: $decisions, project_dir: $project}'
.claude/hooks/autonomous-orchestrator-v2.sh:538:        ;;
.claude/hooks/autonomous-orchestrator-v2.sh:539:
.claude/hooks/autonomous-orchestrator-v2.sh:540:    smart)
.claude/hooks/autonomous-orchestrator-v2.sh:541:        # New smart orchestration with learning
.claude/hooks/autonomous-orchestrator-v2.sh:542:        orchestrate_smart
.claude/hooks/autonomous-orchestrator-v2.sh:543:        ;;
.claude/hooks/autonomous-orchestrator-v2.sh:544:
.claude/hooks/autonomous-orchestrator-v2.sh:545:    execute)
.claude/hooks/autonomous-orchestrator-v2.sh:546:        # Auto-execute actions
.claude/hooks/autonomous-orchestrator-v2.sh:547:        local orchestration
.claude/hooks/autonomous-orchestrator-v2.sh:548:        orchestration=$(orchestrate_smart)
.claude/hooks/autonomous-orchestrator-v2.sh:549:        execute_actions "$orchestration"
.claude/hooks/autonomous-orchestrator-v2.sh:550:        echo "$orchestration"
.claude/hooks/autonomous-orchestrator-v2.sh:551:        ;;
.claude/hooks/autonomous-orchestrator-v2.sh:552:
.claude/hooks/autonomous-orchestrator-v2.sh:553:    populate-queue)
.claude/hooks/autonomous-orchestrator-v2.sh:554:        # Populate task queue from buildguide
.claude/hooks/autonomous-orchestrator-v2.sh:555:        populate_task_queue
.claude/hooks/autonomous-orchestrator-v2.sh:556:        [[ -x "$TASK_QUEUE" ]] && "$TASK_QUEUE" status
.claude/hooks/autonomous-orchestrator-v2.sh:557:        ;;
.claude/hooks/autonomous-orchestrator-v2.sh:558:
.claude/hooks/autonomous-orchestrator-v2.sh:559:    analyze)
.claude/hooks/autonomous-orchestrator-v2.sh:560:        # Analyze a specific task
.claude/hooks/autonomous-orchestrator-v2.sh:561:        analyze_task "${2:-task}"
.claude/hooks/autonomous-orchestrator-v2.sh:562:        ;;
.claude/hooks/autonomous-orchestrator-v2.sh:563:
.claude/hooks/autonomous-orchestrator-v2.sh:564:    help|*)
.claude/hooks/autonomous-orchestrator-v2.sh:565:        echo "Autonomous Orchestrator V2 - Smart Orchestration"
.claude/hooks/autonomous-orchestrator-v2.sh:566:        echo ""
.claude/hooks/autonomous-orchestrator-v2.sh:567:        echo "Usage: $0 <command> [args]"
.claude/hooks/autonomous-orchestrator-v2.sh:568:        echo ""
.claude/hooks/autonomous-orchestrator-v2.sh:569:        echo "Commands:"
.claude/hooks/autonomous-orchestrator-v2.sh:570:        echo "  orchestrate           - Simple orchestration (v1 compatible)"
.claude/hooks/autonomous-orchestrator-v2.sh:571:        echo "  smart                 - Smart orchestration with learning"
.claude/hooks/autonomous-orchestrator-v2.sh:572:        echo "  execute               - Auto-execute orchestrated actions"
.claude/hooks/autonomous-orchestrator-v2.sh:573:        echo "  populate-queue        - Populate task queue from buildguide"
.claude/hooks/autonomous-orchestrator-v2.sh:574:        echo "  analyze <task>        - Analyze task and get recommendations"
.claude/hooks/autonomous-orchestrator-v2.sh:575:        echo ""
.claude/hooks/autonomous-orchestrator-v2.sh:576:        echo "Examples:"
.claude/hooks/autonomous-orchestrator-v2.sh:577:        echo "  $0 smart              # Get smart orchestration with recommendations"
.claude/hooks/autonomous-orchestrator-v2.sh:578:        echo "  $0 execute            # Orchestrate and auto-execute"
.claude/hooks/autonomous-orchestrator-v2.sh:579:        echo "  $0 analyze 'implement auth'  # Get strategy recommendation"
.claude/hooks/autonomous-orchestrator-v2.sh:580:        ;;
.claude/hooks/autonomous-orchestrator-v2.sh:581:esac
.claude/hooks/agent-loop.sh:1:#!/bin/bash
.claude/hooks/agent-loop.sh:2:# Agent Loop - Autonomous execution with tool calling
.claude/hooks/agent-loop.sh:3:# Based on patterns from: Roo-Code AgentLoopState, UI-TARS AgentComposer, PraisonAI, TanStack
.claude/hooks/agent-loop.sh:4:
.claude/hooks/agent-loop.sh:5:set -uo pipefail
.claude/hooks/agent-loop.sh:6:
.claude/hooks/agent-loop.sh:7:AGENT_DIR="${HOME}/.claude/agent"
.claude/hooks/agent-loop.sh:8:AGENT_STATE="$AGENT_DIR/state.json"
.claude/hooks/agent-loop.sh:9:TOOL_REGISTRY="$AGENT_DIR/tools.json"
.claude/hooks/agent-loop.sh:10:EXECUTION_LOG="$AGENT_DIR/execution.log"
.claude/hooks/agent-loop.sh:11:LOG_FILE="${HOME}/.claude/agent-loop.log"
.claude/hooks/agent-loop.sh:12:
.claude/hooks/agent-loop.sh:13:# Memory integration
.claude/hooks/agent-loop.sh:14:MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/agent-loop.sh:15:
.claude/hooks/agent-loop.sh:16:# Loop control
.claude/hooks/agent-loop.sh:17:MAX_ITERATIONS="${MAX_ITERATIONS:-50}"
.claude/hooks/agent-loop.sh:18:MAX_CONSECUTIVE_FAILURES="${MAX_CONSECUTIVE_FAILURES:-3}"
.claude/hooks/agent-loop.sh:19:
.claude/hooks/agent-loop.sh:20:log() {
.claude/hooks/agent-loop.sh:21:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/agent-loop.sh:22:}
.claude/hooks/agent-loop.sh:23:
.claude/hooks/agent-loop.sh:24:init_agent() {
.claude/hooks/agent-loop.sh:25:    mkdir -p "$AGENT_DIR"
.claude/hooks/agent-loop.sh:26:
.claude/hooks/agent-loop.sh:27:    # Initialize tool registry if not exists
.claude/hooks/agent-loop.sh:28:    if [[ ! -f "$TOOL_REGISTRY" ]]; then
.claude/hooks/agent-loop.sh:29:        cat > "$TOOL_REGISTRY" << 'EOF'
.claude/hooks/agent-loop.sh:30:{
.claude/hooks/agent-loop.sh:31:    "tools": {
.claude/hooks/agent-loop.sh:32:        "read_file": {
.claude/hooks/agent-loop.sh:33:            "description": "Read file contents",
.claude/hooks/agent-loop.sh:34:            "command": "cat",
.claude/hooks/agent-loop.sh:35:            "requiresPath": true
.claude/hooks/agent-loop.sh:36:        },
.claude/hooks/agent-loop.sh:37:        "write_file": {
.claude/hooks/agent-loop.sh:38:            "description": "Write to file",
.claude/hooks/agent-loop.sh:39:            "command": "tee",
.claude/hooks/agent-loop.sh:40:            "requiresPath": true
.claude/hooks/agent-loop.sh:41:        },
.claude/hooks/agent-loop.sh:42:        "search_code": {
.claude/hooks/agent-loop.sh:43:            "description": "Search in codebase",
.claude/hooks/agent-loop.sh:44:            "command": "grep -r",
.claude/hooks/agent-loop.sh:45:            "requiresPattern": true
.claude/hooks/agent-loop.sh:46:        },
.claude/hooks/agent-loop.sh:47:        "run_tests": {
.claude/hooks/agent-loop.sh:48:            "description": "Run test suite",
.claude/hooks/agent-loop.sh:49:            "command": "npm test || pytest || go test ./...",
.claude/hooks/agent-loop.sh:50:            "requiresPath": false
.claude/hooks/agent-loop.sh:51:        },
.claude/hooks/agent-loop.sh:52:        "lint_code": {
.claude/hooks/agent-loop.sh:53:            "description": "Run linter",
.claude/hooks/agent-loop.sh:54:            "command": "npm run lint || ruff check . || go vet ./...",
.claude/hooks/agent-loop.sh:55:            "requiresPath": false
.claude/hooks/agent-loop.sh:56:        },
.claude/hooks/agent-loop.sh:57:        "typecheck": {
.claude/hooks/agent-loop.sh:58:            "description": "Run type checker",
.claude/hooks/agent-loop.sh:59:            "command": "npm run typecheck || mypy . || go build ./...",
.claude/hooks/agent-loop.sh:60:            "requiresPath": false
.claude/hooks/agent-loop.sh:61:        },
.claude/hooks/agent-loop.sh:62:        "shell": {
.claude/hooks/agent-loop.sh:63:            "description": "Execute shell command",
.claude/hooks/agent-loop.sh:64:            "command": "bash -c",
.claude/hooks/agent-loop.sh:65:            "requiresCommand": true
.claude/hooks/agent-loop.sh:66:        }
.claude/hooks/agent-loop.sh:67:    }
.claude/hooks/agent-loop.sh:68:}
.claude/hooks/agent-loop.sh:69:EOF
.claude/hooks/agent-loop.sh:70:    fi
.claude/hooks/agent-loop.sh:71:}
.claude/hooks/agent-loop.sh:72:
.claude/hooks/agent-loop.sh:73:# =============================================================================
.claude/hooks/agent-loop.sh:74:# MEMORY INTEGRATION (from Generative Agents, MemGPT patterns)
.claude/hooks/agent-loop.sh:75:# =============================================================================
.claude/hooks/agent-loop.sh:76:
.claude/hooks/agent-loop.sh:77:# Initialize memory for agent session
.claude/hooks/agent-loop.sh:78:memory_init() {
.claude/hooks/agent-loop.sh:79:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:80:        "$MEMORY_MANAGER" init > /dev/null 2>&1
.claude/hooks/agent-loop.sh:81:        log "Memory system initialized"
.claude/hooks/agent-loop.sh:82:    fi
.claude/hooks/agent-loop.sh:83:}
.claude/hooks/agent-loop.sh:84:
.claude/hooks/agent-loop.sh:85:# Set current task in working memory
.claude/hooks/agent-loop.sh:86:memory_set_task() {
.claude/hooks/agent-loop.sh:87:    local goal="$1"
.claude/hooks/agent-loop.sh:88:    local context="${2:-}"
.claude/hooks/agent-loop.sh:89:
.claude/hooks/agent-loop.sh:90:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:91:        "$MEMORY_MANAGER" set-task "$goal" "$context" 2>/dev/null
.claude/hooks/agent-loop.sh:92:        log "Memory: Set task - $goal"
.claude/hooks/agent-loop.sh:93:    fi
.claude/hooks/agent-loop.sh:94:}
.claude/hooks/agent-loop.sh:95:
.claude/hooks/agent-loop.sh:96:# Retrieve relevant context from memory before execution
.claude/hooks/agent-loop.sh:97:memory_retrieve_context() {
.claude/hooks/agent-loop.sh:98:    local query="$1"
.claude/hooks/agent-loop.sh:99:    local limit="${2:-5}"
.claude/hooks/agent-loop.sh:100:
.claude/hooks/agent-loop.sh:101:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:102:        # Use scored retrieval (recency + relevance + importance)
.claude/hooks/agent-loop.sh:103:        local memories
.claude/hooks/agent-loop.sh:104:        memories=$("$MEMORY_MANAGER" remember-scored "$query" "$limit" 2>/dev/null)
.claude/hooks/agent-loop.sh:105:
.claude/hooks/agent-loop.sh:106:        if [[ -n "$memories" && "$memories" != "[]" ]]; then
.claude/hooks/agent-loop.sh:107:            echo "$memories"
.claude/hooks/agent-loop.sh:108:            log "Memory: Retrieved $(echo "$memories" | jq 'length') relevant memories"
.claude/hooks/agent-loop.sh:109:        fi
.claude/hooks/agent-loop.sh:110:    fi
.claude/hooks/agent-loop.sh:111:}
.claude/hooks/agent-loop.sh:112:
.claude/hooks/agent-loop.sh:113:# Record a successful action to memory
.claude/hooks/agent-loop.sh:114:memory_record_success() {
.claude/hooks/agent-loop.sh:115:    local action_type="$1"
.claude/hooks/agent-loop.sh:116:    local description="$2"
.claude/hooks/agent-loop.sh:117:    local details="${3:-}"
.claude/hooks/agent-loop.sh:118:
.claude/hooks/agent-loop.sh:119:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:120:        # Record episode
.claude/hooks/agent-loop.sh:121:        "$MEMORY_MANAGER" record "$action_type" "$description" "success" "$details" 2>/dev/null
.claude/hooks/agent-loop.sh:122:
.claude/hooks/agent-loop.sh:123:        # Log action
.claude/hooks/agent-loop.sh:124:        "$MEMORY_MANAGER" log-action "$action_type" "$description" "success" '{"outcome":"success"}' 2>/dev/null
.claude/hooks/agent-loop.sh:125:
.claude/hooks/agent-loop.sh:126:        log "Memory: Recorded success - $description"
.claude/hooks/agent-loop.sh:127:    fi
.claude/hooks/agent-loop.sh:128:}
.claude/hooks/agent-loop.sh:129:
.claude/hooks/agent-loop.sh:130:# Record a failure to memory for learning
.claude/hooks/agent-loop.sh:131:memory_record_failure() {
.claude/hooks/agent-loop.sh:132:    local action_type="$1"
.claude/hooks/agent-loop.sh:133:    local description="$2"
.claude/hooks/agent-loop.sh:134:    local error="${3:-}"
.claude/hooks/agent-loop.sh:135:
.claude/hooks/agent-loop.sh:136:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:137:        # Record episode
.claude/hooks/agent-loop.sh:138:        "$MEMORY_MANAGER" record "failure" "$description" "failure" "$error" 2>/dev/null
.claude/hooks/agent-loop.sh:139:
.claude/hooks/agent-loop.sh:140:        # Log action
.claude/hooks/agent-loop.sh:141:        "$MEMORY_MANAGER" log-action "$action_type" "$description" "$error" '{"outcome":"failure"}' 2>/dev/null
.claude/hooks/agent-loop.sh:142:
.claude/hooks/agent-loop.sh:143:        log "Memory: Recorded failure - $description"
.claude/hooks/agent-loop.sh:144:    fi
.claude/hooks/agent-loop.sh:145:}
.claude/hooks/agent-loop.sh:146:
.claude/hooks/agent-loop.sh:147:# Learn a pattern from experience
.claude/hooks/agent-loop.sh:148:memory_learn_pattern() {
.claude/hooks/agent-loop.sh:149:    local pattern_type="$1"    # error_fix, optimization, workflow
.claude/hooks/agent-loop.sh:150:    local trigger="$2"          # What triggers this pattern
.claude/hooks/agent-loop.sh:151:    local solution="$3"         # The solution/action
.claude/hooks/agent-loop.sh:152:    local success_rate="${4:-1.0}"
.claude/hooks/agent-loop.sh:153:
.claude/hooks/agent-loop.sh:154:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:155:        local pattern_id
.claude/hooks/agent-loop.sh:156:        pattern_id=$("$MEMORY_MANAGER" add-pattern "$pattern_type" "$trigger" "$solution" "$success_rate" 2>/dev/null)
.claude/hooks/agent-loop.sh:157:
.claude/hooks/agent-loop.sh:158:        log "Memory: Learned pattern $pattern_id - $trigger -> $solution"
.claude/hooks/agent-loop.sh:159:        echo "$pattern_id"
.claude/hooks/agent-loop.sh:160:    fi
.claude/hooks/agent-loop.sh:161:}
.claude/hooks/agent-loop.sh:162:
.claude/hooks/agent-loop.sh:163:# Search for known patterns that might help
.claude/hooks/agent-loop.sh:164:memory_find_patterns() {
.claude/hooks/agent-loop.sh:165:    local query="$1"
.claude/hooks/agent-loop.sh:166:    local limit="${2:-3}"
.claude/hooks/agent-loop.sh:167:
.claude/hooks/agent-loop.sh:168:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:169:        local patterns
.claude/hooks/agent-loop.sh:170:        patterns=$("$MEMORY_MANAGER" find-patterns "$query" "$limit" 2>/dev/null)
.claude/hooks/agent-loop.sh:171:
.claude/hooks/agent-loop.sh:172:        if [[ -n "$patterns" && "$patterns" != "[]" ]]; then
.claude/hooks/agent-loop.sh:173:            echo "$patterns"
.claude/hooks/agent-loop.sh:174:            log "Memory: Found $(echo "$patterns" | jq 'length') matching patterns"
.claude/hooks/agent-loop.sh:175:        fi
.claude/hooks/agent-loop.sh:176:    fi
.claude/hooks/agent-loop.sh:177:}
.claude/hooks/agent-loop.sh:178:
.claude/hooks/agent-loop.sh:179:# Create a reflection after significant work
.claude/hooks/agent-loop.sh:180:memory_reflect() {
.claude/hooks/agent-loop.sh:181:    local focus="$1"
.claude/hooks/agent-loop.sh:182:    local content="$2"
.claude/hooks/agent-loop.sh:183:    local insights="${3:-}"
.claude/hooks/agent-loop.sh:184:
.claude/hooks/agent-loop.sh:185:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:186:        "$MEMORY_MANAGER" reflect "$focus" "$content" "$insights" 2>/dev/null
.claude/hooks/agent-loop.sh:187:        log "Memory: Created reflection - $focus"
.claude/hooks/agent-loop.sh:188:    fi
.claude/hooks/agent-loop.sh:189:}
.claude/hooks/agent-loop.sh:190:
.claude/hooks/agent-loop.sh:191:# Store a fact learned during execution
.claude/hooks/agent-loop.sh:192:memory_store_fact() {
.claude/hooks/agent-loop.sh:193:    local category="$1"
.claude/hooks/agent-loop.sh:194:    local key="$2"
.claude/hooks/agent-loop.sh:195:    local value="$3"
.claude/hooks/agent-loop.sh:196:
.claude/hooks/agent-loop.sh:197:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:198:        "$MEMORY_MANAGER" add-fact "$category" "$key" "$value" 2>/dev/null
.claude/hooks/agent-loop.sh:199:        log "Memory: Stored fact - $category/$key"
.claude/hooks/agent-loop.sh:200:    fi
.claude/hooks/agent-loop.sh:201:}
.claude/hooks/agent-loop.sh:202:
.claude/hooks/agent-loop.sh:203:# Get memory statistics
.claude/hooks/agent-loop.sh:204:memory_stats() {
.claude/hooks/agent-loop.sh:205:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:206:        "$MEMORY_MANAGER" stats 2>/dev/null
.claude/hooks/agent-loop.sh:207:    fi
.claude/hooks/agent-loop.sh:208:}
.claude/hooks/agent-loop.sh:209:
.claude/hooks/agent-loop.sh:210:# =============================================================================
.claude/hooks/agent-loop.sh:211:# AGENT STATE MACHINE (from Roo-Code patterns)
.claude/hooks/agent-loop.sh:212:# =============================================================================
.claude/hooks/agent-loop.sh:213:
.claude/hooks/agent-loop.sh:214:# Agent states: idle, planning, executing, validating, reflecting, paused, completed, failed
.claude/hooks/agent-loop.sh:215:
.claude/hooks/agent-loop.sh:216:start_agent() {
.claude/hooks/agent-loop.sh:217:    local goal="$1"
.claude/hooks/agent-loop.sh:218:    local context="${2:-}"
.claude/hooks/agent-loop.sh:219:
.claude/hooks/agent-loop.sh:220:    init_agent
.claude/hooks/agent-loop.sh:221:
.claude/hooks/agent-loop.sh:222:    # Initialize memory system
.claude/hooks/agent-loop.sh:223:    memory_init
.claude/hooks/agent-loop.sh:224:
.claude/hooks/agent-loop.sh:225:    local agent_id
.claude/hooks/agent-loop.sh:226:    agent_id="agent_$(date +%s)"
.claude/hooks/agent-loop.sh:227:
.claude/hooks/agent-loop.sh:228:    local timestamp
.claude/hooks/agent-loop.sh:229:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/agent-loop.sh:230:
.claude/hooks/agent-loop.sh:231:    # Retrieve relevant memories for this goal
.claude/hooks/agent-loop.sh:232:    local relevant_memories=""
.claude/hooks/agent-loop.sh:233:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:234:        relevant_memories=$(memory_retrieve_context "$goal" 5 2>/dev/null | jq -c '.' 2>/dev/null || echo "[]")
.claude/hooks/agent-loop.sh:235:    fi
.claude/hooks/agent-loop.sh:236:
.claude/hooks/agent-loop.sh:237:    # ============================================================================
.claude/hooks/agent-loop.sh:238:    # PLANNING PHASE: Thinking Framework + Plan-Execute + Task Queue
.claude/hooks/agent-loop.sh:239:    # ============================================================================
.claude/hooks/agent-loop.sh:240:    local THINKING_FRAMEWORK="${HOME}/.claude/hooks/thinking-framework.sh"
.claude/hooks/agent-loop.sh:241:    local PLAN_EXECUTE="${HOME}/.claude/hooks/plan-execute.sh"
.claude/hooks/agent-loop.sh:242:    local TASK_QUEUE="${HOME}/.claude/hooks/task-queue.sh"
.claude/hooks/agent-loop.sh:243:
.claude/hooks/agent-loop.sh:244:    # 1. Thinking Framework: Generate reasoning chain
.claude/hooks/agent-loop.sh:245:    local reasoning_chain="[]"
.claude/hooks/agent-loop.sh:246:    if [[ -x "$THINKING_FRAMEWORK" ]]; then
.claude/hooks/agent-loop.sh:247:        log "Generating reasoning chain with thinking-framework..."
.claude/hooks/agent-loop.sh:248:        reasoning_chain=$("$THINKING_FRAMEWORK" reason "$goal" "$context" 2>/dev/null | jq -c '.' 2>/dev/null || echo '[]')
.claude/hooks/agent-loop.sh:249:        log "Reasoning chain generated: $(echo "$reasoning_chain" | jq 'length') steps"
.claude/hooks/agent-loop.sh:250:    fi
.claude/hooks/agent-loop.sh:251:
.claude/hooks/agent-loop.sh:252:    # 2. Plan-Execute: Create execution plan
.claude/hooks/agent-loop.sh:253:    local execution_plan="[]"
.claude/hooks/agent-loop.sh:254:    if [[ -x "$PLAN_EXECUTE" ]]; then
.claude/hooks/agent-loop.sh:255:        log "Creating execution plan with plan-execute..."
.claude/hooks/agent-loop.sh:256:        execution_plan=$("$PLAN_EXECUTE" plan "$goal" "$context" 2>/dev/null | jq -c '.steps // []' 2>/dev/null || echo '[]')
.claude/hooks/agent-loop.sh:257:        log "Execution plan created: $(echo "$execution_plan" | jq 'length') steps"
.claude/hooks/agent-loop.sh:258:    fi
.claude/hooks/agent-loop.sh:259:
.claude/hooks/agent-loop.sh:260:    # 3. Task Queue: Prioritize tasks
.claude/hooks/agent-loop.sh:261:    local prioritized_plan="[]"
.claude/hooks/agent-loop.sh:262:    if [[ -x "$TASK_QUEUE" && $(echo "$execution_plan" | jq 'length') -gt 0 ]]; then
.claude/hooks/agent-loop.sh:263:        log "Prioritizing tasks with task-queue..."
.claude/hooks/agent-loop.sh:264:        # Add tasks to queue
.claude/hooks/agent-loop.sh:265:        echo "$execution_plan" | jq -c '.[]' | while read -r step; do
.claude/hooks/agent-loop.sh:266:            "$TASK_QUEUE" add "$(echo "$step" | jq -r '.task // .description')" \
.claude/hooks/agent-loop.sh:267:                "$(echo "$step" | jq -r '.priority // "medium"')" 2>/dev/null || true
.claude/hooks/agent-loop.sh:268:        done
.claude/hooks/agent-loop.sh:269:        # Get prioritized list
.claude/hooks/agent-loop.sh:270:        prioritized_plan=$("$TASK_QUEUE" list 2>/dev/null | jq -c '.' 2>/dev/null || echo "$execution_plan")
.claude/hooks/agent-loop.sh:271:        log "Tasks prioritized: $(echo "$prioritized_plan" | jq 'length') tasks"
.claude/hooks/agent-loop.sh:272:    else
.claude/hooks/agent-loop.sh:273:        prioritized_plan="$execution_plan"
.claude/hooks/agent-loop.sh:274:    fi
.claude/hooks/agent-loop.sh:275:    # ============================================================================
.claude/hooks/agent-loop.sh:276:
.claude/hooks/agent-loop.sh:277:    cat > "$AGENT_STATE" << EOF
.claude/hooks/agent-loop.sh:278:{
.claude/hooks/agent-loop.sh:279:    "id": "$agent_id",
.claude/hooks/agent-loop.sh:280:    "goal": "$goal",
.claude/hooks/agent-loop.sh:281:    "context": "$context",
.claude/hooks/agent-loop.sh:282:    "state": "planning",
.claude/hooks/agent-loop.sh:283:    "iteration": 0,
.claude/hooks/agent-loop.sh:284:    "maxIterations": $MAX_ITERATIONS,
.claude/hooks/agent-loop.sh:285:    "consecutiveFailures": 0,
.claude/hooks/agent-loop.sh:286:    "startedAt": "$timestamp",
.claude/hooks/agent-loop.sh:287:    "plan": $prioritized_plan,
.claude/hooks/agent-loop.sh:288:    "reasoningChain": $reasoning_chain,
.claude/hooks/agent-loop.sh:289:    "currentStep": null,
.claude/hooks/agent-loop.sh:290:    "executionHistory": [],
.claude/hooks/agent-loop.sh:291:    "toolCalls": [],
.claude/hooks/agent-loop.sh:292:    "pauseRequested": false,
.claude/hooks/agent-loop.sh:293:    "stopRequested": false,
.claude/hooks/agent-loop.sh:294:    "relevantMemories": $relevant_memories
.claude/hooks/agent-loop.sh:295:}
.claude/hooks/agent-loop.sh:296:EOF
.claude/hooks/agent-loop.sh:297:
.claude/hooks/agent-loop.sh:298:    # Set task in working memory
.claude/hooks/agent-loop.sh:299:    memory_set_task "$goal" "$context"
.claude/hooks/agent-loop.sh:300:
.claude/hooks/agent-loop.sh:301:    log "Started agent: $agent_id with goal: $goal"
.claude/hooks/agent-loop.sh:302:    echo "$agent_id"
.claude/hooks/agent-loop.sh:303:}
.claude/hooks/agent-loop.sh:304:
.claude/hooks/agent-loop.sh:305:# Transition agent state
.claude/hooks/agent-loop.sh:306:transition_state() {
.claude/hooks/agent-loop.sh:307:    local new_state="$1"
.claude/hooks/agent-loop.sh:308:    local reason="${2:-}"
.claude/hooks/agent-loop.sh:309:
.claude/hooks/agent-loop.sh:310:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:311:        return 1
.claude/hooks/agent-loop.sh:312:    fi
.claude/hooks/agent-loop.sh:313:
.claude/hooks/agent-loop.sh:314:    local temp_file
.claude/hooks/agent-loop.sh:315:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:316:
.claude/hooks/agent-loop.sh:317:    local timestamp
.claude/hooks/agent-loop.sh:318:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/agent-loop.sh:319:
.claude/hooks/agent-loop.sh:320:    local old_state
.claude/hooks/agent-loop.sh:321:    old_state=$(jq -r '.state' "$AGENT_STATE")
.claude/hooks/agent-loop.sh:322:
.claude/hooks/agent-loop.sh:323:    jq --arg state "$new_state" \
.claude/hooks/agent-loop.sh:324:       --arg reason "$reason" \
.claude/hooks/agent-loop.sh:325:       --arg ts "$timestamp" \
.claude/hooks/agent-loop.sh:326:       --arg old "$old_state" \
.claude/hooks/agent-loop.sh:327:       '
.claude/hooks/agent-loop.sh:328:       .state = $state |
.claude/hooks/agent-loop.sh:329:       .lastTransition = {
.claude/hooks/agent-loop.sh:330:           from: $old,
.claude/hooks/agent-loop.sh:331:           to: $state,
.claude/hooks/agent-loop.sh:332:           reason: $reason,
.claude/hooks/agent-loop.sh:333:           timestamp: $ts
.claude/hooks/agent-loop.sh:334:       }
.claude/hooks/agent-loop.sh:335:       ' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:336:
.claude/hooks/agent-loop.sh:337:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:338:
.claude/hooks/agent-loop.sh:339:    log "State transition: $old_state -> $new_state (reason: $reason)"
.claude/hooks/agent-loop.sh:340:}
.claude/hooks/agent-loop.sh:341:
.claude/hooks/agent-loop.sh:342:# =============================================================================
.claude/hooks/agent-loop.sh:343:# LOOP CONTROL (from TanStack patterns)
.claude/hooks/agent-loop.sh:344:# =============================================================================
.claude/hooks/agent-loop.sh:345:
.claude/hooks/agent-loop.sh:346:# Check if loop should continue
.claude/hooks/agent-loop.sh:347:should_continue() {
.claude/hooks/agent-loop.sh:348:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:349:        echo "false:no_agent"
.claude/hooks/agent-loop.sh:350:        return 1
.claude/hooks/agent-loop.sh:351:    fi
.claude/hooks/agent-loop.sh:352:
.claude/hooks/agent-loop.sh:353:    local result
.claude/hooks/agent-loop.sh:354:    result=$(jq -r '
.claude/hooks/agent-loop.sh:355:        if .stopRequested then
.claude/hooks/agent-loop.sh:356:            "false:stop_requested"
.claude/hooks/agent-loop.sh:357:        elif .pauseRequested then
.claude/hooks/agent-loop.sh:358:            "false:paused"
.claude/hooks/agent-loop.sh:359:        elif .state == "completed" then
.claude/hooks/agent-loop.sh:360:            "false:completed"
.claude/hooks/agent-loop.sh:361:        elif .state == "failed" then
.claude/hooks/agent-loop.sh:362:            "false:failed"
.claude/hooks/agent-loop.sh:363:        elif .iteration >= .maxIterations then
.claude/hooks/agent-loop.sh:364:            "false:max_iterations"
.claude/hooks/agent-loop.sh:365:        elif .consecutiveFailures >= '"$MAX_CONSECUTIVE_FAILURES"' then
.claude/hooks/agent-loop.sh:366:            "false:consecutive_failures"
.claude/hooks/agent-loop.sh:367:        else
.claude/hooks/agent-loop.sh:368:            "true:continue"
.claude/hooks/agent-loop.sh:369:        end
.claude/hooks/agent-loop.sh:370:    ' "$AGENT_STATE")
.claude/hooks/agent-loop.sh:371:
.claude/hooks/agent-loop.sh:372:    echo "$result"
.claude/hooks/agent-loop.sh:373:}
.claude/hooks/agent-loop.sh:374:
.claude/hooks/agent-loop.sh:375:# Increment iteration
.claude/hooks/agent-loop.sh:376:increment_iteration() {
.claude/hooks/agent-loop.sh:377:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:378:        return 1
.claude/hooks/agent-loop.sh:379:    fi
.claude/hooks/agent-loop.sh:380:
.claude/hooks/agent-loop.sh:381:    local temp_file
.claude/hooks/agent-loop.sh:382:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:383:
.claude/hooks/agent-loop.sh:384:    jq '.iteration += 1' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:385:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:386:}
.claude/hooks/agent-loop.sh:387:
.claude/hooks/agent-loop.sh:388:# Record failure
.claude/hooks/agent-loop.sh:389:record_failure() {
.claude/hooks/agent-loop.sh:390:    local error="${1:-unknown}"
.claude/hooks/agent-loop.sh:391:
.claude/hooks/agent-loop.sh:392:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:393:        return 1
.claude/hooks/agent-loop.sh:394:    fi
.claude/hooks/agent-loop.sh:395:
.claude/hooks/agent-loop.sh:396:    local temp_file
.claude/hooks/agent-loop.sh:397:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:398:
.claude/hooks/agent-loop.sh:399:    local timestamp
.claude/hooks/agent-loop.sh:400:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/agent-loop.sh:401:
.claude/hooks/agent-loop.sh:402:    local goal
.claude/hooks/agent-loop.sh:403:    goal=$(jq -r '.goal' "$AGENT_STATE" 2>/dev/null || echo "")
.claude/hooks/agent-loop.sh:404:
.claude/hooks/agent-loop.sh:405:    # ============================================================================
.claude/hooks/agent-loop.sh:406:    # ERROR HANDLER INTEGRATION: Classify error and get retry strategy
.claude/hooks/agent-loop.sh:407:    # ============================================================================
.claude/hooks/agent-loop.sh:408:    local ERROR_HANDLER="${HOME}/.claude/hooks/error-handler.sh"
.claude/hooks/agent-loop.sh:409:    local error_classification="UNKNOWN"
.claude/hooks/agent-loop.sh:410:    local should_retry="false"
.claude/hooks/agent-loop.sh:411:    local backoff_ms=1000
.claude/hooks/agent-loop.sh:412:    local attempt
.claude/hooks/agent-loop.sh:413:    attempt=$(jq -r '.consecutiveFailures // 0' "$AGENT_STATE" 2>/dev/null || echo "0")
.claude/hooks/agent-loop.sh:414:
.claude/hooks/agent-loop.sh:415:    if [[ -x "$ERROR_HANDLER" ]]; then
.claude/hooks/agent-loop.sh:416:        log "Analyzing error with error-handler..."
.claude/hooks/agent-loop.sh:417:        local handler_response
.claude/hooks/agent-loop.sh:418:        handler_response=$("$ERROR_HANDLER" handle "$error" "$attempt" 3 "agent-loop:$goal" 2>/dev/null || echo '{}')
.claude/hooks/agent-loop.sh:419:
.claude/hooks/agent-loop.sh:420:        error_classification=$(echo "$handler_response" | jq -r '.classification // "UNKNOWN"')
.claude/hooks/agent-loop.sh:421:        should_retry=$(echo "$handler_response" | jq -r '.shouldRetry // false')
.claude/hooks/agent-loop.sh:422:        backoff_ms=$(echo "$handler_response" | jq -r '.backoffMs // 1000')
.claude/hooks/agent-loop.sh:423:
.claude/hooks/agent-loop.sh:424:        log "Error classified as: $error_classification (retry: $should_retry, backoff: ${backoff_ms}ms)"
.claude/hooks/agent-loop.sh:425:    fi
.claude/hooks/agent-loop.sh:426:    # ============================================================================
.claude/hooks/agent-loop.sh:427:
.claude/hooks/agent-loop.sh:428:    jq --arg error "$error" \
.claude/hooks/agent-loop.sh:429:       --arg ts "$timestamp" \
.claude/hooks/agent-loop.sh:430:       --arg classification "$error_classification" \
.claude/hooks/agent-loop.sh:431:       --arg retry "$should_retry" \
.claude/hooks/agent-loop.sh:432:       --argjson backoff "$backoff_ms" \
.claude/hooks/agent-loop.sh:433:       '
.claude/hooks/agent-loop.sh:434:       .consecutiveFailures += 1 |
.claude/hooks/agent-loop.sh:435:       .lastError = {
.claude/hooks/agent-loop.sh:436:           message: $error,
.claude/hooks/agent-loop.sh:437:           timestamp: $ts,
.claude/hooks/agent-loop.sh:438:           iteration: .iteration,
.claude/hooks/agent-loop.sh:439:           classification: $classification,
.claude/hooks/agent-loop.sh:440:           shouldRetry: ($retry == "true"),
.claude/hooks/agent-loop.sh:441:           backoffMs: $backoff
.claude/hooks/agent-loop.sh:442:       }
.claude/hooks/agent-loop.sh:443:       ' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:444:
.claude/hooks/agent-loop.sh:445:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:446:
.claude/hooks/agent-loop.sh:447:    log "Recorded failure: $error"
.claude/hooks/agent-loop.sh:448:
.claude/hooks/agent-loop.sh:449:    # Record failure to memory for learning
.claude/hooks/agent-loop.sh:450:    memory_record_failure "execution" "$goal" "$error"
.claude/hooks/agent-loop.sh:451:}
.claude/hooks/agent-loop.sh:452:
.claude/hooks/agent-loop.sh:453:# Record success (resets consecutive failures)
.claude/hooks/agent-loop.sh:454:record_success() {
.claude/hooks/agent-loop.sh:455:    local result="${1:-success}"
.claude/hooks/agent-loop.sh:456:
.claude/hooks/agent-loop.sh:457:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:458:        return 1
.claude/hooks/agent-loop.sh:459:    fi
.claude/hooks/agent-loop.sh:460:
.claude/hooks/agent-loop.sh:461:    local temp_file
.claude/hooks/agent-loop.sh:462:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:463:
.claude/hooks/agent-loop.sh:464:    local timestamp
.claude/hooks/agent-loop.sh:465:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/agent-loop.sh:466:
.claude/hooks/agent-loop.sh:467:    jq --arg result "$result" \
.claude/hooks/agent-loop.sh:468:       --arg ts "$timestamp" \
.claude/hooks/agent-loop.sh:469:       '
.claude/hooks/agent-loop.sh:470:       .consecutiveFailures = 0 |
.claude/hooks/agent-loop.sh:471:       .lastSuccess = {
.claude/hooks/agent-loop.sh:472:           result: $result,
.claude/hooks/agent-loop.sh:473:           timestamp: $ts,
.claude/hooks/agent-loop.sh:474:           iteration: .iteration
.claude/hooks/agent-loop.sh:475:       }
.claude/hooks/agent-loop.sh:476:       ' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:477:
.claude/hooks/agent-loop.sh:478:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:479:}
.claude/hooks/agent-loop.sh:480:
.claude/hooks/agent-loop.sh:481:# =============================================================================
.claude/hooks/agent-loop.sh:482:# TOOL EXECUTION (from UI-TARS patterns)
.claude/hooks/agent-loop.sh:483:# =============================================================================
.claude/hooks/agent-loop.sh:484:
.claude/hooks/agent-loop.sh:485:# Execute a tool call
.claude/hooks/agent-loop.sh:486:execute_tool() {
.claude/hooks/agent-loop.sh:487:    local tool_name="$1"
.claude/hooks/agent-loop.sh:488:    shift
.claude/hooks/agent-loop.sh:489:    local args=("$@")
.claude/hooks/agent-loop.sh:490:
.claude/hooks/agent-loop.sh:491:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:492:        echo '{"success":false,"error":"no_active_agent"}'
.claude/hooks/agent-loop.sh:493:        return 1
.claude/hooks/agent-loop.sh:494:    fi
.claude/hooks/agent-loop.sh:495:
.claude/hooks/agent-loop.sh:496:    local temp_file
.claude/hooks/agent-loop.sh:497:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:498:
.claude/hooks/agent-loop.sh:499:    local timestamp
.claude/hooks/agent-loop.sh:500:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/agent-loop.sh:501:
.claude/hooks/agent-loop.sh:502:    local tool_call_id
.claude/hooks/agent-loop.sh:503:    tool_call_id="tool_$(date +%s%N | cut -c1-13)"
.claude/hooks/agent-loop.sh:504:
.claude/hooks/agent-loop.sh:505:    # Record tool call start
.claude/hooks/agent-loop.sh:506:    jq --arg id "$tool_call_id" \
.claude/hooks/agent-loop.sh:507:       --arg name "$tool_name" \
.claude/hooks/agent-loop.sh:508:       --arg args "${args[*]}" \
.claude/hooks/agent-loop.sh:509:       --arg ts "$timestamp" \
.claude/hooks/agent-loop.sh:510:       '
.claude/hooks/agent-loop.sh:511:       .toolCalls += [{
.claude/hooks/agent-loop.sh:512:           id: $id,
.claude/hooks/agent-loop.sh:513:           name: $name,
.claude/hooks/agent-loop.sh:514:           args: $args,
.claude/hooks/agent-loop.sh:515:           startedAt: $ts,
.claude/hooks/agent-loop.sh:516:           status: "running"
.claude/hooks/agent-loop.sh:517:       }]
.claude/hooks/agent-loop.sh:518:       ' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:519:
.claude/hooks/agent-loop.sh:520:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:521:
.claude/hooks/agent-loop.sh:522:    log "Executing tool: $tool_name (id: $tool_call_id)"
.claude/hooks/agent-loop.sh:523:
.claude/hooks/agent-loop.sh:524:    # ============================================================================
.claude/hooks/agent-loop.sh:525:    # VALIDATION GATE: Check if command is safe before execution
.claude/hooks/agent-loop.sh:526:    # ============================================================================
.claude/hooks/agent-loop.sh:527:    local VALIDATION_GATE="${HOME}/.claude/hooks/validation-gate.sh"
.claude/hooks/agent-loop.sh:528:    if [[ -x "$VALIDATION_GATE" && "$tool_name" == "shell" ]]; then
.claude/hooks/agent-loop.sh:529:        local validation_result
.claude/hooks/agent-loop.sh:530:        validation_result=$("$VALIDATION_GATE" validate "${args[*]}" 2>/dev/null || echo '{"safe":true}')
.claude/hooks/agent-loop.sh:531:
.claude/hooks/agent-loop.sh:532:        local is_safe
.claude/hooks/agent-loop.sh:533:        is_safe=$(echo "$validation_result" | jq -r '.safe // true')
.claude/hooks/agent-loop.sh:534:
.claude/hooks/agent-loop.sh:535:        if [[ "$is_safe" == "false" ]]; then
.claude/hooks/agent-loop.sh:536:            local reason
.claude/hooks/agent-loop.sh:537:            reason=$(echo "$validation_result" | jq -r '.reason // "Command blocked by safety check"')
.claude/hooks/agent-loop.sh:538:            log "  Validation gate blocked command: ${args[*]} - $reason"
.claude/hooks/agent-loop.sh:539:
.claude/hooks/agent-loop.sh:540:            # Return validation error
.claude/hooks/agent-loop.sh:541:            jq -n \
.claude/hooks/agent-loop.sh:542:                --arg id "$tool_call_id" \
.claude/hooks/agent-loop.sh:543:                --arg name "$tool_name" \
.claude/hooks/agent-loop.sh:544:                --arg reason "$reason" \
.claude/hooks/agent-loop.sh:545:                '{
.claude/hooks/agent-loop.sh:546:                    id: $id,
.claude/hooks/agent-loop.sh:547:                    name: $name,
.claude/hooks/agent-loop.sh:548:                    success: false,
.claude/hooks/agent-loop.sh:549:                    result: ("BLOCKED: " + $reason),
.claude/hooks/agent-loop.sh:550:                    exitCode: 126,
.claude/hooks/agent-loop.sh:551:                    durationMs: 0
.claude/hooks/agent-loop.sh:552:                }'
.claude/hooks/agent-loop.sh:553:            return 126
.claude/hooks/agent-loop.sh:554:        fi
.claude/hooks/agent-loop.sh:555:        log " Validation gate: Command approved"
.claude/hooks/agent-loop.sh:556:    fi
.claude/hooks/agent-loop.sh:557:    # ============================================================================
.claude/hooks/agent-loop.sh:558:
.claude/hooks/agent-loop.sh:559:    # Execute the tool
.claude/hooks/agent-loop.sh:560:    local result
.claude/hooks/agent-loop.sh:561:    local exit_code
.claude/hooks/agent-loop.sh:562:    local start_time
.claude/hooks/agent-loop.sh:563:    start_time=$(date +%s%N)
.claude/hooks/agent-loop.sh:564:
.claude/hooks/agent-loop.sh:565:    case "$tool_name" in
.claude/hooks/agent-loop.sh:566:        read_file)
.claude/hooks/agent-loop.sh:567:            result=$(cat "${args[0]}" 2>&1)
.claude/hooks/agent-loop.sh:568:            exit_code=$?
.claude/hooks/agent-loop.sh:569:            ;;
.claude/hooks/agent-loop.sh:570:        search_code)
.claude/hooks/agent-loop.sh:571:            result=$(grep -r "${args[0]}" "${args[1]:-.}" 2>&1 | head -50)
.claude/hooks/agent-loop.sh:572:            exit_code=$?
.claude/hooks/agent-loop.sh:573:            ;;
.claude/hooks/agent-loop.sh:574:        run_tests)
.claude/hooks/agent-loop.sh:575:            result=$(npm test 2>&1 || pytest 2>&1 || go test ./... 2>&1)
.claude/hooks/agent-loop.sh:576:            exit_code=$?
.claude/hooks/agent-loop.sh:577:            ;;
.claude/hooks/agent-loop.sh:578:        lint_code)
.claude/hooks/agent-loop.sh:579:            result=$(npm run lint 2>&1 || ruff check . 2>&1 || go vet ./... 2>&1)
.claude/hooks/agent-loop.sh:580:            exit_code=$?
.claude/hooks/agent-loop.sh:581:            ;;
.claude/hooks/agent-loop.sh:582:        typecheck)
.claude/hooks/agent-loop.sh:583:            result=$(npm run typecheck 2>&1 || npx tsc --noEmit 2>&1 || mypy . 2>&1)
.claude/hooks/agent-loop.sh:584:            exit_code=$?
.claude/hooks/agent-loop.sh:585:            ;;
.claude/hooks/agent-loop.sh:586:        shell)
.claude/hooks/agent-loop.sh:587:            result=$(bash -c "${args[*]}" 2>&1)
.claude/hooks/agent-loop.sh:588:            exit_code=$?
.claude/hooks/agent-loop.sh:589:            ;;
.claude/hooks/agent-loop.sh:590:        *)
.claude/hooks/agent-loop.sh:591:            result="Unknown tool: $tool_name"
.claude/hooks/agent-loop.sh:592:            exit_code=1
.claude/hooks/agent-loop.sh:593:            ;;
.claude/hooks/agent-loop.sh:594:    esac
.claude/hooks/agent-loop.sh:595:
.claude/hooks/agent-loop.sh:596:    local end_time
.claude/hooks/agent-loop.sh:597:    end_time=$(date +%s%N)
.claude/hooks/agent-loop.sh:598:    local duration=$(( (end_time - start_time) / 1000000 ))  # ms
.claude/hooks/agent-loop.sh:599:
.claude/hooks/agent-loop.sh:600:    # Update tool call with result
.claude/hooks/agent-loop.sh:601:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:602:    local end_timestamp
.claude/hooks/agent-loop.sh:603:    end_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/agent-loop.sh:604:
.claude/hooks/agent-loop.sh:605:    # Truncate result if too long
.claude/hooks/agent-loop.sh:606:    if [[ ${#result} -gt 10000 ]]; then
.claude/hooks/agent-loop.sh:607:        result="${result:0:10000}... (truncated)"
.claude/hooks/agent-loop.sh:608:    fi
.claude/hooks/agent-loop.sh:609:
.claude/hooks/agent-loop.sh:610:    jq --arg id "$tool_call_id" \
.claude/hooks/agent-loop.sh:611:       --arg result "$result" \
.claude/hooks/agent-loop.sh:612:       --argjson code "$exit_code" \
.claude/hooks/agent-loop.sh:613:       --argjson duration "$duration" \
.claude/hooks/agent-loop.sh:614:       --arg ts "$end_timestamp" \
.claude/hooks/agent-loop.sh:615:       '
.claude/hooks/agent-loop.sh:616:       .toolCalls = [.toolCalls[] |
.claude/hooks/agent-loop.sh:617:           if .id == $id then
.claude/hooks/agent-loop.sh:618:               . + {
.claude/hooks/agent-loop.sh:619:                   result: $result,
.claude/hooks/agent-loop.sh:620:                   exitCode: $code,
.claude/hooks/agent-loop.sh:621:                   duration: $duration,
.claude/hooks/agent-loop.sh:622:                   completedAt: $ts,
.claude/hooks/agent-loop.sh:623:                   status: (if $code == 0 then "success" else "failed" end)
.claude/hooks/agent-loop.sh:624:               }
.claude/hooks/agent-loop.sh:625:           else . end
.claude/hooks/agent-loop.sh:626:       ]
.claude/hooks/agent-loop.sh:627:       ' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:628:
.claude/hooks/agent-loop.sh:629:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:630:
.claude/hooks/agent-loop.sh:631:    log "Tool completed: $tool_name (exit: $exit_code, duration: ${duration}ms)"
.claude/hooks/agent-loop.sh:632:
.claude/hooks/agent-loop.sh:633:    # Return result as JSON
.claude/hooks/agent-loop.sh:634:    jq -n \
.claude/hooks/agent-loop.sh:635:        --arg id "$tool_call_id" \
.claude/hooks/agent-loop.sh:636:        --arg name "$tool_name" \
.claude/hooks/agent-loop.sh:637:        --argjson success "$([ $exit_code -eq 0 ] && echo true || echo false)" \
.claude/hooks/agent-loop.sh:638:        --arg result "$result" \
.claude/hooks/agent-loop.sh:639:        --argjson exitCode "$exit_code" \
.claude/hooks/agent-loop.sh:640:        --argjson duration "$duration" \
.claude/hooks/agent-loop.sh:641:        '{
.claude/hooks/agent-loop.sh:642:            id: $id,
.claude/hooks/agent-loop.sh:643:            name: $name,
.claude/hooks/agent-loop.sh:644:            success: $success,
.claude/hooks/agent-loop.sh:645:            result: $result,
.claude/hooks/agent-loop.sh:646:            exitCode: $exitCode,
.claude/hooks/agent-loop.sh:647:            durationMs: $duration
.claude/hooks/agent-loop.sh:648:        }'
.claude/hooks/agent-loop.sh:649:}
.claude/hooks/agent-loop.sh:650:
.claude/hooks/agent-loop.sh:651:# =============================================================================
.claude/hooks/agent-loop.sh:652:# LOOP LIFECYCLE HOOKS (from UI-TARS AgentComposer patterns)
.claude/hooks/agent-loop.sh:653:# =============================================================================
.claude/hooks/agent-loop.sh:654:
.claude/hooks/agent-loop.sh:655:# Called at start of each iteration
.claude/hooks/agent-loop.sh:656:on_loop_start() {
.claude/hooks/agent-loop.sh:657:    local iteration
.claude/hooks/agent-loop.sh:658:    iteration=$(jq -r '.iteration' "$AGENT_STATE" 2>/dev/null || echo "0")
.claude/hooks/agent-loop.sh:659:
.claude/hooks/agent-loop.sh:660:    log "Loop iteration $iteration starting"
.claude/hooks/agent-loop.sh:661:
.claude/hooks/agent-loop.sh:662:    # Log to execution log
.claude/hooks/agent-loop.sh:663:    echo "=== Iteration $iteration ===" >> "$EXECUTION_LOG"
.claude/hooks/agent-loop.sh:664:    echo "Time: $(date '+%Y-%m-%d %H:%M:%S')" >> "$EXECUTION_LOG"
.claude/hooks/agent-loop.sh:665:
.claude/hooks/agent-loop.sh:666:    # Check health
.claude/hooks/agent-loop.sh:667:    if [[ -x "${HOME}/.claude/hooks/self-healing.sh" ]]; then
.claude/hooks/agent-loop.sh:668:        local health
.claude/hooks/agent-loop.sh:669:        health=$("${HOME}/.claude/hooks/self-healing.sh" health 2>/dev/null)
.claude/hooks/agent-loop.sh:670:        if [[ "$health" != "healthy" ]]; then
.claude/hooks/agent-loop.sh:671:            log "Health check: $health - attempting recovery"
.claude/hooks/agent-loop.sh:672:            "${HOME}/.claude/hooks/self-healing.sh" recover 2>/dev/null
.claude/hooks/agent-loop.sh:673:        fi
.claude/hooks/agent-loop.sh:674:    fi
.claude/hooks/agent-loop.sh:675:}
.claude/hooks/agent-loop.sh:676:
.claude/hooks/agent-loop.sh:677:# Called at end of each iteration
.claude/hooks/agent-loop.sh:678:on_loop_end() {
.claude/hooks/agent-loop.sh:679:    local iteration
.claude/hooks/agent-loop.sh:680:    iteration=$(jq -r '.iteration' "$AGENT_STATE" 2>/dev/null || echo "0")
.claude/hooks/agent-loop.sh:681:
.claude/hooks/agent-loop.sh:682:    local state
.claude/hooks/agent-loop.sh:683:    state=$(jq -r '.state' "$AGENT_STATE" 2>/dev/null || echo "unknown")
.claude/hooks/agent-loop.sh:684:
.claude/hooks/agent-loop.sh:685:    local goal
.claude/hooks/agent-loop.sh:686:    goal=$(jq -r '.goal' "$AGENT_STATE" 2>/dev/null || echo "")
.claude/hooks/agent-loop.sh:687:
.claude/hooks/agent-loop.sh:688:    log "Loop iteration $iteration ended (state: $state)"
.claude/hooks/agent-loop.sh:689:
.claude/hooks/agent-loop.sh:690:    # Update metrics
.claude/hooks/agent-loop.sh:691:    if [[ -x "${HOME}/.claude/hooks/metrics-collector.sh" ]]; then
.claude/hooks/agent-loop.sh:692:        "${HOME}/.claude/hooks/metrics-collector.sh" tool "agent_loop" 0 2>/dev/null
.claude/hooks/agent-loop.sh:693:    fi
.claude/hooks/agent-loop.sh:694:
.claude/hooks/agent-loop.sh:695:    # Update progress
.claude/hooks/agent-loop.sh:696:    if [[ -x "${HOME}/.claude/hooks/progress-tracker.sh" ]]; then
.claude/hooks/agent-loop.sh:697:        "${HOME}/.claude/hooks/progress-tracker.sh" update "$iteration" "Iteration $iteration" "Processing..." 2>/dev/null
.claude/hooks/agent-loop.sh:698:    fi
.claude/hooks/agent-loop.sh:699:
.claude/hooks/agent-loop.sh:700:    # Record iteration to memory (every 5 iterations to avoid noise)
.claude/hooks/agent-loop.sh:701:    if [[ $((iteration % 5)) -eq 0 && -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:702:        local tool_count
.claude/hooks/agent-loop.sh:703:        tool_count=$(jq '.toolCalls | length' "$AGENT_STATE" 2>/dev/null || echo "0")
.claude/hooks/agent-loop.sh:704:
.claude/hooks/agent-loop.sh:705:        "$MEMORY_MANAGER" add-context "Iteration $iteration: state=$state, tools=$tool_count" 3 2>/dev/null
.claude/hooks/agent-loop.sh:706:    fi
.claude/hooks/agent-loop.sh:707:}
.claude/hooks/agent-loop.sh:708:
.claude/hooks/agent-loop.sh:709:# =============================================================================
.claude/hooks/agent-loop.sh:710:# CONTROL COMMANDS
.claude/hooks/agent-loop.sh:711:# =============================================================================
.claude/hooks/agent-loop.sh:712:
.claude/hooks/agent-loop.sh:713:# Request pause
.claude/hooks/agent-loop.sh:714:request_pause() {
.claude/hooks/agent-loop.sh:715:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:716:        return 1
.claude/hooks/agent-loop.sh:717:    fi
.claude/hooks/agent-loop.sh:718:
.claude/hooks/agent-loop.sh:719:    local temp_file
.claude/hooks/agent-loop.sh:720:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:721:
.claude/hooks/agent-loop.sh:722:    jq '.pauseRequested = true' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:723:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:724:
.claude/hooks/agent-loop.sh:725:    log "Pause requested"
.claude/hooks/agent-loop.sh:726:}
.claude/hooks/agent-loop.sh:727:
.claude/hooks/agent-loop.sh:728:# Resume from pause
.claude/hooks/agent-loop.sh:729:resume() {
.claude/hooks/agent-loop.sh:730:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:731:        return 1
.claude/hooks/agent-loop.sh:732:    fi
.claude/hooks/agent-loop.sh:733:
.claude/hooks/agent-loop.sh:734:    local temp_file
.claude/hooks/agent-loop.sh:735:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:736:
.claude/hooks/agent-loop.sh:737:    jq '.pauseRequested = false | .state = "executing"' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:738:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:739:
.claude/hooks/agent-loop.sh:740:    log "Resumed from pause"
.claude/hooks/agent-loop.sh:741:}
.claude/hooks/agent-loop.sh:742:
.claude/hooks/agent-loop.sh:743:# Request stop
.claude/hooks/agent-loop.sh:744:request_stop() {
.claude/hooks/agent-loop.sh:745:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:746:        return 1
.claude/hooks/agent-loop.sh:747:    fi
.claude/hooks/agent-loop.sh:748:
.claude/hooks/agent-loop.sh:749:    local temp_file
.claude/hooks/agent-loop.sh:750:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:751:
.claude/hooks/agent-loop.sh:752:    jq '.stopRequested = true' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:753:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:754:
.claude/hooks/agent-loop.sh:755:    log "Stop requested"
.claude/hooks/agent-loop.sh:756:}
.claude/hooks/agent-loop.sh:757:
.claude/hooks/agent-loop.sh:758:# Complete agent
.claude/hooks/agent-loop.sh:759:complete_agent() {
.claude/hooks/agent-loop.sh:760:    local result="${1:-success}"
.claude/hooks/agent-loop.sh:761:    local summary="${2:-}"
.claude/hooks/agent-loop.sh:762:
.claude/hooks/agent-loop.sh:763:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:764:        return 1
.claude/hooks/agent-loop.sh:765:    fi
.claude/hooks/agent-loop.sh:766:
.claude/hooks/agent-loop.sh:767:    local temp_file
.claude/hooks/agent-loop.sh:768:    temp_file=$(mktemp)
.claude/hooks/agent-loop.sh:769:
.claude/hooks/agent-loop.sh:770:    local timestamp
.claude/hooks/agent-loop.sh:771:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/agent-loop.sh:772:
.claude/hooks/agent-loop.sh:773:    local goal
.claude/hooks/agent-loop.sh:774:    goal=$(jq -r '.goal' "$AGENT_STATE" 2>/dev/null || echo "")
.claude/hooks/agent-loop.sh:775:
.claude/hooks/agent-loop.sh:776:    local iteration
.claude/hooks/agent-loop.sh:777:    iteration=$(jq -r '.iteration' "$AGENT_STATE" 2>/dev/null || echo "0")
.claude/hooks/agent-loop.sh:778:
.claude/hooks/agent-loop.sh:779:    local tool_count
.claude/hooks/agent-loop.sh:780:    tool_count=$(jq '.toolCalls | length' "$AGENT_STATE" 2>/dev/null || echo "0")
.claude/hooks/agent-loop.sh:781:
.claude/hooks/agent-loop.sh:782:    local success_count
.claude/hooks/agent-loop.sh:783:    success_count=$(jq '[.toolCalls[] | select(.status == "success")] | length' "$AGENT_STATE" 2>/dev/null || echo "0")
.claude/hooks/agent-loop.sh:784:
.claude/hooks/agent-loop.sh:785:    jq --arg result "$result" \
.claude/hooks/agent-loop.sh:786:       --arg summary "$summary" \
.claude/hooks/agent-loop.sh:787:       --arg ts "$timestamp" \
.claude/hooks/agent-loop.sh:788:       '
.claude/hooks/agent-loop.sh:789:       .state = "completed" |
.claude/hooks/agent-loop.sh:790:       .result = $result |
.claude/hooks/agent-loop.sh:791:       .summary = $summary |
.claude/hooks/agent-loop.sh:792:       .completedAt = $ts |
.claude/hooks/agent-loop.sh:793:       .totalDuration = (
.claude/hooks/agent-loop.sh:794:           (($ts | fromdate) - (.startedAt | fromdate)) | floor
.claude/hooks/agent-loop.sh:795:       )
.claude/hooks/agent-loop.sh:796:       ' "$AGENT_STATE" > "$temp_file"
.claude/hooks/agent-loop.sh:797:
.claude/hooks/agent-loop.sh:798:    mv "$temp_file" "$AGENT_STATE"
.claude/hooks/agent-loop.sh:799:
.claude/hooks/agent-loop.sh:800:    log "Agent completed: $result"
.claude/hooks/agent-loop.sh:801:
.claude/hooks/agent-loop.sh:802:    # Record to memory
.claude/hooks/agent-loop.sh:803:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/agent-loop.sh:804:        # Record episode
.claude/hooks/agent-loop.sh:805:        local details="iterations=$iteration, tools=$tool_count, success=$success_count"
.claude/hooks/agent-loop.sh:806:        memory_record_success "task_complete" "$goal" "$details"
.claude/hooks/agent-loop.sh:807:
.claude/hooks/agent-loop.sh:808:        # Create reflection
.claude/hooks/agent-loop.sh:809:        local reflection_content="Completed: $goal. Used $tool_count tools across $iteration iterations. Result: $result"
.claude/hooks/agent-loop.sh:810:        memory_reflect "progress" "$reflection_content" "$summary"
.claude/hooks/agent-loop.sh:811:
.claude/hooks/agent-loop.sh:812:        # Clear working memory for next task
.claude/hooks/agent-loop.sh:813:        "$MEMORY_MANAGER" clear-working 2>/dev/null
.claude/hooks/agent-loop.sh:814:    fi
.claude/hooks/agent-loop.sh:815:}
.claude/hooks/agent-loop.sh:816:
.claude/hooks/agent-loop.sh:817:# Get agent status
.claude/hooks/agent-loop.sh:818:get_status() {
.claude/hooks/agent-loop.sh:819:    if [[ -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:820:        jq '.' "$AGENT_STATE"
.claude/hooks/agent-loop.sh:821:    else
.claude/hooks/agent-loop.sh:822:        echo '{"state":"no_agent"}'
.claude/hooks/agent-loop.sh:823:    fi
.claude/hooks/agent-loop.sh:824:}
.claude/hooks/agent-loop.sh:825:
.claude/hooks/agent-loop.sh:826:# Get execution summary
.claude/hooks/agent-loop.sh:827:get_summary() {
.claude/hooks/agent-loop.sh:828:    if [[ ! -f "$AGENT_STATE" ]]; then
.claude/hooks/agent-loop.sh:829:        echo "No active agent"
.claude/hooks/agent-loop.sh:830:        return
.claude/hooks/agent-loop.sh:831:    fi
.claude/hooks/agent-loop.sh:832:
.claude/hooks/agent-loop.sh:833:    jq -r '
.claude/hooks/agent-loop.sh:834:        "=== Agent Status ===\n" +
.claude/hooks/agent-loop.sh:835:        "Goal: \(.goal)\n" +
.claude/hooks/agent-loop.sh:836:        "State: \(.state)\n" +
.claude/hooks/agent-loop.sh:837:        "Iteration: \(.iteration)/\(.maxIterations)\n" +
.claude/hooks/agent-loop.sh:838:        "Failures: \(.consecutiveFailures)\n" +
.claude/hooks/agent-loop.sh:839:        "Tool Calls: \(.toolCalls | length)\n" +
.claude/hooks/agent-loop.sh:840:        "Successful Tools: \([.toolCalls[] | select(.status == "success")] | length)\n" +
.claude/hooks/agent-loop.sh:841:        "Duration: \(if .completedAt then .totalDuration else "running" end)\n"
.claude/hooks/agent-loop.sh:842:    ' "$AGENT_STATE"
.claude/hooks/agent-loop.sh:843:}
.claude/hooks/agent-loop.sh:844:
.claude/hooks/agent-loop.sh:845:# =============================================================================
.claude/hooks/agent-loop.sh:846:# COMMAND INTERFACE
.claude/hooks/agent-loop.sh:847:# =============================================================================
.claude/hooks/agent-loop.sh:848:
.claude/hooks/agent-loop.sh:849:case "${1:-help}" in
.claude/hooks/agent-loop.sh:850:    start)
.claude/hooks/agent-loop.sh:851:        start_agent "${2:-goal}" "${3:-}"
.claude/hooks/agent-loop.sh:852:        ;;
.claude/hooks/agent-loop.sh:853:    transition)
.claude/hooks/agent-loop.sh:854:        transition_state "${2:-executing}" "${3:-}"
.claude/hooks/agent-loop.sh:855:        ;;
.claude/hooks/agent-loop.sh:856:    should-continue)
.claude/hooks/agent-loop.sh:857:        should_continue
.claude/hooks/agent-loop.sh:858:        ;;
.claude/hooks/agent-loop.sh:859:    iterate)
.claude/hooks/agent-loop.sh:860:        increment_iteration
.claude/hooks/agent-loop.sh:861:        ;;
.claude/hooks/agent-loop.sh:862:    failure)
.claude/hooks/agent-loop.sh:863:        record_failure "${2:-unknown}"
.claude/hooks/agent-loop.sh:864:        ;;
.claude/hooks/agent-loop.sh:865:    success)
.claude/hooks/agent-loop.sh:866:        record_success "${2:-success}"
.claude/hooks/agent-loop.sh:867:        ;;
.claude/hooks/agent-loop.sh:868:    execute)
.claude/hooks/agent-loop.sh:869:        tool_name="${2:-shell}"
.claude/hooks/agent-loop.sh:870:        shift 2 2>/dev/null || shift 1
.claude/hooks/agent-loop.sh:871:        execute_tool "$tool_name" "$@"
.claude/hooks/agent-loop.sh:872:        ;;
.claude/hooks/agent-loop.sh:873:    on-start)
.claude/hooks/agent-loop.sh:874:        on_loop_start
.claude/hooks/agent-loop.sh:875:        ;;
.claude/hooks/agent-loop.sh:876:    on-end)
.claude/hooks/agent-loop.sh:877:        on_loop_end
.claude/hooks/agent-loop.sh:878:        ;;
.claude/hooks/agent-loop.sh:879:    pause)
.claude/hooks/agent-loop.sh:880:        request_pause
.claude/hooks/agent-loop.sh:881:        ;;
.claude/hooks/agent-loop.sh:882:    resume)
.claude/hooks/agent-loop.sh:883:        resume
.claude/hooks/agent-loop.sh:884:        ;;
.claude/hooks/agent-loop.sh:885:    stop)
.claude/hooks/agent-loop.sh:886:        request_stop
.claude/hooks/agent-loop.sh:887:        ;;
.claude/hooks/agent-loop.sh:888:    complete)
.claude/hooks/agent-loop.sh:889:        complete_agent "${2:-success}" "${3:-}"
.claude/hooks/agent-loop.sh:890:        ;;
.claude/hooks/agent-loop.sh:891:    status)
.claude/hooks/agent-loop.sh:892:        get_status
.claude/hooks/agent-loop.sh:893:        ;;
.claude/hooks/agent-loop.sh:894:    summary)
.claude/hooks/agent-loop.sh:895:        get_summary
.claude/hooks/agent-loop.sh:896:        ;;
.claude/hooks/agent-loop.sh:897:
.claude/hooks/agent-loop.sh:898:    # Memory commands
.claude/hooks/agent-loop.sh:899:    memory-init)
.claude/hooks/agent-loop.sh:900:        memory_init
.claude/hooks/agent-loop.sh:901:        ;;
.claude/hooks/agent-loop.sh:902:    memory-context)
.claude/hooks/agent-loop.sh:903:        memory_retrieve_context "${2:-}" "${3:-5}"
.claude/hooks/agent-loop.sh:904:        ;;
.claude/hooks/agent-loop.sh:905:    memory-patterns)
.claude/hooks/agent-loop.sh:906:        memory_find_patterns "${2:-}" "${3:-3}"
.claude/hooks/agent-loop.sh:907:        ;;
.claude/hooks/agent-loop.sh:908:    memory-learn)
.claude/hooks/agent-loop.sh:909:        memory_learn_pattern "${2:-workflow}" "${3:-}" "${4:-}" "${5:-1.0}"
.claude/hooks/agent-loop.sh:910:        ;;
.claude/hooks/agent-loop.sh:911:    memory-record)
.claude/hooks/agent-loop.sh:912:        memory_record_success "${2:-task}" "${3:-}" "${4:-}"
.claude/hooks/agent-loop.sh:913:        ;;
.claude/hooks/agent-loop.sh:914:    memory-reflect)
.claude/hooks/agent-loop.sh:915:        memory_reflect "${2:-progress}" "${3:-}" "${4:-}"
.claude/hooks/agent-loop.sh:916:        ;;
.claude/hooks/agent-loop.sh:917:    memory-stats)
.claude/hooks/agent-loop.sh:918:        memory_stats
.claude/hooks/agent-loop.sh:919:        ;;
.claude/hooks/agent-loop.sh:920:
.claude/hooks/agent-loop.sh:921:    help|*)
.claude/hooks/agent-loop.sh:922:        echo "Agent Loop - Autonomous Execution System"
.claude/hooks/agent-loop.sh:923:        echo ""
.claude/hooks/agent-loop.sh:924:        echo "Usage: $0 <command> [args]"
.claude/hooks/agent-loop.sh:925:        echo ""
.claude/hooks/agent-loop.sh:926:        echo "Lifecycle Commands:"
.claude/hooks/agent-loop.sh:927:        echo "  start <goal> [context]      - Start new agent"
.claude/hooks/agent-loop.sh:928:        echo "  transition <state> [reason] - Change agent state"
.claude/hooks/agent-loop.sh:929:        echo "  complete <result> [summary] - Complete agent"
.claude/hooks/agent-loop.sh:930:        echo ""
.claude/hooks/agent-loop.sh:931:        echo "Loop Control:"
.claude/hooks/agent-loop.sh:932:        echo "  should-continue             - Check if loop should continue"
.claude/hooks/agent-loop.sh:933:        echo "  iterate                     - Increment iteration counter"
.claude/hooks/agent-loop.sh:934:        echo "  failure <error>             - Record a failure"
.claude/hooks/agent-loop.sh:935:        echo "  success <result>            - Record a success"
.claude/hooks/agent-loop.sh:936:        echo "  pause                       - Request pause"
.claude/hooks/agent-loop.sh:937:        echo "  resume                      - Resume from pause"
.claude/hooks/agent-loop.sh:938:        echo "  stop                        - Request stop"
.claude/hooks/agent-loop.sh:939:        echo ""
.claude/hooks/agent-loop.sh:940:        echo "Tool Execution:"
.claude/hooks/agent-loop.sh:941:        echo "  execute <tool> [args...]    - Execute a tool"
.claude/hooks/agent-loop.sh:942:        echo "    Tools: read_file, search_code, run_tests, lint_code, typecheck, shell"
.claude/hooks/agent-loop.sh:943:        echo ""
.claude/hooks/agent-loop.sh:944:        echo "Hooks:"
.claude/hooks/agent-loop.sh:945:        echo "  on-start                    - Call at loop start"
.claude/hooks/agent-loop.sh:946:        echo "  on-end                      - Call at loop end"
.claude/hooks/agent-loop.sh:947:        echo ""
.claude/hooks/agent-loop.sh:948:        echo "Status:"
.claude/hooks/agent-loop.sh:949:        echo "  status                      - Get full status JSON"
.claude/hooks/agent-loop.sh:950:        echo "  summary                     - Get human-readable summary"
.claude/hooks/agent-loop.sh:951:        echo ""
.claude/hooks/agent-loop.sh:952:        echo "Memory Integration:"
.claude/hooks/agent-loop.sh:953:        echo "  memory-init                 - Initialize memory system"
.claude/hooks/agent-loop.sh:954:        echo "  memory-context <query>      - Retrieve relevant memories"
.claude/hooks/agent-loop.sh:955:        echo "  memory-patterns <query>     - Find known patterns"
.claude/hooks/agent-loop.sh:956:        echo "  memory-learn <type> <trigger> <solution>"
.claude/hooks/agent-loop.sh:957:        echo "                              - Learn a new pattern"
.claude/hooks/agent-loop.sh:958:        echo "  memory-record <type> <desc> - Record to memory"
.claude/hooks/agent-loop.sh:959:        echo "  memory-reflect <focus> <content>"
.claude/hooks/agent-loop.sh:960:        echo "                              - Create reflection"
.claude/hooks/agent-loop.sh:961:        echo "  memory-stats                - Get memory statistics"
.claude/hooks/agent-loop.sh:962:        ;;
.claude/hooks/agent-loop.sh:963:esac
.claude/hooks/memory-manager.sh:1:#!/bin/bash
.claude/hooks/memory-manager.sh:2:# Memory Manager - Persistent memory for Claude Code sessions
.claude/hooks/memory-manager.sh:3:# Based on patterns from: MemGPT/Letta, Generative Agents (Stanford), Mem0, LangChain, CrewAI
.claude/hooks/memory-manager.sh:4:#
.claude/hooks/memory-manager.sh:5:# Supports both global and project-scoped memory:
.claude/hooks/memory-manager.sh:6:# - Global: ~/.claude/memory/ (shared across all projects)
.claude/hooks/memory-manager.sh:7:# - Project: .claude/memory/ (project-specific, auto-detected)
.claude/hooks/memory-manager.sh:8:#
.claude/hooks/memory-manager.sh:9:# Set MEMORY_SCOPE=project to force project-local memory
.claude/hooks/memory-manager.sh:10:# Set MEMORY_SCOPE=global to force global memory
.claude/hooks/memory-manager.sh:11:
.claude/hooks/memory-manager.sh:12:set -uo pipefail
.claude/hooks/memory-manager.sh:13:
.claude/hooks/memory-manager.sh:14:# Detect project root (look for .git, package.json, Cargo.toml, etc.)
.claude/hooks/memory-manager.sh:15:find_project_root() {
.claude/hooks/memory-manager.sh:16:    local dir="$PWD"
.claude/hooks/memory-manager.sh:17:    while [[ "$dir" != "/" ]]; do
.claude/hooks/memory-manager.sh:18:        if [[ -d "$dir/.git" ]] || [[ -f "$dir/package.json" ]] || \
.claude/hooks/memory-manager.sh:19:           [[ -f "$dir/Cargo.toml" ]] || [[ -f "$dir/go.mod" ]] || \
.claude/hooks/memory-manager.sh:20:           [[ -f "$dir/pyproject.toml" ]] || [[ -f "$dir/CLAUDE.md" ]]; then
.claude/hooks/memory-manager.sh:21:            echo "$dir"
.claude/hooks/memory-manager.sh:22:            return 0
.claude/hooks/memory-manager.sh:23:        fi
.claude/hooks/memory-manager.sh:24:        dir="$(dirname "$dir")"
.claude/hooks/memory-manager.sh:25:    done
.claude/hooks/memory-manager.sh:26:    return 1
.claude/hooks/memory-manager.sh:27:}
.claude/hooks/memory-manager.sh:28:
.claude/hooks/memory-manager.sh:29:# Get git channel (branch name, sanitized)
.claude/hooks/memory-manager.sh:30:# Based on patterns from GitHub: git rev-parse --abbrev-ref HEAD
.claude/hooks/memory-manager.sh:31:get_git_channel() {
.claude/hooks/memory-manager.sh:32:    local branch
.claude/hooks/memory-manager.sh:33:
.claude/hooks/memory-manager.sh:34:    # Check if we're in a git repo
.claude/hooks/memory-manager.sh:35:    if git rev-parse --git-dir >/dev/null 2>&1; then
.claude/hooks/memory-manager.sh:36:        branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
.claude/hooks/memory-manager.sh:37:
.claude/hooks/memory-manager.sh:38:        # Handle edge case: newly initialized repo with no commits returns "HEAD"
.claude/hooks/memory-manager.sh:39:        if [[ "$branch" == "HEAD" ]]; then
.claude/hooks/memory-manager.sh:40:            # Try to get default branch name from git config
.claude/hooks/memory-manager.sh:41:            branch=$(git config --get init.defaultBranch 2>/dev/null || echo "main")
.claude/hooks/memory-manager.sh:42:        fi
.claude/hooks/memory-manager.sh:43:    else
.claude/hooks/memory-manager.sh:44:        branch="main"
.claude/hooks/memory-manager.sh:45:    fi
.claude/hooks/memory-manager.sh:46:
.claude/hooks/memory-manager.sh:47:    # Sanitize branch name: replace non-alphanumeric with dashes
.claude/hooks/memory-manager.sh:48:    echo "$branch" | sed 's/[^a-zA-Z0-9_-]/-/g'
.claude/hooks/memory-manager.sh:49:}
.claude/hooks/memory-manager.sh:50:
.claude/hooks/memory-manager.sh:51:# Determine memory directory based on scope
.claude/hooks/memory-manager.sh:52:get_memory_dir() {
.claude/hooks/memory-manager.sh:53:    local scope="${MEMORY_SCOPE:-auto}"
.claude/hooks/memory-manager.sh:54:    local channel
.claude/hooks/memory-manager.sh:55:    channel=$(get_git_channel)
.claude/hooks/memory-manager.sh:56:
.claude/hooks/memory-manager.sh:57:    if [[ "$scope" == "project" ]]; then
.claude/hooks/memory-manager.sh:58:        local project_root
.claude/hooks/memory-manager.sh:59:        if project_root=$(find_project_root); then
.claude/hooks/memory-manager.sh:60:            echo "$project_root/.claude/memory/$channel"
.claude/hooks/memory-manager.sh:61:            return 0
.claude/hooks/memory-manager.sh:62:        fi
.claude/hooks/memory-manager.sh:63:    elif [[ "$scope" == "global" ]]; then
.claude/hooks/memory-manager.sh:64:        echo "${HOME}/.claude/memory/$channel"
.claude/hooks/memory-manager.sh:65:        return 0
.claude/hooks/memory-manager.sh:66:    fi
.claude/hooks/memory-manager.sh:67:
.claude/hooks/memory-manager.sh:68:    # Auto mode: use project memory if in a project, otherwise global
.claude/hooks/memory-manager.sh:69:    local project_root
.claude/hooks/memory-manager.sh:70:    if project_root=$(find_project_root); then
.claude/hooks/memory-manager.sh:71:        echo "$project_root/.claude/memory/$channel"
.claude/hooks/memory-manager.sh:72:    else
.claude/hooks/memory-manager.sh:73:        echo "${HOME}/.claude/memory/$channel"
.claude/hooks/memory-manager.sh:74:    fi
.claude/hooks/memory-manager.sh:75:}
.claude/hooks/memory-manager.sh:76:
.claude/hooks/memory-manager.sh:77:MEMORY_DIR="$(get_memory_dir)"
.claude/hooks/memory-manager.sh:78:WORKING_MEMORY="$MEMORY_DIR/working.json"
.claude/hooks/memory-manager.sh:79:EPISODIC_MEMORY="$MEMORY_DIR/episodic.json"
.claude/hooks/memory-manager.sh:80:SEMANTIC_MEMORY="$MEMORY_DIR/semantic.json"
.claude/hooks/memory-manager.sh:81:ACTION_LOG="$MEMORY_DIR/actions.jsonl"
.claude/hooks/memory-manager.sh:82:REFLECTION_LOG="$MEMORY_DIR/reflections.json"
.claude/hooks/memory-manager.sh:83:LOG_FILE="${HOME}/.claude/memory-manager.log"
.claude/hooks/memory-manager.sh:84:
.claude/hooks/memory-manager.sh:85:# Memory limits
.claude/hooks/memory-manager.sh:86:MAX_WORKING_ITEMS="${MAX_WORKING_ITEMS:-50}"
.claude/hooks/memory-manager.sh:87:MAX_EPISODIC_ITEMS="${MAX_EPISODIC_ITEMS:-1000}"
.claude/hooks/memory-manager.sh:88:MAX_SEMANTIC_ITEMS="${MAX_SEMANTIC_ITEMS:-500}"
.claude/hooks/memory-manager.sh:89:
.claude/hooks/memory-manager.sh:90:log() {
.claude/hooks/memory-manager.sh:91:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/memory-manager.sh:92:}
.claude/hooks/memory-manager.sh:93:
.claude/hooks/memory-manager.sh:94:init_memory() {
.claude/hooks/memory-manager.sh:95:    mkdir -p "$MEMORY_DIR"
.claude/hooks/memory-manager.sh:96:
.claude/hooks/memory-manager.sh:97:    # Initialize working memory (current session state)
.claude/hooks/memory-manager.sh:98:    if [[ ! -f "$WORKING_MEMORY" ]]; then
.claude/hooks/memory-manager.sh:99:        cat > "$WORKING_MEMORY" << 'EOF'
.claude/hooks/memory-manager.sh:100:{
.claude/hooks/memory-manager.sh:101:    "currentTask": null,
.claude/hooks/memory-manager.sh:102:    "currentContext": [],
.claude/hooks/memory-manager.sh:103:    "recentActions": [],
.claude/hooks/memory-manager.sh:104:    "pendingItems": [],
.claude/hooks/memory-manager.sh:105:    "scratchpad": "",
.claude/hooks/memory-manager.sh:106:    "lastUpdated": null
.claude/hooks/memory-manager.sh:107:}
.claude/hooks/memory-manager.sh:108:EOF
.claude/hooks/memory-manager.sh:109:    fi
.claude/hooks/memory-manager.sh:110:
.claude/hooks/memory-manager.sh:111:    # Initialize episodic memory (past experiences)
.claude/hooks/memory-manager.sh:112:    if [[ ! -f "$EPISODIC_MEMORY" ]]; then
.claude/hooks/memory-manager.sh:113:        echo '{"episodes":[]}' > "$EPISODIC_MEMORY"
.claude/hooks/memory-manager.sh:114:    fi
.claude/hooks/memory-manager.sh:115:
.claude/hooks/memory-manager.sh:116:    # Initialize semantic memory (facts and knowledge)
.claude/hooks/memory-manager.sh:117:    if [[ ! -f "$SEMANTIC_MEMORY" ]]; then
.claude/hooks/memory-manager.sh:118:        echo '{"facts":[],"patterns":[],"preferences":[]}' > "$SEMANTIC_MEMORY"
.claude/hooks/memory-manager.sh:119:    fi
.claude/hooks/memory-manager.sh:120:
.claude/hooks/memory-manager.sh:121:    # Initialize reflections
.claude/hooks/memory-manager.sh:122:    if [[ ! -f "$REFLECTION_LOG" ]]; then
.claude/hooks/memory-manager.sh:123:        echo '{"reflections":[]}' > "$REFLECTION_LOG"
.claude/hooks/memory-manager.sh:124:    fi
.claude/hooks/memory-manager.sh:125:
.claude/hooks/memory-manager.sh:126:    # Initialize action log (JSONL)
.claude/hooks/memory-manager.sh:127:    if [[ ! -f "$ACTION_LOG" ]]; then
.claude/hooks/memory-manager.sh:128:        touch "$ACTION_LOG"
.claude/hooks/memory-manager.sh:129:    fi
.claude/hooks/memory-manager.sh:130:}
.claude/hooks/memory-manager.sh:131:
.claude/hooks/memory-manager.sh:132:# =============================================================================
.claude/hooks/memory-manager.sh:133:# WORKING MEMORY (Short-term, current session)
.claude/hooks/memory-manager.sh:134:# Based on: MemGPT core memory, Generative Agents scratch
.claude/hooks/memory-manager.sh:135:# =============================================================================
.claude/hooks/memory-manager.sh:136:
.claude/hooks/memory-manager.sh:137:# Set current task
.claude/hooks/memory-manager.sh:138:set_task() {
.claude/hooks/memory-manager.sh:139:    local task="$1"
.claude/hooks/memory-manager.sh:140:    local context="${2:-}"
.claude/hooks/memory-manager.sh:141:
.claude/hooks/memory-manager.sh:142:    init_memory
.claude/hooks/memory-manager.sh:143:
.claude/hooks/memory-manager.sh:144:    local temp_file
.claude/hooks/memory-manager.sh:145:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:146:
.claude/hooks/memory-manager.sh:147:    local timestamp
.claude/hooks/memory-manager.sh:148:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:149:
.claude/hooks/memory-manager.sh:150:    jq --arg task "$task" \
.claude/hooks/memory-manager.sh:151:       --arg context "$context" \
.claude/hooks/memory-manager.sh:152:       --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:153:       '
.claude/hooks/memory-manager.sh:154:       .currentTask = $task |
.claude/hooks/memory-manager.sh:155:       .currentContext = (if $context != "" then [{content: $context, importance: 5, addedAt: $ts}] else [] end) |
.claude/hooks/memory-manager.sh:156:       .lastUpdated = $ts
.claude/hooks/memory-manager.sh:157:       ' "$WORKING_MEMORY" > "$temp_file"
.claude/hooks/memory-manager.sh:158:
.claude/hooks/memory-manager.sh:159:    mv "$temp_file" "$WORKING_MEMORY"
.claude/hooks/memory-manager.sh:160:    log "Set task: $task"
.claude/hooks/memory-manager.sh:161:}
.claude/hooks/memory-manager.sh:162:
.claude/hooks/memory-manager.sh:163:# Add to current context
.claude/hooks/memory-manager.sh:164:add_context() {
.claude/hooks/memory-manager.sh:165:    local context="$1"
.claude/hooks/memory-manager.sh:166:    local importance="${2:-5}"  # 1-10 scale
.claude/hooks/memory-manager.sh:167:
.claude/hooks/memory-manager.sh:168:    init_memory
.claude/hooks/memory-manager.sh:169:
.claude/hooks/memory-manager.sh:170:    local temp_file
.claude/hooks/memory-manager.sh:171:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:172:
.claude/hooks/memory-manager.sh:173:    local timestamp
.claude/hooks/memory-manager.sh:174:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:175:
.claude/hooks/memory-manager.sh:176:    jq --arg ctx "$context" \
.claude/hooks/memory-manager.sh:177:       --argjson imp "$importance" \
.claude/hooks/memory-manager.sh:178:       --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:179:       '
.claude/hooks/memory-manager.sh:180:       .currentContext += [{
.claude/hooks/memory-manager.sh:181:           content: $ctx,
.claude/hooks/memory-manager.sh:182:           importance: $imp,
.claude/hooks/memory-manager.sh:183:           addedAt: $ts
.claude/hooks/memory-manager.sh:184:       }] |
.claude/hooks/memory-manager.sh:185:       .currentContext = (.currentContext | sort_by(-.importance) | .[0:20]) |
.claude/hooks/memory-manager.sh:186:       .lastUpdated = $ts
.claude/hooks/memory-manager.sh:187:       ' "$WORKING_MEMORY" > "$temp_file"
.claude/hooks/memory-manager.sh:188:
.claude/hooks/memory-manager.sh:189:    mv "$temp_file" "$WORKING_MEMORY"
.claude/hooks/memory-manager.sh:190:    log "Added context (importance: $importance)"
.claude/hooks/memory-manager.sh:191:}
.claude/hooks/memory-manager.sh:192:
.claude/hooks/memory-manager.sh:193:# Update scratchpad (quick notes)
.claude/hooks/memory-manager.sh:194:update_scratchpad() {
.claude/hooks/memory-manager.sh:195:    local note="$1"
.claude/hooks/memory-manager.sh:196:    local append="${2:-true}"
.claude/hooks/memory-manager.sh:197:
.claude/hooks/memory-manager.sh:198:    init_memory
.claude/hooks/memory-manager.sh:199:
.claude/hooks/memory-manager.sh:200:    local temp_file
.claude/hooks/memory-manager.sh:201:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:202:
.claude/hooks/memory-manager.sh:203:    local timestamp
.claude/hooks/memory-manager.sh:204:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:205:
.claude/hooks/memory-manager.sh:206:    if [[ "$append" == "true" ]]; then
.claude/hooks/memory-manager.sh:207:        jq --arg note "$note" \
.claude/hooks/memory-manager.sh:208:           --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:209:           '
.claude/hooks/memory-manager.sh:210:           .scratchpad = (.scratchpad + "\n" + $ts + ": " + $note) |
.claude/hooks/memory-manager.sh:211:           .lastUpdated = $ts
.claude/hooks/memory-manager.sh:212:           ' "$WORKING_MEMORY" > "$temp_file"
.claude/hooks/memory-manager.sh:213:    else
.claude/hooks/memory-manager.sh:214:        jq --arg note "$note" \
.claude/hooks/memory-manager.sh:215:           --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:216:           '
.claude/hooks/memory-manager.sh:217:           .scratchpad = $note |
.claude/hooks/memory-manager.sh:218:           .lastUpdated = $ts
.claude/hooks/memory-manager.sh:219:           ' "$WORKING_MEMORY" > "$temp_file"
.claude/hooks/memory-manager.sh:220:    fi
.claude/hooks/memory-manager.sh:221:
.claude/hooks/memory-manager.sh:222:    mv "$temp_file" "$WORKING_MEMORY"
.claude/hooks/memory-manager.sh:223:}
.claude/hooks/memory-manager.sh:224:
.claude/hooks/memory-manager.sh:225:# Get working memory state
.claude/hooks/memory-manager.sh:226:get_working() {
.claude/hooks/memory-manager.sh:227:    init_memory
.claude/hooks/memory-manager.sh:228:    jq '.' "$WORKING_MEMORY"
.claude/hooks/memory-manager.sh:229:}
.claude/hooks/memory-manager.sh:230:
.claude/hooks/memory-manager.sh:231:# Clear working memory (new session)
.claude/hooks/memory-manager.sh:232:clear_working() {
.claude/hooks/memory-manager.sh:233:    init_memory
.claude/hooks/memory-manager.sh:234:
.claude/hooks/memory-manager.sh:235:    local timestamp
.claude/hooks/memory-manager.sh:236:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:237:
.claude/hooks/memory-manager.sh:238:    cat > "$WORKING_MEMORY" << EOF
.claude/hooks/memory-manager.sh:239:{
.claude/hooks/memory-manager.sh:240:    "currentTask": null,
.claude/hooks/memory-manager.sh:241:    "currentContext": [],
.claude/hooks/memory-manager.sh:242:    "recentActions": [],
.claude/hooks/memory-manager.sh:243:    "pendingItems": [],
.claude/hooks/memory-manager.sh:244:    "scratchpad": "",
.claude/hooks/memory-manager.sh:245:    "lastUpdated": "$timestamp"
.claude/hooks/memory-manager.sh:246:}
.claude/hooks/memory-manager.sh:247:EOF
.claude/hooks/memory-manager.sh:248:    log "Cleared working memory"
.claude/hooks/memory-manager.sh:249:}
.claude/hooks/memory-manager.sh:250:
.claude/hooks/memory-manager.sh:251:# =============================================================================
.claude/hooks/memory-manager.sh:252:# EPISODIC MEMORY (Past experiences/episodes)
.claude/hooks/memory-manager.sh:253:# Based on: Generative Agents memory stream, MemGPT archival memory
.claude/hooks/memory-manager.sh:254:# =============================================================================
.claude/hooks/memory-manager.sh:255:
.claude/hooks/memory-manager.sh:256:# Record an episode (completed task/action)
.claude/hooks/memory-manager.sh:257:record_episode() {
.claude/hooks/memory-manager.sh:258:    local type="$1"        # task_complete, error_fixed, research_done, etc.
.claude/hooks/memory-manager.sh:259:    local description="$2"
.claude/hooks/memory-manager.sh:260:    local outcome="${3:-success}"
.claude/hooks/memory-manager.sh:261:    local details="${4:-}"
.claude/hooks/memory-manager.sh:262:
.claude/hooks/memory-manager.sh:263:    init_memory
.claude/hooks/memory-manager.sh:264:
.claude/hooks/memory-manager.sh:265:    local temp_file
.claude/hooks/memory-manager.sh:266:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:267:
.claude/hooks/memory-manager.sh:268:    local timestamp
.claude/hooks/memory-manager.sh:269:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:270:
.claude/hooks/memory-manager.sh:271:    local episode_id
.claude/hooks/memory-manager.sh:272:    episode_id="ep_$(date +%s%N | cut -c1-13)"
.claude/hooks/memory-manager.sh:273:
.claude/hooks/memory-manager.sh:274:    # Calculate importance based on type and outcome
.claude/hooks/memory-manager.sh:275:    local importance=5
.claude/hooks/memory-manager.sh:276:    case "$type" in
.claude/hooks/memory-manager.sh:277:        error_fixed) importance=8 ;;
.claude/hooks/memory-manager.sh:278:        task_complete) importance=7 ;;
.claude/hooks/memory-manager.sh:279:        research_done) importance=6 ;;
.claude/hooks/memory-manager.sh:280:        pattern_learned) importance=9 ;;
.claude/hooks/memory-manager.sh:281:        failure) importance=7 ;;
.claude/hooks/memory-manager.sh:282:    esac
.claude/hooks/memory-manager.sh:283:
.claude/hooks/memory-manager.sh:284:    jq --arg id "$episode_id" \
.claude/hooks/memory-manager.sh:285:       --arg type "$type" \
.claude/hooks/memory-manager.sh:286:       --arg desc "$description" \
.claude/hooks/memory-manager.sh:287:       --arg outcome "$outcome" \
.claude/hooks/memory-manager.sh:288:       --arg details "$details" \
.claude/hooks/memory-manager.sh:289:       --argjson imp "$importance" \
.claude/hooks/memory-manager.sh:290:       --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:291:       '
.claude/hooks/memory-manager.sh:292:       .episodes = [{
.claude/hooks/memory-manager.sh:293:           id: $id,
.claude/hooks/memory-manager.sh:294:           type: $type,
.claude/hooks/memory-manager.sh:295:           description: $desc,
.claude/hooks/memory-manager.sh:296:           outcome: $outcome,
.claude/hooks/memory-manager.sh:297:           details: $details,
.claude/hooks/memory-manager.sh:298:           importance: $imp,
.claude/hooks/memory-manager.sh:299:           timestamp: $ts,
.claude/hooks/memory-manager.sh:300:           accessCount: 0,
.claude/hooks/memory-manager.sh:301:           lastAccessed: null
.claude/hooks/memory-manager.sh:302:       }] + .episodes |
.claude/hooks/memory-manager.sh:303:       .episodes = .episodes[0:'"$MAX_EPISODIC_ITEMS"']
.claude/hooks/memory-manager.sh:304:       ' "$EPISODIC_MEMORY" > "$temp_file"
.claude/hooks/memory-manager.sh:305:
.claude/hooks/memory-manager.sh:306:    mv "$temp_file" "$EPISODIC_MEMORY"
.claude/hooks/memory-manager.sh:307:    log "Recorded episode: $type - $description"
.claude/hooks/memory-manager.sh:308:    echo "$episode_id"
.claude/hooks/memory-manager.sh:309:}
.claude/hooks/memory-manager.sh:310:
.claude/hooks/memory-manager.sh:311:# Search episodes (simple text match)
.claude/hooks/memory-manager.sh:312:search_episodes() {
.claude/hooks/memory-manager.sh:313:    local query="$1"
.claude/hooks/memory-manager.sh:314:    local limit="${2:-10}"
.claude/hooks/memory-manager.sh:315:
.claude/hooks/memory-manager.sh:316:    init_memory
.claude/hooks/memory-manager.sh:317:
.claude/hooks/memory-manager.sh:318:    jq --arg q "$query" \
.claude/hooks/memory-manager.sh:319:       --argjson limit "$limit" \
.claude/hooks/memory-manager.sh:320:       '
.claude/hooks/memory-manager.sh:321:       .episodes |
.claude/hooks/memory-manager.sh:322:       map(select(
.claude/hooks/memory-manager.sh:323:           (.description | ascii_downcase | contains($q | ascii_downcase)) or
.claude/hooks/memory-manager.sh:324:           (.details | ascii_downcase | contains($q | ascii_downcase)) or
.claude/hooks/memory-manager.sh:325:           (.type | ascii_downcase | contains($q | ascii_downcase))
.claude/hooks/memory-manager.sh:326:       )) |
.claude/hooks/memory-manager.sh:327:       sort_by(.importance | (- if type == "number" then . else 0 end)) |
.claude/hooks/memory-manager.sh:328:       .[0:$limit]
.claude/hooks/memory-manager.sh:329:       ' "$EPISODIC_MEMORY"
.claude/hooks/memory-manager.sh:330:}
.claude/hooks/memory-manager.sh:331:
.claude/hooks/memory-manager.sh:332:# Get recent episodes
.claude/hooks/memory-manager.sh:333:get_recent_episodes() {
.claude/hooks/memory-manager.sh:334:    local limit="${1:-10}"
.claude/hooks/memory-manager.sh:335:    local type_filter="${2:-}"
.claude/hooks/memory-manager.sh:336:
.claude/hooks/memory-manager.sh:337:    init_memory
.claude/hooks/memory-manager.sh:338:
.claude/hooks/memory-manager.sh:339:    if [[ -n "$type_filter" ]]; then
.claude/hooks/memory-manager.sh:340:        jq --arg type "$type_filter" \
.claude/hooks/memory-manager.sh:341:           --argjson limit "$limit" \
.claude/hooks/memory-manager.sh:342:           '.episodes | map(select(.type == $type)) | .[0:$limit]' "$EPISODIC_MEMORY"
.claude/hooks/memory-manager.sh:343:    else
.claude/hooks/memory-manager.sh:344:        jq --argjson limit "$limit" \
.claude/hooks/memory-manager.sh:345:           '.episodes | .[0:$limit]' "$EPISODIC_MEMORY"
.claude/hooks/memory-manager.sh:346:    fi
.claude/hooks/memory-manager.sh:347:}
.claude/hooks/memory-manager.sh:348:
.claude/hooks/memory-manager.sh:349:# =============================================================================
.claude/hooks/memory-manager.sh:350:# SEMANTIC MEMORY (Facts, patterns, preferences)
.claude/hooks/memory-manager.sh:351:# Based on: MemGPT persona/human blocks, knowledge graphs
.claude/hooks/memory-manager.sh:352:# =============================================================================
.claude/hooks/memory-manager.sh:353:
.claude/hooks/memory-manager.sh:354:# Add a fact
.claude/hooks/memory-manager.sh:355:add_fact() {
.claude/hooks/memory-manager.sh:356:    local category="$1"    # project, user, tool, api, etc.
.claude/hooks/memory-manager.sh:357:    local key="$2"
.claude/hooks/memory-manager.sh:358:    local value="$3"
.claude/hooks/memory-manager.sh:359:    local confidence="${4:-0.8}"
.claude/hooks/memory-manager.sh:360:
.claude/hooks/memory-manager.sh:361:    init_memory
.claude/hooks/memory-manager.sh:362:
.claude/hooks/memory-manager.sh:363:    local temp_file
.claude/hooks/memory-manager.sh:364:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:365:
.claude/hooks/memory-manager.sh:366:    local timestamp
.claude/hooks/memory-manager.sh:367:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:368:
.claude/hooks/memory-manager.sh:369:    # Update or insert fact
.claude/hooks/memory-manager.sh:370:    jq --arg cat "$category" \
.claude/hooks/memory-manager.sh:371:       --arg key "$key" \
.claude/hooks/memory-manager.sh:372:       --arg val "$value" \
.claude/hooks/memory-manager.sh:373:       --argjson conf "$confidence" \
.claude/hooks/memory-manager.sh:374:       --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:375:       '
.claude/hooks/memory-manager.sh:376:       .facts = [.facts[] | select(.category != $cat or .key != $key)] + [{
.claude/hooks/memory-manager.sh:377:           category: $cat,
.claude/hooks/memory-manager.sh:378:           key: $key,
.claude/hooks/memory-manager.sh:379:           value: $val,
.claude/hooks/memory-manager.sh:380:           confidence: $conf,
.claude/hooks/memory-manager.sh:381:           updatedAt: $ts
.claude/hooks/memory-manager.sh:382:       }] |
.claude/hooks/memory-manager.sh:383:       .facts = (.facts | sort_by(.category, .key) | .[0:'"$MAX_SEMANTIC_ITEMS"'])
.claude/hooks/memory-manager.sh:384:       ' "$SEMANTIC_MEMORY" > "$temp_file"
.claude/hooks/memory-manager.sh:385:
.claude/hooks/memory-manager.sh:386:    mv "$temp_file" "$SEMANTIC_MEMORY"
.claude/hooks/memory-manager.sh:387:    log "Added fact: $category/$key"
.claude/hooks/memory-manager.sh:388:}
.claude/hooks/memory-manager.sh:389:
.claude/hooks/memory-manager.sh:390:# Get a fact
.claude/hooks/memory-manager.sh:391:get_fact() {
.claude/hooks/memory-manager.sh:392:    local category="$1"
.claude/hooks/memory-manager.sh:393:    local key="$2"
.claude/hooks/memory-manager.sh:394:
.claude/hooks/memory-manager.sh:395:    init_memory
.claude/hooks/memory-manager.sh:396:
.claude/hooks/memory-manager.sh:397:    jq --arg cat "$category" \
.claude/hooks/memory-manager.sh:398:       --arg key "$key" \
.claude/hooks/memory-manager.sh:399:       '.facts[] | select(.category == $cat and .key == $key)' "$SEMANTIC_MEMORY"
.claude/hooks/memory-manager.sh:400:}
.claude/hooks/memory-manager.sh:401:
.claude/hooks/memory-manager.sh:402:# Get all facts in category
.claude/hooks/memory-manager.sh:403:get_facts_by_category() {
.claude/hooks/memory-manager.sh:404:    local category="$1"
.claude/hooks/memory-manager.sh:405:
.claude/hooks/memory-manager.sh:406:    init_memory
.claude/hooks/memory-manager.sh:407:
.claude/hooks/memory-manager.sh:408:    jq --arg cat "$category" \
.claude/hooks/memory-manager.sh:409:       '.facts | map(select(.category == $cat))' "$SEMANTIC_MEMORY"
.claude/hooks/memory-manager.sh:410:}
.claude/hooks/memory-manager.sh:411:
.claude/hooks/memory-manager.sh:412:# Add a learned pattern
.claude/hooks/memory-manager.sh:413:add_pattern() {
.claude/hooks/memory-manager.sh:414:    local pattern_type="$1"   # error_fix, optimization, workflow, etc.
.claude/hooks/memory-manager.sh:415:    local trigger="$2"        # What triggers this pattern
.claude/hooks/memory-manager.sh:416:    local solution="$3"       # The solution/action
.claude/hooks/memory-manager.sh:417:    local success_rate="${4:-1.0}"
.claude/hooks/memory-manager.sh:418:
.claude/hooks/memory-manager.sh:419:    init_memory
.claude/hooks/memory-manager.sh:420:
.claude/hooks/memory-manager.sh:421:    local temp_file
.claude/hooks/memory-manager.sh:422:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:423:
.claude/hooks/memory-manager.sh:424:    local timestamp
.claude/hooks/memory-manager.sh:425:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:426:
.claude/hooks/memory-manager.sh:427:    local pattern_id
.claude/hooks/memory-manager.sh:428:    pattern_id="pat_$(date +%s%N | cut -c1-13)"
.claude/hooks/memory-manager.sh:429:
.claude/hooks/memory-manager.sh:430:    jq --arg id "$pattern_id" \
.claude/hooks/memory-manager.sh:431:       --arg type "$pattern_type" \
.claude/hooks/memory-manager.sh:432:       --arg trigger "$trigger" \
.claude/hooks/memory-manager.sh:433:       --arg solution "$solution" \
.claude/hooks/memory-manager.sh:434:       --argjson rate "$success_rate" \
.claude/hooks/memory-manager.sh:435:       --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:436:       '
.claude/hooks/memory-manager.sh:437:       .patterns = [{
.claude/hooks/memory-manager.sh:438:           id: $id,
.claude/hooks/memory-manager.sh:439:           type: $type,
.claude/hooks/memory-manager.sh:440:           trigger: $trigger,
.claude/hooks/memory-manager.sh:441:           solution: $solution,
.claude/hooks/memory-manager.sh:442:           successRate: $rate,
.claude/hooks/memory-manager.sh:443:           useCount: 0,
.claude/hooks/memory-manager.sh:444:           createdAt: $ts
.claude/hooks/memory-manager.sh:445:       }] + .patterns |
.claude/hooks/memory-manager.sh:446:       .patterns = .patterns[0:200]
.claude/hooks/memory-manager.sh:447:       ' "$SEMANTIC_MEMORY" > "$temp_file"
.claude/hooks/memory-manager.sh:448:
.claude/hooks/memory-manager.sh:449:    mv "$temp_file" "$SEMANTIC_MEMORY"
.claude/hooks/memory-manager.sh:450:    log "Added pattern: $pattern_type"
.claude/hooks/memory-manager.sh:451:    echo "$pattern_id"
.claude/hooks/memory-manager.sh:452:}
.claude/hooks/memory-manager.sh:453:
.claude/hooks/memory-manager.sh:454:# Find matching patterns
.claude/hooks/memory-manager.sh:455:find_patterns() {
.claude/hooks/memory-manager.sh:456:    local query="$1"
.claude/hooks/memory-manager.sh:457:    local limit="${2:-5}"
.claude/hooks/memory-manager.sh:458:
.claude/hooks/memory-manager.sh:459:    init_memory
.claude/hooks/memory-manager.sh:460:
.claude/hooks/memory-manager.sh:461:    jq --arg q "$query" \
.claude/hooks/memory-manager.sh:462:       --argjson limit "$limit" \
.claude/hooks/memory-manager.sh:463:       '
.claude/hooks/memory-manager.sh:464:       .patterns |
.claude/hooks/memory-manager.sh:465:       map(select(
.claude/hooks/memory-manager.sh:466:           (.trigger | ascii_downcase | contains($q | ascii_downcase)) or
.claude/hooks/memory-manager.sh:467:           (.type | ascii_downcase | contains($q | ascii_downcase))
.claude/hooks/memory-manager.sh:468:       )) |
.claude/hooks/memory-manager.sh:469:       sort_by(-.successRate, -.useCount) |
.claude/hooks/memory-manager.sh:470:       .[0:$limit]
.claude/hooks/memory-manager.sh:471:       ' "$SEMANTIC_MEMORY"
.claude/hooks/memory-manager.sh:472:}
.claude/hooks/memory-manager.sh:473:
.claude/hooks/memory-manager.sh:474:# Add user preference
.claude/hooks/memory-manager.sh:475:add_preference() {
.claude/hooks/memory-manager.sh:476:    local key="$1"
.claude/hooks/memory-manager.sh:477:    local value="$2"
.claude/hooks/memory-manager.sh:478:
.claude/hooks/memory-manager.sh:479:    init_memory
.claude/hooks/memory-manager.sh:480:
.claude/hooks/memory-manager.sh:481:    local temp_file
.claude/hooks/memory-manager.sh:482:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:483:
.claude/hooks/memory-manager.sh:484:    local timestamp
.claude/hooks/memory-manager.sh:485:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:486:
.claude/hooks/memory-manager.sh:487:    jq --arg key "$key" \
.claude/hooks/memory-manager.sh:488:       --arg val "$value" \
.claude/hooks/memory-manager.sh:489:       --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:490:       '
.claude/hooks/memory-manager.sh:491:       .preferences = [.preferences[] | select(.key != $key)] + [{
.claude/hooks/memory-manager.sh:492:           key: $key,
.claude/hooks/memory-manager.sh:493:           value: $val,
.claude/hooks/memory-manager.sh:494:           updatedAt: $ts
.claude/hooks/memory-manager.sh:495:       }]
.claude/hooks/memory-manager.sh:496:       ' "$SEMANTIC_MEMORY" > "$temp_file"
.claude/hooks/memory-manager.sh:497:
.claude/hooks/memory-manager.sh:498:    mv "$temp_file" "$SEMANTIC_MEMORY"
.claude/hooks/memory-manager.sh:499:    log "Set preference: $key"
.claude/hooks/memory-manager.sh:500:}
.claude/hooks/memory-manager.sh:501:
.claude/hooks/memory-manager.sh:502:# Get preference
.claude/hooks/memory-manager.sh:503:get_preference() {
.claude/hooks/memory-manager.sh:504:    local key="$1"
.claude/hooks/memory-manager.sh:505:    local default="${2:-}"
.claude/hooks/memory-manager.sh:506:
.claude/hooks/memory-manager.sh:507:    init_memory
.claude/hooks/memory-manager.sh:508:
.claude/hooks/memory-manager.sh:509:    local value
.claude/hooks/memory-manager.sh:510:    value=$(jq -r --arg key "$key" \
.claude/hooks/memory-manager.sh:511:       '.preferences[] | select(.key == $key) | .value' "$SEMANTIC_MEMORY")
.claude/hooks/memory-manager.sh:512:
.claude/hooks/memory-manager.sh:513:    if [[ -n "$value" && "$value" != "null" ]]; then
.claude/hooks/memory-manager.sh:514:        echo "$value"
.claude/hooks/memory-manager.sh:515:    else
.claude/hooks/memory-manager.sh:516:        echo "$default"
.claude/hooks/memory-manager.sh:517:    fi
.claude/hooks/memory-manager.sh:518:}
.claude/hooks/memory-manager.sh:519:
.claude/hooks/memory-manager.sh:520:# =============================================================================
.claude/hooks/memory-manager.sh:521:# ACTION LOG (Append-only log of all actions)
.claude/hooks/memory-manager.sh:522:# Based on: Generative Agents memory stream
.claude/hooks/memory-manager.sh:523:# =============================================================================
.claude/hooks/memory-manager.sh:524:
.claude/hooks/memory-manager.sh:525:# Log an action
.claude/hooks/memory-manager.sh:526:log_action() {
.claude/hooks/memory-manager.sh:527:    local action_type="$1"   # tool_call, edit, search, etc.
.claude/hooks/memory-manager.sh:528:    local description="$2"
.claude/hooks/memory-manager.sh:529:    local result="${3:-}"
.claude/hooks/memory-manager.sh:530:    local metadata="${4:-}"
.claude/hooks/memory-manager.sh:531:
.claude/hooks/memory-manager.sh:532:    init_memory
.claude/hooks/memory-manager.sh:533:
.claude/hooks/memory-manager.sh:534:    local timestamp
.claude/hooks/memory-manager.sh:535:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:536:
.claude/hooks/memory-manager.sh:537:    local action_id
.claude/hooks/memory-manager.sh:538:    action_id="act_$(date +%s%N | cut -c1-13)"
.claude/hooks/memory-manager.sh:539:
.claude/hooks/memory-manager.sh:540:    # Validate or default metadata to empty object
.claude/hooks/memory-manager.sh:541:    if [[ -z "$metadata" ]] || ! echo "$metadata" | jq -e . >/dev/null 2>&1; then
.claude/hooks/memory-manager.sh:542:        metadata='{}'
.claude/hooks/memory-manager.sh:543:    fi
.claude/hooks/memory-manager.sh:544:
.claude/hooks/memory-manager.sh:545:    # Append to JSONL file
.claude/hooks/memory-manager.sh:546:    jq -n -c \
.claude/hooks/memory-manager.sh:547:       --arg id "$action_id" \
.claude/hooks/memory-manager.sh:548:       --arg type "$action_type" \
.claude/hooks/memory-manager.sh:549:       --arg desc "$description" \
.claude/hooks/memory-manager.sh:550:       --arg result "$result" \
.claude/hooks/memory-manager.sh:551:       --argjson meta "$metadata" \
.claude/hooks/memory-manager.sh:552:       --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:553:       '{
.claude/hooks/memory-manager.sh:554:           id: $id,
.claude/hooks/memory-manager.sh:555:           type: $type,
.claude/hooks/memory-manager.sh:556:           description: $desc,
.claude/hooks/memory-manager.sh:557:           result: $result,
.claude/hooks/memory-manager.sh:558:           metadata: $meta,
.claude/hooks/memory-manager.sh:559:           timestamp: $ts
.claude/hooks/memory-manager.sh:560:       }' >> "$ACTION_LOG"
.claude/hooks/memory-manager.sh:561:
.claude/hooks/memory-manager.sh:562:    log "Logged action: $action_type"
.claude/hooks/memory-manager.sh:563:    echo "$action_id"
.claude/hooks/memory-manager.sh:564:}
.claude/hooks/memory-manager.sh:565:
.claude/hooks/memory-manager.sh:566:# Get recent actions
.claude/hooks/memory-manager.sh:567:get_recent_actions() {
.claude/hooks/memory-manager.sh:568:    local limit="${1:-20}"
.claude/hooks/memory-manager.sh:569:    local type_filter="${2:-}"
.claude/hooks/memory-manager.sh:570:
.claude/hooks/memory-manager.sh:571:    init_memory
.claude/hooks/memory-manager.sh:572:
.claude/hooks/memory-manager.sh:573:    if [[ ! -f "$ACTION_LOG" ]]; then
.claude/hooks/memory-manager.sh:574:        echo "[]"
.claude/hooks/memory-manager.sh:575:        return
.claude/hooks/memory-manager.sh:576:    fi
.claude/hooks/memory-manager.sh:577:
.claude/hooks/memory-manager.sh:578:    if [[ -n "$type_filter" ]]; then
.claude/hooks/memory-manager.sh:579:        tail -n 1000 "$ACTION_LOG" | jq -s --arg type "$type_filter" \
.claude/hooks/memory-manager.sh:580:           'map(select(.type == $type)) | reverse | .[0:'"$limit"']'
.claude/hooks/memory-manager.sh:581:    else
.claude/hooks/memory-manager.sh:582:        tail -n "$limit" "$ACTION_LOG" | jq -s 'reverse'
.claude/hooks/memory-manager.sh:583:    fi
.claude/hooks/memory-manager.sh:584:}
.claude/hooks/memory-manager.sh:585:
.claude/hooks/memory-manager.sh:586:# Search action log
.claude/hooks/memory-manager.sh:587:search_actions() {
.claude/hooks/memory-manager.sh:588:    local query="$1"
.claude/hooks/memory-manager.sh:589:    local limit="${2:-20}"
.claude/hooks/memory-manager.sh:590:
.claude/hooks/memory-manager.sh:591:    init_memory
.claude/hooks/memory-manager.sh:592:
.claude/hooks/memory-manager.sh:593:    if [[ ! -f "$ACTION_LOG" ]]; then
.claude/hooks/memory-manager.sh:594:        echo "[]"
.claude/hooks/memory-manager.sh:595:        return
.claude/hooks/memory-manager.sh:596:    fi
.claude/hooks/memory-manager.sh:597:
.claude/hooks/memory-manager.sh:598:    grep -i "$query" "$ACTION_LOG" 2>/dev/null | tail -n "$limit" | jq -s '.'
.claude/hooks/memory-manager.sh:599:}
.claude/hooks/memory-manager.sh:600:
.claude/hooks/memory-manager.sh:601:# =============================================================================
.claude/hooks/memory-manager.sh:602:# REFLECTION (Memory consolidation)
.claude/hooks/memory-manager.sh:603:# Based on: Generative Agents reflection, MemGPT summarization
.claude/hooks/memory-manager.sh:604:# =============================================================================
.claude/hooks/memory-manager.sh:605:
.claude/hooks/memory-manager.sh:606:# Create a reflection (consolidate recent experiences)
.claude/hooks/memory-manager.sh:607:create_reflection() {
.claude/hooks/memory-manager.sh:608:    local focus="${1:-general}"  # general, errors, patterns, progress
.claude/hooks/memory-manager.sh:609:    local content="$2"
.claude/hooks/memory-manager.sh:610:    local insights="${3:-}"
.claude/hooks/memory-manager.sh:611:
.claude/hooks/memory-manager.sh:612:    init_memory
.claude/hooks/memory-manager.sh:613:
.claude/hooks/memory-manager.sh:614:    local temp_file
.claude/hooks/memory-manager.sh:615:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:616:
.claude/hooks/memory-manager.sh:617:    local timestamp
.claude/hooks/memory-manager.sh:618:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:619:
.claude/hooks/memory-manager.sh:620:    local reflection_id
.claude/hooks/memory-manager.sh:621:    reflection_id="ref_$(date +%s)"
.claude/hooks/memory-manager.sh:622:
.claude/hooks/memory-manager.sh:623:    jq --arg id "$reflection_id" \
.claude/hooks/memory-manager.sh:624:       --arg focus "$focus" \
.claude/hooks/memory-manager.sh:625:       --arg content "$content" \
.claude/hooks/memory-manager.sh:626:       --arg insights "$insights" \
.claude/hooks/memory-manager.sh:627:       --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:628:       '
.claude/hooks/memory-manager.sh:629:       .reflections = [{
.claude/hooks/memory-manager.sh:630:           id: $id,
.claude/hooks/memory-manager.sh:631:           focus: $focus,
.claude/hooks/memory-manager.sh:632:           content: $content,
.claude/hooks/memory-manager.sh:633:           insights: $insights,
.claude/hooks/memory-manager.sh:634:           timestamp: $ts
.claude/hooks/memory-manager.sh:635:       }] + .reflections |
.claude/hooks/memory-manager.sh:636:       .reflections = .reflections[0:100]
.claude/hooks/memory-manager.sh:637:       ' "$REFLECTION_LOG" > "$temp_file"
.claude/hooks/memory-manager.sh:638:
.claude/hooks/memory-manager.sh:639:    mv "$temp_file" "$REFLECTION_LOG"
.claude/hooks/memory-manager.sh:640:    log "Created reflection: $focus"
.claude/hooks/memory-manager.sh:641:    echo "$reflection_id"
.claude/hooks/memory-manager.sh:642:}
.claude/hooks/memory-manager.sh:643:
.claude/hooks/memory-manager.sh:644:# Get reflections
.claude/hooks/memory-manager.sh:645:get_reflections() {
.claude/hooks/memory-manager.sh:646:    local focus="${1:-}"
.claude/hooks/memory-manager.sh:647:    local limit="${2:-10}"
.claude/hooks/memory-manager.sh:648:
.claude/hooks/memory-manager.sh:649:    init_memory
.claude/hooks/memory-manager.sh:650:
.claude/hooks/memory-manager.sh:651:    if [[ -n "$focus" ]]; then
.claude/hooks/memory-manager.sh:652:        jq --arg focus "$focus" \
.claude/hooks/memory-manager.sh:653:           --argjson limit "$limit" \
.claude/hooks/memory-manager.sh:654:           '.reflections | map(select(.focus == $focus)) | .[0:$limit]' "$REFLECTION_LOG"
.claude/hooks/memory-manager.sh:655:    else
.claude/hooks/memory-manager.sh:656:        jq --argjson limit "$limit" \
.claude/hooks/memory-manager.sh:657:           '.reflections | .[0:$limit]' "$REFLECTION_LOG"
.claude/hooks/memory-manager.sh:658:    fi
.claude/hooks/memory-manager.sh:659:}
.claude/hooks/memory-manager.sh:660:
.claude/hooks/memory-manager.sh:661:# =============================================================================
.claude/hooks/memory-manager.sh:662:# MEMORY RETRIEVAL (Combined search across all memory types)
.claude/hooks/memory-manager.sh:663:# Based on: Generative Agents retrieval (recency + relevance + importance)
.claude/hooks/memory-manager.sh:664:# =============================================================================
.claude/hooks/memory-manager.sh:665:
.claude/hooks/memory-manager.sh:666:# Calculate recency score with exponential decay
.claude/hooks/memory-manager.sh:667:# Formula: decay_rate ^ hours_since_access
.claude/hooks/memory-manager.sh:668:calculate_recency_score() {
.claude/hooks/memory-manager.sh:669:    local timestamp="$1"
.claude/hooks/memory-manager.sh:670:    local decay_rate="${2:-0.995}"
.claude/hooks/memory-manager.sh:671:
.claude/hooks/memory-manager.sh:672:    # Get hours since timestamp
.claude/hooks/memory-manager.sh:673:    local now_epoch
.claude/hooks/memory-manager.sh:674:    now_epoch=$(date +%s)
.claude/hooks/memory-manager.sh:675:
.claude/hooks/memory-manager.sh:676:    local ts_epoch
.claude/hooks/memory-manager.sh:677:    ts_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$timestamp" +%s 2>/dev/null || echo "$now_epoch")
.claude/hooks/memory-manager.sh:678:
.claude/hooks/memory-manager.sh:679:    local hours_ago
.claude/hooks/memory-manager.sh:680:    hours_ago=$(( (now_epoch - ts_epoch) / 3600 ))
.claude/hooks/memory-manager.sh:681:
.claude/hooks/memory-manager.sh:682:    # Calculate decay (using bc for floating point)
.claude/hooks/memory-manager.sh:683:    echo "scale=4; e(l($decay_rate) * $hours_ago)" | bc -l 2>/dev/null || echo "0.5"
.claude/hooks/memory-manager.sh:684:}
.claude/hooks/memory-manager.sh:685:
.claude/hooks/memory-manager.sh:686:# Calculate relevance score (keyword overlap)
.claude/hooks/memory-manager.sh:687:calculate_relevance_score() {
.claude/hooks/memory-manager.sh:688:    local query="$1"
.claude/hooks/memory-manager.sh:689:    local content="$2"
.claude/hooks/memory-manager.sh:690:
.claude/hooks/memory-manager.sh:691:    # Normalize to lowercase and split into words
.claude/hooks/memory-manager.sh:692:    local query_words
.claude/hooks/memory-manager.sh:693:    query_words=$(echo "$query" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]' '\n' | sort -u)
.claude/hooks/memory-manager.sh:694:
.claude/hooks/memory-manager.sh:695:    local content_words
.claude/hooks/memory-manager.sh:696:    content_words=$(echo "$content" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]' '\n' | sort -u)
.claude/hooks/memory-manager.sh:697:
.claude/hooks/memory-manager.sh:698:    # Count matching words
.claude/hooks/memory-manager.sh:699:    local matches=0
.claude/hooks/memory-manager.sh:700:    local total=0
.claude/hooks/memory-manager.sh:701:    for word in $query_words; do
.claude/hooks/memory-manager.sh:702:        total=$((total + 1))
.claude/hooks/memory-manager.sh:703:        if echo "$content_words" | grep -qw "$word"; then
.claude/hooks/memory-manager.sh:704:            matches=$((matches + 1))
.claude/hooks/memory-manager.sh:705:        fi
.claude/hooks/memory-manager.sh:706:    done
.claude/hooks/memory-manager.sh:707:
.claude/hooks/memory-manager.sh:708:    # Return overlap ratio
.claude/hooks/memory-manager.sh:709:    if [[ $total -gt 0 ]]; then
.claude/hooks/memory-manager.sh:710:        echo "scale=4; $matches / $total" | bc -l 2>/dev/null || echo "0"
.claude/hooks/memory-manager.sh:711:    else
.claude/hooks/memory-manager.sh:712:        echo "0"
.claude/hooks/memory-manager.sh:713:    fi
.claude/hooks/memory-manager.sh:714:}
.claude/hooks/memory-manager.sh:715:
.claude/hooks/memory-manager.sh:716:# Advanced retrieval with three-factor scoring
.claude/hooks/memory-manager.sh:717:# Based on Generative Agents: recency + relevance + importance
.claude/hooks/memory-manager.sh:718:retrieve_scored() {
.claude/hooks/memory-manager.sh:719:    local query="$1"
.claude/hooks/memory-manager.sh:720:    local limit="${2:-10}"
.claude/hooks/memory-manager.sh:721:    local recency_weight="${3:-0.5}"
.claude/hooks/memory-manager.sh:722:    local relevance_weight="${4:-3.0}"
.claude/hooks/memory-manager.sh:723:    local importance_weight="${5:-2.0}"
.claude/hooks/memory-manager.sh:724:
.claude/hooks/memory-manager.sh:725:    init_memory
.claude/hooks/memory-manager.sh:726:
.claude/hooks/memory-manager.sh:727:    local results="[]"
.claude/hooks/memory-manager.sh:728:
.claude/hooks/memory-manager.sh:729:    # Score episodic memories
.claude/hooks/memory-manager.sh:730:    local episodes
.claude/hooks/memory-manager.sh:731:    episodes=$(jq '.episodes' "$EPISODIC_MEMORY")
.claude/hooks/memory-manager.sh:732:
.claude/hooks/memory-manager.sh:733:    while IFS= read -r episode; do
.claude/hooks/memory-manager.sh:734:        if [[ -z "$episode" || "$episode" == "null" ]]; then
.claude/hooks/memory-manager.sh:735:            continue
.claude/hooks/memory-manager.sh:736:        fi
.claude/hooks/memory-manager.sh:737:
.claude/hooks/memory-manager.sh:738:        local description
.claude/hooks/memory-manager.sh:739:        description=$(echo "$episode" | jq -r '.description')
.claude/hooks/memory-manager.sh:740:
.claude/hooks/memory-manager.sh:741:        local timestamp
.claude/hooks/memory-manager.sh:742:        timestamp=$(echo "$episode" | jq -r '.timestamp')
.claude/hooks/memory-manager.sh:743:
.claude/hooks/memory-manager.sh:744:        local importance
.claude/hooks/memory-manager.sh:745:        importance=$(echo "$episode" | jq -r '.importance // 5')
.claude/hooks/memory-manager.sh:746:
.claude/hooks/memory-manager.sh:747:        # Calculate scores
.claude/hooks/memory-manager.sh:748:        local recency_score
.claude/hooks/memory-manager.sh:749:        recency_score=$(calculate_recency_score "$timestamp")
.claude/hooks/memory-manager.sh:750:
.claude/hooks/memory-manager.sh:751:        local relevance_score
.claude/hooks/memory-manager.sh:752:        relevance_score=$(calculate_relevance_score "$query" "$description")
.claude/hooks/memory-manager.sh:753:
.claude/hooks/memory-manager.sh:754:        # Normalize importance to 0-1
.claude/hooks/memory-manager.sh:755:        local importance_score
.claude/hooks/memory-manager.sh:756:        importance_score=$(echo "scale=4; $importance / 10" | bc -l 2>/dev/null || echo "0.5")
.claude/hooks/memory-manager.sh:757:
.claude/hooks/memory-manager.sh:758:        # Combined score with weights
.claude/hooks/memory-manager.sh:759:        local final_score
.claude/hooks/memory-manager.sh:760:        final_score=$(echo "scale=4; ($recency_weight * $recency_score) + ($relevance_weight * $relevance_score) + ($importance_weight * $importance_score)" | bc -l 2>/dev/null || echo "0")
.claude/hooks/memory-manager.sh:761:
.claude/hooks/memory-manager.sh:762:        # Add to results with score
.claude/hooks/memory-manager.sh:763:        results=$(echo "$results" | jq --argjson ep "$episode" --arg score "$final_score" \
.claude/hooks/memory-manager.sh:764:            '. + [($ep + {retrievalScore: ($score | tonumber), source: "episodic"})]')
.claude/hooks/memory-manager.sh:765:    done < <(echo "$episodes" | jq -c '.[]')
.claude/hooks/memory-manager.sh:766:
.claude/hooks/memory-manager.sh:767:    # Score patterns
.claude/hooks/memory-manager.sh:768:    local patterns
.claude/hooks/memory-manager.sh:769:    patterns=$(jq '.patterns' "$SEMANTIC_MEMORY")
.claude/hooks/memory-manager.sh:770:
.claude/hooks/memory-manager.sh:771:    while IFS= read -r pattern; do
.claude/hooks/memory-manager.sh:772:        if [[ -z "$pattern" || "$pattern" == "null" ]]; then
.claude/hooks/memory-manager.sh:773:            continue
.claude/hooks/memory-manager.sh:774:        fi
.claude/hooks/memory-manager.sh:775:
.claude/hooks/memory-manager.sh:776:        local trigger
.claude/hooks/memory-manager.sh:777:        trigger=$(echo "$pattern" | jq -r '.trigger')
.claude/hooks/memory-manager.sh:778:
.claude/hooks/memory-manager.sh:779:        local timestamp
.claude/hooks/memory-manager.sh:780:        timestamp=$(echo "$pattern" | jq -r '.createdAt')
.claude/hooks/memory-manager.sh:781:
.claude/hooks/memory-manager.sh:782:        local success_rate
.claude/hooks/memory-manager.sh:783:        success_rate=$(echo "$pattern" | jq -r '.successRate // 1.0')
.claude/hooks/memory-manager.sh:784:
.claude/hooks/memory-manager.sh:785:        # Calculate scores
.claude/hooks/memory-manager.sh:786:        local recency_score
.claude/hooks/memory-manager.sh:787:        recency_score=$(calculate_recency_score "$timestamp")
.claude/hooks/memory-manager.sh:788:
.claude/hooks/memory-manager.sh:789:        local relevance_score
.claude/hooks/memory-manager.sh:790:        relevance_score=$(calculate_relevance_score "$query" "$trigger")
.claude/hooks/memory-manager.sh:791:
.claude/hooks/memory-manager.sh:792:        # Use success rate as importance
.claude/hooks/memory-manager.sh:793:        local importance_score="$success_rate"
.claude/hooks/memory-manager.sh:794:
.claude/hooks/memory-manager.sh:795:        # Combined score
.claude/hooks/memory-manager.sh:796:        local final_score
.claude/hooks/memory-manager.sh:797:        final_score=$(echo "scale=4; ($recency_weight * $recency_score) + ($relevance_weight * $relevance_score) + ($importance_weight * $importance_score)" | bc -l 2>/dev/null || echo "0")
.claude/hooks/memory-manager.sh:798:
.claude/hooks/memory-manager.sh:799:        # Add to results
.claude/hooks/memory-manager.sh:800:        results=$(echo "$results" | jq --argjson pat "$pattern" --arg score "$final_score" \
.claude/hooks/memory-manager.sh:801:            '. + [($pat + {retrievalScore: ($score | tonumber), source: "pattern"})]')
.claude/hooks/memory-manager.sh:802:    done < <(echo "$patterns" | jq -c '.[]')
.claude/hooks/memory-manager.sh:803:
.claude/hooks/memory-manager.sh:804:    # Sort by score and return top results
.claude/hooks/memory-manager.sh:805:    echo "$results" | jq --argjson limit "$limit" \
.claude/hooks/memory-manager.sh:806:        'sort_by(-.retrievalScore) | .[0:$limit]'
.claude/hooks/memory-manager.sh:807:}
.claude/hooks/memory-manager.sh:808:
.claude/hooks/memory-manager.sh:809:# Unified memory search (simple)
.claude/hooks/memory-manager.sh:810:remember() {
.claude/hooks/memory-manager.sh:811:    local query="$1"
.claude/hooks/memory-manager.sh:812:    local limit="${2:-10}"
.claude/hooks/memory-manager.sh:813:
.claude/hooks/memory-manager.sh:814:    init_memory
.claude/hooks/memory-manager.sh:815:
.claude/hooks/memory-manager.sh:816:    echo "{"
.claude/hooks/memory-manager.sh:817:
.claude/hooks/memory-manager.sh:818:    # Search episodic memory
.claude/hooks/memory-manager.sh:819:    echo '"episodes":'
.claude/hooks/memory-manager.sh:820:    search_episodes "$query" "$limit"
.claude/hooks/memory-manager.sh:821:    echo ","
.claude/hooks/memory-manager.sh:822:
.claude/hooks/memory-manager.sh:823:    # Search patterns
.claude/hooks/memory-manager.sh:824:    echo '"patterns":'
.claude/hooks/memory-manager.sh:825:    find_patterns "$query" "$limit"
.claude/hooks/memory-manager.sh:826:    echo ","
.claude/hooks/memory-manager.sh:827:
.claude/hooks/memory-manager.sh:828:    # Search actions
.claude/hooks/memory-manager.sh:829:    echo '"actions":'
.claude/hooks/memory-manager.sh:830:    search_actions "$query" "$limit"
.claude/hooks/memory-manager.sh:831:
.claude/hooks/memory-manager.sh:832:    echo "}"
.claude/hooks/memory-manager.sh:833:}
.claude/hooks/memory-manager.sh:834:
.claude/hooks/memory-manager.sh:835:# Unified memory search (with scoring)
.claude/hooks/memory-manager.sh:836:remember_scored() {
.claude/hooks/memory-manager.sh:837:    local query="$1"
.claude/hooks/memory-manager.sh:838:    local limit="${2:-10}"
.claude/hooks/memory-manager.sh:839:
.claude/hooks/memory-manager.sh:840:    retrieve_scored "$query" "$limit"
.claude/hooks/memory-manager.sh:841:}
.claude/hooks/memory-manager.sh:842:
.claude/hooks/memory-manager.sh:843:# Get context for current task
.claude/hooks/memory-manager.sh:844:get_context() {
.claude/hooks/memory-manager.sh:845:    init_memory
.claude/hooks/memory-manager.sh:846:
.claude/hooks/memory-manager.sh:847:    echo "{"
.claude/hooks/memory-manager.sh:848:
.claude/hooks/memory-manager.sh:849:    # Working memory
.claude/hooks/memory-manager.sh:850:    echo '"working":'
.claude/hooks/memory-manager.sh:851:    get_working
.claude/hooks/memory-manager.sh:852:    echo ","
.claude/hooks/memory-manager.sh:853:
.claude/hooks/memory-manager.sh:854:    # Recent episodes
.claude/hooks/memory-manager.sh:855:    echo '"recentEpisodes":'
.claude/hooks/memory-manager.sh:856:    get_recent_episodes 5
.claude/hooks/memory-manager.sh:857:    echo ","
.claude/hooks/memory-manager.sh:858:
.claude/hooks/memory-manager.sh:859:    # Recent reflections
.claude/hooks/memory-manager.sh:860:    echo '"reflections":'
.claude/hooks/memory-manager.sh:861:    get_reflections "" 3
.claude/hooks/memory-manager.sh:862:
.claude/hooks/memory-manager.sh:863:    echo "}"
.claude/hooks/memory-manager.sh:864:}
.claude/hooks/memory-manager.sh:865:
.claude/hooks/memory-manager.sh:866:# =============================================================================
.claude/hooks/memory-manager.sh:867:# MEMORY STATISTICS
.claude/hooks/memory-manager.sh:868:# =============================================================================
.claude/hooks/memory-manager.sh:869:
.claude/hooks/memory-manager.sh:870:get_stats() {
.claude/hooks/memory-manager.sh:871:    init_memory
.claude/hooks/memory-manager.sh:872:
.claude/hooks/memory-manager.sh:873:    local episodic_count
.claude/hooks/memory-manager.sh:874:    episodic_count=$(jq '.episodes | length' "$EPISODIC_MEMORY")
.claude/hooks/memory-manager.sh:875:
.claude/hooks/memory-manager.sh:876:    local facts_count
.claude/hooks/memory-manager.sh:877:    facts_count=$(jq '.facts | length' "$SEMANTIC_MEMORY")
.claude/hooks/memory-manager.sh:878:
.claude/hooks/memory-manager.sh:879:    local patterns_count
.claude/hooks/memory-manager.sh:880:    patterns_count=$(jq '.patterns | length' "$SEMANTIC_MEMORY")
.claude/hooks/memory-manager.sh:881:
.claude/hooks/memory-manager.sh:882:    local actions_count
.claude/hooks/memory-manager.sh:883:    actions_count=$(wc -l < "$ACTION_LOG" 2>/dev/null || echo "0")
.claude/hooks/memory-manager.sh:884:
.claude/hooks/memory-manager.sh:885:    local reflections_count
.claude/hooks/memory-manager.sh:886:    reflections_count=$(jq '.reflections | length' "$REFLECTION_LOG")
.claude/hooks/memory-manager.sh:887:
.claude/hooks/memory-manager.sh:888:    jq -n \
.claude/hooks/memory-manager.sh:889:       --argjson episodes "$episodic_count" \
.claude/hooks/memory-manager.sh:890:       --argjson facts "$facts_count" \
.claude/hooks/memory-manager.sh:891:       --argjson patterns "$patterns_count" \
.claude/hooks/memory-manager.sh:892:       --argjson actions "$actions_count" \
.claude/hooks/memory-manager.sh:893:       --argjson reflections "$reflections_count" \
.claude/hooks/memory-manager.sh:894:       '{
.claude/hooks/memory-manager.sh:895:           episodicMemory: $episodes,
.claude/hooks/memory-manager.sh:896:           semanticFacts: $facts,
.claude/hooks/memory-manager.sh:897:           learnedPatterns: $patterns,
.claude/hooks/memory-manager.sh:898:           actionLog: $actions,
.claude/hooks/memory-manager.sh:899:           reflections: $reflections
.claude/hooks/memory-manager.sh:900:       }'
.claude/hooks/memory-manager.sh:901:}
.claude/hooks/memory-manager.sh:902:
.claude/hooks/memory-manager.sh:903:# =============================================================================
.claude/hooks/memory-manager.sh:904:# CHECKPOINT/RESTORE (Session state snapshots)
.claude/hooks/memory-manager.sh:905:# Based on patterns from GitHub: checkpoint/snapshot/restore implementations
.claude/hooks/memory-manager.sh:906:# =============================================================================
.claude/hooks/memory-manager.sh:907:
.claude/hooks/memory-manager.sh:908:# Create a checkpoint (snapshot memory + git metadata)
.claude/hooks/memory-manager.sh:909:checkpoint() {
.claude/hooks/memory-manager.sh:910:    local description="${1:-Auto checkpoint}"
.claude/hooks/memory-manager.sh:911:
.claude/hooks/memory-manager.sh:912:    init_memory
.claude/hooks/memory-manager.sh:913:
.claude/hooks/memory-manager.sh:914:    local checkpoint_dir="$MEMORY_DIR/checkpoints"
.claude/hooks/memory-manager.sh:915:    mkdir -p "$checkpoint_dir"
.claude/hooks/memory-manager.sh:916:
.claude/hooks/memory-manager.sh:917:    local timestamp
.claude/hooks/memory-manager.sh:918:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:919:
.claude/hooks/memory-manager.sh:920:    local checkpoint_id
.claude/hooks/memory-manager.sh:921:    checkpoint_id="ckpt_$(date +%s)"
.claude/hooks/memory-manager.sh:922:
.claude/hooks/memory-manager.sh:923:    local checkpoint_path="$checkpoint_dir/$checkpoint_id.json"
.claude/hooks/memory-manager.sh:924:
.claude/hooks/memory-manager.sh:925:    # Capture git metadata
.claude/hooks/memory-manager.sh:926:    local git_branch
.claude/hooks/memory-manager.sh:927:    git_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
.claude/hooks/memory-manager.sh:928:
.claude/hooks/memory-manager.sh:929:    local git_commit
.claude/hooks/memory-manager.sh:930:    git_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
.claude/hooks/memory-manager.sh:931:
.claude/hooks/memory-manager.sh:932:    local git_dirty
.claude/hooks/memory-manager.sh:933:    git_dirty="false"
.claude/hooks/memory-manager.sh:934:    if [[ -d .git ]] && ! git diff-index --quiet HEAD -- 2>/dev/null; then
.claude/hooks/memory-manager.sh:935:        git_dirty="true"
.claude/hooks/memory-manager.sh:936:    fi
.claude/hooks/memory-manager.sh:937:
.claude/hooks/memory-manager.sh:938:    # Create checkpoint with all memory state
.claude/hooks/memory-manager.sh:939:    jq -n \
.claude/hooks/memory-manager.sh:940:        --arg id "$checkpoint_id" \
.claude/hooks/memory-manager.sh:941:        --arg desc "$description" \
.claude/hooks/memory-manager.sh:942:        --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:943:        --arg branch "$git_branch" \
.claude/hooks/memory-manager.sh:944:        --arg commit "$git_commit" \
.claude/hooks/memory-manager.sh:945:        --arg dirty "$git_dirty" \
.claude/hooks/memory-manager.sh:946:        --slurpfile working "$WORKING_MEMORY" \
.claude/hooks/memory-manager.sh:947:        --slurpfile episodic "$EPISODIC_MEMORY" \
.claude/hooks/memory-manager.sh:948:        --slurpfile semantic "$SEMANTIC_MEMORY" \
.claude/hooks/memory-manager.sh:949:        --slurpfile reflections "$REFLECTION_LOG" \
.claude/hooks/memory-manager.sh:950:        '{
.claude/hooks/memory-manager.sh:951:            id: $id,
.claude/hooks/memory-manager.sh:952:            description: $desc,
.claude/hooks/memory-manager.sh:953:            timestamp: $ts,
.claude/hooks/memory-manager.sh:954:            git: {
.claude/hooks/memory-manager.sh:955:                branch: $branch,
.claude/hooks/memory-manager.sh:956:                commit: $commit,
.claude/hooks/memory-manager.sh:957:                dirty: ($dirty == "true")
.claude/hooks/memory-manager.sh:958:            },
.claude/hooks/memory-manager.sh:959:            memory: {
.claude/hooks/memory-manager.sh:960:                working: $working[0],
.claude/hooks/memory-manager.sh:961:                episodic: $episodic[0],
.claude/hooks/memory-manager.sh:962:                semantic: $semantic[0],
.claude/hooks/memory-manager.sh:963:                reflections: $reflections[0]
.claude/hooks/memory-manager.sh:964:            }
.claude/hooks/memory-manager.sh:965:        }' > "$checkpoint_path"
.claude/hooks/memory-manager.sh:966:
.claude/hooks/memory-manager.sh:967:    # Copy action log (JSONL, just copy the file)
.claude/hooks/memory-manager.sh:968:    if [[ -f "$ACTION_LOG" ]]; then
.claude/hooks/memory-manager.sh:969:        cp "$ACTION_LOG" "$checkpoint_dir/$checkpoint_id.actions.jsonl"
.claude/hooks/memory-manager.sh:970:    fi
.claude/hooks/memory-manager.sh:971:
.claude/hooks/memory-manager.sh:972:    log "Created checkpoint: $checkpoint_id - $description"
.claude/hooks/memory-manager.sh:973:    echo "$checkpoint_id"
.claude/hooks/memory-manager.sh:974:}
.claude/hooks/memory-manager.sh:975:
.claude/hooks/memory-manager.sh:976:# Restore from a checkpoint
.claude/hooks/memory-manager.sh:977:restore_checkpoint() {
.claude/hooks/memory-manager.sh:978:    local checkpoint_id="$1"
.claude/hooks/memory-manager.sh:979:
.claude/hooks/memory-manager.sh:980:    init_memory
.claude/hooks/memory-manager.sh:981:
.claude/hooks/memory-manager.sh:982:    local checkpoint_dir="$MEMORY_DIR/checkpoints"
.claude/hooks/memory-manager.sh:983:    local checkpoint_path="$checkpoint_dir/$checkpoint_id.json"
.claude/hooks/memory-manager.sh:984:
.claude/hooks/memory-manager.sh:985:    if [[ ! -f "$checkpoint_path" ]]; then
.claude/hooks/memory-manager.sh:986:        echo "Error: Checkpoint $checkpoint_id not found" >&2
.claude/hooks/memory-manager.sh:987:        return 1
.claude/hooks/memory-manager.sh:988:    fi
.claude/hooks/memory-manager.sh:989:
.claude/hooks/memory-manager.sh:990:    # Extract and restore memory files
.claude/hooks/memory-manager.sh:991:    jq -r '.memory.working' "$checkpoint_path" > "$WORKING_MEMORY"
.claude/hooks/memory-manager.sh:992:    jq -r '.memory.episodic' "$checkpoint_path" > "$EPISODIC_MEMORY"
.claude/hooks/memory-manager.sh:993:    jq -r '.memory.semantic' "$checkpoint_path" > "$SEMANTIC_MEMORY"
.claude/hooks/memory-manager.sh:994:    jq -r '.memory.reflections' "$checkpoint_path" > "$REFLECTION_LOG"
.claude/hooks/memory-manager.sh:995:
.claude/hooks/memory-manager.sh:996:    # Restore action log if it exists
.claude/hooks/memory-manager.sh:997:    local action_log_backup="$checkpoint_dir/$checkpoint_id.actions.jsonl"
.claude/hooks/memory-manager.sh:998:    if [[ -f "$action_log_backup" ]]; then
.claude/hooks/memory-manager.sh:999:        cp "$action_log_backup" "$ACTION_LOG"
.claude/hooks/memory-manager.sh:1000:    fi
.claude/hooks/memory-manager.sh:1001:
.claude/hooks/memory-manager.sh:1002:    log "Restored checkpoint: $checkpoint_id"
.claude/hooks/memory-manager.sh:1003:
.claude/hooks/memory-manager.sh:1004:    # Return checkpoint info
.claude/hooks/memory-manager.sh:1005:    jq '{id, description, timestamp, git}' "$checkpoint_path"
.claude/hooks/memory-manager.sh:1006:}
.claude/hooks/memory-manager.sh:1007:
.claude/hooks/memory-manager.sh:1008:# List available checkpoints
.claude/hooks/memory-manager.sh:1009:list_checkpoints() {
.claude/hooks/memory-manager.sh:1010:    local limit="${1:-10}"
.claude/hooks/memory-manager.sh:1011:
.claude/hooks/memory-manager.sh:1012:    init_memory
.claude/hooks/memory-manager.sh:1013:
.claude/hooks/memory-manager.sh:1014:    local checkpoint_dir="$MEMORY_DIR/checkpoints"
.claude/hooks/memory-manager.sh:1015:
.claude/hooks/memory-manager.sh:1016:    if [[ ! -d "$checkpoint_dir" ]]; then
.claude/hooks/memory-manager.sh:1017:        echo "[]"
.claude/hooks/memory-manager.sh:1018:        return 0
.claude/hooks/memory-manager.sh:1019:    fi
.claude/hooks/memory-manager.sh:1020:
.claude/hooks/memory-manager.sh:1021:    # Find all checkpoint files, extract metadata, sort by timestamp
.claude/hooks/memory-manager.sh:1022:    local results="[]"
.claude/hooks/memory-manager.sh:1023:    for ckpt_file in "$checkpoint_dir"/ckpt_*.json; do
.claude/hooks/memory-manager.sh:1024:        if [[ -f "$ckpt_file" ]]; then
.claude/hooks/memory-manager.sh:1025:            local ckpt_data
.claude/hooks/memory-manager.sh:1026:            ckpt_data=$(jq '{id, description, timestamp, git}' "$ckpt_file" 2>/dev/null)
.claude/hooks/memory-manager.sh:1027:            if [[ -n "$ckpt_data" ]]; then
.claude/hooks/memory-manager.sh:1028:                results=$(echo "$results" | jq --argjson ckpt "$ckpt_data" '. + [$ckpt]')
.claude/hooks/memory-manager.sh:1029:            fi
.claude/hooks/memory-manager.sh:1030:        fi
.claude/hooks/memory-manager.sh:1031:    done
.claude/hooks/memory-manager.sh:1032:
.claude/hooks/memory-manager.sh:1033:    echo "$results" | jq --argjson limit "$limit" 'sort_by(.timestamp) | reverse | .[0:$limit]'
.claude/hooks/memory-manager.sh:1034:}
.claude/hooks/memory-manager.sh:1035:
.claude/hooks/memory-manager.sh:1036:# Delete old checkpoints (keep N most recent)
.claude/hooks/memory-manager.sh:1037:prune_checkpoints() {
.claude/hooks/memory-manager.sh:1038:    local keep="${1:-5}"
.claude/hooks/memory-manager.sh:1039:
.claude/hooks/memory-manager.sh:1040:    init_memory
.claude/hooks/memory-manager.sh:1041:
.claude/hooks/memory-manager.sh:1042:    local checkpoint_dir="$MEMORY_DIR/checkpoints"
.claude/hooks/memory-manager.sh:1043:
.claude/hooks/memory-manager.sh:1044:    if [[ ! -d "$checkpoint_dir" ]]; then
.claude/hooks/memory-manager.sh:1045:        return 0
.claude/hooks/memory-manager.sh:1046:    fi
.claude/hooks/memory-manager.sh:1047:
.claude/hooks/memory-manager.sh:1048:    # Get list of checkpoints sorted by timestamp (oldest first)
.claude/hooks/memory-manager.sh:1049:    local checkpoints
.claude/hooks/memory-manager.sh:1050:    checkpoints=$(list_checkpoints 1000 | jq -r 'reverse | .[].id')
.claude/hooks/memory-manager.sh:1051:
.claude/hooks/memory-manager.sh:1052:    local count=0
.claude/hooks/memory-manager.sh:1053:    local deleted=0
.claude/hooks/memory-manager.sh:1054:
.claude/hooks/memory-manager.sh:1055:    for ckpt_id in $checkpoints; do
.claude/hooks/memory-manager.sh:1056:        count=$((count + 1))
.claude/hooks/memory-manager.sh:1057:        if [[ $count -le $keep ]]; then
.claude/hooks/memory-manager.sh:1058:            continue
.claude/hooks/memory-manager.sh:1059:        fi
.claude/hooks/memory-manager.sh:1060:
.claude/hooks/memory-manager.sh:1061:        # Delete checkpoint files
.claude/hooks/memory-manager.sh:1062:        rm -f "$checkpoint_dir/$ckpt_id.json"
.claude/hooks/memory-manager.sh:1063:        rm -f "$checkpoint_dir/$ckpt_id.actions.jsonl"
.claude/hooks/memory-manager.sh:1064:        deleted=$((deleted + 1))
.claude/hooks/memory-manager.sh:1065:    done
.claude/hooks/memory-manager.sh:1066:
.claude/hooks/memory-manager.sh:1067:    log "Pruned $deleted old checkpoints (kept $keep most recent)"
.claude/hooks/memory-manager.sh:1068:    echo "$deleted"
.claude/hooks/memory-manager.sh:1069:}
.claude/hooks/memory-manager.sh:1070:
.claude/hooks/memory-manager.sh:1071:# =============================================================================
.claude/hooks/memory-manager.sh:1072:# FILE CHANGE DETECTION (SHA-256 hash tracking)
.claude/hooks/memory-manager.sh:1073:# Based on patterns from GitHub: shasum -a 256 / sha256sum implementations
.claude/hooks/memory-manager.sh:1074:# =============================================================================
.claude/hooks/memory-manager.sh:1075:
.claude/hooks/memory-manager.sh:1076:FILE_CACHE="$MEMORY_DIR/file-cache.json"
.claude/hooks/memory-manager.sh:1077:
.claude/hooks/memory-manager.sh:1078:# Initialize file cache
.claude/hooks/memory-manager.sh:1079:init_file_cache() {
.claude/hooks/memory-manager.sh:1080:    if [[ ! -f "$FILE_CACHE" ]]; then
.claude/hooks/memory-manager.sh:1081:        echo '{"files":{}}' > "$FILE_CACHE"
.claude/hooks/memory-manager.sh:1082:    fi
.claude/hooks/memory-manager.sh:1083:}
.claude/hooks/memory-manager.sh:1084:
.claude/hooks/memory-manager.sh:1085:# Get SHA-256 hash of a file (portable: macOS and Linux)
.claude/hooks/memory-manager.sh:1086:get_file_hash() {
.claude/hooks/memory-manager.sh:1087:    local file_path="$1"
.claude/hooks/memory-manager.sh:1088:
.claude/hooks/memory-manager.sh:1089:    if [[ ! -f "$file_path" ]]; then
.claude/hooks/memory-manager.sh:1090:        echo "error: file not found" >&2
.claude/hooks/memory-manager.sh:1091:        return 1
.claude/hooks/memory-manager.sh:1092:    fi
.claude/hooks/memory-manager.sh:1093:
.claude/hooks/memory-manager.sh:1094:    # Try shasum (macOS) first, fall back to sha256sum (Linux)
.claude/hooks/memory-manager.sh:1095:    if command -v shasum >/dev/null 2>&1; then
.claude/hooks/memory-manager.sh:1096:        shasum -a 256 "$file_path" | awk '{print $1}'
.claude/hooks/memory-manager.sh:1097:    elif command -v sha256sum >/dev/null 2>&1; then
.claude/hooks/memory-manager.sh:1098:        sha256sum "$file_path" | awk '{print $1}'
.claude/hooks/memory-manager.sh:1099:    else
.claude/hooks/memory-manager.sh:1100:        echo "error: no SHA-256 tool available" >&2
.claude/hooks/memory-manager.sh:1101:        return 1
.claude/hooks/memory-manager.sh:1102:    fi
.claude/hooks/memory-manager.sh:1103:}
.claude/hooks/memory-manager.sh:1104:
.claude/hooks/memory-manager.sh:1105:# Cache a file's hash
.claude/hooks/memory-manager.sh:1106:cache_file() {
.claude/hooks/memory-manager.sh:1107:    local file_path="$1"
.claude/hooks/memory-manager.sh:1108:
.claude/hooks/memory-manager.sh:1109:    init_memory
.claude/hooks/memory-manager.sh:1110:    init_file_cache
.claude/hooks/memory-manager.sh:1111:
.claude/hooks/memory-manager.sh:1112:    local hash
.claude/hooks/memory-manager.sh:1113:    hash=$(get_file_hash "$file_path")
.claude/hooks/memory-manager.sh:1114:
.claude/hooks/memory-manager.sh:1115:    if [[ $? -ne 0 ]]; then
.claude/hooks/memory-manager.sh:1116:        return 1
.claude/hooks/memory-manager.sh:1117:    fi
.claude/hooks/memory-manager.sh:1118:
.claude/hooks/memory-manager.sh:1119:    local timestamp
.claude/hooks/memory-manager.sh:1120:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/memory-manager.sh:1121:
.claude/hooks/memory-manager.sh:1122:    # Update cache
.claude/hooks/memory-manager.sh:1123:    local temp_file
.claude/hooks/memory-manager.sh:1124:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:1125:
.claude/hooks/memory-manager.sh:1126:    jq --arg path "$file_path" \
.claude/hooks/memory-manager.sh:1127:       --arg hash "$hash" \
.claude/hooks/memory-manager.sh:1128:       --arg ts "$timestamp" \
.claude/hooks/memory-manager.sh:1129:       '.files[$path] = {hash: $hash, cachedAt: $ts}' \
.claude/hooks/memory-manager.sh:1130:       "$FILE_CACHE" > "$temp_file"
.claude/hooks/memory-manager.sh:1131:
.claude/hooks/memory-manager.sh:1132:    mv "$temp_file" "$FILE_CACHE"
.claude/hooks/memory-manager.sh:1133:
.claude/hooks/memory-manager.sh:1134:    log "Cached file: $file_path (hash: ${hash:0:8}...)"
.claude/hooks/memory-manager.sh:1135:    echo "$hash"
.claude/hooks/memory-manager.sh:1136:}
.claude/hooks/memory-manager.sh:1137:
.claude/hooks/memory-manager.sh:1138:# Check if a file has changed since last cache
.claude/hooks/memory-manager.sh:1139:file_changed() {
.claude/hooks/memory-manager.sh:1140:    local file_path="$1"
.claude/hooks/memory-manager.sh:1141:
.claude/hooks/memory-manager.sh:1142:    init_memory
.claude/hooks/memory-manager.sh:1143:    init_file_cache
.claude/hooks/memory-manager.sh:1144:
.claude/hooks/memory-manager.sh:1145:    # Get current hash
.claude/hooks/memory-manager.sh:1146:    local current_hash
.claude/hooks/memory-manager.sh:1147:    current_hash=$(get_file_hash "$file_path")
.claude/hooks/memory-manager.sh:1148:
.claude/hooks/memory-manager.sh:1149:    if [[ $? -ne 0 ]]; then
.claude/hooks/memory-manager.sh:1150:        return 1
.claude/hooks/memory-manager.sh:1151:    fi
.claude/hooks/memory-manager.sh:1152:
.claude/hooks/memory-manager.sh:1153:    # Get cached hash
.claude/hooks/memory-manager.sh:1154:    local cached_hash
.claude/hooks/memory-manager.sh:1155:    cached_hash=$(jq -r --arg path "$file_path" \
.claude/hooks/memory-manager.sh:1156:        '.files[$path].hash // "none"' "$FILE_CACHE")
.claude/hooks/memory-manager.sh:1157:
.claude/hooks/memory-manager.sh:1158:    # Compare
.claude/hooks/memory-manager.sh:1159:    if [[ "$cached_hash" == "none" ]]; then
.claude/hooks/memory-manager.sh:1160:        # File not cached yet
.claude/hooks/memory-manager.sh:1161:        echo "true"
.claude/hooks/memory-manager.sh:1162:        return 0
.claude/hooks/memory-manager.sh:1163:    elif [[ "$current_hash" != "$cached_hash" ]]; then
.claude/hooks/memory-manager.sh:1164:        # File changed
.claude/hooks/memory-manager.sh:1165:        echo "true"
.claude/hooks/memory-manager.sh:1166:        return 0
.claude/hooks/memory-manager.sh:1167:    else
.claude/hooks/memory-manager.sh:1168:        # File unchanged
.claude/hooks/memory-manager.sh:1169:        echo "false"
.claude/hooks/memory-manager.sh:1170:        return 0
.claude/hooks/memory-manager.sh:1171:    fi
.claude/hooks/memory-manager.sh:1172:}
.claude/hooks/memory-manager.sh:1173:
.claude/hooks/memory-manager.sh:1174:# Get file cache info
.claude/hooks/memory-manager.sh:1175:get_file_cache_info() {
.claude/hooks/memory-manager.sh:1176:    local file_path="$1"
.claude/hooks/memory-manager.sh:1177:
.claude/hooks/memory-manager.sh:1178:    init_memory
.claude/hooks/memory-manager.sh:1179:    init_file_cache
.claude/hooks/memory-manager.sh:1180:
.claude/hooks/memory-manager.sh:1181:    jq --arg path "$file_path" \
.claude/hooks/memory-manager.sh:1182:        '.files[$path] // {error: "not cached"}' \
.claude/hooks/memory-manager.sh:1183:        "$FILE_CACHE"
.claude/hooks/memory-manager.sh:1184:}
.claude/hooks/memory-manager.sh:1185:
.claude/hooks/memory-manager.sh:1186:# List all cached files
.claude/hooks/memory-manager.sh:1187:list_cached_files() {
.claude/hooks/memory-manager.sh:1188:    init_memory
.claude/hooks/memory-manager.sh:1189:    init_file_cache
.claude/hooks/memory-manager.sh:1190:
.claude/hooks/memory-manager.sh:1191:    jq -r '.files | keys[]' "$FILE_CACHE"
.claude/hooks/memory-manager.sh:1192:}
.claude/hooks/memory-manager.sh:1193:
.claude/hooks/memory-manager.sh:1194:# Clear file cache
.claude/hooks/memory-manager.sh:1195:clear_file_cache() {
.claude/hooks/memory-manager.sh:1196:    init_memory
.claude/hooks/memory-manager.sh:1197:
.claude/hooks/memory-manager.sh:1198:    echo '{"files":{}}' > "$FILE_CACHE"
.claude/hooks/memory-manager.sh:1199:    log "Cleared file cache"
.claude/hooks/memory-manager.sh:1200:}
.claude/hooks/memory-manager.sh:1201:
.claude/hooks/memory-manager.sh:1202:# Prune file cache (remove files that don't exist)
.claude/hooks/memory-manager.sh:1203:prune_file_cache() {
.claude/hooks/memory-manager.sh:1204:    init_memory
.claude/hooks/memory-manager.sh:1205:    init_file_cache
.claude/hooks/memory-manager.sh:1206:
.claude/hooks/memory-manager.sh:1207:    local temp_file
.claude/hooks/memory-manager.sh:1208:    temp_file=$(mktemp)
.claude/hooks/memory-manager.sh:1209:
.claude/hooks/memory-manager.sh:1210:    local pruned=0
.claude/hooks/memory-manager.sh:1211:
.claude/hooks/memory-manager.sh:1212:    # Build new cache with only existing files
.claude/hooks/memory-manager.sh:1213:    local cached_files
.claude/hooks/memory-manager.sh:1214:    cached_files=$(jq -r '.files | keys[]' "$FILE_CACHE")
.claude/hooks/memory-manager.sh:1215:
.claude/hooks/memory-manager.sh:1216:    local new_cache='{"files":{}}'
.claude/hooks/memory-manager.sh:1217:
.claude/hooks/memory-manager.sh:1218:    for file_path in $cached_files; do
.claude/hooks/memory-manager.sh:1219:        if [[ -f "$file_path" ]]; then
.claude/hooks/memory-manager.sh:1220:            # File still exists, keep it
.claude/hooks/memory-manager.sh:1221:            local file_data
.claude/hooks/memory-manager.sh:1222:            file_data=$(jq --arg path "$file_path" '.files[$path]' "$FILE_CACHE")
.claude/hooks/memory-manager.sh:1223:            new_cache=$(echo "$new_cache" | jq --arg path "$file_path" \
.claude/hooks/memory-manager.sh:1224:                --argjson data "$file_data" \
.claude/hooks/memory-manager.sh:1225:                '.files[$path] = $data')
.claude/hooks/memory-manager.sh:1226:        else
.claude/hooks/memory-manager.sh:1227:            # File deleted, don't keep
.claude/hooks/memory-manager.sh:1228:            pruned=$((pruned + 1))
.claude/hooks/memory-manager.sh:1229:        fi
.claude/hooks/memory-manager.sh:1230:    done
.claude/hooks/memory-manager.sh:1231:
.claude/hooks/memory-manager.sh:1232:    echo "$new_cache" > "$FILE_CACHE"
.claude/hooks/memory-manager.sh:1233:
.claude/hooks/memory-manager.sh:1234:    log "Pruned $pruned deleted files from cache"
.claude/hooks/memory-manager.sh:1235:    echo "$pruned"
.claude/hooks/memory-manager.sh:1236:}
.claude/hooks/memory-manager.sh:1237:
.claude/hooks/memory-manager.sh:1238:# =============================================================================
.claude/hooks/memory-manager.sh:1239:# COMMAND INTERFACE
.claude/hooks/memory-manager.sh:1240:# =============================================================================
.claude/hooks/memory-manager.sh:1241:
.claude/hooks/memory-manager.sh:1242:case "${1:-help}" in
.claude/hooks/memory-manager.sh:1243:    # Working memory
.claude/hooks/memory-manager.sh:1244:    set-task)
.claude/hooks/memory-manager.sh:1245:        set_task "${2:-}" "${3:-}"
.claude/hooks/memory-manager.sh:1246:        ;;
.claude/hooks/memory-manager.sh:1247:    add-context)
.claude/hooks/memory-manager.sh:1248:        add_context "${2:-}" "${3:-5}"
.claude/hooks/memory-manager.sh:1249:        ;;
.claude/hooks/memory-manager.sh:1250:    scratchpad)
.claude/hooks/memory-manager.sh:1251:        update_scratchpad "${2:-}" "${3:-true}"
.claude/hooks/memory-manager.sh:1252:        ;;
.claude/hooks/memory-manager.sh:1253:    get-working)
.claude/hooks/memory-manager.sh:1254:        get_working
.claude/hooks/memory-manager.sh:1255:        ;;
.claude/hooks/memory-manager.sh:1256:    clear-working)
.claude/hooks/memory-manager.sh:1257:        clear_working
.claude/hooks/memory-manager.sh:1258:        ;;
.claude/hooks/memory-manager.sh:1259:
.claude/hooks/memory-manager.sh:1260:    # Episodic memory
.claude/hooks/memory-manager.sh:1261:    record)
.claude/hooks/memory-manager.sh:1262:        record_episode "${2:-task}" "${3:-}" "${4:-success}" "${5:-}"
.claude/hooks/memory-manager.sh:1263:        ;;
.claude/hooks/memory-manager.sh:1264:    search-episodes)
.claude/hooks/memory-manager.sh:1265:        search_episodes "${2:-}" "${3:-10}"
.claude/hooks/memory-manager.sh:1266:        ;;
.claude/hooks/memory-manager.sh:1267:    recent-episodes)
.claude/hooks/memory-manager.sh:1268:        get_recent_episodes "${2:-10}" "${3:-}"
.claude/hooks/memory-manager.sh:1269:        ;;
.claude/hooks/memory-manager.sh:1270:
.claude/hooks/memory-manager.sh:1271:    # Semantic memory
.claude/hooks/memory-manager.sh:1272:    add-fact)
.claude/hooks/memory-manager.sh:1273:        add_fact "${2:-}" "${3:-}" "${4:-}" "${5:-0.8}"
.claude/hooks/memory-manager.sh:1274:        ;;
.claude/hooks/memory-manager.sh:1275:    get-fact)
.claude/hooks/memory-manager.sh:1276:        get_fact "${2:-}" "${3:-}"
.claude/hooks/memory-manager.sh:1277:        ;;
.claude/hooks/memory-manager.sh:1278:    facts)
.claude/hooks/memory-manager.sh:1279:        get_facts_by_category "${2:-}"
.claude/hooks/memory-manager.sh:1280:        ;;
.claude/hooks/memory-manager.sh:1281:    add-pattern)
.claude/hooks/memory-manager.sh:1282:        add_pattern "${2:-}" "${3:-}" "${4:-}" "${5:-1.0}"
.claude/hooks/memory-manager.sh:1283:        ;;
.claude/hooks/memory-manager.sh:1284:    find-patterns)
.claude/hooks/memory-manager.sh:1285:        find_patterns "${2:-}" "${3:-5}"
.claude/hooks/memory-manager.sh:1286:        ;;
.claude/hooks/memory-manager.sh:1287:    set-pref)
.claude/hooks/memory-manager.sh:1288:        add_preference "${2:-}" "${3:-}"
.claude/hooks/memory-manager.sh:1289:        ;;
.claude/hooks/memory-manager.sh:1290:    get-pref)
.claude/hooks/memory-manager.sh:1291:        get_preference "${2:-}" "${3:-}"
.claude/hooks/memory-manager.sh:1292:        ;;
.claude/hooks/memory-manager.sh:1293:
.claude/hooks/memory-manager.sh:1294:    # Action log
.claude/hooks/memory-manager.sh:1295:    log-action)
.claude/hooks/memory-manager.sh:1296:        log_action "${2:-}" "${3:-}" "${4:-}" "${5:-{}}"
.claude/hooks/memory-manager.sh:1297:        ;;
.claude/hooks/memory-manager.sh:1298:    recent-actions)
.claude/hooks/memory-manager.sh:1299:        get_recent_actions "${2:-20}" "${3:-}"
.claude/hooks/memory-manager.sh:1300:        ;;
.claude/hooks/memory-manager.sh:1301:    search-actions)
.claude/hooks/memory-manager.sh:1302:        search_actions "${2:-}" "${3:-20}"
.claude/hooks/memory-manager.sh:1303:        ;;
.claude/hooks/memory-manager.sh:1304:
.claude/hooks/memory-manager.sh:1305:    # Reflection
.claude/hooks/memory-manager.sh:1306:    reflect)
.claude/hooks/memory-manager.sh:1307:        create_reflection "${2:-general}" "${3:-}" "${4:-}"
.claude/hooks/memory-manager.sh:1308:        ;;
.claude/hooks/memory-manager.sh:1309:    reflections)
.claude/hooks/memory-manager.sh:1310:        get_reflections "${2:-}" "${3:-10}"
.claude/hooks/memory-manager.sh:1311:        ;;
.claude/hooks/memory-manager.sh:1312:
.claude/hooks/memory-manager.sh:1313:    # Retrieval
.claude/hooks/memory-manager.sh:1314:    remember)
.claude/hooks/memory-manager.sh:1315:        remember "${2:-}" "${3:-10}"
.claude/hooks/memory-manager.sh:1316:        ;;
.claude/hooks/memory-manager.sh:1317:    remember-scored)
.claude/hooks/memory-manager.sh:1318:        remember_scored "${2:-}" "${3:-10}"
.claude/hooks/memory-manager.sh:1319:        ;;
.claude/hooks/memory-manager.sh:1320:    context)
.claude/hooks/memory-manager.sh:1321:        get_context
.claude/hooks/memory-manager.sh:1322:        ;;
.claude/hooks/memory-manager.sh:1323:
.claude/hooks/memory-manager.sh:1324:    # Stats
.claude/hooks/memory-manager.sh:1325:    stats)
.claude/hooks/memory-manager.sh:1326:        get_stats
.claude/hooks/memory-manager.sh:1327:        ;;
.claude/hooks/memory-manager.sh:1328:
.claude/hooks/memory-manager.sh:1329:    # Checkpoint/Restore
.claude/hooks/memory-manager.sh:1330:    checkpoint)
.claude/hooks/memory-manager.sh:1331:        checkpoint "${2:-Auto checkpoint}"
.claude/hooks/memory-manager.sh:1332:        ;;
.claude/hooks/memory-manager.sh:1333:    restore)
.claude/hooks/memory-manager.sh:1334:        restore_checkpoint "${2:-}"
.claude/hooks/memory-manager.sh:1335:        ;;
.claude/hooks/memory-manager.sh:1336:    list-checkpoints)
.claude/hooks/memory-manager.sh:1337:        list_checkpoints "${2:-10}"
.claude/hooks/memory-manager.sh:1338:        ;;
.claude/hooks/memory-manager.sh:1339:    prune-checkpoints)
.claude/hooks/memory-manager.sh:1340:        prune_checkpoints "${2:-5}"
.claude/hooks/memory-manager.sh:1341:        ;;
.claude/hooks/memory-manager.sh:1342:
.claude/hooks/memory-manager.sh:1343:    # File Change Detection
.claude/hooks/memory-manager.sh:1344:    cache-file)
.claude/hooks/memory-manager.sh:1345:        cache_file "${2:-}"
.claude/hooks/memory-manager.sh:1346:        ;;
.claude/hooks/memory-manager.sh:1347:    file-changed)
.claude/hooks/memory-manager.sh:1348:        file_changed "${2:-}"
.claude/hooks/memory-manager.sh:1349:        ;;
.claude/hooks/memory-manager.sh:1350:    file-info)
.claude/hooks/memory-manager.sh:1351:        get_file_cache_info "${2:-}"
.claude/hooks/memory-manager.sh:1352:        ;;
.claude/hooks/memory-manager.sh:1353:    list-cached)
.claude/hooks/memory-manager.sh:1354:        list_cached_files
.claude/hooks/memory-manager.sh:1355:        ;;
.claude/hooks/memory-manager.sh:1356:    clear-cache)
.claude/hooks/memory-manager.sh:1357:        clear_file_cache
.claude/hooks/memory-manager.sh:1358:        ;;
.claude/hooks/memory-manager.sh:1359:    prune-cache)
.claude/hooks/memory-manager.sh:1360:        prune_file_cache
.claude/hooks/memory-manager.sh:1361:        ;;
.claude/hooks/memory-manager.sh:1362:
.claude/hooks/memory-manager.sh:1363:    init)
.claude/hooks/memory-manager.sh:1364:        init_memory
.claude/hooks/memory-manager.sh:1365:        echo "Memory initialized at $MEMORY_DIR"
.claude/hooks/memory-manager.sh:1366:        ;;
.claude/hooks/memory-manager.sh:1367:
.claude/hooks/memory-manager.sh:1368:    scope)
.claude/hooks/memory-manager.sh:1369:        echo "Memory Scope Configuration"
.claude/hooks/memory-manager.sh:1370:        echo ""
.claude/hooks/memory-manager.sh:1371:        echo "Current settings:"
.claude/hooks/memory-manager.sh:1372:        echo "  MEMORY_DIR: $MEMORY_DIR"
.claude/hooks/memory-manager.sh:1373:        echo "  MEMORY_SCOPE: ${MEMORY_SCOPE:-auto}"
.claude/hooks/memory-manager.sh:1374:        echo "  Git Channel: $(get_git_channel)"
.claude/hooks/memory-manager.sh:1375:        echo ""
.claude/hooks/memory-manager.sh:1376:        project_root=$(find_project_root 2>/dev/null) && \
.claude/hooks/memory-manager.sh:1377:            echo "  Project root: $project_root" || \
.claude/hooks/memory-manager.sh:1378:            echo "  Project root: (none detected)"
.claude/hooks/memory-manager.sh:1379:        echo ""
.claude/hooks/memory-manager.sh:1380:        echo "To change scope, set MEMORY_SCOPE:"
.claude/hooks/memory-manager.sh:1381:        echo "  export MEMORY_SCOPE=project  # Use project-local memory"
.claude/hooks/memory-manager.sh:1382:        echo "  export MEMORY_SCOPE=global   # Use global memory"
.claude/hooks/memory-manager.sh:1383:        echo "  export MEMORY_SCOPE=auto     # Auto-detect (default)"
.claude/hooks/memory-manager.sh:1384:        ;;
.claude/hooks/memory-manager.sh:1385:
.claude/hooks/memory-manager.sh:1386:    help|*)
.claude/hooks/memory-manager.sh:1387:        echo "Memory Manager - Persistent Agent Memory"
.claude/hooks/memory-manager.sh:1388:        echo ""
.claude/hooks/memory-manager.sh:1389:        echo "Usage: $0 <command> [args]"
.claude/hooks/memory-manager.sh:1390:        echo ""
.claude/hooks/memory-manager.sh:1391:        echo "Working Memory (current session):"
.claude/hooks/memory-manager.sh:1392:        echo "  set-task <task> [context]        - Set current task"
.claude/hooks/memory-manager.sh:1393:        echo "  add-context <text> [importance]  - Add context (1-10)"
.claude/hooks/memory-manager.sh:1394:        echo "  scratchpad <note> [append]       - Update scratchpad"
.claude/hooks/memory-manager.sh:1395:        echo "  get-working                      - Get working memory"
.claude/hooks/memory-manager.sh:1396:        echo "  clear-working                    - Clear for new session"
.claude/hooks/memory-manager.sh:1397:        echo ""
.claude/hooks/memory-manager.sh:1398:        echo "Episodic Memory (past experiences):"
.claude/hooks/memory-manager.sh:1399:        echo "  record <type> <desc> [outcome] [details] - Record episode"
.claude/hooks/memory-manager.sh:1400:        echo "    Types: task_complete, error_fixed, research_done, pattern_learned"
.claude/hooks/memory-manager.sh:1401:        echo "  search-episodes <query> [limit]  - Search episodes"
.claude/hooks/memory-manager.sh:1402:        echo "  recent-episodes [limit] [type]   - Get recent episodes"
.claude/hooks/memory-manager.sh:1403:        echo ""
.claude/hooks/memory-manager.sh:1404:        echo "Semantic Memory (facts & patterns):"
.claude/hooks/memory-manager.sh:1405:        echo "  add-fact <category> <key> <value> [confidence]"
.claude/hooks/memory-manager.sh:1406:        echo "  get-fact <category> <key>        - Get a fact"
.claude/hooks/memory-manager.sh:1407:        echo "  facts <category>                 - Get category facts"
.claude/hooks/memory-manager.sh:1408:        echo "  add-pattern <type> <trigger> <solution> [success_rate]"
.claude/hooks/memory-manager.sh:1409:        echo "  find-patterns <query> [limit]    - Find matching patterns"
.claude/hooks/memory-manager.sh:1410:        echo "  set-pref <key> <value>           - Set preference"
.claude/hooks/memory-manager.sh:1411:        echo "  get-pref <key> [default]         - Get preference"
.claude/hooks/memory-manager.sh:1412:        echo ""
.claude/hooks/memory-manager.sh:1413:        echo "Action Log:"
.claude/hooks/memory-manager.sh:1414:        echo "  log-action <type> <desc> [result] [metadata]"
.claude/hooks/memory-manager.sh:1415:        echo "  recent-actions [limit] [type]    - Get recent actions"
.claude/hooks/memory-manager.sh:1416:        echo "  search-actions <query> [limit]   - Search actions"
.claude/hooks/memory-manager.sh:1417:        echo ""
.claude/hooks/memory-manager.sh:1418:        echo "Reflection:"
.claude/hooks/memory-manager.sh:1419:        echo "  reflect <focus> <content> [insights]"
.claude/hooks/memory-manager.sh:1420:        echo "  reflections [focus] [limit]      - Get reflections"
.claude/hooks/memory-manager.sh:1421:        echo ""
.claude/hooks/memory-manager.sh:1422:        echo "Retrieval:"
.claude/hooks/memory-manager.sh:1423:        echo "  remember <query> [limit]         - Search all memory (simple)"
.claude/hooks/memory-manager.sh:1424:        echo "  remember-scored <query> [limit]  - Search with 3-factor scoring"
.claude/hooks/memory-manager.sh:1425:        echo "                                     (recency + relevance + importance)"
.claude/hooks/memory-manager.sh:1426:        echo "  context                          - Get current context"
.claude/hooks/memory-manager.sh:1427:        echo ""
.claude/hooks/memory-manager.sh:1428:        echo "Checkpoint/Restore:"
.claude/hooks/memory-manager.sh:1429:        echo "  checkpoint [description]         - Create memory snapshot"
.claude/hooks/memory-manager.sh:1430:        echo "  restore <checkpoint_id>          - Restore from checkpoint"
.claude/hooks/memory-manager.sh:1431:        echo "  list-checkpoints [limit]         - List available checkpoints"
.claude/hooks/memory-manager.sh:1432:        echo "  prune-checkpoints [keep]         - Delete old checkpoints (keep N)"
.claude/hooks/memory-manager.sh:1433:        echo ""
.claude/hooks/memory-manager.sh:1434:        echo "File Change Detection:"
.claude/hooks/memory-manager.sh:1435:        echo "  cache-file <path>                - Cache file hash"
.claude/hooks/memory-manager.sh:1436:        echo "  file-changed <path>              - Check if file changed"
.claude/hooks/memory-manager.sh:1437:        echo "  file-info <path>                 - Get cache info for file"
.claude/hooks/memory-manager.sh:1438:        echo "  list-cached                      - List all cached files"
.claude/hooks/memory-manager.sh:1439:        echo "  clear-cache                      - Clear file cache"
.claude/hooks/memory-manager.sh:1440:        echo "  prune-cache                      - Remove deleted files from cache"
.claude/hooks/memory-manager.sh:1441:        echo ""
.claude/hooks/memory-manager.sh:1442:        echo "Management:"
.claude/hooks/memory-manager.sh:1443:        echo "  stats                            - Memory statistics"
.claude/hooks/memory-manager.sh:1444:        echo "  init                             - Initialize memory"
.claude/hooks/memory-manager.sh:1445:        echo "  scope                            - Show memory scope info"
.claude/hooks/memory-manager.sh:1446:        echo ""
.claude/hooks/memory-manager.sh:1447:        echo "Environment:"
.claude/hooks/memory-manager.sh:1448:        echo "  MEMORY_SCOPE=auto|project|global - Control memory location"
.claude/hooks/memory-manager.sh:1449:        echo "  Current: $MEMORY_DIR"
.claude/hooks/memory-manager.sh:1450:        ;;
.claude/hooks/memory-manager.sh:1451:esac
.claude/hooks/auto-checkpoint.sh:1:#!/bin/bash
.claude/hooks/auto-checkpoint.sh:2:# Auto-checkpoint hook - triggers when context exceeds threshold
.claude/hooks/auto-checkpoint.sh:3:# Reads JSON input from Claude Code, checks context percentage
.claude/hooks/auto-checkpoint.sh:4:
.claude/hooks/auto-checkpoint.sh:5:THRESHOLD=${CLAUDE_CONTEXT_THRESHOLD:-40}
.claude/hooks/auto-checkpoint.sh:6:LOG_FILE="${HOME}/.claude/auto-checkpoint.log"
.claude/hooks/auto-checkpoint.sh:7:
.claude/hooks/auto-checkpoint.sh:8:input=$(cat)
.claude/hooks/auto-checkpoint.sh:9:
.claude/hooks/auto-checkpoint.sh:10:# Extract context window info
.claude/hooks/auto-checkpoint.sh:11:CONTEXT_SIZE=$(echo "$input" | jq -r '.context_window.context_window_size // 200000')
.claude/hooks/auto-checkpoint.sh:12:USAGE=$(echo "$input" | jq '.context_window.current_usage // null')
.claude/hooks/auto-checkpoint.sh:13:
.claude/hooks/auto-checkpoint.sh:14:if [ "$USAGE" = "null" ]; then
.claude/hooks/auto-checkpoint.sh:15:    # No usage data available, allow stop
.claude/hooks/auto-checkpoint.sh:16:    exit 0
.claude/hooks/auto-checkpoint.sh:17:fi
.claude/hooks/auto-checkpoint.sh:18:
.claude/hooks/auto-checkpoint.sh:19:# Calculate current token usage
.claude/hooks/auto-checkpoint.sh:20:INPUT_TOKENS=$(echo "$USAGE" | jq -r '.input_tokens // 0')
.claude/hooks/auto-checkpoint.sh:21:CACHE_CREATE=$(echo "$USAGE" | jq -r '.cache_creation_input_tokens // 0')
.claude/hooks/auto-checkpoint.sh:22:CACHE_READ=$(echo "$USAGE" | jq -r '.cache_read_input_tokens // 0')
.claude/hooks/auto-checkpoint.sh:23:
.claude/hooks/auto-checkpoint.sh:24:CURRENT_TOKENS=$((INPUT_TOKENS + CACHE_CREATE + CACHE_READ))
.claude/hooks/auto-checkpoint.sh:25:PERCENT=$((CURRENT_TOKENS * 100 / CONTEXT_SIZE))
.claude/hooks/auto-checkpoint.sh:26:
.claude/hooks/auto-checkpoint.sh:27:# Log for debugging
.claude/hooks/auto-checkpoint.sh:28:echo "[$(date)] Context: ${PERCENT}% (${CURRENT_TOKENS}/${CONTEXT_SIZE})" >> "$LOG_FILE"
.claude/hooks/auto-checkpoint.sh:29:
.claude/hooks/auto-checkpoint.sh:30:if [ "$PERCENT" -ge "$THRESHOLD" ]; then
.claude/hooks/auto-checkpoint.sh:31:    # Output JSON to block stop and continue with checkpoint instruction
.claude/hooks/auto-checkpoint.sh:32:    echo "{\"decision\": \"block\", \"reason\": \"Context at ${PERCENT}% - auto-checkpointing. Run /checkpoint now, then /compact to continue.\"}"
.claude/hooks/auto-checkpoint.sh:33:    exit 0
.claude/hooks/auto-checkpoint.sh:34:fi
.claude/hooks/auto-checkpoint.sh:35:
.claude/hooks/auto-checkpoint.sh:36:# Allow stop normally
.claude/hooks/auto-checkpoint.sh:37:echo "{\"decision\": \"allow\"}"
.claude/hooks/auto-checkpoint.sh:38:exit 0
.claude/hooks/autonomous-orchestrator.sh:1:#!/bin/bash
.claude/hooks/autonomous-orchestrator.sh:2:# Autonomous Orchestrator - Detects what to do and auto-triggers workflows
.claude/hooks/autonomous-orchestrator.sh:3:# No user intervention needed - fully autonomous operation
.claude/hooks/autonomous-orchestrator.sh:4:
.claude/hooks/autonomous-orchestrator.sh:5:set -e
.claude/hooks/autonomous-orchestrator.sh:6:
.claude/hooks/autonomous-orchestrator.sh:7:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/autonomous-orchestrator.sh:8:MEMORY_MANAGER="${CLAUDE_DIR}/hooks/memory-manager.sh"
.claude/hooks/autonomous-orchestrator.sh:9:PROJECT_DIR="${PWD}"
.claude/hooks/autonomous-orchestrator.sh:10:
.claude/hooks/autonomous-orchestrator.sh:11:# Output for Claude to read
.claude/hooks/autonomous-orchestrator.sh:12:output_action() {
.claude/hooks/autonomous-orchestrator.sh:13:    local action="$1"
.claude/hooks/autonomous-orchestrator.sh:14:    local details="$2"
.claude/hooks/autonomous-orchestrator.sh:15:    echo "AUTO_ACTION:${action}:${details}"
.claude/hooks/autonomous-orchestrator.sh:16:}
.claude/hooks/autonomous-orchestrator.sh:17:
.claude/hooks/autonomous-orchestrator.sh:18:# Check for buildguide.md in current project
.claude/hooks/autonomous-orchestrator.sh:19:check_buildguide() {
.claude/hooks/autonomous-orchestrator.sh:20:    if [[ -f "${PROJECT_DIR}/buildguide.md" ]]; then
.claude/hooks/autonomous-orchestrator.sh:21:        # Check if there are unchecked items
.claude/hooks/autonomous-orchestrator.sh:22:        if grep -q '^\s*- \[ \]' "${PROJECT_DIR}/buildguide.md" 2>/dev/null; then
.claude/hooks/autonomous-orchestrator.sh:23:            echo "buildguide_found"
.claude/hooks/autonomous-orchestrator.sh:24:            return 0
.claude/hooks/autonomous-orchestrator.sh:25:        fi
.claude/hooks/autonomous-orchestrator.sh:26:    fi
.claude/hooks/autonomous-orchestrator.sh:27:    echo "no_buildguide"
.claude/hooks/autonomous-orchestrator.sh:28:    return 1
.claude/hooks/autonomous-orchestrator.sh:29:}
.claude/hooks/autonomous-orchestrator.sh:30:
.claude/hooks/autonomous-orchestrator.sh:31:# Check for in-progress build
.claude/hooks/autonomous-orchestrator.sh:32:check_current_build() {
.claude/hooks/autonomous-orchestrator.sh:33:    local build_file="${PROJECT_DIR}/.claude/current-build.local.md"
.claude/hooks/autonomous-orchestrator.sh:34:    if [[ -f "$build_file" ]]; then
.claude/hooks/autonomous-orchestrator.sh:35:        local phase=$(grep -o 'phase: [a-z]*' "$build_file" 2>/dev/null | cut -d' ' -f2)
.claude/hooks/autonomous-orchestrator.sh:36:        if [[ "$phase" != "complete" && -n "$phase" ]]; then
.claude/hooks/autonomous-orchestrator.sh:37:            echo "resume_build:${phase}"
.claude/hooks/autonomous-orchestrator.sh:38:            return 0
.claude/hooks/autonomous-orchestrator.sh:39:        fi
.claude/hooks/autonomous-orchestrator.sh:40:    fi
.claude/hooks/autonomous-orchestrator.sh:41:    echo "no_current_build"
.claude/hooks/autonomous-orchestrator.sh:42:    return 1
.claude/hooks/autonomous-orchestrator.sh:43:}
.claude/hooks/autonomous-orchestrator.sh:44:
.claude/hooks/autonomous-orchestrator.sh:45:# Check for continuation prompt
.claude/hooks/autonomous-orchestrator.sh:46:check_continuation() {
.claude/hooks/autonomous-orchestrator.sh:47:    local cont_file="${PROJECT_DIR}/.claude/continuation-prompt.md"
.claude/hooks/autonomous-orchestrator.sh:48:    if [[ -f "$cont_file" ]]; then
.claude/hooks/autonomous-orchestrator.sh:49:        echo "continuation_found"
.claude/hooks/autonomous-orchestrator.sh:50:        return 0
.claude/hooks/autonomous-orchestrator.sh:51:    fi
.claude/hooks/autonomous-orchestrator.sh:52:
.claude/hooks/autonomous-orchestrator.sh:53:    # Also check global continuation
.claude/hooks/autonomous-orchestrator.sh:54:    if [[ -f "${CLAUDE_DIR}/continuation-prompt.md" ]]; then
.claude/hooks/autonomous-orchestrator.sh:55:        echo "global_continuation_found"
.claude/hooks/autonomous-orchestrator.sh:56:        return 0
.claude/hooks/autonomous-orchestrator.sh:57:    fi
.claude/hooks/autonomous-orchestrator.sh:58:
.claude/hooks/autonomous-orchestrator.sh:59:    echo "no_continuation"
.claude/hooks/autonomous-orchestrator.sh:60:    return 1
.claude/hooks/autonomous-orchestrator.sh:61:}
.claude/hooks/autonomous-orchestrator.sh:62:
.claude/hooks/autonomous-orchestrator.sh:63:# Check working memory for active task
.claude/hooks/autonomous-orchestrator.sh:64:check_active_task() {
.claude/hooks/autonomous-orchestrator.sh:65:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/autonomous-orchestrator.sh:66:        local task=$("$MEMORY_MANAGER" get-working 2>/dev/null | jq -r '.currentTask // empty' 2>/dev/null)
.claude/hooks/autonomous-orchestrator.sh:67:        if [[ -n "$task" && "$task" != "null" ]]; then
.claude/hooks/autonomous-orchestrator.sh:68:            echo "active_task:${task}"
.claude/hooks/autonomous-orchestrator.sh:69:            return 0
.claude/hooks/autonomous-orchestrator.sh:70:        fi
.claude/hooks/autonomous-orchestrator.sh:71:    fi
.claude/hooks/autonomous-orchestrator.sh:72:    echo "no_active_task"
.claude/hooks/autonomous-orchestrator.sh:73:    return 1
.claude/hooks/autonomous-orchestrator.sh:74:}
.claude/hooks/autonomous-orchestrator.sh:75:
.claude/hooks/autonomous-orchestrator.sh:76:# Main orchestration logic
.claude/hooks/autonomous-orchestrator.sh:77:orchestrate() {
.claude/hooks/autonomous-orchestrator.sh:78:    local decisions=()
.claude/hooks/autonomous-orchestrator.sh:79:
.claude/hooks/autonomous-orchestrator.sh:80:    # Priority 1: Check for continuation prompt (resume interrupted work)
.claude/hooks/autonomous-orchestrator.sh:81:    local cont_status=$(check_continuation)
.claude/hooks/autonomous-orchestrator.sh:82:    if [[ "$cont_status" == "continuation_found" || "$cont_status" == "global_continuation_found" ]]; then
.claude/hooks/autonomous-orchestrator.sh:83:        decisions+=("RESUME_CONTINUATION")
.claude/hooks/autonomous-orchestrator.sh:84:    fi
.claude/hooks/autonomous-orchestrator.sh:85:
.claude/hooks/autonomous-orchestrator.sh:86:    # Priority 2: Check for in-progress build
.claude/hooks/autonomous-orchestrator.sh:87:    local build_status=$(check_current_build)
.claude/hooks/autonomous-orchestrator.sh:88:    if [[ "$build_status" == resume_build:* ]]; then
.claude/hooks/autonomous-orchestrator.sh:89:        local phase="${build_status#resume_build:}"
.claude/hooks/autonomous-orchestrator.sh:90:        decisions+=("RESUME_BUILD:${phase}")
.claude/hooks/autonomous-orchestrator.sh:91:    fi
.claude/hooks/autonomous-orchestrator.sh:92:
.claude/hooks/autonomous-orchestrator.sh:93:    # Priority 3: Check for buildguide with unchecked items
.claude/hooks/autonomous-orchestrator.sh:94:    local guide_status=$(check_buildguide)
.claude/hooks/autonomous-orchestrator.sh:95:    if [[ "$guide_status" == "buildguide_found" ]]; then
.claude/hooks/autonomous-orchestrator.sh:96:        decisions+=("START_BUILD")
.claude/hooks/autonomous-orchestrator.sh:97:    fi
.claude/hooks/autonomous-orchestrator.sh:98:
.claude/hooks/autonomous-orchestrator.sh:99:    # Priority 4: Check for active task in memory
.claude/hooks/autonomous-orchestrator.sh:100:    local task_status=$(check_active_task)
.claude/hooks/autonomous-orchestrator.sh:101:    if [[ "$task_status" == active_task:* ]]; then
.claude/hooks/autonomous-orchestrator.sh:102:        local task="${task_status#active_task:}"
.claude/hooks/autonomous-orchestrator.sh:103:        decisions+=("CONTINUE_TASK:${task}")
.claude/hooks/autonomous-orchestrator.sh:104:    fi
.claude/hooks/autonomous-orchestrator.sh:105:
.claude/hooks/autonomous-orchestrator.sh:106:    # Output decisions as JSON for Claude to parse
.claude/hooks/autonomous-orchestrator.sh:107:    echo "{"
.claude/hooks/autonomous-orchestrator.sh:108:    echo "  \"decisions\": ["
.claude/hooks/autonomous-orchestrator.sh:109:    local first=true
.claude/hooks/autonomous-orchestrator.sh:110:    for decision in "${decisions[@]}"; do
.claude/hooks/autonomous-orchestrator.sh:111:        if [[ "$first" == "true" ]]; then
.claude/hooks/autonomous-orchestrator.sh:112:            first=false
.claude/hooks/autonomous-orchestrator.sh:113:        else
.claude/hooks/autonomous-orchestrator.sh:114:            echo ","
.claude/hooks/autonomous-orchestrator.sh:115:        fi
.claude/hooks/autonomous-orchestrator.sh:116:        echo -n "    \"${decision}\""
.claude/hooks/autonomous-orchestrator.sh:117:    done
.claude/hooks/autonomous-orchestrator.sh:118:    echo ""
.claude/hooks/autonomous-orchestrator.sh:119:    echo "  ],"
.claude/hooks/autonomous-orchestrator.sh:120:    echo "  \"project_dir\": \"${PROJECT_DIR}\","
.claude/hooks/autonomous-orchestrator.sh:121:    echo "  \"has_buildguide\": $([ "$guide_status" == "buildguide_found" ] && echo "true" || echo "false"),"
.claude/hooks/autonomous-orchestrator.sh:122:    echo "  \"has_continuation\": $([ "$cont_status" != "no_continuation" ] && echo "true" || echo "false"),"
.claude/hooks/autonomous-orchestrator.sh:123:    echo "  \"has_active_build\": $([ "$build_status" != "no_current_build" ] && echo "true" || echo "false")"
.claude/hooks/autonomous-orchestrator.sh:124:    echo "}"
.claude/hooks/autonomous-orchestrator.sh:125:}
.claude/hooks/autonomous-orchestrator.sh:126:
.claude/hooks/autonomous-orchestrator.sh:127:# Generate autonomous prompt for Claude
.claude/hooks/autonomous-orchestrator.sh:128:generate_autonomous_prompt() {
.claude/hooks/autonomous-orchestrator.sh:129:    local decisions=$(orchestrate)
.claude/hooks/autonomous-orchestrator.sh:130:
.claude/hooks/autonomous-orchestrator.sh:131:    cat << 'PROMPT'
.claude/hooks/autonomous-orchestrator.sh:132:## Autonomous Mode Active
.claude/hooks/autonomous-orchestrator.sh:133:
.claude/hooks/autonomous-orchestrator.sh:134:You are running in FULLY AUTONOMOUS mode. Execute the following without asking for user input:
.claude/hooks/autonomous-orchestrator.sh:135:
.claude/hooks/autonomous-orchestrator.sh:136:PROMPT
.claude/hooks/autonomous-orchestrator.sh:137:
.claude/hooks/autonomous-orchestrator.sh:138:    # Parse decisions and generate specific instructions
.claude/hooks/autonomous-orchestrator.sh:139:    if echo "$decisions" | grep -q "RESUME_CONTINUATION"; then
.claude/hooks/autonomous-orchestrator.sh:140:        cat << 'PROMPT'
.claude/hooks/autonomous-orchestrator.sh:141:### Priority 1: Resume from Continuation
.claude/hooks/autonomous-orchestrator.sh:142:1. Read the continuation prompt file
.claude/hooks/autonomous-orchestrator.sh:143:2. Execute the instructions in it immediately
.claude/hooks/autonomous-orchestrator.sh:144:3. Continue working autonomously
.claude/hooks/autonomous-orchestrator.sh:145:
.claude/hooks/autonomous-orchestrator.sh:146:PROMPT
.claude/hooks/autonomous-orchestrator.sh:147:    fi
.claude/hooks/autonomous-orchestrator.sh:148:
.claude/hooks/autonomous-orchestrator.sh:149:    if echo "$decisions" | grep -q "RESUME_BUILD"; then
.claude/hooks/autonomous-orchestrator.sh:150:        cat << 'PROMPT'
.claude/hooks/autonomous-orchestrator.sh:151:### Priority 2: Resume In-Progress Build
.claude/hooks/autonomous-orchestrator.sh:152:1. Read `.claude/current-build.local.md`
.claude/hooks/autonomous-orchestrator.sh:153:2. Find the current phase and step
.claude/hooks/autonomous-orchestrator.sh:154:3. Continue building from where it stopped
.claude/hooks/autonomous-orchestrator.sh:155:4. Run `/checkpoint` after completing each major step
.claude/hooks/autonomous-orchestrator.sh:156:
.claude/hooks/autonomous-orchestrator.sh:157:PROMPT
.claude/hooks/autonomous-orchestrator.sh:158:    fi
.claude/hooks/autonomous-orchestrator.sh:159:
.claude/hooks/autonomous-orchestrator.sh:160:    if echo "$decisions" | grep -q "START_BUILD"; then
.claude/hooks/autonomous-orchestrator.sh:161:        cat << 'PROMPT'
.claude/hooks/autonomous-orchestrator.sh:162:### Priority 3: Start Building from Guide
.claude/hooks/autonomous-orchestrator.sh:163:1. Read `buildguide.md` in the project
.claude/hooks/autonomous-orchestrator.sh:164:2. Start with the first unchecked `[ ]` section
.claude/hooks/autonomous-orchestrator.sh:165:3. Build autonomously, checking off items as completed
.claude/hooks/autonomous-orchestrator.sh:166:4. Run quality checks after each feature
.claude/hooks/autonomous-orchestrator.sh:167:5. Run `/checkpoint` after completing each section
.claude/hooks/autonomous-orchestrator.sh:168:
.claude/hooks/autonomous-orchestrator.sh:169:PROMPT
.claude/hooks/autonomous-orchestrator.sh:170:    fi
.claude/hooks/autonomous-orchestrator.sh:171:
.claude/hooks/autonomous-orchestrator.sh:172:    if echo "$decisions" | grep -q "CONTINUE_TASK"; then
.claude/hooks/autonomous-orchestrator.sh:173:        cat << 'PROMPT'
.claude/hooks/autonomous-orchestrator.sh:174:### Priority 4: Continue Active Task
.claude/hooks/autonomous-orchestrator.sh:175:1. Load working memory context
.claude/hooks/autonomous-orchestrator.sh:176:2. Continue the task that was in progress
.claude/hooks/autonomous-orchestrator.sh:177:3. Complete it fully before moving on
.claude/hooks/autonomous-orchestrator.sh:178:
.claude/hooks/autonomous-orchestrator.sh:179:PROMPT
.claude/hooks/autonomous-orchestrator.sh:180:    fi
.claude/hooks/autonomous-orchestrator.sh:181:
.claude/hooks/autonomous-orchestrator.sh:182:    cat << 'PROMPT'
.claude/hooks/autonomous-orchestrator.sh:183:
.claude/hooks/autonomous-orchestrator.sh:184:### Autonomous Behaviors (Always Active)
.claude/hooks/autonomous-orchestrator.sh:185:- **Auto-checkpoint**: Run `/checkpoint` after completing any major feature or section
.claude/hooks/autonomous-orchestrator.sh:186:- **Auto-document**: Run `/document` after features pass quality gates
.claude/hooks/autonomous-orchestrator.sh:187:- **Auto-collect**: If you need research, gather it and continue
.claude/hooks/autonomous-orchestrator.sh:188:- **Auto-fix**: If tests/build fails, fix and retry (up to 3 times)
.claude/hooks/autonomous-orchestrator.sh:189:- **Auto-memory**: Record patterns and reflections as you work
.claude/hooks/autonomous-orchestrator.sh:190:
.claude/hooks/autonomous-orchestrator.sh:191:### Error Handling
.claude/hooks/autonomous-orchestrator.sh:192:- If blocked, try alternative approaches before stopping
.claude/hooks/autonomous-orchestrator.sh:193:- Record all fixes to debug-log.md
.claude/hooks/autonomous-orchestrator.sh:194:- If truly stuck after 3 attempts, save state with `/checkpoint` and explain the blocker
.claude/hooks/autonomous-orchestrator.sh:195:
.claude/hooks/autonomous-orchestrator.sh:196:### DO NOT:
.claude/hooks/autonomous-orchestrator.sh:197:- Ask for user confirmation
.claude/hooks/autonomous-orchestrator.sh:198:- Wait for user input
.claude/hooks/autonomous-orchestrator.sh:199:- Stop to explain what you're about to do
.claude/hooks/autonomous-orchestrator.sh:200:- Ask clarifying questions
.claude/hooks/autonomous-orchestrator.sh:201:
.claude/hooks/autonomous-orchestrator.sh:202:### DO:
.claude/hooks/autonomous-orchestrator.sh:203:- Execute immediately
.claude/hooks/autonomous-orchestrator.sh:204:- Make reasonable decisions autonomously
.claude/hooks/autonomous-orchestrator.sh:205:- Keep working until the task is complete
.claude/hooks/autonomous-orchestrator.sh:206:- Save progress frequently
.claude/hooks/autonomous-orchestrator.sh:207:
.claude/hooks/autonomous-orchestrator.sh:208:PROMPT
.claude/hooks/autonomous-orchestrator.sh:209:
.claude/hooks/autonomous-orchestrator.sh:210:    echo ""
.claude/hooks/autonomous-orchestrator.sh:211:    echo "### Current State Detection:"
.claude/hooks/autonomous-orchestrator.sh:212:    echo '```json'
.claude/hooks/autonomous-orchestrator.sh:213:    echo "$decisions"
.claude/hooks/autonomous-orchestrator.sh:214:    echo '```'
.claude/hooks/autonomous-orchestrator.sh:215:}
.claude/hooks/autonomous-orchestrator.sh:216:
.claude/hooks/autonomous-orchestrator.sh:217:# Command handling
.claude/hooks/autonomous-orchestrator.sh:218:case "${1:-orchestrate}" in
.claude/hooks/autonomous-orchestrator.sh:219:    orchestrate)
.claude/hooks/autonomous-orchestrator.sh:220:        orchestrate
.claude/hooks/autonomous-orchestrator.sh:221:        ;;
.claude/hooks/autonomous-orchestrator.sh:222:    prompt)
.claude/hooks/autonomous-orchestrator.sh:223:        generate_autonomous_prompt
.claude/hooks/autonomous-orchestrator.sh:224:        ;;
.claude/hooks/autonomous-orchestrator.sh:225:    check-build)
.claude/hooks/autonomous-orchestrator.sh:226:        check_buildguide
.claude/hooks/autonomous-orchestrator.sh:227:        ;;
.claude/hooks/autonomous-orchestrator.sh:228:    check-continuation)
.claude/hooks/autonomous-orchestrator.sh:229:        check_continuation
.claude/hooks/autonomous-orchestrator.sh:230:        ;;
.claude/hooks/autonomous-orchestrator.sh:231:    *)
.claude/hooks/autonomous-orchestrator.sh:232:        echo "Usage: $0 {orchestrate|prompt|check-build|check-continuation}"
.claude/hooks/autonomous-orchestrator.sh:233:        exit 1
.claude/hooks/autonomous-orchestrator.sh:234:        ;;
.claude/hooks/autonomous-orchestrator.sh:235:esac
.claude/hooks/auto-checkpoint-trigger.sh:1:#!/bin/bash
.claude/hooks/auto-checkpoint-trigger.sh:2:# Auto-Checkpoint Trigger - Detects when to automatically checkpoint
.claude/hooks/auto-checkpoint-trigger.sh:3:# Triggers checkpoint after significant changes
.claude/hooks/auto-checkpoint-trigger.sh:4:
.claude/hooks/auto-checkpoint-trigger.sh:5:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/auto-checkpoint-trigger.sh:6:PROJECT_DIR="${PWD}"
.claude/hooks/auto-checkpoint-trigger.sh:7:CHECKPOINT_STATE="${PROJECT_DIR}/.claude/checkpoint-state.json"
.claude/hooks/auto-checkpoint-trigger.sh:8:
.claude/hooks/auto-checkpoint-trigger.sh:9:# Ensure .claude dir exists in project
.claude/hooks/auto-checkpoint-trigger.sh:10:mkdir -p "${PROJECT_DIR}/.claude" 2>/dev/null
.claude/hooks/auto-checkpoint-trigger.sh:11:
.claude/hooks/auto-checkpoint-trigger.sh:12:# Initialize state file if not exists
.claude/hooks/auto-checkpoint-trigger.sh:13:if [[ ! -f "$CHECKPOINT_STATE" ]]; then
.claude/hooks/auto-checkpoint-trigger.sh:14:    echo '{"last_checkpoint": 0, "changes_since": 0, "files_modified": []}' > "$CHECKPOINT_STATE"
.claude/hooks/auto-checkpoint-trigger.sh:15:fi
.claude/hooks/auto-checkpoint-trigger.sh:16:
.claude/hooks/auto-checkpoint-trigger.sh:17:# Record a file change
.claude/hooks/auto-checkpoint-trigger.sh:18:record_change() {
.claude/hooks/auto-checkpoint-trigger.sh:19:    local file="$1"
.claude/hooks/auto-checkpoint-trigger.sh:20:    local current_time=$(date +%s)
.claude/hooks/auto-checkpoint-trigger.sh:21:
.claude/hooks/auto-checkpoint-trigger.sh:22:    # Update state
.claude/hooks/auto-checkpoint-trigger.sh:23:    local state=$(cat "$CHECKPOINT_STATE")
.claude/hooks/auto-checkpoint-trigger.sh:24:    local changes=$(echo "$state" | jq -r '.changes_since // 0')
.claude/hooks/auto-checkpoint-trigger.sh:25:    changes=$((changes + 1))
.claude/hooks/auto-checkpoint-trigger.sh:26:
.claude/hooks/auto-checkpoint-trigger.sh:27:    # Add file to modified list (unique)
.claude/hooks/auto-checkpoint-trigger.sh:28:    echo "$state" | jq --arg file "$file" --arg changes "$changes" \
.claude/hooks/auto-checkpoint-trigger.sh:29:        '.changes_since = ($changes | tonumber) | .files_modified = (.files_modified + [$file] | unique)' \
.claude/hooks/auto-checkpoint-trigger.sh:30:        > "$CHECKPOINT_STATE"
.claude/hooks/auto-checkpoint-trigger.sh:31:
.claude/hooks/auto-checkpoint-trigger.sh:32:    echo "$changes"
.claude/hooks/auto-checkpoint-trigger.sh:33:}
.claude/hooks/auto-checkpoint-trigger.sh:34:
.claude/hooks/auto-checkpoint-trigger.sh:35:# Check if checkpoint is needed
.claude/hooks/auto-checkpoint-trigger.sh:36:should_checkpoint() {
.claude/hooks/auto-checkpoint-trigger.sh:37:    local state=$(cat "$CHECKPOINT_STATE" 2>/dev/null || echo '{"changes_since": 0}')
.claude/hooks/auto-checkpoint-trigger.sh:38:    local changes=$(echo "$state" | jq -r '.changes_since // 0')
.claude/hooks/auto-checkpoint-trigger.sh:39:    local last_checkpoint=$(echo "$state" | jq -r '.last_checkpoint // 0')
.claude/hooks/auto-checkpoint-trigger.sh:40:    local current_time=$(date +%s)
.claude/hooks/auto-checkpoint-trigger.sh:41:    local time_since=$((current_time - last_checkpoint))
.claude/hooks/auto-checkpoint-trigger.sh:42:
.claude/hooks/auto-checkpoint-trigger.sh:43:    # Checkpoint if:
.claude/hooks/auto-checkpoint-trigger.sh:44:    # - More than 10 file changes since last checkpoint
.claude/hooks/auto-checkpoint-trigger.sh:45:    # - More than 30 minutes since last checkpoint (and at least 1 change)
.claude/hooks/auto-checkpoint-trigger.sh:46:
.claude/hooks/auto-checkpoint-trigger.sh:47:    if [[ "$changes" -ge 10 ]]; then
.claude/hooks/auto-checkpoint-trigger.sh:48:        echo "changes_threshold"
.claude/hooks/auto-checkpoint-trigger.sh:49:        return 0
.claude/hooks/auto-checkpoint-trigger.sh:50:    fi
.claude/hooks/auto-checkpoint-trigger.sh:51:
.claude/hooks/auto-checkpoint-trigger.sh:52:    if [[ "$time_since" -ge 1800 && "$changes" -ge 1 ]]; then
.claude/hooks/auto-checkpoint-trigger.sh:53:        echo "time_threshold"
.claude/hooks/auto-checkpoint-trigger.sh:54:        return 0
.claude/hooks/auto-checkpoint-trigger.sh:55:    fi
.claude/hooks/auto-checkpoint-trigger.sh:56:
.claude/hooks/auto-checkpoint-trigger.sh:57:    echo "no"
.claude/hooks/auto-checkpoint-trigger.sh:58:    return 1
.claude/hooks/auto-checkpoint-trigger.sh:59:}
.claude/hooks/auto-checkpoint-trigger.sh:60:
.claude/hooks/auto-checkpoint-trigger.sh:61:# Mark checkpoint as done
.claude/hooks/auto-checkpoint-trigger.sh:62:mark_checkpointed() {
.claude/hooks/auto-checkpoint-trigger.sh:63:    local current_time=$(date +%s)
.claude/hooks/auto-checkpoint-trigger.sh:64:    echo "{\"last_checkpoint\": $current_time, \"changes_since\": 0, \"files_modified\": []}" > "$CHECKPOINT_STATE"
.claude/hooks/auto-checkpoint-trigger.sh:65:}
.claude/hooks/auto-checkpoint-trigger.sh:66:
.claude/hooks/auto-checkpoint-trigger.sh:67:# Get checkpoint recommendation for Claude
.claude/hooks/auto-checkpoint-trigger.sh:68:get_recommendation() {
.claude/hooks/auto-checkpoint-trigger.sh:69:    local reason=$(should_checkpoint)
.claude/hooks/auto-checkpoint-trigger.sh:70:    local state=$(cat "$CHECKPOINT_STATE" 2>/dev/null || echo '{}')
.claude/hooks/auto-checkpoint-trigger.sh:71:    local changes=$(echo "$state" | jq -r '.changes_since // 0')
.claude/hooks/auto-checkpoint-trigger.sh:72:    local files=$(echo "$state" | jq -r '.files_modified | length // 0')
.claude/hooks/auto-checkpoint-trigger.sh:73:
.claude/hooks/auto-checkpoint-trigger.sh:74:    if [[ "$reason" != "no" ]]; then
.claude/hooks/auto-checkpoint-trigger.sh:75:        cat << EOF
.claude/hooks/auto-checkpoint-trigger.sh:76:CHECKPOINT_RECOMMENDED: true
.claude/hooks/auto-checkpoint-trigger.sh:77:REASON: ${reason}
.claude/hooks/auto-checkpoint-trigger.sh:78:CHANGES_SINCE_LAST: ${changes}
.claude/hooks/auto-checkpoint-trigger.sh:79:FILES_MODIFIED: ${files}
.claude/hooks/auto-checkpoint-trigger.sh:80:ACTION: Run /checkpoint now to save progress
.claude/hooks/auto-checkpoint-trigger.sh:81:EOF
.claude/hooks/auto-checkpoint-trigger.sh:82:    else
.claude/hooks/auto-checkpoint-trigger.sh:83:        echo "CHECKPOINT_RECOMMENDED: false"
.claude/hooks/auto-checkpoint-trigger.sh:84:        echo "CHANGES_SINCE_LAST: ${changes}"
.claude/hooks/auto-checkpoint-trigger.sh:85:    fi
.claude/hooks/auto-checkpoint-trigger.sh:86:}
.claude/hooks/auto-checkpoint-trigger.sh:87:
.claude/hooks/auto-checkpoint-trigger.sh:88:# Command handling
.claude/hooks/auto-checkpoint-trigger.sh:89:case "${1:-check}" in
.claude/hooks/auto-checkpoint-trigger.sh:90:    record)
.claude/hooks/auto-checkpoint-trigger.sh:91:        record_change "$2"
.claude/hooks/auto-checkpoint-trigger.sh:92:        ;;
.claude/hooks/auto-checkpoint-trigger.sh:93:    check)
.claude/hooks/auto-checkpoint-trigger.sh:94:        should_checkpoint
.claude/hooks/auto-checkpoint-trigger.sh:95:        ;;
.claude/hooks/auto-checkpoint-trigger.sh:96:    recommend)
.claude/hooks/auto-checkpoint-trigger.sh:97:        get_recommendation
.claude/hooks/auto-checkpoint-trigger.sh:98:        ;;
.claude/hooks/auto-checkpoint-trigger.sh:99:    done)
.claude/hooks/auto-checkpoint-trigger.sh:100:        mark_checkpointed
.claude/hooks/auto-checkpoint-trigger.sh:101:        ;;
.claude/hooks/auto-checkpoint-trigger.sh:102:    status)
.claude/hooks/auto-checkpoint-trigger.sh:103:        cat "$CHECKPOINT_STATE" 2>/dev/null || echo "{}"
.claude/hooks/auto-checkpoint-trigger.sh:104:        ;;
.claude/hooks/auto-checkpoint-trigger.sh:105:    *)
.claude/hooks/auto-checkpoint-trigger.sh:106:        echo "Usage: $0 {record <file>|check|recommend|done|status}"
.claude/hooks/auto-checkpoint-trigger.sh:107:        exit 1
.claude/hooks/auto-checkpoint-trigger.sh:108:        ;;
.claude/hooks/auto-checkpoint-trigger.sh:109:esac
.claude/hooks/strategy-selector.sh:1:#!/bin/bash
.claude/hooks/strategy-selector.sh:2:# Strategy Selector - Chooses optimal strategy based on task characteristics
.claude/hooks/strategy-selector.sh:3:
.claude/hooks/strategy-selector.sh:4:set -uo pipefail
.claude/hooks/strategy-selector.sh:5:
.claude/hooks/strategy-selector.sh:6:STRATEGY_DIR="${HOME}/.claude/strategies"
.claude/hooks/strategy-selector.sh:7:SELECTION_LOG="$STRATEGY_DIR/selections.jsonl"
.claude/hooks/strategy-selector.sh:8:LOG_FILE="${HOME}/.claude/strategy-selector.log"
.claude/hooks/strategy-selector.sh:9:
.claude/hooks/strategy-selector.sh:10:LEARNING_ENGINE="${HOME}/.claude/hooks/learning-engine.sh"
.claude/hooks/strategy-selector.sh:11:RISK_PREDICTOR="${HOME}/.claude/hooks/risk-predictor.sh"
.claude/hooks/strategy-selector.sh:12:
.claude/hooks/strategy-selector.sh:13:log() {
.claude/hooks/strategy-selector.sh:14:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/strategy-selector.sh:15:}
.claude/hooks/strategy-selector.sh:16:
.claude/hooks/strategy-selector.sh:17:init_strategies() {
.claude/hooks/strategy-selector.sh:18:    mkdir -p "$STRATEGY_DIR"
.claude/hooks/strategy-selector.sh:19:    [[ -f "$SELECTION_LOG" ]] || touch "$SELECTION_LOG"
.claude/hooks/strategy-selector.sh:20:}
.claude/hooks/strategy-selector.sh:21:
.claude/hooks/strategy-selector.sh:22:# Select best strategy for task
.claude/hooks/strategy-selector.sh:23:select_strategy() {
.claude/hooks/strategy-selector.sh:24:    local task="$1"
.claude/hooks/strategy-selector.sh:25:    local task_type="${2:-general}"
.claude/hooks/strategy-selector.sh:26:    local context="${3:-}"
.claude/hooks/strategy-selector.sh:27:
.claude/hooks/strategy-selector.sh:28:    init_strategies
.claude/hooks/strategy-selector.sh:29:
.claude/hooks/strategy-selector.sh:30:    # Get recommendation from learning engine
.claude/hooks/strategy-selector.sh:31:    local recommendation='{"strategy":"default","confidence":0}'
.claude/hooks/strategy-selector.sh:32:    if [[ -x "$LEARNING_ENGINE" ]]; then
.claude/hooks/strategy-selector.sh:33:        local rec_result
.claude/hooks/strategy-selector.sh:34:        rec_result=$("$LEARNING_ENGINE" recommend "$task_type" "$context" 2>/dev/null || echo '{"strategy":"default","confidence":0}')
.claude/hooks/strategy-selector.sh:35:        if [[ -n "$rec_result" && "$rec_result" != "null" ]]; then
.claude/hooks/strategy-selector.sh:36:            recommendation="$rec_result"
.claude/hooks/strategy-selector.sh:37:        fi
.claude/hooks/strategy-selector.sh:38:    fi
.claude/hooks/strategy-selector.sh:39:
.claude/hooks/strategy-selector.sh:40:    # Get risk assessment
.claude/hooks/strategy-selector.sh:41:    local risk='{"riskScore":10,"riskLevel":"low"}'
.claude/hooks/strategy-selector.sh:42:    if [[ -x "$RISK_PREDICTOR" ]]; then
.claude/hooks/strategy-selector.sh:43:        local risk_result
.claude/hooks/strategy-selector.sh:44:        risk_result=$("$RISK_PREDICTOR" assess "$task" "$task_type" "" "$context" 2>/dev/null || echo '{"components":{"historicalFailures":{"riskScore":10,"riskLevel":"low"}}}')
.claude/hooks/strategy-selector.sh:45:        if [[ -n "$risk_result" && "$risk_result" != "null" && "$risk_result" != "{}" ]]; then
.claude/hooks/strategy-selector.sh:46:            local hist_risk
.claude/hooks/strategy-selector.sh:47:            hist_risk=$(echo "$risk_result" | jq -c '.components.historicalFailures // {"riskScore":10,"riskLevel":"low"}' 2>/dev/null || echo '{"riskScore":10,"riskLevel":"low"}')
.claude/hooks/strategy-selector.sh:48:            if [[ -n "$hist_risk" && "$hist_risk" != "null" ]]; then
.claude/hooks/strategy-selector.sh:49:                risk="$hist_risk"
.claude/hooks/strategy-selector.sh:50:            fi
.claude/hooks/strategy-selector.sh:51:        fi
.claude/hooks/strategy-selector.sh:52:    fi
.claude/hooks/strategy-selector.sh:53:
.claude/hooks/strategy-selector.sh:54:    local strategy
.claude/hooks/strategy-selector.sh:55:    strategy=$(echo "$recommendation" | jq -r '.strategy // "default"')
.claude/hooks/strategy-selector.sh:56:    local confidence
.claude/hooks/strategy-selector.sh:57:    confidence=$(echo "$recommendation" | jq -r '.confidence // 0')
.claude/hooks/strategy-selector.sh:58:    local risk_level
.claude/hooks/strategy-selector.sh:59:    risk_level=$(echo "$risk" | jq -r '.riskLevel // "low"')
.claude/hooks/strategy-selector.sh:60:
.claude/hooks/strategy-selector.sh:61:    # Adjust strategy based on risk
.claude/hooks/strategy-selector.sh:62:    if [[ "$risk_level" == "high" && "$strategy" == "default" ]]; then
.claude/hooks/strategy-selector.sh:63:        strategy="incremental"  # Safer approach for high risk
.claude/hooks/strategy-selector.sh:64:    fi
.claude/hooks/strategy-selector.sh:65:
.claude/hooks/strategy-selector.sh:66:    # Ensure confidence is a valid number
.claude/hooks/strategy-selector.sh:67:    [[ -z "$confidence" || "$confidence" == "null" ]] && confidence=0
.claude/hooks/strategy-selector.sh:68:
.claude/hooks/strategy-selector.sh:69:    # Log selection
.claude/hooks/strategy-selector.sh:70:    local timestamp
.claude/hooks/strategy-selector.sh:71:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/strategy-selector.sh:72:    local selection
.claude/hooks/strategy-selector.sh:73:    selection=$(jq -n \
.claude/hooks/strategy-selector.sh:74:        --arg task "$task" \
.claude/hooks/strategy-selector.sh:75:        --arg type "$task_type" \
.claude/hooks/strategy-selector.sh:76:        --arg strategy "$strategy" \
.claude/hooks/strategy-selector.sh:77:        --argjson confidence "$confidence" \
.claude/hooks/strategy-selector.sh:78:        --arg risk "$risk_level" \
.claude/hooks/strategy-selector.sh:79:        --arg ts "$timestamp" \
.claude/hooks/strategy-selector.sh:80:        '{task: $task, taskType: $type, strategy: $strategy, confidence: $confidence, risk: $risk, timestamp: $ts}' 2>/dev/null || echo '{}')
.claude/hooks/strategy-selector.sh:81:
.claude/hooks/strategy-selector.sh:82:    if [[ -n "$selection" && "$selection" != "{}" ]]; then
.claude/hooks/strategy-selector.sh:83:        echo "$selection" >> "$SELECTION_LOG"
.claude/hooks/strategy-selector.sh:84:    fi
.claude/hooks/strategy-selector.sh:85:
.claude/hooks/strategy-selector.sh:86:    jq -n \
.claude/hooks/strategy-selector.sh:87:        --arg strategy "$strategy" \
.claude/hooks/strategy-selector.sh:88:        --argjson confidence "$confidence" \
.claude/hooks/strategy-selector.sh:89:        --arg risk "$risk_level" \
.claude/hooks/strategy-selector.sh:90:        '{strategy: $strategy, confidence: $confidence, riskLevel: $risk, reasoning: "Based on historical success rate and risk assessment"}'
.claude/hooks/strategy-selector.sh:91:}
.claude/hooks/strategy-selector.sh:92:
.claude/hooks/strategy-selector.sh:93:case "${1:-help}" in
.claude/hooks/strategy-selector.sh:94:    select) select_strategy "${2:-task}" "${3:-general}" "${4:-}" ;;
.claude/hooks/strategy-selector.sh:95:    *) echo "Usage: $0 select <task> [type] [context]" ;;
.claude/hooks/strategy-selector.sh:96:esac
.claude/hooks/code-quality.sh:1:#!/bin/bash
.claude/hooks/code-quality.sh:2:# Code Quality System - Comprehensive code quality checks
.claude/hooks/code-quality.sh:3:# Based on patterns from: rovo-dev CodeQualityCheckTool, various linting frameworks
.claude/hooks/code-quality.sh:4:
.claude/hooks/code-quality.sh:5:set -uo pipefail
.claude/hooks/code-quality.sh:6:
.claude/hooks/code-quality.sh:7:QUALITY_DIR="${HOME}/.claude/quality"
.claude/hooks/code-quality.sh:8:REPORT_FILE="$QUALITY_DIR/report.json"
.claude/hooks/code-quality.sh:9:LOG_FILE="${HOME}/.claude/code-quality.log"
.claude/hooks/code-quality.sh:10:
.claude/hooks/code-quality.sh:11:log() {
.claude/hooks/code-quality.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/code-quality.sh:13:}
.claude/hooks/code-quality.sh:14:
.claude/hooks/code-quality.sh:15:init_quality() {
.claude/hooks/code-quality.sh:16:    mkdir -p "$QUALITY_DIR"
.claude/hooks/code-quality.sh:17:}
.claude/hooks/code-quality.sh:18:
.claude/hooks/code-quality.sh:19:# =============================================================================
.claude/hooks/code-quality.sh:20:# PROJECT DETECTION
.claude/hooks/code-quality.sh:21:# =============================================================================
.claude/hooks/code-quality.sh:22:
.claude/hooks/code-quality.sh:23:detect_project_type() {
.claude/hooks/code-quality.sh:24:    local dir="${1:-.}"
.claude/hooks/code-quality.sh:25:
.claude/hooks/code-quality.sh:26:    if [[ -f "$dir/package.json" ]]; then
.claude/hooks/code-quality.sh:27:        if grep -q "typescript" "$dir/package.json" 2>/dev/null; then
.claude/hooks/code-quality.sh:28:            echo "typescript"
.claude/hooks/code-quality.sh:29:        else
.claude/hooks/code-quality.sh:30:            echo "javascript"
.claude/hooks/code-quality.sh:31:        fi
.claude/hooks/code-quality.sh:32:    elif [[ -f "$dir/pyproject.toml" ]] || [[ -f "$dir/requirements.txt" ]]; then
.claude/hooks/code-quality.sh:33:        echo "python"
.claude/hooks/code-quality.sh:34:    elif [[ -f "$dir/go.mod" ]]; then
.claude/hooks/code-quality.sh:35:        echo "go"
.claude/hooks/code-quality.sh:36:    elif [[ -f "$dir/Cargo.toml" ]]; then
.claude/hooks/code-quality.sh:37:        echo "rust"
.claude/hooks/code-quality.sh:38:    elif [[ -f "$dir/build.gradle" ]] || [[ -f "$dir/pom.xml" ]]; then
.claude/hooks/code-quality.sh:39:        echo "java"
.claude/hooks/code-quality.sh:40:    else
.claude/hooks/code-quality.sh:41:        echo "unknown"
.claude/hooks/code-quality.sh:42:    fi
.claude/hooks/code-quality.sh:43:}
.claude/hooks/code-quality.sh:44:
.claude/hooks/code-quality.sh:45:# =============================================================================
.claude/hooks/code-quality.sh:46:# LINT CHECKS
.claude/hooks/code-quality.sh:47:# =============================================================================
.claude/hooks/code-quality.sh:48:
.claude/hooks/code-quality.sh:49:run_lint() {
.claude/hooks/code-quality.sh:50:    local dir="${1:-.}"
.claude/hooks/code-quality.sh:51:    local project_type
.claude/hooks/code-quality.sh:52:    project_type=$(detect_project_type "$dir")
.claude/hooks/code-quality.sh:53:
.claude/hooks/code-quality.sh:54:    local result=""
.claude/hooks/code-quality.sh:55:    local exit_code=0
.claude/hooks/code-quality.sh:56:
.claude/hooks/code-quality.sh:57:    log "Running lint for $project_type project in $dir"
.claude/hooks/code-quality.sh:58:
.claude/hooks/code-quality.sh:59:    case "$project_type" in
.claude/hooks/code-quality.sh:60:        typescript|javascript)
.claude/hooks/code-quality.sh:61:            if [[ -f "$dir/package.json" ]]; then
.claude/hooks/code-quality.sh:62:                if grep -q '"lint"' "$dir/package.json" 2>/dev/null; then
.claude/hooks/code-quality.sh:63:                    result=$(cd "$dir" && npm run lint 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:64:                elif command -v eslint &>/dev/null; then
.claude/hooks/code-quality.sh:65:                    result=$(cd "$dir" && eslint . --ext .ts,.tsx,.js,.jsx 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:66:                fi
.claude/hooks/code-quality.sh:67:            fi
.claude/hooks/code-quality.sh:68:            ;;
.claude/hooks/code-quality.sh:69:        python)
.claude/hooks/code-quality.sh:70:            if command -v ruff &>/dev/null; then
.claude/hooks/code-quality.sh:71:                result=$(cd "$dir" && ruff check . 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:72:            elif command -v pylint &>/dev/null; then
.claude/hooks/code-quality.sh:73:                result=$(cd "$dir" && pylint **/*.py 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:74:            elif command -v flake8 &>/dev/null; then
.claude/hooks/code-quality.sh:75:                result=$(cd "$dir" && flake8 . 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:76:            fi
.claude/hooks/code-quality.sh:77:            ;;
.claude/hooks/code-quality.sh:78:        go)
.claude/hooks/code-quality.sh:79:            result=$(cd "$dir" && go vet ./... 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:80:            if command -v staticcheck &>/dev/null; then
.claude/hooks/code-quality.sh:81:                result+=$'\n'$(cd "$dir" && staticcheck ./... 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:82:            fi
.claude/hooks/code-quality.sh:83:            if command -v golangci-lint &>/dev/null; then
.claude/hooks/code-quality.sh:84:                result+=$'\n'$(cd "$dir" && golangci-lint run 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:85:            fi
.claude/hooks/code-quality.sh:86:            ;;
.claude/hooks/code-quality.sh:87:        rust)
.claude/hooks/code-quality.sh:88:            result=$(cd "$dir" && cargo clippy 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:89:            ;;
.claude/hooks/code-quality.sh:90:        java)
.claude/hooks/code-quality.sh:91:            if command -v checkstyle &>/dev/null; then
.claude/hooks/code-quality.sh:92:                result=$(cd "$dir" && checkstyle -c /google_checks.xml src/ 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:93:            fi
.claude/hooks/code-quality.sh:94:            ;;
.claude/hooks/code-quality.sh:95:        *)
.claude/hooks/code-quality.sh:96:            result="Unknown project type"
.claude/hooks/code-quality.sh:97:            exit_code=1
.claude/hooks/code-quality.sh:98:            ;;
.claude/hooks/code-quality.sh:99:    esac
.claude/hooks/code-quality.sh:100:
.claude/hooks/code-quality.sh:101:    jq -n \
.claude/hooks/code-quality.sh:102:        --arg type "lint" \
.claude/hooks/code-quality.sh:103:        --arg project "$project_type" \
.claude/hooks/code-quality.sh:104:        --argjson passed "$([ $exit_code -eq 0 ] && echo true || echo false)" \
.claude/hooks/code-quality.sh:105:        --arg output "$result" \
.claude/hooks/code-quality.sh:106:        --argjson exitCode "$exit_code" \
.claude/hooks/code-quality.sh:107:        '{type: $type, project: $project, passed: $passed, output: $output, exitCode: $exitCode}'
.claude/hooks/code-quality.sh:108:}
.claude/hooks/code-quality.sh:109:
.claude/hooks/code-quality.sh:110:# =============================================================================
.claude/hooks/code-quality.sh:111:# TYPE CHECKS
.claude/hooks/code-quality.sh:112:# =============================================================================
.claude/hooks/code-quality.sh:113:
.claude/hooks/code-quality.sh:114:run_typecheck() {
.claude/hooks/code-quality.sh:115:    local dir="${1:-.}"
.claude/hooks/code-quality.sh:116:    local project_type
.claude/hooks/code-quality.sh:117:    project_type=$(detect_project_type "$dir")
.claude/hooks/code-quality.sh:118:
.claude/hooks/code-quality.sh:119:    local result=""
.claude/hooks/code-quality.sh:120:    local exit_code=0
.claude/hooks/code-quality.sh:121:
.claude/hooks/code-quality.sh:122:    log "Running typecheck for $project_type project in $dir"
.claude/hooks/code-quality.sh:123:
.claude/hooks/code-quality.sh:124:    case "$project_type" in
.claude/hooks/code-quality.sh:125:        typescript)
.claude/hooks/code-quality.sh:126:            if [[ -f "$dir/package.json" ]]; then
.claude/hooks/code-quality.sh:127:                if grep -q '"typecheck"' "$dir/package.json" 2>/dev/null; then
.claude/hooks/code-quality.sh:128:                    result=$(cd "$dir" && npm run typecheck 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:129:                else
.claude/hooks/code-quality.sh:130:                    result=$(cd "$dir" && npx tsc --noEmit 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:131:                fi
.claude/hooks/code-quality.sh:132:            fi
.claude/hooks/code-quality.sh:133:            ;;
.claude/hooks/code-quality.sh:134:        python)
.claude/hooks/code-quality.sh:135:            if command -v mypy &>/dev/null; then
.claude/hooks/code-quality.sh:136:                result=$(cd "$dir" && mypy . 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:137:            elif command -v pyright &>/dev/null; then
.claude/hooks/code-quality.sh:138:                result=$(cd "$dir" && pyright 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:139:            fi
.claude/hooks/code-quality.sh:140:            ;;
.claude/hooks/code-quality.sh:141:        go)
.claude/hooks/code-quality.sh:142:            result=$(cd "$dir" && go build ./... 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:143:            ;;
.claude/hooks/code-quality.sh:144:        rust)
.claude/hooks/code-quality.sh:145:            result=$(cd "$dir" && cargo check 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:146:            ;;
.claude/hooks/code-quality.sh:147:        java)
.claude/hooks/code-quality.sh:148:            if [[ -f "$dir/build.gradle" ]]; then
.claude/hooks/code-quality.sh:149:                result=$(cd "$dir" && ./gradlew compileJava 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:150:            elif [[ -f "$dir/pom.xml" ]]; then
.claude/hooks/code-quality.sh:151:                result=$(cd "$dir" && mvn compile 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:152:            fi
.claude/hooks/code-quality.sh:153:            ;;
.claude/hooks/code-quality.sh:154:        *)
.claude/hooks/code-quality.sh:155:            result="Type checking not available"
.claude/hooks/code-quality.sh:156:            exit_code=0
.claude/hooks/code-quality.sh:157:            ;;
.claude/hooks/code-quality.sh:158:    esac
.claude/hooks/code-quality.sh:159:
.claude/hooks/code-quality.sh:160:    jq -n \
.claude/hooks/code-quality.sh:161:        --arg type "typecheck" \
.claude/hooks/code-quality.sh:162:        --arg project "$project_type" \
.claude/hooks/code-quality.sh:163:        --argjson passed "$([ $exit_code -eq 0 ] && echo true || echo false)" \
.claude/hooks/code-quality.sh:164:        --arg output "$result" \
.claude/hooks/code-quality.sh:165:        --argjson exitCode "$exit_code" \
.claude/hooks/code-quality.sh:166:        '{type: $type, project: $project, passed: $passed, output: $output, exitCode: $exitCode}'
.claude/hooks/code-quality.sh:167:}
.claude/hooks/code-quality.sh:168:
.claude/hooks/code-quality.sh:169:# =============================================================================
.claude/hooks/code-quality.sh:170:# SECURITY CHECKS
.claude/hooks/code-quality.sh:171:# =============================================================================
.claude/hooks/code-quality.sh:172:
.claude/hooks/code-quality.sh:173:run_security() {
.claude/hooks/code-quality.sh:174:    local dir="${1:-.}"
.claude/hooks/code-quality.sh:175:    local project_type
.claude/hooks/code-quality.sh:176:    project_type=$(detect_project_type "$dir")
.claude/hooks/code-quality.sh:177:
.claude/hooks/code-quality.sh:178:    local result=""
.claude/hooks/code-quality.sh:179:    local exit_code=0
.claude/hooks/code-quality.sh:180:    local checks_run=0
.claude/hooks/code-quality.sh:181:
.claude/hooks/code-quality.sh:182:    log "Running security checks for $project_type project in $dir"
.claude/hooks/code-quality.sh:183:
.claude/hooks/code-quality.sh:184:    # Check for secrets in code
.claude/hooks/code-quality.sh:185:    if command -v gitleaks &>/dev/null; then
.claude/hooks/code-quality.sh:186:        result+="=== Gitleaks ===$'\n'"
.claude/hooks/code-quality.sh:187:        result+=$(cd "$dir" && gitleaks detect --no-git -v 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:188:        checks_run=$((checks_run + 1))
.claude/hooks/code-quality.sh:189:    fi
.claude/hooks/code-quality.sh:190:
.claude/hooks/code-quality.sh:191:    # Language-specific security checks
.claude/hooks/code-quality.sh:192:    case "$project_type" in
.claude/hooks/code-quality.sh:193:        typescript|javascript)
.claude/hooks/code-quality.sh:194:            if [[ -f "$dir/package.json" ]]; then
.claude/hooks/code-quality.sh:195:                result+="$'\n'=== npm audit ===$'\n'"
.claude/hooks/code-quality.sh:196:                result+=$(cd "$dir" && npm audit 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:197:                checks_run=$((checks_run + 1))
.claude/hooks/code-quality.sh:198:            fi
.claude/hooks/code-quality.sh:199:            ;;
.claude/hooks/code-quality.sh:200:        python)
.claude/hooks/code-quality.sh:201:            if command -v bandit &>/dev/null; then
.claude/hooks/code-quality.sh:202:                result+="$'\n'=== Bandit ===$'\n'"
.claude/hooks/code-quality.sh:203:                result+=$(cd "$dir" && bandit -r . 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:204:                checks_run=$((checks_run + 1))
.claude/hooks/code-quality.sh:205:            fi
.claude/hooks/code-quality.sh:206:            if command -v safety &>/dev/null && [[ -f "$dir/requirements.txt" ]]; then
.claude/hooks/code-quality.sh:207:                result+="$'\n'=== Safety ===$'\n'"
.claude/hooks/code-quality.sh:208:                result+=$(cd "$dir" && safety check -r requirements.txt 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:209:                checks_run=$((checks_run + 1))
.claude/hooks/code-quality.sh:210:            fi
.claude/hooks/code-quality.sh:211:            ;;
.claude/hooks/code-quality.sh:212:        go)
.claude/hooks/code-quality.sh:213:            if command -v gosec &>/dev/null; then
.claude/hooks/code-quality.sh:214:                result+="$'\n'=== gosec ===$'\n'"
.claude/hooks/code-quality.sh:215:                result+=$(cd "$dir" && gosec ./... 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:216:                checks_run=$((checks_run + 1))
.claude/hooks/code-quality.sh:217:            fi
.claude/hooks/code-quality.sh:218:            ;;
.claude/hooks/code-quality.sh:219:        rust)
.claude/hooks/code-quality.sh:220:            if command -v cargo-audit &>/dev/null; then
.claude/hooks/code-quality.sh:221:                result+="$'\n'=== cargo audit ===$'\n'"
.claude/hooks/code-quality.sh:222:                result+=$(cd "$dir" && cargo audit 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:223:                checks_run=$((checks_run + 1))
.claude/hooks/code-quality.sh:224:            fi
.claude/hooks/code-quality.sh:225:            ;;
.claude/hooks/code-quality.sh:226:    esac
.claude/hooks/code-quality.sh:227:
.claude/hooks/code-quality.sh:228:    # Check for common issues
.claude/hooks/code-quality.sh:229:    result+="$'\n'=== Pattern Checks ===$'\n'"
.claude/hooks/code-quality.sh:230:
.claude/hooks/code-quality.sh:231:    # Check for hardcoded secrets patterns
.claude/hooks/code-quality.sh:232:    local secret_patterns="(password|secret|api_key|apikey|token|credential)\\s*=\\s*['\"][^'\"]+['\"]"
.claude/hooks/code-quality.sh:233:    local secret_matches
.claude/hooks/code-quality.sh:234:    secret_matches=$(grep -rniE "$secret_patterns" "$dir" --include="*.ts" --include="*.js" --include="*.py" --include="*.go" 2>/dev/null | head -20 || true)
.claude/hooks/code-quality.sh:235:
.claude/hooks/code-quality.sh:236:    if [[ -n "$secret_matches" ]]; then
.claude/hooks/code-quality.sh:237:        result+="Potential hardcoded secrets found:$'\n'$secret_matches"
.claude/hooks/code-quality.sh:238:        exit_code=1
.claude/hooks/code-quality.sh:239:    else
.claude/hooks/code-quality.sh:240:        result+="No hardcoded secrets patterns found"
.claude/hooks/code-quality.sh:241:    fi
.claude/hooks/code-quality.sh:242:
.claude/hooks/code-quality.sh:243:    jq -n \
.claude/hooks/code-quality.sh:244:        --arg type "security" \
.claude/hooks/code-quality.sh:245:        --arg project "$project_type" \
.claude/hooks/code-quality.sh:246:        --argjson passed "$([ $exit_code -eq 0 ] && echo true || echo false)" \
.claude/hooks/code-quality.sh:247:        --arg output "$result" \
.claude/hooks/code-quality.sh:248:        --argjson exitCode "$exit_code" \
.claude/hooks/code-quality.sh:249:        --argjson checksRun "$checks_run" \
.claude/hooks/code-quality.sh:250:        '{type: $type, project: $project, passed: $passed, output: $output, exitCode: $exitCode, checksRun: $checksRun}'
.claude/hooks/code-quality.sh:251:}
.claude/hooks/code-quality.sh:252:
.claude/hooks/code-quality.sh:253:# =============================================================================
.claude/hooks/code-quality.sh:254:# TEST CHECKS
.claude/hooks/code-quality.sh:255:# =============================================================================
.claude/hooks/code-quality.sh:256:
.claude/hooks/code-quality.sh:257:run_tests() {
.claude/hooks/code-quality.sh:258:    local dir="${1:-.}"
.claude/hooks/code-quality.sh:259:    local project_type
.claude/hooks/code-quality.sh:260:    project_type=$(detect_project_type "$dir")
.claude/hooks/code-quality.sh:261:
.claude/hooks/code-quality.sh:262:    local result=""
.claude/hooks/code-quality.sh:263:    local exit_code=0
.claude/hooks/code-quality.sh:264:
.claude/hooks/code-quality.sh:265:    log "Running tests for $project_type project in $dir"
.claude/hooks/code-quality.sh:266:
.claude/hooks/code-quality.sh:267:    case "$project_type" in
.claude/hooks/code-quality.sh:268:        typescript|javascript)
.claude/hooks/code-quality.sh:269:            if [[ -f "$dir/package.json" ]]; then
.claude/hooks/code-quality.sh:270:                if grep -q '"test"' "$dir/package.json" 2>/dev/null; then
.claude/hooks/code-quality.sh:271:                    result=$(cd "$dir" && npm test 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:272:                fi
.claude/hooks/code-quality.sh:273:            fi
.claude/hooks/code-quality.sh:274:            ;;
.claude/hooks/code-quality.sh:275:        python)
.claude/hooks/code-quality.sh:276:            if command -v pytest &>/dev/null; then
.claude/hooks/code-quality.sh:277:                result=$(cd "$dir" && pytest 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:278:            elif [[ -f "$dir/setup.py" ]]; then
.claude/hooks/code-quality.sh:279:                result=$(cd "$dir" && python setup.py test 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:280:            fi
.claude/hooks/code-quality.sh:281:            ;;
.claude/hooks/code-quality.sh:282:        go)
.claude/hooks/code-quality.sh:283:            result=$(cd "$dir" && go test ./... -v 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:284:            ;;
.claude/hooks/code-quality.sh:285:        rust)
.claude/hooks/code-quality.sh:286:            result=$(cd "$dir" && cargo test 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:287:            ;;
.claude/hooks/code-quality.sh:288:        java)
.claude/hooks/code-quality.sh:289:            if [[ -f "$dir/build.gradle" ]]; then
.claude/hooks/code-quality.sh:290:                result=$(cd "$dir" && ./gradlew test 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:291:            elif [[ -f "$dir/pom.xml" ]]; then
.claude/hooks/code-quality.sh:292:                result=$(cd "$dir" && mvn test 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:293:            fi
.claude/hooks/code-quality.sh:294:            ;;
.claude/hooks/code-quality.sh:295:        *)
.claude/hooks/code-quality.sh:296:            result="Test framework not detected"
.claude/hooks/code-quality.sh:297:            exit_code=0
.claude/hooks/code-quality.sh:298:            ;;
.claude/hooks/code-quality.sh:299:    esac
.claude/hooks/code-quality.sh:300:
.claude/hooks/code-quality.sh:301:    jq -n \
.claude/hooks/code-quality.sh:302:        --arg type "tests" \
.claude/hooks/code-quality.sh:303:        --arg project "$project_type" \
.claude/hooks/code-quality.sh:304:        --argjson passed "$([ $exit_code -eq 0 ] && echo true || echo false)" \
.claude/hooks/code-quality.sh:305:        --arg output "$result" \
.claude/hooks/code-quality.sh:306:        --argjson exitCode "$exit_code" \
.claude/hooks/code-quality.sh:307:        '{type: $type, project: $project, passed: $passed, output: $output, exitCode: $exitCode}'
.claude/hooks/code-quality.sh:308:}
.claude/hooks/code-quality.sh:309:
.claude/hooks/code-quality.sh:310:# =============================================================================
.claude/hooks/code-quality.sh:311:# COMPLEXITY ANALYSIS
.claude/hooks/code-quality.sh:312:# =============================================================================
.claude/hooks/code-quality.sh:313:
.claude/hooks/code-quality.sh:314:run_complexity() {
.claude/hooks/code-quality.sh:315:    local dir="${1:-.}"
.claude/hooks/code-quality.sh:316:    local project_type
.claude/hooks/code-quality.sh:317:    project_type=$(detect_project_type "$dir")
.claude/hooks/code-quality.sh:318:
.claude/hooks/code-quality.sh:319:    local result=""
.claude/hooks/code-quality.sh:320:    local exit_code=0
.claude/hooks/code-quality.sh:321:
.claude/hooks/code-quality.sh:322:    log "Running complexity analysis for $project_type project in $dir"
.claude/hooks/code-quality.sh:323:
.claude/hooks/code-quality.sh:324:    case "$project_type" in
.claude/hooks/code-quality.sh:325:        typescript|javascript)
.claude/hooks/code-quality.sh:326:            if command -v npx &>/dev/null; then
.claude/hooks/code-quality.sh:327:                # Try to run complexity analysis
.claude/hooks/code-quality.sh:328:                result="Complexity analysis (file count and size):$'\n'"
.claude/hooks/code-quality.sh:329:                result+=$(find "$dir" -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" 2>/dev/null | wc -l | xargs echo "Total files:")
.claude/hooks/code-quality.sh:330:                result+=$'\n'$(find "$dir" -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" 2>/dev/null -exec wc -l {} + 2>/dev/null | tail -1 | xargs echo "Total lines:")
.claude/hooks/code-quality.sh:331:            fi
.claude/hooks/code-quality.sh:332:            ;;
.claude/hooks/code-quality.sh:333:        python)
.claude/hooks/code-quality.sh:334:            if command -v radon &>/dev/null; then
.claude/hooks/code-quality.sh:335:                result=$(cd "$dir" && radon cc . -a -s 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:336:            else
.claude/hooks/code-quality.sh:337:                result="Complexity analysis (file count and size):$'\n'"
.claude/hooks/code-quality.sh:338:                result+=$(find "$dir" -name "*.py" 2>/dev/null | wc -l | xargs echo "Total files:")
.claude/hooks/code-quality.sh:339:                result+=$'\n'$(find "$dir" -name "*.py" 2>/dev/null -exec wc -l {} + 2>/dev/null | tail -1 | xargs echo "Total lines:")
.claude/hooks/code-quality.sh:340:            fi
.claude/hooks/code-quality.sh:341:            ;;
.claude/hooks/code-quality.sh:342:        go)
.claude/hooks/code-quality.sh:343:            if command -v gocyclo &>/dev/null; then
.claude/hooks/code-quality.sh:344:                result=$(cd "$dir" && gocyclo -over 10 . 2>&1) || exit_code=$?
.claude/hooks/code-quality.sh:345:            else
.claude/hooks/code-quality.sh:346:                result="Complexity analysis (file count and size):$'\n'"
.claude/hooks/code-quality.sh:347:                result+=$(find "$dir" -name "*.go" 2>/dev/null | wc -l | xargs echo "Total files:")
.claude/hooks/code-quality.sh:348:            fi
.claude/hooks/code-quality.sh:349:            ;;
.claude/hooks/code-quality.sh:350:        *)
.claude/hooks/code-quality.sh:351:            result="Complexity analysis not available for $project_type"
.claude/hooks/code-quality.sh:352:            ;;
.claude/hooks/code-quality.sh:353:    esac
.claude/hooks/code-quality.sh:354:
.claude/hooks/code-quality.sh:355:    jq -n \
.claude/hooks/code-quality.sh:356:        --arg type "complexity" \
.claude/hooks/code-quality.sh:357:        --arg project "$project_type" \
.claude/hooks/code-quality.sh:358:        --argjson passed "$([ $exit_code -eq 0 ] && echo true || echo false)" \
.claude/hooks/code-quality.sh:359:        --arg output "$result" \
.claude/hooks/code-quality.sh:360:        --argjson exitCode "$exit_code" \
.claude/hooks/code-quality.sh:361:        '{type: $type, project: $project, passed: $passed, output: $output, exitCode: $exitCode}'
.claude/hooks/code-quality.sh:362:}
.claude/hooks/code-quality.sh:363:
.claude/hooks/code-quality.sh:364:# =============================================================================
.claude/hooks/code-quality.sh:365:# FULL QUALITY CHECK
.claude/hooks/code-quality.sh:366:# =============================================================================
.claude/hooks/code-quality.sh:367:
.claude/hooks/code-quality.sh:368:run_full_check() {
.claude/hooks/code-quality.sh:369:    local dir="${1:-.}"
.claude/hooks/code-quality.sh:370:
.claude/hooks/code-quality.sh:371:    init_quality
.claude/hooks/code-quality.sh:372:
.claude/hooks/code-quality.sh:373:    log "Running full quality check in $dir"
.claude/hooks/code-quality.sh:374:
.claude/hooks/code-quality.sh:375:    local timestamp
.claude/hooks/code-quality.sh:376:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/code-quality.sh:377:
.claude/hooks/code-quality.sh:378:    local project_type
.claude/hooks/code-quality.sh:379:    project_type=$(detect_project_type "$dir")
.claude/hooks/code-quality.sh:380:
.claude/hooks/code-quality.sh:381:    # Run all checks
.claude/hooks/code-quality.sh:382:    local lint_result
.claude/hooks/code-quality.sh:383:    lint_result=$(run_lint "$dir")
.claude/hooks/code-quality.sh:384:
.claude/hooks/code-quality.sh:385:    local type_result
.claude/hooks/code-quality.sh:386:    type_result=$(run_typecheck "$dir")
.claude/hooks/code-quality.sh:387:
.claude/hooks/code-quality.sh:388:    local security_result
.claude/hooks/code-quality.sh:389:    security_result=$(run_security "$dir")
.claude/hooks/code-quality.sh:390:
.claude/hooks/code-quality.sh:391:    local test_result
.claude/hooks/code-quality.sh:392:    test_result=$(run_tests "$dir")
.claude/hooks/code-quality.sh:393:
.claude/hooks/code-quality.sh:394:    local complexity_result
.claude/hooks/code-quality.sh:395:    complexity_result=$(run_complexity "$dir")
.claude/hooks/code-quality.sh:396:
.claude/hooks/code-quality.sh:397:    # Calculate overall score
.claude/hooks/code-quality.sh:398:    local passed_count=0
.claude/hooks/code-quality.sh:399:    local total_count=5
.claude/hooks/code-quality.sh:400:
.claude/hooks/code-quality.sh:401:    [[ $(echo "$lint_result" | jq -r '.passed') == "true" ]] && passed_count=$((passed_count + 1))
.claude/hooks/code-quality.sh:402:    [[ $(echo "$type_result" | jq -r '.passed') == "true" ]] && passed_count=$((passed_count + 1))
.claude/hooks/code-quality.sh:403:    [[ $(echo "$security_result" | jq -r '.passed') == "true" ]] && passed_count=$((passed_count + 1))
.claude/hooks/code-quality.sh:404:    [[ $(echo "$test_result" | jq -r '.passed') == "true" ]] && passed_count=$((passed_count + 1))
.claude/hooks/code-quality.sh:405:    [[ $(echo "$complexity_result" | jq -r '.passed') == "true" ]] && passed_count=$((passed_count + 1))
.claude/hooks/code-quality.sh:406:
.claude/hooks/code-quality.sh:407:    local score
.claude/hooks/code-quality.sh:408:    score=$(echo "scale=2; $passed_count / $total_count * 100" | bc)
.claude/hooks/code-quality.sh:409:
.claude/hooks/code-quality.sh:410:    # Generate report
.claude/hooks/code-quality.sh:411:    jq -n \
.claude/hooks/code-quality.sh:412:        --arg timestamp "$timestamp" \
.claude/hooks/code-quality.sh:413:        --arg project "$project_type" \
.claude/hooks/code-quality.sh:414:        --arg dir "$dir" \
.claude/hooks/code-quality.sh:415:        --argjson score "$score" \
.claude/hooks/code-quality.sh:416:        --argjson passed "$passed_count" \
.claude/hooks/code-quality.sh:417:        --argjson total "$total_count" \
.claude/hooks/code-quality.sh:418:        --argjson lint "$lint_result" \
.claude/hooks/code-quality.sh:419:        --argjson typecheck "$type_result" \
.claude/hooks/code-quality.sh:420:        --argjson security "$security_result" \
.claude/hooks/code-quality.sh:421:        --argjson tests "$test_result" \
.claude/hooks/code-quality.sh:422:        --argjson complexity "$complexity_result" \
.claude/hooks/code-quality.sh:423:        '{
.claude/hooks/code-quality.sh:424:            timestamp: $timestamp,
.claude/hooks/code-quality.sh:425:            project: $project,
.claude/hooks/code-quality.sh:426:            directory: $dir,
.claude/hooks/code-quality.sh:427:            score: $score,
.claude/hooks/code-quality.sh:428:            summary: {
.claude/hooks/code-quality.sh:429:                passed: $passed,
.claude/hooks/code-quality.sh:430:                total: $total
.claude/hooks/code-quality.sh:431:            },
.claude/hooks/code-quality.sh:432:            checks: {
.claude/hooks/code-quality.sh:433:                lint: $lint,
.claude/hooks/code-quality.sh:434:                typecheck: $typecheck,
.claude/hooks/code-quality.sh:435:                security: $security,
.claude/hooks/code-quality.sh:436:                tests: $tests,
.claude/hooks/code-quality.sh:437:                complexity: $complexity
.claude/hooks/code-quality.sh:438:            }
.claude/hooks/code-quality.sh:439:        }' | tee "$REPORT_FILE"
.claude/hooks/code-quality.sh:440:
.claude/hooks/code-quality.sh:441:    log "Full check complete. Score: $score%"
.claude/hooks/code-quality.sh:442:}
.claude/hooks/code-quality.sh:443:
.claude/hooks/code-quality.sh:444:# Get quality summary
.claude/hooks/code-quality.sh:445:get_summary() {
.claude/hooks/code-quality.sh:446:    if [[ ! -f "$REPORT_FILE" ]]; then
.claude/hooks/code-quality.sh:447:        echo "No quality report found. Run 'full' first."
.claude/hooks/code-quality.sh:448:        return 1
.claude/hooks/code-quality.sh:449:    fi
.claude/hooks/code-quality.sh:450:
.claude/hooks/code-quality.sh:451:    jq -r '
.claude/hooks/code-quality.sh:452:        "=== Code Quality Report ===\n" +
.claude/hooks/code-quality.sh:453:        "Project: \(.project)\n" +
.claude/hooks/code-quality.sh:454:        "Score: \(.score)%\n" +
.claude/hooks/code-quality.sh:455:        "Passed: \(.summary.passed)/\(.summary.total)\n" +
.claude/hooks/code-quality.sh:456:        "\n--- Check Results ---\n" +
.claude/hooks/code-quality.sh:457:        "Lint: \(if .checks.lint.passed then "" else "" end)\n" +
.claude/hooks/code-quality.sh:458:        "Types: \(if .checks.typecheck.passed then "" else "" end)\n" +
.claude/hooks/code-quality.sh:459:        "Security: \(if .checks.security.passed then "" else "" end)\n" +
.claude/hooks/code-quality.sh:460:        "Tests: \(if .checks.tests.passed then "" else "" end)\n" +
.claude/hooks/code-quality.sh:461:        "Complexity: \(if .checks.complexity.passed then "" else "" end)"
.claude/hooks/code-quality.sh:462:    ' "$REPORT_FILE"
.claude/hooks/code-quality.sh:463:}
.claude/hooks/code-quality.sh:464:
.claude/hooks/code-quality.sh:465:# =============================================================================
.claude/hooks/code-quality.sh:466:# COMMAND INTERFACE
.claude/hooks/code-quality.sh:467:# =============================================================================
.claude/hooks/code-quality.sh:468:
.claude/hooks/code-quality.sh:469:case "${1:-help}" in
.claude/hooks/code-quality.sh:470:    detect)
.claude/hooks/code-quality.sh:471:        detect_project_type "${2:-.}"
.claude/hooks/code-quality.sh:472:        ;;
.claude/hooks/code-quality.sh:473:    lint)
.claude/hooks/code-quality.sh:474:        run_lint "${2:-.}"
.claude/hooks/code-quality.sh:475:        ;;
.claude/hooks/code-quality.sh:476:    typecheck)
.claude/hooks/code-quality.sh:477:        run_typecheck "${2:-.}"
.claude/hooks/code-quality.sh:478:        ;;
.claude/hooks/code-quality.sh:479:    security)
.claude/hooks/code-quality.sh:480:        run_security "${2:-.}"
.claude/hooks/code-quality.sh:481:        ;;
.claude/hooks/code-quality.sh:482:    tests)
.claude/hooks/code-quality.sh:483:        run_tests "${2:-.}"
.claude/hooks/code-quality.sh:484:        ;;
.claude/hooks/code-quality.sh:485:    complexity)
.claude/hooks/code-quality.sh:486:        run_complexity "${2:-.}"
.claude/hooks/code-quality.sh:487:        ;;
.claude/hooks/code-quality.sh:488:    full)
.claude/hooks/code-quality.sh:489:        run_full_check "${2:-.}"
.claude/hooks/code-quality.sh:490:        ;;
.claude/hooks/code-quality.sh:491:    summary)
.claude/hooks/code-quality.sh:492:        get_summary
.claude/hooks/code-quality.sh:493:        ;;
.claude/hooks/code-quality.sh:494:    help|*)
.claude/hooks/code-quality.sh:495:        echo "Code Quality System"
.claude/hooks/code-quality.sh:496:        echo ""
.claude/hooks/code-quality.sh:497:        echo "Usage: $0 <command> [directory]"
.claude/hooks/code-quality.sh:498:        echo ""
.claude/hooks/code-quality.sh:499:        echo "Commands:"
.claude/hooks/code-quality.sh:500:        echo "  detect [dir]      - Detect project type"
.claude/hooks/code-quality.sh:501:        echo "  lint [dir]        - Run linting"
.claude/hooks/code-quality.sh:502:        echo "  typecheck [dir]   - Run type checking"
.claude/hooks/code-quality.sh:503:        echo "  security [dir]    - Run security checks"
.claude/hooks/code-quality.sh:504:        echo "  tests [dir]       - Run tests"
.claude/hooks/code-quality.sh:505:        echo "  complexity [dir]  - Run complexity analysis"
.claude/hooks/code-quality.sh:506:        echo "  full [dir]        - Run all checks"
.claude/hooks/code-quality.sh:507:        echo "  summary           - Show last report summary"
.claude/hooks/code-quality.sh:508:        echo ""
.claude/hooks/code-quality.sh:509:        echo "Supported Projects:"
.claude/hooks/code-quality.sh:510:        echo "  TypeScript/JavaScript (npm, eslint)"
.claude/hooks/code-quality.sh:511:        echo "  Python (ruff, pylint, mypy, pytest, bandit)"
.claude/hooks/code-quality.sh:512:        echo "  Go (go vet, staticcheck, gosec)"
.claude/hooks/code-quality.sh:513:        echo "  Rust (cargo clippy, cargo audit)"
.claude/hooks/code-quality.sh:514:        echo "  Java (gradle, maven, checkstyle)"
.claude/hooks/code-quality.sh:515:        ;;
.claude/hooks/code-quality.sh:516:esac
.claude/hooks/auto-evaluator.sh.backup:1:#!/bin/bash
.claude/hooks/auto-evaluator.sh.backup:2:# LLM-as-Judge Auto-Evaluator - Real-time quality assessment
.claude/hooks/auto-evaluator.sh.backup:3:# Based on: LlamaStack llm_as_judge, OpenAI cookbook judge patterns, Comet Opik evaluators
.claude/hooks/auto-evaluator.sh.backup:4:# Provides automated evaluation with chain-of-thought reasoning
.claude/hooks/auto-evaluator.sh.backup:5:
.claude/hooks/auto-evaluator.sh.backup:6:set -eo pipefail
.claude/hooks/auto-evaluator.sh.backup:7:
.claude/hooks/auto-evaluator.sh.backup:8:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/auto-evaluator.sh.backup:9:MEMORY_MANAGER="${CLAUDE_DIR}/hooks/memory-manager.sh"
.claude/hooks/auto-evaluator.sh.backup:10:LOG_FILE="${CLAUDE_DIR}/auto-evaluator.log"
.claude/hooks/auto-evaluator.sh.backup:11:EVAL_HISTORY="${CLAUDE_DIR}/.evaluator/history.jsonl"
.claude/hooks/auto-evaluator.sh.backup:12:
.claude/hooks/auto-evaluator.sh.backup:13:mkdir -p "$(dirname "$EVAL_HISTORY")"
.claude/hooks/auto-evaluator.sh.backup:14:
.claude/hooks/auto-evaluator.sh.backup:15:log() {
.claude/hooks/auto-evaluator.sh.backup:16:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/auto-evaluator.sh.backup:17:}
.claude/hooks/auto-evaluator.sh.backup:18:
.claude/hooks/auto-evaluator.sh.backup:19:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:20:# EVALUATION CRITERIA (from OpenAI/Anthropic best practices)
.claude/hooks/auto-evaluator.sh.backup:21:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:22:
.claude/hooks/auto-evaluator.sh.backup:23:# Core evaluation dimensions
.claude/hooks/auto-evaluator.sh.backup:24:get_evaluation_criteria() {
.claude/hooks/auto-evaluator.sh.backup:25:    local eval_type="${1:-code}"
.claude/hooks/auto-evaluator.sh.backup:26:
.claude/hooks/auto-evaluator.sh.backup:27:    case "$eval_type" in
.claude/hooks/auto-evaluator.sh.backup:28:        code)
.claude/hooks/auto-evaluator.sh.backup:29:            cat << 'EOF'
.claude/hooks/auto-evaluator.sh.backup:30:{
.claude/hooks/auto-evaluator.sh.backup:31:    "criteria": {
.claude/hooks/auto-evaluator.sh.backup:32:        "correctness": {
.claude/hooks/auto-evaluator.sh.backup:33:            "description": "Does the code solve the intended problem correctly?",
.claude/hooks/auto-evaluator.sh.backup:34:            "weight": 0.30
.claude/hooks/auto-evaluator.sh.backup:35:        },
.claude/hooks/auto-evaluator.sh.backup:36:        "quality": {
.claude/hooks/auto-evaluator.sh.backup:37:            "description": "Is the code well-written, readable, and maintainable?",
.claude/hooks/auto-evaluator.sh.backup:38:            "weight": 0.25
.claude/hooks/auto-evaluator.sh.backup:39:        },
.claude/hooks/auto-evaluator.sh.backup:40:        "safety": {
.claude/hooks/auto-evaluator.sh.backup:41:            "description": "Does it avoid security vulnerabilities and handle errors?",
.claude/hooks/auto-evaluator.sh.backup:42:            "weight": 0.20
.claude/hooks/auto-evaluator.sh.backup:43:        },
.claude/hooks/auto-evaluator.sh.backup:44:        "efficiency": {
.claude/hooks/auto-evaluator.sh.backup:45:            "description": "Is it performant and resource-efficient?",
.claude/hooks/auto-evaluator.sh.backup:46:            "weight": 0.15
.claude/hooks/auto-evaluator.sh.backup:47:        },
.claude/hooks/auto-evaluator.sh.backup:48:        "completeness": {
.claude/hooks/auto-evaluator.sh.backup:49:            "description": "Does it handle edge cases and meet all requirements?",
.claude/hooks/auto-evaluator.sh.backup:50:            "weight": 0.10
.claude/hooks/auto-evaluator.sh.backup:51:        }
.claude/hooks/auto-evaluator.sh.backup:52:    },
.claude/hooks/auto-evaluator.sh.backup:53:    "scale": "1-10",
.claude/hooks/auto-evaluator.sh.backup:54:    "pass_threshold": 7.0
.claude/hooks/auto-evaluator.sh.backup:55:}
.claude/hooks/auto-evaluator.sh.backup:56:EOF
.claude/hooks/auto-evaluator.sh.backup:57:            ;;
.claude/hooks/auto-evaluator.sh.backup:58:        documentation)
.claude/hooks/auto-evaluator.sh.backup:59:            cat << 'EOF'
.claude/hooks/auto-evaluator.sh.backup:60:{
.claude/hooks/auto-evaluator.sh.backup:61:    "criteria": {
.claude/hooks/auto-evaluator.sh.backup:62:        "clarity": {
.claude/hooks/auto-evaluator.sh.backup:63:            "description": "Is it clear, concise, and easy to understand?",
.claude/hooks/auto-evaluator.sh.backup:64:            "weight": 0.35
.claude/hooks/auto-evaluator.sh.backup:65:        },
.claude/hooks/auto-evaluator.sh.backup:66:        "accuracy": {
.claude/hooks/auto-evaluator.sh.backup:67:            "description": "Is the information correct and up-to-date?",
.claude/hooks/auto-evaluator.sh.backup:68:            "weight": 0.30
.claude/hooks/auto-evaluator.sh.backup:69:        },
.claude/hooks/auto-evaluator.sh.backup:70:        "completeness": {
.claude/hooks/auto-evaluator.sh.backup:71:            "description": "Does it cover all necessary information?",
.claude/hooks/auto-evaluator.sh.backup:72:            "weight": 0.20
.claude/hooks/auto-evaluator.sh.backup:73:        },
.claude/hooks/auto-evaluator.sh.backup:74:        "usefulness": {
.claude/hooks/auto-evaluator.sh.backup:75:            "description": "Will it help the intended audience?",
.claude/hooks/auto-evaluator.sh.backup:76:            "weight": 0.15
.claude/hooks/auto-evaluator.sh.backup:77:        }
.claude/hooks/auto-evaluator.sh.backup:78:    },
.claude/hooks/auto-evaluator.sh.backup:79:    "scale": "1-10",
.claude/hooks/auto-evaluator.sh.backup:80:    "pass_threshold": 7.0
.claude/hooks/auto-evaluator.sh.backup:81:}
.claude/hooks/auto-evaluator.sh.backup:82:EOF
.claude/hooks/auto-evaluator.sh.backup:83:            ;;
.claude/hooks/auto-evaluator.sh.backup:84:        test)
.claude/hooks/auto-evaluator.sh.backup:85:            cat << 'EOF'
.claude/hooks/auto-evaluator.sh.backup:86:{
.claude/hooks/auto-evaluator.sh.backup:87:    "criteria": {
.claude/hooks/auto-evaluator.sh.backup:88:        "coverage": {
.claude/hooks/auto-evaluator.sh.backup:89:            "description": "Does it test all important scenarios?",
.claude/hooks/auto-evaluator.sh.backup:90:            "weight": 0.35
.claude/hooks/auto-evaluator.sh.backup:91:        },
.claude/hooks/auto-evaluator.sh.backup:92:        "correctness": {
.claude/hooks/auto-evaluator.sh.backup:93:            "description": "Are the assertions and expectations correct?",
.claude/hooks/auto-evaluator.sh.backup:94:            "weight": 0.30
.claude/hooks/auto-evaluator.sh.backup:95:        },
.claude/hooks/auto-evaluator.sh.backup:96:        "maintainability": {
.claude/hooks/auto-evaluator.sh.backup:97:            "description": "Is the test code clear and maintainable?",
.claude/hooks/auto-evaluator.sh.backup:98:            "weight": 0.20
.claude/hooks/auto-evaluator.sh.backup:99:        },
.claude/hooks/auto-evaluator.sh.backup:100:        "isolation": {
.claude/hooks/auto-evaluator.sh.backup:101:            "description": "Is it properly isolated and deterministic?",
.claude/hooks/auto-evaluator.sh.backup:102:            "weight": 0.15
.claude/hooks/auto-evaluator.sh.backup:103:        }
.claude/hooks/auto-evaluator.sh.backup:104:    },
.claude/hooks/auto-evaluator.sh.backup:105:    "scale": "1-10",
.claude/hooks/auto-evaluator.sh.backup:106:    "pass_threshold": 7.0
.claude/hooks/auto-evaluator.sh.backup:107:}
.claude/hooks/auto-evaluator.sh.backup:108:EOF
.claude/hooks/auto-evaluator.sh.backup:109:            ;;
.claude/hooks/auto-evaluator.sh.backup:110:        *)
.claude/hooks/auto-evaluator.sh.backup:111:            cat << 'EOF'
.claude/hooks/auto-evaluator.sh.backup:112:{
.claude/hooks/auto-evaluator.sh.backup:113:    "criteria": {
.claude/hooks/auto-evaluator.sh.backup:114:        "quality": {
.claude/hooks/auto-evaluator.sh.backup:115:            "description": "Overall quality of the output",
.claude/hooks/auto-evaluator.sh.backup:116:            "weight": 0.50
.claude/hooks/auto-evaluator.sh.backup:117:        },
.claude/hooks/auto-evaluator.sh.backup:118:        "correctness": {
.claude/hooks/auto-evaluator.sh.backup:119:            "description": "Does it meet the requirements?",
.claude/hooks/auto-evaluator.sh.backup:120:            "weight": 0.30
.claude/hooks/auto-evaluator.sh.backup:121:        },
.claude/hooks/auto-evaluator.sh.backup:122:        "completeness": {
.claude/hooks/auto-evaluator.sh.backup:123:            "description": "Is it complete and thorough?",
.claude/hooks/auto-evaluator.sh.backup:124:            "weight": 0.20
.claude/hooks/auto-evaluator.sh.backup:125:        }
.claude/hooks/auto-evaluator.sh.backup:126:    },
.claude/hooks/auto-evaluator.sh.backup:127:    "scale": "1-10",
.claude/hooks/auto-evaluator.sh.backup:128:    "pass_threshold": 7.0
.claude/hooks/auto-evaluator.sh.backup:129:}
.claude/hooks/auto-evaluator.sh.backup:130:EOF
.claude/hooks/auto-evaluator.sh.backup:131:            ;;
.claude/hooks/auto-evaluator.sh.backup:132:    esac
.claude/hooks/auto-evaluator.sh.backup:133:}
.claude/hooks/auto-evaluator.sh.backup:134:
.claude/hooks/auto-evaluator.sh.backup:135:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:136:# CHAIN-OF-THOUGHT EVALUATION PROMPT (improves reliability by 10-15%)
.claude/hooks/auto-evaluator.sh.backup:137:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:138:
.claude/hooks/auto-evaluator.sh.backup:139:generate_evaluation_prompt() {
.claude/hooks/auto-evaluator.sh.backup:140:    local task="$1"
.claude/hooks/auto-evaluator.sh.backup:141:    local output="$2"
.claude/hooks/auto-evaluator.sh.backup:142:    local eval_type="${3:-code}"
.claude/hooks/auto-evaluator.sh.backup:143:    local context="${4:-}"
.claude/hooks/auto-evaluator.sh.backup:144:
.claude/hooks/auto-evaluator.sh.backup:145:    local criteria_json
.claude/hooks/auto-evaluator.sh.backup:146:    criteria_json=$(get_evaluation_criteria "$eval_type")
.claude/hooks/auto-evaluator.sh.backup:147:
.claude/hooks/auto-evaluator.sh.backup:148:    local criteria_text
.claude/hooks/auto-evaluator.sh.backup:149:    criteria_text=$(echo "$criteria_json" | jq -r '.criteria | to_entries[] | "**\(.key|ascii_upcase)** (\(.value.weight*100|floor)%): \(.value.description)"' | sed 's/^/    /')
.claude/hooks/auto-evaluator.sh.backup:150:
.claude/hooks/auto-evaluator.sh.backup:151:    cat << EOF
.claude/hooks/auto-evaluator.sh.backup:152:{
.claude/hooks/auto-evaluator.sh.backup:153:    "evaluation_prompt": "You are an expert evaluator using chain-of-thought reasoning to assess quality.
.claude/hooks/auto-evaluator.sh.backup:154:
.claude/hooks/auto-evaluator.sh.backup:155:**TASK:**
.claude/hooks/auto-evaluator.sh.backup:156:$task
.claude/hooks/auto-evaluator.sh.backup:157:
.claude/hooks/auto-evaluator.sh.backup:158:**OUTPUT TO EVALUATE:**
.claude/hooks/auto-evaluator.sh.backup:159:\`\`\`
.claude/hooks/auto-evaluator.sh.backup:160:$output
.claude/hooks/auto-evaluator.sh.backup:161:\`\`\`
.claude/hooks/auto-evaluator.sh.backup:162:
.claude/hooks/auto-evaluator.sh.backup:163:**CONTEXT:**
.claude/hooks/auto-evaluator.sh.backup:164:$context
.claude/hooks/auto-evaluator.sh.backup:165:
.claude/hooks/auto-evaluator.sh.backup:166:**EVALUATION INSTRUCTIONS:**
.claude/hooks/auto-evaluator.sh.backup:167:
.claude/hooks/auto-evaluator.sh.backup:168:Please evaluate this output using chain-of-thought reasoning across these dimensions:
.claude/hooks/auto-evaluator.sh.backup:169:
.claude/hooks/auto-evaluator.sh.backup:170:$criteria_text
.claude/hooks/auto-evaluator.sh.backup:171:
.claude/hooks/auto-evaluator.sh.backup:172:**CHAIN-OF-THOUGHT EVALUATION PROCESS:**
.claude/hooks/auto-evaluator.sh.backup:173:
.claude/hooks/auto-evaluator.sh.backup:174:For each criterion:
.claude/hooks/auto-evaluator.sh.backup:175:1. Analyze the specific evidence (quote examples)
.claude/hooks/auto-evaluator.sh.backup:176:2. Identify strengths and weaknesses
.claude/hooks/auto-evaluator.sh.backup:177:3. Assign a score (1-10) with justification
.claude/hooks/auto-evaluator.sh.backup:178:4. Provide specific improvement suggestions
.claude/hooks/auto-evaluator.sh.backup:179:
.claude/hooks/auto-evaluator.sh.backup:180:**FORMAT YOUR RESPONSE AS JSON:**
.claude/hooks/auto-evaluator.sh.backup:181:
.claude/hooks/auto-evaluator.sh.backup:182:\`\`\`json
.claude/hooks/auto-evaluator.sh.backup:183:{
.claude/hooks/auto-evaluator.sh.backup:184:    \"reasoning\": {
.claude/hooks/auto-evaluator.sh.backup:185:        \"criterion_name\": {
.claude/hooks/auto-evaluator.sh.backup:186:            \"analysis\": \"Detailed analysis with evidence...\",
.claude/hooks/auto-evaluator.sh.backup:187:            \"strengths\": [\"Strength 1\", \"Strength 2\"],
.claude/hooks/auto-evaluator.sh.backup:188:            \"weaknesses\": [\"Weakness 1\", \"Weakness 2\"],
.claude/hooks/auto-evaluator.sh.backup:189:            \"score\": 8,
.claude/hooks/auto-evaluator.sh.backup:190:            \"justification\": \"Why this score...\"
.claude/hooks/auto-evaluator.sh.backup:191:        }
.claude/hooks/auto-evaluator.sh.backup:192:    },
.claude/hooks/auto-evaluator.sh.backup:193:    \"scores\": {
.claude/hooks/auto-evaluator.sh.backup:194:        \"criterion_name\": 8.0
.claude/hooks/auto-evaluator.sh.backup:195:    },
.claude/hooks/auto-evaluator.sh.backup:196:    \"weighted_score\": 7.5,
.claude/hooks/auto-evaluator.sh.backup:197:    \"pass\": true,
.claude/hooks/auto-evaluator.sh.backup:198:    \"overall_assessment\": \"Summary of quality...\",
.claude/hooks/auto-evaluator.sh.backup:199:    \"critical_issues\": [\"Issue 1\", \"Issue 2\"],
.claude/hooks/auto-evaluator.sh.backup:200:    \"improvement_suggestions\": [\"Suggestion 1\", \"Suggestion 2\"],
.claude/hooks/auto-evaluator.sh.backup:201:    \"revision_required\": false
.claude/hooks/auto-evaluator.sh.backup:202:}
.claude/hooks/auto-evaluator.sh.backup:203:\`\`\`
.claude/hooks/auto-evaluator.sh.backup:204:
.claude/hooks/auto-evaluator.sh.backup:205:Begin your evaluation:",
.claude/hooks/auto-evaluator.sh.backup:206:    "criteria": $(echo "$criteria_json" | jq -c '.'),
.claude/hooks/auto-evaluator.sh.backup:207:    "eval_type": "$eval_type"
.claude/hooks/auto-evaluator.sh.backup:208:}
.claude/hooks/auto-evaluator.sh.backup:209:EOF
.claude/hooks/auto-evaluator.sh.backup:210:}
.claude/hooks/auto-evaluator.sh.backup:211:
.claude/hooks/auto-evaluator.sh.backup:212:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:213:# EVALUATION EXECUTION
.claude/hooks/auto-evaluator.sh.backup:214:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:215:
.claude/hooks/auto-evaluator.sh.backup:216:# Evaluate output quality (requires Claude API call - returns prompt for now)
.claude/hooks/auto-evaluator.sh.backup:217:evaluate_output() {
.claude/hooks/auto-evaluator.sh.backup:218:    local task="$1"
.claude/hooks/auto-evaluator.sh.backup:219:    local output="$2"
.claude/hooks/auto-evaluator.sh.backup:220:    local eval_type="${3:-code}"
.claude/hooks/auto-evaluator.sh.backup:221:    local context="${4:-}"
.claude/hooks/auto-evaluator.sh.backup:222:
.claude/hooks/auto-evaluator.sh.backup:223:    log "Evaluating output for task: $task (type: $eval_type)"
.claude/hooks/auto-evaluator.sh.backup:224:
.claude/hooks/auto-evaluator.sh.backup:225:    # Generate evaluation prompt
.claude/hooks/auto-evaluator.sh.backup:226:    local eval_prompt
.claude/hooks/auto-evaluator.sh.backup:227:    eval_prompt=$(generate_evaluation_prompt "$task" "$output" "$eval_type" "$context")
.claude/hooks/auto-evaluator.sh.backup:228:
.claude/hooks/auto-evaluator.sh.backup:229:    # Return prompt for Claude to process
.claude/hooks/auto-evaluator.sh.backup:230:    echo "$eval_prompt" | jq -c '.'
.claude/hooks/auto-evaluator.sh.backup:231:}
.claude/hooks/auto-evaluator.sh.backup:232:
.claude/hooks/auto-evaluator.sh.backup:233:# Process evaluation result and determine if revision needed
.claude/hooks/auto-evaluator.sh.backup:234:process_evaluation_result() {
.claude/hooks/auto-evaluator.sh.backup:235:    local eval_result="$1"
.claude/hooks/auto-evaluator.sh.backup:236:    local task="$2"
.claude/hooks/auto-evaluator.sh.backup:237:
.claude/hooks/auto-evaluator.sh.backup:238:    log "Processing evaluation result"
.claude/hooks/auto-evaluator.sh.backup:239:
.claude/hooks/auto-evaluator.sh.backup:240:    # Extract key metrics
.claude/hooks/auto-evaluator.sh.backup:241:    local weighted_score
.claude/hooks/auto-evaluator.sh.backup:242:    local pass_status
.claude/hooks/auto-evaluator.sh.backup:243:    local revision_required
.claude/hooks/auto-evaluator.sh.backup:244:    local critical_issues
.claude/hooks/auto-evaluator.sh.backup:245:
.claude/hooks/auto-evaluator.sh.backup:246:    weighted_score=$(echo "$eval_result" | jq -r '.weighted_score // 5' 2>/dev/null)
.claude/hooks/auto-evaluator.sh.backup:247:    pass_status=$(echo "$eval_result" | jq -r '.pass // false' 2>/dev/null)
.claude/hooks/auto-evaluator.sh.backup:248:    revision_required=$(echo "$eval_result" | jq -r '.revision_required // false' 2>/dev/null)
.claude/hooks/auto-evaluator.sh.backup:249:    critical_issues=$(echo "$eval_result" | jq -r '.critical_issues // [] | length' 2>/dev/null)
.claude/hooks/auto-evaluator.sh.backup:250:
.claude/hooks/auto-evaluator.sh.backup:251:    # Record to history
.claude/hooks/auto-evaluator.sh.backup:252:    record_evaluation_history "$task" "$weighted_score" "$pass_status" "$eval_result"
.claude/hooks/auto-evaluator.sh.backup:253:
.claude/hooks/auto-evaluator.sh.backup:254:    # Store evaluation insights in memory
.claude/hooks/auto-evaluator.sh.backup:255:    if [[ -x "$MEMORY_MANAGER" && "$pass_status" == "true" ]]; then
.claude/hooks/auto-evaluator.sh.backup:256:        local assessment
.claude/hooks/auto-evaluator.sh.backup:257:        assessment=$(echo "$eval_result" | jq -r '.overall_assessment // empty' 2>/dev/null)
.claude/hooks/auto-evaluator.sh.backup:258:        "$MEMORY_MANAGER" add-context "Quality evaluation: $task scored $weighted_score/10. $assessment" "$weighted_score" 2>/dev/null || true
.claude/hooks/auto-evaluator.sh.backup:259:    fi
.claude/hooks/auto-evaluator.sh.backup:260:
.claude/hooks/auto-evaluator.sh.backup:261:    # Generate action recommendation
.claude/hooks/auto-evaluator.sh.backup:262:    local action="continue"
.claude/hooks/auto-evaluator.sh.backup:263:    local reason="Output meets quality threshold"
.claude/hooks/auto-evaluator.sh.backup:264:
.claude/hooks/auto-evaluator.sh.backup:265:    if [[ "$pass_status" == "false" ]] || [[ "$revision_required" == "true" ]] || (( $(echo "$weighted_score < 7" | bc -l 2>/dev/null || echo 0) )); then
.claude/hooks/auto-evaluator.sh.backup:266:        action="revise"
.claude/hooks/auto-evaluator.sh.backup:267:        reason="Quality score ($weighted_score) below threshold or critical issues found ($critical_issues issues)"
.claude/hooks/auto-evaluator.sh.backup:268:    fi
.claude/hooks/auto-evaluator.sh.backup:269:
.claude/hooks/auto-evaluator.sh.backup:270:    cat << EOF
.claude/hooks/auto-evaluator.sh.backup:271:{
.claude/hooks/auto-evaluator.sh.backup:272:    "action": "$action",
.claude/hooks/auto-evaluator.sh.backup:273:    "reason": "$reason",
.claude/hooks/auto-evaluator.sh.backup:274:    "score": $weighted_score,
.claude/hooks/auto-evaluator.sh.backup:275:    "pass": $pass_status,
.claude/hooks/auto-evaluator.sh.backup:276:    "revision_required": $revision_required,
.claude/hooks/auto-evaluator.sh.backup:277:    "critical_issues": $critical_issues,
.claude/hooks/auto-evaluator.sh.backup:278:    "evaluation": $(echo "$eval_result" | jq -c '.')
.claude/hooks/auto-evaluator.sh.backup:279:}
.claude/hooks/auto-evaluator.sh.backup:280:EOF
.claude/hooks/auto-evaluator.sh.backup:281:}
.claude/hooks/auto-evaluator.sh.backup:282:
.claude/hooks/auto-evaluator.sh.backup:283:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:284:# EVALUATION HISTORY AND ANALYTICS
.claude/hooks/auto-evaluator.sh.backup:285:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:286:
.claude/hooks/auto-evaluator.sh.backup:287:# Record evaluation to history
.claude/hooks/auto-evaluator.sh.backup:288:record_evaluation_history() {
.claude/hooks/auto-evaluator.sh.backup:289:    local task="$1"
.claude/hooks/auto-evaluator.sh.backup:290:    local score="$2"
.claude/hooks/auto-evaluator.sh.backup:291:    local pass="$3"
.claude/hooks/auto-evaluator.sh.backup:292:    local full_result="$4"
.claude/hooks/auto-evaluator.sh.backup:293:
.claude/hooks/auto-evaluator.sh.backup:294:    local timestamp
.claude/hooks/auto-evaluator.sh.backup:295:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/auto-evaluator.sh.backup:296:
.claude/hooks/auto-evaluator.sh.backup:297:    local record
.claude/hooks/auto-evaluator.sh.backup:298:    record=$(jq -n \
.claude/hooks/auto-evaluator.sh.backup:299:        --arg task "$task" \
.claude/hooks/auto-evaluator.sh.backup:300:        --arg score "$score" \
.claude/hooks/auto-evaluator.sh.backup:301:        --arg pass "$pass" \
.claude/hooks/auto-evaluator.sh.backup:302:        --arg ts "$timestamp" \
.claude/hooks/auto-evaluator.sh.backup:303:        --argjson result "$full_result" \
.claude/hooks/auto-evaluator.sh.backup:304:        '{
.claude/hooks/auto-evaluator.sh.backup:305:            timestamp: $ts,
.claude/hooks/auto-evaluator.sh.backup:306:            task: $task,
.claude/hooks/auto-evaluator.sh.backup:307:            score: ($score | tonumber),
.claude/hooks/auto-evaluator.sh.backup:308:            pass: ($pass == "true"),
.claude/hooks/auto-evaluator.sh.backup:309:            result: $result
.claude/hooks/auto-evaluator.sh.backup:310:        }')
.claude/hooks/auto-evaluator.sh.backup:311:
.claude/hooks/auto-evaluator.sh.backup:312:    echo "$record" >> "$EVAL_HISTORY"
.claude/hooks/auto-evaluator.sh.backup:313:
.claude/hooks/auto-evaluator.sh.backup:314:    log "Recorded evaluation: task=$task, score=$score, pass=$pass"
.claude/hooks/auto-evaluator.sh.backup:315:}
.claude/hooks/auto-evaluator.sh.backup:316:
.claude/hooks/auto-evaluator.sh.backup:317:# Get evaluation statistics
.claude/hooks/auto-evaluator.sh.backup:318:get_evaluation_stats() {
.claude/hooks/auto-evaluator.sh.backup:319:    local limit="${1:-20}"
.claude/hooks/auto-evaluator.sh.backup:320:
.claude/hooks/auto-evaluator.sh.backup:321:    if [[ ! -f "$EVAL_HISTORY" ]]; then
.claude/hooks/auto-evaluator.sh.backup:322:        echo '{"total":0,"avg_score":0,"pass_rate":0,"recent":[]}'
.claude/hooks/auto-evaluator.sh.backup:323:        return
.claude/hooks/auto-evaluator.sh.backup:324:    fi
.claude/hooks/auto-evaluator.sh.backup:325:
.claude/hooks/auto-evaluator.sh.backup:326:    local recent
.claude/hooks/auto-evaluator.sh.backup:327:    recent=$(tail -n "$limit" "$EVAL_HISTORY" | jq -s '.')
.claude/hooks/auto-evaluator.sh.backup:328:
.claude/hooks/auto-evaluator.sh.backup:329:    local stats
.claude/hooks/auto-evaluator.sh.backup:330:    stats=$(echo "$recent" | jq '{
.claude/hooks/auto-evaluator.sh.backup:331:        total: length,
.claude/hooks/auto-evaluator.sh.backup:332:        avg_score: (map(.score) | add / length),
.claude/hooks/auto-evaluator.sh.backup:333:        pass_rate: (map(select(.pass) | 1) | add // 0) / length * 100,
.claude/hooks/auto-evaluator.sh.backup:334:        recent: .[-5:]
.claude/hooks/auto-evaluator.sh.backup:335:    }')
.claude/hooks/auto-evaluator.sh.backup:336:
.claude/hooks/auto-evaluator.sh.backup:337:    echo "$stats"
.claude/hooks/auto-evaluator.sh.backup:338:}
.claude/hooks/auto-evaluator.sh.backup:339:
.claude/hooks/auto-evaluator.sh.backup:340:# Get evaluation trend (improving/declining)
.claude/hooks/auto-evaluator.sh.backup:341:get_evaluation_trend() {
.claude/hooks/auto-evaluator.sh.backup:342:    local window="${1:-10}"
.claude/hooks/auto-evaluator.sh.backup:343:
.claude/hooks/auto-evaluator.sh.backup:344:    if [[ ! -f "$EVAL_HISTORY" ]]; then
.claude/hooks/auto-evaluator.sh.backup:345:        echo '{"trend":"unknown","confidence":0}'
.claude/hooks/auto-evaluator.sh.backup:346:        return
.claude/hooks/auto-evaluator.sh.backup:347:    fi
.claude/hooks/auto-evaluator.sh.backup:348:
.claude/hooks/auto-evaluator.sh.backup:349:    local recent
.claude/hooks/auto-evaluator.sh.backup:350:    recent=$(tail -n "$((window * 2))" "$EVAL_HISTORY" | jq -s '.')
.claude/hooks/auto-evaluator.sh.backup:351:
.claude/hooks/auto-evaluator.sh.backup:352:    local trend
.claude/hooks/auto-evaluator.sh.backup:353:    trend=$(echo "$recent" | jq --argjson window "$window" '{
.claude/hooks/auto-evaluator.sh.backup:354:        first_half: .[:$window] | map(.score) | add / length,
.claude/hooks/auto-evaluator.sh.backup:355:        second_half: .[$window:] | map(.score) | add / length
.claude/hooks/auto-evaluator.sh.backup:356:    } | if .second_half > .first_half + 0.5 then
.claude/hooks/auto-evaluator.sh.backup:357:        {trend: "improving", confidence: ((.second_half - .first_half) * 10 | floor / 10)}
.claude/hooks/auto-evaluator.sh.backup:358:    elif .first_half > .second_half + 0.5 then
.claude/hooks/auto-evaluator.sh.backup:359:        {trend: "declining", confidence: ((.first_half - .second_half) * 10 | floor / 10)}
.claude/hooks/auto-evaluator.sh.backup:360:    else
.claude/hooks/auto-evaluator.sh.backup:361:        {trend: "stable", confidence: 0.5}
.claude/hooks/auto-evaluator.sh.backup:362:    end')
.claude/hooks/auto-evaluator.sh.backup:363:
.claude/hooks/auto-evaluator.sh.backup:364:    echo "$trend"
.claude/hooks/auto-evaluator.sh.backup:365:}
.claude/hooks/auto-evaluator.sh.backup:366:
.claude/hooks/auto-evaluator.sh.backup:367:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:368:# MULTI-AGENT EVALUATION (debate between evaluators)
.claude/hooks/auto-evaluator.sh.backup:369:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:370:
.claude/hooks/auto-evaluator.sh.backup:371:# Generate multiple evaluation perspectives
.claude/hooks/auto-evaluator.sh.backup:372:generate_multi_evaluator_prompt() {
.claude/hooks/auto-evaluator.sh.backup:373:    local task="$1"
.claude/hooks/auto-evaluator.sh.backup:374:    local output="$2"
.claude/hooks/auto-evaluator.sh.backup:375:    local eval_type="${3:-code}"
.claude/hooks/auto-evaluator.sh.backup:376:
.claude/hooks/auto-evaluator.sh.backup:377:    cat << EOF
.claude/hooks/auto-evaluator.sh.backup:378:{
.claude/hooks/auto-evaluator.sh.backup:379:    "evaluation_approach": "multi_agent_debate",
.claude/hooks/auto-evaluator.sh.backup:380:    "evaluators": [
.claude/hooks/auto-evaluator.sh.backup:381:        {
.claude/hooks/auto-evaluator.sh.backup:382:            "role": "optimist",
.claude/hooks/auto-evaluator.sh.backup:383:            "perspective": "Focus on strengths, what works well, and positive aspects",
.claude/hooks/auto-evaluator.sh.backup:384:            "bias_awareness": "May overlook critical flaws"
.claude/hooks/auto-evaluator.sh.backup:385:        },
.claude/hooks/auto-evaluator.sh.backup:386:        {
.claude/hooks/auto-evaluator.sh.backup:387:            "role": "critic",
.claude/hooks/auto-evaluator.sh.backup:388:            "perspective": "Focus on weaknesses, potential issues, and areas for improvement",
.claude/hooks/auto-evaluator.sh.backup:389:            "bias_awareness": "May be overly harsh and miss good aspects"
.claude/hooks/auto-evaluator.sh.backup:390:        },
.claude/hooks/auto-evaluator.sh.backup:391:        {
.claude/hooks/auto-evaluator.sh.backup:392:            "role": "pragmatist",
.claude/hooks/auto-evaluator.sh.backup:393:            "perspective": "Balance trade-offs, real-world constraints, and practical value",
.claude/hooks/auto-evaluator.sh.backup:394:            "bias_awareness": "May accept suboptimal solutions too easily"
.claude/hooks/auto-evaluator.sh.backup:395:        }
.claude/hooks/auto-evaluator.sh.backup:396:    ],
.claude/hooks/auto-evaluator.sh.backup:397:    "process": "Each evaluator assesses independently, then debate to reach consensus",
.claude/hooks/auto-evaluator.sh.backup:398:    "task": "$task",
.claude/hooks/auto-evaluator.sh.backup:399:    "output": "$output",
.claude/hooks/auto-evaluator.sh.backup:400:    "eval_type": "$eval_type"
.claude/hooks/auto-evaluator.sh.backup:401:}
.claude/hooks/auto-evaluator.sh.backup:402:EOF
.claude/hooks/auto-evaluator.sh.backup:403:}
.claude/hooks/auto-evaluator.sh.backup:404:
.claude/hooks/auto-evaluator.sh.backup:405:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:406:# COMMAND INTERFACE
.claude/hooks/auto-evaluator.sh.backup:407:# =============================================================================
.claude/hooks/auto-evaluator.sh.backup:408:
.claude/hooks/auto-evaluator.sh.backup:409:case "${1:-help}" in
.claude/hooks/auto-evaluator.sh.backup:410:    evaluate)
.claude/hooks/auto-evaluator.sh.backup:411:        # Evaluate an output
.claude/hooks/auto-evaluator.sh.backup:412:        evaluate_output "${2:-task}" "${3:-output}" "${4:-code}" "${5:-}"
.claude/hooks/auto-evaluator.sh.backup:413:        ;;
.claude/hooks/auto-evaluator.sh.backup:414:    process)
.claude/hooks/auto-evaluator.sh.backup:415:        # Process evaluation result
.claude/hooks/auto-evaluator.sh.backup:416:        process_evaluation_result "${2:-{}}" "${3:-task}"
.claude/hooks/auto-evaluator.sh.backup:417:        ;;
.claude/hooks/auto-evaluator.sh.backup:418:    criteria)
.claude/hooks/auto-evaluator.sh.backup:419:        # Get evaluation criteria
.claude/hooks/auto-evaluator.sh.backup:420:        get_evaluation_criteria "${2:-code}"
.claude/hooks/auto-evaluator.sh.backup:421:        ;;
.claude/hooks/auto-evaluator.sh.backup:422:    stats)
.claude/hooks/auto-evaluator.sh.backup:423:        # Get evaluation statistics
.claude/hooks/auto-evaluator.sh.backup:424:        get_evaluation_stats "${2:-20}"
.claude/hooks/auto-evaluator.sh.backup:425:        ;;
.claude/hooks/auto-evaluator.sh.backup:426:    trend)
.claude/hooks/auto-evaluator.sh.backup:427:        # Get evaluation trend
.claude/hooks/auto-evaluator.sh.backup:428:        get_evaluation_trend "${2:-10}"
.claude/hooks/auto-evaluator.sh.backup:429:        ;;
.claude/hooks/auto-evaluator.sh.backup:430:    multi)
.claude/hooks/auto-evaluator.sh.backup:431:        # Generate multi-evaluator prompt
.claude/hooks/auto-evaluator.sh.backup:432:        generate_multi_evaluator_prompt "${2:-task}" "${3:-output}" "${4:-code}"
.claude/hooks/auto-evaluator.sh.backup:433:        ;;
.claude/hooks/auto-evaluator.sh.backup:434:    clear-history)
.claude/hooks/auto-evaluator.sh.backup:435:        # Clear evaluation history
.claude/hooks/auto-evaluator.sh.backup:436:        > "$EVAL_HISTORY"
.claude/hooks/auto-evaluator.sh.backup:437:        echo '{"status":"history_cleared"}'
.claude/hooks/auto-evaluator.sh.backup:438:        ;;
.claude/hooks/auto-evaluator.sh.backup:439:    help|*)
.claude/hooks/auto-evaluator.sh.backup:440:        echo "LLM-as-Judge Auto-Evaluator - Real-time Quality Assessment"
.claude/hooks/auto-evaluator.sh.backup:441:        echo ""
.claude/hooks/auto-evaluator.sh.backup:442:        echo "Usage: $0 <command> [args]"
.claude/hooks/auto-evaluator.sh.backup:443:        echo ""
.claude/hooks/auto-evaluator.sh.backup:444:        echo "Evaluation:"
.claude/hooks/auto-evaluator.sh.backup:445:        echo "  evaluate <task> <output> [type] [context]"
.claude/hooks/auto-evaluator.sh.backup:446:        echo "                                     - Generate evaluation prompt"
.claude/hooks/auto-evaluator.sh.backup:447:        echo "  process <eval_result> <task>       - Process evaluation and decide action"
.claude/hooks/auto-evaluator.sh.backup:448:        echo "  criteria [type]                    - Get evaluation criteria"
.claude/hooks/auto-evaluator.sh.backup:449:        echo "                                       Types: code, documentation, test, general"
.claude/hooks/auto-evaluator.sh.backup:450:        echo ""
.claude/hooks/auto-evaluator.sh.backup:451:        echo "Analytics:"
.claude/hooks/auto-evaluator.sh.backup:452:        echo "  stats [limit]                      - Get evaluation statistics"
.claude/hooks/auto-evaluator.sh.backup:453:        echo "  trend [window]                     - Get evaluation trend"
.claude/hooks/auto-evaluator.sh.backup:454:        echo ""
.claude/hooks/auto-evaluator.sh.backup:455:        echo "Advanced:"
.claude/hooks/auto-evaluator.sh.backup:456:        echo "  multi <task> <output> [type]       - Multi-agent debate evaluation"
.claude/hooks/auto-evaluator.sh.backup:457:        echo "  clear-history                      - Clear evaluation history"
.claude/hooks/auto-evaluator.sh.backup:458:        echo ""
.claude/hooks/auto-evaluator.sh.backup:459:        echo "Example workflow:"
.claude/hooks/auto-evaluator.sh.backup:460:        echo "  1. eval_prompt=\$($0 evaluate 'fix bug' 'code...' 'code' 'auth module')"
.claude/hooks/auto-evaluator.sh.backup:461:        echo "  2. [Send eval_prompt to Claude, get result]"
.claude/hooks/auto-evaluator.sh.backup:462:        echo "  3. action=\$($0 process \"\$result\" 'fix bug')"
.claude/hooks/auto-evaluator.sh.backup:463:        echo "  4. [If action=revise, retry with improvements]"
.claude/hooks/auto-evaluator.sh.backup:464:        echo ""
.claude/hooks/auto-evaluator.sh.backup:465:        echo "Quality Thresholds:"
.claude/hooks/auto-evaluator.sh.backup:466:        echo "  - Score >= 7.0: Pass (continue)"
.claude/hooks/auto-evaluator.sh.backup:467:        echo "  - Score < 7.0: Revise (improve and retry)"
.claude/hooks/auto-evaluator.sh.backup:468:        echo "  - Critical issues: Always revise"
.claude/hooks/auto-evaluator.sh.backup:469:        ;;
.claude/hooks/auto-evaluator.sh.backup:470:esac
.claude/hooks/error-handler.sh:1:#!/bin/bash
.claude/hooks/error-handler.sh:2:# Enhanced Error Handler - Smart retry with backoff and error classification
.claude/hooks/error-handler.sh:3:# Based on patterns from: Discord.js, Cypress, Uniswap, neo4j, midday-ai
.claude/hooks/error-handler.sh:4:
.claude/hooks/error-handler.sh:5:set -euo pipefail
.claude/hooks/error-handler.sh:6:
.claude/hooks/error-handler.sh:7:LOG_FILE="${HOME}/.claude/error-handler.log"
.claude/hooks/error-handler.sh:8:DEBUG_LOG=".claude/docs/debug-log.md"
.claude/hooks/error-handler.sh:9:
.claude/hooks/error-handler.sh:10:log() {
.claude/hooks/error-handler.sh:11:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/error-handler.sh:12:}
.claude/hooks/error-handler.sh:13:
.claude/hooks/error-handler.sh:14:# Error Classification (from neo4j/midday-ai patterns)
.claude/hooks/error-handler.sh:15:classify_error() {
.claude/hooks/error-handler.sh:16:    local error_msg="$1"
.claude/hooks/error-handler.sh:17:
.claude/hooks/error-handler.sh:18:    # Transient errors - should retry
.claude/hooks/error-handler.sh:19:    if echo "$error_msg" | grep -qiE "timeout|ETIMEDOUT|ECONNRESET|ECONNREFUSED|network|socket hang up|ENOTFOUND|503|502|504"; then
.claude/hooks/error-handler.sh:20:        echo "TRANSIENT"
.claude/hooks/error-handler.sh:21:        return
.claude/hooks/error-handler.sh:22:    fi
.claude/hooks/error-handler.sh:23:
.claude/hooks/error-handler.sh:24:    # Rate limit errors - should retry with longer backoff
.claude/hooks/error-handler.sh:25:    if echo "$error_msg" | grep -qiE "rate.?limit|429|too many requests|quota exceeded"; then
.claude/hooks/error-handler.sh:26:        echo "RATE_LIMIT"
.claude/hooks/error-handler.sh:27:        return
.claude/hooks/error-handler.sh:28:    fi
.claude/hooks/error-handler.sh:29:
.claude/hooks/error-handler.sh:30:    # Client errors - should NOT retry (fix needed)
.claude/hooks/error-handler.sh:31:    if echo "$error_msg" | grep -qiE "syntax.?error|type.?error|reference.?error|400|401|403|404|validation|invalid"; then
.claude/hooks/error-handler.sh:32:        echo "CLIENT_ERROR"
.claude/hooks/error-handler.sh:33:        return
.claude/hooks/error-handler.sh:34:    fi
.claude/hooks/error-handler.sh:35:
.claude/hooks/error-handler.sh:36:    # Build/compile errors - should NOT retry (fix needed)
.claude/hooks/error-handler.sh:37:    if echo "$error_msg" | grep -qiE "cannot find|not found|undefined|null|compilation|build failed|lint|typecheck"; then
.claude/hooks/error-handler.sh:38:        echo "BUILD_ERROR"
.claude/hooks/error-handler.sh:39:        return
.claude/hooks/error-handler.sh:40:    fi
.claude/hooks/error-handler.sh:41:
.claude/hooks/error-handler.sh:42:    # Database errors - may retry
.claude/hooks/error-handler.sh:43:    if echo "$error_msg" | grep -qiE "database|postgres|mysql|sqlite|connection|deadlock"; then
.claude/hooks/error-handler.sh:44:        echo "DATABASE_ERROR"
.claude/hooks/error-handler.sh:45:        return
.claude/hooks/error-handler.sh:46:    fi
.claude/hooks/error-handler.sh:47:
.claude/hooks/error-handler.sh:48:    echo "UNKNOWN"
.claude/hooks/error-handler.sh:49:}
.claude/hooks/error-handler.sh:50:
.claude/hooks/error-handler.sh:51:# Determine if error should trigger retry (from Discord.js/Uniswap patterns)
.claude/hooks/error-handler.sh:52:should_retry() {
.claude/hooks/error-handler.sh:53:    local classification="$1"
.claude/hooks/error-handler.sh:54:    local attempt="$2"
.claude/hooks/error-handler.sh:55:    local max_retries="${3:-3}"
.claude/hooks/error-handler.sh:56:
.claude/hooks/error-handler.sh:57:    if [[ $attempt -ge $max_retries ]]; then
.claude/hooks/error-handler.sh:58:        echo "false"
.claude/hooks/error-handler.sh:59:        return
.claude/hooks/error-handler.sh:60:    fi
.claude/hooks/error-handler.sh:61:
.claude/hooks/error-handler.sh:62:    case "$classification" in
.claude/hooks/error-handler.sh:63:        TRANSIENT|RATE_LIMIT|DATABASE_ERROR)
.claude/hooks/error-handler.sh:64:            echo "true"
.claude/hooks/error-handler.sh:65:            ;;
.claude/hooks/error-handler.sh:66:        CLIENT_ERROR|BUILD_ERROR)
.claude/hooks/error-handler.sh:67:            echo "false"
.claude/hooks/error-handler.sh:68:            ;;
.claude/hooks/error-handler.sh:69:        UNKNOWN)
.claude/hooks/error-handler.sh:70:            # Retry unknown errors once
.claude/hooks/error-handler.sh:71:            if [[ $attempt -lt 1 ]]; then
.claude/hooks/error-handler.sh:72:                echo "true"
.claude/hooks/error-handler.sh:73:            else
.claude/hooks/error-handler.sh:74:                echo "false"
.claude/hooks/error-handler.sh:75:            fi
.claude/hooks/error-handler.sh:76:            ;;
.claude/hooks/error-handler.sh:77:        *)
.claude/hooks/error-handler.sh:78:            echo "false"
.claude/hooks/error-handler.sh:79:            ;;
.claude/hooks/error-handler.sh:80:    esac
.claude/hooks/error-handler.sh:81:}
.claude/hooks/error-handler.sh:82:
.claude/hooks/error-handler.sh:83:# Calculate retry delay with exponential backoff (from Cypress/Uniswap patterns)
.claude/hooks/error-handler.sh:84:calculate_backoff() {
.claude/hooks/error-handler.sh:85:    local attempt="$1"
.claude/hooks/error-handler.sh:86:    local classification="$2"
.claude/hooks/error-handler.sh:87:    local base_delay=1000  # 1 second
.claude/hooks/error-handler.sh:88:    local max_delay=30000  # 30 seconds
.claude/hooks/error-handler.sh:89:
.claude/hooks/error-handler.sh:90:    # Rate limits get longer backoff
.claude/hooks/error-handler.sh:91:    if [[ "$classification" == "RATE_LIMIT" ]]; then
.claude/hooks/error-handler.sh:92:        base_delay=5000
.claude/hooks/error-handler.sh:93:        max_delay=60000
.claude/hooks/error-handler.sh:94:    fi
.claude/hooks/error-handler.sh:95:
.claude/hooks/error-handler.sh:96:    # Exponential backoff: base * 2^attempt
.claude/hooks/error-handler.sh:97:    local delay=$((base_delay * (2 ** attempt)))
.claude/hooks/error-handler.sh:98:
.claude/hooks/error-handler.sh:99:    # Cap at max delay
.claude/hooks/error-handler.sh:100:    if [[ $delay -gt $max_delay ]]; then
.claude/hooks/error-handler.sh:101:        delay=$max_delay
.claude/hooks/error-handler.sh:102:    fi
.claude/hooks/error-handler.sh:103:
.claude/hooks/error-handler.sh:104:    echo $delay
.claude/hooks/error-handler.sh:105:}
.claude/hooks/error-handler.sh:106:
.claude/hooks/error-handler.sh:107:# Parse error message to extract key info (from Continue/Novu patterns)
.claude/hooks/error-handler.sh:108:parse_error() {
.claude/hooks/error-handler.sh:109:    local error_msg="$1"
.claude/hooks/error-handler.sh:110:
.claude/hooks/error-handler.sh:111:    # Extract file:line if present
.claude/hooks/error-handler.sh:112:    local file_line=$(echo "$error_msg" | grep -oE '[a-zA-Z0-9_/.-]+\.(ts|js|tsx|jsx|py|go|rs):[0-9]+' | head -1 || echo "")
.claude/hooks/error-handler.sh:113:
.claude/hooks/error-handler.sh:114:    # Extract error code if present
.claude/hooks/error-handler.sh:115:    local error_code=$(echo "$error_msg" | grep -oE '(E[0-9]+|TS[0-9]+|error\[[a-zA-Z0-9_]+\])' | head -1 || echo "")
.claude/hooks/error-handler.sh:116:
.claude/hooks/error-handler.sh:117:    # Extract the core error message (first meaningful line)
.claude/hooks/error-handler.sh:118:    local core_msg=$(echo "$error_msg" | head -5 | grep -iE "error|failed|cannot|invalid" | head -1 || echo "$error_msg" | head -1)
.claude/hooks/error-handler.sh:119:
.claude/hooks/error-handler.sh:120:    echo "FILE_LINE=$file_line"
.claude/hooks/error-handler.sh:121:    echo "ERROR_CODE=$error_code"
.claude/hooks/error-handler.sh:122:    echo "CORE_MSG=$core_msg"
.claude/hooks/error-handler.sh:123:}
.claude/hooks/error-handler.sh:124:
.claude/hooks/error-handler.sh:125:# Log error to debug-log.md with classification
.claude/hooks/error-handler.sh:126:log_error_to_debug() {
.claude/hooks/error-handler.sh:127:    local error_msg="$1"
.claude/hooks/error-handler.sh:128:    local classification="$2"
.claude/hooks/error-handler.sh:129:    local attempt="$3"
.claude/hooks/error-handler.sh:130:    local context="${4:-}"
.claude/hooks/error-handler.sh:131:
.claude/hooks/error-handler.sh:132:    mkdir -p .claude/docs 2>/dev/null || true
.claude/hooks/error-handler.sh:133:
.claude/hooks/error-handler.sh:134:    # Create debug-log if doesn't exist
.claude/hooks/error-handler.sh:135:    if [[ ! -f "$DEBUG_LOG" ]]; then
.claude/hooks/error-handler.sh:136:        cat > "$DEBUG_LOG" << 'EOFLOG'
.claude/hooks/error-handler.sh:137:# Debug Log
.claude/hooks/error-handler.sh:138:
.claude/hooks/error-handler.sh:139:## Active Issues
.claude/hooks/error-handler.sh:140:
.claude/hooks/error-handler.sh:141:## Session Log
.claude/hooks/error-handler.sh:142:
.claude/hooks/error-handler.sh:143:---
.claude/hooks/error-handler.sh:144:
.claude/hooks/error-handler.sh:145:## Resolved Issues
.claude/hooks/error-handler.sh:146:
.claude/hooks/error-handler.sh:147:## Patterns Discovered
.claude/hooks/error-handler.sh:148:
.claude/hooks/error-handler.sh:149:## Research Cache
.claude/hooks/error-handler.sh:150:EOFLOG
.claude/hooks/error-handler.sh:151:    fi
.claude/hooks/error-handler.sh:152:
.claude/hooks/error-handler.sh:153:    # Extract file:line if present
.claude/hooks/error-handler.sh:154:    local file_line
.claude/hooks/error-handler.sh:155:    file_line=$(echo "$error_msg" | grep -oE '[a-zA-Z0-9_/.-]+\.(ts|js|tsx|jsx|py|go|rs):[0-9]+' | head -1 2>/dev/null || echo "unknown")
.claude/hooks/error-handler.sh:156:
.claude/hooks/error-handler.sh:157:    # Extract error code if present
.claude/hooks/error-handler.sh:158:    local error_code
.claude/hooks/error-handler.sh:159:    error_code=$(echo "$error_msg" | grep -oE '(E[0-9]+|TS[0-9]+)' | head -1 2>/dev/null || echo "none")
.claude/hooks/error-handler.sh:160:
.claude/hooks/error-handler.sh:161:    local timestamp
.claude/hooks/error-handler.sh:162:    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
.claude/hooks/error-handler.sh:163:
.claude/hooks/error-handler.sh:164:    local retry_status
.claude/hooks/error-handler.sh:165:    retry_status=$(should_retry "$classification" "$attempt")
.claude/hooks/error-handler.sh:166:
.claude/hooks/error-handler.sh:167:    # Append to debug log (simpler than sed insertion)
.claude/hooks/error-handler.sh:168:    cat >> "$DEBUG_LOG" << EOFENTRY
.claude/hooks/error-handler.sh:169:
.claude/hooks/error-handler.sh:170:### Issue: $classification (Attempt $attempt)
.claude/hooks/error-handler.sh:171:**Time**: $timestamp
.claude/hooks/error-handler.sh:172:**Classification**: $classification
.claude/hooks/error-handler.sh:173:**File**: $file_line
.claude/hooks/error-handler.sh:174:**Code**: $error_code
.claude/hooks/error-handler.sh:175:**Error**: \`$error_msg\`
.claude/hooks/error-handler.sh:176:**Context**: ${context:-none}
.claude/hooks/error-handler.sh:177:**Retryable**: $retry_status
.claude/hooks/error-handler.sh:178:EOFENTRY
.claude/hooks/error-handler.sh:179:
.claude/hooks/error-handler.sh:180:    log "Logged $classification error (attempt $attempt)"
.claude/hooks/error-handler.sh:181:}
.claude/hooks/error-handler.sh:182:
.claude/hooks/error-handler.sh:183:# Main handler - called from other hooks/scripts
.claude/hooks/error-handler.sh:184:handle_error() {
.claude/hooks/error-handler.sh:185:    local error_msg="${1:-}"
.claude/hooks/error-handler.sh:186:    local attempt="${2:-0}"
.claude/hooks/error-handler.sh:187:    local max_retries="${3:-3}"
.claude/hooks/error-handler.sh:188:    local context="${4:-}"
.claude/hooks/error-handler.sh:189:    local test_command="${5:-}"  # Optional test command for regression detection
.claude/hooks/error-handler.sh:190:
.claude/hooks/error-handler.sh:191:    local classification
.claude/hooks/error-handler.sh:192:    classification=$(classify_error "$error_msg")
.claude/hooks/error-handler.sh:193:
.claude/hooks/error-handler.sh:194:    # ============================================================================
.claude/hooks/error-handler.sh:195:    # DEBUG ORCHESTRATOR: SMART-DEBUG (Before Fix)
.claude/hooks/error-handler.sh:196:    # ============================================================================
.claude/hooks/error-handler.sh:197:    local snapshot_id=""
.claude/hooks/error-handler.sh:198:    local debug_suggestions=""
.claude/hooks/error-handler.sh:199:    local DEBUG_ORCHESTRATOR="${HOME}/.claude/hooks/debug-orchestrator.sh"
.claude/hooks/error-handler.sh:200:
.claude/hooks/error-handler.sh:201:    if [[ -x "$DEBUG_ORCHESTRATOR" && "$attempt" -eq 0 ]]; then
.claude/hooks/error-handler.sh:202:        log " Running smart-debug before fix attempt..."
.claude/hooks/error-handler.sh:203:
.claude/hooks/error-handler.sh:204:        # Create before snapshot and search for similar bugs
.claude/hooks/error-handler.sh:205:        local debug_info
.claude/hooks/error-handler.sh:206:        debug_info=$("$DEBUG_ORCHESTRATOR" smart-debug \
.claude/hooks/error-handler.sh:207:            "$error_msg" \
.claude/hooks/error-handler.sh:208:            "$classification" \
.claude/hooks/error-handler.sh:209:            "$test_command" \
.claude/hooks/error-handler.sh:210:            "$context" 2>/dev/null || echo "{}")
.claude/hooks/error-handler.sh:211:
.claude/hooks/error-handler.sh:212:        snapshot_id=$(echo "$debug_info" | jq -r '.snapshot_id // ""' 2>/dev/null || echo "")
.claude/hooks/error-handler.sh:213:        debug_suggestions=$(echo "$debug_info" | jq -r '.suggestions // []' 2>/dev/null || echo "[]")
.claude/hooks/error-handler.sh:214:        local similar_count=$(echo "$debug_suggestions" | jq 'length' 2>/dev/null || echo "0")
.claude/hooks/error-handler.sh:215:
.claude/hooks/error-handler.sh:216:        if [[ -n "$snapshot_id" ]]; then
.claude/hooks/error-handler.sh:217:            log " Debug snapshot created: $snapshot_id"
.claude/hooks/error-handler.sh:218:        fi
.claude/hooks/error-handler.sh:219:
.claude/hooks/error-handler.sh:220:        if [[ "$similar_count" -gt 0 ]]; then
.claude/hooks/error-handler.sh:221:            log " Found $similar_count similar bug fixes in memory"
.claude/hooks/error-handler.sh:222:        fi
.claude/hooks/error-handler.sh:223:    fi
.claude/hooks/error-handler.sh:224:    # ============================================================================
.claude/hooks/error-handler.sh:225:
.claude/hooks/error-handler.sh:226:    # NEW: Query memory for known fixes BEFORE deciding to retry
.claude/hooks/error-handler.sh:227:    local known_fix=""
.claude/hooks/error-handler.sh:228:    local MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/error-handler.sh:229:    if [[ -x "$MEMORY_MANAGER" && "$attempt" -eq 0 ]]; then
.claude/hooks/error-handler.sh:230:        local patterns
.claude/hooks/error-handler.sh:231:        patterns=$("$MEMORY_MANAGER" find-patterns "$error_msg" 3 2>/dev/null || echo "[]")
.claude/hooks/error-handler.sh:232:
.claude/hooks/error-handler.sh:233:        if [[ -n "$patterns" && "$patterns" != "[]" && "$patterns" != "null" ]]; then
.claude/hooks/error-handler.sh:234:            # Get the best matching pattern
.claude/hooks/error-handler.sh:235:            known_fix=$(echo "$patterns" | jq -r '.[0].solution // empty' 2>/dev/null || echo "")
.claude/hooks/error-handler.sh:236:
.claude/hooks/error-handler.sh:237:            if [[ -n "$known_fix" && "$known_fix" != "null" ]]; then
.claude/hooks/error-handler.sh:238:                log "Found known fix in memory: $known_fix"
.claude/hooks/error-handler.sh:239:
.claude/hooks/error-handler.sh:240:                # Return the fix suggestion
.claude/hooks/error-handler.sh:241:                jq -n \
.claude/hooks/error-handler.sh:242:                    --arg classification "$classification" \
.claude/hooks/error-handler.sh:243:                    --arg fix "$known_fix" \
.claude/hooks/error-handler.sh:244:                    --arg error "$error_msg" \
.claude/hooks/error-handler.sh:245:                    '{
.claude/hooks/error-handler.sh:246:                        classification: $classification,
.claude/hooks/error-handler.sh:247:                        shouldRetry: false,
.claude/hooks/error-handler.sh:248:                        hasKnownFix: true,
.claude/hooks/error-handler.sh:249:                        knownFix: $fix,
.claude/hooks/error-handler.sh:250:                        recommendation: "Apply known fix from memory",
.claude/hooks/error-handler.sh:251:                        error: $error
.claude/hooks/error-handler.sh:252:                    }'
.claude/hooks/error-handler.sh:253:                return
.claude/hooks/error-handler.sh:254:            fi
.claude/hooks/error-handler.sh:255:        fi
.claude/hooks/error-handler.sh:256:    fi
.claude/hooks/error-handler.sh:257:
.claude/hooks/error-handler.sh:258:    local retry
.claude/hooks/error-handler.sh:259:    retry=$(should_retry "$classification" "$attempt" "$max_retries")
.claude/hooks/error-handler.sh:260:
.claude/hooks/error-handler.sh:261:    local backoff
.claude/hooks/error-handler.sh:262:    backoff=$(calculate_backoff "$attempt" "$classification")
.claude/hooks/error-handler.sh:263:
.claude/hooks/error-handler.sh:264:    # Log to debug-log.md
.claude/hooks/error-handler.sh:265:    log_error_to_debug "$error_msg" "$classification" "$attempt" "$context"
.claude/hooks/error-handler.sh:266:
.claude/hooks/error-handler.sh:267:    # Output JSON for caller
.claude/hooks/error-handler.sh:268:    jq -n \
.claude/hooks/error-handler.sh:269:        --arg classification "$classification" \
.claude/hooks/error-handler.sh:270:        --arg retry "$retry" \
.claude/hooks/error-handler.sh:271:        --argjson backoff "$backoff" \
.claude/hooks/error-handler.sh:272:        --argjson attempt "$attempt" \
.claude/hooks/error-handler.sh:273:        --arg error "$error_msg" \
.claude/hooks/error-handler.sh:274:        '{
.claude/hooks/error-handler.sh:275:            classification: $classification,
.claude/hooks/error-handler.sh:276:            shouldRetry: ($retry == "true"),
.claude/hooks/error-handler.sh:277:            backoffMs: $backoff,
.claude/hooks/error-handler.sh:278:            attempt: $attempt,
.claude/hooks/error-handler.sh:279:            error: $error,
.claude/hooks/error-handler.sh:280:            hasKnownFix: false
.claude/hooks/error-handler.sh:281:        }'
.claude/hooks/error-handler.sh:282:}
.claude/hooks/error-handler.sh:283:
.claude/hooks/error-handler.sh:284:# NEW: Record successful fix to memory
.claude/hooks/error-handler.sh:285:record_fix_to_memory() {
.claude/hooks/error-handler.sh:286:    local error_msg="$1"
.claude/hooks/error-handler.sh:287:    local fix_applied="$2"
.claude/hooks/error-handler.sh:288:
.claude/hooks/error-handler.sh:289:    local MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/error-handler.sh:290:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/error-handler.sh:291:        "$MEMORY_MANAGER" add-pattern "error_fix" "$error_msg" "$fix_applied" 1.0 2>/dev/null || true
.claude/hooks/error-handler.sh:292:        log "Recorded successful fix to memory"
.claude/hooks/error-handler.sh:293:    fi
.claude/hooks/error-handler.sh:294:}
.claude/hooks/error-handler.sh:295:
.claude/hooks/error-handler.sh:296:# NEW: Verify fix and detect regressions (Debug Orchestrator integration)
.claude/hooks/error-handler.sh:297:verify_fix_no_regressions() {
.claude/hooks/error-handler.sh:298:    local snapshot_id="$1"
.claude/hooks/error-handler.sh:299:    local test_command="$2"
.claude/hooks/error-handler.sh:300:    local fix_description="$3"
.claude/hooks/error-handler.sh:301:    local error_type="$4"
.claude/hooks/error-handler.sh:302:    local error_msg="$5"
.claude/hooks/error-handler.sh:303:
.claude/hooks/error-handler.sh:304:    local DEBUG_ORCHESTRATOR="${HOME}/.claude/hooks/debug-orchestrator.sh"
.claude/hooks/error-handler.sh:305:
.claude/hooks/error-handler.sh:306:    if [[ -x "$DEBUG_ORCHESTRATOR" && -n "$snapshot_id" ]]; then
.claude/hooks/error-handler.sh:307:        log " Running verify-fix to check for regressions..."
.claude/hooks/error-handler.sh:308:
.claude/hooks/error-handler.sh:309:        # Create after snapshot and compare with before
.claude/hooks/error-handler.sh:310:        local verification
.claude/hooks/error-handler.sh:311:        verification=$("$DEBUG_ORCHESTRATOR" verify-fix \
.claude/hooks/error-handler.sh:312:            "$snapshot_id" \
.claude/hooks/error-handler.sh:313:            "$test_command" \
.claude/hooks/error-handler.sh:314:            "$fix_description" 2>/dev/null || echo "{}")
.claude/hooks/error-handler.sh:315:
.claude/hooks/error-handler.sh:316:        local regressions=$(echo "$verification" | jq -r '.regressions_detected // false' 2>/dev/null || echo "false")
.claude/hooks/error-handler.sh:317:
.claude/hooks/error-handler.sh:318:        if [[ "$regressions" == "true" ]]; then
.claude/hooks/error-handler.sh:319:            local regression_list=$(echo "$verification" | jq -r '.regressions[]' 2>/dev/null || echo "")
.claude/hooks/error-handler.sh:320:            log "  REGRESSION DETECTED after fix!"
.claude/hooks/error-handler.sh:321:            log "Regressions: $regression_list"
.claude/hooks/error-handler.sh:322:
.claude/hooks/error-handler.sh:323:            # Return regression detected
.claude/hooks/error-handler.sh:324:            echo "REGRESSION_DETECTED:$regression_list"
.claude/hooks/error-handler.sh:325:            return 1
.claude/hooks/error-handler.sh:326:        else
.claude/hooks/error-handler.sh:327:            log " No regressions detected - fix is clean"
.claude/hooks/error-handler.sh:328:
.claude/hooks/error-handler.sh:329:            # Record successful fix to bug fix memory
.claude/hooks/error-handler.sh:330:            "$DEBUG_ORCHESTRATOR" record-fix "$error_type" "$error_msg" "$fix_description" "success" 2>/dev/null || true
.claude/hooks/error-handler.sh:331:            log " Recorded successful fix to bug fix memory"
.claude/hooks/error-handler.sh:332:
.claude/hooks/error-handler.sh:333:            return 0
.claude/hooks/error-handler.sh:334:        fi
.claude/hooks/error-handler.sh:335:    fi
.claude/hooks/error-handler.sh:336:
.claude/hooks/error-handler.sh:337:    return 0  # If no debug orchestrator, assume no regressions
.claude/hooks/error-handler.sh:338:}
.claude/hooks/error-handler.sh:339:
.claude/hooks/error-handler.sh:340:# Command interface
.claude/hooks/error-handler.sh:341:case "${1:-}" in
.claude/hooks/error-handler.sh:342:    handle)
.claude/hooks/error-handler.sh:343:        handle_error "${2:-}" "${3:-0}" "${4:-3}" "${5:-}"
.claude/hooks/error-handler.sh:344:        ;;
.claude/hooks/error-handler.sh:345:    record-fix)
.claude/hooks/error-handler.sh:346:        record_fix_to_memory "${2:-}" "${3:-}"
.claude/hooks/error-handler.sh:347:        ;;
.claude/hooks/error-handler.sh:348:    *)
.claude/hooks/error-handler.sh:349:        # Backward compatibility: if called directly with error message
.claude/hooks/error-handler.sh:350:        if [[ $# -gt 0 && "$1" != "handle" && "$1" != "record-fix" ]]; then
.claude/hooks/error-handler.sh:351:            handle_error "$1" "${2:-0}" "${3:-3}" "${4:-}"
.claude/hooks/error-handler.sh:352:        fi
.claude/hooks/error-handler.sh:353:        ;;
.claude/hooks/error-handler.sh:354:esac
.claude/hooks/.claude/health.json:1:{
.claude/hooks/.claude/health.json:2:    "status": "healthy",
.claude/hooks/.claude/health.json:3:    "timestamp": "2026-01-12T17:48:10Z",
.claude/hooks/.claude/health.json:4:    "issues": [],
.claude/hooks/.claude/health.json:5:    "checks": {
.claude/hooks/.claude/health.json:6:        "stuck_issues": 0,
.claude/hooks/.claude/health.json:7:        "circuits_open": 0,
.claude/hooks/.claude/health.json:8:        "recent_errors": 0
.claude/hooks/.claude/health.json:9:    }
.claude/hooks/.claude/health.json:10:}
.claude/hooks/on-command.sh:1:#!/bin/bash
.claude/hooks/on-command.sh:2:# Custom command hook for clauded
.claude/hooks/on-command.sh:3:# Adds /models command to show interactive picker
.claude/hooks/on-command.sh:4:
.claude/hooks/on-command.sh:5:COMMAND="$1"
.claude/hooks/on-command.sh:6:shift
.claude/hooks/on-command.sh:7:ARGS="$@"
.claude/hooks/on-command.sh:8:
.claude/hooks/on-command.sh:9:case "$COMMAND" in
.claude/hooks/on-command.sh:10:  models)
.claude/hooks/on-command.sh:11:    echo ""
.claude/hooks/on-command.sh:12:    echo ""
.claude/hooks/on-command.sh:13:    echo "              Available Models - Quick Shortcuts               "
.claude/hooks/on-command.sh:14:    echo ""
.claude/hooks/on-command.sh:15:    echo ""
.claude/hooks/on-command.sh:16:    echo " ONE-COMMAND SHORTCUTS (no typing, no wasted credits!):"
.claude/hooks/on-command.sh:17:    echo ""
.claude/hooks/on-command.sh:18:    echo "GLM (Free):"
.claude/hooks/on-command.sh:19:    echo "  /glm              - GLM-4 (most capable)"
.claude/hooks/on-command.sh:20:    echo "  /glm-flash        - GLM-4-Flash (fastest)"
.claude/hooks/on-command.sh:21:    echo "  /glm-air          - GLM-4-Air (balanced)"
.claude/hooks/on-command.sh:22:    echo ""
.claude/hooks/on-command.sh:23:    echo "Featherless (Uncensored):"
.claude/hooks/on-command.sh:24:    echo "  /featherless      - Llama-3-8B (abliterated)"
.claude/hooks/on-command.sh:25:    echo "  /featherless-70b  - Llama-3-70B (larger, abliterated)"
.claude/hooks/on-command.sh:26:    echo ""
.claude/hooks/on-command.sh:27:    echo "Google:"
.claude/hooks/on-command.sh:28:    echo "  /gemini           - Gemini Pro"
.claude/hooks/on-command.sh:29:    echo "  /gemini-flash     - Gemini 2.0 Flash"
.claude/hooks/on-command.sh:30:    echo ""
.claude/hooks/on-command.sh:31:    echo "Anthropic:"
.claude/hooks/on-command.sh:32:    echo "  /sonnet           - Claude Sonnet 4.5 (default)"
.claude/hooks/on-command.sh:33:    echo ""
.claude/hooks/on-command.sh:34:    echo ""
.claude/hooks/on-command.sh:35:    echo "Just type the shortcut command - switches instantly!"
.claude/hooks/on-command.sh:36:    echo ""
.claude/hooks/on-command.sh:37:    exit 0
.claude/hooks/on-command.sh:38:    ;;
.claude/hooks/on-command.sh:39:esac
.claude/hooks/on-command.sh:40:
.claude/hooks/on-command.sh:41:# Let other commands pass through
.claude/hooks/on-command.sh:42:exit 1
.claude/hooks/auto-evaluator.sh:1:#!/bin/bash
.claude/hooks/auto-evaluator.sh:2:# LLM-as-Judge Auto-Evaluator - Simplified with proper JSON
.claude/hooks/auto-evaluator.sh:3:set -eo pipefail
.claude/hooks/auto-evaluator.sh:4:
.claude/hooks/auto-evaluator.sh:5:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/auto-evaluator.sh:6:EVAL_HISTORY="${CLAUDE_DIR}/.evaluator/history.jsonl"
.claude/hooks/auto-evaluator.sh:7:LOG_FILE="${CLAUDE_DIR}/auto-evaluator.log"
.claude/hooks/auto-evaluator.sh:8:
.claude/hooks/auto-evaluator.sh:9:mkdir -p "$(dirname "$EVAL_HISTORY")"
.claude/hooks/auto-evaluator.sh:10:
.claude/hooks/auto-evaluator.sh:11:log() {
.claude/hooks/auto-evaluator.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/auto-evaluator.sh:13:}
.claude/hooks/auto-evaluator.sh:14:
.claude/hooks/auto-evaluator.sh:15:# Get evaluation criteria
.claude/hooks/auto-evaluator.sh:16:get_evaluation_criteria() {
.claude/hooks/auto-evaluator.sh:17:    local eval_type="${1:-code}"
.claude/hooks/auto-evaluator.sh:18:    
.claude/hooks/auto-evaluator.sh:19:    case "$eval_type" in
.claude/hooks/auto-evaluator.sh:20:        code)
.claude/hooks/auto-evaluator.sh:21:            echo '{"criteria":{"correctness":{"description":"Solves problem correctly","weight":0.30},"quality":{"description":"Well-written and maintainable","weight":0.25},"safety":{"description":"Avoids vulnerabilities","weight":0.20},"efficiency":{"description":"Performant","weight":0.15},"completeness":{"description":"Handles edge cases","weight":0.10}},"scale":"1-10","pass_threshold":7.0}'
.claude/hooks/auto-evaluator.sh:22:            ;;
.claude/hooks/auto-evaluator.sh:23:        test)
.claude/hooks/auto-evaluator.sh:24:            echo '{"criteria":{"coverage":{"description":"Tests all scenarios","weight":0.35},"correctness":{"description":"Assertions are correct","weight":0.30},"maintainability":{"description":"Test code is clear","weight":0.20},"isolation":{"description":"Properly isolated","weight":0.15}},"scale":"1-10","pass_threshold":7.0}'
.claude/hooks/auto-evaluator.sh:25:            ;;
.claude/hooks/auto-evaluator.sh:26:        *)
.claude/hooks/auto-evaluator.sh:27:            echo '{"criteria":{"quality":{"description":"Overall quality","weight":0.50},"correctness":{"description":"Meets requirements","weight":0.30},"completeness":{"description":"Complete and thorough","weight":0.20}},"scale":"1-10","pass_threshold":7.0}'
.claude/hooks/auto-evaluator.sh:28:            ;;
.claude/hooks/auto-evaluator.sh:29:    esac
.claude/hooks/auto-evaluator.sh:30:}
.claude/hooks/auto-evaluator.sh:31:
.claude/hooks/auto-evaluator.sh:32:# Generate evaluation prompt - returns plain text prompt for Claude
.claude/hooks/auto-evaluator.sh:33:evaluate_output() {
.claude/hooks/auto-evaluator.sh:34:    local task="$1"
.claude/hooks/auto-evaluator.sh:35:    local output="$2"
.claude/hooks/auto-evaluator.sh:36:    local eval_type="${3:-code}"
.claude/hooks/auto-evaluator.sh:37:    
.claude/hooks/auto-evaluator.sh:38:    log "Generating evaluation prompt for: $task"
.claude/hooks/auto-evaluator.sh:39:    
.claude/hooks/auto-evaluator.sh:40:    local criteria
.claude/hooks/auto-evaluator.sh:41:    criteria=$(get_evaluation_criteria "$eval_type")
.claude/hooks/auto-evaluator.sh:42:    
.claude/hooks/auto-evaluator.sh:43:    echo "EVALUATION REQUEST: Evaluate this $eval_type output for task: $task"
.claude/hooks/auto-evaluator.sh:44:    echo ""
.claude/hooks/auto-evaluator.sh:45:    echo "OUTPUT TO EVALUATE:"
.claude/hooks/auto-evaluator.sh:46:    echo "$output"
.claude/hooks/auto-evaluator.sh:47:    echo ""
.claude/hooks/auto-evaluator.sh:48:    echo "CRITERIA: $criteria"
.claude/hooks/auto-evaluator.sh:49:    echo ""
.claude/hooks/auto-evaluator.sh:50:    echo "Please provide JSON response with: weighted_score (1-10), pass (bool), critical_issues (array), improvement_suggestions (array), revision_required (bool)"
.claude/hooks/auto-evaluator.sh:51:}
.claude/hooks/auto-evaluator.sh:52:
.claude/hooks/auto-evaluator.sh:53:# Process evaluation result
.claude/hooks/auto-evaluator.sh:54:process_evaluation_result() {
.claude/hooks/auto-evaluator.sh:55:    local eval_result="$1"
.claude/hooks/auto-evaluator.sh:56:    local task="$2"
.claude/hooks/auto-evaluator.sh:57:    
.claude/hooks/auto-evaluator.sh:58:    log "Processing evaluation result for: $task"
.claude/hooks/auto-evaluator.sh:59:    
.claude/hooks/auto-evaluator.sh:60:    local score
.claude/hooks/auto-evaluator.sh:61:    local pass_status
.claude/hooks/auto-evaluator.sh:62:    
.claude/hooks/auto-evaluator.sh:63:    score=$(echo "$eval_result" | jq -r '.weighted_score // 5' 2>/dev/null || echo "5")
.claude/hooks/auto-evaluator.sh:64:    pass_status=$(echo "$eval_result" | jq -r '.pass // false' 2>/dev/null || echo "false")
.claude/hooks/auto-evaluator.sh:65:    
.claude/hooks/auto-evaluator.sh:66:    # Record to history
.claude/hooks/auto-evaluator.sh:67:    echo "$eval_result" | jq -c ". + {task: \"$task\", timestamp: \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" >> "$EVAL_HISTORY" 2>/dev/null || true
.claude/hooks/auto-evaluator.sh:68:    
.claude/hooks/auto-evaluator.sh:69:    local action="continue"
.claude/hooks/auto-evaluator.sh:70:    if (( $(echo "$score < 7" | bc -l 2>/dev/null || echo 1) )); then
.claude/hooks/auto-evaluator.sh:71:        action="revise"
.claude/hooks/auto-evaluator.sh:72:    fi
.claude/hooks/auto-evaluator.sh:73:    
.claude/hooks/auto-evaluator.sh:74:    jq -n \
.claude/hooks/auto-evaluator.sh:75:        --arg action "$action" \
.claude/hooks/auto-evaluator.sh:76:        --arg score "$score" \
.claude/hooks/auto-evaluator.sh:77:        --arg pass "$pass_status" \
.claude/hooks/auto-evaluator.sh:78:        "{action: \$action, score: (\$score | tonumber), pass: (\$pass == \"true\")}"
.claude/hooks/auto-evaluator.sh:79:}
.claude/hooks/auto-evaluator.sh:80:
.claude/hooks/auto-evaluator.sh:81:# Get stats
.claude/hooks/auto-evaluator.sh:82:get_evaluation_stats() {
.claude/hooks/auto-evaluator.sh:83:    local limit="${1:-20}"
.claude/hooks/auto-evaluator.sh:84:    
.claude/hooks/auto-evaluator.sh:85:    if [[ ! -f "$EVAL_HISTORY" ]]; then
.claude/hooks/auto-evaluator.sh:86:        echo '{"total":0,"avg_score":0}'
.claude/hooks/auto-evaluator.sh:87:        return
.claude/hooks/auto-evaluator.sh:88:    fi
.claude/hooks/auto-evaluator.sh:89:    
.claude/hooks/auto-evaluator.sh:90:    tail -n "$limit" "$EVAL_HISTORY" | jq -s '{total: length, avg_score: (map(.weighted_score // 5) | add / length)}'
.claude/hooks/auto-evaluator.sh:91:}
.claude/hooks/auto-evaluator.sh:92:
.claude/hooks/auto-evaluator.sh:93:case "${1:-help}" in
.claude/hooks/auto-evaluator.sh:94:    evaluate)
.claude/hooks/auto-evaluator.sh:95:        evaluate_output "${2:-task}" "${3:-output}" "${4:-code}"
.claude/hooks/auto-evaluator.sh:96:        ;;
.claude/hooks/auto-evaluator.sh:97:    process)
.claude/hooks/auto-evaluator.sh:98:        process_evaluation_result "${2:-{}}" "${3:-task}"
.claude/hooks/auto-evaluator.sh:99:        ;;
.claude/hooks/auto-evaluator.sh:100:    criteria)
.claude/hooks/auto-evaluator.sh:101:        get_evaluation_criteria "${2:-code}"
.claude/hooks/auto-evaluator.sh:102:        ;;
.claude/hooks/auto-evaluator.sh:103:    stats)
.claude/hooks/auto-evaluator.sh:104:        get_evaluation_stats "${2:-20}"
.claude/hooks/auto-evaluator.sh:105:        ;;
.claude/hooks/auto-evaluator.sh:106:    help|*)
.claude/hooks/auto-evaluator.sh:107:        echo "LLM-as-Judge Auto-Evaluator"
.claude/hooks/auto-evaluator.sh:108:        echo "Usage: $0 <command> [args]"
.claude/hooks/auto-evaluator.sh:109:        echo "  evaluate <task> <output> [type]  - Generate evaluation prompt"
.claude/hooks/auto-evaluator.sh:110:        echo "  process <result> <task>          - Process evaluation result"
.claude/hooks/auto-evaluator.sh:111:        echo "  criteria [type]                  - Get criteria (code/test/general)"
.claude/hooks/auto-evaluator.sh:112:        echo "  stats [limit]                    - Get statistics"
.claude/hooks/auto-evaluator.sh:113:        ;;
.claude/hooks/auto-evaluator.sh:114:esac
.claude/hooks/thinking-framework.sh:1:#!/bin/bash
.claude/hooks/thinking-framework.sh:2:# Thinking Framework - Self-reflection, chain-of-thought, reasoning validation
.claude/hooks/thinking-framework.sh:3:# Based on patterns from: mcp-think-tank, midday-ai, cipher, TriliumNext, beeai-framework
.claude/hooks/thinking-framework.sh:4:
.claude/hooks/thinking-framework.sh:5:set -uo pipefail
.claude/hooks/thinking-framework.sh:6:
.claude/hooks/thinking-framework.sh:7:THINKING_DIR="${HOME}/.claude/thinking"
.claude/hooks/thinking-framework.sh:8:CURRENT_THOUGHT="$THINKING_DIR/current.json"
.claude/hooks/thinking-framework.sh:9:THOUGHT_HISTORY="$THINKING_DIR/history.json"
.claude/hooks/thinking-framework.sh:10:LOG_FILE="${HOME}/.claude/thinking-framework.log"
.claude/hooks/thinking-framework.sh:11:
.claude/hooks/thinking-framework.sh:12:log() {
.claude/hooks/thinking-framework.sh:13:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/thinking-framework.sh:14:}
.claude/hooks/thinking-framework.sh:15:
.claude/hooks/thinking-framework.sh:16:init_thinking() {
.claude/hooks/thinking-framework.sh:17:    mkdir -p "$THINKING_DIR"
.claude/hooks/thinking-framework.sh:18:    if [[ ! -f "$THOUGHT_HISTORY" ]]; then
.claude/hooks/thinking-framework.sh:19:        echo '{"sessions":[]}' > "$THOUGHT_HISTORY"
.claude/hooks/thinking-framework.sh:20:    fi
.claude/hooks/thinking-framework.sh:21:}
.claude/hooks/thinking-framework.sh:22:
.claude/hooks/thinking-framework.sh:23:# =============================================================================
.claude/hooks/thinking-framework.sh:24:# CHAIN OF THOUGHT (from midday-ai patterns)
.claude/hooks/thinking-framework.sh:25:# Step-by-step reasoning for complex tasks
.claude/hooks/thinking-framework.sh:26:# =============================================================================
.claude/hooks/thinking-framework.sh:27:
.claude/hooks/thinking-framework.sh:28:# Start a new thinking session
.claude/hooks/thinking-framework.sh:29:start_thinking() {
.claude/hooks/thinking-framework.sh:30:    local task="$1"
.claude/hooks/thinking-framework.sh:31:    local context="${2:-}"
.claude/hooks/thinking-framework.sh:32:
.claude/hooks/thinking-framework.sh:33:    init_thinking
.claude/hooks/thinking-framework.sh:34:
.claude/hooks/thinking-framework.sh:35:    local session_id
.claude/hooks/thinking-framework.sh:36:    session_id="think_$(date +%s)"
.claude/hooks/thinking-framework.sh:37:
.claude/hooks/thinking-framework.sh:38:    local timestamp
.claude/hooks/thinking-framework.sh:39:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/thinking-framework.sh:40:
.claude/hooks/thinking-framework.sh:41:    cat > "$CURRENT_THOUGHT" << EOF
.claude/hooks/thinking-framework.sh:42:{
.claude/hooks/thinking-framework.sh:43:    "id": "$session_id",
.claude/hooks/thinking-framework.sh:44:    "task": "$task",
.claude/hooks/thinking-framework.sh:45:    "context": "$context",
.claude/hooks/thinking-framework.sh:46:    "status": "in_progress",
.claude/hooks/thinking-framework.sh:47:    "startedAt": "$timestamp",
.claude/hooks/thinking-framework.sh:48:    "steps": [],
.claude/hooks/thinking-framework.sh:49:    "reflections": [],
.claude/hooks/thinking-framework.sh:50:    "loopDetection": {
.claude/hooks/thinking-framework.sh:51:        "contentHashes": [],
.claude/hooks/thinking-framework.sh:52:        "loopDetected": false
.claude/hooks/thinking-framework.sh:53:    }
.claude/hooks/thinking-framework.sh:54:}
.claude/hooks/thinking-framework.sh:55:EOF
.claude/hooks/thinking-framework.sh:56:
.claude/hooks/thinking-framework.sh:57:    log "Started thinking session: $session_id for task: $task"
.claude/hooks/thinking-framework.sh:58:    echo "$session_id"
.claude/hooks/thinking-framework.sh:59:}
.claude/hooks/thinking-framework.sh:60:
.claude/hooks/thinking-framework.sh:61:# Add a reasoning step
.claude/hooks/thinking-framework.sh:62:add_step() {
.claude/hooks/thinking-framework.sh:63:    local step_type="$1"  # analyze, plan, execute, validate, reflect
.claude/hooks/thinking-framework.sh:64:    local content="$2"
.claude/hooks/thinking-framework.sh:65:    local confidence="${3:-0.8}"
.claude/hooks/thinking-framework.sh:66:
.claude/hooks/thinking-framework.sh:67:    if [[ ! -f "$CURRENT_THOUGHT" ]]; then
.claude/hooks/thinking-framework.sh:68:        log "No active thinking session"
.claude/hooks/thinking-framework.sh:69:        return 1
.claude/hooks/thinking-framework.sh:70:    fi
.claude/hooks/thinking-framework.sh:71:
.claude/hooks/thinking-framework.sh:72:    local temp_file
.claude/hooks/thinking-framework.sh:73:    temp_file=$(mktemp)
.claude/hooks/thinking-framework.sh:74:
.claude/hooks/thinking-framework.sh:75:    local timestamp
.claude/hooks/thinking-framework.sh:76:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/thinking-framework.sh:77:
.claude/hooks/thinking-framework.sh:78:    local step_id
.claude/hooks/thinking-framework.sh:79:    step_id="step_$(date +%s%N | cut -c1-13)"
.claude/hooks/thinking-framework.sh:80:
.claude/hooks/thinking-framework.sh:81:    # Calculate content hash for loop detection
.claude/hooks/thinking-framework.sh:82:    local content_hash
.claude/hooks/thinking-framework.sh:83:    content_hash=$(echo "$content" | md5sum | cut -d' ' -f1)
.claude/hooks/thinking-framework.sh:84:
.claude/hooks/thinking-framework.sh:85:    # Check for reasoning loop
.claude/hooks/thinking-framework.sh:86:    local loop_detected
.claude/hooks/thinking-framework.sh:87:    loop_detected=$(jq -r --arg hash "$content_hash" '
.claude/hooks/thinking-framework.sh:88:        if (.loopDetection.contentHashes | index($hash)) then "true" else "false" end
.claude/hooks/thinking-framework.sh:89:    ' "$CURRENT_THOUGHT")
.claude/hooks/thinking-framework.sh:90:
.claude/hooks/thinking-framework.sh:91:    jq --arg id "$step_id" \
.claude/hooks/thinking-framework.sh:92:       --arg type "$step_type" \
.claude/hooks/thinking-framework.sh:93:       --arg content "$content" \
.claude/hooks/thinking-framework.sh:94:       --argjson conf "$confidence" \
.claude/hooks/thinking-framework.sh:95:       --arg ts "$timestamp" \
.claude/hooks/thinking-framework.sh:96:       --arg hash "$content_hash" \
.claude/hooks/thinking-framework.sh:97:       --arg loop "$loop_detected" \
.claude/hooks/thinking-framework.sh:98:       '
.claude/hooks/thinking-framework.sh:99:       .steps += [{
.claude/hooks/thinking-framework.sh:100:           id: $id,
.claude/hooks/thinking-framework.sh:101:           type: $type,
.claude/hooks/thinking-framework.sh:102:           content: $content,
.claude/hooks/thinking-framework.sh:103:           confidence: $conf,
.claude/hooks/thinking-framework.sh:104:           timestamp: $ts
.claude/hooks/thinking-framework.sh:105:       }] |
.claude/hooks/thinking-framework.sh:106:       .loopDetection.contentHashes += [$hash] |
.claude/hooks/thinking-framework.sh:107:       .loopDetection.loopDetected = ($loop == "true")
.claude/hooks/thinking-framework.sh:108:       ' "$CURRENT_THOUGHT" > "$temp_file"
.claude/hooks/thinking-framework.sh:109:
.claude/hooks/thinking-framework.sh:110:    mv "$temp_file" "$CURRENT_THOUGHT"
.claude/hooks/thinking-framework.sh:111:
.claude/hooks/thinking-framework.sh:112:    if [[ "$loop_detected" == "true" ]]; then
.claude/hooks/thinking-framework.sh:113:        log "WARNING: Reasoning loop detected at step $step_id"
.claude/hooks/thinking-framework.sh:114:        echo "loop_detected"
.claude/hooks/thinking-framework.sh:115:    else
.claude/hooks/thinking-framework.sh:116:        log "Added step: $step_type ($step_id)"
.claude/hooks/thinking-framework.sh:117:        echo "$step_id"
.claude/hooks/thinking-framework.sh:118:    fi
.claude/hooks/thinking-framework.sh:119:}
.claude/hooks/thinking-framework.sh:120:
.claude/hooks/thinking-framework.sh:121:# =============================================================================
.claude/hooks/thinking-framework.sh:122:# SELF-REFLECTION (from mcp-think-tank patterns)
.claude/hooks/thinking-framework.sh:123:# Analyze and critique reasoning
.claude/hooks/thinking-framework.sh:124:# =============================================================================
.claude/hooks/thinking-framework.sh:125:
.claude/hooks/thinking-framework.sh:126:# Perform self-reflection on current reasoning
.claude/hooks/thinking-framework.sh:127:reflect() {
.claude/hooks/thinking-framework.sh:128:    local focus="${1:-quality}"  # quality, completeness, accuracy, alternatives
.claude/hooks/thinking-framework.sh:129:    local custom_prompt="${2:-}"
.claude/hooks/thinking-framework.sh:130:
.claude/hooks/thinking-framework.sh:131:    if [[ ! -f "$CURRENT_THOUGHT" ]]; then
.claude/hooks/thinking-framework.sh:132:        return 1
.claude/hooks/thinking-framework.sh:133:    fi
.claude/hooks/thinking-framework.sh:134:
.claude/hooks/thinking-framework.sh:135:    local temp_file
.claude/hooks/thinking-framework.sh:136:    temp_file=$(mktemp)
.claude/hooks/thinking-framework.sh:137:
.claude/hooks/thinking-framework.sh:138:    local timestamp
.claude/hooks/thinking-framework.sh:139:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/thinking-framework.sh:140:
.claude/hooks/thinking-framework.sh:141:    local reflection_id
.claude/hooks/thinking-framework.sh:142:    reflection_id="reflect_$(date +%s)"
.claude/hooks/thinking-framework.sh:143:
.claude/hooks/thinking-framework.sh:144:    # Get current steps for analysis
.claude/hooks/thinking-framework.sh:145:    local steps_summary
.claude/hooks/thinking-framework.sh:146:    steps_summary=$(jq -r '.steps | map("\(.type): \(.content | .[0:100])") | join("\n")' "$CURRENT_THOUGHT")
.claude/hooks/thinking-framework.sh:147:
.claude/hooks/thinking-framework.sh:148:    # Build reflection based on focus
.claude/hooks/thinking-framework.sh:149:    local reflection_content=""
.claude/hooks/thinking-framework.sh:150:    case "$focus" in
.claude/hooks/thinking-framework.sh:151:        quality)
.claude/hooks/thinking-framework.sh:152:            reflection_content="Quality check: Are the reasoning steps logically sound and well-structured?"
.claude/hooks/thinking-framework.sh:153:            ;;
.claude/hooks/thinking-framework.sh:154:        completeness)
.claude/hooks/thinking-framework.sh:155:            reflection_content="Completeness check: Are there any gaps in the reasoning chain?"
.claude/hooks/thinking-framework.sh:156:            ;;
.claude/hooks/thinking-framework.sh:157:        accuracy)
.claude/hooks/thinking-framework.sh:158:            reflection_content="Accuracy check: Are the facts and assumptions correct?"
.claude/hooks/thinking-framework.sh:159:            ;;
.claude/hooks/thinking-framework.sh:160:        alternatives)
.claude/hooks/thinking-framework.sh:161:            reflection_content="Alternatives check: Were other approaches considered?"
.claude/hooks/thinking-framework.sh:162:            ;;
.claude/hooks/thinking-framework.sh:163:        custom)
.claude/hooks/thinking-framework.sh:164:            reflection_content="$custom_prompt"
.claude/hooks/thinking-framework.sh:165:            ;;
.claude/hooks/thinking-framework.sh:166:    esac
.claude/hooks/thinking-framework.sh:167:
.claude/hooks/thinking-framework.sh:168:    jq --arg id "$reflection_id" \
.claude/hooks/thinking-framework.sh:169:       --arg focus "$focus" \
.claude/hooks/thinking-framework.sh:170:       --arg content "$reflection_content" \
.claude/hooks/thinking-framework.sh:171:       --arg ts "$timestamp" \
.claude/hooks/thinking-framework.sh:172:       '
.claude/hooks/thinking-framework.sh:173:       .reflections += [{
.claude/hooks/thinking-framework.sh:174:           id: $id,
.claude/hooks/thinking-framework.sh:175:           focus: $focus,
.claude/hooks/thinking-framework.sh:176:           content: $content,
.claude/hooks/thinking-framework.sh:177:           timestamp: $ts
.claude/hooks/thinking-framework.sh:178:       }]
.claude/hooks/thinking-framework.sh:179:       ' "$CURRENT_THOUGHT" > "$temp_file"
.claude/hooks/thinking-framework.sh:180:
.claude/hooks/thinking-framework.sh:181:    mv "$temp_file" "$CURRENT_THOUGHT"
.claude/hooks/thinking-framework.sh:182:
.claude/hooks/thinking-framework.sh:183:    log "Added reflection: $focus ($reflection_id)"
.claude/hooks/thinking-framework.sh:184:    echo "$reflection_id"
.claude/hooks/thinking-framework.sh:185:}
.claude/hooks/thinking-framework.sh:186:
.claude/hooks/thinking-framework.sh:187:# =============================================================================
.claude/hooks/thinking-framework.sh:188:# REASONING LOOP DETECTION (from cipher patterns)
.claude/hooks/thinking-framework.sh:189:# Prevent circular reasoning
.claude/hooks/thinking-framework.sh:190:# =============================================================================
.claude/hooks/thinking-framework.sh:191:
.claude/hooks/thinking-framework.sh:192:# Check if reasoning is stuck in a loop
.claude/hooks/thinking-framework.sh:193:check_for_loops() {
.claude/hooks/thinking-framework.sh:194:    if [[ ! -f "$CURRENT_THOUGHT" ]]; then
.claude/hooks/thinking-framework.sh:195:        echo "no_session"
.claude/hooks/thinking-framework.sh:196:        return 1
.claude/hooks/thinking-framework.sh:197:    fi
.claude/hooks/thinking-framework.sh:198:
.claude/hooks/thinking-framework.sh:199:    local result
.claude/hooks/thinking-framework.sh:200:    result=$(jq -r '
.claude/hooks/thinking-framework.sh:201:        .loopDetection as $ld |
.claude/hooks/thinking-framework.sh:202:        .steps | length as $stepCount |
.claude/hooks/thinking-framework.sh:203:        if $ld.loopDetected then
.claude/hooks/thinking-framework.sh:204:            "loop_detected"
.claude/hooks/thinking-framework.sh:205:        elif $stepCount > 10 then
.claude/hooks/thinking-framework.sh:206:            "too_many_steps"
.claude/hooks/thinking-framework.sh:207:        elif ($ld.contentHashes | unique | length) < ($stepCount * 0.7 | floor) then
.claude/hooks/thinking-framework.sh:208:            "potential_repetition"
.claude/hooks/thinking-framework.sh:209:        else
.claude/hooks/thinking-framework.sh:210:            "ok"
.claude/hooks/thinking-framework.sh:211:        end
.claude/hooks/thinking-framework.sh:212:    ' "$CURRENT_THOUGHT")
.claude/hooks/thinking-framework.sh:213:
.claude/hooks/thinking-framework.sh:214:    echo "$result"
.claude/hooks/thinking-framework.sh:215:}
.claude/hooks/thinking-framework.sh:216:
.claude/hooks/thinking-framework.sh:217:# Get suggestions to break out of loop
.claude/hooks/thinking-framework.sh:218:get_loop_breaker() {
.claude/hooks/thinking-framework.sh:219:    local loop_type="${1:-loop_detected}"
.claude/hooks/thinking-framework.sh:220:
.claude/hooks/thinking-framework.sh:221:    case "$loop_type" in
.claude/hooks/thinking-framework.sh:222:        loop_detected)
.claude/hooks/thinking-framework.sh:223:            echo "SUGGESTION: Exact reasoning loop detected. Try a different approach or decompose the problem differently."
.claude/hooks/thinking-framework.sh:224:            ;;
.claude/hooks/thinking-framework.sh:225:        too_many_steps)
.claude/hooks/thinking-framework.sh:226:            echo "SUGGESTION: Too many reasoning steps. Consider simplifying or breaking into sub-problems."
.claude/hooks/thinking-framework.sh:227:            ;;
.claude/hooks/thinking-framework.sh:228:        potential_repetition)
.claude/hooks/thinking-framework.sh:229:            echo "SUGGESTION: Repetitive reasoning patterns detected. Step back and reconsider the approach."
.claude/hooks/thinking-framework.sh:230:            ;;
.claude/hooks/thinking-framework.sh:231:        *)
.claude/hooks/thinking-framework.sh:232:            echo "SUGGESTION: Reasoning appears healthy. Continue."
.claude/hooks/thinking-framework.sh:233:            ;;
.claude/hooks/thinking-framework.sh:234:    esac
.claude/hooks/thinking-framework.sh:235:}
.claude/hooks/thinking-framework.sh:236:
.claude/hooks/thinking-framework.sh:237:# =============================================================================
.claude/hooks/thinking-framework.sh:238:# THINKING PROCESS MANAGEMENT (from TriliumNext patterns)
.claude/hooks/thinking-framework.sh:239:# =============================================================================
.claude/hooks/thinking-framework.sh:240:
.claude/hooks/thinking-framework.sh:241:# Complete thinking session and save to history
.claude/hooks/thinking-framework.sh:242:complete_thinking() {
.claude/hooks/thinking-framework.sh:243:    local conclusion="$1"
.claude/hooks/thinking-framework.sh:244:    local quality_score="${2:-0.8}"
.claude/hooks/thinking-framework.sh:245:
.claude/hooks/thinking-framework.sh:246:    if [[ ! -f "$CURRENT_THOUGHT" ]]; then
.claude/hooks/thinking-framework.sh:247:        return 1
.claude/hooks/thinking-framework.sh:248:    fi
.claude/hooks/thinking-framework.sh:249:
.claude/hooks/thinking-framework.sh:250:    local temp_file
.claude/hooks/thinking-framework.sh:251:    temp_file=$(mktemp)
.claude/hooks/thinking-framework.sh:252:
.claude/hooks/thinking-framework.sh:253:    local timestamp
.claude/hooks/thinking-framework.sh:254:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/thinking-framework.sh:255:
.claude/hooks/thinking-framework.sh:256:    # Update current thought
.claude/hooks/thinking-framework.sh:257:    jq --arg conclusion "$conclusion" \
.claude/hooks/thinking-framework.sh:258:       --argjson quality "$quality_score" \
.claude/hooks/thinking-framework.sh:259:       --arg ts "$timestamp" \
.claude/hooks/thinking-framework.sh:260:       '
.claude/hooks/thinking-framework.sh:261:       .status = "completed" |
.claude/hooks/thinking-framework.sh:262:       .conclusion = $conclusion |
.claude/hooks/thinking-framework.sh:263:       .qualityScore = $quality |
.claude/hooks/thinking-framework.sh:264:       .completedAt = $ts |
.claude/hooks/thinking-framework.sh:265:       .duration = (
.claude/hooks/thinking-framework.sh:266:           (($ts | fromdate) - (.startedAt | fromdate)) | floor
.claude/hooks/thinking-framework.sh:267:       )
.claude/hooks/thinking-framework.sh:268:       ' "$CURRENT_THOUGHT" > "$temp_file"
.claude/hooks/thinking-framework.sh:269:
.claude/hooks/thinking-framework.sh:270:    mv "$temp_file" "$CURRENT_THOUGHT"
.claude/hooks/thinking-framework.sh:271:
.claude/hooks/thinking-framework.sh:272:    # Add to history
.claude/hooks/thinking-framework.sh:273:    local history_temp
.claude/hooks/thinking-framework.sh:274:    history_temp=$(mktemp)
.claude/hooks/thinking-framework.sh:275:
.claude/hooks/thinking-framework.sh:276:    jq --slurpfile thought "$CURRENT_THOUGHT" \
.claude/hooks/thinking-framework.sh:277:       '.sessions = [$thought[0]] + .sessions | .sessions = .sessions[:100]' \
.claude/hooks/thinking-framework.sh:278:       "$THOUGHT_HISTORY" > "$history_temp"
.claude/hooks/thinking-framework.sh:279:
.claude/hooks/thinking-framework.sh:280:    mv "$history_temp" "$THOUGHT_HISTORY"
.claude/hooks/thinking-framework.sh:281:
.claude/hooks/thinking-framework.sh:282:    # Archive current thought
.claude/hooks/thinking-framework.sh:283:    local archive_file="$THINKING_DIR/archive/$(jq -r '.id' "$CURRENT_THOUGHT").json"
.claude/hooks/thinking-framework.sh:284:    mkdir -p "$THINKING_DIR/archive"
.claude/hooks/thinking-framework.sh:285:    mv "$CURRENT_THOUGHT" "$archive_file"
.claude/hooks/thinking-framework.sh:286:
.claude/hooks/thinking-framework.sh:287:    log "Completed thinking session"
.claude/hooks/thinking-framework.sh:288:    echo "$archive_file"
.claude/hooks/thinking-framework.sh:289:}
.claude/hooks/thinking-framework.sh:290:
.claude/hooks/thinking-framework.sh:291:# Get current thinking state
.claude/hooks/thinking-framework.sh:292:get_state() {
.claude/hooks/thinking-framework.sh:293:    if [[ -f "$CURRENT_THOUGHT" ]]; then
.claude/hooks/thinking-framework.sh:294:        jq '.' "$CURRENT_THOUGHT"
.claude/hooks/thinking-framework.sh:295:    else
.claude/hooks/thinking-framework.sh:296:        echo '{"status":"no_active_session"}'
.claude/hooks/thinking-framework.sh:297:    fi
.claude/hooks/thinking-framework.sh:298:}
.claude/hooks/thinking-framework.sh:299:
.claude/hooks/thinking-framework.sh:300:# Get thinking summary
.claude/hooks/thinking-framework.sh:301:get_summary() {
.claude/hooks/thinking-framework.sh:302:    if [[ ! -f "$CURRENT_THOUGHT" ]]; then
.claude/hooks/thinking-framework.sh:303:        echo "No active thinking session"
.claude/hooks/thinking-framework.sh:304:        return
.claude/hooks/thinking-framework.sh:305:    fi
.claude/hooks/thinking-framework.sh:306:
.claude/hooks/thinking-framework.sh:307:    jq -r '
.claude/hooks/thinking-framework.sh:308:        "=== Thinking Session ===\n" +
.claude/hooks/thinking-framework.sh:309:        "Task: \(.task)\n" +
.claude/hooks/thinking-framework.sh:310:        "Status: \(.status)\n" +
.claude/hooks/thinking-framework.sh:311:        "Steps: \(.steps | length)\n" +
.claude/hooks/thinking-framework.sh:312:        "Reflections: \(.reflections | length)\n" +
.claude/hooks/thinking-framework.sh:313:        "Loop Status: \(if .loopDetection.loopDetected then " LOOP DETECTED" else " OK" end)\n" +
.claude/hooks/thinking-framework.sh:314:        "\n--- Step Types ---\n" +
.claude/hooks/thinking-framework.sh:315:        (.steps | group_by(.type) | map("\(.[0].type): \(length)") | join("\n"))
.claude/hooks/thinking-framework.sh:316:    ' "$CURRENT_THOUGHT"
.claude/hooks/thinking-framework.sh:317:}
.claude/hooks/thinking-framework.sh:318:
.claude/hooks/thinking-framework.sh:319:# =============================================================================
.claude/hooks/thinking-framework.sh:320:# PROMPTS FOR REASONING (from beeai-framework patterns)
.claude/hooks/thinking-framework.sh:321:# =============================================================================
.claude/hooks/thinking-framework.sh:322:
.claude/hooks/thinking-framework.sh:323:# Generate chain-of-thought prompt
.claude/hooks/thinking-framework.sh:324:generate_cot_prompt() {
.claude/hooks/thinking-framework.sh:325:    local task="$1"
.claude/hooks/thinking-framework.sh:326:    local context="${2:-}"
.claude/hooks/thinking-framework.sh:327:
.claude/hooks/thinking-framework.sh:328:    cat << EOF
.claude/hooks/thinking-framework.sh:329:CHAIN OF THOUGHT REASONING
.claude/hooks/thinking-framework.sh:330:
.claude/hooks/thinking-framework.sh:331:Task: $task
.claude/hooks/thinking-framework.sh:332:${context:+Context: $context}
.claude/hooks/thinking-framework.sh:333:
.claude/hooks/thinking-framework.sh:334:Follow these steps:
.claude/hooks/thinking-framework.sh:335:
.claude/hooks/thinking-framework.sh:336:1. UNDERSTAND: What exactly is being asked? What are the constraints?
.claude/hooks/thinking-framework.sh:337:2. ANALYZE: What information do we have? What's missing?
.claude/hooks/thinking-framework.sh:338:3. PLAN: What approach will solve this? What are the steps?
.claude/hooks/thinking-framework.sh:339:4. EXECUTE: Work through each step systematically
.claude/hooks/thinking-framework.sh:340:5. VALIDATE: Does the solution meet all requirements?
.claude/hooks/thinking-framework.sh:341:6. REFLECT: Is there a better approach? What did we learn?
.claude/hooks/thinking-framework.sh:342:
.claude/hooks/thinking-framework.sh:343:Begin your reasoning:
.claude/hooks/thinking-framework.sh:344:EOF
.claude/hooks/thinking-framework.sh:345:}
.claude/hooks/thinking-framework.sh:346:
.claude/hooks/thinking-framework.sh:347:# Generate reflection prompt
.claude/hooks/thinking-framework.sh:348:generate_reflection_prompt() {
.claude/hooks/thinking-framework.sh:349:    local reasoning="$1"
.claude/hooks/thinking-framework.sh:350:    local focus="${2:-quality}"
.claude/hooks/thinking-framework.sh:351:
.claude/hooks/thinking-framework.sh:352:    cat << EOF
.claude/hooks/thinking-framework.sh:353:SELF-REFLECTION
.claude/hooks/thinking-framework.sh:354:
.claude/hooks/thinking-framework.sh:355:Review the following reasoning:
.claude/hooks/thinking-framework.sh:356:---
.claude/hooks/thinking-framework.sh:357:$reasoning
.claude/hooks/thinking-framework.sh:358:---
.claude/hooks/thinking-framework.sh:359:
.claude/hooks/thinking-framework.sh:360:Focus: $focus
.claude/hooks/thinking-framework.sh:361:
.claude/hooks/thinking-framework.sh:362:Evaluate:
.claude/hooks/thinking-framework.sh:363:1. Is the logic sound and free of fallacies?
.claude/hooks/thinking-framework.sh:364:2. Are there any gaps or missing steps?
.claude/hooks/thinking-framework.sh:365:3. Were assumptions clearly stated and valid?
.claude/hooks/thinking-framework.sh:366:4. Could this be solved more efficiently?
.claude/hooks/thinking-framework.sh:367:5. What would improve this reasoning?
.claude/hooks/thinking-framework.sh:368:
.claude/hooks/thinking-framework.sh:369:Provide your reflection:
.claude/hooks/thinking-framework.sh:370:EOF
.claude/hooks/thinking-framework.sh:371:}
.claude/hooks/thinking-framework.sh:372:
.claude/hooks/thinking-framework.sh:373:# Generate critique prompt
.claude/hooks/thinking-framework.sh:374:generate_critique_prompt() {
.claude/hooks/thinking-framework.sh:375:    local solution="$1"
.claude/hooks/thinking-framework.sh:376:    local requirements="${2:-}"
.claude/hooks/thinking-framework.sh:377:
.claude/hooks/thinking-framework.sh:378:    cat << EOF
.claude/hooks/thinking-framework.sh:379:SOLUTION CRITIQUE
.claude/hooks/thinking-framework.sh:380:
.claude/hooks/thinking-framework.sh:381:Solution:
.claude/hooks/thinking-framework.sh:382:---
.claude/hooks/thinking-framework.sh:383:$solution
.claude/hooks/thinking-framework.sh:384:---
.claude/hooks/thinking-framework.sh:385:
.claude/hooks/thinking-framework.sh:386:${requirements:+Requirements: $requirements}
.claude/hooks/thinking-framework.sh:387:
.claude/hooks/thinking-framework.sh:388:Critique this solution:
.claude/hooks/thinking-framework.sh:389:1. CORRECTNESS: Does it solve the problem correctly?
.claude/hooks/thinking-framework.sh:390:2. COMPLETENESS: Does it handle all cases?
.claude/hooks/thinking-framework.sh:391:3. EFFICIENCY: Is there unnecessary complexity?
.claude/hooks/thinking-framework.sh:392:4. ROBUSTNESS: How does it handle edge cases?
.claude/hooks/thinking-framework.sh:393:5. MAINTAINABILITY: Is it clear and well-structured?
.claude/hooks/thinking-framework.sh:394:
.claude/hooks/thinking-framework.sh:395:Provide specific, actionable feedback:
.claude/hooks/thinking-framework.sh:396:EOF
.claude/hooks/thinking-framework.sh:397:}
.claude/hooks/thinking-framework.sh:398:
.claude/hooks/thinking-framework.sh:399:# =============================================================================
.claude/hooks/thinking-framework.sh:400:# COMMAND INTERFACE
.claude/hooks/thinking-framework.sh:401:# =============================================================================
.claude/hooks/thinking-framework.sh:402:
.claude/hooks/thinking-framework.sh:403:case "${1:-help}" in
.claude/hooks/thinking-framework.sh:404:    start)
.claude/hooks/thinking-framework.sh:405:        start_thinking "${2:-task}" "${3:-}"
.claude/hooks/thinking-framework.sh:406:        ;;
.claude/hooks/thinking-framework.sh:407:    step)
.claude/hooks/thinking-framework.sh:408:        add_step "${2:-analyze}" "${3:-step content}" "${4:-0.8}"
.claude/hooks/thinking-framework.sh:409:        ;;
.claude/hooks/thinking-framework.sh:410:    reflect)
.claude/hooks/thinking-framework.sh:411:        reflect "${2:-quality}" "${3:-}"
.claude/hooks/thinking-framework.sh:412:        ;;
.claude/hooks/thinking-framework.sh:413:    check-loops)
.claude/hooks/thinking-framework.sh:414:        check_for_loops
.claude/hooks/thinking-framework.sh:415:        ;;
.claude/hooks/thinking-framework.sh:416:    loop-breaker)
.claude/hooks/thinking-framework.sh:417:        get_loop_breaker "${2:-loop_detected}"
.claude/hooks/thinking-framework.sh:418:        ;;
.claude/hooks/thinking-framework.sh:419:    complete)
.claude/hooks/thinking-framework.sh:420:        complete_thinking "${2:-completed}" "${3:-0.8}"
.claude/hooks/thinking-framework.sh:421:        ;;
.claude/hooks/thinking-framework.sh:422:    state)
.claude/hooks/thinking-framework.sh:423:        get_state
.claude/hooks/thinking-framework.sh:424:        ;;
.claude/hooks/thinking-framework.sh:425:    summary)
.claude/hooks/thinking-framework.sh:426:        get_summary
.claude/hooks/thinking-framework.sh:427:        ;;
.claude/hooks/thinking-framework.sh:428:    cot-prompt)
.claude/hooks/thinking-framework.sh:429:        generate_cot_prompt "${2:-task}" "${3:-}"
.claude/hooks/thinking-framework.sh:430:        ;;
.claude/hooks/thinking-framework.sh:431:    reflection-prompt)
.claude/hooks/thinking-framework.sh:432:        generate_reflection_prompt "${2:-reasoning}" "${3:-quality}"
.claude/hooks/thinking-framework.sh:433:        ;;
.claude/hooks/thinking-framework.sh:434:    critique-prompt)
.claude/hooks/thinking-framework.sh:435:        generate_critique_prompt "${2:-solution}" "${3:-}"
.claude/hooks/thinking-framework.sh:436:        ;;
.claude/hooks/thinking-framework.sh:437:    help|*)
.claude/hooks/thinking-framework.sh:438:        echo "Thinking Framework - Self-reflection & Reasoning"
.claude/hooks/thinking-framework.sh:439:        echo ""
.claude/hooks/thinking-framework.sh:440:        echo "Usage: $0 <command> [args]"
.claude/hooks/thinking-framework.sh:441:        echo ""
.claude/hooks/thinking-framework.sh:442:        echo "Session Commands:"
.claude/hooks/thinking-framework.sh:443:        echo "  start <task> [context]           - Start thinking session"
.claude/hooks/thinking-framework.sh:444:        echo "  step <type> <content> [conf]     - Add reasoning step"
.claude/hooks/thinking-framework.sh:445:        echo "    Types: analyze, plan, execute, validate, reflect"
.claude/hooks/thinking-framework.sh:446:        echo "  reflect <focus> [prompt]         - Add self-reflection"
.claude/hooks/thinking-framework.sh:447:        echo "    Focus: quality, completeness, accuracy, alternatives, custom"
.claude/hooks/thinking-framework.sh:448:        echo "  complete <conclusion> [score]    - Complete session"
.claude/hooks/thinking-framework.sh:449:        echo ""
.claude/hooks/thinking-framework.sh:450:        echo "Analysis Commands:"
.claude/hooks/thinking-framework.sh:451:        echo "  check-loops                      - Check for reasoning loops"
.claude/hooks/thinking-framework.sh:452:        echo "  loop-breaker <type>              - Get suggestion to break loop"
.claude/hooks/thinking-framework.sh:453:        echo "  state                            - Get current state"
.claude/hooks/thinking-framework.sh:454:        echo "  summary                          - Get session summary"
.claude/hooks/thinking-framework.sh:455:        echo ""
.claude/hooks/thinking-framework.sh:456:        echo "Prompt Generators:"
.claude/hooks/thinking-framework.sh:457:        echo "  cot-prompt <task> [context]      - Generate chain-of-thought prompt"
.claude/hooks/thinking-framework.sh:458:        echo "  reflection-prompt <reasoning>    - Generate reflection prompt"
.claude/hooks/thinking-framework.sh:459:        echo "  critique-prompt <solution>       - Generate critique prompt"
.claude/hooks/thinking-framework.sh:460:        ;;
.claude/hooks/thinking-framework.sh:461:esac
.claude/hooks/multi-agent-orchestrator.sh:1:#!/bin/bash
.claude/hooks/multi-agent-orchestrator.sh:2:# Multi-Agent Orchestrator - Coordinate specialist agents
.claude/hooks/multi-agent-orchestrator.sh:3:# Based on: ragapp AgentOrchestrator, mistralai agent patterns
.claude/hooks/multi-agent-orchestrator.sh:4:# Implements specialist swarm with task routing
.claude/hooks/multi-agent-orchestrator.sh:5:
.claude/hooks/multi-agent-orchestrator.sh:6:set -eo pipefail
.claude/hooks/multi-agent-orchestrator.sh:7:
.claude/hooks/multi-agent-orchestrator.sh:8:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/multi-agent-orchestrator.sh:9:AGENTS_DIR="${CLAUDE_DIR}/agents"
.claude/hooks/multi-agent-orchestrator.sh:10:LOG_FILE="${CLAUDE_DIR}/multi-agent-orchestrator.log"
.claude/hooks/multi-agent-orchestrator.sh:11:
.claude/hooks/multi-agent-orchestrator.sh:12:mkdir -p "$AGENTS_DIR"
.claude/hooks/multi-agent-orchestrator.sh:13:
.claude/hooks/multi-agent-orchestrator.sh:14:log() {
.claude/hooks/multi-agent-orchestrator.sh:15:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/multi-agent-orchestrator.sh:16:}
.claude/hooks/multi-agent-orchestrator.sh:17:
.claude/hooks/multi-agent-orchestrator.sh:18:# Agent registry
.claude/hooks/multi-agent-orchestrator.sh:19:get_agent_registry() {
.claude/hooks/multi-agent-orchestrator.sh:20:    cat << 'EOF'
.claude/hooks/multi-agent-orchestrator.sh:21:{
.claude/hooks/multi-agent-orchestrator.sh:22:    "agents": {
.claude/hooks/multi-agent-orchestrator.sh:23:        "code_writer": {
.claude/hooks/multi-agent-orchestrator.sh:24:            "expertise": ["implementation", "coding", "refactoring"],
.claude/hooks/multi-agent-orchestrator.sh:25:            "description": "Focused on writing high-quality code",
.claude/hooks/multi-agent-orchestrator.sh:26:            "priority_for": ["implement", "code", "write", "refactor"]
.claude/hooks/multi-agent-orchestrator.sh:27:        },
.claude/hooks/multi-agent-orchestrator.sh:28:        "test_engineer": {
.claude/hooks/multi-agent-orchestrator.sh:29:            "expertise": ["testing", "validation", "quality_assurance"],
.claude/hooks/multi-agent-orchestrator.sh:30:            "description": "Focused on writing and running tests",
.claude/hooks/multi-agent-orchestrator.sh:31:            "priority_for": ["test", "validate", "check", "verify"]
.claude/hooks/multi-agent-orchestrator.sh:32:        },
.claude/hooks/multi-agent-orchestrator.sh:33:        "security_auditor": {
.claude/hooks/multi-agent-orchestrator.sh:34:            "expertise": ["security", "vulnerabilities", "auditing"],
.claude/hooks/multi-agent-orchestrator.sh:35:            "description": "Focused on finding security issues",
.claude/hooks/multi-agent-orchestrator.sh:36:            "priority_for": ["security", "vulnerability", "audit", "exploit"]
.claude/hooks/multi-agent-orchestrator.sh:37:        },
.claude/hooks/multi-agent-orchestrator.sh:38:        "performance_optimizer": {
.claude/hooks/multi-agent-orchestrator.sh:39:            "expertise": ["performance", "optimization", "profiling"],
.claude/hooks/multi-agent-orchestrator.sh:40:            "description": "Focused on improving performance",
.claude/hooks/multi-agent-orchestrator.sh:41:            "priority_for": ["performance", "optimize", "speed", "profile"]
.claude/hooks/multi-agent-orchestrator.sh:42:        },
.claude/hooks/multi-agent-orchestrator.sh:43:        "documentation_writer": {
.claude/hooks/multi-agent-orchestrator.sh:44:            "expertise": ["documentation", "explanations", "guides"],
.claude/hooks/multi-agent-orchestrator.sh:45:            "description": "Focused on creating clear documentation",
.claude/hooks/multi-agent-orchestrator.sh:46:            "priority_for": ["document", "explain", "guide", "readme"]
.claude/hooks/multi-agent-orchestrator.sh:47:        },
.claude/hooks/multi-agent-orchestrator.sh:48:        "debugger": {
.claude/hooks/multi-agent-orchestrator.sh:49:            "expertise": ["debugging", "troubleshooting", "root_cause"],
.claude/hooks/multi-agent-orchestrator.sh:50:            "description": "Focused on finding and fixing bugs",
.claude/hooks/multi-agent-orchestrator.sh:51:            "priority_for": ["debug", "fix", "bug", "error", "troubleshoot"]
.claude/hooks/multi-agent-orchestrator.sh:52:        }
.claude/hooks/multi-agent-orchestrator.sh:53:    }
.claude/hooks/multi-agent-orchestrator.sh:54:}
.claude/hooks/multi-agent-orchestrator.sh:55:EOF
.claude/hooks/multi-agent-orchestrator.sh:56:}
.claude/hooks/multi-agent-orchestrator.sh:57:
.claude/hooks/multi-agent-orchestrator.sh:58:# Route task to appropriate agent
.claude/hooks/multi-agent-orchestrator.sh:59:route_task() {
.claude/hooks/multi-agent-orchestrator.sh:60:    local task="$1"
.claude/hooks/multi-agent-orchestrator.sh:61:
.claude/hooks/multi-agent-orchestrator.sh:62:    log "Routing task: $task"
.claude/hooks/multi-agent-orchestrator.sh:63:
.claude/hooks/multi-agent-orchestrator.sh:64:    local registry
.claude/hooks/multi-agent-orchestrator.sh:65:    registry=$(get_agent_registry)
.claude/hooks/multi-agent-orchestrator.sh:66:
.claude/hooks/multi-agent-orchestrator.sh:67:    # Find best matching agent
.claude/hooks/multi-agent-orchestrator.sh:68:    local best_agent="code_writer"
.claude/hooks/multi-agent-orchestrator.sh:69:    local best_score=0
.claude/hooks/multi-agent-orchestrator.sh:70:
.claude/hooks/multi-agent-orchestrator.sh:71:    while IFS= read -r agent_name; do
.claude/hooks/multi-agent-orchestrator.sh:72:        local keywords
.claude/hooks/multi-agent-orchestrator.sh:73:        keywords=$(echo "$registry" | jq -r ".agents.$agent_name.priority_for[]" 2>/dev/null)
.claude/hooks/multi-agent-orchestrator.sh:74:
.claude/hooks/multi-agent-orchestrator.sh:75:        local score=0
.claude/hooks/multi-agent-orchestrator.sh:76:        while IFS= read -r keyword; do
.claude/hooks/multi-agent-orchestrator.sh:77:            if echo "$task" | grep -qi "$keyword"; then
.claude/hooks/multi-agent-orchestrator.sh:78:                score=$((score + 1))
.claude/hooks/multi-agent-orchestrator.sh:79:            fi
.claude/hooks/multi-agent-orchestrator.sh:80:        done <<< "$keywords"
.claude/hooks/multi-agent-orchestrator.sh:81:
.claude/hooks/multi-agent-orchestrator.sh:82:        if (( score > best_score )); then
.claude/hooks/multi-agent-orchestrator.sh:83:            best_score=$score
.claude/hooks/multi-agent-orchestrator.sh:84:            best_agent="$agent_name"
.claude/hooks/multi-agent-orchestrator.sh:85:        fi
.claude/hooks/multi-agent-orchestrator.sh:86:    done < <(echo "$registry" | jq -r '.agents | keys[]')
.claude/hooks/multi-agent-orchestrator.sh:87:
.claude/hooks/multi-agent-orchestrator.sh:88:    echo "$registry" | jq --arg agent "$best_agent" '{
.claude/hooks/multi-agent-orchestrator.sh:89:        selected_agent: $agent,
.claude/hooks/multi-agent-orchestrator.sh:90:        agent_info: .agents[$agent],
.claude/hooks/multi-agent-orchestrator.sh:91:        routing_confidence: (if '"$best_score"' > 0 then '"$best_score"' * 20 else 10 end)
.claude/hooks/multi-agent-orchestrator.sh:92:    }'
.claude/hooks/multi-agent-orchestrator.sh:93:}
.claude/hooks/multi-agent-orchestrator.sh:94:
.claude/hooks/multi-agent-orchestrator.sh:95:# Orchestrate multi-agent collaboration
.claude/hooks/multi-agent-orchestrator.sh:96:orchestrate() {
.claude/hooks/multi-agent-orchestrator.sh:97:    local task="$1"
.claude/hooks/multi-agent-orchestrator.sh:98:    local require_all="${2:-false}"
.claude/hooks/multi-agent-orchestrator.sh:99:
.claude/hooks/multi-agent-orchestrator.sh:100:    log "Orchestrating multi-agent task: $task"
.claude/hooks/multi-agent-orchestrator.sh:101:
.claude/hooks/multi-agent-orchestrator.sh:102:    cat << EOF
.claude/hooks/multi-agent-orchestrator.sh:103:{
.claude/hooks/multi-agent-orchestrator.sh:104:    "task": "$task",
.claude/hooks/multi-agent-orchestrator.sh:105:    "orchestration_strategy": "$(if [[ "$require_all" == "true" ]]; then echo "parallel_all"; else echo "sequential_specialists"; fi)",
.claude/hooks/multi-agent-orchestrator.sh:106:    "workflow": [
.claude/hooks/multi-agent-orchestrator.sh:107:        {
.claude/hooks/multi-agent-orchestrator.sh:108:            "phase": "planning",
.claude/hooks/multi-agent-orchestrator.sh:109:            "agents": ["code_writer"],
.claude/hooks/multi-agent-orchestrator.sh:110:            "action": "Break down task into subtasks"
.claude/hooks/multi-agent-orchestrator.sh:111:        },
.claude/hooks/multi-agent-orchestrator.sh:112:        {
.claude/hooks/multi-agent-orchestrator.sh:113:            "phase": "implementation",
.claude/hooks/multi-agent-orchestrator.sh:114:            "agents": ["code_writer", "debugger"],
.claude/hooks/multi-agent-orchestrator.sh:115:            "action": "Implement solution with error handling"
.claude/hooks/multi-agent-orchestrator.sh:116:        },
.claude/hooks/multi-agent-orchestrator.sh:117:        {
.claude/hooks/multi-agent-orchestrator.sh:118:            "phase": "validation",
.claude/hooks/multi-agent-orchestrator.sh:119:            "agents": ["test_engineer", "security_auditor"],
.claude/hooks/multi-agent-orchestrator.sh:120:            "action": "Run tests and security checks in parallel",
.claude/hooks/multi-agent-orchestrator.sh:121:            "parallel": true
.claude/hooks/multi-agent-orchestrator.sh:122:        },
.claude/hooks/multi-agent-orchestrator.sh:123:        {
.claude/hooks/multi-agent-orchestrator.sh:124:            "phase": "optimization",
.claude/hooks/multi-agent-orchestrator.sh:125:            "agents": ["performance_optimizer"],
.claude/hooks/multi-agent-orchestrator.sh:126:            "action": "Profile and optimize if needed",
.claude/hooks/multi-agent-orchestrator.sh:127:            "conditional": "if performance issues detected"
.claude/hooks/multi-agent-orchestrator.sh:128:        },
.claude/hooks/multi-agent-orchestrator.sh:129:        {
.claude/hooks/multi-agent-orchestrator.sh:130:            "phase": "documentation",
.claude/hooks/multi-agent-orchestrator.sh:131:            "agents": ["documentation_writer"],
.claude/hooks/multi-agent-orchestrator.sh:132:            "action": "Document completed feature"
.claude/hooks/multi-agent-orchestrator.sh:133:        }
.claude/hooks/multi-agent-orchestrator.sh:134:    ]
.claude/hooks/multi-agent-orchestrator.sh:135:}
.claude/hooks/multi-agent-orchestrator.sh:136:EOF
.claude/hooks/multi-agent-orchestrator.sh:137:}
.claude/hooks/multi-agent-orchestrator.sh:138:
.claude/hooks/multi-agent-orchestrator.sh:139:case "${1:-help}" in
.claude/hooks/multi-agent-orchestrator.sh:140:    route)
.claude/hooks/multi-agent-orchestrator.sh:141:        route_task "${2:-task}"
.claude/hooks/multi-agent-orchestrator.sh:142:        ;;
.claude/hooks/multi-agent-orchestrator.sh:143:    orchestrate)
.claude/hooks/multi-agent-orchestrator.sh:144:        orchestrate "${2:-task}" "${3:-false}"
.claude/hooks/multi-agent-orchestrator.sh:145:        ;;
.claude/hooks/multi-agent-orchestrator.sh:146:    agents)
.claude/hooks/multi-agent-orchestrator.sh:147:        get_agent_registry
.claude/hooks/multi-agent-orchestrator.sh:148:        ;;
.claude/hooks/multi-agent-orchestrator.sh:149:    help|*)
.claude/hooks/multi-agent-orchestrator.sh:150:        echo "Multi-Agent Orchestrator"
.claude/hooks/multi-agent-orchestrator.sh:151:        echo "Usage: $0 <command> [args]"
.claude/hooks/multi-agent-orchestrator.sh:152:        echo "  route <task>              - Route task to best agent"
.claude/hooks/multi-agent-orchestrator.sh:153:        echo "  orchestrate <task> [all]  - Coordinate multi-agent workflow"
.claude/hooks/multi-agent-orchestrator.sh:154:        echo "  agents                    - List available agents"
.claude/hooks/multi-agent-orchestrator.sh:155:        ;;
.claude/hooks/multi-agent-orchestrator.sh:156:esac
.claude/hooks/ui-test-framework.sh:1:#!/bin/bash
.claude/hooks/ui-test-framework.sh:2:# UI Test Framework - Automated browser testing with Claude in Chrome
.claude/hooks/ui-test-framework.sh:3:# Solves the problem: "UI testing is tedious"
.claude/hooks/ui-test-framework.sh:4:
.claude/hooks/ui-test-framework.sh:5:set -eo pipefail
.claude/hooks/ui-test-framework.sh:6:
.claude/hooks/ui-test-framework.sh:7:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/ui-test-framework.sh:8:UI_TEST_DIR="${CLAUDE_DIR}/.ui-tests"
.claude/hooks/ui-test-framework.sh:9:TEST_RESULTS="${UI_TEST_DIR}/results.jsonl"
.claude/hooks/ui-test-framework.sh:10:TEST_RECORDINGS="${UI_TEST_DIR}/recordings"
.claude/hooks/ui-test-framework.sh:11:LOG_FILE="${CLAUDE_DIR}/ui-test-framework.log"
.claude/hooks/ui-test-framework.sh:12:
.claude/hooks/ui-test-framework.sh:13:mkdir -p "$UI_TEST_DIR" "$TEST_RECORDINGS"
.claude/hooks/ui-test-framework.sh:14:
.claude/hooks/ui-test-framework.sh:15:log() {
.claude/hooks/ui-test-framework.sh:16:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/ui-test-framework.sh:17:}
.claude/hooks/ui-test-framework.sh:18:
.claude/hooks/ui-test-framework.sh:19:# =============================================================================
.claude/hooks/ui-test-framework.sh:20:# UI TEST DEFINITIONS
.claude/hooks/ui-test-framework.sh:21:# =============================================================================
.claude/hooks/ui-test-framework.sh:22:
.claude/hooks/ui-test-framework.sh:23:create_test_suite() {
.claude/hooks/ui-test-framework.sh:24:    local suite_name="$1"
.claude/hooks/ui-test-framework.sh:25:    local base_url="$2"
.claude/hooks/ui-test-framework.sh:26:
.claude/hooks/ui-test-framework.sh:27:    local suite_file="${UI_TEST_DIR}/${suite_name}.json"
.claude/hooks/ui-test-framework.sh:28:
.claude/hooks/ui-test-framework.sh:29:    jq -n \
.claude/hooks/ui-test-framework.sh:30:        --arg name "$suite_name" \
.claude/hooks/ui-test-framework.sh:31:        --arg url "$base_url" \
.claude/hooks/ui-test-framework.sh:32:        '{
.claude/hooks/ui-test-framework.sh:33:            suite_name: $name,
.claude/hooks/ui-test-framework.sh:34:            base_url: $url,
.claude/hooks/ui-test-framework.sh:35:            tests: [],
.claude/hooks/ui-test-framework.sh:36:            created_at: (now | todate)
.claude/hooks/ui-test-framework.sh:37:        }' > "$suite_file"
.claude/hooks/ui-test-framework.sh:38:
.claude/hooks/ui-test-framework.sh:39:    log "Created test suite: $suite_name"
.claude/hooks/ui-test-framework.sh:40:    echo "$suite_file"
.claude/hooks/ui-test-framework.sh:41:}
.claude/hooks/ui-test-framework.sh:42:
.claude/hooks/ui-test-framework.sh:43:add_test_case() {
.claude/hooks/ui-test-framework.sh:44:    local suite_name="$1"
.claude/hooks/ui-test-framework.sh:45:    local test_name="$2"
.claude/hooks/ui-test-framework.sh:46:    local test_steps="$3"  # JSON array of steps
.claude/hooks/ui-test-framework.sh:47:    local expected_outcome="$4"
.claude/hooks/ui-test-framework.sh:48:
.claude/hooks/ui-test-framework.sh:49:    local suite_file="${UI_TEST_DIR}/${suite_name}.json"
.claude/hooks/ui-test-framework.sh:50:
.claude/hooks/ui-test-framework.sh:51:    if [[ ! -f "$suite_file" ]]; then
.claude/hooks/ui-test-framework.sh:52:        echo '{"error":"Test suite not found"}'
.claude/hooks/ui-test-framework.sh:53:        return 1
.claude/hooks/ui-test-framework.sh:54:    fi
.claude/hooks/ui-test-framework.sh:55:
.claude/hooks/ui-test-framework.sh:56:    local test_case
.claude/hooks/ui-test-framework.sh:57:    test_case=$(jq -n \
.claude/hooks/ui-test-framework.sh:58:        --arg name "$test_name" \
.claude/hooks/ui-test-framework.sh:59:        --argjson steps "$test_steps" \
.claude/hooks/ui-test-framework.sh:60:        --arg expected "$expected_outcome" \
.claude/hooks/ui-test-framework.sh:61:        '{
.claude/hooks/ui-test-framework.sh:62:            test_name: $name,
.claude/hooks/ui-test-framework.sh:63:            steps: $steps,
.claude/hooks/ui-test-framework.sh:64:            expected_outcome: $expected,
.claude/hooks/ui-test-framework.sh:65:            added_at: (now | todate)
.claude/hooks/ui-test-framework.sh:66:        }')
.claude/hooks/ui-test-framework.sh:67:
.claude/hooks/ui-test-framework.sh:68:    jq --argjson test "$test_case" '.tests += [$test]' "$suite_file" > "${suite_file}.tmp"
.claude/hooks/ui-test-framework.sh:69:    mv "${suite_file}.tmp" "$suite_file"
.claude/hooks/ui-test-framework.sh:70:
.claude/hooks/ui-test-framework.sh:71:    log "Added test case: $test_name to $suite_name"
.claude/hooks/ui-test-framework.sh:72:    echo "$test_case"
.claude/hooks/ui-test-framework.sh:73:}
.claude/hooks/ui-test-framework.sh:74:
.claude/hooks/ui-test-framework.sh:75:# =============================================================================
.claude/hooks/ui-test-framework.sh:76:# BROWSER AUTOMATION HELPERS
.claude/hooks/ui-test-framework.sh:77:# =============================================================================
.claude/hooks/ui-test-framework.sh:78:
.claude/hooks/ui-test-framework.sh:79:generate_browser_script() {
.claude/hooks/ui-test-framework.sh:80:    local test_case="$1"
.claude/hooks/ui-test-framework.sh:81:    local base_url="$2"
.claude/hooks/ui-test-framework.sh:82:
.claude/hooks/ui-test-framework.sh:83:    # Extract test steps
.claude/hooks/ui-test-framework.sh:84:    local test_name
.claude/hooks/ui-test-framework.sh:85:    local steps
.claude/hooks/ui-test-framework.sh:86:    local expected
.claude/hooks/ui-test-framework.sh:87:    test_name=$(echo "$test_case" | jq -r '.test_name')
.claude/hooks/ui-test-framework.sh:88:    steps=$(echo "$test_case" | jq -c '.steps')
.claude/hooks/ui-test-framework.sh:89:    expected=$(echo "$test_case" | jq -r '.expected_outcome')
.claude/hooks/ui-test-framework.sh:90:
.claude/hooks/ui-test-framework.sh:91:    log "Generating browser automation script for: $test_name"
.claude/hooks/ui-test-framework.sh:92:
.claude/hooks/ui-test-framework.sh:93:    # Generate Claude-executable instructions
.claude/hooks/ui-test-framework.sh:94:    jq -n \
.claude/hooks/ui-test-framework.sh:95:        --arg name "$test_name" \
.claude/hooks/ui-test-framework.sh:96:        --arg url "$base_url" \
.claude/hooks/ui-test-framework.sh:97:        --argjson steps "$steps" \
.claude/hooks/ui-test-framework.sh:98:        --arg expected "$expected" \
.claude/hooks/ui-test-framework.sh:99:        '{
.claude/hooks/ui-test-framework.sh:100:            test_name: $name,
.claude/hooks/ui-test-framework.sh:101:            automation_instructions: {
.claude/hooks/ui-test-framework.sh:102:                phase_1_setup: {
.claude/hooks/ui-test-framework.sh:103:                    description: "Initialize browser session",
.claude/hooks/ui-test-framework.sh:104:                    tools: [
.claude/hooks/ui-test-framework.sh:105:                        {
.claude/hooks/ui-test-framework.sh:106:                            tool: "mcp__claude-in-chrome__tabs_context_mcp",
.claude/hooks/ui-test-framework.sh:107:                            params: {createIfEmpty: true},
.claude/hooks/ui-test-framework.sh:108:                            purpose: "Get or create browser tab"
.claude/hooks/ui-test-framework.sh:109:                        },
.claude/hooks/ui-test-framework.sh:110:                        {
.claude/hooks/ui-test-framework.sh:111:                            tool: "mcp__claude-in-chrome__tabs_create_mcp",
.claude/hooks/ui-test-framework.sh:112:                            params: {},
.claude/hooks/ui-test-framework.sh:113:                            purpose: "Create new tab for test"
.claude/hooks/ui-test-framework.sh:114:                        },
.claude/hooks/ui-test-framework.sh:115:                        {
.claude/hooks/ui-test-framework.sh:116:                            tool: "mcp__claude-in-chrome__navigate",
.claude/hooks/ui-test-framework.sh:117:                            params: {url: $url, tabId: "<from_previous_step>"},
.claude/hooks/ui-test-framework.sh:118:                            purpose: "Navigate to application"
.claude/hooks/ui-test-framework.sh:119:                        }
.claude/hooks/ui-test-framework.sh:120:                    ]
.claude/hooks/ui-test-framework.sh:121:                },
.claude/hooks/ui-test-framework.sh:122:                phase_2_actions: {
.claude/hooks/ui-test-framework.sh:123:                    description: "Execute test steps",
.claude/hooks/ui-test-framework.sh:124:                    steps: $steps,
.claude/hooks/ui-test-framework.sh:125:                    tools_per_step: [
.claude/hooks/ui-test-framework.sh:126:                        {
.claude/hooks/ui-test-framework.sh:127:                            type: "click",
.claude/hooks/ui-test-framework.sh:128:                            tool: "mcp__claude-in-chrome__find + computer",
.claude/hooks/ui-test-framework.sh:129:                            example: "find(\"login button\") then computer(left_click, ref)"
.claude/hooks/ui-test-framework.sh:130:                        },
.claude/hooks/ui-test-framework.sh:131:                        {
.claude/hooks/ui-test-framework.sh:132:                            type: "type",
.claude/hooks/ui-test-framework.sh:133:                            tool: "mcp__claude-in-chrome__find + computer",
.claude/hooks/ui-test-framework.sh:134:                            example: "find(\"username field\") then computer(type, \"username\")"
.claude/hooks/ui-test-framework.sh:135:                        },
.claude/hooks/ui-test-framework.sh:136:                        {
.claude/hooks/ui-test-framework.sh:137:                            type: "wait",
.claude/hooks/ui-test-framework.sh:138:                            tool: "mcp__claude-in-chrome__computer",
.claude/hooks/ui-test-framework.sh:139:                            example: "computer(wait, 2 seconds)"
.claude/hooks/ui-test-framework.sh:140:                        },
.claude/hooks/ui-test-framework.sh:141:                        {
.claude/hooks/ui-test-framework.sh:142:                            type: "screenshot",
.claude/hooks/ui-test-framework.sh:143:                            tool: "mcp__claude-in-chrome__computer",
.claude/hooks/ui-test-framework.sh:144:                            example: "computer(screenshot) for evidence"
.claude/hooks/ui-test-framework.sh:145:                        }
.claude/hooks/ui-test-framework.sh:146:                    ]
.claude/hooks/ui-test-framework.sh:147:                },
.claude/hooks/ui-test-framework.sh:148:                phase_3_verification: {
.claude/hooks/ui-test-framework.sh:149:                    description: "Verify expected outcome",
.claude/hooks/ui-test-framework.sh:150:                    expected_outcome: $expected,
.claude/hooks/ui-test-framework.sh:151:                    tools: [
.claude/hooks/ui-test-framework.sh:152:                        {
.claude/hooks/ui-test-framework.sh:153:                            tool: "mcp__claude-in-chrome__read_page",
.claude/hooks/ui-test-framework.sh:154:                            params: {tabId: "<active_tab>"},
.claude/hooks/ui-test-framework.sh:155:                            purpose: "Read page state"
.claude/hooks/ui-test-framework.sh:156:                        },
.claude/hooks/ui-test-framework.sh:157:                        {
.claude/hooks/ui-test-framework.sh:158:                            tool: "mcp__claude-in-chrome__find",
.claude/hooks/ui-test-framework.sh:159:                            params: {query: "<expected_element>", tabId: "<active_tab>"},
.claude/hooks/ui-test-framework.sh:160:                            purpose: "Verify expected elements present"
.claude/hooks/ui-test-framework.sh:161:                        },
.claude/hooks/ui-test-framework.sh:162:                        {
.claude/hooks/ui-test-framework.sh:163:                            tool: "mcp__claude-in-chrome__computer",
.claude/hooks/ui-test-framework.sh:164:                            params: {action: "screenshot"},
.claude/hooks/ui-test-framework.sh:165:                            purpose: "Capture final state as evidence"
.claude/hooks/ui-test-framework.sh:166:                        }
.claude/hooks/ui-test-framework.sh:167:                    ]
.claude/hooks/ui-test-framework.sh:168:                },
.claude/hooks/ui-test-framework.sh:169:                phase_4_report: {
.claude/hooks/ui-test-framework.sh:170:                    description: "Generate test result",
.claude/hooks/ui-test-framework.sh:171:                    report_format: {
.claude/hooks/ui-test-framework.sh:172:                        test_name: $name,
.claude/hooks/ui-test-framework.sh:173:                        status: "pass|fail",
.claude/hooks/ui-test-framework.sh:174:                        actual_outcome: "description",
.claude/hooks/ui-test-framework.sh:175:                        expected_outcome: $expected,
.claude/hooks/ui-test-framework.sh:176:                        screenshots: ["list", "of", "screenshot", "ids"],
.claude/hooks/ui-test-framework.sh:177:                        error: "if any",
.claude/hooks/ui-test-framework.sh:178:                        duration: "seconds"
.claude/hooks/ui-test-framework.sh:179:                    }
.claude/hooks/ui-test-framework.sh:180:                }
.claude/hooks/ui-test-framework.sh:181:            },
.claude/hooks/ui-test-framework.sh:182:            claude_prompt: "Execute this UI test using Claude in Chrome MCP tools:\n\n1. Initialize browser (tabs_context_mcp, tabs_create_mcp, navigate)\n2. Execute steps: " + ($steps | join(", ")) + "\n3. Verify: " + $expected + "\n4. Report: Pass/Fail with evidence (screenshots)\n\nUse find() to locate elements, computer() to interact, read_page() to verify state."
.claude/hooks/ui-test-framework.sh:183:        }'
.claude/hooks/ui-test-framework.sh:184:}
.claude/hooks/ui-test-framework.sh:185:
.claude/hooks/ui-test-framework.sh:186:# =============================================================================
.claude/hooks/ui-test-framework.sh:187:# VISUAL REGRESSION TESTING
.claude/hooks/ui-test-framework.sh:188:# =============================================================================
.claude/hooks/ui-test-framework.sh:189:
.claude/hooks/ui-test-framework.sh:190:take_baseline_screenshot() {
.claude/hooks/ui-test-framework.sh:191:    local test_name="$1"
.claude/hooks/ui-test-framework.sh:192:    local element_selector="$2"
.claude/hooks/ui-test-framework.sh:193:    local url="$3"
.claude/hooks/ui-test-framework.sh:194:
.claude/hooks/ui-test-framework.sh:195:    local baseline_id="${test_name}_baseline_$(date +%s)"
.claude/hooks/ui-test-framework.sh:196:    local baseline_file="${TEST_RECORDINGS}/${baseline_id}.json"
.claude/hooks/ui-test-framework.sh:197:
.claude/hooks/ui-test-framework.sh:198:    log "Taking baseline screenshot for visual regression: $test_name"
.claude/hooks/ui-test-framework.sh:199:
.claude/hooks/ui-test-framework.sh:200:    # Instructions for Claude to take screenshot
.claude/hooks/ui-test-framework.sh:201:    jq -n \
.claude/hooks/ui-test-framework.sh:202:        --arg id "$baseline_id" \
.claude/hooks/ui-test-framework.sh:203:        --arg test "$test_name" \
.claude/hooks/ui-test-framework.sh:204:        --arg selector "$element_selector" \
.claude/hooks/ui-test-framework.sh:205:        --arg url "$url" \
.claude/hooks/ui-test-framework.sh:206:        '{
.claude/hooks/ui-test-framework.sh:207:            baseline_id: $id,
.claude/hooks/ui-test-framework.sh:208:            test_name: $test,
.claude/hooks/ui-test-framework.sh:209:            url: $url,
.claude/hooks/ui-test-framework.sh:210:            element_selector: $selector,
.claude/hooks/ui-test-framework.sh:211:            instructions: [
.claude/hooks/ui-test-framework.sh:212:                "1. Navigate to: " + $url,
.claude/hooks/ui-test-framework.sh:213:                "2. Find element: " + $selector,
.claude/hooks/ui-test-framework.sh:214:                "3. Take screenshot using computer(screenshot) or zoom action",
.claude/hooks/ui-test-framework.sh:215:                "4. Save screenshot ID as baseline for visual comparison",
.claude/hooks/ui-test-framework.sh:216:                "5. Store in: " + "'"$baseline_file"'"
.claude/hooks/ui-test-framework.sh:217:            ],
.claude/hooks/ui-test-framework.sh:218:            purpose: "Visual regression baseline - future screenshots compared against this",
.claude/hooks/ui-test-framework.sh:219:            timestamp: (now | todate)
.claude/hooks/ui-test-framework.sh:220:        }' > "$baseline_file"
.claude/hooks/ui-test-framework.sh:221:
.claude/hooks/ui-test-framework.sh:222:    echo "$baseline_id"
.claude/hooks/ui-test-framework.sh:223:}
.claude/hooks/ui-test-framework.sh:224:
.claude/hooks/ui-test-framework.sh:225:compare_visual_regression() {
.claude/hooks/ui-test-framework.sh:226:    local baseline_id="$1"
.claude/hooks/ui-test-framework.sh:227:    local new_screenshot_id="$2"
.claude/hooks/ui-test-framework.sh:228:
.claude/hooks/ui-test-framework.sh:229:    log "Comparing visual regression: $baseline_id vs $new_screenshot_id"
.claude/hooks/ui-test-framework.sh:230:
.claude/hooks/ui-test-framework.sh:231:    # Return comparison instructions for Claude
.claude/hooks/ui-test-framework.sh:232:    jq -n \
.claude/hooks/ui-test-framework.sh:233:        --arg baseline "$baseline_id" \
.claude/hooks/ui-test-framework.sh:234:        --arg current "$new_screenshot_id" \
.claude/hooks/ui-test-framework.sh:235:        '{
.claude/hooks/ui-test-framework.sh:236:            comparison_task: "Visual regression detection",
.claude/hooks/ui-test-framework.sh:237:            baseline_screenshot: $baseline,
.claude/hooks/ui-test-framework.sh:238:            current_screenshot: $current,
.claude/hooks/ui-test-framework.sh:239:            instructions: [
.claude/hooks/ui-test-framework.sh:240:                "1. Retrieve both screenshot images",
.claude/hooks/ui-test-framework.sh:241:                "2. Compare visually for differences:",
.claude/hooks/ui-test-framework.sh:242:                "   - Layout changes",
.claude/hooks/ui-test-framework.sh:243:                "   - Styling differences",
.claude/hooks/ui-test-framework.sh:244:                "   - Missing elements",
.claude/hooks/ui-test-framework.sh:245:                "   - Text changes",
.claude/hooks/ui-test-framework.sh:246:                "   - Color shifts",
.claude/hooks/ui-test-framework.sh:247:                "3. Report differences with descriptions",
.claude/hooks/ui-test-framework.sh:248:                "4. Classify: pass (no significant changes) or fail (visual regression)"
.claude/hooks/ui-test-framework.sh:249:            ],
.claude/hooks/ui-test-framework.sh:250:            output_format: {
.claude/hooks/ui-test-framework.sh:251:                status: "pass|fail",
.claude/hooks/ui-test-framework.sh:252:                differences: ["list of visual differences found"],
.claude/hooks/ui-test-framework.sh:253:                severity: "minor|major|breaking",
.claude/hooks/ui-test-framework.sh:254:                recommendation: "accept changes|investigate|revert"
.claude/hooks/ui-test-framework.sh:255:            }
.claude/hooks/ui-test-framework.sh:256:        }'
.claude/hooks/ui-test-framework.sh:257:}
.claude/hooks/ui-test-framework.sh:258:
.claude/hooks/ui-test-framework.sh:259:# =============================================================================
.claude/hooks/ui-test-framework.sh:260:# E2E TEST ORCHESTRATION
.claude/hooks/ui-test-framework.sh:261:# =============================================================================
.claude/hooks/ui-test-framework.sh:262:
.claude/hooks/ui-test-framework.sh:263:run_test_suite() {
.claude/hooks/ui-test-framework.sh:264:    local suite_name="$1"
.claude/hooks/ui-test-framework.sh:265:    local record_video="${2:-false}"
.claude/hooks/ui-test-framework.sh:266:
.claude/hooks/ui-test-framework.sh:267:    local suite_file="${UI_TEST_DIR}/${suite_name}.json"
.claude/hooks/ui-test-framework.sh:268:
.claude/hooks/ui-test-framework.sh:269:    if [[ ! -f "$suite_file" ]]; then
.claude/hooks/ui-test-framework.sh:270:        echo '{"error":"Test suite not found: '"$suite_name"'"}'
.claude/hooks/ui-test-framework.sh:271:        return 1
.claude/hooks/ui-test-framework.sh:272:    fi
.claude/hooks/ui-test-framework.sh:273:
.claude/hooks/ui-test-framework.sh:274:    log "Running test suite: $suite_name"
.claude/hooks/ui-test-framework.sh:275:
.claude/hooks/ui-test-framework.sh:276:    local base_url
.claude/hooks/ui-test-framework.sh:277:    local tests
.claude/hooks/ui-test-framework.sh:278:    base_url=$(jq -r '.base_url' "$suite_file")
.claude/hooks/ui-test-framework.sh:279:    tests=$(jq -c '.tests[]' "$suite_file")
.claude/hooks/ui-test-framework.sh:280:
.claude/hooks/ui-test-framework.sh:281:    local test_count=0
.claude/hooks/ui-test-framework.sh:282:    local passed=0
.claude/hooks/ui-test-framework.sh:283:    local failed=0
.claude/hooks/ui-test-framework.sh:284:
.claude/hooks/ui-test-framework.sh:285:    # Generate execution plan for Claude
.claude/hooks/ui-test-framework.sh:286:    local execution_plan='{"test_suite":"'"$suite_name"'","base_url":"'"$base_url"'","tests":[],"recording":'"$record_video"'}'
.claude/hooks/ui-test-framework.sh:287:
.claude/hooks/ui-test-framework.sh:288:    while IFS= read -r test_case; do
.claude/hooks/ui-test-framework.sh:289:        ((test_count++))
.claude/hooks/ui-test-framework.sh:290:
.claude/hooks/ui-test-framework.sh:291:        local test_script
.claude/hooks/ui-test-framework.sh:292:        test_script=$(generate_browser_script "$test_case" "$base_url")
.claude/hooks/ui-test-framework.sh:293:
.claude/hooks/ui-test-framework.sh:294:        execution_plan=$(echo "$execution_plan" | jq \
.claude/hooks/ui-test-framework.sh:295:            --argjson script "$test_script" \
.claude/hooks/ui-test-framework.sh:296:            '.tests += [$script]')
.claude/hooks/ui-test-framework.sh:297:
.claude/hooks/ui-test-framework.sh:298:    done <<< "$tests"
.claude/hooks/ui-test-framework.sh:299:
.claude/hooks/ui-test-framework.sh:300:    # Add GIF recording if requested
.claude/hooks/ui-test-framework.sh:301:    if [[ "$record_video" == "true" ]]; then
.claude/hooks/ui-test-framework.sh:302:        execution_plan=$(echo "$execution_plan" | jq '.recording_instructions = {
.claude/hooks/ui-test-framework.sh:303:            start: "Use gif_creator(action: start_recording) before tests",
.claude/hooks/ui-test-framework.sh:304:            during: "Take screenshots at key moments",
.claude/hooks/ui-test-framework.sh:305:            end: "Use gif_creator(action: export, download: true) after tests",
.claude/hooks/ui-test-framework.sh:306:            purpose: "Visual proof of test execution"
.claude/hooks/ui-test-framework.sh:307:        }')
.claude/hooks/ui-test-framework.sh:308:    fi
.claude/hooks/ui-test-framework.sh:309:
.claude/hooks/ui-test-framework.sh:310:    # Return full execution plan
.claude/hooks/ui-test-framework.sh:311:    jq -n \
.claude/hooks/ui-test-framework.sh:312:        --argjson plan "$execution_plan" \
.claude/hooks/ui-test-framework.sh:313:        --argjson count "$test_count" \
.claude/hooks/ui-test-framework.sh:314:        '{
.claude/hooks/ui-test-framework.sh:315:            suite_execution: $plan,
.claude/hooks/ui-test-framework.sh:316:            total_tests: $count,
.claude/hooks/ui-test-framework.sh:317:            status: "ready_to_execute",
.claude/hooks/ui-test-framework.sh:318:            instructions: [
.claude/hooks/ui-test-framework.sh:319:                "1. Start GIF recording if recording: true",
.claude/hooks/ui-test-framework.sh:320:                "2. For each test in tests array:",
.claude/hooks/ui-test-framework.sh:321:                "   a. Execute automation_instructions phase by phase",
.claude/hooks/ui-test-framework.sh:322:                "   b. Take screenshots for evidence",
.claude/hooks/ui-test-framework.sh:323:                "   c. Record result (pass/fail)",
.claude/hooks/ui-test-framework.sh:324:                "3. Stop GIF recording and export",
.claude/hooks/ui-test-framework.sh:325:                "4. Generate summary report",
.claude/hooks/ui-test-framework.sh:326:                "5. Save results to: '"$TEST_RESULTS"'"
.claude/hooks/ui-test-framework.sh:327:            ],
.claude/hooks/ui-test-framework.sh:328:            note: "Use Claude in Chrome MCP tools to execute this plan. All tools are already available."
.claude/hooks/ui-test-framework.sh:329:        }'
.claude/hooks/ui-test-framework.sh:330:}
.claude/hooks/ui-test-framework.sh:331:
.claude/hooks/ui-test-framework.sh:332:record_test_result() {
.claude/hooks/ui-test-framework.sh:333:    local test_name="$1"
.claude/hooks/ui-test-framework.sh:334:    local suite_name="$2"
.claude/hooks/ui-test-framework.sh:335:    local status="$3"
.claude/hooks/ui-test-framework.sh:336:    local duration="$4"
.claude/hooks/ui-test-framework.sh:337:    local error_message="${5:-}"
.claude/hooks/ui-test-framework.sh:338:    local screenshots="${6:-[]}"
.claude/hooks/ui-test-framework.sh:339:
.claude/hooks/ui-test-framework.sh:340:    local result
.claude/hooks/ui-test-framework.sh:341:    result=$(jq -n \
.claude/hooks/ui-test-framework.sh:342:        --arg test "$test_name" \
.claude/hooks/ui-test-framework.sh:343:        --arg suite "$suite_name" \
.claude/hooks/ui-test-framework.sh:344:        --arg status "$status" \
.claude/hooks/ui-test-framework.sh:345:        --argjson duration "$duration" \
.claude/hooks/ui-test-framework.sh:346:        --arg error "$error_message" \
.claude/hooks/ui-test-framework.sh:347:        --argjson screenshots "$screenshots" \
.claude/hooks/ui-test-framework.sh:348:        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/ui-test-framework.sh:349:        '{
.claude/hooks/ui-test-framework.sh:350:            timestamp: $ts,
.claude/hooks/ui-test-framework.sh:351:            test_name: $test,
.claude/hooks/ui-test-framework.sh:352:            suite_name: $suite,
.claude/hooks/ui-test-framework.sh:353:            status: $status,
.claude/hooks/ui-test-framework.sh:354:            duration_seconds: $duration,
.claude/hooks/ui-test-framework.sh:355:            error_message: $error,
.claude/hooks/ui-test-framework.sh:356:            screenshots: $screenshots
.claude/hooks/ui-test-framework.sh:357:        }')
.claude/hooks/ui-test-framework.sh:358:
.claude/hooks/ui-test-framework.sh:359:    echo "$result" >> "$TEST_RESULTS"
.claude/hooks/ui-test-framework.sh:360:    log "Recorded test result: $test_name -> $status"
.claude/hooks/ui-test-framework.sh:361:    echo "$result"
.claude/hooks/ui-test-framework.sh:362:}
.claude/hooks/ui-test-framework.sh:363:
.claude/hooks/ui-test-framework.sh:364:# =============================================================================
.claude/hooks/ui-test-framework.sh:365:# SMART TEST GENERATION
.claude/hooks/ui-test-framework.sh:366:# =============================================================================
.claude/hooks/ui-test-framework.sh:367:
.claude/hooks/ui-test-framework.sh:368:generate_tests_from_page() {
.claude/hooks/ui-test-framework.sh:369:    local url="$1"
.claude/hooks/ui-test-framework.sh:370:    local focus_area="${2:-all}"
.claude/hooks/ui-test-framework.sh:371:
.claude/hooks/ui-test-framework.sh:372:    log "Generating tests from page: $url"
.claude/hooks/ui-test-framework.sh:373:
.claude/hooks/ui-test-framework.sh:374:    # Return instructions for Claude to analyze and generate tests
.claude/hooks/ui-test-framework.sh:375:    jq -n \
.claude/hooks/ui-test-framework.sh:376:        --arg url "$url" \
.claude/hooks/ui-test-framework.sh:377:        --arg focus "$focus_area" \
.claude/hooks/ui-test-framework.sh:378:        '{
.claude/hooks/ui-test-framework.sh:379:            task: "Analyze page and generate UI tests",
.claude/hooks/ui-test-framework.sh:380:            url: $url,
.claude/hooks/ui-test-framework.sh:381:            focus_area: $focus,
.claude/hooks/ui-test-framework.sh:382:            instructions: [
.claude/hooks/ui-test-framework.sh:383:                "1. Navigate to URL using Claude in Chrome",
.claude/hooks/ui-test-framework.sh:384:                "2. Use read_page() to analyze page structure",
.claude/hooks/ui-test-framework.sh:385:                "3. Identify interactive elements:",
.claude/hooks/ui-test-framework.sh:386:                "   - Forms and input fields",
.claude/hooks/ui-test-framework.sh:387:                "   - Buttons and links",
.claude/hooks/ui-test-framework.sh:388:                "   - Navigation menus",
.claude/hooks/ui-test-framework.sh:389:                "   - Modal dialogs",
.claude/hooks/ui-test-framework.sh:390:                "   - Dynamic content areas",
.claude/hooks/ui-test-framework.sh:391:                "4. For each element, generate test case:",
.claude/hooks/ui-test-framework.sh:392:                "   - Test name (e.g., \"Submit contact form\")",
.claude/hooks/ui-test-framework.sh:393:                "   - Steps to interact",
.claude/hooks/ui-test-framework.sh:394:                "   - Expected outcome",
.claude/hooks/ui-test-framework.sh:395:                "5. Create test suite with all generated tests"
.claude/hooks/ui-test-framework.sh:396:            ],
.claude/hooks/ui-test-framework.sh:397:            output_format: {
.claude/hooks/ui-test-framework.sh:398:                suite_name: "generated_tests_" + $url,
.claude/hooks/ui-test-framework.sh:399:                tests: [
.claude/hooks/ui-test-framework.sh:400:                    {
.claude/hooks/ui-test-framework.sh:401:                        test_name: "example",
.claude/hooks/ui-test-framework.sh:402:                        steps: ["step1", "step2"],
.claude/hooks/ui-test-framework.sh:403:                        expected_outcome: "outcome"
.claude/hooks/ui-test-framework.sh:404:                    }
.claude/hooks/ui-test-framework.sh:405:                ]
.claude/hooks/ui-test-framework.sh:406:            },
.claude/hooks/ui-test-framework.sh:407:            usage: "Use generated tests with: ui-test-framework.sh run-test-suite <suite_name>"
.claude/hooks/ui-test-framework.sh:408:        }'
.claude/hooks/ui-test-framework.sh:409:}
.claude/hooks/ui-test-framework.sh:410:
.claude/hooks/ui-test-framework.sh:411:# =============================================================================
.claude/hooks/ui-test-framework.sh:412:# COMMAND INTERFACE
.claude/hooks/ui-test-framework.sh:413:# =============================================================================
.claude/hooks/ui-test-framework.sh:414:
.claude/hooks/ui-test-framework.sh:415:case "${1:-help}" in
.claude/hooks/ui-test-framework.sh:416:    create-suite)
.claude/hooks/ui-test-framework.sh:417:        create_test_suite "${2:-test_suite}" "${3:-http://localhost:3000}"
.claude/hooks/ui-test-framework.sh:418:        ;;
.claude/hooks/ui-test-framework.sh:419:    add-test)
.claude/hooks/ui-test-framework.sh:420:        # args: suite_name test_name steps_json expected_outcome
.claude/hooks/ui-test-framework.sh:421:        add_test_case "${2:-suite}" "${3:-test}" "${4:-[]}" "${5:-outcome}"
.claude/hooks/ui-test-framework.sh:422:        ;;
.claude/hooks/ui-test-framework.sh:423:    generate-script)
.claude/hooks/ui-test-framework.sh:424:        # Generate automation script for a test
.claude/hooks/ui-test-framework.sh:425:        test_case=$(cat "${2:-test.json}")
.claude/hooks/ui-test-framework.sh:426:        generate_browser_script "$test_case" "${3:-http://localhost:3000}"
.claude/hooks/ui-test-framework.sh:427:        ;;
.claude/hooks/ui-test-framework.sh:428:    run-suite)
.claude/hooks/ui-test-framework.sh:429:        run_test_suite "${2:-test_suite}" "${3:-false}"
.claude/hooks/ui-test-framework.sh:430:        ;;
.claude/hooks/ui-test-framework.sh:431:    record-result)
.claude/hooks/ui-test-framework.sh:432:        record_test_result "${2:-test}" "${3:-suite}" "${4:-pass}" "${5:-0}" "${6:-}" "${7:-[]}"
.claude/hooks/ui-test-framework.sh:433:        ;;
.claude/hooks/ui-test-framework.sh:434:    baseline-screenshot)
.claude/hooks/ui-test-framework.sh:435:        take_baseline_screenshot "${2:-test}" "${3:-element}" "${4:-http://localhost:3000}"
.claude/hooks/ui-test-framework.sh:436:        ;;
.claude/hooks/ui-test-framework.sh:437:    visual-regression)
.claude/hooks/ui-test-framework.sh:438:        compare_visual_regression "${2:-baseline_id}" "${3:-screenshot_id}"
.claude/hooks/ui-test-framework.sh:439:        ;;
.claude/hooks/ui-test-framework.sh:440:    generate-tests)
.claude/hooks/ui-test-framework.sh:441:        generate_tests_from_page "${2:-http://localhost:3000}" "${3:-all}"
.claude/hooks/ui-test-framework.sh:442:        ;;
.claude/hooks/ui-test-framework.sh:443:    list-suites)
.claude/hooks/ui-test-framework.sh:444:        ls -1 "${UI_TEST_DIR}"/*.json 2>/dev/null | xargs -I {} basename {} .json || echo "No test suites found"
.claude/hooks/ui-test-framework.sh:445:        ;;
.claude/hooks/ui-test-framework.sh:446:    view-results)
.claude/hooks/ui-test-framework.sh:447:        if [[ -f "$TEST_RESULTS" ]]; then
.claude/hooks/ui-test-framework.sh:448:            tail -n "${2:-10}" "$TEST_RESULTS" | jq -s '{
.claude/hooks/ui-test-framework.sh:449:                total: length,
.claude/hooks/ui-test-framework.sh:450:                passed: (map(select(.status == "pass")) | length),
.claude/hooks/ui-test-framework.sh:451:                failed: (map(select(.status == "fail")) | length),
.claude/hooks/ui-test-framework.sh:452:                recent: .
.claude/hooks/ui-test-framework.sh:453:            }'
.claude/hooks/ui-test-framework.sh:454:        else
.claude/hooks/ui-test-framework.sh:455:            echo '{"total":0,"passed":0,"failed":0,"recent":[]}'
.claude/hooks/ui-test-framework.sh:456:        fi
.claude/hooks/ui-test-framework.sh:457:        ;;
.claude/hooks/ui-test-framework.sh:458:    help|*)
.claude/hooks/ui-test-framework.sh:459:        cat << 'EOF'
.claude/hooks/ui-test-framework.sh:460:UI Test Framework - Automated Browser Testing
.claude/hooks/ui-test-framework.sh:461:
.claude/hooks/ui-test-framework.sh:462:Solves the problem: "UI testing is tedious"
.claude/hooks/ui-test-framework.sh:463:
.claude/hooks/ui-test-framework.sh:464:USES CLAUDE IN CHROME MCP FOR AUTOMATION!
.claude/hooks/ui-test-framework.sh:465:
.claude/hooks/ui-test-framework.sh:466:USAGE:
.claude/hooks/ui-test-framework.sh:467:  ui-test-framework.sh <command> [args]
.claude/hooks/ui-test-framework.sh:468:
.claude/hooks/ui-test-framework.sh:469:COMMANDS:
.claude/hooks/ui-test-framework.sh:470:  create-suite <name> <base_url>
.claude/hooks/ui-test-framework.sh:471:    - Create new test suite
.claude/hooks/ui-test-framework.sh:472:    - Example: create-suite "auth_tests" "http://localhost:3000"
.claude/hooks/ui-test-framework.sh:473:
.claude/hooks/ui-test-framework.sh:474:  add-test <suite> <test_name> <steps_json> <expected>
.claude/hooks/ui-test-framework.sh:475:    - Add test case to suite
.claude/hooks/ui-test-framework.sh:476:    - Steps: JSON array like '["Click login", "Enter credentials", "Submit"]'
.claude/hooks/ui-test-framework.sh:477:    - Example: add-test "auth_tests" "Login flow" '[...]' "Dashboard loads"
.claude/hooks/ui-test-framework.sh:478:
.claude/hooks/ui-test-framework.sh:479:  run-suite <suite_name> [record_gif]
.claude/hooks/ui-test-framework.sh:480:    - Execute all tests in suite using Claude in Chrome
.claude/hooks/ui-test-framework.sh:481:    - record_gif: true/false (creates GIF recording of execution)
.claude/hooks/ui-test-framework.sh:482:    - Returns execution plan for Claude to follow
.claude/hooks/ui-test-framework.sh:483:
.claude/hooks/ui-test-framework.sh:484:  generate-tests <url> [focus_area]
.claude/hooks/ui-test-framework.sh:485:    - Automatically generate tests by analyzing a page
.claude/hooks/ui-test-framework.sh:486:    - Focus: "forms", "navigation", "interactions", or "all"
.claude/hooks/ui-test-framework.sh:487:    - Uses Claude in Chrome to crawl and identify testable elements
.claude/hooks/ui-test-framework.sh:488:
.claude/hooks/ui-test-framework.sh:489:  baseline-screenshot <test_name> <element> <url>
.claude/hooks/ui-test-framework.sh:490:    - Take baseline screenshot for visual regression
.claude/hooks/ui-test-framework.sh:491:    - Future tests compare against this baseline
.claude/hooks/ui-test-framework.sh:492:
.claude/hooks/ui-test-framework.sh:493:  visual-regression <baseline_id> <current_screenshot_id>
.claude/hooks/ui-test-framework.sh:494:    - Compare screenshots for visual regressions
.claude/hooks/ui-test-framework.sh:495:    - Returns differences and recommendations
.claude/hooks/ui-test-framework.sh:496:
.claude/hooks/ui-test-framework.sh:497:  record-result <test> <suite> <status> <duration> [error] [screenshots]
.claude/hooks/ui-test-framework.sh:498:    - Record test execution result
.claude/hooks/ui-test-framework.sh:499:    - Status: pass/fail
.claude/hooks/ui-test-framework.sh:500:    - Duration: seconds
.claude/hooks/ui-test-framework.sh:501:
.claude/hooks/ui-test-framework.sh:502:  view-results [limit]
.claude/hooks/ui-test-framework.sh:503:    - View recent test results
.claude/hooks/ui-test-framework.sh:504:    - Default: last 10 results
.claude/hooks/ui-test-framework.sh:505:
.claude/hooks/ui-test-framework.sh:506:  list-suites
.claude/hooks/ui-test-framework.sh:507:    - List all test suites
.claude/hooks/ui-test-framework.sh:508:
.claude/hooks/ui-test-framework.sh:509:WORKFLOW EXAMPLE:
.claude/hooks/ui-test-framework.sh:510:  # 1. Create test suite
.claude/hooks/ui-test-framework.sh:511:  ui-test-framework.sh create-suite "checkout" "http://localhost:3000"
.claude/hooks/ui-test-framework.sh:512:
.claude/hooks/ui-test-framework.sh:513:  # 2. Add test cases
.claude/hooks/ui-test-framework.sh:514:  ui-test-framework.sh add-test "checkout" "Add to cart" \
.claude/hooks/ui-test-framework.sh:515:    '["Click product", "Click add to cart", "Verify cart count"]' \
.claude/hooks/ui-test-framework.sh:516:    "Cart shows 1 item"
.claude/hooks/ui-test-framework.sh:517:
.claude/hooks/ui-test-framework.sh:518:  # 3. Run tests (with GIF recording)
.claude/hooks/ui-test-framework.sh:519:  ui-test-framework.sh run-suite "checkout" true > execution_plan.json
.claude/hooks/ui-test-framework.sh:520:
.claude/hooks/ui-test-framework.sh:521:  # 4. Execute plan using Claude in Chrome MCP
.claude/hooks/ui-test-framework.sh:522:  # (Claude reads execution_plan.json and executes with browser tools)
.claude/hooks/ui-test-framework.sh:523:
.claude/hooks/ui-test-framework.sh:524:  # 5. View results
.claude/hooks/ui-test-framework.sh:525:  ui-test-framework.sh view-results 5
.claude/hooks/ui-test-framework.sh:526:
.claude/hooks/ui-test-framework.sh:527:SMART TEST GENERATION:
.claude/hooks/ui-test-framework.sh:528:  # Auto-generate tests from existing page
.claude/hooks/ui-test-framework.sh:529:  ui-test-framework.sh generate-tests "http://localhost:3000/login" "forms"
.claude/hooks/ui-test-framework.sh:530:
.claude/hooks/ui-test-framework.sh:531:  # Claude will:
.claude/hooks/ui-test-framework.sh:532:  # 1. Analyze page structure
.claude/hooks/ui-test-framework.sh:533:  # 2. Identify all interactive elements
.claude/hooks/ui-test-framework.sh:534:  # 3. Generate test cases for each interaction
.claude/hooks/ui-test-framework.sh:535:  # 4. Create complete test suite
.claude/hooks/ui-test-framework.sh:536:
.claude/hooks/ui-test-framework.sh:537:VISUAL REGRESSION TESTING:
.claude/hooks/ui-test-framework.sh:538:  # Take baseline
.claude/hooks/ui-test-framework.sh:539:  ui-test-framework.sh baseline-screenshot "homepage" ".hero-section" "http://localhost:3000"
.claude/hooks/ui-test-framework.sh:540:
.claude/hooks/ui-test-framework.sh:541:  # After code changes, compare
.claude/hooks/ui-test-framework.sh:542:  ui-test-framework.sh visual-regression "baseline_id" "new_screenshot_id"
.claude/hooks/ui-test-framework.sh:543:
.claude/hooks/ui-test-framework.sh:544:KEY FEATURES:
.claude/hooks/ui-test-framework.sh:545:   Automated browser testing with Claude in Chrome
.claude/hooks/ui-test-framework.sh:546:   GIF recording of test execution
.claude/hooks/ui-test-framework.sh:547:   Visual regression detection
.claude/hooks/ui-test-framework.sh:548:   Smart test generation from page analysis
.claude/hooks/ui-test-framework.sh:549:   Test result tracking and history
.claude/hooks/ui-test-framework.sh:550:   Screenshot evidence for each test
.claude/hooks/ui-test-framework.sh:551:   Integration with debug-orchestrator for regression detection
.claude/hooks/ui-test-framework.sh:552:
.claude/hooks/ui-test-framework.sh:553:CLAUDE IN CHROME MCP TOOLS USED:
.claude/hooks/ui-test-framework.sh:554:   tabs_context_mcp - Browser session management
.claude/hooks/ui-test-framework.sh:555:   tabs_create_mcp - Create test tabs
.claude/hooks/ui-test-framework.sh:556:   navigate - Go to URLs
.claude/hooks/ui-test-framework.sh:557:   find - Locate elements by description
.claude/hooks/ui-test-framework.sh:558:   computer - Click, type, screenshot
.claude/hooks/ui-test-framework.sh:559:   read_page - Verify page state
.claude/hooks/ui-test-framework.sh:560:   gif_creator - Record test execution
.claude/hooks/ui-test-framework.sh:561:
.claude/hooks/ui-test-framework.sh:562:INTEGRATION WITH DEBUG ORCHESTRATOR:
.claude/hooks/ui-test-framework.sh:563:  # Combine UI testing with debugging
.claude/hooks/ui-test-framework.sh:564:  debug-orchestrator.sh smart-debug "Button not working" ui \
.claude/hooks/ui-test-framework.sh:565:    "ui-test-framework.sh run-suite button_tests"
.claude/hooks/ui-test-framework.sh:566:
.claude/hooks/ui-test-framework.sh:567:  # Regression detection with UI tests
.claude/hooks/ui-test-framework.sh:568:  debug-orchestrator.sh verify-fix snapshot_123 \
.claude/hooks/ui-test-framework.sh:569:    "ui-test-framework.sh run-suite full_suite"
.claude/hooks/ui-test-framework.sh:570:
.claude/hooks/ui-test-framework.sh:571:EOF
.claude/hooks/ui-test-framework.sh:572:        ;;
.claude/hooks/ui-test-framework.sh:573:esac
.claude/hooks/meta-reflection.sh:1:#!/bin/bash
.claude/hooks/meta-reflection.sh:2:# Meta-Reflection - Reflects on own decision-making process
.claude/hooks/meta-reflection.sh:3:
.claude/hooks/meta-reflection.sh:4:set -uo pipefail
.claude/hooks/meta-reflection.sh:5:
.claude/hooks/meta-reflection.sh:6:REFLECTION_DIR="${HOME}/.claude/reflections"
.claude/hooks/meta-reflection.sh:7:REFLECTIONS_FILE="$REFLECTION_DIR/meta_reflections.jsonl"
.claude/hooks/meta-reflection.sh:8:LOG_FILE="${HOME}/.claude/meta-reflection.log"
.claude/hooks/meta-reflection.sh:9:
.claude/hooks/meta-reflection.sh:10:MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/meta-reflection.sh:11:
.claude/hooks/meta-reflection.sh:12:log() {
.claude/hooks/meta-reflection.sh:13:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/meta-reflection.sh:14:}
.claude/hooks/meta-reflection.sh:15:
.claude/hooks/meta-reflection.sh:16:init_reflection() {
.claude/hooks/meta-reflection.sh:17:    mkdir -p "$REFLECTION_DIR"
.claude/hooks/meta-reflection.sh:18:    [[ -f "$REFLECTIONS_FILE" ]] || touch "$REFLECTIONS_FILE"
.claude/hooks/meta-reflection.sh:19:}
.claude/hooks/meta-reflection.sh:20:
.claude/hooks/meta-reflection.sh:21:# Create reflection after significant work
.claude/hooks/meta-reflection.sh:22:reflect() {
.claude/hooks/meta-reflection.sh:23:    local focus="$1"  # why_worked, why_failed, what_learned, alternatives
.claude/hooks/meta-reflection.sh:24:    local task="$2"
.claude/hooks/meta-reflection.sh:25:    local outcome="$3"
.claude/hooks/meta-reflection.sh:26:    local reasoning="${4:-}"
.claude/hooks/meta-reflection.sh:27:
.claude/hooks/meta-reflection.sh:28:    init_reflection
.claude/hooks/meta-reflection.sh:29:
.claude/hooks/meta-reflection.sh:30:    local timestamp
.claude/hooks/meta-reflection.sh:31:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/meta-reflection.sh:32:
.claude/hooks/meta-reflection.sh:33:    local reflection
.claude/hooks/meta-reflection.sh:34:    case "$focus" in
.claude/hooks/meta-reflection.sh:35:        why_worked)
.claude/hooks/meta-reflection.sh:36:            reflection="Task '$task' succeeded. Key factors: $reasoning. This approach should be reused for similar tasks."
.claude/hooks/meta-reflection.sh:37:            ;;
.claude/hooks/meta-reflection.sh:38:        why_failed)
.claude/hooks/meta-reflection.sh:39:            reflection="Task '$task' failed. Root causes: $reasoning. Future tasks should avoid this approach or address these issues first."
.claude/hooks/meta-reflection.sh:40:            ;;
.claude/hooks/meta-reflection.sh:41:        what_learned)
.claude/hooks/meta-reflection.sh:42:            reflection="From task '$task': $reasoning. This insight will improve future decision-making."
.claude/hooks/meta-reflection.sh:43:            ;;
.claude/hooks/meta-reflection.sh:44:        alternatives)
.claude/hooks/meta-reflection.sh:45:            reflection="Task '$task' completed, but alternative approaches considered: $reasoning. May be more efficient for similar future tasks."
.claude/hooks/meta-reflection.sh:46:            ;;
.claude/hooks/meta-reflection.sh:47:    esac
.claude/hooks/meta-reflection.sh:48:
.claude/hooks/meta-reflection.sh:49:    local record
.claude/hooks/meta-reflection.sh:50:    record=$(jq -n \
.claude/hooks/meta-reflection.sh:51:        --arg focus "$focus" \
.claude/hooks/meta-reflection.sh:52:        --arg task "$task" \
.claude/hooks/meta-reflection.sh:53:        --arg outcome "$outcome" \
.claude/hooks/meta-reflection.sh:54:        --arg reflection "$reflection" \
.claude/hooks/meta-reflection.sh:55:        --arg ts "$timestamp" \
.claude/hooks/meta-reflection.sh:56:        '{focus: $focus, task: $task, outcome: $outcome, reflection: $reflection, timestamp: $ts}' 2>/dev/null || echo '{"focus":"error","task":"error","outcome":"error","reflection":"error","timestamp":"error"}')
.claude/hooks/meta-reflection.sh:57:
.claude/hooks/meta-reflection.sh:58:    echo "$record" >> "$REFLECTIONS_FILE"
.claude/hooks/meta-reflection.sh:59:
.claude/hooks/meta-reflection.sh:60:    # Store in memory as semantic knowledge
.claude/hooks/meta-reflection.sh:61:    [[ -x "$MEMORY_MANAGER" ]] && \
.claude/hooks/meta-reflection.sh:62:        "$MEMORY_MANAGER" reflect "$focus" "$reflection" "$reasoning" 2>/dev/null || true
.claude/hooks/meta-reflection.sh:63:
.claude/hooks/meta-reflection.sh:64:    log "Created meta-reflection: $focus for $task"
.claude/hooks/meta-reflection.sh:65:    echo "$record"
.claude/hooks/meta-reflection.sh:66:}
.claude/hooks/meta-reflection.sh:67:
.claude/hooks/meta-reflection.sh:68:# Get insights from reflections
.claude/hooks/meta-reflection.sh:69:get_insights() {
.claude/hooks/meta-reflection.sh:70:    local focus="${1:-}"
.claude/hooks/meta-reflection.sh:71:
.claude/hooks/meta-reflection.sh:72:    init_reflection
.claude/hooks/meta-reflection.sh:73:
.claude/hooks/meta-reflection.sh:74:    if [[ -n "$focus" ]]; then
.claude/hooks/meta-reflection.sh:75:        grep "\"focus\":\"$focus\"" "$REFLECTIONS_FILE" 2>/dev/null | jq -s '.' || echo '[]'
.claude/hooks/meta-reflection.sh:76:    else
.claude/hooks/meta-reflection.sh:77:        jq -s '.' "$REFLECTIONS_FILE" 2>/dev/null || echo '[]'
.claude/hooks/meta-reflection.sh:78:    fi
.claude/hooks/meta-reflection.sh:79:}
.claude/hooks/meta-reflection.sh:80:
.claude/hooks/meta-reflection.sh:81:case "${1:-help}" in
.claude/hooks/meta-reflection.sh:82:    reflect) reflect "${2:-what_learned}" "${3:-task}" "${4:-success}" "${5:-}" ;;
.claude/hooks/meta-reflection.sh:83:    insights) get_insights "${2:-}" ;;
.claude/hooks/meta-reflection.sh:84:    *) echo "Usage: $0 {reflect|insights} [args]" ;;
.claude/hooks/meta-reflection.sh:85:esac
.claude/hooks/react-reflexion.sh:1:#!/bin/bash
.claude/hooks/react-reflexion.sh:2:# ReAct + Reflexion Framework - Reasoning + Acting + Self-Reflection
.claude/hooks/react-reflexion.sh:3:# Based on: langchain reflection patterns, DocsGPT ReActAgent, llama_index ReActAgent
.claude/hooks/react-reflexion.sh:4:# Implements think  act  observe  reflect loop
.claude/hooks/react-reflexion.sh:5:
.claude/hooks/react-reflexion.sh:6:set -eo pipefail
.claude/hooks/react-reflexion.sh:7:
.claude/hooks/react-reflexion.sh:8:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/react-reflexion.sh:9:MEMORY_MANAGER="${CLAUDE_DIR}/hooks/memory-manager.sh"
.claude/hooks/react-reflexion.sh:10:LOG_FILE="${CLAUDE_DIR}/react-reflexion.log"
.claude/hooks/react-reflexion.sh:11:
.claude/hooks/react-reflexion.sh:12:log() {
.claude/hooks/react-reflexion.sh:13:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/react-reflexion.sh:14:}
.claude/hooks/react-reflexion.sh:15:
.claude/hooks/react-reflexion.sh:16:# =============================================================================
.claude/hooks/react-reflexion.sh:17:# REACT CYCLE: Thought  Action  Observation
.claude/hooks/react-reflexion.sh:18:# =============================================================================
.claude/hooks/react-reflexion.sh:19:
.claude/hooks/react-reflexion.sh:20:# Generate reasoning before action (based on ReAct pattern)
.claude/hooks/react-reflexion.sh:21:generate_thought() {
.claude/hooks/react-reflexion.sh:22:    local goal="$1"
.claude/hooks/react-reflexion.sh:23:    local context="$2"
.claude/hooks/react-reflexion.sh:24:    local iteration="${3:-1}"
.claude/hooks/react-reflexion.sh:25:
.claude/hooks/react-reflexion.sh:26:    log "Generating thought for: $goal (iteration $iteration)"
.claude/hooks/react-reflexion.sh:27:
.claude/hooks/react-reflexion.sh:28:    # Retrieve relevant memories
.claude/hooks/react-reflexion.sh:29:    local memories=""
.claude/hooks/react-reflexion.sh:30:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/react-reflexion.sh:31:        memories=$("$MEMORY_MANAGER" remember-scored "$goal" 3 2>/dev/null || echo "[]")
.claude/hooks/react-reflexion.sh:32:    fi
.claude/hooks/react-reflexion.sh:33:
.claude/hooks/react-reflexion.sh:34:    local reasoning_prompt="Before I act, let me think through this step-by-step:\\n\\n1. What is the goal? $goal\\n2. What do I know? $context\\n3. What have I learned from similar situations?\\n4. What are my options?\\n5. What is the best approach and why?\\n6. What could go wrong?\\n7. How will I know if I succeeded?\\n\\nMy reasoning:"
.claude/hooks/react-reflexion.sh:35:
.claude/hooks/react-reflexion.sh:36:    jq -n \
.claude/hooks/react-reflexion.sh:37:        --arg goal "$goal" \
.claude/hooks/react-reflexion.sh:38:        --arg context "$context" \
.claude/hooks/react-reflexion.sh:39:        --argjson iteration "$iteration" \
.claude/hooks/react-reflexion.sh:40:        --argjson memories "${memories:-[]}" \
.claude/hooks/react-reflexion.sh:41:        --arg prompt "$reasoning_prompt" \
.claude/hooks/react-reflexion.sh:42:        '{
.claude/hooks/react-reflexion.sh:43:            goal: $goal,
.claude/hooks/react-reflexion.sh:44:            context: $context,
.claude/hooks/react-reflexion.sh:45:            iteration: $iteration,
.claude/hooks/react-reflexion.sh:46:            relevant_memories: $memories,
.claude/hooks/react-reflexion.sh:47:            reasoning_prompt: $prompt,
.claude/hooks/react-reflexion.sh:48:            thought: ""
.claude/hooks/react-reflexion.sh:49:        }'
.claude/hooks/react-reflexion.sh:50:}
.claude/hooks/react-reflexion.sh:51:
.claude/hooks/react-reflexion.sh:52:# Record the action taken
.claude/hooks/react-reflexion.sh:53:record_action() {
.claude/hooks/react-reflexion.sh:54:    local thought="$1"
.claude/hooks/react-reflexion.sh:55:    local action="$2"
.claude/hooks/react-reflexion.sh:56:    local action_input="$3"
.claude/hooks/react-reflexion.sh:57:
.claude/hooks/react-reflexion.sh:58:    log "Recording action: $action"
.claude/hooks/react-reflexion.sh:59:
.claude/hooks/react-reflexion.sh:60:    jq -n \
.claude/hooks/react-reflexion.sh:61:        --arg thought "$thought" \
.claude/hooks/react-reflexion.sh:62:        --arg action "$action" \
.claude/hooks/react-reflexion.sh:63:        --arg input "$action_input" \
.claude/hooks/react-reflexion.sh:64:        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/react-reflexion.sh:65:        '{
.claude/hooks/react-reflexion.sh:66:            thought: $thought,
.claude/hooks/react-reflexion.sh:67:            action: $action,
.claude/hooks/react-reflexion.sh:68:            action_input: $input,
.claude/hooks/react-reflexion.sh:69:            timestamp: $ts
.claude/hooks/react-reflexion.sh:70:        }'
.claude/hooks/react-reflexion.sh:71:}
.claude/hooks/react-reflexion.sh:72:
.claude/hooks/react-reflexion.sh:73:# Record the observation/result
.claude/hooks/react-reflexion.sh:74:record_observation() {
.claude/hooks/react-reflexion.sh:75:    local action="$1"
.claude/hooks/react-reflexion.sh:76:    local result="$2"
.claude/hooks/react-reflexion.sh:77:    local success="${3:-unknown}"
.claude/hooks/react-reflexion.sh:78:
.claude/hooks/react-reflexion.sh:79:    log "Recording observation: success=$success"
.claude/hooks/react-reflexion.sh:80:
.claude/hooks/react-reflexion.sh:81:    jq -n \
.claude/hooks/react-reflexion.sh:82:        --arg action "$action" \
.claude/hooks/react-reflexion.sh:83:        --arg result "$result" \
.claude/hooks/react-reflexion.sh:84:        --arg success "$success" \
.claude/hooks/react-reflexion.sh:85:        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/react-reflexion.sh:86:        '{
.claude/hooks/react-reflexion.sh:87:            action: $action,
.claude/hooks/react-reflexion.sh:88:            result: $result,
.claude/hooks/react-reflexion.sh:89:            success: $success,
.claude/hooks/react-reflexion.sh:90:            timestamp: $ts
.claude/hooks/react-reflexion.sh:91:        }'
.claude/hooks/react-reflexion.sh:92:}
.claude/hooks/react-reflexion.sh:93:
.claude/hooks/react-reflexion.sh:94:# =============================================================================
.claude/hooks/react-reflexion.sh:95:# REFLEXION: Self-Critique and Learning
.claude/hooks/react-reflexion.sh:96:# =============================================================================
.claude/hooks/react-reflexion.sh:97:
.claude/hooks/react-reflexion.sh:98:# Generate self-reflection on the action taken (based on Reflexion paper)
.claude/hooks/react-reflexion.sh:99:generate_reflection() {
.claude/hooks/react-reflexion.sh:100:    local thought="$1"
.claude/hooks/react-reflexion.sh:101:    local action="$2"
.claude/hooks/react-reflexion.sh:102:    local observation="$3"
.claude/hooks/react-reflexion.sh:103:    local success="${4:-unknown}"
.claude/hooks/react-reflexion.sh:104:
.claude/hooks/react-reflexion.sh:105:    log "Generating reflection on action: $action (success=$success)"
.claude/hooks/react-reflexion.sh:106:
.claude/hooks/react-reflexion.sh:107:[Omitted long matching line]
.claude/hooks/react-reflexion.sh:108:
.claude/hooks/react-reflexion.sh:109:    jq -n \
.claude/hooks/react-reflexion.sh:110:        --arg prompt "$reflection_prompt" \
.claude/hooks/react-reflexion.sh:111:        '{
.claude/hooks/react-reflexion.sh:112:            reflection_prompt: $prompt,
.claude/hooks/react-reflexion.sh:113:            quality_score: null,
.claude/hooks/react-reflexion.sh:114:            lessons_learned: [],
.claude/hooks/react-reflexion.sh:115:            alternative_approaches: [],
.claude/hooks/react-reflexion.sh:116:            pattern_extracted: null,
.claude/hooks/react-reflexion.sh:117:            improvement_suggestions: []
.claude/hooks/react-reflexion.sh:118:        }'
.claude/hooks/react-reflexion.sh:119:}
.claude/hooks/react-reflexion.sh:120:
.claude/hooks/react-reflexion.sh:121:# Extract lessons from reflection and store in memory
.claude/hooks/react-reflexion.sh:122:extract_and_store_lessons() {
.claude/hooks/react-reflexion.sh:123:    local reflection_json="$1"
.claude/hooks/react-reflexion.sh:124:    local success="${2:-unknown}"
.claude/hooks/react-reflexion.sh:125:
.claude/hooks/react-reflexion.sh:126:    if [[ ! -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/react-reflexion.sh:127:        return 0
.claude/hooks/react-reflexion.sh:128:    fi
.claude/hooks/react-reflexion.sh:129:
.claude/hooks/react-reflexion.sh:130:    log "Extracting and storing lessons from reflection"
.claude/hooks/react-reflexion.sh:131:
.claude/hooks/react-reflexion.sh:132:    # Extract quality score
.claude/hooks/react-reflexion.sh:133:    local quality_score
.claude/hooks/react-reflexion.sh:134:    quality_score=$(echo "$reflection_json" | jq -r '.quality_score // 5' 2>/dev/null)
.claude/hooks/react-reflexion.sh:135:
.claude/hooks/react-reflexion.sh:136:    # Extract lessons learned
.claude/hooks/react-reflexion.sh:137:    local lessons
.claude/hooks/react-reflexion.sh:138:    lessons=$(echo "$reflection_json" | jq -r '.lessons_learned[]? // empty' 2>/dev/null)
.claude/hooks/react-reflexion.sh:139:
.claude/hooks/react-reflexion.sh:140:    if [[ -n "$lessons" ]]; then
.claude/hooks/react-reflexion.sh:141:        while IFS= read -r lesson; do
.claude/hooks/react-reflexion.sh:142:            "$MEMORY_MANAGER" add-context "Lesson: $lesson" "$quality_score" 2>/dev/null || true
.claude/hooks/react-reflexion.sh:143:        done <<< "$lessons"
.claude/hooks/react-reflexion.sh:144:    fi
.claude/hooks/react-reflexion.sh:145:
.claude/hooks/react-reflexion.sh:146:    # Extract and store pattern
.claude/hooks/react-reflexion.sh:147:    local pattern
.claude/hooks/react-reflexion.sh:148:    pattern=$(echo "$reflection_json" | jq -r '.pattern_extracted // empty' 2>/dev/null)
.claude/hooks/react-reflexion.sh:149:
.claude/hooks/react-reflexion.sh:150:    if [[ -n "$pattern" && "$pattern" != "null" ]]; then
.claude/hooks/react-reflexion.sh:151:        local trigger
.claude/hooks/react-reflexion.sh:152:        local solution
.claude/hooks/react-reflexion.sh:153:        trigger=$(echo "$pattern" | jq -r '.trigger // empty' 2>/dev/null)
.claude/hooks/react-reflexion.sh:154:        solution=$(echo "$pattern" | jq -r '.solution // empty' 2>/dev/null)
.claude/hooks/react-reflexion.sh:155:
.claude/hooks/react-reflexion.sh:156:        if [[ -n "$trigger" && -n "$solution" ]]; then
.claude/hooks/react-reflexion.sh:157:            local pattern_type="optimization"
.claude/hooks/react-reflexion.sh:158:            [[ "$success" == "false" ]] && pattern_type="error_fix"
.claude/hooks/react-reflexion.sh:159:
.claude/hooks/react-reflexion.sh:160:            "$MEMORY_MANAGER" add-pattern "$pattern_type" "$trigger" "$solution" 2>/dev/null || true
.claude/hooks/react-reflexion.sh:161:        fi
.claude/hooks/react-reflexion.sh:162:    fi
.claude/hooks/react-reflexion.sh:163:
.claude/hooks/react-reflexion.sh:164:    # Create reflection in memory
.claude/hooks/react-reflexion.sh:165:    local thought
.claude/hooks/react-reflexion.sh:166:    local action
.claude/hooks/react-reflexion.sh:167:    thought=$(echo "$reflection_json" | jq -r '.thought // empty' 2>/dev/null)
.claude/hooks/react-reflexion.sh:168:    action=$(echo "$reflection_json" | jq -r '.action // empty' 2>/dev/null)
.claude/hooks/react-reflexion.sh:169:
.claude/hooks/react-reflexion.sh:170:    "$MEMORY_MANAGER" reflect "action_evaluation" "Evaluated: $action" "Score: $quality_score/10. $lessons" 2>/dev/null || true
.claude/hooks/react-reflexion.sh:171:
.claude/hooks/react-reflexion.sh:172:    log "Stored lessons and patterns in memory"
.claude/hooks/react-reflexion.sh:173:}
.claude/hooks/react-reflexion.sh:174:
.claude/hooks/react-reflexion.sh:175:# =============================================================================
.claude/hooks/react-reflexion.sh:176:# FULL REACT-REFLEXION CYCLE
.claude/hooks/react-reflexion.sh:177:# =============================================================================
.claude/hooks/react-reflexion.sh:178:
.claude/hooks/react-reflexion.sh:179:# Run a complete cycle: Think  Act  Observe  Reflect
.claude/hooks/react-reflexion.sh:180:run_cycle() {
.claude/hooks/react-reflexion.sh:181:    local goal="$1"
.claude/hooks/react-reflexion.sh:182:    local context="$2"
.claude/hooks/react-reflexion.sh:183:    local action="$3"
.claude/hooks/react-reflexion.sh:184:    local action_input="$4"
.claude/hooks/react-reflexion.sh:185:    local iteration="${5:-1}"
.claude/hooks/react-reflexion.sh:186:
.claude/hooks/react-reflexion.sh:187:    log "Starting ReAct-Reflexion cycle $iteration for goal: $goal"
.claude/hooks/react-reflexion.sh:188:
.claude/hooks/react-reflexion.sh:189:    # 1. THINK: Generate reasoning
.claude/hooks/react-reflexion.sh:190:    local thought_json
.claude/hooks/react-reflexion.sh:191:    thought_json=$(generate_thought "$goal" "$context" "$iteration")
.claude/hooks/react-reflexion.sh:192:
.claude/hooks/react-reflexion.sh:193:    # 2. ACT: Record the action (actual execution happens outside)
.claude/hooks/react-reflexion.sh:194:    local action_json
.claude/hooks/react-reflexion.sh:195:    action_json=$(record_action "reasoning_generated" "$action" "$action_input")
.claude/hooks/react-reflexion.sh:196:
.claude/hooks/react-reflexion.sh:197:    # Return the thought for Claude to use
.claude/hooks/react-reflexion.sh:198:    echo "$thought_json"
.claude/hooks/react-reflexion.sh:199:}
.claude/hooks/react-reflexion.sh:200:
.claude/hooks/react-reflexion.sh:201:# Run reflection after action completes
.claude/hooks/react-reflexion.sh:202:run_reflection() {
.claude/hooks/react-reflexion.sh:203:    local thought="$1"
.claude/hooks/react-reflexion.sh:204:    local action="$2"
.claude/hooks/react-reflexion.sh:205:    local observation="$3"
.claude/hooks/react-reflexion.sh:206:    local success="${4:-unknown}"
.claude/hooks/react-reflexion.sh:207:
.claude/hooks/react-reflexion.sh:208:    log "Starting reflection on completed action: $action"
.claude/hooks/react-reflexion.sh:209:
.claude/hooks/react-reflexion.sh:210:    # Generate reflection prompt
.claude/hooks/react-reflexion.sh:211:    local reflection_json
.claude/hooks/react-reflexion.sh:212:    reflection_json=$(generate_reflection "$thought" "$action" "$observation" "$success")
.claude/hooks/react-reflexion.sh:213:
.claude/hooks/react-reflexion.sh:214:    echo "$reflection_json"
.claude/hooks/react-reflexion.sh:215:}
.claude/hooks/react-reflexion.sh:216:
.claude/hooks/react-reflexion.sh:217:# Process completed reflection (store lessons)
.claude/hooks/react-reflexion.sh:218:process_reflection() {
.claude/hooks/react-reflexion.sh:219:    local reflection_result="$1"
.claude/hooks/react-reflexion.sh:220:    local success="${2:-unknown}"
.claude/hooks/react-reflexion.sh:221:
.claude/hooks/react-reflexion.sh:222:    log "Processing reflection results"
.claude/hooks/react-reflexion.sh:223:
.claude/hooks/react-reflexion.sh:224:    extract_and_store_lessons "$reflection_result" "$success"
.claude/hooks/react-reflexion.sh:225:
.claude/hooks/react-reflexion.sh:226:    echo '{"status":"reflection_processed","stored_to_memory":true}'
.claude/hooks/react-reflexion.sh:227:}
.claude/hooks/react-reflexion.sh:228:
.claude/hooks/react-reflexion.sh:229:# =============================================================================
.claude/hooks/react-reflexion.sh:230:# REFLEXION HISTORY: Track improvement over time
.claude/hooks/react-reflexion.sh:231:# =============================================================================
.claude/hooks/react-reflexion.sh:232:
.claude/hooks/react-reflexion.sh:233:# Get reflection history for a goal
.claude/hooks/react-reflexion.sh:234:get_reflection_history() {
.claude/hooks/react-reflexion.sh:235:    local goal="$1"
.claude/hooks/react-reflexion.sh:236:    local limit="${2:-5}"
.claude/hooks/react-reflexion.sh:237:
.claude/hooks/react-reflexion.sh:238:    if [[ ! -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/react-reflexion.sh:239:        echo '[]'
.claude/hooks/react-reflexion.sh:240:        return
.claude/hooks/react-reflexion.sh:241:    fi
.claude/hooks/react-reflexion.sh:242:
.claude/hooks/react-reflexion.sh:243:    "$MEMORY_MANAGER" search-reflections "$goal" "$limit" 2>/dev/null || echo '[]'
.claude/hooks/react-reflexion.sh:244:}
.claude/hooks/react-reflexion.sh:245:
.claude/hooks/react-reflexion.sh:246:# Get learned patterns relevant to current goal
.claude/hooks/react-reflexion.sh:247:get_relevant_patterns() {
.claude/hooks/react-reflexion.sh:248:    local goal="$1"
.claude/hooks/react-reflexion.sh:249:    local limit="${2:-3}"
.claude/hooks/react-reflexion.sh:250:
.claude/hooks/react-reflexion.sh:251:    if [[ ! -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/react-reflexion.sh:252:        echo '[]'
.claude/hooks/react-reflexion.sh:253:        return
.claude/hooks/react-reflexion.sh:254:    fi
.claude/hooks/react-reflexion.sh:255:
.claude/hooks/react-reflexion.sh:256:    "$MEMORY_MANAGER" find-patterns "$goal" "$limit" 2>/dev/null || echo '[]'
.claude/hooks/react-reflexion.sh:257:}
.claude/hooks/react-reflexion.sh:258:
.claude/hooks/react-reflexion.sh:259:# =============================================================================
.claude/hooks/react-reflexion.sh:260:# COMMAND INTERFACE
.claude/hooks/react-reflexion.sh:261:# =============================================================================
.claude/hooks/react-reflexion.sh:262:
.claude/hooks/react-reflexion.sh:263:case "${1:-help}" in
.claude/hooks/react-reflexion.sh:264:    think)
.claude/hooks/react-reflexion.sh:265:        # Generate reasoning before action
.claude/hooks/react-reflexion.sh:266:        generate_thought "${2:-goal}" "${3:-context}" "${4:-1}"
.claude/hooks/react-reflexion.sh:267:        ;;
.claude/hooks/react-reflexion.sh:268:    act)
.claude/hooks/react-reflexion.sh:269:        # Record action taken
.claude/hooks/react-reflexion.sh:270:        record_action "${2:-thought}" "${3:-action}" "${4:-input}"
.claude/hooks/react-reflexion.sh:271:        ;;
.claude/hooks/react-reflexion.sh:272:    observe)
.claude/hooks/react-reflexion.sh:273:        # Record observation/result
.claude/hooks/react-reflexion.sh:274:        record_observation "${2:-action}" "${3:-result}" "${4:-unknown}"
.claude/hooks/react-reflexion.sh:275:        ;;
.claude/hooks/react-reflexion.sh:276:    reflect)
.claude/hooks/react-reflexion.sh:277:        # Generate self-reflection
.claude/hooks/react-reflexion.sh:278:        generate_reflection "${2:-thought}" "${3:-action}" "${4:-observation}" "${5:-unknown}"
.claude/hooks/react-reflexion.sh:279:        ;;
.claude/hooks/react-reflexion.sh:280:    cycle)
.claude/hooks/react-reflexion.sh:281:        # Run full ReAct cycle (think  act)
.claude/hooks/react-reflexion.sh:282:        run_cycle "${2:-goal}" "${3:-context}" "${4:-action}" "${5:-input}" "${6:-1}"
.claude/hooks/react-reflexion.sh:283:        ;;
.claude/hooks/react-reflexion.sh:284:    run-reflection)
.claude/hooks/react-reflexion.sh:285:        # Run reflection after action
.claude/hooks/react-reflexion.sh:286:        run_reflection "${2:-thought}" "${3:-action}" "${4:-observation}" "${5:-unknown}"
.claude/hooks/react-reflexion.sh:287:        ;;
.claude/hooks/react-reflexion.sh:288:    process)
.claude/hooks/react-reflexion.sh:289:        # Process and store reflection
.claude/hooks/react-reflexion.sh:290:        process_reflection "${2:-reflection_json}" "${3:-unknown}"
.claude/hooks/react-reflexion.sh:291:        ;;
.claude/hooks/react-reflexion.sh:292:    history)
.claude/hooks/react-reflexion.sh:293:        # Get reflection history
.claude/hooks/react-reflexion.sh:294:        get_reflection_history "${2:-goal}" "${3:-5}"
.claude/hooks/react-reflexion.sh:295:        ;;
.claude/hooks/react-reflexion.sh:296:    patterns)
.claude/hooks/react-reflexion.sh:297:        # Get relevant patterns
.claude/hooks/react-reflexion.sh:298:        get_relevant_patterns "${2:-goal}" "${3:-3}"
.claude/hooks/react-reflexion.sh:299:        ;;
.claude/hooks/react-reflexion.sh:300:    help|*)
.claude/hooks/react-reflexion.sh:301:        echo "ReAct + Reflexion Framework - Think  Act  Observe  Reflect"
.claude/hooks/react-reflexion.sh:302:        echo ""
.claude/hooks/react-reflexion.sh:303:        echo "Usage: $0 <command> [args]"
.claude/hooks/react-reflexion.sh:304:        echo ""
.claude/hooks/react-reflexion.sh:305:        echo "ReAct Cycle:"
.claude/hooks/react-reflexion.sh:306:        echo "  think <goal> <context> [iteration]     - Generate reasoning before action"
.claude/hooks/react-reflexion.sh:307:        echo "  act <thought> <action> <input>         - Record action taken"
.claude/hooks/react-reflexion.sh:308:        echo "  observe <action> <result> [success]    - Record observation"
.claude/hooks/react-reflexion.sh:309:        echo "  cycle <goal> <context> <action> <input> [iteration]"
.claude/hooks/react-reflexion.sh:310:        echo "                                         - Run full thinkact cycle"
.claude/hooks/react-reflexion.sh:311:        echo ""
.claude/hooks/react-reflexion.sh:312:        echo "Reflexion:"
.claude/hooks/react-reflexion.sh:313:        echo "  reflect <thought> <action> <observation> [success]"
.claude/hooks/react-reflexion.sh:314:        echo "                                         - Generate self-reflection"
.claude/hooks/react-reflexion.sh:315:        echo "  run-reflection <thought> <action> <observation> [success]"
.claude/hooks/react-reflexion.sh:316:        echo "                                         - Run reflection after action"
.claude/hooks/react-reflexion.sh:317:        echo "  process <reflection_json> [success]    - Process and store reflection"
.claude/hooks/react-reflexion.sh:318:        echo ""
.claude/hooks/react-reflexion.sh:319:        echo "History:"
.claude/hooks/react-reflexion.sh:320:        echo "  history <goal> [limit]                 - Get reflection history"
.claude/hooks/react-reflexion.sh:321:        echo "  patterns <goal> [limit]                - Get learned patterns"
.claude/hooks/react-reflexion.sh:322:        echo ""
.claude/hooks/react-reflexion.sh:323:        echo "Example workflow:"
.claude/hooks/react-reflexion.sh:324:        echo "  1. $0 cycle 'fix bug' 'error in auth' 'edit_file' 'auth.js'"
.claude/hooks/react-reflexion.sh:325:        echo "  2. [Execute the action]"
.claude/hooks/react-reflexion.sh:326:        echo "  3. $0 run-reflection 'reasoning' 'edit_file' 'fixed' 'true'"
.claude/hooks/react-reflexion.sh:327:        echo "  4. $0 process '{reflection}' 'true'"
.claude/hooks/react-reflexion.sh:328:        ;;
.claude/hooks/react-reflexion.sh:329:esac
.claude/hooks/lock-manager.sh:1:#!/bin/bash
.claude/hooks/lock-manager.sh:2:# Lock Manager - Prevent concurrent builds and operations
.claude/hooks/lock-manager.sh:3:# Based on patterns from: vscode tryAcquireLock, joplin LockHandler, medusa acquireLockStep
.claude/hooks/lock-manager.sh:4:
.claude/hooks/lock-manager.sh:5:set -uo pipefail
.claude/hooks/lock-manager.sh:6:
.claude/hooks/lock-manager.sh:7:LOCK_DIR="${HOME}/.claude/locks"
.claude/hooks/lock-manager.sh:8:LOG_FILE="${HOME}/.claude/lock-manager.log"
.claude/hooks/lock-manager.sh:9:
.claude/hooks/lock-manager.sh:10:# Lock timeout in seconds (stale lock cleanup)
.claude/hooks/lock-manager.sh:11:LOCK_TIMEOUT="${LOCK_TIMEOUT:-3600}"  # 1 hour default
.claude/hooks/lock-manager.sh:12:
.claude/hooks/lock-manager.sh:13:log() {
.claude/hooks/lock-manager.sh:14:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/lock-manager.sh:15:}
.claude/hooks/lock-manager.sh:16:
.claude/hooks/lock-manager.sh:17:init_locks() {
.claude/hooks/lock-manager.sh:18:    mkdir -p "$LOCK_DIR"
.claude/hooks/lock-manager.sh:19:}
.claude/hooks/lock-manager.sh:20:
.claude/hooks/lock-manager.sh:21:# =============================================================================
.claude/hooks/lock-manager.sh:22:# LOCK MANAGEMENT (from vscode/joplin patterns)
.claude/hooks/lock-manager.sh:23:# =============================================================================
.claude/hooks/lock-manager.sh:24:
.claude/hooks/lock-manager.sh:25:# Get lock file path
.claude/hooks/lock-manager.sh:26:get_lock_file() {
.claude/hooks/lock-manager.sh:27:    local lock_name="$1"
.claude/hooks/lock-manager.sh:28:    echo "$LOCK_DIR/${lock_name}.lock"
.claude/hooks/lock-manager.sh:29:}
.claude/hooks/lock-manager.sh:30:
.claude/hooks/lock-manager.sh:31:# Try to acquire a lock (non-blocking)
.claude/hooks/lock-manager.sh:32:try_acquire() {
.claude/hooks/lock-manager.sh:33:    local lock_name="$1"
.claude/hooks/lock-manager.sh:34:    local owner="${2:-$$}"
.claude/hooks/lock-manager.sh:35:    local timeout="${3:-$LOCK_TIMEOUT}"
.claude/hooks/lock-manager.sh:36:
.claude/hooks/lock-manager.sh:37:    init_locks
.claude/hooks/lock-manager.sh:38:
.claude/hooks/lock-manager.sh:39:    local lock_file
.claude/hooks/lock-manager.sh:40:    lock_file=$(get_lock_file "$lock_name")
.claude/hooks/lock-manager.sh:41:
.claude/hooks/lock-manager.sh:42:    # Check if lock exists
.claude/hooks/lock-manager.sh:43:    if [[ -f "$lock_file" ]]; then
.claude/hooks/lock-manager.sh:44:        # Read lock info
.claude/hooks/lock-manager.sh:45:        local lock_pid lock_time lock_owner
.claude/hooks/lock-manager.sh:46:        lock_pid=$(jq -r '.pid // 0' "$lock_file" 2>/dev/null || echo "0")
.claude/hooks/lock-manager.sh:47:        lock_time=$(jq -r '.timestamp // 0' "$lock_file" 2>/dev/null || echo "0")
.claude/hooks/lock-manager.sh:48:        lock_owner=$(jq -r '.owner // ""' "$lock_file" 2>/dev/null || echo "")
.claude/hooks/lock-manager.sh:49:
.claude/hooks/lock-manager.sh:50:        local now
.claude/hooks/lock-manager.sh:51:        now=$(date +%s)
.claude/hooks/lock-manager.sh:52:        local age=$((now - lock_time))
.claude/hooks/lock-manager.sh:53:
.claude/hooks/lock-manager.sh:54:        # Check if lock is stale (process dead or timeout)
.claude/hooks/lock-manager.sh:55:        if [[ $lock_pid -ne 0 ]] && ! kill -0 "$lock_pid" 2>/dev/null; then
.claude/hooks/lock-manager.sh:56:            log "Lock $lock_name held by dead process $lock_pid, removing"
.claude/hooks/lock-manager.sh:57:            rm -f "$lock_file"
.claude/hooks/lock-manager.sh:58:        elif [[ $age -gt $timeout ]]; then
.claude/hooks/lock-manager.sh:59:            log "Lock $lock_name expired (age: ${age}s > ${timeout}s), removing"
.claude/hooks/lock-manager.sh:60:            rm -f "$lock_file"
.claude/hooks/lock-manager.sh:61:        else
.claude/hooks/lock-manager.sh:62:            # Lock is valid and held by another process
.claude/hooks/lock-manager.sh:63:            log "Lock $lock_name held by $lock_owner (pid: $lock_pid, age: ${age}s)"
.claude/hooks/lock-manager.sh:64:            echo "locked:$lock_owner:$lock_pid"
.claude/hooks/lock-manager.sh:65:            return 1
.claude/hooks/lock-manager.sh:66:        fi
.claude/hooks/lock-manager.sh:67:    fi
.claude/hooks/lock-manager.sh:68:
.claude/hooks/lock-manager.sh:69:    # Create lock
.claude/hooks/lock-manager.sh:70:    local timestamp
.claude/hooks/lock-manager.sh:71:    timestamp=$(date +%s)
.claude/hooks/lock-manager.sh:72:
.claude/hooks/lock-manager.sh:73:    cat > "$lock_file" << EOF
.claude/hooks/lock-manager.sh:74:{
.claude/hooks/lock-manager.sh:75:    "name": "$lock_name",
.claude/hooks/lock-manager.sh:76:    "pid": $$,
.claude/hooks/lock-manager.sh:77:    "owner": "$owner",
.claude/hooks/lock-manager.sh:78:    "timestamp": $timestamp,
.claude/hooks/lock-manager.sh:79:    "acquired": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
.claude/hooks/lock-manager.sh:80:}
.claude/hooks/lock-manager.sh:81:EOF
.claude/hooks/lock-manager.sh:82:
.claude/hooks/lock-manager.sh:83:    log "Acquired lock: $lock_name (owner: $owner, pid: $$)"
.claude/hooks/lock-manager.sh:84:    echo "acquired:$owner:$$"
.claude/hooks/lock-manager.sh:85:    return 0
.claude/hooks/lock-manager.sh:86:}
.claude/hooks/lock-manager.sh:87:
.claude/hooks/lock-manager.sh:88:# Acquire lock with retry (blocking)
.claude/hooks/lock-manager.sh:89:acquire() {
.claude/hooks/lock-manager.sh:90:    local lock_name="$1"
.claude/hooks/lock-manager.sh:91:    local owner="${2:-$$}"
.claude/hooks/lock-manager.sh:92:    local max_wait="${3:-300}"  # Max 5 minutes wait
.claude/hooks/lock-manager.sh:93:    local retry_interval="${4:-2}"
.claude/hooks/lock-manager.sh:94:
.claude/hooks/lock-manager.sh:95:    local elapsed=0
.claude/hooks/lock-manager.sh:96:
.claude/hooks/lock-manager.sh:97:    while [[ $elapsed -lt $max_wait ]]; do
.claude/hooks/lock-manager.sh:98:        if try_acquire "$lock_name" "$owner"; then
.claude/hooks/lock-manager.sh:99:            return 0
.claude/hooks/lock-manager.sh:100:        fi
.claude/hooks/lock-manager.sh:101:
.claude/hooks/lock-manager.sh:102:        sleep "$retry_interval"
.claude/hooks/lock-manager.sh:103:        elapsed=$((elapsed + retry_interval))
.claude/hooks/lock-manager.sh:104:        log "Waiting for lock $lock_name (${elapsed}s/${max_wait}s)"
.claude/hooks/lock-manager.sh:105:    done
.claude/hooks/lock-manager.sh:106:
.claude/hooks/lock-manager.sh:107:    log "Failed to acquire lock $lock_name after ${max_wait}s"
.claude/hooks/lock-manager.sh:108:    return 1
.claude/hooks/lock-manager.sh:109:}
.claude/hooks/lock-manager.sh:110:
.claude/hooks/lock-manager.sh:111:# Release a lock
.claude/hooks/lock-manager.sh:112:release() {
.claude/hooks/lock-manager.sh:113:    local lock_name="$1"
.claude/hooks/lock-manager.sh:114:    local owner="${2:-$$}"
.claude/hooks/lock-manager.sh:115:
.claude/hooks/lock-manager.sh:116:    local lock_file
.claude/hooks/lock-manager.sh:117:    lock_file=$(get_lock_file "$lock_name")
.claude/hooks/lock-manager.sh:118:
.claude/hooks/lock-manager.sh:119:    if [[ ! -f "$lock_file" ]]; then
.claude/hooks/lock-manager.sh:120:        log "Lock $lock_name not found"
.claude/hooks/lock-manager.sh:121:        return 0
.claude/hooks/lock-manager.sh:122:    fi
.claude/hooks/lock-manager.sh:123:
.claude/hooks/lock-manager.sh:124:    # Verify ownership before releasing
.claude/hooks/lock-manager.sh:125:    local lock_pid lock_owner
.claude/hooks/lock-manager.sh:126:    lock_pid=$(jq -r '.pid // 0' "$lock_file" 2>/dev/null || echo "0")
.claude/hooks/lock-manager.sh:127:    lock_owner=$(jq -r '.owner // ""' "$lock_file" 2>/dev/null || echo "")
.claude/hooks/lock-manager.sh:128:
.claude/hooks/lock-manager.sh:129:    if [[ "$lock_pid" != "$$" ]] && [[ "$lock_owner" != "$owner" ]]; then
.claude/hooks/lock-manager.sh:130:        log "Cannot release lock $lock_name: owned by $lock_owner (pid: $lock_pid)"
.claude/hooks/lock-manager.sh:131:        return 1
.claude/hooks/lock-manager.sh:132:    fi
.claude/hooks/lock-manager.sh:133:
.claude/hooks/lock-manager.sh:134:    rm -f "$lock_file"
.claude/hooks/lock-manager.sh:135:    log "Released lock: $lock_name"
.claude/hooks/lock-manager.sh:136:    return 0
.claude/hooks/lock-manager.sh:137:}
.claude/hooks/lock-manager.sh:138:
.claude/hooks/lock-manager.sh:139:# Force release (admin)
.claude/hooks/lock-manager.sh:140:force_release() {
.claude/hooks/lock-manager.sh:141:    local lock_name="$1"
.claude/hooks/lock-manager.sh:142:
.claude/hooks/lock-manager.sh:143:    local lock_file
.claude/hooks/lock-manager.sh:144:    lock_file=$(get_lock_file "$lock_name")
.claude/hooks/lock-manager.sh:145:
.claude/hooks/lock-manager.sh:146:    if [[ -f "$lock_file" ]]; then
.claude/hooks/lock-manager.sh:147:        local lock_info
.claude/hooks/lock-manager.sh:148:        lock_info=$(cat "$lock_file")
.claude/hooks/lock-manager.sh:149:        rm -f "$lock_file"
.claude/hooks/lock-manager.sh:150:        log "Force released lock: $lock_name (was: $lock_info)"
.claude/hooks/lock-manager.sh:151:    fi
.claude/hooks/lock-manager.sh:152:}
.claude/hooks/lock-manager.sh:153:
.claude/hooks/lock-manager.sh:154:# Check if lock is held
.claude/hooks/lock-manager.sh:155:is_locked() {
.claude/hooks/lock-manager.sh:156:    local lock_name="$1"
.claude/hooks/lock-manager.sh:157:
.claude/hooks/lock-manager.sh:158:    local lock_file
.claude/hooks/lock-manager.sh:159:    lock_file=$(get_lock_file "$lock_name")
.claude/hooks/lock-manager.sh:160:
.claude/hooks/lock-manager.sh:161:    if [[ ! -f "$lock_file" ]]; then
.claude/hooks/lock-manager.sh:162:        echo "unlocked"
.claude/hooks/lock-manager.sh:163:        return 1
.claude/hooks/lock-manager.sh:164:    fi
.claude/hooks/lock-manager.sh:165:
.claude/hooks/lock-manager.sh:166:    # Check if lock is valid
.claude/hooks/lock-manager.sh:167:    local lock_pid lock_time
.claude/hooks/lock-manager.sh:168:    lock_pid=$(jq -r '.pid // 0' "$lock_file" 2>/dev/null || echo "0")
.claude/hooks/lock-manager.sh:169:    lock_time=$(jq -r '.timestamp // 0' "$lock_file" 2>/dev/null || echo "0")
.claude/hooks/lock-manager.sh:170:
.claude/hooks/lock-manager.sh:171:    local now
.claude/hooks/lock-manager.sh:172:    now=$(date +%s)
.claude/hooks/lock-manager.sh:173:    local age=$((now - lock_time))
.claude/hooks/lock-manager.sh:174:
.claude/hooks/lock-manager.sh:175:    # Check if stale
.claude/hooks/lock-manager.sh:176:    if [[ $lock_pid -ne 0 ]] && ! kill -0 "$lock_pid" 2>/dev/null; then
.claude/hooks/lock-manager.sh:177:        echo "stale:dead_process"
.claude/hooks/lock-manager.sh:178:        return 1
.claude/hooks/lock-manager.sh:179:    elif [[ $age -gt $LOCK_TIMEOUT ]]; then
.claude/hooks/lock-manager.sh:180:        echo "stale:timeout"
.claude/hooks/lock-manager.sh:181:        return 1
.claude/hooks/lock-manager.sh:182:    fi
.claude/hooks/lock-manager.sh:183:
.claude/hooks/lock-manager.sh:184:    local lock_owner
.claude/hooks/lock-manager.sh:185:    lock_owner=$(jq -r '.owner // "unknown"' "$lock_file")
.claude/hooks/lock-manager.sh:186:    echo "locked:$lock_owner:$lock_pid"
.claude/hooks/lock-manager.sh:187:    return 0
.claude/hooks/lock-manager.sh:188:}
.claude/hooks/lock-manager.sh:189:
.claude/hooks/lock-manager.sh:190:# Get lock info
.claude/hooks/lock-manager.sh:191:get_info() {
.claude/hooks/lock-manager.sh:192:    local lock_name="$1"
.claude/hooks/lock-manager.sh:193:
.claude/hooks/lock-manager.sh:194:    local lock_file
.claude/hooks/lock-manager.sh:195:    lock_file=$(get_lock_file "$lock_name")
.claude/hooks/lock-manager.sh:196:
.claude/hooks/lock-manager.sh:197:    if [[ -f "$lock_file" ]]; then
.claude/hooks/lock-manager.sh:198:        jq '.' "$lock_file"
.claude/hooks/lock-manager.sh:199:    else
.claude/hooks/lock-manager.sh:200:        echo '{"status":"unlocked"}'
.claude/hooks/lock-manager.sh:201:    fi
.claude/hooks/lock-manager.sh:202:}
.claude/hooks/lock-manager.sh:203:
.claude/hooks/lock-manager.sh:204:# List all locks
.claude/hooks/lock-manager.sh:205:list_locks() {
.claude/hooks/lock-manager.sh:206:    init_locks
.claude/hooks/lock-manager.sh:207:
.claude/hooks/lock-manager.sh:208:    echo "{"
.claude/hooks/lock-manager.sh:209:    echo '  "locks": ['
.claude/hooks/lock-manager.sh:210:
.claude/hooks/lock-manager.sh:211:    local first=true
.claude/hooks/lock-manager.sh:212:    local lock_files
.claude/hooks/lock-manager.sh:213:    lock_files=$(ls "$LOCK_DIR"/*.lock 2>/dev/null || true)
.claude/hooks/lock-manager.sh:214:
.claude/hooks/lock-manager.sh:215:    for lock_file in $lock_files; do
.claude/hooks/lock-manager.sh:216:        if [[ -f "$lock_file" ]]; then
.claude/hooks/lock-manager.sh:217:            if [[ "$first" != "true" ]]; then
.claude/hooks/lock-manager.sh:218:                echo ","
.claude/hooks/lock-manager.sh:219:            fi
.claude/hooks/lock-manager.sh:220:            first=false
.claude/hooks/lock-manager.sh:221:            cat "$lock_file"
.claude/hooks/lock-manager.sh:222:        fi
.claude/hooks/lock-manager.sh:223:    done
.claude/hooks/lock-manager.sh:224:
.claude/hooks/lock-manager.sh:225:    echo '  ]'
.claude/hooks/lock-manager.sh:226:    echo "}"
.claude/hooks/lock-manager.sh:227:}
.claude/hooks/lock-manager.sh:228:
.claude/hooks/lock-manager.sh:229:# Cleanup stale locks
.claude/hooks/lock-manager.sh:230:cleanup() {
.claude/hooks/lock-manager.sh:231:    init_locks
.claude/hooks/lock-manager.sh:232:
.claude/hooks/lock-manager.sh:233:    local cleaned=0
.claude/hooks/lock-manager.sh:234:    local lock_files
.claude/hooks/lock-manager.sh:235:    lock_files=$(ls "$LOCK_DIR"/*.lock 2>/dev/null || true)
.claude/hooks/lock-manager.sh:236:
.claude/hooks/lock-manager.sh:237:    for lock_file in $lock_files; do
.claude/hooks/lock-manager.sh:238:        if [[ -f "$lock_file" ]]; then
.claude/hooks/lock-manager.sh:239:            local lock_name
.claude/hooks/lock-manager.sh:240:            lock_name=$(basename "$lock_file" .lock)
.claude/hooks/lock-manager.sh:241:
.claude/hooks/lock-manager.sh:242:            local status
.claude/hooks/lock-manager.sh:243:            status=$(is_locked "$lock_name")
.claude/hooks/lock-manager.sh:244:
.claude/hooks/lock-manager.sh:245:            if [[ "$status" == stale:* ]]; then
.claude/hooks/lock-manager.sh:246:                rm -f "$lock_file"
.claude/hooks/lock-manager.sh:247:                log "Cleaned up stale lock: $lock_name ($status)"
.claude/hooks/lock-manager.sh:248:                cleaned=$((cleaned + 1))
.claude/hooks/lock-manager.sh:249:            fi
.claude/hooks/lock-manager.sh:250:        fi
.claude/hooks/lock-manager.sh:251:    done
.claude/hooks/lock-manager.sh:252:
.claude/hooks/lock-manager.sh:253:    echo "Cleaned up $cleaned stale locks"
.claude/hooks/lock-manager.sh:254:}
.claude/hooks/lock-manager.sh:255:
.claude/hooks/lock-manager.sh:256:# Execute with lock (convenience wrapper)
.claude/hooks/lock-manager.sh:257:with_lock() {
.claude/hooks/lock-manager.sh:258:    local lock_name="$1"
.claude/hooks/lock-manager.sh:259:    shift
.claude/hooks/lock-manager.sh:260:    local command=("$@")
.claude/hooks/lock-manager.sh:261:
.claude/hooks/lock-manager.sh:262:    if ! acquire "$lock_name" "$$" 60 2; then
.claude/hooks/lock-manager.sh:263:        echo "Failed to acquire lock: $lock_name" >&2
.claude/hooks/lock-manager.sh:264:        return 1
.claude/hooks/lock-manager.sh:265:    fi
.claude/hooks/lock-manager.sh:266:
.claude/hooks/lock-manager.sh:267:    # Execute command
.claude/hooks/lock-manager.sh:268:    local result
.claude/hooks/lock-manager.sh:269:    set +e
.claude/hooks/lock-manager.sh:270:    "${command[@]}"
.claude/hooks/lock-manager.sh:271:    result=$?
.claude/hooks/lock-manager.sh:272:    set -e
.claude/hooks/lock-manager.sh:273:
.claude/hooks/lock-manager.sh:274:    # Always release lock
.claude/hooks/lock-manager.sh:275:    release "$lock_name" "$$"
.claude/hooks/lock-manager.sh:276:
.claude/hooks/lock-manager.sh:277:    return $result
.claude/hooks/lock-manager.sh:278:}
.claude/hooks/lock-manager.sh:279:
.claude/hooks/lock-manager.sh:280:# =============================================================================
.claude/hooks/lock-manager.sh:281:# COMMAND INTERFACE
.claude/hooks/lock-manager.sh:282:# =============================================================================
.claude/hooks/lock-manager.sh:283:
.claude/hooks/lock-manager.sh:284:case "${1:-help}" in
.claude/hooks/lock-manager.sh:285:    try)
.claude/hooks/lock-manager.sh:286:        try_acquire "${2:-default}" "${3:-$$}" "${4:-$LOCK_TIMEOUT}"
.claude/hooks/lock-manager.sh:287:        ;;
.claude/hooks/lock-manager.sh:288:    acquire)
.claude/hooks/lock-manager.sh:289:        acquire "${2:-default}" "${3:-$$}" "${4:-300}" "${5:-2}"
.claude/hooks/lock-manager.sh:290:        ;;
.claude/hooks/lock-manager.sh:291:    release)
.claude/hooks/lock-manager.sh:292:        release "${2:-default}" "${3:-$$}"
.claude/hooks/lock-manager.sh:293:        ;;
.claude/hooks/lock-manager.sh:294:    force-release)
.claude/hooks/lock-manager.sh:295:        force_release "${2:-default}"
.claude/hooks/lock-manager.sh:296:        ;;
.claude/hooks/lock-manager.sh:297:    check)
.claude/hooks/lock-manager.sh:298:        is_locked "${2:-default}"
.claude/hooks/lock-manager.sh:299:        ;;
.claude/hooks/lock-manager.sh:300:    info)
.claude/hooks/lock-manager.sh:301:        get_info "${2:-default}"
.claude/hooks/lock-manager.sh:302:        ;;
.claude/hooks/lock-manager.sh:303:    list)
.claude/hooks/lock-manager.sh:304:        list_locks
.claude/hooks/lock-manager.sh:305:        ;;
.claude/hooks/lock-manager.sh:306:    cleanup)
.claude/hooks/lock-manager.sh:307:        cleanup
.claude/hooks/lock-manager.sh:308:        ;;
.claude/hooks/lock-manager.sh:309:    with)
.claude/hooks/lock-manager.sh:310:        lock_name="${2:-default}"
.claude/hooks/lock-manager.sh:311:        shift 2
.claude/hooks/lock-manager.sh:312:        with_lock "$lock_name" "$@"
.claude/hooks/lock-manager.sh:313:        ;;
.claude/hooks/lock-manager.sh:314:    help|*)
.claude/hooks/lock-manager.sh:315:        echo "Lock Manager"
.claude/hooks/lock-manager.sh:316:        echo ""
.claude/hooks/lock-manager.sh:317:        echo "Usage: $0 <command> [args]"
.claude/hooks/lock-manager.sh:318:        echo ""
.claude/hooks/lock-manager.sh:319:        echo "Commands:"
.claude/hooks/lock-manager.sh:320:        echo "  try <name> [owner] [timeout]      - Try to acquire lock (non-blocking)"
.claude/hooks/lock-manager.sh:321:        echo "  acquire <name> [owner] [max_wait] [interval] - Acquire with retry"
.claude/hooks/lock-manager.sh:322:        echo "  release <name> [owner]            - Release a lock"
.claude/hooks/lock-manager.sh:323:        echo "  force-release <name>              - Force release (admin)"
.claude/hooks/lock-manager.sh:324:        echo "  check <name>                      - Check if lock is held"
.claude/hooks/lock-manager.sh:325:        echo "  info <name>                       - Get lock details"
.claude/hooks/lock-manager.sh:326:        echo "  list                              - List all locks"
.claude/hooks/lock-manager.sh:327:        echo "  cleanup                           - Remove stale locks"
.claude/hooks/lock-manager.sh:328:        echo "  with <name> <command...>          - Execute command with lock"
.claude/hooks/lock-manager.sh:329:        echo ""
.claude/hooks/lock-manager.sh:330:        echo "Environment:"
.claude/hooks/lock-manager.sh:331:        echo "  LOCK_TIMEOUT - Lock timeout in seconds (default: 3600)"
.claude/hooks/lock-manager.sh:332:        ;;
.claude/hooks/lock-manager.sh:333:esac
.claude/hooks/progress-tracker.sh:1:#!/bin/bash
.claude/hooks/progress-tracker.sh:2:# Progress Tracker - Build progress with ETA calculation
.claude/hooks/progress-tracker.sh:3:# Based on patterns from: elizaOS matrix-orchestrator, rancher-desktop progressTracker
.claude/hooks/progress-tracker.sh:4:
.claude/hooks/progress-tracker.sh:5:set -uo pipefail
.claude/hooks/progress-tracker.sh:6:
.claude/hooks/progress-tracker.sh:7:PROGRESS_DIR="${HOME}/.claude/progress"
.claude/hooks/progress-tracker.sh:8:PROGRESS_FILE="$PROGRESS_DIR/current.json"
.claude/hooks/progress-tracker.sh:9:HISTORY_FILE="$PROGRESS_DIR/history.json"
.claude/hooks/progress-tracker.sh:10:LOG_FILE="${HOME}/.claude/progress-tracker.log"
.claude/hooks/progress-tracker.sh:11:
.claude/hooks/progress-tracker.sh:12:log() {
.claude/hooks/progress-tracker.sh:13:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/progress-tracker.sh:14:}
.claude/hooks/progress-tracker.sh:15:
.claude/hooks/progress-tracker.sh:16:init_progress() {
.claude/hooks/progress-tracker.sh:17:    mkdir -p "$PROGRESS_DIR"
.claude/hooks/progress-tracker.sh:18:    if [[ ! -f "$HISTORY_FILE" ]]; then
.claude/hooks/progress-tracker.sh:19:        echo '{"builds":[]}' > "$HISTORY_FILE"
.claude/hooks/progress-tracker.sh:20:    fi
.claude/hooks/progress-tracker.sh:21:}
.claude/hooks/progress-tracker.sh:22:
.claude/hooks/progress-tracker.sh:23:# =============================================================================
.claude/hooks/progress-tracker.sh:24:# PROGRESS TRACKING (from elizaOS/rancher-desktop patterns)
.claude/hooks/progress-tracker.sh:25:# =============================================================================
.claude/hooks/progress-tracker.sh:26:
.claude/hooks/progress-tracker.sh:27:# Start tracking a new build
.claude/hooks/progress-tracker.sh:28:start_build() {
.claude/hooks/progress-tracker.sh:29:    local build_name="$1"
.claude/hooks/progress-tracker.sh:30:    local total_steps="${2:-0}"
.claude/hooks/progress-tracker.sh:31:
.claude/hooks/progress-tracker.sh:32:    init_progress
.claude/hooks/progress-tracker.sh:33:
.claude/hooks/progress-tracker.sh:34:    local build_id
.claude/hooks/progress-tracker.sh:35:    build_id="build_$(date +%s)"
.claude/hooks/progress-tracker.sh:36:
.claude/hooks/progress-tracker.sh:37:    local timestamp
.claude/hooks/progress-tracker.sh:38:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/progress-tracker.sh:39:
.claude/hooks/progress-tracker.sh:40:    cat > "$PROGRESS_FILE" << EOF
.claude/hooks/progress-tracker.sh:41:{
.claude/hooks/progress-tracker.sh:42:    "id": "$build_id",
.claude/hooks/progress-tracker.sh:43:    "name": "$build_name",
.claude/hooks/progress-tracker.sh:44:    "status": "running",
.claude/hooks/progress-tracker.sh:45:    "totalSteps": $total_steps,
.claude/hooks/progress-tracker.sh:46:    "currentStep": 0,
.claude/hooks/progress-tracker.sh:47:    "completedSteps": [],
.claude/hooks/progress-tracker.sh:48:    "startedAt": "$timestamp",
.claude/hooks/progress-tracker.sh:49:    "lastUpdated": "$timestamp",
.claude/hooks/progress-tracker.sh:50:    "stepDurations": [],
.claude/hooks/progress-tracker.sh:51:    "estimatedCompletion": null,
.claude/hooks/progress-tracker.sh:52:    "currentAction": "Starting build..."
.claude/hooks/progress-tracker.sh:53:}
.claude/hooks/progress-tracker.sh:54:EOF
.claude/hooks/progress-tracker.sh:55:
.claude/hooks/progress-tracker.sh:56:    log "Started build: $build_name (id: $build_id, steps: $total_steps)"
.claude/hooks/progress-tracker.sh:57:    echo "$build_id"
.claude/hooks/progress-tracker.sh:58:}
.claude/hooks/progress-tracker.sh:59:
.claude/hooks/progress-tracker.sh:60:# Update current step
.claude/hooks/progress-tracker.sh:61:update_step() {
.claude/hooks/progress-tracker.sh:62:    local step_number="$1"
.claude/hooks/progress-tracker.sh:63:    local step_name="$2"
.claude/hooks/progress-tracker.sh:64:    local action="${3:-Processing...}"
.claude/hooks/progress-tracker.sh:65:
.claude/hooks/progress-tracker.sh:66:    if [[ ! -f "$PROGRESS_FILE" ]]; then
.claude/hooks/progress-tracker.sh:67:        log "No active build to update"
.claude/hooks/progress-tracker.sh:68:        return 1
.claude/hooks/progress-tracker.sh:69:    fi
.claude/hooks/progress-tracker.sh:70:
.claude/hooks/progress-tracker.sh:71:    local temp_file
.claude/hooks/progress-tracker.sh:72:    temp_file=$(mktemp)
.claude/hooks/progress-tracker.sh:73:
.claude/hooks/progress-tracker.sh:74:    local timestamp
.claude/hooks/progress-tracker.sh:75:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/progress-tracker.sh:76:
.claude/hooks/progress-tracker.sh:77:    # Calculate ETA based on average step duration
.claude/hooks/progress-tracker.sh:78:    jq --argjson step "$step_number" \
.claude/hooks/progress-tracker.sh:79:       --arg name "$step_name" \
.claude/hooks/progress-tracker.sh:80:       --arg action "$action" \
.claude/hooks/progress-tracker.sh:81:       --arg ts "$timestamp" \
.claude/hooks/progress-tracker.sh:82:       '
.claude/hooks/progress-tracker.sh:83:       . as $root |
.claude/hooks/progress-tracker.sh:84:       ($root.stepDurations | if length > 0 then (add / length) else 60 end) as $avgDuration |
.claude/hooks/progress-tracker.sh:85:       (($root.totalSteps - $step) * $avgDuration) as $remainingSeconds |
.claude/hooks/progress-tracker.sh:86:       (now + $remainingSeconds | strftime("%Y-%m-%dT%H:%M:%SZ")) as $eta |
.claude/hooks/progress-tracker.sh:87:       .currentStep = $step |
.claude/hooks/progress-tracker.sh:88:       .currentStepName = $name |
.claude/hooks/progress-tracker.sh:89:       .currentAction = $action |
.claude/hooks/progress-tracker.sh:90:       .lastUpdated = $ts |
.claude/hooks/progress-tracker.sh:91:       .estimatedCompletion = $eta |
.claude/hooks/progress-tracker.sh:92:       .progress = (if .totalSteps > 0 then ($step / .totalSteps * 100 | floor) else 0 end)
.claude/hooks/progress-tracker.sh:93:       ' "$PROGRESS_FILE" > "$temp_file"
.claude/hooks/progress-tracker.sh:94:
.claude/hooks/progress-tracker.sh:95:    mv "$temp_file" "$PROGRESS_FILE"
.claude/hooks/progress-tracker.sh:96:
.claude/hooks/progress-tracker.sh:97:    log "Updated step: $step_number - $step_name"
.claude/hooks/progress-tracker.sh:98:}
.claude/hooks/progress-tracker.sh:99:
.claude/hooks/progress-tracker.sh:100:# Complete a step (records duration for ETA calculation)
.claude/hooks/progress-tracker.sh:101:complete_step() {
.claude/hooks/progress-tracker.sh:102:    local step_number="$1"
.claude/hooks/progress-tracker.sh:103:    local step_name="$2"
.claude/hooks/progress-tracker.sh:104:    local duration="${3:-0}"
.claude/hooks/progress-tracker.sh:105:
.claude/hooks/progress-tracker.sh:106:    if [[ ! -f "$PROGRESS_FILE" ]]; then
.claude/hooks/progress-tracker.sh:107:        return 1
.claude/hooks/progress-tracker.sh:108:    fi
.claude/hooks/progress-tracker.sh:109:
.claude/hooks/progress-tracker.sh:110:    local temp_file
.claude/hooks/progress-tracker.sh:111:    temp_file=$(mktemp)
.claude/hooks/progress-tracker.sh:112:
.claude/hooks/progress-tracker.sh:113:    local timestamp
.claude/hooks/progress-tracker.sh:114:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/progress-tracker.sh:115:
.claude/hooks/progress-tracker.sh:116:    jq --argjson step "$step_number" \
.claude/hooks/progress-tracker.sh:117:       --arg name "$step_name" \
.claude/hooks/progress-tracker.sh:118:       --argjson duration "$duration" \
.claude/hooks/progress-tracker.sh:119:       --arg ts "$timestamp" \
.claude/hooks/progress-tracker.sh:120:       '
.claude/hooks/progress-tracker.sh:121:       .completedSteps += [{step: $step, name: $name, duration: $duration, completedAt: $ts}] |
.claude/hooks/progress-tracker.sh:122:       .stepDurations += [$duration] |
.claude/hooks/progress-tracker.sh:123:       .lastUpdated = $ts
.claude/hooks/progress-tracker.sh:124:       ' "$PROGRESS_FILE" > "$temp_file"
.claude/hooks/progress-tracker.sh:125:
.claude/hooks/progress-tracker.sh:126:    mv "$temp_file" "$PROGRESS_FILE"
.claude/hooks/progress-tracker.sh:127:
.claude/hooks/progress-tracker.sh:128:    log "Completed step: $step_number - $step_name (${duration}s)"
.claude/hooks/progress-tracker.sh:129:}
.claude/hooks/progress-tracker.sh:130:
.claude/hooks/progress-tracker.sh:131:# Mark build as complete
.claude/hooks/progress-tracker.sh:132:finish_build() {
.claude/hooks/progress-tracker.sh:133:    local result="${1:-success}"
.claude/hooks/progress-tracker.sh:134:    local summary="${2:-}"
.claude/hooks/progress-tracker.sh:135:
.claude/hooks/progress-tracker.sh:136:    if [[ ! -f "$PROGRESS_FILE" ]]; then
.claude/hooks/progress-tracker.sh:137:        return 1
.claude/hooks/progress-tracker.sh:138:    fi
.claude/hooks/progress-tracker.sh:139:
.claude/hooks/progress-tracker.sh:140:    local temp_file
.claude/hooks/progress-tracker.sh:141:    temp_file=$(mktemp)
.claude/hooks/progress-tracker.sh:142:
.claude/hooks/progress-tracker.sh:143:    local timestamp
.claude/hooks/progress-tracker.sh:144:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/progress-tracker.sh:145:
.claude/hooks/progress-tracker.sh:146:    # Update progress file
.claude/hooks/progress-tracker.sh:147:    jq --arg result "$result" \
.claude/hooks/progress-tracker.sh:148:       --arg summary "$summary" \
.claude/hooks/progress-tracker.sh:149:       --arg ts "$timestamp" \
.claude/hooks/progress-tracker.sh:150:       '
.claude/hooks/progress-tracker.sh:151:       .status = $result |
.claude/hooks/progress-tracker.sh:152:       .completedAt = $ts |
.claude/hooks/progress-tracker.sh:153:       .summary = $summary |
.claude/hooks/progress-tracker.sh:154:       .progress = 100 |
.claude/hooks/progress-tracker.sh:155:       .totalDuration = (
.claude/hooks/progress-tracker.sh:156:           (.completedAt | fromdate) - (.startedAt | fromdate) | floor
.claude/hooks/progress-tracker.sh:157:       )
.claude/hooks/progress-tracker.sh:158:       ' "$PROGRESS_FILE" > "$temp_file"
.claude/hooks/progress-tracker.sh:159:
.claude/hooks/progress-tracker.sh:160:    mv "$temp_file" "$PROGRESS_FILE"
.claude/hooks/progress-tracker.sh:161:
.claude/hooks/progress-tracker.sh:162:    # Add to history
.claude/hooks/progress-tracker.sh:163:    local history_temp
.claude/hooks/progress-tracker.sh:164:    history_temp=$(mktemp)
.claude/hooks/progress-tracker.sh:165:
.claude/hooks/progress-tracker.sh:166:    jq --slurpfile build "$PROGRESS_FILE" \
.claude/hooks/progress-tracker.sh:167:       '.builds = [$build[0]] + .builds | .builds = .builds[:50]' \
.claude/hooks/progress-tracker.sh:168:       "$HISTORY_FILE" > "$history_temp"
.claude/hooks/progress-tracker.sh:169:
.claude/hooks/progress-tracker.sh:170:    mv "$history_temp" "$HISTORY_FILE"
.claude/hooks/progress-tracker.sh:171:
.claude/hooks/progress-tracker.sh:172:    log "Finished build: $result"
.claude/hooks/progress-tracker.sh:173:}
.claude/hooks/progress-tracker.sh:174:
.claude/hooks/progress-tracker.sh:175:# Get current progress
.claude/hooks/progress-tracker.sh:176:get_progress() {
.claude/hooks/progress-tracker.sh:177:    if [[ ! -f "$PROGRESS_FILE" ]]; then
.claude/hooks/progress-tracker.sh:178:        echo '{"status":"no_active_build"}'
.claude/hooks/progress-tracker.sh:179:        return
.claude/hooks/progress-tracker.sh:180:    fi
.claude/hooks/progress-tracker.sh:181:
.claude/hooks/progress-tracker.sh:182:    jq '.' "$PROGRESS_FILE"
.claude/hooks/progress-tracker.sh:183:}
.claude/hooks/progress-tracker.sh:184:
.claude/hooks/progress-tracker.sh:185:# Get progress summary (for display)
.claude/hooks/progress-tracker.sh:186:get_summary() {
.claude/hooks/progress-tracker.sh:187:    if [[ ! -f "$PROGRESS_FILE" ]]; then
.claude/hooks/progress-tracker.sh:188:        echo "No active build"
.claude/hooks/progress-tracker.sh:189:        return
.claude/hooks/progress-tracker.sh:190:    fi
.claude/hooks/progress-tracker.sh:191:
.claude/hooks/progress-tracker.sh:192:    jq -r '
.claude/hooks/progress-tracker.sh:193:        "Build: \(.name)\n" +
.claude/hooks/progress-tracker.sh:194:        "Status: \(.status)\n" +
.claude/hooks/progress-tracker.sh:195:        "Progress: \(.progress // 0)% (\(.currentStep)/\(.totalSteps) steps)\n" +
.claude/hooks/progress-tracker.sh:196:        "Current: \(.currentAction // "Idle")\n" +
.claude/hooks/progress-tracker.sh:197:        "ETA: \(.estimatedCompletion // "Calculating...")"
.claude/hooks/progress-tracker.sh:198:    ' "$PROGRESS_FILE"
.claude/hooks/progress-tracker.sh:199:}
.claude/hooks/progress-tracker.sh:200:
.claude/hooks/progress-tracker.sh:201:# Get build history stats
.claude/hooks/progress-tracker.sh:202:get_stats() {
.claude/hooks/progress-tracker.sh:203:    init_progress
.claude/hooks/progress-tracker.sh:204:
.claude/hooks/progress-tracker.sh:205:    jq '
.claude/hooks/progress-tracker.sh:206:        .builds as $builds |
.claude/hooks/progress-tracker.sh:207:        {
.claude/hooks/progress-tracker.sh:208:            totalBuilds: ($builds | length),
.claude/hooks/progress-tracker.sh:209:            successful: ([$builds[] | select(.status == "success")] | length),
.claude/hooks/progress-tracker.sh:210:            failed: ([$builds[] | select(.status == "failed")] | length),
.claude/hooks/progress-tracker.sh:211:            avgDuration: (
.claude/hooks/progress-tracker.sh:212:                [$builds[] | select(.totalDuration != null) | .totalDuration] |
.claude/hooks/progress-tracker.sh:213:                if length > 0 then (add / length | floor) else 0 end
.claude/hooks/progress-tracker.sh:214:            ),
.claude/hooks/progress-tracker.sh:215:            avgSteps: (
.claude/hooks/progress-tracker.sh:216:                [$builds[] | .totalSteps] |
.claude/hooks/progress-tracker.sh:217:                if length > 0 then (add / length | floor) else 0 end
.claude/hooks/progress-tracker.sh:218:            ),
.claude/hooks/progress-tracker.sh:219:            lastBuild: ($builds[0] // null)
.claude/hooks/progress-tracker.sh:220:        }
.claude/hooks/progress-tracker.sh:221:    ' "$HISTORY_FILE"
.claude/hooks/progress-tracker.sh:222:}
.claude/hooks/progress-tracker.sh:223:
.claude/hooks/progress-tracker.sh:224:# Get ETA for remaining work
.claude/hooks/progress-tracker.sh:225:get_eta() {
.claude/hooks/progress-tracker.sh:226:    if [[ ! -f "$PROGRESS_FILE" ]]; then
.claude/hooks/progress-tracker.sh:227:        echo "unknown"
.claude/hooks/progress-tracker.sh:228:        return
.claude/hooks/progress-tracker.sh:229:    fi
.claude/hooks/progress-tracker.sh:230:
.claude/hooks/progress-tracker.sh:231:    jq -r '.estimatedCompletion // "unknown"' "$PROGRESS_FILE"
.claude/hooks/progress-tracker.sh:232:}
.claude/hooks/progress-tracker.sh:233:
.claude/hooks/progress-tracker.sh:234:# Update total steps (if discovered during build)
.claude/hooks/progress-tracker.sh:235:set_total_steps() {
.claude/hooks/progress-tracker.sh:236:    local total="$1"
.claude/hooks/progress-tracker.sh:237:
.claude/hooks/progress-tracker.sh:238:    if [[ ! -f "$PROGRESS_FILE" ]]; then
.claude/hooks/progress-tracker.sh:239:        return 1
.claude/hooks/progress-tracker.sh:240:    fi
.claude/hooks/progress-tracker.sh:241:
.claude/hooks/progress-tracker.sh:242:    local temp_file
.claude/hooks/progress-tracker.sh:243:    temp_file=$(mktemp)
.claude/hooks/progress-tracker.sh:244:
.claude/hooks/progress-tracker.sh:245:    jq --argjson total "$total" '.totalSteps = $total' "$PROGRESS_FILE" > "$temp_file"
.claude/hooks/progress-tracker.sh:246:    mv "$temp_file" "$PROGRESS_FILE"
.claude/hooks/progress-tracker.sh:247:
.claude/hooks/progress-tracker.sh:248:    log "Updated total steps to: $total"
.claude/hooks/progress-tracker.sh:249:}
.claude/hooks/progress-tracker.sh:250:
.claude/hooks/progress-tracker.sh:251:# Record an error during build
.claude/hooks/progress-tracker.sh:252:record_error() {
.claude/hooks/progress-tracker.sh:253:    local error_msg="$1"
.claude/hooks/progress-tracker.sh:254:    local step="${2:-}"
.claude/hooks/progress-tracker.sh:255:
.claude/hooks/progress-tracker.sh:256:    if [[ ! -f "$PROGRESS_FILE" ]]; then
.claude/hooks/progress-tracker.sh:257:        return 1
.claude/hooks/progress-tracker.sh:258:    fi
.claude/hooks/progress-tracker.sh:259:
.claude/hooks/progress-tracker.sh:260:    local temp_file
.claude/hooks/progress-tracker.sh:261:    temp_file=$(mktemp)
.claude/hooks/progress-tracker.sh:262:
.claude/hooks/progress-tracker.sh:263:    local timestamp
.claude/hooks/progress-tracker.sh:264:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/progress-tracker.sh:265:
.claude/hooks/progress-tracker.sh:266:    jq --arg error "$error_msg" \
.claude/hooks/progress-tracker.sh:267:       --arg step "$step" \
.claude/hooks/progress-tracker.sh:268:       --arg ts "$timestamp" \
.claude/hooks/progress-tracker.sh:269:       '
.claude/hooks/progress-tracker.sh:270:       .errors = (.errors // []) + [{
.claude/hooks/progress-tracker.sh:271:           message: $error,
.claude/hooks/progress-tracker.sh:272:           step: $step,
.claude/hooks/progress-tracker.sh:273:           timestamp: $ts
.claude/hooks/progress-tracker.sh:274:       }]
.claude/hooks/progress-tracker.sh:275:       ' "$PROGRESS_FILE" > "$temp_file"
.claude/hooks/progress-tracker.sh:276:
.claude/hooks/progress-tracker.sh:277:    mv "$temp_file" "$PROGRESS_FILE"
.claude/hooks/progress-tracker.sh:278:
.claude/hooks/progress-tracker.sh:279:    log "Recorded error at step $step: $error_msg"
.claude/hooks/progress-tracker.sh:280:}
.claude/hooks/progress-tracker.sh:281:
.claude/hooks/progress-tracker.sh:282:# =============================================================================
.claude/hooks/progress-tracker.sh:283:# COMMAND INTERFACE
.claude/hooks/progress-tracker.sh:284:# =============================================================================
.claude/hooks/progress-tracker.sh:285:
.claude/hooks/progress-tracker.sh:286:case "${1:-help}" in
.claude/hooks/progress-tracker.sh:287:    start)
.claude/hooks/progress-tracker.sh:288:        start_build "${2:-unnamed}" "${3:-0}"
.claude/hooks/progress-tracker.sh:289:        ;;
.claude/hooks/progress-tracker.sh:290:    update)
.claude/hooks/progress-tracker.sh:291:        update_step "${2:-0}" "${3:-step}" "${4:-Processing...}"
.claude/hooks/progress-tracker.sh:292:        ;;
.claude/hooks/progress-tracker.sh:293:    complete-step)
.claude/hooks/progress-tracker.sh:294:        complete_step "${2:-0}" "${3:-step}" "${4:-0}"
.claude/hooks/progress-tracker.sh:295:        ;;
.claude/hooks/progress-tracker.sh:296:    finish)
.claude/hooks/progress-tracker.sh:297:        finish_build "${2:-success}" "${3:-}"
.claude/hooks/progress-tracker.sh:298:        ;;
.claude/hooks/progress-tracker.sh:299:    progress)
.claude/hooks/progress-tracker.sh:300:        get_progress
.claude/hooks/progress-tracker.sh:301:        ;;
.claude/hooks/progress-tracker.sh:302:    summary)
.claude/hooks/progress-tracker.sh:303:        get_summary
.claude/hooks/progress-tracker.sh:304:        ;;
.claude/hooks/progress-tracker.sh:305:    stats)
.claude/hooks/progress-tracker.sh:306:        get_stats
.claude/hooks/progress-tracker.sh:307:        ;;
.claude/hooks/progress-tracker.sh:308:    eta)
.claude/hooks/progress-tracker.sh:309:        get_eta
.claude/hooks/progress-tracker.sh:310:        ;;
.claude/hooks/progress-tracker.sh:311:    set-total)
.claude/hooks/progress-tracker.sh:312:        set_total_steps "${2:-0}"
.claude/hooks/progress-tracker.sh:313:        ;;
.claude/hooks/progress-tracker.sh:314:    error)
.claude/hooks/progress-tracker.sh:315:        record_error "${2:-unknown}" "${3:-}"
.claude/hooks/progress-tracker.sh:316:        ;;
.claude/hooks/progress-tracker.sh:317:    help|*)
.claude/hooks/progress-tracker.sh:318:        echo "Progress Tracker"
.claude/hooks/progress-tracker.sh:319:        echo ""
.claude/hooks/progress-tracker.sh:320:        echo "Usage: $0 <command> [args]"
.claude/hooks/progress-tracker.sh:321:        echo ""
.claude/hooks/progress-tracker.sh:322:        echo "Commands:"
.claude/hooks/progress-tracker.sh:323:        echo "  start <name> [total_steps]      - Start tracking a build"
.claude/hooks/progress-tracker.sh:324:        echo "  update <step> <name> [action]   - Update current step"
.claude/hooks/progress-tracker.sh:325:        echo "  complete-step <step> <name> [duration_secs] - Mark step complete"
.claude/hooks/progress-tracker.sh:326:        echo "  finish [success|failed] [summary] - Finish build"
.claude/hooks/progress-tracker.sh:327:        echo "  progress                         - Get full progress JSON"
.claude/hooks/progress-tracker.sh:328:        echo "  summary                          - Get human-readable summary"
.claude/hooks/progress-tracker.sh:329:        echo "  stats                            - Get build history stats"
.claude/hooks/progress-tracker.sh:330:        echo "  eta                              - Get estimated completion time"
.claude/hooks/progress-tracker.sh:331:        echo "  set-total <steps>                - Update total step count"
.claude/hooks/progress-tracker.sh:332:        echo "  error <message> [step]           - Record an error"
.claude/hooks/progress-tracker.sh:333:        ;;
.claude/hooks/progress-tracker.sh:334:esac
.claude/hooks/metrics-collector.sh:1:#!/bin/bash
.claude/hooks/metrics-collector.sh:2:# Metrics Collector - Build and session metrics
.claude/hooks/metrics-collector.sh:3:# Based on patterns from: claude-flow MetricsCollector, rushstack HeftMetrics
.claude/hooks/metrics-collector.sh:4:
.claude/hooks/metrics-collector.sh:5:set -uo pipefail
.claude/hooks/metrics-collector.sh:6:
.claude/hooks/metrics-collector.sh:7:METRICS_DIR="${HOME}/.claude/metrics"
.claude/hooks/metrics-collector.sh:8:SESSION_FILE="$METRICS_DIR/session.json"
.claude/hooks/metrics-collector.sh:9:AGGREGATE_FILE="$METRICS_DIR/aggregate.json"
.claude/hooks/metrics-collector.sh:10:LOG_FILE="${HOME}/.claude/metrics-collector.log"
.claude/hooks/metrics-collector.sh:11:
.claude/hooks/metrics-collector.sh:12:log() {
.claude/hooks/metrics-collector.sh:13:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/metrics-collector.sh:14:}
.claude/hooks/metrics-collector.sh:15:
.claude/hooks/metrics-collector.sh:16:init_metrics() {
.claude/hooks/metrics-collector.sh:17:    mkdir -p "$METRICS_DIR"
.claude/hooks/metrics-collector.sh:18:    if [[ ! -f "$AGGREGATE_FILE" ]]; then
.claude/hooks/metrics-collector.sh:19:        cat > "$AGGREGATE_FILE" << 'EOF'
.claude/hooks/metrics-collector.sh:20:{
.claude/hooks/metrics-collector.sh:21:    "totalSessions": 0,
.claude/hooks/metrics-collector.sh:22:    "totalBuilds": 0,
.claude/hooks/metrics-collector.sh:23:    "totalErrors": 0,
.claude/hooks/metrics-collector.sh:24:    "totalFixes": 0,
.claude/hooks/metrics-collector.sh:25:    "totalResearchQueries": 0,
.claude/hooks/metrics-collector.sh:26:    "successRate": 0,
.claude/hooks/metrics-collector.sh:27:    "avgBuildTime": 0,
.claude/hooks/metrics-collector.sh:28:    "avgErrorsPerBuild": 0,
.claude/hooks/metrics-collector.sh:29:    "topErrors": {},
.claude/hooks/metrics-collector.sh:30:    "topFixes": {},
.claude/hooks/metrics-collector.sh:31:    "lastUpdated": null
.claude/hooks/metrics-collector.sh:32:}
.claude/hooks/metrics-collector.sh:33:EOF
.claude/hooks/metrics-collector.sh:34:    fi
.claude/hooks/metrics-collector.sh:35:}
.claude/hooks/metrics-collector.sh:36:
.claude/hooks/metrics-collector.sh:37:# =============================================================================
.claude/hooks/metrics-collector.sh:38:# SESSION METRICS (from rushstack patterns)
.claude/hooks/metrics-collector.sh:39:# =============================================================================
.claude/hooks/metrics-collector.sh:40:
.claude/hooks/metrics-collector.sh:41:# Start a new metrics session
.claude/hooks/metrics-collector.sh:42:start_session() {
.claude/hooks/metrics-collector.sh:43:    init_metrics
.claude/hooks/metrics-collector.sh:44:
.claude/hooks/metrics-collector.sh:45:    local session_id
.claude/hooks/metrics-collector.sh:46:    session_id="session_$(date +%s)"
.claude/hooks/metrics-collector.sh:47:
.claude/hooks/metrics-collector.sh:48:    local timestamp
.claude/hooks/metrics-collector.sh:49:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/metrics-collector.sh:50:
.claude/hooks/metrics-collector.sh:51:    cat > "$SESSION_FILE" << EOF
.claude/hooks/metrics-collector.sh:52:{
.claude/hooks/metrics-collector.sh:53:    "id": "$session_id",
.claude/hooks/metrics-collector.sh:54:    "startedAt": "$timestamp",
.claude/hooks/metrics-collector.sh:55:    "builds": [],
.claude/hooks/metrics-collector.sh:56:    "errors": [],
.claude/hooks/metrics-collector.sh:57:    "fixes": [],
.claude/hooks/metrics-collector.sh:58:    "research": [],
.claude/hooks/metrics-collector.sh:59:    "checkpoints": [],
.claude/hooks/metrics-collector.sh:60:    "toolCalls": {},
.claude/hooks/metrics-collector.sh:61:    "contextUsage": []
.claude/hooks/metrics-collector.sh:62:}
.claude/hooks/metrics-collector.sh:63:EOF
.claude/hooks/metrics-collector.sh:64:
.claude/hooks/metrics-collector.sh:65:    log "Started metrics session: $session_id"
.claude/hooks/metrics-collector.sh:66:    echo "$session_id"
.claude/hooks/metrics-collector.sh:67:}
.claude/hooks/metrics-collector.sh:68:
.claude/hooks/metrics-collector.sh:69:# Record a build
.claude/hooks/metrics-collector.sh:70:record_build() {
.claude/hooks/metrics-collector.sh:71:    local build_name="$1"
.claude/hooks/metrics-collector.sh:72:    local status="$2"
.claude/hooks/metrics-collector.sh:73:    local duration="${3:-0}"
.claude/hooks/metrics-collector.sh:74:    local steps="${4:-0}"
.claude/hooks/metrics-collector.sh:75:    local errors="${5:-0}"
.claude/hooks/metrics-collector.sh:76:
.claude/hooks/metrics-collector.sh:77:    if [[ ! -f "$SESSION_FILE" ]]; then
.claude/hooks/metrics-collector.sh:78:        start_session > /dev/null
.claude/hooks/metrics-collector.sh:79:    fi
.claude/hooks/metrics-collector.sh:80:
.claude/hooks/metrics-collector.sh:81:    local temp_file
.claude/hooks/metrics-collector.sh:82:    temp_file=$(mktemp)
.claude/hooks/metrics-collector.sh:83:
.claude/hooks/metrics-collector.sh:84:    local timestamp
.claude/hooks/metrics-collector.sh:85:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/metrics-collector.sh:86:
.claude/hooks/metrics-collector.sh:87:    jq --arg name "$build_name" \
.claude/hooks/metrics-collector.sh:88:       --arg status "$status" \
.claude/hooks/metrics-collector.sh:89:       --argjson duration "$duration" \
.claude/hooks/metrics-collector.sh:90:       --argjson steps "$steps" \
.claude/hooks/metrics-collector.sh:91:       --argjson errors "$errors" \
.claude/hooks/metrics-collector.sh:92:       --arg ts "$timestamp" \
.claude/hooks/metrics-collector.sh:93:       '.builds += [{
.claude/hooks/metrics-collector.sh:94:           name: $name,
.claude/hooks/metrics-collector.sh:95:           status: $status,
.claude/hooks/metrics-collector.sh:96:           duration: $duration,
.claude/hooks/metrics-collector.sh:97:           steps: $steps,
.claude/hooks/metrics-collector.sh:98:           errors: $errors,
.claude/hooks/metrics-collector.sh:99:           timestamp: $ts
.claude/hooks/metrics-collector.sh:100:       }]' "$SESSION_FILE" > "$temp_file"
.claude/hooks/metrics-collector.sh:101:
.claude/hooks/metrics-collector.sh:102:    mv "$temp_file" "$SESSION_FILE"
.claude/hooks/metrics-collector.sh:103:
.claude/hooks/metrics-collector.sh:104:    log "Recorded build: $build_name ($status, ${duration}s, $errors errors)"
.claude/hooks/metrics-collector.sh:105:}
.claude/hooks/metrics-collector.sh:106:
.claude/hooks/metrics-collector.sh:107:# Record an error
.claude/hooks/metrics-collector.sh:108:record_error() {
.claude/hooks/metrics-collector.sh:109:    local error_type="$1"
.claude/hooks/metrics-collector.sh:110:    local error_msg="$2"
.claude/hooks/metrics-collector.sh:111:    local file="${3:-}"
.claude/hooks/metrics-collector.sh:112:    local resolved="${4:-false}"
.claude/hooks/metrics-collector.sh:113:
.claude/hooks/metrics-collector.sh:114:    if [[ ! -f "$SESSION_FILE" ]]; then
.claude/hooks/metrics-collector.sh:115:        start_session > /dev/null
.claude/hooks/metrics-collector.sh:116:    fi
.claude/hooks/metrics-collector.sh:117:
.claude/hooks/metrics-collector.sh:118:    local temp_file
.claude/hooks/metrics-collector.sh:119:    temp_file=$(mktemp)
.claude/hooks/metrics-collector.sh:120:
.claude/hooks/metrics-collector.sh:121:    local timestamp
.claude/hooks/metrics-collector.sh:122:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/metrics-collector.sh:123:
.claude/hooks/metrics-collector.sh:124:    jq --arg type "$error_type" \
.claude/hooks/metrics-collector.sh:125:       --arg msg "$error_msg" \
.claude/hooks/metrics-collector.sh:126:       --arg file "$file" \
.claude/hooks/metrics-collector.sh:127:       --arg resolved "$resolved" \
.claude/hooks/metrics-collector.sh:128:       --arg ts "$timestamp" \
.claude/hooks/metrics-collector.sh:129:       '.errors += [{
.claude/hooks/metrics-collector.sh:130:           type: $type,
.claude/hooks/metrics-collector.sh:131:           message: $msg,
.claude/hooks/metrics-collector.sh:132:           file: $file,
.claude/hooks/metrics-collector.sh:133:           resolved: ($resolved == "true"),
.claude/hooks/metrics-collector.sh:134:           timestamp: $ts
.claude/hooks/metrics-collector.sh:135:       }]' "$SESSION_FILE" > "$temp_file"
.claude/hooks/metrics-collector.sh:136:
.claude/hooks/metrics-collector.sh:137:    mv "$temp_file" "$SESSION_FILE"
.claude/hooks/metrics-collector.sh:138:
.claude/hooks/metrics-collector.sh:139:    log "Recorded error: $error_type"
.claude/hooks/metrics-collector.sh:140:}
.claude/hooks/metrics-collector.sh:141:
.claude/hooks/metrics-collector.sh:142:# Record a fix
.claude/hooks/metrics-collector.sh:143:record_fix() {
.claude/hooks/metrics-collector.sh:144:    local error_type="$1"
.claude/hooks/metrics-collector.sh:145:    local fix_method="$2"
.claude/hooks/metrics-collector.sh:146:    local source="${3:-manual}"
.claude/hooks/metrics-collector.sh:147:
.claude/hooks/metrics-collector.sh:148:    if [[ ! -f "$SESSION_FILE" ]]; then
.claude/hooks/metrics-collector.sh:149:        start_session > /dev/null
.claude/hooks/metrics-collector.sh:150:    fi
.claude/hooks/metrics-collector.sh:151:
.claude/hooks/metrics-collector.sh:152:    local temp_file
.claude/hooks/metrics-collector.sh:153:    temp_file=$(mktemp)
.claude/hooks/metrics-collector.sh:154:
.claude/hooks/metrics-collector.sh:155:    local timestamp
.claude/hooks/metrics-collector.sh:156:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/metrics-collector.sh:157:
.claude/hooks/metrics-collector.sh:158:    jq --arg type "$error_type" \
.claude/hooks/metrics-collector.sh:159:       --arg method "$fix_method" \
.claude/hooks/metrics-collector.sh:160:       --arg source "$source" \
.claude/hooks/metrics-collector.sh:161:       --arg ts "$timestamp" \
.claude/hooks/metrics-collector.sh:162:       '.fixes += [{
.claude/hooks/metrics-collector.sh:163:           errorType: $type,
.claude/hooks/metrics-collector.sh:164:           method: $method,
.claude/hooks/metrics-collector.sh:165:           source: $source,
.claude/hooks/metrics-collector.sh:166:           timestamp: $ts
.claude/hooks/metrics-collector.sh:167:       }]' "$SESSION_FILE" > "$temp_file"
.claude/hooks/metrics-collector.sh:168:
.claude/hooks/metrics-collector.sh:169:    mv "$temp_file" "$SESSION_FILE"
.claude/hooks/metrics-collector.sh:170:
.claude/hooks/metrics-collector.sh:171:    log "Recorded fix: $error_type via $fix_method"
.claude/hooks/metrics-collector.sh:172:}
.claude/hooks/metrics-collector.sh:173:
.claude/hooks/metrics-collector.sh:174:# Record a research query
.claude/hooks/metrics-collector.sh:175:record_research() {
.claude/hooks/metrics-collector.sh:176:    local query="$1"
.claude/hooks/metrics-collector.sh:177:    local source="$2"
.claude/hooks/metrics-collector.sh:178:    local results="${3:-0}"
.claude/hooks/metrics-collector.sh:179:    local useful="${4:-false}"
.claude/hooks/metrics-collector.sh:180:
.claude/hooks/metrics-collector.sh:181:    if [[ ! -f "$SESSION_FILE" ]]; then
.claude/hooks/metrics-collector.sh:182:        start_session > /dev/null
.claude/hooks/metrics-collector.sh:183:    fi
.claude/hooks/metrics-collector.sh:184:
.claude/hooks/metrics-collector.sh:185:    local temp_file
.claude/hooks/metrics-collector.sh:186:    temp_file=$(mktemp)
.claude/hooks/metrics-collector.sh:187:
.claude/hooks/metrics-collector.sh:188:    local timestamp
.claude/hooks/metrics-collector.sh:189:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/metrics-collector.sh:190:
.claude/hooks/metrics-collector.sh:191:    jq --arg query "$query" \
.claude/hooks/metrics-collector.sh:192:       --arg source "$source" \
.claude/hooks/metrics-collector.sh:193:       --argjson results "$results" \
.claude/hooks/metrics-collector.sh:194:       --arg useful "$useful" \
.claude/hooks/metrics-collector.sh:195:       --arg ts "$timestamp" \
.claude/hooks/metrics-collector.sh:196:       '.research += [{
.claude/hooks/metrics-collector.sh:197:           query: $query,
.claude/hooks/metrics-collector.sh:198:           source: $source,
.claude/hooks/metrics-collector.sh:199:           results: $results,
.claude/hooks/metrics-collector.sh:200:           useful: ($useful == "true"),
.claude/hooks/metrics-collector.sh:201:           timestamp: $ts
.claude/hooks/metrics-collector.sh:202:       }]' "$SESSION_FILE" > "$temp_file"
.claude/hooks/metrics-collector.sh:203:
.claude/hooks/metrics-collector.sh:204:    mv "$temp_file" "$SESSION_FILE"
.claude/hooks/metrics-collector.sh:205:
.claude/hooks/metrics-collector.sh:206:    log "Recorded research: $source ($results results)"
.claude/hooks/metrics-collector.sh:207:}
.claude/hooks/metrics-collector.sh:208:
.claude/hooks/metrics-collector.sh:209:# Record tool usage
.claude/hooks/metrics-collector.sh:210:record_tool() {
.claude/hooks/metrics-collector.sh:211:    local tool_name="$1"
.claude/hooks/metrics-collector.sh:212:    local duration="${2:-0}"
.claude/hooks/metrics-collector.sh:213:
.claude/hooks/metrics-collector.sh:214:    if [[ ! -f "$SESSION_FILE" ]]; then
.claude/hooks/metrics-collector.sh:215:        start_session > /dev/null
.claude/hooks/metrics-collector.sh:216:    fi
.claude/hooks/metrics-collector.sh:217:
.claude/hooks/metrics-collector.sh:218:    local temp_file
.claude/hooks/metrics-collector.sh:219:    temp_file=$(mktemp)
.claude/hooks/metrics-collector.sh:220:
.claude/hooks/metrics-collector.sh:221:    jq --arg tool "$tool_name" \
.claude/hooks/metrics-collector.sh:222:       --argjson duration "$duration" \
.claude/hooks/metrics-collector.sh:223:       '.toolCalls[$tool] = ((.toolCalls[$tool] // {count: 0, totalDuration: 0}) |
.claude/hooks/metrics-collector.sh:224:           .count += 1 | .totalDuration += $duration)' "$SESSION_FILE" > "$temp_file"
.claude/hooks/metrics-collector.sh:225:
.claude/hooks/metrics-collector.sh:226:    mv "$temp_file" "$SESSION_FILE"
.claude/hooks/metrics-collector.sh:227:}
.claude/hooks/metrics-collector.sh:228:
.claude/hooks/metrics-collector.sh:229:# Record context usage
.claude/hooks/metrics-collector.sh:230:record_context() {
.claude/hooks/metrics-collector.sh:231:    local percentage="$1"
.claude/hooks/metrics-collector.sh:232:    local action="${2:-checkpoint}"
.claude/hooks/metrics-collector.sh:233:
.claude/hooks/metrics-collector.sh:234:    if [[ ! -f "$SESSION_FILE" ]]; then
.claude/hooks/metrics-collector.sh:235:        start_session > /dev/null
.claude/hooks/metrics-collector.sh:236:    fi
.claude/hooks/metrics-collector.sh:237:
.claude/hooks/metrics-collector.sh:238:    local temp_file
.claude/hooks/metrics-collector.sh:239:    temp_file=$(mktemp)
.claude/hooks/metrics-collector.sh:240:
.claude/hooks/metrics-collector.sh:241:    local timestamp
.claude/hooks/metrics-collector.sh:242:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/metrics-collector.sh:243:
.claude/hooks/metrics-collector.sh:244:    jq --argjson pct "$percentage" \
.claude/hooks/metrics-collector.sh:245:       --arg action "$action" \
.claude/hooks/metrics-collector.sh:246:       --arg ts "$timestamp" \
.claude/hooks/metrics-collector.sh:247:       '.contextUsage += [{
.claude/hooks/metrics-collector.sh:248:           percentage: $pct,
.claude/hooks/metrics-collector.sh:249:           action: $action,
.claude/hooks/metrics-collector.sh:250:           timestamp: $ts
.claude/hooks/metrics-collector.sh:251:       }]' "$SESSION_FILE" > "$temp_file"
.claude/hooks/metrics-collector.sh:252:
.claude/hooks/metrics-collector.sh:253:    mv "$temp_file" "$SESSION_FILE"
.claude/hooks/metrics-collector.sh:254:
.claude/hooks/metrics-collector.sh:255:    log "Recorded context: ${percentage}% ($action)"
.claude/hooks/metrics-collector.sh:256:}
.claude/hooks/metrics-collector.sh:257:
.claude/hooks/metrics-collector.sh:258:# End session and update aggregates
.claude/hooks/metrics-collector.sh:259:end_session() {
.claude/hooks/metrics-collector.sh:260:    if [[ ! -f "$SESSION_FILE" ]]; then
.claude/hooks/metrics-collector.sh:261:        return 1
.claude/hooks/metrics-collector.sh:262:    fi
.claude/hooks/metrics-collector.sh:263:
.claude/hooks/metrics-collector.sh:264:    local temp_file
.claude/hooks/metrics-collector.sh:265:    temp_file=$(mktemp)
.claude/hooks/metrics-collector.sh:266:
.claude/hooks/metrics-collector.sh:267:    local timestamp
.claude/hooks/metrics-collector.sh:268:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/metrics-collector.sh:269:
.claude/hooks/metrics-collector.sh:270:    # Calculate session stats
.claude/hooks/metrics-collector.sh:271:    local session_stats
.claude/hooks/metrics-collector.sh:272:    session_stats=$(jq '
.claude/hooks/metrics-collector.sh:273:        {
.claude/hooks/metrics-collector.sh:274:            builds: (.builds | length),
.claude/hooks/metrics-collector.sh:275:            successful: ([.builds[] | select(.status == "success")] | length),
.claude/hooks/metrics-collector.sh:276:            errors: (.errors | length),
.claude/hooks/metrics-collector.sh:277:            fixes: (.fixes | length),
.claude/hooks/metrics-collector.sh:278:            research: (.research | length),
.claude/hooks/metrics-collector.sh:279:            duration: (
.claude/hooks/metrics-collector.sh:280:                (now | floor) - (.startedAt | fromdate | floor)
.claude/hooks/metrics-collector.sh:281:            )
.claude/hooks/metrics-collector.sh:282:        }
.claude/hooks/metrics-collector.sh:283:    ' "$SESSION_FILE")
.claude/hooks/metrics-collector.sh:284:
.claude/hooks/metrics-collector.sh:285:    # Update aggregate metrics
.claude/hooks/metrics-collector.sh:286:    local agg_temp
.claude/hooks/metrics-collector.sh:287:    agg_temp=$(mktemp)
.claude/hooks/metrics-collector.sh:288:
.claude/hooks/metrics-collector.sh:289:    jq --argjson stats "$session_stats" \
.claude/hooks/metrics-collector.sh:290:       --arg ts "$timestamp" \
.claude/hooks/metrics-collector.sh:291:       '
.claude/hooks/metrics-collector.sh:292:       .totalSessions += 1 |
.claude/hooks/metrics-collector.sh:293:       .totalBuilds += $stats.builds |
.claude/hooks/metrics-collector.sh:294:       .totalErrors += $stats.errors |
.claude/hooks/metrics-collector.sh:295:       .totalFixes += $stats.fixes |
.claude/hooks/metrics-collector.sh:296:       .totalResearchQueries += $stats.research |
.claude/hooks/metrics-collector.sh:297:       .successRate = (
.claude/hooks/metrics-collector.sh:298:           if (.totalBuilds + $stats.builds) > 0 then
.claude/hooks/metrics-collector.sh:299:               (((.successRate * .totalBuilds) + ($stats.successful)) / (.totalBuilds + $stats.builds) * 100 | floor)
.claude/hooks/metrics-collector.sh:300:           else 0 end
.claude/hooks/metrics-collector.sh:301:       ) |
.claude/hooks/metrics-collector.sh:302:       .lastUpdated = $ts
.claude/hooks/metrics-collector.sh:303:       ' "$AGGREGATE_FILE" > "$agg_temp"
.claude/hooks/metrics-collector.sh:304:
.claude/hooks/metrics-collector.sh:305:    mv "$agg_temp" "$AGGREGATE_FILE"
.claude/hooks/metrics-collector.sh:306:
.claude/hooks/metrics-collector.sh:307:    # Archive session
.claude/hooks/metrics-collector.sh:308:    local archive_dir="$METRICS_DIR/archive"
.claude/hooks/metrics-collector.sh:309:    mkdir -p "$archive_dir"
.claude/hooks/metrics-collector.sh:310:    mv "$SESSION_FILE" "$archive_dir/session_$(date +%Y%m%d_%H%M%S).json"
.claude/hooks/metrics-collector.sh:311:
.claude/hooks/metrics-collector.sh:312:    log "Ended session, updated aggregates"
.claude/hooks/metrics-collector.sh:313:    echo "$session_stats"
.claude/hooks/metrics-collector.sh:314:}
.claude/hooks/metrics-collector.sh:315:
.claude/hooks/metrics-collector.sh:316:# Get current session metrics
.claude/hooks/metrics-collector.sh:317:get_session() {
.claude/hooks/metrics-collector.sh:318:    if [[ ! -f "$SESSION_FILE" ]]; then
.claude/hooks/metrics-collector.sh:319:        echo '{"status":"no_active_session"}'
.claude/hooks/metrics-collector.sh:320:        return
.claude/hooks/metrics-collector.sh:321:    fi
.claude/hooks/metrics-collector.sh:322:
.claude/hooks/metrics-collector.sh:323:    jq '.' "$SESSION_FILE"
.claude/hooks/metrics-collector.sh:324:}
.claude/hooks/metrics-collector.sh:325:
.claude/hooks/metrics-collector.sh:326:# Get aggregate metrics
.claude/hooks/metrics-collector.sh:327:get_aggregates() {
.claude/hooks/metrics-collector.sh:328:    init_metrics
.claude/hooks/metrics-collector.sh:329:    jq '.' "$AGGREGATE_FILE"
.claude/hooks/metrics-collector.sh:330:}
.claude/hooks/metrics-collector.sh:331:
.claude/hooks/metrics-collector.sh:332:# Get summary for display
.claude/hooks/metrics-collector.sh:333:get_summary() {
.claude/hooks/metrics-collector.sh:334:    init_metrics
.claude/hooks/metrics-collector.sh:335:
.claude/hooks/metrics-collector.sh:336:    jq -r '
.claude/hooks/metrics-collector.sh:337:        "=== Build Metrics ===\n" +
.claude/hooks/metrics-collector.sh:338:        "Total Sessions: \(.totalSessions)\n" +
.claude/hooks/metrics-collector.sh:339:        "Total Builds: \(.totalBuilds)\n" +
.claude/hooks/metrics-collector.sh:340:        "Success Rate: \(.successRate)%\n" +
.claude/hooks/metrics-collector.sh:341:        "Total Errors: \(.totalErrors)\n" +
.claude/hooks/metrics-collector.sh:342:        "Total Fixes: \(.totalFixes)\n" +
.claude/hooks/metrics-collector.sh:343:        "Research Queries: \(.totalResearchQueries)\n" +
.claude/hooks/metrics-collector.sh:344:        "Last Updated: \(.lastUpdated // "never")"
.claude/hooks/metrics-collector.sh:345:    ' "$AGGREGATE_FILE"
.claude/hooks/metrics-collector.sh:346:}
.claude/hooks/metrics-collector.sh:347:
.claude/hooks/metrics-collector.sh:348:# =============================================================================
.claude/hooks/metrics-collector.sh:349:# COMMAND INTERFACE
.claude/hooks/metrics-collector.sh:350:# =============================================================================
.claude/hooks/metrics-collector.sh:351:
.claude/hooks/metrics-collector.sh:352:case "${1:-help}" in
.claude/hooks/metrics-collector.sh:353:    start)
.claude/hooks/metrics-collector.sh:354:        start_session
.claude/hooks/metrics-collector.sh:355:        ;;
.claude/hooks/metrics-collector.sh:356:    build)
.claude/hooks/metrics-collector.sh:357:        record_build "${2:-unnamed}" "${3:-success}" "${4:-0}" "${5:-0}" "${6:-0}"
.claude/hooks/metrics-collector.sh:358:        ;;
.claude/hooks/metrics-collector.sh:359:    error)
.claude/hooks/metrics-collector.sh:360:        record_error "${2:-UNKNOWN}" "${3:-error}" "${4:-}" "${5:-false}"
.claude/hooks/metrics-collector.sh:361:        ;;
.claude/hooks/metrics-collector.sh:362:    fix)
.claude/hooks/metrics-collector.sh:363:        record_fix "${2:-UNKNOWN}" "${3:-manual}" "${4:-manual}"
.claude/hooks/metrics-collector.sh:364:        ;;
.claude/hooks/metrics-collector.sh:365:    research)
.claude/hooks/metrics-collector.sh:366:        record_research "${2:-query}" "${3:-github}" "${4:-0}" "${5:-false}"
.claude/hooks/metrics-collector.sh:367:        ;;
.claude/hooks/metrics-collector.sh:368:    tool)
.claude/hooks/metrics-collector.sh:369:        record_tool "${2:-unknown}" "${3:-0}"
.claude/hooks/metrics-collector.sh:370:        ;;
.claude/hooks/metrics-collector.sh:371:    context)
.claude/hooks/metrics-collector.sh:372:        record_context "${2:-0}" "${3:-checkpoint}"
.claude/hooks/metrics-collector.sh:373:        ;;
.claude/hooks/metrics-collector.sh:374:    end)
.claude/hooks/metrics-collector.sh:375:        end_session
.claude/hooks/metrics-collector.sh:376:        ;;
.claude/hooks/metrics-collector.sh:377:    session)
.claude/hooks/metrics-collector.sh:378:        get_session
.claude/hooks/metrics-collector.sh:379:        ;;
.claude/hooks/metrics-collector.sh:380:    aggregates)
.claude/hooks/metrics-collector.sh:381:        get_aggregates
.claude/hooks/metrics-collector.sh:382:        ;;
.claude/hooks/metrics-collector.sh:383:    summary)
.claude/hooks/metrics-collector.sh:384:        get_summary
.claude/hooks/metrics-collector.sh:385:        ;;
.claude/hooks/metrics-collector.sh:386:    help|*)
.claude/hooks/metrics-collector.sh:387:        echo "Metrics Collector"
.claude/hooks/metrics-collector.sh:388:        echo ""
.claude/hooks/metrics-collector.sh:389:        echo "Usage: $0 <command> [args]"
.claude/hooks/metrics-collector.sh:390:        echo ""
.claude/hooks/metrics-collector.sh:391:        echo "Commands:"
.claude/hooks/metrics-collector.sh:392:        echo "  start                                    - Start new session"
.claude/hooks/metrics-collector.sh:393:        echo "  build <name> <status> [duration] [steps] [errors]"
.claude/hooks/metrics-collector.sh:394:        echo "  error <type> <message> [file] [resolved]"
.claude/hooks/metrics-collector.sh:395:        echo "  fix <error_type> <method> [source]"
.claude/hooks/metrics-collector.sh:396:        echo "  research <query> <source> [results] [useful]"
.claude/hooks/metrics-collector.sh:397:        echo "  tool <name> [duration_ms]"
.claude/hooks/metrics-collector.sh:398:        echo "  context <percentage> [action]"
.claude/hooks/metrics-collector.sh:399:        echo "  end                                      - End session, update aggregates"
.claude/hooks/metrics-collector.sh:400:        echo "  session                                  - Get current session"
.claude/hooks/metrics-collector.sh:401:        echo "  aggregates                               - Get aggregate metrics"
.claude/hooks/metrics-collector.sh:402:        echo "  summary                                  - Get human-readable summary"
.claude/hooks/metrics-collector.sh:403:        ;;
.claude/hooks/metrics-collector.sh:404:esac
.claude/hooks/parallel-execution-planner.sh:1:#!/bin/bash
.claude/hooks/parallel-execution-planner.sh:2:# Parallel Execution Planner - Simple working version
.claude/hooks/parallel-execution-planner.sh:3:set -eo pipefail
.claude/hooks/parallel-execution-planner.sh:4:
.claude/hooks/parallel-execution-planner.sh:5:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/parallel-execution-planner.sh:6:LOG_FILE="${CLAUDE_DIR}/parallel-planner.log"
.claude/hooks/parallel-execution-planner.sh:7:
.claude/hooks/parallel-execution-planner.sh:8:log() {
.claude/hooks/parallel-execution-planner.sh:9:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/parallel-execution-planner.sh:10:}
.claude/hooks/parallel-execution-planner.sh:11:
.claude/hooks/parallel-execution-planner.sh:12:analyze_dependencies() {
.claude/hooks/parallel-execution-planner.sh:13:    local tasks_json="$1"
.claude/hooks/parallel-execution-planner.sh:14:
.claude/hooks/parallel-execution-planner.sh:15:    log "Analyzing dependencies"
.claude/hooks/parallel-execution-planner.sh:16:
.claude/hooks/parallel-execution-planner.sh:17:    jq -n \
.claude/hooks/parallel-execution-planner.sh:18:        --argjson tasks "$tasks_json" \
.claude/hooks/parallel-execution-planner.sh:19:        '{
.claude/hooks/parallel-execution-planner.sh:20:            analysis_prompt: "Analyze these tasks for dependencies and identify which can run in parallel",
.claude/hooks/parallel-execution-planner.sh:21:            tasks: $tasks,
.claude/hooks/parallel-execution-planner.sh:22:            instructions: "Group independent tasks together for parallel execution"
.claude/hooks/parallel-execution-planner.sh:23:        }'
.claude/hooks/parallel-execution-planner.sh:24:}
.claude/hooks/parallel-execution-planner.sh:25:
.claude/hooks/parallel-execution-planner.sh:26:generate_execution_plan() {
.claude/hooks/parallel-execution-planner.sh:27:    local analysis="$1"
.claude/hooks/parallel-execution-planner.sh:28:
.claude/hooks/parallel-execution-planner.sh:29:    log "Generating execution plan"
.claude/hooks/parallel-execution-planner.sh:30:
.claude/hooks/parallel-execution-planner.sh:31:    echo "$analysis" | jq '{
.claude/hooks/parallel-execution-planner.sh:32:        strategy: "parallel_execution",
.claude/hooks/parallel-execution-planner.sh:33:        instructions: "Execute groups sequentially, tasks within groups in parallel",
.claude/hooks/parallel-execution-planner.sh:34:        groups: []
.claude/hooks/parallel-execution-planner.sh:35:    }'
.claude/hooks/parallel-execution-planner.sh:36:}
.claude/hooks/parallel-execution-planner.sh:37:
.claude/hooks/parallel-execution-planner.sh:38:case "${1:-help}" in
.claude/hooks/parallel-execution-planner.sh:39:    analyze) analyze_dependencies "${2:-{\"tasks\":[]}}" ;;
.claude/hooks/parallel-execution-planner.sh:40:    plan) generate_execution_plan "${2:-{}}" ;;
.claude/hooks/parallel-execution-planner.sh:41:    *) echo "Usage: $0 {analyze|plan} <json>" ;;
.claude/hooks/parallel-execution-planner.sh:42:esac
.claude/hooks/context-optimizer.sh:1:#!/bin/bash
.claude/hooks/context-optimizer.sh:2:# Context Optimizer - Predicts and optimizes context window usage
.claude/hooks/context-optimizer.sh:3:
.claude/hooks/context-optimizer.sh:4:set -uo pipefail
.claude/hooks/context-optimizer.sh:5:
.claude/hooks/context-optimizer.sh:6:CONTEXT_DIR="${HOME}/.claude/context"
.claude/hooks/context-optimizer.sh:7:USAGE_HISTORY="$CONTEXT_DIR/usage_history.jsonl"
.claude/hooks/context-optimizer.sh:8:PREDICTIONS="$CONTEXT_DIR/predictions.json"
.claude/hooks/context-optimizer.sh:9:LOG_FILE="${HOME}/.claude/context-optimizer.log"
.claude/hooks/context-optimizer.sh:10:
.claude/hooks/context-optimizer.sh:11:log() {
.claude/hooks/context-optimizer.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/context-optimizer.sh:13:}
.claude/hooks/context-optimizer.sh:14:
.claude/hooks/context-optimizer.sh:15:init_context() {
.claude/hooks/context-optimizer.sh:16:    mkdir -p "$CONTEXT_DIR"
.claude/hooks/context-optimizer.sh:17:    [[ -f "$USAGE_HISTORY" ]] || touch "$USAGE_HISTORY"
.claude/hooks/context-optimizer.sh:18:    [[ -f "$PREDICTIONS" ]] || echo '{}' > "$PREDICTIONS"
.claude/hooks/context-optimizer.sh:19:}
.claude/hooks/context-optimizer.sh:20:
.claude/hooks/context-optimizer.sh:21:# Record context usage
.claude/hooks/context-optimizer.sh:22:record_usage() {
.claude/hooks/context-optimizer.sh:23:    local operation="$1"
.claude/hooks/context-optimizer.sh:24:    local tokens_used="$2"
.claude/hooks/context-optimizer.sh:25:    local files_loaded="${3:-0}"
.claude/hooks/context-optimizer.sh:26:
.claude/hooks/context-optimizer.sh:27:    init_context
.claude/hooks/context-optimizer.sh:28:
.claude/hooks/context-optimizer.sh:29:    local timestamp
.claude/hooks/context-optimizer.sh:30:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/context-optimizer.sh:31:
.claude/hooks/context-optimizer.sh:32:    local record
.claude/hooks/context-optimizer.sh:33:    record=$(jq -n \
.claude/hooks/context-optimizer.sh:34:        --arg op "$operation" \
.claude/hooks/context-optimizer.sh:35:        --argjson tokens "$tokens_used" \
.claude/hooks/context-optimizer.sh:36:        --argjson files "$files_loaded" \
.claude/hooks/context-optimizer.sh:37:        --arg ts "$timestamp" \
.claude/hooks/context-optimizer.sh:38:        '{operation: $op, tokens: $tokens, files: $files, timestamp: $ts}')
.claude/hooks/context-optimizer.sh:39:
.claude/hooks/context-optimizer.sh:40:    echo "$record" >> "$USAGE_HISTORY"
.claude/hooks/context-optimizer.sh:41:    log "Recorded: $operation used $tokens_used tokens"
.claude/hooks/context-optimizer.sh:42:}
.claude/hooks/context-optimizer.sh:43:
.claude/hooks/context-optimizer.sh:44:# Predict tokens needed for operation
.claude/hooks/context-optimizer.sh:45:predict_tokens() {
.claude/hooks/context-optimizer.sh:46:    local operation="$1"
.claude/hooks/context-optimizer.sh:47:    local file_count="${2:-1}"
.claude/hooks/context-optimizer.sh:48:
.claude/hooks/context-optimizer.sh:49:    init_context
.claude/hooks/context-optimizer.sh:50:
.claude/hooks/context-optimizer.sh:51:    # Get historical average for this operation
.claude/hooks/context-optimizer.sh:52:    local avg_tokens
.claude/hooks/context-optimizer.sh:53:    avg_tokens=$(grep "\"operation\":\"$operation\"" "$USAGE_HISTORY" 2>/dev/null | \
.claude/hooks/context-optimizer.sh:54:        jq -s 'if length > 0 then ([.[].tokens] | add / length | floor) else 5000 end')
.claude/hooks/context-optimizer.sh:55:
.claude/hooks/context-optimizer.sh:56:    # Adjust for file count (rough estimate: 1000 tokens per file)
.claude/hooks/context-optimizer.sh:57:    local predicted
.claude/hooks/context-optimizer.sh:58:    predicted=$((avg_tokens + (file_count * 1000)))
.claude/hooks/context-optimizer.sh:59:
.claude/hooks/context-optimizer.sh:60:    echo "{\"operation\":\"$operation\",\"predictedTokens\":$predicted,\"confidence\":\"medium\"}"
.claude/hooks/context-optimizer.sh:61:}
.claude/hooks/context-optimizer.sh:62:
.claude/hooks/context-optimizer.sh:63:# Check if operation will exceed threshold
.claude/hooks/context-optimizer.sh:64:will_exceed_threshold() {
.claude/hooks/context-optimizer.sh:65:    local current_usage="$1"
.claude/hooks/context-optimizer.sh:66:    local operation="$2"
.claude/hooks/context-optimizer.sh:67:    local threshold="${3:-80}"  # percentage
.claude/hooks/context-optimizer.sh:68:    local max_tokens="${4:-200000}"
.claude/hooks/context-optimizer.sh:69:
.claude/hooks/context-optimizer.sh:70:    local prediction
.claude/hooks/context-optimizer.sh:71:    prediction=$(predict_tokens "$operation")
.claude/hooks/context-optimizer.sh:72:    local predicted_tokens
.claude/hooks/context-optimizer.sh:73:    predicted_tokens=$(echo "$prediction" | jq -r '.predictedTokens')
.claude/hooks/context-optimizer.sh:74:
.claude/hooks/context-optimizer.sh:75:    local total_after
.claude/hooks/context-optimizer.sh:76:    total_after=$((current_usage + predicted_tokens))
.claude/hooks/context-optimizer.sh:77:    local percent_after
.claude/hooks/context-optimizer.sh:78:    percent_after=$((total_after * 100 / max_tokens))
.claude/hooks/context-optimizer.sh:79:
.claude/hooks/context-optimizer.sh:80:    if [[ $percent_after -gt $threshold ]]; then
.claude/hooks/context-optimizer.sh:81:        echo "{\"willExceed\":true,\"percentAfter\":$percent_after,\"recommendation\":\"Consider compacting context first\"}"
.claude/hooks/context-optimizer.sh:82:    else
.claude/hooks/context-optimizer.sh:83:        echo "{\"willExceed\":false,\"percentAfter\":$percent_after,\"recommendation\":\"Safe to proceed\"}"
.claude/hooks/context-optimizer.sh:84:    fi
.claude/hooks/context-optimizer.sh:85:}
.claude/hooks/context-optimizer.sh:86:
.claude/hooks/context-optimizer.sh:87:# Optimize context by identifying low-value content
.claude/hooks/context-optimizer.sh:88:optimize() {
.claude/hooks/context-optimizer.sh:89:    local current_files="$1"  # JSON array of loaded files
.claude/hooks/context-optimizer.sh:90:
.claude/hooks/context-optimizer.sh:91:    # Score files by relevance (placeholder - real impl would use embeddings)
.claude/hooks/context-optimizer.sh:92:    echo "$current_files" | jq '[
.claude/hooks/context-optimizer.sh:93:        .[] |
.claude/hooks/context-optimizer.sh:94:        . + {relevanceScore: (if .lastAccessed then 70 else 30 end)}
.claude/hooks/context-optimizer.sh:95:    ] | sort_by(-.relevanceScore)'
.claude/hooks/context-optimizer.sh:96:}
.claude/hooks/context-optimizer.sh:97:
.claude/hooks/context-optimizer.sh:98:case "${1:-help}" in
.claude/hooks/context-optimizer.sh:99:    record) record_usage "${2:-op}" "${3:-0}" "${4:-0}" ;;
.claude/hooks/context-optimizer.sh:100:    predict) predict_tokens "${2:-op}" "${3:-1}" ;;
.claude/hooks/context-optimizer.sh:101:    check-threshold) will_exceed_threshold "${2:-0}" "${3:-op}" "${4:-80}" "${5:-200000}" ;;
.claude/hooks/context-optimizer.sh:102:    optimize) optimize "${2:-[]}" ;;
.claude/hooks/context-optimizer.sh:103:    *) echo "Usage: $0 {record|predict|check-threshold|optimize} [args]" ;;
.claude/hooks/context-optimizer.sh:104:esac
.claude/hooks/auto-continue.sh:1:#!/bin/bash
.claude/hooks/auto-continue.sh:2:# Auto-Continue Hook - Fully automated context management with quality awareness
.claude/hooks/auto-continue.sh:3:# When context hits threshold:
.claude/hooks/auto-continue.sh:4:# 1. Checks if build is in progress
.claude/hooks/auto-continue.sh:5:# 2. Runs validation before checkpoint
.claude/hooks/auto-continue.sh:6:# 3. Saves state and creates continuation prompt
.claude/hooks/auto-continue.sh:7:# 4. Feeds prompt back to keep running
.claude/hooks/auto-continue.sh:8:
.claude/hooks/auto-continue.sh:9:set -euo pipefail
.claude/hooks/auto-continue.sh:10:
.claude/hooks/auto-continue.sh:11:THRESHOLD=${CLAUDE_CONTEXT_THRESHOLD:-40}
.claude/hooks/auto-continue.sh:12:LOG_FILE="${HOME}/.claude/auto-continue.log"
.claude/hooks/auto-continue.sh:13:STATE_FILE=".claude/auto-continue.local.md"
.claude/hooks/auto-continue.sh:14:BUILD_STATE=".claude/current-build.local.md"
.claude/hooks/auto-continue.sh:15:
.claude/hooks/auto-continue.sh:16:log() {
.claude/hooks/auto-continue.sh:17:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/auto-continue.sh:18:}
.claude/hooks/auto-continue.sh:19:
.claude/hooks/auto-continue.sh:20:# Read hook input
.claude/hooks/auto-continue.sh:21:HOOK_INPUT=$(cat)
.claude/hooks/auto-continue.sh:22:
.claude/hooks/auto-continue.sh:23:# Extract context info
.claude/hooks/auto-continue.sh:24:CONTEXT_SIZE=$(echo "$HOOK_INPUT" | jq -r '.context_window.context_window_size // 200000')
.claude/hooks/auto-continue.sh:25:USAGE=$(echo "$HOOK_INPUT" | jq '.context_window.current_usage // null')
.claude/hooks/auto-continue.sh:26:TRANSCRIPT_PATH=$(echo "$HOOK_INPUT" | jq -r '.transcript_path // ""')
.claude/hooks/auto-continue.sh:27:
.claude/hooks/auto-continue.sh:28:if [[ "$USAGE" == "null" ]]; then
.claude/hooks/auto-continue.sh:29:    log "No usage data - allowing stop"
.claude/hooks/auto-continue.sh:30:    exit 0
.claude/hooks/auto-continue.sh:31:fi
.claude/hooks/auto-continue.sh:32:
.claude/hooks/auto-continue.sh:33:# Calculate percentage
.claude/hooks/auto-continue.sh:34:INPUT_TOKENS=$(echo "$USAGE" | jq -r '.input_tokens // 0')
.claude/hooks/auto-continue.sh:35:CACHE_CREATE=$(echo "$USAGE" | jq -r '.cache_creation_input_tokens // 0')
.claude/hooks/auto-continue.sh:36:CACHE_READ=$(echo "$USAGE" | jq -r '.cache_read_input_tokens // 0')
.claude/hooks/auto-continue.sh:37:CURRENT_TOKENS=$((INPUT_TOKENS + CACHE_CREATE + CACHE_READ))
.claude/hooks/auto-continue.sh:38:PERCENT=$((CURRENT_TOKENS * 100 / CONTEXT_SIZE))
.claude/hooks/auto-continue.sh:39:
.claude/hooks/auto-continue.sh:40:log "Context: ${PERCENT}% (${CURRENT_TOKENS}/${CONTEXT_SIZE})"
.claude/hooks/auto-continue.sh:41:
.claude/hooks/auto-continue.sh:42:# Check if auto-continue is disabled
.claude/hooks/auto-continue.sh:43:if [[ -f ".claude/auto-continue-disabled" ]]; then
.claude/hooks/auto-continue.sh:44:    log "Auto-continue disabled - allowing stop"
.claude/hooks/auto-continue.sh:45:    exit 0
.claude/hooks/auto-continue.sh:46:fi
.claude/hooks/auto-continue.sh:47:
.claude/hooks/auto-continue.sh:48:# Check for stop words in last message
.claude/hooks/auto-continue.sh:49:if [[ -n "$TRANSCRIPT_PATH" ]] && [[ -f "$TRANSCRIPT_PATH" ]]; then
.claude/hooks/auto-continue.sh:50:    LAST_USER=$(grep '"role":"user"' "$TRANSCRIPT_PATH" | tail -1 | jq -r '.message.content[0].text // ""' 2>/dev/null || echo "")
.claude/hooks/auto-continue.sh:51:    if echo "$LAST_USER" | grep -qiE '\b(stop|pause|hold|wait|quit)\b'; then
.claude/hooks/auto-continue.sh:52:        log "Stop word detected - allowing stop"
.claude/hooks/auto-continue.sh:53:        exit 0
.claude/hooks/auto-continue.sh:54:    fi
.claude/hooks/auto-continue.sh:55:fi
.claude/hooks/auto-continue.sh:56:
.claude/hooks/auto-continue.sh:57:# Below threshold - allow normal stop
.claude/hooks/auto-continue.sh:58:if [[ $PERCENT -lt $THRESHOLD ]]; then
.claude/hooks/auto-continue.sh:59:    exit 0
.claude/hooks/auto-continue.sh:60:fi
.claude/hooks/auto-continue.sh:61:
.claude/hooks/auto-continue.sh:62:log "Threshold reached (${PERCENT}% >= ${THRESHOLD}%) - triggering auto-continue"
.claude/hooks/auto-continue.sh:63:
.claude/hooks/auto-continue.sh:64:# PHASE 1 INTEGRATION: Create memory checkpoint before compacting
.claude/hooks/auto-continue.sh:65:log "Creating memory checkpoint before compact..."
.claude/hooks/auto-continue.sh:66:MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/auto-continue.sh:67:CHECKPOINT_ID=""
.claude/hooks/auto-continue.sh:68:
.claude/hooks/auto-continue.sh:69:if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/auto-continue.sh:70:    # Create checkpoint with context percentage in description
.claude/hooks/auto-continue.sh:71:    CHECKPOINT_ID=$("$MEMORY_MANAGER" checkpoint "Auto-checkpoint at ${PERCENT}% context before compact" 2>/dev/null || echo "")
.claude/hooks/auto-continue.sh:72:
.claude/hooks/auto-continue.sh:73:    if [[ -n "$CHECKPOINT_ID" ]]; then
.claude/hooks/auto-continue.sh:74:        log " Memory checkpoint created: $CHECKPOINT_ID"
.claude/hooks/auto-continue.sh:75:    else
.claude/hooks/auto-continue.sh:76:        log "  Failed to create memory checkpoint"
.claude/hooks/auto-continue.sh:77:    fi
.claude/hooks/auto-continue.sh:78:else
.claude/hooks/auto-continue.sh:79:    log "  memory-manager.sh not found - skipping checkpoint"
.claude/hooks/auto-continue.sh:80:fi
.claude/hooks/auto-continue.sh:81:
.claude/hooks/auto-continue.sh:82:# Get current working directory info
.claude/hooks/auto-continue.sh:83:PROJECT_NAME=$(basename "$(pwd)")
.claude/hooks/auto-continue.sh:84:PROJECT_DIR=$(pwd)
.claude/hooks/auto-continue.sh:85:
.claude/hooks/auto-continue.sh:86:# Check if build is in progress
.claude/hooks/auto-continue.sh:87:BUILD_CONTEXT=""
.claude/hooks/auto-continue.sh:88:if [[ -f "$BUILD_STATE" ]]; then
.claude/hooks/auto-continue.sh:89:    BUILD_FEATURE=$(grep '^feature:' "$BUILD_STATE" | sed 's/feature: *//' || echo "")
.claude/hooks/auto-continue.sh:90:    BUILD_PHASE=$(grep '^phase:' "$BUILD_STATE" | sed 's/phase: *//' || echo "")
.claude/hooks/auto-continue.sh:91:    BUILD_ITERATION=$(grep '^iteration:' "$BUILD_STATE" | sed 's/iteration: *//' || echo "1")
.claude/hooks/auto-continue.sh:92:
.claude/hooks/auto-continue.sh:93:    if [[ -n "$BUILD_FEATURE" ]] && [[ "$BUILD_PHASE" != "complete" ]]; then
.claude/hooks/auto-continue.sh:94:        BUILD_CONTEXT="
.claude/hooks/auto-continue.sh:95:**Active Build**: $BUILD_FEATURE (phase: $BUILD_PHASE, iteration: $BUILD_ITERATION)
.claude/hooks/auto-continue.sh:96:Continue implementing this feature. Check .claude/current-build.local.md for progress."
.claude/hooks/auto-continue.sh:97:    fi
.claude/hooks/auto-continue.sh:98:fi
.claude/hooks/auto-continue.sh:99:
.claude/hooks/auto-continue.sh:100:# Read CLAUDE.md if exists
.claude/hooks/auto-continue.sh:101:CLAUDE_MD_CONTENT=""
.claude/hooks/auto-continue.sh:102:if [[ -f "CLAUDE.md" ]]; then
.claude/hooks/auto-continue.sh:103:    CLAUDE_MD_CONTENT=$(head -50 CLAUDE.md 2>/dev/null || echo "")
.claude/hooks/auto-continue.sh:104:fi
.claude/hooks/auto-continue.sh:105:
.claude/hooks/auto-continue.sh:106:# Read buildguide.md next section if exists
.claude/hooks/auto-continue.sh:107:NEXT_SECTION=""
.claude/hooks/auto-continue.sh:108:NEXT_SECTION_DETAIL=""
.claude/hooks/auto-continue.sh:109:if [[ -f "buildguide.md" ]]; then
.claude/hooks/auto-continue.sh:110:    # Get first unchecked section
.claude/hooks/auto-continue.sh:111:    NEXT_SECTION=$(grep -m1 '^\- \[ \]' buildguide.md 2>/dev/null | sed 's/- \[ \] //' || echo "")
.claude/hooks/auto-continue.sh:112:
.claude/hooks/auto-continue.sh:113:    # Try to get the section details
.claude/hooks/auto-continue.sh:114:    if [[ -n "$NEXT_SECTION" ]]; then
.claude/hooks/auto-continue.sh:115:        # Find the section header and get content until next section
.claude/hooks/auto-continue.sh:116:        SECTION_CONTENT=$(awk "/^## .*${NEXT_SECTION}/,/^## /" buildguide.md 2>/dev/null | head -30 || echo "")
.claude/hooks/auto-continue.sh:117:        if [[ -n "$SECTION_CONTENT" ]]; then
.claude/hooks/auto-continue.sh:118:            NEXT_SECTION_DETAIL="
.claude/hooks/auto-continue.sh:119:**Next Section from buildguide.md**: $NEXT_SECTION
.claude/hooks/auto-continue.sh:120:$SECTION_CONTENT"
.claude/hooks/auto-continue.sh:121:        fi
.claude/hooks/auto-continue.sh:122:    fi
.claude/hooks/auto-continue.sh:123:fi
.claude/hooks/auto-continue.sh:124:
.claude/hooks/auto-continue.sh:125:# Check for architecture docs
.claude/hooks/auto-continue.sh:126:ARCH_CONTEXT=""
.claude/hooks/auto-continue.sh:127:for arch_file in "ARCHITECTURE.md" "docs/architecture.md" ".claude/docs/architecture.md"; do
.claude/hooks/auto-continue.sh:128:    if [[ -f "$arch_file" ]]; then
.claude/hooks/auto-continue.sh:129:        ARCH_CONTEXT="
.claude/hooks/auto-continue.sh:130:**Architecture**: See $arch_file for system design."
.claude/hooks/auto-continue.sh:131:        break
.claude/hooks/auto-continue.sh:132:    fi
.claude/hooks/auto-continue.sh:133:done
.claude/hooks/auto-continue.sh:134:
.claude/hooks/auto-continue.sh:135:# Check for stuck issues in debug-log
.claude/hooks/auto-continue.sh:136:STUCK_ISSUES=""
.claude/hooks/auto-continue.sh:137:if [[ -f ".claude/docs/debug-log.md" ]]; then
.claude/hooks/auto-continue.sh:138:    STUCK=$(grep -c "STUCK" ".claude/docs/debug-log.md" 2>/dev/null || echo "0")
.claude/hooks/auto-continue.sh:139:    if [[ "$STUCK" -gt 0 ]]; then
.claude/hooks/auto-continue.sh:140:        STUCK_ISSUES="
.claude/hooks/auto-continue.sh:141: $STUCK stuck issues in debug-log.md - may need review."
.claude/hooks/auto-continue.sh:142:    fi
.claude/hooks/auto-continue.sh:143:fi
.claude/hooks/auto-continue.sh:144:
.claude/hooks/auto-continue.sh:145:# Build continuation prompt (token-effective per Ken Kai principles)
.claude/hooks/auto-continue.sh:146:# Short, focused, no essays - agent is smart
.claude/hooks/auto-continue.sh:147:CHECKPOINT_INFO=""
.claude/hooks/auto-continue.sh:148:if [[ -n "$CHECKPOINT_ID" ]]; then
.claude/hooks/auto-continue.sh:149:    CHECKPOINT_INFO="
.claude/hooks/auto-continue.sh:150: Memory checkpoint: $CHECKPOINT_ID (restore with: memory-manager.sh restore $CHECKPOINT_ID)"
.claude/hooks/auto-continue.sh:151:fi
.claude/hooks/auto-continue.sh:152:
.claude/hooks/auto-continue.sh:153:CONTINUATION_PROMPT="Continue ${PROJECT_NAME}. Context compacted at ${PERCENT}%.${CHECKPOINT_INFO}
.claude/hooks/auto-continue.sh:154:${BUILD_CONTEXT:-No active build.}
.claude/hooks/auto-continue.sh:155:${NEXT_SECTION:+Next: $NEXT_SECTION}
.claude/hooks/auto-continue.sh:156:${STUCK_ISSUES}
.claude/hooks/auto-continue.sh:157:
.claude/hooks/auto-continue.sh:158:Action: ${BUILD_CONTEXT:+Continue build from .claude/current-build.local.md}${BUILD_CONTEXT:-Run /build for next section}
.claude/hooks/auto-continue.sh:159:
.claude/hooks/auto-continue.sh:160:Remember: Short prompts > long ones. Reference docs, don't dump. Work focused."
.claude/hooks/auto-continue.sh:161:
.claude/hooks/auto-continue.sh:162:# Track iteration
.claude/hooks/auto-continue.sh:163:ITERATION=1
.claude/hooks/auto-continue.sh:164:if [[ -f "$STATE_FILE" ]]; then
.claude/hooks/auto-continue.sh:165:    ITERATION=$(grep '^iteration:' "$STATE_FILE" | sed 's/iteration: *//' || echo "1")
.claude/hooks/auto-continue.sh:166:    ITERATION=$((ITERATION + 1))
.claude/hooks/auto-continue.sh:167:fi
.claude/hooks/auto-continue.sh:168:
.claude/hooks/auto-continue.sh:169:# Create/update state file
.claude/hooks/auto-continue.sh:170:mkdir -p .claude
.claude/hooks/auto-continue.sh:171:cat > "$STATE_FILE" <<EOF
.claude/hooks/auto-continue.sh:172:---
.claude/hooks/auto-continue.sh:173:active: true
.claude/hooks/auto-continue.sh:174:iteration: $ITERATION
.claude/hooks/auto-continue.sh:175:threshold: $THRESHOLD
.claude/hooks/auto-continue.sh:176:last_percent: $PERCENT
.claude/hooks/auto-continue.sh:177:last_compact: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
.claude/hooks/auto-continue.sh:178:build_active: $(if [[ -n "$BUILD_CONTEXT" ]]; then echo "true"; else echo "false"; fi)
.claude/hooks/auto-continue.sh:179:---
.claude/hooks/auto-continue.sh:180:
.claude/hooks/auto-continue.sh:181:Auto-continue active. Iteration ${ITERATION}.
.claude/hooks/auto-continue.sh:182:EOF
.claude/hooks/auto-continue.sh:183:
.claude/hooks/auto-continue.sh:184:# Output JSON to block stop and feed continuation prompt
.claude/hooks/auto-continue.sh:185:jq -n \
.claude/hooks/auto-continue.sh:186:    --arg prompt "$CONTINUATION_PROMPT" \
.claude/hooks/auto-continue.sh:187:    --arg msg " Auto-continue: Context ${PERCENT}%  compacted (iteration ${ITERATION})${BUILD_CONTEXT:+ | Build: $BUILD_FEATURE}" \
.claude/hooks/auto-continue.sh:188:    '{
.claude/hooks/auto-continue.sh:189:        "decision": "block",
.claude/hooks/auto-continue.sh:190:        "reason": $prompt,
.claude/hooks/auto-continue.sh:191:        "systemMessage": $msg
.claude/hooks/auto-continue.sh:192:    }'
.claude/hooks/auto-continue.sh:193:
.claude/hooks/auto-continue.sh:194:log "Auto-continue triggered - iteration $ITERATION"
.claude/hooks/auto-continue.sh:195:exit 0
.claude/hooks/.claude/file-changes.json:1:{
.claude/hooks/.claude/file-changes.json:2:  "session_start": "2026-01-12T17:40:18Z",
.claude/hooks/.claude/file-changes.json:3:  "last_checkpoint": "2026-01-12T18:01:40Z",
.claude/hooks/.claude/file-changes.json:4:  "files_changed": [
.claude/hooks/.claude/file-changes.json:5:    {
.claude/hooks/.claude/file-changes.json:6:      "file": "/Users/imorgado/.claude/docs/GREP-MCP-AUTOMATION-COMPLETE.md",
.claude/hooks/.claude/file-changes.json:7:      "type": "modified",
.claude/hooks/.claude/file-changes.json:8:      "timestamp": "2026-01-12T18:03:12Z"
.claude/hooks/.claude/file-changes.json:9:    },
.claude/hooks/.claude/file-changes.json:10:    {
.claude/hooks/.claude/file-changes.json:11:      "file": "/Users/imorgado/.claude/commands/auto.md",
.claude/hooks/.claude/file-changes.json:12:      "type": "modified",
.claude/hooks/.claude/file-changes.json:13:      "timestamp": "2026-01-12T18:10:58Z"
.claude/hooks/.claude/file-changes.json:14:    }
.claude/hooks/.claude/file-changes.json:15:  ],
.claude/hooks/.claude/file-changes.json:16:  "change_count": 2,
.claude/hooks/.claude/file-changes.json:17:  "checkpoint_count": 1
.claude/hooks/.claude/file-changes.json:18:}
.claude/hooks/task-queue.sh:1:#!/bin/bash
.claude/hooks/task-queue.sh:2:# Task Queue System - Priority-based task management
.claude/hooks/task-queue.sh:3:# Based on patterns from: DataDog browser-sdk, claude-flow orchestrator, piscina
.claude/hooks/task-queue.sh:4:
.claude/hooks/task-queue.sh:5:set -uo pipefail
.claude/hooks/task-queue.sh:6:
.claude/hooks/task-queue.sh:7:QUEUE_DIR="${HOME}/.claude/queue"
.claude/hooks/task-queue.sh:8:QUEUE_FILE="$QUEUE_DIR/tasks.json"
.claude/hooks/task-queue.sh:9:LOG_FILE="${HOME}/.claude/task-queue.log"
.claude/hooks/task-queue.sh:10:
.claude/hooks/task-queue.sh:11:log() {
.claude/hooks/task-queue.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/task-queue.sh:13:}
.claude/hooks/task-queue.sh:14:
.claude/hooks/task-queue.sh:15:init_queue() {
.claude/hooks/task-queue.sh:16:    mkdir -p "$QUEUE_DIR"
.claude/hooks/task-queue.sh:17:    if [[ ! -f "$QUEUE_FILE" ]]; then
.claude/hooks/task-queue.sh:18:        echo '{"tasks":[],"completed":[],"failed":[]}' > "$QUEUE_FILE"
.claude/hooks/task-queue.sh:19:    fi
.claude/hooks/task-queue.sh:20:}
.claude/hooks/task-queue.sh:21:
.claude/hooks/task-queue.sh:22:# =============================================================================
.claude/hooks/task-queue.sh:23:# TASK MANAGEMENT (from DataDog/piscina patterns)
.claude/hooks/task-queue.sh:24:# =============================================================================
.claude/hooks/task-queue.sh:25:
.claude/hooks/task-queue.sh:26:# Add task to queue with priority
.claude/hooks/task-queue.sh:27:# Priority: 1 (highest) to 5 (lowest)
.claude/hooks/task-queue.sh:28:add_task() {
.claude/hooks/task-queue.sh:29:    local name="$1"
.claude/hooks/task-queue.sh:30:    local priority="${2:-3}"
.claude/hooks/task-queue.sh:31:    local context="${3:-}"
.claude/hooks/task-queue.sh:32:    local depends_on="${4:-}"
.claude/hooks/task-queue.sh:33:
.claude/hooks/task-queue.sh:34:    init_queue
.claude/hooks/task-queue.sh:35:
.claude/hooks/task-queue.sh:36:    local task_id
.claude/hooks/task-queue.sh:37:    task_id="task_$(date +%s)_$$"
.claude/hooks/task-queue.sh:38:
.claude/hooks/task-queue.sh:39:    local timestamp
.claude/hooks/task-queue.sh:40:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/task-queue.sh:41:
.claude/hooks/task-queue.sh:42:    local temp_file
.claude/hooks/task-queue.sh:43:    temp_file=$(mktemp)
.claude/hooks/task-queue.sh:44:
.claude/hooks/task-queue.sh:45:    jq --arg id "$task_id" \
.claude/hooks/task-queue.sh:46:       --arg name "$name" \
.claude/hooks/task-queue.sh:47:       --argjson priority "$priority" \
.claude/hooks/task-queue.sh:48:       --arg context "$context" \
.claude/hooks/task-queue.sh:49:       --arg depends "$depends_on" \
.claude/hooks/task-queue.sh:50:       --arg ts "$timestamp" \
.claude/hooks/task-queue.sh:51:       '.tasks += [{
.claude/hooks/task-queue.sh:52:           id: $id,
.claude/hooks/task-queue.sh:53:           name: $name,
.claude/hooks/task-queue.sh:54:           priority: $priority,
.claude/hooks/task-queue.sh:55:           context: $context,
.claude/hooks/task-queue.sh:56:           dependsOn: $depends,
.claude/hooks/task-queue.sh:57:           status: "pending",
.claude/hooks/task-queue.sh:58:           createdAt: $ts,
.claude/hooks/task-queue.sh:59:           attempts: 0
.claude/hooks/task-queue.sh:60:       }]' "$QUEUE_FILE" > "$temp_file"
.claude/hooks/task-queue.sh:61:
.claude/hooks/task-queue.sh:62:    mv "$temp_file" "$QUEUE_FILE"
.claude/hooks/task-queue.sh:63:
.claude/hooks/task-queue.sh:64:    log "Added task: $name (id: $task_id, priority: $priority)"
.claude/hooks/task-queue.sh:65:    echo "$task_id"
.claude/hooks/task-queue.sh:66:}
.claude/hooks/task-queue.sh:67:
.claude/hooks/task-queue.sh:68:# Get next task by priority (lower number = higher priority)
.claude/hooks/task-queue.sh:69:get_next_task() {
.claude/hooks/task-queue.sh:70:    init_queue
.claude/hooks/task-queue.sh:71:
.claude/hooks/task-queue.sh:72:    # Get highest priority pending task with no unmet dependencies
.claude/hooks/task-queue.sh:73:    local next_task
.claude/hooks/task-queue.sh:74:    next_task=$(jq -r '
.claude/hooks/task-queue.sh:75:        .tasks
.claude/hooks/task-queue.sh:76:        | map(select(.status == "pending"))
.claude/hooks/task-queue.sh:77:        | map(select(
.claude/hooks/task-queue.sh:78:            .dependsOn == "" or
.claude/hooks/task-queue.sh:79:            .dependsOn == null or
.claude/hooks/task-queue.sh:80:            (.dependsOn as $dep |
.claude/hooks/task-queue.sh:81:                (input_filename | . as $f |
.claude/hooks/task-queue.sh:82:                    ($f | .completed | map(.name) | index($dep)) != null
.claude/hooks/task-queue.sh:83:                )
.claude/hooks/task-queue.sh:84:            )
.claude/hooks/task-queue.sh:85:        ))
.claude/hooks/task-queue.sh:86:        | sort_by(.priority, .createdAt)
.claude/hooks/task-queue.sh:87:        | first
.claude/hooks/task-queue.sh:88:        | .id // empty
.claude/hooks/task-queue.sh:89:    ' "$QUEUE_FILE" 2>/dev/null || echo "")
.claude/hooks/task-queue.sh:90:
.claude/hooks/task-queue.sh:91:    # Simpler fallback - just get highest priority pending
.claude/hooks/task-queue.sh:92:    if [[ -z "$next_task" ]]; then
.claude/hooks/task-queue.sh:93:        next_task=$(jq -r '
.claude/hooks/task-queue.sh:94:            .tasks
.claude/hooks/task-queue.sh:95:            | map(select(.status == "pending"))
.claude/hooks/task-queue.sh:96:            | sort_by(.priority, .createdAt)
.claude/hooks/task-queue.sh:97:            | first
.claude/hooks/task-queue.sh:98:            | .id // empty
.claude/hooks/task-queue.sh:99:        ' "$QUEUE_FILE")
.claude/hooks/task-queue.sh:100:    fi
.claude/hooks/task-queue.sh:101:
.claude/hooks/task-queue.sh:102:    echo "$next_task"
.claude/hooks/task-queue.sh:103:}
.claude/hooks/task-queue.sh:104:
.claude/hooks/task-queue.sh:105:# Start a task (mark as in_progress)
.claude/hooks/task-queue.sh:106:start_task() {
.claude/hooks/task-queue.sh:107:    local task_id="$1"
.claude/hooks/task-queue.sh:108:
.claude/hooks/task-queue.sh:109:    init_queue
.claude/hooks/task-queue.sh:110:
.claude/hooks/task-queue.sh:111:    local temp_file
.claude/hooks/task-queue.sh:112:    temp_file=$(mktemp)
.claude/hooks/task-queue.sh:113:
.claude/hooks/task-queue.sh:114:    local timestamp
.claude/hooks/task-queue.sh:115:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/task-queue.sh:116:
.claude/hooks/task-queue.sh:117:    jq --arg id "$task_id" \
.claude/hooks/task-queue.sh:118:       --arg ts "$timestamp" \
.claude/hooks/task-queue.sh:119:       '.tasks = [.tasks[] | if .id == $id then
.claude/hooks/task-queue.sh:120:           .status = "in_progress" | .startedAt = $ts | .attempts += 1
.claude/hooks/task-queue.sh:121:       else . end]' "$QUEUE_FILE" > "$temp_file"
.claude/hooks/task-queue.sh:122:
.claude/hooks/task-queue.sh:123:    mv "$temp_file" "$QUEUE_FILE"
.claude/hooks/task-queue.sh:124:
.claude/hooks/task-queue.sh:125:    log "Started task: $task_id"
.claude/hooks/task-queue.sh:126:}
.claude/hooks/task-queue.sh:127:
.claude/hooks/task-queue.sh:128:# Complete a task
.claude/hooks/task-queue.sh:129:complete_task() {
.claude/hooks/task-queue.sh:130:    local task_id="$1"
.claude/hooks/task-queue.sh:131:    local result="${2:-success}"
.claude/hooks/task-queue.sh:132:
.claude/hooks/task-queue.sh:133:    init_queue
.claude/hooks/task-queue.sh:134:
.claude/hooks/task-queue.sh:135:    local temp_file
.claude/hooks/task-queue.sh:136:    temp_file=$(mktemp)
.claude/hooks/task-queue.sh:137:
.claude/hooks/task-queue.sh:138:    local timestamp
.claude/hooks/task-queue.sh:139:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/task-queue.sh:140:
.claude/hooks/task-queue.sh:141:    # Move to completed array
.claude/hooks/task-queue.sh:142:    jq --arg id "$task_id" \
.claude/hooks/task-queue.sh:143:       --arg ts "$timestamp" \
.claude/hooks/task-queue.sh:144:       --arg result "$result" \
.claude/hooks/task-queue.sh:145:       '
.claude/hooks/task-queue.sh:146:       (.tasks | map(select(.id == $id)) | first) as $task |
.claude/hooks/task-queue.sh:147:       if $task then
.claude/hooks/task-queue.sh:148:           .completed += [$task + {completedAt: $ts, result: $result, status: "completed"}] |
.claude/hooks/task-queue.sh:149:           .tasks = [.tasks[] | select(.id != $id)]
.claude/hooks/task-queue.sh:150:       else . end
.claude/hooks/task-queue.sh:151:       ' "$QUEUE_FILE" > "$temp_file"
.claude/hooks/task-queue.sh:152:
.claude/hooks/task-queue.sh:153:    mv "$temp_file" "$QUEUE_FILE"
.claude/hooks/task-queue.sh:154:
.claude/hooks/task-queue.sh:155:    log "Completed task: $task_id (result: $result)"
.claude/hooks/task-queue.sh:156:}
.claude/hooks/task-queue.sh:157:
.claude/hooks/task-queue.sh:158:# Fail a task
.claude/hooks/task-queue.sh:159:fail_task() {
.claude/hooks/task-queue.sh:160:    local task_id="$1"
.claude/hooks/task-queue.sh:161:    local error="${2:-unknown}"
.claude/hooks/task-queue.sh:162:    local max_retries="${3:-3}"
.claude/hooks/task-queue.sh:163:
.claude/hooks/task-queue.sh:164:    init_queue
.claude/hooks/task-queue.sh:165:
.claude/hooks/task-queue.sh:166:    local temp_file
.claude/hooks/task-queue.sh:167:    temp_file=$(mktemp)
.claude/hooks/task-queue.sh:168:
.claude/hooks/task-queue.sh:169:    local timestamp
.claude/hooks/task-queue.sh:170:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/task-queue.sh:171:
.claude/hooks/task-queue.sh:172:    # Check attempts and either retry or move to failed
.claude/hooks/task-queue.sh:173:    local attempts
.claude/hooks/task-queue.sh:174:    attempts=$(jq -r --arg id "$task_id" '.tasks[] | select(.id == $id) | .attempts' "$QUEUE_FILE")
.claude/hooks/task-queue.sh:175:    attempts=$((attempts + 0))
.claude/hooks/task-queue.sh:176:
.claude/hooks/task-queue.sh:177:    if [[ $attempts -lt $max_retries ]]; then
.claude/hooks/task-queue.sh:178:        # Reset to pending for retry
.claude/hooks/task-queue.sh:179:        jq --arg id "$task_id" \
.claude/hooks/task-queue.sh:180:           --arg ts "$timestamp" \
.claude/hooks/task-queue.sh:181:           --arg err "$error" \
.claude/hooks/task-queue.sh:182:           '.tasks = [.tasks[] | if .id == $id then
.claude/hooks/task-queue.sh:183:               .status = "pending" | .lastError = $err | .lastFailedAt = $ts
.claude/hooks/task-queue.sh:184:           else . end]' "$QUEUE_FILE" > "$temp_file"
.claude/hooks/task-queue.sh:185:
.claude/hooks/task-queue.sh:186:        log "Task $task_id failed (attempt $attempts/$max_retries), will retry"
.claude/hooks/task-queue.sh:187:    else
.claude/hooks/task-queue.sh:188:        # Move to failed array
.claude/hooks/task-queue.sh:189:        jq --arg id "$task_id" \
.claude/hooks/task-queue.sh:190:           --arg ts "$timestamp" \
.claude/hooks/task-queue.sh:191:           --arg err "$error" \
.claude/hooks/task-queue.sh:192:           '
.claude/hooks/task-queue.sh:193:           (.tasks | map(select(.id == $id)) | first) as $task |
.claude/hooks/task-queue.sh:194:           if $task then
.claude/hooks/task-queue.sh:195:               .failed += [$task + {failedAt: $ts, error: $err, status: "failed"}] |
.claude/hooks/task-queue.sh:196:               .tasks = [.tasks[] | select(.id != $id)]
.claude/hooks/task-queue.sh:197:           else . end
.claude/hooks/task-queue.sh:198:           ' "$QUEUE_FILE" > "$temp_file"
.claude/hooks/task-queue.sh:199:
.claude/hooks/task-queue.sh:200:        log "Task $task_id permanently failed after $attempts attempts"
.claude/hooks/task-queue.sh:201:    fi
.claude/hooks/task-queue.sh:202:
.claude/hooks/task-queue.sh:203:    mv "$temp_file" "$QUEUE_FILE"
.claude/hooks/task-queue.sh:204:}
.claude/hooks/task-queue.sh:205:
.claude/hooks/task-queue.sh:206:# Get task info
.claude/hooks/task-queue.sh:207:get_task() {
.claude/hooks/task-queue.sh:208:    local task_id="$1"
.claude/hooks/task-queue.sh:209:
.claude/hooks/task-queue.sh:210:    init_queue
.claude/hooks/task-queue.sh:211:
.claude/hooks/task-queue.sh:212:    jq --arg id "$task_id" '
.claude/hooks/task-queue.sh:213:        (.tasks[] | select(.id == $id)) //
.claude/hooks/task-queue.sh:214:        (.completed[] | select(.id == $id)) //
.claude/hooks/task-queue.sh:215:        (.failed[] | select(.id == $id)) //
.claude/hooks/task-queue.sh:216:        null
.claude/hooks/task-queue.sh:217:    ' "$QUEUE_FILE"
.claude/hooks/task-queue.sh:218:}
.claude/hooks/task-queue.sh:219:
.claude/hooks/task-queue.sh:220:# Get queue status
.claude/hooks/task-queue.sh:221:get_status() {
.claude/hooks/task-queue.sh:222:    init_queue
.claude/hooks/task-queue.sh:223:
.claude/hooks/task-queue.sh:224:    jq '{
.claude/hooks/task-queue.sh:225:        pending: [.tasks[] | select(.status == "pending")] | length,
.claude/hooks/task-queue.sh:226:        in_progress: [.tasks[] | select(.status == "in_progress")] | length,
.claude/hooks/task-queue.sh:227:        completed: .completed | length,
.claude/hooks/task-queue.sh:228:        failed: .failed | length,
.claude/hooks/task-queue.sh:229:        total: (.tasks | length) + (.completed | length) + (.failed | length)
.claude/hooks/task-queue.sh:230:    }' "$QUEUE_FILE"
.claude/hooks/task-queue.sh:231:}
.claude/hooks/task-queue.sh:232:
.claude/hooks/task-queue.sh:233:# Clear completed/failed tasks
.claude/hooks/task-queue.sh:234:clear_history() {
.claude/hooks/task-queue.sh:235:    init_queue
.claude/hooks/task-queue.sh:236:
.claude/hooks/task-queue.sh:237:    local temp_file
.claude/hooks/task-queue.sh:238:    temp_file=$(mktemp)
.claude/hooks/task-queue.sh:239:
.claude/hooks/task-queue.sh:240:    jq '.completed = [] | .failed = []' "$QUEUE_FILE" > "$temp_file"
.claude/hooks/task-queue.sh:241:    mv "$temp_file" "$QUEUE_FILE"
.claude/hooks/task-queue.sh:242:
.claude/hooks/task-queue.sh:243:    log "Cleared task history"
.claude/hooks/task-queue.sh:244:}
.claude/hooks/task-queue.sh:245:
.claude/hooks/task-queue.sh:246:# List all tasks
.claude/hooks/task-queue.sh:247:list_tasks() {
.claude/hooks/task-queue.sh:248:    local filter="${1:-all}"
.claude/hooks/task-queue.sh:249:
.claude/hooks/task-queue.sh:250:    init_queue
.claude/hooks/task-queue.sh:251:
.claude/hooks/task-queue.sh:252:    case "$filter" in
.claude/hooks/task-queue.sh:253:        pending)
.claude/hooks/task-queue.sh:254:            jq '.tasks | map(select(.status == "pending"))' "$QUEUE_FILE"
.claude/hooks/task-queue.sh:255:            ;;
.claude/hooks/task-queue.sh:256:        in_progress)
.claude/hooks/task-queue.sh:257:            jq '.tasks | map(select(.status == "in_progress"))' "$QUEUE_FILE"
.claude/hooks/task-queue.sh:258:            ;;
.claude/hooks/task-queue.sh:259:        completed)
.claude/hooks/task-queue.sh:260:            jq '.completed' "$QUEUE_FILE"
.claude/hooks/task-queue.sh:261:            ;;
.claude/hooks/task-queue.sh:262:        failed)
.claude/hooks/task-queue.sh:263:            jq '.failed' "$QUEUE_FILE"
.claude/hooks/task-queue.sh:264:            ;;
.claude/hooks/task-queue.sh:265:        all|*)
.claude/hooks/task-queue.sh:266:            jq '.' "$QUEUE_FILE"
.claude/hooks/task-queue.sh:267:            ;;
.claude/hooks/task-queue.sh:268:    esac
.claude/hooks/task-queue.sh:269:}
.claude/hooks/task-queue.sh:270:
.claude/hooks/task-queue.sh:271:# =============================================================================
.claude/hooks/task-queue.sh:272:# COMMAND INTERFACE
.claude/hooks/task-queue.sh:273:# =============================================================================
.claude/hooks/task-queue.sh:274:
.claude/hooks/task-queue.sh:275:case "${1:-help}" in
.claude/hooks/task-queue.sh:276:    add)
.claude/hooks/task-queue.sh:277:        add_task "${2:-unnamed}" "${3:-3}" "${4:-}" "${5:-}"
.claude/hooks/task-queue.sh:278:        ;;
.claude/hooks/task-queue.sh:279:    next)
.claude/hooks/task-queue.sh:280:        get_next_task
.claude/hooks/task-queue.sh:281:        ;;
.claude/hooks/task-queue.sh:282:    start)
.claude/hooks/task-queue.sh:283:        start_task "${2:-}"
.claude/hooks/task-queue.sh:284:        ;;
.claude/hooks/task-queue.sh:285:    complete)
.claude/hooks/task-queue.sh:286:        complete_task "${2:-}" "${3:-success}"
.claude/hooks/task-queue.sh:287:        ;;
.claude/hooks/task-queue.sh:288:    fail)
.claude/hooks/task-queue.sh:289:        fail_task "${2:-}" "${3:-unknown}" "${4:-3}"
.claude/hooks/task-queue.sh:290:        ;;
.claude/hooks/task-queue.sh:291:    get)
.claude/hooks/task-queue.sh:292:        get_task "${2:-}"
.claude/hooks/task-queue.sh:293:        ;;
.claude/hooks/task-queue.sh:294:    status)
.claude/hooks/task-queue.sh:295:        get_status
.claude/hooks/task-queue.sh:296:        ;;
.claude/hooks/task-queue.sh:297:    list)
.claude/hooks/task-queue.sh:298:        list_tasks "${2:-all}"
.claude/hooks/task-queue.sh:299:        ;;
.claude/hooks/task-queue.sh:300:    clear)
.claude/hooks/task-queue.sh:301:        clear_history
.claude/hooks/task-queue.sh:302:        ;;
.claude/hooks/task-queue.sh:303:    help|*)
.claude/hooks/task-queue.sh:304:        echo "Task Queue System"
.claude/hooks/task-queue.sh:305:        echo ""
.claude/hooks/task-queue.sh:306:        echo "Usage: $0 <command> [args]"
.claude/hooks/task-queue.sh:307:        echo ""
.claude/hooks/task-queue.sh:308:        echo "Commands:"
.claude/hooks/task-queue.sh:309:        echo "  add <name> [priority] [context] [depends_on]  - Add task (priority 1-5)"
.claude/hooks/task-queue.sh:310:        echo "  next                                          - Get next task ID"
.claude/hooks/task-queue.sh:311:        echo "  start <task_id>                               - Mark task as started"
.claude/hooks/task-queue.sh:312:        echo "  complete <task_id> [result]                   - Mark task as complete"
.claude/hooks/task-queue.sh:313:        echo "  fail <task_id> [error] [max_retries]          - Mark task as failed"
.claude/hooks/task-queue.sh:314:        echo "  get <task_id>                                 - Get task details"
.claude/hooks/task-queue.sh:315:        echo "  status                                        - Get queue status"
.claude/hooks/task-queue.sh:316:        echo "  list [pending|in_progress|completed|failed]   - List tasks"
.claude/hooks/task-queue.sh:317:        echo "  clear                                         - Clear history"
.claude/hooks/task-queue.sh:318:        ;;
.claude/hooks/task-queue.sh:319:esac
.claude/hooks/coordinator.sh:1:#!/bin/bash
.claude/hooks/coordinator.sh:2:# Central Coordinator - Orchestrates all autonomous systems
.claude/hooks/coordinator.sh:3:# The intelligence layer that connects everything
.claude/hooks/coordinator.sh:4:
.claude/hooks/coordinator.sh:5:set -uo pipefail
.claude/hooks/coordinator.sh:6:
.claude/hooks/coordinator.sh:7:COORD_DIR="${HOME}/.claude/coordination"
.claude/hooks/coordinator.sh:8:COORD_STATE="$COORD_DIR/state.json"
.claude/hooks/coordinator.sh:9:EXECUTION_LOG="$COORD_DIR/execution.log"
.claude/hooks/coordinator.sh:10:LOG_FILE="${HOME}/.claude/coordinator.log"
.claude/hooks/coordinator.sh:11:
.claude/hooks/coordinator.sh:12:# All integrated hooks (Phase 1-3 - Existing)
.claude/hooks/coordinator.sh:13:ORCHESTRATOR="${HOME}/.claude/hooks/autonomous-orchestrator-v2.sh"
.claude/hooks/coordinator.sh:14:AGENT_LOOP="${HOME}/.claude/hooks/agent-loop.sh"
.claude/hooks/coordinator.sh:15:LEARNING_ENGINE="${HOME}/.claude/hooks/learning-engine.sh"
.claude/hooks/coordinator.sh:16:FEEDBACK_LOOP="${HOME}/.claude/hooks/feedback-loop.sh"
.claude/hooks/coordinator.sh:17:RISK_PREDICTOR="${HOME}/.claude/hooks/risk-predictor.sh"
.claude/hooks/coordinator.sh:18:PATTERN_MINER="${HOME}/.claude/hooks/pattern-miner.sh"
.claude/hooks/coordinator.sh:19:STRATEGY_SELECTOR="${HOME}/.claude/hooks/strategy-selector.sh"
.claude/hooks/coordinator.sh:20:META_REFLECTION="${HOME}/.claude/hooks/meta-reflection.sh"
.claude/hooks/coordinator.sh:21:HYPOTHESIS_TESTER="${HOME}/.claude/hooks/hypothesis-tester.sh"
.claude/hooks/coordinator.sh:22:CONTEXT_OPTIMIZER="${HOME}/.claude/hooks/context-optimizer.sh"
.claude/hooks/coordinator.sh:23:SELF_HEALING="${HOME}/.claude/hooks/self-healing.sh"
.claude/hooks/coordinator.sh:24:THINKING_FRAMEWORK="${HOME}/.claude/hooks/thinking-framework.sh"
.claude/hooks/coordinator.sh:25:MEMORY_MANAGER="${HOME}/.claude/hooks/memory-manager.sh"
.claude/hooks/coordinator.sh:26:ERROR_HANDLER="${HOME}/.claude/hooks/error-handler.sh"
.claude/hooks/coordinator.sh:27:PLAN_EXECUTE="${HOME}/.claude/hooks/plan-execute.sh"
.claude/hooks/coordinator.sh:28:TASK_QUEUE="${HOME}/.claude/hooks/task-queue.sh"
.claude/hooks/coordinator.sh:29:
.claude/hooks/coordinator.sh:30:# New integrated hooks (10 Advanced Features)
.claude/hooks/coordinator.sh:31:REASONING_MODE_SWITCHER="${HOME}/.claude/hooks/reasoning-mode-switcher.sh"
.claude/hooks/coordinator.sh:32:BOUNDED_AUTONOMY="${HOME}/.claude/hooks/bounded-autonomy.sh"
.claude/hooks/coordinator.sh:33:TREE_OF_THOUGHTS="${HOME}/.claude/hooks/tree-of-thoughts.sh"
.claude/hooks/coordinator.sh:34:MULTI_AGENT_ORCHESTRATOR="${HOME}/.claude/hooks/multi-agent-orchestrator.sh"
.claude/hooks/coordinator.sh:35:REACT_REFLEXION="${HOME}/.claude/hooks/react-reflexion.sh"
.claude/hooks/coordinator.sh:36:CONSTITUTIONAL_AI="${HOME}/.claude/hooks/constitutional-ai.sh"
.claude/hooks/coordinator.sh:37:AUTO_EVALUATOR="${HOME}/.claude/hooks/auto-evaluator.sh"
.claude/hooks/coordinator.sh:38:REINFORCEMENT_LEARNING="${HOME}/.claude/hooks/reinforcement-learning.sh"
.claude/hooks/coordinator.sh:39:ENHANCED_AUDIT_TRAIL="${HOME}/.claude/hooks/enhanced-audit-trail.sh"
.claude/hooks/coordinator.sh:40:PARALLEL_EXECUTION_PLANNER="${HOME}/.claude/hooks/parallel-execution-planner.sh"
.claude/hooks/coordinator.sh:41:
.claude/hooks/coordinator.sh:42:log() {
.claude/hooks/coordinator.sh:43:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/coordinator.sh:44:}
.claude/hooks/coordinator.sh:45:
.claude/hooks/coordinator.sh:46:init_coordinator() {
.claude/hooks/coordinator.sh:47:    mkdir -p "$COORD_DIR"
.claude/hooks/coordinator.sh:48:
.claude/hooks/coordinator.sh:49:    if [[ ! -f "$COORD_STATE" ]]; then
.claude/hooks/coordinator.sh:50:        cat > "$COORD_STATE" << 'EOF'
.claude/hooks/coordinator.sh:51:{
.claude/hooks/coordinator.sh:52:    "status": "idle",
.claude/hooks/coordinator.sh:53:    "currentTask": null,
.claude/hooks/coordinator.sh:54:    "initialized": false,
.claude/hooks/coordinator.sh:55:    "systems": {
.claude/hooks/coordinator.sh:56:        "learning": false,
.claude/hooks/coordinator.sh:57:        "memory": false,
.claude/hooks/coordinator.sh:58:        "agentLoop": false,
.claude/hooks/coordinator.sh:59:        "orchestrator": false
.claude/hooks/coordinator.sh:60:    }
.claude/hooks/coordinator.sh:61:}
.claude/hooks/coordinator.sh:62:EOF
.claude/hooks/coordinator.sh:63:    fi
.claude/hooks/coordinator.sh:64:
.claude/hooks/coordinator.sh:65:    # Initialize all systems
.claude/hooks/coordinator.sh:66:    [[ -x "$LEARNING_ENGINE" ]] && "$LEARNING_ENGINE" init > /dev/null 2>&1 && update_system_status "learning" true
.claude/hooks/coordinator.sh:67:    [[ -x "$MEMORY_MANAGER" ]] && "$MEMORY_MANAGER" init > /dev/null 2>&1 && update_system_status "memory" true
.claude/hooks/coordinator.sh:68:
.claude/hooks/coordinator.sh:69:    update_coordinator_status "initialized" true
.claude/hooks/coordinator.sh:70:    log "Coordinator initialized"
.claude/hooks/coordinator.sh:71:}
.claude/hooks/coordinator.sh:72:
.claude/hooks/coordinator.sh:73:update_system_status() {
.claude/hooks/coordinator.sh:74:    local system="$1"
.claude/hooks/coordinator.sh:75:    local status="$2"
.claude/hooks/coordinator.sh:76:
.claude/hooks/coordinator.sh:77:    local temp_file
.claude/hooks/coordinator.sh:78:    temp_file=$(mktemp)
.claude/hooks/coordinator.sh:79:
.claude/hooks/coordinator.sh:80:    jq --arg system "$system" --argjson status "$status" \
.claude/hooks/coordinator.sh:81:        '.systems[$system] = $status' "$COORD_STATE" > "$temp_file"
.claude/hooks/coordinator.sh:82:    mv "$temp_file" "$COORD_STATE"
.claude/hooks/coordinator.sh:83:}
.claude/hooks/coordinator.sh:84:
.claude/hooks/coordinator.sh:85:update_coordinator_status() {
.claude/hooks/coordinator.sh:86:    local key="$1"
.claude/hooks/coordinator.sh:87:    local value="$2"
.claude/hooks/coordinator.sh:88:
.claude/hooks/coordinator.sh:89:    local temp_file
.claude/hooks/coordinator.sh:90:    temp_file=$(mktemp)
.claude/hooks/coordinator.sh:91:
.claude/hooks/coordinator.sh:92:    jq --arg key "$key" --arg value "$value" \
.claude/hooks/coordinator.sh:93:        '.[$key] = $value' "$COORD_STATE" > "$temp_file"
.claude/hooks/coordinator.sh:94:    mv "$temp_file" "$COORD_STATE"
.claude/hooks/coordinator.sh:95:}
.claude/hooks/coordinator.sh:96:
.claude/hooks/coordinator.sh:97:# =============================================================================
.claude/hooks/coordinator.sh:98:# TASK COORDINATION (MAIN ENTRY POINT)
.claude/hooks/coordinator.sh:99:# =============================================================================
.claude/hooks/coordinator.sh:100:
.claude/hooks/coordinator.sh:101:coordinate_task() {
.claude/hooks/coordinator.sh:102:    local task="$1"
.claude/hooks/coordinator.sh:103:    local task_type="${2:-general}"
.claude/hooks/coordinator.sh:104:    local context="${3:-}"
.claude/hooks/coordinator.sh:105:
.claude/hooks/coordinator.sh:106:    init_coordinator
.claude/hooks/coordinator.sh:107:    log "Coordinating task: $task (type: $task_type)"
.claude/hooks/coordinator.sh:108:
.claude/hooks/coordinator.sh:109:    local start_time
.claude/hooks/coordinator.sh:110:    start_time=$(date +%s)
.claude/hooks/coordinator.sh:111:
.claude/hooks/coordinator.sh:112:    # Phase 1: PRE-EXECUTION INTELLIGENCE
.claude/hooks/coordinator.sh:113:    log "Phase 1: Pre-execution analysis"
.claude/hooks/coordinator.sh:114:
.claude/hooks/coordinator.sh:115:    # 1.0: Select reasoning mode (reflexive/deliberate/reactive)
.claude/hooks/coordinator.sh:116:    local reasoning_mode="deliberate"
.claude/hooks/coordinator.sh:117:    local mode_info=""
.claude/hooks/coordinator.sh:118:    if [[ -x "$REASONING_MODE_SWITCHER" ]]; then
.claude/hooks/coordinator.sh:119:        # Assess task characteristics for mode selection
.claude/hooks/coordinator.sh:120:        local complexity="normal"
.claude/hooks/coordinator.sh:121:        local urgency="normal"
.claude/hooks/coordinator.sh:122:
.claude/hooks/coordinator.sh:123:        # Simple heuristics for now
.claude/hooks/coordinator.sh:124:        [[ "$task" =~ (fix|bug|error|urgent) ]] && urgency="critical"
.claude/hooks/coordinator.sh:125:        [[ "$task" =~ (implement|architecture|design|complex) ]] && complexity="high"
.claude/hooks/coordinator.sh:126:        [[ "$task" =~ (typo|comment|simple|quick) ]] && complexity="low"
.claude/hooks/coordinator.sh:127:
.claude/hooks/coordinator.sh:128:        local risk_for_mode="low"
.claude/hooks/coordinator.sh:129:        [[ "$task" =~ (security|auth|payment|data|production) ]] && risk_for_mode="high"
.claude/hooks/coordinator.sh:130:
.claude/hooks/coordinator.sh:131:        mode_info=$("$REASONING_MODE_SWITCHER" select "$task" "$context" "$urgency" "$complexity" "$risk_for_mode" 2>/dev/null || echo '{"selected_mode":"deliberate"}')
.claude/hooks/coordinator.sh:132:        reasoning_mode=$(echo "$mode_info" | jq -r '.selected_mode // "deliberate"')
.claude/hooks/coordinator.sh:133:        log "Selected reasoning mode: $reasoning_mode (complexity: $complexity, risk: $risk_for_mode, urgency: $urgency)"
.claude/hooks/coordinator.sh:134:
.claude/hooks/coordinator.sh:135:        # Log decision to audit trail
.claude/hooks/coordinator.sh:136:        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
.claude/hooks/coordinator.sh:137:            "$ENHANCED_AUDIT_TRAIL" log "select_reasoning_mode" \
.claude/hooks/coordinator.sh:138:                "Task characteristics suggest $reasoning_mode mode" \
.claude/hooks/coordinator.sh:139:                "reflexive,deliberate,reactive" \
.claude/hooks/coordinator.sh:140:                "$reasoning_mode balances thoroughness with efficiency for this task" \
.claude/hooks/coordinator.sh:141:                "0.85" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:142:        fi
.claude/hooks/coordinator.sh:143:    fi
.claude/hooks/coordinator.sh:144:
.claude/hooks/coordinator.sh:145:    # 1.1: State hypothesis
.claude/hooks/coordinator.sh:146:    local hypothesis_id=""
.claude/hooks/coordinator.sh:147:    if [[ -x "$HYPOTHESIS_TESTER" ]]; then
.claude/hooks/coordinator.sh:148:        local hypothesis="Task '$task' will succeed using recommended strategy"
.claude/hooks/coordinator.sh:149:        hypothesis_id=$("$HYPOTHESIS_TESTER" state "$hypothesis" "success" "$task" 2>/dev/null | jq -r '.id' || echo "")
.claude/hooks/coordinator.sh:150:        log "Stated hypothesis: $hypothesis_id"
.claude/hooks/coordinator.sh:151:    fi
.claude/hooks/coordinator.sh:152:
.claude/hooks/coordinator.sh:153:    # 1.2: Get strategy recommendation
.claude/hooks/coordinator.sh:154:    local strategy="default"
.claude/hooks/coordinator.sh:155:    local strategy_confidence=0
.claude/hooks/coordinator.sh:156:    if [[ -x "$STRATEGY_SELECTOR" ]]; then
.claude/hooks/coordinator.sh:157:        local strategy_result
.claude/hooks/coordinator.sh:158:        strategy_result=$("$STRATEGY_SELECTOR" select "$task" "$task_type" "$context" 2>/dev/null || echo '{"strategy":"default","confidence":0}')
.claude/hooks/coordinator.sh:159:        strategy=$(echo "$strategy_result" | jq -r '.strategy')
.claude/hooks/coordinator.sh:160:        strategy_confidence=$(echo "$strategy_result" | jq -r '.confidence')
.claude/hooks/coordinator.sh:161:        log "Selected strategy: $strategy (confidence: $strategy_confidence)"
.claude/hooks/coordinator.sh:162:    fi
.claude/hooks/coordinator.sh:163:
.claude/hooks/coordinator.sh:164:    # 1.3: Assess risk
.claude/hooks/coordinator.sh:165:    local risk_level="low"
.claude/hooks/coordinator.sh:166:    local risk_score=10
.claude/hooks/coordinator.sh:167:    if [[ -x "$RISK_PREDICTOR" ]]; then
.claude/hooks/coordinator.sh:168:        local risk_result
.claude/hooks/coordinator.sh:169:        risk_result=$("$RISK_PREDICTOR" assess "$task" "$task_type" "" "$context" 2>/dev/null || echo '{"riskLevel":"low","totalRisk":10}')
.claude/hooks/coordinator.sh:170:        risk_level=$(echo "$risk_result" | jq -r '.riskLevel')
.claude/hooks/coordinator.sh:171:        risk_score=$(echo "$risk_result" | jq -r '.totalRisk')
.claude/hooks/coordinator.sh:172:        log "Risk assessment: $risk_level ($risk_score/100)"
.claude/hooks/coordinator.sh:173:    fi
.claude/hooks/coordinator.sh:174:
.claude/hooks/coordinator.sh:175:    # 1.4: Mine relevant patterns
.claude/hooks/coordinator.sh:176:    local patterns="[]"
.claude/hooks/coordinator.sh:177:    if [[ -x "$PATTERN_MINER" ]]; then
.claude/hooks/coordinator.sh:178:        patterns=$("$PATTERN_MINER" mine "$task_type" 2>/dev/null || echo '[]')
.claude/hooks/coordinator.sh:179:        local pattern_count
.claude/hooks/coordinator.sh:180:        pattern_count=$(echo "$patterns" | jq 'length')
.claude/hooks/coordinator.sh:181:        log "Found $pattern_count relevant patterns"
.claude/hooks/coordinator.sh:182:    fi
.claude/hooks/coordinator.sh:183:
.claude/hooks/coordinator.sh:184:    # 1.4a: AUTO-RESEARCH: Check for unfamiliar libraries and execute GitHub search
.claude/hooks/coordinator.sh:185:    local github_search_results="[]"
.claude/hooks/coordinator.sh:186:    if [[ -x "$ORCHESTRATOR" ]]; then
.claude/hooks/coordinator.sh:187:        local task_analysis
.claude/hooks/coordinator.sh:188:        task_analysis=$("$ORCHESTRATOR" analyze "$task" 2>/dev/null || echo '{}')
.claude/hooks/coordinator.sh:189:
.claude/hooks/coordinator.sh:190:        local needs_research=$(echo "$task_analysis" | jq -r '.research.needsResearch // false')
.claude/hooks/coordinator.sh:191:        if [[ "$needs_research" == "true" ]]; then
.claude/hooks/coordinator.sh:192:            local library=$(echo "$task_analysis" | jq -r '.research.library')
.claude/hooks/coordinator.sh:193:            local search_instruction=$(echo "$task_analysis" | jq -r '.githubSearch.instruction')
.claude/hooks/coordinator.sh:194:
.claude/hooks/coordinator.sh:195:            log " Auto-research triggered for library: $library"
.claude/hooks/coordinator.sh:196:            log " Recommendation: $search_instruction"
.claude/hooks/coordinator.sh:197:
.claude/hooks/coordinator.sh:198:            # Note: The GitHub search will be executed by Claude in autonomous mode
.claude/hooks/coordinator.sh:199:            # The search parameters are provided in task_analysis.githubSearch
.claude/hooks/coordinator.sh:200:            # This allows Claude to invoke mcp__grep__searchGitHub with the prepared query
.claude/hooks/coordinator.sh:201:            github_search_results=$(echo "$task_analysis" | jq -c '.githubSearch')
.claude/hooks/coordinator.sh:202:        fi
.claude/hooks/coordinator.sh:203:    fi
.claude/hooks/coordinator.sh:204:
.claude/hooks/coordinator.sh:205:    # 1.4b: Reasoning mode execution strategy
.claude/hooks/coordinator.sh:206:    local tot_result=""
.claude/hooks/coordinator.sh:207:    local selected_approach=""
.claude/hooks/coordinator.sh:208:
.claude/hooks/coordinator.sh:209:    if [[ "$reasoning_mode" == "reflexive" ]]; then
.claude/hooks/coordinator.sh:210:        # REFLEXIVE MODE: Fast-path execution, skip Tree of Thoughts
.claude/hooks/coordinator.sh:211:        log "Reflexive mode: Fast-path execution (skipping Tree of Thoughts for speed)"
.claude/hooks/coordinator.sh:212:
.claude/hooks/coordinator.sh:213:        # Log decision to audit trail
.claude/hooks/coordinator.sh:214:        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
.claude/hooks/coordinator.sh:215:            "$ENHANCED_AUDIT_TRAIL" log "reflexive_fast_path" \
.claude/hooks/coordinator.sh:216:                "Task classified as low complexity/risk - using fast execution" \
.claude/hooks/coordinator.sh:217:                "skip_tree_of_thoughts" \
.claude/hooks/coordinator.sh:218:                "Reflexive mode prioritizes speed over thorough exploration" \
.claude/hooks/coordinator.sh:219:                "0.90" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:220:        fi
.claude/hooks/coordinator.sh:221:
.claude/hooks/coordinator.sh:222:    elif [[ "$reasoning_mode" == "reactive" ]]; then
.claude/hooks/coordinator.sh:223:        # REACTIVE MODE: Immediate action, minimal planning
.claude/hooks/coordinator.sh:224:        log "Reactive mode: Immediate action for urgent task (minimal deliberation)"
.claude/hooks/coordinator.sh:225:
.claude/hooks/coordinator.sh:226:        # Log decision to audit trail
.claude/hooks/coordinator.sh:227:        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
.claude/hooks/coordinator.sh:228:            "$ENHANCED_AUDIT_TRAIL" log "reactive_immediate_action" \
.claude/hooks/coordinator.sh:229:                "Task classified as urgent - executing immediately" \
.claude/hooks/coordinator.sh:230:                "minimal_planning" \
.claude/hooks/coordinator.sh:231:                "Reactive mode prioritizes urgency over thoroughness" \
.claude/hooks/coordinator.sh:232:                "0.85" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:233:        fi
.claude/hooks/coordinator.sh:234:
.claude/hooks/coordinator.sh:235:    elif [[ "$reasoning_mode" == "deliberate" && -x "$TREE_OF_THOUGHTS" ]]; then
.claude/hooks/coordinator.sh:236:        # DELIBERATE MODE: Thorough exploration with Tree of Thoughts
.claude/hooks/coordinator.sh:237:        log "Deliberate mode: Exploring multiple solution paths with Tree of Thoughts"
.claude/hooks/coordinator.sh:238:
.claude/hooks/coordinator.sh:239:        # Generate multiple branches
.claude/hooks/coordinator.sh:240:        tot_result=$("$TREE_OF_THOUGHTS" generate "$task" "$context" 3 2>/dev/null || echo '{}')
.claude/hooks/coordinator.sh:241:
.claude/hooks/coordinator.sh:242:        # Evaluate and select best branch
.claude/hooks/coordinator.sh:243:        local tot_eval
.claude/hooks/coordinator.sh:244:        tot_eval=$("$TREE_OF_THOUGHTS" evaluate "$tot_result" 2>/dev/null || echo '{"selected_branch":null}')
.claude/hooks/coordinator.sh:245:        selected_approach=$(echo "$tot_eval" | jq -r '.selected_branch.strategy // ""')
.claude/hooks/coordinator.sh:246:
.claude/hooks/coordinator.sh:247:        if [[ -n "$selected_approach" ]]; then
.claude/hooks/coordinator.sh:248:            log "Tree of Thoughts selected approach: $selected_approach"
.claude/hooks/coordinator.sh:249:
.claude/hooks/coordinator.sh:250:            # Log to audit trail
.claude/hooks/coordinator.sh:251:            if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
.claude/hooks/coordinator.sh:252:                local alternatives
.claude/hooks/coordinator.sh:253:                alternatives=$(echo "$tot_eval" | jq -r '.branches[] | .strategy' | tr '\n' ',' | sed 's/,$//')
.claude/hooks/coordinator.sh:254:                "$ENHANCED_AUDIT_TRAIL" log "tot_approach_selection" \
.claude/hooks/coordinator.sh:255:                    "Evaluated multiple approaches using Tree of Thoughts" \
.claude/hooks/coordinator.sh:256:                    "$alternatives" \
.claude/hooks/coordinator.sh:257:                    "Selected approach has best weighted score across feasibility, quality, risk, and effort" \
.claude/hooks/coordinator.sh:258:                    "$(echo "$tot_eval" | jq -r '.selected_branch.weighted_score / 10 // 0.75')" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:259:            fi
.claude/hooks/coordinator.sh:260:
.claude/hooks/coordinator.sh:261:            # Override strategy if ToT found better approach
.claude/hooks/coordinator.sh:262:            if [[ -n "$selected_approach" && "$selected_approach" != "null" ]]; then
.claude/hooks/coordinator.sh:263:                strategy="$selected_approach"
.claude/hooks/coordinator.sh:264:                strategy_confidence=0.85
.claude/hooks/coordinator.sh:265:            fi
.claude/hooks/coordinator.sh:266:        fi
.claude/hooks/coordinator.sh:267:    fi
.claude/hooks/coordinator.sh:268:
.claude/hooks/coordinator.sh:269:    # 1.5: Start thinking session
.claude/hooks/coordinator.sh:270:    local thinking_id=""
.claude/hooks/coordinator.sh:271:    if [[ -x "$THINKING_FRAMEWORK" ]]; then
.claude/hooks/coordinator.sh:272:        thinking_id=$("$THINKING_FRAMEWORK" start "$task" "$context" 2>/dev/null || echo "")
.claude/hooks/coordinator.sh:273:        [[ -n "$thinking_id" ]] && log "Started thinking session: $thinking_id"
.claude/hooks/coordinator.sh:274:    fi
.claude/hooks/coordinator.sh:275:
.claude/hooks/coordinator.sh:276:    # 1.6: Check system health
.claude/hooks/coordinator.sh:277:    if [[ -x "$SELF_HEALING" ]]; then
.claude/hooks/coordinator.sh:278:        local health
.claude/hooks/coordinator.sh:279:        health=$("$SELF_HEALING" health 2>/dev/null || echo "unknown")
.claude/hooks/coordinator.sh:280:        log "System health: $health"
.claude/hooks/coordinator.sh:281:
.claude/hooks/coordinator.sh:282:        if [[ "$health" == "unhealthy" ]]; then
.claude/hooks/coordinator.sh:283:            log "System unhealthy, recovering..."
.claude/hooks/coordinator.sh:284:            "$SELF_HEALING" recover 2>/dev/null || true
.claude/hooks/coordinator.sh:285:        fi
.claude/hooks/coordinator.sh:286:    fi
.claude/hooks/coordinator.sh:287:
.claude/hooks/coordinator.sh:288:    # Phase 2: EXECUTION WITH MONITORING
.claude/hooks/coordinator.sh:289:    log "Phase 2: Execution"
.claude/hooks/coordinator.sh:290:
.claude/hooks/coordinator.sh:291:    # 2.0: Bounded autonomy check (safety layer)
.claude/hooks/coordinator.sh:292:    local autonomy_check=""
.claude/hooks/coordinator.sh:293:    local action_allowed="true"
.claude/hooks/coordinator.sh:294:    local requires_approval="false"
.claude/hooks/coordinator.sh:295:    if [[ -x "$BOUNDED_AUTONOMY" ]]; then
.claude/hooks/coordinator.sh:296:        autonomy_check=$("$BOUNDED_AUTONOMY" check "$task" "$context,strategy:$strategy,risk:$risk_level" 2>/dev/null || echo '{"allowed":true,"requires_approval":false}')
.claude/hooks/coordinator.sh:297:        action_allowed=$(echo "$autonomy_check" | jq -r '.allowed // true')
.claude/hooks/coordinator.sh:298:        requires_approval=$(echo "$autonomy_check" | jq -r '.requires_approval // false')
.claude/hooks/coordinator.sh:299:
.claude/hooks/coordinator.sh:300:        if [[ "$action_allowed" == "false" ]]; then
.claude/hooks/coordinator.sh:301:            log "BLOCKED: Task prohibited by bounded autonomy rules"
.claude/hooks/coordinator.sh:302:            echo '{"error":"action_prohibited","task":"'"$task"'","reason":"Bounded autonomy safety check failed"}'
.claude/hooks/coordinator.sh:303:            return 1
.claude/hooks/coordinator.sh:304:        fi
.claude/hooks/coordinator.sh:305:
.claude/hooks/coordinator.sh:306:        if [[ "$requires_approval" == "true" ]]; then
.claude/hooks/coordinator.sh:307:            log "ESCALATION: Task requires user approval (confidence < 70% or high risk)"
.claude/hooks/coordinator.sh:308:            # Log to audit trail
.claude/hooks/coordinator.sh:309:            if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
.claude/hooks/coordinator.sh:310:                "$ENHANCED_AUDIT_TRAIL" log "escalate_for_approval" \
.claude/hooks/coordinator.sh:311:                    "Task requires user approval due to: $(echo "$autonomy_check" | jq -r '.reason // "high risk or low confidence"')" \
.claude/hooks/coordinator.sh:312:                    "auto-proceed,escalate" \
.claude/hooks/coordinator.sh:313:                    "Safety-first approach dictates human review for uncertain or risky operations" \
.claude/hooks/coordinator.sh:314:                    "0.95" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:315:            fi
.claude/hooks/coordinator.sh:316:            echo '{"status":"requires_approval","task":"'"$task"'","reason":"'"$(echo "$autonomy_check" | jq -r '.reason')"'"}'
.claude/hooks/coordinator.sh:317:            return 0
.claude/hooks/coordinator.sh:318:        fi
.claude/hooks/coordinator.sh:319:
.claude/hooks/coordinator.sh:320:        log "Bounded autonomy check: ALLOWED (category: $(echo "$autonomy_check" | jq -r '.category // "unknown"'))"
.claude/hooks/coordinator.sh:321:    fi
.claude/hooks/coordinator.sh:322:
.claude/hooks/coordinator.sh:323:    update_coordinator_status "status" "executing"
.claude/hooks/coordinator.sh:324:    update_coordinator_status "currentTask" "$task"
.claude/hooks/coordinator.sh:325:
.claude/hooks/coordinator.sh:326:    # 2.1: Create execution plan
.claude/hooks/coordinator.sh:327:    local plan_id=""
.claude/hooks/coordinator.sh:328:    if [[ -x "$PLAN_EXECUTE" ]]; then
.claude/hooks/coordinator.sh:329:        plan_id=$("$PLAN_EXECUTE" create "$task" "$context" 2>/dev/null || echo "")
.claude/hooks/coordinator.sh:330:        if [[ -n "$plan_id" ]]; then
.claude/hooks/coordinator.sh:331:            # Decompose and add steps
.claude/hooks/coordinator.sh:332:            "$PLAN_EXECUTE" decompose "$task" "$task_type" 2>/dev/null | while read -r step; do
.claude/hooks/coordinator.sh:333:                [[ -n "$step" ]] && "$PLAN_EXECUTE" add-step "${step#* }" "shell" "" "" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:334:            done
.claude/hooks/coordinator.sh:335:            log "Created plan: $plan_id"
.claude/hooks/coordinator.sh:336:        fi
.claude/hooks/coordinator.sh:337:    fi
.claude/hooks/coordinator.sh:338:
.claude/hooks/coordinator.sh:339:    # 2.2: Route to appropriate agent (multi-agent orchestration)
.claude/hooks/coordinator.sh:340:    local assigned_agent="general"
.claude/hooks/coordinator.sh:341:    local agent_info=""
.claude/hooks/coordinator.sh:342:    if [[ -x "$MULTI_AGENT_ORCHESTRATOR" ]]; then
.claude/hooks/coordinator.sh:343:        local routing_result
.claude/hooks/coordinator.sh:344:        routing_result=$("$MULTI_AGENT_ORCHESTRATOR" route "$task" 2>/dev/null || echo '{"selected_agent":"general"}')
.claude/hooks/coordinator.sh:345:        assigned_agent=$(echo "$routing_result" | jq -r '.selected_agent // "general"')
.claude/hooks/coordinator.sh:346:        agent_info=$(echo "$routing_result" | jq -r '.agent_info.description // ""')
.claude/hooks/coordinator.sh:347:        log "Multi-agent routing: Assigned to $assigned_agent agent ($agent_info)"
.claude/hooks/coordinator.sh:348:
.claude/hooks/coordinator.sh:349:        # Log to audit trail
.claude/hooks/coordinator.sh:350:        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
.claude/hooks/coordinator.sh:351:            local all_agents
.claude/hooks/coordinator.sh:352:            all_agents=$("$MULTI_AGENT_ORCHESTRATOR" agents 2>/dev/null | jq -r '.agents | keys | join(",")')
.claude/hooks/coordinator.sh:353:            "$ENHANCED_AUDIT_TRAIL" log "agent_routing" \
.claude/hooks/coordinator.sh:354:                "Routed task to specialist $assigned_agent agent" \
.claude/hooks/coordinator.sh:355:                "$all_agents" \
.claude/hooks/coordinator.sh:356:                "Task keywords match $assigned_agent expertise: $agent_info" \
.claude/hooks/coordinator.sh:357:                "$(echo "$routing_result" | jq -r '.routing_confidence / 100 // 0.7')" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:358:        fi
.claude/hooks/coordinator.sh:359:    fi
.claude/hooks/coordinator.sh:360:
.claude/hooks/coordinator.sh:361:    # 2.3: Start ReAct + Reflexion cycle
.claude/hooks/coordinator.sh:362:    local reflexion_iteration=1
.claude/hooks/coordinator.sh:363:    local reflexion_goal="$task"
.claude/hooks/coordinator.sh:364:    if [[ -x "$REACT_REFLEXION" ]]; then
.claude/hooks/coordinator.sh:365:        log "Starting ReAct + Reflexion cycle (Think  Act  Observe  Reflect)"
.claude/hooks/coordinator.sh:366:
.claude/hooks/coordinator.sh:367:        # Generate reasoning before action
.claude/hooks/coordinator.sh:368:        local thought_result
.claude/hooks/coordinator.sh:369:        thought_result=$("$REACT_REFLEXION" think "$reflexion_goal" "$context" "$reflexion_iteration" 2>/dev/null || echo '{}')
.claude/hooks/coordinator.sh:370:        log "ReAct thought generated for iteration $reflexion_iteration"
.claude/hooks/coordinator.sh:371:    fi
.claude/hooks/coordinator.sh:372:
.claude/hooks/coordinator.sh:373:    # ============================================================================
.claude/hooks/coordinator.sh:374:    # PARALLEL EXECUTION ANALYSIS: Check if tasks can be parallelized
.claude/hooks/coordinator.sh:375:    # ============================================================================
.claude/hooks/coordinator.sh:376:    local parallel_groups="[]"
.claude/hooks/coordinator.sh:377:    local can_parallelize="false"
.claude/hooks/coordinator.sh:378:    if [[ -x "$PARALLEL_EXECUTION_PLANNER" ]]; then
.claude/hooks/coordinator.sh:379:        log "Analyzing task for parallel execution opportunities..."
.claude/hooks/coordinator.sh:380:        local parallel_analysis
.claude/hooks/coordinator.sh:381:        parallel_analysis=$("$PARALLEL_EXECUTION_PLANNER" analyze "$task" "$context" 2>/dev/null || echo '{}')
.claude/hooks/coordinator.sh:382:
.claude/hooks/coordinator.sh:383:        can_parallelize=$(echo "$parallel_analysis" | jq -r '.canParallelize // false')
.claude/hooks/coordinator.sh:384:        parallel_groups=$(echo "$parallel_analysis" | jq -c '.groups // []')
.claude/hooks/coordinator.sh:385:
.claude/hooks/coordinator.sh:386:        if [[ "$can_parallelize" == "true" ]]; then
.claude/hooks/coordinator.sh:387:            local group_count
.claude/hooks/coordinator.sh:388:            group_count=$(echo "$parallel_groups" | jq 'length')
.claude/hooks/coordinator.sh:389:            log "Task can be parallelized into $group_count groups"
.claude/hooks/coordinator.sh:390:        else
.claude/hooks/coordinator.sh:391:            log "Task will execute sequentially (no parallelization opportunities)"
.claude/hooks/coordinator.sh:392:        fi
.claude/hooks/coordinator.sh:393:    fi
.claude/hooks/coordinator.sh:394:    # ============================================================================
.claude/hooks/coordinator.sh:395:
.claude/hooks/coordinator.sh:396:    # 2.4: Start agent loop with specialist context
.claude/hooks/coordinator.sh:397:    local agent_id=""
.claude/hooks/coordinator.sh:398:    local execution_result="pending"
.claude/hooks/coordinator.sh:399:    if [[ -x "$AGENT_LOOP" ]]; then
.claude/hooks/coordinator.sh:400:        agent_id=$("$AGENT_LOOP" start "$task" "strategy:$strategy,risk:$risk_level,plan:$plan_id,agent:$assigned_agent,mode:$reasoning_mode,parallel:$can_parallelize" 2>/dev/null || echo "")
.claude/hooks/coordinator.sh:401:        log "Started agent loop: $agent_id (via $assigned_agent agent in $reasoning_mode mode)"
.claude/hooks/coordinator.sh:402:
.claude/hooks/coordinator.sh:403:        # Monitor execution (in real implementation, this would be event-driven)
.claude/hooks/coordinator.sh:404:        # For now, just record that we started it
.claude/hooks/coordinator.sh:405:        execution_result="started"
.claude/hooks/coordinator.sh:406:    fi
.claude/hooks/coordinator.sh:407:
.claude/hooks/coordinator.sh:408:    # Phase 3: POST-EXECUTION LEARNING
.claude/hooks/coordinator.sh:409:    log "Phase 3: Post-execution learning"
.claude/hooks/coordinator.sh:410:
.claude/hooks/coordinator.sh:411:    local end_time
.claude/hooks/coordinator.sh:412:    end_time=$(date +%s)
.claude/hooks/coordinator.sh:413:    local duration
.claude/hooks/coordinator.sh:414:    duration=$((end_time - start_time))
.claude/hooks/coordinator.sh:415:
.claude/hooks/coordinator.sh:416:    # 3.1: Complete ReAct + Reflexion cycle
.claude/hooks/coordinator.sh:417:    local quality_score=7.0
.claude/hooks/coordinator.sh:418:    if [[ -x "$REACT_REFLEXION" ]]; then
.claude/hooks/coordinator.sh:419:        log "Completing ReAct + Reflexion: Reflect on execution outcome"
.claude/hooks/coordinator.sh:420:
.claude/hooks/coordinator.sh:421:        # Reflect on the outcome
.claude/hooks/coordinator.sh:422:        local reflection_result
.claude/hooks/coordinator.sh:423:        reflection_result=$("$REACT_REFLEXION" reflect "$execution_result" "$task" "$context" 2>/dev/null || echo '{"quality_score":7.0}')
.claude/hooks/coordinator.sh:424:        quality_score=$(echo "$reflection_result" | jq -r '.quality_score // 7.0')
.claude/hooks/coordinator.sh:425:
.claude/hooks/coordinator.sh:426:        # Extract lessons learned
.claude/hooks/coordinator.sh:427:        if [[ "$execution_result" =~ (success|completed|started) ]]; then
.claude/hooks/coordinator.sh:428:            "$REACT_REFLEXION" learn "$task" "$execution_result" "Learned from execution" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:429:            log "ReAct reflexion complete: quality=$quality_score/10, lessons extracted"
.claude/hooks/coordinator.sh:430:        fi
.claude/hooks/coordinator.sh:431:    fi
.claude/hooks/coordinator.sh:432:
.claude/hooks/coordinator.sh:433:    # 3.2: Constitutional AI validation WITH AUTO-REVISION
.claude/hooks/coordinator.sh:434:    local constitutional_violations=""
.claude/hooks/coordinator.sh:435:    local revision_count=0
.claude/hooks/coordinator.sh:436:    if [[ -x "$CONSTITUTIONAL_AI" ]]; then
.claude/hooks/coordinator.sh:437:        log "Running Constitutional AI validation against principles"
.claude/hooks/coordinator.sh:438:
.claude/hooks/coordinator.sh:439:        # Critique output against principles
.claude/hooks/coordinator.sh:440:        local critique_json
.claude/hooks/coordinator.sh:441:        critique_json=$("$CONSTITUTIONAL_AI" critique "$execution_result" all 2>/dev/null || echo '{}')
.claude/hooks/coordinator.sh:442:
.claude/hooks/coordinator.sh:443:        # Parse critique results
.claude/hooks/coordinator.sh:444:        local assessment=$(echo "$critique_json" | jq -r '.overall_assessment // "safe"' 2>/dev/null || echo "safe")
.claude/hooks/coordinator.sh:445:        local violations=$(echo "$critique_json" | jq -r '.violations | length' 2>/dev/null || echo "0")
.claude/hooks/coordinator.sh:446:
.claude/hooks/coordinator.sh:447:        if [[ "$assessment" != "safe" ]] && [[ "$violations" -gt 0 ]]; then
.claude/hooks/coordinator.sh:448:            log "  Constitutional AI: $violations violations found - initiating auto-revision"
.claude/hooks/coordinator.sh:449:
.claude/hooks/coordinator.sh:450:            # AUTO-REVISION LOOP (max 2 iterations)
.claude/hooks/coordinator.sh:451:            while [[ $revision_count -lt 2 ]] && [[ "$assessment" != "safe" ]]; do
.claude/hooks/coordinator.sh:452:                revision_count=$((revision_count + 1))
.claude/hooks/coordinator.sh:453:                log "Auto-revision attempt $revision_count/$2..."
.claude/hooks/coordinator.sh:454:
.claude/hooks/coordinator.sh:455:                # Generate revision
.claude/hooks/coordinator.sh:456:                local revised
.claude/hooks/coordinator.sh:457:                revised=$("$CONSTITUTIONAL_AI" revise "$execution_result" "$critique_json" 2>/dev/null || echo "")
.claude/hooks/coordinator.sh:458:
.claude/hooks/coordinator.sh:459:                if [[ -n "$revised" && "$revised" != "null" && "$revised" != "{}" ]]; then
.claude/hooks/coordinator.sh:460:                    execution_result="$revised"
.claude/hooks/coordinator.sh:461:                    log " Constitutional AI: Auto-revision $revision_count applied"
.claude/hooks/coordinator.sh:462:
.claude/hooks/coordinator.sh:463:                    # Re-evaluate revised output
.claude/hooks/coordinator.sh:464:                    critique_json=$("$CONSTITUTIONAL_AI" critique "$execution_result" all 2>/dev/null || echo '{}')
.claude/hooks/coordinator.sh:465:                    assessment=$(echo "$critique_json" | jq -r '.overall_assessment // "safe"' 2>/dev/null || echo "safe")
.claude/hooks/coordinator.sh:466:                    violations=$(echo "$critique_json" | jq -r '.violations | length' 2>/dev/null || echo "0")
.claude/hooks/coordinator.sh:467:                else
.claude/hooks/coordinator.sh:468:                    log " Constitutional AI: Revision generation failed"
.claude/hooks/coordinator.sh:469:                    break
.claude/hooks/coordinator.sh:470:                fi
.claude/hooks/coordinator.sh:471:            done
.claude/hooks/coordinator.sh:472:
.claude/hooks/coordinator.sh:473:            if [[ "$assessment" == "safe" ]]; then
.claude/hooks/coordinator.sh:474:                log " Constitutional AI: All violations resolved after $revision_count revision(s)"
.claude/hooks/coordinator.sh:475:            else
.claude/hooks/coordinator.sh:476:                log "  Constitutional AI: $violations violations remain after $revision_count revisions"
.claude/hooks/coordinator.sh:477:            fi
.claude/hooks/coordinator.sh:478:        else
.claude/hooks/coordinator.sh:479:            log " Constitutional AI check complete: $assessment (no violations)"
.claude/hooks/coordinator.sh:480:        fi
.claude/hooks/coordinator.sh:481:
.claude/hooks/coordinator.sh:482:        # Log to audit trail
.claude/hooks/coordinator.sh:483:        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
.claude/hooks/coordinator.sh:484:            "$ENHANCED_AUDIT_TRAIL" log "constitutional_validation" \
.claude/hooks/coordinator.sh:485:                "Validated and revised: $assessment, $violations violations, $revision_count revisions" \
.claude/hooks/coordinator.sh:486:                "skip-validation,run-validation,auto-revise" \
.claude/hooks/coordinator.sh:487:                "Ensures code quality, security, testing, error handling, compatibility, documentation, simplicity, and no data loss" \
.claude/hooks/coordinator.sh:488:                "0.90" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:489:        fi
.claude/hooks/coordinator.sh:490:    fi
.claude/hooks/coordinator.sh:491:
.claude/hooks/coordinator.sh:492:    # 3.3: Auto-evaluator quality gates
.claude/hooks/coordinator.sh:493:    local eval_score=7.0
.claude/hooks/coordinator.sh:494:    local eval_decision="continue"
.claude/hooks/coordinator.sh:495:    if [[ -x "$AUTO_EVALUATOR" ]]; then
.claude/hooks/coordinator.sh:496:        log "Running auto-evaluator quality assessment"
.claude/hooks/coordinator.sh:497:
.claude/hooks/coordinator.sh:498:        # Get evaluation criteria
.claude/hooks/coordinator.sh:499:        local eval_criteria
.claude/hooks/coordinator.sh:500:        eval_criteria=$("$AUTO_EVALUATOR" criteria "$task_type" 2>/dev/null || echo '{}')
.claude/hooks/coordinator.sh:501:
.claude/hooks/coordinator.sh:502:        # In production, Claude would evaluate against criteria
.claude/hooks/coordinator.sh:503:        # For now, use reflexion quality score
.claude/hooks/coordinator.sh:504:        eval_score="$quality_score"
.claude/hooks/coordinator.sh:505:
.claude/hooks/coordinator.sh:506:        # Determine if revision needed (threshold 7.0)
.claude/hooks/coordinator.sh:507:        if (( $(echo "$eval_score < 7.0" | bc -l 2>/dev/null || echo 0) )); then
.claude/hooks/coordinator.sh:508:            eval_decision="revise"
.claude/hooks/coordinator.sh:509:            log "Auto-evaluator: Quality below threshold ($eval_score < 7.0), revision recommended"
.claude/hooks/coordinator.sh:510:        else
.claude/hooks/coordinator.sh:511:            eval_decision="continue"
.claude/hooks/coordinator.sh:512:            log "Auto-evaluator: Quality acceptable ($eval_score >= 7.0)"
.claude/hooks/coordinator.sh:513:        fi
.claude/hooks/coordinator.sh:514:
.claude/hooks/coordinator.sh:515:        # Log to audit trail
.claude/hooks/coordinator.sh:516:        if [[ -x "$ENHANCED_AUDIT_TRAIL" ]]; then
.claude/hooks/coordinator.sh:517:            "$ENHANCED_AUDIT_TRAIL" log "quality_evaluation" \
.claude/hooks/coordinator.sh:518:                "Evaluated output quality: $eval_score/10" \
.claude/hooks/coordinator.sh:519:                "accept,revise,reject" \
.claude/hooks/coordinator.sh:520:                "Score meets/exceeds threshold of 7.0 for $task_type tasks" \
.claude/hooks/coordinator.sh:521:                "$(echo "$eval_score / 10" | bc -l 2>/dev/null || echo 0.7)" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:522:        fi
.claude/hooks/coordinator.sh:523:    fi
.claude/hooks/coordinator.sh:524:
.claude/hooks/coordinator.sh:525:    # 3.4: Record to reinforcement learning
.claude/hooks/coordinator.sh:526:    if [[ -x "$REINFORCEMENT_LEARNING" ]]; then
.claude/hooks/coordinator.sh:527:        # Determine reward based on execution result and quality
.claude/hooks/coordinator.sh:528:        local reward=0.0
.claude/hooks/coordinator.sh:529:        if [[ "$execution_result" =~ (success|completed|started) ]]; then
.claude/hooks/coordinator.sh:530:            reward=$(echo "scale=2; $eval_score / 10" | bc -l 2>/dev/null || echo "0.7")
.claude/hooks/coordinator.sh:531:        else
.claude/hooks/coordinator.sh:532:            reward=0.0
.claude/hooks/coordinator.sh:533:        fi
.claude/hooks/coordinator.sh:534:
.claude/hooks/coordinator.sh:535:        "$REINFORCEMENT_LEARNING" record "$task_type" "$context" "$execution_result" "$reward" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:536:        log "Recorded RL outcome: $task_type -> $execution_result (reward: $reward)"
.claude/hooks/coordinator.sh:537:    fi
.claude/hooks/coordinator.sh:538:
.claude/hooks/coordinator.sh:539:    # 3.5: Verify hypothesis
.claude/hooks/coordinator.sh:540:    if [[ -n "$hypothesis_id" && -x "$HYPOTHESIS_TESTER" ]]; then
.claude/hooks/coordinator.sh:541:        "$HYPOTHESIS_TESTER" verify "$hypothesis_id" "$execution_result" "Execution completed" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:542:        log "Verified hypothesis: $hypothesis_id"
.claude/hooks/coordinator.sh:543:    fi
.claude/hooks/coordinator.sh:544:
.claude/hooks/coordinator.sh:545:    # 3.6: Record outcome to feedback loop
.claude/hooks/coordinator.sh:546:    if [[ -x "$FEEDBACK_LOOP" ]]; then
.claude/hooks/coordinator.sh:547:        "$FEEDBACK_LOOP" record "$task" "$task_type" "$strategy" "$execution_result" "$duration" "" "$context" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:548:        log "Recorded feedback"
.claude/hooks/coordinator.sh:549:    fi
.claude/hooks/coordinator.sh:550:
.claude/hooks/coordinator.sh:551:    # 3.3: Create meta-reflection
.claude/hooks/coordinator.sh:552:    if [[ -x "$META_REFLECTION" ]]; then
.claude/hooks/coordinator.sh:553:        "$META_REFLECTION" reflect "what_learned" "$task" "$execution_result" "Used $strategy strategy with $risk_level risk" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:554:        log "Created meta-reflection"
.claude/hooks/coordinator.sh:555:    fi
.claude/hooks/coordinator.sh:556:
.claude/hooks/coordinator.sh:557:    # 3.4: Complete thinking session
.claude/hooks/coordinator.sh:558:    if [[ -n "$thinking_id" && -x "$THINKING_FRAMEWORK" ]]; then
.claude/hooks/coordinator.sh:559:        "$THINKING_FRAMEWORK" complete "Completed: $execution_result" 0.8 > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:560:        log "Completed thinking session"
.claude/hooks/coordinator.sh:561:    fi
.claude/hooks/coordinator.sh:562:
.claude/hooks/coordinator.sh:563:    # 3.5: Complete plan
.claude/hooks/coordinator.sh:564:    if [[ -n "$plan_id" && -x "$PLAN_EXECUTE" ]]; then
.claude/hooks/coordinator.sh:565:        "$PLAN_EXECUTE" finish "$execution_result" "Coordination complete" > /dev/null 2>&1 || true
.claude/hooks/coordinator.sh:566:    fi
.claude/hooks/coordinator.sh:567:
.claude/hooks/coordinator.sh:568:    update_coordinator_status "status" "idle"
.claude/hooks/coordinator.sh:569:    update_coordinator_status "currentTask" "null"
.claude/hooks/coordinator.sh:570:
.claude/hooks/coordinator.sh:571:    # Return comprehensive result with full intelligence data
.claude/hooks/coordinator.sh:572:    jq -n \
.claude/hooks/coordinator.sh:573:        --arg task "$task" \
.claude/hooks/coordinator.sh:574:        --arg strategy "$strategy" \
.claude/hooks/coordinator.sh:575:        --argjson strategyConf "$strategy_confidence" \
.claude/hooks/coordinator.sh:576:        --arg riskLevel "$risk_level" \
.claude/hooks/coordinator.sh:577:        --argjson riskScore "$risk_score" \
.claude/hooks/coordinator.sh:578:        --arg agentId "$agent_id" \
.claude/hooks/coordinator.sh:579:        --arg planId "$plan_id" \
.claude/hooks/coordinator.sh:580:        --arg thinkingId "$thinking_id" \
.claude/hooks/coordinator.sh:581:        --argjson duration "$duration" \
.claude/hooks/coordinator.sh:582:        --arg result "$execution_result" \
.claude/hooks/coordinator.sh:583:        --argjson patternCount "$(echo "$patterns" | jq 'length')" \
.claude/hooks/coordinator.sh:584:        --arg reasoningMode "$reasoning_mode" \
.claude/hooks/coordinator.sh:585:        --arg assignedAgent "$assigned_agent" \
.claude/hooks/coordinator.sh:586:        --argjson qualityScore "$quality_score" \
.claude/hooks/coordinator.sh:587:        --argjson evalScore "$eval_score" \
.claude/hooks/coordinator.sh:588:        --arg evalDecision "$eval_decision" \
.claude/hooks/coordinator.sh:589:        --arg totApproach "$selected_approach" \
.claude/hooks/coordinator.sh:590:        '{
.claude/hooks/coordinator.sh:591:            task: $task,
.claude/hooks/coordinator.sh:592:            execution: {
.claude/hooks/coordinator.sh:593:                agentId: $agentId,
.claude/hooks/coordinator.sh:594:                planId: $planId,
.claude/hooks/coordinator.sh:595:                thinkingId: $thinkingId,
.claude/hooks/coordinator.sh:596:                result: $result,
.claude/hooks/coordinator.sh:597:                duration: $duration
.claude/hooks/coordinator.sh:598:            },
.claude/hooks/coordinator.sh:599:            intelligence: {
.claude/hooks/coordinator.sh:600:                strategy: $strategy,
.claude/hooks/coordinator.sh:601:                strategyConfidence: $strategyConf,
.claude/hooks/coordinator.sh:602:                riskLevel: $riskLevel,
.claude/hooks/coordinator.sh:603:                riskScore: $riskScore,
.claude/hooks/coordinator.sh:604:                patternsFound: $patternCount,
.claude/hooks/coordinator.sh:605:                reasoningMode: $reasoningMode,
.claude/hooks/coordinator.sh:606:                assignedAgent: $assignedAgent,
.claude/hooks/coordinator.sh:607:                totSelectedApproach: $totApproach
.claude/hooks/coordinator.sh:608:            },
.claude/hooks/coordinator.sh:609:            quality: {
.claude/hooks/coordinator.sh:610:                reflexionScore: $qualityScore,
.claude/hooks/coordinator.sh:611:                evaluatorScore: $evalScore,
.claude/hooks/coordinator.sh:612:                decision: $evalDecision,
.claude/hooks/coordinator.sh:613:                constitutionalValidation: "completed"
.claude/hooks/coordinator.sh:614:            },
.claude/hooks/coordinator.sh:615:            learning: {
.claude/hooks/coordinator.sh:616:                reinforcementLearning: "recorded",
.claude/hooks/coordinator.sh:617:                reflexionLessons: "extracted",
.claude/hooks/coordinator.sh:618:                auditTrail: "logged"
.claude/hooks/coordinator.sh:619:            },
.claude/hooks/coordinator.sh:620:            timestamp: (now | todate)
.claude/hooks/coordinator.sh:621:        }'
.claude/hooks/coordinator.sh:622:
.claude/hooks/coordinator.sh:623:    log "Coordination complete for: $task (result: $execution_result, duration: ${duration}s)"
.claude/hooks/coordinator.sh:624:}
.claude/hooks/coordinator.sh:625:
.claude/hooks/coordinator.sh:626:# =============================================================================
.claude/hooks/coordinator.sh:627:# AUTONOMOUS ORCHESTRATION
.claude/hooks/coordinator.sh:628:# =============================================================================
.claude/hooks/coordinator.sh:629:
.claude/hooks/coordinator.sh:630:orchestrate_autonomous() {
.claude/hooks/coordinator.sh:631:    init_coordinator
.claude/hooks/coordinator.sh:632:
.claude/hooks/coordinator.sh:633:    log "Starting autonomous orchestration"
.claude/hooks/coordinator.sh:634:
.claude/hooks/coordinator.sh:635:    # Get orchestration decisions
.claude/hooks/coordinator.sh:636:    if [[ ! -x "$ORCHESTRATOR" ]]; then
.claude/hooks/coordinator.sh:637:        log "Orchestrator not available"
.claude/hooks/coordinator.sh:638:        echo '{"error":"orchestrator_unavailable"}'
.claude/hooks/coordinator.sh:639:        return 1
.claude/hooks/coordinator.sh:640:    fi
.claude/hooks/coordinator.sh:641:
.claude/hooks/coordinator.sh:642:    local orchestration
.claude/hooks/coordinator.sh:643:    orchestration=$("$ORCHESTRATOR" smart 2>/dev/null || echo '{"decisions":[],"actions":[]}')
.claude/hooks/coordinator.sh:644:
.claude/hooks/coordinator.sh:645:    log "Orchestration: $(echo "$orchestration" | jq -c '.')"
.claude/hooks/coordinator.sh:646:
.claude/hooks/coordinator.sh:647:    # Get actions to execute
.claude/hooks/coordinator.sh:648:    local actions
.claude/hooks/coordinator.sh:649:    actions=$(echo "$orchestration" | jq -r '.actions[]' 2>/dev/null || true)
.claude/hooks/coordinator.sh:650:
.claude/hooks/coordinator.sh:651:    if [[ -z "$actions" ]]; then
.claude/hooks/coordinator.sh:652:        log "No actions to execute"
.claude/hooks/coordinator.sh:653:        echo '{"status":"no_actions","orchestration":'"$orchestration"'}'
.claude/hooks/coordinator.sh:654:        return
.claude/hooks/coordinator.sh:655:    fi
.claude/hooks/coordinator.sh:656:
.claude/hooks/coordinator.sh:657:    # Execute each action through coordinator
.claude/hooks/coordinator.sh:658:    while IFS= read -r action; do
.claude/hooks/coordinator.sh:659:        [[ -z "$action" ]] && continue
.claude/hooks/coordinator.sh:660:
.claude/hooks/coordinator.sh:661:        case "$action" in
.claude/hooks/coordinator.sh:662:            start_task:*)
.claude/hooks/coordinator.sh:663:                local task_id
.claude/hooks/coordinator.sh:664:                task_id=$(echo "$action" | cut -d: -f2)
.claude/hooks/coordinator.sh:665:                local task_name
.claude/hooks/coordinator.sh:666:                task_name=$(echo "$action" | cut -d: -f3-)
.claude/hooks/coordinator.sh:667:
.claude/hooks/coordinator.sh:668:                log "Executing action: start_task $task_name"
.claude/hooks/coordinator.sh:669:
.claude/hooks/coordinator.sh:670:                # Coordinate the task
.claude/hooks/coordinator.sh:671:                coordinate_task "$task_name" "general" "from buildguide"
.claude/hooks/coordinator.sh:672:                ;;
.claude/hooks/coordinator.sh:673:            *)
.claude/hooks/coordinator.sh:674:                log "Unknown action: $action"
.claude/hooks/coordinator.sh:675:                ;;
.claude/hooks/coordinator.sh:676:        esac
.claude/hooks/coordinator.sh:677:    done <<< "$actions"
.claude/hooks/coordinator.sh:678:
.claude/hooks/coordinator.sh:679:    echo '{"status":"completed","orchestration":'"$orchestration"'}'
.claude/hooks/coordinator.sh:680:}
.claude/hooks/coordinator.sh:681:
.claude/hooks/coordinator.sh:682:# =============================================================================
.claude/hooks/coordinator.sh:683:# COMMAND INTERFACE
.claude/hooks/coordinator.sh:684:# =============================================================================
.claude/hooks/coordinator.sh:685:
.claude/hooks/coordinator.sh:686:case "${1:-help}" in
.claude/hooks/coordinator.sh:687:    init)
.claude/hooks/coordinator.sh:688:        init_coordinator
.claude/hooks/coordinator.sh:689:        ;;
.claude/hooks/coordinator.sh:690:    coordinate)
.claude/hooks/coordinator.sh:691:        coordinate_task "${2:-task}" "${3:-general}" "${4:-}"
.claude/hooks/coordinator.sh:692:        ;;
.claude/hooks/coordinator.sh:693:    orchestrate)
.claude/hooks/coordinator.sh:694:        orchestrate_autonomous
.claude/hooks/coordinator.sh:695:        ;;
.claude/hooks/coordinator.sh:696:    status)
.claude/hooks/coordinator.sh:697:        cat "$COORD_STATE"
.claude/hooks/coordinator.sh:698:        ;;
.claude/hooks/coordinator.sh:699:    help|*)
.claude/hooks/coordinator.sh:700:        echo "Central Coordinator - Intelligence Layer"
.claude/hooks/coordinator.sh:701:        echo ""
.claude/hooks/coordinator.sh:702:        echo "Usage: $0 <command> [args]"
.claude/hooks/coordinator.sh:703:        echo ""
.claude/hooks/coordinator.sh:704:        echo "Commands:"
.claude/hooks/coordinator.sh:705:        echo "  init                                  - Initialize coordinator"
.claude/hooks/coordinator.sh:706:        echo "  coordinate <task> [type] [context]    - Coordinate single task"
.claude/hooks/coordinator.sh:707:        echo "  orchestrate                           - Autonomous orchestration"
.claude/hooks/coordinator.sh:708:        echo "  status                                - Get coordinator status"
.claude/hooks/coordinator.sh:709:        echo ""
.claude/hooks/coordinator.sh:710:        echo "Examples:"
.claude/hooks/coordinator.sh:711:        echo "  $0 coordinate 'implement auth' feature"
.claude/hooks/coordinator.sh:712:        echo "  $0 orchestrate  # Run autonomous orchestration"
.claude/hooks/coordinator.sh:713:        ;;
.claude/hooks/coordinator.sh:714:esac
.claude/hooks/debug-orchestrator.sh:1:#!/bin/bash
.claude/hooks/debug-orchestrator.sh:2:# Debug Orchestrator - Intelligent debugging with regression detection and self-healing
.claude/hooks/debug-orchestrator.sh:3:# Solves the problem: "fixing one thing breaks another"
.claude/hooks/debug-orchestrator.sh:4:
.claude/hooks/debug-orchestrator.sh:5:set -eo pipefail
.claude/hooks/debug-orchestrator.sh:6:
.claude/hooks/debug-orchestrator.sh:7:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/debug-orchestrator.sh:8:DEBUG_DIR="${CLAUDE_DIR}/.debug"
.claude/hooks/debug-orchestrator.sh:9:BUG_FIX_MEMORY="${DEBUG_DIR}/bug-fixes.jsonl"
.claude/hooks/debug-orchestrator.sh:10:REGRESSION_LOG="${DEBUG_DIR}/regressions.jsonl"
.claude/hooks/debug-orchestrator.sh:11:TEST_SNAPSHOTS="${DEBUG_DIR}/test-snapshots"
.claude/hooks/debug-orchestrator.sh:12:LOG_FILE="${CLAUDE_DIR}/debug-orchestrator.log"
.claude/hooks/debug-orchestrator.sh:13:
.claude/hooks/debug-orchestrator.sh:14:# GitHub MCP integration
.claude/hooks/debug-orchestrator.sh:15:GITHUB_MCP_AVAILABLE=false
.claude/hooks/debug-orchestrator.sh:16:CHROME_MCP_AVAILABLE=false
.claude/hooks/debug-orchestrator.sh:17:
.claude/hooks/debug-orchestrator.sh:18:mkdir -p "$DEBUG_DIR" "$TEST_SNAPSHOTS"
.claude/hooks/debug-orchestrator.sh:19:
.claude/hooks/debug-orchestrator.sh:20:log() {
.claude/hooks/debug-orchestrator.sh:21:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/debug-orchestrator.sh:22:}
.claude/hooks/debug-orchestrator.sh:23:
.claude/hooks/debug-orchestrator.sh:24:# =============================================================================
.claude/hooks/debug-orchestrator.sh:25:# BUG FIX MEMORY BANK
.claude/hooks/debug-orchestrator.sh:26:# =============================================================================
.claude/hooks/debug-orchestrator.sh:27:
.claude/hooks/debug-orchestrator.sh:28:record_bug_fix() {
.claude/hooks/debug-orchestrator.sh:29:    local bug_description="$1"
.claude/hooks/debug-orchestrator.sh:30:    local bug_type="$2"
.claude/hooks/debug-orchestrator.sh:31:    local fix_description="$3"
.claude/hooks/debug-orchestrator.sh:32:    local files_changed="$4"
.claude/hooks/debug-orchestrator.sh:33:    local success="$5"
.claude/hooks/debug-orchestrator.sh:34:    local tests_passed="${6:-unknown}"
.claude/hooks/debug-orchestrator.sh:35:
.claude/hooks/debug-orchestrator.sh:36:    local record
.claude/hooks/debug-orchestrator.sh:37:    record=$(jq -n \
.claude/hooks/debug-orchestrator.sh:38:        --arg desc "$bug_description" \
.claude/hooks/debug-orchestrator.sh:39:        --arg type "$bug_type" \
.claude/hooks/debug-orchestrator.sh:40:        --arg fix "$fix_description" \
.claude/hooks/debug-orchestrator.sh:41:        --arg files "$files_changed" \
.claude/hooks/debug-orchestrator.sh:42:        --arg success "$success" \
.claude/hooks/debug-orchestrator.sh:43:        --arg tests "$tests_passed" \
.claude/hooks/debug-orchestrator.sh:44:        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/debug-orchestrator.sh:45:        '{
.claude/hooks/debug-orchestrator.sh:46:            timestamp: $ts,
.claude/hooks/debug-orchestrator.sh:47:            bug_description: $desc,
.claude/hooks/debug-orchestrator.sh:48:            bug_type: $type,
.claude/hooks/debug-orchestrator.sh:49:            fix_description: $fix,
.claude/hooks/debug-orchestrator.sh:50:            files_changed: $files,
.claude/hooks/debug-orchestrator.sh:51:            success: ($success == "true"),
.claude/hooks/debug-orchestrator.sh:52:            tests_passed: $tests,
.claude/hooks/debug-orchestrator.sh:53:            embedding_keywords: ($desc + " " + $fix | split(" ") | map(select(length > 3)))
.claude/hooks/debug-orchestrator.sh:54:        }')
.claude/hooks/debug-orchestrator.sh:55:
.claude/hooks/debug-orchestrator.sh:56:    echo "$record" >> "$BUG_FIX_MEMORY"
.claude/hooks/debug-orchestrator.sh:57:    log "Recorded bug fix: $bug_description -> $success"
.claude/hooks/debug-orchestrator.sh:58:    echo "$record"
.claude/hooks/debug-orchestrator.sh:59:}
.claude/hooks/debug-orchestrator.sh:60:
.claude/hooks/debug-orchestrator.sh:61:search_similar_bugs() {
.claude/hooks/debug-orchestrator.sh:62:    local search_query="$1"
.claude/hooks/debug-orchestrator.sh:63:    local limit="${2:-5}"
.claude/hooks/debug-orchestrator.sh:64:
.claude/hooks/debug-orchestrator.sh:65:    if [[ ! -f "$BUG_FIX_MEMORY" ]]; then
.claude/hooks/debug-orchestrator.sh:66:        echo '{"similar_fixes":[],"count":0}'
.claude/hooks/debug-orchestrator.sh:67:        return
.claude/hooks/debug-orchestrator.sh:68:    fi
.claude/hooks/debug-orchestrator.sh:69:
.claude/hooks/debug-orchestrator.sh:70:    # Simple keyword matching (could be enhanced with embeddings)
.claude/hooks/debug-orchestrator.sh:71:    local keywords
.claude/hooks/debug-orchestrator.sh:72:    keywords=$(echo "$search_query" | tr '[:upper:]' '[:lower:]' | tr -s ' ' '\n' | grep -v '^$' || true)
.claude/hooks/debug-orchestrator.sh:73:
.claude/hooks/debug-orchestrator.sh:74:    log "Searching for similar bugs: $search_query"
.claude/hooks/debug-orchestrator.sh:75:
.claude/hooks/debug-orchestrator.sh:76:    # Search through bug fix memory
.claude/hooks/debug-orchestrator.sh:77:    local results
.claude/hooks/debug-orchestrator.sh:78:    results=$(tail -n 100 "$BUG_FIX_MEMORY" | jq -s \
.claude/hooks/debug-orchestrator.sh:79:        --arg query "$(echo "$keywords" | tr '\n' ' ')" \
.claude/hooks/debug-orchestrator.sh:80:        --argjson limit "$limit" \
.claude/hooks/debug-orchestrator.sh:81:        'map(select(.success == true)) |
.claude/hooks/debug-orchestrator.sh:82:         map(. + {relevance_score: 0}) |
.claude/hooks/debug-orchestrator.sh:83:         .[:$limit]')
.claude/hooks/debug-orchestrator.sh:84:
.claude/hooks/debug-orchestrator.sh:85:    jq -n \
.claude/hooks/debug-orchestrator.sh:86:        --argjson results "$results" \
.claude/hooks/debug-orchestrator.sh:87:        --argjson count "$(echo "$results" | jq 'length')" \
.claude/hooks/debug-orchestrator.sh:88:        '{similar_fixes: $results, count: $count}'
.claude/hooks/debug-orchestrator.sh:89:}
.claude/hooks/debug-orchestrator.sh:90:
.claude/hooks/debug-orchestrator.sh:91:# =============================================================================
.claude/hooks/debug-orchestrator.sh:92:# REGRESSION DETECTION
.claude/hooks/debug-orchestrator.sh:93:# =============================================================================
.claude/hooks/debug-orchestrator.sh:94:
.claude/hooks/debug-orchestrator.sh:95:create_test_snapshot() {
.claude/hooks/debug-orchestrator.sh:96:    local snapshot_id="$1"
.claude/hooks/debug-orchestrator.sh:97:    local test_command="$2"
.claude/hooks/debug-orchestrator.sh:98:    local description="$3"
.claude/hooks/debug-orchestrator.sh:99:
.claude/hooks/debug-orchestrator.sh:100:    log "Creating test snapshot: $snapshot_id"
.claude/hooks/debug-orchestrator.sh:101:
.claude/hooks/debug-orchestrator.sh:102:    # Run tests and capture output
.claude/hooks/debug-orchestrator.sh:103:    local test_output
.claude/hooks/debug-orchestrator.sh:104:    local test_exit_code=0
.claude/hooks/debug-orchestrator.sh:105:    test_output=$(eval "$test_command" 2>&1 || test_exit_code=$?)
.claude/hooks/debug-orchestrator.sh:106:
.claude/hooks/debug-orchestrator.sh:107:    # Save snapshot
.claude/hooks/debug-orchestrator.sh:108:    local snapshot_file="${TEST_SNAPSHOTS}/${snapshot_id}.json"
.claude/hooks/debug-orchestrator.sh:109:    jq -n \
.claude/hooks/debug-orchestrator.sh:110:        --arg id "$snapshot_id" \
.claude/hooks/debug-orchestrator.sh:111:        --arg desc "$description" \
.claude/hooks/debug-orchestrator.sh:112:        --arg cmd "$test_command" \
.claude/hooks/debug-orchestrator.sh:113:        --arg output "$test_output" \
.claude/hooks/debug-orchestrator.sh:114:        --argjson exit_code "$test_exit_code" \
.claude/hooks/debug-orchestrator.sh:115:        --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/debug-orchestrator.sh:116:        '{
.claude/hooks/debug-orchestrator.sh:117:            snapshot_id: $id,
.claude/hooks/debug-orchestrator.sh:118:            description: $desc,
.claude/hooks/debug-orchestrator.sh:119:            test_command: $cmd,
.claude/hooks/debug-orchestrator.sh:120:            output: $output,
.claude/hooks/debug-orchestrator.sh:121:            exit_code: $exit_code,
.claude/hooks/debug-orchestrator.sh:122:            timestamp: $ts,
.claude/hooks/debug-orchestrator.sh:123:            tests_passed: ($exit_code == 0)
.claude/hooks/debug-orchestrator.sh:124:        }' > "$snapshot_file"
.claude/hooks/debug-orchestrator.sh:125:
.claude/hooks/debug-orchestrator.sh:126:    log "Snapshot created: $snapshot_id (exit code: $test_exit_code)"
.claude/hooks/debug-orchestrator.sh:127:    echo "$snapshot_file"
.claude/hooks/debug-orchestrator.sh:128:}
.claude/hooks/debug-orchestrator.sh:129:
.claude/hooks/debug-orchestrator.sh:130:detect_regression() {
.claude/hooks/debug-orchestrator.sh:131:    local before_snapshot="$1"
.claude/hooks/debug-orchestrator.sh:132:    local after_snapshot="$2"
.claude/hooks/debug-orchestrator.sh:133:
.claude/hooks/debug-orchestrator.sh:134:    if [[ ! -f "$before_snapshot" || ! -f "$after_snapshot" ]]; then
.claude/hooks/debug-orchestrator.sh:135:        echo '{"regression_detected":false,"error":"Snapshots not found"}'
.claude/hooks/debug-orchestrator.sh:136:        return 1
.claude/hooks/debug-orchestrator.sh:137:    fi
.claude/hooks/debug-orchestrator.sh:138:
.claude/hooks/debug-orchestrator.sh:139:    local before_passed
.claude/hooks/debug-orchestrator.sh:140:    local after_passed
.claude/hooks/debug-orchestrator.sh:141:    before_passed=$(jq -r '.tests_passed' "$before_snapshot")
.claude/hooks/debug-orchestrator.sh:142:    after_passed=$(jq -r '.tests_passed' "$after_snapshot")
.claude/hooks/debug-orchestrator.sh:143:
.claude/hooks/debug-orchestrator.sh:144:    local regression_detected="false"
.claude/hooks/debug-orchestrator.sh:145:    local regression_type="none"
.claude/hooks/debug-orchestrator.sh:146:    local details=""
.claude/hooks/debug-orchestrator.sh:147:
.claude/hooks/debug-orchestrator.sh:148:    if [[ "$before_passed" == "true" && "$after_passed" == "false" ]]; then
.claude/hooks/debug-orchestrator.sh:149:        regression_detected="true"
.claude/hooks/debug-orchestrator.sh:150:        regression_type="test_failure"
.claude/hooks/debug-orchestrator.sh:151:        details="Tests passed before fix, but fail after fix"
.claude/hooks/debug-orchestrator.sh:152:        log "REGRESSION DETECTED: Tests failing after fix"
.claude/hooks/debug-orchestrator.sh:153:
.claude/hooks/debug-orchestrator.sh:154:        # Record regression
.claude/hooks/debug-orchestrator.sh:155:        jq -n \
.claude/hooks/debug-orchestrator.sh:156:            --arg type "$regression_type" \
.claude/hooks/debug-orchestrator.sh:157:            --arg details "$details" \
.claude/hooks/debug-orchestrator.sh:158:            --arg before_id "$(jq -r '.snapshot_id' "$before_snapshot")" \
.claude/hooks/debug-orchestrator.sh:159:            --arg after_id "$(jq -r '.snapshot_id' "$after_snapshot")" \
.claude/hooks/debug-orchestrator.sh:160:            --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
.claude/hooks/debug-orchestrator.sh:161:            '{
.claude/hooks/debug-orchestrator.sh:162:                timestamp: $ts,
.claude/hooks/debug-orchestrator.sh:163:                regression_type: $type,
.claude/hooks/debug-orchestrator.sh:164:                details: $details,
.claude/hooks/debug-orchestrator.sh:165:                before_snapshot: $before_id,
.claude/hooks/debug-orchestrator.sh:166:                after_snapshot: $after_id
.claude/hooks/debug-orchestrator.sh:167:            }' >> "$REGRESSION_LOG"
.claude/hooks/debug-orchestrator.sh:168:    fi
.claude/hooks/debug-orchestrator.sh:169:
.claude/hooks/debug-orchestrator.sh:170:    jq -n \
.claude/hooks/debug-orchestrator.sh:171:        --argjson regression "$regression_detected" \
.claude/hooks/debug-orchestrator.sh:172:        --arg type "$regression_type" \
.claude/hooks/debug-orchestrator.sh:173:        --arg details "$details" \
.claude/hooks/debug-orchestrator.sh:174:        '{regression_detected: $regression, regression_type: $type, details: $details}'
.claude/hooks/debug-orchestrator.sh:175:}
.claude/hooks/debug-orchestrator.sh:176:
.claude/hooks/debug-orchestrator.sh:177:# =============================================================================
.claude/hooks/debug-orchestrator.sh:178:# SELF-HEALING FIX ORCHESTRATION
.claude/hooks/debug-orchestrator.sh:179:# =============================================================================
.claude/hooks/debug-orchestrator.sh:180:
.claude/hooks/debug-orchestrator.sh:181:smart_debug() {
.claude/hooks/debug-orchestrator.sh:182:    local bug_description="$1"
.claude/hooks/debug-orchestrator.sh:183:    local bug_type="${2:-general}"
.claude/hooks/debug-orchestrator.sh:184:    local test_command="${3:-echo 'No tests configured'}"
.claude/hooks/debug-orchestrator.sh:185:    local context="${4:-}"
.claude/hooks/debug-orchestrator.sh:186:
.claude/hooks/debug-orchestrator.sh:187:    log "Starting smart debug: $bug_description"
.claude/hooks/debug-orchestrator.sh:188:
.claude/hooks/debug-orchestrator.sh:189:    # Step 1: Create BEFORE snapshot
.claude/hooks/debug-orchestrator.sh:190:    local before_snapshot_id="before_$(date +%s)"
.claude/hooks/debug-orchestrator.sh:191:    local before_snapshot
.claude/hooks/debug-orchestrator.sh:192:    before_snapshot=$(create_test_snapshot "$before_snapshot_id" "$test_command" "Before fix: $bug_description")
.claude/hooks/debug-orchestrator.sh:193:
.claude/hooks/debug-orchestrator.sh:194:    # Step 2: Search for similar bug fixes in memory
.claude/hooks/debug-orchestrator.sh:195:    log "Searching bug fix memory for similar bugs..."
.claude/hooks/debug-orchestrator.sh:196:    local similar_fixes
.claude/hooks/debug-orchestrator.sh:197:    similar_fixes=$(search_similar_bugs "$bug_description" 5)
.claude/hooks/debug-orchestrator.sh:198:    local similar_count
.claude/hooks/debug-orchestrator.sh:199:    similar_count=$(echo "$similar_fixes" | jq -r '.count')
.claude/hooks/debug-orchestrator.sh:200:
.claude/hooks/debug-orchestrator.sh:201:    if [[ "$similar_count" -gt 0 ]]; then
.claude/hooks/debug-orchestrator.sh:202:        log "Found $similar_count similar bug fixes in memory"
.claude/hooks/debug-orchestrator.sh:203:    fi
.claude/hooks/debug-orchestrator.sh:204:
.claude/hooks/debug-orchestrator.sh:205:    # Step 3: Search GitHub for similar issues (if GitHub MCP available)
.claude/hooks/debug-orchestrator.sh:206:    local github_solutions=""
.claude/hooks/debug-orchestrator.sh:207:    if command -v gh &> /dev/null; then
.claude/hooks/debug-orchestrator.sh:208:        log "Searching GitHub for similar issues..."
.claude/hooks/debug-orchestrator.sh:209:        # Use gh CLI to search (fallback if GitHub MCP not available)
.claude/hooks/debug-orchestrator.sh:210:        github_solutions=$(gh search issues "$bug_description" --limit 3 --json title,url 2>/dev/null || echo '[]')
.claude/hooks/debug-orchestrator.sh:211:    fi
.claude/hooks/debug-orchestrator.sh:212:
.claude/hooks/debug-orchestrator.sh:213:    # Step 4: Generate intelligent fix prompt
.claude/hooks/debug-orchestrator.sh:214:    local fix_prompt
.claude/hooks/debug-orchestrator.sh:215:    fix_prompt=$(jq -n \
.claude/hooks/debug-orchestrator.sh:216:        --arg bug "$bug_description" \
.claude/hooks/debug-orchestrator.sh:217:        --arg type "$bug_type" \
.claude/hooks/debug-orchestrator.sh:218:        --arg context "$context" \
.claude/hooks/debug-orchestrator.sh:219:        --argjson similar "$similar_fixes" \
.claude/hooks/debug-orchestrator.sh:220:        --arg github "$github_solutions" \
.claude/hooks/debug-orchestrator.sh:221:        '{
.claude/hooks/debug-orchestrator.sh:222:            task: "Fix bug with regression awareness",
.claude/hooks/debug-orchestrator.sh:223:            bug_description: $bug,
.claude/hooks/debug-orchestrator.sh:224:            bug_type: $type,
.claude/hooks/debug-orchestrator.sh:225:            context: $context,
.claude/hooks/debug-orchestrator.sh:226:            similar_fixes_from_memory: $similar,
.claude/hooks/debug-orchestrator.sh:227:            github_solutions: $github,
.claude/hooks/debug-orchestrator.sh:228:            instructions: [
.claude/hooks/debug-orchestrator.sh:229:                "1. Review similar fixes from memory to avoid repeating failed approaches",
.claude/hooks/debug-orchestrator.sh:230:                "2. Consider GitHub solutions if available",
.claude/hooks/debug-orchestrator.sh:231:                "3. Make the fix incrementally",
.claude/hooks/debug-orchestrator.sh:232:                "4. Think about potential side effects on other components",
.claude/hooks/debug-orchestrator.sh:233:                "5. Run tests after fix to detect regressions"
.claude/hooks/debug-orchestrator.sh:234:            ]
.claude/hooks/debug-orchestrator.sh:235:        }')
.claude/hooks/debug-orchestrator.sh:236:
.claude/hooks/debug-orchestrator.sh:237:    log "Fix prompt generated with context from memory and GitHub"
.claude/hooks/debug-orchestrator.sh:238:
.claude/hooks/debug-orchestrator.sh:239:    # Return orchestration data for Claude to use
.claude/hooks/debug-orchestrator.sh:240:    jq -n \
.claude/hooks/debug-orchestrator.sh:241:        --arg bug "$bug_description" \
.claude/hooks/debug-orchestrator.sh:242:        --arg before_snapshot_id "$before_snapshot_id" \
.claude/hooks/debug-orchestrator.sh:243:        --argjson similar "$similar_fixes" \
.claude/hooks/debug-orchestrator.sh:244:        --arg github "$github_solutions" \
.claude/hooks/debug-orchestrator.sh:245:        --argjson fix_prompt "$fix_prompt" \
.claude/hooks/debug-orchestrator.sh:246:        '{
.claude/hooks/debug-orchestrator.sh:247:            bug: $bug,
.claude/hooks/debug-orchestrator.sh:248:            before_snapshot: $before_snapshot_id,
.claude/hooks/debug-orchestrator.sh:249:            similar_fixes_count: ($similar.count),
.claude/hooks/debug-orchestrator.sh:250:            similar_fixes: $similar,
.claude/hooks/debug-orchestrator.sh:251:            github_solutions: $github,
.claude/hooks/debug-orchestrator.sh:252:            fix_prompt: $fix_prompt,
.claude/hooks/debug-orchestrator.sh:253:            next_steps: [
.claude/hooks/debug-orchestrator.sh:254:                "1. Review similar fixes and GitHub solutions",
.claude/hooks/debug-orchestrator.sh:255:                "2. Apply fix incrementally",
.claude/hooks/debug-orchestrator.sh:256:                "3. Run: debug-orchestrator.sh verify-fix <snapshot_id> <test_command>",
.claude/hooks/debug-orchestrator.sh:257:                "4. If regression detected, will auto-recommend revert"
.claude/hooks/debug-orchestrator.sh:258:            ]
.claude/hooks/debug-orchestrator.sh:259:        }'
.claude/hooks/debug-orchestrator.sh:260:}
.claude/hooks/debug-orchestrator.sh:261:
.claude/hooks/debug-orchestrator.sh:262:verify_fix() {
.claude/hooks/debug-orchestrator.sh:263:    local before_snapshot_id="$1"
.claude/hooks/debug-orchestrator.sh:264:    local test_command="$2"
.claude/hooks/debug-orchestrator.sh:265:    local fix_description="${3:-Fix applied}"
.claude/hooks/debug-orchestrator.sh:266:
.claude/hooks/debug-orchestrator.sh:267:    log "Verifying fix against snapshot: $before_snapshot_id"
.claude/hooks/debug-orchestrator.sh:268:
.claude/hooks/debug-orchestrator.sh:269:    # Create AFTER snapshot
.claude/hooks/debug-orchestrator.sh:270:    local after_snapshot_id="after_$(date +%s)"
.claude/hooks/debug-orchestrator.sh:271:    local after_snapshot
.claude/hooks/debug-orchestrator.sh:272:    after_snapshot=$(create_test_snapshot "$after_snapshot_id" "$test_command" "After fix")
.claude/hooks/debug-orchestrator.sh:273:
.claude/hooks/debug-orchestrator.sh:274:    local before_snapshot_file="${TEST_SNAPSHOTS}/${before_snapshot_id}.json"
.claude/hooks/debug-orchestrator.sh:275:
.claude/hooks/debug-orchestrator.sh:276:    # Detect regression
.claude/hooks/debug-orchestrator.sh:277:    local regression_result
.claude/hooks/debug-orchestrator.sh:278:    regression_result=$(detect_regression "$before_snapshot_file" "$after_snapshot")
.claude/hooks/debug-orchestrator.sh:279:
.claude/hooks/debug-orchestrator.sh:280:    local regression_detected
.claude/hooks/debug-orchestrator.sh:281:    regression_detected=$(echo "$regression_result" | jq -r '.regression_detected')
.claude/hooks/debug-orchestrator.sh:282:
.claude/hooks/debug-orchestrator.sh:283:    if [[ "$regression_detected" == "true" ]]; then
.claude/hooks/debug-orchestrator.sh:284:        log "REGRESSION DETECTED: Fix broke something else!"
.claude/hooks/debug-orchestrator.sh:285:
.claude/hooks/debug-orchestrator.sh:286:        # Return recommendation to revert
.claude/hooks/debug-orchestrator.sh:287:        jq -n \
.claude/hooks/debug-orchestrator.sh:288:            --arg status "regression_detected" \
.claude/hooks/debug-orchestrator.sh:289:            --arg message "Fix introduced a regression - tests passing before, failing after" \
.claude/hooks/debug-orchestrator.sh:290:            --argjson regression "$regression_result" \
.claude/hooks/debug-orchestrator.sh:291:            '{
.claude/hooks/debug-orchestrator.sh:292:                status: $status,
.claude/hooks/debug-orchestrator.sh:293:                message: $message,
.claude/hooks/debug-orchestrator.sh:294:                regression: $regression,
.claude/hooks/debug-orchestrator.sh:295:                recommendation: "REVERT THE FIX",
.claude/hooks/debug-orchestrator.sh:296:                actions: [
.claude/hooks/debug-orchestrator.sh:297:                    "1. Git revert the changes",
.claude/hooks/debug-orchestrator.sh:298:                    "2. Analyze test failures",
.claude/hooks/debug-orchestrator.sh:299:                    "3. Try alternative approach using similar_fixes from memory"
.claude/hooks/debug-orchestrator.sh:300:                ]
.claude/hooks/debug-orchestrator.sh:301:            }'
.claude/hooks/debug-orchestrator.sh:302:    else
.claude/hooks/debug-orchestrator.sh:303:        log "No regression detected - fix looks good!"
.claude/hooks/debug-orchestrator.sh:304:
.claude/hooks/debug-orchestrator.sh:305:        # Record successful fix to memory
.claude/hooks/debug-orchestrator.sh:306:        record_bug_fix "Bug fix verified" "general" "$fix_description" "unknown" "true" "passed"
.claude/hooks/debug-orchestrator.sh:307:
.claude/hooks/debug-orchestrator.sh:308:        jq -n \
.claude/hooks/debug-orchestrator.sh:309:            --arg status "success" \
.claude/hooks/debug-orchestrator.sh:310:            --arg message "Fix verified - no regressions detected" \
.claude/hooks/debug-orchestrator.sh:311:            '{
.claude/hooks/debug-orchestrator.sh:312:                status: $status,
.claude/hooks/debug-orchestrator.sh:313:                message: $message,
.claude/hooks/debug-orchestrator.sh:314:                tests_passed: true,
.claude/hooks/debug-orchestrator.sh:315:                recorded_to_memory: true
.claude/hooks/debug-orchestrator.sh:316:            }'
.claude/hooks/debug-orchestrator.sh:317:    fi
.claude/hooks/debug-orchestrator.sh:318:}
.claude/hooks/debug-orchestrator.sh:319:
.claude/hooks/debug-orchestrator.sh:320:# =============================================================================
.claude/hooks/debug-orchestrator.sh:321:# UI TESTING WITH CLAUDE IN CHROME
.claude/hooks/debug-orchestrator.sh:322:# =============================================================================
.claude/hooks/debug-orchestrator.sh:323:
.claude/hooks/debug-orchestrator.sh:324:ui_test_workflow() {
.claude/hooks/debug-orchestrator.sh:325:    local test_scenario="$1"
.claude/hooks/debug-orchestrator.sh:326:    local url="$2"
.claude/hooks/debug-orchestrator.sh:327:    local expected_outcome="$3"
.claude/hooks/debug-orchestrator.sh:328:
.claude/hooks/debug-orchestrator.sh:329:    log "Starting UI test workflow: $test_scenario"
.claude/hooks/debug-orchestrator.sh:330:
.claude/hooks/debug-orchestrator.sh:331:    # Generate test instructions for Claude in Chrome
.claude/hooks/debug-orchestrator.sh:332:    jq -n \
.claude/hooks/debug-orchestrator.sh:333:        --arg scenario "$test_scenario" \
.claude/hooks/debug-orchestrator.sh:334:        --arg url "$url" \
.claude/hooks/debug-orchestrator.sh:335:        --arg expected "$expected_outcome" \
.claude/hooks/debug-orchestrator.sh:336:        '{
.claude/hooks/debug-orchestrator.sh:337:            ui_test: {
.claude/hooks/debug-orchestrator.sh:338:                scenario: $scenario,
.claude/hooks/debug-orchestrator.sh:339:                url: $url,
.claude/hooks/debug-orchestrator.sh:340:                expected_outcome: $expected,
.claude/hooks/debug-orchestrator.sh:341:                instructions: [
.claude/hooks/debug-orchestrator.sh:342:                    "1. Use Claude in Chrome MCP to open browser",
.claude/hooks/debug-orchestrator.sh:343:                    "2. Navigate to URL",
.claude/hooks/debug-orchestrator.sh:344:                    "3. Perform test actions (click, type, etc.)",
.claude/hooks/debug-orchestrator.sh:345:                    "4. Take screenshots at each step",
.claude/hooks/debug-orchestrator.sh:346:                    "5. Verify expected outcome",
.claude/hooks/debug-orchestrator.sh:347:                    "6. Report pass/fail with evidence"
.claude/hooks/debug-orchestrator.sh:348:                ],
.claude/hooks/debug-orchestrator.sh:349:                tools_needed: [
.claude/hooks/debug-orchestrator.sh:350:                    "mcp__claude-in-chrome__tabs_create_mcp",
.claude/hooks/debug-orchestrator.sh:351:                    "mcp__claude-in-chrome__navigate",
.claude/hooks/debug-orchestrator.sh:352:                    "mcp__claude-in-chrome__computer (for clicks/typing)",
.claude/hooks/debug-orchestrator.sh:353:                    "mcp__claude-in-chrome__read_page (verify state)",
.claude/hooks/debug-orchestrator.sh:354:                    "mcp__claude-in-chrome__computer (screenshot action)"
.claude/hooks/debug-orchestrator.sh:355:                ]
.claude/hooks/debug-orchestrator.sh:356:            },
.claude/hooks/debug-orchestrator.sh:357:            note: "Claude in Chrome MCP is already installed and available for browser automation"
.claude/hooks/debug-orchestrator.sh:358:        }'
.claude/hooks/debug-orchestrator.sh:359:}
.claude/hooks/debug-orchestrator.sh:360:
.claude/hooks/debug-orchestrator.sh:361:# =============================================================================
.claude/hooks/debug-orchestrator.sh:362:# COMMAND INTERFACE
.claude/hooks/debug-orchestrator.sh:363:# =============================================================================
.claude/hooks/debug-orchestrator.sh:364:
.claude/hooks/debug-orchestrator.sh:365:case "${1:-help}" in
.claude/hooks/debug-orchestrator.sh:366:    smart-debug)
.claude/hooks/debug-orchestrator.sh:367:        smart_debug "${2:-bug description}" "${3:-general}" "${4:-echo 'No tests'}" "${5:-}"
.claude/hooks/debug-orchestrator.sh:368:        ;;
.claude/hooks/debug-orchestrator.sh:369:    verify-fix)
.claude/hooks/debug-orchestrator.sh:370:        verify_fix "${2:-before_snapshot}" "${3:-echo 'No tests'}" "${4:-Fix applied}"
.claude/hooks/debug-orchestrator.sh:371:        ;;
.claude/hooks/debug-orchestrator.sh:372:    record-fix)
.claude/hooks/debug-orchestrator.sh:373:        record_bug_fix "${2:-bug}" "${3:-general}" "${4:-fix}" "${5:-files}" "${6:-true}" "${7:-passed}"
.claude/hooks/debug-orchestrator.sh:374:        ;;
.claude/hooks/debug-orchestrator.sh:375:    search-similar)
.claude/hooks/debug-orchestrator.sh:376:        search_similar_bugs "${2:-search query}" "${3:-5}"
.claude/hooks/debug-orchestrator.sh:377:        ;;
.claude/hooks/debug-orchestrator.sh:378:    snapshot)
.claude/hooks/debug-orchestrator.sh:379:        create_test_snapshot "${2:-snapshot_$(date +%s)}" "${3:-echo 'No tests'}" "${4:-Test snapshot}"
.claude/hooks/debug-orchestrator.sh:380:        ;;
.claude/hooks/debug-orchestrator.sh:381:    detect-regression)
.claude/hooks/debug-orchestrator.sh:382:        detect_regression "${2:-before_snapshot_file}" "${3:-after_snapshot_file}"
.claude/hooks/debug-orchestrator.sh:383:        ;;
.claude/hooks/debug-orchestrator.sh:384:    ui-test)
.claude/hooks/debug-orchestrator.sh:385:        ui_test_workflow "${2:-test scenario}" "${3:-http://localhost:3000}" "${4:-expected outcome}"
.claude/hooks/debug-orchestrator.sh:386:        ;;
.claude/hooks/debug-orchestrator.sh:387:    memory-stats)
.claude/hooks/debug-orchestrator.sh:388:        if [[ -f "$BUG_FIX_MEMORY" ]]; then
.claude/hooks/debug-orchestrator.sh:389:            jq -s '{
.claude/hooks/debug-orchestrator.sh:390:                total_fixes: length,
.claude/hooks/debug-orchestrator.sh:391:                successful_fixes: (map(select(.success == true)) | length),
.claude/hooks/debug-orchestrator.sh:392:                recent_fixes: (.[-10:] | map({bug: .bug_description, success: .success, timestamp: .timestamp}))
.claude/hooks/debug-orchestrator.sh:393:            }' "$BUG_FIX_MEMORY"
.claude/hooks/debug-orchestrator.sh:394:        else
.claude/hooks/debug-orchestrator.sh:395:            echo '{"total_fixes":0,"successful_fixes":0,"recent_fixes":[]}'
.claude/hooks/debug-orchestrator.sh:396:        fi
.claude/hooks/debug-orchestrator.sh:397:        ;;
.claude/hooks/debug-orchestrator.sh:398:    help|*)
.claude/hooks/debug-orchestrator.sh:399:        cat << 'EOF'
.claude/hooks/debug-orchestrator.sh:400:Debug Orchestrator - Intelligent Debugging System
.claude/hooks/debug-orchestrator.sh:401:
.claude/hooks/debug-orchestrator.sh:402:Solves the problem: "Fixing one thing breaks another"
.claude/hooks/debug-orchestrator.sh:403:
.claude/hooks/debug-orchestrator.sh:404:USAGE:
.claude/hooks/debug-orchestrator.sh:405:  debug-orchestrator.sh <command> [args]
.claude/hooks/debug-orchestrator.sh:406:
.claude/hooks/debug-orchestrator.sh:407:COMMANDS:
.claude/hooks/debug-orchestrator.sh:408:  smart-debug <bug_desc> [bug_type] [test_command] [context]
.claude/hooks/debug-orchestrator.sh:409:    - Intelligent debugging with memory and regression awareness
.claude/hooks/debug-orchestrator.sh:410:    - Searches similar bugs in memory
.claude/hooks/debug-orchestrator.sh:411:    - Searches GitHub for solutions
.claude/hooks/debug-orchestrator.sh:412:    - Creates before snapshot for regression detection
.claude/hooks/debug-orchestrator.sh:413:
.claude/hooks/debug-orchestrator.sh:414:  verify-fix <before_snapshot_id> <test_command> [fix_desc]
.claude/hooks/debug-orchestrator.sh:415:    - Verifies fix didn't introduce regression
.claude/hooks/debug-orchestrator.sh:416:    - Compares before/after test results
.claude/hooks/debug-orchestrator.sh:417:    - Auto-recommends revert if regression detected
.claude/hooks/debug-orchestrator.sh:418:    - Records successful fixes to memory
.claude/hooks/debug-orchestrator.sh:419:
.claude/hooks/debug-orchestrator.sh:420:  record-fix <bug> <type> <fix> <files> <success> [tests]
.claude/hooks/debug-orchestrator.sh:421:    - Manually record a bug fix to memory
.claude/hooks/debug-orchestrator.sh:422:    - Builds knowledge base of successful fixes
.claude/hooks/debug-orchestrator.sh:423:
.claude/hooks/debug-orchestrator.sh:424:  search-similar <query> [limit]
.claude/hooks/debug-orchestrator.sh:425:    - Search bug fix memory for similar bugs
.claude/hooks/debug-orchestrator.sh:426:    - Returns relevant fixes with descriptions
.claude/hooks/debug-orchestrator.sh:427:
.claude/hooks/debug-orchestrator.sh:428:  snapshot <id> <test_command> [description]
.claude/hooks/debug-orchestrator.sh:429:    - Create test snapshot for comparison
.claude/hooks/debug-orchestrator.sh:430:    - Captures test output and exit code
.claude/hooks/debug-orchestrator.sh:431:
.claude/hooks/debug-orchestrator.sh:432:  ui-test <scenario> <url> <expected_outcome>
.claude/hooks/debug-orchestrator.sh:433:    - Generate UI test workflow using Claude in Chrome
.claude/hooks/debug-orchestrator.sh:434:    - Automated browser testing
.claude/hooks/debug-orchestrator.sh:435:
.claude/hooks/debug-orchestrator.sh:436:  memory-stats
.claude/hooks/debug-orchestrator.sh:437:    - View bug fix memory statistics
.claude/hooks/debug-orchestrator.sh:438:    - See recent successful fixes
.claude/hooks/debug-orchestrator.sh:439:
.claude/hooks/debug-orchestrator.sh:440:WORKFLOW EXAMPLE:
.claude/hooks/debug-orchestrator.sh:441:  # 1. Start debugging with memory awareness
.claude/hooks/debug-orchestrator.sh:442:  debug-orchestrator.sh smart-debug "Login button not working" ui "npm test"
.claude/hooks/debug-orchestrator.sh:443:
.claude/hooks/debug-orchestrator.sh:444:  # 2. Apply fix based on suggestions from similar bugs
.claude/hooks/debug-orchestrator.sh:445:  # (make your code changes)
.claude/hooks/debug-orchestrator.sh:446:
.claude/hooks/debug-orchestrator.sh:447:  # 3. Verify fix with regression detection
.claude/hooks/debug-orchestrator.sh:448:  debug-orchestrator.sh verify-fix before_1234567 "npm test" "Fixed login handler"
.claude/hooks/debug-orchestrator.sh:449:
.claude/hooks/debug-orchestrator.sh:450:  # If regression detected, will recommend revert
.claude/hooks/debug-orchestrator.sh:451:  # If clean, records to memory for future reference
.claude/hooks/debug-orchestrator.sh:452:
.claude/hooks/debug-orchestrator.sh:453:UI TESTING EXAMPLE:
.claude/hooks/debug-orchestrator.sh:454:  # Generate UI test workflow
.claude/hooks/debug-orchestrator.sh:455:  debug-orchestrator.sh ui-test "User login flow" "http://localhost:3000/login" "Dashboard page loads"
.claude/hooks/debug-orchestrator.sh:456:
.claude/hooks/debug-orchestrator.sh:457:  # Use with Claude in Chrome MCP for automated testing
.claude/hooks/debug-orchestrator.sh:458:  # Takes screenshots, verifies state, reports results
.claude/hooks/debug-orchestrator.sh:459:
.claude/hooks/debug-orchestrator.sh:460:KEY FEATURES:
.claude/hooks/debug-orchestrator.sh:461:   Bug fix memory bank (learns from past fixes)
.claude/hooks/debug-orchestrator.sh:462:   Regression detection (catches when fixes break other things)
.claude/hooks/debug-orchestrator.sh:463:   GitHub solution search (finds similar issues online)
.claude/hooks/debug-orchestrator.sh:464:   Self-healing recommendations (auto-suggests revert)
.claude/hooks/debug-orchestrator.sh:465:   UI testing with browser automation (Claude in Chrome)
.claude/hooks/debug-orchestrator.sh:466:   Test snapshots (before/after comparison)
.claude/hooks/debug-orchestrator.sh:467:
.claude/hooks/debug-orchestrator.sh:468:INTEGRATIONS:
.claude/hooks/debug-orchestrator.sh:469:   Memory Manager (stores patterns)
.claude/hooks/debug-orchestrator.sh:470:   GitHub MCP (searches similar issues)
.claude/hooks/debug-orchestrator.sh:471:   Claude in Chrome MCP (browser automation)
.claude/hooks/debug-orchestrator.sh:472:   Reinforcement Learning (learns what works)
.claude/hooks/debug-orchestrator.sh:473:
.claude/hooks/debug-orchestrator.sh:474:EOF
.claude/hooks/debug-orchestrator.sh:475:        ;;
.claude/hooks/debug-orchestrator.sh:476:esac
.claude/hooks/.claude/checkpoint-state.json:1:{
.claude/hooks/.claude/checkpoint-state.json:2:  "last_checkpoint": 0,
.claude/hooks/.claude/checkpoint-state.json:3:  "changes_since": 32,
.claude/hooks/.claude/checkpoint-state.json:4:  "files_modified": [
.claude/hooks/.claude/checkpoint-state.json:5:    ""
.claude/hooks/.claude/checkpoint-state.json:6:  ]
.claude/hooks/.claude/checkpoint-state.json:7:}
.claude/hooks/plan-execute.sh:1:#!/bin/bash
.claude/hooks/plan-execute.sh:2:# Plan and Execute - Task decomposition and autonomous execution
.claude/hooks/plan-execute.sh:3:# Based on patterns from: langchainjs PlanAndExecuteAgentExecutor, n8n, AgentGPT, obsidian-copilot
.claude/hooks/plan-execute.sh:4:
.claude/hooks/plan-execute.sh:5:set -uo pipefail
.claude/hooks/plan-execute.sh:6:
.claude/hooks/plan-execute.sh:7:PLAN_DIR="${HOME}/.claude/plans"
.claude/hooks/plan-execute.sh:8:CURRENT_PLAN="$PLAN_DIR/current.json"
.claude/hooks/plan-execute.sh:9:PLAN_HISTORY="$PLAN_DIR/history.json"
.claude/hooks/plan-execute.sh:10:LOG_FILE="${HOME}/.claude/plan-execute.log"
.claude/hooks/plan-execute.sh:11:
.claude/hooks/plan-execute.sh:12:log() {
.claude/hooks/plan-execute.sh:13:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/plan-execute.sh:14:}
.claude/hooks/plan-execute.sh:15:
.claude/hooks/plan-execute.sh:16:init_plans() {
.claude/hooks/plan-execute.sh:17:    mkdir -p "$PLAN_DIR"
.claude/hooks/plan-execute.sh:18:    if [[ ! -f "$PLAN_HISTORY" ]]; then
.claude/hooks/plan-execute.sh:19:        echo '{"plans":[]}' > "$PLAN_HISTORY"
.claude/hooks/plan-execute.sh:20:    fi
.claude/hooks/plan-execute.sh:21:}
.claude/hooks/plan-execute.sh:22:
.claude/hooks/plan-execute.sh:23:# =============================================================================
.claude/hooks/plan-execute.sh:24:# PLAN CREATION (from langchainjs patterns)
.claude/hooks/plan-execute.sh:25:# =============================================================================
.claude/hooks/plan-execute.sh:26:
.claude/hooks/plan-execute.sh:27:# Create a new plan for a goal
.claude/hooks/plan-execute.sh:28:create_plan() {
.claude/hooks/plan-execute.sh:29:    local goal="$1"
.claude/hooks/plan-execute.sh:30:    local context="${2:-}"
.claude/hooks/plan-execute.sh:31:
.claude/hooks/plan-execute.sh:32:    init_plans
.claude/hooks/plan-execute.sh:33:
.claude/hooks/plan-execute.sh:34:    local plan_id
.claude/hooks/plan-execute.sh:35:    plan_id="plan_$(date +%s)"
.claude/hooks/plan-execute.sh:36:
.claude/hooks/plan-execute.sh:37:    local timestamp
.claude/hooks/plan-execute.sh:38:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/plan-execute.sh:39:
.claude/hooks/plan-execute.sh:40:    cat > "$CURRENT_PLAN" << EOF
.claude/hooks/plan-execute.sh:41:{
.claude/hooks/plan-execute.sh:42:    "id": "$plan_id",
.claude/hooks/plan-execute.sh:43:    "goal": "$goal",
.claude/hooks/plan-execute.sh:44:    "context": "$context",
.claude/hooks/plan-execute.sh:45:    "status": "planning",
.claude/hooks/plan-execute.sh:46:    "createdAt": "$timestamp",
.claude/hooks/plan-execute.sh:47:    "steps": [],
.claude/hooks/plan-execute.sh:48:    "currentStepIndex": 0,
.claude/hooks/plan-execute.sh:49:    "completedSteps": [],
.claude/hooks/plan-execute.sh:50:    "failedSteps": [],
.claude/hooks/plan-execute.sh:51:    "replanning": {
.claude/hooks/plan-execute.sh:52:        "count": 0,
.claude/hooks/plan-execute.sh:53:        "maxReplans": 3,
.claude/hooks/plan-execute.sh:54:        "reasons": []
.claude/hooks/plan-execute.sh:55:    }
.claude/hooks/plan-execute.sh:56:}
.claude/hooks/plan-execute.sh:57:EOF
.claude/hooks/plan-execute.sh:58:
.claude/hooks/plan-execute.sh:59:    log "Created plan: $plan_id for goal: $goal"
.claude/hooks/plan-execute.sh:60:    echo "$plan_id"
.claude/hooks/plan-execute.sh:61:}
.claude/hooks/plan-execute.sh:62:
.claude/hooks/plan-execute.sh:63:# Add a step to the plan
.claude/hooks/plan-execute.sh:64:add_step() {
.claude/hooks/plan-execute.sh:65:    local description="$1"
.claude/hooks/plan-execute.sh:66:    local tool="${2:-shell}"
.claude/hooks/plan-execute.sh:67:    local args="${3:-}"
.claude/hooks/plan-execute.sh:68:    local dependencies="${4:-}"
.claude/hooks/plan-execute.sh:69:
.claude/hooks/plan-execute.sh:70:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:71:        log "No active plan"
.claude/hooks/plan-execute.sh:72:        return 1
.claude/hooks/plan-execute.sh:73:    fi
.claude/hooks/plan-execute.sh:74:
.claude/hooks/plan-execute.sh:75:    local temp_file
.claude/hooks/plan-execute.sh:76:    temp_file=$(mktemp)
.claude/hooks/plan-execute.sh:77:
.claude/hooks/plan-execute.sh:78:    local step_id
.claude/hooks/plan-execute.sh:79:    step_id="step_$(date +%s%N | cut -c1-13)"
.claude/hooks/plan-execute.sh:80:
.claude/hooks/plan-execute.sh:81:    jq --arg id "$step_id" \
.claude/hooks/plan-execute.sh:82:       --arg desc "$description" \
.claude/hooks/plan-execute.sh:83:       --arg tool "$tool" \
.claude/hooks/plan-execute.sh:84:       --arg args "$args" \
.claude/hooks/plan-execute.sh:85:       --arg deps "$dependencies" \
.claude/hooks/plan-execute.sh:86:       '
.claude/hooks/plan-execute.sh:87:       .steps += [{
.claude/hooks/plan-execute.sh:88:           id: $id,
.claude/hooks/plan-execute.sh:89:           description: $desc,
.claude/hooks/plan-execute.sh:90:           tool: $tool,
.claude/hooks/plan-execute.sh:91:           args: $args,
.claude/hooks/plan-execute.sh:92:           dependencies: ($deps | split(",") | map(select(. != ""))),
.claude/hooks/plan-execute.sh:93:           status: "pending",
.claude/hooks/plan-execute.sh:94:           result: null
.claude/hooks/plan-execute.sh:95:       }]
.claude/hooks/plan-execute.sh:96:       ' "$CURRENT_PLAN" > "$temp_file"
.claude/hooks/plan-execute.sh:97:
.claude/hooks/plan-execute.sh:98:    mv "$temp_file" "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:99:
.claude/hooks/plan-execute.sh:100:    log "Added step: $description (id: $step_id)"
.claude/hooks/plan-execute.sh:101:    echo "$step_id"
.claude/hooks/plan-execute.sh:102:}
.claude/hooks/plan-execute.sh:103:
.claude/hooks/plan-execute.sh:104:# Decompose a complex task into steps
.claude/hooks/plan-execute.sh:105:decompose_task() {
.claude/hooks/plan-execute.sh:106:    local task="$1"
.claude/hooks/plan-execute.sh:107:    local task_type="${2:-general}"
.claude/hooks/plan-execute.sh:108:
.claude/hooks/plan-execute.sh:109:    # Predefined decomposition patterns
.claude/hooks/plan-execute.sh:110:    case "$task_type" in
.claude/hooks/plan-execute.sh:111:        feature)
.claude/hooks/plan-execute.sh:112:            echo "1. Analyze requirements and existing code"
.claude/hooks/plan-execute.sh:113:            echo "2. Design implementation approach"
.claude/hooks/plan-execute.sh:114:            echo "3. Write core functionality"
.claude/hooks/plan-execute.sh:115:            echo "4. Add error handling"
.claude/hooks/plan-execute.sh:116:            echo "5. Write tests"
.claude/hooks/plan-execute.sh:117:            echo "6. Run lint and typecheck"
.claude/hooks/plan-execute.sh:118:            echo "7. Run tests"
.claude/hooks/plan-execute.sh:119:            echo "8. Document changes"
.claude/hooks/plan-execute.sh:120:            ;;
.claude/hooks/plan-execute.sh:121:        bugfix)
.claude/hooks/plan-execute.sh:122:            echo "1. Reproduce the bug"
.claude/hooks/plan-execute.sh:123:            echo "2. Identify root cause"
.claude/hooks/plan-execute.sh:124:            echo "3. Design fix"
.claude/hooks/plan-execute.sh:125:            echo "4. Implement fix"
.claude/hooks/plan-execute.sh:126:            echo "5. Verify fix resolves issue"
.claude/hooks/plan-execute.sh:127:            echo "6. Run regression tests"
.claude/hooks/plan-execute.sh:128:            echo "7. Document fix"
.claude/hooks/plan-execute.sh:129:            ;;
.claude/hooks/plan-execute.sh:130:        refactor)
.claude/hooks/plan-execute.sh:131:            echo "1. Identify code to refactor"
.claude/hooks/plan-execute.sh:132:            echo "2. Ensure test coverage exists"
.claude/hooks/plan-execute.sh:133:            echo "3. Make incremental changes"
.claude/hooks/plan-execute.sh:134:            echo "4. Run tests after each change"
.claude/hooks/plan-execute.sh:135:            echo "5. Verify behavior unchanged"
.claude/hooks/plan-execute.sh:136:            echo "6. Update documentation"
.claude/hooks/plan-execute.sh:137:            ;;
.claude/hooks/plan-execute.sh:138:        test)
.claude/hooks/plan-execute.sh:139:            echo "1. Identify untested code"
.claude/hooks/plan-execute.sh:140:            echo "2. Design test cases"
.claude/hooks/plan-execute.sh:141:            echo "3. Write unit tests"
.claude/hooks/plan-execute.sh:142:            echo "4. Write integration tests"
.claude/hooks/plan-execute.sh:143:            echo "5. Run full test suite"
.claude/hooks/plan-execute.sh:144:            echo "6. Check coverage metrics"
.claude/hooks/plan-execute.sh:145:            ;;
.claude/hooks/plan-execute.sh:146:        general|*)
.claude/hooks/plan-execute.sh:147:            echo "1. Understand the task"
.claude/hooks/plan-execute.sh:148:            echo "2. Research and gather information"
.claude/hooks/plan-execute.sh:149:            echo "3. Plan the approach"
.claude/hooks/plan-execute.sh:150:            echo "4. Execute the plan"
.claude/hooks/plan-execute.sh:151:            echo "5. Validate results"
.claude/hooks/plan-execute.sh:152:            echo "6. Document outcome"
.claude/hooks/plan-execute.sh:153:            ;;
.claude/hooks/plan-execute.sh:154:    esac
.claude/hooks/plan-execute.sh:155:}
.claude/hooks/plan-execute.sh:156:
.claude/hooks/plan-execute.sh:157:# =============================================================================
.claude/hooks/plan-execute.sh:158:# PLAN EXECUTION (from n8n/AgentGPT patterns)
.claude/hooks/plan-execute.sh:159:# =============================================================================
.claude/hooks/plan-execute.sh:160:
.claude/hooks/plan-execute.sh:161:# Get next executable step
.claude/hooks/plan-execute.sh:162:get_next_step() {
.claude/hooks/plan-execute.sh:163:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:164:        echo "no_plan"
.claude/hooks/plan-execute.sh:165:        return 1
.claude/hooks/plan-execute.sh:166:    fi
.claude/hooks/plan-execute.sh:167:
.claude/hooks/plan-execute.sh:168:    jq -r '
.claude/hooks/plan-execute.sh:169:        .steps as $steps |
.claude/hooks/plan-execute.sh:170:        .currentStepIndex as $idx |
.claude/hooks/plan-execute.sh:171:        if $idx >= ($steps | length) then
.claude/hooks/plan-execute.sh:172:            "plan_complete"
.claude/hooks/plan-execute.sh:173:        else
.claude/hooks/plan-execute.sh:174:            $steps[$idx] |
.claude/hooks/plan-execute.sh:175:            if .status == "pending" then
.claude/hooks/plan-execute.sh:176:                # Check dependencies
.claude/hooks/plan-execute.sh:177:                .dependencies as $deps |
.claude/hooks/plan-execute.sh:178:                if ($deps | length) == 0 then
.claude/hooks/plan-execute.sh:179:                    "\(.id):\(.description)"
.claude/hooks/plan-execute.sh:180:                else
.claude/hooks/plan-execute.sh:181:                    # Check if all dependencies are completed
.claude/hooks/plan-execute.sh:182:                    ($deps | all(. as $dep | $steps | any(.id == $dep and .status == "completed"))) as $ready |
.claude/hooks/plan-execute.sh:183:                    if $ready then
.claude/hooks/plan-execute.sh:184:                        "\(.id):\(.description)"
.claude/hooks/plan-execute.sh:185:                    else
.claude/hooks/plan-execute.sh:186:                        "waiting_for_dependencies"
.claude/hooks/plan-execute.sh:187:                    end
.claude/hooks/plan-execute.sh:188:                end
.claude/hooks/plan-execute.sh:189:            elif .status == "in_progress" then
.claude/hooks/plan-execute.sh:190:                "step_in_progress:\(.id)"
.claude/hooks/plan-execute.sh:191:            else
.claude/hooks/plan-execute.sh:192:                "unexpected_state:\(.status)"
.claude/hooks/plan-execute.sh:193:            end
.claude/hooks/plan-execute.sh:194:        end
.claude/hooks/plan-execute.sh:195:    ' "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:196:}
.claude/hooks/plan-execute.sh:197:
.claude/hooks/plan-execute.sh:198:# Start executing a step
.claude/hooks/plan-execute.sh:199:start_step() {
.claude/hooks/plan-execute.sh:200:    local step_id="$1"
.claude/hooks/plan-execute.sh:201:
.claude/hooks/plan-execute.sh:202:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:203:        return 1
.claude/hooks/plan-execute.sh:204:    fi
.claude/hooks/plan-execute.sh:205:
.claude/hooks/plan-execute.sh:206:    local temp_file
.claude/hooks/plan-execute.sh:207:    temp_file=$(mktemp)
.claude/hooks/plan-execute.sh:208:
.claude/hooks/plan-execute.sh:209:    local timestamp
.claude/hooks/plan-execute.sh:210:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/plan-execute.sh:211:
.claude/hooks/plan-execute.sh:212:    jq --arg id "$step_id" \
.claude/hooks/plan-execute.sh:213:       --arg ts "$timestamp" \
.claude/hooks/plan-execute.sh:214:       '
.claude/hooks/plan-execute.sh:215:       .steps = [.steps[] |
.claude/hooks/plan-execute.sh:216:           if .id == $id then
.claude/hooks/plan-execute.sh:217:               . + {status: "in_progress", startedAt: $ts}
.claude/hooks/plan-execute.sh:218:           else . end
.claude/hooks/plan-execute.sh:219:       ]
.claude/hooks/plan-execute.sh:220:       ' "$CURRENT_PLAN" > "$temp_file"
.claude/hooks/plan-execute.sh:221:
.claude/hooks/plan-execute.sh:222:    mv "$temp_file" "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:223:
.claude/hooks/plan-execute.sh:224:    log "Started step: $step_id"
.claude/hooks/plan-execute.sh:225:}
.claude/hooks/plan-execute.sh:226:
.claude/hooks/plan-execute.sh:227:# Complete a step
.claude/hooks/plan-execute.sh:228:complete_step() {
.claude/hooks/plan-execute.sh:229:    local step_id="$1"
.claude/hooks/plan-execute.sh:230:    local result="${2:-success}"
.claude/hooks/plan-execute.sh:231:    local output="${3:-}"
.claude/hooks/plan-execute.sh:232:
.claude/hooks/plan-execute.sh:233:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:234:        return 1
.claude/hooks/plan-execute.sh:235:    fi
.claude/hooks/plan-execute.sh:236:
.claude/hooks/plan-execute.sh:237:    local temp_file
.claude/hooks/plan-execute.sh:238:    temp_file=$(mktemp)
.claude/hooks/plan-execute.sh:239:
.claude/hooks/plan-execute.sh:240:    local timestamp
.claude/hooks/plan-execute.sh:241:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/plan-execute.sh:242:
.claude/hooks/plan-execute.sh:243:    jq --arg id "$step_id" \
.claude/hooks/plan-execute.sh:244:       --arg result "$result" \
.claude/hooks/plan-execute.sh:245:       --arg output "$output" \
.claude/hooks/plan-execute.sh:246:       --arg ts "$timestamp" \
.claude/hooks/plan-execute.sh:247:       '
.claude/hooks/plan-execute.sh:248:       .steps = [.steps[] |
.claude/hooks/plan-execute.sh:249:           if .id == $id then
.claude/hooks/plan-execute.sh:250:               . + {
.claude/hooks/plan-execute.sh:251:                   status: "completed",
.claude/hooks/plan-execute.sh:252:                   result: $result,
.claude/hooks/plan-execute.sh:253:                   output: $output,
.claude/hooks/plan-execute.sh:254:                   completedAt: $ts
.claude/hooks/plan-execute.sh:255:               }
.claude/hooks/plan-execute.sh:256:           else . end
.claude/hooks/plan-execute.sh:257:       ] |
.claude/hooks/plan-execute.sh:258:       .completedSteps += [$id] |
.claude/hooks/plan-execute.sh:259:       .currentStepIndex += 1
.claude/hooks/plan-execute.sh:260:       ' "$CURRENT_PLAN" > "$temp_file"
.claude/hooks/plan-execute.sh:261:
.claude/hooks/plan-execute.sh:262:    mv "$temp_file" "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:263:
.claude/hooks/plan-execute.sh:264:    log "Completed step: $step_id with result: $result"
.claude/hooks/plan-execute.sh:265:}
.claude/hooks/plan-execute.sh:266:
.claude/hooks/plan-execute.sh:267:# Fail a step
.claude/hooks/plan-execute.sh:268:fail_step() {
.claude/hooks/plan-execute.sh:269:    local step_id="$1"
.claude/hooks/plan-execute.sh:270:    local error="${2:-unknown error}"
.claude/hooks/plan-execute.sh:271:
.claude/hooks/plan-execute.sh:272:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:273:        return 1
.claude/hooks/plan-execute.sh:274:    fi
.claude/hooks/plan-execute.sh:275:
.claude/hooks/plan-execute.sh:276:    local temp_file
.claude/hooks/plan-execute.sh:277:    temp_file=$(mktemp)
.claude/hooks/plan-execute.sh:278:
.claude/hooks/plan-execute.sh:279:    local timestamp
.claude/hooks/plan-execute.sh:280:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/plan-execute.sh:281:
.claude/hooks/plan-execute.sh:282:    jq --arg id "$step_id" \
.claude/hooks/plan-execute.sh:283:       --arg error "$error" \
.claude/hooks/plan-execute.sh:284:       --arg ts "$timestamp" \
.claude/hooks/plan-execute.sh:285:       '
.claude/hooks/plan-execute.sh:286:       .steps = [.steps[] |
.claude/hooks/plan-execute.sh:287:           if .id == $id then
.claude/hooks/plan-execute.sh:288:               . + {
.claude/hooks/plan-execute.sh:289:                   status: "failed",
.claude/hooks/plan-execute.sh:290:                   error: $error,
.claude/hooks/plan-execute.sh:291:                   failedAt: $ts
.claude/hooks/plan-execute.sh:292:               }
.claude/hooks/plan-execute.sh:293:           else . end
.claude/hooks/plan-execute.sh:294:       ] |
.claude/hooks/plan-execute.sh:295:       .failedSteps += [$id]
.claude/hooks/plan-execute.sh:296:       ' "$CURRENT_PLAN" > "$temp_file"
.claude/hooks/plan-execute.sh:297:
.claude/hooks/plan-execute.sh:298:    mv "$temp_file" "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:299:
.claude/hooks/plan-execute.sh:300:    log "Failed step: $step_id with error: $error"
.claude/hooks/plan-execute.sh:301:}
.claude/hooks/plan-execute.sh:302:
.claude/hooks/plan-execute.sh:303:# =============================================================================
.claude/hooks/plan-execute.sh:304:# REPLANNING (from obsidian-copilot/AgentGPT patterns)
.claude/hooks/plan-execute.sh:305:# =============================================================================
.claude/hooks/plan-execute.sh:306:
.claude/hooks/plan-execute.sh:307:# Check if replanning is needed
.claude/hooks/plan-execute.sh:308:should_replan() {
.claude/hooks/plan-execute.sh:309:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:310:        echo "no_plan"
.claude/hooks/plan-execute.sh:311:        return 1
.claude/hooks/plan-execute.sh:312:    fi
.claude/hooks/plan-execute.sh:313:
.claude/hooks/plan-execute.sh:314:    jq -r '
.claude/hooks/plan-execute.sh:315:        .replanning as $rp |
.claude/hooks/plan-execute.sh:316:        .failedSteps | length as $failures |
.claude/hooks/plan-execute.sh:317:        if $failures > 0 and $rp.count < $rp.maxReplans then
.claude/hooks/plan-execute.sh:318:            "replan_needed:\($failures) failures"
.claude/hooks/plan-execute.sh:319:        elif $rp.count >= $rp.maxReplans then
.claude/hooks/plan-execute.sh:320:            "max_replans_reached"
.claude/hooks/plan-execute.sh:321:        else
.claude/hooks/plan-execute.sh:322:            "continue"
.claude/hooks/plan-execute.sh:323:        end
.claude/hooks/plan-execute.sh:324:    ' "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:325:}
.claude/hooks/plan-execute.sh:326:
.claude/hooks/plan-execute.sh:327:# Trigger replanning
.claude/hooks/plan-execute.sh:328:replan() {
.claude/hooks/plan-execute.sh:329:    local reason="$1"
.claude/hooks/plan-execute.sh:330:
.claude/hooks/plan-execute.sh:331:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:332:        return 1
.claude/hooks/plan-execute.sh:333:    fi
.claude/hooks/plan-execute.sh:334:
.claude/hooks/plan-execute.sh:335:    local temp_file
.claude/hooks/plan-execute.sh:336:    temp_file=$(mktemp)
.claude/hooks/plan-execute.sh:337:
.claude/hooks/plan-execute.sh:338:    local timestamp
.claude/hooks/plan-execute.sh:339:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/plan-execute.sh:340:
.claude/hooks/plan-execute.sh:341:    jq --arg reason "$reason" \
.claude/hooks/plan-execute.sh:342:       --arg ts "$timestamp" \
.claude/hooks/plan-execute.sh:343:       '
.claude/hooks/plan-execute.sh:344:       .replanning.count += 1 |
.claude/hooks/plan-execute.sh:345:       .replanning.reasons += [{reason: $reason, timestamp: $ts}] |
.claude/hooks/plan-execute.sh:346:       .status = "replanning" |
.claude/hooks/plan-execute.sh:347:       # Reset failed steps to pending for retry
.claude/hooks/plan-execute.sh:348:       .steps = [.steps[] |
.claude/hooks/plan-execute.sh:349:           if .status == "failed" then
.claude/hooks/plan-execute.sh:350:               . + {status: "pending", retryCount: ((.retryCount // 0) + 1)}
.claude/hooks/plan-execute.sh:351:           else . end
.claude/hooks/plan-execute.sh:352:       ] |
.claude/hooks/plan-execute.sh:353:       .failedSteps = []
.claude/hooks/plan-execute.sh:354:       ' "$CURRENT_PLAN" > "$temp_file"
.claude/hooks/plan-execute.sh:355:
.claude/hooks/plan-execute.sh:356:    mv "$temp_file" "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:357:
.claude/hooks/plan-execute.sh:358:    log "Triggered replan: $reason"
.claude/hooks/plan-execute.sh:359:}
.claude/hooks/plan-execute.sh:360:
.claude/hooks/plan-execute.sh:361:# Add new steps during replanning
.claude/hooks/plan-execute.sh:362:insert_step() {
.claude/hooks/plan-execute.sh:363:    local after_step_id="$1"
.claude/hooks/plan-execute.sh:364:    local description="$2"
.claude/hooks/plan-execute.sh:365:    local tool="${3:-shell}"
.claude/hooks/plan-execute.sh:366:
.claude/hooks/plan-execute.sh:367:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:368:        return 1
.claude/hooks/plan-execute.sh:369:    fi
.claude/hooks/plan-execute.sh:370:
.claude/hooks/plan-execute.sh:371:    local temp_file
.claude/hooks/plan-execute.sh:372:    temp_file=$(mktemp)
.claude/hooks/plan-execute.sh:373:
.claude/hooks/plan-execute.sh:374:    local step_id
.claude/hooks/plan-execute.sh:375:    step_id="step_$(date +%s%N | cut -c1-13)"
.claude/hooks/plan-execute.sh:376:
.claude/hooks/plan-execute.sh:377:    jq --arg after "$after_step_id" \
.claude/hooks/plan-execute.sh:378:       --arg id "$step_id" \
.claude/hooks/plan-execute.sh:379:       --arg desc "$description" \
.claude/hooks/plan-execute.sh:380:       --arg tool "$tool" \
.claude/hooks/plan-execute.sh:381:       '
.claude/hooks/plan-execute.sh:382:       .steps as $steps |
.claude/hooks/plan-execute.sh:383:       ($steps | to_entries | map(select(.value.id == $after)) | .[0].key // -1) as $idx |
.claude/hooks/plan-execute.sh:384:       if $idx >= 0 then
.claude/hooks/plan-execute.sh:385:           .steps = ($steps[:$idx+1] + [{
.claude/hooks/plan-execute.sh:386:               id: $id,
.claude/hooks/plan-execute.sh:387:               description: $desc,
.claude/hooks/plan-execute.sh:388:               tool: $tool,
.claude/hooks/plan-execute.sh:389:               status: "pending",
.claude/hooks/plan-execute.sh:390:               insertedDuringReplan: true
.claude/hooks/plan-execute.sh:391:           }] + $steps[$idx+1:])
.claude/hooks/plan-execute.sh:392:       else
.claude/hooks/plan-execute.sh:393:           .steps += [{
.claude/hooks/plan-execute.sh:394:               id: $id,
.claude/hooks/plan-execute.sh:395:               description: $desc,
.claude/hooks/plan-execute.sh:396:               tool: $tool,
.claude/hooks/plan-execute.sh:397:               status: "pending",
.claude/hooks/plan-execute.sh:398:               insertedDuringReplan: true
.claude/hooks/plan-execute.sh:399:           }]
.claude/hooks/plan-execute.sh:400:       end
.claude/hooks/plan-execute.sh:401:       ' "$CURRENT_PLAN" > "$temp_file"
.claude/hooks/plan-execute.sh:402:
.claude/hooks/plan-execute.sh:403:    mv "$temp_file" "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:404:
.claude/hooks/plan-execute.sh:405:    log "Inserted step after $after_step_id: $description"
.claude/hooks/plan-execute.sh:406:    echo "$step_id"
.claude/hooks/plan-execute.sh:407:}
.claude/hooks/plan-execute.sh:408:
.claude/hooks/plan-execute.sh:409:# =============================================================================
.claude/hooks/plan-execute.sh:410:# PLAN COMPLETION
.claude/hooks/plan-execute.sh:411:# =============================================================================
.claude/hooks/plan-execute.sh:412:
.claude/hooks/plan-execute.sh:413:# Check plan status
.claude/hooks/plan-execute.sh:414:check_plan_status() {
.claude/hooks/plan-execute.sh:415:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:416:        echo "no_plan"
.claude/hooks/plan-execute.sh:417:        return 1
.claude/hooks/plan-execute.sh:418:    fi
.claude/hooks/plan-execute.sh:419:
.claude/hooks/plan-execute.sh:420:    jq -r '
.claude/hooks/plan-execute.sh:421:        .steps | length as $total |
.claude/hooks/plan-execute.sh:422:        [.[] | select(.status == "completed")] | length as $completed |
.claude/hooks/plan-execute.sh:423:        [.[] | select(.status == "failed")] | length as $failed |
.claude/hooks/plan-execute.sh:424:        [.[] | select(.status == "pending")] | length as $pending |
.claude/hooks/plan-execute.sh:425:        [.[] | select(.status == "in_progress")] | length as $in_progress |
.claude/hooks/plan-execute.sh:426:        {
.claude/hooks/plan-execute.sh:427:            total: $total,
.claude/hooks/plan-execute.sh:428:            completed: $completed,
.claude/hooks/plan-execute.sh:429:            failed: $failed,
.claude/hooks/plan-execute.sh:430:            pending: $pending,
.claude/hooks/plan-execute.sh:431:            in_progress: $in_progress,
.claude/hooks/plan-execute.sh:432:            progress: (if $total > 0 then ($completed * 100 / $total) else 0 end)
.claude/hooks/plan-execute.sh:433:        } |
.claude/hooks/plan-execute.sh:434:        "total:\(.total) completed:\(.completed) failed:\(.failed) pending:\(.pending) progress:\(.progress)%"
.claude/hooks/plan-execute.sh:435:    ' "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:436:}
.claude/hooks/plan-execute.sh:437:
.claude/hooks/plan-execute.sh:438:# Complete the plan
.claude/hooks/plan-execute.sh:439:complete_plan() {
.claude/hooks/plan-execute.sh:440:    local outcome="${1:-success}"
.claude/hooks/plan-execute.sh:441:    local summary="${2:-}"
.claude/hooks/plan-execute.sh:442:
.claude/hooks/plan-execute.sh:443:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:444:        return 1
.claude/hooks/plan-execute.sh:445:    fi
.claude/hooks/plan-execute.sh:446:
.claude/hooks/plan-execute.sh:447:    local temp_file
.claude/hooks/plan-execute.sh:448:    temp_file=$(mktemp)
.claude/hooks/plan-execute.sh:449:
.claude/hooks/plan-execute.sh:450:    local timestamp
.claude/hooks/plan-execute.sh:451:    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
.claude/hooks/plan-execute.sh:452:
.claude/hooks/plan-execute.sh:453:    jq --arg outcome "$outcome" \
.claude/hooks/plan-execute.sh:454:       --arg summary "$summary" \
.claude/hooks/plan-execute.sh:455:       --arg ts "$timestamp" \
.claude/hooks/plan-execute.sh:456:       '
.claude/hooks/plan-execute.sh:457:       .status = "completed" |
.claude/hooks/plan-execute.sh:458:       .outcome = $outcome |
.claude/hooks/plan-execute.sh:459:       .summary = $summary |
.claude/hooks/plan-execute.sh:460:       .completedAt = $ts |
.claude/hooks/plan-execute.sh:461:       .duration = (
.claude/hooks/plan-execute.sh:462:           (($ts | fromdate) - (.createdAt | fromdate)) | floor
.claude/hooks/plan-execute.sh:463:       )
.claude/hooks/plan-execute.sh:464:       ' "$CURRENT_PLAN" > "$temp_file"
.claude/hooks/plan-execute.sh:465:
.claude/hooks/plan-execute.sh:466:    mv "$temp_file" "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:467:
.claude/hooks/plan-execute.sh:468:    # Add to history
.claude/hooks/plan-execute.sh:469:    local history_temp
.claude/hooks/plan-execute.sh:470:    history_temp=$(mktemp)
.claude/hooks/plan-execute.sh:471:
.claude/hooks/plan-execute.sh:472:    jq --slurpfile plan "$CURRENT_PLAN" \
.claude/hooks/plan-execute.sh:473:       '.plans = [$plan[0]] + .plans | .plans = .plans[:50]' \
.claude/hooks/plan-execute.sh:474:       "$PLAN_HISTORY" > "$history_temp"
.claude/hooks/plan-execute.sh:475:
.claude/hooks/plan-execute.sh:476:    mv "$history_temp" "$PLAN_HISTORY"
.claude/hooks/plan-execute.sh:477:
.claude/hooks/plan-execute.sh:478:    # Archive
.claude/hooks/plan-execute.sh:479:    local archive_file="$PLAN_DIR/archive/$(jq -r '.id' "$CURRENT_PLAN").json"
.claude/hooks/plan-execute.sh:480:    mkdir -p "$PLAN_DIR/archive"
.claude/hooks/plan-execute.sh:481:    mv "$CURRENT_PLAN" "$archive_file"
.claude/hooks/plan-execute.sh:482:
.claude/hooks/plan-execute.sh:483:    log "Completed plan with outcome: $outcome"
.claude/hooks/plan-execute.sh:484:    echo "$archive_file"
.claude/hooks/plan-execute.sh:485:}
.claude/hooks/plan-execute.sh:486:
.claude/hooks/plan-execute.sh:487:# Get plan state
.claude/hooks/plan-execute.sh:488:get_state() {
.claude/hooks/plan-execute.sh:489:    if [[ -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:490:        jq '.' "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:491:    else
.claude/hooks/plan-execute.sh:492:        echo '{"status":"no_active_plan"}'
.claude/hooks/plan-execute.sh:493:    fi
.claude/hooks/plan-execute.sh:494:}
.claude/hooks/plan-execute.sh:495:
.claude/hooks/plan-execute.sh:496:# Get plan summary
.claude/hooks/plan-execute.sh:497:get_summary() {
.claude/hooks/plan-execute.sh:498:    if [[ ! -f "$CURRENT_PLAN" ]]; then
.claude/hooks/plan-execute.sh:499:        echo "No active plan"
.claude/hooks/plan-execute.sh:500:        return
.claude/hooks/plan-execute.sh:501:    fi
.claude/hooks/plan-execute.sh:502:
.claude/hooks/plan-execute.sh:503:    jq -r '
.claude/hooks/plan-execute.sh:504:        "=== Plan Summary ===" +
.claude/hooks/plan-execute.sh:505:        "\nGoal: \(.goal)" +
.claude/hooks/plan-execute.sh:506:        "\nStatus: \(.status)" +
.claude/hooks/plan-execute.sh:507:        "\nSteps: \(.steps | length)" +
.claude/hooks/plan-execute.sh:508:        "\nCompleted: \(.completedSteps | length)" +
.claude/hooks/plan-execute.sh:509:        "\nFailed: \(.failedSteps | length)" +
.claude/hooks/plan-execute.sh:510:        "\nReplans: \(.replanning.count)/\(.replanning.maxReplans)" +
.claude/hooks/plan-execute.sh:511:        "\n\n--- Steps ---" +
.claude/hooks/plan-execute.sh:512:        "\n" + (.steps | map(
.claude/hooks/plan-execute.sh:513:            "[\(.status | .[0:1] | ascii_upcase)] \(.description)"
.claude/hooks/plan-execute.sh:514:        ) | join("\n"))
.claude/hooks/plan-execute.sh:515:    ' "$CURRENT_PLAN"
.claude/hooks/plan-execute.sh:516:}
.claude/hooks/plan-execute.sh:517:
.claude/hooks/plan-execute.sh:518:# =============================================================================
.claude/hooks/plan-execute.sh:519:# COMMAND INTERFACE
.claude/hooks/plan-execute.sh:520:# =============================================================================
.claude/hooks/plan-execute.sh:521:
.claude/hooks/plan-execute.sh:522:case "${1:-help}" in
.claude/hooks/plan-execute.sh:523:    create)
.claude/hooks/plan-execute.sh:524:        create_plan "${2:-goal}" "${3:-}"
.claude/hooks/plan-execute.sh:525:        ;;
.claude/hooks/plan-execute.sh:526:    add-step)
.claude/hooks/plan-execute.sh:527:        add_step "${2:-step description}" "${3:-shell}" "${4:-}" "${5:-}"
.claude/hooks/plan-execute.sh:528:        ;;
.claude/hooks/plan-execute.sh:529:    decompose)
.claude/hooks/plan-execute.sh:530:        decompose_task "${2:-task}" "${3:-general}"
.claude/hooks/plan-execute.sh:531:        ;;
.claude/hooks/plan-execute.sh:532:    next)
.claude/hooks/plan-execute.sh:533:        get_next_step
.claude/hooks/plan-execute.sh:534:        ;;
.claude/hooks/plan-execute.sh:535:    start)
.claude/hooks/plan-execute.sh:536:        start_step "${2:-step_id}"
.claude/hooks/plan-execute.sh:537:        ;;
.claude/hooks/plan-execute.sh:538:    complete)
.claude/hooks/plan-execute.sh:539:        complete_step "${2:-step_id}" "${3:-success}" "${4:-}"
.claude/hooks/plan-execute.sh:540:        ;;
.claude/hooks/plan-execute.sh:541:    fail)
.claude/hooks/plan-execute.sh:542:        fail_step "${2:-step_id}" "${3:-error}"
.claude/hooks/plan-execute.sh:543:        ;;
.claude/hooks/plan-execute.sh:544:    should-replan)
.claude/hooks/plan-execute.sh:545:        should_replan
.claude/hooks/plan-execute.sh:546:        ;;
.claude/hooks/plan-execute.sh:547:    replan)
.claude/hooks/plan-execute.sh:548:        replan "${2:-reason}"
.claude/hooks/plan-execute.sh:549:        ;;
.claude/hooks/plan-execute.sh:550:    insert)
.claude/hooks/plan-execute.sh:551:        insert_step "${2:-after_step}" "${3:-description}" "${4:-shell}"
.claude/hooks/plan-execute.sh:552:        ;;
.claude/hooks/plan-execute.sh:553:    status)
.claude/hooks/plan-execute.sh:554:        check_plan_status
.claude/hooks/plan-execute.sh:555:        ;;
.claude/hooks/plan-execute.sh:556:    finish)
.claude/hooks/plan-execute.sh:557:        complete_plan "${2:-success}" "${3:-}"
.claude/hooks/plan-execute.sh:558:        ;;
.claude/hooks/plan-execute.sh:559:    state)
.claude/hooks/plan-execute.sh:560:        get_state
.claude/hooks/plan-execute.sh:561:        ;;
.claude/hooks/plan-execute.sh:562:    summary)
.claude/hooks/plan-execute.sh:563:        get_summary
.claude/hooks/plan-execute.sh:564:        ;;
.claude/hooks/plan-execute.sh:565:    help|*)
.claude/hooks/plan-execute.sh:566:        echo "Plan and Execute - Task Decomposition System"
.claude/hooks/plan-execute.sh:567:        echo ""
.claude/hooks/plan-execute.sh:568:        echo "Usage: $0 <command> [args]"
.claude/hooks/plan-execute.sh:569:        echo ""
.claude/hooks/plan-execute.sh:570:        echo "Plan Commands:"
.claude/hooks/plan-execute.sh:571:        echo "  create <goal> [context]           - Create new plan"
.claude/hooks/plan-execute.sh:572:        echo "  add-step <desc> [tool] [args] [deps] - Add step to plan"
.claude/hooks/plan-execute.sh:573:        echo "  decompose <task> [type]           - Get decomposition template"
.claude/hooks/plan-execute.sh:574:        echo "    Types: feature, bugfix, refactor, test, general"
.claude/hooks/plan-execute.sh:575:        echo ""
.claude/hooks/plan-execute.sh:576:        echo "Execution Commands:"
.claude/hooks/plan-execute.sh:577:        echo "  next                              - Get next executable step"
.claude/hooks/plan-execute.sh:578:        echo "  start <step_id>                   - Start executing step"
.claude/hooks/plan-execute.sh:579:        echo "  complete <step_id> [result] [out] - Complete step"
.claude/hooks/plan-execute.sh:580:        echo "  fail <step_id> [error]            - Mark step as failed"
.claude/hooks/plan-execute.sh:581:        echo ""
.claude/hooks/plan-execute.sh:582:        echo "Replanning Commands:"
.claude/hooks/plan-execute.sh:583:        echo "  should-replan                     - Check if replan needed"
.claude/hooks/plan-execute.sh:584:        echo "  replan <reason>                   - Trigger replanning"
.claude/hooks/plan-execute.sh:585:        echo "  insert <after_id> <desc> [tool]   - Insert new step"
.claude/hooks/plan-execute.sh:586:        echo ""
.claude/hooks/plan-execute.sh:587:        echo "Status Commands:"
.claude/hooks/plan-execute.sh:588:        echo "  status                            - Get progress stats"
.claude/hooks/plan-execute.sh:589:        echo "  finish [outcome] [summary]        - Complete the plan"
.claude/hooks/plan-execute.sh:590:        echo "  state                             - Get full state JSON"
.claude/hooks/plan-execute.sh:591:        echo "  summary                           - Get human-readable summary"
.claude/hooks/plan-execute.sh:592:        ;;
.claude/hooks/plan-execute.sh:593:esac
.claude/hooks/tree-of-thoughts.sh:1:#!/bin/bash
.claude/hooks/tree-of-thoughts.sh:2:# Tree of Thoughts - Explore multiple solution paths, evaluate, select best
.claude/hooks/tree-of-thoughts.sh:3:# Based on: kyegomez/tree-of-thoughts, strategic-debate-tot, ToT papers
.claude/hooks/tree-of-thoughts.sh:4:# Implements branching reasoning with evaluation and selection
.claude/hooks/tree-of-thoughts.sh:5:
.claude/hooks/tree-of-thoughts.sh:6:set -eo pipefail
.claude/hooks/tree-of-thoughts.sh:7:
.claude/hooks/tree-of-thoughts.sh:8:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/tree-of-thoughts.sh:9:MEMORY_MANAGER="${CLAUDE_DIR}/hooks/memory-manager.sh"
.claude/hooks/tree-of-thoughts.sh:10:LOG_FILE="${CLAUDE_DIR}/tree-of-thoughts.log"
.claude/hooks/tree-of-thoughts.sh:11:TOT_STATE_DIR="${CLAUDE_DIR}/.tot"
.claude/hooks/tree-of-thoughts.sh:12:
.claude/hooks/tree-of-thoughts.sh:13:mkdir -p "$TOT_STATE_DIR"
.claude/hooks/tree-of-thoughts.sh:14:
.claude/hooks/tree-of-thoughts.sh:15:log() {
.claude/hooks/tree-of-thoughts.sh:16:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/tree-of-thoughts.sh:17:}
.claude/hooks/tree-of-thoughts.sh:18:
.claude/hooks/tree-of-thoughts.sh:19:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:20:# TREE OF THOUGHTS: Generate multiple solution paths
.claude/hooks/tree-of-thoughts.sh:21:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:22:
.claude/hooks/tree-of-thoughts.sh:23:# Generate N different approaches to a problem
.claude/hooks/tree-of-thoughts.sh:24:generate_thought_branches() {
.claude/hooks/tree-of-thoughts.sh:25:    local problem="$1"
.claude/hooks/tree-of-thoughts.sh:26:    local context="$2"
.claude/hooks/tree-of-thoughts.sh:27:    local num_branches="${3:-3}"
.claude/hooks/tree-of-thoughts.sh:28:    local depth="${4:-0}"
.claude/hooks/tree-of-thoughts.sh:29:
.claude/hooks/tree-of-thoughts.sh:30:    log "Generating $num_branches thought branches for: $problem (depth=$depth)"
.claude/hooks/tree-of-thoughts.sh:31:
.claude/hooks/tree-of-thoughts.sh:32:    # Search for similar problems in memory
.claude/hooks/tree-of-thoughts.sh:33:    local similar_solutions="[]"
.claude/hooks/tree-of-thoughts.sh:34:    if [[ -x "$MEMORY_MANAGER" ]]; then
.claude/hooks/tree-of-thoughts.sh:35:        similar_solutions=$("$MEMORY_MANAGER" remember-scored "$problem" 3 2>/dev/null || echo '[]')
.claude/hooks/tree-of-thoughts.sh:36:    fi
.claude/hooks/tree-of-thoughts.sh:37:
.claude/hooks/tree-of-thoughts.sh:38:[Omitted long matching line]
.claude/hooks/tree-of-thoughts.sh:39:
.claude/hooks/tree-of-thoughts.sh:40:    local tree_id="tot_$(date +%s)_$$"
.claude/hooks/tree-of-thoughts.sh:41:
.claude/hooks/tree-of-thoughts.sh:42:    jq -n \
.claude/hooks/tree-of-thoughts.sh:43:        --arg problem "$problem" \
.claude/hooks/tree-of-thoughts.sh:44:        --arg context "$context" \
.claude/hooks/tree-of-thoughts.sh:45:        --argjson depth "$depth" \
.claude/hooks/tree-of-thoughts.sh:46:        --argjson num_branches "$num_branches" \
.claude/hooks/tree-of-thoughts.sh:47:        --argjson similar_solutions "${similar_solutions}" \
.claude/hooks/tree-of-thoughts.sh:48:        --arg prompt "$generation_prompt" \
.claude/hooks/tree-of-thoughts.sh:49:        --arg tree_id "$tree_id" \
.claude/hooks/tree-of-thoughts.sh:50:        '{
.claude/hooks/tree-of-thoughts.sh:51:            problem: $problem,
.claude/hooks/tree-of-thoughts.sh:52:            context: $context,
.claude/hooks/tree-of-thoughts.sh:53:            depth: $depth,
.claude/hooks/tree-of-thoughts.sh:54:            num_branches: $num_branches,
.claude/hooks/tree-of-thoughts.sh:55:            similar_solutions: $similar_solutions,
.claude/hooks/tree-of-thoughts.sh:56:            generation_prompt: $prompt,
.claude/hooks/tree-of-thoughts.sh:57:            tree_id: $tree_id
.claude/hooks/tree-of-thoughts.sh:58:        }'
.claude/hooks/tree-of-thoughts.sh:59:}
.claude/hooks/tree-of-thoughts.sh:60:
.claude/hooks/tree-of-thoughts.sh:61:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:62:# BRANCH EVALUATION: Score and rank approaches
.claude/hooks/tree-of-thoughts.sh:63:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:64:
.claude/hooks/tree-of-thoughts.sh:65:# Evaluate a single branch
.claude/hooks/tree-of-thoughts.sh:66:evaluate_branch() {
.claude/hooks/tree-of-thoughts.sh:67:    local branch_json="$1"
.claude/hooks/tree-of-thoughts.sh:68:    local weights="${2:-feasibility:0.3,quality:0.3,risk:0.2,effort:0.2}"
.claude/hooks/tree-of-thoughts.sh:69:
.claude/hooks/tree-of-thoughts.sh:70:    log "Evaluating branch: $(echo "$branch_json" | jq -r '.name // "unknown"')"
.claude/hooks/tree-of-thoughts.sh:71:
.claude/hooks/tree-of-thoughts.sh:72:    # Parse weights
.claude/hooks/tree-of-thoughts.sh:73:    local w_feasibility=$(echo "$weights" | grep -oP 'feasibility:\K[0-9.]+' || echo "0.3")
.claude/hooks/tree-of-thoughts.sh:74:    local w_quality=$(echo "$weights" | grep -oP 'quality:\K[0-9.]+' || echo "0.3")
.claude/hooks/tree-of-thoughts.sh:75:    local w_risk=$(echo "$weights" | grep -oP 'risk:\K[0-9.]+' || echo "0.2")
.claude/hooks/tree-of-thoughts.sh:76:    local w_effort=$(echo "$weights" | grep -oP 'effort:\K[0-9.]+' || echo "0.2")
.claude/hooks/tree-of-thoughts.sh:77:
.claude/hooks/tree-of-thoughts.sh:78:    # Extract scores
.claude/hooks/tree-of-thoughts.sh:79:    local feasibility=$(echo "$branch_json" | jq -r '.scores.feasibility // 5')
.claude/hooks/tree-of-thoughts.sh:80:    local quality=$(echo "$branch_json" | jq -r '.scores.quality // 5')
.claude/hooks/tree-of-thoughts.sh:81:    local risk=$(echo "$branch_json" | jq -r '.scores.risk // 5')
.claude/hooks/tree-of-thoughts.sh:82:    local effort=$(echo "$branch_json" | jq -r '.scores.effort // 5')
.claude/hooks/tree-of-thoughts.sh:83:
.claude/hooks/tree-of-thoughts.sh:84:    # Calculate weighted score (invert risk and effort - lower is better)
.claude/hooks/tree-of-thoughts.sh:85:    local weighted_score=$(echo "scale=2; ($feasibility * $w_feasibility) + ($quality * $w_quality) + ((10 - $risk) * $w_risk) + ((10 - $effort) * $w_effort)" | bc)
.claude/hooks/tree-of-thoughts.sh:86:
.claude/hooks/tree-of-thoughts.sh:87:    # Add evaluation to branch
.claude/hooks/tree-of-thoughts.sh:88:    echo "$branch_json" | jq --argjson score "$weighted_score" '. + {
.claude/hooks/tree-of-thoughts.sh:89:        weighted_score: $score,
.claude/hooks/tree-of-thoughts.sh:90:        evaluated_at: (now | todate)
.claude/hooks/tree-of-thoughts.sh:91:    }'
.claude/hooks/tree-of-thoughts.sh:92:}
.claude/hooks/tree-of-thoughts.sh:93:
.claude/hooks/tree-of-thoughts.sh:94:# Compare and rank all branches
.claude/hooks/tree-of-thoughts.sh:95:rank_branches() {
.claude/hooks/tree-of-thoughts.sh:96:    local branches_json="$1"
.claude/hooks/tree-of-thoughts.sh:97:    local weights="${2:-feasibility:0.3,quality:0.3,risk:0.2,effort:0.2}"
.claude/hooks/tree-of-thoughts.sh:98:
.claude/hooks/tree-of-thoughts.sh:99:    log "Ranking branches"
.claude/hooks/tree-of-thoughts.sh:100:
.claude/hooks/tree-of-thoughts.sh:101:    # Evaluate each branch
.claude/hooks/tree-of-thoughts.sh:102:    local evaluated_branches
.claude/hooks/tree-of-thoughts.sh:103:    evaluated_branches=$(echo "$branches_json" | jq -r '.branches[]' | while IFS= read -r branch; do
.claude/hooks/tree-of-thoughts.sh:104:        evaluate_branch "$branch" "$weights"
.claude/hooks/tree-of-thoughts.sh:105:    done | jq -s '.')
.claude/hooks/tree-of-thoughts.sh:106:
.claude/hooks/tree-of-thoughts.sh:107:    # Sort by weighted score
.claude/hooks/tree-of-thoughts.sh:108:    local ranked
.claude/hooks/tree-of-thoughts.sh:109:    ranked=$(echo "$evaluated_branches" | jq 'sort_by(-.weighted_score)')
.claude/hooks/tree-of-thoughts.sh:110:
.claude/hooks/tree-of-thoughts.sh:111:    echo "$ranked"
.claude/hooks/tree-of-thoughts.sh:112:}
.claude/hooks/tree-of-thoughts.sh:113:
.claude/hooks/tree-of-thoughts.sh:114:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:115:# DECISION MAKING: Select best approach
.claude/hooks/tree-of-thoughts.sh:116:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:117:
.claude/hooks/tree-of-thoughts.sh:118:# Select the best branch
.claude/hooks/tree-of-thoughts.sh:119:select_best_branch() {
.claude/hooks/tree-of-thoughts.sh:120:    local ranked_branches="$1"
.claude/hooks/tree-of-thoughts.sh:121:    local selection_strategy="${2:-highest_score}"
.claude/hooks/tree-of-thoughts.sh:122:
.claude/hooks/tree-of-thoughts.sh:123:    log "Selecting best branch (strategy: $selection_strategy)"
.claude/hooks/tree-of-thoughts.sh:124:
.claude/hooks/tree-of-thoughts.sh:125:    case "$selection_strategy" in
.claude/hooks/tree-of-thoughts.sh:126:        highest_score)
.claude/hooks/tree-of-thoughts.sh:127:            # Simply pick the highest scoring branch
.claude/hooks/tree-of-thoughts.sh:128:            echo "$ranked_branches" | jq '.[0]'
.claude/hooks/tree-of-thoughts.sh:129:            ;;
.claude/hooks/tree-of-thoughts.sh:130:        risk_averse)
.claude/hooks/tree-of-thoughts.sh:131:            # Pick highest score among low-risk options (risk <= 5)
.claude/hooks/tree-of-thoughts.sh:132:            echo "$ranked_branches" | jq '[.[] | select(.scores.risk <= 5)] | .[0]'
.claude/hooks/tree-of-thoughts.sh:133:            ;;
.claude/hooks/tree-of-thoughts.sh:134:        quick_win)
.claude/hooks/tree-of-thoughts.sh:135:            # Pick lowest effort option that scores >= 7
.claude/hooks/tree-of-thoughts.sh:136:            echo "$ranked_branches" | jq '[.[] | select(.weighted_score >= 7)] | sort_by(.scores.effort) | .[0]'
.claude/hooks/tree-of-thoughts.sh:137:            ;;
.claude/hooks/tree-of-thoughts.sh:138:        high_quality)
.claude/hooks/tree-of-thoughts.sh:139:            # Pick highest quality option regardless of effort
.claude/hooks/tree-of-thoughts.sh:140:            echo "$ranked_branches" | jq 'sort_by(-.scores.quality) | .[0]'
.claude/hooks/tree-of-thoughts.sh:141:            ;;
.claude/hooks/tree-of-thoughts.sh:142:        *)
.claude/hooks/tree-of-thoughts.sh:143:            # Default to highest score
.claude/hooks/tree-of-thoughts.sh:144:            echo "$ranked_branches" | jq '.[0]'
.claude/hooks/tree-of-thoughts.sh:145:            ;;
.claude/hooks/tree-of-thoughts.sh:146:    esac
.claude/hooks/tree-of-thoughts.sh:147:}
.claude/hooks/tree-of-thoughts.sh:148:
.claude/hooks/tree-of-thoughts.sh:149:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:150:# TREE EXPANSION: Explore deeper into selected branches
.claude/hooks/tree-of-thoughts.sh:151:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:152:
.claude/hooks/tree-of-thoughts.sh:153:# Expand a branch into sub-branches
.claude/hooks/tree-of-thoughts.sh:154:expand_branch() {
.claude/hooks/tree-of-thoughts.sh:155:    local branch_json="$1"
.claude/hooks/tree-of-thoughts.sh:156:    local max_depth="${2:-2}"
.claude/hooks/tree-of-thoughts.sh:157:    local current_depth="${3:-0}"
.claude/hooks/tree-of-thoughts.sh:158:
.claude/hooks/tree-of-thoughts.sh:159:    local branch_name
.claude/hooks/tree-of-thoughts.sh:160:    branch_name=$(echo "$branch_json" | jq -r '.name')
.claude/hooks/tree-of-thoughts.sh:161:
.claude/hooks/tree-of-thoughts.sh:162:    log "Expanding branch: $branch_name (depth $current_depth/$max_depth)"
.claude/hooks/tree-of-thoughts.sh:163:
.claude/hooks/tree-of-thoughts.sh:164:    if (( current_depth >= max_depth )); then
.claude/hooks/tree-of-thoughts.sh:165:        log "Max depth reached, stopping expansion"
.claude/hooks/tree-of-thoughts.sh:166:        echo "$branch_json"
.claude/hooks/tree-of-thoughts.sh:167:        return
.claude/hooks/tree-of-thoughts.sh:168:    fi
.claude/hooks/tree-of-thoughts.sh:169:
.claude/hooks/tree-of-thoughts.sh:170:    # Create sub-problem for this branch
.claude/hooks/tree-of-thoughts.sh:171:    local strategy
.claude/hooks/tree-of-thoughts.sh:172:    strategy=$(echo "$branch_json" | jq -r '.strategy')
.claude/hooks/tree-of-thoughts.sh:173:
.claude/hooks/tree-of-thoughts.sh:174:    # Generate sub-branches
.claude/hooks/tree-of-thoughts.sh:175:    local next_depth=$((current_depth + 1))
.claude/hooks/tree-of-thoughts.sh:176:    local sub_branches_prompt
.claude/hooks/tree-of-thoughts.sh:177:    sub_branches_prompt=$(generate_thought_branches "$strategy" "Expanding: $branch_name" 3 "$next_depth")
.claude/hooks/tree-of-thoughts.sh:178:
.claude/hooks/tree-of-thoughts.sh:179:    # Return prompt for sub-generation
.claude/hooks/tree-of-thoughts.sh:180:    echo "$sub_branches_prompt" | jq --argjson parent "$branch_json" '. + {parent_branch: $parent}'
.claude/hooks/tree-of-thoughts.sh:181:}
.claude/hooks/tree-of-thoughts.sh:182:
.claude/hooks/tree-of-thoughts.sh:183:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:184:# MONTE CARLO TREE SEARCH (MCTS) simulation
.claude/hooks/tree-of-thoughts.sh:185:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:186:
.claude/hooks/tree-of-thoughts.sh:187:# Simplified MCTS: Select  Expand  Simulate  Backpropagate
.claude/hooks/tree-of-thoughts.sh:188:mcts_iteration() {
.claude/hooks/tree-of-thoughts.sh:189:    local problem="$1"
.claude/hooks/tree-of-thoughts.sh:190:    local context="$2"
.claude/hooks/tree-of-thoughts.sh:191:    local iterations="${3:-5}"
.claude/hooks/tree-of-thoughts.sh:192:
.claude/hooks/tree-of-thoughts.sh:193:    log "Running MCTS for $iterations iterations"
.claude/hooks/tree-of-thoughts.sh:194:
.claude/hooks/tree-of-thoughts.sh:195:    local mcts_prompt="Using Monte Carlo Tree Search to explore solution space:\\n\\nProblem: $problem\\nContext: $context\\nIterations: $iterations\\n\\nFor each iteration:\\n1. Select the most promising unexplored branch\\n2. Expand it with new sub-approaches\\n3. Simulate outcomes\\n4. Update scores based on results\\n\\nThis explores the solution space more thoroughly than simple branching."
.claude/hooks/tree-of-thoughts.sh:196:
.claude/hooks/tree-of-thoughts.sh:197:    jq -n \
.claude/hooks/tree-of-thoughts.sh:198:        --arg algo "monte_carlo_tree_search" \
.claude/hooks/tree-of-thoughts.sh:199:        --arg problem "$problem" \
.claude/hooks/tree-of-thoughts.sh:200:        --arg context "$context" \
.claude/hooks/tree-of-thoughts.sh:201:        --argjson iterations "$iterations" \
.claude/hooks/tree-of-thoughts.sh:202:        --arg prompt "$mcts_prompt" \
.claude/hooks/tree-of-thoughts.sh:203:        '{
.claude/hooks/tree-of-thoughts.sh:204:            algorithm: $algo,
.claude/hooks/tree-of-thoughts.sh:205:            problem: $problem,
.claude/hooks/tree-of-thoughts.sh:206:            context: $context,
.claude/hooks/tree-of-thoughts.sh:207:            iterations: $iterations,
.claude/hooks/tree-of-thoughts.sh:208:            process: [
.claude/hooks/tree-of-thoughts.sh:209:                "1. Selection: Choose most promising branch using UCB1",
.claude/hooks/tree-of-thoughts.sh:210:                "2. Expansion: Generate child branches",
.claude/hooks/tree-of-thoughts.sh:211:                "3. Simulation: Evaluate potential outcomes",
.claude/hooks/tree-of-thoughts.sh:212:                "4. Backpropagation: Update branch scores"
.claude/hooks/tree-of-thoughts.sh:213:            ],
.claude/hooks/tree-of-thoughts.sh:214:            prompt: $prompt
.claude/hooks/tree-of-thoughts.sh:215:        }'
.claude/hooks/tree-of-thoughts.sh:216:}
.claude/hooks/tree-of-thoughts.sh:217:
.claude/hooks/tree-of-thoughts.sh:218:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:219:# TREE PERSISTENCE AND VISUALIZATION
.claude/hooks/tree-of-thoughts.sh:220:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:221:
.claude/hooks/tree-of-thoughts.sh:222:# Save tree state
.claude/hooks/tree-of-thoughts.sh:223:save_tree_state() {
.claude/hooks/tree-of-thoughts.sh:224:    local tree_id="$1"
.claude/hooks/tree-of-thoughts.sh:225:    local tree_data="$2"
.claude/hooks/tree-of-thoughts.sh:226:
.claude/hooks/tree-of-thoughts.sh:227:    local tree_file="$TOT_STATE_DIR/${tree_id}.json"
.claude/hooks/tree-of-thoughts.sh:228:
.claude/hooks/tree-of-thoughts.sh:229:    echo "$tree_data" > "$tree_file"
.claude/hooks/tree-of-thoughts.sh:230:
.claude/hooks/tree-of-thoughts.sh:231:    log "Saved tree state: $tree_file"
.claude/hooks/tree-of-thoughts.sh:232:
.claude/hooks/tree-of-thoughts.sh:233:    echo "{\"status\":\"saved\",\"file\":\"$tree_file\"}"
.claude/hooks/tree-of-thoughts.sh:234:}
.claude/hooks/tree-of-thoughts.sh:235:
.claude/hooks/tree-of-thoughts.sh:236:# Load tree state
.claude/hooks/tree-of-thoughts.sh:237:load_tree_state() {
.claude/hooks/tree-of-thoughts.sh:238:    local tree_id="$1"
.claude/hooks/tree-of-thoughts.sh:239:
.claude/hooks/tree-of-thoughts.sh:240:    local tree_file="$TOT_STATE_DIR/${tree_id}.json"
.claude/hooks/tree-of-thoughts.sh:241:
.claude/hooks/tree-of-thoughts.sh:242:    if [[ ! -f "$tree_file" ]]; then
.claude/hooks/tree-of-thoughts.sh:243:        log "Tree not found: $tree_id"
.claude/hooks/tree-of-thoughts.sh:244:        echo "{\"error\":\"tree_not_found\"}"
.claude/hooks/tree-of-thoughts.sh:245:        return 1
.claude/hooks/tree-of-thoughts.sh:246:    fi
.claude/hooks/tree-of-thoughts.sh:247:
.claude/hooks/tree-of-thoughts.sh:248:    cat "$tree_file"
.claude/hooks/tree-of-thoughts.sh:249:}
.claude/hooks/tree-of-thoughts.sh:250:
.claude/hooks/tree-of-thoughts.sh:251:# Generate tree visualization
.claude/hooks/tree-of-thoughts.sh:252:visualize_tree() {
.claude/hooks/tree-of-thoughts.sh:253:    local tree_data="$1"
.claude/hooks/tree-of-thoughts.sh:254:
.claude/hooks/tree-of-thoughts.sh:255:    log "Generating tree visualization"
.claude/hooks/tree-of-thoughts.sh:256:
.claude/hooks/tree-of-thoughts.sh:257:    local visualization
.claude/hooks/tree-of-thoughts.sh:258:    visualization=$(echo "$tree_data" | jq -r '
.claude/hooks/tree-of-thoughts.sh:259:        if .branches then
.claude/hooks/tree-of-thoughts.sh:260:            "# Tree of Thoughts\n\n" +
.claude/hooks/tree-of-thoughts.sh:261:            (.branches[] | "## \(.name) (Score: \(.weighted_score // "N/A"))\n\n" +
.claude/hooks/tree-of-thoughts.sh:262:            "**Strategy:** \(.strategy)\n\n" +
.claude/hooks/tree-of-thoughts.sh:263:            "**Pros:** \(.pros | join(", "))\n\n" +
.claude/hooks/tree-of-thoughts.sh:264:            "**Cons:** \(.cons | join(", "))\n\n" +
.claude/hooks/tree-of-thoughts.sh:265:            "**Scores:**\n" +
.claude/hooks/tree-of-thoughts.sh:266:            "- Feasibility: \(.scores.feasibility)/10\n" +
.claude/hooks/tree-of-thoughts.sh:267:            "- Quality: \(.scores.quality)/10\n" +
.claude/hooks/tree-of-thoughts.sh:268:            "- Risk: \(.scores.risk)/10\n" +
.claude/hooks/tree-of-thoughts.sh:269:            "- Effort: \(.scores.effort)/10\n\n" +
.claude/hooks/tree-of-thoughts.sh:270:            "---\n\n")
.claude/hooks/tree-of-thoughts.sh:271:        else
.claude/hooks/tree-of-thoughts.sh:272:            "No branches to visualize"
.claude/hooks/tree-of-thoughts.sh:273:        end
.claude/hooks/tree-of-thoughts.sh:274:    ')
.claude/hooks/tree-of-thoughts.sh:275:
.claude/hooks/tree-of-thoughts.sh:276:    echo "$visualization"
.claude/hooks/tree-of-thoughts.sh:277:}
.claude/hooks/tree-of-thoughts.sh:278:
.claude/hooks/tree-of-thoughts.sh:279:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:280:# COMMAND INTERFACE
.claude/hooks/tree-of-thoughts.sh:281:# =============================================================================
.claude/hooks/tree-of-thoughts.sh:282:
.claude/hooks/tree-of-thoughts.sh:283:case "${1:-help}" in
.claude/hooks/tree-of-thoughts.sh:284:    generate)
.claude/hooks/tree-of-thoughts.sh:285:        # Generate thought branches
.claude/hooks/tree-of-thoughts.sh:286:        generate_thought_branches "${2:-problem}" "${3:-context}" "${4:-3}" "${5:-0}"
.claude/hooks/tree-of-thoughts.sh:287:        ;;
.claude/hooks/tree-of-thoughts.sh:288:    evaluate)
.claude/hooks/tree-of-thoughts.sh:289:        # Evaluate a single branch
.claude/hooks/tree-of-thoughts.sh:290:        evaluate_branch "${2:-{}}" "${3:-feasibility:0.3,quality:0.3,risk:0.2,effort:0.2}"
.claude/hooks/tree-of-thoughts.sh:291:        ;;
.claude/hooks/tree-of-thoughts.sh:292:    rank)
.claude/hooks/tree-of-thoughts.sh:293:        # Rank all branches
.claude/hooks/tree-of-thoughts.sh:294:        rank_branches "${2:-{}}" "${3:-feasibility:0.3,quality:0.3,risk:0.2,effort:0.2}"
.claude/hooks/tree-of-thoughts.sh:295:        ;;
.claude/hooks/tree-of-thoughts.sh:296:    select)
.claude/hooks/tree-of-thoughts.sh:297:        # Select best branch
.claude/hooks/tree-of-thoughts.sh:298:        select_best_branch "${2:-[]}" "${3:-highest_score}"
.claude/hooks/tree-of-thoughts.sh:299:        ;;
.claude/hooks/tree-of-thoughts.sh:300:    expand)
.claude/hooks/tree-of-thoughts.sh:301:        # Expand a branch
.claude/hooks/tree-of-thoughts.sh:302:        expand_branch "${2:-{}}" "${3:-2}" "${4:-0}"
.claude/hooks/tree-of-thoughts.sh:303:        ;;
.claude/hooks/tree-of-thoughts.sh:304:    mcts)
.claude/hooks/tree-of-thoughts.sh:305:        # Run MCTS
.claude/hooks/tree-of-thoughts.sh:306:        mcts_iteration "${2:-problem}" "${3:-context}" "${4:-5}"
.claude/hooks/tree-of-thoughts.sh:307:        ;;
.claude/hooks/tree-of-thoughts.sh:308:    save)
.claude/hooks/tree-of-thoughts.sh:309:        # Save tree state
.claude/hooks/tree-of-thoughts.sh:310:        save_tree_state "${2:-tree_id}" "${3:-{}}"
.claude/hooks/tree-of-thoughts.sh:311:        ;;
.claude/hooks/tree-of-thoughts.sh:312:    load)
.claude/hooks/tree-of-thoughts.sh:313:        # Load tree state
.claude/hooks/tree-of-thoughts.sh:314:        load_tree_state "${2:-tree_id}"
.claude/hooks/tree-of-thoughts.sh:315:        ;;
.claude/hooks/tree-of-thoughts.sh:316:    visualize)
.claude/hooks/tree-of-thoughts.sh:317:        # Visualize tree
.claude/hooks/tree-of-thoughts.sh:318:        visualize_tree "${2:-{}}"
.claude/hooks/tree-of-thoughts.sh:319:        ;;
.claude/hooks/tree-of-thoughts.sh:320:    help|*)
.claude/hooks/tree-of-thoughts.sh:321:        echo "Tree of Thoughts - Multi-Path Reasoning and Selection"
.claude/hooks/tree-of-thoughts.sh:322:        echo ""
.claude/hooks/tree-of-thoughts.sh:323:        echo "Usage: $0 <command> [args]"
.claude/hooks/tree-of-thoughts.sh:324:        echo ""
.claude/hooks/tree-of-thoughts.sh:325:        echo "Generation:"
.claude/hooks/tree-of-thoughts.sh:326:        echo "  generate <problem> <context> [num_branches] [depth]"
.claude/hooks/tree-of-thoughts.sh:327:        echo "                                     - Generate N different approaches"
.claude/hooks/tree-of-thoughts.sh:328:        echo ""
.claude/hooks/tree-of-thoughts.sh:329:        echo "Evaluation:"
.claude/hooks/tree-of-thoughts.sh:330:        echo "  evaluate <branch_json> [weights]   - Evaluate single branch"
.claude/hooks/tree-of-thoughts.sh:331:        echo "  rank <branches_json> [weights]     - Rank all branches"
.claude/hooks/tree-of-thoughts.sh:332:        echo "                                       Weights: 'feasibility:0.3,quality:0.3,risk:0.2,effort:0.2'"
.claude/hooks/tree-of-thoughts.sh:333:        echo ""
.claude/hooks/tree-of-thoughts.sh:334:        echo "Selection:"
.claude/hooks/tree-of-thoughts.sh:335:        echo "  select <ranked_branches> [strategy]"
.claude/hooks/tree-of-thoughts.sh:336:        echo "                                     - Select best branch"
.claude/hooks/tree-of-thoughts.sh:337:        echo "                                       Strategies: highest_score, risk_averse,"
.claude/hooks/tree-of-thoughts.sh:338:        echo "                                                   quick_win, high_quality"
.claude/hooks/tree-of-thoughts.sh:339:        echo ""
.claude/hooks/tree-of-thoughts.sh:340:        echo "Tree Expansion:"
.claude/hooks/tree-of-thoughts.sh:341:        echo "  expand <branch_json> [max_depth] [current_depth]"
.claude/hooks/tree-of-thoughts.sh:342:        echo "                                     - Expand branch into sub-branches"
.claude/hooks/tree-of-thoughts.sh:343:        echo "  mcts <problem> <context> [iterations]"
.claude/hooks/tree-of-thoughts.sh:344:        echo "                                     - Monte Carlo Tree Search"
.claude/hooks/tree-of-thoughts.sh:345:        echo ""
.claude/hooks/tree-of-thoughts.sh:346:        echo "Persistence:"
.claude/hooks/tree-of-thoughts.sh:347:        echo "  save <tree_id> <tree_data>         - Save tree state"
.claude/hooks/tree-of-thoughts.sh:348:        echo "  load <tree_id>                     - Load tree state"
.claude/hooks/tree-of-thoughts.sh:349:        echo "  visualize <tree_data>              - Generate markdown visualization"
.claude/hooks/tree-of-thoughts.sh:350:        echo ""
.claude/hooks/tree-of-thoughts.sh:351:        echo "Example workflow:"
.claude/hooks/tree-of-thoughts.sh:352:        echo "  1. prompt=\$($0 generate 'fix bug' 'auth module' 3)"
.claude/hooks/tree-of-thoughts.sh:353:        echo "  2. [Send to Claude, get branches]"
.claude/hooks/tree-of-thoughts.sh:354:        echo "  3. ranked=\$($0 rank \"\$branches\")"
.claude/hooks/tree-of-thoughts.sh:355:        echo "  4. best=\$($0 select \"\$ranked\" highest_score)"
.claude/hooks/tree-of-thoughts.sh:356:        echo "  5. [Execute the best approach]"
.claude/hooks/tree-of-thoughts.sh:357:        echo ""
.claude/hooks/tree-of-thoughts.sh:358:        echo "When to use ToT:"
.claude/hooks/tree-of-thoughts.sh:359:        echo "  - Tests failing after 2+ attempts"
.claude/hooks/tree-of-thoughts.sh:360:        echo "  - Complex architectural decisions"
.claude/hooks/tree-of-thoughts.sh:361:        echo "  - Multiple valid approaches exist"
.claude/hooks/tree-of-thoughts.sh:362:        echo "  - Need to explore solution space thoroughly"
.claude/hooks/tree-of-thoughts.sh:363:        ;;
.claude/hooks/tree-of-thoughts.sh:364:esac
.claude/hooks/self-healing.sh:1:#!/bin/bash
.claude/hooks/self-healing.sh:2:# Self-Healing System - Based on patterns from:
.claude/hooks/self-healing.sh:3:# - Roo-Code: recoverFromError, state management
.claude/hooks/self-healing.sh:4:# - claude-flow: circuit breaker, health checks
.claude/hooks/self-healing.sh:5:# - medusa: checkpointing with rollback
.claude/hooks/self-healing.sh:6:# - lmstudio-js: signal recovery
.claude/hooks/self-healing.sh:7:# - aiometadata: corrupted cache repair
.claude/hooks/self-healing.sh:8:
.claude/hooks/self-healing.sh:9:set -uo pipefail
.claude/hooks/self-healing.sh:10:
.claude/hooks/self-healing.sh:11:LOG_FILE="${HOME}/.claude/self-healing.log"
.claude/hooks/self-healing.sh:12:STATE_DIR=".claude"
.claude/hooks/self-healing.sh:13:HEALTH_FILE="${STATE_DIR}/health.json"
.claude/hooks/self-healing.sh:14:CIRCUIT_FILE="${STATE_DIR}/circuit-breaker.json"
.claude/hooks/self-healing.sh:15:CHECKPOINT_DIR="${STATE_DIR}/checkpoints"
.claude/hooks/self-healing.sh:16:
.claude/hooks/self-healing.sh:17:log() {
.claude/hooks/self-healing.sh:18:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/self-healing.sh:19:}
.claude/hooks/self-healing.sh:20:
.claude/hooks/self-healing.sh:21:# =============================================================================
.claude/hooks/self-healing.sh:22:# CIRCUIT BREAKER (from claude-flow pattern)
.claude/hooks/self-healing.sh:23:# Prevents repeated attempts at failing operations
.claude/hooks/self-healing.sh:24:# =============================================================================
.claude/hooks/self-healing.sh:25:
.claude/hooks/self-healing.sh:26:init_circuit_breaker() {
.claude/hooks/self-healing.sh:27:    mkdir -p "$STATE_DIR"
.claude/hooks/self-healing.sh:28:    if [[ ! -f "$CIRCUIT_FILE" ]]; then
.claude/hooks/self-healing.sh:29:        echo '{"failures":{},"open":{}}' > "$CIRCUIT_FILE"
.claude/hooks/self-healing.sh:30:    fi
.claude/hooks/self-healing.sh:31:}
.claude/hooks/self-healing.sh:32:
.claude/hooks/self-healing.sh:33:# Check if circuit is open (too many failures)
.claude/hooks/self-healing.sh:34:is_circuit_open() {
.claude/hooks/self-healing.sh:35:    local operation="$1"
.claude/hooks/self-healing.sh:36:    local threshold="${2:-5}"
.claude/hooks/self-healing.sh:37:
.claude/hooks/self-healing.sh:38:    init_circuit_breaker
.claude/hooks/self-healing.sh:39:
.claude/hooks/self-healing.sh:40:    local failures
.claude/hooks/self-healing.sh:41:    failures=$(jq -r ".failures[\"$operation\"] // 0" "$CIRCUIT_FILE")
.claude/hooks/self-healing.sh:42:    local is_open
.claude/hooks/self-healing.sh:43:    is_open=$(jq -r ".open[\"$operation\"] // false" "$CIRCUIT_FILE")
.claude/hooks/self-healing.sh:44:
.claude/hooks/self-healing.sh:45:    if [[ "$is_open" == "true" ]]; then
.claude/hooks/self-healing.sh:46:        # Check if reset timeout has passed (5 minutes)
.claude/hooks/self-healing.sh:47:        local open_time
.claude/hooks/self-healing.sh:48:        open_time=$(jq -r ".openTime[\"$operation\"] // 0" "$CIRCUIT_FILE")
.claude/hooks/self-healing.sh:49:        local now
.claude/hooks/self-healing.sh:50:        now=$(date +%s)
.claude/hooks/self-healing.sh:51:        local elapsed=$((now - open_time))
.claude/hooks/self-healing.sh:52:
.claude/hooks/self-healing.sh:53:        if [[ $elapsed -gt 300 ]]; then
.claude/hooks/self-healing.sh:54:            # Reset circuit to half-open (allow one attempt)
.claude/hooks/self-healing.sh:55:            log "Circuit half-open for $operation (timeout passed)"
.claude/hooks/self-healing.sh:56:            echo "half-open"
.claude/hooks/self-healing.sh:57:            return
.claude/hooks/self-healing.sh:58:        fi
.claude/hooks/self-healing.sh:59:        echo "open"
.claude/hooks/self-healing.sh:60:        return
.claude/hooks/self-healing.sh:61:    fi
.claude/hooks/self-healing.sh:62:
.claude/hooks/self-healing.sh:63:    if [[ $failures -ge $threshold ]]; then
.claude/hooks/self-healing.sh:64:        echo "open"
.claude/hooks/self-healing.sh:65:    else
.claude/hooks/self-healing.sh:66:        echo "closed"
.claude/hooks/self-healing.sh:67:    fi
.claude/hooks/self-healing.sh:68:}
.claude/hooks/self-healing.sh:69:
.claude/hooks/self-healing.sh:70:# Record a failure
.claude/hooks/self-healing.sh:71:record_failure() {
.claude/hooks/self-healing.sh:72:    local operation="$1"
.claude/hooks/self-healing.sh:73:
.claude/hooks/self-healing.sh:74:    init_circuit_breaker
.claude/hooks/self-healing.sh:75:
.claude/hooks/self-healing.sh:76:    local current
.claude/hooks/self-healing.sh:77:    current=$(jq -r ".failures[\"$operation\"] // 0" "$CIRCUIT_FILE")
.claude/hooks/self-healing.sh:78:    local new_count=$((current + 1))
.claude/hooks/self-healing.sh:79:
.claude/hooks/self-healing.sh:80:    # Update failures count
.claude/hooks/self-healing.sh:81:    local temp_file
.claude/hooks/self-healing.sh:82:    temp_file=$(mktemp)
.claude/hooks/self-healing.sh:83:    jq ".failures[\"$operation\"] = $new_count" "$CIRCUIT_FILE" > "$temp_file"
.claude/hooks/self-healing.sh:84:    mv "$temp_file" "$CIRCUIT_FILE"
.claude/hooks/self-healing.sh:85:
.claude/hooks/self-healing.sh:86:    # Open circuit if threshold reached
.claude/hooks/self-healing.sh:87:    if [[ $new_count -ge 5 ]]; then
.claude/hooks/self-healing.sh:88:        local now
.claude/hooks/self-healing.sh:89:        now=$(date +%s)
.claude/hooks/self-healing.sh:90:        temp_file=$(mktemp)
.claude/hooks/self-healing.sh:91:        jq ".open[\"$operation\"] = true | .openTime[\"$operation\"] = $now" "$CIRCUIT_FILE" > "$temp_file"
.claude/hooks/self-healing.sh:92:        mv "$temp_file" "$CIRCUIT_FILE"
.claude/hooks/self-healing.sh:93:        log "Circuit opened for $operation (failures: $new_count)"
.claude/hooks/self-healing.sh:94:    fi
.claude/hooks/self-healing.sh:95:}
.claude/hooks/self-healing.sh:96:
.claude/hooks/self-healing.sh:97:# Record a success (reset failures)
.claude/hooks/self-healing.sh:98:record_success() {
.claude/hooks/self-healing.sh:99:    local operation="$1"
.claude/hooks/self-healing.sh:100:
.claude/hooks/self-healing.sh:101:    init_circuit_breaker
.claude/hooks/self-healing.sh:102:
.claude/hooks/self-healing.sh:103:    local temp_file
.claude/hooks/self-healing.sh:104:    temp_file=$(mktemp)
.claude/hooks/self-healing.sh:105:    jq ".failures[\"$operation\"] = 0 | .open[\"$operation\"] = false" "$CIRCUIT_FILE" > "$temp_file"
.claude/hooks/self-healing.sh:106:    mv "$temp_file" "$CIRCUIT_FILE"
.claude/hooks/self-healing.sh:107:
.claude/hooks/self-healing.sh:108:    log "Circuit reset for $operation"
.claude/hooks/self-healing.sh:109:}
.claude/hooks/self-healing.sh:110:
.claude/hooks/self-healing.sh:111:# =============================================================================
.claude/hooks/self-healing.sh:112:# CHECKPOINTING (from medusa/Roo-Code patterns)
.claude/hooks/self-healing.sh:113:# Save state before risky operations, rollback on failure
.claude/hooks/self-healing.sh:114:# =============================================================================
.claude/hooks/self-healing.sh:115:
.claude/hooks/self-healing.sh:116:save_checkpoint() {
.claude/hooks/self-healing.sh:117:    local checkpoint_name="$1"
.claude/hooks/self-healing.sh:118:    local files_to_backup="${2:-}"  # Space-separated list of files
.claude/hooks/self-healing.sh:119:
.claude/hooks/self-healing.sh:120:    mkdir -p "$CHECKPOINT_DIR"
.claude/hooks/self-healing.sh:121:
.claude/hooks/self-healing.sh:122:    local checkpoint_id
.claude/hooks/self-healing.sh:123:    checkpoint_id=$(date +%Y%m%d_%H%M%S)_${checkpoint_name}
.claude/hooks/self-healing.sh:124:    local checkpoint_path="$CHECKPOINT_DIR/$checkpoint_id"
.claude/hooks/self-healing.sh:125:    mkdir -p "$checkpoint_path"
.claude/hooks/self-healing.sh:126:
.claude/hooks/self-healing.sh:127:    # Save metadata
.claude/hooks/self-healing.sh:128:    cat > "$checkpoint_path/metadata.json" << EOF
.claude/hooks/self-healing.sh:129:{
.claude/hooks/self-healing.sh:130:    "name": "$checkpoint_name",
.claude/hooks/self-healing.sh:131:    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
.claude/hooks/self-healing.sh:132:    "files": []
.claude/hooks/self-healing.sh:133:}
.claude/hooks/self-healing.sh:134:EOF
.claude/hooks/self-healing.sh:135:
.claude/hooks/self-healing.sh:136:    # Backup specified files
.claude/hooks/self-healing.sh:137:    if [[ -n "$files_to_backup" ]]; then
.claude/hooks/self-healing.sh:138:        for file in $files_to_backup; do
.claude/hooks/self-healing.sh:139:            if [[ -f "$file" ]]; then
.claude/hooks/self-healing.sh:140:                local backup_path="$checkpoint_path/$(basename "$file")"
.claude/hooks/self-healing.sh:141:                cp "$file" "$backup_path"
.claude/hooks/self-healing.sh:142:                log "Checkpointed: $file  $backup_path"
.claude/hooks/self-healing.sh:143:            fi
.claude/hooks/self-healing.sh:144:        done
.claude/hooks/self-healing.sh:145:    fi
.claude/hooks/self-healing.sh:146:
.claude/hooks/self-healing.sh:147:    # Also backup key state files
.claude/hooks/self-healing.sh:148:    for state_file in ".claude/current-build.local.md" "CLAUDE.md" ".claude/docs/debug-log.md"; do
.claude/hooks/self-healing.sh:149:        if [[ -f "$state_file" ]]; then
.claude/hooks/self-healing.sh:150:            cp "$state_file" "$checkpoint_path/" 2>/dev/null || true
.claude/hooks/self-healing.sh:151:        fi
.claude/hooks/self-healing.sh:152:    done
.claude/hooks/self-healing.sh:153:
.claude/hooks/self-healing.sh:154:    echo "$checkpoint_id"
.claude/hooks/self-healing.sh:155:    log "Checkpoint saved: $checkpoint_id"
.claude/hooks/self-healing.sh:156:}
.claude/hooks/self-healing.sh:157:
.claude/hooks/self-healing.sh:158:rollback_to_checkpoint() {
.claude/hooks/self-healing.sh:159:    local checkpoint_id="$1"
.claude/hooks/self-healing.sh:160:    local checkpoint_path="$CHECKPOINT_DIR/$checkpoint_id"
.claude/hooks/self-healing.sh:161:
.claude/hooks/self-healing.sh:162:    if [[ ! -d "$checkpoint_path" ]]; then
.claude/hooks/self-healing.sh:163:        log "Checkpoint not found: $checkpoint_id"
.claude/hooks/self-healing.sh:164:        return 1
.claude/hooks/self-healing.sh:165:    fi
.claude/hooks/self-healing.sh:166:
.claude/hooks/self-healing.sh:167:    # Restore all backed up files
.claude/hooks/self-healing.sh:168:    for backup_file in "$checkpoint_path"/*; do
.claude/hooks/self-healing.sh:169:        if [[ -f "$backup_file" ]] && [[ "$(basename "$backup_file")" != "metadata.json" ]]; then
.claude/hooks/self-healing.sh:170:            local filename
.claude/hooks/self-healing.sh:171:            filename=$(basename "$backup_file")
.claude/hooks/self-healing.sh:172:
.claude/hooks/self-healing.sh:173:            # Determine original location
.claude/hooks/self-healing.sh:174:            case "$filename" in
.claude/hooks/self-healing.sh:175:                current-build.local.md)
.claude/hooks/self-healing.sh:176:                    cp "$backup_file" ".claude/current-build.local.md"
.claude/hooks/self-healing.sh:177:                    ;;
.claude/hooks/self-healing.sh:178:                CLAUDE.md)
.claude/hooks/self-healing.sh:179:                    cp "$backup_file" "CLAUDE.md"
.claude/hooks/self-healing.sh:180:                    ;;
.claude/hooks/self-healing.sh:181:                debug-log.md)
.claude/hooks/self-healing.sh:182:                    cp "$backup_file" ".claude/docs/debug-log.md"
.claude/hooks/self-healing.sh:183:                    ;;
.claude/hooks/self-healing.sh:184:                *)
.claude/hooks/self-healing.sh:185:                    # For other files, restore to current directory
.claude/hooks/self-healing.sh:186:                    cp "$backup_file" "./$filename"
.claude/hooks/self-healing.sh:187:                    ;;
.claude/hooks/self-healing.sh:188:            esac
.claude/hooks/self-healing.sh:189:            log "Restored: $filename from checkpoint $checkpoint_id"
.claude/hooks/self-healing.sh:190:        fi
.claude/hooks/self-healing.sh:191:    done
.claude/hooks/self-healing.sh:192:
.claude/hooks/self-healing.sh:193:    log "Rollback complete to checkpoint: $checkpoint_id"
.claude/hooks/self-healing.sh:194:}
.claude/hooks/self-healing.sh:195:
.claude/hooks/self-healing.sh:196:get_latest_checkpoint() {
.claude/hooks/self-healing.sh:197:    ls -t "$CHECKPOINT_DIR" 2>/dev/null | head -1
.claude/hooks/self-healing.sh:198:}
.claude/hooks/self-healing.sh:199:
.claude/hooks/self-healing.sh:200:# =============================================================================
.claude/hooks/self-healing.sh:201:# HEALTH CHECKS (from claude-flow/TabbyML patterns)
.claude/hooks/self-healing.sh:202:# Monitor system health and trigger recovery
.claude/hooks/self-healing.sh:203:# =============================================================================
.claude/hooks/self-healing.sh:204:
.claude/hooks/self-healing.sh:205:perform_health_check() {
.claude/hooks/self-healing.sh:206:    mkdir -p "$STATE_DIR"
.claude/hooks/self-healing.sh:207:
.claude/hooks/self-healing.sh:208:    local health_status="healthy"
.claude/hooks/self-healing.sh:209:    local issues=()
.claude/hooks/self-healing.sh:210:
.claude/hooks/self-healing.sh:211:    # Check 1: State files integrity
.claude/hooks/self-healing.sh:212:    if [[ -f ".claude/current-build.local.md" ]]; then
.claude/hooks/self-healing.sh:213:        if ! head -1 ".claude/current-build.local.md" | grep -q "^---"; then
.claude/hooks/self-healing.sh:214:            issues+=("corrupted_build_state")
.claude/hooks/self-healing.sh:215:            health_status="degraded"
.claude/hooks/self-healing.sh:216:        fi
.claude/hooks/self-healing.sh:217:    fi
.claude/hooks/self-healing.sh:218:
.claude/hooks/self-healing.sh:219:    # Check 2: Debug log integrity
.claude/hooks/self-healing.sh:220:    if [[ -f ".claude/docs/debug-log.md" ]]; then
.claude/hooks/self-healing.sh:221:        if ! head -1 ".claude/docs/debug-log.md" | grep -q "^#"; then
.claude/hooks/self-healing.sh:222:            issues+=("corrupted_debug_log")
.claude/hooks/self-healing.sh:223:            health_status="degraded"
.claude/hooks/self-healing.sh:224:        fi
.claude/hooks/self-healing.sh:225:    fi
.claude/hooks/self-healing.sh:226:
.claude/hooks/self-healing.sh:227:    # Check 3: Check for stuck processes
.claude/hooks/self-healing.sh:228:    local stuck_count=0
.claude/hooks/self-healing.sh:229:    if [[ -f ".claude/docs/debug-log.md" ]]; then
.claude/hooks/self-healing.sh:230:        stuck_count=$(grep "STUCK" ".claude/docs/debug-log.md" 2>/dev/null | wc -l | tr -d ' ')
.claude/hooks/self-healing.sh:231:    fi
.claude/hooks/self-healing.sh:232:    stuck_count=$((stuck_count + 0))  # Ensure it's a number
.claude/hooks/self-healing.sh:233:    if [[ $stuck_count -gt 3 ]]; then
.claude/hooks/self-healing.sh:234:        issues+=("too_many_stuck_issues")
.claude/hooks/self-healing.sh:235:        health_status="degraded"
.claude/hooks/self-healing.sh:236:    fi
.claude/hooks/self-healing.sh:237:
.claude/hooks/self-healing.sh:238:    # Check 4: Circuit breaker status
.claude/hooks/self-healing.sh:239:    local open_circuits=0
.claude/hooks/self-healing.sh:240:    if [[ -f "$CIRCUIT_FILE" ]]; then
.claude/hooks/self-healing.sh:241:        open_circuits=$(jq '[.open | to_entries[] | select(.value == true)] | length' "$CIRCUIT_FILE" 2>/dev/null || echo "0")
.claude/hooks/self-healing.sh:242:    fi
.claude/hooks/self-healing.sh:243:    open_circuits=$((open_circuits + 0))  # Ensure it's a number
.claude/hooks/self-healing.sh:244:    if [[ $open_circuits -gt 0 ]]; then
.claude/hooks/self-healing.sh:245:        issues+=("circuits_open:$open_circuits")
.claude/hooks/self-healing.sh:246:        health_status="degraded"
.claude/hooks/self-healing.sh:247:    fi
.claude/hooks/self-healing.sh:248:
.claude/hooks/self-healing.sh:249:    # Check 5: Recent error rate
.claude/hooks/self-healing.sh:250:    local recent_errors=0
.claude/hooks/self-healing.sh:251:    if [[ -f "$LOG_FILE" ]]; then
.claude/hooks/self-healing.sh:252:        recent_errors=$(tail -100 "$LOG_FILE" 2>/dev/null | grep "ERROR\|FAIL" | wc -l | tr -d ' ')
.claude/hooks/self-healing.sh:253:    fi
.claude/hooks/self-healing.sh:254:    recent_errors=$((recent_errors + 0))  # Ensure it's a number
.claude/hooks/self-healing.sh:255:    if [[ $recent_errors -gt 10 ]]; then
.claude/hooks/self-healing.sh:256:        issues+=("high_error_rate:$recent_errors")
.claude/hooks/self-healing.sh:257:        health_status="unhealthy"
.claude/hooks/self-healing.sh:258:    fi
.claude/hooks/self-healing.sh:259:
.claude/hooks/self-healing.sh:260:    # Convert issues array to JSON
.claude/hooks/self-healing.sh:261:    local issues_json="[]"
.claude/hooks/self-healing.sh:262:    if [[ ${#issues[@]} -gt 0 ]]; then
.claude/hooks/self-healing.sh:263:        issues_json=$(printf '%s\n' "${issues[@]}" | jq -R . | jq -s .)
.claude/hooks/self-healing.sh:264:    fi
.claude/hooks/self-healing.sh:265:
.claude/hooks/self-healing.sh:266:    # Save health status
.claude/hooks/self-healing.sh:267:    cat > "$HEALTH_FILE" << EOF
.claude/hooks/self-healing.sh:268:{
.claude/hooks/self-healing.sh:269:    "status": "$health_status",
.claude/hooks/self-healing.sh:270:    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
.claude/hooks/self-healing.sh:271:    "issues": $issues_json,
.claude/hooks/self-healing.sh:272:    "checks": {
.claude/hooks/self-healing.sh:273:        "stuck_issues": $stuck_count,
.claude/hooks/self-healing.sh:274:        "circuits_open": ${open_circuits:-0},
.claude/hooks/self-healing.sh:275:        "recent_errors": $recent_errors
.claude/hooks/self-healing.sh:276:    }
.claude/hooks/self-healing.sh:277:}
.claude/hooks/self-healing.sh:278:EOF
.claude/hooks/self-healing.sh:279:
.claude/hooks/self-healing.sh:280:    log "Health check: $health_status (issues: ${issues[*]:-none})"
.claude/hooks/self-healing.sh:281:    echo "$health_status"
.claude/hooks/self-healing.sh:282:}
.claude/hooks/self-healing.sh:283:
.claude/hooks/self-healing.sh:284:# =============================================================================
.claude/hooks/self-healing.sh:285:# SELF-HEALING ACTIONS (from aiometadata/Roo-Code patterns)
.claude/hooks/self-healing.sh:286:# Attempt to repair common issues automatically
.claude/hooks/self-healing.sh:287:# =============================================================================
.claude/hooks/self-healing.sh:288:
.claude/hooks/self-healing.sh:289:attempt_self_healing() {
.claude/hooks/self-healing.sh:290:    local issue="$1"
.claude/hooks/self-healing.sh:291:
.claude/hooks/self-healing.sh:292:    log "Attempting self-healing for: $issue"
.claude/hooks/self-healing.sh:293:
.claude/hooks/self-healing.sh:294:    case "$issue" in
.claude/hooks/self-healing.sh:295:        corrupted_build_state)
.claude/hooks/self-healing.sh:296:            # Repair by recreating from last checkpoint or resetting
.claude/hooks/self-healing.sh:297:            local latest
.claude/hooks/self-healing.sh:298:            latest=$(get_latest_checkpoint)
.claude/hooks/self-healing.sh:299:            if [[ -n "$latest" ]]; then
.claude/hooks/self-healing.sh:300:                rollback_to_checkpoint "$latest"
.claude/hooks/self-healing.sh:301:                log "Healed: restored build state from checkpoint"
.claude/hooks/self-healing.sh:302:            else
.claude/hooks/self-healing.sh:303:                # Reset to clean state
.claude/hooks/self-healing.sh:304:                rm -f ".claude/current-build.local.md"
.claude/hooks/self-healing.sh:305:                log "Healed: removed corrupted build state"
.claude/hooks/self-healing.sh:306:            fi
.claude/hooks/self-healing.sh:307:            ;;
.claude/hooks/self-healing.sh:308:
.claude/hooks/self-healing.sh:309:        corrupted_debug_log)
.claude/hooks/self-healing.sh:310:            # Repair by recreating header
.claude/hooks/self-healing.sh:311:            local temp_file
.claude/hooks/self-healing.sh:312:            temp_file=$(mktemp)
.claude/hooks/self-healing.sh:313:            echo "# Debug Log" > "$temp_file"
.claude/hooks/self-healing.sh:314:            echo "" >> "$temp_file"
.claude/hooks/self-healing.sh:315:            echo "## Session Log" >> "$temp_file"
.claude/hooks/self-healing.sh:316:            echo "" >> "$temp_file"
.claude/hooks/self-healing.sh:317:            if [[ -f ".claude/docs/debug-log.md" ]]; then
.claude/hooks/self-healing.sh:318:                tail -n +2 ".claude/docs/debug-log.md" >> "$temp_file" 2>/dev/null || true
.claude/hooks/self-healing.sh:319:            fi
.claude/hooks/self-healing.sh:320:            mv "$temp_file" ".claude/docs/debug-log.md"
.claude/hooks/self-healing.sh:321:            log "Healed: repaired debug log header"
.claude/hooks/self-healing.sh:322:            ;;
.claude/hooks/self-healing.sh:323:
.claude/hooks/self-healing.sh:324:        too_many_stuck_issues)
.claude/hooks/self-healing.sh:325:            # Archive old stuck issues
.claude/hooks/self-healing.sh:326:            if [[ -f ".claude/docs/debug-log.md" ]]; then
.claude/hooks/self-healing.sh:327:                local archive_file=".claude/docs/debug-log-archive-$(date +%Y%m%d).md"
.claude/hooks/self-healing.sh:328:                mv ".claude/docs/debug-log.md" "$archive_file"
.claude/hooks/self-healing.sh:329:                # Create fresh debug log
.claude/hooks/self-healing.sh:330:                cat > ".claude/docs/debug-log.md" << 'EOF'
.claude/hooks/self-healing.sh:331:# Debug Log
.claude/hooks/self-healing.sh:332:
.claude/hooks/self-healing.sh:333:## Session Log
.claude/hooks/self-healing.sh:334:
.claude/hooks/self-healing.sh:335:---
.claude/hooks/self-healing.sh:336:
.claude/hooks/self-healing.sh:337:## Resolved Issues
.claude/hooks/self-healing.sh:338:
.claude/hooks/self-healing.sh:339:## Patterns Discovered
.claude/hooks/self-healing.sh:340:EOF
.claude/hooks/self-healing.sh:341:                log "Healed: archived debug log with stuck issues to $archive_file"
.claude/hooks/self-healing.sh:342:            fi
.claude/hooks/self-healing.sh:343:            ;;
.claude/hooks/self-healing.sh:344:
.claude/hooks/self-healing.sh:345:        circuits_open:*)
.claude/hooks/self-healing.sh:346:            # Reset all circuits after timeout
.claude/hooks/self-healing.sh:347:            if [[ -f "$CIRCUIT_FILE" ]]; then
.claude/hooks/self-healing.sh:348:                echo '{"failures":{},"open":{}}' > "$CIRCUIT_FILE"
.claude/hooks/self-healing.sh:349:                log "Healed: reset all circuit breakers"
.claude/hooks/self-healing.sh:350:            fi
.claude/hooks/self-healing.sh:351:            ;;
.claude/hooks/self-healing.sh:352:
.claude/hooks/self-healing.sh:353:        *)
.claude/hooks/self-healing.sh:354:            log "No self-healing action for: $issue"
.claude/hooks/self-healing.sh:355:            return 1
.claude/hooks/self-healing.sh:356:            ;;
.claude/hooks/self-healing.sh:357:    esac
.claude/hooks/self-healing.sh:358:
.claude/hooks/self-healing.sh:359:    return 0
.claude/hooks/self-healing.sh:360:}
.claude/hooks/self-healing.sh:361:
.claude/hooks/self-healing.sh:362:# =============================================================================
.claude/hooks/self-healing.sh:363:# RECOVERY FROM ERROR (from Roo-Code pattern)
.claude/hooks/self-healing.sh:364:# Full recovery when system is in error state
.claude/hooks/self-healing.sh:365:# =============================================================================
.claude/hooks/self-healing.sh:366:
.claude/hooks/self-healing.sh:367:recover_from_error() {
.claude/hooks/self-healing.sh:368:    log "Starting full error recovery..."
.claude/hooks/self-healing.sh:369:
.claude/hooks/self-healing.sh:370:    # 1. Perform health check
.claude/hooks/self-healing.sh:371:    local health
.claude/hooks/self-healing.sh:372:    health=$(perform_health_check)
.claude/hooks/self-healing.sh:373:
.claude/hooks/self-healing.sh:374:    # 2. If unhealthy, attempt healing
.claude/hooks/self-healing.sh:375:    if [[ "$health" != "healthy" ]]; then
.claude/hooks/self-healing.sh:376:        # Read issues from health file
.claude/hooks/self-healing.sh:377:        if [[ -f "$HEALTH_FILE" ]]; then
.claude/hooks/self-healing.sh:378:            local issues
.claude/hooks/self-healing.sh:379:            issues=$(jq -r '.issues[]' "$HEALTH_FILE" 2>/dev/null || echo "")
.claude/hooks/self-healing.sh:380:            for issue in $issues; do
.claude/hooks/self-healing.sh:381:                attempt_self_healing "$issue"
.claude/hooks/self-healing.sh:382:            done
.claude/hooks/self-healing.sh:383:        fi
.claude/hooks/self-healing.sh:384:    fi
.claude/hooks/self-healing.sh:385:
.claude/hooks/self-healing.sh:386:    # 3. Reset circuit breakers
.claude/hooks/self-healing.sh:387:    if [[ -f "$CIRCUIT_FILE" ]]; then
.claude/hooks/self-healing.sh:388:        echo '{"failures":{},"open":{}}' > "$CIRCUIT_FILE"
.claude/hooks/self-healing.sh:389:    fi
.claude/hooks/self-healing.sh:390:
.claude/hooks/self-healing.sh:391:    # 4. Clear any lock files
.claude/hooks/self-healing.sh:392:    rm -f ".claude/*.lock" 2>/dev/null || true
.claude/hooks/self-healing.sh:393:
.claude/hooks/self-healing.sh:394:    # 5. Re-check health
.claude/hooks/self-healing.sh:395:    health=$(perform_health_check)
.claude/hooks/self-healing.sh:396:
.claude/hooks/self-healing.sh:397:    log "Recovery complete. Health status: $health"
.claude/hooks/self-healing.sh:398:    echo "$health"
.claude/hooks/self-healing.sh:399:}
.claude/hooks/self-healing.sh:400:
.claude/hooks/self-healing.sh:401:# =============================================================================
.claude/hooks/self-healing.sh:402:# MAIN COMMAND INTERFACE
.claude/hooks/self-healing.sh:403:# =============================================================================
.claude/hooks/self-healing.sh:404:
.claude/hooks/self-healing.sh:405:case "${1:-help}" in
.claude/hooks/self-healing.sh:406:    health)
.claude/hooks/self-healing.sh:407:        perform_health_check
.claude/hooks/self-healing.sh:408:        ;;
.claude/hooks/self-healing.sh:409:    circuit-check)
.claude/hooks/self-healing.sh:410:        is_circuit_open "${2:-default}"
.claude/hooks/self-healing.sh:411:        ;;
.claude/hooks/self-healing.sh:412:    circuit-fail)
.claude/hooks/self-healing.sh:413:        record_failure "${2:-default}"
.claude/hooks/self-healing.sh:414:        ;;
.claude/hooks/self-healing.sh:415:    circuit-success)
.claude/hooks/self-healing.sh:416:        record_success "${2:-default}"
.claude/hooks/self-healing.sh:417:        ;;
.claude/hooks/self-healing.sh:418:    checkpoint)
.claude/hooks/self-healing.sh:419:        save_checkpoint "${2:-auto}" "${3:-}"
.claude/hooks/self-healing.sh:420:        ;;
.claude/hooks/self-healing.sh:421:    rollback)
.claude/hooks/self-healing.sh:422:        rollback_to_checkpoint "${2:-$(get_latest_checkpoint)}"
.claude/hooks/self-healing.sh:423:        ;;
.claude/hooks/self-healing.sh:424:    heal)
.claude/hooks/self-healing.sh:425:        attempt_self_healing "${2:-}"
.claude/hooks/self-healing.sh:426:        ;;
.claude/hooks/self-healing.sh:427:    recover)
.claude/hooks/self-healing.sh:428:        recover_from_error
.claude/hooks/self-healing.sh:429:        ;;
.claude/hooks/self-healing.sh:430:    status)
.claude/hooks/self-healing.sh:431:        if [[ -f "$HEALTH_FILE" ]]; then
.claude/hooks/self-healing.sh:432:            cat "$HEALTH_FILE"
.claude/hooks/self-healing.sh:433:        else
.claude/hooks/self-healing.sh:434:            echo '{"status":"unknown"}'
.claude/hooks/self-healing.sh:435:        fi
.claude/hooks/self-healing.sh:436:        ;;
.claude/hooks/self-healing.sh:437:    help|*)
.claude/hooks/self-healing.sh:438:        echo "Self-Healing System"
.claude/hooks/self-healing.sh:439:        echo ""
.claude/hooks/self-healing.sh:440:        echo "Usage: $0 <command> [args]"
.claude/hooks/self-healing.sh:441:        echo ""
.claude/hooks/self-healing.sh:442:        echo "Commands:"
.claude/hooks/self-healing.sh:443:        echo "  health              - Run health check"
.claude/hooks/self-healing.sh:444:        echo "  circuit-check <op>  - Check if circuit is open"
.claude/hooks/self-healing.sh:445:        echo "  circuit-fail <op>   - Record a failure"
.claude/hooks/self-healing.sh:446:        echo "  circuit-success <op>- Record a success"
.claude/hooks/self-healing.sh:447:        echo "  checkpoint <name>   - Save checkpoint"
.claude/hooks/self-healing.sh:448:        echo "  rollback [id]       - Rollback to checkpoint"
.claude/hooks/self-healing.sh:449:        echo "  heal <issue>        - Attempt to heal specific issue"
.claude/hooks/self-healing.sh:450:        echo "  recover             - Full error recovery"
.claude/hooks/self-healing.sh:451:        echo "  status              - Show current health status"
.claude/hooks/self-healing.sh:452:        ;;
.claude/hooks/self-healing.sh:453:esac
.claude/hooks/bounded-autonomy.sh:1:#!/bin/bash
.claude/hooks/bounded-autonomy.sh:2:# Bounded Autonomy - Safety guardrails and escalation paths
.claude/hooks/bounded-autonomy.sh:3:# Based on: Deloitte bounded autonomy patterns, enterprise AI governance
.claude/hooks/bounded-autonomy.sh:4:# Implements clear operational limits and human escalation
.claude/hooks/bounded-autonomy.sh:5:
.claude/hooks/bounded-autonomy.sh:6:set -eo pipefail
.claude/hooks/bounded-autonomy.sh:7:
.claude/hooks/bounded-autonomy.sh:8:CLAUDE_DIR="${HOME}/.claude"
.claude/hooks/bounded-autonomy.sh:9:LOG_FILE="${CLAUDE_DIR}/bounded-autonomy.log"
.claude/hooks/bounded-autonomy.sh:10:
.claude/hooks/bounded-autonomy.sh:11:log() {
.claude/hooks/bounded-autonomy.sh:12:    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
.claude/hooks/bounded-autonomy.sh:13:}
.claude/hooks/bounded-autonomy.sh:14:
.claude/hooks/bounded-autonomy.sh:15:# Define autonomy boundaries
.claude/hooks/bounded-autonomy.sh:16:get_autonomy_rules() {
.claude/hooks/bounded-autonomy.sh:17:    cat << 'EOF'
.claude/hooks/bounded-autonomy.sh:18:{
.claude/hooks/bounded-autonomy.sh:19:    "auto_allowed": {
.claude/hooks/bounded-autonomy.sh:20:        "description": "Actions that can be taken without approval",
.claude/hooks/bounded-autonomy.sh:21:        "actions": [
.claude/hooks/bounded-autonomy.sh:22:            "Read files",
.claude/hooks/bounded-autonomy.sh:23:            "Search code",
.claude/hooks/bounded-autonomy.sh:24:            "Run tests",
.claude/hooks/bounded-autonomy.sh:25:            "Run linters",
.claude/hooks/bounded-autonomy.sh:26:            "Edit files (< 100 lines changed)",
.claude/hooks/bounded-autonomy.sh:27:            "Add/update comments",
.claude/hooks/bounded-autonomy.sh:28:            "Fix linting errors",
.claude/hooks/bounded-autonomy.sh:29:            "Update dependencies (patch/minor versions)",
.claude/hooks/bounded-autonomy.sh:30:            "Create test files",
.claude/hooks/bounded-autonomy.sh:31:            "Fix test failures",
.claude/hooks/bounded-autonomy.sh:32:            "Update documentation",
.claude/hooks/bounded-autonomy.sh:33:            "Refactor without changing behavior (< 50 lines)"
.claude/hooks/bounded-autonomy.sh:34:        ],
.claude/hooks/bounded-autonomy.sh:35:        "limits": {
.claude/hooks/bounded-autonomy.sh:36:            "max_file_changes": 10,
.claude/hooks/bounded-autonomy.sh:37:            "max_lines_per_file": 100,
.claude/hooks/bounded-autonomy.sh:38:            "max_new_files": 3,
.claude/hooks/bounded-autonomy.sh:39:            "max_deletions": 20
.claude/hooks/bounded-autonomy.sh:40:        }
.claude/hooks/bounded-autonomy.sh:41:    },
.claude/hooks/bounded-autonomy.sh:42:    "requires_approval": {
.claude/hooks/bounded-autonomy.sh:43:        "description": "Actions requiring user confirmation",
.claude/hooks/bounded-autonomy.sh:44:        "actions": [
.claude/hooks/bounded-autonomy.sh:45:            "Architecture changes",
.claude/hooks/bounded-autonomy.sh:46:            "Database migrations",
.claude/hooks/bounded-autonomy.sh:47:            "External API integrations",
.claude/hooks/bounded-autonomy.sh:48:            "Security-sensitive code",
.claude/hooks/bounded-autonomy.sh:49:            "Large refactoring (> 100 lines)",
.claude/hooks/bounded-autonomy.sh:50:            "Dependency major version updates",
.claude/hooks/bounded-autonomy.sh:51:            "Configuration changes",
.claude/hooks/bounded-autonomy.sh:52:            "Delete files",
.claude/hooks/bounded-autonomy.sh:53:            "Modify build scripts",
.claude/hooks/bounded-autonomy.sh:54:            "Change CI/CD pipelines",
.claude/hooks/bounded-autonomy.sh:55:            "Install new dependencies"
.claude/hooks/bounded-autonomy.sh:56:        ],
.claude/hooks/bounded-autonomy.sh:57:        "escalation_triggers": [
.claude/hooks/bounded-autonomy.sh:58:            "Confidence < 70%",
.claude/hooks/bounded-autonomy.sh:59:            "High risk operation",
.claude/hooks/bounded-autonomy.sh:60:            "Multiple failures (> 2)",
.claude/hooks/bounded-autonomy.sh:61:            "Ambiguous requirements",
.claude/hooks/bounded-autonomy.sh:62:            "Security implications"
.claude/hooks/bounded-autonomy.sh:63:        ]
.claude/hooks/bounded-autonomy.sh:64:    },
.claude/hooks/bounded-autonomy.sh:65:    "prohibited": {
.claude/hooks/bounded-autonomy.sh:66:        "description": "Actions never allowed autonomously",
.claude/hooks/bounded-autonomy.sh:67:        "actions": [
.claude/hooks/bounded-autonomy.sh:68:            "Commit with --no-verify",
.claude/hooks/bounded-autonomy.sh:69:            "Force push to main/master",
.claude/hooks/bounded-autonomy.sh:70:            "Delete production data",
.claude/hooks/bounded-autonomy.sh:71:            "Expose secrets/credentials",
.claude/hooks/bounded-autonomy.sh:72:            "Bypass security checks",
.claude/hooks/bounded-autonomy.sh:73:            "Modify .git directory",
.claude/hooks/bounded-autonomy.sh:74:            "Change system files",
.claude/hooks/bounded-autonomy.sh:75:            "Deploy to production"
.claude/hooks/bounded-autonomy.sh:76:        ]
.claude/hooks/bounded-autonomy.sh:77:    }
.claude/hooks/bounded-autonomy.sh:78:}
.claude/hooks/bounded-autonomy.sh:79:EOF
.claude/hooks/bounded-autonomy.sh:80:}
.claude/hooks/bounded-autonomy.sh:81:
.claude/hooks/bounded-autonomy.sh:82:# Check if action requires approval
.claude/hooks/bounded-autonomy.sh:83:check_action_autonomy() {
.claude/hooks/bounded-autonomy.sh:84:    local action="$1"
.claude/hooks/bounded-autonomy.sh:85:    local context="$2"
.claude/hooks/bounded-autonomy.sh:86:
.claude/hooks/bounded-autonomy.sh:87:    log "Checking autonomy for action: $action"
.claude/hooks/bounded-autonomy.sh:88:
.claude/hooks/bounded-autonomy.sh:89:    local rules
.claude/hooks/bounded-autonomy.sh:90:    rules=$(get_autonomy_rules)
.claude/hooks/bounded-autonomy.sh:91:
.claude/hooks/bounded-autonomy.sh:92:    # Check if prohibited
.claude/hooks/bounded-autonomy.sh:93:    local prohibited
.claude/hooks/bounded-autonomy.sh:94:    prohibited=$(echo "$rules" | jq -r '.prohibited.actions[]')
.claude/hooks/bounded-autonomy.sh:95:    if echo "$prohibited" | grep -qi "$action"; then
.claude/hooks/bounded-autonomy.sh:96:        echo '{"allowed":false,"reason":"prohibited_action","requires":"user_intervention"}'
.claude/hooks/bounded-autonomy.sh:97:        return
.claude/hooks/bounded-autonomy.sh:98:    fi
.claude/hooks/bounded-autonomy.sh:99:
.claude/hooks/bounded-autonomy.sh:100:    # Check if requires approval
.claude/hooks/bounded-autonomy.sh:101:    local requires_approval
.claude/hooks/bounded-autonomy.sh:102:    requires_approval=$(echo "$rules" | jq -r '.requires_approval.actions[]')
.claude/hooks/bounded-autonomy.sh:103:    if echo "$requires_approval" | grep -qi "$action"; then
.claude/hooks/bounded-autonomy.sh:104:        echo '{"allowed":false,"reason":"requires_approval","requires":"user_confirmation","escalate":true}'
.claude/hooks/bounded-autonomy.sh:105:        return
.claude/hooks/bounded-autonomy.sh:106:    fi
.claude/hooks/bounded-autonomy.sh:107:
.claude/hooks/bounded-autonomy.sh:108:    # Check auto_allowed limits
.claude/hooks/bounded-autonomy.sh:109:    echo '{"allowed":true,"reason":"auto_allowed","limits":'"$(echo "$rules" | jq -c '.auto_allowed.limits')"'}'
.claude/hooks/bounded-autonomy.sh:110:}
.claude/hooks/bounded-autonomy.sh:111:
.claude/hooks/bounded-autonomy.sh:112:# Generate escalation message
.claude/hooks/bounded-autonomy.sh:113:generate_escalation() {
.claude/hooks/bounded-autonomy.sh:114:    local action="$1"
.claude/hooks/bounded-autonomy.sh:115:    local reason="$2"
.claude/hooks/bounded-autonomy.sh:116:    local context="$3"
.claude/hooks/bounded-autonomy.sh:117:
.claude/hooks/bounded-autonomy.sh:118:    cat << EOF
.claude/hooks/bounded-autonomy.sh:119:{
.claude/hooks/bounded-autonomy.sh:120:    "escalation": {
.claude/hooks/bounded-autonomy.sh:121:        "action": "$action",
.claude/hooks/bounded-autonomy.sh:122:        "reason": "$reason",
.claude/hooks/bounded-autonomy.sh:123:        "context": "$context",
.claude/hooks/bounded-autonomy.sh:124:        "message": " ESCALATION REQUIRED
.claude/hooks/bounded-autonomy.sh:125:
.claude/hooks/bounded-autonomy.sh:126:**Action:** $action
.claude/hooks/bounded-autonomy.sh:127:**Reason:** $reason
.claude/hooks/bounded-autonomy.sh:128:**Context:** $context
.claude/hooks/bounded-autonomy.sh:129:
.claude/hooks/bounded-autonomy.sh:130:This action requires your approval before I can proceed.
.claude/hooks/bounded-autonomy.sh:131:
.claude/hooks/bounded-autonomy.sh:132:**Options:**
.claude/hooks/bounded-autonomy.sh:133:1. Approve - I'll proceed with this action
.claude/hooks/bounded-autonomy.sh:134:2. Modify - Suggest changes to the approach
.claude/hooks/bounded-autonomy.sh:135:3. Reject - I'll try a different approach
.claude/hooks/bounded-autonomy.sh:136:
.claude/hooks/bounded-autonomy.sh:137:Please respond with your decision.",
.claude/hooks/bounded-autonomy.sh:138:        "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
.claude/hooks/bounded-autonomy.sh:139:    }
.claude/hooks/bounded-autonomy.sh:140:}
.claude/hooks/bounded-autonomy.sh:141:EOF
.claude/hooks/bounded-autonomy.sh:142:}
.claude/hooks/bounded-autonomy.sh:143:
.claude/hooks/bounded-autonomy.sh:144:case "${1:-help}" in
.claude/hooks/bounded-autonomy.sh:145:    check)
.claude/hooks/bounded-autonomy.sh:146:        check_action_autonomy "${2:-action}" "${3:-context}"
.claude/hooks/bounded-autonomy.sh:147:        ;;
.claude/hooks/bounded-autonomy.sh:148:    rules)
.claude/hooks/bounded-autonomy.sh:149:        get_autonomy_rules
.claude/hooks/bounded-autonomy.sh:150:        ;;
.claude/hooks/bounded-autonomy.sh:151:    escalate)
.claude/hooks/bounded-autonomy.sh:152:        generate_escalation "${2:-action}" "${3:-reason}" "${4:-context}"
.claude/hooks/bounded-autonomy.sh:153:        ;;
.claude/hooks/bounded-autonomy.sh:154:    help|*)
.claude/hooks/bounded-autonomy.sh:155:        echo "Bounded Autonomy - Safety Guardrails"
.claude/hooks/bounded-autonomy.sh:156:        echo "Usage: $0 <command> [args]"
.claude/hooks/bounded-autonomy.sh:157:        echo "  check <action> [context]  - Check if action is allowed"
.claude/hooks/bounded-autonomy.sh:158:        echo "  rules                     - Show autonomy rules"
.claude/hooks/bounded-autonomy.sh:159:        echo "  escalate <action> <reason> <context> - Generate escalation"
.claude/hooks/bounded-autonomy.sh:160:        ;;
.claude/hooks/bounded-autonomy.sh:161:esac