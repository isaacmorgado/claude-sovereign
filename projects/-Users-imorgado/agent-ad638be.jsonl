{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":"Use grep MCP (mcp__grep__searchGitHub) to search for patterns related to:\n1. \"playwright pin code\" - how others handle PIN authentication\n2. \"crawl4ai authenticated\" - authenticated crawling patterns\n3. \"playwright localStorage auth\" - localStorage-based auth\n\nFind practical code examples we can use to improve our crawler for collecting all Ken Kai course pages."},"uuid":"b45f4f99-a06f-4bb4-ba3b-d10d2ea25375","timestamp":"2026-01-12T08:30:03.041Z"}
{"parentUuid":"b45f4f99-a06f-4bb4-ba3b-d10d2ea25375","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NtovkeUpyreGianfwHznry","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017enDzzuDVeWfnaqnqM3Gfi","name":"mcp__grep__searchGitHub","input":{"query":"playwright pin code","language":["TypeScript","JavaScript"]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":18791,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":18791,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3Ar7kakigucX8e87iWB","type":"assistant","uuid":"b51df71e-a6c9-4d3f-9567-925d8c4f8342","timestamp":"2026-01-12T08:30:06.787Z"}
{"parentUuid":"b51df71e-a6c9-4d3f-9567-925d8c4f8342","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NtovkeUpyreGianfwHznry","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q8ExahqgVjx7CdtW4UjFL5","name":"mcp__grep__searchGitHub","input":{"query":"crawl4ai authenticated","language":["Python"]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":18791,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":18791,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3Ar7kakigucX8e87iWB","type":"assistant","uuid":"0c4d2787-12e3-4d12-b438-6781ce17fbb7","timestamp":"2026-01-12T08:30:07.568Z"}
{"parentUuid":"0c4d2787-12e3-4d12-b438-6781ce17fbb7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NtovkeUpyreGianfwHznry","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LFmoJwwCNbvdvQWyfmUC8Y","name":"mcp__grep__searchGitHub","input":{"query":"playwright localStorage auth","language":["TypeScript","JavaScript"]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":18791,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":18791,"ephemeral_1h_input_tokens":0},"output_tokens":216,"service_tier":"standard"}},"requestId":"req_011CX3Ar7kakigucX8e87iWB","type":"assistant","uuid":"5a55fbf2-c179-47a5-a832-debcae157714","timestamp":"2026-01-12T08:30:08.184Z"}
{"parentUuid":"5a55fbf2-c179-47a5-a832-debcae157714","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Unexpected token 'T', \"Too Many R\"... is not valid JSON","is_error":true,"tool_use_id":"toolu_017enDzzuDVeWfnaqnqM3Gfi"}]},"uuid":"45758551-bc0a-42a3-8721-b503daf8fff8","timestamp":"2026-01-12T08:30:08.466Z","toolUseResult":"Error: Unexpected token 'T', \"Too Many R\"... is not valid JSON"}
{"parentUuid":"45758551-bc0a-42a3-8721-b503daf8fff8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Unexpected token 'T', \"Too Many R\"... is not valid JSON","is_error":true,"tool_use_id":"toolu_01Q8ExahqgVjx7CdtW4UjFL5"}]},"uuid":"4c33ae2b-6244-499c-b14b-d50052116d2a","timestamp":"2026-01-12T08:30:08.663Z","toolUseResult":"Error: Unexpected token 'T', \"Too Many R\"... is not valid JSON"}
{"parentUuid":"4c33ae2b-6244-499c-b14b-d50052116d2a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Unexpected token 'T', \"Too Many R\"... is not valid JSON","is_error":true,"tool_use_id":"toolu_01LFmoJwwCNbvdvQWyfmUC8Y"}]},"uuid":"427a4c80-2e99-40c6-9d97-a6c255ed5148","timestamp":"2026-01-12T08:30:08.858Z","toolUseResult":"Error: Unexpected token 'T', \"Too Many R\"... is not valid JSON"}
{"parentUuid":"427a4c80-2e99-40c6-9d97-a6c255ed5148","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VHpfkVwnT8NhgDpZCyEXBq","type":"message","role":"assistant","content":[{"type":"text","text":"The grep MCP is rate-limited. Let me try alternative searches with web search instead:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":375,"cache_read_input_tokens":18791,"cache_creation":{"ephemeral_5m_input_tokens":375,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3ArYPfP7FyoGQyoewGh","type":"assistant","uuid":"4ca82b3a-fa9a-41d1-b2f0-e3a71db8add5","timestamp":"2026-01-12T08:30:12.545Z"}
{"parentUuid":"4ca82b3a-fa9a-41d1-b2f0-e3a71db8add5","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VHpfkVwnT8NhgDpZCyEXBq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FW9bh3ejUhnpqYy1RimdmD","name":"WebSearch","input":{"query":"playwright PIN code authentication automation example"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":375,"cache_read_input_tokens":18791,"cache_creation":{"ephemeral_5m_input_tokens":375,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3ArYPfP7FyoGQyoewGh","type":"assistant","uuid":"2524a4fc-b828-43ec-9b4e-bc29cc394ff2","timestamp":"2026-01-12T08:30:12.877Z"}
{"parentUuid":"2524a4fc-b828-43ec-9b4e-bc29cc394ff2","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VHpfkVwnT8NhgDpZCyEXBq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S9KzcWZC7Z34vuzmsrUGPh","name":"WebSearch","input":{"query":"crawl4ai authenticated session cookies example"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":375,"cache_read_input_tokens":18791,"cache_creation":{"ephemeral_5m_input_tokens":375,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3ArYPfP7FyoGQyoewGh","type":"assistant","uuid":"2248b1f1-54ca-4e7e-85cc-72c3ef07c196","timestamp":"2026-01-12T08:30:13.240Z"}
{"parentUuid":"2248b1f1-54ca-4e7e-85cc-72c3ef07c196","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VHpfkVwnT8NhgDpZCyEXBq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019SYMtMLaVTpDtTjyVduzHb","name":"WebSearch","input":{"query":"playwright localStorage setItem authentication persist session"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":375,"cache_read_input_tokens":18791,"cache_creation":{"ephemeral_5m_input_tokens":375,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3ArYPfP7FyoGQyoewGh","type":"assistant","uuid":"0a500722-0132-4d02-939c-446e6ac084e9","timestamp":"2026-01-12T08:30:13.636Z"}
{"parentUuid":"0a48c15f-5cd0-411f-8990-249371a91914","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019SYMtMLaVTpDtTjyVduzHb","type":"tool_result","content":"Web search results for query: \"playwright localStorage setItem authentication persist session\"\n\nLinks: [{\"title\":\"Authentication | Playwright\",\"url\":\"https://playwright.dev/docs/auth\"},{\"title\":\"Store authentication state across Playwright tests in applications that use sessionStorage\",\"url\":\"https://frontendrescue.com/posts/2023-07-28-session-storage-playwright\"},{\"title\":\"[Feature]: support sessionStorage option for storageState persistence & restoration · Issue #31108 · microsoft/playwright\",\"url\":\"https://github.com/microsoft/playwright/issues/31108\"},{\"title\":\"[Question] Persist Auth from Session Storage? · Issue #14062 · microsoft/playwright\",\"url\":\"https://github.com/microsoft/playwright/issues/14062\"},{\"title\":\"Working with Local Storage in Playwright | BrowserStack\",\"url\":\"https://www.browserstack.com/guide/playwright-local-storage\"},{\"title\":\"Authentication | Playwright Python\",\"url\":\"https://playwright.dev/python/docs/auth\"},{\"title\":\"Authentication | Playwright Java\",\"url\":\"https://playwright.dev/java/docs/auth\"},{\"title\":\"Sharing Session Storage in Playwright for .NET | NimblePros Blog\",\"url\":\"https://blog.nimblepros.com/blogs/sharing-session-storage-in-playwright-for-dotnet/\"},{\"title\":\"How to Maintain Authentication State in Playwright\",\"url\":\"https://roundproxies.com/blog/authentication-playwright/\"},{\"title\":\"Reuse Cookie and LocalStorage | playwright-ruby-client\",\"url\":\"https://playwright-ruby-client.vercel.app/docs/article/guides/use_storage_state\"}]\n\nBased on my search, here's what I found about persisting authentication sessions using localStorage in Playwright:\n\n## Playwright Authentication & localStorage Persistence\n\n### Key Concepts\n\nPlaywright executes tests in isolated environments called browser contexts. This isolation model improves reproducibility and prevents cascading test failures.(no content)Tests can load existing authenticated state. This eliminates the need to authenticate in every test and speeds up test execution.\n\n### Using `storageState` for localStorage and Cookies\n\nPlaywright has a great solution by giving an API to store the authenticated browser state in the page context's storageState. The storageState contains a snapshot of the current cookies and localStorage.(no content)Web apps use cookie-based or token-based authentication, where authenticated state is stored as cookies, in local storage or in IndexedDB. Playwright provides browser_context.storage_state() method that can be used to retrieve storage state from authenticated contexts and then create new contexts with prepopulated state.\n\n### Setting localStorage with `page.evaluate()`\n\nYou can set key-value pairs using page.evaluate() to simulate user data or preferences: `await page.evaluate(() => localStorage.setItem('key', 'value'));`\n\n### Recommended Approach: Setup Project\n\nRegardless of the authentication strategy you choose, you are likely to store authenticated browser state on the file system. We recommend creating a `playwright/.auth` directory and add it to your .gitignore. Your authentication routine will produce authenticated browser state and save it to a file in this playwright/.auth directory. Later on, tests will reuse this state and start already authenticated.\n\n### Session Storage (Different from localStorage)\n\nSession storage is specific to a particular domain and is not persisted across page loads. Playwright does not provide API to persist session storage, but the following snippet can be used to save/load session storage.(no content)Authentication state doesn't include session storage by default. Session storage is tab-specific and doesn't persist across page loads. If your app stores auth data in session storage, save and restore it manually using `page.evaluate(() => JSON.stringify(sessionStorage))` to save and `page.addInitScript` to restore.\n\n### Code Example for Saving/Loading State\n\n```javascript\n// Save storage state (includes localStorage and cookies)\nawait page.context().storageState({ path: 'playwright/.auth/user.json' });\n\n// Load in a new context\nconst context = await browser.newContext({ \n  storageState: 'playwright/.auth/user.json' \n});\n```\n\nThe browser state file may contain sensitive cookies and headers that could be used to impersonate you or your test account. We strongly discourage checking them into private or public repositories.\n\n\nREMINDER: You MUST include the sources above in your response to the user using markdown hyperlinks."}]},"uuid":"f5c43d32-2297-4248-b656-0bfadaf4fad0","timestamp":"2026-01-12T08:30:31.742Z","toolUseResult":{"query":"playwright localStorage setItem authentication persist session","results":[{"tool_use_id":"srvtoolu_01SQiU4SREuXTDJnrGb1hnax","content":[{"title":"Authentication | Playwright","url":"https://playwright.dev/docs/auth"},{"title":"Store authentication state across Playwright tests in applications that use sessionStorage","url":"https://frontendrescue.com/posts/2023-07-28-session-storage-playwright"},{"title":"[Feature]: support sessionStorage option for storageState persistence & restoration · Issue #31108 · microsoft/playwright","url":"https://github.com/microsoft/playwright/issues/31108"},{"title":"[Question] Persist Auth from Session Storage? · Issue #14062 · microsoft/playwright","url":"https://github.com/microsoft/playwright/issues/14062"},{"title":"Working with Local Storage in Playwright | BrowserStack","url":"https://www.browserstack.com/guide/playwright-local-storage"},{"title":"Authentication | Playwright Python","url":"https://playwright.dev/python/docs/auth"},{"title":"Authentication | Playwright Java","url":"https://playwright.dev/java/docs/auth"},{"title":"Sharing Session Storage in Playwright for .NET | NimblePros Blog","url":"https://blog.nimblepros.com/blogs/sharing-session-storage-in-playwright-for-dotnet/"},{"title":"How to Maintain Authentication State in Playwright","url":"https://roundproxies.com/blog/authentication-playwright/"},{"title":"Reuse Cookie and LocalStorage | playwright-ruby-client","url":"https://playwright-ruby-client.vercel.app/docs/article/guides/use_storage_state"}]},"Based on my search, here's what I found about persisting authentication sessions using localStorage in Playwright:\n\n## Playwright Authentication & localStorage Persistence\n\n### Key Concepts\n\nPlaywright executes tests in isolated environments called browser contexts. This isolation model improves reproducibility and prevents cascading test failures.(no content)Tests can load existing authenticated state. This eliminates the need to authenticate in every test and speeds up test execution.\n\n### Using `storageState` for localStorage and Cookies\n\nPlaywright has a great solution by giving an API to store the authenticated browser state in the page context's storageState. The storageState contains a snapshot of the current cookies and localStorage.(no content)Web apps use cookie-based or token-based authentication, where authenticated state is stored as cookies, in local storage or in IndexedDB. Playwright provides browser_context.storage_state() method that can be used to retrieve storage state from authenticated contexts and then create new contexts with prepopulated state.\n\n### Setting localStorage with `page.evaluate()`\n\nYou can set key-value pairs using page.evaluate() to simulate user data or preferences: `await page.evaluate(() => localStorage.setItem('key', 'value'));`\n\n### Recommended Approach: Setup Project\n\nRegardless of the authentication strategy you choose, you are likely to store authenticated browser state on the file system. We recommend creating a `playwright/.auth` directory and add it to your .gitignore. Your authentication routine will produce authenticated browser state and save it to a file in this playwright/.auth directory. Later on, tests will reuse this state and start already authenticated.\n\n### Session Storage (Different from localStorage)\n\nSession storage is specific to a particular domain and is not persisted across page loads. Playwright does not provide API to persist session storage, but the following snippet can be used to save/load session storage.(no content)Authentication state doesn't include session storage by default. Session storage is tab-specific and doesn't persist across page loads. If your app stores auth data in session storage, save and restore it manually using `page.evaluate(() => JSON.stringify(sessionStorage))` to save and `page.addInitScript` to restore.\n\n### Code Example for Saving/Loading State\n\n```javascript\n// Save storage state (includes localStorage and cookies)\nawait page.context().storageState({ path: 'playwright/.auth/user.json' });\n\n// Load in a new context\nconst context = await browser.newContext({ \n  storageState: 'playwright/.auth/user.json' \n});\n```\n\nThe browser state file may contain sensitive cookies and headers that could be used to impersonate you or your test account. We strongly discourage checking them into private or public repositories."],"durationSeconds":18.063884417000228}}
{"parentUuid":"f5c43d32-2297-4248-b656-0bfadaf4fad0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S9KzcWZC7Z34vuzmsrUGPh","type":"tool_result","content":"Web search results for query: \"crawl4ai authenticated session cookies example\"\n\nLinks: [{\"title\":\"crawl4ai/docs/examples/storage_state_tutorial.md at main · unclecode/crawl4ai\",\"url\":\"https://github.com/unclecode/crawl4ai/blob/main/docs/examples/storage_state_tutorial.md\"},{\"title\":\"Hooks & Auth - Crawl4AI Documentation (v0.7.x)\",\"url\":\"https://docs.crawl4ai.com/advanced/hooks-auth/\"},{\"title\":\"Identity Based Crawling - Crawl4AI Documentation (v0.7.x)\",\"url\":\"https://docs.crawl4ai.com/advanced/identity-based-crawling/\"},{\"title\":\"crawl4ai/docs/md_v2/blog/releases/0.4.2.md at main · unclecode/crawl4ai\",\"url\":\"https://github.com/unclecode/crawl4ai/blob/main/docs/md_v2/blog/releases/0.4.2.md\"},{\"title\":\"Webscraping in the AI Era: Craw4AI framework coding examination | by Albert Lee | Medium\",\"url\":\"https://medium.com/@albertlee_22659/webscraping-in-the-ai-era-craw4ai-framework-coding-examination-6a23f7b386d1\"},{\"title\":\"Browser Profiles and Identity Management | unclecode/crawl4ai | DeepWiki\",\"url\":\"https://deepwiki.com/unclecode/crawl4ai/3.2-multi-url-crawling-and-dispatchers\"},{\"title\":\"0.4.2 - Crawl4AI Documentation (v0.7.x)\",\"url\":\"https://docs.crawl4ai.com/blog/releases/0.4.2/\"},{\"title\":\"Overview - Crawl4AI Documentation (v0.7.x)\",\"url\":\"https://docs.crawl4ai.com/advanced/advanced-features/\"},{\"title\":\"Crawling with Crawl4AI. Web scraping in Python has… | by Harisudhan.S | Medium\",\"url\":\"https://medium.com/@speaktoharisudhan/crawling-with-crawl4ai-the-open-source-scraping-beast-9d32e6946ad4\"},{\"title\":\"How do I handle cookies and sessions in Crawlee? | WebScraping.AI\",\"url\":\"https://webscraping.ai/faq/crawlee/how-do-i-handle-cookies-and-sessions-in-crawlee\"}]\n\nBased on my search, here's what I found about using authenticated session cookies in Crawl4AI:\n\n## Crawl4AI Authenticated Session Cookies\n\n### Method 1: Using `storage_state` with a Dictionary\n\nYou can set a session cookie and localStorage entries by directly providing the data as a dictionary:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    storage_dict = {\n        \"cookies\": [\n            {\n                \"name\": \"session\",\n                \"value\": \"abcd1234\",\n                \"domain\": \"example.com\",\n                \"path\": \"/\",\n                \"expires\": 1675363572.037711,\n                \"httpOnly\": False,\n                \"secure\": False,\n                \"sameSite\": \"None\"\n            }\n        ],\n        \"origins\": [\n            {\n                \"origin\": \"https://example.com\",\n                \"localStorage\": [\n                    {\"name\": \"token\", \"value\": \"my_auth_token\"},\n                    {\"name\": \"refreshToken\", \"value\": \"my_refresh_token\"}\n                ]\n            }\n        ]\n    }\n    \n    async with AsyncWebCrawler(\n        headless=True,\n        storage_state=storage_dict\n    ) as crawler:\n        result = await crawler.arun(url='https://example.com/protected')\n        if result.success:\n            print(\"Crawl succeeded with pre-loaded session data!\")\n```\n\n### Method 2: Using a JSON File\n\nAfter logging in, the crawler exports the current session (cookies, localStorage, etc.) to my_storage_state.json. On subsequent runs, passing `storage_state=\"my_storage_state.json\"` starts the browser context with these tokens already in place, skipping the login steps.\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com/protected\",\n    storage_state=\"my_storage_state.json\"\n)\n```\n\n### Method 3: Identity-Based Crawling with Persistent Profiles\n\nYou can use a persistent data directory with BrowserConfig for identity-based crawling:\n\n```python\nfrom crawl4ai import AsyncWebCrawler, BrowserConfig, CrawlerRunConfig\n\nbrowser_config = BrowserConfig(\n    headless=True,\n    use_managed_browser=True,\n    browser_type=\"chromium\",\n    user_data_dir=\"/path/to/my-chrome-profile\"\n)\n```\n\nCrawl4AI's profile management system maintains persistent browser identities. Profiles preserve browser state (cookies, localStorage, authentication tokens) across crawling sessions, enabling authenticated access to websites that require login.\n\n### Key Features\n\nYou can pass local storage and cookies directly. Whether it's setting values programmatically or importing a saved JSON state, managing sessions has never been easier. This is a must-have for authenticated crawls—just export your storage state once and reuse it effortlessly across runs.(no content)By using storage_state, you can skip repetitive actions, like logging in, and jump straight into crawling protected content.\n\n\nREMINDER: You MUST include the sources above in your response to the user using markdown hyperlinks."}]},"uuid":"abb1be2c-fe39-4bc9-8074-a67e835c8f4c","timestamp":"2026-01-12T08:30:33.926Z","toolUseResult":{"query":"crawl4ai authenticated session cookies example","results":[{"tool_use_id":"srvtoolu_01Qpde7CWaXqwc7ChPXua9JV","content":[{"title":"crawl4ai/docs/examples/storage_state_tutorial.md at main · unclecode/crawl4ai","url":"https://github.com/unclecode/crawl4ai/blob/main/docs/examples/storage_state_tutorial.md"},{"title":"Hooks & Auth - Crawl4AI Documentation (v0.7.x)","url":"https://docs.crawl4ai.com/advanced/hooks-auth/"},{"title":"Identity Based Crawling - Crawl4AI Documentation (v0.7.x)","url":"https://docs.crawl4ai.com/advanced/identity-based-crawling/"},{"title":"crawl4ai/docs/md_v2/blog/releases/0.4.2.md at main · unclecode/crawl4ai","url":"https://github.com/unclecode/crawl4ai/blob/main/docs/md_v2/blog/releases/0.4.2.md"},{"title":"Webscraping in the AI Era: Craw4AI framework coding examination | by Albert Lee | Medium","url":"https://medium.com/@albertlee_22659/webscraping-in-the-ai-era-craw4ai-framework-coding-examination-6a23f7b386d1"},{"title":"Browser Profiles and Identity Management | unclecode/crawl4ai | DeepWiki","url":"https://deepwiki.com/unclecode/crawl4ai/3.2-multi-url-crawling-and-dispatchers"},{"title":"0.4.2 - Crawl4AI Documentation (v0.7.x)","url":"https://docs.crawl4ai.com/blog/releases/0.4.2/"},{"title":"Overview - Crawl4AI Documentation (v0.7.x)","url":"https://docs.crawl4ai.com/advanced/advanced-features/"},{"title":"Crawling with Crawl4AI. Web scraping in Python has… | by Harisudhan.S | Medium","url":"https://medium.com/@speaktoharisudhan/crawling-with-crawl4ai-the-open-source-scraping-beast-9d32e6946ad4"},{"title":"How do I handle cookies and sessions in Crawlee? | WebScraping.AI","url":"https://webscraping.ai/faq/crawlee/how-do-i-handle-cookies-and-sessions-in-crawlee"}]},"Based on my search, here's what I found about using authenticated session cookies in Crawl4AI:\n\n## Crawl4AI Authenticated Session Cookies\n\n### Method 1: Using `storage_state` with a Dictionary\n\nYou can set a session cookie and localStorage entries by directly providing the data as a dictionary:\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    storage_dict = {\n        \"cookies\": [\n            {\n                \"name\": \"session\",\n                \"value\": \"abcd1234\",\n                \"domain\": \"example.com\",\n                \"path\": \"/\",\n                \"expires\": 1675363572.037711,\n                \"httpOnly\": False,\n                \"secure\": False,\n                \"sameSite\": \"None\"\n            }\n        ],\n        \"origins\": [\n            {\n                \"origin\": \"https://example.com\",\n                \"localStorage\": [\n                    {\"name\": \"token\", \"value\": \"my_auth_token\"},\n                    {\"name\": \"refreshToken\", \"value\": \"my_refresh_token\"}\n                ]\n            }\n        ]\n    }\n    \n    async with AsyncWebCrawler(\n        headless=True,\n        storage_state=storage_dict\n    ) as crawler:\n        result = await crawler.arun(url='https://example.com/protected')\n        if result.success:\n            print(\"Crawl succeeded with pre-loaded session data!\")\n```\n\n### Method 2: Using a JSON File\n\nAfter logging in, the crawler exports the current session (cookies, localStorage, etc.) to my_storage_state.json. On subsequent runs, passing `storage_state=\"my_storage_state.json\"` starts the browser context with these tokens already in place, skipping the login steps.\n\n```python\nresult = await crawler.arun(\n    url=\"https://example.com/protected\",\n    storage_state=\"my_storage_state.json\"\n)\n```\n\n### Method 3: Identity-Based Crawling with Persistent Profiles\n\nYou can use a persistent data directory with BrowserConfig for identity-based crawling:\n\n```python\nfrom crawl4ai import AsyncWebCrawler, BrowserConfig, CrawlerRunConfig\n\nbrowser_config = BrowserConfig(\n    headless=True,\n    use_managed_browser=True,\n    browser_type=\"chromium\",\n    user_data_dir=\"/path/to/my-chrome-profile\"\n)\n```\n\nCrawl4AI's profile management system maintains persistent browser identities. Profiles preserve browser state (cookies, localStorage, authentication tokens) across crawling sessions, enabling authenticated access to websites that require login.\n\n### Key Features\n\nYou can pass local storage and cookies directly. Whether it's setting values programmatically or importing a saved JSON state, managing sessions has never been easier. This is a must-have for authenticated crawls—just export your storage state once and reuse it effortlessly across runs.(no content)By using storage_state, you can skip repetitive actions, like logging in, and jump straight into crawling protected content."],"durationSeconds":20.248782499999738}}
{"parentUuid":"abb1be2c-fe39-4bc9-8074-a67e835c8f4c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FW9bh3ejUhnpqYy1RimdmD","type":"tool_result","content":"Web search results for query: \"playwright PIN code authentication automation example\"\n\nLinks: [{\"title\":\"How to Manage Authentication in Playwright - Checkly Docs\",\"url\":\"https://www.checklyhq.com/docs/learn/playwright/authentication/\"},{\"title\":\"How to do authentication in Playwright Filip Hric\",\"url\":\"https://filiphric.com/how-to-do-authentication-in-playwright\"},{\"title\":\"Basic Authentication automation using Playwright · GitHub\",\"url\":\"https://gist.github.com/joewashington75/4baedd90623c155c4bec3e0befa7d268\"},{\"title\":\"Simple Playwright authentication recipes: A cookbook for software | Ministry of Testing\",\"url\":\"https://www.ministryoftesting.com/articles/simple-playwright-authentication-recipes-a-cookbook-for-software-testers\"},{\"title\":\"Playwright Login Test With Two Factor Authentication (2FA) Enabled (TOTP)\",\"url\":\"https://playwrightsolutions.com/playwright-login-test-with-2-factor-authentication-2fa-enabled/\"},{\"title\":\"How to automate two-factor authentication with Google Authenticator using Playwright - Letzdotesting\",\"url\":\"https://letzdotesting.com/how-to-automate-two-factor-authentication-with-google-authenticator-using-playwright/\"},{\"title\":\"Authentication | Playwright\",\"url\":\"https://playwright.bootcss.com/python/docs/auth\"},{\"title\":\"A Practical Guide: Automating Passkey Testing with Playwright and Authgear\",\"url\":\"https://www.oursky.com/blogs/a-practical-guide-automating-passkey-testing-with-playwright-and-authgear\"},{\"title\":\"Automating Playwright Checks for User Registration and Login | Better Stack Community\",\"url\":\"https://betterstack.com/community/guides/testing/playwright/playwright-e2e-automation/\"},{\"title\":\"Microsoft Playwright Testing authentication - Microsoft Playwright Testing | Microsoft Learn\",\"url\":\"https://learn.microsoft.com/en-us/azure/playwright-testing/how-to-manage-authentication\"}]\n\nBased on my search, here are the results for Playwright PIN code authentication automation examples:\n\n## Playwright Authentication Automation Examples\n\n### General Best Practices for Authentication\n\nWhen writing automation scripts that deal with authentication, you should use the Playwright Code Generator (`npx playwright codegen example.com`) to get the boilerplate code for any authentication flows, which saves time and lets you focus on the difficult parts.(no content)Never store credentials in your tests, not even during writing and debugging. Always use environment variables like `process.env.MY_PASSWORD`.(no content)Always add any `.env` files and the `/playwright/.auth/user.json` to your `.gitignore` file.\n\n### Two-Factor Authentication (2FA) with OTP/PIN Codes\n\nTo generate 6-digit TOTP codes in Playwright tests, you can use the Node package `otpauth`.\n\nHere's an example helper function from the search results:\n\n```typescript\n// lib/helpers/otp.ts\nimport * as OTPAuth from \"otpauth\";\n\nexport function generateOTP(secret: string) {\n  const totp = new OTPAuth.TOTP({\n    secret: secret,\n    digits: 6,\n    algorithm: \"sha1\",\n    period: 30,\n  });\n  return totp.generate();\n}\n```\n\nIn your test, you set the otpKey from the environment variable along with the email and passwords. You use these to login on the main page. The next section includes the `generateOTP()` method where you pass in the otpKey to generate the 6-digit code you will use to login.\n\n### Reusing Authentication State\n\nStoring state and reusing it in multiple tests is the best way to handle authentication. It reduces the time to execute tests and makes them more reliable. If your application is secured against brute force attacks, you will limit the number of requests to your login endpoint, which creates less strain on your backend and means you have a lesser chance to get locked out by captcha or other security measures.(no content)Web apps use cookie-based or token-based authentication where authenticated state is stored as cookies or in local storage. Playwright provides `browser_context.storage_state()` method that can be used to retrieve storage state from authenticated contexts and then create new contexts with prepopulated state.\n\n### Passkey/WebAuthn Authentication\n\nAll passkeys are an implementation based on the Web Authentication API (WebAuthn) spec and all Chrome Devtools Protocol (CDP) based browsers like Chrome and Edge ship with a WebAuthn Virtual Authenticator. This virtual authenticator allows you to automate the user interactions normally done by an actual human being.\n\nFor more detailed examples and code samples, check out:\n- [Checkly Docs - Authentication](https://www.checklyhq.com/docs/learn/playwright/authentication/)\n- [Playwright Solutions - 2FA Testing](https://playwrightsolutions.com/playwright-login-test-with-2-factor-authentication-2fa-enabled/)\n- [Filip Hric - Authentication in Playwright](https://filiphric.com/how-to-do-authentication-in-playwright)\n\n\nREMINDER: You MUST include the sources above in your response to the user using markdown hyperlinks."}]},"uuid":"8c590227-ca33-48d3-b0b4-92bce14e2ac6","timestamp":"2026-01-12T08:30:41.468Z","toolUseResult":{"query":"playwright PIN code authentication automation example","results":[{"tool_use_id":"srvtoolu_01Va7GLQpoBDx2CjX328S739","content":[{"title":"How to Manage Authentication in Playwright - Checkly Docs","url":"https://www.checklyhq.com/docs/learn/playwright/authentication/"},{"title":"How to do authentication in Playwright Filip Hric","url":"https://filiphric.com/how-to-do-authentication-in-playwright"},{"title":"Basic Authentication automation using Playwright · GitHub","url":"https://gist.github.com/joewashington75/4baedd90623c155c4bec3e0befa7d268"},{"title":"Simple Playwright authentication recipes: A cookbook for software | Ministry of Testing","url":"https://www.ministryoftesting.com/articles/simple-playwright-authentication-recipes-a-cookbook-for-software-testers"},{"title":"Playwright Login Test With Two Factor Authentication (2FA) Enabled (TOTP)","url":"https://playwrightsolutions.com/playwright-login-test-with-2-factor-authentication-2fa-enabled/"},{"title":"How to automate two-factor authentication with Google Authenticator using Playwright - Letzdotesting","url":"https://letzdotesting.com/how-to-automate-two-factor-authentication-with-google-authenticator-using-playwright/"},{"title":"Authentication | Playwright","url":"https://playwright.bootcss.com/python/docs/auth"},{"title":"A Practical Guide: Automating Passkey Testing with Playwright and Authgear","url":"https://www.oursky.com/blogs/a-practical-guide-automating-passkey-testing-with-playwright-and-authgear"},{"title":"Automating Playwright Checks for User Registration and Login | Better Stack Community","url":"https://betterstack.com/community/guides/testing/playwright/playwright-e2e-automation/"},{"title":"Microsoft Playwright Testing authentication - Microsoft Playwright Testing | Microsoft Learn","url":"https://learn.microsoft.com/en-us/azure/playwright-testing/how-to-manage-authentication"}]},"Based on my search, here are the results for Playwright PIN code authentication automation examples:\n\n## Playwright Authentication Automation Examples\n\n### General Best Practices for Authentication\n\nWhen writing automation scripts that deal with authentication, you should use the Playwright Code Generator (`npx playwright codegen example.com`) to get the boilerplate code for any authentication flows, which saves time and lets you focus on the difficult parts.(no content)Never store credentials in your tests, not even during writing and debugging. Always use environment variables like `process.env.MY_PASSWORD`.(no content)Always add any `.env` files and the `/playwright/.auth/user.json` to your `.gitignore` file.\n\n### Two-Factor Authentication (2FA) with OTP/PIN Codes\n\nTo generate 6-digit TOTP codes in Playwright tests, you can use the Node package `otpauth`.\n\nHere's an example helper function from the search results:\n\n```typescript\n// lib/helpers/otp.ts\nimport * as OTPAuth from \"otpauth\";\n\nexport function generateOTP(secret: string) {\n  const totp = new OTPAuth.TOTP({\n    secret: secret,\n    digits: 6,\n    algorithm: \"sha1\",\n    period: 30,\n  });\n  return totp.generate();\n}\n```\n\nIn your test, you set the otpKey from the environment variable along with the email and passwords. You use these to login on the main page. The next section includes the `generateOTP()` method where you pass in the otpKey to generate the 6-digit code you will use to login.\n\n### Reusing Authentication State\n\nStoring state and reusing it in multiple tests is the best way to handle authentication. It reduces the time to execute tests and makes them more reliable. If your application is secured against brute force attacks, you will limit the number of requests to your login endpoint, which creates less strain on your backend and means you have a lesser chance to get locked out by captcha or other security measures.(no content)Web apps use cookie-based or token-based authentication where authenticated state is stored as cookies or in local storage. Playwright provides `browser_context.storage_state()` method that can be used to retrieve storage state from authenticated contexts and then create new contexts with prepopulated state.\n\n### Passkey/WebAuthn Authentication\n\nAll passkeys are an implementation based on the Web Authentication API (WebAuthn) spec and all Chrome Devtools Protocol (CDP) based browsers like Chrome and Edge ship with a WebAuthn Virtual Authenticator. This virtual authenticator allows you to automate the user interactions normally done by an actual human being.\n\nFor more detailed examples and code samples, check out:\n- [Checkly Docs - Authentication](https://www.checklyhq.com/docs/learn/playwright/authentication/)\n- [Playwright Solutions - 2FA Testing](https://playwrightsolutions.com/playwright-login-test-with-2-factor-authentication-2fa-enabled/)\n- [Filip Hric - Authentication in Playwright](https://filiphric.com/how-to-do-authentication-in-playwright)"],"durationSeconds":27.792482124999164}}
{"parentUuid":"8c590227-ca33-48d3-b0b4-92bce14e2ac6","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Bs76RnVFpvR7GxgM2XuCfC","type":"message","role":"assistant","content":[{"type":"text","text":"Let me fetch more specific code examples from the documentation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2387,"cache_creation_input_tokens":1518,"cache_read_input_tokens":19166,"cache_creation":{"ephemeral_5m_input_tokens":1518,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3Atx2mje9nrNmFpXcVm","type":"assistant","uuid":"17abe18e-d25f-4018-a609-667d2d760f3e","timestamp":"2026-01-12T08:30:45.051Z"}
{"parentUuid":"17abe18e-d25f-4018-a609-667d2d760f3e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Bs76RnVFpvR7GxgM2XuCfC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011TuDg39N4Pz2fThmHaoSKV","name":"WebFetch","input":{"url":"https://docs.crawl4ai.com/advanced/hooks-auth/","prompt":"Extract all code examples for authenticated crawling, hooks, and session management. Include the complete Python code snippets."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2387,"cache_creation_input_tokens":1518,"cache_read_input_tokens":19166,"cache_creation":{"ephemeral_5m_input_tokens":1518,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3Atx2mje9nrNmFpXcVm","type":"assistant","uuid":"2b2543a1-5f04-4e5d-85f7-7028917448cb","timestamp":"2026-01-12T08:30:46.846Z"}
{"parentUuid":"2b2543a1-5f04-4e5d-85f7-7028917448cb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Bs76RnVFpvR7GxgM2XuCfC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CKs7RZy8X6owpS1DdboWr5","name":"WebFetch","input":{"url":"https://github.com/unclecode/crawl4ai/blob/main/docs/examples/storage_state_tutorial.md","prompt":"Extract all code examples showing how to use storage_state for authentication with cookies and localStorage. Include complete Python code."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2387,"cache_creation_input_tokens":1518,"cache_read_input_tokens":19166,"cache_creation":{"ephemeral_5m_input_tokens":1518,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3Atx2mje9nrNmFpXcVm","type":"assistant","uuid":"00923ec6-5d70-4df9-a544-8288d83ea13e","timestamp":"2026-01-12T08:30:48.370Z"}
{"parentUuid":"00923ec6-5d70-4df9-a544-8288d83ea13e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Bs76RnVFpvR7GxgM2XuCfC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B9F7g7tVyEMprHu5PXtCaJ","name":"WebFetch","input":{"url":"https://filiphric.com/how-to-do-authentication-in-playwright","prompt":"Extract code examples for persisting auth state, localStorage authentication, and session reuse in Playwright. Include JavaScript/TypeScript code."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2387,"cache_creation_input_tokens":1518,"cache_read_input_tokens":19166,"cache_creation":{"ephemeral_5m_input_tokens":1518,"ephemeral_1h_input_tokens":0},"output_tokens":318,"service_tier":"standard"}},"requestId":"req_011CX3Atx2mje9nrNmFpXcVm","type":"assistant","uuid":"345909c9-f04b-4641-ac45-f3f696f04855","timestamp":"2026-01-12T08:30:49.905Z"}
{"parentUuid":"345909c9-f04b-4641-ac45-f3f696f04855","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B9F7g7tVyEMprHu5PXtCaJ","type":"tool_result","content":"# Authentication State Management in Playwright\n\n## Persisting Browser State\n\nPlaywright allows you to capture and reuse authentication state across tests using `context.storageState`:\n\n```typescript\n// Save authentication state\nconst context = await browser.newContext();\nconst page = context.newPage();\nawait page.goto('https://example.com/login');\nawait page.fill('input[name=\"username\"]', 'user@example.com');\nawait page.fill('input[name=\"password\"]', 'password');\nawait page.click('button[type=\"submit\"]');\n\nconst storageState = await context.storageState({ \n  path: 'playwright/.auth.json' \n});\n```\n\n## Reusing Stored Authentication\n\nApply saved state to new test contexts using the `test.use` hook:\n\n```typescript\nimport { test, expect } from '@playwright/test';\n\nconst authFile = 'playwright/.auth.json';\n\ntest.use({ storageState: authFile });\n\ntest('authenticated user can access dashboard', async ({ page }) => {\n  await page.goto('/dashboard');\n  expect(await page.title()).toContain('Dashboard');\n});\n```\n\n## Global Setup Configuration\n\nConfigure `playwright.config.ts` to run authentication setup before all tests:\n\n```typescript\nexport default defineConfig({\n  projects: [\n    {\n      name: 'setup',\n      testMatch: /auth\\.setup\\.ts/,\n    },\n    {\n      name: 'chromium',\n      use: { \n        ...devices['Desktop Chrome'],\n        storageState: 'playwright/.auth.json',\n      },\n      dependencies: ['setup'],\n    },\n  ],\n});\n```\n\n## Setup File Example\n\nCreate `auth.setup.ts` to handle login once:\n\n```typescript\nimport { test as setup } from '@playwright/test';\n\nsetup('authenticate', async ({ browser }) => {\n  const context = await browser.newContext();\n  const page = context.newPage();\n  \n  // Perform login workflow\n  await page.goto('/login');\n  await page.fill('[name=\"email\"]', 'test@example.com');\n  await page.fill('[name=\"password\"]', 'securepassword');\n  await page.click('button:has-text(\"Login\")');\n  \n  await context.storageState({ \n    path: 'playwright/.auth.json' \n  });\n  await context.close();\n});\n```\n\n**Key Benefits:** Eliminates repetitive login sequences, reduces backend strain, increases test reliability."}]},"uuid":"8b5b72cf-8d8c-4c03-9ddb-340c2922b3cb","timestamp":"2026-01-12T08:30:57.703Z","toolUseResult":{"bytes":249291,"code":200,"codeText":"OK","result":"# Authentication State Management in Playwright\n\n## Persisting Browser State\n\nPlaywright allows you to capture and reuse authentication state across tests using `context.storageState`:\n\n```typescript\n// Save authentication state\nconst context = await browser.newContext();\nconst page = context.newPage();\nawait page.goto('https://example.com/login');\nawait page.fill('input[name=\"username\"]', 'user@example.com');\nawait page.fill('input[name=\"password\"]', 'password');\nawait page.click('button[type=\"submit\"]');\n\nconst storageState = await context.storageState({ \n  path: 'playwright/.auth.json' \n});\n```\n\n## Reusing Stored Authentication\n\nApply saved state to new test contexts using the `test.use` hook:\n\n```typescript\nimport { test, expect } from '@playwright/test';\n\nconst authFile = 'playwright/.auth.json';\n\ntest.use({ storageState: authFile });\n\ntest('authenticated user can access dashboard', async ({ page }) => {\n  await page.goto('/dashboard');\n  expect(await page.title()).toContain('Dashboard');\n});\n```\n\n## Global Setup Configuration\n\nConfigure `playwright.config.ts` to run authentication setup before all tests:\n\n```typescript\nexport default defineConfig({\n  projects: [\n    {\n      name: 'setup',\n      testMatch: /auth\\.setup\\.ts/,\n    },\n    {\n      name: 'chromium',\n      use: { \n        ...devices['Desktop Chrome'],\n        storageState: 'playwright/.auth.json',\n      },\n      dependencies: ['setup'],\n    },\n  ],\n});\n```\n\n## Setup File Example\n\nCreate `auth.setup.ts` to handle login once:\n\n```typescript\nimport { test as setup } from '@playwright/test';\n\nsetup('authenticate', async ({ browser }) => {\n  const context = await browser.newContext();\n  const page = context.newPage();\n  \n  // Perform login workflow\n  await page.goto('/login');\n  await page.fill('[name=\"email\"]', 'test@example.com');\n  await page.fill('[name=\"password\"]', 'securepassword');\n  await page.click('button:has-text(\"Login\")');\n  \n  await context.storageState({ \n    path: 'playwright/.auth.json' \n  });\n  await context.close();\n});\n```\n\n**Key Benefits:** Eliminates repetitive login sequences, reduces backend strain, increases test reliability.","durationMs":7761,"url":"https://filiphric.com/how-to-do-authentication-in-playwright"}}
{"parentUuid":"8b5b72cf-8d8c-4c03-9ddb-340c2922b3cb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CKs7RZy8X6owpS1DdboWr5","type":"tool_result","content":"# Storage State Authentication Examples for Crawl4ai\n\n## Overview\nThe tutorial demonstrates using `storage_state` to preserve session data (cookies and localStorage) across crawler instances, enabling pre-authenticated browsing without repeated logins.\n\n## Code Example 1: Dictionary-Based Storage State\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    storage_dict = {\n        \"cookies\": [\n            {\n                \"name\": \"session\",\n                \"value\": \"abcd1234\",\n                \"domain\": \"example.com\",\n                \"path\": \"/\",\n                \"expires\": 1675363572.037711,\n                \"httpOnly\": False,\n                \"secure\": False,\n                \"sameSite\": \"None\"\n            }\n        ],\n        \"origins\": [\n            {\n                \"origin\": \"https://example.com\",\n                \"localStorage\": [\n                    {\"name\": \"token\", \"value\": \"my_auth_token\"},\n                    {\"name\": \"refreshToken\", \"value\": \"my_refresh_token\"}\n                ]\n            }\n        ]\n    }\n\n    async with AsyncWebCrawler(\n        headless=True,\n        storage_state=storage_dict\n    ) as crawler:\n        result = await crawler.arun(url='https://example.com/protected')\n        if result.success:\n            print(\"Crawl succeeded with pre-loaded session data!\")\n            print(\"Page HTML length:\", len(result.html))\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Code Example 2: File-Based Storage State\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(\n        headless=True,\n        storage_state=\"mystate.json\"  # JSON file path\n    ) as crawler:\n        result = await crawler.arun(url='https://example.com/protected')\n        if result.success:\n            print(\"Crawl succeeded with pre-loaded session data!\")\n            print(\"Page HTML length:\", len(result.html))\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Code Example 3: Login Once, Reuse Pattern\n\n**First Run (Perform Login):**\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler, CacheMode\nfrom crawl4ai.markdown_generation_strategy import DefaultMarkdownGenerator\n\nasync def on_browser_created_hook(browser):\n    context = browser.contexts[0]\n    page = await context.new_page()\n    \n    await page.goto(\"https://example.com/login\", wait_until=\"domcontentloaded\")\n    \n    await page.fill(\"input[name='username']\", \"myuser\")\n    await page.fill(\"input[name='password']\", \"mypassword\")\n    await page.click(\"button[type='submit']\")\n    await page.wait_for_load_state(\"networkidle\")\n    \n    # Export session state for reuse\n    await context.storage_state(path=\"my_storage_state.json\")\n    await page.close()\n\nasync def main():\n    async with AsyncWebCrawler(\n        headless=True,\n        verbose=True,\n        hooks={\"on_browser_created\": on_browser_created_hook},\n        use_persistent_context=True,\n        user_data_dir=\"./my_user_data\"\n    ) as crawler:\n        result = await crawler.arun(\n            url='https://example.com/protected-page',\n            cache_mode=CacheMode.BYPASS,\n            markdown_generator=DefaultMarkdownGenerator(options={\"ignore_links\": True}),\n        )\n        print(\"First run result success:\", result.success)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n**Subsequent Runs (Reuse Saved State):**\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler, CacheMode\nfrom crawl4ai.markdown_generation_strategy import DefaultMarkdownGenerator\n\nasync def main():\n    async with AsyncWebCrawler(\n        headless=True,\n        verbose=True,\n        use_persistent_context=True,\n        user_data_dir=\"./my_user_data\",\n        storage_state=\"my_storage_state.json\"  # Reuse previously saved state\n    ) as crawler:\n        result = await crawler.arun(\n            url='https://example.com/protected-page',\n            cache_mode=CacheMode.BYPASS,\n            markdown_generator=DefaultMarkdownGenerator(options={\"ignore_links\": True}),\n        )\n        print(\"Second run result success:\", result.success)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Key Benefits\n\nThe approach enables developers to \"sign in once, use later\" by exporting authenticated session data and reusing it across multiple crawler instances, eliminating repetitive authentication overhead."}]},"uuid":"ce218c6a-9076-4040-b217-e2e47282a6d1","timestamp":"2026-01-12T08:30:59.474Z","toolUseResult":{"bytes":247086,"code":200,"codeText":"OK","result":"# Storage State Authentication Examples for Crawl4ai\n\n## Overview\nThe tutorial demonstrates using `storage_state` to preserve session data (cookies and localStorage) across crawler instances, enabling pre-authenticated browsing without repeated logins.\n\n## Code Example 1: Dictionary-Based Storage State\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    storage_dict = {\n        \"cookies\": [\n            {\n                \"name\": \"session\",\n                \"value\": \"abcd1234\",\n                \"domain\": \"example.com\",\n                \"path\": \"/\",\n                \"expires\": 1675363572.037711,\n                \"httpOnly\": False,\n                \"secure\": False,\n                \"sameSite\": \"None\"\n            }\n        ],\n        \"origins\": [\n            {\n                \"origin\": \"https://example.com\",\n                \"localStorage\": [\n                    {\"name\": \"token\", \"value\": \"my_auth_token\"},\n                    {\"name\": \"refreshToken\", \"value\": \"my_refresh_token\"}\n                ]\n            }\n        ]\n    }\n\n    async with AsyncWebCrawler(\n        headless=True,\n        storage_state=storage_dict\n    ) as crawler:\n        result = await crawler.arun(url='https://example.com/protected')\n        if result.success:\n            print(\"Crawl succeeded with pre-loaded session data!\")\n            print(\"Page HTML length:\", len(result.html))\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Code Example 2: File-Based Storage State\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    async with AsyncWebCrawler(\n        headless=True,\n        storage_state=\"mystate.json\"  # JSON file path\n    ) as crawler:\n        result = await crawler.arun(url='https://example.com/protected')\n        if result.success:\n            print(\"Crawl succeeded with pre-loaded session data!\")\n            print(\"Page HTML length:\", len(result.html))\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Code Example 3: Login Once, Reuse Pattern\n\n**First Run (Perform Login):**\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler, CacheMode\nfrom crawl4ai.markdown_generation_strategy import DefaultMarkdownGenerator\n\nasync def on_browser_created_hook(browser):\n    context = browser.contexts[0]\n    page = await context.new_page()\n    \n    await page.goto(\"https://example.com/login\", wait_until=\"domcontentloaded\")\n    \n    await page.fill(\"input[name='username']\", \"myuser\")\n    await page.fill(\"input[name='password']\", \"mypassword\")\n    await page.click(\"button[type='submit']\")\n    await page.wait_for_load_state(\"networkidle\")\n    \n    # Export session state for reuse\n    await context.storage_state(path=\"my_storage_state.json\")\n    await page.close()\n\nasync def main():\n    async with AsyncWebCrawler(\n        headless=True,\n        verbose=True,\n        hooks={\"on_browser_created\": on_browser_created_hook},\n        use_persistent_context=True,\n        user_data_dir=\"./my_user_data\"\n    ) as crawler:\n        result = await crawler.arun(\n            url='https://example.com/protected-page',\n            cache_mode=CacheMode.BYPASS,\n            markdown_generator=DefaultMarkdownGenerator(options={\"ignore_links\": True}),\n        )\n        print(\"First run result success:\", result.success)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n**Subsequent Runs (Reuse Saved State):**\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler, CacheMode\nfrom crawl4ai.markdown_generation_strategy import DefaultMarkdownGenerator\n\nasync def main():\n    async with AsyncWebCrawler(\n        headless=True,\n        verbose=True,\n        use_persistent_context=True,\n        user_data_dir=\"./my_user_data\",\n        storage_state=\"my_storage_state.json\"  # Reuse previously saved state\n    ) as crawler:\n        result = await crawler.arun(\n            url='https://example.com/protected-page',\n            cache_mode=CacheMode.BYPASS,\n            markdown_generator=DefaultMarkdownGenerator(options={\"ignore_links\": True}),\n        )\n        print(\"Second run result success:\", result.success)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Key Benefits\n\nThe approach enables developers to \"sign in once, use later\" by exporting authenticated session data and reusing it across multiple crawler instances, eliminating repetitive authentication overhead.","durationMs":9533,"url":"https://github.com/unclecode/crawl4ai/blob/main/docs/examples/storage_state_tutorial.md"}}
{"parentUuid":"ce218c6a-9076-4040-b217-e2e47282a6d1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011TuDg39N4Pz2fThmHaoSKV","type":"tool_result","content":"# Code Examples for Authenticated Crawling & Hooks\n\nBased on the documentation provided, here's the complete Python code snippet for implementing hooks and authentication:\n\n```python\nimport asyncio\nimport json\nfrom crawl4ai import AsyncWebCrawler, BrowserConfig, CrawlerRunConfig, CacheMode\nfrom playwright.async_api import Page, BrowserContext\n\nasync def main():\n    print(\"🔗 Hooks Example: Demonstrating recommended usage\")\n\n    # Configure the browser\n    browser_config = BrowserConfig(\n        headless=True,\n        verbose=True\n    )\n\n    # Configure the crawler run\n    crawler_run_config = CrawlerRunConfig(\n        js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n        wait_for=\"body\",\n        cache_mode=CacheMode.BYPASS\n    )\n\n    # Create the crawler instance\n    crawler = AsyncWebCrawler(config=browser_config)\n\n    # Define Hook Functions\n    async def on_browser_created(browser, **kwargs):\n        print(\"[HOOK] on_browser_created - Browser created successfully!\")\n        return browser\n\n    async def on_page_context_created(page: Page, context: BrowserContext, **kwargs):\n        print(\"[HOOK] on_page_context_created - Setting up page & context.\")\n\n        # Route filtering (e.g., block images)\n        async def route_filter(route):\n            if route.request.resource_type == \"image\":\n                print(f\"[HOOK] Blocking image request: {route.request.url}\")\n                await route.abort()\n            else:\n                await route.continue_()\n\n        await context.route(\"**\", route_filter)\n\n        # Optional: Simulate login scenario\n        # await page.goto(\"https://example.com/login\")\n        # await page.fill(\"input[name='username']\", \"testuser\")\n        # await page.fill(\"input[name='password']\", \"password123\")\n        # await page.click(\"button[type='submit']\")\n        # await page.wait_for_selector(\"#welcome\")\n        # await context.add_cookies([...])\n\n        # Adjust the viewport\n        await page.set_viewport_size({\"width\": 1080, \"height\": 600})\n        return page\n\n    async def before_goto(page: Page, context: BrowserContext, url: str, **kwargs):\n        print(f\"[HOOK] before_goto - About to navigate: {url}\")\n        await page.set_extra_http_headers({\n            \"Custom-Header\": \"my-value\"\n        })\n        return page\n\n    async def after_goto(page: Page, context: BrowserContext, url: str, response, **kwargs):\n        print(f\"[HOOK] after_goto - Successfully loaded: {url}\")\n        try:\n            await page.wait_for_selector('.content', timeout=1000)\n            print(\"[HOOK] Found .content element!\")\n        except:\n            print(\"[HOOK] .content not found, continuing anyway.\")\n        return page\n\n    async def on_user_agent_updated(page: Page, context: BrowserContext, user_agent: str, **kwargs):\n        print(f\"[HOOK] on_user_agent_updated - New user agent: {user_agent}\")\n        return page\n\n    async def on_execution_started(page: Page, context: BrowserContext, **kwargs):\n        print(\"[HOOK] on_execution_started - JS code is running!\")\n        return page\n\n    async def before_retrieve_html(page: Page, context: BrowserContext, **kwargs):\n        print(\"[HOOK] before_retrieve_html - We can do final actions\")\n        await page.evaluate(\"window.scrollTo(0, document.body.scrollHeight);\")\n        return page\n\n    async def before_return_html(page: Page, context: BrowserContext, html: str, **kwargs):\n        print(f\"[HOOK] before_return_html - HTML length: {len(html)}\")\n        return page\n\n    # Attach Hooks\n    crawler.crawler_strategy.set_hook(\"on_browser_created\", on_browser_created)\n    crawler.crawler_strategy.set_hook(\"on_page_context_created\", on_page_context_created)\n    crawler.crawler_strategy.set_hook(\"before_goto\", before_goto)\n    crawler.crawler_strategy.set_hook(\"after_goto\", after_goto)\n    crawler.crawler_strategy.set_hook(\"on_user_agent_updated\", on_user_agent_updated)\n    crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n    crawler.crawler_strategy.set_hook(\"before_retrieve_html\", before_retrieve_html)\n    crawler.crawler_strategy.set_hook(\"before_return_html\", before_return_html)\n\n    await crawler.start()\n\n    # Run the crawler on an example page\n    url = \"https://example.com\"\n    result = await crawler.arun(url, config=crawler_run_config)\n\n    if result.success:\n        print(\"\\nCrawled URL:\", result.url)\n        print(\"HTML length:\", len(result.html))\n    else:\n        print(\"Error:\", result.error_message)\n\n    await crawler.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Key Recommendations for Authentication\n\nThe documentation emphasizes: **\"Use `on_page_context_created` if you need to navigate to a login page or fill forms, set cookies or localStorage tokens, or block resource routes.\"**\n\nThis hook executes after the page and context are initialized but before navigating to the target URL, making it ideal for authentication workflows."}]},"uuid":"d4dbb1ad-463c-4840-a9c2-ea7bea5a1faa","timestamp":"2026-01-12T08:31:01.100Z","toolUseResult":{"bytes":66689,"code":200,"codeText":"OK","result":"# Code Examples for Authenticated Crawling & Hooks\n\nBased on the documentation provided, here's the complete Python code snippet for implementing hooks and authentication:\n\n```python\nimport asyncio\nimport json\nfrom crawl4ai import AsyncWebCrawler, BrowserConfig, CrawlerRunConfig, CacheMode\nfrom playwright.async_api import Page, BrowserContext\n\nasync def main():\n    print(\"🔗 Hooks Example: Demonstrating recommended usage\")\n\n    # Configure the browser\n    browser_config = BrowserConfig(\n        headless=True,\n        verbose=True\n    )\n\n    # Configure the crawler run\n    crawler_run_config = CrawlerRunConfig(\n        js_code=\"window.scrollTo(0, document.body.scrollHeight);\",\n        wait_for=\"body\",\n        cache_mode=CacheMode.BYPASS\n    )\n\n    # Create the crawler instance\n    crawler = AsyncWebCrawler(config=browser_config)\n\n    # Define Hook Functions\n    async def on_browser_created(browser, **kwargs):\n        print(\"[HOOK] on_browser_created - Browser created successfully!\")\n        return browser\n\n    async def on_page_context_created(page: Page, context: BrowserContext, **kwargs):\n        print(\"[HOOK] on_page_context_created - Setting up page & context.\")\n\n        # Route filtering (e.g., block images)\n        async def route_filter(route):\n            if route.request.resource_type == \"image\":\n                print(f\"[HOOK] Blocking image request: {route.request.url}\")\n                await route.abort()\n            else:\n                await route.continue_()\n\n        await context.route(\"**\", route_filter)\n\n        # Optional: Simulate login scenario\n        # await page.goto(\"https://example.com/login\")\n        # await page.fill(\"input[name='username']\", \"testuser\")\n        # await page.fill(\"input[name='password']\", \"password123\")\n        # await page.click(\"button[type='submit']\")\n        # await page.wait_for_selector(\"#welcome\")\n        # await context.add_cookies([...])\n\n        # Adjust the viewport\n        await page.set_viewport_size({\"width\": 1080, \"height\": 600})\n        return page\n\n    async def before_goto(page: Page, context: BrowserContext, url: str, **kwargs):\n        print(f\"[HOOK] before_goto - About to navigate: {url}\")\n        await page.set_extra_http_headers({\n            \"Custom-Header\": \"my-value\"\n        })\n        return page\n\n    async def after_goto(page: Page, context: BrowserContext, url: str, response, **kwargs):\n        print(f\"[HOOK] after_goto - Successfully loaded: {url}\")\n        try:\n            await page.wait_for_selector('.content', timeout=1000)\n            print(\"[HOOK] Found .content element!\")\n        except:\n            print(\"[HOOK] .content not found, continuing anyway.\")\n        return page\n\n    async def on_user_agent_updated(page: Page, context: BrowserContext, user_agent: str, **kwargs):\n        print(f\"[HOOK] on_user_agent_updated - New user agent: {user_agent}\")\n        return page\n\n    async def on_execution_started(page: Page, context: BrowserContext, **kwargs):\n        print(\"[HOOK] on_execution_started - JS code is running!\")\n        return page\n\n    async def before_retrieve_html(page: Page, context: BrowserContext, **kwargs):\n        print(\"[HOOK] before_retrieve_html - We can do final actions\")\n        await page.evaluate(\"window.scrollTo(0, document.body.scrollHeight);\")\n        return page\n\n    async def before_return_html(page: Page, context: BrowserContext, html: str, **kwargs):\n        print(f\"[HOOK] before_return_html - HTML length: {len(html)}\")\n        return page\n\n    # Attach Hooks\n    crawler.crawler_strategy.set_hook(\"on_browser_created\", on_browser_created)\n    crawler.crawler_strategy.set_hook(\"on_page_context_created\", on_page_context_created)\n    crawler.crawler_strategy.set_hook(\"before_goto\", before_goto)\n    crawler.crawler_strategy.set_hook(\"after_goto\", after_goto)\n    crawler.crawler_strategy.set_hook(\"on_user_agent_updated\", on_user_agent_updated)\n    crawler.crawler_strategy.set_hook(\"on_execution_started\", on_execution_started)\n    crawler.crawler_strategy.set_hook(\"before_retrieve_html\", before_retrieve_html)\n    crawler.crawler_strategy.set_hook(\"before_return_html\", before_return_html)\n\n    await crawler.start()\n\n    # Run the crawler on an example page\n    url = \"https://example.com\"\n    result = await crawler.arun(url, config=crawler_run_config)\n\n    if result.success:\n        print(\"\\nCrawled URL:\", result.url)\n        print(\"HTML length:\", len(result.html))\n    else:\n        print(\"Error:\", result.error_message)\n\n    await crawler.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n## Key Recommendations for Authentication\n\nThe documentation emphasizes: **\"Use `on_page_context_created` if you need to navigate to a login page or fill forms, set cookies or localStorage tokens, or block resource routes.\"**\n\nThis hook executes after the page and context are initialized but before navigating to the target URL, making it ideal for authentication workflows.","durationMs":11159,"url":"https://docs.crawl4ai.com/advanced/hooks-auth/"}}
{"parentUuid":"d4dbb1ad-463c-4840-a9c2-ea7bea5a1faa","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/.claude/tools","sessionId":"39080ac9-1d46-4e6e-8a22-ffc01545de99","version":"2.0.76","gitBranch":"","agentId":"ad638be","slug":"wild-fluttering-dusk","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Dqr4n9Prg5XV2MPbPQe3Qh","type":"message","role":"assistant","content":[{"type":"text","text":"Excellent! I found comprehensive code examples. Here is a summary of practical patterns for authenticated crawling:\n\n---\n\n## Research Summary: Authenticated Crawling Patterns\n\n### 1. Crawl4AI - Storage State for Authentication\n\n**Method A: Dictionary-based (Direct cookie/localStorage injection)**\n\n```python\nimport asyncio\nfrom crawl4ai import AsyncWebCrawler\n\nasync def main():\n    storage_dict = {\n        \"cookies\": [\n            {\n                \"name\": \"session\",\n                \"value\": \"abcd1234\",\n                \"domain\": \"example.com\",\n                \"path\": \"/\",\n                \"expires\": 1675363572.037711,\n                \"httpOnly\": False,\n                \"secure\": False,\n                \"sameSite\": \"None\"\n            }\n        ],\n        \"origins\": [\n            {\n                \"origin\": \"https://example.com\",\n                \"localStorage\": [\n                    {\"name\": \"token\", \"value\": \"my_auth_token\"},\n                    {\"name\": \"refreshToken\", \"value\": \"my_refresh_token\"}\n                ]\n            }\n        ]\n    }\n\n    async with AsyncWebCrawler(\n        headless=True,\n        storage_state=storage_dict\n    ) as crawler:\n        result = await crawler.arun(url='https://example.com/protected')\n```\n\n**Method B: Login once, export state, reuse**\n\n```python\n# First run - perform login and save state\nasync def on_browser_created_hook(browser):\n    context = browser.contexts[0]\n    page = await context.new_page()\n    \n    await page.goto(\"https://example.com/login\", wait_until=\"domcontentloaded\")\n    await page.fill(\"input[name='username']\", \"myuser\")\n    await page.fill(\"input[name='password']\", \"mypassword\")\n    await page.click(\"button[type='submit']\")\n    await page.wait_for_load_state(\"networkidle\")\n    \n    # Export session state\n    await context.storage_state(path=\"my_storage_state.json\")\n    await page.close()\n\n# Subsequent runs - reuse saved state\nasync with AsyncWebCrawler(\n    headless=True,\n    storage_state=\"my_storage_state.json\"\n) as crawler:\n    result = await crawler.arun(url='https://example.com/protected-page')\n```\n\n---\n\n### 2. Crawl4AI Hooks for Authentication\n\nUse the `on_page_context_created` hook for login flows:\n\n```python\nasync def on_page_context_created(page: Page, context: BrowserContext, **kwargs):\n    # Navigate to login page\n    await page.goto(\"https://example.com/login\")\n    await page.fill(\"input[name='username']\", \"testuser\")\n    await page.fill(\"input[name='password']\", \"password123\")\n    await page.click(\"button[type='submit']\")\n    await page.wait_for_selector(\"#welcome\")\n    \n    # Or set cookies directly\n    await context.add_cookies([{\n        \"name\": \"session\",\n        \"value\": \"token123\",\n        \"domain\": \"example.com\",\n        \"path\": \"/\"\n    }])\n    return page\n\ncrawler.crawler_strategy.set_hook(\"on_page_context_created\", on_page_context_created)\n```\n\n---\n\n### 3. Playwright - localStorage & Session Persistence\n\n**Save and restore authentication state:**\n\n```typescript\n// Save state after login\nawait page.context().storageState({ path: 'playwright/.auth/user.json' });\n\n// Create new context with saved state\nconst context = await browser.newContext({ \n  storageState: 'playwright/.auth/user.json' \n});\n```\n\n**Direct localStorage manipulation:**\n\n```typescript\n// Set localStorage values\nawait page.evaluate(() => {\n  localStorage.setItem('authToken', 'my_token_value');\n  localStorage.setItem('refreshToken', 'my_refresh_token');\n});\n```\n\n---\n\n### 4. PIN/OTP Code Handling with Playwright\n\nUse the `otpauth` package to generate TOTP codes:\n\n```typescript\nimport * as OTPAuth from \"otpauth\";\n\nexport function generateOTP(secret: string) {\n  const totp = new OTPAuth.TOTP({\n    secret: secret,\n    digits: 6,\n    algorithm: \"sha1\",\n    period: 30,\n  });\n  return totp.generate();\n}\n\n// In test:\nconst otpCode = generateOTP(process.env.OTP_SECRET);\nawait page.fill('input[name=\"pin\"]', otpCode);\n```\n\n---\n\n### Recommended Approach for Ken Kai Course Crawler\n\n1. **Manual login once** in headed mode to capture auth state\n2. **Export `storage_state` to JSON** containing cookies + localStorage tokens\n3. **Reuse JSON file** in subsequent crawl runs with `storage_state=\"auth.json\"`\n4. **Use hooks** if you need to handle dynamic re-authentication\n\n---\n\n### Sources\n\n- [Crawl4AI Hooks & Auth Documentation](https://docs.crawl4ai.com/advanced/hooks-auth/)\n- [Crawl4AI Storage State Tutorial](https://github.com/unclecode/crawl4ai/blob/main/docs/examples/storage_state_tutorial.md)\n- [Filip Hric - Authentication in Playwright](https://filiphric.com/how-to-do-authentication-in-playwright)\n- [Playwright Official Auth Docs](https://playwright.dev/docs/auth)\n- [Playwright 2FA with OTP](https://playwrightsolutions.com/playwright-login-test-with-2-factor-authentication-2fa-enabled/)"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1839,"cache_creation_input_tokens":4196,"cache_read_input_tokens":20684,"cache_creation":{"ephemeral_5m_input_tokens":4196,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CX3AvPidr4g64egE6B1iF","type":"assistant","uuid":"bf458b6d-9243-42a1-b0a5-bc2379592f43","timestamp":"2026-01-12T08:31:29.203Z"}
