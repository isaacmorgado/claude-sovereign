     1→// Maximum number of chunks that can be queued for word-level timestamp API processing
     2→const MAX_FILLER_WORDS_UPGRADE_QUEUE_SIZE = 2;
     3→
     4→/**
     5→ * Upgrades filler word detection accuracy by sending audio chunks to word-level timestamps API
     6→ */
     7→async function upgradeFillerWordsAccuracyIfRequired() {
     8→    console.log('filler_words_upgrade_accuracy_if_required');
     9→    
    10→    for (let chunkIndex = 0; chunkIndex < g_filler_words_chunks_status.length; chunkIndex++) {
    11→        if (g_filler_words_chunks_status[chunkIndex] === 'queued for sending to word level timestamps API') {
    12→            console.log('chunk ' + chunkIndex + ' is queued');
    13→            
    14→            // Disable UI buttons and show spinner
    15→            $('#button-remove-filler-words-markers').prop('disabled', true);
    16→            $('#button-remove-filler-words-go').prop('disabled', true);
    17→            $('#filler-words-processing-spinner').removeClass('hidden');
    18→            
    19→            // Clone current transcript for word-level processing
    20→            g_filler_words_transcript_word_level[chunkIndex] = JSON.parse(
    21→                JSON.stringify(g_filler_words_transcript[chunkIndex])
    22→            );
    23→            
    24→            // Check if queue is full
    25→            const queuedCount = g_filler_words_chunks_status.reduce(
    26→                (count, status) => count + (status === 'sent to word level timestamps API'),
    27→                0
    28→            );
    29→            
    30→            if (queuedCount >= MAX_FILLER_WORDS_UPGRADE_QUEUE_SIZE) {
    31→                console.log('queue is full');
    32→                continue;
    33→            }
    34→            
    35→            console.log('sending');
    36→            
    37→            try {
    38→                g_filler_words_chunks_status[chunkIndex] = 'sent to word level timestamps API';
    39→                
    40→                const audioFilePath = path.join(DIR_temporary_files, 'filler_words', chunkIndex + '_concat.mp3');
    41→                const transcript = g_filler_words_transcript[chunkIndex];
    42→                
    43→                const whisperResponse = await test_67_improve_accuracy_words_only_chunked(
    44→                    audioFilePath,
    45→                    transcript,
    46→                    0,
    47→                    'en',
    48→                    transcript.segments.map(segment => segment.id)
    49→                );
    50→                
    51→                const chunkStartOffset = g_filler_words_chunks[chunkIndex][0];
    52→                console.log('whisper_response_for_chunk', clone(whisperResponse));
    53→                
    54→                // Process each segment from the whisper response
    55→                for (let segmentIndex = 0; segmentIndex < whisperResponse.segments.length; segmentIndex++) {
    56→                    const segment = whisperResponse.segments[segmentIndex];
    57→                    segment.word_level_accuracy = true;
    58→                    segment.text = segment.text.trim();
    59→                    g_filler_words_transcript_word_level[chunkIndex].segments[segmentIndex] = segment;
    60→                    
    61→                    // Adjust word timestamps relative to chunk position
    62→                    for (let wordIndex = 0; wordIndex < segment.words.length; wordIndex++) {
    63→                        const word = segment.words[wordIndex];
    64→                        
    65→                        // Adjust start/end times relative to chunk offset and filler prompt duration
    66→                        word.start = Math.max(
    67→                            (word.start + chunkStartOffset) - filler_prompt_duration,
    68→                            0
    69→                        );
    70→                        word.end = Math.max(
    71→                            (word.end + chunkStartOffset) - filler_prompt_duration,
    72→                            0
    73→                        );
    74→                        
    75→                        // Handle edge case where start equals end
    76→                        if (word.start === word.end) {
    77→                            if (wordIndex > 0) {
    78→                                const prevWordEnd = whisperResponse.segments[segmentIndex].words[wordIndex - 1].end;
    79→                                word.start -= (word.start - prevWordEnd) / 2;
    80→                            }
    81→                            if (wordIndex < whisperResponse.segments[segmentIndex].words.length - 1) {
    82→                                const nextWordStart = whisperResponse.segments[segmentIndex].words[wordIndex + 1].start;
    83→                                word.end += (nextWordStart - word.end) / 2;
    84→                            }
    85→                        }
    86→                        
    87→                        word.word = word.word.trim();
    88→                        word.text = word.word;
    89→                        g_filler_words_transcript_word_level[chunkIndex].segments[segmentIndex].words[wordIndex] = word;
    90→                    }
    91→                }
    92→                
    93→                g_filler_words_chunks_status[chunkIndex] = 'upgraded to word level timestamps';
    94→                
    95→                // Re-enable UI
    96→                $('#button-remove-filler-words-markers').prop('disabled', false);
    97→                $('#button-remove-filler-words-go').prop('disabled', false);
    98→                $('#filler-words-processing-spinner').addClass('hidden');
    99→                
   100→                // Continue processing and update UI
   101→                upgradeFillerWordsAccuracyIfRequired();
   102→                writeHTML_filler_words_results();
   103→                adjust_filler_words_timestamps();
   104→                
   105→            } catch (error) {
   106→                g_filler_words_chunks_status[chunkIndex] = 'error';
   107→            }
   108→        }
   109→    }
   110→}
   111→
   112→/**
   113→ * Cleans a word by removing non-alphanumeric characters and converting to lowercase
   114→ */
   115→function cleanFillerWord(word) {
   116→    return word.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
   117→}
   118→
   119→/**
   120→ * Resets filler words state to defaults
   121→ */
   122→function resetFillerWords() {
   123→    g_filler_words = clone(g_filler_words_default);
   124→    g_filler_words_extended = clone(g_filler_words_default)
   125→        .concat(filler_word_prompt.split(', '))
   126→        .filter(word => word !== ' ' && word !== '');
   127→    g_filler_words_in = null;
   128→    g_filler_words_out = null;
   129→    g_filler_words_tags_selected = {};
   130→    g_filler_words_user_selected = {};
   131→    renderRemoveSilencesWordTags(g_filler_words);
   132→}
   133→
   134→/**
   135→ * Gets word at specified position in transcript
   136→ */
   137→function getWordAtTranscriptPosition(chunkIndex, segmentIndex, wordIndex) {
   138→    if (!g_filler_words_transcript[chunkIndex]) return null;
   139→    if (!g_filler_words_transcript[chunkIndex].segments[segmentIndex]) return null;
   140→    if (!g_filler_words_transcript[chunkIndex].segments[segmentIndex].words[wordIndex]) return null;
   141→    
   142→    const wordData = g_filler_words_transcript[chunkIndex].segments[segmentIndex].words[wordIndex];
   143→    let cleanedWord;
   144→    
   145→    if (typeof wordData === 'object') {
   146→        cleanedWord = cleanFillerWord(engine === 'web' ? wordData.text : wordData.word);
   147→    } else {
   148→        cleanedWord = cleanFillerWord(wordData);
   149→    }
   150→    
   151→    return {
   152→        chunk_index: chunkIndex,
   153→        segment_index: segmentIndex,
   154→        word_index: wordIndex,
   155→        word: cleanedWord
   156→    };
   157→}
   158→
   159→/**
   160→ * Gets the previous word in the transcript
   161→ */
   162→function getPreviousTranscriptWord(chunkIndex, segmentIndex, wordIndex) {
   163→    wordIndex -= 1;
   164→    
   165→    if (wordIndex < 0) {
   166→        segmentIndex -= 1;
   167→        if (segmentIndex < 0) {
   168→            chunkIndex -= 1;
   169→            segmentIndex = g_filler_words_transcript[chunkIndex].segments.length - 1;
   170→        }
   171→        wordIndex = g_filler_words_transcript[chunkIndex].segments[segmentIndex].words.length - 1;
   172→    }
   173→    
   174→    return getWordAtTranscriptPosition(chunkIndex, segmentIndex, wordIndex);
   175→}
   176→
   177→/**
   178→ * Gets the next word in the transcript
   179→ */
   180→function getNextTranscriptWord(chunkIndex, segmentIndex, wordIndex) {
   181→    // Try next word in same segment
   182→    let nextWord = getWordAtTranscriptPosition(chunkIndex, segmentIndex, wordIndex + 1);
   183→    if (nextWord) return nextWord;
   184→    
   185→    // Try first word of next segment
   186→    nextWord = getWordAtTranscriptPosition(chunkIndex, segmentIndex + 1, 0);
   187→    if (nextWord) return nextWord;
   188→    
   189→    // Try first word of next chunk
   190→    nextWord = getWordAtTranscriptPosition(chunkIndex + 1, 0, 0);
   191→    if (nextWord) return nextWord;
   192→    
   193→    return null;
   194→}
   195→
   196→/**
   197→ * Checks if word at position matches filler word tags
   198→ */
   199→function isFillerWordAtPositionByTags(chunkIndex, segmentIndex, wordIndex) {
   200→    const wordData = getWordAtTranscriptPosition(chunkIndex, segmentIndex, wordIndex);
   201→    if (wordData === null) return false;
   202→    
   203→    const cleanedWord = cleanFillerWord(wordData.word);
   204→    
   205→    for (let fillerWord of g_filler_words) {
   206→        const fillerParts = fillerWord.split(' ').map(part => cleanFillerWord(part));
   207→        
   208→        // Single word filler
   209→        if (fillerParts.length === 1 && matchFillerWord(fillerParts[0], cleanedWord)) {
   210→            addWordToFillerState(chunkIndex, segmentIndex, wordIndex, cleanedWord, true, g_filler_words_tags_selected);
   211→            return true;
   212→        }
   213→        
   214→        // Multi-word filler phrase
   215→        if (fillerParts.length > 1 && fillerParts.includes(cleanedWord)) {
   216→            matchLoop:
   217→            for (let partIndex = 0; partIndex < fillerParts.length; partIndex++) {
   218→                if (matchFillerWord(fillerParts[partIndex], cleanedWord)) {
   219→                    // Check previous words match
   220→                    let prevWord = wordData;
   221→                    for (let prevIndex = partIndex - 1; prevIndex >= 0; prevIndex--) {
   222→                        prevWord = getPreviousTranscriptWord(
   223→                            prevWord.chunk_index,
   224→                            prevWord.segment_index,
   225→                            prevWord.word_index
   226→                        );
   227→                        if (!prevWord || prevWord.word !== fillerParts[prevIndex]) {
   228→                            break matchLoop;
   229→                        }
   230→                    }
   231→                    
   232→                    // Check next words match
   233→                    let nextWord = wordData;
   234→                    for (let nextIndex = partIndex + 1; nextIndex < fillerParts.length; nextIndex++) {
   235→                        nextWord = getNextTranscriptWord(
   236→                            nextWord.chunk_index,
   237→                            nextWord.segment_index,
   238→                            nextWord.word_index
   239→                        );
   240→                        if (!prevWord || nextWord.word !== fillerParts[nextIndex]) {
   241→                            break matchLoop;
   242→                        }
   243→                    }
   244→                    
   245→                    // Check if not already in user selected state
   246→                    if (getFillerWordAtPosition(chunkIndex, segmentIndex, wordIndex, g_filler_words_user_selected) != null) {
   247→                        addWordToFillerState(chunkIndex, segmentIndex, wordIndex, cleanedWord, true, g_filler_words_user_selected);
   248→                    }
   249→                    addWordToFillerState(chunkIndex, segmentIndex, wordIndex, cleanedWord, true, g_filler_words_tags_selected);
   250→                    return true;
   251→                }
   252→            }
   253→        }
   254→    }
   255→    
   256→    // Check if already marked in tags
   257→    return getFillerWordAtPosition(chunkIndex, segmentIndex, wordIndex, g_filler_words_tags_selected) === true
   258→        ? true
   259→        : null;
   260→}
   261→
   262→/**
   263→ * Matches a filler word against a target word, handling similar sounds (um/uh/ah variants)
   264→ */
   265→function matchFillerWord(fillerWord, targetWord) {
   266→    const umVariants = g_filler_words.filter(word => filler_word_prompt_um.includes(word));
   267→    const uhVariants = g_filler_words.filter(word => filler_word_prompt_uh.includes(word));
   268→    const ahVariants = g_filler_words.filter(word => filler_word_prompt_ah.includes(word));
   269→    
   270→    if (umVariants.length > 0 && filler_word_prompt_um.includes(targetWord)) {
   271→        return true;
   272→    }
   273→    if (uhVariants.length > 0 && filler_word_prompt_uh.includes(targetWord)) {
   274→        return true;
   275→    }
   276→    if (ahVariants.length > 0 && filler_word_prompt_ah.includes(targetWord)) {
   277→        return true;
   278→    }
   279→    
   280→    return fillerWord === targetWord;
   281→}
   282→
   283→/**
   284→ * Gets filler word state at a specific position
   285→ */
   286→function getFillerWordAtPosition(chunkIndex, segmentIndex, wordIndex, stateObject) {
   287→    if (stateObject[chunkIndex] && 
   288→        stateObject[chunkIndex][segmentIndex] && 
   289→        stateObject[chunkIndex][segmentIndex][wordIndex]) {
   290→        return stateObject[chunkIndex][segmentIndex][wordIndex].remove;
   291→    }
   292→    return null;
   293→}
   294→
   295→/**
   296→ * Adds a word to the filler words state
   297→ */
   298→function addWordToFillerState(chunkIndex, segmentIndex, wordIndex, word, shouldRemove, stateObject) {
   299→    if (!stateObject[chunkIndex]) {
   300→        stateObject[chunkIndex] = {};
   301→    }
   302→    if (!stateObject[chunkIndex][segmentIndex]) {
   303→        stateObject[chunkIndex][segmentIndex] = {};
   304→    }
   305→    stateObject[chunkIndex][segmentIndex][wordIndex] = {
   306→        remove: shouldRemove,
   307→        word: word
   308→    };
   309→}
   310→
   311→/**
   312→ * Checks if word at transcript position is marked as filler
   313→ */
   314→function isWordFillerAtTranscriptPosition(chunkIndex, segmentIndex, wordIndex) {
   315→    let isFillerByTags = isFillerWordAtPositionByTags(chunkIndex, segmentIndex, wordIndex);
   316→    const userSelection = getFillerWordAtPosition(chunkIndex, segmentIndex, wordIndex, g_filler_words_user_selected);
   317→    
   318→    if (userSelection !== null) {
   319→        isFillerByTags = userSelection;
   320→    }
   321→    
   322→    return isFillerByTags;
   323→}
   324→
   325→/**
   326→ * Updates filler word removal state for words matching a pattern
   327→ */
   328→function updateFillerWordRemovalStates(pattern, shouldRemove, stateObject) {
   329→    if (!pattern) return;
   330→    
   331→    const words = pattern.split(' ');
   332→    
   333→    for (let word of words) {
   334→        word = cleanFillerWord(word);
   335→        
   336→        for (let chunkIndex in stateObject) {
   337→            const chunk = stateObject[chunkIndex];
   338→            for (let segmentIndex in chunk) {
   339→                const segment = chunk[segmentIndex];
   340→                for (let wordIndex in segment) {
   341→                    const wordState = segment[wordIndex];
   342→                    if (matchFillerWord(wordState.word, word)) {
   343→                        wordState.remove = shouldRemove;
   344→                    }
   345→                }
   346→            }
   347→        }
   348→    }
   349→}
   350→
   351→/**
   352→ * Gets timing ranges for all filler words to be removed
   353→ */
   354→function getFillerWordsTimings(mergeConsecutive) {
   355→    // Merge tag and user selections
   356→    const mergedState = {};
   357→    
   358→    for (let chunkIndex in g_filler_words_tags_selected) {
   359→        const chunk = g_filler_words_tags_selected[chunkIndex];
   360→        for (let segmentIndex in chunk) {
   361→            const segment = chunk[segmentIndex];
   362→            for (let wordIndex in segment) {
   363→                const wordState = segment[wordIndex];
   364→                addWordToFillerState(chunkIndex, segmentIndex, wordIndex, wordState.word, wordState.remove, mergedState);
   365→            }
   366→        }
   367→    }
   368→    
   369→    // User selections override tag selections
   370→    for (let chunkIndex in g_filler_words_user_selected) {
   371→        const chunk = g_filler_words_user_selected[chunkIndex];
   372→        for (let segmentIndex in chunk) {
   373→            const segment = chunk[segmentIndex];
   374→            for (let wordIndex in segment) {
   375→                const wordState = segment[wordIndex];
   376→                addWordToFillerState(chunkIndex, segmentIndex, wordIndex, wordState.word, wordState.remove, mergedState);
   377→            }
   378→        }
   379→    }
   380→    
   381→    const timingRanges = [];
   382→    let currentRange = [];
   383→    let previousWasFiller = false;
   384→    
   385→    for (let chunkIndex = 0; chunkIndex < g_filler_words_transcript_word_level_adjusted.length; chunkIndex++) {
   386→        const chunk = g_filler_words_transcript_word_level_adjusted[chunkIndex];
   387→        if (!chunk) continue;
   388→        
   389→        for (let segmentIndex = 0; segmentIndex < chunk.segments.length; segmentIndex++) {
   390→            const segment = chunk.segments[segmentIndex];
   391→            
   392→            for (let wordIndex = 0; wordIndex < segment.words.length; wordIndex++) {
   393→                const word = segment.words[wordIndex];
   394→                const isFillerWord = getFillerWordAtPosition(chunkIndex, segmentIndex, wordIndex, mergedState);
   395→                
   396→                if (!mergeConsecutive) {
   397→                    // Non-merging mode: each filler word gets its own timing
   398→                    if (isFillerWord) {
   399→                        const timing = [word.start, word.end];
   400→                        addWordTimingToSelection(timing, timingRanges);
   401→                    }
   402→                } else {
   403→                    // Merging mode: consecutive filler words are combined
   404→                    if (isFillerWord && currentRange.length === 0) {
   405→                        currentRange = [word.start, word.end];
   406→                    } else if (isFillerWord && previousWasFiller) {
   407→                        currentRange[1] = word.end;
   408→                    } else {
   409→                        addWordTimingToSelection(currentRange, timingRanges);
   410→                        currentRange = [];
   411→                    }
   412→                    previousWasFiller = isFillerWord;
   413→                }
   414→            }
   415→        }
   416→    }
   417→    
   418→    return timingRanges;
   419→}
   420→
   421→/**
   422→ * Adds a word timing to the selection if valid
   423→ */
   424→function addWordTimingToSelection(timing, timingRanges) {
   425→    if (timing[1] > timing[0]) {
   426→        console.log('Filler word timing was valid, adding to filler_words_selection');
   427→        timingRanges.push(clone(timing));
   428→    } else {
   429→        console.log('Filler word timing was invalid, not adding to filler_words_selection');
   430→    }
   431→}
   432→
   433→/**
   434→ * Selects a filler word in the transcript and positions the player
   435→ */
   436→function selectTranscriptFillerWord(
   437→    chunkIndex = null,
   438→    segmentIndex = null,
   439→    wordIndex = null,
   440→    unused1 = null,
   441→    unused2 = null,
   442→    startPadding = 0,
   443→    endPadding = 0
   444→) {
   445→    if (chunkIndex == null || segmentIndex == null || wordIndex == null) {
   446→        g_selected_transcript_word_level_filler = null;
   447→        return;
   448→    }
   449→    
   450→    // Check if word-level data is available, queue for upgrade if needed
   451→    if (g_filler_words_transcript_word_level_adjusted[chunkIndex] == null) {
   452→        if (g_filler_words_chunks_status[chunkIndex] === 'received from openai') {
   453→            g_filler_words_chunks_status[chunkIndex] = 'queued for sending to word level timestamps API';
   454→            upgradeFillerWordsAccuracyIfRequired();
   455→        }
   456→        return;
   457→    }
   458→    
   459→    g_selected_transcript_word_level_filler = {
   460→        chunk_index: chunkIndex,
   461→        segment_index: segmentIndex,
   462→        word_index: wordIndex
   463→    };
   464→    
   465→    const wordStart = g_filler_words_transcript_word_level_adjusted[chunkIndex].segments[segmentIndex].words[wordIndex].start;
   466→    const wordEnd = g_filler_words_transcript_word_level_adjusted[chunkIndex].segments[segmentIndex].words[wordIndex].end;
   467→    
   468→    let inPoint = wordStart + startPadding;
   469→    let outPoint = wordEnd - endPadding;
   470→    let shouldSetPoints = true;
   471→    
   472→    // Ensure minimum duration of 0.1 seconds
   473→    if (inPoint > outPoint - 0.1) {
   474→        shouldSetPoints = false;
   475→    }
   476→    
   477→    console.log('Moving to time section 2: ', inPoint, outPoint);
   478→    
   479→    if (shouldSetPoints) {
   480→        jsxProject.setInPoint(inPoint);
   481→        jsxProject.setOutPoint(outPoint);
   482→    }
   483→    jsxProject.setPlayerPosition(inPoint);
   484→}
   485→
   486→/**
   487→ * Removes invalid segments (null or zero/negative duration)
   488→ */
   489→function removeBadSegments(transcript) {
   490→    for (let i = 0; i < transcript.segments.length; i++) {
   491→        const segment = transcript.segments[i];
   492→        if (segment.start == null || segment.end == null || segment.end <= segment.start) {
   493→            transcript.segments.splice(i, 1);
   494→            i--;
   495→        }
   496→    }
   497→    return transcript;
   498→}
   499→
   500→/**
   501→ * Checks if no filler words were found and shows message
   502→ */
   503→function checkNoFillerWords() {
   504→    let noFillerWordsFound = true;
   505→    
   506→    for (let i = 0; i < g_filler_words_chunks_status.length; i++) {
   507→        for (let j = 0; j < g_filler_words_chunks_status[i].length; j++) {
   508→            if (g_filler_words_chunks_status[i][j] != 'no filler words in segment') {
   509→                noFillerWordsFound = false;
   510→                break;
   511→            }
   512→        }
   513→    }
   514→    
   515→    if (noFillerWordsFound) {
   516→        showMessage(
   517→            "Sorry, no filler words found. If there are definitely filler words in your audio, " +
   518→            "please make sure you've followed the 'best practices' in the previous menu. " +
   519→            "If still no luck, let us know in the 'share feedback' menu and we'll continue to improve detection!"
   520→        );
   521→        open_menu('remove-filler-words');
   522→    }
   523→}
   524→
   525→/**
   526→ * Combines multiple segments into one
   527→ */
   528→function combineSegments(segments) {
   529→    console.log('combine_segments called with segments: ', JSON.stringify(segments));
   530→    
   531→    const combined = {
   532→        start: segments[0].start,
   533→        end: segments[segments.length - 1].end,
   534→        words: []
   535→    };
   536→    
   537→    for (let i = 0; i < segments.length; i++) {
   538→        for (let j = 0; j < segments[i].words.length; j++) {
   539→            combined.words.push(JSON.parse(JSON.stringify(segments[i].words[j])));
   540→        }
   541→    }
   542→    
   543→    console.log('combine_segments returning combined_segment: ', JSON.stringify(combined));
   544→    return combined;
   545→}
   546→
   547→/**
   548→ * Transcribes audio file for filler word detection
   549→ */
   550→async function transcribeAudioFileForFillerWords(audioFilePath, language = 'en') {
   551→    regular_license_key_checker();
   552→    
   553→    const fileStream = fs.createReadStream(audioFilePath);
   554→    const fileStats = fs.statSync(audioFilePath);
   555→    const fileSize = fileStats.size;
   556→    
   557→    // Validate file size (max 25MB, min 1KB)
   558→    const MAX_FILE_SIZE = 25 * 1024 * 1024;
   559→    const MIN_FILE_SIZE = 1 * 1024;
   560→    
   561→    if (fileSize > MAX_FILE_SIZE) {
   562→        throw new Error('Audio file is too large.');
   563→    } else if (fileSize < MIN_FILE_SIZE) {
   564→        throw new Error('Audio file is too short.');
   565→    }
   566→    
   567→    const formData = new FormData();
   568→    formData.append('file', fileStream);
   569→    formData.append('language', language);
   570→    
   571→    const environmentConfigs = {
   572→        PRODUCTION: {
   573→            API_URL: 'https://firecut.ai/',
   574→            WHISPER_OPTIONS: {
   575→                host: 'firecut.ai',
   576→                path: '/api/filler_words/',
   577→                method: 'POST',
   578→                protocol: 'https:',
   579→                headers: {
   580→                    Authorization: 'Bearer ' + apiKey_editai,
   581→                    APPVERSION: app_version
   582→                }
   583→            }
   584→        },
   585→        STAGING: {
   586→            API_URL: 'https://editai-api-staging.suhailidrees.com/',
   587→            WHISPER_OPTIONS: {
   588→                host: 'editai-api-staging.suhailidrees.com',
   589→                path: '/api/filler_words/',
   590→                method: 'POST',
   591→                protocol: 'https:',
   592→                headers: {
   593→                    Authorization: 'Bearer ' + apiKey_editai,
   594→                    APPVERSION: app_version
   595→                }
   596→            }
   597→        },
   598→        DEVELOPMENT: {
   599→            API_URL: 'http://127.0.0.1:8000/',
   600→            WHISPER_OPTIONS: {
   601→                host: '127.0.0.1',
   602→                port: 8000,
   603→                path: '/api/filler_words/',
   604→                method: 'POST',
   605→                protocol: 'http:',
   606→                headers: {
   607→                    Authorization: 'Bearer ' + apiKey_editai,
   608→                    APPVERSION: app_version
   609→                }
   610→            }
   611→        }
   612→    };
   613→    
   614→    const options = environmentConfigs[ENVIRONMENT].WHISPER_OPTIONS;
   615→    console.log('options');
   616→    console.log(options);
   617→    
   618→    // Retry up to 3 times with 2 second delay, 60 second timeout
   619→    return await retryFormDataSubmit(formData, options, 3, 2 * 1000, 60 * 1000);
   620→}
   621→
   622→/**
   623→ * Adjusts filler word timestamps by bridging gaps between words
   624→ */
   625→function adjustFillerWordsTimestamps() {
   626→    filler_words_adjustment_params = test_55_get_filler_words_adjustment_params();
   627→    console.log('PARAMS', filler_words_adjustment_params);
   628→    
   629→    // Clone the word-level transcript for adjustments
   630→    g_filler_words_transcript_word_level_adjusted = JSON.parse(
   631→        JSON.stringify(g_filler_words_transcript_word_level)
   632→    );
   633→    
   634→    console.log('g_filler_words_transcript_word_level_adjusted');
   635→    console.log(JSON.parse(JSON.stringify(g_filler_words_transcript_word_level_adjusted)));
   636→    
   637→    for (let chunkIndex = 0; chunkIndex < g_filler_words_transcript_word_level_adjusted.length; chunkIndex++) {
   638→        try {
   639→            const chunk = g_filler_words_transcript_word_level_adjusted[chunkIndex];
   640→            if (chunk == null) continue;
   641→            
   642→            for (let segmentIndex = 0; segmentIndex < chunk.segments.length; segmentIndex++) {
   643→                try {
   644→                    if (chunk.segments[segmentIndex] == null) continue;
   645→                    
   646→                    for (let wordIndex = 0; wordIndex < chunk.segments[segmentIndex].words.length; wordIndex++) {
   647→                        if (filler_words_adjustment_params.bridging) {
   648→                            try {
   649→                                // Skip first word of first segment of first chunk
   650→                                if (wordIndex === 0) {
   651→                                    if (chunkIndex === 0 && segmentIndex == 0) continue;
   652→                                    
   653→                                    // Bridge to previous segment
   654→                                    let prevSegment = null;
   655→                                    if (segmentIndex > 0) {
   656→                                        prevSegment = chunk.segments[segmentIndex - 1];
   657→                                    } else {
   658→                                        if (g_filler_words_transcript_word_level_adjusted[chunkIndex - 1] == null) continue;
   659→                                        const prevChunk = g_filler_words_transcript_word_level_adjusted[chunkIndex - 1];
   660→                                        prevSegment = prevChunk.segments[prevChunk.segments.length - 1];
   661→                                    }
   662→                                    
   663→                                    // Set midpoint between previous word end and current word start
   664→                                    const prevWordEnd = prevSegment.words[prevSegment.words.length - 1].end;
   665→                                    const currentWordStart = chunk.segments[segmentIndex].words[wordIndex].start;
   666→                                    const midpoint = (prevWordEnd + currentWordStart) / 2;
   667→                                    
   668→                                    prevSegment.words[prevSegment.words.length - 1].end = midpoint;
   669→                                    chunk.segments[segmentIndex].words[wordIndex].start = midpoint;
   670→                                    continue;
   671→                                }
   672→                            } catch (error) {
   673→                                console.log('Error in adjusting filler word timestamps:', error);
   674→                            }
   675→                            
   676→                            // Bridge gap between consecutive words in same segment
   677→                            const prevWordEnd = chunk.segments[segmentIndex].words[wordIndex - 1].end;
   678→                            const currentWordStart = chunk.segments[segmentIndex].words[wordIndex].start;
   679→                            const midpoint = (prevWordEnd + currentWordStart) / 2;
   680→                            
   681→                            chunk.segments[segmentIndex].words[wordIndex - 1].end = midpoint;
   682→                            chunk.segments[segmentIndex].words[wordIndex].start = midpoint;
   683→                        }
   684→                    }
   685→                } catch (error) {
   686→                    console.log('err', error);
   687→                }
   688→            }
   689→        } catch (error) {
   690→            console.log('err', error);
   691→        }
   692→    }
   693→    
   694→    // Re-select current word if one was selected
   695→    if (g_selected_transcript_word_level_filler != null) {
   696→        selectTranscriptFillerWord(
   697→            g_selected_transcript_word_level_filler.chunk_index,
   698→            g_selected_transcript_word_level_filler.segment_index,
   699→            g_selected_transcript_word_level_filler.word_index
   700→        );
   701→    }
   702→}

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
