     1→import { SourceMapConsumer, type RawSourceMap } from "source-map-js";
     2→
     3→/** Internal type - not exported, used only within this module */
     4→interface SourceMapInfo {
     5→  sources: string[];
     6→  sourcesContent: string[] | null;
     7→  variableNames: Map<string, string>;
     8→}
     9→
    10→export interface SourceMapResult {
    11→  hasSourceMap: boolean;
    12→  originalSources?: Array<{ file: string; content: string }>;
    13→  variableHints?: Record<string, string>;
    14→  externalSourceMapUrl?: string;
    15→}
    16→
    17→/**
    18→ * Detect sourceMappingURL comment in code
    19→ * Returns the URL/data-uri or null if not found
    20→ */
    21→export function detectSourceMapUrl(code: string): string | null {
    22→  // Match JS-style (//# sourceMappingURL=...) and CSS-style (/*# sourceMappingURL=... */)
    23→  // CSS pattern uses negative lookahead to exclude closing */ while allowing * in URLs
    24→  const regex = /(?:\/\/[#@] ?sourceMappingURL=([^\s'"]+)|\/\*[#@] ?sourceMappingURL=((?:[^\s'"*]|\*(?!\/))+) ?\*\/)\s*$/gm;
    25→  let match: RegExpExecArray | null;
    26→  let lastMatch: string | null = null;
    27→
    28→  while ((match = regex.exec(code)) !== null) {
    29→    lastMatch = match[1] || match[2];
    30→  }
    31→
    32→  return lastMatch;
    33→}
    34→
    35→/**
    36→ * Parse inline source map from data URI
    37→ * Handles data:application/json;base64,... and data:application/json;charset=utf-8;base64,... formats
    38→ */
    39→export function parseInlineSourceMap(dataUri: string): RawSourceMap | null {
    40→  try {
    41→    // Handle optional charset parameter: data:application/json;charset=utf-8;base64,...
    42→    const dataUriRegex = /^data:application\/json(?:;charset=[^;]+)?;base64,/;
    43→    const match = dataUri.match(dataUriRegex);
    44→    if (!match) {
    45→      return null;
    46→    }
    47→
    48→    const base64 = dataUri.slice(match[0].length);
    49→    const json = Buffer.from(base64, "base64").toString("utf-8");
    50→    const parsed = JSON.parse(json);
    51→
    52→    // Validate required RawSourceMap fields
    53→    if (
    54→      typeof parsed !== "object" ||
    55→      parsed === null ||
    56→      typeof parsed.version !== "number" ||
    57→      !Array.isArray(parsed.sources) ||
    58→      typeof parsed.mappings !== "string"
    59→    ) {
    60→      return null;
    61→    }
    62→
    63→    return parsed as RawSourceMap;
    64→  } catch {
    65→    return null;
    66→  }
    67→}
    68→
    69→/**
    70→ * Extract source map information including original sources and variable name mappings
    71→ */
    72→export function extractSourceMapInfo(map: RawSourceMap): SourceMapInfo | null {
    73→  try {
    74→    const variableNames = new Map<string, string>();
    75→
    76→    const consumer = new SourceMapConsumer(map);
    77→
    78→    consumer.eachMapping((mapping) => {
    79→      if (mapping.name) {
    80→        const generatedKey = `${mapping.generatedLine}:${mapping.generatedColumn}`;
    81→        variableNames.set(generatedKey, mapping.name);
    82→      }
    83→    });
    84→
    85→    return {
    86→      sources: map.sources,
    87→      sourcesContent: map.sourcesContent || null,
    88→      variableNames,
    89→    };
    90→  } catch {
    91→    return null;
    92→  }
    93→}
    94→
    95→/**
    96→ * Main entry point: process code with source map
    97→ * Detects, parses, and extracts all source map information in one call
    98→ */
    99→export function processCodeWithSourceMap(code: string): SourceMapResult {
   100→  const sourceMapUrl = detectSourceMapUrl(code);
   101→
   102→  if (!sourceMapUrl) {
   103→    return { hasSourceMap: false };
   104→  }
   105→
   106→  const map = parseInlineSourceMap(sourceMapUrl);
   107→
   108→  if (!map) {
   109→    // URL was detected but not inline base64 - it's an external file reference
   110→    return { hasSourceMap: true, externalSourceMapUrl: sourceMapUrl };
   111→  }
   112→
   113→  const info = extractSourceMapInfo(map);
   114→
   115→  if (!info) {
   116→    return { hasSourceMap: true };
   117→  }
   118→
   119→  // Build originalSources array pairing filenames with content
   120→  const originalSources = info.sourcesContent
   121→    ? info.sources
   122→        .map((file, i) => ({ file, content: info.sourcesContent![i] }))
   123→        .filter((source): source is { file: string; content: string } => !!source.content)
   124→    : [];
   125→
   126→  const variableHints: Record<string, string> = Object.fromEntries(info.variableNames);
   127→
   128→  return {
   129→    hasSourceMap: true,
   130→    originalSources: originalSources.length > 0 ? originalSources : undefined,
   131→    variableHints: Object.keys(variableHints).length > 0 ? variableHints : undefined,
   132→  };
   133→}
   134→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
