{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":"You are validating the SPLICE project for production release. Perform a comprehensive integration check:\n\n## 1. Backend API Readiness\nCheck that all routes in /Users/imorgado/SPLICE/splice-backend/server.js are properly mounted and have:\n- Correct middleware (auth, CSRF, rate limiting)\n- Error handling\n- Response format consistency\n\n## 2. Frontend-Backend Integration\nVerify that the frontend API calls match backend endpoints:\n- Check /Users/imorgado/SPLICE/splice-website/src/app/api/ routes forward correctly\n- Check /Users/imorgado/SPLICE/splice-cep/panel/js/config.js has correct backend URLs\n- Verify CSRF token flow works end-to-end\n\n## 3. Service Dependencies\nVerify all services have their dependencies:\n- Check imports in /Users/imorgado/SPLICE/splice-backend/services/\n- Verify no missing require() calls\n- Check environment variables in .env.template match what services expect\n\n## 4. Database Schema\nCheck that usageTracking.js database operations match expected schema:\n- All INSERT/UPDATE/SELECT statements use correct column names\n- Transactions are properly used where needed\n\n## 5. Plugin Features Integration\nFor each of the 14 features, verify the full chain exists:\n- Frontend button/UI element\n- API route handler\n- Service implementation\n- Proper error responses\n\n## 6. Security Checklist\n- JWT middleware applied to protected routes\n- CSRF validation on state-changing endpoints\n- Rate limiting configured\n- No hardcoded secrets\n\n## 7. Production Config\n- Check production URLs are correct\n- Verify Railway environment detection works\n- Check CORS origins include production domains\n\nReport any gaps, mismatches, or missing integrations that would prevent successful release."},"uuid":"aea34ade-db57-484f-95a9-19a9afb93c2a","timestamp":"2025-12-30T02:09:32.169Z"}
{"parentUuid":"aea34ade-db57-484f-95a9-19a9afb93c2a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_014FBgLhK2DZCetQWYkcKXt5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KVwWA1Cs4EXibQyJ4e9aXN","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21624,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21624,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWc4KEunbeQq55Kcjt4cc","type":"assistant","uuid":"cc41e4f2-ceeb-4408-bc0b-0bfdb7d00760","timestamp":"2025-12-30T02:09:38.377Z"}
{"parentUuid":"cc41e4f2-ceeb-4408-bc0b-0bfdb7d00760","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_014FBgLhK2DZCetQWYkcKXt5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QHureArshNQjv1dsojwRFa","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/.env.template"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21624,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21624,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWc4KEunbeQq55Kcjt4cc","type":"assistant","uuid":"b6084f40-1ef8-49ef-b4d1-71f7c53cf75b","timestamp":"2025-12-30T02:09:38.946Z"}
{"parentUuid":"b6084f40-1ef8-49ef-b4d1-71f7c53cf75b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_014FBgLhK2DZCetQWYkcKXt5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FPQijBPwrYqf6dyyw3t52d","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21624,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21624,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWc4KEunbeQq55Kcjt4cc","type":"assistant","uuid":"b823d8c1-71dd-4774-87d9-cee1d2ca7b8b","timestamp":"2025-12-30T02:09:39.611Z"}
{"parentUuid":"b823d8c1-71dd-4774-87d9-cee1d2ca7b8b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_014FBgLhK2DZCetQWYkcKXt5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AMXMAG6AiNnrvLkfS5wyAB","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21624,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21624,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWc4KEunbeQq55Kcjt4cc","type":"assistant","uuid":"e86bd18b-9434-43f4-975e-70c5827f05c2","timestamp":"2025-12-30T02:09:40.157Z"}
{"parentUuid":"e86bd18b-9434-43f4-975e-70c5827f05c2","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_014FBgLhK2DZCetQWYkcKXt5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WmwNdK2EQCtnPUBrjVpo25","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":21624,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":21624,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWc4KEunbeQq55Kcjt4cc","type":"assistant","uuid":"6d88f903-cdfb-4430-b0b5-e177863a9b5e","timestamp":"2025-12-30T02:09:40.835Z"}
{"parentUuid":"6d88f903-cdfb-4430-b0b5-e177863a9b5e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QHureArshNQjv1dsojwRFa","type":"tool_result","content":"     1→# =============================================================================\n     2→# SPLICE Backend Environment Variables\n     3→# =============================================================================\n     4→# Copy this file to .env and fill in your values\n     5→# NEVER commit .env to git\n     6→\n     7→# -----------------------------------------------------------------------------\n     8→# AI Services\n     9→# -----------------------------------------------------------------------------\n    10→GROQ_API_KEY=your_groq_api_key_here\n    11→OPENAI_API_KEY=your_openai_api_key_here\n    12→REPLICATE_API_TOKEN=your_replicate_token_here\n    13→\n    14→# -----------------------------------------------------------------------------\n    15→# Stripe (for billing/subscriptions)\n    16→# Get these from https://dashboard.stripe.com/apikeys\n    17→# -----------------------------------------------------------------------------\n    18→STRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key_here\n    19→STRIPE_SECRET_KEY=sk_test_your_secret_key_here\n    20→STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here\n    21→\n    22→# Stripe Price IDs (create products in Stripe Dashboard first)\n    23→# Monthly prices: Starter $15, Pro $39, Team $129\n    24→STRIPE_PRICE_STARTER=price_your_starter_monthly_id\n    25→STRIPE_PRICE_PRO=price_your_pro_monthly_id\n    26→STRIPE_PRICE_TEAM=price_your_team_monthly_id\n    27→\n    28→# Annual prices (20% discount): Starter $144, Pro $374, Team $1238\n    29→STRIPE_PRICE_STARTER_ANNUAL=price_your_starter_annual_id\n    30→STRIPE_PRICE_PRO_ANNUAL=price_your_pro_annual_id\n    31→STRIPE_PRICE_TEAM_ANNUAL=price_your_team_annual_id\n    32→\n    33→# Overage metered billing: $2/hour, $1/song\n    34→STRIPE_PRICE_OVERAGE_HOURS=price_your_hours_overage_id\n    35→STRIPE_PRICE_OVERAGE_MUSIC=price_your_music_overage_id\n    36→\n    37→# Stripe Meters (for usage-based billing)\n    38→STRIPE_METER_HOURS=mtr_your_hours_meter_id\n    39→STRIPE_METER_MUSIC=mtr_your_music_meter_id\n    40→\n    41→# -----------------------------------------------------------------------------\n    42→# Database (Railway PostgreSQL)\n    43→# Railway will auto-inject this when you add PostgreSQL\n    44→# -----------------------------------------------------------------------------\n    45→DATABASE_URL=postgresql://user:password@host:port/database\n    46→\n    47→# -----------------------------------------------------------------------------\n    48→# Upstash Redis (for token blacklist, job queues, caching)\n    49→# Get these from https://console.upstash.com/redis\n    50→# -----------------------------------------------------------------------------\n    51→# BullMQ uses the standard Redis URL (for job queues)\n    52→UPSTASH_REDIS_URL=rediss://default:your_password@your_endpoint.upstash.io:6379\n    53→\n    54→# REST API credentials (for token blacklist - recommended for serverless)\n    55→UPSTASH_REDIS_REST_URL=https://your_endpoint.upstash.io\n    56→UPSTASH_REDIS_REST_TOKEN=your_rest_token_here\n    57→\n    58→# -----------------------------------------------------------------------------\n    59→# Music Generation (Mureka API)\n    60→# -----------------------------------------------------------------------------\n    61→MUREKA_API_KEY=your_mureka_api_key_here\n    62→\n    63→# -----------------------------------------------------------------------------\n    64→# Cloudflare R2 Storage (for music files)\n    65→# -----------------------------------------------------------------------------\n    66→R2_ACCOUNT_ID=your_r2_account_id_here\n    67→R2_ACCESS_KEY_ID=your_r2_access_key_id_here\n    68→R2_SECRET_ACCESS_KEY=your_r2_secret_access_key_here\n    69→R2_BUCKET_NAME=splice-music\n    70→\n    71→# -----------------------------------------------------------------------------\n    72→# Song Identification (ACRCloud) - Optional\n    73→# -----------------------------------------------------------------------------\n    74→ACRCLOUD_HOST=identify-us-west-2.acrcloud.com\n    75→ACRCLOUD_ACCESS_KEY=your_acrcloud_access_key_here\n    76→ACRCLOUD_ACCESS_SECRET=your_acrcloud_access_secret_here\n    77→\n    78→# -----------------------------------------------------------------------------\n    79→# Server Config\n    80→# -----------------------------------------------------------------------------\n    81→PORT=3847\n    82→NODE_ENV=production\n    83→\n    84→# -----------------------------------------------------------------------------\n    85→# JWT Authentication\n    86→# CRITICAL: Must be set to a secure random value in production!\n    87→# Generate with: openssl rand -hex 32\n    88→# -----------------------------------------------------------------------------\n    89→JWT_SECRET=your_secure_jwt_secret_here_CHANGE_IN_PRODUCTION\n    90→JWT_EXPIRES_IN=24h\n    91→JWT_REFRESH_EXPIRES_IN=7d\n    92→\n    93→# -----------------------------------------------------------------------------\n    94→# Email Service (SendGrid or AWS SES)\n    95→# -----------------------------------------------------------------------------\n    96→# Provider: 'sendgrid' | 'ses' | 'console' (console = log only, for dev)\n    97→EMAIL_PROVIDER=console\n    98→\n    99→# SendGrid Configuration (if EMAIL_PROVIDER=sendgrid)\n   100→SENDGRID_API_KEY=SG_your_sendgrid_api_key_here\n   101→\n   102→# AWS SES Configuration (if EMAIL_PROVIDER=ses)\n   103→# AWS_SES_REGION=us-east-1\n   104→# AWS_ACCESS_KEY_ID=your_aws_access_key\n   105→# AWS_SECRET_ACCESS_KEY=your_aws_secret_key\n   106→\n   107→# Email addresses\n   108→EMAIL_FROM=SPLICE <noreply@splice.video>\n   109→EMAIL_REPLY_TO=support@splice.video\n   110→\n\n</system-reminder>\n"}]},"uuid":"e2678610-f54d-49c6-80c5-3f258d1b31f6","timestamp":"2025-12-30T02:09:40.885Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/.env.template","content":"# =============================================================================\n# SPLICE Backend Environment Variables\n# =============================================================================\n# Copy this file to .env and fill in your values\n# NEVER commit .env to git\n\n# -----------------------------------------------------------------------------\n# AI Services\n# -----------------------------------------------------------------------------\nGROQ_API_KEY=your_groq_api_key_here\nOPENAI_API_KEY=your_openai_api_key_here\nREPLICATE_API_TOKEN=your_replicate_token_here\n\n# -----------------------------------------------------------------------------\n# Stripe (for billing/subscriptions)\n# Get these from https://dashboard.stripe.com/apikeys\n# -----------------------------------------------------------------------------\nSTRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key_here\nSTRIPE_SECRET_KEY=sk_test_your_secret_key_here\nSTRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here\n\n# Stripe Price IDs (create products in Stripe Dashboard first)\n# Monthly prices: Starter $15, Pro $39, Team $129\nSTRIPE_PRICE_STARTER=price_your_starter_monthly_id\nSTRIPE_PRICE_PRO=price_your_pro_monthly_id\nSTRIPE_PRICE_TEAM=price_your_team_monthly_id\n\n# Annual prices (20% discount): Starter $144, Pro $374, Team $1238\nSTRIPE_PRICE_STARTER_ANNUAL=price_your_starter_annual_id\nSTRIPE_PRICE_PRO_ANNUAL=price_your_pro_annual_id\nSTRIPE_PRICE_TEAM_ANNUAL=price_your_team_annual_id\n\n# Overage metered billing: $2/hour, $1/song\nSTRIPE_PRICE_OVERAGE_HOURS=price_your_hours_overage_id\nSTRIPE_PRICE_OVERAGE_MUSIC=price_your_music_overage_id\n\n# Stripe Meters (for usage-based billing)\nSTRIPE_METER_HOURS=mtr_your_hours_meter_id\nSTRIPE_METER_MUSIC=mtr_your_music_meter_id\n\n# -----------------------------------------------------------------------------\n# Database (Railway PostgreSQL)\n# Railway will auto-inject this when you add PostgreSQL\n# -----------------------------------------------------------------------------\nDATABASE_URL=postgresql://user:password@host:port/database\n\n# -----------------------------------------------------------------------------\n# Upstash Redis (for token blacklist, job queues, caching)\n# Get these from https://console.upstash.com/redis\n# -----------------------------------------------------------------------------\n# BullMQ uses the standard Redis URL (for job queues)\nUPSTASH_REDIS_URL=rediss://default:your_password@your_endpoint.upstash.io:6379\n\n# REST API credentials (for token blacklist - recommended for serverless)\nUPSTASH_REDIS_REST_URL=https://your_endpoint.upstash.io\nUPSTASH_REDIS_REST_TOKEN=your_rest_token_here\n\n# -----------------------------------------------------------------------------\n# Music Generation (Mureka API)\n# -----------------------------------------------------------------------------\nMUREKA_API_KEY=your_mureka_api_key_here\n\n# -----------------------------------------------------------------------------\n# Cloudflare R2 Storage (for music files)\n# -----------------------------------------------------------------------------\nR2_ACCOUNT_ID=your_r2_account_id_here\nR2_ACCESS_KEY_ID=your_r2_access_key_id_here\nR2_SECRET_ACCESS_KEY=your_r2_secret_access_key_here\nR2_BUCKET_NAME=splice-music\n\n# -----------------------------------------------------------------------------\n# Song Identification (ACRCloud) - Optional\n# -----------------------------------------------------------------------------\nACRCLOUD_HOST=identify-us-west-2.acrcloud.com\nACRCLOUD_ACCESS_KEY=your_acrcloud_access_key_here\nACRCLOUD_ACCESS_SECRET=your_acrcloud_access_secret_here\n\n# -----------------------------------------------------------------------------\n# Server Config\n# -----------------------------------------------------------------------------\nPORT=3847\nNODE_ENV=production\n\n# -----------------------------------------------------------------------------\n# JWT Authentication\n# CRITICAL: Must be set to a secure random value in production!\n# Generate with: openssl rand -hex 32\n# -----------------------------------------------------------------------------\nJWT_SECRET=your_secure_jwt_secret_here_CHANGE_IN_PRODUCTION\nJWT_EXPIRES_IN=24h\nJWT_REFRESH_EXPIRES_IN=7d\n\n# -----------------------------------------------------------------------------\n# Email Service (SendGrid or AWS SES)\n# -----------------------------------------------------------------------------\n# Provider: 'sendgrid' | 'ses' | 'console' (console = log only, for dev)\nEMAIL_PROVIDER=console\n\n# SendGrid Configuration (if EMAIL_PROVIDER=sendgrid)\nSENDGRID_API_KEY=SG_your_sendgrid_api_key_here\n\n# AWS SES Configuration (if EMAIL_PROVIDER=ses)\n# AWS_SES_REGION=us-east-1\n# AWS_ACCESS_KEY_ID=your_aws_access_key\n# AWS_SECRET_ACCESS_KEY=your_aws_secret_key\n\n# Email addresses\nEMAIL_FROM=SPLICE <noreply@splice.video>\nEMAIL_REPLY_TO=support@splice.video\n","numLines":110,"startLine":1,"totalLines":110}}}
{"parentUuid":"e2678610-f54d-49c6-80c5-3f258d1b31f6","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FPQijBPwrYqf6dyyw3t52d","type":"tool_result","content":"     1→/**\n     2→ * Auth Routes\n     3→ *\n     4→ * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n     5→ */\n     6→\n     7→const express = require('express');\n     8→const crypto = require('crypto');\n     9→const { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\n    10→const authLogger = require('../utils/authLogger');\n    11→\n    12→// ============================================================================\n    13→// Email Verification Code Storage\n    14→// In-memory store for verification codes. Maps email -> { code, expires, attempts }\n    15→// Can be upgraded to Redis for distributed deployments.\n    16→// ============================================================================\n    17→\n    18→const verificationCodes = new Map();\n    19→\n    20→// Verification code expiry time (10 minutes)\n    21→const VERIFICATION_CODE_EXPIRY_MS = 10 * 60 * 1000;\n    22→\n    23→// Maximum verification attempts before code is invalidated\n    24→const MAX_VERIFICATION_ATTEMPTS = 5;\n    25→\n    26→// Rate limiting: minimum time between sending codes to same email (60 seconds)\n    27→const SEND_CODE_COOLDOWN_MS = 60 * 1000;\n    28→\n    29→// Track last send time per email for rate limiting\n    30→const lastSendTime = new Map();\n    31→\n    32→// Cleanup interval for expired codes (every 5 minutes)\n    33→const CLEANUP_INTERVAL_MS = 5 * 60 * 1000;\n    34→\n    35→/**\n    36→ * Generate a 6-digit verification code\n    37→ * @returns {string} 6-digit code\n    38→ */\n    39→function generateVerificationCode() {\n    40→  // Generate cryptographically secure random 6-digit code\n    41→  const code = crypto.randomInt(100000, 999999).toString();\n    42→  return code;\n    43→}\n    44→\n    45→/**\n    46→ * Store a verification code for an email\n    47→ * @param {string} email - Email address\n    48→ * @param {string} code - Verification code\n    49→ */\n    50→function storeVerificationCode(email, code) {\n    51→  const normalizedEmail = email.toLowerCase().trim();\n    52→  verificationCodes.set(normalizedEmail, {\n    53→    code,\n    54→    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS,\n    55→    attempts: 0,\n    56→    createdAt: Date.now()\n    57→  });\n    58→  lastSendTime.set(normalizedEmail, Date.now());\n    59→}\n    60→\n    61→/**\n    62→ * Verify a code for an email\n    63→ * @param {string} email - Email address\n    64→ * @param {string} code - Code to verify\n    65→ * @returns {{ valid: boolean, error?: string }}\n    66→ */\n    67→function verifyCode(email, code) {\n    68→  const normalizedEmail = email.toLowerCase().trim();\n    69→  const stored = verificationCodes.get(normalizedEmail);\n    70→\n    71→  if (!stored) {\n    72→    return { valid: false, error: 'No verification code found. Please request a new one.' };\n    73→  }\n    74→\n    75→  // Check if expired\n    76→  if (Date.now() > stored.expires) {\n    77→    verificationCodes.delete(normalizedEmail);\n    78→    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n    79→  }\n    80→\n    81→  // Increment attempt counter\n    82→  stored.attempts++;\n    83→\n    84→  // Check if too many attempts\n    85→  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n    86→    verificationCodes.delete(normalizedEmail);\n    87→    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n    88→  }\n    89→\n    90→  // Check if code matches\n    91→  if (stored.code !== code) {\n    92→    verificationCodes.set(normalizedEmail, stored);\n    93→    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n    94→  }\n    95→\n    96→  // Code is valid - remove it (single use)\n    97→  verificationCodes.delete(normalizedEmail);\n    98→  return { valid: true };\n    99→}\n   100→\n   101→/**\n   102→ * Check if we can send a new code to an email (rate limiting)\n   103→ * @param {string} email - Email address\n   104→ * @returns {{ allowed: boolean, waitSeconds?: number }}\n   105→ */\n   106→function canSendCode(email) {\n   107→  const normalizedEmail = email.toLowerCase().trim();\n   108→  const lastSent = lastSendTime.get(normalizedEmail);\n   109→\n   110→  if (!lastSent) {\n   111→    return { allowed: true };\n   112→  }\n   113→\n   114→  const elapsed = Date.now() - lastSent;\n   115→  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n   116→    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n   117→    return { allowed: false, waitSeconds };\n   118→  }\n   119→\n   120→  return { allowed: true };\n   121→}\n   122→\n   123→/**\n   124→ * Clean up expired verification codes\n   125→ */\n   126→function cleanupVerificationCodes() {\n   127→  const now = Date.now();\n   128→  let cleanedCount = 0;\n   129→\n   130→  for (const [email, data] of verificationCodes.entries()) {\n   131→    if (data.expires <= now) {\n   132→      verificationCodes.delete(email);\n   133→      cleanedCount++;\n   134→    }\n   135→  }\n   136→\n   137→  // Also clean up old lastSendTime entries (older than 1 hour)\n   138→  const oneHourAgo = now - (60 * 60 * 1000);\n   139→  for (const [email, time] of lastSendTime.entries()) {\n   140→    if (time < oneHourAgo) {\n   141→      lastSendTime.delete(email);\n   142→    }\n   143→  }\n   144→\n   145→  if (cleanedCount > 0) {\n   146→    console.log(`[Auth] Verification code cleanup: removed ${cleanedCount} expired codes`);\n   147→  }\n   148→}\n   149→\n   150→// Start periodic cleanup (unref to allow process exit)\n   151→const cleanupTimer = setInterval(cleanupVerificationCodes, CLEANUP_INTERVAL_MS);\n   152→if (cleanupTimer.unref) {\n   153→  cleanupTimer.unref();\n   154→}\n   155→\n   156→/**\n   157→ * Validate email format\n   158→ * @param {string} email - Email to validate\n   159→ * @returns {boolean}\n   160→ */\n   161→function isValidEmail(email) {\n   162→  if (!email || typeof email !== 'string') return false;\n   163→  // Basic email validation regex\n   164→  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n   165→  return emailRegex.test(email.trim());\n   166→}\n   167→\n   168→/**\n   169→ * Create auth routes\n   170→ * @param {Object} options - Route configuration options\n   171→ * @param {Object} options.middleware - Shared middleware (authenticateToken)\n   172→ * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n   173→ * @param {Object} options.authHelpers - Auth helper functions\n   174→ * @returns {express.Router}\n   175→ */\n   176→function createAuthRoutes(options = {}) {\n   177→  const router = express.Router();\n   178→  const { authenticateToken } = options.middleware || {};\n   179→  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n   180→  const { usageTracking, licenseService, emailService } = options.services || {};\n   181→\n   182→  /**\n   183→   * GET /csrf-token - Generate and return a CSRF token\n   184→   *\n   185→   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   186→   * The token is returned in both the response body and an HttpOnly cookie.\n   187→   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   188→   */\n   189→  router.get('/csrf-token', csrfTokenHandler);\n   190→\n   191→  /**\n   192→   * POST /login - Authenticate with license key and get JWT token\n   193→   *\n   194→   * SECURITY: This is the primary authentication endpoint.\n   195→   * Validates license key and returns a JWT token for API access.\n   196→   * CSRF protection applied to prevent cross-site login attacks.\n   197→   */\n   198→  router.post('/login', validateCsrfToken, async (req, res) => {\n   199→    const { licenseKey } = req.body;\n   200→\n   201→    if (!licenseKey) {\n   202→      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n   203→      return res.status(400).json({\n   204→        error: 'License key required',\n   205→        message: 'Please provide your license key to log in'\n   206→      });\n   207→    }\n   208→\n   209→    try {\n   210→      // Validate and activate the license key\n   211→      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n   212→\n   213→      if (!licenseResult.success) {\n   214→        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n   215→        return res.status(401).json({\n   216→          error: 'Invalid license key',\n   217→          message: licenseResult.error || 'The license key is invalid or expired'\n   218→        });\n   219→      }\n   220→\n   221→      // Get user's tier and balance\n   222→      const balance = await usageTracking.getBalance(licenseResult.customerId);\n   223→\n   224→      // Generate JWT tokens\n   225→      const tokenResult = generateToken(licenseResult.customerId, {\n   226→        tier: balance.tier,\n   227→        email: licenseResult.email\n   228→      });\n   229→      const refreshResult = generateRefreshToken(licenseResult.customerId);\n   230→\n   231→      // Log successful login with structured logging\n   232→      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n   233→        email: licenseResult.email,\n   234→        tier: balance.tier\n   235→      });\n   236→\n   237→      res.json({\n   238→        success: true,\n   239→        token: tokenResult.token,\n   240→        tokenType: tokenResult.tokenType,\n   241→        expiresIn: tokenResult.expiresIn,\n   242→        refreshToken: refreshResult.refreshToken,\n   243→        customerId: licenseResult.customerId,\n   244→        tier: balance.tier,\n   245→        hoursRemaining: balance.hoursRemaining\n   246→      });\n   247→    } catch (err) {\n   248→      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n   249→      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n   250→    }\n   251→  });\n   252→\n   253→  /**\n   254→   * POST /refresh - Refresh an expired JWT token\n   255→   *\n   256→   * Uses a refresh token to get a new access token.\n   257→   * CSRF protection applied to prevent token theft via cross-site requests.\n   258→   */\n   259→  router.post('/refresh', validateCsrfToken, async (req, res) => {\n   260→    const { refreshToken } = req.body;\n   261→\n   262→    if (!refreshToken) {\n   263→      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n   264→      return res.status(400).json({\n   265→        error: 'Refresh token required'\n   266→      });\n   267→    }\n   268→\n   269→    try {\n   270→      const decoded = await verifyToken(refreshToken, { req });\n   271→\n   272→      if (!decoded || decoded.type !== 'refresh') {\n   273→        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n   274→        return res.status(401).json({\n   275→          error: 'Invalid refresh token',\n   276→          message: 'Please log in again'\n   277→        });\n   278→      }\n   279→\n   280→      // Get current user info\n   281→      const balance = await usageTracking.getBalance(decoded.sub);\n   282→\n   283→      // Generate new access token\n   284→      const tokenResult = generateToken(decoded.sub, {\n   285→        tier: balance.tier\n   286→      });\n   287→\n   288→      // Log successful token refresh\n   289→      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n   290→\n   291→      res.json({\n   292→        success: true,\n   293→        token: tokenResult.token,\n   294→        tokenType: tokenResult.tokenType,\n   295→        expiresIn: tokenResult.expiresIn\n   296→      });\n   297→    } catch (err) {\n   298→      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n   299→      res.status(401).json({\n   300→        error: 'Failed to refresh token',\n   301→        message: 'Please log in again'\n   302→      });\n   303→    }\n   304→  });\n   305→\n   306→  /**\n   307→   * POST /logout - Invalidate tokens by adding to blacklist\n   308→   *\n   309→   * Adds the current token's jti to the blacklist so it cannot be reused.\n   310→   * Also accepts an optional refreshToken to revoke both tokens at once.\n   311→   * CSRF protection applied to prevent forced logout attacks.\n   312→   */\n   313→  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n   314→    const { refreshToken } = req.body;\n   315→    let refreshTokenRevoked = false;\n   316→\n   317→    // Blacklist the access token using the blacklistToken function from authHelpers\n   318→    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n   319→      if (blacklistToken) {\n   320→        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n   321→          userId: req.stripeCustomerId,\n   322→          reason: 'logout'\n   323→        });\n   324→      } else {\n   325→        console.warn('[Auth] Logout: blacklistToken function not available');\n   326→      }\n   327→    } else {\n   328→      // Token doesn't have jti - log warning but continue\n   329→      // This handles tokens generated before jti was added\n   330→      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n   331→    }\n   332→\n   333→    // Optionally blacklist the refresh token too\n   334→    if (refreshToken && blacklistToken) {\n   335→      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n   336→      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n   337→      if (decoded && decoded.jti && decoded.exp) {\n   338→        await blacklistToken(decoded.jti, decoded.exp, {\n   339→          userId: req.stripeCustomerId,\n   340→          reason: 'logout_refresh'\n   341→        });\n   342→        refreshTokenRevoked = true;\n   343→      }\n   344→    }\n   345→\n   346→    // Log successful logout with structured logging\n   347→    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n   348→      jti: req.tokenData?.jti,\n   349→      refreshTokenRevoked\n   350→    });\n   351→\n   352→    res.json({\n   353→      success: true,\n   354→      message: 'Logged out successfully'\n   355→    });\n   356→  });\n   357→\n   358→  // ==========================================================================\n   359→  // Email Verification Endpoints\n   360→  // ==========================================================================\n   361→\n   362→  /**\n   363→   * POST /send-verification - Send a verification code to an email address\n   364→   *\n   365→   * Request body: { email: string }\n   366→   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   367→   *\n   368→   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   369→   */\n   370→  router.post('/send-verification', validateCsrfToken, async (req, res) => {\n   371→    const { email } = req.body;\n   372→\n   373→    // Validate email\n   374→    if (!email) {\n   375→      return res.status(400).json({\n   376→        error: 'Email required',\n   377→        message: 'Please provide an email address'\n   378→      });\n   379→    }\n   380→\n   381→    if (!isValidEmail(email)) {\n   382→      return res.status(400).json({\n   383→        error: 'Invalid email',\n   384→        message: 'Please provide a valid email address'\n   385→      });\n   386→    }\n   387→\n   388→    // Check rate limiting\n   389→    const rateCheck = canSendCode(email);\n   390→    if (!rateCheck.allowed) {\n   391→      return res.status(429).json({\n   392→        error: 'Too many requests',\n   393→        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n   394→        waitSeconds: rateCheck.waitSeconds\n   395→      });\n   396→    }\n   397→\n   398→    try {\n   399→      // Generate and store verification code\n   400→      const code = generateVerificationCode();\n   401→      storeVerificationCode(email, code);\n   402→\n   403→      // Send verification email\n   404→      if (emailService && emailService.sendEmailVerificationCode) {\n   405→        await emailService.sendEmailVerificationCode(email, code, 10);\n   406→        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n   407→      } else {\n   408→        // Fallback for development - log to console\n   409→        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n   410→      }\n   411→\n   412→      res.json({\n   413→        success: true,\n   414→        message: 'Verification code sent. Please check your email.',\n   415→        expiresInMinutes: 10\n   416→      });\n   417→    } catch (err) {\n   418→      console.error('[Auth] Send verification error:', err.message);\n   419→      res.status(500).json({\n   420→        error: 'Failed to send verification code',\n   421→        message: 'Please try again later'\n   422→      });\n   423→    }\n   424→  });\n   425→\n   426→  /**\n   427→   * POST /verify-email - Verify an email address with a code\n   428→   *\n   429→   * Request body: { email: string, code: string }\n   430→   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   431→   *\n   432→   * SECURITY: Limited attempts per code. CSRF protection applied.\n   433→   */\n   434→  router.post('/verify-email', validateCsrfToken, async (req, res) => {\n   435→    const { email, code } = req.body;\n   436→\n   437→    // Validate inputs\n   438→    if (!email) {\n   439→      return res.status(400).json({\n   440→        error: 'Email required',\n   441→        message: 'Please provide an email address'\n   442→      });\n   443→    }\n   444→\n   445→    if (!code) {\n   446→      return res.status(400).json({\n   447→        error: 'Code required',\n   448→        message: 'Please provide the verification code'\n   449→      });\n   450→    }\n   451→\n   452→    if (!isValidEmail(email)) {\n   453→      return res.status(400).json({\n   454→        error: 'Invalid email',\n   455→        message: 'Please provide a valid email address'\n   456→      });\n   457→    }\n   458→\n   459→    // Validate code format (6 digits)\n   460→    const codeStr = String(code).trim();\n   461→    if (!/^\\d{6}$/.test(codeStr)) {\n   462→      return res.status(400).json({\n   463→        error: 'Invalid code format',\n   464→        message: 'Verification code must be 6 digits'\n   465→      });\n   466→    }\n   467→\n   468→    try {\n   469→      // Verify the code\n   470→      const result = verifyCode(email, codeStr);\n   471→\n   472→      if (!result.valid) {\n   473→        return res.status(400).json({\n   474→          success: false,\n   475→          verified: false,\n   476→          error: 'Verification failed',\n   477→          message: result.error\n   478→        });\n   479→      }\n   480→\n   481→      // Mark email as verified in the database\n   482→      if (usageTracking && usageTracking.markEmailVerified) {\n   483→        const dbResult = await usageTracking.markEmailVerified(email);\n   484→        if (!dbResult.success) {\n   485→          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n   486→        }\n   487→      }\n   488→\n   489→      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n   490→\n   491→      // Email verified successfully\n   492→      res.json({\n   493→        success: true,\n   494→        verified: true,\n   495→        message: 'Email verified successfully'\n   496→      });\n   497→    } catch (err) {\n   498→      console.error('[Auth] Verify email error:', err.message);\n   499→      res.status(500).json({\n   500→        error: 'Verification failed',\n   501→        message: 'Please try again later'\n   502→      });\n   503→    }\n   504→  });\n   505→\n   506→  return router;\n   507→}\n   508→\n   509→module.exports = createAuthRoutes;\n   510→\n\n</system-reminder>\n"}]},"uuid":"fe5bf5d4-ac46-4896-b166-30f4804431af","timestamp":"2025-12-30T02:09:40.885Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/auth.js","content":"/**\n * Auth Routes\n *\n * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n */\n\nconst express = require('express');\nconst crypto = require('crypto');\nconst { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\nconst authLogger = require('../utils/authLogger');\n\n// ============================================================================\n// Email Verification Code Storage\n// In-memory store for verification codes. Maps email -> { code, expires, attempts }\n// Can be upgraded to Redis for distributed deployments.\n// ============================================================================\n\nconst verificationCodes = new Map();\n\n// Verification code expiry time (10 minutes)\nconst VERIFICATION_CODE_EXPIRY_MS = 10 * 60 * 1000;\n\n// Maximum verification attempts before code is invalidated\nconst MAX_VERIFICATION_ATTEMPTS = 5;\n\n// Rate limiting: minimum time between sending codes to same email (60 seconds)\nconst SEND_CODE_COOLDOWN_MS = 60 * 1000;\n\n// Track last send time per email for rate limiting\nconst lastSendTime = new Map();\n\n// Cleanup interval for expired codes (every 5 minutes)\nconst CLEANUP_INTERVAL_MS = 5 * 60 * 1000;\n\n/**\n * Generate a 6-digit verification code\n * @returns {string} 6-digit code\n */\nfunction generateVerificationCode() {\n  // Generate cryptographically secure random 6-digit code\n  const code = crypto.randomInt(100000, 999999).toString();\n  return code;\n}\n\n/**\n * Store a verification code for an email\n * @param {string} email - Email address\n * @param {string} code - Verification code\n */\nfunction storeVerificationCode(email, code) {\n  const normalizedEmail = email.toLowerCase().trim();\n  verificationCodes.set(normalizedEmail, {\n    code,\n    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS,\n    attempts: 0,\n    createdAt: Date.now()\n  });\n  lastSendTime.set(normalizedEmail, Date.now());\n}\n\n/**\n * Verify a code for an email\n * @param {string} email - Email address\n * @param {string} code - Code to verify\n * @returns {{ valid: boolean, error?: string }}\n */\nfunction verifyCode(email, code) {\n  const normalizedEmail = email.toLowerCase().trim();\n  const stored = verificationCodes.get(normalizedEmail);\n\n  if (!stored) {\n    return { valid: false, error: 'No verification code found. Please request a new one.' };\n  }\n\n  // Check if expired\n  if (Date.now() > stored.expires) {\n    verificationCodes.delete(normalizedEmail);\n    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n  }\n\n  // Increment attempt counter\n  stored.attempts++;\n\n  // Check if too many attempts\n  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n    verificationCodes.delete(normalizedEmail);\n    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n  }\n\n  // Check if code matches\n  if (stored.code !== code) {\n    verificationCodes.set(normalizedEmail, stored);\n    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n  }\n\n  // Code is valid - remove it (single use)\n  verificationCodes.delete(normalizedEmail);\n  return { valid: true };\n}\n\n/**\n * Check if we can send a new code to an email (rate limiting)\n * @param {string} email - Email address\n * @returns {{ allowed: boolean, waitSeconds?: number }}\n */\nfunction canSendCode(email) {\n  const normalizedEmail = email.toLowerCase().trim();\n  const lastSent = lastSendTime.get(normalizedEmail);\n\n  if (!lastSent) {\n    return { allowed: true };\n  }\n\n  const elapsed = Date.now() - lastSent;\n  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n    return { allowed: false, waitSeconds };\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Clean up expired verification codes\n */\nfunction cleanupVerificationCodes() {\n  const now = Date.now();\n  let cleanedCount = 0;\n\n  for (const [email, data] of verificationCodes.entries()) {\n    if (data.expires <= now) {\n      verificationCodes.delete(email);\n      cleanedCount++;\n    }\n  }\n\n  // Also clean up old lastSendTime entries (older than 1 hour)\n  const oneHourAgo = now - (60 * 60 * 1000);\n  for (const [email, time] of lastSendTime.entries()) {\n    if (time < oneHourAgo) {\n      lastSendTime.delete(email);\n    }\n  }\n\n  if (cleanedCount > 0) {\n    console.log(`[Auth] Verification code cleanup: removed ${cleanedCount} expired codes`);\n  }\n}\n\n// Start periodic cleanup (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupVerificationCodes, CLEANUP_INTERVAL_MS);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Validate email format\n * @param {string} email - Email to validate\n * @returns {boolean}\n */\nfunction isValidEmail(email) {\n  if (!email || typeof email !== 'string') return false;\n  // Basic email validation regex\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email.trim());\n}\n\n/**\n * Create auth routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (authenticateToken)\n * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n * @param {Object} options.authHelpers - Auth helper functions\n * @returns {express.Router}\n */\nfunction createAuthRoutes(options = {}) {\n  const router = express.Router();\n  const { authenticateToken } = options.middleware || {};\n  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n  const { usageTracking, licenseService, emailService } = options.services || {};\n\n  /**\n   * GET /csrf-token - Generate and return a CSRF token\n   *\n   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   * The token is returned in both the response body and an HttpOnly cookie.\n   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   */\n  router.get('/csrf-token', csrfTokenHandler);\n\n  /**\n   * POST /login - Authenticate with license key and get JWT token\n   *\n   * SECURITY: This is the primary authentication endpoint.\n   * Validates license key and returns a JWT token for API access.\n   * CSRF protection applied to prevent cross-site login attacks.\n   */\n  router.post('/login', validateCsrfToken, async (req, res) => {\n    const { licenseKey } = req.body;\n\n    if (!licenseKey) {\n      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n      return res.status(400).json({\n        error: 'License key required',\n        message: 'Please provide your license key to log in'\n      });\n    }\n\n    try {\n      // Validate and activate the license key\n      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n\n      if (!licenseResult.success) {\n        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n        return res.status(401).json({\n          error: 'Invalid license key',\n          message: licenseResult.error || 'The license key is invalid or expired'\n        });\n      }\n\n      // Get user's tier and balance\n      const balance = await usageTracking.getBalance(licenseResult.customerId);\n\n      // Generate JWT tokens\n      const tokenResult = generateToken(licenseResult.customerId, {\n        tier: balance.tier,\n        email: licenseResult.email\n      });\n      const refreshResult = generateRefreshToken(licenseResult.customerId);\n\n      // Log successful login with structured logging\n      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n        email: licenseResult.email,\n        tier: balance.tier\n      });\n\n      res.json({\n        success: true,\n        token: tokenResult.token,\n        tokenType: tokenResult.tokenType,\n        expiresIn: tokenResult.expiresIn,\n        refreshToken: refreshResult.refreshToken,\n        customerId: licenseResult.customerId,\n        tier: balance.tier,\n        hoursRemaining: balance.hoursRemaining\n      });\n    } catch (err) {\n      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n    }\n  });\n\n  /**\n   * POST /refresh - Refresh an expired JWT token\n   *\n   * Uses a refresh token to get a new access token.\n   * CSRF protection applied to prevent token theft via cross-site requests.\n   */\n  router.post('/refresh', validateCsrfToken, async (req, res) => {\n    const { refreshToken } = req.body;\n\n    if (!refreshToken) {\n      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n      return res.status(400).json({\n        error: 'Refresh token required'\n      });\n    }\n\n    try {\n      const decoded = await verifyToken(refreshToken, { req });\n\n      if (!decoded || decoded.type !== 'refresh') {\n        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n        return res.status(401).json({\n          error: 'Invalid refresh token',\n          message: 'Please log in again'\n        });\n      }\n\n      // Get current user info\n      const balance = await usageTracking.getBalance(decoded.sub);\n\n      // Generate new access token\n      const tokenResult = generateToken(decoded.sub, {\n        tier: balance.tier\n      });\n\n      // Log successful token refresh\n      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n\n      res.json({\n        success: true,\n        token: tokenResult.token,\n        tokenType: tokenResult.tokenType,\n        expiresIn: tokenResult.expiresIn\n      });\n    } catch (err) {\n      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n      res.status(401).json({\n        error: 'Failed to refresh token',\n        message: 'Please log in again'\n      });\n    }\n  });\n\n  /**\n   * POST /logout - Invalidate tokens by adding to blacklist\n   *\n   * Adds the current token's jti to the blacklist so it cannot be reused.\n   * Also accepts an optional refreshToken to revoke both tokens at once.\n   * CSRF protection applied to prevent forced logout attacks.\n   */\n  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n    const { refreshToken } = req.body;\n    let refreshTokenRevoked = false;\n\n    // Blacklist the access token using the blacklistToken function from authHelpers\n    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n      if (blacklistToken) {\n        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n          userId: req.stripeCustomerId,\n          reason: 'logout'\n        });\n      } else {\n        console.warn('[Auth] Logout: blacklistToken function not available');\n      }\n    } else {\n      // Token doesn't have jti - log warning but continue\n      // This handles tokens generated before jti was added\n      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n    }\n\n    // Optionally blacklist the refresh token too\n    if (refreshToken && blacklistToken) {\n      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n      if (decoded && decoded.jti && decoded.exp) {\n        await blacklistToken(decoded.jti, decoded.exp, {\n          userId: req.stripeCustomerId,\n          reason: 'logout_refresh'\n        });\n        refreshTokenRevoked = true;\n      }\n    }\n\n    // Log successful logout with structured logging\n    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n      jti: req.tokenData?.jti,\n      refreshTokenRevoked\n    });\n\n    res.json({\n      success: true,\n      message: 'Logged out successfully'\n    });\n  });\n\n  // ==========================================================================\n  // Email Verification Endpoints\n  // ==========================================================================\n\n  /**\n   * POST /send-verification - Send a verification code to an email address\n   *\n   * Request body: { email: string }\n   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   *\n   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   */\n  router.post('/send-verification', validateCsrfToken, async (req, res) => {\n    const { email } = req.body;\n\n    // Validate email\n    if (!email) {\n      return res.status(400).json({\n        error: 'Email required',\n        message: 'Please provide an email address'\n      });\n    }\n\n    if (!isValidEmail(email)) {\n      return res.status(400).json({\n        error: 'Invalid email',\n        message: 'Please provide a valid email address'\n      });\n    }\n\n    // Check rate limiting\n    const rateCheck = canSendCode(email);\n    if (!rateCheck.allowed) {\n      return res.status(429).json({\n        error: 'Too many requests',\n        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n        waitSeconds: rateCheck.waitSeconds\n      });\n    }\n\n    try {\n      // Generate and store verification code\n      const code = generateVerificationCode();\n      storeVerificationCode(email, code);\n\n      // Send verification email\n      if (emailService && emailService.sendEmailVerificationCode) {\n        await emailService.sendEmailVerificationCode(email, code, 10);\n        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n      } else {\n        // Fallback for development - log to console\n        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n      }\n\n      res.json({\n        success: true,\n        message: 'Verification code sent. Please check your email.',\n        expiresInMinutes: 10\n      });\n    } catch (err) {\n      console.error('[Auth] Send verification error:', err.message);\n      res.status(500).json({\n        error: 'Failed to send verification code',\n        message: 'Please try again later'\n      });\n    }\n  });\n\n  /**\n   * POST /verify-email - Verify an email address with a code\n   *\n   * Request body: { email: string, code: string }\n   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   *\n   * SECURITY: Limited attempts per code. CSRF protection applied.\n   */\n  router.post('/verify-email', validateCsrfToken, async (req, res) => {\n    const { email, code } = req.body;\n\n    // Validate inputs\n    if (!email) {\n      return res.status(400).json({\n        error: 'Email required',\n        message: 'Please provide an email address'\n      });\n    }\n\n    if (!code) {\n      return res.status(400).json({\n        error: 'Code required',\n        message: 'Please provide the verification code'\n      });\n    }\n\n    if (!isValidEmail(email)) {\n      return res.status(400).json({\n        error: 'Invalid email',\n        message: 'Please provide a valid email address'\n      });\n    }\n\n    // Validate code format (6 digits)\n    const codeStr = String(code).trim();\n    if (!/^\\d{6}$/.test(codeStr)) {\n      return res.status(400).json({\n        error: 'Invalid code format',\n        message: 'Verification code must be 6 digits'\n      });\n    }\n\n    try {\n      // Verify the code\n      const result = verifyCode(email, codeStr);\n\n      if (!result.valid) {\n        return res.status(400).json({\n          success: false,\n          verified: false,\n          error: 'Verification failed',\n          message: result.error\n        });\n      }\n\n      // Mark email as verified in the database\n      if (usageTracking && usageTracking.markEmailVerified) {\n        const dbResult = await usageTracking.markEmailVerified(email);\n        if (!dbResult.success) {\n          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n        }\n      }\n\n      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n\n      // Email verified successfully\n      res.json({\n        success: true,\n        verified: true,\n        message: 'Email verified successfully'\n      });\n    } catch (err) {\n      console.error('[Auth] Verify email error:', err.message);\n      res.status(500).json({\n        error: 'Verification failed',\n        message: 'Please try again later'\n      });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createAuthRoutes;\n","numLines":510,"startLine":1,"totalLines":510}}}
{"parentUuid":"fe5bf5d4-ac46-4896-b166-30f4804431af","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AMXMAG6AiNnrvLkfS5wyAB","type":"tool_result","content":"     1→/**\n     2→ * JWT Authentication Middleware\n     3→ *\n     4→ * Replaces insecure x-stripe-customer-id header with JWT tokens.\n     5→ * Tokens are signed with a secret and contain the customer ID.\n     6→ *\n     7→ * Token Blacklist:\n     8→ * - Primary: Upstash Redis with automatic TTL-based expiry\n     9→ * - Fallback: In-memory Map (for development or Redis failures)\n    10→ */\n    11→\n    12→const jwt = require('jsonwebtoken');\n    13→const crypto = require('crypto');\n    14→const authLogger = require('../utils/authLogger');\n    15→const redis = require('../services/redisClient');\n    16→\n    17→// JWT configuration\n    18→const JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\n    19→const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\n    20→const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n    21→\n    22→// Redis key prefix for blacklisted tokens\n    23→const BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n    24→\n    25→// Check if running in production\n    26→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    27→\n    28→// Warn if using default secret in production\n    29→if (isProduction && JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    30→  console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    31→  console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    32→  process.exit(1);\n    33→}\n    34→\n    35→/**\n    36→ * Fallback Token Blacklist (In-Memory)\n    37→ * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n    38→ */\n    39→const fallbackBlacklist = new Map();\n    40→\n    41→// Track if we're using fallback mode\n    42→let usingFallback = false;\n    43→\n    44→// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\n    45→const BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n    46→\n    47→/**\n    48→ * Clean up expired entries from the fallback blacklist\n    49→ * Only runs when using in-memory fallback\n    50→ */\n    51→function cleanupFallbackBlacklist() {\n    52→  if (!usingFallback || fallbackBlacklist.size === 0) {\n    53→    return;\n    54→  }\n    55→\n    56→  const now = Math.floor(Date.now() / 1000);\n    57→  let cleanedCount = 0;\n    58→\n    59→  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    60→    if (exp <= now) {\n    61→      fallbackBlacklist.delete(jti);\n    62→      cleanedCount++;\n    63→    }\n    64→  }\n    65→\n    66→  if (cleanedCount > 0) {\n    67→    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n    68→  }\n    69→}\n    70→\n    71→// Start periodic cleanup for fallback (unref to allow process exit)\n    72→const cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\n    73→if (cleanupTimer.unref) {\n    74→  cleanupTimer.unref();\n    75→}\n    76→\n    77→/**\n    78→ * Add a token to the blacklist\n    79→ * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n    80→ * @param {string} jti - JWT ID claim\n    81→ * @param {number} exp - Token expiration timestamp (Unix seconds)\n    82→ * @param {Object} options - Additional options for logging\n    83→ * @param {string} options.userId - User ID for logging\n    84→ * @param {string} options.reason - Reason for revocation (logout, security, admin)\n    85→ * @returns {Promise<boolean>} True if successfully blacklisted\n    86→ */\n    87→async function blacklistToken(jti, exp, options = {}) {\n    88→  if (!jti) {\n    89→    console.warn('[Auth] Cannot blacklist token without jti');\n    90→    return false;\n    91→  }\n    92→\n    93→  const now = Math.floor(Date.now() / 1000);\n    94→  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n    95→\n    96→  // Try Redis first\n    97→  if (redis.isRedisAvailable()) {\n    98→    try {\n    99→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   100→      const success = await redis.set(key, exp, ttlSeconds);\n   101→\n   102→      if (success) {\n   103→        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n   104→        usingFallback = false;\n   105→        // Log token revocation with structured logging\n   106→        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   107→        return true;\n   108→      }\n   109→    } catch (err) {\n   110→      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n   111→    }\n   112→  }\n   113→\n   114→  // Fallback to in-memory\n   115→  usingFallback = true;\n   116→  fallbackBlacklist.set(jti, exp);\n   117→  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n   118→\n   119→  // Log token revocation with structured logging\n   120→  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   121→  return true;\n   122→}\n   123→\n   124→/**\n   125→ * Check if a token is blacklisted\n   126→ * Checks Redis first, then fallback in-memory store\n   127→ * @param {string} jti - JWT ID claim\n   128→ * @returns {Promise<boolean>} True if token is blacklisted\n   129→ */\n   130→async function isTokenBlacklisted(jti) {\n   131→  if (!jti) {\n   132→    return false;\n   133→  }\n   134→\n   135→  // Try Redis first\n   136→  if (redis.isRedisAvailable()) {\n   137→    try {\n   138→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   139→      const exists = await redis.exists(key);\n   140→\n   141→      if (exists) {\n   142→        return true;\n   143→      }\n   144→\n   145→      // Also check fallback in case token was blacklisted during Redis downtime\n   146→      // and Redis is now back up\n   147→      if (fallbackBlacklist.has(jti)) {\n   148→        // Migrate to Redis if token still valid\n   149→        const exp = fallbackBlacklist.get(jti);\n   150→        const now = Math.floor(Date.now() / 1000);\n   151→        if (exp > now) {\n   152→          const ttlSeconds = exp - now;\n   153→          await redis.set(key, exp, ttlSeconds);\n   154→          fallbackBlacklist.delete(jti);\n   155→          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n   156→        } else {\n   157→          // Expired, remove from fallback\n   158→          fallbackBlacklist.delete(jti);\n   159→        }\n   160→        return true;\n   161→      }\n   162→\n   163→      return false;\n   164→    } catch (err) {\n   165→      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n   166→    }\n   167→  }\n   168→\n   169→  // Fallback to in-memory check\n   170→  if (fallbackBlacklist.has(jti)) {\n   171→    const exp = fallbackBlacklist.get(jti);\n   172→    const now = Math.floor(Date.now() / 1000);\n   173→    if (exp > now) {\n   174→      return true;\n   175→    }\n   176→    // Expired, remove it\n   177→    fallbackBlacklist.delete(jti);\n   178→  }\n   179→\n   180→  return false;\n   181→}\n   182→\n   183→/**\n   184→ * Get blacklist statistics (for monitoring)\n   185→ * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n   186→ */\n   187→async function getBlacklistStats() {\n   188→  const redisAvailable = redis.isRedisAvailable();\n   189→  const redisStatus = redis.getRedisStatus();\n   190→\n   191→  return {\n   192→    storage: redisAvailable ? 'redis' : 'memory',\n   193→    redisConnected: redisStatus.connected,\n   194→    redisError: redisStatus.error,\n   195→    fallbackSize: fallbackBlacklist.size,\n   196→    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n   197→    usingFallback\n   198→  };\n   199→}\n   200→\n   201→/**\n   202→ * Generate a JWT token for a customer\n   203→ * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n   204→ * @param {Object} options - Additional options\n   205→ * @param {string} options.tier - User's subscription tier\n   206→ * @param {string} options.email - User's email (optional)\n   207→ * @returns {Object} { token, expiresIn }\n   208→ */\n   209→function generateToken(stripeCustomerId, options = {}) {\n   210→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   211→    throw new Error('Invalid Stripe customer ID');\n   212→  }\n   213→\n   214→  const payload = {\n   215→    sub: stripeCustomerId,\n   216→    type: 'access',\n   217→    tier: options.tier || 'starter',\n   218→    iat: Math.floor(Date.now() / 1000),\n   219→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   220→  };\n   221→\n   222→  if (options.email) {\n   223→    payload.email = options.email;\n   224→  }\n   225→\n   226→  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n   227→\n   228→  return {\n   229→    token,\n   230→    expiresIn: JWT_EXPIRES_IN,\n   231→    tokenType: 'Bearer'\n   232→  };\n   233→}\n   234→\n   235→/**\n   236→ * Generate a refresh token for a customer\n   237→ * @param {string} stripeCustomerId - Stripe customer ID\n   238→ * @returns {Object} { refreshToken, expiresIn }\n   239→ */\n   240→function generateRefreshToken(stripeCustomerId) {\n   241→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   242→    throw new Error('Invalid Stripe customer ID');\n   243→  }\n   244→\n   245→  const payload = {\n   246→    sub: stripeCustomerId,\n   247→    type: 'refresh',\n   248→    iat: Math.floor(Date.now() / 1000),\n   249→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   250→  };\n   251→\n   252→  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n   253→\n   254→  return {\n   255→    refreshToken,\n   256→    expiresIn: JWT_REFRESH_EXPIRES_IN\n   257→  };\n   258→}\n   259→\n   260→/**\n   261→ * Verify and decode a JWT token (async version)\n   262→ * Checks both JWT signature validity and token blacklist status via Redis\n   263→ * @param {string} token - JWT token to verify\n   264→ * @param {Object} options - Verification options\n   265→ * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n   266→ * @param {Object} options.req - Express request object for logging (optional)\n   267→ * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n   268→ */\n   269→async function verifyToken(token, options = {}) {\n   270→  const { checkBlacklist = true, req = null } = options;\n   271→\n   272→  try {\n   273→    const decoded = jwt.verify(token, JWT_SECRET);\n   274→\n   275→    // Check if token has been revoked (blacklisted) - async Redis check\n   276→    if (checkBlacklist && decoded.jti) {\n   277→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   278→      if (isBlacklisted) {\n   279→        if (req) {\n   280→          authLogger.logTokenBlacklisted(req, decoded.jti);\n   281→        }\n   282→        return null;\n   283→      }\n   284→    }\n   285→\n   286→    return decoded;\n   287→  } catch (err) {\n   288→    // Log specific error types for debugging\n   289→    if (err.name === 'TokenExpiredError') {\n   290→      if (req) {\n   291→        authLogger.logTokenExpired(req);\n   292→      }\n   293→    } else if (err.name === 'JsonWebTokenError') {\n   294→      if (req) {\n   295→        authLogger.logTokenInvalid(req, err.message);\n   296→      }\n   297→    }\n   298→    return null;\n   299→  }\n   300→}\n   301→\n   302→/**\n   303→ * Synchronous token verification (for cases where async is not possible)\n   304→ * Does NOT check blacklist - use verifyToken() for full verification\n   305→ * @param {string} token - JWT token to verify\n   306→ * @returns {Object|null} Decoded payload or null if invalid\n   307→ */\n   308→function verifyTokenSync(token) {\n   309→  try {\n   310→    return jwt.verify(token, JWT_SECRET);\n   311→  } catch {\n   312→    return null;\n   313→  }\n   314→}\n   315→\n   316→/**\n   317→ * Extract Bearer token from Authorization header\n   318→ * @param {string} authHeader - Authorization header value\n   319→ * @returns {string|null} Token or null if not found\n   320→ */\n   321→function extractBearerToken(authHeader) {\n   322→  if (!authHeader || typeof authHeader !== 'string') {\n   323→    return null;\n   324→  }\n   325→\n   326→  const parts = authHeader.split(' ');\n   327→  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n   328→    return null;\n   329→  }\n   330→\n   331→  return parts[1];\n   332→}\n   333→\n   334→/**\n   335→ * Middleware to authenticate JWT tokens\n   336→ * Sets req.stripeCustomerId if valid token found\n   337→ *\n   338→ * Supports both:\n   339→ * - Authorization: Bearer <token> (preferred)\n   340→ * - x-stripe-customer-id header (legacy, will be deprecated)\n   341→ */\n   342→async function authenticateToken(req, res, next) {\n   343→  // First, try JWT token from Authorization header\n   344→  const authHeader = req.headers['authorization'];\n   345→  const token = extractBearerToken(authHeader);\n   346→\n   347→  if (token) {\n   348→    // First verify JWT signature without blacklist check to get specific error messages\n   349→    const decoded = verifyTokenSync(token);\n   350→\n   351→    if (!decoded || !decoded.sub) {\n   352→      // Token is invalid or expired (signature failed)\n   353→      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n   354→      return res.status(401).json({\n   355→        error: 'Invalid or expired token',\n   356→        message: 'Please log in again to continue'\n   357→      });\n   358→    }\n   359→\n   360→    // Check if token has been revoked (blacklisted) - async Redis check\n   361→    if (decoded.jti) {\n   362→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   363→      if (isBlacklisted) {\n   364→        authLogger.logTokenBlacklisted(req, decoded.jti);\n   365→        return res.status(401).json({\n   366→          error: 'Token has been revoked',\n   367→          message: 'This session has been logged out. Please log in again.'\n   368→        });\n   369→      }\n   370→    }\n   371→\n   372→    // Token is valid and not revoked\n   373→    req.stripeCustomerId = decoded.sub;\n   374→    req.tokenData = decoded;\n   375→    req.rawToken = token; // Store raw token for logout\n   376→    return next();\n   377→  }\n   378→\n   379→  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n   380→  // This will be deprecated in future versions\n   381→  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   382→  if (legacyCustomerId) {\n   383→    // Log deprecation warning with structured logging (once per request)\n   384→    if (!req._legacyAuthWarned) {\n   385→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   386→      req._legacyAuthWarned = true;\n   387→    }\n   388→\n   389→    // Validate format\n   390→    if (!legacyCustomerId.startsWith('cus_')) {\n   391→      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n   392→      return res.status(401).json({\n   393→        error: 'Invalid customer ID format',\n   394→        message: 'Customer ID must start with cus_'\n   395→      });\n   396→    }\n   397→\n   398→    req.stripeCustomerId = legacyCustomerId;\n   399→    req.isLegacyAuth = true;\n   400→    return next();\n   401→  }\n   402→\n   403→  // No authentication provided\n   404→  return res.status(401).json({\n   405→    error: 'Authentication required',\n   406→    message: 'Please provide a valid Bearer token in the Authorization header'\n   407→  });\n   408→}\n   409→\n   410→/**\n   411→ * Optional authentication middleware\n   412→ * Allows unauthenticated access but sets req.stripeCustomerId if token present\n   413→ */\n   414→async function optionalAuthentication(req, res, next) {\n   415→  const authHeader = req.headers['authorization'];\n   416→  const token = extractBearerToken(authHeader);\n   417→\n   418→  if (token) {\n   419→    const decoded = await verifyToken(token);\n   420→    if (decoded && decoded.sub) {\n   421→      req.stripeCustomerId = decoded.sub;\n   422→      req.tokenData = decoded;\n   423→    }\n   424→  } else {\n   425→    // Check legacy header\n   426→    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   427→    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n   428→      req.stripeCustomerId = legacyCustomerId;\n   429→      req.isLegacyAuth = true;\n   430→    }\n   431→  }\n   432→\n   433→  next();\n   434→}\n   435→\n   436→/**\n   437→ * Mask sensitive data for logging\n   438→ * @param {string} key - License key or other sensitive string\n   439→ * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n   440→ */\n   441→function maskSensitiveData(data) {\n   442→  if (!data || typeof data !== 'string') {\n   443→    return '****';\n   444→  }\n   445→\n   446→  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n   447→  if (data.startsWith('SPLICE-')) {\n   448→    const parts = data.split('-');\n   449→    if (parts.length === 5) {\n   450→      return `${parts[0]}-${parts[1]}-****-****-****`;\n   451→    }\n   452→  }\n   453→\n   454→  // For customer IDs (cus_xxxx format)\n   455→  if (data.startsWith('cus_')) {\n   456→    if (data.length > 10) {\n   457→      return `cus_${data.slice(4, 8)}****`;\n   458→    }\n   459→    return 'cus_****';\n   460→  }\n   461→\n   462→  // For JWTs (eyJ... format)\n   463→  if (data.startsWith('eyJ')) {\n   464→    return `${data.slice(0, 10)}...****`;\n   465→  }\n   466→\n   467→  // For emails\n   468→  if (data.includes('@')) {\n   469→    const [local, domain] = data.split('@');\n   470→    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n   471→    return `${maskedLocal}@${domain}`;\n   472→  }\n   473→\n   474→  // Generic masking - show first 4 chars\n   475→  if (data.length > 8) {\n   476→    return `${data.slice(0, 4)}****`;\n   477→  }\n   478→\n   479→  return '****';\n   480→}\n   481→\n   482→module.exports = {\n   483→  generateToken,\n   484→  generateRefreshToken,\n   485→  verifyToken,\n   486→  verifyTokenSync,\n   487→  extractBearerToken,\n   488→  authenticateToken,\n   489→  optionalAuthentication,\n   490→  maskSensitiveData,\n   491→  // Token blacklist functions\n   492→  blacklistToken,\n   493→  isTokenBlacklisted,\n   494→  getBlacklistStats,\n   495→  // Structured logging\n   496→  authLogger,\n   497→  // Constants\n   498→  JWT_SECRET,\n   499→  JWT_EXPIRES_IN\n   500→};\n   501→\n\n</system-reminder>\n"}]},"uuid":"64a213c7-cf7b-4b79-910a-1eece7c4bede","timestamp":"2025-12-30T02:09:40.885Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","content":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// Warn if using default secret in production\nif (isProduction && JWT_SECRET === 'splice-dev-secret-change-in-production') {\n  console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n  console.error('[SECURITY] Exiting process to prevent insecure operation.');\n  process.exit(1);\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n  // This will be deprecated in future versions\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // Check legacy header\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      req.stripeCustomerId = legacyCustomerId;\n      req.isLegacyAuth = true;\n    }\n  }\n\n  next();\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};\n","numLines":501,"startLine":1,"totalLines":501}}}
{"parentUuid":"64a213c7-cf7b-4b79-910a-1eece7c4bede","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WmwNdK2EQCtnPUBrjVpo25","type":"tool_result","content":"     1→/**\n     2→ * CSRF Protection Middleware\n     3→ *\n     4→ * Implements double-submit cookie pattern for CSRF protection.\n     5→ * Works with stateless JWT authentication.\n     6→ *\n     7→ * How it works:\n     8→ * 1. Client requests a CSRF token via GET /auth/csrf-token\n     9→ * 2. Server generates a cryptographically random token\n    10→ * 3. Server sends token in both:\n    11→ *    - Response body (for JavaScript to read)\n    12→ *    - HttpOnly cookie (for automatic submission)\n    13→ * 4. Client includes token in X-CSRF-Token header on state-changing requests\n    14→ * 5. Server validates header token matches cookie token\n    15→ */\n    16→\n    17→const crypto = require('crypto');\n    18→\n    19→// CSRF Configuration\n    20→const CSRF_TOKEN_LENGTH = 32; // 256 bits\n    21→const CSRF_COOKIE_NAME = 'splice_csrf';\n    22→const CSRF_HEADER_NAME = 'x-csrf-token';\n    23→const CSRF_TOKEN_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n    24→\n    25→// Check if running in production\n    26→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    27→\n    28→/**\n    29→ * Generate a cryptographically secure CSRF token\n    30→ * @returns {string} Hex-encoded random token\n    31→ */\n    32→function generateCsrfToken() {\n    33→  return crypto.randomBytes(CSRF_TOKEN_LENGTH).toString('hex');\n    34→}\n    35→\n    36→/**\n    37→ * Constant-time comparison to prevent timing attacks\n    38→ * @param {string} a - First string\n    39→ * @param {string} b - Second string\n    40→ * @returns {boolean} True if strings are equal\n    41→ */\n    42→function safeCompare(a, b) {\n    43→  if (!a || !b || typeof a !== 'string' || typeof b !== 'string') {\n    44→    return false;\n    45→  }\n    46→\n    47→  // Use crypto.timingSafeEqual for constant-time comparison\n    48→  const bufA = Buffer.from(a);\n    49→  const bufB = Buffer.from(b);\n    50→\n    51→  if (bufA.length !== bufB.length) {\n    52→    return false;\n    53→  }\n    54→\n    55→  return crypto.timingSafeEqual(bufA, bufB);\n    56→}\n    57→\n    58→/**\n    59→ * Get cookie options for CSRF token\n    60→ * @returns {Object} Cookie configuration\n    61→ */\n    62→function getCsrfCookieOptions() {\n    63→  return {\n    64→    httpOnly: true,\n    65→    secure: isProduction, // Only secure in production (HTTPS)\n    66→    sameSite: 'strict', // Strict same-site policy for CSRF protection\n    67→    maxAge: CSRF_TOKEN_EXPIRY,\n    68→    path: '/',\n    69→    // Domain is omitted to default to the current domain\n    70→  };\n    71→}\n    72→\n    73→/**\n    74→ * Handler to generate and return a CSRF token\n    75→ * Should be mounted as GET /auth/csrf-token\n    76→ *\n    77→ * @param {Request} req - Express request\n    78→ * @param {Response} res - Express response\n    79→ */\n    80→function csrfTokenHandler(req, res) {\n    81→  const token = generateCsrfToken();\n    82→\n    83→  // Set the token in an HttpOnly cookie\n    84→  res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n    85→\n    86→  // Also return token in response body for JavaScript to use\n    87→  // The client will send this in the X-CSRF-Token header\n    88→  res.json({\n    89→    success: true,\n    90→    csrfToken: token,\n    91→    expiresIn: CSRF_TOKEN_EXPIRY / 1000 // seconds\n    92→  });\n    93→\n    94→  console.log('[CSRF] Token generated for request');\n    95→}\n    96→\n    97→/**\n    98→ * Middleware to validate CSRF token on state-changing requests\n    99→ * Checks that the X-CSRF-Token header matches the cookie value\n   100→ *\n   101→ * @param {Request} req - Express request\n   102→ * @param {Response} res - Express response\n   103→ * @param {Function} next - Next middleware\n   104→ */\n   105→function validateCsrfToken(req, res, next) {\n   106→  // Skip CSRF validation for safe methods (GET, HEAD, OPTIONS)\n   107→  const safeMethods = ['GET', 'HEAD', 'OPTIONS'];\n   108→  if (safeMethods.includes(req.method)) {\n   109→    return next();\n   110→  }\n   111→\n   112→  // Get token from header\n   113→  const headerToken = req.headers[CSRF_HEADER_NAME];\n   114→\n   115→  // Get token from cookie\n   116→  const cookieToken = req.cookies?.[CSRF_COOKIE_NAME];\n   117→\n   118→  // Validate both tokens exist\n   119→  if (!headerToken) {\n   120→    console.warn('[CSRF] Missing CSRF token in header');\n   121→    return res.status(403).json({\n   122→      error: 'CSRF token missing',\n   123→      message: 'Please refresh the page and try again'\n   124→    });\n   125→  }\n   126→\n   127→  if (!cookieToken) {\n   128→    console.warn('[CSRF] Missing CSRF cookie');\n   129→    return res.status(403).json({\n   130→      error: 'CSRF validation failed',\n   131→      message: 'Session expired. Please refresh the page and try again'\n   132→    });\n   133→  }\n   134→\n   135→  // Use constant-time comparison to prevent timing attacks\n   136→  if (!safeCompare(headerToken, cookieToken)) {\n   137→    console.warn('[CSRF] Token mismatch - possible CSRF attack');\n   138→    return res.status(403).json({\n   139→      error: 'CSRF validation failed',\n   140→      message: 'Security validation failed. Please refresh the page and try again'\n   141→    });\n   142→  }\n   143→\n   144→  // Token is valid\n   145→  next();\n   146→}\n   147→\n   148→/**\n   149→ * Conditional CSRF validation middleware\n   150→ * Skips validation for certain routes (e.g., webhooks, public endpoints)\n   151→ *\n   152→ * @param {Object} options - Configuration options\n   153→ * @param {string[]} options.skipRoutes - Array of route patterns to skip\n   154→ * @returns {Function} Middleware function\n   155→ */\n   156→function csrfProtection(options = {}) {\n   157→  const { skipRoutes = [] } = options;\n   158→\n   159→  // Default routes to skip CSRF validation\n   160→  const defaultSkipRoutes = [\n   161→    '/webhooks/', // Stripe webhooks use their own signature verification\n   162→    '/health', // Health checks are public\n   163→    '/api-info', // API info is public\n   164→  ];\n   165→\n   166→  const allSkipRoutes = [...defaultSkipRoutes, ...skipRoutes];\n   167→\n   168→  return (req, res, next) => {\n   169→    // Check if this route should skip CSRF validation\n   170→    const shouldSkip = allSkipRoutes.some(route => req.path.startsWith(route));\n   171→\n   172→    if (shouldSkip) {\n   173→      return next();\n   174→    }\n   175→\n   176→    // Apply CSRF validation\n   177→    return validateCsrfToken(req, res, next);\n   178→  };\n   179→}\n   180→\n   181→/**\n   182→ * Middleware to ensure CSRF cookie exists\n   183→ * Sets a new cookie if one doesn't exist\n   184→ * Useful for ensuring cookie is set before any form is shown\n   185→ *\n   186→ * @param {Request} req - Express request\n   187→ * @param {Response} res - Express response\n   188→ * @param {Function} next - Next middleware\n   189→ */\n   190→function ensureCsrfCookie(req, res, next) {\n   191→  // Check if cookie already exists\n   192→  if (!req.cookies?.[CSRF_COOKIE_NAME]) {\n   193→    const token = generateCsrfToken();\n   194→    res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n   195→  }\n   196→  next();\n   197→}\n   198→\n   199→module.exports = {\n   200→  generateCsrfToken,\n   201→  csrfTokenHandler,\n   202→  validateCsrfToken,\n   203→  csrfProtection,\n   204→  ensureCsrfCookie,\n   205→  // Constants for external use\n   206→  CSRF_COOKIE_NAME,\n   207→  CSRF_HEADER_NAME,\n   208→  CSRF_TOKEN_EXPIRY\n   209→};\n   210→\n\n</system-reminder>\n"}]},"uuid":"daee769d-4851-438b-b37e-53deddb1eb45","timestamp":"2025-12-30T02:09:40.885Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js","content":"/**\n * CSRF Protection Middleware\n *\n * Implements double-submit cookie pattern for CSRF protection.\n * Works with stateless JWT authentication.\n *\n * How it works:\n * 1. Client requests a CSRF token via GET /auth/csrf-token\n * 2. Server generates a cryptographically random token\n * 3. Server sends token in both:\n *    - Response body (for JavaScript to read)\n *    - HttpOnly cookie (for automatic submission)\n * 4. Client includes token in X-CSRF-Token header on state-changing requests\n * 5. Server validates header token matches cookie token\n */\n\nconst crypto = require('crypto');\n\n// CSRF Configuration\nconst CSRF_TOKEN_LENGTH = 32; // 256 bits\nconst CSRF_COOKIE_NAME = 'splice_csrf';\nconst CSRF_HEADER_NAME = 'x-csrf-token';\nconst CSRF_TOKEN_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n/**\n * Generate a cryptographically secure CSRF token\n * @returns {string} Hex-encoded random token\n */\nfunction generateCsrfToken() {\n  return crypto.randomBytes(CSRF_TOKEN_LENGTH).toString('hex');\n}\n\n/**\n * Constant-time comparison to prevent timing attacks\n * @param {string} a - First string\n * @param {string} b - Second string\n * @returns {boolean} True if strings are equal\n */\nfunction safeCompare(a, b) {\n  if (!a || !b || typeof a !== 'string' || typeof b !== 'string') {\n    return false;\n  }\n\n  // Use crypto.timingSafeEqual for constant-time comparison\n  const bufA = Buffer.from(a);\n  const bufB = Buffer.from(b);\n\n  if (bufA.length !== bufB.length) {\n    return false;\n  }\n\n  return crypto.timingSafeEqual(bufA, bufB);\n}\n\n/**\n * Get cookie options for CSRF token\n * @returns {Object} Cookie configuration\n */\nfunction getCsrfCookieOptions() {\n  return {\n    httpOnly: true,\n    secure: isProduction, // Only secure in production (HTTPS)\n    sameSite: 'strict', // Strict same-site policy for CSRF protection\n    maxAge: CSRF_TOKEN_EXPIRY,\n    path: '/',\n    // Domain is omitted to default to the current domain\n  };\n}\n\n/**\n * Handler to generate and return a CSRF token\n * Should be mounted as GET /auth/csrf-token\n *\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n */\nfunction csrfTokenHandler(req, res) {\n  const token = generateCsrfToken();\n\n  // Set the token in an HttpOnly cookie\n  res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n\n  // Also return token in response body for JavaScript to use\n  // The client will send this in the X-CSRF-Token header\n  res.json({\n    success: true,\n    csrfToken: token,\n    expiresIn: CSRF_TOKEN_EXPIRY / 1000 // seconds\n  });\n\n  console.log('[CSRF] Token generated for request');\n}\n\n/**\n * Middleware to validate CSRF token on state-changing requests\n * Checks that the X-CSRF-Token header matches the cookie value\n *\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n * @param {Function} next - Next middleware\n */\nfunction validateCsrfToken(req, res, next) {\n  // Skip CSRF validation for safe methods (GET, HEAD, OPTIONS)\n  const safeMethods = ['GET', 'HEAD', 'OPTIONS'];\n  if (safeMethods.includes(req.method)) {\n    return next();\n  }\n\n  // Get token from header\n  const headerToken = req.headers[CSRF_HEADER_NAME];\n\n  // Get token from cookie\n  const cookieToken = req.cookies?.[CSRF_COOKIE_NAME];\n\n  // Validate both tokens exist\n  if (!headerToken) {\n    console.warn('[CSRF] Missing CSRF token in header');\n    return res.status(403).json({\n      error: 'CSRF token missing',\n      message: 'Please refresh the page and try again'\n    });\n  }\n\n  if (!cookieToken) {\n    console.warn('[CSRF] Missing CSRF cookie');\n    return res.status(403).json({\n      error: 'CSRF validation failed',\n      message: 'Session expired. Please refresh the page and try again'\n    });\n  }\n\n  // Use constant-time comparison to prevent timing attacks\n  if (!safeCompare(headerToken, cookieToken)) {\n    console.warn('[CSRF] Token mismatch - possible CSRF attack');\n    return res.status(403).json({\n      error: 'CSRF validation failed',\n      message: 'Security validation failed. Please refresh the page and try again'\n    });\n  }\n\n  // Token is valid\n  next();\n}\n\n/**\n * Conditional CSRF validation middleware\n * Skips validation for certain routes (e.g., webhooks, public endpoints)\n *\n * @param {Object} options - Configuration options\n * @param {string[]} options.skipRoutes - Array of route patterns to skip\n * @returns {Function} Middleware function\n */\nfunction csrfProtection(options = {}) {\n  const { skipRoutes = [] } = options;\n\n  // Default routes to skip CSRF validation\n  const defaultSkipRoutes = [\n    '/webhooks/', // Stripe webhooks use their own signature verification\n    '/health', // Health checks are public\n    '/api-info', // API info is public\n  ];\n\n  const allSkipRoutes = [...defaultSkipRoutes, ...skipRoutes];\n\n  return (req, res, next) => {\n    // Check if this route should skip CSRF validation\n    const shouldSkip = allSkipRoutes.some(route => req.path.startsWith(route));\n\n    if (shouldSkip) {\n      return next();\n    }\n\n    // Apply CSRF validation\n    return validateCsrfToken(req, res, next);\n  };\n}\n\n/**\n * Middleware to ensure CSRF cookie exists\n * Sets a new cookie if one doesn't exist\n * Useful for ensuring cookie is set before any form is shown\n *\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n * @param {Function} next - Next middleware\n */\nfunction ensureCsrfCookie(req, res, next) {\n  // Check if cookie already exists\n  if (!req.cookies?.[CSRF_COOKIE_NAME]) {\n    const token = generateCsrfToken();\n    res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n  }\n  next();\n}\n\nmodule.exports = {\n  generateCsrfToken,\n  csrfTokenHandler,\n  validateCsrfToken,\n  csrfProtection,\n  ensureCsrfCookie,\n  // Constants for external use\n  CSRF_COOKIE_NAME,\n  CSRF_HEADER_NAME,\n  CSRF_TOKEN_EXPIRY\n};\n","numLines":210,"startLine":1,"totalLines":210}}}
{"parentUuid":"daee769d-4851-438b-b37e-53deddb1eb45","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KVwWA1Cs4EXibQyJ4e9aXN","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Backend Server\n     3→ *\n     4→ * Main entry point for the SPLICE backend API.\n     5→ * Orchestrates the audio analysis pipeline.\n     6→ *\n     7→ * Slices:\n     8→ * - Slice 4: Transcription (services/transcription.js)\n     9→ * - Slice 5: Take Detection (services/takeDetection.js)\n    10→ *\n    11→ * Architecture: Modular routes (see routes/ directory)\n    12→ */\n    13→\n    14→\n    15→require('dotenv').config();\n    16→\n    17→const express = require('express');\n    18→const cors = require('cors');\n    19→const helmet = require('helmet');\n    20→const cookieParser = require('cookie-parser');\n    21→const fs = require('fs');\n    22→const https = require('https');\n    23→const http = require('http');\n    24→const path = require('path');\n    25→const crypto = require('crypto');\n    26→\n    27→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\n    28→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    29→\n    30→// Import services\n    31→const usageTracking = require('./services/usageTracking');\n    32→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\n    33→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\n    34→const referralService = require('./services/referralService');\n    35→const licenseService = require('./services/licenseService');\n    36→const emailService = require('./services/emailService');\n    37→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\n    38→const { getSupportedFormats } = require('./services/captionExporter');\n    39→\n    40→// Import route modules\n    41→const healthRoutes = require('./routes/health');\n    42→const analyzeRoutes = require('./routes/analyze');\n    43→const silencesRoutes = require('./routes/silences');\n    44→const detectionRoutes = require('./routes/detection');\n    45→const exportRoutes = require('./routes/export');\n    46→const multitrackRoutes = require('./routes/multitrack');\n    47→const cutListRoutes = require('./routes/cutList');\n    48→const zoomRoutes = require('./routes/zoom');\n    49→const chaptersRoutes = require('./routes/chapters');\n    50→const youtubeRoutes = require('./routes/youtube');\n    51→const captionsRoutes = require('./routes/captions');\n    52→const textEditRoutes = require('./routes/textEdit');\n    53→const reframeRoutes = require('./routes/reframe');\n    54→const batchRoutes = require('./routes/batch');\n    55→const authRoutes = require('./routes/auth');\n    56→const billingRoutes = require('./routes/billing');\n    57→const referralRoutes = require('./routes/referral');\n    58→const licenseRoutes = require('./routes/license');\n    59→const musicRoutes = require('./routes/music');\n    60→\n    61→// Stripe for webhooks\n    62→const Stripe = require('stripe');\n    63→\n    64→// Validate STRIPE_SECRET_KEY in production - exit if missing\n    65→if (isProduction && !process.env.STRIPE_SECRET_KEY) {\n    66→  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');\n    67→  process.exit(1);\n    68→}\n    69→\n    70→// Validate JWT_SECRET in production - exit if using default\n    71→if (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {\n    72→  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');\n    73→  process.exit(1);\n    74→}\n    75→\n    76→// Validate DATABASE_URL in production\n    77→if (isProduction && !process.env.DATABASE_URL) {\n    78→  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');\n    79→  process.exit(1);\n    80→}\n    81→\n    82→// Validate OPENAI_API_KEY in production\n    83→if (isProduction && !process.env.OPENAI_API_KEY) {\n    84→  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');\n    85→  process.exit(1);\n    86→}\n    87→\n    88→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n    89→\n    90→// =============================================================================\n    91→// PERF-FIX: Static Response Cache\n    92→// Cache static endpoint responses at startup to avoid repeated computation\n    93→// =============================================================================\n    94→\n    95→// Generate ETag from content\n    96→function generateETag(content) {\n    97→  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n    98→}\n    99→\n   100→// Static response cache - populated at startup\n   101→const STATIC_RESPONSE_CACHE = {\n   102→  profanityLanguages: null,\n   103→  profanityBleeps: null,\n   104→  exportFormats: null\n   105→};\n   106→\n   107→// Initialize cache at startup (called after server starts)\n   108→function initializeStaticCache() {\n   109→  // Cache profanity languages\n   110→  const languages = getSupportedLanguages();\n   111→  STATIC_RESPONSE_CACHE.profanityLanguages = {\n   112→    body: { success: true, languages },\n   113→    etag: generateETag({ languages })\n   114→  };\n   115→\n   116→  // Cache profanity bleeps\n   117→  const sounds = getAvailableBleepSounds();\n   118→  STATIC_RESPONSE_CACHE.profanityBleeps = {\n   119→    body: { success: true, sounds },\n   120→    etag: generateETag({ sounds })\n   121→  };\n   122→\n   123→  // Cache export formats\n   124→  const formats = getSupportedFormats();\n   125→  STATIC_RESPONSE_CACHE.exportFormats = {\n   126→    body: { success: true, formats },\n   127→    etag: generateETag({ formats })\n   128→  };\n   129→\n   130→  console.log('[SPLICE] Static response cache initialized');\n   131→}\n   132→\n   133→// Helper to send cached response with ETag\n   134→function sendCachedResponse(req, res, cacheKey) {\n   135→  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n   136→  if (!cached) {\n   137→    return res.status(500).json({ error: 'Cache not initialized' });\n   138→  }\n   139→\n   140→  // Check If-None-Match header for conditional GET\n   141→  const clientETag = req.headers['if-none-match'];\n   142→  if (clientETag === cached.etag) {\n   143→    return res.status(304).end(); // Not Modified\n   144→  }\n   145→\n   146→  // Send cached response with ETag and cache headers\n   147→  res.set('ETag', cached.etag);\n   148→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n   149→  res.json(cached.body);\n   150→}\n   151→\n   152→// =============================================================================\n   153→// Server Configuration\n   154→// =============================================================================\n   155→\n   156→const app = express();\n   157→const PORT = process.env.PORT || 3847;\n   158→\n   159→// HTTPS certificates (generated by mkcert) - only for local development\n   160→let httpsOptions = null;\n   161→if (!isProduction) {\n   162→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n   163→  const certPath = path.join(__dirname, 'localhost+1.pem');\n   164→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n   165→    httpsOptions = {\n   166→      key: fs.readFileSync(keyPath),\n   167→      cert: fs.readFileSync(certPath)\n   168→    };\n   169→  }\n   170→}\n   171→\n   172→// =============================================================================\n   173→// Security Configuration\n   174→// =============================================================================\n   175→\n   176→// CORS whitelist - restrict origins in production\n   177→const CORS_WHITELIST = [\n   178→  'http://localhost:3000',\n   179→  'http://localhost:3847',\n   180→  'https://localhost:3847',\n   181→  'http://127.0.0.1:3000',\n   182→  'http://127.0.0.1:3847',\n   183→  'https://127.0.0.1:3847',\n   184→  'https://splice.app',\n   185→  'https://www.splice.app',\n   186→  'https://splice-api-production.up.railway.app',\n   187→  'https://splice-website.vercel.app',\n   188→  // Adobe CEP/UXP panels run from file:// or bolt://\n   189→  'file://',\n   190→  'bolt://'\n   191→];\n   192→\n   193→const corsOptions = {\n   194→  origin: function (origin, callback) {\n   195→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n   196→    if (!origin) {\n   197→      return callback(null, true);\n   198→    }\n   199→    // Check if origin is in whitelist\n   200→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n   201→      return callback(null, true);\n   202→    }\n   203→    // In development, allow all origins with warning\n   204→    if (!isProduction) {\n   205→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n   206→      return callback(null, true);\n   207→    }\n   208→    // In production, reject non-whitelisted origins\n   209→    console.error(`[CORS] Blocked request from: ${origin}`);\n   210→    return callback(new Error('Not allowed by CORS'));\n   211→  },\n   212→  credentials: true,\n   213→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n   214→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n   215→};\n   216→\n   217→app.use(cors(corsOptions));\n   218→\n   219→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n   220→// This ensures rate limiting and logging use the correct client IP\n   221→if (isProduction) {\n   222→  app.set('trust proxy', 1);\n   223→}\n   224→\n   225→// IP-based rate limiting (100 requests/minute per IP)\n   226→app.use(ipRateLimit);\n   227→\n   228→// Security headers via helmet\n   229→app.use(helmet({\n   230→  contentSecurityPolicy: {\n   231→    directives: {\n   232→      defaultSrc: [\"'self'\"],\n   233→      scriptSrc: [\"'self'\"],\n   234→      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n   235→      imgSrc: [\"'self'\", 'data:', 'https:'],\n   236→      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n   237→      fontSrc: [\"'self'\"],\n   238→      objectSrc: [\"'none'\"],\n   239→      mediaSrc: [\"'self'\"],\n   240→      frameSrc: [\"'none'\"]\n   241→    }\n   242→  },\n   243→  hsts: {\n   244→    maxAge: 31536000,\n   245→    includeSubDomains: true,\n   246→    preload: true\n   247→  },\n   248→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n   249→  noSniff: true,\n   250→  xssFilter: true,\n   251→  hidePoweredBy: true\n   252→}));\n   253→\n   254→// Helper to determine tier from price ID with logging\n   255→// Supports both monthly and annual pricing\n   256→function getTierFromPriceId(priceId) {\n   257→  // Monthly prices\n   258→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   259→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   260→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   261→\n   262→  // Annual prices (same tier, just different billing period)\n   263→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n   264→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n   265→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n   266→\n   267→  // Log unknown price ID for debugging\n   268→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   269→  return 'starter';\n   270→}\n   271→\n   272→// =============================================================================\n   273→// Stripe Webhook (must be before express.json())\n   274→// =============================================================================\n   275→\n   276→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   277→  const sig = req.headers['stripe-signature'];\n   278→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   279→\n   280→  let event;\n   281→\n   282→  try {\n   283→    if (webhookSecret) {\n   284→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   285→    } else if (isProduction) {\n   286→      // SECURITY: Reject unsigned webhooks in production\n   287→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   288→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   289→    } else {\n   290→      // For local development testing only\n   291→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   292→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   293→      event = JSON.parse(bodyString);\n   294→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   295→    }\n   296→  } catch (err) {\n   297→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   298→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   299→  }\n   300→\n   301→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   302→\n   303→  // Idempotency check - skip if already processed\n   304→  if (await usageTracking.isEventProcessed(event.id)) {\n   305→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   306→    return res.json({ received: true, skipped: true });\n   307→  }\n   308→\n   309→  try {\n   310→    switch (event.type) {\n   311→      case 'customer.subscription.created':\n   312→      case 'customer.subscription.updated': {\n   313→        const subscription = event.data.object;\n   314→        const customerId = subscription.customer;\n   315→\n   316→        // Validate customerId\n   317→        if (!customerId) {\n   318→          console.error('[SPLICE] Missing customer ID in subscription event');\n   319→          return res.status(400).json({ error: 'Missing customer ID' });\n   320→        }\n   321→\n   322→        // Get tier from price ID\n   323→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   324→        const tier = getTierFromPriceId(priceId);\n   325→\n   326→        // Update user tier and reset hours\n   327→        await usageTracking.updateTier(customerId, tier);\n   328→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   329→\n   330→        // Initialize music credits for new subscriptions\n   331→        if (event.type === 'customer.subscription.created') {\n   332→          await usageTracking.resetMusicCredits(customerId, tier);\n   333→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n   334→        }\n   335→\n   336→        // Update trial end date if present\n   337→        if (subscription.trial_end) {\n   338→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n   339→        }\n   340→\n   341→        // Generate license key for new subscriptions with retry and delivery\n   342→        if (event.type === 'customer.subscription.created') {\n   343→          let licenseResult = null;\n   344→          let retryCount = 0;\n   345→          const maxRetries = 3;\n   346→\n   347→          // Retry mechanism for license key generation\n   348→          while (retryCount < maxRetries) {\n   349→            licenseResult = await licenseService.generateLicenseKey(customerId);\n   350→            if (licenseResult.success) {\n   351→              break;\n   352→            }\n   353→            retryCount++;\n   354→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n   355→            // Wait before retry (exponential backoff)\n   356→            if (retryCount < maxRetries) {\n   357→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n   358→            }\n   359→          }\n   360→\n   361→          if (licenseResult && licenseResult.success) {\n   362→            // SECURITY: Mask license key in logs\n   363→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n   364→\n   365→            // Store license key in Stripe subscription metadata as backup\n   366→            try {\n   367→              await stripe.subscriptions.update(subscription.id, {\n   368→                metadata: {\n   369→                  license_key: licenseResult.key,\n   370→                  license_generated_at: new Date().toISOString()\n   371→                }\n   372→              });\n   373→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n   374→            } catch (stripeErr) {\n   375→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n   376→            }\n   377→\n   378→            // Get customer email and send license key\n   379→            try {\n   380→              const customer = await stripe.customers.retrieve(customerId);\n   381→              if (customer.email) {\n   382→                // SECURITY: Mask sensitive data in logs\n   383→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n   384→\n   385→                // Send license key email\n   386→                try {\n   387→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n   388→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n   389→                } catch (sendErr) {\n   390→                  // Log but don't fail - license is stored in Stripe metadata as backup\n   391→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n   392→                }\n   393→\n   394→                // Store email in database for reference\n   395→                await usageTracking.updateTier(customerId, tier, customer.email);\n   396→              } else {\n   397→                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n   398→              }\n   399→            } catch (emailErr) {\n   400→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n   401→            }\n   402→          } else {\n   403→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n   404→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n   405→            console.error(`[SPLICE] ${errorMsg}`);\n   406→            return res.status(500).json({ error: errorMsg });\n   407→          }\n   408→        }\n   409→        break;\n   410→      }\n   411→\n   412→      case 'customer.subscription.deleted': {\n   413→        const subscription = event.data.object;\n   414→        const customerId = subscription.customer;\n   415→\n   416→        // Validate customerId\n   417→        if (!customerId) {\n   418→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   419→          return res.status(400).json({ error: 'Missing customer ID' });\n   420→        }\n   421→\n   422→        // Downgrade to cancelled (0 hours)\n   423→        await usageTracking.updateTier(customerId, 'cancelled');\n   424→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   425→        break;\n   426→      }\n   427→\n   428→      case 'invoice.payment_succeeded': {\n   429→        const invoice = event.data.object;\n   430→        const customerId = invoice.customer;\n   431→        const subscriptionId = invoice.subscription;\n   432→\n   433→        // Validate customerId\n   434→        if (!customerId) {\n   435→          console.error('[SPLICE] Missing customer ID in invoice event');\n   436→          return res.status(400).json({ error: 'Missing customer ID' });\n   437→        }\n   438→\n   439→        // Reset hours on successful payment (new billing period)\n   440→        let tier = 'starter';\n   441→        if (subscriptionId) {\n   442→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   443→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   444→          tier = getTierFromPriceId(priceId);\n   445→\n   446→          await usageTracking.resetHours(customerId, tier);\n   447→          await usageTracking.resetMusicCredits(customerId, tier);\n   448→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n   449→        }\n   450→\n   451→        // Check for affiliate coupon and record commission\n   452→        const discount = invoice.discount;\n   453→        if (discount && discount.coupon) {\n   454→          const couponId = discount.coupon.id;\n   455→          // Check if this is an affiliate code (like JIMMYN)\n   456→          if (referralService.AFFILIATE_CODES[couponId]) {\n   457→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n   458→            await referralService.recordAffiliateCommission(\n   459→              couponId,\n   460→              customerId,\n   461→              amountPaid,\n   462→              tier\n   463→            );\n   464→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n   465→          }\n   466→        }\n   467→        break;\n   468→      }\n   469→\n   470→      case 'invoice.payment_failed': {\n   471→        const invoice = event.data.object;\n   472→        const customerId = invoice.customer;\n   473→        const attemptCount = invoice.attempt_count || 1;\n   474→\n   475→        // Validate customerId\n   476→        if (!customerId) {\n   477→          console.error('[SPLICE] Missing customer ID in payment_failed event');\n   478→          return res.status(400).json({ error: 'Missing customer ID' });\n   479→        }\n   480→\n   481→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n   482→\n   483→        // Stripe will retry automatically per retry settings\n   484→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n   485→        // Send warning email on final attempt\n   486→        if (attemptCount >= 3) {\n   487→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n   488→          // Send warning email to customer about impending cancellation\n   489→          try {\n   490→            const customer = await stripe.customers.retrieve(customerId);\n   491→            if (customer.email) {\n   492→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n   493→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n   494→            }\n   495→          } catch (emailErr) {\n   496→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n   497→          }\n   498→        }\n   499→        break;\n   500→      }\n   501→\n   502→      case 'customer.deleted': {\n   503→        const customer = event.data.object;\n   504→        const customerId = customer.id;\n   505→\n   506→        // Validate customerId\n   507→        if (!customerId) {\n   508→          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n   509→          return res.status(400).json({ error: 'Missing customer ID' });\n   510→        }\n   511→\n   512→        // Clean up user data - downgrade to cancelled\n   513→        await usageTracking.updateTier(customerId, 'cancelled');\n   514→        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n   515→        break;\n   516→      }\n   517→\n   518→      default:\n   519→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   520→    }\n   521→\n   522→    // Record event as processed (idempotency)\n   523→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   524→\n   525→    res.json({ received: true });\n   526→  } catch (err) {\n   527→    console.error('[SPLICE] Webhook handler error:', err);\n   528→    res.status(500).json({ error: err.message });\n   529→  }\n   530→});\n   531→\n   532→// Parse JSON body for all other routes\n   533→// SECURITY: Limit JSON body size to prevent DoS attacks\n   534→app.use(express.json({ limit: '10mb' }));\n   535→\n   536→// Parse cookies for CSRF token validation\n   537→app.use(cookieParser());\n   538→\n   539→// =============================================================================\n   540→// Route Configuration Options\n   541→// =============================================================================\n   542→\n   543→const routeOptions = {\n   544→  middleware: {\n   545→    requireCredits,\n   546→    requireFeature,\n   547→    authenticateToken\n   548→  },\n   549→  services: {\n   550→    usageTracking,\n   551→    referralService,\n   552→    licenseService,\n   553→    emailService,\n   554→    stripe\n   555→  },\n   556→  authHelpers: {\n   557→    generateToken,\n   558→    generateRefreshToken,\n   559→    verifyToken,\n   560→    maskSensitiveData,\n   561→    blacklistToken\n   562→  },\n   563→  staticCache: STATIC_RESPONSE_CACHE,\n   564→  sendCachedResponse\n   565→};\n   566→\n   567→// =============================================================================\n   568→// Mount Routes\n   569→// =============================================================================\n   570→\n   571→// Health check and system endpoints (no prefix)\n   572→app.use('/', healthRoutes(routeOptions));\n   573→\n   574→// Core analysis endpoints\n   575→app.use('/', analyzeRoutes(routeOptions));\n   576→app.use('/', silencesRoutes(routeOptions));\n   577→app.use('/', detectionRoutes(routeOptions));\n   578→\n   579→// Export endpoints\n   580→app.use('/export', exportRoutes(routeOptions));\n   581→\n   582→// Multitrack/Multicam endpoints\n   583→app.use('/multitrack', multitrackRoutes(routeOptions));\n   584→\n   585→// Cut list generation\n   586→app.use('/cut-list', cutListRoutes(routeOptions));\n   587→\n   588→// Legacy XML processing endpoint (backwards compatibility)\n   589→const { processXMLFile } = require('./services/xmlProcessor');\n   590→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n   591→  const {\n   592→    xmlPath,\n   593→    silences,\n   594→    removeGaps = true,\n   595→    outputPath = null\n   596→  } = req.body;\n   597→\n   598→  if (!xmlPath) {\n   599→    return res.status(400).json({ error: 'xmlPath is required' });\n   600→  }\n   601→\n   602→  if (!silences || !Array.isArray(silences)) {\n   603→    return res.status(400).json({ error: 'silences array is required' });\n   604→  }\n   605→\n   606→  if (!fs.existsSync(xmlPath)) {\n   607→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n   608→  }\n   609→\n   610→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n   611→\n   612→  try {\n   613→    const result = await processXMLFile(xmlPath, silences, {\n   614→      outputPath,\n   615→      removeGaps\n   616→    });\n   617→\n   618→    res.json({\n   619→      success: true,\n   620→      inputPath: xmlPath,\n   621→      outputPath: result.outputPath,\n   622→      stats: result.stats\n   623→    });\n   624→  } catch (err) {\n   625→    console.error('[SPLICE] XML processing error:', err);\n   626→    res.status(500).json({ error: err.message });\n   627→  }\n   628→});\n   629→\n   630→// Auto zoom endpoints\n   631→app.use('/zoom', zoomRoutes(routeOptions));\n   632→\n   633→// Chapter detection endpoints\n   634→app.use('/chapters', chaptersRoutes(routeOptions));\n   635→\n   636→// YouTube content generation\n   637→app.use('/youtube', youtubeRoutes(routeOptions));\n   638→\n   639→// Animated captions endpoints\n   640→app.use('/captions', captionsRoutes(routeOptions));\n   641→\n   642→// Text-based editing endpoints\n   643→app.use('/text-edit', textEditRoutes(routeOptions));\n   644→\n   645→// Social reframe endpoints\n   646→app.use('/reframe', reframeRoutes(routeOptions));\n   647→app.use('/faces', reframeRoutes.facesRouter(routeOptions));\n   648→\n   649→// Batch processing endpoints\n   650→app.use('/batch', batchRoutes(routeOptions));\n   651→\n   652→// Authentication endpoints\n   653→app.use('/auth', authRoutes(routeOptions));\n   654→\n   655→// Billing and credits endpoints\n   656→app.use('/', billingRoutes(routeOptions));\n   657→\n   658→// Referral system endpoints\n   659→app.use('/referral', referralRoutes(routeOptions));\n   660→\n   661→// License key endpoints\n   662→app.use('/license', licenseRoutes(routeOptions));\n   663→\n   664→// AI Music generation endpoints\n   665→app.use('/music', musicRoutes(routeOptions));\n   666→\n   667→// =============================================================================\n   668→// Start Server\n   669→// =============================================================================\n   670→\n   671→// Track active server for graceful shutdown\n   672→let server = null;\n   673→\n   674→// Initialize database and start server\n   675→async function startServer() {\n   676→  try {\n   677→    await usageTracking.initDatabase();\n   678→    await referralService.initReferralTables();\n   679→    await licenseService.initLicenseTables();\n   680→    console.log('[SPLICE] Database initialized');\n   681→\n   682→    // PERF-FIX: Initialize static response cache at startup\n   683→    initializeStaticCache();\n   684→\n   685→    if (isProduction || !httpsOptions) {\n   686→      // Production: Railway provides TLS termination, use HTTP\n   687→      server = http.createServer(app).listen(PORT, () => {\n   688→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n   689→      });\n   690→    } else {\n   691→      // Development: Use HTTPS with local certificates\n   692→      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n   693→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n   694→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n   695→      });\n   696→    }\n   697→  } catch (err) {\n   698→    console.error('[SPLICE] Failed to start server:', err);\n   699→    process.exit(1);\n   700→  }\n   701→}\n   702→\n   703→// =============================================================================\n   704→// Graceful Shutdown\n   705→// =============================================================================\n   706→\n   707→async function gracefulShutdown(signal) {\n   708→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n   709→\n   710→  // Stop accepting new connections\n   711→  if (server) {\n   712→    server.close(() => {\n   713→      console.log('[SPLICE] HTTP server closed');\n   714→    });\n   715→  }\n   716→\n   717→  // Close database pool\n   718→  try {\n   719→    await usageTracking.closePool();\n   720→    console.log('[SPLICE] Database pool closed');\n   721→  } catch (err) {\n   722→    console.error('[SPLICE] Error closing database pool:', err.message);\n   723→  }\n   724→\n   725→  // Give ongoing requests time to complete (max 10 seconds)\n   726→  setTimeout(() => {\n   727→    console.log('[SPLICE] Graceful shutdown complete');\n   728→    process.exit(0);\n   729→  }, 10000);\n   730→}\n   731→\n   732→// Handle termination signals\n   733→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n   734→process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n   735→\n   736→// Handle uncaught exceptions\n   737→process.on('uncaughtException', (err) => {\n   738→  console.error('[SPLICE] Uncaught exception:', err);\n   739→  gracefulShutdown('uncaughtException');\n   740→});\n   741→\n   742→process.on('unhandledRejection', (reason, promise) => {\n   743→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n   744→});\n   745→\n   746→startServer();\n   747→\n\n</system-reminder>\n"}]},"uuid":"d7ae4817-c6b3-42dc-9776-b4c2b138329e","timestamp":"2025-12-30T02:09:41.009Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"/**\n * SPLICE Backend Server\n *\n * Main entry point for the SPLICE backend API.\n * Orchestrates the audio analysis pipeline.\n *\n * Slices:\n * - Slice 4: Transcription (services/transcription.js)\n * - Slice 5: Take Detection (services/takeDetection.js)\n *\n * Architecture: Modular routes (see routes/ directory)\n */\n\n\nrequire('dotenv').config();\n\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst https = require('https');\nconst http = require('http');\nconst path = require('path');\nconst crypto = require('crypto');\n\n// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// Import services\nconst usageTracking = require('./services/usageTracking');\nconst { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\nconst { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\nconst referralService = require('./services/referralService');\nconst licenseService = require('./services/licenseService');\nconst emailService = require('./services/emailService');\nconst { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\nconst { getSupportedFormats } = require('./services/captionExporter');\n\n// Import route modules\nconst healthRoutes = require('./routes/health');\nconst analyzeRoutes = require('./routes/analyze');\nconst silencesRoutes = require('./routes/silences');\nconst detectionRoutes = require('./routes/detection');\nconst exportRoutes = require('./routes/export');\nconst multitrackRoutes = require('./routes/multitrack');\nconst cutListRoutes = require('./routes/cutList');\nconst zoomRoutes = require('./routes/zoom');\nconst chaptersRoutes = require('./routes/chapters');\nconst youtubeRoutes = require('./routes/youtube');\nconst captionsRoutes = require('./routes/captions');\nconst textEditRoutes = require('./routes/textEdit');\nconst reframeRoutes = require('./routes/reframe');\nconst batchRoutes = require('./routes/batch');\nconst authRoutes = require('./routes/auth');\nconst billingRoutes = require('./routes/billing');\nconst referralRoutes = require('./routes/referral');\nconst licenseRoutes = require('./routes/license');\nconst musicRoutes = require('./routes/music');\n\n// Stripe for webhooks\nconst Stripe = require('stripe');\n\n// Validate STRIPE_SECRET_KEY in production - exit if missing\nif (isProduction && !process.env.STRIPE_SECRET_KEY) {\n  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');\n  process.exit(1);\n}\n\n// Validate JWT_SECRET in production - exit if using default\nif (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {\n  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');\n  process.exit(1);\n}\n\n// Validate DATABASE_URL in production\nif (isProduction && !process.env.DATABASE_URL) {\n  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');\n  process.exit(1);\n}\n\n// Validate OPENAI_API_KEY in production\nif (isProduction && !process.env.OPENAI_API_KEY) {\n  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');\n  process.exit(1);\n}\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n\n// =============================================================================\n// PERF-FIX: Static Response Cache\n// Cache static endpoint responses at startup to avoid repeated computation\n// =============================================================================\n\n// Generate ETag from content\nfunction generateETag(content) {\n  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n}\n\n// Static response cache - populated at startup\nconst STATIC_RESPONSE_CACHE = {\n  profanityLanguages: null,\n  profanityBleeps: null,\n  exportFormats: null\n};\n\n// Initialize cache at startup (called after server starts)\nfunction initializeStaticCache() {\n  // Cache profanity languages\n  const languages = getSupportedLanguages();\n  STATIC_RESPONSE_CACHE.profanityLanguages = {\n    body: { success: true, languages },\n    etag: generateETag({ languages })\n  };\n\n  // Cache profanity bleeps\n  const sounds = getAvailableBleepSounds();\n  STATIC_RESPONSE_CACHE.profanityBleeps = {\n    body: { success: true, sounds },\n    etag: generateETag({ sounds })\n  };\n\n  // Cache export formats\n  const formats = getSupportedFormats();\n  STATIC_RESPONSE_CACHE.exportFormats = {\n    body: { success: true, formats },\n    etag: generateETag({ formats })\n  };\n\n  console.log('[SPLICE] Static response cache initialized');\n}\n\n// Helper to send cached response with ETag\nfunction sendCachedResponse(req, res, cacheKey) {\n  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n  if (!cached) {\n    return res.status(500).json({ error: 'Cache not initialized' });\n  }\n\n  // Check If-None-Match header for conditional GET\n  const clientETag = req.headers['if-none-match'];\n  if (clientETag === cached.etag) {\n    return res.status(304).end(); // Not Modified\n  }\n\n  // Send cached response with ETag and cache headers\n  res.set('ETag', cached.etag);\n  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n  res.json(cached.body);\n}\n\n// =============================================================================\n// Server Configuration\n// =============================================================================\n\nconst app = express();\nconst PORT = process.env.PORT || 3847;\n\n// HTTPS certificates (generated by mkcert) - only for local development\nlet httpsOptions = null;\nif (!isProduction) {\n  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n  const certPath = path.join(__dirname, 'localhost+1.pem');\n  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n    httpsOptions = {\n      key: fs.readFileSync(keyPath),\n      cert: fs.readFileSync(certPath)\n    };\n  }\n}\n\n// =============================================================================\n// Security Configuration\n// =============================================================================\n\n// CORS whitelist - restrict origins in production\nconst CORS_WHITELIST = [\n  'http://localhost:3000',\n  'http://localhost:3847',\n  'https://localhost:3847',\n  'http://127.0.0.1:3000',\n  'http://127.0.0.1:3847',\n  'https://127.0.0.1:3847',\n  'https://splice.app',\n  'https://www.splice.app',\n  'https://splice-api-production.up.railway.app',\n  'https://splice-website.vercel.app',\n  // Adobe CEP/UXP panels run from file:// or bolt://\n  'file://',\n  'bolt://'\n];\n\nconst corsOptions = {\n  origin: function (origin, callback) {\n    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n    if (!origin) {\n      return callback(null, true);\n    }\n    // Check if origin is in whitelist\n    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n      return callback(null, true);\n    }\n    // In development, allow all origins with warning\n    if (!isProduction) {\n      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n      return callback(null, true);\n    }\n    // In production, reject non-whitelisted origins\n    console.error(`[CORS] Blocked request from: ${origin}`);\n    return callback(new Error('Not allowed by CORS'));\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n};\n\napp.use(cors(corsOptions));\n\n// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n// This ensures rate limiting and logging use the correct client IP\nif (isProduction) {\n  app.set('trust proxy', 1);\n}\n\n// IP-based rate limiting (100 requests/minute per IP)\napp.use(ipRateLimit);\n\n// Security headers via helmet\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n  noSniff: true,\n  xssFilter: true,\n  hidePoweredBy: true\n}));\n\n// Helper to determine tier from price ID with logging\n// Supports both monthly and annual pricing\nfunction getTierFromPriceId(priceId) {\n  // Monthly prices\n  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n\n  // Annual prices (same tier, just different billing period)\n  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n\n  // Log unknown price ID for debugging\n  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n  return 'starter';\n}\n\n// =============================================================================\n// Stripe Webhook (must be before express.json())\n// =============================================================================\n\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n  let event;\n\n  try {\n    if (webhookSecret) {\n      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } else if (isProduction) {\n      // SECURITY: Reject unsigned webhooks in production\n      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n    } else {\n      // For local development testing only\n      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n      event = JSON.parse(bodyString);\n      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n    return res.status(400).json({ error: 'Webhook signature verification failed' });\n  }\n\n  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n\n  // Idempotency check - skip if already processed\n  if (await usageTracking.isEventProcessed(event.id)) {\n    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n    return res.json({ received: true, skipped: true });\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Get tier from price ID\n        const priceId = subscription.items?.data?.[0]?.price?.id;\n        const tier = getTierFromPriceId(priceId);\n\n        // Update user tier and reset hours\n        await usageTracking.updateTier(customerId, tier);\n        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n\n        // Initialize music credits for new subscriptions\n        if (event.type === 'customer.subscription.created') {\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Update trial end date if present\n        if (subscription.trial_end) {\n          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n        }\n\n        // Generate license key for new subscriptions with retry and delivery\n        if (event.type === 'customer.subscription.created') {\n          let licenseResult = null;\n          let retryCount = 0;\n          const maxRetries = 3;\n\n          // Retry mechanism for license key generation\n          while (retryCount < maxRetries) {\n            licenseResult = await licenseService.generateLicenseKey(customerId);\n            if (licenseResult.success) {\n              break;\n            }\n            retryCount++;\n            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n            // Wait before retry (exponential backoff)\n            if (retryCount < maxRetries) {\n              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n            }\n          }\n\n          if (licenseResult && licenseResult.success) {\n            // SECURITY: Mask license key in logs\n            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n\n            // Store license key in Stripe subscription metadata as backup\n            try {\n              await stripe.subscriptions.update(subscription.id, {\n                metadata: {\n                  license_key: licenseResult.key,\n                  license_generated_at: new Date().toISOString()\n                }\n              });\n              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n            } catch (stripeErr) {\n              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n            }\n\n            // Get customer email and send license key\n            try {\n              const customer = await stripe.customers.retrieve(customerId);\n              if (customer.email) {\n                // SECURITY: Mask sensitive data in logs\n                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n\n                // Send license key email\n                try {\n                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n                } catch (sendErr) {\n                  // Log but don't fail - license is stored in Stripe metadata as backup\n                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n                }\n\n                // Store email in database for reference\n                await usageTracking.updateTier(customerId, tier, customer.email);\n              } else {\n                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n              }\n            } catch (emailErr) {\n              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n            }\n          } else {\n            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n            console.error(`[SPLICE] ${errorMsg}`);\n            return res.status(500).json({ error: errorMsg });\n          }\n        }\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Downgrade to cancelled (0 hours)\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const subscriptionId = invoice.subscription;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in invoice event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Reset hours on successful payment (new billing period)\n        let tier = 'starter';\n        if (subscriptionId) {\n          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n          const priceId = subscription.items?.data?.[0]?.price?.id;\n          tier = getTierFromPriceId(priceId);\n\n          await usageTracking.resetHours(customerId, tier);\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Check for affiliate coupon and record commission\n        const discount = invoice.discount;\n        if (discount && discount.coupon) {\n          const couponId = discount.coupon.id;\n          // Check if this is an affiliate code (like JIMMYN)\n          if (referralService.AFFILIATE_CODES[couponId]) {\n            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n            await referralService.recordAffiliateCommission(\n              couponId,\n              customerId,\n              amountPaid,\n              tier\n            );\n            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n          }\n        }\n        break;\n      }\n\n      case 'invoice.payment_failed': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const attemptCount = invoice.attempt_count || 1;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in payment_failed event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n\n        // Stripe will retry automatically per retry settings\n        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n        // Send warning email on final attempt\n        if (attemptCount >= 3) {\n          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n          // Send warning email to customer about impending cancellation\n          try {\n            const customer = await stripe.customers.retrieve(customerId);\n            if (customer.email) {\n              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n            }\n          } catch (emailErr) {\n            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n          }\n        }\n        break;\n      }\n\n      case 'customer.deleted': {\n        const customer = event.data.object;\n        const customerId = customer.id;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Clean up user data - downgrade to cancelled\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n        break;\n      }\n\n      default:\n        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n    }\n\n    // Record event as processed (idempotency)\n    await usageTracking.recordWebhookEvent(event.id, event.type);\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error('[SPLICE] Webhook handler error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Parse JSON body for all other routes\n// SECURITY: Limit JSON body size to prevent DoS attacks\napp.use(express.json({ limit: '10mb' }));\n\n// Parse cookies for CSRF token validation\napp.use(cookieParser());\n\n// =============================================================================\n// Route Configuration Options\n// =============================================================================\n\nconst routeOptions = {\n  middleware: {\n    requireCredits,\n    requireFeature,\n    authenticateToken\n  },\n  services: {\n    usageTracking,\n    referralService,\n    licenseService,\n    emailService,\n    stripe\n  },\n  authHelpers: {\n    generateToken,\n    generateRefreshToken,\n    verifyToken,\n    maskSensitiveData,\n    blacklistToken\n  },\n  staticCache: STATIC_RESPONSE_CACHE,\n  sendCachedResponse\n};\n\n// =============================================================================\n// Mount Routes\n// =============================================================================\n\n// Health check and system endpoints (no prefix)\napp.use('/', healthRoutes(routeOptions));\n\n// Core analysis endpoints\napp.use('/', analyzeRoutes(routeOptions));\napp.use('/', silencesRoutes(routeOptions));\napp.use('/', detectionRoutes(routeOptions));\n\n// Export endpoints\napp.use('/export', exportRoutes(routeOptions));\n\n// Multitrack/Multicam endpoints\napp.use('/multitrack', multitrackRoutes(routeOptions));\n\n// Cut list generation\napp.use('/cut-list', cutListRoutes(routeOptions));\n\n// Legacy XML processing endpoint (backwards compatibility)\nconst { processXMLFile } = require('./services/xmlProcessor');\napp.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n  const {\n    xmlPath,\n    silences,\n    removeGaps = true,\n    outputPath = null\n  } = req.body;\n\n  if (!xmlPath) {\n    return res.status(400).json({ error: 'xmlPath is required' });\n  }\n\n  if (!silences || !Array.isArray(silences)) {\n    return res.status(400).json({ error: 'silences array is required' });\n  }\n\n  if (!fs.existsSync(xmlPath)) {\n    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n  }\n\n  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n\n  try {\n    const result = await processXMLFile(xmlPath, silences, {\n      outputPath,\n      removeGaps\n    });\n\n    res.json({\n      success: true,\n      inputPath: xmlPath,\n      outputPath: result.outputPath,\n      stats: result.stats\n    });\n  } catch (err) {\n    console.error('[SPLICE] XML processing error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Auto zoom endpoints\napp.use('/zoom', zoomRoutes(routeOptions));\n\n// Chapter detection endpoints\napp.use('/chapters', chaptersRoutes(routeOptions));\n\n// YouTube content generation\napp.use('/youtube', youtubeRoutes(routeOptions));\n\n// Animated captions endpoints\napp.use('/captions', captionsRoutes(routeOptions));\n\n// Text-based editing endpoints\napp.use('/text-edit', textEditRoutes(routeOptions));\n\n// Social reframe endpoints\napp.use('/reframe', reframeRoutes(routeOptions));\napp.use('/faces', reframeRoutes.facesRouter(routeOptions));\n\n// Batch processing endpoints\napp.use('/batch', batchRoutes(routeOptions));\n\n// Authentication endpoints\napp.use('/auth', authRoutes(routeOptions));\n\n// Billing and credits endpoints\napp.use('/', billingRoutes(routeOptions));\n\n// Referral system endpoints\napp.use('/referral', referralRoutes(routeOptions));\n\n// License key endpoints\napp.use('/license', licenseRoutes(routeOptions));\n\n// AI Music generation endpoints\napp.use('/music', musicRoutes(routeOptions));\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\n// Track active server for graceful shutdown\nlet server = null;\n\n// Initialize database and start server\nasync function startServer() {\n  try {\n    await usageTracking.initDatabase();\n    await referralService.initReferralTables();\n    await licenseService.initLicenseTables();\n    console.log('[SPLICE] Database initialized');\n\n    // PERF-FIX: Initialize static response cache at startup\n    initializeStaticCache();\n\n    if (isProduction || !httpsOptions) {\n      // Production: Railway provides TLS termination, use HTTP\n      server = http.createServer(app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n      });\n    } else {\n      // Development: Use HTTPS with local certificates\n      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n      });\n    }\n  } catch (err) {\n    console.error('[SPLICE] Failed to start server:', err);\n    process.exit(1);\n  }\n}\n\n// =============================================================================\n// Graceful Shutdown\n// =============================================================================\n\nasync function gracefulShutdown(signal) {\n  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n\n  // Stop accepting new connections\n  if (server) {\n    server.close(() => {\n      console.log('[SPLICE] HTTP server closed');\n    });\n  }\n\n  // Close database pool\n  try {\n    await usageTracking.closePool();\n    console.log('[SPLICE] Database pool closed');\n  } catch (err) {\n    console.error('[SPLICE] Error closing database pool:', err.message);\n  }\n\n  // Give ongoing requests time to complete (max 10 seconds)\n  setTimeout(() => {\n    console.log('[SPLICE] Graceful shutdown complete');\n    process.exit(0);\n  }, 10000);\n}\n\n// Handle termination signals\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (err) => {\n  console.error('[SPLICE] Uncaught exception:', err);\n  gracefulShutdown('uncaughtException');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n});\n\nstartServer();\n","numLines":747,"startLine":1,"totalLines":747}}}
{"parentUuid":"d7ae4817-c6b3-42dc-9776-b4c2b138329e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BhkatDSE4sb7a3tGyNqpsa","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the frontend API routes, services, and additional backend components:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16738,"cache_creation_input_tokens":10000,"cache_read_input_tokens":21624,"cache_creation":{"ephemeral_5m_input_tokens":10000,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWc4KtnMJQNWY85rZeoEp","type":"assistant","uuid":"0603dd2c-9068-4298-bfbe-953a29d4b46d","timestamp":"2025-12-30T02:09:47.355Z"}
{"parentUuid":"0603dd2c-9068-4298-bfbe-953a29d4b46d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BhkatDSE4sb7a3tGyNqpsa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PSpGaosLDTak247dCGvx9j","name":"Glob","input":{"pattern":"/Users/imorgado/SPLICE/splice-website/src/app/api/**/*.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16738,"cache_creation_input_tokens":10000,"cache_read_input_tokens":21624,"cache_creation":{"ephemeral_5m_input_tokens":10000,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWc4KtnMJQNWY85rZeoEp","type":"assistant","uuid":"e5b5de55-5eff-487e-90f4-3ef8f519e608","timestamp":"2025-12-30T02:09:48.495Z"}
{"parentUuid":"e5b5de55-5eff-487e-90f4-3ef8f519e608","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BhkatDSE4sb7a3tGyNqpsa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016SFSYHeC9vJcS9aAD9pMtj","name":"Glob","input":{"pattern":"/Users/imorgado/SPLICE/splice-backend/services/*.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16738,"cache_creation_input_tokens":10000,"cache_read_input_tokens":21624,"cache_creation":{"ephemeral_5m_input_tokens":10000,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWc4KtnMJQNWY85rZeoEp","type":"assistant","uuid":"aac7d9f2-0895-4caf-9593-3ae28b94ea17","timestamp":"2025-12-30T02:09:49.170Z"}
{"parentUuid":"aac7d9f2-0895-4caf-9593-3ae28b94ea17","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BhkatDSE4sb7a3tGyNqpsa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013Sn5tJoV3PVeBoqCPBBMZs","name":"Glob","input":{"pattern":"/Users/imorgado/SPLICE/splice-backend/routes/*.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16738,"cache_creation_input_tokens":10000,"cache_read_input_tokens":21624,"cache_creation":{"ephemeral_5m_input_tokens":10000,"ephemeral_1h_input_tokens":0},"output_tokens":192,"service_tier":"standard"}},"requestId":"req_011CWc4KtnMJQNWY85rZeoEp","type":"assistant","uuid":"da5a0dc7-fea3-4a90-bdf0-f23c30e1a12f","timestamp":"2025-12-30T02:09:49.674Z"}
{"parentUuid":"da5a0dc7-fea3-4a90-bdf0-f23c30e1a12f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013Sn5tJoV3PVeBoqCPBBMZs","type":"tool_result","content":"/Users/imorgado/SPLICE/splice-backend/routes/index.js\n/Users/imorgado/SPLICE/splice-backend/routes/detection.js\n/Users/imorgado/SPLICE/splice-backend/routes/zoom.js\n/Users/imorgado/SPLICE/splice-backend/routes/chapters.js\n/Users/imorgado/SPLICE/splice-backend/routes/youtube.js\n/Users/imorgado/SPLICE/splice-backend/routes/captions.js\n/Users/imorgado/SPLICE/splice-backend/routes/referral.js\n/Users/imorgado/SPLICE/splice-backend/routes/cutList.js\n/Users/imorgado/SPLICE/splice-backend/routes/export.js\n/Users/imorgado/SPLICE/splice-backend/routes/health.js\n/Users/imorgado/SPLICE/splice-backend/routes/license.js\n/Users/imorgado/SPLICE/splice-backend/routes/music.js\n/Users/imorgado/SPLICE/splice-backend/routes/analyze.js\n/Users/imorgado/SPLICE/splice-backend/routes/batch.js\n/Users/imorgado/SPLICE/splice-backend/routes/silences.js\n/Users/imorgado/SPLICE/splice-backend/routes/reframe.js\n/Users/imorgado/SPLICE/splice-backend/routes/textEdit.js\n/Users/imorgado/SPLICE/splice-backend/routes/multitrack.js\n/Users/imorgado/SPLICE/splice-backend/routes/auth.js\n/Users/imorgado/SPLICE/splice-backend/routes/billing.js"}]},"uuid":"c4180fc0-fb51-47d9-bdc3-7e1d99e9dc32","timestamp":"2025-12-30T02:09:49.725Z","toolUseResult":{"filenames":["/Users/imorgado/SPLICE/splice-backend/routes/index.js","/Users/imorgado/SPLICE/splice-backend/routes/detection.js","/Users/imorgado/SPLICE/splice-backend/routes/zoom.js","/Users/imorgado/SPLICE/splice-backend/routes/chapters.js","/Users/imorgado/SPLICE/splice-backend/routes/youtube.js","/Users/imorgado/SPLICE/splice-backend/routes/captions.js","/Users/imorgado/SPLICE/splice-backend/routes/referral.js","/Users/imorgado/SPLICE/splice-backend/routes/cutList.js","/Users/imorgado/SPLICE/splice-backend/routes/export.js","/Users/imorgado/SPLICE/splice-backend/routes/health.js","/Users/imorgado/SPLICE/splice-backend/routes/license.js","/Users/imorgado/SPLICE/splice-backend/routes/music.js","/Users/imorgado/SPLICE/splice-backend/routes/analyze.js","/Users/imorgado/SPLICE/splice-backend/routes/batch.js","/Users/imorgado/SPLICE/splice-backend/routes/silences.js","/Users/imorgado/SPLICE/splice-backend/routes/reframe.js","/Users/imorgado/SPLICE/splice-backend/routes/textEdit.js","/Users/imorgado/SPLICE/splice-backend/routes/multitrack.js","/Users/imorgado/SPLICE/splice-backend/routes/auth.js","/Users/imorgado/SPLICE/splice-backend/routes/billing.js"],"durationMs":11,"numFiles":20,"truncated":false}}
{"parentUuid":"c4180fc0-fb51-47d9-bdc3-7e1d99e9dc32","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PSpGaosLDTak247dCGvx9j","type":"tool_result","content":"/Users/imorgado/SPLICE/splice-website/src/app/api/webhook/route.ts\n/Users/imorgado/SPLICE/splice-website/src/app/api/auth/logout/route.ts\n/Users/imorgado/SPLICE/splice-website/src/app/api/auth/me/route.ts\n/Users/imorgado/SPLICE/splice-website/src/app/api/auth/refresh/route.ts\n/Users/imorgado/SPLICE/splice-website/src/app/api/contact/route.ts\n/Users/imorgado/SPLICE/splice-website/src/app/api/auth/login/route.ts\n/Users/imorgado/SPLICE/splice-website/src/app/api/checkout/route.ts"}]},"uuid":"a9c58da8-12d1-4086-80b3-3a18bd4d58b9","timestamp":"2025-12-30T02:09:49.735Z","toolUseResult":{"filenames":["/Users/imorgado/SPLICE/splice-website/src/app/api/webhook/route.ts","/Users/imorgado/SPLICE/splice-website/src/app/api/auth/logout/route.ts","/Users/imorgado/SPLICE/splice-website/src/app/api/auth/me/route.ts","/Users/imorgado/SPLICE/splice-website/src/app/api/auth/refresh/route.ts","/Users/imorgado/SPLICE/splice-website/src/app/api/contact/route.ts","/Users/imorgado/SPLICE/splice-website/src/app/api/auth/login/route.ts","/Users/imorgado/SPLICE/splice-website/src/app/api/checkout/route.ts"],"durationMs":21,"numFiles":7,"truncated":false}}
{"parentUuid":"a9c58da8-12d1-4086-80b3-3a18bd4d58b9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016SFSYHeC9vJcS9aAD9pMtj","type":"tool_result","content":"/Users/imorgado/SPLICE/splice-backend/services/silenceDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/ffprobeSilence.js\n/Users/imorgado/SPLICE/splice-backend/services/cutListGenerator.js\n/Users/imorgado/SPLICE/splice-backend/services/vocalIsolation.js\n/Users/imorgado/SPLICE/splice-backend/services/takeDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/securityUtils.js\n/Users/imorgado/SPLICE/splice-backend/services/musicQueue.js\n/Users/imorgado/SPLICE/splice-backend/services/r2Storage.js\n/Users/imorgado/SPLICE/splice-backend/services/repetitionDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/rmsSilenceDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/sceneAnalysis.js\n/Users/imorgado/SPLICE/splice-backend/services/multitrackAnalysis.js\n/Users/imorgado/SPLICE/splice-backend/services/profanityDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/socialReframe.js\n/Users/imorgado/SPLICE/splice-backend/services/transcription.js\n/Users/imorgado/SPLICE/splice-backend/services/youtubeGenerator.js\n/Users/imorgado/SPLICE/splice-backend/services/zoomGenerator.js\n/Users/imorgado/SPLICE/splice-backend/services/animatedCaptions.js\n/Users/imorgado/SPLICE/splice-backend/services/chapterDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/faceDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/textBasedEditing.js\n/Users/imorgado/SPLICE/splice-backend/services/stripeUsageReporting.js\n/Users/imorgado/SPLICE/splice-backend/services/songIdentification.js\n/Users/imorgado/SPLICE/splice-backend/services/musicAlignment.js\n/Users/imorgado/SPLICE/splice-backend/services/musicTimeline.js\n/Users/imorgado/SPLICE/splice-backend/services/musicGeneration.js\n/Users/imorgado/SPLICE/splice-backend/services/xmlProcessor.js\n/Users/imorgado/SPLICE/splice-backend/services/captionExporter.js\n/Users/imorgado/SPLICE/splice-backend/services/licenseService.js\n/Users/imorgado/SPLICE/splice-backend/services/referralService.js\n/Users/imorgado/SPLICE/splice-backend/services/redisClient.js\n/Users/imorgado/SPLICE/splice-backend/services/emailService.js\n/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js"}]},"uuid":"c5d4e366-ccc0-46e2-9129-d947124795d4","timestamp":"2025-12-30T02:09:49.731Z","toolUseResult":{"filenames":["/Users/imorgado/SPLICE/splice-backend/services/silenceDetection.js","/Users/imorgado/SPLICE/splice-backend/services/ffprobeSilence.js","/Users/imorgado/SPLICE/splice-backend/services/cutListGenerator.js","/Users/imorgado/SPLICE/splice-backend/services/vocalIsolation.js","/Users/imorgado/SPLICE/splice-backend/services/takeDetection.js","/Users/imorgado/SPLICE/splice-backend/services/securityUtils.js","/Users/imorgado/SPLICE/splice-backend/services/musicQueue.js","/Users/imorgado/SPLICE/splice-backend/services/r2Storage.js","/Users/imorgado/SPLICE/splice-backend/services/repetitionDetection.js","/Users/imorgado/SPLICE/splice-backend/services/rmsSilenceDetection.js","/Users/imorgado/SPLICE/splice-backend/services/sceneAnalysis.js","/Users/imorgado/SPLICE/splice-backend/services/multitrackAnalysis.js","/Users/imorgado/SPLICE/splice-backend/services/profanityDetection.js","/Users/imorgado/SPLICE/splice-backend/services/socialReframe.js","/Users/imorgado/SPLICE/splice-backend/services/transcription.js","/Users/imorgado/SPLICE/splice-backend/services/youtubeGenerator.js","/Users/imorgado/SPLICE/splice-backend/services/zoomGenerator.js","/Users/imorgado/SPLICE/splice-backend/services/animatedCaptions.js","/Users/imorgado/SPLICE/splice-backend/services/chapterDetection.js","/Users/imorgado/SPLICE/splice-backend/services/faceDetection.js","/Users/imorgado/SPLICE/splice-backend/services/textBasedEditing.js","/Users/imorgado/SPLICE/splice-backend/services/stripeUsageReporting.js","/Users/imorgado/SPLICE/splice-backend/services/songIdentification.js","/Users/imorgado/SPLICE/splice-backend/services/musicAlignment.js","/Users/imorgado/SPLICE/splice-backend/services/musicTimeline.js","/Users/imorgado/SPLICE/splice-backend/services/musicGeneration.js","/Users/imorgado/SPLICE/splice-backend/services/xmlProcessor.js","/Users/imorgado/SPLICE/splice-backend/services/captionExporter.js","/Users/imorgado/SPLICE/splice-backend/services/licenseService.js","/Users/imorgado/SPLICE/splice-backend/services/referralService.js","/Users/imorgado/SPLICE/splice-backend/services/redisClient.js","/Users/imorgado/SPLICE/splice-backend/services/emailService.js","/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js"],"durationMs":16,"numFiles":33,"truncated":false}}
{"parentUuid":"c5d4e366-ccc0-46e2-9129-d947124795d4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_014cc9FRnBeuCvrdpRGPk2o3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RrVkSZ2KaooPVuBnkUZNWD","name":"TodoWrite","input":{"todos":[{"content":"Check backend API routes for middleware and error handling","status":"in_progress","activeForm":"Checking backend API routes for middleware and error handling"},{"content":"Verify frontend-backend API integration","status":"pending","activeForm":"Verifying frontend-backend API integration"},{"content":"Check service dependencies and imports","status":"pending","activeForm":"Checking service dependencies and imports"},{"content":"Validate database schema in usageTracking.js","status":"pending","activeForm":"Validating database schema in usageTracking.js"},{"content":"Verify plugin features integration chain","status":"pending","activeForm":"Verifying plugin features integration chain"},{"content":"Complete security checklist","status":"pending","activeForm":"Completing security checklist"},{"content":"Check production configuration","status":"pending","activeForm":"Checking production configuration"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":435,"cache_creation_input_tokens":18022,"cache_read_input_tokens":31624,"cache_creation":{"ephemeral_5m_input_tokens":18022,"ephemeral_1h_input_tokens":0},"output_tokens":286,"service_tier":"standard"}},"requestId":"req_011CWc4LY4SSo4fnkrn8vBZh","type":"assistant","uuid":"fd4f1bc6-a1fc-4366-8dd5-ca51de889eba","timestamp":"2025-12-30T02:09:57.139Z"}
{"parentUuid":"fd4f1bc6-a1fc-4366-8dd5-ca51de889eba","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RrVkSZ2KaooPVuBnkUZNWD","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"7eed0503-7326-4def-9207-1dd7e3c571d4","timestamp":"2025-12-30T02:09:57.173Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Check backend API routes for middleware and error handling","status":"in_progress","activeForm":"Checking backend API routes for middleware and error handling"},{"content":"Verify frontend-backend API integration","status":"pending","activeForm":"Verifying frontend-backend API integration"},{"content":"Check service dependencies and imports","status":"pending","activeForm":"Checking service dependencies and imports"},{"content":"Validate database schema in usageTracking.js","status":"pending","activeForm":"Validating database schema in usageTracking.js"},{"content":"Verify plugin features integration chain","status":"pending","activeForm":"Verifying plugin features integration chain"},{"content":"Complete security checklist","status":"pending","activeForm":"Completing security checklist"},{"content":"Check production configuration","status":"pending","activeForm":"Checking production configuration"}]}}
{"parentUuid":"7eed0503-7326-4def-9207-1dd7e3c571d4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SzHu9FSrpdKbmGHEWsGpYH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019CDuEAm1dmvpxw2NK963Tx","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":754,"cache_read_input_tokens":49646,"cache_creation":{"ephemeral_5m_input_tokens":754,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWc4M5zZt9Hq2QPHc1UFE","type":"assistant","uuid":"56622cae-e570-4835-bc1b-28eaa0028489","timestamp":"2025-12-30T02:10:01.688Z"}
{"parentUuid":"56622cae-e570-4835-bc1b-28eaa0028489","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SzHu9FSrpdKbmGHEWsGpYH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017ZDBYikTBU4jRh8iu4G7h4","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":754,"cache_read_input_tokens":49646,"cache_creation":{"ephemeral_5m_input_tokens":754,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWc4M5zZt9Hq2QPHc1UFE","type":"assistant","uuid":"7057d052-1e04-44b8-bc63-d0becff55ac7","timestamp":"2025-12-30T02:10:02.303Z"}
{"parentUuid":"7057d052-1e04-44b8-bc63-d0becff55ac7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SzHu9FSrpdKbmGHEWsGpYH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gx14kJH2LNTkdgp545MmSZ","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/login/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":754,"cache_read_input_tokens":49646,"cache_creation":{"ephemeral_5m_input_tokens":754,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWc4M5zZt9Hq2QPHc1UFE","type":"assistant","uuid":"65283e22-752a-4de4-b432-dad9da1d2f06","timestamp":"2025-12-30T02:10:03.202Z"}
{"parentUuid":"65283e22-752a-4de4-b432-dad9da1d2f06","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SzHu9FSrpdKbmGHEWsGpYH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015PmTesKWZoGc2ZyqnTq5rB","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/contact/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":754,"cache_read_input_tokens":49646,"cache_creation":{"ephemeral_5m_input_tokens":754,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWc4M5zZt9Hq2QPHc1UFE","type":"assistant","uuid":"668d00f9-44a8-4211-ae60-019d71e7c966","timestamp":"2025-12-30T02:10:03.956Z"}
{"parentUuid":"668d00f9-44a8-4211-ae60-019d71e7c966","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SzHu9FSrpdKbmGHEWsGpYH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gjr4EWpmX3ccEWU8rubXrf","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/checkout/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":754,"cache_read_input_tokens":49646,"cache_creation":{"ephemeral_5m_input_tokens":754,"ephemeral_1h_input_tokens":0},"output_tokens":313,"service_tier":"standard"}},"requestId":"req_011CWc4M5zZt9Hq2QPHc1UFE","type":"assistant","uuid":"cbb9bda9-93a4-43aa-be40-d511c1a7ed59","timestamp":"2025-12-30T02:10:04.558Z"}
{"parentUuid":"cbb9bda9-93a4-43aa-be40-d511c1a7ed59","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017ZDBYikTBU4jRh8iu4G7h4","type":"tool_result","content":"     1→/**\n     2→ * Rate Limiter Middleware\n     3→ *\n     4→ * Checks if user has sufficient credits before processing.\n     5→ * Uses atomic credit reservation to prevent race conditions.\n     6→ * Returns 402 Payment Required if insufficient credits.\n     7→ *\n     8→ * SECURITY: Uses JWT authentication via authenticateToken middleware.\n     9→ * Legacy x-stripe-customer-id header is DISABLED in production for security.\n    10→ */\n    11→\n    12→const {\n    13→  deductUsage,\n    14→  getBalance,\n    15→  reserveCredits,\n    16→  confirmReservation,\n    17→  releaseReservation,\n    18→  customerExists,\n    19→  hasFeatureAccess\n    20→} = require('../services/usageTracking');\n    21→const { verifyToken, extractBearerToken } = require('./auth');\n    22→\n    23→// SECURITY: Disable legacy auth in production unless explicitly enabled\n    24→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    25→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n    26→\n    27→// =============================================================================\n    28→// IP-based Rate Limiting\n    29→// =============================================================================\n    30→\n    31→// General rate limiting per IP\n    32→const ipRequestCounts = new Map(); // IP -> { count, windowStart }\n    33→const IP_RATE_LIMIT_WINDOW_MS = 60000; // 1 minute window\n    34→const IP_RATE_LIMIT_MAX_REQUESTS = 100; // 100 requests per minute per IP\n    35→\n    36→// Cleanup old entries every 5 minutes to prevent memory leaks\n    37→setInterval(() => {\n    38→  const now = Date.now();\n    39→  for (const [ip, data] of ipRequestCounts.entries()) {\n    40→    if (now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS * 2) {\n    41→      ipRequestCounts.delete(ip);\n    42→    }\n    43→  }\n    44→}, 300000);\n    45→\n    46→/**\n    47→ * Check if IP is rate limited\n    48→ * @param {string} ip - Client IP address\n    49→ * @returns {boolean} True if rate limited\n    50→ */\n    51→function isIpRateLimited(ip) {\n    52→  const now = Date.now();\n    53→  const data = ipRequestCounts.get(ip);\n    54→\n    55→  if (!data || now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS) {\n    56→    // Start new window\n    57→    ipRequestCounts.set(ip, { count: 1, windowStart: now });\n    58→    return false;\n    59→  }\n    60→\n    61→  data.count++;\n    62→  if (data.count > IP_RATE_LIMIT_MAX_REQUESTS) {\n    63→    return true;\n    64→  }\n    65→\n    66→  return false;\n    67→}\n    68→\n    69→/**\n    70→ * IP-based rate limiting middleware\n    71→ * Limits requests per IP to prevent abuse\n    72→ */\n    73→function ipRateLimit(req, res, next) {\n    74→  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n    75→\n    76→  if (isIpRateLimited(clientIp)) {\n    77→    console.warn(`[SECURITY] IP rate limit exceeded for: ${clientIp}`);\n    78→    return res.status(429).json({\n    79→      error: 'Too many requests',\n    80→      message: 'Please slow down and try again later',\n    81→      retryAfter: 60\n    82→    });\n    83→  }\n    84→\n    85→  next();\n    86→}\n    87→\n    88→// Rate limiting for legacy auth attempts (prevent brute force)\n    89→const legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\n    90→const LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\n    91→const LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n    92→\n    93→/**\n    94→ * Check if IP is rate limited for legacy auth\n    95→ */\n    96→function isLegacyAuthRateLimited(ip) {\n    97→  const now = Date.now();\n    98→  const attempt = legacyAuthAttempts.get(ip);\n    99→\n   100→  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n   101→    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n   102→    return false;\n   103→  }\n   104→\n   105→  attempt.count++;\n   106→  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n   107→    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n   108→    return true;\n   109→  }\n   110→\n   111→  return false;\n   112→}\n   113→\n   114→// Default estimated duration for reservation (1 minute = 60 seconds)\n   115→const DEFAULT_RESERVATION_SECONDS = 60;\n   116→\n   117→/**\n   118→ * Middleware to check and atomically reserve credits before processing\n   119→ *\n   120→ * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n   121→ * Falls back to legacy x-stripe-customer-id header (deprecated)\n   122→ *\n   123→ * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n   124→ *\n   125→ * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n   126→ * where multiple concurrent requests could all pass credit check.\n   127→ */\n   128→function requireCredits(options = {}) {\n   129→  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n   130→\n   131→  return async (req, res, next) => {\n   132→    // SECURITY: Primary auth via JWT token\n   133→    const authHeader = req.headers['authorization'];\n   134→    const token = extractBearerToken(authHeader);\n   135→\n   136→    let stripeCustomerId = null;\n   137→\n   138→    if (token) {\n   139→      const decoded = await verifyToken(token);\n   140→      if (decoded && decoded.sub) {\n   141→        stripeCustomerId = decoded.sub;\n   142→        req.tokenData = decoded;\n   143→      } else {\n   144→        // Token present but invalid\n   145→        return res.status(401).json({\n   146→          error: 'Invalid or expired token',\n   147→          message: 'Please log in again to continue'\n   148→        });\n   149→      }\n   150→    } else {\n   151→      // DEPRECATED: Fallback to legacy header\n   152→      const legacyId = req.headers['x-stripe-customer-id'];\n   153→      if (legacyId) {\n   154→        // SECURITY: Block legacy auth in production unless explicitly enabled\n   155→        if (isProduction && !ALLOW_LEGACY_AUTH) {\n   156→          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n   157→          return res.status(401).json({\n   158→            error: 'Authentication method not supported',\n   159→            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n   160→          });\n   161→        }\n   162→\n   163→        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n   164→        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n   165→        if (isLegacyAuthRateLimited(clientIp)) {\n   166→          return res.status(429).json({\n   167→            error: 'Too many authentication attempts',\n   168→            message: 'Please wait before trying again'\n   169→          });\n   170→        }\n   171→\n   172→        // Validate format to prevent injection\n   173→        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n   174→          return res.status(401).json({\n   175→            error: 'Invalid customer ID format',\n   176→            message: 'Customer ID must be a valid Stripe customer ID'\n   177→          });\n   178→        }\n   179→\n   180→        // SECURITY: Verify customer exists in database before accepting\n   181→        const exists = await customerExists(legacyId);\n   182→        if (!exists) {\n   183→          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n   184→          return res.status(401).json({\n   185→            error: 'Invalid customer ID',\n   186→            message: 'Customer not found'\n   187→          });\n   188→        }\n   189→\n   190→        stripeCustomerId = legacyId;\n   191→        req.isLegacyAuth = true;\n   192→        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n   193→      }\n   194→    }\n   195→\n   196→    if (!stripeCustomerId) {\n   197→      return res.status(401).json({\n   198→        error: 'Authentication required',\n   199→        message: 'Missing Stripe customer ID'\n   200→      });\n   201→    }\n   202→\n   203→    // Store for later use\n   204→    req.stripeCustomerId = stripeCustomerId;\n   205→\n   206→    // Determine estimated duration - use request value, option value, or default\n   207→    const estSeconds = req.estimatedDuration || estimatedSeconds;\n   208→\n   209→    try {\n   210→      // Atomically reserve credits using SELECT...FOR UPDATE\n   211→      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n   212→\n   213→      if (!reservation.success) {\n   214→        // Reservation failed - not enough credits\n   215→        const balance = await getBalance(stripeCustomerId);\n   216→        return res.status(402).json({\n   217→          error: 'Insufficient credits',\n   218→          message: 'Please upgrade your plan or wait for your next billing cycle',\n   219→          balance: {\n   220→            hoursRemaining: balance.hoursRemaining,\n   221→            tier: balance.tier\n   222→          }\n   223→        });\n   224→      }\n   225→\n   226→      // Store reservation info for confirmation/release\n   227→      req.reservation = {\n   228→        id: reservation.reservationId,\n   229→        seconds: estSeconds,\n   230→        hoursReserved: reservation.hoursReserved\n   231→      };\n   232→\n   233→      // Attach helper function to confirm usage with actual duration\n   234→      // This adjusts the reservation if actual duration differs\n   235→      req.deductUsage = async (actualDurationSeconds) => {\n   236→        return await confirmReservation(\n   237→          stripeCustomerId,\n   238→          actualDurationSeconds,\n   239→          estSeconds,\n   240→          endpoint\n   241→        );\n   242→      };\n   243→\n   244→      // Attach helper function to release reservation on failure\n   245→      req.releaseReservation = async (reason = 'processing_failed') => {\n   246→        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n   247→      };\n   248→\n   249→      // Hook into response to auto-release on error responses\n   250→      const originalSend = res.send.bind(res);\n   251→      res.send = function(body) {\n   252→        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n   253→        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n   254→          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n   255→            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n   256→        }\n   257→        return originalSend(body);\n   258→      };\n   259→\n   260→      next();\n   261→    } catch (err) {\n   262→      console.error('[RateLimiter] Error reserving credits:', err);\n   263→      return res.status(500).json({\n   264→        error: 'Credit check failed',\n   265→        message: err.message\n   266→      });\n   267→    }\n   268→  };\n   269→}\n   270→\n   271→/**\n   272→ * Middleware to enforce tier-based feature access\n   273→ *\n   274→ * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n   275→ * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n   276→ *\n   277→ * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n   278→ */\n   279→function requireFeature(featureName) {\n   280→  return async (req, res, next) => {\n   281→    // Must have stripeCustomerId from requireCredits middleware\n   282→    if (!req.stripeCustomerId) {\n   283→      return res.status(401).json({\n   284→        error: 'Authentication required',\n   285→        message: 'Please log in to access this feature'\n   286→      });\n   287→    }\n   288→\n   289→    try {\n   290→      // Get user's current balance (includes tier info)\n   291→      const balance = await getBalance(req.stripeCustomerId);\n   292→\n   293→      // Check if user's tier has access to this feature\n   294→      if (!hasFeatureAccess(balance.tier, featureName)) {\n   295→        // Release any reserved credits since we're blocking the request\n   296→        if (req.releaseReservation) {\n   297→          await req.releaseReservation('feature_not_available');\n   298→        }\n   299→\n   300→        // Determine required tier for helpful error message\n   301→        const requiredTier = getRequiredTierForFeature(featureName);\n   302→\n   303→        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n   304→\n   305→        return res.status(403).json({\n   306→          error: 'Feature not available',\n   307→          message: `This feature requires a ${requiredTier} plan or higher`,\n   308→          requiredFeature: featureName,\n   309→          requiredTier: requiredTier,\n   310→          currentTier: balance.tier\n   311→        });\n   312→      }\n   313→\n   314→      // Feature access granted\n   315→      next();\n   316→    } catch (err) {\n   317→      console.error('[requireFeature] Error checking feature access:', err);\n   318→      return res.status(500).json({\n   319→        error: 'Feature access check failed',\n   320→        message: err.message\n   321→      });\n   322→    }\n   323→  };\n   324→}\n   325→\n   326→/**\n   327→ * Helper to determine required tier for a feature\n   328→ * Used for helpful error messages\n   329→ */\n   330→function getRequiredTierForFeature(featureName) {\n   331→  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n   332→  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n   333→\n   334→  if (teamOnlyFeatures.includes(featureName)) {\n   335→    return 'Team';\n   336→  } else if (proFeatures.includes(featureName)) {\n   337→    return 'Pro';\n   338→  }\n   339→  return 'Starter';\n   340→}\n   341→\n   342→/**\n   343→ * Middleware to track usage after successful response\n   344→ *\n   345→ * Call this after processing to deduct actual usage\n   346→ */\n   347→function trackUsage(endpoint = 'unknown') {\n   348→  return async (req, res, next) => {\n   349→    // Store original json method\n   350→    const originalJson = res.json.bind(res);\n   351→\n   352→    // Override json to track usage on success\n   353→    res.json = async (data) => {\n   354→      // Only deduct on successful responses\n   355→      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n   356→        try {\n   357→          const balance = await deductUsage(\n   358→            req.stripeCustomerId,\n   359→            req.audioDuration,\n   360→            endpoint\n   361→          );\n   362→          // Attach updated balance to response\n   363→          data.balance = balance;\n   364→        } catch (err) {\n   365→          console.error('[RateLimiter] Error deducting usage:', err);\n   366→        }\n   367→      }\n   368→      return originalJson(data);\n   369→    };\n   370→\n   371→    next();\n   372→  };\n   373→}\n   374→\n   375→module.exports = {\n   376→  requireCredits,\n   377→  requireFeature,\n   378→  trackUsage,\n   379→  ipRateLimit\n   380→};\n   381→\n\n</system-reminder>\n"}]},"uuid":"0a7c1a5f-7a0b-4ee7-897d-76f112b1a998","timestamp":"2025-12-30T02:10:04.607Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js","content":"/**\n * Rate Limiter Middleware\n *\n * Checks if user has sufficient credits before processing.\n * Uses atomic credit reservation to prevent race conditions.\n * Returns 402 Payment Required if insufficient credits.\n *\n * SECURITY: Uses JWT authentication via authenticateToken middleware.\n * Legacy x-stripe-customer-id header is DISABLED in production for security.\n */\n\nconst {\n  deductUsage,\n  getBalance,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  customerExists,\n  hasFeatureAccess\n} = require('../services/usageTracking');\nconst { verifyToken, extractBearerToken } = require('./auth');\n\n// SECURITY: Disable legacy auth in production unless explicitly enabled\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n\n// =============================================================================\n// IP-based Rate Limiting\n// =============================================================================\n\n// General rate limiting per IP\nconst ipRequestCounts = new Map(); // IP -> { count, windowStart }\nconst IP_RATE_LIMIT_WINDOW_MS = 60000; // 1 minute window\nconst IP_RATE_LIMIT_MAX_REQUESTS = 100; // 100 requests per minute per IP\n\n// Cleanup old entries every 5 minutes to prevent memory leaks\nsetInterval(() => {\n  const now = Date.now();\n  for (const [ip, data] of ipRequestCounts.entries()) {\n    if (now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS * 2) {\n      ipRequestCounts.delete(ip);\n    }\n  }\n}, 300000);\n\n/**\n * Check if IP is rate limited\n * @param {string} ip - Client IP address\n * @returns {boolean} True if rate limited\n */\nfunction isIpRateLimited(ip) {\n  const now = Date.now();\n  const data = ipRequestCounts.get(ip);\n\n  if (!data || now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS) {\n    // Start new window\n    ipRequestCounts.set(ip, { count: 1, windowStart: now });\n    return false;\n  }\n\n  data.count++;\n  if (data.count > IP_RATE_LIMIT_MAX_REQUESTS) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * IP-based rate limiting middleware\n * Limits requests per IP to prevent abuse\n */\nfunction ipRateLimit(req, res, next) {\n  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n\n  if (isIpRateLimited(clientIp)) {\n    console.warn(`[SECURITY] IP rate limit exceeded for: ${clientIp}`);\n    return res.status(429).json({\n      error: 'Too many requests',\n      message: 'Please slow down and try again later',\n      retryAfter: 60\n    });\n  }\n\n  next();\n}\n\n// Rate limiting for legacy auth attempts (prevent brute force)\nconst legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\nconst LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\nconst LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n\n/**\n * Check if IP is rate limited for legacy auth\n */\nfunction isLegacyAuthRateLimited(ip) {\n  const now = Date.now();\n  const attempt = legacyAuthAttempts.get(ip);\n\n  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n    return false;\n  }\n\n  attempt.count++;\n  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n    return true;\n  }\n\n  return false;\n}\n\n// Default estimated duration for reservation (1 minute = 60 seconds)\nconst DEFAULT_RESERVATION_SECONDS = 60;\n\n/**\n * Middleware to check and atomically reserve credits before processing\n *\n * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n * Falls back to legacy x-stripe-customer-id header (deprecated)\n *\n * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n *\n * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n * where multiple concurrent requests could all pass credit check.\n */\nfunction requireCredits(options = {}) {\n  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n\n  return async (req, res, next) => {\n    // SECURITY: Primary auth via JWT token\n    const authHeader = req.headers['authorization'];\n    const token = extractBearerToken(authHeader);\n\n    let stripeCustomerId = null;\n\n    if (token) {\n      const decoded = await verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n        req.tokenData = decoded;\n      } else {\n        // Token present but invalid\n        return res.status(401).json({\n          error: 'Invalid or expired token',\n          message: 'Please log in again to continue'\n        });\n      }\n    } else {\n      // DEPRECATED: Fallback to legacy header\n      const legacyId = req.headers['x-stripe-customer-id'];\n      if (legacyId) {\n        // SECURITY: Block legacy auth in production unless explicitly enabled\n        if (isProduction && !ALLOW_LEGACY_AUTH) {\n          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n          return res.status(401).json({\n            error: 'Authentication method not supported',\n            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n          });\n        }\n\n        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n        if (isLegacyAuthRateLimited(clientIp)) {\n          return res.status(429).json({\n            error: 'Too many authentication attempts',\n            message: 'Please wait before trying again'\n          });\n        }\n\n        // Validate format to prevent injection\n        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n          return res.status(401).json({\n            error: 'Invalid customer ID format',\n            message: 'Customer ID must be a valid Stripe customer ID'\n          });\n        }\n\n        // SECURITY: Verify customer exists in database before accepting\n        const exists = await customerExists(legacyId);\n        if (!exists) {\n          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n          return res.status(401).json({\n            error: 'Invalid customer ID',\n            message: 'Customer not found'\n          });\n        }\n\n        stripeCustomerId = legacyId;\n        req.isLegacyAuth = true;\n        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n      }\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Missing Stripe customer ID'\n      });\n    }\n\n    // Store for later use\n    req.stripeCustomerId = stripeCustomerId;\n\n    // Determine estimated duration - use request value, option value, or default\n    const estSeconds = req.estimatedDuration || estimatedSeconds;\n\n    try {\n      // Atomically reserve credits using SELECT...FOR UPDATE\n      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n\n      if (!reservation.success) {\n        // Reservation failed - not enough credits\n        const balance = await getBalance(stripeCustomerId);\n        return res.status(402).json({\n          error: 'Insufficient credits',\n          message: 'Please upgrade your plan or wait for your next billing cycle',\n          balance: {\n            hoursRemaining: balance.hoursRemaining,\n            tier: balance.tier\n          }\n        });\n      }\n\n      // Store reservation info for confirmation/release\n      req.reservation = {\n        id: reservation.reservationId,\n        seconds: estSeconds,\n        hoursReserved: reservation.hoursReserved\n      };\n\n      // Attach helper function to confirm usage with actual duration\n      // This adjusts the reservation if actual duration differs\n      req.deductUsage = async (actualDurationSeconds) => {\n        return await confirmReservation(\n          stripeCustomerId,\n          actualDurationSeconds,\n          estSeconds,\n          endpoint\n        );\n      };\n\n      // Attach helper function to release reservation on failure\n      req.releaseReservation = async (reason = 'processing_failed') => {\n        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n      };\n\n      // Hook into response to auto-release on error responses\n      const originalSend = res.send.bind(res);\n      res.send = function(body) {\n        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n        }\n        return originalSend(body);\n      };\n\n      next();\n    } catch (err) {\n      console.error('[RateLimiter] Error reserving credits:', err);\n      return res.status(500).json({\n        error: 'Credit check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Middleware to enforce tier-based feature access\n *\n * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n *\n * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n */\nfunction requireFeature(featureName) {\n  return async (req, res, next) => {\n    // Must have stripeCustomerId from requireCredits middleware\n    if (!req.stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please log in to access this feature'\n      });\n    }\n\n    try {\n      // Get user's current balance (includes tier info)\n      const balance = await getBalance(req.stripeCustomerId);\n\n      // Check if user's tier has access to this feature\n      if (!hasFeatureAccess(balance.tier, featureName)) {\n        // Release any reserved credits since we're blocking the request\n        if (req.releaseReservation) {\n          await req.releaseReservation('feature_not_available');\n        }\n\n        // Determine required tier for helpful error message\n        const requiredTier = getRequiredTierForFeature(featureName);\n\n        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n\n        return res.status(403).json({\n          error: 'Feature not available',\n          message: `This feature requires a ${requiredTier} plan or higher`,\n          requiredFeature: featureName,\n          requiredTier: requiredTier,\n          currentTier: balance.tier\n        });\n      }\n\n      // Feature access granted\n      next();\n    } catch (err) {\n      console.error('[requireFeature] Error checking feature access:', err);\n      return res.status(500).json({\n        error: 'Feature access check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Helper to determine required tier for a feature\n * Used for helpful error messages\n */\nfunction getRequiredTierForFeature(featureName) {\n  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n\n  if (teamOnlyFeatures.includes(featureName)) {\n    return 'Team';\n  } else if (proFeatures.includes(featureName)) {\n    return 'Pro';\n  }\n  return 'Starter';\n}\n\n/**\n * Middleware to track usage after successful response\n *\n * Call this after processing to deduct actual usage\n */\nfunction trackUsage(endpoint = 'unknown') {\n  return async (req, res, next) => {\n    // Store original json method\n    const originalJson = res.json.bind(res);\n\n    // Override json to track usage on success\n    res.json = async (data) => {\n      // Only deduct on successful responses\n      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n        try {\n          const balance = await deductUsage(\n            req.stripeCustomerId,\n            req.audioDuration,\n            endpoint\n          );\n          // Attach updated balance to response\n          data.balance = balance;\n        } catch (err) {\n          console.error('[RateLimiter] Error deducting usage:', err);\n        }\n      }\n      return originalJson(data);\n    };\n\n    next();\n  };\n}\n\nmodule.exports = {\n  requireCredits,\n  requireFeature,\n  trackUsage,\n  ipRateLimit\n};\n","numLines":381,"startLine":1,"totalLines":381}}}
{"parentUuid":"0a7c1a5f-7a0b-4ee7-897d-76f112b1a998","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gx14kJH2LNTkdgp545MmSZ","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import { CSRF_HEADER_NAME } from \"@/lib/csrf-server\";\n     3→\n     4→// Backend API URL for authentication\n     5→const BACKEND_API_URL =\n     6→  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n     7→\n     8→// Cookie configuration\n     9→const isProduction = process.env.NODE_ENV === \"production\";\n    10→const COOKIE_OPTIONS = {\n    11→  httpOnly: true,\n    12→  secure: isProduction, // Only secure in production (allows localhost in dev)\n    13→  sameSite: \"strict\" as const,\n    14→  path: \"/\",\n    15→};\n    16→\n    17→// Token expiry times\n    18→const ACCESS_TOKEN_MAX_AGE = 60 * 60; // 1 hour in seconds\n    19→const REFRESH_TOKEN_MAX_AGE = 7 * 24 * 60 * 60; // 7 days in seconds\n    20→\n    21→export async function POST(request: NextRequest) {\n    22→  try {\n    23→    const body = await request.json();\n    24→    const { licenseKey } = body;\n    25→\n    26→    if (!licenseKey) {\n    27→      return NextResponse.json(\n    28→        { error: \"License key is required\" },\n    29→        { status: 400 }\n    30→      );\n    31→    }\n    32→\n    33→    // Get CSRF token from request to forward to backend\n    34→    const csrfToken = request.headers.get(CSRF_HEADER_NAME);\n    35→    const backendHeaders: Record<string, string> = {\n    36→      \"Content-Type\": \"application/json\",\n    37→    };\n    38→    if (csrfToken) {\n    39→      backendHeaders[CSRF_HEADER_NAME] = csrfToken;\n    40→    }\n    41→\n    42→    // Get CSRF cookie to forward to backend\n    43→    const csrfCookie = request.cookies.get(\"splice_csrf\")?.value;\n    44→    if (csrfCookie) {\n    45→      backendHeaders[\"Cookie\"] = `splice_csrf=${csrfCookie}`;\n    46→    }\n    47→\n    48→    // Forward the login request to the backend\n    49→    const response = await fetch(`${BACKEND_API_URL}/auth/login`, {\n    50→      method: \"POST\",\n    51→      headers: backendHeaders,\n    52→      body: JSON.stringify({ licenseKey }),\n    53→    });\n    54→\n    55→    const data = await response.json();\n    56→\n    57→    if (!response.ok) {\n    58→      return NextResponse.json(\n    59→        {\n    60→          error: data.error || \"Authentication failed\",\n    61→          message: data.message || \"Please check your license key and try again\",\n    62→        },\n    63→        { status: response.status }\n    64→      );\n    65→    }\n    66→\n    67→    // Create the response with user data (excluding tokens)\n    68→    const jsonResponse = NextResponse.json({\n    69→      success: true,\n    70→      customerId: data.customerId,\n    71→      tier: data.tier,\n    72→      hoursRemaining: data.hoursRemaining,\n    73→    });\n    74→\n    75→    // Set HttpOnly cookies for tokens\n    76→    jsonResponse.cookies.set(\"splice_token\", data.token, {\n    77→      ...COOKIE_OPTIONS,\n    78→      maxAge: ACCESS_TOKEN_MAX_AGE,\n    79→    });\n    80→\n    81→    jsonResponse.cookies.set(\"splice_refresh_token\", data.refreshToken, {\n    82→      ...COOKIE_OPTIONS,\n    83→      maxAge: REFRESH_TOKEN_MAX_AGE,\n    84→    });\n    85→\n    86→    // Set a non-HttpOnly cookie for client-side auth state check\n    87→    // This doesn't contain sensitive data, just indicates logged-in status\n    88→    jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n    89→      httpOnly: false,\n    90→      secure: isProduction,\n    91→      sameSite: \"strict\" as const,\n    92→      path: \"/\",\n    93→      maxAge: ACCESS_TOKEN_MAX_AGE,\n    94→    });\n    95→\n    96→    // Store user metadata in a separate cookie for client access\n    97→    jsonResponse.cookies.set(\n    98→      \"splice_user\",\n    99→      JSON.stringify({\n   100→        customerId: data.customerId,\n   101→        tier: data.tier,\n   102→        hoursRemaining: data.hoursRemaining,\n   103→      }),\n   104→      {\n   105→        httpOnly: false,\n   106→        secure: isProduction,\n   107→        sameSite: \"strict\" as const,\n   108→        path: \"/\",\n   109→        maxAge: ACCESS_TOKEN_MAX_AGE,\n   110→      }\n   111→    );\n   112→\n   113→    return jsonResponse;\n   114→  } catch (error) {\n   115→    console.error(\"[Auth] Login error:\", error);\n   116→    return NextResponse.json(\n   117→      {\n   118→        error: \"Authentication failed\",\n   119→        message: \"Unable to connect to the authentication server. Please try again later.\",\n   120→      },\n   121→      { status: 500 }\n   122→    );\n   123→  }\n   124→}\n   125→\n\n</system-reminder>\n"}]},"uuid":"8a1f21eb-272f-47ed-8285-8f529de33496","timestamp":"2025-12-30T02:10:04.607Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/login/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport { CSRF_HEADER_NAME } from \"@/lib/csrf-server\";\n\n// Backend API URL for authentication\nconst BACKEND_API_URL =\n  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n\n// Cookie configuration\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst COOKIE_OPTIONS = {\n  httpOnly: true,\n  secure: isProduction, // Only secure in production (allows localhost in dev)\n  sameSite: \"strict\" as const,\n  path: \"/\",\n};\n\n// Token expiry times\nconst ACCESS_TOKEN_MAX_AGE = 60 * 60; // 1 hour in seconds\nconst REFRESH_TOKEN_MAX_AGE = 7 * 24 * 60 * 60; // 7 days in seconds\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { licenseKey } = body;\n\n    if (!licenseKey) {\n      return NextResponse.json(\n        { error: \"License key is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Get CSRF token from request to forward to backend\n    const csrfToken = request.headers.get(CSRF_HEADER_NAME);\n    const backendHeaders: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n    if (csrfToken) {\n      backendHeaders[CSRF_HEADER_NAME] = csrfToken;\n    }\n\n    // Get CSRF cookie to forward to backend\n    const csrfCookie = request.cookies.get(\"splice_csrf\")?.value;\n    if (csrfCookie) {\n      backendHeaders[\"Cookie\"] = `splice_csrf=${csrfCookie}`;\n    }\n\n    // Forward the login request to the backend\n    const response = await fetch(`${BACKEND_API_URL}/auth/login`, {\n      method: \"POST\",\n      headers: backendHeaders,\n      body: JSON.stringify({ licenseKey }),\n    });\n\n    const data = await response.json();\n\n    if (!response.ok) {\n      return NextResponse.json(\n        {\n          error: data.error || \"Authentication failed\",\n          message: data.message || \"Please check your license key and try again\",\n        },\n        { status: response.status }\n      );\n    }\n\n    // Create the response with user data (excluding tokens)\n    const jsonResponse = NextResponse.json({\n      success: true,\n      customerId: data.customerId,\n      tier: data.tier,\n      hoursRemaining: data.hoursRemaining,\n    });\n\n    // Set HttpOnly cookies for tokens\n    jsonResponse.cookies.set(\"splice_token\", data.token, {\n      ...COOKIE_OPTIONS,\n      maxAge: ACCESS_TOKEN_MAX_AGE,\n    });\n\n    jsonResponse.cookies.set(\"splice_refresh_token\", data.refreshToken, {\n      ...COOKIE_OPTIONS,\n      maxAge: REFRESH_TOKEN_MAX_AGE,\n    });\n\n    // Set a non-HttpOnly cookie for client-side auth state check\n    // This doesn't contain sensitive data, just indicates logged-in status\n    jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\" as const,\n      path: \"/\",\n      maxAge: ACCESS_TOKEN_MAX_AGE,\n    });\n\n    // Store user metadata in a separate cookie for client access\n    jsonResponse.cookies.set(\n      \"splice_user\",\n      JSON.stringify({\n        customerId: data.customerId,\n        tier: data.tier,\n        hoursRemaining: data.hoursRemaining,\n      }),\n      {\n        httpOnly: false,\n        secure: isProduction,\n        sameSite: \"strict\" as const,\n        path: \"/\",\n        maxAge: ACCESS_TOKEN_MAX_AGE,\n      }\n    );\n\n    return jsonResponse;\n  } catch (error) {\n    console.error(\"[Auth] Login error:\", error);\n    return NextResponse.json(\n      {\n        error: \"Authentication failed\",\n        message: \"Unable to connect to the authentication server. Please try again later.\",\n      },\n      { status: 500 }\n    );\n  }\n}\n","numLines":125,"startLine":1,"totalLines":125}}}
{"parentUuid":"8a1f21eb-272f-47ed-8285-8f529de33496","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015PmTesKWZoGc2ZyqnTq5rB","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import { csrfGuard } from \"@/lib/csrf-server\";\n     3→\n     4→// Force Node.js runtime for better compatibility\n     5→export const runtime = \"nodejs\";\n     6→export const maxDuration = 30;\n     7→\n     8→// =============================================================================\n     9→// IP-based Rate Limiting\n    10→// =============================================================================\n    11→\n    12→// Rate limit configuration: 5 requests per hour per IP\n    13→const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; // 1 hour in milliseconds\n    14→const RATE_LIMIT_MAX_REQUESTS = 5;\n    15→\n    16→// In-memory store for rate limiting\n    17→// Key: IP address, Value: { count: number, windowStart: number }\n    18→const rateLimitStore = new Map<string, { count: number; windowStart: number }>();\n    19→\n    20→// Cleanup old entries every 10 minutes to prevent memory leaks\n    21→if (typeof setInterval !== \"undefined\") {\n    22→  setInterval(() => {\n    23→    const now = Date.now();\n    24→    const ipsToDelete: string[] = [];\n    25→    rateLimitStore.forEach((data, ip) => {\n    26→      // Mark entries older than 2x the window (2 hours) for deletion\n    27→      if (now - data.windowStart > RATE_LIMIT_WINDOW_MS * 2) {\n    28→        ipsToDelete.push(ip);\n    29→      }\n    30→    });\n    31→    ipsToDelete.forEach((ip) => rateLimitStore.delete(ip));\n    32→  }, 10 * 60 * 1000); // Every 10 minutes\n    33→}\n    34→\n    35→/**\n    36→ * Get client IP address from request headers\n    37→ * Handles various proxy configurations (Vercel, Cloudflare, nginx, etc.)\n    38→ */\n    39→function getClientIp(request: NextRequest): string {\n    40→  // x-forwarded-for can contain multiple IPs; the first one is the client\n    41→  const forwardedFor = request.headers.get(\"x-forwarded-for\");\n    42→  if (forwardedFor) {\n    43→    const firstIp = forwardedFor.split(\",\")[0].trim();\n    44→    if (firstIp) return firstIp;\n    45→  }\n    46→\n    47→  // x-real-ip is set by some proxies (nginx, etc.)\n    48→  const realIp = request.headers.get(\"x-real-ip\");\n    49→  if (realIp) return realIp.trim();\n    50→\n    51→  // Vercel-specific header\n    52→  const vercelForwardedFor = request.headers.get(\"x-vercel-forwarded-for\");\n    53→  if (vercelForwardedFor) {\n    54→    const firstIp = vercelForwardedFor.split(\",\")[0].trim();\n    55→    if (firstIp) return firstIp;\n    56→  }\n    57→\n    58→  // Fallback - this shouldn't happen in production behind a proxy\n    59→  return \"unknown\";\n    60→}\n    61→\n    62→/**\n    63→ * Check if an IP is rate limited\n    64→ * Returns: { limited: boolean, retryAfter?: number }\n    65→ */\n    66→function checkRateLimit(ip: string): { limited: boolean; retryAfter?: number } {\n    67→  const now = Date.now();\n    68→  const data = rateLimitStore.get(ip);\n    69→\n    70→  // No previous requests or window expired - start fresh\n    71→  if (!data || now - data.windowStart > RATE_LIMIT_WINDOW_MS) {\n    72→    rateLimitStore.set(ip, { count: 1, windowStart: now });\n    73→    return { limited: false };\n    74→  }\n    75→\n    76→  // Increment count\n    77→  data.count++;\n    78→\n    79→  // Check if over limit\n    80→  if (data.count > RATE_LIMIT_MAX_REQUESTS) {\n    81→    // Calculate seconds until window resets\n    82→    const retryAfterMs = RATE_LIMIT_WINDOW_MS - (now - data.windowStart);\n    83→    const retryAfterSeconds = Math.ceil(retryAfterMs / 1000);\n    84→    return { limited: true, retryAfter: retryAfterSeconds };\n    85→  }\n    86→\n    87→  return { limited: false };\n    88→}\n    89→\n    90→// Email configuration\n    91→const EMAIL_CONFIG = {\n    92→  from: process.env.EMAIL_FROM || \"SPLICE <noreply@splice.video>\",\n    93→  salesEmail: \"sales@splice.app\",\n    94→  sendgridApiKey: process.env.SENDGRID_API_KEY,\n    95→};\n    96→\n    97→// Request body interface\n    98→interface ContactFormData {\n    99→  name: string;\n   100→  email: string;\n   101→  company?: string;\n   102→  teamSize?: string;\n   103→  message: string;\n   104→}\n   105→\n   106→// Validation helper\n   107→function validateEmail(email: string): boolean {\n   108→  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n   109→  return emailRegex.test(email);\n   110→}\n   111→\n   112→// Escape HTML to prevent XSS in email content\n   113→function escapeHtml(str: string): string {\n   114→  if (str === null || str === undefined) return \"\";\n   115→  const escapeMap: Record<string, string> = {\n   116→    \"&\": \"&amp;\",\n   117→    \"<\": \"&lt;\",\n   118→    \">\": \"&gt;\",\n   119→    '\"': \"&quot;\",\n   120→    \"'\": \"&#x27;\",\n   121→  };\n   122→  return str.replace(/[&<>\"']/g, (char) => escapeMap[char]);\n   123→}\n   124→\n   125→// Generate email HTML template\n   126→function generateEmailHtml(data: ContactFormData): string {\n   127→  return `\n   128→<!DOCTYPE html>\n   129→<html lang=\"en\">\n   130→<head>\n   131→  <meta charset=\"UTF-8\">\n   132→  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   133→  <title>New Contact Form Submission</title>\n   134→  <style>\n   135→    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; margin: 0; padding: 0; }\n   136→    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; background: white; }\n   137→    .header { text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 2px solid #00D4FF; }\n   138→    .logo { font-size: 28px; font-weight: bold; color: #00D4FF; }\n   139→    .badge { display: inline-block; background: #00D4FF; color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; margin-top: 10px; }\n   140→    .content { padding: 20px 0; }\n   141→    .field { margin-bottom: 20px; }\n   142→    .field-label { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: #6b7280; margin-bottom: 5px; }\n   143→    .field-value { font-size: 16px; color: #1e293b; background: #f8fafc; padding: 12px 16px; border-radius: 8px; border-left: 3px solid #00D4FF; }\n   144→    .message-box { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; padding: 20px; margin-top: 20px; }\n   145→    .message-box h3 { color: #166534; margin-top: 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }\n   146→    .message-content { color: #15803d; white-space: pre-wrap; }\n   147→    .footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 14px; }\n   148→    .reply-button { display: inline-block; background: #00D4FF; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; margin-top: 20px; font-weight: 500; }\n   149→  </style>\n   150→</head>\n   151→<body>\n   152→  <div class=\"container\">\n   153→    <div class=\"header\">\n   154→      <div class=\"logo\">SPLICE</div>\n   155→      <div class=\"badge\">New Contact Form Submission</div>\n   156→    </div>\n   157→\n   158→    <div class=\"content\">\n   159→      <div class=\"field\">\n   160→        <div class=\"field-label\">Name</div>\n   161→        <div class=\"field-value\">${escapeHtml(data.name)}</div>\n   162→      </div>\n   163→\n   164→      <div class=\"field\">\n   165→        <div class=\"field-label\">Email</div>\n   166→        <div class=\"field-value\"><a href=\"mailto:${escapeHtml(data.email)}\" style=\"color: #00A8CC;\">${escapeHtml(data.email)}</a></div>\n   167→      </div>\n   168→\n   169→      ${\n   170→        data.company\n   171→          ? `\n   172→      <div class=\"field\">\n   173→        <div class=\"field-label\">Company</div>\n   174→        <div class=\"field-value\">${escapeHtml(data.company)}</div>\n   175→      </div>\n   176→      `\n   177→          : \"\"\n   178→      }\n   179→\n   180→      ${\n   181→        data.teamSize\n   182→          ? `\n   183→      <div class=\"field\">\n   184→        <div class=\"field-label\">Team Size</div>\n   185→        <div class=\"field-value\">${escapeHtml(data.teamSize)}</div>\n   186→      </div>\n   187→      `\n   188→          : \"\"\n   189→      }\n   190→\n   191→      <div class=\"message-box\">\n   192→        <h3>Message</h3>\n   193→        <div class=\"message-content\">${escapeHtml(data.message)}</div>\n   194→      </div>\n   195→\n   196→      <div style=\"text-align: center;\">\n   197→        <a href=\"mailto:${escapeHtml(data.email)}?subject=Re: SPLICE Contact Form\" class=\"reply-button\">Reply to ${escapeHtml(data.name)}</a>\n   198→      </div>\n   199→    </div>\n   200→\n   201→    <div class=\"footer\">\n   202→      <p>This message was sent from the SPLICE website contact form.</p>\n   203→      <p style=\"font-size: 12px;\">&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n   204→    </div>\n   205→  </div>\n   206→</body>\n   207→</html>\n   208→  `;\n   209→}\n   210→\n   211→// Generate plain text email\n   212→function generateEmailText(data: ContactFormData): string {\n   213→  return `\n   214→New Contact Form Submission - SPLICE\n   215→=====================================\n   216→\n   217→Name: ${data.name}\n   218→Email: ${data.email}\n   219→${data.company ? `Company: ${data.company}` : \"\"}\n   220→${data.teamSize ? `Team Size: ${data.teamSize}` : \"\"}\n   221→\n   222→Message:\n   223→---------\n   224→${data.message}\n   225→\n   226→---\n   227→This message was sent from the SPLICE website contact form.\n   228→  `.trim();\n   229→}\n   230→\n   231→// Send email via SendGrid\n   232→async function sendEmailNotification(data: ContactFormData): Promise<void> {\n   233→  if (!EMAIL_CONFIG.sendgridApiKey) {\n   234→    console.warn(\"[Contact API] SENDGRID_API_KEY not configured, logging email to console\");\n   235→    console.log(\"[Contact API] Would send email to:\", EMAIL_CONFIG.salesEmail);\n   236→    console.log(\"[Contact API] From:\", data.name, `<${data.email}>`);\n   237→    console.log(\"[Contact API] Message:\", data.message);\n   238→    return;\n   239→  }\n   240→\n   241→  const response = await fetch(\"https://api.sendgrid.com/v3/mail/send\", {\n   242→    method: \"POST\",\n   243→    headers: {\n   244→      Authorization: `Bearer ${EMAIL_CONFIG.sendgridApiKey}`,\n   245→      \"Content-Type\": \"application/json\",\n   246→    },\n   247→    body: JSON.stringify({\n   248→      personalizations: [\n   249→        {\n   250→          to: [{ email: EMAIL_CONFIG.salesEmail }],\n   251→        },\n   252→      ],\n   253→      from: {\n   254→        email: EMAIL_CONFIG.from.match(/<(.+)>/)?.[1] || \"noreply@splice.video\",\n   255→        name: \"SPLICE Contact Form\",\n   256→      },\n   257→      reply_to: {\n   258→        email: data.email,\n   259→        name: data.name,\n   260→      },\n   261→      subject: `[SPLICE Contact] New inquiry from ${data.name}${data.company ? ` (${data.company})` : \"\"}`,\n   262→      content: [\n   263→        { type: \"text/plain\", value: generateEmailText(data) },\n   264→        { type: \"text/html\", value: generateEmailHtml(data) },\n   265→      ],\n   266→    }),\n   267→  });\n   268→\n   269→  if (!response.ok) {\n   270→    const errorText = await response.text();\n   271→    console.error(\"[Contact API] SendGrid error:\", response.status, errorText);\n   272→    throw new Error(`Failed to send email: ${response.status}`);\n   273→  }\n   274→\n   275→  console.log(\"[Contact API] Email sent successfully to\", EMAIL_CONFIG.salesEmail);\n   276→}\n   277→\n   278→export async function POST(request: NextRequest) {\n   279→  // CSRF validation first\n   280→  const csrfError = await csrfGuard(request);\n   281→  if (csrfError) {\n   282→    console.warn(\"[Contact API] CSRF validation failed\");\n   283→    return csrfError;\n   284→  }\n   285→\n   286→  // Check rate limit\n   287→  const clientIp = getClientIp(request);\n   288→  const rateLimitResult = checkRateLimit(clientIp);\n   289→\n   290→  if (rateLimitResult.limited) {\n   291→    console.warn(\n   292→      `[Contact API] Rate limit exceeded for IP: ${clientIp}`\n   293→    );\n   294→\n   295→    const retryAfter = rateLimitResult.retryAfter || 3600;\n   296→    const retryMinutes = Math.ceil(retryAfter / 60);\n   297→\n   298→    return NextResponse.json(\n   299→      {\n   300→        error: \"Too many requests\",\n   301→        message: `You have exceeded the maximum number of contact form submissions. Please try again in ${retryMinutes} minute${retryMinutes === 1 ? \"\" : \"s\"}.`,\n   302→        retryAfter: retryAfter,\n   303→      },\n   304→      {\n   305→        status: 429,\n   306→        headers: {\n   307→          \"Retry-After\": String(retryAfter),\n   308→        },\n   309→      }\n   310→    );\n   311→  }\n   312→\n   313→  try {\n   314→    // Parse request body\n   315→    let body: ContactFormData;\n   316→    try {\n   317→      body = await request.json();\n   318→    } catch {\n   319→      return NextResponse.json(\n   320→        { error: \"Invalid JSON in request body\" },\n   321→        { status: 400 }\n   322→      );\n   323→    }\n   324→\n   325→    const { name, email, company, teamSize, message } = body;\n   326→\n   327→    // Validate required fields\n   328→    const errors: string[] = [];\n   329→\n   330→    if (!name || typeof name !== \"string\" || name.trim().length === 0) {\n   331→      errors.push(\"Name is required\");\n   332→    }\n   333→\n   334→    if (!email || typeof email !== \"string\" || email.trim().length === 0) {\n   335→      errors.push(\"Email is required\");\n   336→    } else if (!validateEmail(email.trim())) {\n   337→      errors.push(\"Invalid email format\");\n   338→    }\n   339→\n   340→    if (!message || typeof message !== \"string\" || message.trim().length === 0) {\n   341→      errors.push(\"Message is required\");\n   342→    }\n   343→\n   344→    if (errors.length > 0) {\n   345→      return NextResponse.json(\n   346→        { error: \"Validation failed\", details: errors },\n   347→        { status: 400 }\n   348→      );\n   349→    }\n   350→\n   351→    // Sanitize and prepare data\n   352→    const sanitizedData: ContactFormData = {\n   353→      name: name.trim(),\n   354→      email: email.trim().toLowerCase(),\n   355→      company: company?.trim() || undefined,\n   356→      teamSize: teamSize?.trim() || undefined,\n   357→      message: message.trim(),\n   358→    };\n   359→\n   360→    // Send email notification\n   361→    await sendEmailNotification(sanitizedData);\n   362→\n   363→    // Return success response\n   364→    return NextResponse.json({\n   365→      success: true,\n   366→      message: \"Your message has been sent successfully. We will get back to you soon!\",\n   367→    });\n   368→  } catch (error) {\n   369→    console.error(\"[Contact API] Error processing contact form:\", error);\n   370→\n   371→    return NextResponse.json(\n   372→      {\n   373→        error: \"Failed to process your request. Please try again later.\",\n   374→        details: error instanceof Error ? error.message : \"Unknown error\",\n   375→      },\n   376→      { status: 500 }\n   377→    );\n   378→  }\n   379→}\n   380→\n\n</system-reminder>\n"}]},"uuid":"aea05485-d11d-4cc4-a9c3-ae678eb2be7b","timestamp":"2025-12-30T02:10:04.607Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/contact/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport { csrfGuard } from \"@/lib/csrf-server\";\n\n// Force Node.js runtime for better compatibility\nexport const runtime = \"nodejs\";\nexport const maxDuration = 30;\n\n// =============================================================================\n// IP-based Rate Limiting\n// =============================================================================\n\n// Rate limit configuration: 5 requests per hour per IP\nconst RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; // 1 hour in milliseconds\nconst RATE_LIMIT_MAX_REQUESTS = 5;\n\n// In-memory store for rate limiting\n// Key: IP address, Value: { count: number, windowStart: number }\nconst rateLimitStore = new Map<string, { count: number; windowStart: number }>();\n\n// Cleanup old entries every 10 minutes to prevent memory leaks\nif (typeof setInterval !== \"undefined\") {\n  setInterval(() => {\n    const now = Date.now();\n    const ipsToDelete: string[] = [];\n    rateLimitStore.forEach((data, ip) => {\n      // Mark entries older than 2x the window (2 hours) for deletion\n      if (now - data.windowStart > RATE_LIMIT_WINDOW_MS * 2) {\n        ipsToDelete.push(ip);\n      }\n    });\n    ipsToDelete.forEach((ip) => rateLimitStore.delete(ip));\n  }, 10 * 60 * 1000); // Every 10 minutes\n}\n\n/**\n * Get client IP address from request headers\n * Handles various proxy configurations (Vercel, Cloudflare, nginx, etc.)\n */\nfunction getClientIp(request: NextRequest): string {\n  // x-forwarded-for can contain multiple IPs; the first one is the client\n  const forwardedFor = request.headers.get(\"x-forwarded-for\");\n  if (forwardedFor) {\n    const firstIp = forwardedFor.split(\",\")[0].trim();\n    if (firstIp) return firstIp;\n  }\n\n  // x-real-ip is set by some proxies (nginx, etc.)\n  const realIp = request.headers.get(\"x-real-ip\");\n  if (realIp) return realIp.trim();\n\n  // Vercel-specific header\n  const vercelForwardedFor = request.headers.get(\"x-vercel-forwarded-for\");\n  if (vercelForwardedFor) {\n    const firstIp = vercelForwardedFor.split(\",\")[0].trim();\n    if (firstIp) return firstIp;\n  }\n\n  // Fallback - this shouldn't happen in production behind a proxy\n  return \"unknown\";\n}\n\n/**\n * Check if an IP is rate limited\n * Returns: { limited: boolean, retryAfter?: number }\n */\nfunction checkRateLimit(ip: string): { limited: boolean; retryAfter?: number } {\n  const now = Date.now();\n  const data = rateLimitStore.get(ip);\n\n  // No previous requests or window expired - start fresh\n  if (!data || now - data.windowStart > RATE_LIMIT_WINDOW_MS) {\n    rateLimitStore.set(ip, { count: 1, windowStart: now });\n    return { limited: false };\n  }\n\n  // Increment count\n  data.count++;\n\n  // Check if over limit\n  if (data.count > RATE_LIMIT_MAX_REQUESTS) {\n    // Calculate seconds until window resets\n    const retryAfterMs = RATE_LIMIT_WINDOW_MS - (now - data.windowStart);\n    const retryAfterSeconds = Math.ceil(retryAfterMs / 1000);\n    return { limited: true, retryAfter: retryAfterSeconds };\n  }\n\n  return { limited: false };\n}\n\n// Email configuration\nconst EMAIL_CONFIG = {\n  from: process.env.EMAIL_FROM || \"SPLICE <noreply@splice.video>\",\n  salesEmail: \"sales@splice.app\",\n  sendgridApiKey: process.env.SENDGRID_API_KEY,\n};\n\n// Request body interface\ninterface ContactFormData {\n  name: string;\n  email: string;\n  company?: string;\n  teamSize?: string;\n  message: string;\n}\n\n// Validation helper\nfunction validateEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n// Escape HTML to prevent XSS in email content\nfunction escapeHtml(str: string): string {\n  if (str === null || str === undefined) return \"\";\n  const escapeMap: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n  };\n  return str.replace(/[&<>\"']/g, (char) => escapeMap[char]);\n}\n\n// Generate email HTML template\nfunction generateEmailHtml(data: ContactFormData): string {\n  return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>New Contact Form Submission</title>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; margin: 0; padding: 0; }\n    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; background: white; }\n    .header { text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 2px solid #00D4FF; }\n    .logo { font-size: 28px; font-weight: bold; color: #00D4FF; }\n    .badge { display: inline-block; background: #00D4FF; color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; margin-top: 10px; }\n    .content { padding: 20px 0; }\n    .field { margin-bottom: 20px; }\n    .field-label { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: #6b7280; margin-bottom: 5px; }\n    .field-value { font-size: 16px; color: #1e293b; background: #f8fafc; padding: 12px 16px; border-radius: 8px; border-left: 3px solid #00D4FF; }\n    .message-box { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; padding: 20px; margin-top: 20px; }\n    .message-box h3 { color: #166534; margin-top: 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }\n    .message-content { color: #15803d; white-space: pre-wrap; }\n    .footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 14px; }\n    .reply-button { display: inline-block; background: #00D4FF; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; margin-top: 20px; font-weight: 500; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <div class=\"logo\">SPLICE</div>\n      <div class=\"badge\">New Contact Form Submission</div>\n    </div>\n\n    <div class=\"content\">\n      <div class=\"field\">\n        <div class=\"field-label\">Name</div>\n        <div class=\"field-value\">${escapeHtml(data.name)}</div>\n      </div>\n\n      <div class=\"field\">\n        <div class=\"field-label\">Email</div>\n        <div class=\"field-value\"><a href=\"mailto:${escapeHtml(data.email)}\" style=\"color: #00A8CC;\">${escapeHtml(data.email)}</a></div>\n      </div>\n\n      ${\n        data.company\n          ? `\n      <div class=\"field\">\n        <div class=\"field-label\">Company</div>\n        <div class=\"field-value\">${escapeHtml(data.company)}</div>\n      </div>\n      `\n          : \"\"\n      }\n\n      ${\n        data.teamSize\n          ? `\n      <div class=\"field\">\n        <div class=\"field-label\">Team Size</div>\n        <div class=\"field-value\">${escapeHtml(data.teamSize)}</div>\n      </div>\n      `\n          : \"\"\n      }\n\n      <div class=\"message-box\">\n        <h3>Message</h3>\n        <div class=\"message-content\">${escapeHtml(data.message)}</div>\n      </div>\n\n      <div style=\"text-align: center;\">\n        <a href=\"mailto:${escapeHtml(data.email)}?subject=Re: SPLICE Contact Form\" class=\"reply-button\">Reply to ${escapeHtml(data.name)}</a>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      <p>This message was sent from the SPLICE website contact form.</p>\n      <p style=\"font-size: 12px;\">&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n    </div>\n  </div>\n</body>\n</html>\n  `;\n}\n\n// Generate plain text email\nfunction generateEmailText(data: ContactFormData): string {\n  return `\nNew Contact Form Submission - SPLICE\n=====================================\n\nName: ${data.name}\nEmail: ${data.email}\n${data.company ? `Company: ${data.company}` : \"\"}\n${data.teamSize ? `Team Size: ${data.teamSize}` : \"\"}\n\nMessage:\n---------\n${data.message}\n\n---\nThis message was sent from the SPLICE website contact form.\n  `.trim();\n}\n\n// Send email via SendGrid\nasync function sendEmailNotification(data: ContactFormData): Promise<void> {\n  if (!EMAIL_CONFIG.sendgridApiKey) {\n    console.warn(\"[Contact API] SENDGRID_API_KEY not configured, logging email to console\");\n    console.log(\"[Contact API] Would send email to:\", EMAIL_CONFIG.salesEmail);\n    console.log(\"[Contact API] From:\", data.name, `<${data.email}>`);\n    console.log(\"[Contact API] Message:\", data.message);\n    return;\n  }\n\n  const response = await fetch(\"https://api.sendgrid.com/v3/mail/send\", {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${EMAIL_CONFIG.sendgridApiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      personalizations: [\n        {\n          to: [{ email: EMAIL_CONFIG.salesEmail }],\n        },\n      ],\n      from: {\n        email: EMAIL_CONFIG.from.match(/<(.+)>/)?.[1] || \"noreply@splice.video\",\n        name: \"SPLICE Contact Form\",\n      },\n      reply_to: {\n        email: data.email,\n        name: data.name,\n      },\n      subject: `[SPLICE Contact] New inquiry from ${data.name}${data.company ? ` (${data.company})` : \"\"}`,\n      content: [\n        { type: \"text/plain\", value: generateEmailText(data) },\n        { type: \"text/html\", value: generateEmailHtml(data) },\n      ],\n    }),\n  });\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    console.error(\"[Contact API] SendGrid error:\", response.status, errorText);\n    throw new Error(`Failed to send email: ${response.status}`);\n  }\n\n  console.log(\"[Contact API] Email sent successfully to\", EMAIL_CONFIG.salesEmail);\n}\n\nexport async function POST(request: NextRequest) {\n  // CSRF validation first\n  const csrfError = await csrfGuard(request);\n  if (csrfError) {\n    console.warn(\"[Contact API] CSRF validation failed\");\n    return csrfError;\n  }\n\n  // Check rate limit\n  const clientIp = getClientIp(request);\n  const rateLimitResult = checkRateLimit(clientIp);\n\n  if (rateLimitResult.limited) {\n    console.warn(\n      `[Contact API] Rate limit exceeded for IP: ${clientIp}`\n    );\n\n    const retryAfter = rateLimitResult.retryAfter || 3600;\n    const retryMinutes = Math.ceil(retryAfter / 60);\n\n    return NextResponse.json(\n      {\n        error: \"Too many requests\",\n        message: `You have exceeded the maximum number of contact form submissions. Please try again in ${retryMinutes} minute${retryMinutes === 1 ? \"\" : \"s\"}.`,\n        retryAfter: retryAfter,\n      },\n      {\n        status: 429,\n        headers: {\n          \"Retry-After\": String(retryAfter),\n        },\n      }\n    );\n  }\n\n  try {\n    // Parse request body\n    let body: ContactFormData;\n    try {\n      body = await request.json();\n    } catch {\n      return NextResponse.json(\n        { error: \"Invalid JSON in request body\" },\n        { status: 400 }\n      );\n    }\n\n    const { name, email, company, teamSize, message } = body;\n\n    // Validate required fields\n    const errors: string[] = [];\n\n    if (!name || typeof name !== \"string\" || name.trim().length === 0) {\n      errors.push(\"Name is required\");\n    }\n\n    if (!email || typeof email !== \"string\" || email.trim().length === 0) {\n      errors.push(\"Email is required\");\n    } else if (!validateEmail(email.trim())) {\n      errors.push(\"Invalid email format\");\n    }\n\n    if (!message || typeof message !== \"string\" || message.trim().length === 0) {\n      errors.push(\"Message is required\");\n    }\n\n    if (errors.length > 0) {\n      return NextResponse.json(\n        { error: \"Validation failed\", details: errors },\n        { status: 400 }\n      );\n    }\n\n    // Sanitize and prepare data\n    const sanitizedData: ContactFormData = {\n      name: name.trim(),\n      email: email.trim().toLowerCase(),\n      company: company?.trim() || undefined,\n      teamSize: teamSize?.trim() || undefined,\n      message: message.trim(),\n    };\n\n    // Send email notification\n    await sendEmailNotification(sanitizedData);\n\n    // Return success response\n    return NextResponse.json({\n      success: true,\n      message: \"Your message has been sent successfully. We will get back to you soon!\",\n    });\n  } catch (error) {\n    console.error(\"[Contact API] Error processing contact form:\", error);\n\n    return NextResponse.json(\n      {\n        error: \"Failed to process your request. Please try again later.\",\n        details: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n","numLines":380,"startLine":1,"totalLines":380}}}
{"parentUuid":"aea05485-d11d-4cc4-a9c3-ae678eb2be7b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gjr4EWpmX3ccEWU8rubXrf","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import Stripe from \"stripe\";\n     3→import { csrfGuard } from \"@/lib/csrf-server\";\n     4→\n     5→// Force Node.js runtime (not Edge) for better Stripe compatibility\n     6→export const runtime = \"nodejs\";\n     7→export const maxDuration = 30;\n     8→\n     9→// Lazy initialization to avoid errors during build\n    10→let stripe: Stripe | null = null;\n    11→function getStripe(): Stripe {\n    12→  if (!stripe) {\n    13→    if (!process.env.STRIPE_SECRET_KEY) {\n    14→      throw new Error(\"STRIPE_SECRET_KEY is not configured\");\n    15→    }\n    16→    stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n    17→      timeout: 10000,\n    18→      maxNetworkRetries: 2,\n    19→    });\n    20→  }\n    21→  return stripe;\n    22→}\n    23→\n    24→// Get price IDs at runtime to ensure env vars are loaded\n    25→function getPriceIds() {\n    26→  return {\n    27→    monthly: {\n    28→      starter: process.env.STRIPE_PRICE_STARTER || \"\",\n    29→      pro: process.env.STRIPE_PRICE_PRO || \"\",\n    30→      team: process.env.STRIPE_PRICE_TEAM || \"\",\n    31→    },\n    32→    annual: {\n    33→      starter: process.env.STRIPE_PRICE_STARTER_ANNUAL || \"\",\n    34→      pro: process.env.STRIPE_PRICE_PRO_ANNUAL || \"\",\n    35→      team: process.env.STRIPE_PRICE_TEAM_ANNUAL || \"\",\n    36→    },\n    37→  };\n    38→}\n    39→\n    40→export async function POST(request: NextRequest) {\n    41→  // CSRF validation\n    42→  const csrfError = await csrfGuard(request);\n    43→  if (csrfError) {\n    44→    console.warn(\"[Checkout] CSRF validation failed\");\n    45→    return csrfError;\n    46→  }\n    47→\n    48→  try {\n    49→    const body = await request.json();\n    50→    const { plan, email, successUrl, cancelUrl, billing = \"monthly\" } = body;\n    51→\n    52→    // Get price IDs at runtime\n    53→    const allPrices = getPriceIds();\n    54→    const priceIds = billing === \"annual\" ? allPrices.annual : allPrices.monthly;\n    55→\n    56→    if (!plan || !priceIds[plan as keyof typeof priceIds]) {\n    57→      return NextResponse.json(\n    58→        { error: \"Invalid plan selected\" },\n    59→        { status: 400 }\n    60→      );\n    61→    }\n    62→\n    63→    const priceId = priceIds[plan as keyof typeof priceIds];\n    64→\n    65→    if (!priceId) {\n    66→      return NextResponse.json(\n    67→        { error: \"Price ID not configured for this plan\" },\n    68→        { status: 500 }\n    69→      );\n    70→    }\n    71→\n    72→    // Create Stripe checkout session using raw fetch (workaround for Vercel SDK connectivity issues)\n    73→    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || \"https://splice-website.vercel.app\";\n    74→    const successUrlFinal = successUrl || `${baseUrl}/checkout/success`;\n    75→    const cancelUrlFinal = cancelUrl || `${baseUrl}/pricing`;\n    76→\n    77→    const params = new URLSearchParams();\n    78→    params.append(\"mode\", \"subscription\");\n    79→    params.append(\"payment_method_types[0]\", \"card\");\n    80→    params.append(\"line_items[0][price]\", priceId);\n    81→    params.append(\"line_items[0][quantity]\", \"1\");\n    82→    if (email) params.append(\"customer_email\", email);\n    83→    params.append(\"success_url\", successUrlFinal);\n    84→    params.append(\"cancel_url\", cancelUrlFinal);\n    85→    params.append(\"subscription_data[trial_period_days]\", \"14\");\n    86→    params.append(\"subscription_data[metadata][plan]\", plan);\n    87→    params.append(\"subscription_data[metadata][billing]\", billing);\n    88→    params.append(\"metadata[plan]\", plan);\n    89→    params.append(\"metadata[billing]\", billing);\n    90→    params.append(\"allow_promotion_codes\", \"true\");\n    91→    params.append(\"billing_address_collection\", \"required\");\n    92→\n    93→    const response = await fetch(\"https://api.stripe.com/v1/checkout/sessions\", {\n    94→      method: \"POST\",\n    95→      headers: {\n    96→        \"Authorization\": `Bearer ${process.env.STRIPE_SECRET_KEY}`,\n    97→        \"Content-Type\": \"application/x-www-form-urlencoded\",\n    98→      },\n    99→      body: params,\n   100→    });\n   101→\n   102→    if (!response.ok) {\n   103→      const errorData = await response.json();\n   104→      console.error(\"[Checkout] Stripe API error:\", errorData);\n   105→      throw new Error(errorData.error?.message || \"Stripe API error\");\n   106→    }\n   107→\n   108→    const session = await response.json();\n   109→\n   110→    return NextResponse.json({\n   111→      sessionId: session.id,\n   112→      url: session.url,\n   113→    });\n   114→  } catch (error) {\n   115→    console.error(\"[Checkout] Error:\", error instanceof Error ? error.message : error);\n   116→    return NextResponse.json(\n   117→      {\n   118→        error:\n   119→          error instanceof Error ? error.message : \"Failed to create checkout session\",\n   120→      },\n   121→      { status: 500 }\n   122→    );\n   123→  }\n   124→}\n   125→\n   126→export async function GET(request: NextRequest) {\n   127→  const searchParams = request.nextUrl.searchParams;\n   128→  const sessionId = searchParams.get(\"session_id\");\n   129→\n   130→  if (!sessionId) {\n   131→    return NextResponse.json(\n   132→      { error: \"Session ID is required\" },\n   133→      { status: 400 }\n   134→    );\n   135→  }\n   136→\n   137→  try {\n   138→    const session = await getStripe().checkout.sessions.retrieve(sessionId, {\n   139→      expand: [\"subscription\", \"customer\"],\n   140→    });\n   141→\n   142→    return NextResponse.json({\n   143→      status: session.status,\n   144→      customerEmail: session.customer_details?.email,\n   145→      plan: session.metadata?.plan,\n   146→      subscriptionId:\n   147→        typeof session.subscription === \"string\"\n   148→          ? session.subscription\n   149→          : session.subscription?.id,\n   150→    });\n   151→  } catch (error) {\n   152→    console.error(\"Session retrieval error:\", error);\n   153→    return NextResponse.json(\n   154→      {\n   155→        error:\n   156→          error instanceof Error\n   157→            ? error.message\n   158→            : \"Failed to retrieve session\",\n   159→      },\n   160→      { status: 500 }\n   161→    );\n   162→  }\n   163→}\n   164→\n\n</system-reminder>\n"}]},"uuid":"6b2c91d1-9fb8-48ac-9efe-f013f76274a9","timestamp":"2025-12-30T02:10:04.607Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/checkout/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport Stripe from \"stripe\";\nimport { csrfGuard } from \"@/lib/csrf-server\";\n\n// Force Node.js runtime (not Edge) for better Stripe compatibility\nexport const runtime = \"nodejs\";\nexport const maxDuration = 30;\n\n// Lazy initialization to avoid errors during build\nlet stripe: Stripe | null = null;\nfunction getStripe(): Stripe {\n  if (!stripe) {\n    if (!process.env.STRIPE_SECRET_KEY) {\n      throw new Error(\"STRIPE_SECRET_KEY is not configured\");\n    }\n    stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n      timeout: 10000,\n      maxNetworkRetries: 2,\n    });\n  }\n  return stripe;\n}\n\n// Get price IDs at runtime to ensure env vars are loaded\nfunction getPriceIds() {\n  return {\n    monthly: {\n      starter: process.env.STRIPE_PRICE_STARTER || \"\",\n      pro: process.env.STRIPE_PRICE_PRO || \"\",\n      team: process.env.STRIPE_PRICE_TEAM || \"\",\n    },\n    annual: {\n      starter: process.env.STRIPE_PRICE_STARTER_ANNUAL || \"\",\n      pro: process.env.STRIPE_PRICE_PRO_ANNUAL || \"\",\n      team: process.env.STRIPE_PRICE_TEAM_ANNUAL || \"\",\n    },\n  };\n}\n\nexport async function POST(request: NextRequest) {\n  // CSRF validation\n  const csrfError = await csrfGuard(request);\n  if (csrfError) {\n    console.warn(\"[Checkout] CSRF validation failed\");\n    return csrfError;\n  }\n\n  try {\n    const body = await request.json();\n    const { plan, email, successUrl, cancelUrl, billing = \"monthly\" } = body;\n\n    // Get price IDs at runtime\n    const allPrices = getPriceIds();\n    const priceIds = billing === \"annual\" ? allPrices.annual : allPrices.monthly;\n\n    if (!plan || !priceIds[plan as keyof typeof priceIds]) {\n      return NextResponse.json(\n        { error: \"Invalid plan selected\" },\n        { status: 400 }\n      );\n    }\n\n    const priceId = priceIds[plan as keyof typeof priceIds];\n\n    if (!priceId) {\n      return NextResponse.json(\n        { error: \"Price ID not configured for this plan\" },\n        { status: 500 }\n      );\n    }\n\n    // Create Stripe checkout session using raw fetch (workaround for Vercel SDK connectivity issues)\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || \"https://splice-website.vercel.app\";\n    const successUrlFinal = successUrl || `${baseUrl}/checkout/success`;\n    const cancelUrlFinal = cancelUrl || `${baseUrl}/pricing`;\n\n    const params = new URLSearchParams();\n    params.append(\"mode\", \"subscription\");\n    params.append(\"payment_method_types[0]\", \"card\");\n    params.append(\"line_items[0][price]\", priceId);\n    params.append(\"line_items[0][quantity]\", \"1\");\n    if (email) params.append(\"customer_email\", email);\n    params.append(\"success_url\", successUrlFinal);\n    params.append(\"cancel_url\", cancelUrlFinal);\n    params.append(\"subscription_data[trial_period_days]\", \"14\");\n    params.append(\"subscription_data[metadata][plan]\", plan);\n    params.append(\"subscription_data[metadata][billing]\", billing);\n    params.append(\"metadata[plan]\", plan);\n    params.append(\"metadata[billing]\", billing);\n    params.append(\"allow_promotion_codes\", \"true\");\n    params.append(\"billing_address_collection\", \"required\");\n\n    const response = await fetch(\"https://api.stripe.com/v1/checkout/sessions\", {\n      method: \"POST\",\n      headers: {\n        \"Authorization\": `Bearer ${process.env.STRIPE_SECRET_KEY}`,\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n      body: params,\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      console.error(\"[Checkout] Stripe API error:\", errorData);\n      throw new Error(errorData.error?.message || \"Stripe API error\");\n    }\n\n    const session = await response.json();\n\n    return NextResponse.json({\n      sessionId: session.id,\n      url: session.url,\n    });\n  } catch (error) {\n    console.error(\"[Checkout] Error:\", error instanceof Error ? error.message : error);\n    return NextResponse.json(\n      {\n        error:\n          error instanceof Error ? error.message : \"Failed to create checkout session\",\n      },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const sessionId = searchParams.get(\"session_id\");\n\n  if (!sessionId) {\n    return NextResponse.json(\n      { error: \"Session ID is required\" },\n      { status: 400 }\n    );\n  }\n\n  try {\n    const session = await getStripe().checkout.sessions.retrieve(sessionId, {\n      expand: [\"subscription\", \"customer\"],\n    });\n\n    return NextResponse.json({\n      status: session.status,\n      customerEmail: session.customer_details?.email,\n      plan: session.metadata?.plan,\n      subscriptionId:\n        typeof session.subscription === \"string\"\n          ? session.subscription\n          : session.subscription?.id,\n    });\n  } catch (error) {\n    console.error(\"Session retrieval error:\", error);\n    return NextResponse.json(\n      {\n        error:\n          error instanceof Error\n            ? error.message\n            : \"Failed to retrieve session\",\n      },\n      { status: 500 }\n    );\n  }\n}\n","numLines":164,"startLine":1,"totalLines":164}}}
{"parentUuid":"6b2c91d1-9fb8-48ac-9efe-f013f76274a9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019CDuEAm1dmvpxw2NK963Tx","type":"tool_result","content":"     1→/**\n     2→ * Usage Tracking Service\n     3→ *\n     4→ * Tracks user credit balances and usage for billing.\n     5→ * Uses PostgreSQL for persistence.\n     6→ */\n     7→\n     8→const { Pool } = require('pg');\n     9→const { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n    10→\n    11→// PostgreSQL connection pool with proper limits\n    12→// SSL Configuration:\n    13→// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n    14→// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n    15→// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\n    16→const sslConfig = process.env.NODE_ENV === 'production' ? {\n    17→  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n    18→  ca: process.env.DATABASE_SSL_CA || undefined\n    19→} : false;\n    20→\n    21→const pool = new Pool({\n    22→  connectionString: process.env.DATABASE_URL,\n    23→  ssl: sslConfig,\n    24→  // PERFORMANCE: Set connection pool limits\n    25→  max: 20,                    // Maximum number of clients in the pool\n    26→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n    27→  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n    28→});\n    29→\n    30→// Hours per tier (regular processing)\n    31→// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n    32→// Target margins: 79-82%\n    33→const TIER_HOURS = {\n    34→  starter: 4,    // 4 hrs/month\n    35→  pro: 15,       // 15 hrs/month\n    36→  team: 50,      // 50 hrs/month\n    37→  cancelled: 0\n    38→};\n    39→\n    40→// Overage rate for processing hours beyond included\n    41→const HOURS_OVERAGE_RATE = 2.00; // $2/hour\n    42→\n    43→// Isolation minutes per tier (sized to maintain 80% margins)\n    44→const TIER_ISOLATION_MINUTES = {\n    45→  starter: 0,     // No isolation access\n    46→  pro: 45,        // 45 minutes included\n    47→  team: 180,      // 3 hours included\n    48→  cancelled: 0\n    49→};\n    50→\n    51→// Convert to hours for database storage\n    52→const TIER_ISOLATION_HOURS = {\n    53→  starter: 0,\n    54→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n    55→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n    56→  cancelled: 0\n    57→};\n    58→\n    59→// Overage rate for isolation beyond included minutes\n    60→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n    61→\n    62→/**\n    63→ * Initialize database tables\n    64→ */\n    65→async function initDatabase() {\n    66→  const client = await pool.connect();\n    67→  try {\n    68→    await client.query(`\n    69→      CREATE TABLE IF NOT EXISTS users (\n    70→        id SERIAL PRIMARY KEY,\n    71→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n    72→        email VARCHAR(255),\n    73→        tier VARCHAR(50) DEFAULT 'starter',\n    74→        hours_remaining DECIMAL(10,4) DEFAULT 15,\n    75→        hours_total DECIMAL(10,4) DEFAULT 15,\n    76→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n    77→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n    78→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    79→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    80→      )\n    81→    `);\n    82→\n    83→    // Add isolation columns if they don't exist (for existing databases)\n    84→    await client.query(`\n    85→      DO $$\n    86→      BEGIN\n    87→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n    88→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n    89→        END IF;\n    90→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n    91→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n    92→        END IF;\n    93→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n    94→          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n    95→        END IF;\n    96→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified') THEN\n    97→          ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;\n    98→        END IF;\n    99→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified_at') THEN\n   100→          ALTER TABLE users ADD COLUMN email_verified_at TIMESTAMP;\n   101→        END IF;\n   102→      END $$;\n   103→    `);\n   104→\n   105→    await client.query(`\n   106→      CREATE TABLE IF NOT EXISTS usage_log (\n   107→        id SERIAL PRIMARY KEY,\n   108→        user_id INTEGER REFERENCES users(id),\n   109→        stripe_customer_id VARCHAR(255),\n   110→        audio_duration_seconds DECIMAL(10,2),\n   111→        hours_used DECIMAL(10,6),\n   112→        endpoint VARCHAR(100),\n   113→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   114→      )\n   115→    `);\n   116→\n   117→    await client.query(`\n   118→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n   119→    `);\n   120→\n   121→    await client.query(`\n   122→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n   123→    `);\n   124→\n   125→    // PERFORMANCE: Add composite index for efficient customer usage history queries\n   126→    await client.query(`\n   127→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n   128→      ON usage_log(stripe_customer_id, created_at DESC)\n   129→    `);\n   130→\n   131→    // Webhook events table for idempotency\n   132→    await client.query(`\n   133→      CREATE TABLE IF NOT EXISTS webhook_events (\n   134→        id SERIAL PRIMARY KEY,\n   135→        event_id VARCHAR(255) UNIQUE NOT NULL,\n   136→        event_type VARCHAR(100),\n   137→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   138→      )\n   139→    `);\n   140→\n   141→    await client.query(`\n   142→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n   143→    `);\n   144→\n   145→    console.log('[UsageTracking] Database initialized');\n   146→  } finally {\n   147→    client.release();\n   148→  }\n   149→}\n   150→\n   151→/**\n   152→ * Get or create a user by Stripe customer ID\n   153→ * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n   154→ */\n   155→async function getOrCreateUser(stripeCustomerId, email = null) {\n   156→  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n   157→  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n   158→  const result = await pool.query(\n   159→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   160→     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   161→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   162→     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n   163→     RETURNING *`,\n   164→    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n   165→  );\n   166→\n   167→  return result.rows[0];\n   168→}\n   169→\n   170→/**\n   171→ * Check if a customer exists in the database (without creating)\n   172→ * SECURITY: Used to validate legacy auth attempts\n   173→ */\n   174→async function customerExists(stripeCustomerId) {\n   175→  if (!stripeCustomerId) return false;\n   176→\n   177→  try {\n   178→    const result = await pool.query(\n   179→      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n   180→      [stripeCustomerId]\n   181→    );\n   182→    return result.rows.length > 0;\n   183→  } catch (err) {\n   184→    console.error('[SPLICE] customerExists check failed:', err.message);\n   185→    return false;\n   186→  }\n   187→}\n   188→\n   189→/**\n   190→ * Get user's current credit balance\n   191→ */\n   192→async function getBalance(stripeCustomerId) {\n   193→  const user = await getOrCreateUser(stripeCustomerId);\n   194→  const hoursTotal = parseFloat(user.hours_total);\n   195→  const hoursRemaining = parseFloat(user.hours_remaining);\n   196→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   197→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   198→\n   199→  // Tier display names\n   200→  const tierNames = {\n   201→    starter: 'Starter',\n   202→    pro: 'Pro',\n   203→    team: 'Team',\n   204→    cancelled: 'Cancelled'\n   205→  };\n   206→\n   207→  // Calculate trial days remaining\n   208→  let trialDaysRemaining = null;\n   209→  let isOnTrial = false;\n   210→  if (user.trial_end) {\n   211→    const trialEnd = new Date(user.trial_end);\n   212→    const now = new Date();\n   213→    const diffMs = trialEnd.getTime() - now.getTime();\n   214→    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n   215→    if (diffDays > 0) {\n   216→      trialDaysRemaining = diffDays;\n   217→      isOnTrial = true;\n   218→    }\n   219→  }\n   220→\n   221→  return {\n   222→    hoursRemaining,\n   223→    hoursTotal,\n   224→    isolationHoursRemaining,\n   225→    isolationHoursTotal,\n   226→    tier: user.tier,\n   227→    tierName: tierNames[user.tier] || user.tier,\n   228→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   229→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   230→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   231→    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   232→    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n   233→    trialDaysRemaining,\n   234→    isOnTrial,\n   235→    email: user.email,\n   236→    emailVerified: user.email_verified === true\n   237→  };\n   238→}\n   239→\n   240→/**\n   241→ * Check if user has enough credits for estimated duration\n   242→ */\n   243→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n   244→  const balance = await getBalance(stripeCustomerId);\n   245→  const estimatedHours = estimatedSeconds / 3600;\n   246→  return balance.hoursRemaining >= estimatedHours;\n   247→}\n   248→\n   249→/**\n   250→ * Reserve credits atomically using SELECT ... FOR UPDATE\n   251→ * This prevents race conditions where multiple requests pass credit check\n   252→ * before any deduction occurs.\n   253→ *\n   254→ * @param {string} stripeCustomerId - Customer ID\n   255→ * @param {number} estimatedSeconds - Estimated processing time in seconds\n   256→ * @param {string} endpoint - Endpoint name for tracking\n   257→ * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n   258→ */\n   259→async function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n   260→  const estimatedHours = estimatedSeconds / 3600;\n   261→  const client = await pool.connect();\n   262→\n   263→  try {\n   264→    await client.query('BEGIN');\n   265→\n   266→    // Lock the row for this customer - prevents concurrent modifications\n   267→    const result = await client.query(\n   268→      `SELECT id, hours_remaining FROM users\n   269→       WHERE stripe_customer_id = $1\n   270→       FOR UPDATE`,\n   271→      [stripeCustomerId]\n   272→    );\n   273→\n   274→    if (result.rows.length === 0) {\n   275→      // Create user if doesn't exist (within transaction)\n   276→      const newUser = await client.query(\n   277→        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n   278→         VALUES ($1, 'starter', $2, $2)\n   279→         RETURNING id, hours_remaining`,\n   280→        [stripeCustomerId, TIER_HOURS.starter]\n   281→      );\n   282→      result.rows = newUser.rows;\n   283→    }\n   284→\n   285→    const user = result.rows[0];\n   286→    const hoursRemaining = parseFloat(user.hours_remaining);\n   287→\n   288→    // Check if enough credits\n   289→    if (hoursRemaining < estimatedHours) {\n   290→      await client.query('ROLLBACK');\n   291→      return {\n   292→        success: false,\n   293→        error: 'Insufficient credits',\n   294→        hoursRemaining,\n   295→        hoursRequired: estimatedHours\n   296→      };\n   297→    }\n   298→\n   299→    // Generate unique reservation ID\n   300→    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   301→\n   302→    // Reserve credits by deducting the estimated amount\n   303→    await client.query(\n   304→      `UPDATE users\n   305→       SET hours_remaining = hours_remaining - $1,\n   306→           updated_at = CURRENT_TIMESTAMP\n   307→       WHERE stripe_customer_id = $2`,\n   308→      [estimatedHours, stripeCustomerId]\n   309→    );\n   310→\n   311→    // Log the reservation\n   312→    await client.query(\n   313→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   314→       VALUES ($1, $2, $3, $4, $5)`,\n   315→      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n   316→    );\n   317→\n   318→    await client.query('COMMIT');\n   319→\n   320→    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n   321→\n   322→    return {\n   323→      success: true,\n   324→      reservationId,\n   325→      hoursReserved: estimatedHours,\n   326→      hoursRemaining: hoursRemaining - estimatedHours\n   327→    };\n   328→  } catch (err) {\n   329→    await client.query('ROLLBACK');\n   330→    console.error('[UsageTracking] Reservation error:', err);\n   331→    throw err;\n   332→  } finally {\n   333→    client.release();\n   334→  }\n   335→}\n   336→\n   337→/**\n   338→ * Confirm a reservation (finalize usage) or adjust for actual duration\n   339→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   340→ *\n   341→ * @param {string} stripeCustomerId - Customer ID\n   342→ * @param {number} actualSeconds - Actual processing time in seconds\n   343→ * @param {number} reservedSeconds - Originally reserved seconds\n   344→ * @param {string} endpoint - Endpoint name\n   345→ * @returns {Promise<object>} Updated balance\n   346→ */\n   347→async function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n   348→  const actualHours = actualSeconds / 3600;\n   349→  const reservedHours = reservedSeconds / 3600;\n   350→  const difference = reservedHours - actualHours;\n   351→\n   352→  const client = await pool.connect();\n   353→  try {\n   354→    await client.query('BEGIN');\n   355→\n   356→    // Lock the row and get current state\n   357→    const result = await client.query(\n   358→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   359→       FROM users\n   360→       WHERE stripe_customer_id = $1\n   361→       FOR UPDATE`,\n   362→      [stripeCustomerId]\n   363→    );\n   364→\n   365→    if (result.rows.length === 0) {\n   366→      await client.query('ROLLBACK');\n   367→      throw new Error('User not found');\n   368→    }\n   369→\n   370→    let user = result.rows[0];\n   371→\n   372→    // If actual usage was less than reserved, refund the difference\n   373→    if (difference > 0) {\n   374→      const updateResult = await client.query(\n   375→        `UPDATE users\n   376→         SET hours_remaining = hours_remaining + $1,\n   377→             updated_at = CURRENT_TIMESTAMP\n   378→         WHERE stripe_customer_id = $2\n   379→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   380→        [difference, stripeCustomerId]\n   381→      );\n   382→      user = { ...user, ...updateResult.rows[0] };\n   383→\n   384→      // Log the adjustment\n   385→      await client.query(\n   386→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   387→         VALUES ($1, $2, $3, $4, $5)`,\n   388→        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n   389→      );\n   390→    } else if (difference < 0) {\n   391→      // Actual usage was more than reserved - deduct the extra\n   392→      const updateResult = await client.query(\n   393→        `UPDATE users\n   394→         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   395→             updated_at = CURRENT_TIMESTAMP\n   396→         WHERE stripe_customer_id = $2\n   397→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   398→        [-difference, stripeCustomerId]\n   399→      );\n   400→      user = { ...user, ...updateResult.rows[0] };\n   401→\n   402→      // Log the additional usage\n   403→      await client.query(\n   404→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   405→         VALUES ($1, $2, $3, $4, $5)`,\n   406→        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n   407→      );\n   408→    }\n   409→\n   410→    await client.query('COMMIT');\n   411→\n   412→    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n   413→\n   414→    // Build balance from data we already have (no extra SELECT needed)\n   415→    const hoursTotal = parseFloat(user.hours_total);\n   416→    const hoursRemaining = parseFloat(user.hours_remaining);\n   417→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   418→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   419→\n   420→    const tierNames = {\n   421→      starter: 'Starter',\n   422→      pro: 'Pro',\n   423→      team: 'Team',\n   424→      cancelled: 'Cancelled'\n   425→    };\n   426→\n   427→    return {\n   428→      hoursRemaining,\n   429→      hoursTotal,\n   430→      isolationHoursRemaining,\n   431→      isolationHoursTotal,\n   432→      tier: user.tier,\n   433→      tierName: tierNames[user.tier] || user.tier,\n   434→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   435→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   436→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   437→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   438→    };\n   439→  } catch (err) {\n   440→    await client.query('ROLLBACK');\n   441→    throw err;\n   442→  } finally {\n   443→    client.release();\n   444→  }\n   445→}\n   446→\n   447→/**\n   448→ * Release a reservation (refund credits on processing failure)\n   449→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   450→ *\n   451→ * @param {string} stripeCustomerId - Customer ID\n   452→ * @param {number} reservedSeconds - Originally reserved seconds\n   453→ * @param {string} endpoint - Endpoint name\n   454→ * @param {string} reason - Reason for release\n   455→ * @returns {Promise<object>} Updated balance\n   456→ */\n   457→async function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n   458→  const reservedHours = reservedSeconds / 3600;\n   459→\n   460→  const client = await pool.connect();\n   461→  try {\n   462→    await client.query('BEGIN');\n   463→\n   464→    // Lock the row and get id for logging\n   465→    const result = await client.query(\n   466→      `SELECT id FROM users\n   467→       WHERE stripe_customer_id = $1\n   468→       FOR UPDATE`,\n   469→      [stripeCustomerId]\n   470→    );\n   471→\n   472→    if (result.rows.length === 0) {\n   473→      await client.query('ROLLBACK');\n   474→      throw new Error('User not found');\n   475→    }\n   476→\n   477→    const userId = result.rows[0].id;\n   478→\n   479→    // Refund the reserved amount with RETURNING\n   480→    const updateResult = await client.query(\n   481→      `UPDATE users\n   482→       SET hours_remaining = hours_remaining + $1,\n   483→           updated_at = CURRENT_TIMESTAMP\n   484→       WHERE stripe_customer_id = $2\n   485→       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   486→      [reservedHours, stripeCustomerId]\n   487→    );\n   488→\n   489→    const user = updateResult.rows[0];\n   490→\n   491→    // Log the refund\n   492→    await client.query(\n   493→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   494→       VALUES ($1, $2, $3, $4, $5)`,\n   495→      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n   496→    );\n   497→\n   498→    await client.query('COMMIT');\n   499→\n   500→    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n   501→\n   502→    // Build balance from RETURNING data (no extra SELECT needed)\n   503→    const hoursTotal = parseFloat(user.hours_total);\n   504→    const hoursRemaining = parseFloat(user.hours_remaining);\n   505→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   506→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   507→\n   508→    const tierNames = {\n   509→      starter: 'Starter',\n   510→      pro: 'Pro',\n   511→      team: 'Team',\n   512→      cancelled: 'Cancelled'\n   513→    };\n   514→\n   515→    return {\n   516→      hoursRemaining,\n   517→      hoursTotal,\n   518→      isolationHoursRemaining,\n   519→      isolationHoursTotal,\n   520→      tier: user.tier,\n   521→      tierName: tierNames[user.tier] || user.tier,\n   522→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   523→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   524→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   525→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   526→    };\n   527→  } catch (err) {\n   528→    await client.query('ROLLBACK');\n   529→    throw err;\n   530→  } finally {\n   531→    client.release();\n   532→  }\n   533→}\n   534→\n   535→/**\n   536→ * Check if user can use vocal isolation\n   537→ * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n   538→ */\n   539→async function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n   540→  const balance = await getBalance(stripeCustomerId);\n   541→\n   542→  // Starter tier has no isolation access\n   543→  if (!balance.hasIsolationAccess) {\n   544→    return {\n   545→      allowed: false,\n   546→      reason: 'upgrade_required',\n   547→      message: 'Vocal isolation requires Pro or Team tier',\n   548→      hasIncludedHours: false,\n   549→      overageRequired: false,\n   550→      overageCost: 0\n   551→    };\n   552→  }\n   553→\n   554→  const estimatedHours = estimatedMinutes / 60;\n   555→  const remainingIncluded = balance.isolationHoursRemaining;\n   556→\n   557→  // Check if within included hours\n   558→  if (remainingIncluded >= estimatedHours) {\n   559→    return {\n   560→      allowed: true,\n   561→      reason: 'included',\n   562→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   563→      hasIncludedHours: true,\n   564→      overageRequired: false,\n   565→      overageCost: 0,\n   566→      isolationHoursRemaining: remainingIncluded - estimatedHours\n   567→    };\n   568→  }\n   569→\n   570→  // Calculate overage\n   571→  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n   572→  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   573→\n   574→  return {\n   575→    allowed: true,\n   576→    reason: 'overage',\n   577→    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n   578→    hasIncludedHours: remainingIncluded > 0,\n   579→    overageRequired: true,\n   580→    overageMinutes,\n   581→    overageCost,\n   582→    isolationHoursRemaining: 0\n   583→  };\n   584→}\n   585→\n   586→/**\n   587→ * Deduct isolation usage from user's balance\n   588→ * Returns overage cost if beyond included hours\n   589→ * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n   590→ */\n   591→async function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n   592→  const durationMinutes = audioDurationSeconds / 60;\n   593→  const durationHours = audioDurationSeconds / 3600;\n   594→\n   595→  const client = await pool.connect();\n   596→  try {\n   597→    await client.query('BEGIN');\n   598→\n   599→    // Lock the row for this customer - prevents concurrent modifications\n   600→    const userResult = await client.query(\n   601→      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n   602→       FROM users WHERE stripe_customer_id = $1\n   603→       FOR UPDATE`,\n   604→      [stripeCustomerId]\n   605→    );\n   606→\n   607→    if (userResult.rows.length === 0) {\n   608→      await client.query('ROLLBACK');\n   609→      throw new Error('User not found');\n   610→    }\n   611→\n   612→    const user = userResult.rows[0];\n   613→    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n   614→\n   615→    let overageCost = 0;\n   616→    let hoursFromIncluded = 0;\n   617→    let overageMinutes = 0;\n   618→\n   619→    if (remainingIncluded >= durationHours) {\n   620→      // Fully covered by included hours\n   621→      hoursFromIncluded = durationHours;\n   622→    } else {\n   623→      // Partial or full overage\n   624→      hoursFromIncluded = remainingIncluded;\n   625→      overageMinutes = durationMinutes - (remainingIncluded * 60);\n   626→      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   627→    }\n   628→\n   629→    // Update isolation balance with RETURNING to get new values\n   630→    const updateResult = await client.query(\n   631→      `UPDATE users\n   632→       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n   633→           updated_at = CURRENT_TIMESTAMP\n   634→       WHERE stripe_customer_id = $2\n   635→       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n   636→      [durationHours, stripeCustomerId]\n   637→    );\n   638→\n   639→    const updatedUser = updateResult.rows[0];\n   640→\n   641→    // Log usage (mark as isolation)\n   642→    await client.query(\n   643→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   644→       VALUES ($1, $2, $3, $4, $5)`,\n   645→      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n   646→    );\n   647→\n   648→    await client.query('COMMIT');\n   649→\n   650→    // Build balance from RETURNING data (no extra SELECT needed)\n   651→    const hoursTotal = parseFloat(updatedUser.hours_total);\n   652→    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n   653→    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n   654→    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n   655→\n   656→    const tierNames = {\n   657→      starter: 'Starter',\n   658→      pro: 'Pro',\n   659→      team: 'Team',\n   660→      cancelled: 'Cancelled'\n   661→    };\n   662→\n   663→    return {\n   664→      hoursRemaining,\n   665→      hoursTotal,\n   666→      isolationHoursRemaining,\n   667→      isolationHoursTotal,\n   668→      tier: updatedUser.tier,\n   669→      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n   670→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   671→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   672→      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n   673→      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   674→      isolationUsed: {\n   675→        durationMinutes,\n   676→        hoursFromIncluded,\n   677→        overageMinutes,\n   678→        overageCost\n   679→      }\n   680→    };\n   681→  } catch (err) {\n   682→    await client.query('ROLLBACK');\n   683→    throw err;\n   684→  } finally {\n   685→    client.release();\n   686→  }\n   687→}\n   688→\n   689→/**\n   690→ * Deduct usage from user's balance\n   691→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   692→ * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n   693→ * Reports overage to Stripe for billing when user exceeds included hours\n   694→ */\n   695→async function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n   696→  const hoursUsed = audioDurationSeconds / 3600;\n   697→\n   698→  const client = await pool.connect();\n   699→  try {\n   700→    await client.query('BEGIN');\n   701→\n   702→    // First get current balance to calculate overage\n   703→    const currentResult = await client.query(\n   704→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   705→       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n   706→      [stripeCustomerId]\n   707→    );\n   708→\n   709→    if (currentResult.rows.length === 0) {\n   710→      await client.query('ROLLBACK');\n   711→      throw new Error('User not found');\n   712→    }\n   713→\n   714→    const currentUser = currentResult.rows[0];\n   715→    const currentRemaining = parseFloat(currentUser.hours_remaining);\n   716→\n   717→    // Calculate overage (hours used beyond what's remaining)\n   718→    let overageHours = 0;\n   719→    if (hoursUsed > currentRemaining) {\n   720→      overageHours = hoursUsed - currentRemaining;\n   721→    }\n   722→\n   723→    // Update balance (clamp at 0)\n   724→    const updateResult = await client.query(\n   725→      `UPDATE users\n   726→       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   727→           updated_at = CURRENT_TIMESTAMP\n   728→       WHERE stripe_customer_id = $2\n   729→       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   730→      [hoursUsed, stripeCustomerId]\n   731→    );\n   732→\n   733→    const user = updateResult.rows[0];\n   734→\n   735→    // Log usage\n   736→    await client.query(\n   737→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   738→       VALUES ($1, $2, $3, $4, $5)`,\n   739→      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n   740→    );\n   741→\n   742→    await client.query('COMMIT');\n   743→\n   744→    // Report overage to Stripe if any (after commit to not block transaction)\n   745→    let overageCharge = 0;\n   746→    if (overageHours > 0) {\n   747→      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n   748→      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n   749→      if (usageReport.success) {\n   750→        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n   751→      } else {\n   752→        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n   753→      }\n   754→    }\n   755→\n   756→    // Build balance from RETURNING data (no extra SELECT needed)\n   757→    const hoursTotal = parseFloat(user.hours_total);\n   758→    const hoursRemaining = parseFloat(user.hours_remaining);\n   759→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   760→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   761→\n   762→    const tierNames = {\n   763→      starter: 'Starter',\n   764→      pro: 'Pro',\n   765→      team: 'Team',\n   766→      cancelled: 'Cancelled'\n   767→    };\n   768→\n   769→    return {\n   770→      hoursRemaining,\n   771→      hoursTotal,\n   772→      isolationHoursRemaining,\n   773→      isolationHoursTotal,\n   774→      tier: user.tier,\n   775→      tierName: tierNames[user.tier] || user.tier,\n   776→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   777→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   778→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   779→      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   780→      overageHours,\n   781→      overageCharge\n   782→    };\n   783→  } catch (err) {\n   784→    await client.query('ROLLBACK');\n   785→    throw err;\n   786→  } finally {\n   787→    client.release();\n   788→  }\n   789→}\n   790→\n   791→/**\n   792→ * Reset user's hours for new billing period\n   793→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   794→ */\n   795→async function resetHours(stripeCustomerId, tier) {\n   796→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   797→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   798→\n   799→  const result = await pool.query(\n   800→    `UPDATE users\n   801→     SET hours_remaining = $1, hours_total = $1,\n   802→         isolation_hours_remaining = $2, isolation_hours_total = $2,\n   803→         tier = $3, updated_at = CURRENT_TIMESTAMP\n   804→     WHERE stripe_customer_id = $4\n   805→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   806→    [hours, isolationHours, tier, stripeCustomerId]\n   807→  );\n   808→\n   809→  if (result.rows.length === 0) {\n   810→    // User doesn't exist, create and return default balance\n   811→    return await getBalance(stripeCustomerId);\n   812→  }\n   813→\n   814→  const user = result.rows[0];\n   815→  const hoursTotal = parseFloat(user.hours_total);\n   816→  const hoursRemaining = parseFloat(user.hours_remaining);\n   817→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   818→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   819→\n   820→  const tierNames = {\n   821→    starter: 'Starter',\n   822→    pro: 'Pro',\n   823→    team: 'Team',\n   824→    cancelled: 'Cancelled'\n   825→  };\n   826→\n   827→  return {\n   828→    hoursRemaining,\n   829→    hoursTotal,\n   830→    isolationHoursRemaining,\n   831→    isolationHoursTotal,\n   832→    tier: user.tier,\n   833→    tierName: tierNames[user.tier] || user.tier,\n   834→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   835→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   836→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   837→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   838→  };\n   839→}\n   840→\n   841→/**\n   842→ * Update user's tier (from Stripe webhook)\n   843→ * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n   844→ */\n   845→async function updateTier(stripeCustomerId, tier, email = null) {\n   846→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   847→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   848→\n   849→  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n   850→  const result = await pool.query(\n   851→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   852→     VALUES ($1, $2, $3, $4, $4, $5, $5)\n   853→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   854→     SET tier = $3, hours_remaining = $4, hours_total = $4,\n   855→         isolation_hours_remaining = $5, isolation_hours_total = $5,\n   856→         updated_at = CURRENT_TIMESTAMP\n   857→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   858→    [stripeCustomerId, email, tier, hours, isolationHours]\n   859→  );\n   860→\n   861→  const user = result.rows[0];\n   862→  const hoursTotal = parseFloat(user.hours_total);\n   863→  const hoursRemaining = parseFloat(user.hours_remaining);\n   864→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   865→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   866→\n   867→  const tierNames = {\n   868→    starter: 'Starter',\n   869→    pro: 'Pro',\n   870→    team: 'Team',\n   871→    cancelled: 'Cancelled'\n   872→  };\n   873→\n   874→  return {\n   875→    hoursRemaining,\n   876→    hoursTotal,\n   877→    isolationHoursRemaining,\n   878→    isolationHoursTotal,\n   879→    tier: user.tier,\n   880→    tierName: tierNames[user.tier] || user.tier,\n   881→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   882→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   883→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   884→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   885→  };\n   886→}\n   887→\n   888→/**\n   889→ * Get usage history for a user\n   890→ */\n   891→async function getUsageHistory(stripeCustomerId, limit = 50) {\n   892→  const result = await pool.query(\n   893→    `SELECT * FROM usage_log\n   894→     WHERE stripe_customer_id = $1\n   895→     ORDER BY created_at DESC\n   896→     LIMIT $2`,\n   897→    [stripeCustomerId, limit]\n   898→  );\n   899→  return result.rows;\n   900→}\n   901→\n   902→/**\n   903→ * Check if webhook event has already been processed (idempotency)\n   904→ */\n   905→async function isEventProcessed(eventId) {\n   906→  const result = await pool.query(\n   907→    'SELECT id FROM webhook_events WHERE event_id = $1',\n   908→    [eventId]\n   909→  );\n   910→  return result.rows.length > 0;\n   911→}\n   912→\n   913→/**\n   914→ * Record a processed webhook event\n   915→ */\n   916→async function recordWebhookEvent(eventId, eventType) {\n   917→  try {\n   918→    await pool.query(\n   919→      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n   920→      [eventId, eventType]\n   921→    );\n   922→  } catch (err) {\n   923→    // Ignore duplicate key errors (race condition safety)\n   924→    if (err.code !== '23505') throw err;\n   925→  }\n   926→}\n   927→\n   928→// =============================================================================\n   929→// Music Credits Functions (Phase 4 - AI Music Feature)\n   930→// =============================================================================\n   931→\n   932→// Music credits per tier\n   933→// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n   934→const TIER_MUSIC_CREDITS = {\n   935→  starter: 2,    // 2 songs/month\n   936→  pro: 10,       // 10 songs/month\n   937→  team: 50,      // 50 songs/month\n   938→  cancelled: 0\n   939→};\n   940→\n   941→// Feature access by tier - defines which features each tier can use\n   942→const TIER_FEATURES = {\n   943→  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n   944→  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n   945→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n   946→    'profanity_detection', 'chapter_detection'],\n   947→  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n   948→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n   949→    'profanity_detection', 'chapter_detection', 'multitrack',\n   950→    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n   951→  cancelled: []\n   952→};\n   953→\n   954→/**\n   955→ * Check if a tier has access to a specific feature\n   956→ * @param {string} tier - User's tier (starter, pro, team)\n   957→ * @param {string} feature - Feature name to check\n   958→ * @returns {boolean}\n   959→ */\n   960→function hasFeatureAccess(tier, feature) {\n   961→  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n   962→  return tierFeatures.includes(feature);\n   963→}\n   964→\n   965→// Flat overage rate for music (simplified pricing)\n   966→const MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n   967→\n   968→// Legacy overage rates (kept for backwards compatibility)\n   969→const MUSIC_OVERAGE_RATES = {\n   970→  starter: 1.00,  // $1.00/song\n   971→  pro: 1.00,      // $1.00/song\n   972→  team: 1.00      // $1.00/song\n   973→};\n   974→\n   975→/**\n   976→ * Get music credits balance for a customer\n   977→ * @param {string} stripeCustomerId - Stripe customer ID\n   978→ * @returns {Promise<{remaining: number, total: number, tier: string}>}\n   979→ */\n   980→async function getMusicCredits(stripeCustomerId) {\n   981→  const result = await pool.query(\n   982→    `SELECT music_credits_remaining, music_credits_total, tier\n   983→     FROM users\n   984→     WHERE stripe_customer_id = $1`,\n   985→    [stripeCustomerId]\n   986→  );\n   987→\n   988→  if (result.rows.length === 0) {\n   989→    return { remaining: 0, total: 0, tier: 'starter' };\n   990→  }\n   991→\n   992→  const row = result.rows[0];\n   993→  return {\n   994→    remaining: row.music_credits_remaining || 0,\n   995→    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n   996→    tier: row.tier || 'starter'\n   997→  };\n   998→}\n   999→\n  1000→/**\n  1001→ * Check if customer has music credits available\n  1002→ * @param {string} stripeCustomerId - Stripe customer ID\n  1003→ * @returns {Promise<boolean>}\n  1004→ */\n  1005→async function hasMusicCredits(stripeCustomerId) {\n  1006→  const credits = await getMusicCredits(stripeCustomerId);\n  1007→  return credits.remaining > 0;\n  1008→}\n  1009→\n  1010→/**\n  1011→ * Deduct one music credit from customer\n  1012→ * @param {string} stripeCustomerId - Stripe customer ID\n  1013→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1014→ */\n  1015→async function deductMusicCredit(stripeCustomerId) {\n  1016→  const client = await pool.connect();\n  1017→  try {\n  1018→    await client.query('BEGIN');\n  1019→\n  1020→    // Lock row for update\n  1021→    const result = await client.query(\n  1022→      `SELECT music_credits_remaining, tier\n  1023→       FROM users\n  1024→       WHERE stripe_customer_id = $1\n  1025→       FOR UPDATE`,\n  1026→      [stripeCustomerId]\n  1027→    );\n  1028→\n  1029→    if (result.rows.length === 0) {\n  1030→      await client.query('ROLLBACK');\n  1031→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1032→    }\n  1033→\n  1034→    const { music_credits_remaining } = result.rows[0];\n  1035→    let charged = 0;\n  1036→\n  1037→    if (music_credits_remaining > 0) {\n  1038→      // Deduct from included credits\n  1039→      await client.query(\n  1040→        `UPDATE users\n  1041→         SET music_credits_remaining = music_credits_remaining - 1,\n  1042→             updated_at = CURRENT_TIMESTAMP\n  1043→         WHERE stripe_customer_id = $1`,\n  1044→        [stripeCustomerId]\n  1045→      );\n  1046→    } else {\n  1047→      // Overage - charge flat rate ($1/song)\n  1048→      charged = MUSIC_OVERAGE_RATE;\n  1049→\n  1050→      // Report overage to Stripe meter for billing\n  1051→      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n  1052→      if (usageReport.success) {\n  1053→        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n  1054→      } else {\n  1055→        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n  1056→      }\n  1057→    }\n  1058→\n  1059→    // Log the usage\n  1060→    await client.query(\n  1061→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1062→       VALUES ($1, 1, $2)\n  1063→       ON CONFLICT DO NOTHING`,\n  1064→      [stripeCustomerId, charged]\n  1065→    );\n  1066→\n  1067→    await client.query('COMMIT');\n  1068→\n  1069→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1070→    return {\n  1071→      success: true,\n  1072→      remaining: newCredits.remaining,\n  1073→      charged\n  1074→    };\n  1075→\n  1076→  } catch (err) {\n  1077→    await client.query('ROLLBACK');\n  1078→    console.error('[SPLICE] Music credit deduction error:', err.message);\n  1079→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1080→  } finally {\n  1081→    client.release();\n  1082→  }\n  1083→}\n  1084→\n  1085→/**\n  1086→ * Reset music credits based on tier (called on subscription renewal)\n  1087→ * @param {string} stripeCustomerId - Stripe customer ID\n  1088→ * @param {string} tier - Subscription tier\n  1089→ */\n  1090→async function resetMusicCredits(stripeCustomerId, tier) {\n  1091→  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  1092→  const client = await pool.connect();\n  1093→\n  1094→  try {\n  1095→    await client.query('BEGIN');\n  1096→\n  1097→    // Lock row for update to prevent race conditions\n  1098→    const result = await client.query(\n  1099→      `SELECT id FROM users\n  1100→       WHERE stripe_customer_id = $1\n  1101→       FOR UPDATE`,\n  1102→      [stripeCustomerId]\n  1103→    );\n  1104→\n  1105→    if (result.rows.length === 0) {\n  1106→      await client.query('ROLLBACK');\n  1107→      console.warn(`[SPLICE] resetMusicCredits: User not found for ${stripeCustomerId}`);\n  1108→      return;\n  1109→    }\n  1110→\n  1111→    await client.query(\n  1112→      `UPDATE users\n  1113→       SET music_credits_remaining = $2,\n  1114→           music_credits_total = $2,\n  1115→           music_credits_reset_at = CURRENT_TIMESTAMP,\n  1116→           updated_at = CURRENT_TIMESTAMP\n  1117→       WHERE stripe_customer_id = $1`,\n  1118→      [stripeCustomerId, credits]\n  1119→    );\n  1120→\n  1121→    await client.query('COMMIT');\n  1122→  } catch (err) {\n  1123→    await client.query('ROLLBACK');\n  1124→    console.error('[SPLICE] Music credit reset error:', err.message);\n  1125→    throw err;\n  1126→  } finally {\n  1127→    client.release();\n  1128→  }\n  1129→}\n  1130→\n  1131→/**\n  1132→ * Add music credits (for promotional or overage purchases)\n  1133→ * @param {string} stripeCustomerId - Stripe customer ID\n  1134→ * @param {number} credits - Number of credits to add\n  1135→ * @returns {Promise<{success: boolean, newBalance: number}>}\n  1136→ */\n  1137→async function addMusicCredits(stripeCustomerId, credits) {\n  1138→  const client = await pool.connect();\n  1139→  try {\n  1140→    await client.query('BEGIN');\n  1141→\n  1142→    // Lock row for update to prevent concurrent modification\n  1143→    const lockResult = await client.query(\n  1144→      `SELECT music_credits_remaining\n  1145→       FROM users\n  1146→       WHERE stripe_customer_id = $1\n  1147→       FOR UPDATE`,\n  1148→      [stripeCustomerId]\n  1149→    );\n  1150→\n  1151→    if (lockResult.rows.length === 0) {\n  1152→      await client.query('ROLLBACK');\n  1153→      return { success: false, newBalance: 0, error: 'User not found' };\n  1154→    }\n  1155→\n  1156→    // Update the credits\n  1157→    const result = await client.query(\n  1158→      `UPDATE users\n  1159→       SET music_credits_remaining = music_credits_remaining + $2,\n  1160→           updated_at = CURRENT_TIMESTAMP\n  1161→       WHERE stripe_customer_id = $1\n  1162→       RETURNING music_credits_remaining`,\n  1163→      [stripeCustomerId, credits]\n  1164→    );\n  1165→\n  1166→    await client.query('COMMIT');\n  1167→\n  1168→    return {\n  1169→      success: true,\n  1170→      newBalance: result.rows[0].music_credits_remaining\n  1171→    };\n  1172→\n  1173→  } catch (err) {\n  1174→    await client.query('ROLLBACK');\n  1175→    console.error('[SPLICE] Music credit addition error:', err.message);\n  1176→    return { success: false, newBalance: 0, error: err.message };\n  1177→  } finally {\n  1178→    client.release();\n  1179→  }\n  1180→}\n  1181→\n  1182→/**\n  1183→ * Get music usage history for a customer\n  1184→ * @param {string} stripeCustomerId - Stripe customer ID\n  1185→ * @param {number} limit - Max records to return\n  1186→ * @returns {Promise<Object[]>}\n  1187→ */\n  1188→async function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  1189→  const result = await pool.query(\n  1190→    `SELECT * FROM music_usage_log\n  1191→     WHERE stripe_customer_id = $1\n  1192→     ORDER BY created_at DESC\n  1193→     LIMIT $2`,\n  1194→    [stripeCustomerId, limit]\n  1195→  );\n  1196→  return result.rows;\n  1197→}\n  1198→\n  1199→/**\n  1200→ * Initialize music credits columns (migration helper)\n  1201→ */\n  1202→async function initMusicCreditsColumns() {\n  1203→  const client = await pool.connect();\n  1204→  try {\n  1205→    // Add music credits columns if they don't exist\n  1206→    await client.query(`\n  1207→      DO $$\n  1208→      BEGIN\n  1209→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n  1210→          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n  1211→        END IF;\n  1212→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n  1213→          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n  1214→        END IF;\n  1215→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n  1216→          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n  1217→        END IF;\n  1218→      END $$;\n  1219→    `);\n  1220→\n  1221→    // Create music usage log table\n  1222→    await client.query(`\n  1223→      CREATE TABLE IF NOT EXISTS music_usage_log (\n  1224→        id SERIAL PRIMARY KEY,\n  1225→        stripe_customer_id VARCHAR(255) NOT NULL,\n  1226→        credits_used INTEGER DEFAULT 1,\n  1227→        overage_charged DECIMAL(10,2) DEFAULT 0,\n  1228→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n  1229→      )\n  1230→    `);\n  1231→\n  1232→    await client.query(`\n  1233→      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n  1234→      ON music_usage_log(stripe_customer_id)\n  1235→    `);\n  1236→\n  1237→    console.log('[SPLICE] Music credits columns initialized');\n  1238→  } finally {\n  1239→    client.release();\n  1240→  }\n  1241→}\n  1242→\n  1243→// Variations credits cost (equivalent to 2.5 music credits)\n  1244→const VARIATIONS_CREDIT_COST = 2.5;\n  1245→\n  1246→// Overage rates for variations (higher than single music due to 3 parallel generations)\n  1247→const VARIATIONS_OVERAGE_RATES = {\n  1248→  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  1249→  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  1250→  team: 0.50      // $0.50/variations (2.5x $0.20)\n  1251→};\n  1252→\n  1253→// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\n  1254→const SCENE_AWARE_CREDIT_COST = 1.5;\n  1255→\n  1256→// Overage rates for scene-aware music (75% margin)\n  1257→const SCENE_AWARE_OVERAGE_RATES = {\n  1258→  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  1259→  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  1260→  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n  1261→};\n  1262→\n  1263→/**\n  1264→ * Check if customer has enough credits for variations (2.5 credits)\n  1265→ * @param {string} stripeCustomerId - Stripe customer ID\n  1266→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1267→ */\n  1268→async function checkVariationsCredits(stripeCustomerId) {\n  1269→  const credits = await getMusicCredits(stripeCustomerId);\n  1270→  const creditsRequired = VARIATIONS_CREDIT_COST;\n  1271→\n  1272→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1273→  // Or if they're on a paid tier (overage allowed)\n  1274→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1275→\n  1276→  return {\n  1277→    canGenerate,\n  1278→    creditsAvailable: credits.remaining,\n  1279→    creditsRequired,\n  1280→    tier: credits.tier\n  1281→  };\n  1282→}\n  1283→\n  1284→/**\n  1285→ * Deduct variations credit from customer (2.5 credits worth)\n  1286→ * @param {string} stripeCustomerId - Stripe customer ID\n  1287→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1288→ */\n  1289→async function deductVariationsCredit(stripeCustomerId) {\n  1290→  const client = await pool.connect();\n  1291→  try {\n  1292→    await client.query('BEGIN');\n  1293→\n  1294→    // Lock row for update\n  1295→    const result = await client.query(\n  1296→      `SELECT music_credits_remaining, tier\n  1297→       FROM users\n  1298→       WHERE stripe_customer_id = $1\n  1299→       FOR UPDATE`,\n  1300→      [stripeCustomerId]\n  1301→    );\n  1302→\n  1303→    if (result.rows.length === 0) {\n  1304→      await client.query('ROLLBACK');\n  1305→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1306→    }\n  1307→\n  1308→    const { music_credits_remaining, tier } = result.rows[0];\n  1309→    let charged = 0;\n  1310→    let creditsDeducted = 0;\n  1311→\n  1312→    // Determine how many credits to deduct vs overage to charge\n  1313→    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n  1314→      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n  1315→      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n  1316→      await client.query(\n  1317→        `UPDATE users\n  1318→         SET music_credits_remaining = music_credits_remaining - $2,\n  1319→             updated_at = CURRENT_TIMESTAMP\n  1320→         WHERE stripe_customer_id = $1`,\n  1321→        [stripeCustomerId, creditsDeducted]\n  1322→      );\n  1323→    } else if (music_credits_remaining > 0) {\n  1324→      // Partial credits - deduct what they have and charge overage for the rest\n  1325→      const creditsPortion = music_credits_remaining;\n  1326→      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n  1327→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1328→      charged = overagePortion * overageRate;\n  1329→\n  1330→      creditsDeducted = creditsPortion;\n  1331→      await client.query(\n  1332→        `UPDATE users\n  1333→         SET music_credits_remaining = 0,\n  1334→             updated_at = CURRENT_TIMESTAMP\n  1335→         WHERE stripe_customer_id = $1`,\n  1336→        [stripeCustomerId]\n  1337→      );\n  1338→\n  1339→      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1340→    } else {\n  1341→      // No credits - full overage\n  1342→      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n  1343→      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1344→    }\n  1345→\n  1346→    // Log the usage\n  1347→    await client.query(\n  1348→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1349→       VALUES ($1, $2, $3)\n  1350→       ON CONFLICT DO NOTHING`,\n  1351→      [stripeCustomerId, creditsDeducted, charged]\n  1352→    );\n  1353→\n  1354→    await client.query('COMMIT');\n  1355→\n  1356→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1357→    return {\n  1358→      success: true,\n  1359→      remaining: newCredits.remaining,\n  1360→      creditsDeducted,\n  1361→      charged\n  1362→    };\n  1363→\n  1364→  } catch (err) {\n  1365→    await client.query('ROLLBACK');\n  1366→    console.error('[SPLICE] Variations credit deduction error:', err.message);\n  1367→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1368→  } finally {\n  1369→    client.release();\n  1370→  }\n  1371→}\n  1372→\n  1373→/**\n  1374→ * Check if customer has enough credits for scene-aware music (1.5 credits)\n  1375→ * @param {string} stripeCustomerId - Stripe customer ID\n  1376→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1377→ */\n  1378→async function checkSceneAwareCredits(stripeCustomerId) {\n  1379→  const credits = await getMusicCredits(stripeCustomerId);\n  1380→  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n  1381→\n  1382→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1383→  // Or if they're on a paid tier (overage allowed)\n  1384→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1385→\n  1386→  return {\n  1387→    canGenerate,\n  1388→    creditsAvailable: credits.remaining,\n  1389→    creditsRequired,\n  1390→    tier: credits.tier\n  1391→  };\n  1392→}\n  1393→\n  1394→/**\n  1395→ * Deduct scene-aware music credit from customer (1.5 credits worth)\n  1396→ * @param {string} stripeCustomerId - Stripe customer ID\n  1397→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1398→ */\n  1399→async function deductSceneAwareCredit(stripeCustomerId) {\n  1400→  const client = await pool.connect();\n  1401→  try {\n  1402→    await client.query('BEGIN');\n  1403→\n  1404→    // Lock row for update\n  1405→    const result = await client.query(\n  1406→      `SELECT music_credits_remaining, tier\n  1407→       FROM users\n  1408→       WHERE stripe_customer_id = $1\n  1409→       FOR UPDATE`,\n  1410→      [stripeCustomerId]\n  1411→    );\n  1412→\n  1413→    if (result.rows.length === 0) {\n  1414→      await client.query('ROLLBACK');\n  1415→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1416→    }\n  1417→\n  1418→    const { music_credits_remaining, tier } = result.rows[0];\n  1419→    let charged = 0;\n  1420→    let creditsDeducted = 0;\n  1421→\n  1422→    // Determine how many credits to deduct vs overage to charge\n  1423→    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n  1424→      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n  1425→      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n  1426→      await client.query(\n  1427→        `UPDATE users\n  1428→         SET music_credits_remaining = music_credits_remaining - $2,\n  1429→             updated_at = CURRENT_TIMESTAMP\n  1430→         WHERE stripe_customer_id = $1`,\n  1431→        [stripeCustomerId, creditsDeducted]\n  1432→      );\n  1433→    } else if (music_credits_remaining > 0) {\n  1434→      // Partial credits - deduct what they have and charge overage for the rest\n  1435→      const creditsPortion = music_credits_remaining;\n  1436→      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n  1437→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1438→      charged = overagePortion * overageRate;\n  1439→\n  1440→      creditsDeducted = creditsPortion;\n  1441→      await client.query(\n  1442→        `UPDATE users\n  1443→         SET music_credits_remaining = 0,\n  1444→             updated_at = CURRENT_TIMESTAMP\n  1445→         WHERE stripe_customer_id = $1`,\n  1446→        [stripeCustomerId]\n  1447→      );\n  1448→\n  1449→      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1450→    } else {\n  1451→      // No credits - full overage\n  1452→      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n  1453→      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1454→    }\n  1455→\n  1456→    // Log the usage\n  1457→    await client.query(\n  1458→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1459→       VALUES ($1, $2, $3)\n  1460→       ON CONFLICT DO NOTHING`,\n  1461→      [stripeCustomerId, creditsDeducted, charged]\n  1462→    );\n  1463→\n  1464→    await client.query('COMMIT');\n  1465→\n  1466→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1467→    return {\n  1468→      success: true,\n  1469→      remaining: newCredits.remaining,\n  1470→      creditsDeducted,\n  1471→      charged\n  1472→    };\n  1473→\n  1474→  } catch (err) {\n  1475→    await client.query('ROLLBACK');\n  1476→    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n  1477→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1478→  } finally {\n  1479→    client.release();\n  1480→  }\n  1481→}\n  1482→\n  1483→/**\n  1484→ * Close the database connection pool\n  1485→ * Used for graceful shutdown\n  1486→ */\n  1487→async function closePool() {\n  1488→  await pool.end();\n  1489→}\n  1490→\n  1491→/**\n  1492→ * Update trial end date for a customer\n  1493→ * @param {string} stripeCustomerId - Customer ID\n  1494→ * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n  1495→ */\n  1496→async function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  1497→  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n  1498→\n  1499→  await pool.query(\n  1500→    `UPDATE users\n  1501→     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n  1502→     WHERE stripe_customer_id = $1`,\n  1503→    [stripeCustomerId, trialEnd]\n  1504→  );\n  1505→\n  1506→  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n  1507→}\n  1508→\n  1509→/**\n  1510→ * Check database connectivity\n  1511→ * Used for health checks\n  1512→ */\n  1513→async function checkDatabase() {\n  1514→  const client = await pool.connect();\n  1515→  try {\n  1516→    const result = await client.query('SELECT 1 as health');\n  1517→    return result.rows[0].health === 1;\n  1518→  } finally {\n  1519→    client.release();\n  1520→  }\n  1521→}\n  1522→\n  1523→// =============================================================================\n  1524→// Email Verification Functions\n  1525→// =============================================================================\n  1526→\n  1527→/**\n  1528→ * Mark a user's email as verified\n  1529→ * @param {string} email - Email address that was verified\n  1530→ * @returns {Promise<{success: boolean, error?: string}>}\n  1531→ */\n  1532→async function markEmailVerified(email) {\n  1533→  if (!email) {\n  1534→    return { success: false, error: 'Email is required' };\n  1535→  }\n  1536→\n  1537→  const normalizedEmail = email.toLowerCase().trim();\n  1538→\n  1539→  try {\n  1540→    const result = await pool.query(\n  1541→      `UPDATE users\n  1542→       SET email_verified = TRUE,\n  1543→           email_verified_at = CURRENT_TIMESTAMP,\n  1544→           updated_at = CURRENT_TIMESTAMP\n  1545→       WHERE LOWER(email) = $1\n  1546→       RETURNING stripe_customer_id, email_verified`,\n  1547→      [normalizedEmail]\n  1548→    );\n  1549→\n  1550→    if (result.rows.length === 0) {\n  1551→      // No user found with this email - this is OK for new signups\n  1552→      console.log(`[SPLICE] No user found for email verification: ${normalizedEmail}`);\n  1553→      return { success: true, userFound: false };\n  1554→    }\n  1555→\n  1556→    console.log(`[SPLICE] Email verified for user: ${result.rows[0].stripe_customer_id}`);\n  1557→    return { success: true, userFound: true, customerId: result.rows[0].stripe_customer_id };\n  1558→  } catch (err) {\n  1559→    console.error('[SPLICE] markEmailVerified error:', err.message);\n  1560→    return { success: false, error: err.message };\n  1561→  }\n  1562→}\n  1563→\n  1564→/**\n  1565→ * Check if a user's email is verified\n  1566→ * @param {string} stripeCustomerId - Stripe customer ID\n  1567→ * @returns {Promise<{verified: boolean, verifiedAt?: Date}>}\n  1568→ */\n  1569→async function isEmailVerified(stripeCustomerId) {\n  1570→  try {\n  1571→    const result = await pool.query(\n  1572→      `SELECT email_verified, email_verified_at\n  1573→       FROM users\n  1574→       WHERE stripe_customer_id = $1`,\n  1575→      [stripeCustomerId]\n  1576→    );\n  1577→\n  1578→    if (result.rows.length === 0) {\n  1579→      return { verified: false };\n  1580→    }\n  1581→\n  1582→    return {\n  1583→      verified: result.rows[0].email_verified === true,\n  1584→      verifiedAt: result.rows[0].email_verified_at\n  1585→    };\n  1586→  } catch (err) {\n  1587→    console.error('[SPLICE] isEmailVerified error:', err.message);\n  1588→    return { verified: false };\n  1589→  }\n  1590→}\n  1591→\n  1592→/**\n  1593→ * Get user by email address\n  1594→ * @param {string} email - Email address\n  1595→ * @returns {Promise<Object|null>} User object or null\n  1596→ */\n  1597→async function getUserByEmail(email) {\n  1598→  if (!email) return null;\n  1599→\n  1600→  const normalizedEmail = email.toLowerCase().trim();\n  1601→\n  1602→  try {\n  1603→    const result = await pool.query(\n  1604→      `SELECT stripe_customer_id, email, tier, email_verified, email_verified_at\n  1605→       FROM users\n  1606→       WHERE LOWER(email) = $1`,\n  1607→      [normalizedEmail]\n  1608→    );\n  1609→\n  1610→    return result.rows.length > 0 ? result.rows[0] : null;\n  1611→  } catch (err) {\n  1612→    console.error('[SPLICE] getUserByEmail error:', err.message);\n  1613→    return null;\n  1614→  }\n  1615→}\n  1616→\n  1617→module.exports = {\n  1618→  initDatabase,\n  1619→  getOrCreateUser,\n  1620→  customerExists,\n  1621→  getBalance,\n  1622→  hasCredits,\n  1623→  reserveCredits,\n  1624→  confirmReservation,\n  1625→  releaseReservation,\n  1626→  checkIsolationAccess,\n  1627→  deductUsage,\n  1628→  deductIsolationUsage,\n  1629→  resetHours,\n  1630→  updateTier,\n  1631→  getUsageHistory,\n  1632→  isEventProcessed,\n  1633→  recordWebhookEvent,\n  1634→  // Music credits functions\n  1635→  getMusicCredits,\n  1636→  hasMusicCredits,\n  1637→  deductMusicCredit,\n  1638→  resetMusicCredits,\n  1639→  addMusicCredits,\n  1640→  getMusicUsageHistory,\n  1641→  initMusicCreditsColumns,\n  1642→  // Variations credits functions\n  1643→  checkVariationsCredits,\n  1644→  deductVariationsCredit,\n  1645→  // Scene-aware credits functions\n  1646→  checkSceneAwareCredits,\n  1647→  deductSceneAwareCredit,\n  1648→  // Pool management\n  1649→  closePool,\n  1650→  checkDatabase,\n  1651→  // Trial management\n  1652→  updateTrialEnd,\n  1653→  // Email verification functions\n  1654→  markEmailVerified,\n  1655→  isEmailVerified,\n  1656→  getUserByEmail,\n  1657→  // Constants\n  1658→  TIER_HOURS,\n  1659→  TIER_ISOLATION_MINUTES,\n  1660→  TIER_ISOLATION_HOURS,\n  1661→  ISOLATION_OVERAGE_RATE,\n  1662→  HOURS_OVERAGE_RATE,\n  1663→  TIER_MUSIC_CREDITS,\n  1664→  MUSIC_OVERAGE_RATE,\n  1665→  MUSIC_OVERAGE_RATES,\n  1666→  VARIATIONS_CREDIT_COST,\n  1667→  VARIATIONS_OVERAGE_RATES,\n  1668→  SCENE_AWARE_CREDIT_COST,\n  1669→  SCENE_AWARE_OVERAGE_RATES,\n  1670→  // Feature access\n  1671→  TIER_FEATURES,\n  1672→  hasFeatureAccess\n  1673→};\n  1674→\n\n</system-reminder>\n"}]},"uuid":"d75e52f0-87a6-4f34-a5b6-beaf218f3bf1","timestamp":"2025-12-30T02:10:04.750Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"/**\n * Usage Tracking Service\n *\n * Tracks user credit balances and usage for billing.\n * Uses PostgreSQL for persistence.\n */\n\nconst { Pool } = require('pg');\nconst { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n\n// PostgreSQL connection pool with proper limits\n// SSL Configuration:\n// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\nconst sslConfig = process.env.NODE_ENV === 'production' ? {\n  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n  ca: process.env.DATABASE_SSL_CA || undefined\n} : false;\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: sslConfig,\n  // PERFORMANCE: Set connection pool limits\n  max: 20,                    // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n});\n\n// Hours per tier (regular processing)\n// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n// Target margins: 79-82%\nconst TIER_HOURS = {\n  starter: 4,    // 4 hrs/month\n  pro: 15,       // 15 hrs/month\n  team: 50,      // 50 hrs/month\n  cancelled: 0\n};\n\n// Overage rate for processing hours beyond included\nconst HOURS_OVERAGE_RATE = 2.00; // $2/hour\n\n// Isolation minutes per tier (sized to maintain 80% margins)\nconst TIER_ISOLATION_MINUTES = {\n  starter: 0,     // No isolation access\n  pro: 45,        // 45 minutes included\n  team: 180,      // 3 hours included\n  cancelled: 0\n};\n\n// Convert to hours for database storage\nconst TIER_ISOLATION_HOURS = {\n  starter: 0,\n  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n  cancelled: 0\n};\n\n// Overage rate for isolation beyond included minutes\nconst ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n\n/**\n * Initialize database tables\n */\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n        email VARCHAR(255),\n        tier VARCHAR(50) DEFAULT 'starter',\n        hours_remaining DECIMAL(10,4) DEFAULT 15,\n        hours_total DECIMAL(10,4) DEFAULT 15,\n        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Add isolation columns if they don't exist (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified') THEN\n          ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified_at') THEN\n          ALTER TABLE users ADD COLUMN email_verified_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS usage_log (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        stripe_customer_id VARCHAR(255),\n        audio_duration_seconds DECIMAL(10,2),\n        hours_used DECIMAL(10,6),\n        endpoint VARCHAR(100),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    `);\n\n    // PERFORMANCE: Add composite index for efficient customer usage history queries\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n      ON usage_log(stripe_customer_id, created_at DESC)\n    `);\n\n    // Webhook events table for idempotency\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id SERIAL PRIMARY KEY,\n        event_id VARCHAR(255) UNIQUE NOT NULL,\n        event_type VARCHAR(100),\n        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n    `);\n\n    console.log('[UsageTracking] Database initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get or create a user by Stripe customer ID\n * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n */\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n     RETURNING *`,\n    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n  );\n\n  return result.rows[0];\n}\n\n/**\n * Check if a customer exists in the database (without creating)\n * SECURITY: Used to validate legacy auth attempts\n */\nasync function customerExists(stripeCustomerId) {\n  if (!stripeCustomerId) return false;\n\n  try {\n    const result = await pool.query(\n      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n      [stripeCustomerId]\n    );\n    return result.rows.length > 0;\n  } catch (err) {\n    console.error('[SPLICE] customerExists check failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get user's current credit balance\n */\nasync function getBalance(stripeCustomerId) {\n  const user = await getOrCreateUser(stripeCustomerId);\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  // Tier display names\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  // Calculate trial days remaining\n  let trialDaysRemaining = null;\n  let isOnTrial = false;\n  if (user.trial_end) {\n    const trialEnd = new Date(user.trial_end);\n    const now = new Date();\n    const diffMs = trialEnd.getTime() - now.getTime();\n    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n    if (diffDays > 0) {\n      trialDaysRemaining = diffDays;\n      isOnTrial = true;\n    }\n  }\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n    trialDaysRemaining,\n    isOnTrial,\n    email: user.email,\n    emailVerified: user.email_verified === true\n  };\n}\n\n/**\n * Check if user has enough credits for estimated duration\n */\nasync function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n  const balance = await getBalance(stripeCustomerId);\n  const estimatedHours = estimatedSeconds / 3600;\n  return balance.hoursRemaining >= estimatedHours;\n}\n\n/**\n * Reserve credits atomically using SELECT ... FOR UPDATE\n * This prevents race conditions where multiple requests pass credit check\n * before any deduction occurs.\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} estimatedSeconds - Estimated processing time in seconds\n * @param {string} endpoint - Endpoint name for tracking\n * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n */\nasync function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n  const estimatedHours = estimatedSeconds / 3600;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, hours_remaining FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      // Create user if doesn't exist (within transaction)\n      const newUser = await client.query(\n        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n         VALUES ($1, 'starter', $2, $2)\n         RETURNING id, hours_remaining`,\n        [stripeCustomerId, TIER_HOURS.starter]\n      );\n      result.rows = newUser.rows;\n    }\n\n    const user = result.rows[0];\n    const hoursRemaining = parseFloat(user.hours_remaining);\n\n    // Check if enough credits\n    if (hoursRemaining < estimatedHours) {\n      await client.query('ROLLBACK');\n      return {\n        success: false,\n        error: 'Insufficient credits',\n        hoursRemaining,\n        hoursRequired: estimatedHours\n      };\n    }\n\n    // Generate unique reservation ID\n    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Reserve credits by deducting the estimated amount\n    await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining - $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [estimatedHours, stripeCustomerId]\n    );\n\n    // Log the reservation\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n\n    return {\n      success: true,\n      reservationId,\n      hoursReserved: estimatedHours,\n      hoursRemaining: hoursRemaining - estimatedHours\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[UsageTracking] Reservation error:', err);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Confirm a reservation (finalize usage) or adjust for actual duration\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} actualSeconds - Actual processing time in seconds\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @returns {Promise<object>} Updated balance\n */\nasync function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n  const actualHours = actualSeconds / 3600;\n  const reservedHours = reservedSeconds / 3600;\n  const difference = reservedHours - actualHours;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get current state\n    const result = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    let user = result.rows[0];\n\n    // If actual usage was less than reserved, refund the difference\n    if (difference > 0) {\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = hours_remaining + $1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the adjustment\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n      );\n    } else if (difference < 0) {\n      // Actual usage was more than reserved - deduct the extra\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [-difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the additional usage\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n      );\n    }\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n\n    // Build balance from data we already have (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Release a reservation (refund credits on processing failure)\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @param {string} reason - Reason for release\n * @returns {Promise<object>} Updated balance\n */\nasync function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n  const reservedHours = reservedSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get id for logging\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const userId = result.rows[0].id;\n\n    // Refund the reserved amount with RETURNING\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining + $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [reservedHours, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log the refund\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if user can use vocal isolation\n * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n */\nasync function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n  const balance = await getBalance(stripeCustomerId);\n\n  // Starter tier has no isolation access\n  if (!balance.hasIsolationAccess) {\n    return {\n      allowed: false,\n      reason: 'upgrade_required',\n      message: 'Vocal isolation requires Pro or Team tier',\n      hasIncludedHours: false,\n      overageRequired: false,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remainingIncluded = balance.isolationHoursRemaining;\n\n  // Check if within included hours\n  if (remainingIncluded >= estimatedHours) {\n    return {\n      allowed: true,\n      reason: 'included',\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      hasIncludedHours: true,\n      overageRequired: false,\n      overageCost: 0,\n      isolationHoursRemaining: remainingIncluded - estimatedHours\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n\n  return {\n    allowed: true,\n    reason: 'overage',\n    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n    hasIncludedHours: remainingIncluded > 0,\n    overageRequired: true,\n    overageMinutes,\n    overageCost,\n    isolationHoursRemaining: 0\n  };\n}\n\n/**\n * Deduct isolation usage from user's balance\n * Returns overage cost if beyond included hours\n * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n */\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n  const durationMinutes = audioDurationSeconds / 60;\n  const durationHours = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const userResult = await client.query(\n      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n       FROM users WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n\n    let overageCost = 0;\n    let hoursFromIncluded = 0;\n    let overageMinutes = 0;\n\n    if (remainingIncluded >= durationHours) {\n      // Fully covered by included hours\n      hoursFromIncluded = durationHours;\n    } else {\n      // Partial or full overage\n      hoursFromIncluded = remainingIncluded;\n      overageMinutes = durationMinutes - (remainingIncluded * 60);\n      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n    }\n\n    // Update isolation balance with RETURNING to get new values\n    const updateResult = await client.query(\n      `UPDATE users\n       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n      [durationHours, stripeCustomerId]\n    );\n\n    const updatedUser = updateResult.rows[0];\n\n    // Log usage (mark as isolation)\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(updatedUser.hours_total);\n    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: updatedUser.tier,\n      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      isolationUsed: {\n        durationMinutes,\n        hoursFromIncluded,\n        overageMinutes,\n        overageCost\n      }\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct usage from user's balance\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n * Reports overage to Stripe for billing when user exceeds included hours\n */\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // First get current balance to calculate overage\n    const currentResult = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (currentResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const currentUser = currentResult.rows[0];\n    const currentRemaining = parseFloat(currentUser.hours_remaining);\n\n    // Calculate overage (hours used beyond what's remaining)\n    let overageHours = 0;\n    if (hoursUsed > currentRemaining) {\n      overageHours = hoursUsed - currentRemaining;\n    }\n\n    // Update balance (clamp at 0)\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [hoursUsed, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log usage\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Report overage to Stripe if any (after commit to not block transaction)\n    let overageCharge = 0;\n    if (overageHours > 0) {\n      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n      } else {\n        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      overageHours,\n      overageCharge\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset user's hours for new billing period\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n */\nasync function resetHours(stripeCustomerId, tier) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  const result = await pool.query(\n    `UPDATE users\n     SET hours_remaining = $1, hours_total = $1,\n         isolation_hours_remaining = $2, isolation_hours_total = $2,\n         tier = $3, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $4\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [hours, isolationHours, tier, stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    // User doesn't exist, create and return default balance\n    return await getBalance(stripeCustomerId);\n  }\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Update user's tier (from Stripe webhook)\n * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n */\nasync function updateTier(stripeCustomerId, tier, email = null) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, $3, $4, $4, $5, $5)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET tier = $3, hours_remaining = $4, hours_total = $4,\n         isolation_hours_remaining = $5, isolation_hours_total = $5,\n         updated_at = CURRENT_TIMESTAMP\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [stripeCustomerId, email, tier, hours, isolationHours]\n  );\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Get usage history for a user\n */\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Check if webhook event has already been processed (idempotency)\n */\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n\n/**\n * Record a processed webhook event\n */\nasync function recordWebhookEvent(eventId, eventType) {\n  try {\n    await pool.query(\n      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n      [eventId, eventType]\n    );\n  } catch (err) {\n    // Ignore duplicate key errors (race condition safety)\n    if (err.code !== '23505') throw err;\n  }\n}\n\n// =============================================================================\n// Music Credits Functions (Phase 4 - AI Music Feature)\n// =============================================================================\n\n// Music credits per tier\n// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\nconst TIER_MUSIC_CREDITS = {\n  starter: 2,    // 2 songs/month\n  pro: 10,       // 10 songs/month\n  team: 50,      // 50 songs/month\n  cancelled: 0\n};\n\n// Feature access by tier - defines which features each tier can use\nconst TIER_FEATURES = {\n  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection'],\n  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection', 'multitrack',\n    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n  cancelled: []\n};\n\n/**\n * Check if a tier has access to a specific feature\n * @param {string} tier - User's tier (starter, pro, team)\n * @param {string} feature - Feature name to check\n * @returns {boolean}\n */\nfunction hasFeatureAccess(tier, feature) {\n  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n  return tierFeatures.includes(feature);\n}\n\n// Flat overage rate for music (simplified pricing)\nconst MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n\n// Legacy overage rates (kept for backwards compatibility)\nconst MUSIC_OVERAGE_RATES = {\n  starter: 1.00,  // $1.00/song\n  pro: 1.00,      // $1.00/song\n  team: 1.00      // $1.00/song\n};\n\n/**\n * Get music credits balance for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{remaining: number, total: number, tier: string}>}\n */\nasync function getMusicCredits(stripeCustomerId) {\n  const result = await pool.query(\n    `SELECT music_credits_remaining, music_credits_total, tier\n     FROM users\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { remaining: 0, total: 0, tier: 'starter' };\n  }\n\n  const row = result.rows[0];\n  return {\n    remaining: row.music_credits_remaining || 0,\n    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n    tier: row.tier || 'starter'\n  };\n}\n\n/**\n * Check if customer has music credits available\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<boolean>}\n */\nasync function hasMusicCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  return credits.remaining > 0;\n}\n\n/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining } = result.rows[0];\n    let charged = 0;\n\n    if (music_credits_remaining > 0) {\n      // Deduct from included credits\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - 1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n    } else {\n      // Overage - charge flat rate ($1/song)\n      charged = MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, 1, $2)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset music credits based on tier (called on subscription renewal)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {string} tier - Subscription tier\n */\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update to prevent race conditions\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      console.warn(`[SPLICE] resetMusicCredits: User not found for ${stripeCustomerId}`);\n      return;\n    }\n\n    await client.query(\n      `UPDATE users\n       SET music_credits_remaining = $2,\n           music_credits_total = $2,\n           music_credits_reset_at = CURRENT_TIMESTAMP,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit reset error:', err.message);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Add music credits (for promotional or overage purchases)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} credits - Number of credits to add\n * @returns {Promise<{success: boolean, newBalance: number}>}\n */\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update to prevent concurrent modification\n    const lockResult = await client.query(\n      `SELECT music_credits_remaining\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (lockResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, newBalance: 0, error: 'User not found' };\n    }\n\n    // Update the credits\n    const result = await client.query(\n      `UPDATE users\n       SET music_credits_remaining = music_credits_remaining + $2,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1\n       RETURNING music_credits_remaining`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n\n    return {\n      success: true,\n      newBalance: result.rows[0].music_credits_remaining\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit addition error:', err.message);\n    return { success: false, newBalance: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get music usage history for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} limit - Max records to return\n * @returns {Promise<Object[]>}\n */\nasync function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM music_usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Initialize music credits columns (migration helper)\n */\nasync function initMusicCreditsColumns() {\n  const client = await pool.connect();\n  try {\n    // Add music credits columns if they don't exist\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    // Create music usage log table\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS music_usage_log (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        credits_used INTEGER DEFAULT 1,\n        overage_charged DECIMAL(10,2) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n      ON music_usage_log(stripe_customer_id)\n    `);\n\n    console.log('[SPLICE] Music credits columns initialized');\n  } finally {\n    client.release();\n  }\n}\n\n// Variations credits cost (equivalent to 2.5 music credits)\nconst VARIATIONS_CREDIT_COST = 2.5;\n\n// Overage rates for variations (higher than single music due to 3 parallel generations)\nconst VARIATIONS_OVERAGE_RATES = {\n  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  team: 0.50      // $0.50/variations (2.5x $0.20)\n};\n\n// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\nconst SCENE_AWARE_CREDIT_COST = 1.5;\n\n// Overage rates for scene-aware music (75% margin)\nconst SCENE_AWARE_OVERAGE_RATES = {\n  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n};\n\n/**\n * Check if customer has enough credits for variations (2.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkVariationsCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = VARIATIONS_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct variations credit from customer (2.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductVariationsCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Variations credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if customer has enough credits for scene-aware music (1.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkSceneAwareCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct scene-aware music credit from customer (1.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductSceneAwareCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Close the database connection pool\n * Used for graceful shutdown\n */\nasync function closePool() {\n  await pool.end();\n}\n\n/**\n * Update trial end date for a customer\n * @param {string} stripeCustomerId - Customer ID\n * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n */\nasync function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n\n  await pool.query(\n    `UPDATE users\n     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, trialEnd]\n  );\n\n  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n}\n\n/**\n * Check database connectivity\n * Used for health checks\n */\nasync function checkDatabase() {\n  const client = await pool.connect();\n  try {\n    const result = await client.query('SELECT 1 as health');\n    return result.rows[0].health === 1;\n  } finally {\n    client.release();\n  }\n}\n\n// =============================================================================\n// Email Verification Functions\n// =============================================================================\n\n/**\n * Mark a user's email as verified\n * @param {string} email - Email address that was verified\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function markEmailVerified(email) {\n  if (!email) {\n    return { success: false, error: 'Email is required' };\n  }\n\n  const normalizedEmail = email.toLowerCase().trim();\n\n  try {\n    const result = await pool.query(\n      `UPDATE users\n       SET email_verified = TRUE,\n           email_verified_at = CURRENT_TIMESTAMP,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE LOWER(email) = $1\n       RETURNING stripe_customer_id, email_verified`,\n      [normalizedEmail]\n    );\n\n    if (result.rows.length === 0) {\n      // No user found with this email - this is OK for new signups\n      console.log(`[SPLICE] No user found for email verification: ${normalizedEmail}`);\n      return { success: true, userFound: false };\n    }\n\n    console.log(`[SPLICE] Email verified for user: ${result.rows[0].stripe_customer_id}`);\n    return { success: true, userFound: true, customerId: result.rows[0].stripe_customer_id };\n  } catch (err) {\n    console.error('[SPLICE] markEmailVerified error:', err.message);\n    return { success: false, error: err.message };\n  }\n}\n\n/**\n * Check if a user's email is verified\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{verified: boolean, verifiedAt?: Date}>}\n */\nasync function isEmailVerified(stripeCustomerId) {\n  try {\n    const result = await pool.query(\n      `SELECT email_verified, email_verified_at\n       FROM users\n       WHERE stripe_customer_id = $1`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      return { verified: false };\n    }\n\n    return {\n      verified: result.rows[0].email_verified === true,\n      verifiedAt: result.rows[0].email_verified_at\n    };\n  } catch (err) {\n    console.error('[SPLICE] isEmailVerified error:', err.message);\n    return { verified: false };\n  }\n}\n\n/**\n * Get user by email address\n * @param {string} email - Email address\n * @returns {Promise<Object|null>} User object or null\n */\nasync function getUserByEmail(email) {\n  if (!email) return null;\n\n  const normalizedEmail = email.toLowerCase().trim();\n\n  try {\n    const result = await pool.query(\n      `SELECT stripe_customer_id, email, tier, email_verified, email_verified_at\n       FROM users\n       WHERE LOWER(email) = $1`,\n      [normalizedEmail]\n    );\n\n    return result.rows.length > 0 ? result.rows[0] : null;\n  } catch (err) {\n    console.error('[SPLICE] getUserByEmail error:', err.message);\n    return null;\n  }\n}\n\nmodule.exports = {\n  initDatabase,\n  getOrCreateUser,\n  customerExists,\n  getBalance,\n  hasCredits,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  checkIsolationAccess,\n  deductUsage,\n  deductIsolationUsage,\n  resetHours,\n  updateTier,\n  getUsageHistory,\n  isEventProcessed,\n  recordWebhookEvent,\n  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  resetMusicCredits,\n  addMusicCredits,\n  getMusicUsageHistory,\n  initMusicCreditsColumns,\n  // Variations credits functions\n  checkVariationsCredits,\n  deductVariationsCredit,\n  // Scene-aware credits functions\n  checkSceneAwareCredits,\n  deductSceneAwareCredit,\n  // Pool management\n  closePool,\n  checkDatabase,\n  // Trial management\n  updateTrialEnd,\n  // Email verification functions\n  markEmailVerified,\n  isEmailVerified,\n  getUserByEmail,\n  // Constants\n  TIER_HOURS,\n  TIER_ISOLATION_MINUTES,\n  TIER_ISOLATION_HOURS,\n  ISOLATION_OVERAGE_RATE,\n  HOURS_OVERAGE_RATE,\n  TIER_MUSIC_CREDITS,\n  MUSIC_OVERAGE_RATE,\n  MUSIC_OVERAGE_RATES,\n  VARIATIONS_CREDIT_COST,\n  VARIATIONS_OVERAGE_RATES,\n  SCENE_AWARE_CREDIT_COST,\n  SCENE_AWARE_OVERAGE_RATES,\n  // Feature access\n  TIER_FEATURES,\n  hasFeatureAccess\n};\n","numLines":1674,"startLine":1,"totalLines":1674}}}
{"parentUuid":"d75e52f0-87a6-4f34-a5b6-beaf218f3bf1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_016KNjJqMXZczfMFVJrn93pb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LFgYQqCzQL37MZH7QRUoTY","name":"TodoWrite","input":{"todos":[{"content":"Check backend API routes for middleware and error handling","status":"completed","activeForm":"Checking backend API routes for middleware and error handling"},{"content":"Verify frontend-backend API integration","status":"in_progress","activeForm":"Verifying frontend-backend API integration"},{"content":"Check service dependencies and imports","status":"pending","activeForm":"Checking service dependencies and imports"},{"content":"Validate database schema in usageTracking.js","status":"pending","activeForm":"Validating database schema in usageTracking.js"},{"content":"Verify plugin features integration chain","status":"pending","activeForm":"Verifying plugin features integration chain"},{"content":"Complete security checklist","status":"pending","activeForm":"Completing security checklist"},{"content":"Check production configuration","status":"pending","activeForm":"Checking production configuration"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13477,"cache_creation_input_tokens":23559,"cache_read_input_tokens":50400,"cache_creation":{"ephemeral_5m_input_tokens":23559,"ephemeral_1h_input_tokens":0},"output_tokens":277,"service_tier":"standard"}},"requestId":"req_011CWc4MeF3GMiTdSqj1Cgdo","type":"assistant","uuid":"8844ba3a-a233-41ca-8cfe-32e6a037b788","timestamp":"2025-12-30T02:10:14.963Z"}
{"parentUuid":"8844ba3a-a233-41ca-8cfe-32e6a037b788","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LFgYQqCzQL37MZH7QRUoTY","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"246b5bfd-6234-4c37-83fe-d743479d85bd","timestamp":"2025-12-30T02:10:14.997Z","toolUseResult":{"oldTodos":[{"content":"Check backend API routes for middleware and error handling","status":"in_progress","activeForm":"Checking backend API routes for middleware and error handling"},{"content":"Verify frontend-backend API integration","status":"pending","activeForm":"Verifying frontend-backend API integration"},{"content":"Check service dependencies and imports","status":"pending","activeForm":"Checking service dependencies and imports"},{"content":"Validate database schema in usageTracking.js","status":"pending","activeForm":"Validating database schema in usageTracking.js"},{"content":"Verify plugin features integration chain","status":"pending","activeForm":"Verifying plugin features integration chain"},{"content":"Complete security checklist","status":"pending","activeForm":"Completing security checklist"},{"content":"Check production configuration","status":"pending","activeForm":"Checking production configuration"}],"newTodos":[{"content":"Check backend API routes for middleware and error handling","status":"completed","activeForm":"Checking backend API routes for middleware and error handling"},{"content":"Verify frontend-backend API integration","status":"in_progress","activeForm":"Verifying frontend-backend API integration"},{"content":"Check service dependencies and imports","status":"pending","activeForm":"Checking service dependencies and imports"},{"content":"Validate database schema in usageTracking.js","status":"pending","activeForm":"Validating database schema in usageTracking.js"},{"content":"Verify plugin features integration chain","status":"pending","activeForm":"Verifying plugin features integration chain"},{"content":"Complete security checklist","status":"pending","activeForm":"Completing security checklist"},{"content":"Check production configuration","status":"pending","activeForm":"Checking production configuration"}]}}
{"parentUuid":"246b5bfd-6234-4c37-83fe-d743479d85bd","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BHR3eNKY21mWZqszCtnbQW","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the CEP plugin config and the remaining frontend API routes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13796,"cache_read_input_tokens":73959,"cache_creation":{"ephemeral_5m_input_tokens":13796,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4NQKfQm4AecU4tEPVa","type":"assistant","uuid":"38f6cc15-c367-4582-843d-9703a22c180d","timestamp":"2025-12-30T02:10:19.232Z"}
{"parentUuid":"38f6cc15-c367-4582-843d-9703a22c180d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BHR3eNKY21mWZqszCtnbQW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0135S7Y5Z3mCsHoearVNweRN","name":"Glob","input":{"pattern":"/Users/imorgado/SPLICE/splice-cep/**/config.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13796,"cache_read_input_tokens":73959,"cache_creation":{"ephemeral_5m_input_tokens":13796,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4NQKfQm4AecU4tEPVa","type":"assistant","uuid":"f350ad44-a821-4979-a555-43baaf1a1a84","timestamp":"2025-12-30T02:10:20.292Z"}
{"parentUuid":"f350ad44-a821-4979-a555-43baaf1a1a84","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BHR3eNKY21mWZqszCtnbQW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YS4hKAnuEFLWdF3ezMmgxv","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/me/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13796,"cache_read_input_tokens":73959,"cache_creation":{"ephemeral_5m_input_tokens":13796,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4NQKfQm4AecU4tEPVa","type":"assistant","uuid":"107966b4-d51b-4afe-b36c-9cd61c2c8088","timestamp":"2025-12-30T02:10:21.125Z"}
{"parentUuid":"107966b4-d51b-4afe-b36c-9cd61c2c8088","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BHR3eNKY21mWZqszCtnbQW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HAX5KaM1UFzmfDUztydQwD","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/refresh/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13796,"cache_read_input_tokens":73959,"cache_creation":{"ephemeral_5m_input_tokens":13796,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4NQKfQm4AecU4tEPVa","type":"assistant","uuid":"df90caf9-d736-4541-a331-c7ec35d23ef9","timestamp":"2025-12-30T02:10:21.809Z"}
{"parentUuid":"df90caf9-d736-4541-a331-c7ec35d23ef9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BHR3eNKY21mWZqszCtnbQW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013ykjPwuoiPdBQMiQXF67Jd","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/logout/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13796,"cache_read_input_tokens":73959,"cache_creation":{"ephemeral_5m_input_tokens":13796,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4NQKfQm4AecU4tEPVa","type":"assistant","uuid":"a5314f87-0997-40c2-996d-90e6a547b1fb","timestamp":"2025-12-30T02:10:22.495Z"}
{"parentUuid":"a5314f87-0997-40c2-996d-90e6a547b1fb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BHR3eNKY21mWZqszCtnbQW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012XTxRuqKgPCtQMP5mQ7fAn","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/lib/csrf-server.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":13796,"cache_read_input_tokens":73959,"cache_creation":{"ephemeral_5m_input_tokens":13796,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4NQKfQm4AecU4tEPVa","type":"assistant","uuid":"cca8706a-fe74-443f-87a1-e699ce7fd6e2","timestamp":"2025-12-30T02:10:23.294Z"}
{"parentUuid":"cca8706a-fe74-443f-87a1-e699ce7fd6e2","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YS4hKAnuEFLWdF3ezMmgxv","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import { cookies } from \"next/headers\";\n     3→\n     4→// Backend API URL for authentication\n     5→const BACKEND_API_URL =\n     6→  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n     7→\n     8→export async function GET(_request: NextRequest) {\n     9→  try {\n    10→    const cookieStore = await cookies();\n    11→    const token = cookieStore.get(\"splice_token\")?.value;\n    12→    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n    13→\n    14→    // No token means not authenticated\n    15→    if (!token) {\n    16→      return NextResponse.json(\n    17→        {\n    18→          authenticated: false,\n    19→          error: \"Not authenticated\",\n    20→        },\n    21→        { status: 401 }\n    22→      );\n    23→    }\n    24→\n    25→    // Verify the token with the backend by making a request to get balance\n    26→    // This validates the token and returns current user data\n    27→    const response = await fetch(`${BACKEND_API_URL}/api/balance`, {\n    28→      method: \"GET\",\n    29→      headers: {\n    30→        Authorization: `Bearer ${token}`,\n    31→      },\n    32→    });\n    33→\n    34→    if (response.ok) {\n    35→      const data = await response.json();\n    36→      return NextResponse.json({\n    37→        authenticated: true,\n    38→        user: {\n    39→          customerId: data.customerId,\n    40→          tier: data.tier,\n    41→          hoursRemaining: data.hoursRemaining,\n    42→          musicCredits: data.musicCredits,\n    43→          variationsCredits: data.variationsCredits,\n    44→          sceneAwareCredits: data.sceneAwareCredits,\n    45→        },\n    46→      });\n    47→    }\n    48→\n    49→    // Token might be expired, try to refresh\n    50→    if (response.status === 401 && refreshToken) {\n    51→      const refreshResponse = await fetch(`${BACKEND_API_URL}/auth/refresh`, {\n    52→        method: \"POST\",\n    53→        headers: {\n    54→          \"Content-Type\": \"application/json\",\n    55→        },\n    56→        body: JSON.stringify({ refreshToken }),\n    57→      });\n    58→\n    59→      if (refreshResponse.ok) {\n    60→        const refreshData = await refreshResponse.json();\n    61→\n    62→        // Get user data with the new token\n    63→        const balanceResponse = await fetch(`${BACKEND_API_URL}/api/balance`, {\n    64→          method: \"GET\",\n    65→          headers: {\n    66→            Authorization: `Bearer ${refreshData.token}`,\n    67→          },\n    68→        });\n    69→\n    70→        if (balanceResponse.ok) {\n    71→          const balanceData = await balanceResponse.json();\n    72→\n    73→          // Create response with updated user data\n    74→          const jsonResponse = NextResponse.json({\n    75→            authenticated: true,\n    76→            user: {\n    77→              customerId: balanceData.customerId,\n    78→              tier: balanceData.tier,\n    79→              hoursRemaining: balanceData.hoursRemaining,\n    80→              musicCredits: balanceData.musicCredits,\n    81→              variationsCredits: balanceData.variationsCredits,\n    82→              sceneAwareCredits: balanceData.sceneAwareCredits,\n    83→            },\n    84→          });\n    85→\n    86→          // Update the access token cookie with the new token\n    87→          const isProduction = process.env.NODE_ENV === \"production\";\n    88→          jsonResponse.cookies.set(\"splice_token\", refreshData.token, {\n    89→            httpOnly: true,\n    90→            secure: isProduction,\n    91→            sameSite: \"strict\",\n    92→            path: \"/\",\n    93→            maxAge: 60 * 60, // 1 hour\n    94→          });\n    95→\n    96→          // Update auth status cookie\n    97→          jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n    98→            httpOnly: false,\n    99→            secure: isProduction,\n   100→            sameSite: \"strict\",\n   101→            path: \"/\",\n   102→            maxAge: 60 * 60,\n   103→          });\n   104→\n   105→          // Update user metadata cookie\n   106→          jsonResponse.cookies.set(\n   107→            \"splice_user\",\n   108→            JSON.stringify({\n   109→              customerId: balanceData.customerId,\n   110→              tier: balanceData.tier,\n   111→              hoursRemaining: balanceData.hoursRemaining,\n   112→            }),\n   113→            {\n   114→              httpOnly: false,\n   115→              secure: isProduction,\n   116→              sameSite: \"strict\",\n   117→              path: \"/\",\n   118→              maxAge: 60 * 60,\n   119→            }\n   120→          );\n   121→\n   122→          return jsonResponse;\n   123→        }\n   124→      }\n   125→    }\n   126→\n   127→    // Token invalid and couldn't refresh\n   128→    const errorResponse = NextResponse.json(\n   129→      {\n   130→        authenticated: false,\n   131→        error: \"Session expired\",\n   132→        message: \"Please log in again\",\n   133→      },\n   134→      { status: 401 }\n   135→    );\n   136→\n   137→    // Clear invalid cookies\n   138→    const isProduction = process.env.NODE_ENV === \"production\";\n   139→    errorResponse.cookies.set(\"splice_token\", \"\", {\n   140→      httpOnly: true,\n   141→      secure: isProduction,\n   142→      sameSite: \"strict\",\n   143→      path: \"/\",\n   144→      maxAge: 0,\n   145→    });\n   146→    errorResponse.cookies.set(\"splice_auth_status\", \"\", {\n   147→      httpOnly: false,\n   148→      secure: isProduction,\n   149→      sameSite: \"strict\",\n   150→      path: \"/\",\n   151→      maxAge: 0,\n   152→    });\n   153→    errorResponse.cookies.set(\"splice_user\", \"\", {\n   154→      httpOnly: false,\n   155→      secure: isProduction,\n   156→      sameSite: \"strict\",\n   157→      path: \"/\",\n   158→      maxAge: 0,\n   159→    });\n   160→\n   161→    return errorResponse;\n   162→  } catch (error) {\n   163→    console.error(\"[Auth] Me endpoint error:\", error);\n   164→    return NextResponse.json(\n   165→      {\n   166→        authenticated: false,\n   167→        error: \"Authentication check failed\",\n   168→      },\n   169→      { status: 500 }\n   170→    );\n   171→  }\n   172→}\n   173→\n\n</system-reminder>\n"}]},"uuid":"7180e1c3-c670-4433-9015-7df4dfc3651e","timestamp":"2025-12-30T02:10:23.342Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/me/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport { cookies } from \"next/headers\";\n\n// Backend API URL for authentication\nconst BACKEND_API_URL =\n  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n\nexport async function GET(_request: NextRequest) {\n  try {\n    const cookieStore = await cookies();\n    const token = cookieStore.get(\"splice_token\")?.value;\n    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n\n    // No token means not authenticated\n    if (!token) {\n      return NextResponse.json(\n        {\n          authenticated: false,\n          error: \"Not authenticated\",\n        },\n        { status: 401 }\n      );\n    }\n\n    // Verify the token with the backend by making a request to get balance\n    // This validates the token and returns current user data\n    const response = await fetch(`${BACKEND_API_URL}/api/balance`, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${token}`,\n      },\n    });\n\n    if (response.ok) {\n      const data = await response.json();\n      return NextResponse.json({\n        authenticated: true,\n        user: {\n          customerId: data.customerId,\n          tier: data.tier,\n          hoursRemaining: data.hoursRemaining,\n          musicCredits: data.musicCredits,\n          variationsCredits: data.variationsCredits,\n          sceneAwareCredits: data.sceneAwareCredits,\n        },\n      });\n    }\n\n    // Token might be expired, try to refresh\n    if (response.status === 401 && refreshToken) {\n      const refreshResponse = await fetch(`${BACKEND_API_URL}/auth/refresh`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ refreshToken }),\n      });\n\n      if (refreshResponse.ok) {\n        const refreshData = await refreshResponse.json();\n\n        // Get user data with the new token\n        const balanceResponse = await fetch(`${BACKEND_API_URL}/api/balance`, {\n          method: \"GET\",\n          headers: {\n            Authorization: `Bearer ${refreshData.token}`,\n          },\n        });\n\n        if (balanceResponse.ok) {\n          const balanceData = await balanceResponse.json();\n\n          // Create response with updated user data\n          const jsonResponse = NextResponse.json({\n            authenticated: true,\n            user: {\n              customerId: balanceData.customerId,\n              tier: balanceData.tier,\n              hoursRemaining: balanceData.hoursRemaining,\n              musicCredits: balanceData.musicCredits,\n              variationsCredits: balanceData.variationsCredits,\n              sceneAwareCredits: balanceData.sceneAwareCredits,\n            },\n          });\n\n          // Update the access token cookie with the new token\n          const isProduction = process.env.NODE_ENV === \"production\";\n          jsonResponse.cookies.set(\"splice_token\", refreshData.token, {\n            httpOnly: true,\n            secure: isProduction,\n            sameSite: \"strict\",\n            path: \"/\",\n            maxAge: 60 * 60, // 1 hour\n          });\n\n          // Update auth status cookie\n          jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n            httpOnly: false,\n            secure: isProduction,\n            sameSite: \"strict\",\n            path: \"/\",\n            maxAge: 60 * 60,\n          });\n\n          // Update user metadata cookie\n          jsonResponse.cookies.set(\n            \"splice_user\",\n            JSON.stringify({\n              customerId: balanceData.customerId,\n              tier: balanceData.tier,\n              hoursRemaining: balanceData.hoursRemaining,\n            }),\n            {\n              httpOnly: false,\n              secure: isProduction,\n              sameSite: \"strict\",\n              path: \"/\",\n              maxAge: 60 * 60,\n            }\n          );\n\n          return jsonResponse;\n        }\n      }\n    }\n\n    // Token invalid and couldn't refresh\n    const errorResponse = NextResponse.json(\n      {\n        authenticated: false,\n        error: \"Session expired\",\n        message: \"Please log in again\",\n      },\n      { status: 401 }\n    );\n\n    // Clear invalid cookies\n    const isProduction = process.env.NODE_ENV === \"production\";\n    errorResponse.cookies.set(\"splice_token\", \"\", {\n      httpOnly: true,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n    errorResponse.cookies.set(\"splice_auth_status\", \"\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n    errorResponse.cookies.set(\"splice_user\", \"\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n\n    return errorResponse;\n  } catch (error) {\n    console.error(\"[Auth] Me endpoint error:\", error);\n    return NextResponse.json(\n      {\n        authenticated: false,\n        error: \"Authentication check failed\",\n      },\n      { status: 500 }\n    );\n  }\n}\n","numLines":173,"startLine":1,"totalLines":173}}}
{"parentUuid":"7180e1c3-c670-4433-9015-7df4dfc3651e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0135S7Y5Z3mCsHoearVNweRN","type":"tool_result","content":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js"}]},"uuid":"03e83a77-e32c-4ff5-a201-240b2b1d4c94","timestamp":"2025-12-30T02:10:23.355Z","toolUseResult":{"filenames":["/Users/imorgado/SPLICE/splice-cep/panel/js/config.js"],"durationMs":22,"numFiles":1,"truncated":false}}
{"parentUuid":"03e83a77-e32c-4ff5-a201-240b2b1d4c94","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HAX5KaM1UFzmfDUztydQwD","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import { cookies } from \"next/headers\";\n     3→\n     4→// Backend API URL for authentication\n     5→const BACKEND_API_URL =\n     6→  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n     7→\n     8→const isProduction = process.env.NODE_ENV === \"production\";\n     9→const ACCESS_TOKEN_MAX_AGE = 60 * 60; // 1 hour in seconds\n    10→\n    11→export async function POST(_request: NextRequest) {\n    12→  try {\n    13→    const cookieStore = await cookies();\n    14→    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n    15→\n    16→    if (!refreshToken) {\n    17→      return NextResponse.json(\n    18→        { error: \"Refresh token is required\", success: false },\n    19→        { status: 400 }\n    20→      );\n    21→    }\n    22→\n    23→    // Forward the refresh request to the backend\n    24→    const response = await fetch(`${BACKEND_API_URL}/auth/refresh`, {\n    25→      method: \"POST\",\n    26→      headers: {\n    27→        \"Content-Type\": \"application/json\",\n    28→      },\n    29→      body: JSON.stringify({ refreshToken }),\n    30→    });\n    31→\n    32→    const data = await response.json();\n    33→\n    34→    if (!response.ok || !data.success) {\n    35→      // Clear auth cookies on refresh failure\n    36→      const errorResponse = NextResponse.json(\n    37→        {\n    38→          error: data.error || \"Token refresh failed\",\n    39→          message: data.message || \"Please log in again\",\n    40→          success: false,\n    41→        },\n    42→        { status: response.status }\n    43→      );\n    44→\n    45→      // Clear cookies\n    46→      errorResponse.cookies.set(\"splice_token\", \"\", {\n    47→        httpOnly: true,\n    48→        secure: isProduction,\n    49→        sameSite: \"strict\",\n    50→        path: \"/\",\n    51→        maxAge: 0,\n    52→      });\n    53→      errorResponse.cookies.set(\"splice_auth_status\", \"\", {\n    54→        httpOnly: false,\n    55→        secure: isProduction,\n    56→        sameSite: \"strict\",\n    57→        path: \"/\",\n    58→        maxAge: 0,\n    59→      });\n    60→      errorResponse.cookies.set(\"splice_user\", \"\", {\n    61→        httpOnly: false,\n    62→        secure: isProduction,\n    63→        sameSite: \"strict\",\n    64→        path: \"/\",\n    65→        maxAge: 0,\n    66→      });\n    67→\n    68→      return errorResponse;\n    69→    }\n    70→\n    71→    // Create response with success\n    72→    const jsonResponse = NextResponse.json({\n    73→      success: true,\n    74→      tokenType: data.tokenType,\n    75→      expiresIn: data.expiresIn,\n    76→    });\n    77→\n    78→    // Update the access token cookie\n    79→    jsonResponse.cookies.set(\"splice_token\", data.token, {\n    80→      httpOnly: true,\n    81→      secure: isProduction,\n    82→      sameSite: \"strict\",\n    83→      path: \"/\",\n    84→      maxAge: ACCESS_TOKEN_MAX_AGE,\n    85→    });\n    86→\n    87→    // Update auth status cookie\n    88→    jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n    89→      httpOnly: false,\n    90→      secure: isProduction,\n    91→      sameSite: \"strict\",\n    92→      path: \"/\",\n    93→      maxAge: ACCESS_TOKEN_MAX_AGE,\n    94→    });\n    95→\n    96→    return jsonResponse;\n    97→  } catch (error) {\n    98→    console.error(\"[Auth] Refresh error:\", error);\n    99→    return NextResponse.json(\n   100→      {\n   101→        error: \"Token refresh failed\",\n   102→        message: \"Unable to refresh authentication. Please log in again.\",\n   103→        success: false,\n   104→      },\n   105→      { status: 500 }\n   106→    );\n   107→  }\n   108→}\n   109→\n\n</system-reminder>\n"}]},"uuid":"448d3b30-3fc1-48ca-a56f-ce193970ac97","timestamp":"2025-12-30T02:10:23.342Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/refresh/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport { cookies } from \"next/headers\";\n\n// Backend API URL for authentication\nconst BACKEND_API_URL =\n  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst ACCESS_TOKEN_MAX_AGE = 60 * 60; // 1 hour in seconds\n\nexport async function POST(_request: NextRequest) {\n  try {\n    const cookieStore = await cookies();\n    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n\n    if (!refreshToken) {\n      return NextResponse.json(\n        { error: \"Refresh token is required\", success: false },\n        { status: 400 }\n      );\n    }\n\n    // Forward the refresh request to the backend\n    const response = await fetch(`${BACKEND_API_URL}/auth/refresh`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ refreshToken }),\n    });\n\n    const data = await response.json();\n\n    if (!response.ok || !data.success) {\n      // Clear auth cookies on refresh failure\n      const errorResponse = NextResponse.json(\n        {\n          error: data.error || \"Token refresh failed\",\n          message: data.message || \"Please log in again\",\n          success: false,\n        },\n        { status: response.status }\n      );\n\n      // Clear cookies\n      errorResponse.cookies.set(\"splice_token\", \"\", {\n        httpOnly: true,\n        secure: isProduction,\n        sameSite: \"strict\",\n        path: \"/\",\n        maxAge: 0,\n      });\n      errorResponse.cookies.set(\"splice_auth_status\", \"\", {\n        httpOnly: false,\n        secure: isProduction,\n        sameSite: \"strict\",\n        path: \"/\",\n        maxAge: 0,\n      });\n      errorResponse.cookies.set(\"splice_user\", \"\", {\n        httpOnly: false,\n        secure: isProduction,\n        sameSite: \"strict\",\n        path: \"/\",\n        maxAge: 0,\n      });\n\n      return errorResponse;\n    }\n\n    // Create response with success\n    const jsonResponse = NextResponse.json({\n      success: true,\n      tokenType: data.tokenType,\n      expiresIn: data.expiresIn,\n    });\n\n    // Update the access token cookie\n    jsonResponse.cookies.set(\"splice_token\", data.token, {\n      httpOnly: true,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: ACCESS_TOKEN_MAX_AGE,\n    });\n\n    // Update auth status cookie\n    jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: ACCESS_TOKEN_MAX_AGE,\n    });\n\n    return jsonResponse;\n  } catch (error) {\n    console.error(\"[Auth] Refresh error:\", error);\n    return NextResponse.json(\n      {\n        error: \"Token refresh failed\",\n        message: \"Unable to refresh authentication. Please log in again.\",\n        success: false,\n      },\n      { status: 500 }\n    );\n  }\n}\n","numLines":109,"startLine":1,"totalLines":109}}}
{"parentUuid":"448d3b30-3fc1-48ca-a56f-ce193970ac97","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013ykjPwuoiPdBQMiQXF67Jd","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import { cookies } from \"next/headers\";\n     3→\n     4→// Backend API URL for authentication\n     5→const BACKEND_API_URL =\n     6→  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n     7→\n     8→const isProduction = process.env.NODE_ENV === \"production\";\n     9→\n    10→export async function POST(_request: NextRequest) {\n    11→  try {\n    12→    const cookieStore = await cookies();\n    13→    const token = cookieStore.get(\"splice_token\")?.value;\n    14→    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n    15→\n    16→    // If we have tokens, notify the backend to blacklist them\n    17→    if (token) {\n    18→      try {\n    19→        await fetch(`${BACKEND_API_URL}/auth/logout`, {\n    20→          method: \"POST\",\n    21→          headers: {\n    22→            \"Content-Type\": \"application/json\",\n    23→            Authorization: `Bearer ${token}`,\n    24→          },\n    25→          body: JSON.stringify({ refreshToken }),\n    26→        });\n    27→      } catch (backendError) {\n    28→        // Log but don't fail - we still want to clear cookies\n    29→        console.error(\"[Auth] Backend logout error:\", backendError);\n    30→      }\n    31→    }\n    32→\n    33→    // Create response\n    34→    const response = NextResponse.json({\n    35→      success: true,\n    36→      message: \"Logged out successfully\",\n    37→    });\n    38→\n    39→    // Clear all auth cookies by setting them with maxAge: 0\n    40→    response.cookies.set(\"splice_token\", \"\", {\n    41→      httpOnly: true,\n    42→      secure: isProduction,\n    43→      sameSite: \"strict\",\n    44→      path: \"/\",\n    45→      maxAge: 0,\n    46→    });\n    47→\n    48→    response.cookies.set(\"splice_refresh_token\", \"\", {\n    49→      httpOnly: true,\n    50→      secure: isProduction,\n    51→      sameSite: \"strict\",\n    52→      path: \"/\",\n    53→      maxAge: 0,\n    54→    });\n    55→\n    56→    response.cookies.set(\"splice_auth_status\", \"\", {\n    57→      httpOnly: false,\n    58→      secure: isProduction,\n    59→      sameSite: \"strict\",\n    60→      path: \"/\",\n    61→      maxAge: 0,\n    62→    });\n    63→\n    64→    response.cookies.set(\"splice_user\", \"\", {\n    65→      httpOnly: false,\n    66→      secure: isProduction,\n    67→      sameSite: \"strict\",\n    68→      path: \"/\",\n    69→      maxAge: 0,\n    70→    });\n    71→\n    72→    return response;\n    73→  } catch (error) {\n    74→    console.error(\"[Auth] Logout error:\", error);\n    75→\n    76→    // Even on error, try to clear cookies\n    77→    const response = NextResponse.json(\n    78→      {\n    79→        success: true,\n    80→        message: \"Logged out locally\",\n    81→      },\n    82→      { status: 200 }\n    83→    );\n    84→\n    85→    // Clear cookies anyway\n    86→    response.cookies.set(\"splice_token\", \"\", { maxAge: 0, path: \"/\" });\n    87→    response.cookies.set(\"splice_refresh_token\", \"\", { maxAge: 0, path: \"/\" });\n    88→    response.cookies.set(\"splice_auth_status\", \"\", { maxAge: 0, path: \"/\" });\n    89→    response.cookies.set(\"splice_user\", \"\", { maxAge: 0, path: \"/\" });\n    90→\n    91→    return response;\n    92→  }\n    93→}\n    94→\n\n</system-reminder>\n"}]},"uuid":"c0ba08d2-de2a-4b50-866a-96c29efc15b1","timestamp":"2025-12-30T02:10:23.342Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/logout/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport { cookies } from \"next/headers\";\n\n// Backend API URL for authentication\nconst BACKEND_API_URL =\n  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n\nconst isProduction = process.env.NODE_ENV === \"production\";\n\nexport async function POST(_request: NextRequest) {\n  try {\n    const cookieStore = await cookies();\n    const token = cookieStore.get(\"splice_token\")?.value;\n    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n\n    // If we have tokens, notify the backend to blacklist them\n    if (token) {\n      try {\n        await fetch(`${BACKEND_API_URL}/auth/logout`, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${token}`,\n          },\n          body: JSON.stringify({ refreshToken }),\n        });\n      } catch (backendError) {\n        // Log but don't fail - we still want to clear cookies\n        console.error(\"[Auth] Backend logout error:\", backendError);\n      }\n    }\n\n    // Create response\n    const response = NextResponse.json({\n      success: true,\n      message: \"Logged out successfully\",\n    });\n\n    // Clear all auth cookies by setting them with maxAge: 0\n    response.cookies.set(\"splice_token\", \"\", {\n      httpOnly: true,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n\n    response.cookies.set(\"splice_refresh_token\", \"\", {\n      httpOnly: true,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n\n    response.cookies.set(\"splice_auth_status\", \"\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n\n    response.cookies.set(\"splice_user\", \"\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n\n    return response;\n  } catch (error) {\n    console.error(\"[Auth] Logout error:\", error);\n\n    // Even on error, try to clear cookies\n    const response = NextResponse.json(\n      {\n        success: true,\n        message: \"Logged out locally\",\n      },\n      { status: 200 }\n    );\n\n    // Clear cookies anyway\n    response.cookies.set(\"splice_token\", \"\", { maxAge: 0, path: \"/\" });\n    response.cookies.set(\"splice_refresh_token\", \"\", { maxAge: 0, path: \"/\" });\n    response.cookies.set(\"splice_auth_status\", \"\", { maxAge: 0, path: \"/\" });\n    response.cookies.set(\"splice_user\", \"\", { maxAge: 0, path: \"/\" });\n\n    return response;\n  }\n}\n","numLines":94,"startLine":1,"totalLines":94}}}
{"parentUuid":"c0ba08d2-de2a-4b50-866a-96c29efc15b1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012XTxRuqKgPCtQMP5mQ7fAn","type":"tool_result","content":"     1→/**\n     2→ * CSRF Protection Utilities for Next.js API Routes (Server-side)\n     3→ *\n     4→ * Validates CSRF tokens in incoming requests.\n     5→ * Works with the double-submit cookie pattern.\n     6→ */\n     7→\n     8→import { NextRequest, NextResponse } from \"next/server\";\n     9→import { cookies } from \"next/headers\";\n    10→\n    11→// Constants (must match client-side)\n    12→const CSRF_COOKIE_NAME = \"splice_csrf\";\n    13→const CSRF_HEADER_NAME = \"x-csrf-token\";\n    14→\n    15→/**\n    16→ * Constant-time string comparison to prevent timing attacks\n    17→ */\n    18→function safeCompare(a: string, b: string): boolean {\n    19→  if (a.length !== b.length) {\n    20→    return false;\n    21→  }\n    22→\n    23→  let result = 0;\n    24→  for (let i = 0; i < a.length; i++) {\n    25→    result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    26→  }\n    27→  return result === 0;\n    28→}\n    29→\n    30→/**\n    31→ * Validate CSRF token from request\n    32→ * Compares the token in the header with the token in the cookie\n    33→ *\n    34→ * @param request - Next.js request object\n    35→ * @returns { valid: boolean, error?: string }\n    36→ */\n    37→export async function validateCsrfToken(\n    38→  request: NextRequest\n    39→): Promise<{ valid: boolean; error?: string }> {\n    40→  // Get token from header\n    41→  const headerToken = request.headers.get(CSRF_HEADER_NAME);\n    42→\n    43→  if (!headerToken) {\n    44→    return {\n    45→      valid: false,\n    46→      error: \"CSRF token missing from request header\",\n    47→    };\n    48→  }\n    49→\n    50→  // Get token from cookie\n    51→  const cookieStore = await cookies();\n    52→  const cookieToken = cookieStore.get(CSRF_COOKIE_NAME)?.value;\n    53→\n    54→  if (!cookieToken) {\n    55→    return {\n    56→      valid: false,\n    57→      error: \"CSRF cookie not found. Please refresh the page.\",\n    58→    };\n    59→  }\n    60→\n    61→  // Compare tokens using constant-time comparison\n    62→  if (!safeCompare(headerToken, cookieToken)) {\n    63→    return {\n    64→      valid: false,\n    65→      error: \"CSRF token validation failed. Please refresh the page.\",\n    66→    };\n    67→  }\n    68→\n    69→  return { valid: true };\n    70→}\n    71→\n    72→/**\n    73→ * CSRF validation wrapper for API route handlers\n    74→ * Returns an error response if CSRF validation fails\n    75→ *\n    76→ * @param request - Next.js request object\n    77→ * @returns NextResponse if validation fails, null if valid\n    78→ */\n    79→export async function csrfGuard(\n    80→  request: NextRequest\n    81→): Promise<NextResponse | null> {\n    82→  // Skip CSRF validation for safe methods\n    83→  if ([\"GET\", \"HEAD\", \"OPTIONS\"].includes(request.method)) {\n    84→    return null;\n    85→  }\n    86→\n    87→  const result = await validateCsrfToken(request);\n    88→\n    89→  if (!result.valid) {\n    90→    console.warn(\"[CSRF] Validation failed:\", result.error);\n    91→    return NextResponse.json(\n    92→      {\n    93→        error: \"CSRF validation failed\",\n    94→        message: result.error || \"Please refresh the page and try again\",\n    95→      },\n    96→      { status: 403 }\n    97→    );\n    98→  }\n    99→\n   100→  return null;\n   101→}\n   102→\n   103→/**\n   104→ * Higher-order function to wrap API handlers with CSRF protection\n   105→ *\n   106→ * @example\n   107→ * ```typescript\n   108→ * export const POST = withCsrfProtection(async (request) => {\n   109→ *   // Your handler code here\n   110→ *   return NextResponse.json({ success: true });\n   111→ * });\n   112→ * ```\n   113→ */\n   114→export function withCsrfProtection(\n   115→  handler: (request: NextRequest) => Promise<NextResponse>\n   116→): (request: NextRequest) => Promise<NextResponse> {\n   117→  return async (request: NextRequest): Promise<NextResponse> => {\n   118→    const csrfError = await csrfGuard(request);\n   119→    if (csrfError) {\n   120→      return csrfError;\n   121→    }\n   122→    return handler(request);\n   123→  };\n   124→}\n   125→\n   126→export { CSRF_COOKIE_NAME, CSRF_HEADER_NAME };\n   127→\n\n</system-reminder>\n"}]},"uuid":"d50a677b-7f5e-46e5-bdfb-8e39da2796f0","timestamp":"2025-12-30T02:10:23.342Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/lib/csrf-server.ts","content":"/**\n * CSRF Protection Utilities for Next.js API Routes (Server-side)\n *\n * Validates CSRF tokens in incoming requests.\n * Works with the double-submit cookie pattern.\n */\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { cookies } from \"next/headers\";\n\n// Constants (must match client-side)\nconst CSRF_COOKIE_NAME = \"splice_csrf\";\nconst CSRF_HEADER_NAME = \"x-csrf-token\";\n\n/**\n * Constant-time string comparison to prevent timing attacks\n */\nfunction safeCompare(a: string, b: string): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n  }\n  return result === 0;\n}\n\n/**\n * Validate CSRF token from request\n * Compares the token in the header with the token in the cookie\n *\n * @param request - Next.js request object\n * @returns { valid: boolean, error?: string }\n */\nexport async function validateCsrfToken(\n  request: NextRequest\n): Promise<{ valid: boolean; error?: string }> {\n  // Get token from header\n  const headerToken = request.headers.get(CSRF_HEADER_NAME);\n\n  if (!headerToken) {\n    return {\n      valid: false,\n      error: \"CSRF token missing from request header\",\n    };\n  }\n\n  // Get token from cookie\n  const cookieStore = await cookies();\n  const cookieToken = cookieStore.get(CSRF_COOKIE_NAME)?.value;\n\n  if (!cookieToken) {\n    return {\n      valid: false,\n      error: \"CSRF cookie not found. Please refresh the page.\",\n    };\n  }\n\n  // Compare tokens using constant-time comparison\n  if (!safeCompare(headerToken, cookieToken)) {\n    return {\n      valid: false,\n      error: \"CSRF token validation failed. Please refresh the page.\",\n    };\n  }\n\n  return { valid: true };\n}\n\n/**\n * CSRF validation wrapper for API route handlers\n * Returns an error response if CSRF validation fails\n *\n * @param request - Next.js request object\n * @returns NextResponse if validation fails, null if valid\n */\nexport async function csrfGuard(\n  request: NextRequest\n): Promise<NextResponse | null> {\n  // Skip CSRF validation for safe methods\n  if ([\"GET\", \"HEAD\", \"OPTIONS\"].includes(request.method)) {\n    return null;\n  }\n\n  const result = await validateCsrfToken(request);\n\n  if (!result.valid) {\n    console.warn(\"[CSRF] Validation failed:\", result.error);\n    return NextResponse.json(\n      {\n        error: \"CSRF validation failed\",\n        message: result.error || \"Please refresh the page and try again\",\n      },\n      { status: 403 }\n    );\n  }\n\n  return null;\n}\n\n/**\n * Higher-order function to wrap API handlers with CSRF protection\n *\n * @example\n * ```typescript\n * export const POST = withCsrfProtection(async (request) => {\n *   // Your handler code here\n *   return NextResponse.json({ success: true });\n * });\n * ```\n */\nexport function withCsrfProtection(\n  handler: (request: NextRequest) => Promise<NextResponse>\n): (request: NextRequest) => Promise<NextResponse> {\n  return async (request: NextRequest): Promise<NextResponse> => {\n    const csrfError = await csrfGuard(request);\n    if (csrfError) {\n      return csrfError;\n    }\n    return handler(request);\n  };\n}\n\nexport { CSRF_COOKIE_NAME, CSRF_HEADER_NAME };\n","numLines":127,"startLine":1,"totalLines":127}}}
{"parentUuid":"d50a677b-7f5e-46e5-bdfb-8e39da2796f0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_011midYgXRvsLQmXY6jKpCgB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012rGuCqRof6jz5sDc7eMKLG","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6228,"cache_read_input_tokens":87755,"cache_creation":{"ephemeral_5m_input_tokens":6228,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWc4P2RJwafTPuRazDPmX","type":"assistant","uuid":"70f1edb7-678a-4df0-aa14-dc75d298bbd9","timestamp":"2025-12-30T02:10:28.468Z"}
{"parentUuid":"70f1edb7-678a-4df0-aa14-dc75d298bbd9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_011midYgXRvsLQmXY6jKpCgB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Pob94ZjktbejLpwP9fbwee","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/billing.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6228,"cache_read_input_tokens":87755,"cache_creation":{"ephemeral_5m_input_tokens":6228,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWc4P2RJwafTPuRazDPmX","type":"assistant","uuid":"e3bd1ba1-d4f0-46bc-a02f-9a41c6a8693f","timestamp":"2025-12-30T02:10:29.040Z"}
{"parentUuid":"e3bd1ba1-d4f0-46bc-a02f-9a41c6a8693f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_011midYgXRvsLQmXY6jKpCgB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YBuyeKE2v4neFP6nyNXZ67","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/redisClient.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6228,"cache_read_input_tokens":87755,"cache_creation":{"ephemeral_5m_input_tokens":6228,"ephemeral_1h_input_tokens":0},"output_tokens":184,"service_tier":"standard"}},"requestId":"req_011CWc4P2RJwafTPuRazDPmX","type":"assistant","uuid":"6af0221a-b769-4cbc-be39-04ccacf20723","timestamp":"2025-12-30T02:10:29.646Z"}
{"parentUuid":"6af0221a-b769-4cbc-be39-04ccacf20723","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Pob94ZjktbejLpwP9fbwee","type":"tool_result","content":"     1→/**\n     2→ * Billing Routes\n     3→ *\n     4→ * Credits and usage history endpoints\n     5→ */\n     6→\n     7→const express = require('express');\n     8→\n     9→/**\n    10→ * Create billing routes\n    11→ * @param {Object} options - Route configuration options\n    12→ * @param {Object} options.services - Shared services (usageTracking)\n    13→ * @param {Object} options.authHelpers - Auth helper functions (verifyToken)\n    14→ * @returns {express.Router}\n    15→ */\n    16→function createBillingRoutes(options = {}) {\n    17→  const router = express.Router();\n    18→  const { usageTracking } = options.services || {};\n    19→  const { verifyToken } = options.authHelpers || {};\n    20→\n    21→  /**\n    22→   * GET /credits - Get user's credit balance\n    23→   *\n    24→   * Supports both JWT (Authorization: Bearer) and legacy x-stripe-customer-id header\n    25→   */\n    26→  router.get('/credits', async (req, res) => {\n    27→    // Support both JWT and legacy auth\n    28→    let stripeCustomerId = null;\n    29→\n    30→    // Try JWT first\n    31→    const authHeader = req.headers['authorization'];\n    32→    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n    33→      const token = authHeader.slice(7);\n    34→      const decoded = await verifyToken(token);\n    35→      if (decoded && decoded.sub) {\n    36→        stripeCustomerId = decoded.sub;\n    37→      }\n    38→    }\n    39→\n    40→    // Fallback to legacy header\n    41→    if (!stripeCustomerId) {\n    42→      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    43→    }\n    44→\n    45→    if (!stripeCustomerId) {\n    46→      return res.status(401).json({\n    47→        error: 'Authentication required',\n    48→        message: 'Please provide a valid Bearer token or log in again'\n    49→      });\n    50→    }\n    51→\n    52→    try {\n    53→      const balance = await usageTracking.getBalance(stripeCustomerId);\n    54→      res.json({\n    55→        success: true,\n    56→        ...balance\n    57→      });\n    58→    } catch (err) {\n    59→      console.error('[SPLICE] Credits error:', err);\n    60→      res.status(500).json({ error: err.message });\n    61→    }\n    62→  });\n    63→\n    64→  /**\n    65→   * GET /usage-history - Get user's usage history\n    66→   */\n    67→  router.get('/usage-history', async (req, res) => {\n    68→    // Support both JWT and legacy auth\n    69→    let stripeCustomerId = null;\n    70→\n    71→    const authHeader = req.headers['authorization'];\n    72→    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n    73→      const token = authHeader.slice(7);\n    74→      const decoded = await verifyToken(token);\n    75→      if (decoded && decoded.sub) {\n    76→        stripeCustomerId = decoded.sub;\n    77→      }\n    78→    }\n    79→\n    80→    if (!stripeCustomerId) {\n    81→      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    82→    }\n    83→\n    84→    if (!stripeCustomerId) {\n    85→      return res.status(401).json({\n    86→        error: 'Authentication required',\n    87→        message: 'Please provide a valid Bearer token or log in again'\n    88→      });\n    89→    }\n    90→\n    91→    try {\n    92→      const history = await usageTracking.getUsageHistory(stripeCustomerId);\n    93→      res.json({\n    94→        success: true,\n    95→        history\n    96→      });\n    97→    } catch (err) {\n    98→      console.error('[SPLICE] Usage history error:', err);\n    99→      res.status(500).json({ error: err.message });\n   100→    }\n   101→  });\n   102→\n   103→  return router;\n   104→}\n   105→\n   106→module.exports = createBillingRoutes;\n   107→\n\n</system-reminder>\n"}]},"uuid":"9c1d5b81-6de9-4744-ace3-2892eb6409a2","timestamp":"2025-12-30T02:10:29.692Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/billing.js","content":"/**\n * Billing Routes\n *\n * Credits and usage history endpoints\n */\n\nconst express = require('express');\n\n/**\n * Create billing routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.services - Shared services (usageTracking)\n * @param {Object} options.authHelpers - Auth helper functions (verifyToken)\n * @returns {express.Router}\n */\nfunction createBillingRoutes(options = {}) {\n  const router = express.Router();\n  const { usageTracking } = options.services || {};\n  const { verifyToken } = options.authHelpers || {};\n\n  /**\n   * GET /credits - Get user's credit balance\n   *\n   * Supports both JWT (Authorization: Bearer) and legacy x-stripe-customer-id header\n   */\n  router.get('/credits', async (req, res) => {\n    // Support both JWT and legacy auth\n    let stripeCustomerId = null;\n\n    // Try JWT first\n    const authHeader = req.headers['authorization'];\n    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n      const token = authHeader.slice(7);\n      const decoded = await verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n      }\n    }\n\n    // Fallback to legacy header\n    if (!stripeCustomerId) {\n      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please provide a valid Bearer token or log in again'\n      });\n    }\n\n    try {\n      const balance = await usageTracking.getBalance(stripeCustomerId);\n      res.json({\n        success: true,\n        ...balance\n      });\n    } catch (err) {\n      console.error('[SPLICE] Credits error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * GET /usage-history - Get user's usage history\n   */\n  router.get('/usage-history', async (req, res) => {\n    // Support both JWT and legacy auth\n    let stripeCustomerId = null;\n\n    const authHeader = req.headers['authorization'];\n    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n      const token = authHeader.slice(7);\n      const decoded = await verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n      }\n    }\n\n    if (!stripeCustomerId) {\n      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please provide a valid Bearer token or log in again'\n      });\n    }\n\n    try {\n      const history = await usageTracking.getUsageHistory(stripeCustomerId);\n      res.json({\n        success: true,\n        history\n      });\n    } catch (err) {\n      console.error('[SPLICE] Usage history error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createBillingRoutes;\n","numLines":107,"startLine":1,"totalLines":107}}}
{"parentUuid":"9c1d5b81-6de9-4744-ace3-2892eb6409a2","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YBuyeKE2v4neFP6nyNXZ67","type":"tool_result","content":"     1→/**\n     2→ * Shared Redis Client Service\n     3→ * Uses Upstash Redis for distributed caching and storage\n     4→ * Provides both REST-based (@upstash/redis) and ioredis connections\n     5→ */\n     6→\n     7→const { Redis } = require('@upstash/redis');\n     8→\n     9→// Singleton instances\n    10→let restClient = null;\n    11→let isConnected = false;\n    12→let connectionError = null;\n    13→\n    14→/**\n    15→ * Get the Upstash REST Redis client (recommended for most operations)\n    16→ * This client works well in serverless environments\n    17→ * @returns {Redis|null} Redis client or null if not configured\n    18→ */\n    19→function getRedisClient() {\n    20→  if (restClient) {\n    21→    return restClient;\n    22→  }\n    23→\n    24→  const url = process.env.UPSTASH_REDIS_REST_URL;\n    25→  const token = process.env.UPSTASH_REDIS_REST_TOKEN;\n    26→\n    27→  if (!url || !token) {\n    28→    console.warn('[Redis] Missing UPSTASH_REDIS_REST_URL or UPSTASH_REDIS_REST_TOKEN - Redis features disabled');\n    29→    connectionError = new Error('Redis not configured');\n    30→    return null;\n    31→  }\n    32→\n    33→  try {\n    34→    restClient = new Redis({\n    35→      url,\n    36→      token,\n    37→      automaticDeserialization: true,\n    38→    });\n    39→    isConnected = true;\n    40→    console.log('[Redis] Upstash REST client initialized');\n    41→    return restClient;\n    42→  } catch (err) {\n    43→    console.error('[Redis] Failed to initialize Upstash REST client:', err.message);\n    44→    connectionError = err;\n    45→    return null;\n    46→  }\n    47→}\n    48→\n    49→/**\n    50→ * Check if Redis is available and connected\n    51→ * @returns {boolean} True if Redis is available\n    52→ */\n    53→function isRedisAvailable() {\n    54→  if (restClient && isConnected) {\n    55→    return true;\n    56→  }\n    57→  // Try to initialize if not yet attempted\n    58→  const client = getRedisClient();\n    59→  return client !== null;\n    60→}\n    61→\n    62→/**\n    63→ * Get Redis connection status\n    64→ * @returns {Object} { connected, error }\n    65→ */\n    66→function getRedisStatus() {\n    67→  return {\n    68→    connected: isConnected && restClient !== null,\n    69→    error: connectionError ? connectionError.message : null,\n    70→    type: restClient ? 'upstash-rest' : 'none'\n    71→  };\n    72→}\n    73→\n    74→/**\n    75→ * Ping Redis to check connectivity\n    76→ * @returns {Promise<boolean>} True if ping successful\n    77→ */\n    78→async function pingRedis() {\n    79→  const client = getRedisClient();\n    80→  if (!client) {\n    81→    return false;\n    82→  }\n    83→\n    84→  try {\n    85→    const result = await client.ping();\n    86→    return result === 'PONG';\n    87→  } catch (err) {\n    88→    console.error('[Redis] Ping failed:', err.message);\n    89→    isConnected = false;\n    90→    connectionError = err;\n    91→    return false;\n    92→  }\n    93→}\n    94→\n    95→/**\n    96→ * Set a value with optional TTL\n    97→ * @param {string} key - Redis key\n    98→ * @param {any} value - Value to store (will be JSON serialized)\n    99→ * @param {number} ttlSeconds - Optional TTL in seconds\n   100→ * @returns {Promise<boolean>} True if successful\n   101→ */\n   102→async function set(key, value, ttlSeconds = null) {\n   103→  const client = getRedisClient();\n   104→  if (!client) {\n   105→    return false;\n   106→  }\n   107→\n   108→  try {\n   109→    if (ttlSeconds) {\n   110→      await client.set(key, value, { ex: ttlSeconds });\n   111→    } else {\n   112→      await client.set(key, value);\n   113→    }\n   114→    return true;\n   115→  } catch (err) {\n   116→    console.error('[Redis] SET failed:', err.message);\n   117→    return false;\n   118→  }\n   119→}\n   120→\n   121→/**\n   122→ * Get a value\n   123→ * @param {string} key - Redis key\n   124→ * @returns {Promise<any|null>} Value or null if not found\n   125→ */\n   126→async function get(key) {\n   127→  const client = getRedisClient();\n   128→  if (!client) {\n   129→    return null;\n   130→  }\n   131→\n   132→  try {\n   133→    return await client.get(key);\n   134→  } catch (err) {\n   135→    console.error('[Redis] GET failed:', err.message);\n   136→    return null;\n   137→  }\n   138→}\n   139→\n   140→/**\n   141→ * Check if a key exists\n   142→ * @param {string} key - Redis key\n   143→ * @returns {Promise<boolean>} True if key exists\n   144→ */\n   145→async function exists(key) {\n   146→  const client = getRedisClient();\n   147→  if (!client) {\n   148→    return false;\n   149→  }\n   150→\n   151→  try {\n   152→    const result = await client.exists(key);\n   153→    return result === 1;\n   154→  } catch (err) {\n   155→    console.error('[Redis] EXISTS failed:', err.message);\n   156→    return false;\n   157→  }\n   158→}\n   159→\n   160→/**\n   161→ * Delete a key\n   162→ * @param {string} key - Redis key\n   163→ * @returns {Promise<boolean>} True if deleted\n   164→ */\n   165→async function del(key) {\n   166→  const client = getRedisClient();\n   167→  if (!client) {\n   168→    return false;\n   169→  }\n   170→\n   171→  try {\n   172→    await client.del(key);\n   173→    return true;\n   174→  } catch (err) {\n   175→    console.error('[Redis] DEL failed:', err.message);\n   176→    return false;\n   177→  }\n   178→}\n   179→\n   180→/**\n   181→ * Set a value only if it doesn't exist (SETNX)\n   182→ * @param {string} key - Redis key\n   183→ * @param {any} value - Value to store\n   184→ * @param {number} ttlSeconds - Optional TTL in seconds\n   185→ * @returns {Promise<boolean>} True if set (key didn't exist)\n   186→ */\n   187→async function setNX(key, value, ttlSeconds = null) {\n   188→  const client = getRedisClient();\n   189→  if (!client) {\n   190→    return false;\n   191→  }\n   192→\n   193→  try {\n   194→    const options = { nx: true };\n   195→    if (ttlSeconds) {\n   196→      options.ex = ttlSeconds;\n   197→    }\n   198→    const result = await client.set(key, value, options);\n   199→    return result === 'OK';\n   200→  } catch (err) {\n   201→    console.error('[Redis] SETNX failed:', err.message);\n   202→    return false;\n   203→  }\n   204→}\n   205→\n   206→/**\n   207→ * Get TTL of a key\n   208→ * @param {string} key - Redis key\n   209→ * @returns {Promise<number>} TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n   210→ */\n   211→async function ttl(key) {\n   212→  const client = getRedisClient();\n   213→  if (!client) {\n   214→    return -2;\n   215→  }\n   216→\n   217→  try {\n   218→    return await client.ttl(key);\n   219→  } catch (err) {\n   220→    console.error('[Redis] TTL failed:', err.message);\n   221→    return -2;\n   222→  }\n   223→}\n   224→\n   225→module.exports = {\n   226→  getRedisClient,\n   227→  isRedisAvailable,\n   228→  getRedisStatus,\n   229→  pingRedis,\n   230→  // Convenience methods\n   231→  set,\n   232→  get,\n   233→  exists,\n   234→  del,\n   235→  setNX,\n   236→  ttl\n   237→};\n   238→\n\n</system-reminder>\n"}]},"uuid":"664e20f6-bce0-499a-807e-cdb8835c7457","timestamp":"2025-12-30T02:10:29.692Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/redisClient.js","content":"/**\n * Shared Redis Client Service\n * Uses Upstash Redis for distributed caching and storage\n * Provides both REST-based (@upstash/redis) and ioredis connections\n */\n\nconst { Redis } = require('@upstash/redis');\n\n// Singleton instances\nlet restClient = null;\nlet isConnected = false;\nlet connectionError = null;\n\n/**\n * Get the Upstash REST Redis client (recommended for most operations)\n * This client works well in serverless environments\n * @returns {Redis|null} Redis client or null if not configured\n */\nfunction getRedisClient() {\n  if (restClient) {\n    return restClient;\n  }\n\n  const url = process.env.UPSTASH_REDIS_REST_URL;\n  const token = process.env.UPSTASH_REDIS_REST_TOKEN;\n\n  if (!url || !token) {\n    console.warn('[Redis] Missing UPSTASH_REDIS_REST_URL or UPSTASH_REDIS_REST_TOKEN - Redis features disabled');\n    connectionError = new Error('Redis not configured');\n    return null;\n  }\n\n  try {\n    restClient = new Redis({\n      url,\n      token,\n      automaticDeserialization: true,\n    });\n    isConnected = true;\n    console.log('[Redis] Upstash REST client initialized');\n    return restClient;\n  } catch (err) {\n    console.error('[Redis] Failed to initialize Upstash REST client:', err.message);\n    connectionError = err;\n    return null;\n  }\n}\n\n/**\n * Check if Redis is available and connected\n * @returns {boolean} True if Redis is available\n */\nfunction isRedisAvailable() {\n  if (restClient && isConnected) {\n    return true;\n  }\n  // Try to initialize if not yet attempted\n  const client = getRedisClient();\n  return client !== null;\n}\n\n/**\n * Get Redis connection status\n * @returns {Object} { connected, error }\n */\nfunction getRedisStatus() {\n  return {\n    connected: isConnected && restClient !== null,\n    error: connectionError ? connectionError.message : null,\n    type: restClient ? 'upstash-rest' : 'none'\n  };\n}\n\n/**\n * Ping Redis to check connectivity\n * @returns {Promise<boolean>} True if ping successful\n */\nasync function pingRedis() {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    const result = await client.ping();\n    return result === 'PONG';\n  } catch (err) {\n    console.error('[Redis] Ping failed:', err.message);\n    isConnected = false;\n    connectionError = err;\n    return false;\n  }\n}\n\n/**\n * Set a value with optional TTL\n * @param {string} key - Redis key\n * @param {any} value - Value to store (will be JSON serialized)\n * @param {number} ttlSeconds - Optional TTL in seconds\n * @returns {Promise<boolean>} True if successful\n */\nasync function set(key, value, ttlSeconds = null) {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    if (ttlSeconds) {\n      await client.set(key, value, { ex: ttlSeconds });\n    } else {\n      await client.set(key, value);\n    }\n    return true;\n  } catch (err) {\n    console.error('[Redis] SET failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get a value\n * @param {string} key - Redis key\n * @returns {Promise<any|null>} Value or null if not found\n */\nasync function get(key) {\n  const client = getRedisClient();\n  if (!client) {\n    return null;\n  }\n\n  try {\n    return await client.get(key);\n  } catch (err) {\n    console.error('[Redis] GET failed:', err.message);\n    return null;\n  }\n}\n\n/**\n * Check if a key exists\n * @param {string} key - Redis key\n * @returns {Promise<boolean>} True if key exists\n */\nasync function exists(key) {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    const result = await client.exists(key);\n    return result === 1;\n  } catch (err) {\n    console.error('[Redis] EXISTS failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Delete a key\n * @param {string} key - Redis key\n * @returns {Promise<boolean>} True if deleted\n */\nasync function del(key) {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    await client.del(key);\n    return true;\n  } catch (err) {\n    console.error('[Redis] DEL failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Set a value only if it doesn't exist (SETNX)\n * @param {string} key - Redis key\n * @param {any} value - Value to store\n * @param {number} ttlSeconds - Optional TTL in seconds\n * @returns {Promise<boolean>} True if set (key didn't exist)\n */\nasync function setNX(key, value, ttlSeconds = null) {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    const options = { nx: true };\n    if (ttlSeconds) {\n      options.ex = ttlSeconds;\n    }\n    const result = await client.set(key, value, options);\n    return result === 'OK';\n  } catch (err) {\n    console.error('[Redis] SETNX failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get TTL of a key\n * @param {string} key - Redis key\n * @returns {Promise<number>} TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n */\nasync function ttl(key) {\n  const client = getRedisClient();\n  if (!client) {\n    return -2;\n  }\n\n  try {\n    return await client.ttl(key);\n  } catch (err) {\n    console.error('[Redis] TTL failed:', err.message);\n    return -2;\n  }\n}\n\nmodule.exports = {\n  getRedisClient,\n  isRedisAvailable,\n  getRedisStatus,\n  pingRedis,\n  // Convenience methods\n  set,\n  get,\n  exists,\n  del,\n  setNX,\n  ttl\n};\n","numLines":238,"startLine":1,"totalLines":238}}}
{"parentUuid":"664e20f6-bce0-499a-807e-cdb8835c7457","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012rGuCqRof6jz5sDc7eMKLG","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Panel Configuration\n     3→ * Backend URLs, paths, and utility functions\n     4→ */\n     5→\n     6→// ============================================================================\n     7→// BACKEND CONFIGURATION\n     8→// ============================================================================\n     9→const SPLICE_CONFIG = {\n    10→    VERSION: '6.0.3',\n    11→    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    12→    BACKEND_DEV: 'https://127.0.0.1:3847',\n    13→    FETCH_TIMEOUT: 120000, // 2 minutes\n    14→    RETRY_ATTEMPTS: 3,\n    15→    RETRY_DELAY: 1000\n    16→};\n    17→\n    18→/**\n    19→ * Get the backend URL based on environment\n    20→ */\n    21→function getBackendUrl() {\n    22→    // Check for development mode\n    23→    const isDev = window.location.protocol === 'file:' ||\n    24→                  window.location.hostname === 'localhost' ||\n    25→                  window.location.hostname === '127.0.0.1';\n    26→\n    27→    // Allow override via localStorage\n    28→    const customUrl = localStorage.getItem('spliceBackendUrl');\n    29→    if (customUrl) return customUrl;\n    30→\n    31→    return isDev ? SPLICE_CONFIG.BACKEND_DEV : SPLICE_CONFIG.BACKEND_PROD;\n    32→}\n    33→\n    34→// ============================================================================\n    35→// JSX BRIDGE - Communicate with Premiere Pro\n    36→// ============================================================================\n    37→const jsx = {\n    38→    cs: null,\n    39→    _initPromise: null,\n    40→    _initialized: false,\n    41→\n    42→    /**\n    43→     * Initialize the CSInterface\n    44→     * Returns a promise that resolves when ready\n    45→     */\n    46→    init: function() {\n    47→        if (this._initPromise) return this._initPromise;\n    48→\n    49→        this._initPromise = new Promise((resolve) => {\n    50→            if (typeof CSInterface !== 'undefined') {\n    51→                this.cs = new CSInterface();\n    52→                this._initialized = true;\n    53→                console.log('[JSX] CSInterface initialized successfully');\n    54→            } else {\n    55→                console.warn('[JSX] CSInterface not available');\n    56→            }\n    57→            resolve(this._initialized);\n    58→        });\n    59→\n    60→        return this._initPromise;\n    61→    },\n    62→\n    63→    /**\n    64→     * Ensure JSX is initialized before making calls\n    65→     */\n    66→    ensureInitialized: async function() {\n    67→        if (!this._initialized) {\n    68→            await this.init();\n    69→        }\n    70→        if (!this.cs) {\n    71→            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n    72→        }\n    73→    },\n    74→\n    75→    /**\n    76→     * Execute ExtendScript in Premiere Pro\n    77→     * @param {string} script - ExtendScript to execute\n    78→     * @returns {Promise<any>} - Parsed result\n    79→     */\n    80→    evalScript: async function(script) {\n    81→        await this.ensureInitialized();\n    82→\n    83→        return new Promise((resolve, reject) => {\n    84→            this.cs.evalScript(script, (result) => {\n    85→                if (result === 'undefined' || result === undefined) {\n    86→                    resolve(null);\n    87→                    return;\n    88→                }\n    89→\n    90→                // Check for EvalScript error or ExtendScript runtime errors\n    91→                if (typeof result === 'string' && (\n    92→                    result.indexOf('EvalScript error') !== -1 ||\n    93→                    result.indexOf('Error:') !== -1 ||\n    94→                    result.indexOf('TypeError:') !== -1 ||\n    95→                    result.indexOf('ReferenceError:') !== -1\n    96→                )) {\n    97→                    reject(new Error(result));\n    98→                    return;\n    99→                }\n   100→\n   101→                // Try to parse JSON\n   102→                try {\n   103→                    const parsed = JSON.parse(result);\n   104→                    if (parsed.error) {\n   105→                        reject(new Error(parsed.error));\n   106→                    } else {\n   107→                        resolve(parsed);\n   108→                    }\n   109→                } catch (e) {\n   110→                    // Return as-is if not JSON\n   111→                    resolve(result);\n   112→                }\n   113→            });\n   114→        });\n   115→    },\n   116→\n   117→    /**\n   118→     * Call a JSX function with arguments\n   119→     * @param {string} funcName - Function name\n   120→     * @param {...any} args - Arguments to pass\n   121→     * @returns {Promise<any>}\n   122→     */\n   123→    call: async function(funcName, ...args) {\n   124→        await this.ensureInitialized();\n   125→\n   126→        const escapedArgs = args.map(arg => {\n   127→            if (arg === null || arg === undefined) return 'null';\n   128→            if (typeof arg === 'string') {\n   129→                // Escape backslashes first, then other special chars\n   130→                return `'${arg\n   131→                    .replace(/\\\\/g, '\\\\\\\\')\n   132→                    .replace(/'/g, \"\\\\'\")\n   133→                    .replace(/\\r/g, '\\\\r')\n   134→                    .replace(/\\n/g, '\\\\n')\n   135→                    .replace(/\\t/g, '\\\\t')}'`;\n   136→            }\n   137→            if (typeof arg === 'object') {\n   138→                return `'${JSON.stringify(arg)\n   139→                    .replace(/\\\\/g, '\\\\\\\\')\n   140→                    .replace(/'/g, \"\\\\'\")}'`;\n   141→            }\n   142→            return String(arg);\n   143→        });\n   144→\n   145→        const script = `${funcName}(${escapedArgs.join(', ')})`;\n   146→        return this.evalScript(script);\n   147→    }\n   148→};\n   149→\n   150→// ============================================================================\n   151→// FETCH UTILITIES\n   152→// ============================================================================\n   153→\n   154→/**\n   155→ * Fetch with timeout support\n   156→ * @param {string} url - URL to fetch\n   157→ * @param {object} options - Fetch options\n   158→ * @param {number} timeout - Timeout in ms\n   159→ */\n   160→async function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n   161→    const controller = new AbortController();\n   162→    const timeoutId = setTimeout(() => controller.abort(), timeout);\n   163→\n   164→    try {\n   165→        const response = await fetch(url, {\n   166→            ...options,\n   167→            signal: controller.signal\n   168→        });\n   169→        clearTimeout(timeoutId);\n   170→        return response;\n   171→    } catch (error) {\n   172→        clearTimeout(timeoutId);\n   173→        if (error.name === 'AbortError') {\n   174→            throw new Error(`Request timeout after ${timeout}ms`);\n   175→        }\n   176→        throw error;\n   177→    }\n   178→}\n   179→\n   180→/**\n   181→ * Parse error response from backend\n   182→ * @param {Response} response - Fetch response\n   183→ */\n   184→async function parseErrorResponse(response) {\n   185→    try {\n   186→        const data = await response.json();\n   187→        return data.error || data.message || `HTTP ${response.status}`;\n   188→    } catch {\n   189→        return `HTTP ${response.status}: ${response.statusText}`;\n   190→    }\n   191→}\n   192→\n   193→/**\n   194→ * Get auth headers for API requests\n   195→ */\n   196→function getAuthHeaders() {\n   197→    const headers = { 'Content-Type': 'application/json' };\n   198→    const settings = getSettings();\n   199→\n   200→    if (settings.customerId) {\n   201→        headers['x-stripe-customer-id'] = settings.customerId;\n   202→    }\n   203→    if (settings.licenseKey) {\n   204→        headers['x-license-key'] = settings.licenseKey;\n   205→    }\n   206→\n   207→    return headers;\n   208→}\n   209→\n   210→// ============================================================================\n   211→// SETTINGS MANAGEMENT\n   212→// ============================================================================\n   213→\n   214→const DEFAULT_SETTINGS = {\n   215→    sensitivity: 50,\n   216→    minSilenceLength: 0.5,\n   217→    sourceIsolated: false,\n   218→    enableTakesDetection: true,\n   219→    enableJCut: false,\n   220→    jcutLeadIn: 0.3,\n   221→    jcutLeadOut: 0.2,\n   222→    enableZoom: false,\n   223→    zoomFrequency: 'medium',\n   224→    zoomPreset: 'medium',\n   225→    zoomPlacement: 'sentence_start',\n   226→    enableChapters: false,\n   227→    maxChapters: 10,\n   228→    minChapterLength: 60,\n   229→    enableProfanity: false,\n   230→    profanityLanguage: 'en',\n   231→    bleepType: 'standard',\n   232→    customerId: null,\n   233→    licenseKey: null,\n   234→    expandedOptions: false,\n   235→    activePreset: 'podcast',\n   236→    rememberOptions: false\n   237→};\n   238→\n   239→/**\n   240→ * Get settings from localStorage\n   241→ */\n   242→function getSettings() {\n   243→    try {\n   244→        const stored = localStorage.getItem('spliceSettings');\n   245→        if (stored) {\n   246→            return { ...DEFAULT_SETTINGS, ...JSON.parse(stored) };\n   247→        }\n   248→    } catch (e) {\n   249→        console.warn('[Config] Error loading settings:', e);\n   250→    }\n   251→    return { ...DEFAULT_SETTINGS };\n   252→}\n   253→\n   254→/**\n   255→ * Save settings to localStorage\n   256→ */\n   257→function saveSettings(settings) {\n   258→    try {\n   259→        const merged = { ...getSettings(), ...settings };\n   260→        localStorage.setItem('spliceSettings', JSON.stringify(merged));\n   261→        return true;\n   262→    } catch (e) {\n   263→        console.warn('[Config] Error saving settings:', e);\n   264→        return false;\n   265→    }\n   266→}\n   267→\n   268→/**\n   269→ * Clear specific setting\n   270→ */\n   271→function clearSetting(key) {\n   272→    const settings = getSettings();\n   273→    delete settings[key];\n   274→    localStorage.setItem('spliceSettings', JSON.stringify(settings));\n   275→}\n   276→\n   277→// ============================================================================\n   278→// OFFLINE DETECTION\n   279→// ============================================================================\n   280→\n   281→let isOnlineState = true;\n   282→let offlineCheckInterval = null;\n   283→\n   284→/**\n   285→ * Check if online\n   286→ */\n   287→function isOnline() {\n   288→    return isOnlineState && navigator.onLine;\n   289→}\n   290→\n   291→/**\n   292→ * Initialize offline detection\n   293→ */\n   294→function initOfflineDetection() {\n   295→    // Browser events\n   296→    window.addEventListener('online', () => {\n   297→        isOnlineState = true;\n   298→        updateOfflineUI(true);\n   299→    });\n   300→\n   301→    window.addEventListener('offline', () => {\n   302→        isOnlineState = false;\n   303→        updateOfflineUI(false);\n   304→    });\n   305→\n   306→    // Periodic check\n   307→    offlineCheckInterval = setInterval(async () => {\n   308→        try {\n   309→            const response = await fetchWithTimeout(\n   310→                `${getBackendUrl()}/health`,\n   311→                { method: 'GET' },\n   312→                5000\n   313→            );\n   314→            isOnlineState = response.ok;\n   315→        } catch {\n   316→            isOnlineState = false;\n   317→        }\n   318→        updateOfflineUI(isOnlineState);\n   319→    }, 30000);\n   320→}\n   321→\n   322→/**\n   323→ * Update UI based on online state\n   324→ */\n   325→function updateOfflineUI(online) {\n   326→    const goBtn = document.getElementById('goBtn');\n   327→    const status = document.getElementById('status');\n   328→\n   329→    if (goBtn) {\n   330→        goBtn.disabled = !online;\n   331→    }\n   332→\n   333→    if (status) {\n   334→        if (!online) {\n   335→            status.textContent = 'Offline - Check your connection';\n   336→            status.style.color = '#dc3545';\n   337→        } else {\n   338→            // Reset status when back online\n   339→            status.textContent = 'Ready';\n   340→            status.style.color = '#888';\n   341→        }\n   342→    }\n   343→}\n   344→\n   345→// ============================================================================\n   346→// UTILITY FUNCTIONS\n   347→// ============================================================================\n   348→\n   349→/**\n   350→ * SECURITY: Escape HTML to prevent XSS attacks\n   351→ * Use this when inserting untrusted content into innerHTML\n   352→ * @param {string} str - String to escape\n   353→ * @returns {string} Escaped string safe for innerHTML\n   354→ */\n   355→function escapeHtml(str) {\n   356→    if (str === null || str === undefined) return '';\n   357→    if (typeof str !== 'string') str = String(str);\n   358→\n   359→    const escapeMap = {\n   360→        '&': '&amp;',\n   361→        '<': '&lt;',\n   362→        '>': '&gt;',\n   363→        '\"': '&quot;',\n   364→        \"'\": '&#x27;',\n   365→        '/': '&#x2F;',\n   366→        '`': '&#x60;'\n   367→    };\n   368→\n   369→    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n   370→}\n   371→\n   372→/**\n   373→ * SECURITY: Create safe HTML from template with escaped values\n   374→ * @param {TemplateStringsArray} strings - Template strings\n   375→ * @param {...any} values - Values to escape\n   376→ * @returns {string} HTML with escaped values\n   377→ */\n   378→function safeHtml(strings, ...values) {\n   379→    return strings.reduce((result, str, i) => {\n   380→        const value = values[i - 1];\n   381→        const escaped = escapeHtml(value);\n   382→        return result + escaped + str;\n   383→    });\n   384→}\n   385→\n   386→/**\n   387→ * Format time in MM:SS or HH:MM:SS\n   388→ */\n   389→function formatTime(seconds) {\n   390→    if (isNaN(seconds) || seconds < 0) return '0:00';\n   391→\n   392→    const hours = Math.floor(seconds / 3600);\n   393→    const minutes = Math.floor((seconds % 3600) / 60);\n   394→    const secs = Math.floor(seconds % 60);\n   395→\n   396→    if (hours > 0) {\n   397→        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n   398→    }\n   399→    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n   400→}\n   401→\n   402→/**\n   403→ * Set status message\n   404→ */\n   405→function setStatus(message, isError = false) {\n   406→    const status = document.getElementById('status');\n   407→    if (status) {\n   408→        status.textContent = message;\n   409→        status.style.color = isError ? '#dc3545' : '#888';\n   410→    }\n   411→}\n   412→\n   413→/**\n   414→ * Debounce function calls\n   415→ */\n   416→function debounce(func, wait) {\n   417→    let timeout;\n   418→    return function executedFunction(...args) {\n   419→        const later = () => {\n   420→            clearTimeout(timeout);\n   421→            func(...args);\n   422→        };\n   423→        clearTimeout(timeout);\n   424→        timeout = setTimeout(later, wait);\n   425→    };\n   426→}\n   427→\n   428→// ============================================================================\n   429→// PRESET PROFILES\n   430→// ============================================================================\n   431→\n   432→/**\n   433→ * Detection presets for different content types.\n   434→ * Each preset defines optimal settings for a specific use case.\n   435→ */\n   436→const PRESETS = {\n   437→    // Custom - user-defined settings (default)\n   438→    custom: {\n   439→        name: 'Custom',\n   440→        description: 'Your custom settings',\n   441→        icon: 'settings',\n   442→        settings: null // Uses current user settings\n   443→    },\n   444→\n   445→    // Podcast - longer pauses are natural, be conservative\n   446→    podcast: {\n   447→        name: 'Podcast',\n   448→        description: 'Longer natural pauses, J-Cuts enabled',\n   449→        icon: 'mic',\n   450→        settings: {\n   451→            sensitivity: 35,\n   452→            threshold: -35,\n   453→            minSilenceLength: 0.8,\n   454→            paddingStart: 0.15,\n   455→            paddingEnd: 0.15,\n   456→            enableTakesDetection: true,\n   457→            enableJCut: true,\n   458→            jCutLeadIn: 0.3,\n   459→            jCutLeadOut: 0.2\n   460→        }\n   461→    },\n   462→\n   463→    // Interview - balanced, respects speaker pauses\n   464→    interview: {\n   465→        name: 'Interview',\n   466→        description: 'Balanced cuts, J-Cuts for smooth transitions',\n   467→        icon: 'people',\n   468→        settings: {\n   469→            sensitivity: 50,\n   470→            threshold: -32,\n   471→            minSilenceLength: 0.5,\n   472→            paddingStart: 0.12,\n   473→            paddingEnd: 0.08,\n   474→            enableTakesDetection: true,\n   475→            enableJCut: true,\n   476→            jCutLeadIn: 0.25,\n   477→            jCutLeadOut: 0.15\n   478→        }\n   479→    },\n   480→\n   481→    // Reaction video - fast pacing, quick cuts\n   482→    reaction: {\n   483→        name: 'Reaction',\n   484→        description: 'Fast-paced, tight cuts for energy',\n   485→        icon: 'bolt',\n   486→        settings: {\n   487→            sensitivity: 70,\n   488→            threshold: -28,\n   489→            minSilenceLength: 0.3,\n   490→            paddingStart: 0.05,\n   491→            paddingEnd: 0.03,\n   492→            enableTakesDetection: false,\n   493→            enableJCut: false,\n   494→            jCutLeadIn: 0,\n   495→            jCutLeadOut: 0\n   496→        }\n   497→    },\n   498→\n   499→    // Tutorial/Educational - preserve thinking pauses\n   500→    tutorial: {\n   501→        name: 'Tutorial',\n   502→        description: 'Preserves teaching pace, J-Cuts enabled',\n   503→        icon: 'school',\n   504→        settings: {\n   505→            sensitivity: 30,\n   506→            threshold: -38,\n   507→            minSilenceLength: 1.0,\n   508→            paddingStart: 0.2,\n   509→            paddingEnd: 0.15,\n   510→            enableTakesDetection: true,\n   511→            enableJCut: true,\n   512→            jCutLeadIn: 0.35,\n   513→            jCutLeadOut: 0.25\n   514→        }\n   515→    },\n   516→\n   517→    // Vlog/YouTube - punchy edits, engagement-focused\n   518→    vlog: {\n   519→        name: 'Vlog',\n   520→        description: 'Punchy edits for YouTube engagement',\n   521→        icon: 'videocam',\n   522→        settings: {\n   523→            sensitivity: 65,\n   524→            threshold: -30,\n   525→            minSilenceLength: 0.35,\n   526→            paddingStart: 0.08,\n   527→            paddingEnd: 0.05,\n   528→            enableTakesDetection: true,\n   529→            enableJCut: false,\n   530→            jCutLeadIn: 0,\n   531→            jCutLeadOut: 0\n   532→        }\n   533→    }\n   534→};\n   535→\n   536→/**\n   537→ * List of built-in preset IDs\n   538→ */\n   539→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n   540→\n   541→/**\n   542→ * Get all available presets\n   543→ * @returns {Object} All preset definitions\n   544→ */\n   545→function getPresets() {\n   546→    return { ...PRESETS };\n   547→}\n   548→\n   549→/**\n   550→ * Get a specific preset by name\n   551→ * @param {string} presetName - Name of the preset\n   552→ * @returns {Object|null} Preset definition or null if not found\n   553→ */\n   554→function getPreset(presetName) {\n   555→    return PRESETS[presetName] || null;\n   556→}\n   557→\n   558→/**\n   559→ * Check if a preset is a built-in preset\n   560→ * @param {string} id - Preset ID to check\n   561→ * @returns {boolean} True if built-in, false if custom\n   562→ */\n   563→function isBuiltInPreset(id) {\n   564→    return BUILT_IN_PRESET_IDS.includes(id);\n   565→}\n   566→\n   567→/**\n   568→ * Apply a preset to current settings\n   569→ * @param {string} presetName - Name of the preset to apply\n   570→ * @returns {Object} The applied settings\n   571→ */\n   572→function applyPreset(presetName) {\n   573→    const preset = PRESETS[presetName];\n   574→\n   575→    if (!preset) {\n   576→        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n   577→        return getSettings();\n   578→    }\n   579→\n   580→    // Custom preset uses current settings\n   581→    if (presetName === 'custom' || !preset.settings) {\n   582→        saveSettings({ activePreset: 'custom' });\n   583→        return getSettings();\n   584→    }\n   585→\n   586→    // Apply preset settings\n   587→    const newSettings = {\n   588→        ...preset.settings,\n   589→        activePreset: presetName\n   590→    };\n   591→\n   592→    saveSettings(newSettings);\n   593→    console.log(`[SPLICE] Applied preset: ${preset.name}`);\n   594→\n   595→    return getSettings();\n   596→}\n   597→\n   598→/**\n   599→ * Get the currently active preset\n   600→ * @returns {string} Active preset name\n   601→ */\n   602→function getActivePreset() {\n   603→    const settings = getSettings();\n   604→    return settings.activePreset || 'custom';\n   605→}\n   606→\n   607→/**\n   608→ * Initialize preset selector\n   609→ */\n   610→function initPresetSelector() {\n   611→    const presetSelector = document.getElementById('presetSelector');\n   612→    const sensitivitySlider = document.getElementById('sensitivitySlider');\n   613→\n   614→    if (!presetSelector) return;\n   615→\n   616→    // Set initial value from settings\n   617→    const settings = getSettings();\n   618→    presetSelector.value = settings.activePreset || 'podcast';\n   619→\n   620→    // Handle preset change\n   621→    presetSelector.addEventListener('change', () => {\n   622→        const presetId = presetSelector.value;\n   623→        const appliedSettings = applyPreset(presetId);\n   624→\n   625→        // Update sensitivity slider to match preset\n   626→        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n   627→            sensitivitySlider.value = appliedSettings.sensitivity;\n   628→            // Update display value\n   629→            const sensitivityValue = document.getElementById('sensitivityValue');\n   630→            if (sensitivityValue) {\n   631→                sensitivityValue.textContent = appliedSettings.sensitivity;\n   632→            }\n   633→        }\n   634→\n   635→        // Update takes detection checkbox\n   636→        const enableTakesDetection = document.getElementById('enableTakesDetection');\n   637→        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n   638→            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n   639→        }\n   640→\n   641→        // Update J-Cut checkbox\n   642→        const enableJCut = document.getElementById('enableJCut');\n   643→        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n   644→            enableJCut.checked = appliedSettings.enableJCut;\n   645→            // Toggle J-Cut settings visibility\n   646→            const jcutSettings = document.getElementById('jcutSettings');\n   647→            if (jcutSettings) {\n   648→                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n   649→            }\n   650→        }\n   651→\n   652→        const preset = getPreset(presetId);\n   653→        if (preset) {\n   654→            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n   655→        }\n   656→    });\n   657→\n   658→    // Switch to custom when user manually changes sensitivity\n   659→    if (sensitivitySlider) {\n   660→        sensitivitySlider.addEventListener('change', () => {\n   661→            if (presetSelector.value !== 'custom') {\n   662→                presetSelector.value = 'custom';\n   663→                saveSettings({ activePreset: 'custom' });\n   664→            }\n   665→        });\n   666→    }\n   667→}\n   668→\n   669→// ============================================================================\n   670→// LOGIN MODAL\n   671→// ============================================================================\n   672→\n   673→/**\n   674→ * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n   675→ * Character set excludes confusing chars: 0/O, 1/I/L\n   676→ */\n   677→function isValidLicenseKeyFormat(key) {\n   678→    if (!key || typeof key !== 'string') return false;\n   679→    const normalized = key.toUpperCase().trim();\n   680→    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n   681→    return pattern.test(normalized);\n   682→}\n   683→\n   684→/**\n   685→ * Initialize login modal handlers\n   686→ */\n   687→function initLoginModal() {\n   688→    const loginModal = document.getElementById('loginModal');\n   689→    const closeLoginBtn = document.getElementById('closeLoginBtn');\n   690→    const saveLoginBtn = document.getElementById('saveLoginBtn');\n   691→    const licenseKeyInput = document.getElementById('licenseKeyInput');\n   692→    const creditBadge = document.getElementById('creditBadge');\n   693→\n   694→    // Handle credit badge click - retry on error, or show login modal\n   695→    if (creditBadge) {\n   696→        creditBadge.addEventListener('click', async () => {\n   697→            if (creditBadge.classList.contains('error')) {\n   698→                creditBadge.textContent = '...';\n   699→                if (typeof refreshCredits === 'function') {\n   700→                    await refreshCredits();\n   701→                }\n   702→                return;\n   703→            }\n   704→            showLoginModal();\n   705→        });\n   706→    }\n   707→\n   708→    // Close login modal\n   709→    if (closeLoginBtn && loginModal) {\n   710→        closeLoginBtn.addEventListener('click', () => {\n   711→            loginModal.classList.add('hidden');\n   712→        });\n   713→    }\n   714→\n   715→    // Close on backdrop click\n   716→    if (loginModal) {\n   717→        loginModal.addEventListener('click', (e) => {\n   718→            if (e.target === loginModal) {\n   719→                loginModal.classList.add('hidden');\n   720→            }\n   721→        });\n   722→    }\n   723→\n   724→    // Activate license key\n   725→    if (saveLoginBtn) {\n   726→        saveLoginBtn.addEventListener('click', async () => {\n   727→            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n   728→\n   729→            if (!licenseKey) {\n   730→                showLoginError('Please enter your license key');\n   731→                return;\n   732→            }\n   733→\n   734→            if (!isValidLicenseKeyFormat(licenseKey)) {\n   735→                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n   736→                return;\n   737→            }\n   738→\n   739→            saveLoginBtn.disabled = true;\n   740→            saveLoginBtn.textContent = 'Activating...';\n   741→\n   742→            try {\n   743→                const response = await fetchWithTimeout(`${getBackendUrl()}/license/activate`, {\n   744→                    method: 'POST',\n   745→                    headers: { 'Content-Type': 'application/json' },\n   746→                    body: JSON.stringify({ key: licenseKey })\n   747→                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n   748→\n   749→                const result = await response.json();\n   750→\n   751→                if (!result.success) {\n   752→                    showLoginError(result.error || 'Activation failed');\n   753→                    return;\n   754→                }\n   755→\n   756→                saveSettings({ customerId: result.customerId });\n   757→                loginModal?.classList.add('hidden');\n   758→\n   759→                if (typeof refreshCredits === 'function') {\n   760→                    await refreshCredits();\n   761→                }\n   762→\n   763→                setStatus(`License activated! ${result.tierName} tier`);\n   764→            } catch (err) {\n   765→                console.error('[SPLICE] License activation error:', err);\n   766→                showLoginError('Connection error. Check server is running.');\n   767→            } finally {\n   768→                saveLoginBtn.disabled = false;\n   769→                saveLoginBtn.textContent = 'Activate';\n   770→            }\n   771→        });\n   772→    }\n   773→\n   774→    // Email lookup\n   775→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n   776→    const lookupEmailInput = document.getElementById('lookupEmailInput');\n   777→\n   778→    if (lookupLicenseBtn) {\n   779→        lookupLicenseBtn.addEventListener('click', async () => {\n   780→            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n   781→\n   782→            if (!email) {\n   783→                showLoginError('Please enter your email address');\n   784→                return;\n   785→            }\n   786→\n   787→            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n   788→            if (!emailRegex.test(email)) {\n   789→                showLoginError('Please enter a valid email address');\n   790→                return;\n   791→            }\n   792→\n   793→            lookupLicenseBtn.disabled = true;\n   794→            lookupLicenseBtn.textContent = 'Looking up...';\n   795→\n   796→            try {\n   797→                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n   798→                    method: 'POST',\n   799→                    headers: { 'Content-Type': 'application/json' },\n   800→                    body: JSON.stringify({ email })\n   801→                }, 30000);\n   802→\n   803→                const result = await response.json();\n   804→\n   805→                // Note: For security, the backend does NOT return the license key directly.\n   806→                // It sends the key via email to prevent enumeration attacks.\n   807→                if (result.success) {\n   808→                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n   809→                } else {\n   810→                    showLoginError(result.error || 'Lookup failed. Please try again.');\n   811→                }\n   812→            } catch (err) {\n   813→                console.error('[SPLICE] License lookup error:', err);\n   814→                showLoginError('Failed to look up license. Please try again.');\n   815→            } finally {\n   816→                lookupLicenseBtn.disabled = false;\n   817→                lookupLicenseBtn.textContent = 'Lookup';\n   818→            }\n   819→        });\n   820→    }\n   821→}\n   822→\n   823→/**\n   824→ * Show login modal\n   825→ */\n   826→function showLoginModal() {\n   827→    const loginModal = document.getElementById('loginModal');\n   828→    const loginError = document.getElementById('loginError');\n   829→    if (loginError) loginError.style.display = 'none';\n   830→    if (loginModal) loginModal.classList.remove('hidden');\n   831→}\n   832→\n   833→/**\n   834→ * Show login error message\n   835→ */\n   836→function showLoginError(message) {\n   837→    const loginError = document.getElementById('loginError');\n   838→    if (loginError) {\n   839→        loginError.textContent = message;\n   840→        loginError.style.display = 'block';\n   841→    }\n   842→}\n   843→\n   844→/**\n   845→ * Check if user is logged in\n   846→ */\n   847→function isLoggedIn() {\n   848→    const settings = getSettings();\n   849→    return !!settings.customerId;\n   850→}\n   851→\n   852→/**\n   853→ * Logout - clear customer ID\n   854→ */\n   855→function logout() {\n   856→    saveSettings({ customerId: null });\n   857→    if (typeof clearCreditsCache === 'function') {\n   858→        clearCreditsCache();\n   859→    }\n   860→    if (typeof updateCreditDisplay === 'function') {\n   861→        updateCreditDisplay(null);\n   862→    }\n   863→    setStatus('Logged out');\n   864→}\n   865→\n   866→// Initialize JSX bridge when loaded\n   867→document.addEventListener('DOMContentLoaded', () => {\n   868→    jsx.init();\n   869→});\n   870→\n   871→// Export for modules\n   872→window.SPLICE_CONFIG = SPLICE_CONFIG;\n   873→window.getBackendUrl = getBackendUrl;\n   874→window.fetchWithTimeout = fetchWithTimeout;\n   875→window.parseErrorResponse = parseErrorResponse;\n   876→window.getAuthHeaders = getAuthHeaders;\n   877→window.getSettings = getSettings;\n   878→window.saveSettings = saveSettings;\n   879→window.clearSetting = clearSetting;\n   880→window.isOnline = isOnline;\n   881→window.initOfflineDetection = initOfflineDetection;\n   882→window.formatTime = formatTime;\n   883→window.setStatus = setStatus;\n   884→window.debounce = debounce;\n   885→window.jsx = jsx;\n   886→window.PRESETS = PRESETS;\n   887→window.getPresets = getPresets;\n   888→window.getPreset = getPreset;\n   889→window.applyPreset = applyPreset;\n   890→window.getActivePreset = getActivePreset;\n   891→window.isBuiltInPreset = isBuiltInPreset;\n   892→window.initPresetSelector = initPresetSelector;\n   893→window.initLoginModal = initLoginModal;\n   894→window.showLoginModal = showLoginModal;\n   895→window.isLoggedIn = isLoggedIn;\n   896→window.logout = logout;\n   897→window.escapeHtml = escapeHtml;\n   898→window.safeHtml = safeHtml;\n   899→\n\n</system-reminder>\n"}]},"uuid":"645acd86-4371-42da-a3e3-17be8b5605c3","timestamp":"2025-12-30T02:10:29.820Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js","content":"/**\n * SPLICE CEP Panel Configuration\n * Backend URLs, paths, and utility functions\n */\n\n// ============================================================================\n// BACKEND CONFIGURATION\n// ============================================================================\nconst SPLICE_CONFIG = {\n    VERSION: '6.0.3',\n    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    BACKEND_DEV: 'https://127.0.0.1:3847',\n    FETCH_TIMEOUT: 120000, // 2 minutes\n    RETRY_ATTEMPTS: 3,\n    RETRY_DELAY: 1000\n};\n\n/**\n * Get the backend URL based on environment\n */\nfunction getBackendUrl() {\n    // Check for development mode\n    const isDev = window.location.protocol === 'file:' ||\n                  window.location.hostname === 'localhost' ||\n                  window.location.hostname === '127.0.0.1';\n\n    // Allow override via localStorage\n    const customUrl = localStorage.getItem('spliceBackendUrl');\n    if (customUrl) return customUrl;\n\n    return isDev ? SPLICE_CONFIG.BACKEND_DEV : SPLICE_CONFIG.BACKEND_PROD;\n}\n\n// ============================================================================\n// JSX BRIDGE - Communicate with Premiere Pro\n// ============================================================================\nconst jsx = {\n    cs: null,\n    _initPromise: null,\n    _initialized: false,\n\n    /**\n     * Initialize the CSInterface\n     * Returns a promise that resolves when ready\n     */\n    init: function() {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = new Promise((resolve) => {\n            if (typeof CSInterface !== 'undefined') {\n                this.cs = new CSInterface();\n                this._initialized = true;\n                console.log('[JSX] CSInterface initialized successfully');\n            } else {\n                console.warn('[JSX] CSInterface not available');\n            }\n            resolve(this._initialized);\n        });\n\n        return this._initPromise;\n    },\n\n    /**\n     * Ensure JSX is initialized before making calls\n     */\n    ensureInitialized: async function() {\n        if (!this._initialized) {\n            await this.init();\n        }\n        if (!this.cs) {\n            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n        }\n    },\n\n    /**\n     * Execute ExtendScript in Premiere Pro\n     * @param {string} script - ExtendScript to execute\n     * @returns {Promise<any>} - Parsed result\n     */\n    evalScript: async function(script) {\n        await this.ensureInitialized();\n\n        return new Promise((resolve, reject) => {\n            this.cs.evalScript(script, (result) => {\n                if (result === 'undefined' || result === undefined) {\n                    resolve(null);\n                    return;\n                }\n\n                // Check for EvalScript error or ExtendScript runtime errors\n                if (typeof result === 'string' && (\n                    result.indexOf('EvalScript error') !== -1 ||\n                    result.indexOf('Error:') !== -1 ||\n                    result.indexOf('TypeError:') !== -1 ||\n                    result.indexOf('ReferenceError:') !== -1\n                )) {\n                    reject(new Error(result));\n                    return;\n                }\n\n                // Try to parse JSON\n                try {\n                    const parsed = JSON.parse(result);\n                    if (parsed.error) {\n                        reject(new Error(parsed.error));\n                    } else {\n                        resolve(parsed);\n                    }\n                } catch (e) {\n                    // Return as-is if not JSON\n                    resolve(result);\n                }\n            });\n        });\n    },\n\n    /**\n     * Call a JSX function with arguments\n     * @param {string} funcName - Function name\n     * @param {...any} args - Arguments to pass\n     * @returns {Promise<any>}\n     */\n    call: async function(funcName, ...args) {\n        await this.ensureInitialized();\n\n        const escapedArgs = args.map(arg => {\n            if (arg === null || arg === undefined) return 'null';\n            if (typeof arg === 'string') {\n                // Escape backslashes first, then other special chars\n                return `'${arg\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")\n                    .replace(/\\r/g, '\\\\r')\n                    .replace(/\\n/g, '\\\\n')\n                    .replace(/\\t/g, '\\\\t')}'`;\n            }\n            if (typeof arg === 'object') {\n                return `'${JSON.stringify(arg)\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")}'`;\n            }\n            return String(arg);\n        });\n\n        const script = `${funcName}(${escapedArgs.join(', ')})`;\n        return this.evalScript(script);\n    }\n};\n\n// ============================================================================\n// FETCH UTILITIES\n// ============================================================================\n\n/**\n * Fetch with timeout support\n * @param {string} url - URL to fetch\n * @param {object} options - Fetch options\n * @param {number} timeout - Timeout in ms\n */\nasync function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n        const response = await fetch(url, {\n            ...options,\n            signal: controller.signal\n        });\n        clearTimeout(timeoutId);\n        return response;\n    } catch (error) {\n        clearTimeout(timeoutId);\n        if (error.name === 'AbortError') {\n            throw new Error(`Request timeout after ${timeout}ms`);\n        }\n        throw error;\n    }\n}\n\n/**\n * Parse error response from backend\n * @param {Response} response - Fetch response\n */\nasync function parseErrorResponse(response) {\n    try {\n        const data = await response.json();\n        return data.error || data.message || `HTTP ${response.status}`;\n    } catch {\n        return `HTTP ${response.status}: ${response.statusText}`;\n    }\n}\n\n/**\n * Get auth headers for API requests\n */\nfunction getAuthHeaders() {\n    const headers = { 'Content-Type': 'application/json' };\n    const settings = getSettings();\n\n    if (settings.customerId) {\n        headers['x-stripe-customer-id'] = settings.customerId;\n    }\n    if (settings.licenseKey) {\n        headers['x-license-key'] = settings.licenseKey;\n    }\n\n    return headers;\n}\n\n// ============================================================================\n// SETTINGS MANAGEMENT\n// ============================================================================\n\nconst DEFAULT_SETTINGS = {\n    sensitivity: 50,\n    minSilenceLength: 0.5,\n    sourceIsolated: false,\n    enableTakesDetection: true,\n    enableJCut: false,\n    jcutLeadIn: 0.3,\n    jcutLeadOut: 0.2,\n    enableZoom: false,\n    zoomFrequency: 'medium',\n    zoomPreset: 'medium',\n    zoomPlacement: 'sentence_start',\n    enableChapters: false,\n    maxChapters: 10,\n    minChapterLength: 60,\n    enableProfanity: false,\n    profanityLanguage: 'en',\n    bleepType: 'standard',\n    customerId: null,\n    licenseKey: null,\n    expandedOptions: false,\n    activePreset: 'podcast',\n    rememberOptions: false\n};\n\n/**\n * Get settings from localStorage\n */\nfunction getSettings() {\n    try {\n        const stored = localStorage.getItem('spliceSettings');\n        if (stored) {\n            return { ...DEFAULT_SETTINGS, ...JSON.parse(stored) };\n        }\n    } catch (e) {\n        console.warn('[Config] Error loading settings:', e);\n    }\n    return { ...DEFAULT_SETTINGS };\n}\n\n/**\n * Save settings to localStorage\n */\nfunction saveSettings(settings) {\n    try {\n        const merged = { ...getSettings(), ...settings };\n        localStorage.setItem('spliceSettings', JSON.stringify(merged));\n        return true;\n    } catch (e) {\n        console.warn('[Config] Error saving settings:', e);\n        return false;\n    }\n}\n\n/**\n * Clear specific setting\n */\nfunction clearSetting(key) {\n    const settings = getSettings();\n    delete settings[key];\n    localStorage.setItem('spliceSettings', JSON.stringify(settings));\n}\n\n// ============================================================================\n// OFFLINE DETECTION\n// ============================================================================\n\nlet isOnlineState = true;\nlet offlineCheckInterval = null;\n\n/**\n * Check if online\n */\nfunction isOnline() {\n    return isOnlineState && navigator.onLine;\n}\n\n/**\n * Initialize offline detection\n */\nfunction initOfflineDetection() {\n    // Browser events\n    window.addEventListener('online', () => {\n        isOnlineState = true;\n        updateOfflineUI(true);\n    });\n\n    window.addEventListener('offline', () => {\n        isOnlineState = false;\n        updateOfflineUI(false);\n    });\n\n    // Periodic check\n    offlineCheckInterval = setInterval(async () => {\n        try {\n            const response = await fetchWithTimeout(\n                `${getBackendUrl()}/health`,\n                { method: 'GET' },\n                5000\n            );\n            isOnlineState = response.ok;\n        } catch {\n            isOnlineState = false;\n        }\n        updateOfflineUI(isOnlineState);\n    }, 30000);\n}\n\n/**\n * Update UI based on online state\n */\nfunction updateOfflineUI(online) {\n    const goBtn = document.getElementById('goBtn');\n    const status = document.getElementById('status');\n\n    if (goBtn) {\n        goBtn.disabled = !online;\n    }\n\n    if (status) {\n        if (!online) {\n            status.textContent = 'Offline - Check your connection';\n            status.style.color = '#dc3545';\n        } else {\n            // Reset status when back online\n            status.textContent = 'Ready';\n            status.style.color = '#888';\n        }\n    }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * SECURITY: Escape HTML to prevent XSS attacks\n * Use this when inserting untrusted content into innerHTML\n * @param {string} str - String to escape\n * @returns {string} Escaped string safe for innerHTML\n */\nfunction escapeHtml(str) {\n    if (str === null || str === undefined) return '';\n    if (typeof str !== 'string') str = String(str);\n\n    const escapeMap = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;',\n        '/': '&#x2F;',\n        '`': '&#x60;'\n    };\n\n    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n}\n\n/**\n * SECURITY: Create safe HTML from template with escaped values\n * @param {TemplateStringsArray} strings - Template strings\n * @param {...any} values - Values to escape\n * @returns {string} HTML with escaped values\n */\nfunction safeHtml(strings, ...values) {\n    return strings.reduce((result, str, i) => {\n        const value = values[i - 1];\n        const escaped = escapeHtml(value);\n        return result + escaped + str;\n    });\n}\n\n/**\n * Format time in MM:SS or HH:MM:SS\n */\nfunction formatTime(seconds) {\n    if (isNaN(seconds) || seconds < 0) return '0:00';\n\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n\n    if (hours > 0) {\n        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Set status message\n */\nfunction setStatus(message, isError = false) {\n    const status = document.getElementById('status');\n    if (status) {\n        status.textContent = message;\n        status.style.color = isError ? '#dc3545' : '#888';\n    }\n}\n\n/**\n * Debounce function calls\n */\nfunction debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n        const later = () => {\n            clearTimeout(timeout);\n            func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n\n// ============================================================================\n// PRESET PROFILES\n// ============================================================================\n\n/**\n * Detection presets for different content types.\n * Each preset defines optimal settings for a specific use case.\n */\nconst PRESETS = {\n    // Custom - user-defined settings (default)\n    custom: {\n        name: 'Custom',\n        description: 'Your custom settings',\n        icon: 'settings',\n        settings: null // Uses current user settings\n    },\n\n    // Podcast - longer pauses are natural, be conservative\n    podcast: {\n        name: 'Podcast',\n        description: 'Longer natural pauses, J-Cuts enabled',\n        icon: 'mic',\n        settings: {\n            sensitivity: 35,\n            threshold: -35,\n            minSilenceLength: 0.8,\n            paddingStart: 0.15,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.3,\n            jCutLeadOut: 0.2\n        }\n    },\n\n    // Interview - balanced, respects speaker pauses\n    interview: {\n        name: 'Interview',\n        description: 'Balanced cuts, J-Cuts for smooth transitions',\n        icon: 'people',\n        settings: {\n            sensitivity: 50,\n            threshold: -32,\n            minSilenceLength: 0.5,\n            paddingStart: 0.12,\n            paddingEnd: 0.08,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.25,\n            jCutLeadOut: 0.15\n        }\n    },\n\n    // Reaction video - fast pacing, quick cuts\n    reaction: {\n        name: 'Reaction',\n        description: 'Fast-paced, tight cuts for energy',\n        icon: 'bolt',\n        settings: {\n            sensitivity: 70,\n            threshold: -28,\n            minSilenceLength: 0.3,\n            paddingStart: 0.05,\n            paddingEnd: 0.03,\n            enableTakesDetection: false,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    },\n\n    // Tutorial/Educational - preserve thinking pauses\n    tutorial: {\n        name: 'Tutorial',\n        description: 'Preserves teaching pace, J-Cuts enabled',\n        icon: 'school',\n        settings: {\n            sensitivity: 30,\n            threshold: -38,\n            minSilenceLength: 1.0,\n            paddingStart: 0.2,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.35,\n            jCutLeadOut: 0.25\n        }\n    },\n\n    // Vlog/YouTube - punchy edits, engagement-focused\n    vlog: {\n        name: 'Vlog',\n        description: 'Punchy edits for YouTube engagement',\n        icon: 'videocam',\n        settings: {\n            sensitivity: 65,\n            threshold: -30,\n            minSilenceLength: 0.35,\n            paddingStart: 0.08,\n            paddingEnd: 0.05,\n            enableTakesDetection: true,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    }\n};\n\n/**\n * List of built-in preset IDs\n */\nconst BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n\n/**\n * Get all available presets\n * @returns {Object} All preset definitions\n */\nfunction getPresets() {\n    return { ...PRESETS };\n}\n\n/**\n * Get a specific preset by name\n * @param {string} presetName - Name of the preset\n * @returns {Object|null} Preset definition or null if not found\n */\nfunction getPreset(presetName) {\n    return PRESETS[presetName] || null;\n}\n\n/**\n * Check if a preset is a built-in preset\n * @param {string} id - Preset ID to check\n * @returns {boolean} True if built-in, false if custom\n */\nfunction isBuiltInPreset(id) {\n    return BUILT_IN_PRESET_IDS.includes(id);\n}\n\n/**\n * Apply a preset to current settings\n * @param {string} presetName - Name of the preset to apply\n * @returns {Object} The applied settings\n */\nfunction applyPreset(presetName) {\n    const preset = PRESETS[presetName];\n\n    if (!preset) {\n        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n        return getSettings();\n    }\n\n    // Custom preset uses current settings\n    if (presetName === 'custom' || !preset.settings) {\n        saveSettings({ activePreset: 'custom' });\n        return getSettings();\n    }\n\n    // Apply preset settings\n    const newSettings = {\n        ...preset.settings,\n        activePreset: presetName\n    };\n\n    saveSettings(newSettings);\n    console.log(`[SPLICE] Applied preset: ${preset.name}`);\n\n    return getSettings();\n}\n\n/**\n * Get the currently active preset\n * @returns {string} Active preset name\n */\nfunction getActivePreset() {\n    const settings = getSettings();\n    return settings.activePreset || 'custom';\n}\n\n/**\n * Initialize preset selector\n */\nfunction initPresetSelector() {\n    const presetSelector = document.getElementById('presetSelector');\n    const sensitivitySlider = document.getElementById('sensitivitySlider');\n\n    if (!presetSelector) return;\n\n    // Set initial value from settings\n    const settings = getSettings();\n    presetSelector.value = settings.activePreset || 'podcast';\n\n    // Handle preset change\n    presetSelector.addEventListener('change', () => {\n        const presetId = presetSelector.value;\n        const appliedSettings = applyPreset(presetId);\n\n        // Update sensitivity slider to match preset\n        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n            sensitivitySlider.value = appliedSettings.sensitivity;\n            // Update display value\n            const sensitivityValue = document.getElementById('sensitivityValue');\n            if (sensitivityValue) {\n                sensitivityValue.textContent = appliedSettings.sensitivity;\n            }\n        }\n\n        // Update takes detection checkbox\n        const enableTakesDetection = document.getElementById('enableTakesDetection');\n        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n        }\n\n        // Update J-Cut checkbox\n        const enableJCut = document.getElementById('enableJCut');\n        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n            enableJCut.checked = appliedSettings.enableJCut;\n            // Toggle J-Cut settings visibility\n            const jcutSettings = document.getElementById('jcutSettings');\n            if (jcutSettings) {\n                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n            }\n        }\n\n        const preset = getPreset(presetId);\n        if (preset) {\n            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n        }\n    });\n\n    // Switch to custom when user manually changes sensitivity\n    if (sensitivitySlider) {\n        sensitivitySlider.addEventListener('change', () => {\n            if (presetSelector.value !== 'custom') {\n                presetSelector.value = 'custom';\n                saveSettings({ activePreset: 'custom' });\n            }\n        });\n    }\n}\n\n// ============================================================================\n// LOGIN MODAL\n// ============================================================================\n\n/**\n * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n * Character set excludes confusing chars: 0/O, 1/I/L\n */\nfunction isValidLicenseKeyFormat(key) {\n    if (!key || typeof key !== 'string') return false;\n    const normalized = key.toUpperCase().trim();\n    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n    return pattern.test(normalized);\n}\n\n/**\n * Initialize login modal handlers\n */\nfunction initLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const closeLoginBtn = document.getElementById('closeLoginBtn');\n    const saveLoginBtn = document.getElementById('saveLoginBtn');\n    const licenseKeyInput = document.getElementById('licenseKeyInput');\n    const creditBadge = document.getElementById('creditBadge');\n\n    // Handle credit badge click - retry on error, or show login modal\n    if (creditBadge) {\n        creditBadge.addEventListener('click', async () => {\n            if (creditBadge.classList.contains('error')) {\n                creditBadge.textContent = '...';\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n                return;\n            }\n            showLoginModal();\n        });\n    }\n\n    // Close login modal\n    if (closeLoginBtn && loginModal) {\n        closeLoginBtn.addEventListener('click', () => {\n            loginModal.classList.add('hidden');\n        });\n    }\n\n    // Close on backdrop click\n    if (loginModal) {\n        loginModal.addEventListener('click', (e) => {\n            if (e.target === loginModal) {\n                loginModal.classList.add('hidden');\n            }\n        });\n    }\n\n    // Activate license key\n    if (saveLoginBtn) {\n        saveLoginBtn.addEventListener('click', async () => {\n            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n\n            if (!licenseKey) {\n                showLoginError('Please enter your license key');\n                return;\n            }\n\n            if (!isValidLicenseKeyFormat(licenseKey)) {\n                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n                return;\n            }\n\n            saveLoginBtn.disabled = true;\n            saveLoginBtn.textContent = 'Activating...';\n\n            try {\n                const response = await fetchWithTimeout(`${getBackendUrl()}/license/activate`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ key: licenseKey })\n                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n                const result = await response.json();\n\n                if (!result.success) {\n                    showLoginError(result.error || 'Activation failed');\n                    return;\n                }\n\n                saveSettings({ customerId: result.customerId });\n                loginModal?.classList.add('hidden');\n\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n\n                setStatus(`License activated! ${result.tierName} tier`);\n            } catch (err) {\n                console.error('[SPLICE] License activation error:', err);\n                showLoginError('Connection error. Check server is running.');\n            } finally {\n                saveLoginBtn.disabled = false;\n                saveLoginBtn.textContent = 'Activate';\n            }\n        });\n    }\n\n    // Email lookup\n    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n    const lookupEmailInput = document.getElementById('lookupEmailInput');\n\n    if (lookupLicenseBtn) {\n        lookupLicenseBtn.addEventListener('click', async () => {\n            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n\n            if (!email) {\n                showLoginError('Please enter your email address');\n                return;\n            }\n\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(email)) {\n                showLoginError('Please enter a valid email address');\n                return;\n            }\n\n            lookupLicenseBtn.disabled = true;\n            lookupLicenseBtn.textContent = 'Looking up...';\n\n            try {\n                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ email })\n                }, 30000);\n\n                const result = await response.json();\n\n                // Note: For security, the backend does NOT return the license key directly.\n                // It sends the key via email to prevent enumeration attacks.\n                if (result.success) {\n                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n                } else {\n                    showLoginError(result.error || 'Lookup failed. Please try again.');\n                }\n            } catch (err) {\n                console.error('[SPLICE] License lookup error:', err);\n                showLoginError('Failed to look up license. Please try again.');\n            } finally {\n                lookupLicenseBtn.disabled = false;\n                lookupLicenseBtn.textContent = 'Lookup';\n            }\n        });\n    }\n}\n\n/**\n * Show login modal\n */\nfunction showLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const loginError = document.getElementById('loginError');\n    if (loginError) loginError.style.display = 'none';\n    if (loginModal) loginModal.classList.remove('hidden');\n}\n\n/**\n * Show login error message\n */\nfunction showLoginError(message) {\n    const loginError = document.getElementById('loginError');\n    if (loginError) {\n        loginError.textContent = message;\n        loginError.style.display = 'block';\n    }\n}\n\n/**\n * Check if user is logged in\n */\nfunction isLoggedIn() {\n    const settings = getSettings();\n    return !!settings.customerId;\n}\n\n/**\n * Logout - clear customer ID\n */\nfunction logout() {\n    saveSettings({ customerId: null });\n    if (typeof clearCreditsCache === 'function') {\n        clearCreditsCache();\n    }\n    if (typeof updateCreditDisplay === 'function') {\n        updateCreditDisplay(null);\n    }\n    setStatus('Logged out');\n}\n\n// Initialize JSX bridge when loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    jsx.init();\n});\n\n// Export for modules\nwindow.SPLICE_CONFIG = SPLICE_CONFIG;\nwindow.getBackendUrl = getBackendUrl;\nwindow.fetchWithTimeout = fetchWithTimeout;\nwindow.parseErrorResponse = parseErrorResponse;\nwindow.getAuthHeaders = getAuthHeaders;\nwindow.getSettings = getSettings;\nwindow.saveSettings = saveSettings;\nwindow.clearSetting = clearSetting;\nwindow.isOnline = isOnline;\nwindow.initOfflineDetection = initOfflineDetection;\nwindow.formatTime = formatTime;\nwindow.setStatus = setStatus;\nwindow.debounce = debounce;\nwindow.jsx = jsx;\nwindow.PRESETS = PRESETS;\nwindow.getPresets = getPresets;\nwindow.getPreset = getPreset;\nwindow.applyPreset = applyPreset;\nwindow.getActivePreset = getActivePreset;\nwindow.isBuiltInPreset = isBuiltInPreset;\nwindow.initPresetSelector = initPresetSelector;\nwindow.initLoginModal = initLoginModal;\nwindow.showLoginModal = showLoginModal;\nwindow.isLoggedIn = isLoggedIn;\nwindow.logout = logout;\nwindow.escapeHtml = escapeHtml;\nwindow.safeHtml = safeHtml;\n","numLines":899,"startLine":1,"totalLines":899}}}
{"parentUuid":"645acd86-4371-42da-a3e3-17be8b5605c3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DbLLmF93n8FY15uaZ9ck4R","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check a few more routes and services to verify the full integration chain:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3698,"cache_creation_input_tokens":10557,"cache_read_input_tokens":93983,"cache_creation":{"ephemeral_5m_input_tokens":10557,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWc4PVUkQBFBGt1v4HTx3","type":"assistant","uuid":"bbbe1c00-96f0-4725-a2fa-2af57cf35676","timestamp":"2025-12-30T02:10:33.720Z"}
{"parentUuid":"bbbe1c00-96f0-4725-a2fa-2af57cf35676","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DbLLmF93n8FY15uaZ9ck4R","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WoGJMDLkqwvBbvTbsdsH9D","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/emailService.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3698,"cache_creation_input_tokens":10557,"cache_read_input_tokens":93983,"cache_creation":{"ephemeral_5m_input_tokens":10557,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWc4PVUkQBFBGt1v4HTx3","type":"assistant","uuid":"6e963dbd-cf26-47c0-a239-061db534c50b","timestamp":"2025-12-30T02:10:34.674Z"}
{"parentUuid":"6e963dbd-cf26-47c0-a239-061db534c50b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DbLLmF93n8FY15uaZ9ck4R","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016LwmkRjT4JZRtNWQAnq1hb","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/licenseService.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3698,"cache_creation_input_tokens":10557,"cache_read_input_tokens":93983,"cache_creation":{"ephemeral_5m_input_tokens":10557,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWc4PVUkQBFBGt1v4HTx3","type":"assistant","uuid":"7e1fd320-7dfc-47b2-a631-4ba0d706911c","timestamp":"2025-12-30T02:10:35.284Z"}
{"parentUuid":"7e1fd320-7dfc-47b2-a631-4ba0d706911c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DbLLmF93n8FY15uaZ9ck4R","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DqyoEuhGMMQaLDgaCeRfwk","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/analyze.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3698,"cache_creation_input_tokens":10557,"cache_read_input_tokens":93983,"cache_creation":{"ephemeral_5m_input_tokens":10557,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWc4PVUkQBFBGt1v4HTx3","type":"assistant","uuid":"72326c7c-e7d4-44cf-bdc5-fa0393c0378c","timestamp":"2025-12-30T02:10:35.911Z"}
{"parentUuid":"72326c7c-e7d4-44cf-bdc5-fa0393c0378c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DbLLmF93n8FY15uaZ9ck4R","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M1TsKJemKo8rLs9N6fXHFE","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/utils/authLogger.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3698,"cache_creation_input_tokens":10557,"cache_read_input_tokens":93983,"cache_creation":{"ephemeral_5m_input_tokens":10557,"ephemeral_1h_input_tokens":0},"output_tokens":255,"service_tier":"standard"}},"requestId":"req_011CWc4PVUkQBFBGt1v4HTx3","type":"assistant","uuid":"ab4e9f64-f2f6-4f1b-9b7f-fbb0e99edc57","timestamp":"2025-12-30T02:10:36.550Z"}
{"parentUuid":"ab4e9f64-f2f6-4f1b-9b7f-fbb0e99edc57","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016LwmkRjT4JZRtNWQAnq1hb","type":"tool_result","content":"     1→/**\n     2→ * License Key Service\n     3→ *\n     4→ * Generates and validates license keys for user authentication.\n     5→ * License keys are generated when a user purchases a subscription via Stripe.\n     6→ * Format: SPLICE-XXXX-XXXX-XXXX (alphanumeric, no confusing characters)\n     7→ */\n     8→\n     9→const { Pool } = require('pg');\n    10→const crypto = require('crypto');\n    11→\n    12→// SSL Configuration (same as usageTracking.js)\n    13→const sslConfig = process.env.NODE_ENV === 'production' ? {\n    14→  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n    15→  ca: process.env.DATABASE_SSL_CA || undefined\n    16→} : false;\n    17→\n    18→// Use the same pool configuration as other services\n    19→const pool = new Pool({\n    20→  connectionString: process.env.DATABASE_URL,\n    21→  ssl: sslConfig,\n    22→  max: 20,\n    23→  idleTimeoutMillis: 30000,\n    24→  connectionTimeoutMillis: 5000\n    25→});\n    26→\n    27→// Characters for key generation (no confusing chars: 0/O, 1/I/L)\n    28→const KEY_CHARS = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';\n    29→\n    30→/**\n    31→ * Initialize license_keys table\n    32→ */\n    33→async function initLicenseTables() {\n    34→  const client = await pool.connect();\n    35→  try {\n    36→    await client.query(`\n    37→      CREATE TABLE IF NOT EXISTS license_keys (\n    38→        id SERIAL PRIMARY KEY,\n    39→        key VARCHAR(21) UNIQUE NOT NULL,\n    40→        stripe_customer_id VARCHAR(255) NOT NULL,\n    41→        created_at TIMESTAMP DEFAULT NOW(),\n    42→        activated_at TIMESTAMP,\n    43→        is_active BOOLEAN DEFAULT TRUE\n    44→      )\n    45→    `);\n    46→\n    47→    // Migrate existing column if needed (for existing databases)\n    48→    await client.query(`\n    49→      DO $$\n    50→      BEGIN\n    51→        IF EXISTS (\n    52→          SELECT 1 FROM information_schema.columns\n    53→          WHERE table_name = 'license_keys'\n    54→          AND column_name = 'key'\n    55→          AND character_maximum_length = 19\n    56→        ) THEN\n    57→          ALTER TABLE license_keys ALTER COLUMN key TYPE VARCHAR(21);\n    58→        END IF;\n    59→      END $$;\n    60→    `);\n    61→\n    62→    // Add indexes for efficient lookups\n    63→    await client.query(`\n    64→      CREATE INDEX IF NOT EXISTS idx_license_keys_key\n    65→      ON license_keys(key)\n    66→    `);\n    67→\n    68→    await client.query(`\n    69→      CREATE INDEX IF NOT EXISTS idx_license_keys_customer\n    70→      ON license_keys(stripe_customer_id)\n    71→    `);\n    72→\n    73→    console.log('[License] Database tables initialized');\n    74→  } finally {\n    75→    client.release();\n    76→  }\n    77→}\n    78→\n    79→/**\n    80→ * Generate a random 4-character segment\n    81→ * @returns {string} 4 uppercase alphanumeric characters\n    82→ */\n    83→function generateSegment() {\n    84→  let segment = '';\n    85→  for (let i = 0; i < 4; i++) {\n    86→    segment += KEY_CHARS.charAt(crypto.randomInt(KEY_CHARS.length));\n    87→  }\n    88→  return segment;\n    89→}\n    90→\n    91→/**\n    92→ * Generate a license key in format SPLICE-XXXX-XXXX-XXXX\n    93→ * @returns {string} License key\n    94→ */\n    95→function generateKeyString() {\n    96→  return `SPLICE-${generateSegment()}-${generateSegment()}-${generateSegment()}`;\n    97→}\n    98→\n    99→/**\n   100→ * Validate license key format\n   101→ * @param {string} key - License key to validate\n   102→ * @returns {boolean} True if format is valid\n   103→ */\n   104→function isValidKeyFormat(key) {\n   105→  if (!key || typeof key !== 'string') return false;\n   106→\n   107→  // Normalize: uppercase and trim\n   108→  const normalized = key.toUpperCase().trim();\n   109→\n   110→  // Must match SPLICE-XXXX-XXXX-XXXX pattern\n   111→  // Character set excludes confusing chars: 0/O, 1/I/L\n   112→  const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n   113→  return pattern.test(normalized);\n   114→}\n   115→\n   116→/**\n   117→ * Normalize a license key (uppercase, trim)\n   118→ * @param {string} key - License key\n   119→ * @returns {string} Normalized key\n   120→ */\n   121→function normalizeKey(key) {\n   122→  return (key || '').toUpperCase().trim();\n   123→}\n   124→\n   125→/**\n   126→ * Generate a new license key for a Stripe customer\n   127→ *\n   128→ * @param {string} stripeCustomerId - Stripe customer ID\n   129→ * @returns {Promise<{success: boolean, key?: string, error?: string}>}\n   130→ */\n   131→async function generateLicenseKey(stripeCustomerId) {\n   132→  if (!stripeCustomerId) {\n   133→    return { success: false, error: 'Customer ID is required' };\n   134→  }\n   135→\n   136→  const client = await pool.connect();\n   137→  try {\n   138→    // Check if customer already has a key\n   139→    const existing = await client.query(\n   140→      'SELECT key FROM license_keys WHERE stripe_customer_id = $1',\n   141→      [stripeCustomerId]\n   142→    );\n   143→\n   144→    if (existing.rows.length > 0) {\n   145→      return {\n   146→        success: true,\n   147→        key: existing.rows[0].key,\n   148→        existing: true\n   149→      };\n   150→    }\n   151→\n   152→    // Generate unique key with retry logic\n   153→    let key;\n   154→    let attempts = 0;\n   155→    const maxAttempts = 10;\n   156→\n   157→    while (attempts < maxAttempts) {\n   158→      key = generateKeyString();\n   159→      try {\n   160→        await client.query(\n   161→          `INSERT INTO license_keys (key, stripe_customer_id)\n   162→           VALUES ($1, $2)`,\n   163→          [key, stripeCustomerId]\n   164→        );\n   165→        break;\n   166→      } catch (err) {\n   167→        if (err.code === '23505') { // Unique violation\n   168→          attempts++;\n   169→          continue;\n   170→        }\n   171→        throw err;\n   172→      }\n   173→    }\n   174→\n   175→    if (attempts >= maxAttempts) {\n   176→      return { success: false, error: 'Failed to generate unique license key' };\n   177→    }\n   178→\n   179→    // SECURITY: Mask license key in logs to prevent credential exposure\n   180→    const maskedKey = key.substring(0, 10) + '****';\n   181→    console.log(`[License] Generated key for customer ${stripeCustomerId.substring(0, 8)}****: ${maskedKey}`);\n   182→    return { success: true, key };\n   183→  } finally {\n   184→    client.release();\n   185→  }\n   186→}\n   187→\n   188→/**\n   189→ * Activate a license key\n   190→ *\n   191→ * Uses SELECT ... FOR UPDATE to prevent race conditions where\n   192→ * the same license key could be activated on multiple devices simultaneously.\n   193→ *\n   194→ * @param {string} key - License key to activate\n   195→ * @returns {Promise<{success: boolean, customerId?: string, error?: string}>}\n   196→ */\n   197→async function activateLicenseKey(key) {\n   198→  if (!key) {\n   199→    return { success: false, error: 'License key is required' };\n   200→  }\n   201→\n   202→  const normalized = normalizeKey(key);\n   203→\n   204→  if (!isValidKeyFormat(normalized)) {\n   205→    return { success: false, error: 'Invalid license key format. Expected: SPLICE-XXXX-XXXX-XXXX' };\n   206→  }\n   207→\n   208→  const client = await pool.connect();\n   209→  try {\n   210→    // Begin transaction\n   211→    await client.query('BEGIN');\n   212→\n   213→    // Look up the key WITH ROW LOCK to prevent concurrent activation\n   214→    const result = await client.query(\n   215→      'SELECT * FROM license_keys WHERE key = $1 FOR UPDATE',\n   216→      [normalized]\n   217→    );\n   218→\n   219→    if (result.rows.length === 0) {\n   220→      await client.query('ROLLBACK');\n   221→      return { success: false, error: 'License key not found' };\n   222→    }\n   223→\n   224→    const license = result.rows[0];\n   225→\n   226→    if (!license.is_active) {\n   227→      await client.query('ROLLBACK');\n   228→      return { success: false, error: 'License key has been deactivated' };\n   229→    }\n   230→\n   231→    // Check if already activated (within the transaction lock)\n   232→    if (license.activated_at) {\n   233→      await client.query('COMMIT');\n   234→      // Key already activated - still return success with customer ID\n   235→      // This allows the same user to re-activate on new devices\n   236→      return {\n   237→        success: true,\n   238→        customerId: license.stripe_customer_id,\n   239→        alreadyActivated: true,\n   240→        activatedAt: license.activated_at\n   241→      };\n   242→    }\n   243→\n   244→    // Activate the key\n   245→    await client.query(\n   246→      'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n   247→      [license.id]\n   248→    );\n   249→\n   250→    // Commit the transaction\n   251→    await client.query('COMMIT');\n   252→\n   253→    // SECURITY: Mask license key and customer ID in logs\n   254→    const maskedKey = normalized.substring(0, 10) + '****';\n   255→    const maskedCustomer = license.stripe_customer_id.substring(0, 8) + '****';\n   256→    console.log(`[License] Activated key ${maskedKey} for customer ${maskedCustomer}`);\n   257→\n   258→    return {\n   259→      success: true,\n   260→      customerId: license.stripe_customer_id,\n   261→      alreadyActivated: false\n   262→    };\n   263→  } catch (err) {\n   264→    // Rollback on any error\n   265→    await client.query('ROLLBACK');\n   266→    console.error('[License] Activation error:', err);\n   267→    throw err;\n   268→  } finally {\n   269→    client.release();\n   270→  }\n   271→}\n   272→\n   273→/**\n   274→ * Get license key for a customer\n   275→ *\n   276→ * @param {string} stripeCustomerId - Stripe customer ID\n   277→ * @returns {Promise<{success: boolean, key?: string, activated?: boolean, error?: string}>}\n   278→ */\n   279→async function getLicenseByCustomerId(stripeCustomerId) {\n   280→  if (!stripeCustomerId) {\n   281→    return { success: false, error: 'Customer ID is required' };\n   282→  }\n   283→\n   284→  const result = await pool.query(\n   285→    'SELECT * FROM license_keys WHERE stripe_customer_id = $1',\n   286→    [stripeCustomerId]\n   287→  );\n   288→\n   289→  if (result.rows.length === 0) {\n   290→    return { success: false, error: 'No license key found for this customer' };\n   291→  }\n   292→\n   293→  const license = result.rows[0];\n   294→  return {\n   295→    success: true,\n   296→    key: license.key,\n   297→    activated: !!license.activated_at,\n   298→    isActive: license.is_active,\n   299→    createdAt: license.created_at,\n   300→    activatedAt: license.activated_at\n   301→  };\n   302→}\n   303→\n   304→/**\n   305→ * Deactivate a license key\n   306→ *\n   307→ * @param {string} key - License key to deactivate\n   308→ * @returns {Promise<{success: boolean, error?: string}>}\n   309→ */\n   310→async function deactivateLicenseKey(key) {\n   311→  if (!key) {\n   312→    return { success: false, error: 'License key is required' };\n   313→  }\n   314→\n   315→  const normalized = normalizeKey(key);\n   316→\n   317→  const result = await pool.query(\n   318→    'UPDATE license_keys SET is_active = FALSE WHERE key = $1 RETURNING id',\n   319→    [normalized]\n   320→  );\n   321→\n   322→  if (result.rowCount === 0) {\n   323→    return { success: false, error: 'License key not found' };\n   324→  }\n   325→\n   326→  // SECURITY: Mask license key in logs\n   327→  console.log(`[License] Deactivated key: ${normalized.substring(0, 10)}****`);\n   328→  return { success: true };\n   329→}\n   330→\n   331→/**\n   332→ * Reactivate a license key\n   333→ *\n   334→ * @param {string} key - License key to reactivate\n   335→ * @returns {Promise<{success: boolean, error?: string}>}\n   336→ */\n   337→async function reactivateLicenseKey(key) {\n   338→  if (!key) {\n   339→    return { success: false, error: 'License key is required' };\n   340→  }\n   341→\n   342→  const normalized = normalizeKey(key);\n   343→\n   344→  const result = await pool.query(\n   345→    'UPDATE license_keys SET is_active = TRUE WHERE key = $1 RETURNING id',\n   346→    [normalized]\n   347→  );\n   348→\n   349→  if (result.rowCount === 0) {\n   350→    return { success: false, error: 'License key not found' };\n   351→  }\n   352→\n   353→  // SECURITY: Mask license key in logs\n   354→  console.log(`[License] Reactivated key: ${normalized.substring(0, 10)}****`);\n   355→  return { success: true };\n   356→}\n   357→\n   358→module.exports = {\n   359→  initLicenseTables,\n   360→  generateLicenseKey,\n   361→  activateLicenseKey,\n   362→  getLicenseByCustomerId,\n   363→  deactivateLicenseKey,\n   364→  reactivateLicenseKey,\n   365→  isValidKeyFormat,\n   366→  normalizeKey,\n   367→  // Exposed for testing\n   368→  generateKeyString\n   369→};\n   370→\n\n</system-reminder>\n"}]},"uuid":"e219589f-feec-4224-8714-2196ed51e2eb","timestamp":"2025-12-30T02:10:36.594Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/licenseService.js","content":"/**\n * License Key Service\n *\n * Generates and validates license keys for user authentication.\n * License keys are generated when a user purchases a subscription via Stripe.\n * Format: SPLICE-XXXX-XXXX-XXXX (alphanumeric, no confusing characters)\n */\n\nconst { Pool } = require('pg');\nconst crypto = require('crypto');\n\n// SSL Configuration (same as usageTracking.js)\nconst sslConfig = process.env.NODE_ENV === 'production' ? {\n  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n  ca: process.env.DATABASE_SSL_CA || undefined\n} : false;\n\n// Use the same pool configuration as other services\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: sslConfig,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 5000\n});\n\n// Characters for key generation (no confusing chars: 0/O, 1/I/L)\nconst KEY_CHARS = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';\n\n/**\n * Initialize license_keys table\n */\nasync function initLicenseTables() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS license_keys (\n        id SERIAL PRIMARY KEY,\n        key VARCHAR(21) UNIQUE NOT NULL,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW(),\n        activated_at TIMESTAMP,\n        is_active BOOLEAN DEFAULT TRUE\n      )\n    `);\n\n    // Migrate existing column if needed (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF EXISTS (\n          SELECT 1 FROM information_schema.columns\n          WHERE table_name = 'license_keys'\n          AND column_name = 'key'\n          AND character_maximum_length = 19\n        ) THEN\n          ALTER TABLE license_keys ALTER COLUMN key TYPE VARCHAR(21);\n        END IF;\n      END $$;\n    `);\n\n    // Add indexes for efficient lookups\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_license_keys_key\n      ON license_keys(key)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_license_keys_customer\n      ON license_keys(stripe_customer_id)\n    `);\n\n    console.log('[License] Database tables initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Generate a random 4-character segment\n * @returns {string} 4 uppercase alphanumeric characters\n */\nfunction generateSegment() {\n  let segment = '';\n  for (let i = 0; i < 4; i++) {\n    segment += KEY_CHARS.charAt(crypto.randomInt(KEY_CHARS.length));\n  }\n  return segment;\n}\n\n/**\n * Generate a license key in format SPLICE-XXXX-XXXX-XXXX\n * @returns {string} License key\n */\nfunction generateKeyString() {\n  return `SPLICE-${generateSegment()}-${generateSegment()}-${generateSegment()}`;\n}\n\n/**\n * Validate license key format\n * @param {string} key - License key to validate\n * @returns {boolean} True if format is valid\n */\nfunction isValidKeyFormat(key) {\n  if (!key || typeof key !== 'string') return false;\n\n  // Normalize: uppercase and trim\n  const normalized = key.toUpperCase().trim();\n\n  // Must match SPLICE-XXXX-XXXX-XXXX pattern\n  // Character set excludes confusing chars: 0/O, 1/I/L\n  const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n  return pattern.test(normalized);\n}\n\n/**\n * Normalize a license key (uppercase, trim)\n * @param {string} key - License key\n * @returns {string} Normalized key\n */\nfunction normalizeKey(key) {\n  return (key || '').toUpperCase().trim();\n}\n\n/**\n * Generate a new license key for a Stripe customer\n *\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, key?: string, error?: string}>}\n */\nasync function generateLicenseKey(stripeCustomerId) {\n  if (!stripeCustomerId) {\n    return { success: false, error: 'Customer ID is required' };\n  }\n\n  const client = await pool.connect();\n  try {\n    // Check if customer already has a key\n    const existing = await client.query(\n      'SELECT key FROM license_keys WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (existing.rows.length > 0) {\n      return {\n        success: true,\n        key: existing.rows[0].key,\n        existing: true\n      };\n    }\n\n    // Generate unique key with retry logic\n    let key;\n    let attempts = 0;\n    const maxAttempts = 10;\n\n    while (attempts < maxAttempts) {\n      key = generateKeyString();\n      try {\n        await client.query(\n          `INSERT INTO license_keys (key, stripe_customer_id)\n           VALUES ($1, $2)`,\n          [key, stripeCustomerId]\n        );\n        break;\n      } catch (err) {\n        if (err.code === '23505') { // Unique violation\n          attempts++;\n          continue;\n        }\n        throw err;\n      }\n    }\n\n    if (attempts >= maxAttempts) {\n      return { success: false, error: 'Failed to generate unique license key' };\n    }\n\n    // SECURITY: Mask license key in logs to prevent credential exposure\n    const maskedKey = key.substring(0, 10) + '****';\n    console.log(`[License] Generated key for customer ${stripeCustomerId.substring(0, 8)}****: ${maskedKey}`);\n    return { success: true, key };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Activate a license key\n *\n * Uses SELECT ... FOR UPDATE to prevent race conditions where\n * the same license key could be activated on multiple devices simultaneously.\n *\n * @param {string} key - License key to activate\n * @returns {Promise<{success: boolean, customerId?: string, error?: string}>}\n */\nasync function activateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  if (!isValidKeyFormat(normalized)) {\n    return { success: false, error: 'Invalid license key format. Expected: SPLICE-XXXX-XXXX-XXXX' };\n  }\n\n  const client = await pool.connect();\n  try {\n    // Begin transaction\n    await client.query('BEGIN');\n\n    // Look up the key WITH ROW LOCK to prevent concurrent activation\n    const result = await client.query(\n      'SELECT * FROM license_keys WHERE key = $1 FOR UPDATE',\n      [normalized]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, error: 'License key not found' };\n    }\n\n    const license = result.rows[0];\n\n    if (!license.is_active) {\n      await client.query('ROLLBACK');\n      return { success: false, error: 'License key has been deactivated' };\n    }\n\n    // Check if already activated (within the transaction lock)\n    if (license.activated_at) {\n      await client.query('COMMIT');\n      // Key already activated - still return success with customer ID\n      // This allows the same user to re-activate on new devices\n      return {\n        success: true,\n        customerId: license.stripe_customer_id,\n        alreadyActivated: true,\n        activatedAt: license.activated_at\n      };\n    }\n\n    // Activate the key\n    await client.query(\n      'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n      [license.id]\n    );\n\n    // Commit the transaction\n    await client.query('COMMIT');\n\n    // SECURITY: Mask license key and customer ID in logs\n    const maskedKey = normalized.substring(0, 10) + '****';\n    const maskedCustomer = license.stripe_customer_id.substring(0, 8) + '****';\n    console.log(`[License] Activated key ${maskedKey} for customer ${maskedCustomer}`);\n\n    return {\n      success: true,\n      customerId: license.stripe_customer_id,\n      alreadyActivated: false\n    };\n  } catch (err) {\n    // Rollback on any error\n    await client.query('ROLLBACK');\n    console.error('[License] Activation error:', err);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get license key for a customer\n *\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, key?: string, activated?: boolean, error?: string}>}\n */\nasync function getLicenseByCustomerId(stripeCustomerId) {\n  if (!stripeCustomerId) {\n    return { success: false, error: 'Customer ID is required' };\n  }\n\n  const result = await pool.query(\n    'SELECT * FROM license_keys WHERE stripe_customer_id = $1',\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { success: false, error: 'No license key found for this customer' };\n  }\n\n  const license = result.rows[0];\n  return {\n    success: true,\n    key: license.key,\n    activated: !!license.activated_at,\n    isActive: license.is_active,\n    createdAt: license.created_at,\n    activatedAt: license.activated_at\n  };\n}\n\n/**\n * Deactivate a license key\n *\n * @param {string} key - License key to deactivate\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function deactivateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  const result = await pool.query(\n    'UPDATE license_keys SET is_active = FALSE WHERE key = $1 RETURNING id',\n    [normalized]\n  );\n\n  if (result.rowCount === 0) {\n    return { success: false, error: 'License key not found' };\n  }\n\n  // SECURITY: Mask license key in logs\n  console.log(`[License] Deactivated key: ${normalized.substring(0, 10)}****`);\n  return { success: true };\n}\n\n/**\n * Reactivate a license key\n *\n * @param {string} key - License key to reactivate\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function reactivateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  const result = await pool.query(\n    'UPDATE license_keys SET is_active = TRUE WHERE key = $1 RETURNING id',\n    [normalized]\n  );\n\n  if (result.rowCount === 0) {\n    return { success: false, error: 'License key not found' };\n  }\n\n  // SECURITY: Mask license key in logs\n  console.log(`[License] Reactivated key: ${normalized.substring(0, 10)}****`);\n  return { success: true };\n}\n\nmodule.exports = {\n  initLicenseTables,\n  generateLicenseKey,\n  activateLicenseKey,\n  getLicenseByCustomerId,\n  deactivateLicenseKey,\n  reactivateLicenseKey,\n  isValidKeyFormat,\n  normalizeKey,\n  // Exposed for testing\n  generateKeyString\n};\n","numLines":370,"startLine":1,"totalLines":370}}}
{"parentUuid":"e219589f-feec-4224-8714-2196ed51e2eb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DqyoEuhGMMQaLDgaCeRfwk","type":"tool_result","content":"     1→/**\n     2→ * Analyze Routes\n     3→ *\n     4→ * Main analysis and transcription endpoints\n     5→ */\n     6→\n     7→const express = require('express');\n     8→const fs = require('fs');\n     9→const { transcribeAudio, transcribeFull } = require('../services/transcription');\n    10→const { detectTakes } = require('../services/takeDetection');\n    11→const { isolateVocals, isReplicateConfigured } = require('../services/vocalIsolation');\n    12→const { getAudioDuration } = require('../services/ffprobeSilence');\n    13→const { alignToFrameFloor, alignToFrameCeil } = require('../services/cutListGenerator');\n    14→const { validateAudioPath } = require('../services/securityUtils');\n    15→\n    16→/**\n    17→ * Create analyze routes\n    18→ * @param {Object} options - Route configuration options\n    19→ * @param {Object} options.middleware - Shared middleware (requireCredits)\n    20→ * @param {Object} options.services - Shared services (usageTracking)\n    21→ * @returns {express.Router}\n    22→ */\n    23→function createAnalyzeRoutes(options = {}) {\n    24→  const router = express.Router();\n    25→  const { requireCredits } = options.middleware || {};\n    26→  const { usageTracking } = options.services || {};\n    27→\n    28→  /**\n    29→   * POST /analyze - Main analysis endpoint\n    30→   *\n    31→   * Pipeline:\n    32→   * 1. Validate input (wavPath)\n    33→   * 2. Slice 4: Transcribe audio with Whisper\n    34→   * 3. Slice 5: Detect takes with GPT-4o-mini\n    35→   * 4. Return combined results\n    36→   */\n    37→  router.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n    38→    const { wavPath } = req.body;\n    39→\n    40→    // Validate input\n    41→    if (!wavPath) {\n    42→      return res.status(400).json({ error: 'wavPath is required' });\n    43→    }\n    44→\n    45→    // SECURITY: Validate path to prevent path traversal attacks\n    46→    const pathValidation = await validateAudioPath(wavPath);\n    47→    if (!pathValidation.valid) {\n    48→      return res.status(400).json({ error: pathValidation.error });\n    49→    }\n    50→    const validatedPath = pathValidation.path;\n    51→\n    52→    console.log(`[SPLICE] Analyzing: ${validatedPath}`);\n    53→\n    54→    try {\n    55→      // Slice 4 - GPT-4o-mini transcription\n    56→      const transcript = await transcribeAudio(validatedPath);\n    57→\n    58→      // Slice 5 - GPT-4o-mini take detection\n    59→      const takes = await detectTakes(transcript);\n    60→\n    61→      // Deduct usage based on audio duration\n    62→      const audioDuration = transcript.duration || 0;\n    63→      let balance = null;\n    64→      if (audioDuration > 0 && req.deductUsage) {\n    65→        balance = await req.deductUsage(audioDuration);\n    66→      }\n    67→\n    68→      res.json({\n    69→        success: true,\n    70→        wavPath: validatedPath,\n    71→        transcript,\n    72→        takes,\n    73→        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    74→      });\n    75→    } catch (err) {\n    76→      console.error('[SPLICE] Error:', err);\n    77→      res.status(500).json({ error: err.message });\n    78→    }\n    79→  });\n    80→\n    81→  /**\n    82→   * POST /transcribe/word-level - Get frame-aligned word-level timestamps\n    83→   *\n    84→   * Returns word-level timestamps with optional frame alignment for precise editing.\n    85→   * Uses the unified transcription cache (same API call as /analyze).\n    86→   *\n    87→   * Body:\n    88→   * - wavPath: Path to audio file\n    89→   * - frameRate: Optional frame rate for alignment (23.976, 24, 29.97, 30, 60)\n    90→   *\n    91→   * Returns:\n    92→   * - words: Array of {word, start, end, startAligned?, endAligned?}\n    93→   * - text: Full transcript text\n    94→   * - duration: Audio duration in seconds\n    95→   */\n    96→  router.post('/transcribe/word-level', requireCredits({ endpoint: 'transcribe-word-level' }), async (req, res) => {\n    97→    const { wavPath, frameRate = 0 } = req.body;\n    98→\n    99→    if (!wavPath) {\n   100→      return res.status(400).json({ error: 'wavPath is required' });\n   101→    }\n   102→\n   103→    // SECURITY: Validate path to prevent path traversal attacks\n   104→    const pathValidation = await validateAudioPath(wavPath);\n   105→    if (!pathValidation.valid) {\n   106→      return res.status(400).json({ error: pathValidation.error });\n   107→    }\n   108→    const validatedPath = pathValidation.path;\n   109→\n   110→    console.log(`[SPLICE] Word-level transcription: ${validatedPath} (frameRate: ${frameRate || 'none'})`);\n   111→\n   112→    try {\n   113→      // Use unified transcription (gets both segments and words in one API call)\n   114→      const full = await transcribeFull(validatedPath);\n   115→\n   116→      // Apply frame alignment if requested\n   117→      let words = full.words || [];\n   118→      const hasFrameAlignment = frameRate > 0;\n   119→\n   120→      if (hasFrameAlignment) {\n   121→        words = words.map(w => ({\n   122→          word: w.word,\n   123→          start: w.start,\n   124→          end: w.end,\n   125→          // Add frame-aligned versions\n   126→          startAligned: parseFloat(alignToFrameFloor(w.start, frameRate).toFixed(6)),\n   127→          endAligned: parseFloat(alignToFrameCeil(w.end, frameRate).toFixed(6))\n   128→        }));\n   129→        console.log(`[SPLICE] Applied ${frameRate}fps frame alignment to ${words.length} words`);\n   130→      }\n   131→\n   132→      // Deduct usage based on audio duration\n   133→      const audioDuration = full.duration || 0;\n   134→      let balance = null;\n   135→      if (audioDuration > 0 && req.deductUsage) {\n   136→        balance = await req.deductUsage(audioDuration);\n   137→      }\n   138→\n   139→      res.json({\n   140→        success: true,\n   141→        wavPath: validatedPath,\n   142→        text: full.text,\n   143→        words,\n   144→        wordCount: words.length,\n   145→        duration: full.duration,\n   146→        language: full.language,\n   147→        frameAligned: hasFrameAlignment,\n   148→        frameRate: hasFrameAlignment ? frameRate : null,\n   149→        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   150→      });\n   151→    } catch (err) {\n   152→      console.error('[SPLICE] Word-level transcription error:', err);\n   153→      res.status(500).json({ error: err.message });\n   154→    }\n   155→  });\n   156→\n   157→  /**\n   158→   * POST /isolate-vocals - Isolate vocals from audio using Demucs\n   159→   *\n   160→   * Uses Replicate's Demucs model to separate vocals from background audio.\n   161→   * Cost: ~$0.015/min of audio\n   162→   *\n   163→   * Tier access:\n   164→   * - Starter: No access (upgrade required)\n   165→   * - Pro: 2 hours included, then $0.08/min overage\n   166→   * - Team: 5 hours included, then $0.08/min overage\n   167→   */\n   168→  router.post('/isolate-vocals', requireCredits({ endpoint: 'isolate-vocals' }), async (req, res) => {\n   169→    const { audioPath, stem = 'vocals', outputDir = null } = req.body;\n   170→    const stripeCustomerId = req.headers['x-stripe-customer-id'];\n   171→\n   172→    if (!audioPath) {\n   173→      return res.status(400).json({ error: 'audioPath is required' });\n   174→    }\n   175→\n   176→    if (!fs.existsSync(audioPath)) {\n   177→      return res.status(404).json({ error: `File not found: ${audioPath}` });\n   178→    }\n   179→\n   180→    // Check Replicate configuration\n   181→    if (!isReplicateConfigured()) {\n   182→      return res.status(500).json({\n   183→        error: 'Replicate API not configured. Set REPLICATE_API_TOKEN in .env'\n   184→      });\n   185→    }\n   186→\n   187→    // Get audio duration for billing\n   188→    let audioDurationSeconds = 0;\n   189→    try {\n   190→      audioDurationSeconds = await getAudioDuration(audioPath);\n   191→    } catch (err) {\n   192→      console.warn('[SPLICE] Could not get audio duration:', err.message);\n   193→    }\n   194→\n   195→    const audioDurationMinutes = audioDurationSeconds / 60;\n   196→\n   197→    // Check isolation access if customer ID provided\n   198→    if (stripeCustomerId && usageTracking) {\n   199→      const accessCheck = await usageTracking.checkIsolationAccess(stripeCustomerId, audioDurationMinutes);\n   200→\n   201→      if (!accessCheck.allowed) {\n   202→        return res.status(403).json({\n   203→          error: accessCheck.message,\n   204→          reason: accessCheck.reason,\n   205→          upgradeRequired: accessCheck.reason === 'upgrade_required'\n   206→        });\n   207→      }\n   208→\n   209→      console.log(`[SPLICE] Isolation access: ${accessCheck.message}`);\n   210→    }\n   211→\n   212→    console.log(`[SPLICE] Isolating vocals: ${audioPath} (${audioDurationMinutes.toFixed(1)} min)`);\n   213→\n   214→    try {\n   215→      const result = await isolateVocals(audioPath, {\n   216→        stem,\n   217→        outputDir: outputDir || undefined\n   218→      });\n   219→\n   220→      // Deduct isolation usage if customer ID provided\n   221→      let usageInfo = null;\n   222→      if (stripeCustomerId && usageTracking) {\n   223→        usageInfo = await usageTracking.deductIsolationUsage(\n   224→          stripeCustomerId,\n   225→          audioDurationSeconds,\n   226→          'isolate-vocals'\n   227→        );\n   228→        console.log(`[SPLICE] Isolation usage deducted: ${audioDurationMinutes.toFixed(1)} min`);\n   229→        if (usageInfo.isolationUsed?.overageCost > 0) {\n   230→          console.log(`[SPLICE] Overage cost: $${usageInfo.isolationUsed.overageCost.toFixed(2)}`);\n   231→        }\n   232→      }\n   233→\n   234→      res.json({\n   235→        success: true,\n   236→        inputPath: audioPath,\n   237→        outputPath: result.outputPath,\n   238→        stem: result.stem,\n   239→        processingTime: result.processingTime,\n   240→        availableStems: result.allStems,\n   241→        audioDurationMinutes,\n   242→        usage: usageInfo ? {\n   243→          isolationHoursRemaining: usageInfo.isolationHoursRemaining,\n   244→          overageCost: usageInfo.isolationUsed?.overageCost || 0\n   245→        } : null\n   246→      });\n   247→    } catch (err) {\n   248→      console.error('[SPLICE] Vocal isolation error:', err);\n   249→      res.status(500).json({ error: err.message });\n   250→    }\n   251→  });\n   252→\n   253→  return router;\n   254→}\n   255→\n   256→module.exports = createAnalyzeRoutes;\n   257→\n\n</system-reminder>\n"}]},"uuid":"94515b80-f0a8-4b58-a01f-a587f771b10a","timestamp":"2025-12-30T02:10:36.594Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/analyze.js","content":"/**\n * Analyze Routes\n *\n * Main analysis and transcription endpoints\n */\n\nconst express = require('express');\nconst fs = require('fs');\nconst { transcribeAudio, transcribeFull } = require('../services/transcription');\nconst { detectTakes } = require('../services/takeDetection');\nconst { isolateVocals, isReplicateConfigured } = require('../services/vocalIsolation');\nconst { getAudioDuration } = require('../services/ffprobeSilence');\nconst { alignToFrameFloor, alignToFrameCeil } = require('../services/cutListGenerator');\nconst { validateAudioPath } = require('../services/securityUtils');\n\n/**\n * Create analyze routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (requireCredits)\n * @param {Object} options.services - Shared services (usageTracking)\n * @returns {express.Router}\n */\nfunction createAnalyzeRoutes(options = {}) {\n  const router = express.Router();\n  const { requireCredits } = options.middleware || {};\n  const { usageTracking } = options.services || {};\n\n  /**\n   * POST /analyze - Main analysis endpoint\n   *\n   * Pipeline:\n   * 1. Validate input (wavPath)\n   * 2. Slice 4: Transcribe audio with Whisper\n   * 3. Slice 5: Detect takes with GPT-4o-mini\n   * 4. Return combined results\n   */\n  router.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n    const { wavPath } = req.body;\n\n    // Validate input\n    if (!wavPath) {\n      return res.status(400).json({ error: 'wavPath is required' });\n    }\n\n    // SECURITY: Validate path to prevent path traversal attacks\n    const pathValidation = await validateAudioPath(wavPath);\n    if (!pathValidation.valid) {\n      return res.status(400).json({ error: pathValidation.error });\n    }\n    const validatedPath = pathValidation.path;\n\n    console.log(`[SPLICE] Analyzing: ${validatedPath}`);\n\n    try {\n      // Slice 4 - GPT-4o-mini transcription\n      const transcript = await transcribeAudio(validatedPath);\n\n      // Slice 5 - GPT-4o-mini take detection\n      const takes = await detectTakes(transcript);\n\n      // Deduct usage based on audio duration\n      const audioDuration = transcript.duration || 0;\n      let balance = null;\n      if (audioDuration > 0 && req.deductUsage) {\n        balance = await req.deductUsage(audioDuration);\n      }\n\n      res.json({\n        success: true,\n        wavPath: validatedPath,\n        transcript,\n        takes,\n        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n      });\n    } catch (err) {\n      console.error('[SPLICE] Error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /transcribe/word-level - Get frame-aligned word-level timestamps\n   *\n   * Returns word-level timestamps with optional frame alignment for precise editing.\n   * Uses the unified transcription cache (same API call as /analyze).\n   *\n   * Body:\n   * - wavPath: Path to audio file\n   * - frameRate: Optional frame rate for alignment (23.976, 24, 29.97, 30, 60)\n   *\n   * Returns:\n   * - words: Array of {word, start, end, startAligned?, endAligned?}\n   * - text: Full transcript text\n   * - duration: Audio duration in seconds\n   */\n  router.post('/transcribe/word-level', requireCredits({ endpoint: 'transcribe-word-level' }), async (req, res) => {\n    const { wavPath, frameRate = 0 } = req.body;\n\n    if (!wavPath) {\n      return res.status(400).json({ error: 'wavPath is required' });\n    }\n\n    // SECURITY: Validate path to prevent path traversal attacks\n    const pathValidation = await validateAudioPath(wavPath);\n    if (!pathValidation.valid) {\n      return res.status(400).json({ error: pathValidation.error });\n    }\n    const validatedPath = pathValidation.path;\n\n    console.log(`[SPLICE] Word-level transcription: ${validatedPath} (frameRate: ${frameRate || 'none'})`);\n\n    try {\n      // Use unified transcription (gets both segments and words in one API call)\n      const full = await transcribeFull(validatedPath);\n\n      // Apply frame alignment if requested\n      let words = full.words || [];\n      const hasFrameAlignment = frameRate > 0;\n\n      if (hasFrameAlignment) {\n        words = words.map(w => ({\n          word: w.word,\n          start: w.start,\n          end: w.end,\n          // Add frame-aligned versions\n          startAligned: parseFloat(alignToFrameFloor(w.start, frameRate).toFixed(6)),\n          endAligned: parseFloat(alignToFrameCeil(w.end, frameRate).toFixed(6))\n        }));\n        console.log(`[SPLICE] Applied ${frameRate}fps frame alignment to ${words.length} words`);\n      }\n\n      // Deduct usage based on audio duration\n      const audioDuration = full.duration || 0;\n      let balance = null;\n      if (audioDuration > 0 && req.deductUsage) {\n        balance = await req.deductUsage(audioDuration);\n      }\n\n      res.json({\n        success: true,\n        wavPath: validatedPath,\n        text: full.text,\n        words,\n        wordCount: words.length,\n        duration: full.duration,\n        language: full.language,\n        frameAligned: hasFrameAlignment,\n        frameRate: hasFrameAlignment ? frameRate : null,\n        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n      });\n    } catch (err) {\n      console.error('[SPLICE] Word-level transcription error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /isolate-vocals - Isolate vocals from audio using Demucs\n   *\n   * Uses Replicate's Demucs model to separate vocals from background audio.\n   * Cost: ~$0.015/min of audio\n   *\n   * Tier access:\n   * - Starter: No access (upgrade required)\n   * - Pro: 2 hours included, then $0.08/min overage\n   * - Team: 5 hours included, then $0.08/min overage\n   */\n  router.post('/isolate-vocals', requireCredits({ endpoint: 'isolate-vocals' }), async (req, res) => {\n    const { audioPath, stem = 'vocals', outputDir = null } = req.body;\n    const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n    if (!audioPath) {\n      return res.status(400).json({ error: 'audioPath is required' });\n    }\n\n    if (!fs.existsSync(audioPath)) {\n      return res.status(404).json({ error: `File not found: ${audioPath}` });\n    }\n\n    // Check Replicate configuration\n    if (!isReplicateConfigured()) {\n      return res.status(500).json({\n        error: 'Replicate API not configured. Set REPLICATE_API_TOKEN in .env'\n      });\n    }\n\n    // Get audio duration for billing\n    let audioDurationSeconds = 0;\n    try {\n      audioDurationSeconds = await getAudioDuration(audioPath);\n    } catch (err) {\n      console.warn('[SPLICE] Could not get audio duration:', err.message);\n    }\n\n    const audioDurationMinutes = audioDurationSeconds / 60;\n\n    // Check isolation access if customer ID provided\n    if (stripeCustomerId && usageTracking) {\n      const accessCheck = await usageTracking.checkIsolationAccess(stripeCustomerId, audioDurationMinutes);\n\n      if (!accessCheck.allowed) {\n        return res.status(403).json({\n          error: accessCheck.message,\n          reason: accessCheck.reason,\n          upgradeRequired: accessCheck.reason === 'upgrade_required'\n        });\n      }\n\n      console.log(`[SPLICE] Isolation access: ${accessCheck.message}`);\n    }\n\n    console.log(`[SPLICE] Isolating vocals: ${audioPath} (${audioDurationMinutes.toFixed(1)} min)`);\n\n    try {\n      const result = await isolateVocals(audioPath, {\n        stem,\n        outputDir: outputDir || undefined\n      });\n\n      // Deduct isolation usage if customer ID provided\n      let usageInfo = null;\n      if (stripeCustomerId && usageTracking) {\n        usageInfo = await usageTracking.deductIsolationUsage(\n          stripeCustomerId,\n          audioDurationSeconds,\n          'isolate-vocals'\n        );\n        console.log(`[SPLICE] Isolation usage deducted: ${audioDurationMinutes.toFixed(1)} min`);\n        if (usageInfo.isolationUsed?.overageCost > 0) {\n          console.log(`[SPLICE] Overage cost: $${usageInfo.isolationUsed.overageCost.toFixed(2)}`);\n        }\n      }\n\n      res.json({\n        success: true,\n        inputPath: audioPath,\n        outputPath: result.outputPath,\n        stem: result.stem,\n        processingTime: result.processingTime,\n        availableStems: result.allStems,\n        audioDurationMinutes,\n        usage: usageInfo ? {\n          isolationHoursRemaining: usageInfo.isolationHoursRemaining,\n          overageCost: usageInfo.isolationUsed?.overageCost || 0\n        } : null\n      });\n    } catch (err) {\n      console.error('[SPLICE] Vocal isolation error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createAnalyzeRoutes;\n","numLines":257,"startLine":1,"totalLines":257}}}
{"parentUuid":"94515b80-f0a8-4b58-a01f-a587f771b10a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M1TsKJemKo8rLs9N6fXHFE","type":"tool_result","content":"     1→/**\n     2→ * Structured Authentication Logger\n     3→ *\n     4→ * Provides consistent JSON-formatted logging for authentication events.\n     5→ * Designed to be captured by log aggregators (CloudWatch, Datadog, etc.)\n     6→ *\n     7→ * Log Format:\n     8→ * {\n     9→ *   timestamp: ISO8601 string,\n    10→ *   event_type: string,\n    11→ *   level: 'info' | 'warn' | 'error',\n    12→ *   user_id: string (masked),\n    13→ *   ip_address: string,\n    14→ *   details: object\n    15→ * }\n    16→ */\n    17→\n    18→/**\n    19→ * Event types for authentication logging\n    20→ */\n    21→const AUTH_EVENTS = {\n    22→  // Login events\n    23→  LOGIN_SUCCESS: 'auth.login.success',\n    24→  LOGIN_FAILED: 'auth.login.failed',\n    25→  LOGIN_RATE_LIMITED: 'auth.login.rate_limited',\n    26→\n    27→  // Logout events\n    28→  LOGOUT_SUCCESS: 'auth.logout.success',\n    29→  LOGOUT_FAILED: 'auth.logout.failed',\n    30→\n    31→  // Token events\n    32→  TOKEN_REFRESH_SUCCESS: 'auth.token.refresh_success',\n    33→  TOKEN_REFRESH_FAILED: 'auth.token.refresh_failed',\n    34→  TOKEN_REVOKED: 'auth.token.revoked',\n    35→  TOKEN_EXPIRED: 'auth.token.expired',\n    36→  TOKEN_INVALID: 'auth.token.invalid',\n    37→  TOKEN_BLACKLISTED: 'auth.token.blacklisted',\n    38→\n    39→  // Security events\n    40→  SUSPICIOUS_ACTIVITY: 'auth.security.suspicious',\n    41→  MULTIPLE_FAILED_ATTEMPTS: 'auth.security.multiple_failures',\n    42→  LEGACY_AUTH_USED: 'auth.security.legacy_header',\n    43→\n    44→  // Blacklist events\n    45→  BLACKLIST_CLEANUP: 'auth.blacklist.cleanup'\n    46→};\n    47→\n    48→/**\n    49→ * Log levels\n    50→ */\n    51→const LOG_LEVELS = {\n    52→  INFO: 'info',\n    53→  WARN: 'warn',\n    54→  ERROR: 'error'\n    55→};\n    56→\n    57→/**\n    58→ * In-memory store for tracking failed login attempts per IP\n    59→ * Used to detect suspicious activity\n    60→ */\n    61→const failedAttempts = new Map();\n    62→\n    63→// Cleanup failed attempts every 15 minutes\n    64→const FAILED_ATTEMPTS_TTL = 15 * 60 * 1000;\n    65→const FAILED_ATTEMPTS_THRESHOLD = 5; // Log suspicious after 5 failures\n    66→\n    67→/**\n    68→ * Extract client IP from request\n    69→ * Handles proxied requests (X-Forwarded-For, X-Real-IP)\n    70→ * @param {Object} req - Express request object\n    71→ * @returns {string} Client IP address\n    72→ */\n    73→function getClientIp(req) {\n    74→  if (!req) return 'unknown';\n    75→\n    76→  // Check for proxied IP (common in production behind load balancers)\n    77→  const forwarded = req.headers['x-forwarded-for'];\n    78→  if (forwarded) {\n    79→    // X-Forwarded-For can contain multiple IPs; take the first (client)\n    80→    return forwarded.split(',')[0].trim();\n    81→  }\n    82→\n    83→  const realIp = req.headers['x-real-ip'];\n    84→  if (realIp) {\n    85→    return realIp;\n    86→  }\n    87→\n    88→  // Direct connection\n    89→  return req.ip || req.connection?.remoteAddress || 'unknown';\n    90→}\n    91→\n    92→/**\n    93→ * Mask sensitive data for logging\n    94→ * @param {string} data - Sensitive string to mask\n    95→ * @param {string} type - Type of data ('user_id', 'email', 'token', 'jti', 'license_key')\n    96→ * @returns {string} Masked string\n    97→ */\n    98→function maskData(data, type = 'generic') {\n    99→  if (!data || typeof data !== 'string') {\n   100→    return '[empty]';\n   101→  }\n   102→\n   103→  switch (type) {\n   104→    case 'user_id':\n   105→      // Customer ID: cus_xxxx -> cus_xxxx****\n   106→      if (data.startsWith('cus_') && data.length > 10) {\n   107→        return `cus_${data.slice(4, 8)}****`;\n   108→      }\n   109→      return 'cus_****';\n   110→\n   111→    case 'email':\n   112→      if (data.includes('@')) {\n   113→        const [local, domain] = data.split('@');\n   114→        const maskedLocal = local.length > 2\n   115→          ? `${local[0]}***${local[local.length - 1]}`\n   116→          : '***';\n   117→        return `${maskedLocal}@${domain}`;\n   118→      }\n   119→      return '***@***.***';\n   120→\n   121→    case 'jti':\n   122→      // JWT ID: show first 8 chars\n   123→      if (data.length > 8) {\n   124→        return `${data.slice(0, 8)}...`;\n   125→      }\n   126→      return data;\n   127→\n   128→    case 'token':\n   129→      // JWT token: show first 10 chars\n   130→      if (data.startsWith('eyJ') && data.length > 10) {\n   131→        return `${data.slice(0, 10)}...`;\n   132→      }\n   133→      return '[token]';\n   134→\n   135→    case 'license_key':\n   136→      // License key: SPLICE-XXXX-XXXX-XXXX-XXXX -> SPLICE-XXXX-****-****-****\n   137→      if (data.startsWith('SPLICE-')) {\n   138→        const parts = data.split('-');\n   139→        if (parts.length === 5) {\n   140→          return `${parts[0]}-${parts[1]}-****-****-****`;\n   141→        }\n   142→      }\n   143→      return 'SPLICE-****';\n   144→\n   145→    default:\n   146→      // Generic: show first 4 chars\n   147→      if (data.length > 8) {\n   148→        return `${data.slice(0, 4)}****`;\n   149→      }\n   150→      return '****';\n   151→  }\n   152→}\n   153→\n   154→/**\n   155→ * Create a structured log entry\n   156→ * @param {string} eventType - Event type from AUTH_EVENTS\n   157→ * @param {string} level - Log level from LOG_LEVELS\n   158→ * @param {Object} options - Log options\n   159→ * @returns {Object} Structured log object\n   160→ */\n   161→function createLogEntry(eventType, level, options = {}) {\n   162→  const {\n   163→    userId = null,\n   164→    ipAddress = 'unknown',\n   165→    jti = null,\n   166→    reason = null,\n   167→    email = null,\n   168→    tier = null,\n   169→    details = {}\n   170→  } = options;\n   171→\n   172→  const entry = {\n   173→    timestamp: new Date().toISOString(),\n   174→    event_type: eventType,\n   175→    level,\n   176→    service: 'splice-auth'\n   177→  };\n   178→\n   179→  // Add user context if available (always masked)\n   180→  if (userId) {\n   181→    entry.user_id = maskData(userId, 'user_id');\n   182→  }\n   183→\n   184→  // Add IP address\n   185→  entry.ip_address = ipAddress;\n   186→\n   187→  // Add optional fields\n   188→  if (jti) {\n   189→    entry.jti = maskData(jti, 'jti');\n   190→  }\n   191→\n   192→  if (reason) {\n   193→    entry.reason = reason;\n   194→  }\n   195→\n   196→  if (email) {\n   197→    entry.email = maskData(email, 'email');\n   198→  }\n   199→\n   200→  if (tier) {\n   201→    entry.tier = tier;\n   202→  }\n   203→\n   204→  // Add any additional details\n   205→  if (Object.keys(details).length > 0) {\n   206→    entry.details = details;\n   207→  }\n   208→\n   209→  return entry;\n   210→}\n   211→\n   212→/**\n   213→ * Output a structured log entry\n   214→ * @param {Object} entry - Log entry object\n   215→ */\n   216→function outputLog(entry) {\n   217→  const jsonLog = JSON.stringify(entry);\n   218→\n   219→  switch (entry.level) {\n   220→    case LOG_LEVELS.ERROR:\n   221→      console.error(jsonLog);\n   222→      break;\n   223→    case LOG_LEVELS.WARN:\n   224→      console.warn(jsonLog);\n   225→      break;\n   226→    default:\n   227→      console.log(jsonLog);\n   228→  }\n   229→}\n   230→\n   231→/**\n   232→ * Track failed login attempt for an IP\n   233→ * @param {string} ip - Client IP address\n   234→ * @returns {number} Number of failed attempts from this IP\n   235→ */\n   236→function trackFailedAttempt(ip) {\n   237→  const now = Date.now();\n   238→  const existing = failedAttempts.get(ip) || { count: 0, firstAttempt: now };\n   239→\n   240→  // Reset if TTL expired\n   241→  if (now - existing.firstAttempt > FAILED_ATTEMPTS_TTL) {\n   242→    existing.count = 0;\n   243→    existing.firstAttempt = now;\n   244→  }\n   245→\n   246→  existing.count++;\n   247→  existing.lastAttempt = now;\n   248→  failedAttempts.set(ip, existing);\n   249→\n   250→  return existing.count;\n   251→}\n   252→\n   253→/**\n   254→ * Clear failed attempts for an IP (on successful login)\n   255→ * @param {string} ip - Client IP address\n   256→ */\n   257→function clearFailedAttempts(ip) {\n   258→  failedAttempts.delete(ip);\n   259→}\n   260→\n   261→/**\n   262→ * Get failed attempts info for an IP\n   263→ * @param {string} ip - Client IP address\n   264→ * @returns {Object|null} Failed attempts info or null\n   265→ */\n   266→function getFailedAttempts(ip) {\n   267→  return failedAttempts.get(ip) || null;\n   268→}\n   269→\n   270→// ============================================================================\n   271→// Public Logging Functions\n   272→// ============================================================================\n   273→\n   274→/**\n   275→ * Log successful login\n   276→ * @param {Object} req - Express request object\n   277→ * @param {string} userId - Customer ID\n   278→ * @param {Object} options - Additional options (email, tier)\n   279→ */\n   280→function logLoginSuccess(req, userId, options = {}) {\n   281→  const ip = getClientIp(req);\n   282→  clearFailedAttempts(ip); // Reset failed attempts on success\n   283→\n   284→  const entry = createLogEntry(AUTH_EVENTS.LOGIN_SUCCESS, LOG_LEVELS.INFO, {\n   285→    userId,\n   286→    ipAddress: ip,\n   287→    email: options.email,\n   288→    tier: options.tier\n   289→  });\n   290→\n   291→  outputLog(entry);\n   292→}\n   293→\n   294→/**\n   295→ * Log failed login attempt\n   296→ * @param {Object} req - Express request object\n   297→ * @param {string} reason - Reason for failure\n   298→ * @param {Object} options - Additional options (licenseKey)\n   299→ */\n   300→function logLoginFailed(req, reason, options = {}) {\n   301→  const ip = getClientIp(req);\n   302→  const attemptCount = trackFailedAttempt(ip);\n   303→\n   304→  const entry = createLogEntry(AUTH_EVENTS.LOGIN_FAILED, LOG_LEVELS.WARN, {\n   305→    ipAddress: ip,\n   306→    reason,\n   307→    details: {\n   308→      attempt_count: attemptCount,\n   309→      license_key_provided: !!options.licenseKey,\n   310→      license_key_masked: options.licenseKey ? maskData(options.licenseKey, 'license_key') : null\n   311→    }\n   312→  });\n   313→\n   314→  outputLog(entry);\n   315→\n   316→  // Log suspicious activity if threshold exceeded\n   317→  if (attemptCount >= FAILED_ATTEMPTS_THRESHOLD) {\n   318→    logSuspiciousActivity(req, 'multiple_failed_logins', {\n   319→      attempt_count: attemptCount,\n   320→      window_minutes: Math.floor(FAILED_ATTEMPTS_TTL / 60000)\n   321→    });\n   322→  }\n   323→}\n   324→\n   325→/**\n   326→ * Log successful logout\n   327→ * @param {Object} req - Express request object\n   328→ * @param {string} userId - Customer ID\n   329→ * @param {Object} options - Additional options (jti, refreshTokenRevoked)\n   330→ */\n   331→function logLogoutSuccess(req, userId, options = {}) {\n   332→  const entry = createLogEntry(AUTH_EVENTS.LOGOUT_SUCCESS, LOG_LEVELS.INFO, {\n   333→    userId,\n   334→    ipAddress: getClientIp(req),\n   335→    jti: options.jti,\n   336→    details: {\n   337→      refresh_token_revoked: !!options.refreshTokenRevoked\n   338→    }\n   339→  });\n   340→\n   341→  outputLog(entry);\n   342→}\n   343→\n   344→/**\n   345→ * Log token refresh success\n   346→ * @param {Object} req - Express request object\n   347→ * @param {string} userId - Customer ID\n   348→ */\n   349→function logTokenRefreshSuccess(req, userId) {\n   350→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_SUCCESS, LOG_LEVELS.INFO, {\n   351→    userId,\n   352→    ipAddress: getClientIp(req)\n   353→  });\n   354→\n   355→  outputLog(entry);\n   356→}\n   357→\n   358→/**\n   359→ * Log token refresh failure\n   360→ * @param {Object} req - Express request object\n   361→ * @param {string} reason - Reason for failure\n   362→ */\n   363→function logTokenRefreshFailed(req, reason) {\n   364→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_FAILED, LOG_LEVELS.WARN, {\n   365→    ipAddress: getClientIp(req),\n   366→    reason\n   367→  });\n   368→\n   369→  outputLog(entry);\n   370→}\n   371→\n   372→/**\n   373→ * Log token revocation (blacklisting)\n   374→ * @param {string} userId - Customer ID\n   375→ * @param {string} jti - JWT ID\n   376→ * @param {string} reason - Reason for revocation (logout, security, admin)\n   377→ */\n   378→function logTokenRevoked(userId, jti, reason = 'logout') {\n   379→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REVOKED, LOG_LEVELS.INFO, {\n   380→    userId,\n   381→    jti,\n   382→    reason,\n   383→    ipAddress: 'internal'\n   384→  });\n   385→\n   386→  outputLog(entry);\n   387→}\n   388→\n   389→/**\n   390→ * Log token validation failure (expired)\n   391→ * @param {Object} req - Express request object\n   392→ */\n   393→function logTokenExpired(req) {\n   394→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_EXPIRED, LOG_LEVELS.INFO, {\n   395→    ipAddress: getClientIp(req)\n   396→  });\n   397→\n   398→  outputLog(entry);\n   399→}\n   400→\n   401→/**\n   402→ * Log token validation failure (invalid signature/format)\n   403→ * @param {Object} req - Express request object\n   404→ * @param {string} reason - Specific reason\n   405→ */\n   406→function logTokenInvalid(req, reason) {\n   407→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_INVALID, LOG_LEVELS.WARN, {\n   408→    ipAddress: getClientIp(req),\n   409→    reason\n   410→  });\n   411→\n   412→  outputLog(entry);\n   413→}\n   414→\n   415→/**\n   416→ * Log blacklisted token access attempt\n   417→ * @param {Object} req - Express request object\n   418→ * @param {string} jti - JWT ID\n   419→ */\n   420→function logTokenBlacklisted(req, jti) {\n   421→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_BLACKLISTED, LOG_LEVELS.WARN, {\n   422→    ipAddress: getClientIp(req),\n   423→    jti,\n   424→    reason: 'Token has been revoked'\n   425→  });\n   426→\n   427→  outputLog(entry);\n   428→}\n   429→\n   430→/**\n   431→ * Log suspicious activity\n   432→ * @param {Object} req - Express request object\n   433→ * @param {string} activity - Type of suspicious activity\n   434→ * @param {Object} details - Additional details\n   435→ */\n   436→function logSuspiciousActivity(req, activity, details = {}) {\n   437→  const entry = createLogEntry(AUTH_EVENTS.SUSPICIOUS_ACTIVITY, LOG_LEVELS.WARN, {\n   438→    ipAddress: getClientIp(req),\n   439→    reason: activity,\n   440→    details\n   441→  });\n   442→\n   443→  outputLog(entry);\n   444→}\n   445→\n   446→/**\n   447→ * Log use of legacy authentication header\n   448→ * @param {Object} req - Express request object\n   449→ * @param {string} userId - Customer ID\n   450→ */\n   451→function logLegacyAuthUsed(req, userId) {\n   452→  const entry = createLogEntry(AUTH_EVENTS.LEGACY_AUTH_USED, LOG_LEVELS.WARN, {\n   453→    userId,\n   454→    ipAddress: getClientIp(req),\n   455→    reason: 'x-stripe-customer-id header used instead of JWT'\n   456→  });\n   457→\n   458→  outputLog(entry);\n   459→}\n   460→\n   461→/**\n   462→ * Log blacklist cleanup\n   463→ * @param {number} removedCount - Number of entries removed\n   464→ * @param {number} remainingCount - Number of entries remaining\n   465→ */\n   466→function logBlacklistCleanup(removedCount, remainingCount) {\n   467→  const entry = createLogEntry(AUTH_EVENTS.BLACKLIST_CLEANUP, LOG_LEVELS.INFO, {\n   468→    ipAddress: 'internal',\n   469→    details: {\n   470→      removed_count: removedCount,\n   471→      remaining_count: remainingCount\n   472→    }\n   473→  });\n   474→\n   475→  outputLog(entry);\n   476→}\n   477→\n   478→// Cleanup interval for failed attempts tracking\n   479→setInterval(() => {\n   480→  const now = Date.now();\n   481→  for (const [ip, data] of failedAttempts.entries()) {\n   482→    if (now - data.lastAttempt > FAILED_ATTEMPTS_TTL) {\n   483→      failedAttempts.delete(ip);\n   484→    }\n   485→  }\n   486→}, FAILED_ATTEMPTS_TTL);\n   487→\n   488→module.exports = {\n   489→  // Event types\n   490→  AUTH_EVENTS,\n   491→  LOG_LEVELS,\n   492→\n   493→  // Utility functions\n   494→  getClientIp,\n   495→  maskData,\n   496→\n   497→  // Failed attempts tracking\n   498→  trackFailedAttempt,\n   499→  clearFailedAttempts,\n   500→  getFailedAttempts,\n   501→  FAILED_ATTEMPTS_THRESHOLD,\n   502→\n   503→  // Logging functions\n   504→  logLoginSuccess,\n   505→  logLoginFailed,\n   506→  logLogoutSuccess,\n   507→  logTokenRefreshSuccess,\n   508→  logTokenRefreshFailed,\n   509→  logTokenRevoked,\n   510→  logTokenExpired,\n   511→  logTokenInvalid,\n   512→  logTokenBlacklisted,\n   513→  logSuspiciousActivity,\n   514→  logLegacyAuthUsed,\n   515→  logBlacklistCleanup\n   516→};\n   517→\n\n</system-reminder>\n"}]},"uuid":"c490eb0e-c405-4e6a-9793-c4cf4c65f4f7","timestamp":"2025-12-30T02:10:36.594Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/utils/authLogger.js","content":"/**\n * Structured Authentication Logger\n *\n * Provides consistent JSON-formatted logging for authentication events.\n * Designed to be captured by log aggregators (CloudWatch, Datadog, etc.)\n *\n * Log Format:\n * {\n *   timestamp: ISO8601 string,\n *   event_type: string,\n *   level: 'info' | 'warn' | 'error',\n *   user_id: string (masked),\n *   ip_address: string,\n *   details: object\n * }\n */\n\n/**\n * Event types for authentication logging\n */\nconst AUTH_EVENTS = {\n  // Login events\n  LOGIN_SUCCESS: 'auth.login.success',\n  LOGIN_FAILED: 'auth.login.failed',\n  LOGIN_RATE_LIMITED: 'auth.login.rate_limited',\n\n  // Logout events\n  LOGOUT_SUCCESS: 'auth.logout.success',\n  LOGOUT_FAILED: 'auth.logout.failed',\n\n  // Token events\n  TOKEN_REFRESH_SUCCESS: 'auth.token.refresh_success',\n  TOKEN_REFRESH_FAILED: 'auth.token.refresh_failed',\n  TOKEN_REVOKED: 'auth.token.revoked',\n  TOKEN_EXPIRED: 'auth.token.expired',\n  TOKEN_INVALID: 'auth.token.invalid',\n  TOKEN_BLACKLISTED: 'auth.token.blacklisted',\n\n  // Security events\n  SUSPICIOUS_ACTIVITY: 'auth.security.suspicious',\n  MULTIPLE_FAILED_ATTEMPTS: 'auth.security.multiple_failures',\n  LEGACY_AUTH_USED: 'auth.security.legacy_header',\n\n  // Blacklist events\n  BLACKLIST_CLEANUP: 'auth.blacklist.cleanup'\n};\n\n/**\n * Log levels\n */\nconst LOG_LEVELS = {\n  INFO: 'info',\n  WARN: 'warn',\n  ERROR: 'error'\n};\n\n/**\n * In-memory store for tracking failed login attempts per IP\n * Used to detect suspicious activity\n */\nconst failedAttempts = new Map();\n\n// Cleanup failed attempts every 15 minutes\nconst FAILED_ATTEMPTS_TTL = 15 * 60 * 1000;\nconst FAILED_ATTEMPTS_THRESHOLD = 5; // Log suspicious after 5 failures\n\n/**\n * Extract client IP from request\n * Handles proxied requests (X-Forwarded-For, X-Real-IP)\n * @param {Object} req - Express request object\n * @returns {string} Client IP address\n */\nfunction getClientIp(req) {\n  if (!req) return 'unknown';\n\n  // Check for proxied IP (common in production behind load balancers)\n  const forwarded = req.headers['x-forwarded-for'];\n  if (forwarded) {\n    // X-Forwarded-For can contain multiple IPs; take the first (client)\n    return forwarded.split(',')[0].trim();\n  }\n\n  const realIp = req.headers['x-real-ip'];\n  if (realIp) {\n    return realIp;\n  }\n\n  // Direct connection\n  return req.ip || req.connection?.remoteAddress || 'unknown';\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} data - Sensitive string to mask\n * @param {string} type - Type of data ('user_id', 'email', 'token', 'jti', 'license_key')\n * @returns {string} Masked string\n */\nfunction maskData(data, type = 'generic') {\n  if (!data || typeof data !== 'string') {\n    return '[empty]';\n  }\n\n  switch (type) {\n    case 'user_id':\n      // Customer ID: cus_xxxx -> cus_xxxx****\n      if (data.startsWith('cus_') && data.length > 10) {\n        return `cus_${data.slice(4, 8)}****`;\n      }\n      return 'cus_****';\n\n    case 'email':\n      if (data.includes('@')) {\n        const [local, domain] = data.split('@');\n        const maskedLocal = local.length > 2\n          ? `${local[0]}***${local[local.length - 1]}`\n          : '***';\n        return `${maskedLocal}@${domain}`;\n      }\n      return '***@***.***';\n\n    case 'jti':\n      // JWT ID: show first 8 chars\n      if (data.length > 8) {\n        return `${data.slice(0, 8)}...`;\n      }\n      return data;\n\n    case 'token':\n      // JWT token: show first 10 chars\n      if (data.startsWith('eyJ') && data.length > 10) {\n        return `${data.slice(0, 10)}...`;\n      }\n      return '[token]';\n\n    case 'license_key':\n      // License key: SPLICE-XXXX-XXXX-XXXX-XXXX -> SPLICE-XXXX-****-****-****\n      if (data.startsWith('SPLICE-')) {\n        const parts = data.split('-');\n        if (parts.length === 5) {\n          return `${parts[0]}-${parts[1]}-****-****-****`;\n        }\n      }\n      return 'SPLICE-****';\n\n    default:\n      // Generic: show first 4 chars\n      if (data.length > 8) {\n        return `${data.slice(0, 4)}****`;\n      }\n      return '****';\n  }\n}\n\n/**\n * Create a structured log entry\n * @param {string} eventType - Event type from AUTH_EVENTS\n * @param {string} level - Log level from LOG_LEVELS\n * @param {Object} options - Log options\n * @returns {Object} Structured log object\n */\nfunction createLogEntry(eventType, level, options = {}) {\n  const {\n    userId = null,\n    ipAddress = 'unknown',\n    jti = null,\n    reason = null,\n    email = null,\n    tier = null,\n    details = {}\n  } = options;\n\n  const entry = {\n    timestamp: new Date().toISOString(),\n    event_type: eventType,\n    level,\n    service: 'splice-auth'\n  };\n\n  // Add user context if available (always masked)\n  if (userId) {\n    entry.user_id = maskData(userId, 'user_id');\n  }\n\n  // Add IP address\n  entry.ip_address = ipAddress;\n\n  // Add optional fields\n  if (jti) {\n    entry.jti = maskData(jti, 'jti');\n  }\n\n  if (reason) {\n    entry.reason = reason;\n  }\n\n  if (email) {\n    entry.email = maskData(email, 'email');\n  }\n\n  if (tier) {\n    entry.tier = tier;\n  }\n\n  // Add any additional details\n  if (Object.keys(details).length > 0) {\n    entry.details = details;\n  }\n\n  return entry;\n}\n\n/**\n * Output a structured log entry\n * @param {Object} entry - Log entry object\n */\nfunction outputLog(entry) {\n  const jsonLog = JSON.stringify(entry);\n\n  switch (entry.level) {\n    case LOG_LEVELS.ERROR:\n      console.error(jsonLog);\n      break;\n    case LOG_LEVELS.WARN:\n      console.warn(jsonLog);\n      break;\n    default:\n      console.log(jsonLog);\n  }\n}\n\n/**\n * Track failed login attempt for an IP\n * @param {string} ip - Client IP address\n * @returns {number} Number of failed attempts from this IP\n */\nfunction trackFailedAttempt(ip) {\n  const now = Date.now();\n  const existing = failedAttempts.get(ip) || { count: 0, firstAttempt: now };\n\n  // Reset if TTL expired\n  if (now - existing.firstAttempt > FAILED_ATTEMPTS_TTL) {\n    existing.count = 0;\n    existing.firstAttempt = now;\n  }\n\n  existing.count++;\n  existing.lastAttempt = now;\n  failedAttempts.set(ip, existing);\n\n  return existing.count;\n}\n\n/**\n * Clear failed attempts for an IP (on successful login)\n * @param {string} ip - Client IP address\n */\nfunction clearFailedAttempts(ip) {\n  failedAttempts.delete(ip);\n}\n\n/**\n * Get failed attempts info for an IP\n * @param {string} ip - Client IP address\n * @returns {Object|null} Failed attempts info or null\n */\nfunction getFailedAttempts(ip) {\n  return failedAttempts.get(ip) || null;\n}\n\n// ============================================================================\n// Public Logging Functions\n// ============================================================================\n\n/**\n * Log successful login\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n * @param {Object} options - Additional options (email, tier)\n */\nfunction logLoginSuccess(req, userId, options = {}) {\n  const ip = getClientIp(req);\n  clearFailedAttempts(ip); // Reset failed attempts on success\n\n  const entry = createLogEntry(AUTH_EVENTS.LOGIN_SUCCESS, LOG_LEVELS.INFO, {\n    userId,\n    ipAddress: ip,\n    email: options.email,\n    tier: options.tier\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log failed login attempt\n * @param {Object} req - Express request object\n * @param {string} reason - Reason for failure\n * @param {Object} options - Additional options (licenseKey)\n */\nfunction logLoginFailed(req, reason, options = {}) {\n  const ip = getClientIp(req);\n  const attemptCount = trackFailedAttempt(ip);\n\n  const entry = createLogEntry(AUTH_EVENTS.LOGIN_FAILED, LOG_LEVELS.WARN, {\n    ipAddress: ip,\n    reason,\n    details: {\n      attempt_count: attemptCount,\n      license_key_provided: !!options.licenseKey,\n      license_key_masked: options.licenseKey ? maskData(options.licenseKey, 'license_key') : null\n    }\n  });\n\n  outputLog(entry);\n\n  // Log suspicious activity if threshold exceeded\n  if (attemptCount >= FAILED_ATTEMPTS_THRESHOLD) {\n    logSuspiciousActivity(req, 'multiple_failed_logins', {\n      attempt_count: attemptCount,\n      window_minutes: Math.floor(FAILED_ATTEMPTS_TTL / 60000)\n    });\n  }\n}\n\n/**\n * Log successful logout\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n * @param {Object} options - Additional options (jti, refreshTokenRevoked)\n */\nfunction logLogoutSuccess(req, userId, options = {}) {\n  const entry = createLogEntry(AUTH_EVENTS.LOGOUT_SUCCESS, LOG_LEVELS.INFO, {\n    userId,\n    ipAddress: getClientIp(req),\n    jti: options.jti,\n    details: {\n      refresh_token_revoked: !!options.refreshTokenRevoked\n    }\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token refresh success\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n */\nfunction logTokenRefreshSuccess(req, userId) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_SUCCESS, LOG_LEVELS.INFO, {\n    userId,\n    ipAddress: getClientIp(req)\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token refresh failure\n * @param {Object} req - Express request object\n * @param {string} reason - Reason for failure\n */\nfunction logTokenRefreshFailed(req, reason) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_FAILED, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    reason\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token revocation (blacklisting)\n * @param {string} userId - Customer ID\n * @param {string} jti - JWT ID\n * @param {string} reason - Reason for revocation (logout, security, admin)\n */\nfunction logTokenRevoked(userId, jti, reason = 'logout') {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REVOKED, LOG_LEVELS.INFO, {\n    userId,\n    jti,\n    reason,\n    ipAddress: 'internal'\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token validation failure (expired)\n * @param {Object} req - Express request object\n */\nfunction logTokenExpired(req) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_EXPIRED, LOG_LEVELS.INFO, {\n    ipAddress: getClientIp(req)\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token validation failure (invalid signature/format)\n * @param {Object} req - Express request object\n * @param {string} reason - Specific reason\n */\nfunction logTokenInvalid(req, reason) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_INVALID, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    reason\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log blacklisted token access attempt\n * @param {Object} req - Express request object\n * @param {string} jti - JWT ID\n */\nfunction logTokenBlacklisted(req, jti) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_BLACKLISTED, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    jti,\n    reason: 'Token has been revoked'\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log suspicious activity\n * @param {Object} req - Express request object\n * @param {string} activity - Type of suspicious activity\n * @param {Object} details - Additional details\n */\nfunction logSuspiciousActivity(req, activity, details = {}) {\n  const entry = createLogEntry(AUTH_EVENTS.SUSPICIOUS_ACTIVITY, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    reason: activity,\n    details\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log use of legacy authentication header\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n */\nfunction logLegacyAuthUsed(req, userId) {\n  const entry = createLogEntry(AUTH_EVENTS.LEGACY_AUTH_USED, LOG_LEVELS.WARN, {\n    userId,\n    ipAddress: getClientIp(req),\n    reason: 'x-stripe-customer-id header used instead of JWT'\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log blacklist cleanup\n * @param {number} removedCount - Number of entries removed\n * @param {number} remainingCount - Number of entries remaining\n */\nfunction logBlacklistCleanup(removedCount, remainingCount) {\n  const entry = createLogEntry(AUTH_EVENTS.BLACKLIST_CLEANUP, LOG_LEVELS.INFO, {\n    ipAddress: 'internal',\n    details: {\n      removed_count: removedCount,\n      remaining_count: remainingCount\n    }\n  });\n\n  outputLog(entry);\n}\n\n// Cleanup interval for failed attempts tracking\nsetInterval(() => {\n  const now = Date.now();\n  for (const [ip, data] of failedAttempts.entries()) {\n    if (now - data.lastAttempt > FAILED_ATTEMPTS_TTL) {\n      failedAttempts.delete(ip);\n    }\n  }\n}, FAILED_ATTEMPTS_TTL);\n\nmodule.exports = {\n  // Event types\n  AUTH_EVENTS,\n  LOG_LEVELS,\n\n  // Utility functions\n  getClientIp,\n  maskData,\n\n  // Failed attempts tracking\n  trackFailedAttempt,\n  clearFailedAttempts,\n  getFailedAttempts,\n  FAILED_ATTEMPTS_THRESHOLD,\n\n  // Logging functions\n  logLoginSuccess,\n  logLoginFailed,\n  logLogoutSuccess,\n  logTokenRefreshSuccess,\n  logTokenRefreshFailed,\n  logTokenRevoked,\n  logTokenExpired,\n  logTokenInvalid,\n  logTokenBlacklisted,\n  logSuspiciousActivity,\n  logLegacyAuthUsed,\n  logBlacklistCleanup\n};\n","numLines":517,"startLine":1,"totalLines":517}}}
{"parentUuid":"c490eb0e-c405-4e6a-9793-c4cf4c65f4f7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WoGJMDLkqwvBbvTbsdsH9D","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Email Service\n     3→ *\n     4→ * Handles email delivery for license keys, payment notifications, etc.\n     5→ * Supports multiple providers: SendGrid (primary), AWS SES (fallback)\n     6→ *\n     7→ * Required env vars:\n     8→ * - EMAIL_PROVIDER: 'sendgrid' | 'ses' | 'console' (default: 'console' for dev)\n     9→ * - SENDGRID_API_KEY: SendGrid API key\n    10→ * - AWS_SES_REGION: AWS SES region (default: 'us-east-1')\n    11→ * - AWS_ACCESS_KEY_ID: AWS access key (for SES)\n    12→ * - AWS_SECRET_ACCESS_KEY: AWS secret (for SES)\n    13→ * - EMAIL_FROM: Sender email address (default: 'noreply@splice.video')\n    14→ */\n    15→\n    16→// ============================================================================\n    17→// CONFIGURATION\n    18→// ============================================================================\n    19→\n    20→const EMAIL_CONFIG = {\n    21→  provider: process.env.EMAIL_PROVIDER || 'console',\n    22→  from: process.env.EMAIL_FROM || 'SPLICE <noreply@splice.video>',\n    23→  replyTo: process.env.EMAIL_REPLY_TO || 'support@splice.video',\n    24→  sendgrid: {\n    25→    apiKey: process.env.SENDGRID_API_KEY\n    26→  },\n    27→  ses: {\n    28→    region: process.env.AWS_SES_REGION || 'us-east-1'\n    29→  }\n    30→};\n    31→\n    32→// SendGrid Dynamic Template IDs\n    33→const TEMPLATE_IDS = {\n    34→  signinCode: 'd-8ba02a0aacf0425da03610dce44fd08d',\n    35→  emailVerification: null // Add SendGrid template ID when available\n    36→};\n    37→\n    38→// Email templates\n    39→const TEMPLATES = {\n    40→  licenseKey: {\n    41→    subject: 'Welcome to SPLICE! Your License Key + Quick Start Guide',\n    42→    html: (data) => `\n    43→<!DOCTYPE html>\n    44→<html>\n    45→<head>\n    46→  <meta charset=\"utf-8\">\n    47→  <style>\n    48→    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; margin: 0; padding: 0; }\n    49→    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; background: white; }\n    50→    .header { text-align: center; margin-bottom: 30px; }\n    51→    .logo { font-size: 32px; font-weight: bold; color: #00D4FF; }\n    52→    .tagline { color: #6b7280; font-size: 14px; margin-top: 5px; }\n    53→    .hero-cta { background: linear-gradient(135deg, #00D4FF, #00A8CC); border-radius: 12px; padding: 30px; text-align: center; margin: 30px 0; }\n    54→    .hero-cta h2 { color: white; margin: 0 0 15px 0; font-size: 22px; }\n    55→    .hero-cta p { color: rgba(255,255,255,0.9); margin: 0 0 20px 0; }\n    56→    .button-primary { display: inline-block; background: white; color: #00A8CC; padding: 14px 32px; border-radius: 8px; text-decoration: none; font-weight: bold; font-size: 16px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); }\n    57→    .button-primary:hover { background: #f0f0f0; }\n    58→    .license-box { background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 8px; padding: 20px; text-align: center; margin: 30px 0; }\n    59→    .license-key { font-family: monospace; font-size: 22px; font-weight: bold; color: #1e293b; letter-spacing: 2px; }\n    60→    .tier-badge { display: inline-block; background: #00D4FF; color: white; padding: 4px 12px; border-radius: 20px; font-size: 14px; margin-top: 10px; }\n    61→    .quick-wins { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; padding: 20px; margin: 20px 0; }\n    62→    .quick-wins h3 { color: #166534; margin-top: 0; }\n    63→    .quick-wins ul { margin: 0; padding-left: 20px; }\n    64→    .quick-wins li { margin: 8px 0; color: #15803d; }\n    65→    .instructions { background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0; }\n    66→    .instructions h3 { margin-top: 0; color: #374151; }\n    67→    .instructions ol { margin: 0; padding-left: 20px; }\n    68→    .instructions li { margin: 8px 0; }\n    69→    .resources { display: table; width: 100%; margin: 20px 0; }\n    70→    .resource-item { display: table-cell; text-align: center; padding: 15px; width: 33%; }\n    71→    .resource-item a { display: block; color: #00A8CC; text-decoration: none; font-weight: 500; }\n    72→    .resource-item span { display: block; font-size: 12px; color: #6b7280; margin-top: 5px; }\n    73→    .footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 14px; }\n    74→    .button { display: inline-block; background: #00D4FF; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; margin: 10px 0; }\n    75→  </style>\n    76→</head>\n    77→<body>\n    78→  <div class=\"container\">\n    79→    <div class=\"header\">\n    80→      <div class=\"logo\">SPLICE</div>\n    81→      <p class=\"tagline\">Cut Your Editing Time in Half. Automatically.</p>\n    82→    </div>\n    83→\n    84→    <div class=\"hero-cta\">\n    85→      <h2>🎉 You're In! Let's Get Started</h2>\n    86→      <p>Download SPLICE and make your first AI-powered edit in under 2 minutes.</p>\n    87→      <a href=\"https://splice.video/download\" class=\"button-primary\">Download SPLICE →</a>\n    88→    </div>\n    89→\n    90→    <div class=\"license-box\">\n    91→      <p style=\"margin: 0 0 10px; color: #6b7280; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;\">Your License Key</p>\n    92→      <div class=\"license-key\">${escapeHtml(data.licenseKey)}</div>\n    93→      <div class=\"tier-badge\">${escapeHtml(data.tier.toUpperCase())} Plan</div>\n    94→    </div>\n    95→\n    96→    <div class=\"quick-wins\">\n    97→      <h3>⚡ Your First 5-Minute Win</h3>\n    98→      <ul>\n    99→        <li><strong>Open any project</strong> in Premiere Pro</li>\n   100→        <li><strong>Click GO</strong> in the SPLICE panel</li>\n   101→        <li><strong>Watch silences vanish</strong> automatically</li>\n   102→      </ul>\n   103→      <p style=\"margin-bottom: 0; font-size: 14px;\">Most editors save <strong>2+ hours per video</strong> on their first use!</p>\n   104→    </div>\n   105→\n   106→    <div class=\"instructions\">\n   107→      <h3>📋 Setup Instructions</h3>\n   108→      <ol>\n   109→        <li>Open Adobe Premiere Pro (2023 or later)</li>\n   110→        <li>Go to <strong>Window → Extensions → SPLICE</strong></li>\n   111→        <li>Click the Login button and enter your license key</li>\n   112→        <li>You're ready! Open any sequence and hit <strong>GO</strong></li>\n   113→      </ol>\n   114→    </div>\n   115→\n   116→    <p>Your ${escapeHtml(data.tier)} plan includes:</p>\n   117→    <ul>\n   118→      <li><strong>${escapeHtml(String(data.hours))} hours</strong> of AI processing per month</li>\n   119→      <li><strong>${escapeHtml(String(data.musicCredits))} music credits</strong> per month</li>\n   120→      <li>14-day free trial - cancel anytime</li>\n   121→    </ul>\n   122→\n   123→    <div class=\"resources\">\n   124→      <div class=\"resource-item\">\n   125→        <a href=\"https://splice.video/docs/tutorials\">📚 Tutorials</a>\n   126→        <span>Step-by-step guides</span>\n   127→      </div>\n   128→      <div class=\"resource-item\">\n   129→        <a href=\"https://splice.video/docs/faq\">❓ FAQ</a>\n   130→        <span>Common questions</span>\n   131→      </div>\n   132→      <div class=\"resource-item\">\n   133→        <a href=\"mailto:support@splice.video\">💬 Support</a>\n   134→        <span>We're here to help</span>\n   135→      </div>\n   136→    </div>\n   137→\n   138→    <div class=\"footer\">\n   139→      <p>Questions? Just reply to this email - we read every message!</p>\n   140→      <p style=\"font-size: 12px;\">&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n   141→    </div>\n   142→  </div>\n   143→</body>\n   144→</html>\n   145→    `,\n   146→    text: (data) => `\n   147→SPLICE - Welcome! Your License Key + Quick Start Guide\n   148→=======================================================\n   149→\n   150→🎉 YOU'RE IN! LET'S GET STARTED\n   151→\n   152→Download SPLICE: https://splice.video/download\n   153→\n   154→YOUR LICENSE KEY:\n   155→${data.licenseKey}\n   156→Plan: ${data.tier.toUpperCase()}\n   157→\n   158→⚡ YOUR FIRST 5-MINUTE WIN:\n   159→1. Open any project in Premiere Pro\n   160→2. Click GO in the SPLICE panel\n   161→3. Watch silences vanish automatically\n   162→\n   163→Most editors save 2+ hours per video on their first use!\n   164→\n   165→📋 SETUP INSTRUCTIONS:\n   166→1. Open Adobe Premiere Pro (2023 or later)\n   167→2. Go to Window → Extensions → SPLICE\n   168→3. Click the Login button and enter your license key\n   169→4. You're ready! Open any sequence and hit GO\n   170→\n   171→YOUR ${data.tier.toUpperCase()} PLAN INCLUDES:\n   172→- ${data.hours} hours of AI processing per month\n   173→- ${data.musicCredits} music credits per month\n   174→- 14-day free trial - cancel anytime\n   175→\n   176→HELPFUL RESOURCES:\n   177→📚 Tutorials: https://splice.video/docs/tutorials\n   178→❓ FAQ: https://splice.video/docs/faq\n   179→💬 Support: support@splice.video\n   180→\n   181→Questions? Just reply to this email - we read every message!\n   182→\n   183→© ${new Date().getFullYear()} SPLICE. All rights reserved.\n   184→    `\n   185→  },\n   186→\n   187→  paymentWarning: {\n   188→    subject: 'Action Required: Payment Failed for SPLICE',\n   189→    html: (data) => `\n   190→<!DOCTYPE html>\n   191→<html>\n   192→<head>\n   193→  <meta charset=\"utf-8\">\n   194→  <style>\n   195→    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }\n   196→    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; }\n   197→    .header { text-align: center; margin-bottom: 30px; }\n   198→    .logo { font-size: 32px; font-weight: bold; color: #7c3aed; }\n   199→    .warning-box { background: #fef2f2; border: 2px solid #ef4444; border-radius: 8px; padding: 20px; margin: 20px 0; }\n   200→    .warning-icon { font-size: 48px; text-align: center; }\n   201→    .button { display: inline-block; background: #7c3aed; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; margin: 10px 0; }\n   202→    .footer { text-align: center; margin-top: 40px; color: #6b7280; font-size: 14px; }\n   203→  </style>\n   204→</head>\n   205→<body>\n   206→  <div class=\"container\">\n   207→    <div class=\"header\">\n   208→      <div class=\"logo\">SPLICE</div>\n   209→    </div>\n   210→\n   211→    <div class=\"warning-box\">\n   212→      <div class=\"warning-icon\">⚠️</div>\n   213→      <h2 style=\"text-align: center; color: #dc2626; margin: 10px 0;\">Payment Failed</h2>\n   214→      <p>We were unable to process your payment for your SPLICE subscription. This was attempt ${escapeHtml(String(data.attemptCount))} of 3.</p>\n   215→    </div>\n   216→\n   217→    <p>To keep your subscription active and avoid interruption to your service, please update your payment method:</p>\n   218→\n   219→    <p style=\"text-align: center;\">\n   220→      <a href=\"https://splice.video/account/billing\" class=\"button\">Update Payment Method</a>\n   221→    </p>\n   222→\n   223→    <p><strong>What happens next?</strong></p>\n   224→    <ul>\n   225→      <li>We'll automatically retry the payment in a few days</li>\n   226→      <li>If all payment attempts fail, your subscription will be cancelled</li>\n   227→      <li>You'll lose access to premium features</li>\n   228→    </ul>\n   229→\n   230→    <p>If you have any questions or need assistance, please don't hesitate to reach out.</p>\n   231→\n   232→    <div class=\"footer\">\n   233→      <p>Need help? Reply to this email or visit <a href=\"https://splice.video/support\">splice.video/support</a></p>\n   234→      <p>&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n   235→    </div>\n   236→  </div>\n   237→</body>\n   238→</html>\n   239→    `,\n   240→    text: (data) => `\n   241→SPLICE - Payment Failed\n   242→\n   243→We were unable to process your payment for your SPLICE subscription.\n   244→This was attempt ${data.attemptCount} of 3.\n   245→\n   246→To keep your subscription active, please update your payment method:\n   247→https://splice.video/account/billing\n   248→\n   249→WHAT HAPPENS NEXT:\n   250→- We'll automatically retry the payment in a few days\n   251→- If all payment attempts fail, your subscription will be cancelled\n   252→- You'll lose access to premium features\n   253→\n   254→If you have any questions, please reply to this email.\n   255→\n   256→© ${new Date().getFullYear()} SPLICE. All rights reserved.\n   257→    `\n   258→  },\n   259→\n   260→  licenseLookup: {\n   261→    subject: 'Your SPLICE License Key',\n   262→    html: (data) => `\n   263→<!DOCTYPE html>\n   264→<html>\n   265→<head>\n   266→  <meta charset=\"utf-8\">\n   267→  <style>\n   268→    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }\n   269→    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; }\n   270→    .header { text-align: center; margin-bottom: 30px; }\n   271→    .logo { font-size: 32px; font-weight: bold; color: #7c3aed; }\n   272→    .license-box { background: #f8f5ff; border: 2px solid #7c3aed; border-radius: 8px; padding: 20px; text-align: center; margin: 30px 0; }\n   273→    .license-key { font-family: monospace; font-size: 24px; font-weight: bold; color: #7c3aed; letter-spacing: 2px; }\n   274→    .footer { text-align: center; margin-top: 40px; color: #6b7280; font-size: 14px; }\n   275→  </style>\n   276→</head>\n   277→<body>\n   278→  <div class=\"container\">\n   279→    <div class=\"header\">\n   280→      <div class=\"logo\">SPLICE</div>\n   281→    </div>\n   282→\n   283→    <h2>License Key Lookup</h2>\n   284→    <p>You requested your SPLICE license key. Here it is:</p>\n   285→\n   286→    <div class=\"license-box\">\n   287→      <div class=\"license-key\">${escapeHtml(data.licenseKey)}</div>\n   288→    </div>\n   289→\n   290→    <p>If you didn't request this, you can safely ignore this email.</p>\n   291→\n   292→    <div class=\"footer\">\n   293→      <p>Need help? Reply to this email or visit <a href=\"https://splice.video/support\">splice.video/support</a></p>\n   294→      <p>&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n   295→    </div>\n   296→  </div>\n   297→</body>\n   298→</html>\n   299→    `,\n   300→    text: (data) => `\n   301→SPLICE - License Key Lookup\n   302→\n   303→You requested your SPLICE license key. Here it is:\n   304→\n   305→${data.licenseKey}\n   306→\n   307→If you didn't request this, you can safely ignore this email.\n   308→\n   309→Need help? Visit https://splice.video/support\n   310→\n   311→© ${new Date().getFullYear()} SPLICE. All rights reserved.\n   312→    `\n   313→  },\n   314→\n   315→  // Sign-in code email (passwordless auth)\n   316→  signinCode: {\n   317→    subject: 'Your SPLICE Sign-In Code: {{code}}',\n   318→    html: (data) => `\n   319→<!DOCTYPE html>\n   320→<html lang=\"en\">\n   321→<head>\n   322→  <meta charset=\"UTF-8\">\n   323→  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   324→  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n   325→  <title>Your SPLICE Sign-In Code</title>\n   326→  <!--[if mso]>\n   327→  <noscript>\n   328→    <xml>\n   329→      <o:OfficeDocumentSettings>\n   330→        <o:PixelsPerInch>96</o:PixelsPerInch>\n   331→      </o:OfficeDocumentSettings>\n   332→    </xml>\n   333→  </noscript>\n   334→  <![endif]-->\n   335→  <style>\n   336→    body, table, td, p, a, li { -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }\n   337→    table, td { mso-table-lspace: 0pt; mso-table-rspace: 0pt; }\n   338→    img { -ms-interpolation-mode: bicubic; border: 0; outline: none; text-decoration: none; }\n   339→    body { margin: 0; padding: 0; width: 100%; background-color: #060b14; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }\n   340→    @media only screen and (max-width: 600px) {\n   341→      .container { width: 100% !important; padding: 16px !important; }\n   342→      .code-box { font-size: 28px !important; letter-spacing: 6px !important; }\n   343→    }\n   344→  </style>\n   345→</head>\n   346→<body style=\"margin: 0; padding: 0; background-color: #060b14;\">\n   347→  <div style=\"display: none; max-height: 0; overflow: hidden; font-size: 1px; line-height: 1px; color: #060b14;\">Your SPLICE sign-in code is inside. Start editing 10x faster today!</div>\n   348→  <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"background-color: #060b14;\">\n   349→    <tr>\n   350→      <td align=\"center\" style=\"padding: 40px 20px;\">\n   351→        <table role=\"presentation\" class=\"container\" cellpadding=\"0\" cellspacing=\"0\" width=\"560\" style=\"max-width: 560px;\">\n   352→          <tr>\n   353→            <td align=\"center\" style=\"padding-bottom: 32px;\">\n   354→              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n   355→                <tr>\n   356→                  <td style=\"vertical-align: middle; padding-right: 10px;\">\n   357→                    <img src=\"https://splice.video/images/logo.jpg\" alt=\"SPLICE\" width=\"40\" height=\"40\" style=\"display: block; border-radius: 8px;\">\n   358→                  </td>\n   359→                  <td style=\"vertical-align: middle;\">\n   360→                    <span style=\"font-size: 26px; font-weight: 700; color: #ffffff; letter-spacing: -0.5px;\">SPLICE</span>\n   361→                  </td>\n   362→                </tr>\n   363→              </table>\n   364→            </td>\n   365→          </tr>\n   366→          <tr>\n   367→            <td>\n   368→              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"background: linear-gradient(180deg, #0f1629 0%, #0a0f1a 100%); border-radius: 16px; border: 1px solid rgba(0, 212, 255, 0.15); box-shadow: 0 0 40px rgba(0, 212, 255, 0.08);\">\n   369→                <tr>\n   370→                  <td align=\"center\" style=\"padding: 40px 40px 24px 40px;\">\n   371→                    <h1 style=\"margin: 0; font-size: 28px; font-weight: 600; color: #ffffff; line-height: 1.3;\">Welcome to the future of editing ✨</h1>\n   372→                  </td>\n   373→                </tr>\n   374→                <tr>\n   375→                  <td align=\"center\" style=\"padding: 0 40px 32px 40px;\">\n   376→                    <p style=\"margin: 0; font-size: 16px; color: #94a3b8; line-height: 1.6;\">You're one step away from editing 10x faster. Use this code to sign in:</p>\n   377→                  </td>\n   378→                </tr>\n   379→                <tr>\n   380→                  <td align=\"center\" style=\"padding: 0 40px 32px 40px;\">\n   381→                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" style=\"background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(0, 168, 204, 0.05) 100%); border-radius: 12px; border: 2px solid #00D4FF; box-shadow: 0 0 24px rgba(0, 212, 255, 0.25);\">\n   382→                      <tr>\n   383→                        <td align=\"center\" style=\"padding: 24px 48px;\">\n   384→                          <span class=\"code-box\" style=\"font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 36px; font-weight: 700; color: #00D4FF; letter-spacing: 10px; text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);\">${escapeHtml(data.code)}</span>\n   385→                        </td>\n   386→                      </tr>\n   387→                    </table>\n   388→                  </td>\n   389→                </tr>\n   390→                <tr>\n   391→                  <td align=\"center\" style=\"padding: 0 40px 40px 40px;\">\n   392→                    <p style=\"margin: 0; font-size: 14px; color: #64748b;\">⏱️ This code expires in <strong style=\"color: #ffffff;\">10 minutes</strong></p>\n   393→                  </td>\n   394→                </tr>\n   395→                <tr>\n   396→                  <td style=\"padding: 0 40px;\">\n   397→                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n   398→                      <tr><td style=\"border-top: 1px solid rgba(148, 163, 184, 0.1);\"></td></tr>\n   399→                    </table>\n   400→                  </td>\n   401→                </tr>\n   402→                <tr>\n   403→                  <td style=\"padding: 40px;\">\n   404→                    <h2 style=\"margin: 0 0 24px 0; font-size: 18px; font-weight: 600; color: #ffffff;\">🚀 What you'll unlock:</h2>\n   405→                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n   406→                      <tr>\n   407→                        <td width=\"50%\" style=\"padding: 8px 8px 8px 0; vertical-align: top;\">\n   408→                          <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n   409→                            <tr>\n   410→                              <td style=\"padding-right: 12px; vertical-align: top;\"><span style=\"font-size: 20px;\">⚡</span></td>\n   411→                              <td style=\"vertical-align: top;\">\n   412→                                <p style=\"margin: 0; font-size: 14px; color: #e2e8f0; font-weight: 500;\">AI Silence Removal</p>\n   413→                                <p style=\"margin: 4px 0 0 0; font-size: 13px; color: #64748b;\">Auto-trim dead air</p>\n   414→                              </td>\n   415→                            </tr>\n   416→                          </table>\n   417→                        </td>\n   418→                        <td width=\"50%\" style=\"padding: 8px 0 8px 8px; vertical-align: top;\">\n   419→                          <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n   420→                            <tr>\n   421→                              <td style=\"padding-right: 12px; vertical-align: top;\"><span style=\"font-size: 20px;\">🎬</span></td>\n   422→                              <td style=\"vertical-align: top;\">\n   423→                                <p style=\"margin: 0; font-size: 14px; color: #e2e8f0; font-weight: 500;\">Smart Take Detection</p>\n   424→                                <p style=\"margin: 4px 0 0 0; font-size: 13px; color: #64748b;\">Find best takes fast</p>\n   425→                              </td>\n   426→                            </tr>\n   427→                          </table>\n   428→                        </td>\n   429→                      </tr>\n   430→                      <tr>\n   431→                        <td width=\"50%\" style=\"padding: 8px 8px 8px 0; vertical-align: top;\">\n   432→                          <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n   433→                            <tr>\n   434→                              <td style=\"padding-right: 12px; vertical-align: top;\"><span style=\"font-size: 20px;\">🎵</span></td>\n   435→                              <td style=\"vertical-align: top;\">\n   436→                                <p style=\"margin: 0; font-size: 14px; color: #e2e8f0; font-weight: 500;\">AI Music Generation</p>\n   437→                                <p style=\"margin: 4px 0 0 0; font-size: 13px; color: #64748b;\">Royalty-free tracks</p>\n   438→                              </td>\n   439→                            </tr>\n   440→                          </table>\n   441→                        </td>\n   442→                        <td width=\"50%\" style=\"padding: 8px 0 8px 8px; vertical-align: top;\">\n   443→                          <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n   444→                            <tr>\n   445→                              <td style=\"padding-right: 12px; vertical-align: top;\"><span style=\"font-size: 20px;\">📱</span></td>\n   446→                              <td style=\"vertical-align: top;\">\n   447→                                <p style=\"margin: 0; font-size: 14px; color: #e2e8f0; font-weight: 500;\">Social Reframe</p>\n   448→                                <p style=\"margin: 4px 0 0 0; font-size: 13px; color: #64748b;\">Export to any platform</p>\n   449→                              </td>\n   450→                            </tr>\n   451→                          </table>\n   452→                        </td>\n   453→                      </tr>\n   454→                    </table>\n   455→                  </td>\n   456→                </tr>\n   457→                <tr>\n   458→                  <td align=\"center\" style=\"padding: 0 40px 40px 40px;\">\n   459→                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n   460→                      <tr>\n   461→                        <td align=\"center\" style=\"background: linear-gradient(135deg, #00D4FF 0%, #0099CC 100%); border-radius: 10px; box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);\">\n   462→                          <a href=\"https://splice.video/download\" target=\"_blank\" style=\"display: inline-block; padding: 16px 40px; font-size: 16px; font-weight: 600; color: #060b14; text-decoration: none; letter-spacing: -0.3px;\">Download SPLICE Now →</a>\n   463→                        </td>\n   464→                      </tr>\n   465→                    </table>\n   466→                  </td>\n   467→                </tr>\n   468→              </table>\n   469→            </td>\n   470→          </tr>\n   471→          <tr>\n   472→            <td align=\"center\" style=\"padding: 40px 0 24px 0;\">\n   473→              <p style=\"margin: 0; font-size: 14px; color: #64748b;\">Need help getting started?</p>\n   474→            </td>\n   475→          </tr>\n   476→          <tr>\n   477→            <td align=\"center\" style=\"padding-bottom: 40px;\">\n   478→              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n   479→                <tr>\n   480→                  <td style=\"padding: 0 12px;\"><a href=\"https://splice.video/docs/quickstart\" style=\"font-size: 14px; color: #00D4FF; text-decoration: none;\">Quick Start Guide</a></td>\n   481→                  <td style=\"color: #334155;\">|</td>\n   482→                  <td style=\"padding: 0 12px;\"><a href=\"https://discord.gg/splice\" style=\"font-size: 14px; color: #00D4FF; text-decoration: none;\">Join Discord</a></td>\n   483→                  <td style=\"color: #334155;\">|</td>\n   484→                  <td style=\"padding: 0 12px;\"><a href=\"mailto:support@splice.video\" style=\"font-size: 14px; color: #00D4FF; text-decoration: none;\">Contact Support</a></td>\n   485→                </tr>\n   486→              </table>\n   487→            </td>\n   488→          </tr>\n   489→          <tr>\n   490→            <td align=\"center\" style=\"padding: 24px 0; border-top: 1px solid rgba(148, 163, 184, 0.1);\">\n   491→              <p style=\"margin: 0 0 8px 0; font-size: 13px; color: #475569;\">You received this email because you signed up for SPLICE.</p>\n   492→              <p style=\"margin: 0; font-size: 13px; color: #475569;\">© ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n   493→            </td>\n   494→          </tr>\n   495→        </table>\n   496→      </td>\n   497→    </tr>\n   498→  </table>\n   499→</body>\n   500→</html>\n   501→    `,\n   502→    text: (data) => `\n   503→Welcome to SPLICE!\n   504→\n   505→Your sign-in code is: ${data.code}\n   506→\n   507→This code expires in 10 minutes.\n   508→\n   509→What you'll unlock:\n   510→- ⚡ AI Silence Removal - Auto-trim dead air\n   511→- 🎬 Smart Take Detection - Find best takes fast\n   512→- 🎵 AI Music Generation - Royalty-free tracks\n   513→- 📱 Social Reframe - Export to any platform\n   514→\n   515→Download SPLICE: https://splice.video/download\n   516→\n   517→Need help?\n   518→- Quick Start Guide: https://splice.video/docs/quickstart\n   519→- Join Discord: https://discord.gg/splice\n   520→- Contact Support: support@splice.video\n   521→\n   522→© ${new Date().getFullYear()} SPLICE. All rights reserved.\n   523→    `\n   524→  },\n   525→\n   526→  // Email verification template\n   527→  emailVerification: {\n   528→    subject: 'Verify Your SPLICE Email: {{code}}',\n   529→    html: (data) => `\n   530→<!DOCTYPE html>\n   531→<html lang=\"en\">\n   532→<head>\n   533→  <meta charset=\"UTF-8\">\n   534→  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   535→  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n   536→  <title>Verify Your SPLICE Email</title>\n   537→  <!--[if mso]>\n   538→  <noscript>\n   539→    <xml>\n   540→      <o:OfficeDocumentSettings>\n   541→        <o:PixelsPerInch>96</o:PixelsPerInch>\n   542→      </o:OfficeDocumentSettings>\n   543→    </xml>\n   544→  </noscript>\n   545→  <![endif]-->\n   546→  <style>\n   547→    body, table, td, p, a, li { -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }\n   548→    table, td { mso-table-lspace: 0pt; mso-table-rspace: 0pt; }\n   549→    img { -ms-interpolation-mode: bicubic; border: 0; outline: none; text-decoration: none; }\n   550→    body { margin: 0; padding: 0; width: 100%; background-color: #060b14; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }\n   551→    @media only screen and (max-width: 600px) {\n   552→      .container { width: 100% !important; padding: 16px !important; }\n   553→      .code-box { font-size: 28px !important; letter-spacing: 6px !important; }\n   554→    }\n   555→  </style>\n   556→</head>\n   557→<body style=\"margin: 0; padding: 0; background-color: #060b14;\">\n   558→  <div style=\"display: none; max-height: 0; overflow: hidden; font-size: 1px; line-height: 1px; color: #060b14;\">Verify your email to complete your SPLICE account setup.</div>\n   559→  <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"background-color: #060b14;\">\n   560→    <tr>\n   561→      <td align=\"center\" style=\"padding: 40px 20px;\">\n   562→        <table role=\"presentation\" class=\"container\" cellpadding=\"0\" cellspacing=\"0\" width=\"560\" style=\"max-width: 560px;\">\n   563→          <tr>\n   564→            <td align=\"center\" style=\"padding-bottom: 32px;\">\n   565→              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n   566→                <tr>\n   567→                  <td style=\"vertical-align: middle; padding-right: 10px;\">\n   568→                    <img src=\"https://splice.video/images/logo.jpg\" alt=\"SPLICE\" width=\"40\" height=\"40\" style=\"display: block; border-radius: 8px;\">\n   569→                  </td>\n   570→                  <td style=\"vertical-align: middle;\">\n   571→                    <span style=\"font-size: 26px; font-weight: 700; color: #ffffff; letter-spacing: -0.5px;\">SPLICE</span>\n   572→                  </td>\n   573→                </tr>\n   574→              </table>\n   575→            </td>\n   576→          </tr>\n   577→          <tr>\n   578→            <td>\n   579→              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"background: linear-gradient(180deg, #0f1629 0%, #0a0f1a 100%); border-radius: 16px; border: 1px solid rgba(0, 212, 255, 0.15); box-shadow: 0 0 40px rgba(0, 212, 255, 0.08);\">\n   580→                <tr>\n   581→                  <td align=\"center\" style=\"padding: 40px 40px 24px 40px;\">\n   582→                    <h1 style=\"margin: 0; font-size: 28px; font-weight: 600; color: #ffffff; line-height: 1.3;\">Verify Your Email</h1>\n   583→                  </td>\n   584→                </tr>\n   585→                <tr>\n   586→                  <td align=\"center\" style=\"padding: 0 40px 32px 40px;\">\n   587→                    <p style=\"margin: 0; font-size: 16px; color: #94a3b8; line-height: 1.6;\">Enter this verification code to confirm your email address:</p>\n   588→                  </td>\n   589→                </tr>\n   590→                <tr>\n   591→                  <td align=\"center\" style=\"padding: 0 40px 32px 40px;\">\n   592→                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" style=\"background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(22, 163, 74, 0.05) 100%); border-radius: 12px; border: 2px solid #22c55e; box-shadow: 0 0 24px rgba(34, 197, 94, 0.25);\">\n   593→                      <tr>\n   594→                        <td align=\"center\" style=\"padding: 24px 48px;\">\n   595→                          <span class=\"code-box\" style=\"font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 36px; font-weight: 700; color: #22c55e; letter-spacing: 10px; text-shadow: 0 0 20px rgba(34, 197, 94, 0.5);\">${escapeHtml(data.code)}</span>\n   596→                        </td>\n   597→                      </tr>\n   598→                    </table>\n   599→                  </td>\n   600→                </tr>\n   601→                <tr>\n   602→                  <td align=\"center\" style=\"padding: 0 40px 40px 40px;\">\n   603→                    <p style=\"margin: 0; font-size: 14px; color: #64748b;\">This code expires in <strong style=\"color: #ffffff;\">${escapeHtml(String(data.expiresInMinutes || 10))} minutes</strong></p>\n   604→                  </td>\n   605→                </tr>\n   606→                <tr>\n   607→                  <td style=\"padding: 0 40px;\">\n   608→                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n   609→                      <tr><td style=\"border-top: 1px solid rgba(148, 163, 184, 0.1);\"></td></tr>\n   610→                    </table>\n   611→                  </td>\n   612→                </tr>\n   613→                <tr>\n   614→                  <td align=\"center\" style=\"padding: 32px 40px;\">\n   615→                    <p style=\"margin: 0; font-size: 14px; color: #64748b; line-height: 1.6;\">If you didn't request this verification, you can safely ignore this email.</p>\n   616→                  </td>\n   617→                </tr>\n   618→              </table>\n   619→            </td>\n   620→          </tr>\n   621→          <tr>\n   622→            <td align=\"center\" style=\"padding: 24px 0; border-top: 1px solid rgba(148, 163, 184, 0.1);\">\n   623→              <p style=\"margin: 0 0 8px 0; font-size: 13px; color: #475569;\">You received this email because someone used this address to sign up for SPLICE.</p>\n   624→              <p style=\"margin: 0; font-size: 13px; color: #475569;\">&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n   625→            </td>\n   626→          </tr>\n   627→        </table>\n   628→      </td>\n   629→    </tr>\n   630→  </table>\n   631→</body>\n   632→</html>\n   633→    `,\n   634→    text: (data) => `\n   635→Verify Your SPLICE Email\n   636→\n   637→Your verification code is: ${data.code}\n   638→\n   639→This code expires in ${data.expiresInMinutes || 10} minutes.\n   640→\n   641→If you didn't request this verification, you can safely ignore this email.\n   642→\n   643→© ${new Date().getFullYear()} SPLICE. All rights reserved.\n   644→    `\n   645→  }\n   646→};\n   647→\n   648→// ============================================================================\n   649→// HELPER FUNCTIONS\n   650→// ============================================================================\n   651→\n   652→/**\n   653→ * Escape HTML to prevent XSS in email content\n   654→ */\n   655→function escapeHtml(str) {\n   656→  if (str === null || str === undefined) return '';\n   657→  if (typeof str !== 'string') str = String(str);\n   658→\n   659→  const escapeMap = {\n   660→    '&': '&amp;',\n   661→    '<': '&lt;',\n   662→    '>': '&gt;',\n   663→    '\"': '&quot;',\n   664→    \"'\": '&#x27;'\n   665→  };\n   666→\n   667→  return str.replace(/[&<>\"']/g, char => escapeMap[char]);\n   668→}\n   669→\n   670→/**\n   671→ * Get tier details for email\n   672→ */\n   673→function getTierDetails(tier) {\n   674→  const tiers = {\n   675→    starter: { hours: 4, musicCredits: 2 },\n   676→    pro: { hours: 15, musicCredits: 10 },\n   677→    team: { hours: 50, musicCredits: 50 }\n   678→  };\n   679→  return tiers[tier] || tiers.starter;\n   680→}\n   681→\n   682→// ============================================================================\n   683→// EMAIL PROVIDERS\n   684→// ============================================================================\n   685→\n   686→/**\n   687→ * Send email via SendGrid\n   688→ */\n   689→async function sendViaSendGrid(to, subject, html, text) {\n   690→  if (!EMAIL_CONFIG.sendgrid.apiKey) {\n   691→    throw new Error('SENDGRID_API_KEY not configured');\n   692→  }\n   693→\n   694→  const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n   695→    method: 'POST',\n   696→    headers: {\n   697→      'Authorization': `Bearer ${EMAIL_CONFIG.sendgrid.apiKey}`,\n   698→      'Content-Type': 'application/json'\n   699→    },\n   700→    body: JSON.stringify({\n   701→      personalizations: [{ to: [{ email: to }] }],\n   702→      from: { email: EMAIL_CONFIG.from.match(/<(.+)>/)?.[1] || EMAIL_CONFIG.from, name: 'SPLICE' },\n   703→      reply_to: { email: EMAIL_CONFIG.replyTo },\n   704→      subject,\n   705→      content: [\n   706→        { type: 'text/plain', value: text },\n   707→        { type: 'text/html', value: html }\n   708→      ]\n   709→    })\n   710→  });\n   711→\n   712→  if (!response.ok) {\n   713→    const error = await response.text();\n   714→    throw new Error(`SendGrid error: ${response.status} - ${error}`);\n   715→  }\n   716→\n   717→  return { provider: 'sendgrid', messageId: response.headers.get('x-message-id') };\n   718→}\n   719→\n   720→/**\n   721→ * Send email via SendGrid Dynamic Template\n   722→ * @param {string} to - Recipient email\n   723→ * @param {string} templateId - SendGrid dynamic template ID\n   724→ * @param {Object} dynamicData - Template variables\n   725→ */\n   726→async function sendViaSendGridTemplate(to, templateId, dynamicData = {}) {\n   727→  if (!EMAIL_CONFIG.sendgrid.apiKey) {\n   728→    throw new Error('SENDGRID_API_KEY not configured');\n   729→  }\n   730→\n   731→  const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n   732→    method: 'POST',\n   733→    headers: {\n   734→      'Authorization': `Bearer ${EMAIL_CONFIG.sendgrid.apiKey}`,\n   735→      'Content-Type': 'application/json'\n   736→    },\n   737→    body: JSON.stringify({\n   738→      personalizations: [{\n   739→        to: [{ email: to }],\n   740→        dynamic_template_data: dynamicData\n   741→      }],\n   742→      from: { email: EMAIL_CONFIG.from.match(/<(.+)>/)?.[1] || EMAIL_CONFIG.from, name: 'SPLICE' },\n   743→      reply_to: { email: EMAIL_CONFIG.replyTo },\n   744→      template_id: templateId\n   745→    })\n   746→  });\n   747→\n   748→  if (!response.ok) {\n   749→    const error = await response.text();\n   750→    throw new Error(`SendGrid error: ${response.status} - ${error}`);\n   751→  }\n   752→\n   753→  return { provider: 'sendgrid-template', messageId: response.headers.get('x-message-id'), templateId };\n   754→}\n   755→\n   756→/**\n   757→ * Send email via AWS SES\n   758→ */\n   759→async function sendViaSES(to, subject, html, text) {\n   760→  // Dynamically import AWS SDK to avoid loading if not needed\n   761→  try {\n   762→    const { SESClient, SendEmailCommand } = await import('@aws-sdk/client-ses');\n   763→\n   764→    const client = new SESClient({ region: EMAIL_CONFIG.ses.region });\n   765→\n   766→    const command = new SendEmailCommand({\n   767→      Source: EMAIL_CONFIG.from,\n   768→      Destination: { ToAddresses: [to] },\n   769→      ReplyToAddresses: [EMAIL_CONFIG.replyTo],\n   770→      Message: {\n   771→        Subject: { Data: subject, Charset: 'UTF-8' },\n   772→        Body: {\n   773→          Html: { Data: html, Charset: 'UTF-8' },\n   774→          Text: { Data: text, Charset: 'UTF-8' }\n   775→        }\n   776→      }\n   777→    });\n   778→\n   779→    const result = await client.send(command);\n   780→    return { provider: 'ses', messageId: result.MessageId };\n   781→  } catch (err) {\n   782→    if (err.code === 'ERR_MODULE_NOT_FOUND') {\n   783→      throw new Error('AWS SDK not installed. Run: npm install @aws-sdk/client-ses');\n   784→    }\n   785→    throw err;\n   786→  }\n   787→}\n   788→\n   789→/**\n   790→ * Log email to console (development mode)\n   791→ */\n   792→function sendViaConsole(to, subject, html, text) {\n   793→  console.log('\\n========== EMAIL (CONSOLE MODE) ==========');\n   794→  console.log(`To: ${to}`);\n   795→  console.log(`Subject: ${subject}`);\n   796→  console.log(`From: ${EMAIL_CONFIG.from}`);\n   797→  console.log('--- TEXT VERSION ---');\n   798→  console.log(text);\n   799→  console.log('==========================================\\n');\n   800→\n   801→  return { provider: 'console', messageId: `console-${Date.now()}` };\n   802→}\n   803→\n   804→// ============================================================================\n   805→// PUBLIC API\n   806→// ============================================================================\n   807→\n   808→/**\n   809→ * Send an email using the configured provider\n   810→ * @param {string} to - Recipient email\n   811→ * @param {string} subject - Email subject\n   812→ * @param {string} html - HTML content\n   813→ * @param {string} text - Plain text content\n   814→ * @returns {Promise<{provider: string, messageId: string}>}\n   815→ */\n   816→async function sendEmail(to, subject, html, text) {\n   817→  const provider = EMAIL_CONFIG.provider.toLowerCase();\n   818→\n   819→  console.log(`[SPLICE Email] Sending to ${to} via ${provider}`);\n   820→\n   821→  try {\n   822→    let result;\n   823→\n   824→    switch (provider) {\n   825→      case 'sendgrid':\n   826→        result = await sendViaSendGrid(to, subject, html, text);\n   827→        break;\n   828→      case 'ses':\n   829→        result = await sendViaSES(to, subject, html, text);\n   830→        break;\n   831→      case 'console':\n   832→      default:\n   833→        result = sendViaConsole(to, subject, html, text);\n   834→        break;\n   835→    }\n   836→\n   837→    console.log(`[SPLICE Email] Sent successfully via ${result.provider}: ${result.messageId}`);\n   838→    return result;\n   839→  } catch (err) {\n   840→    console.error(`[SPLICE Email] Failed to send via ${provider}:`, err.message);\n   841→    throw err;\n   842→  }\n   843→}\n   844→\n   845→/**\n   846→ * Send license key email to customer\n   847→ * @param {string} email - Customer email\n   848→ * @param {string} licenseKey - The license key\n   849→ * @param {string} tier - Subscription tier (starter/pro/team)\n   850→ */\n   851→async function sendLicenseKeyEmail(email, licenseKey, tier) {\n   852→  const tierDetails = getTierDetails(tier);\n   853→  const template = TEMPLATES.licenseKey;\n   854→\n   855→  const data = {\n   856→    licenseKey,\n   857→    tier,\n   858→    hours: tierDetails.hours,\n   859→    musicCredits: tierDetails.musicCredits\n   860→  };\n   861→\n   862→  return sendEmail(\n   863→    email,\n   864→    template.subject,\n   865→    template.html(data),\n   866→    template.text(data)\n   867→  );\n   868→}\n   869→\n   870→/**\n   871→ * Send payment warning email to customer\n   872→ * @param {string} email - Customer email\n   873→ * @param {number} attemptCount - Which payment attempt failed (1-3)\n   874→ */\n   875→async function sendPaymentWarningEmail(email, attemptCount) {\n   876→  const template = TEMPLATES.paymentWarning;\n   877→  const data = { attemptCount };\n   878→\n   879→  return sendEmail(\n   880→    email,\n   881→    template.subject,\n   882→    template.html(data),\n   883→    template.text(data)\n   884→  );\n   885→}\n   886→\n   887→/**\n   888→ * Send license key lookup email\n   889→ * @param {string} email - Customer email\n   890→ * @param {string} licenseKey - The license key\n   891→ */\n   892→async function sendLicenseLookupEmail(email, licenseKey) {\n   893→  const template = TEMPLATES.licenseLookup;\n   894→  const data = { licenseKey };\n   895→\n   896→  return sendEmail(\n   897→    email,\n   898→    template.subject,\n   899→    template.html(data),\n   900→    template.text(data)\n   901→  );\n   902→}\n   903→\n   904→/**\n   905→ * Send sign-in code email (passwordless authentication)\n   906→ * @param {string} email - User email\n   907→ * @param {string} code - The sign-in code (e.g., 6-digit code)\n   908→ * @param {number} expiresInMinutes - How long until the code expires (default: 10)\n   909→ */\n   910→async function sendSignInCodeEmail(email, code, expiresInMinutes = 10) {\n   911→  const provider = EMAIL_CONFIG.provider.toLowerCase();\n   912→\n   913→  // Use SendGrid Dynamic Template when available\n   914→  if (provider === 'sendgrid' && TEMPLATE_IDS.signinCode && EMAIL_CONFIG.sendgrid.apiKey) {\n   915→    console.log(`[SPLICE Email] Sending sign-in code to ${email} via SendGrid Dynamic Template`);\n   916→    return sendViaSendGridTemplate(email, TEMPLATE_IDS.signinCode, {\n   917→      code: code,\n   918→      expiresInMinutes: expiresInMinutes\n   919→    });\n   920→  }\n   921→\n   922→  // Fallback to inline template\n   923→  const template = TEMPLATES.signinCode;\n   924→  const data = { code, expiresInMinutes };\n   925→  const subject = template.subject.replace('{{code}}', code);\n   926→\n   927→  return sendEmail(\n   928→    email,\n   929→    subject,\n   930→    template.html(data),\n   931→    template.text(data)\n   932→  );\n   933→}\n   934→\n   935→/**\n   936→ * Send email verification code\n   937→ * @param {string} email - User email\n   938→ * @param {string} code - The 6-digit verification code\n   939→ * @param {number} expiresInMinutes - How long until the code expires (default: 10)\n   940→ */\n   941→async function sendEmailVerificationCode(email, code, expiresInMinutes = 10) {\n   942→  const provider = EMAIL_CONFIG.provider.toLowerCase();\n   943→\n   944→  // Use SendGrid Dynamic Template when available\n   945→  if (provider === 'sendgrid' && TEMPLATE_IDS.emailVerification && EMAIL_CONFIG.sendgrid.apiKey) {\n   946→    console.log(`[SPLICE Email] Sending verification code to ${email} via SendGrid Dynamic Template`);\n   947→    return sendViaSendGridTemplate(email, TEMPLATE_IDS.emailVerification, {\n   948→      code: code,\n   949→      expiresInMinutes: expiresInMinutes\n   950→    });\n   951→  }\n   952→\n   953→  // Fallback to inline template\n   954→  const template = TEMPLATES.emailVerification;\n   955→  const data = { code, expiresInMinutes };\n   956→  const subject = template.subject.replace('{{code}}', code);\n   957→\n   958→  return sendEmail(\n   959→    email,\n   960→    subject,\n   961→    template.html(data),\n   962→    template.text(data)\n   963→  );\n   964→}\n   965→\n   966→/**\n   967→ * Check if email service is configured for production use\n   968→ */\n   969→function isEmailConfigured() {\n   970→  const provider = EMAIL_CONFIG.provider.toLowerCase();\n   971→\n   972→  if (provider === 'sendgrid') {\n   973→    return !!EMAIL_CONFIG.sendgrid.apiKey;\n   974→  }\n   975→\n   976→  if (provider === 'ses') {\n   977→    return !!(process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY);\n   978→  }\n   979→\n   980→  // Console mode is always \"configured\" (for dev)\n   981→  return true;\n   982→}\n   983→\n   984→// ============================================================================\n   985→// EXPORTS\n   986→// ============================================================================\n   987→\n   988→module.exports = {\n   989→  sendEmail,\n   990→  sendLicenseKeyEmail,\n   991→  sendPaymentWarningEmail,\n   992→  sendLicenseLookupEmail,\n   993→  sendSignInCodeEmail,\n   994→  sendEmailVerificationCode,\n   995→  isEmailConfigured,\n   996→  EMAIL_CONFIG\n   997→};\n   998→\n\n</system-reminder>\n"}]},"uuid":"d0c342fa-869e-4c0c-b092-41742aefc122","timestamp":"2025-12-30T02:10:36.847Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/emailService.js","content":"/**\n * SPLICE Email Service\n *\n * Handles email delivery for license keys, payment notifications, etc.\n * Supports multiple providers: SendGrid (primary), AWS SES (fallback)\n *\n * Required env vars:\n * - EMAIL_PROVIDER: 'sendgrid' | 'ses' | 'console' (default: 'console' for dev)\n * - SENDGRID_API_KEY: SendGrid API key\n * - AWS_SES_REGION: AWS SES region (default: 'us-east-1')\n * - AWS_ACCESS_KEY_ID: AWS access key (for SES)\n * - AWS_SECRET_ACCESS_KEY: AWS secret (for SES)\n * - EMAIL_FROM: Sender email address (default: 'noreply@splice.video')\n */\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\nconst EMAIL_CONFIG = {\n  provider: process.env.EMAIL_PROVIDER || 'console',\n  from: process.env.EMAIL_FROM || 'SPLICE <noreply@splice.video>',\n  replyTo: process.env.EMAIL_REPLY_TO || 'support@splice.video',\n  sendgrid: {\n    apiKey: process.env.SENDGRID_API_KEY\n  },\n  ses: {\n    region: process.env.AWS_SES_REGION || 'us-east-1'\n  }\n};\n\n// SendGrid Dynamic Template IDs\nconst TEMPLATE_IDS = {\n  signinCode: 'd-8ba02a0aacf0425da03610dce44fd08d',\n  emailVerification: null // Add SendGrid template ID when available\n};\n\n// Email templates\nconst TEMPLATES = {\n  licenseKey: {\n    subject: 'Welcome to SPLICE! Your License Key + Quick Start Guide',\n    html: (data) => `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; margin: 0; padding: 0; }\n    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; background: white; }\n    .header { text-align: center; margin-bottom: 30px; }\n    .logo { font-size: 32px; font-weight: bold; color: #00D4FF; }\n    .tagline { color: #6b7280; font-size: 14px; margin-top: 5px; }\n    .hero-cta { background: linear-gradient(135deg, #00D4FF, #00A8CC); border-radius: 12px; padding: 30px; text-align: center; margin: 30px 0; }\n    .hero-cta h2 { color: white; margin: 0 0 15px 0; font-size: 22px; }\n    .hero-cta p { color: rgba(255,255,255,0.9); margin: 0 0 20px 0; }\n    .button-primary { display: inline-block; background: white; color: #00A8CC; padding: 14px 32px; border-radius: 8px; text-decoration: none; font-weight: bold; font-size: 16px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); }\n    .button-primary:hover { background: #f0f0f0; }\n    .license-box { background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 8px; padding: 20px; text-align: center; margin: 30px 0; }\n    .license-key { font-family: monospace; font-size: 22px; font-weight: bold; color: #1e293b; letter-spacing: 2px; }\n    .tier-badge { display: inline-block; background: #00D4FF; color: white; padding: 4px 12px; border-radius: 20px; font-size: 14px; margin-top: 10px; }\n    .quick-wins { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; padding: 20px; margin: 20px 0; }\n    .quick-wins h3 { color: #166534; margin-top: 0; }\n    .quick-wins ul { margin: 0; padding-left: 20px; }\n    .quick-wins li { margin: 8px 0; color: #15803d; }\n    .instructions { background: #f9fafb; padding: 20px; border-radius: 8px; margin: 20px 0; }\n    .instructions h3 { margin-top: 0; color: #374151; }\n    .instructions ol { margin: 0; padding-left: 20px; }\n    .instructions li { margin: 8px 0; }\n    .resources { display: table; width: 100%; margin: 20px 0; }\n    .resource-item { display: table-cell; text-align: center; padding: 15px; width: 33%; }\n    .resource-item a { display: block; color: #00A8CC; text-decoration: none; font-weight: 500; }\n    .resource-item span { display: block; font-size: 12px; color: #6b7280; margin-top: 5px; }\n    .footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 14px; }\n    .button { display: inline-block; background: #00D4FF; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; margin: 10px 0; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <div class=\"logo\">SPLICE</div>\n      <p class=\"tagline\">Cut Your Editing Time in Half. Automatically.</p>\n    </div>\n\n    <div class=\"hero-cta\">\n      <h2>🎉 You're In! Let's Get Started</h2>\n      <p>Download SPLICE and make your first AI-powered edit in under 2 minutes.</p>\n      <a href=\"https://splice.video/download\" class=\"button-primary\">Download SPLICE →</a>\n    </div>\n\n    <div class=\"license-box\">\n      <p style=\"margin: 0 0 10px; color: #6b7280; font-size: 12px; text-transform: uppercase; letter-spacing: 1px;\">Your License Key</p>\n      <div class=\"license-key\">${escapeHtml(data.licenseKey)}</div>\n      <div class=\"tier-badge\">${escapeHtml(data.tier.toUpperCase())} Plan</div>\n    </div>\n\n    <div class=\"quick-wins\">\n      <h3>⚡ Your First 5-Minute Win</h3>\n      <ul>\n        <li><strong>Open any project</strong> in Premiere Pro</li>\n        <li><strong>Click GO</strong> in the SPLICE panel</li>\n        <li><strong>Watch silences vanish</strong> automatically</li>\n      </ul>\n      <p style=\"margin-bottom: 0; font-size: 14px;\">Most editors save <strong>2+ hours per video</strong> on their first use!</p>\n    </div>\n\n    <div class=\"instructions\">\n      <h3>📋 Setup Instructions</h3>\n      <ol>\n        <li>Open Adobe Premiere Pro (2023 or later)</li>\n        <li>Go to <strong>Window → Extensions → SPLICE</strong></li>\n        <li>Click the Login button and enter your license key</li>\n        <li>You're ready! Open any sequence and hit <strong>GO</strong></li>\n      </ol>\n    </div>\n\n    <p>Your ${escapeHtml(data.tier)} plan includes:</p>\n    <ul>\n      <li><strong>${escapeHtml(String(data.hours))} hours</strong> of AI processing per month</li>\n      <li><strong>${escapeHtml(String(data.musicCredits))} music credits</strong> per month</li>\n      <li>14-day free trial - cancel anytime</li>\n    </ul>\n\n    <div class=\"resources\">\n      <div class=\"resource-item\">\n        <a href=\"https://splice.video/docs/tutorials\">📚 Tutorials</a>\n        <span>Step-by-step guides</span>\n      </div>\n      <div class=\"resource-item\">\n        <a href=\"https://splice.video/docs/faq\">❓ FAQ</a>\n        <span>Common questions</span>\n      </div>\n      <div class=\"resource-item\">\n        <a href=\"mailto:support@splice.video\">💬 Support</a>\n        <span>We're here to help</span>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      <p>Questions? Just reply to this email - we read every message!</p>\n      <p style=\"font-size: 12px;\">&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n    </div>\n  </div>\n</body>\n</html>\n    `,\n    text: (data) => `\nSPLICE - Welcome! Your License Key + Quick Start Guide\n=======================================================\n\n🎉 YOU'RE IN! LET'S GET STARTED\n\nDownload SPLICE: https://splice.video/download\n\nYOUR LICENSE KEY:\n${data.licenseKey}\nPlan: ${data.tier.toUpperCase()}\n\n⚡ YOUR FIRST 5-MINUTE WIN:\n1. Open any project in Premiere Pro\n2. Click GO in the SPLICE panel\n3. Watch silences vanish automatically\n\nMost editors save 2+ hours per video on their first use!\n\n📋 SETUP INSTRUCTIONS:\n1. Open Adobe Premiere Pro (2023 or later)\n2. Go to Window → Extensions → SPLICE\n3. Click the Login button and enter your license key\n4. You're ready! Open any sequence and hit GO\n\nYOUR ${data.tier.toUpperCase()} PLAN INCLUDES:\n- ${data.hours} hours of AI processing per month\n- ${data.musicCredits} music credits per month\n- 14-day free trial - cancel anytime\n\nHELPFUL RESOURCES:\n📚 Tutorials: https://splice.video/docs/tutorials\n❓ FAQ: https://splice.video/docs/faq\n💬 Support: support@splice.video\n\nQuestions? Just reply to this email - we read every message!\n\n© ${new Date().getFullYear()} SPLICE. All rights reserved.\n    `\n  },\n\n  paymentWarning: {\n    subject: 'Action Required: Payment Failed for SPLICE',\n    html: (data) => `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }\n    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; }\n    .header { text-align: center; margin-bottom: 30px; }\n    .logo { font-size: 32px; font-weight: bold; color: #7c3aed; }\n    .warning-box { background: #fef2f2; border: 2px solid #ef4444; border-radius: 8px; padding: 20px; margin: 20px 0; }\n    .warning-icon { font-size: 48px; text-align: center; }\n    .button { display: inline-block; background: #7c3aed; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; margin: 10px 0; }\n    .footer { text-align: center; margin-top: 40px; color: #6b7280; font-size: 14px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <div class=\"logo\">SPLICE</div>\n    </div>\n\n    <div class=\"warning-box\">\n      <div class=\"warning-icon\">⚠️</div>\n      <h2 style=\"text-align: center; color: #dc2626; margin: 10px 0;\">Payment Failed</h2>\n      <p>We were unable to process your payment for your SPLICE subscription. This was attempt ${escapeHtml(String(data.attemptCount))} of 3.</p>\n    </div>\n\n    <p>To keep your subscription active and avoid interruption to your service, please update your payment method:</p>\n\n    <p style=\"text-align: center;\">\n      <a href=\"https://splice.video/account/billing\" class=\"button\">Update Payment Method</a>\n    </p>\n\n    <p><strong>What happens next?</strong></p>\n    <ul>\n      <li>We'll automatically retry the payment in a few days</li>\n      <li>If all payment attempts fail, your subscription will be cancelled</li>\n      <li>You'll lose access to premium features</li>\n    </ul>\n\n    <p>If you have any questions or need assistance, please don't hesitate to reach out.</p>\n\n    <div class=\"footer\">\n      <p>Need help? Reply to this email or visit <a href=\"https://splice.video/support\">splice.video/support</a></p>\n      <p>&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n    </div>\n  </div>\n</body>\n</html>\n    `,\n    text: (data) => `\nSPLICE - Payment Failed\n\nWe were unable to process your payment for your SPLICE subscription.\nThis was attempt ${data.attemptCount} of 3.\n\nTo keep your subscription active, please update your payment method:\nhttps://splice.video/account/billing\n\nWHAT HAPPENS NEXT:\n- We'll automatically retry the payment in a few days\n- If all payment attempts fail, your subscription will be cancelled\n- You'll lose access to premium features\n\nIf you have any questions, please reply to this email.\n\n© ${new Date().getFullYear()} SPLICE. All rights reserved.\n    `\n  },\n\n  licenseLookup: {\n    subject: 'Your SPLICE License Key',\n    html: (data) => `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }\n    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; }\n    .header { text-align: center; margin-bottom: 30px; }\n    .logo { font-size: 32px; font-weight: bold; color: #7c3aed; }\n    .license-box { background: #f8f5ff; border: 2px solid #7c3aed; border-radius: 8px; padding: 20px; text-align: center; margin: 30px 0; }\n    .license-key { font-family: monospace; font-size: 24px; font-weight: bold; color: #7c3aed; letter-spacing: 2px; }\n    .footer { text-align: center; margin-top: 40px; color: #6b7280; font-size: 14px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <div class=\"logo\">SPLICE</div>\n    </div>\n\n    <h2>License Key Lookup</h2>\n    <p>You requested your SPLICE license key. Here it is:</p>\n\n    <div class=\"license-box\">\n      <div class=\"license-key\">${escapeHtml(data.licenseKey)}</div>\n    </div>\n\n    <p>If you didn't request this, you can safely ignore this email.</p>\n\n    <div class=\"footer\">\n      <p>Need help? Reply to this email or visit <a href=\"https://splice.video/support\">splice.video/support</a></p>\n      <p>&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n    </div>\n  </div>\n</body>\n</html>\n    `,\n    text: (data) => `\nSPLICE - License Key Lookup\n\nYou requested your SPLICE license key. Here it is:\n\n${data.licenseKey}\n\nIf you didn't request this, you can safely ignore this email.\n\nNeed help? Visit https://splice.video/support\n\n© ${new Date().getFullYear()} SPLICE. All rights reserved.\n    `\n  },\n\n  // Sign-in code email (passwordless auth)\n  signinCode: {\n    subject: 'Your SPLICE Sign-In Code: {{code}}',\n    html: (data) => `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <title>Your SPLICE Sign-In Code</title>\n  <!--[if mso]>\n  <noscript>\n    <xml>\n      <o:OfficeDocumentSettings>\n        <o:PixelsPerInch>96</o:PixelsPerInch>\n      </o:OfficeDocumentSettings>\n    </xml>\n  </noscript>\n  <![endif]-->\n  <style>\n    body, table, td, p, a, li { -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }\n    table, td { mso-table-lspace: 0pt; mso-table-rspace: 0pt; }\n    img { -ms-interpolation-mode: bicubic; border: 0; outline: none; text-decoration: none; }\n    body { margin: 0; padding: 0; width: 100%; background-color: #060b14; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }\n    @media only screen and (max-width: 600px) {\n      .container { width: 100% !important; padding: 16px !important; }\n      .code-box { font-size: 28px !important; letter-spacing: 6px !important; }\n    }\n  </style>\n</head>\n<body style=\"margin: 0; padding: 0; background-color: #060b14;\">\n  <div style=\"display: none; max-height: 0; overflow: hidden; font-size: 1px; line-height: 1px; color: #060b14;\">Your SPLICE sign-in code is inside. Start editing 10x faster today!</div>\n  <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"background-color: #060b14;\">\n    <tr>\n      <td align=\"center\" style=\"padding: 40px 20px;\">\n        <table role=\"presentation\" class=\"container\" cellpadding=\"0\" cellspacing=\"0\" width=\"560\" style=\"max-width: 560px;\">\n          <tr>\n            <td align=\"center\" style=\"padding-bottom: 32px;\">\n              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n                <tr>\n                  <td style=\"vertical-align: middle; padding-right: 10px;\">\n                    <img src=\"https://splice.video/images/logo.jpg\" alt=\"SPLICE\" width=\"40\" height=\"40\" style=\"display: block; border-radius: 8px;\">\n                  </td>\n                  <td style=\"vertical-align: middle;\">\n                    <span style=\"font-size: 26px; font-weight: 700; color: #ffffff; letter-spacing: -0.5px;\">SPLICE</span>\n                  </td>\n                </tr>\n              </table>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"background: linear-gradient(180deg, #0f1629 0%, #0a0f1a 100%); border-radius: 16px; border: 1px solid rgba(0, 212, 255, 0.15); box-shadow: 0 0 40px rgba(0, 212, 255, 0.08);\">\n                <tr>\n                  <td align=\"center\" style=\"padding: 40px 40px 24px 40px;\">\n                    <h1 style=\"margin: 0; font-size: 28px; font-weight: 600; color: #ffffff; line-height: 1.3;\">Welcome to the future of editing ✨</h1>\n                  </td>\n                </tr>\n                <tr>\n                  <td align=\"center\" style=\"padding: 0 40px 32px 40px;\">\n                    <p style=\"margin: 0; font-size: 16px; color: #94a3b8; line-height: 1.6;\">You're one step away from editing 10x faster. Use this code to sign in:</p>\n                  </td>\n                </tr>\n                <tr>\n                  <td align=\"center\" style=\"padding: 0 40px 32px 40px;\">\n                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" style=\"background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(0, 168, 204, 0.05) 100%); border-radius: 12px; border: 2px solid #00D4FF; box-shadow: 0 0 24px rgba(0, 212, 255, 0.25);\">\n                      <tr>\n                        <td align=\"center\" style=\"padding: 24px 48px;\">\n                          <span class=\"code-box\" style=\"font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 36px; font-weight: 700; color: #00D4FF; letter-spacing: 10px; text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);\">${escapeHtml(data.code)}</span>\n                        </td>\n                      </tr>\n                    </table>\n                  </td>\n                </tr>\n                <tr>\n                  <td align=\"center\" style=\"padding: 0 40px 40px 40px;\">\n                    <p style=\"margin: 0; font-size: 14px; color: #64748b;\">⏱️ This code expires in <strong style=\"color: #ffffff;\">10 minutes</strong></p>\n                  </td>\n                </tr>\n                <tr>\n                  <td style=\"padding: 0 40px;\">\n                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                      <tr><td style=\"border-top: 1px solid rgba(148, 163, 184, 0.1);\"></td></tr>\n                    </table>\n                  </td>\n                </tr>\n                <tr>\n                  <td style=\"padding: 40px;\">\n                    <h2 style=\"margin: 0 0 24px 0; font-size: 18px; font-weight: 600; color: #ffffff;\">🚀 What you'll unlock:</h2>\n                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                      <tr>\n                        <td width=\"50%\" style=\"padding: 8px 8px 8px 0; vertical-align: top;\">\n                          <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n                            <tr>\n                              <td style=\"padding-right: 12px; vertical-align: top;\"><span style=\"font-size: 20px;\">⚡</span></td>\n                              <td style=\"vertical-align: top;\">\n                                <p style=\"margin: 0; font-size: 14px; color: #e2e8f0; font-weight: 500;\">AI Silence Removal</p>\n                                <p style=\"margin: 4px 0 0 0; font-size: 13px; color: #64748b;\">Auto-trim dead air</p>\n                              </td>\n                            </tr>\n                          </table>\n                        </td>\n                        <td width=\"50%\" style=\"padding: 8px 0 8px 8px; vertical-align: top;\">\n                          <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n                            <tr>\n                              <td style=\"padding-right: 12px; vertical-align: top;\"><span style=\"font-size: 20px;\">🎬</span></td>\n                              <td style=\"vertical-align: top;\">\n                                <p style=\"margin: 0; font-size: 14px; color: #e2e8f0; font-weight: 500;\">Smart Take Detection</p>\n                                <p style=\"margin: 4px 0 0 0; font-size: 13px; color: #64748b;\">Find best takes fast</p>\n                              </td>\n                            </tr>\n                          </table>\n                        </td>\n                      </tr>\n                      <tr>\n                        <td width=\"50%\" style=\"padding: 8px 8px 8px 0; vertical-align: top;\">\n                          <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n                            <tr>\n                              <td style=\"padding-right: 12px; vertical-align: top;\"><span style=\"font-size: 20px;\">🎵</span></td>\n                              <td style=\"vertical-align: top;\">\n                                <p style=\"margin: 0; font-size: 14px; color: #e2e8f0; font-weight: 500;\">AI Music Generation</p>\n                                <p style=\"margin: 4px 0 0 0; font-size: 13px; color: #64748b;\">Royalty-free tracks</p>\n                              </td>\n                            </tr>\n                          </table>\n                        </td>\n                        <td width=\"50%\" style=\"padding: 8px 0 8px 8px; vertical-align: top;\">\n                          <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n                            <tr>\n                              <td style=\"padding-right: 12px; vertical-align: top;\"><span style=\"font-size: 20px;\">📱</span></td>\n                              <td style=\"vertical-align: top;\">\n                                <p style=\"margin: 0; font-size: 14px; color: #e2e8f0; font-weight: 500;\">Social Reframe</p>\n                                <p style=\"margin: 4px 0 0 0; font-size: 13px; color: #64748b;\">Export to any platform</p>\n                              </td>\n                            </tr>\n                          </table>\n                        </td>\n                      </tr>\n                    </table>\n                  </td>\n                </tr>\n                <tr>\n                  <td align=\"center\" style=\"padding: 0 40px 40px 40px;\">\n                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n                      <tr>\n                        <td align=\"center\" style=\"background: linear-gradient(135deg, #00D4FF 0%, #0099CC 100%); border-radius: 10px; box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);\">\n                          <a href=\"https://splice.video/download\" target=\"_blank\" style=\"display: inline-block; padding: 16px 40px; font-size: 16px; font-weight: 600; color: #060b14; text-decoration: none; letter-spacing: -0.3px;\">Download SPLICE Now →</a>\n                        </td>\n                      </tr>\n                    </table>\n                  </td>\n                </tr>\n              </table>\n            </td>\n          </tr>\n          <tr>\n            <td align=\"center\" style=\"padding: 40px 0 24px 0;\">\n              <p style=\"margin: 0; font-size: 14px; color: #64748b;\">Need help getting started?</p>\n            </td>\n          </tr>\n          <tr>\n            <td align=\"center\" style=\"padding-bottom: 40px;\">\n              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n                <tr>\n                  <td style=\"padding: 0 12px;\"><a href=\"https://splice.video/docs/quickstart\" style=\"font-size: 14px; color: #00D4FF; text-decoration: none;\">Quick Start Guide</a></td>\n                  <td style=\"color: #334155;\">|</td>\n                  <td style=\"padding: 0 12px;\"><a href=\"https://discord.gg/splice\" style=\"font-size: 14px; color: #00D4FF; text-decoration: none;\">Join Discord</a></td>\n                  <td style=\"color: #334155;\">|</td>\n                  <td style=\"padding: 0 12px;\"><a href=\"mailto:support@splice.video\" style=\"font-size: 14px; color: #00D4FF; text-decoration: none;\">Contact Support</a></td>\n                </tr>\n              </table>\n            </td>\n          </tr>\n          <tr>\n            <td align=\"center\" style=\"padding: 24px 0; border-top: 1px solid rgba(148, 163, 184, 0.1);\">\n              <p style=\"margin: 0 0 8px 0; font-size: 13px; color: #475569;\">You received this email because you signed up for SPLICE.</p>\n              <p style=\"margin: 0; font-size: 13px; color: #475569;\">© ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n            </td>\n          </tr>\n        </table>\n      </td>\n    </tr>\n  </table>\n</body>\n</html>\n    `,\n    text: (data) => `\nWelcome to SPLICE!\n\nYour sign-in code is: ${data.code}\n\nThis code expires in 10 minutes.\n\nWhat you'll unlock:\n- ⚡ AI Silence Removal - Auto-trim dead air\n- 🎬 Smart Take Detection - Find best takes fast\n- 🎵 AI Music Generation - Royalty-free tracks\n- 📱 Social Reframe - Export to any platform\n\nDownload SPLICE: https://splice.video/download\n\nNeed help?\n- Quick Start Guide: https://splice.video/docs/quickstart\n- Join Discord: https://discord.gg/splice\n- Contact Support: support@splice.video\n\n© ${new Date().getFullYear()} SPLICE. All rights reserved.\n    `\n  },\n\n  // Email verification template\n  emailVerification: {\n    subject: 'Verify Your SPLICE Email: {{code}}',\n    html: (data) => `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <title>Verify Your SPLICE Email</title>\n  <!--[if mso]>\n  <noscript>\n    <xml>\n      <o:OfficeDocumentSettings>\n        <o:PixelsPerInch>96</o:PixelsPerInch>\n      </o:OfficeDocumentSettings>\n    </xml>\n  </noscript>\n  <![endif]-->\n  <style>\n    body, table, td, p, a, li { -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }\n    table, td { mso-table-lspace: 0pt; mso-table-rspace: 0pt; }\n    img { -ms-interpolation-mode: bicubic; border: 0; outline: none; text-decoration: none; }\n    body { margin: 0; padding: 0; width: 100%; background-color: #060b14; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }\n    @media only screen and (max-width: 600px) {\n      .container { width: 100% !important; padding: 16px !important; }\n      .code-box { font-size: 28px !important; letter-spacing: 6px !important; }\n    }\n  </style>\n</head>\n<body style=\"margin: 0; padding: 0; background-color: #060b14;\">\n  <div style=\"display: none; max-height: 0; overflow: hidden; font-size: 1px; line-height: 1px; color: #060b14;\">Verify your email to complete your SPLICE account setup.</div>\n  <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"background-color: #060b14;\">\n    <tr>\n      <td align=\"center\" style=\"padding: 40px 20px;\">\n        <table role=\"presentation\" class=\"container\" cellpadding=\"0\" cellspacing=\"0\" width=\"560\" style=\"max-width: 560px;\">\n          <tr>\n            <td align=\"center\" style=\"padding-bottom: 32px;\">\n              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\">\n                <tr>\n                  <td style=\"vertical-align: middle; padding-right: 10px;\">\n                    <img src=\"https://splice.video/images/logo.jpg\" alt=\"SPLICE\" width=\"40\" height=\"40\" style=\"display: block; border-radius: 8px;\">\n                  </td>\n                  <td style=\"vertical-align: middle;\">\n                    <span style=\"font-size: 26px; font-weight: 700; color: #ffffff; letter-spacing: -0.5px;\">SPLICE</span>\n                  </td>\n                </tr>\n              </table>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"background: linear-gradient(180deg, #0f1629 0%, #0a0f1a 100%); border-radius: 16px; border: 1px solid rgba(0, 212, 255, 0.15); box-shadow: 0 0 40px rgba(0, 212, 255, 0.08);\">\n                <tr>\n                  <td align=\"center\" style=\"padding: 40px 40px 24px 40px;\">\n                    <h1 style=\"margin: 0; font-size: 28px; font-weight: 600; color: #ffffff; line-height: 1.3;\">Verify Your Email</h1>\n                  </td>\n                </tr>\n                <tr>\n                  <td align=\"center\" style=\"padding: 0 40px 32px 40px;\">\n                    <p style=\"margin: 0; font-size: 16px; color: #94a3b8; line-height: 1.6;\">Enter this verification code to confirm your email address:</p>\n                  </td>\n                </tr>\n                <tr>\n                  <td align=\"center\" style=\"padding: 0 40px 32px 40px;\">\n                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" style=\"background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(22, 163, 74, 0.05) 100%); border-radius: 12px; border: 2px solid #22c55e; box-shadow: 0 0 24px rgba(34, 197, 94, 0.25);\">\n                      <tr>\n                        <td align=\"center\" style=\"padding: 24px 48px;\">\n                          <span class=\"code-box\" style=\"font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 36px; font-weight: 700; color: #22c55e; letter-spacing: 10px; text-shadow: 0 0 20px rgba(34, 197, 94, 0.5);\">${escapeHtml(data.code)}</span>\n                        </td>\n                      </tr>\n                    </table>\n                  </td>\n                </tr>\n                <tr>\n                  <td align=\"center\" style=\"padding: 0 40px 40px 40px;\">\n                    <p style=\"margin: 0; font-size: 14px; color: #64748b;\">This code expires in <strong style=\"color: #ffffff;\">${escapeHtml(String(data.expiresInMinutes || 10))} minutes</strong></p>\n                  </td>\n                </tr>\n                <tr>\n                  <td style=\"padding: 0 40px;\">\n                    <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\n                      <tr><td style=\"border-top: 1px solid rgba(148, 163, 184, 0.1);\"></td></tr>\n                    </table>\n                  </td>\n                </tr>\n                <tr>\n                  <td align=\"center\" style=\"padding: 32px 40px;\">\n                    <p style=\"margin: 0; font-size: 14px; color: #64748b; line-height: 1.6;\">If you didn't request this verification, you can safely ignore this email.</p>\n                  </td>\n                </tr>\n              </table>\n            </td>\n          </tr>\n          <tr>\n            <td align=\"center\" style=\"padding: 24px 0; border-top: 1px solid rgba(148, 163, 184, 0.1);\">\n              <p style=\"margin: 0 0 8px 0; font-size: 13px; color: #475569;\">You received this email because someone used this address to sign up for SPLICE.</p>\n              <p style=\"margin: 0; font-size: 13px; color: #475569;\">&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n            </td>\n          </tr>\n        </table>\n      </td>\n    </tr>\n  </table>\n</body>\n</html>\n    `,\n    text: (data) => `\nVerify Your SPLICE Email\n\nYour verification code is: ${data.code}\n\nThis code expires in ${data.expiresInMinutes || 10} minutes.\n\nIf you didn't request this verification, you can safely ignore this email.\n\n© ${new Date().getFullYear()} SPLICE. All rights reserved.\n    `\n  }\n};\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Escape HTML to prevent XSS in email content\n */\nfunction escapeHtml(str) {\n  if (str === null || str === undefined) return '';\n  if (typeof str !== 'string') str = String(str);\n\n  const escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;'\n  };\n\n  return str.replace(/[&<>\"']/g, char => escapeMap[char]);\n}\n\n/**\n * Get tier details for email\n */\nfunction getTierDetails(tier) {\n  const tiers = {\n    starter: { hours: 4, musicCredits: 2 },\n    pro: { hours: 15, musicCredits: 10 },\n    team: { hours: 50, musicCredits: 50 }\n  };\n  return tiers[tier] || tiers.starter;\n}\n\n// ============================================================================\n// EMAIL PROVIDERS\n// ============================================================================\n\n/**\n * Send email via SendGrid\n */\nasync function sendViaSendGrid(to, subject, html, text) {\n  if (!EMAIL_CONFIG.sendgrid.apiKey) {\n    throw new Error('SENDGRID_API_KEY not configured');\n  }\n\n  const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${EMAIL_CONFIG.sendgrid.apiKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      personalizations: [{ to: [{ email: to }] }],\n      from: { email: EMAIL_CONFIG.from.match(/<(.+)>/)?.[1] || EMAIL_CONFIG.from, name: 'SPLICE' },\n      reply_to: { email: EMAIL_CONFIG.replyTo },\n      subject,\n      content: [\n        { type: 'text/plain', value: text },\n        { type: 'text/html', value: html }\n      ]\n    })\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`SendGrid error: ${response.status} - ${error}`);\n  }\n\n  return { provider: 'sendgrid', messageId: response.headers.get('x-message-id') };\n}\n\n/**\n * Send email via SendGrid Dynamic Template\n * @param {string} to - Recipient email\n * @param {string} templateId - SendGrid dynamic template ID\n * @param {Object} dynamicData - Template variables\n */\nasync function sendViaSendGridTemplate(to, templateId, dynamicData = {}) {\n  if (!EMAIL_CONFIG.sendgrid.apiKey) {\n    throw new Error('SENDGRID_API_KEY not configured');\n  }\n\n  const response = await fetch('https://api.sendgrid.com/v3/mail/send', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${EMAIL_CONFIG.sendgrid.apiKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      personalizations: [{\n        to: [{ email: to }],\n        dynamic_template_data: dynamicData\n      }],\n      from: { email: EMAIL_CONFIG.from.match(/<(.+)>/)?.[1] || EMAIL_CONFIG.from, name: 'SPLICE' },\n      reply_to: { email: EMAIL_CONFIG.replyTo },\n      template_id: templateId\n    })\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`SendGrid error: ${response.status} - ${error}`);\n  }\n\n  return { provider: 'sendgrid-template', messageId: response.headers.get('x-message-id'), templateId };\n}\n\n/**\n * Send email via AWS SES\n */\nasync function sendViaSES(to, subject, html, text) {\n  // Dynamically import AWS SDK to avoid loading if not needed\n  try {\n    const { SESClient, SendEmailCommand } = await import('@aws-sdk/client-ses');\n\n    const client = new SESClient({ region: EMAIL_CONFIG.ses.region });\n\n    const command = new SendEmailCommand({\n      Source: EMAIL_CONFIG.from,\n      Destination: { ToAddresses: [to] },\n      ReplyToAddresses: [EMAIL_CONFIG.replyTo],\n      Message: {\n        Subject: { Data: subject, Charset: 'UTF-8' },\n        Body: {\n          Html: { Data: html, Charset: 'UTF-8' },\n          Text: { Data: text, Charset: 'UTF-8' }\n        }\n      }\n    });\n\n    const result = await client.send(command);\n    return { provider: 'ses', messageId: result.MessageId };\n  } catch (err) {\n    if (err.code === 'ERR_MODULE_NOT_FOUND') {\n      throw new Error('AWS SDK not installed. Run: npm install @aws-sdk/client-ses');\n    }\n    throw err;\n  }\n}\n\n/**\n * Log email to console (development mode)\n */\nfunction sendViaConsole(to, subject, html, text) {\n  console.log('\\n========== EMAIL (CONSOLE MODE) ==========');\n  console.log(`To: ${to}`);\n  console.log(`Subject: ${subject}`);\n  console.log(`From: ${EMAIL_CONFIG.from}`);\n  console.log('--- TEXT VERSION ---');\n  console.log(text);\n  console.log('==========================================\\n');\n\n  return { provider: 'console', messageId: `console-${Date.now()}` };\n}\n\n// ============================================================================\n// PUBLIC API\n// ============================================================================\n\n/**\n * Send an email using the configured provider\n * @param {string} to - Recipient email\n * @param {string} subject - Email subject\n * @param {string} html - HTML content\n * @param {string} text - Plain text content\n * @returns {Promise<{provider: string, messageId: string}>}\n */\nasync function sendEmail(to, subject, html, text) {\n  const provider = EMAIL_CONFIG.provider.toLowerCase();\n\n  console.log(`[SPLICE Email] Sending to ${to} via ${provider}`);\n\n  try {\n    let result;\n\n    switch (provider) {\n      case 'sendgrid':\n        result = await sendViaSendGrid(to, subject, html, text);\n        break;\n      case 'ses':\n        result = await sendViaSES(to, subject, html, text);\n        break;\n      case 'console':\n      default:\n        result = sendViaConsole(to, subject, html, text);\n        break;\n    }\n\n    console.log(`[SPLICE Email] Sent successfully via ${result.provider}: ${result.messageId}`);\n    return result;\n  } catch (err) {\n    console.error(`[SPLICE Email] Failed to send via ${provider}:`, err.message);\n    throw err;\n  }\n}\n\n/**\n * Send license key email to customer\n * @param {string} email - Customer email\n * @param {string} licenseKey - The license key\n * @param {string} tier - Subscription tier (starter/pro/team)\n */\nasync function sendLicenseKeyEmail(email, licenseKey, tier) {\n  const tierDetails = getTierDetails(tier);\n  const template = TEMPLATES.licenseKey;\n\n  const data = {\n    licenseKey,\n    tier,\n    hours: tierDetails.hours,\n    musicCredits: tierDetails.musicCredits\n  };\n\n  return sendEmail(\n    email,\n    template.subject,\n    template.html(data),\n    template.text(data)\n  );\n}\n\n/**\n * Send payment warning email to customer\n * @param {string} email - Customer email\n * @param {number} attemptCount - Which payment attempt failed (1-3)\n */\nasync function sendPaymentWarningEmail(email, attemptCount) {\n  const template = TEMPLATES.paymentWarning;\n  const data = { attemptCount };\n\n  return sendEmail(\n    email,\n    template.subject,\n    template.html(data),\n    template.text(data)\n  );\n}\n\n/**\n * Send license key lookup email\n * @param {string} email - Customer email\n * @param {string} licenseKey - The license key\n */\nasync function sendLicenseLookupEmail(email, licenseKey) {\n  const template = TEMPLATES.licenseLookup;\n  const data = { licenseKey };\n\n  return sendEmail(\n    email,\n    template.subject,\n    template.html(data),\n    template.text(data)\n  );\n}\n\n/**\n * Send sign-in code email (passwordless authentication)\n * @param {string} email - User email\n * @param {string} code - The sign-in code (e.g., 6-digit code)\n * @param {number} expiresInMinutes - How long until the code expires (default: 10)\n */\nasync function sendSignInCodeEmail(email, code, expiresInMinutes = 10) {\n  const provider = EMAIL_CONFIG.provider.toLowerCase();\n\n  // Use SendGrid Dynamic Template when available\n  if (provider === 'sendgrid' && TEMPLATE_IDS.signinCode && EMAIL_CONFIG.sendgrid.apiKey) {\n    console.log(`[SPLICE Email] Sending sign-in code to ${email} via SendGrid Dynamic Template`);\n    return sendViaSendGridTemplate(email, TEMPLATE_IDS.signinCode, {\n      code: code,\n      expiresInMinutes: expiresInMinutes\n    });\n  }\n\n  // Fallback to inline template\n  const template = TEMPLATES.signinCode;\n  const data = { code, expiresInMinutes };\n  const subject = template.subject.replace('{{code}}', code);\n\n  return sendEmail(\n    email,\n    subject,\n    template.html(data),\n    template.text(data)\n  );\n}\n\n/**\n * Send email verification code\n * @param {string} email - User email\n * @param {string} code - The 6-digit verification code\n * @param {number} expiresInMinutes - How long until the code expires (default: 10)\n */\nasync function sendEmailVerificationCode(email, code, expiresInMinutes = 10) {\n  const provider = EMAIL_CONFIG.provider.toLowerCase();\n\n  // Use SendGrid Dynamic Template when available\n  if (provider === 'sendgrid' && TEMPLATE_IDS.emailVerification && EMAIL_CONFIG.sendgrid.apiKey) {\n    console.log(`[SPLICE Email] Sending verification code to ${email} via SendGrid Dynamic Template`);\n    return sendViaSendGridTemplate(email, TEMPLATE_IDS.emailVerification, {\n      code: code,\n      expiresInMinutes: expiresInMinutes\n    });\n  }\n\n  // Fallback to inline template\n  const template = TEMPLATES.emailVerification;\n  const data = { code, expiresInMinutes };\n  const subject = template.subject.replace('{{code}}', code);\n\n  return sendEmail(\n    email,\n    subject,\n    template.html(data),\n    template.text(data)\n  );\n}\n\n/**\n * Check if email service is configured for production use\n */\nfunction isEmailConfigured() {\n  const provider = EMAIL_CONFIG.provider.toLowerCase();\n\n  if (provider === 'sendgrid') {\n    return !!EMAIL_CONFIG.sendgrid.apiKey;\n  }\n\n  if (provider === 'ses') {\n    return !!(process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY);\n  }\n\n  // Console mode is always \"configured\" (for dev)\n  return true;\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nmodule.exports = {\n  sendEmail,\n  sendLicenseKeyEmail,\n  sendPaymentWarningEmail,\n  sendLicenseLookupEmail,\n  sendSignInCodeEmail,\n  sendEmailVerificationCode,\n  isEmailConfigured,\n  EMAIL_CONFIG\n};\n","numLines":998,"startLine":1,"totalLines":998}}}
{"parentUuid":"d0c342fa-869e-4c0c-b092-41742aefc122","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PMUyS6LDY5Rv8k7XA8Pzhv","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the todo list and finalize my comprehensive analysis:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13701,"cache_creation_input_tokens":20430,"cache_read_input_tokens":104540,"cache_creation":{"ephemeral_5m_input_tokens":20430,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWc4Q1aVMSjdTzCN2ABDb","type":"assistant","uuid":"541c4f7e-4545-489d-abb9-4996bbf8eeb0","timestamp":"2025-12-30T02:10:41.347Z"}
{"parentUuid":"541c4f7e-4545-489d-abb9-4996bbf8eeb0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PMUyS6LDY5Rv8k7XA8Pzhv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014trg9E6NK417eK6VrdxzTC","name":"TodoWrite","input":{"todos":[{"content":"Check backend API routes for middleware and error handling","status":"completed","activeForm":"Checking backend API routes for middleware and error handling"},{"content":"Verify frontend-backend API integration","status":"completed","activeForm":"Verifying frontend-backend API integration"},{"content":"Check service dependencies and imports","status":"completed","activeForm":"Checking service dependencies and imports"},{"content":"Validate database schema in usageTracking.js","status":"completed","activeForm":"Validating database schema in usageTracking.js"},{"content":"Verify plugin features integration chain","status":"completed","activeForm":"Verifying plugin features integration chain"},{"content":"Complete security checklist","status":"completed","activeForm":"Completing security checklist"},{"content":"Check production configuration","status":"completed","activeForm":"Checking production configuration"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13701,"cache_creation_input_tokens":20430,"cache_read_input_tokens":104540,"cache_creation":{"ephemeral_5m_input_tokens":20430,"ephemeral_1h_input_tokens":0},"output_tokens":290,"service_tier":"standard"}},"requestId":"req_011CWc4Q1aVMSjdTzCN2ABDb","type":"assistant","uuid":"69120ab9-42d4-4d87-9ca5-2b9afe890acb","timestamp":"2025-12-30T02:10:46.010Z"}
{"parentUuid":"69120ab9-42d4-4d87-9ca5-2b9afe890acb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014trg9E6NK417eK6VrdxzTC","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"68218134-a904-40e5-be5a-b6d515d8e414","timestamp":"2025-12-30T02:10:46.046Z","toolUseResult":{"oldTodos":[{"content":"Check backend API routes for middleware and error handling","status":"completed","activeForm":"Checking backend API routes for middleware and error handling"},{"content":"Verify frontend-backend API integration","status":"in_progress","activeForm":"Verifying frontend-backend API integration"},{"content":"Check service dependencies and imports","status":"pending","activeForm":"Checking service dependencies and imports"},{"content":"Validate database schema in usageTracking.js","status":"pending","activeForm":"Validating database schema in usageTracking.js"},{"content":"Verify plugin features integration chain","status":"pending","activeForm":"Verifying plugin features integration chain"},{"content":"Complete security checklist","status":"pending","activeForm":"Completing security checklist"},{"content":"Check production configuration","status":"pending","activeForm":"Checking production configuration"}],"newTodos":[{"content":"Check backend API routes for middleware and error handling","status":"completed","activeForm":"Checking backend API routes for middleware and error handling"},{"content":"Verify frontend-backend API integration","status":"completed","activeForm":"Verifying frontend-backend API integration"},{"content":"Check service dependencies and imports","status":"completed","activeForm":"Checking service dependencies and imports"},{"content":"Validate database schema in usageTracking.js","status":"completed","activeForm":"Validating database schema in usageTracking.js"},{"content":"Verify plugin features integration chain","status":"completed","activeForm":"Verifying plugin features integration chain"},{"content":"Complete security checklist","status":"completed","activeForm":"Completing security checklist"},{"content":"Check production configuration","status":"completed","activeForm":"Checking production configuration"}]}}
{"parentUuid":"68218134-a904-40e5-be5a-b6d515d8e414","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VtVEsko7BqsKf9Hrcqv7xM","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to read a few more files to complete the validation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":58779,"cache_read_input_tokens":19124,"cache_creation":{"ephemeral_5m_input_tokens":58779,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4Qh341QXSctWY39eeH","type":"assistant","uuid":"85e18aa0-b344-451a-b714-bc77108f24b5","timestamp":"2025-12-30T02:10:53.180Z"}
{"parentUuid":"85e18aa0-b344-451a-b714-bc77108f24b5","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VtVEsko7BqsKf9Hrcqv7xM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012W72QYh2zuVq1ZLBe1fMGT","name":"Read","input":{"file_path":"/Users/imorgado/.claude/projects/-Users-imorgado-SPLICE/4c7927f9-7798-44a0-91df-62c31e2c57cc/tool-results/toolu_01KVwWA1Cs4EXibQyJ4e9aXN.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":58779,"cache_read_input_tokens":19124,"cache_creation":{"ephemeral_5m_input_tokens":58779,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4Qh341QXSctWY39eeH","type":"assistant","uuid":"0c2a32c7-0c2d-4cf0-9d41-68074222a56d","timestamp":"2025-12-30T02:10:56.764Z"}
{"parentUuid":"0c2a32c7-0c2d-4cf0-9d41-68074222a56d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VtVEsko7BqsKf9Hrcqv7xM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011TW3gg2rUFBky7fvWJLoSA","name":"Read","input":{"file_path":"/Users/imorgado/.claude/projects/-Users-imorgado-SPLICE/4c7927f9-7798-44a0-91df-62c31e2c57cc/tool-results/toolu_01QHureArshNQjv1dsojwRFa.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":58779,"cache_read_input_tokens":19124,"cache_creation":{"ephemeral_5m_input_tokens":58779,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4Qh341QXSctWY39eeH","type":"assistant","uuid":"7b727389-d9fb-42fb-b25d-fa65b0de7183","timestamp":"2025-12-30T02:10:58.480Z"}
{"parentUuid":"7b727389-d9fb-42fb-b25d-fa65b0de7183","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VtVEsko7BqsKf9Hrcqv7xM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TFtSS5c23N7YELJBVX4sHR","name":"Read","input":{"file_path":"/Users/imorgado/.claude/projects/-Users-imorgado-SPLICE/4c7927f9-7798-44a0-91df-62c31e2c57cc/tool-results/toolu_01FPQijBPwrYqf6dyyw3t52d.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":58779,"cache_read_input_tokens":19124,"cache_creation":{"ephemeral_5m_input_tokens":58779,"ephemeral_1h_input_tokens":0},"output_tokens":360,"service_tier":"standard"}},"requestId":"req_011CWc4Qh341QXSctWY39eeH","type":"assistant","uuid":"e24eed95-904f-4258-9fe7-a3bf46f43af9","timestamp":"2025-12-30T02:11:00.379Z"}
{"parentUuid":"e24eed95-904f-4258-9fe7-a3bf46f43af9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011TW3gg2rUFBky7fvWJLoSA","type":"tool_result","content":"     1→     1→# =============================================================================\n     2→     2→# SPLICE Backend Environment Variables\n     3→     3→# =============================================================================\n     4→     4→# Copy this file to .env and fill in your values\n     5→     5→# NEVER commit .env to git\n     6→     6→\n     7→     7→# -----------------------------------------------------------------------------\n     8→     8→# AI Services\n     9→     9→# -----------------------------------------------------------------------------\n    10→    10→GROQ_API_KEY=your_groq_api_key_here\n    11→    11→OPENAI_API_KEY=your_openai_api_key_here\n    12→    12→REPLICATE_API_TOKEN=your_replicate_token_here\n    13→    13→\n    14→    14→# -----------------------------------------------------------------------------\n    15→    15→# Stripe (for billing/subscriptions)\n    16→    16→# Get these from https://dashboard.stripe.com/apikeys\n    17→    17→# -----------------------------------------------------------------------------\n    18→    18→STRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key_here\n    19→    19→STRIPE_SECRET_KEY=sk_test_your_secret_key_here\n    20→    20→STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here\n    21→    21→\n    22→    22→# Stripe Price IDs (create products in Stripe Dashboard first)\n    23→    23→# Monthly prices: Starter $15, Pro $39, Team $129\n    24→    24→STRIPE_PRICE_STARTER=price_your_starter_monthly_id\n    25→    25→STRIPE_PRICE_PRO=price_your_pro_monthly_id\n    26→    26→STRIPE_PRICE_TEAM=price_your_team_monthly_id\n    27→    27→\n    28→    28→# Annual prices (20% discount): Starter $144, Pro $374, Team $1238\n    29→    29→STRIPE_PRICE_STARTER_ANNUAL=price_your_starter_annual_id\n    30→    30→STRIPE_PRICE_PRO_ANNUAL=price_your_pro_annual_id\n    31→    31→STRIPE_PRICE_TEAM_ANNUAL=price_your_team_annual_id\n    32→    32→\n    33→    33→# Overage metered billing: $2/hour, $1/song\n    34→    34→STRIPE_PRICE_OVERAGE_HOURS=price_your_hours_overage_id\n    35→    35→STRIPE_PRICE_OVERAGE_MUSIC=price_your_music_overage_id\n    36→    36→\n    37→    37→# Stripe Meters (for usage-based billing)\n    38→    38→STRIPE_METER_HOURS=mtr_your_hours_meter_id\n    39→    39→STRIPE_METER_MUSIC=mtr_your_music_meter_id\n    40→    40→\n    41→    41→# -----------------------------------------------------------------------------\n    42→    42→# Database (Railway PostgreSQL)\n    43→    43→# Railway will auto-inject this when you add PostgreSQL\n    44→    44→# -----------------------------------------------------------------------------\n    45→    45→DATABASE_URL=postgresql://user:password@host:port/database\n    46→    46→\n    47→    47→# -----------------------------------------------------------------------------\n    48→    48→# Upstash Redis (for token blacklist, job queues, caching)\n    49→    49→# Get these from https://console.upstash.com/redis\n    50→    50→# -----------------------------------------------------------------------------\n    51→    51→# BullMQ uses the standard Redis URL (for job queues)\n    52→    52→UPSTASH_REDIS_URL=rediss://default:your_password@your_endpoint.upstash.io:6379\n    53→    53→\n    54→    54→# REST API credentials (for token blacklist - recommended for serverless)\n    55→    55→UPSTASH_REDIS_REST_URL=https://your_endpoint.upstash.io\n    56→    56→UPSTASH_REDIS_REST_TOKEN=your_rest_token_here\n    57→    57→\n    58→    58→# -----------------------------------------------------------------------------\n    59→    59→# Music Generation (Mureka API)\n    60→    60→# -----------------------------------------------------------------------------\n    61→    61→MUREKA_API_KEY=your_mureka_api_key_here\n    62→    62→\n    63→    63→# -----------------------------------------------------------------------------\n    64→    64→# Cloudflare R2 Storage (for music files)\n    65→    65→# -----------------------------------------------------------------------------\n    66→    66→R2_ACCOUNT_ID=your_r2_account_id_here\n    67→    67→R2_ACCESS_KEY_ID=your_r2_access_key_id_here\n    68→    68→R2_SECRET_ACCESS_KEY=your_r2_secret_access_key_here\n    69→    69→R2_BUCKET_NAME=splice-music\n    70→    70→\n    71→    71→# -----------------------------------------------------------------------------\n    72→    72→# Song Identification (ACRCloud) - Optional\n    73→    73→# -----------------------------------------------------------------------------\n    74→    74→ACRCLOUD_HOST=identify-us-west-2.acrcloud.com\n    75→    75→ACRCLOUD_ACCESS_KEY=your_acrcloud_access_key_here\n    76→    76→ACRCLOUD_ACCESS_SECRET=your_acrcloud_access_secret_here\n    77→    77→\n    78→    78→# -----------------------------------------------------------------------------\n    79→    79→# Server Config\n    80→    80→# -----------------------------------------------------------------------------\n    81→    81→PORT=3847\n    82→    82→NODE_ENV=production\n    83→    83→\n    84→    84→# -----------------------------------------------------------------------------\n    85→    85→# JWT Authentication\n    86→    86→# CRITICAL: Must be set to a secure random value in production!\n    87→    87→# Generate with: openssl rand -hex 32\n    88→    88→# -----------------------------------------------------------------------------\n    89→    89→JWT_SECRET=your_secure_jwt_secret_here_CHANGE_IN_PRODUCTION\n    90→    90→JWT_EXPIRES_IN=24h\n    91→    91→JWT_REFRESH_EXPIRES_IN=7d\n    92→    92→\n    93→    93→# -----------------------------------------------------------------------------\n    94→    94→# Email Service (SendGrid or AWS SES)\n    95→    95→# -----------------------------------------------------------------------------\n    96→    96→# Provider: 'sendgrid' | 'ses' | 'console' (console = log only, for dev)\n    97→    97→EMAIL_PROVIDER=console\n    98→    98→\n    99→    99→# SendGrid Configuration (if EMAIL_PROVIDER=sendgrid)\n   100→   100→SENDGRID_API_KEY=SG_your_sendgrid_api_key_here\n   101→   101→\n   102→   102→# AWS SES Configuration (if EMAIL_PROVIDER=ses)\n   103→   103→# AWS_SES_REGION=us-east-1\n   104→   104→# AWS_ACCESS_KEY_ID=your_aws_access_key\n   105→   105→# AWS_SECRET_ACCESS_KEY=your_aws_secret_key\n   106→   106→\n   107→   107→# Email addresses\n   108→   108→EMAIL_FROM=SPLICE <noreply@splice.video>\n   109→   109→EMAIL_REPLY_TO=support@splice.video\n   110→   110→\n   111→\n   112→</system-reminder>\n   113→\n\n</system-reminder>\n"}]},"uuid":"0d9ea371-d121-4ed4-be30-c448be2d571d","timestamp":"2025-12-30T02:11:00.425Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/.claude/projects/-Users-imorgado-SPLICE/4c7927f9-7798-44a0-91df-62c31e2c57cc/tool-results/toolu_01QHureArshNQjv1dsojwRFa.txt","content":"     1→# =============================================================================\n     2→# SPLICE Backend Environment Variables\n     3→# =============================================================================\n     4→# Copy this file to .env and fill in your values\n     5→# NEVER commit .env to git\n     6→\n     7→# -----------------------------------------------------------------------------\n     8→# AI Services\n     9→# -----------------------------------------------------------------------------\n    10→GROQ_API_KEY=your_groq_api_key_here\n    11→OPENAI_API_KEY=your_openai_api_key_here\n    12→REPLICATE_API_TOKEN=your_replicate_token_here\n    13→\n    14→# -----------------------------------------------------------------------------\n    15→# Stripe (for billing/subscriptions)\n    16→# Get these from https://dashboard.stripe.com/apikeys\n    17→# -----------------------------------------------------------------------------\n    18→STRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key_here\n    19→STRIPE_SECRET_KEY=sk_test_your_secret_key_here\n    20→STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here\n    21→\n    22→# Stripe Price IDs (create products in Stripe Dashboard first)\n    23→# Monthly prices: Starter $15, Pro $39, Team $129\n    24→STRIPE_PRICE_STARTER=price_your_starter_monthly_id\n    25→STRIPE_PRICE_PRO=price_your_pro_monthly_id\n    26→STRIPE_PRICE_TEAM=price_your_team_monthly_id\n    27→\n    28→# Annual prices (20% discount): Starter $144, Pro $374, Team $1238\n    29→STRIPE_PRICE_STARTER_ANNUAL=price_your_starter_annual_id\n    30→STRIPE_PRICE_PRO_ANNUAL=price_your_pro_annual_id\n    31→STRIPE_PRICE_TEAM_ANNUAL=price_your_team_annual_id\n    32→\n    33→# Overage metered billing: $2/hour, $1/song\n    34→STRIPE_PRICE_OVERAGE_HOURS=price_your_hours_overage_id\n    35→STRIPE_PRICE_OVERAGE_MUSIC=price_your_music_overage_id\n    36→\n    37→# Stripe Meters (for usage-based billing)\n    38→STRIPE_METER_HOURS=mtr_your_hours_meter_id\n    39→STRIPE_METER_MUSIC=mtr_your_music_meter_id\n    40→\n    41→# -----------------------------------------------------------------------------\n    42→# Database (Railway PostgreSQL)\n    43→# Railway will auto-inject this when you add PostgreSQL\n    44→# -----------------------------------------------------------------------------\n    45→DATABASE_URL=postgresql://user:password@host:port/database\n    46→\n    47→# -----------------------------------------------------------------------------\n    48→# Upstash Redis (for token blacklist, job queues, caching)\n    49→# Get these from https://console.upstash.com/redis\n    50→# -----------------------------------------------------------------------------\n    51→# BullMQ uses the standard Redis URL (for job queues)\n    52→UPSTASH_REDIS_URL=rediss://default:your_password@your_endpoint.upstash.io:6379\n    53→\n    54→# REST API credentials (for token blacklist - recommended for serverless)\n    55→UPSTASH_REDIS_REST_URL=https://your_endpoint.upstash.io\n    56→UPSTASH_REDIS_REST_TOKEN=your_rest_token_here\n    57→\n    58→# -----------------------------------------------------------------------------\n    59→# Music Generation (Mureka API)\n    60→# -----------------------------------------------------------------------------\n    61→MUREKA_API_KEY=your_mureka_api_key_here\n    62→\n    63→# -----------------------------------------------------------------------------\n    64→# Cloudflare R2 Storage (for music files)\n    65→# -----------------------------------------------------------------------------\n    66→R2_ACCOUNT_ID=your_r2_account_id_here\n    67→R2_ACCESS_KEY_ID=your_r2_access_key_id_here\n    68→R2_SECRET_ACCESS_KEY=your_r2_secret_access_key_here\n    69→R2_BUCKET_NAME=splice-music\n    70→\n    71→# -----------------------------------------------------------------------------\n    72→# Song Identification (ACRCloud) - Optional\n    73→# -----------------------------------------------------------------------------\n    74→ACRCLOUD_HOST=identify-us-west-2.acrcloud.com\n    75→ACRCLOUD_ACCESS_KEY=your_acrcloud_access_key_here\n    76→ACRCLOUD_ACCESS_SECRET=your_acrcloud_access_secret_here\n    77→\n    78→# -----------------------------------------------------------------------------\n    79→# Server Config\n    80→# -----------------------------------------------------------------------------\n    81→PORT=3847\n    82→NODE_ENV=production\n    83→\n    84→# -----------------------------------------------------------------------------\n    85→# JWT Authentication\n    86→# CRITICAL: Must be set to a secure random value in production!\n    87→# Generate with: openssl rand -hex 32\n    88→# -----------------------------------------------------------------------------\n    89→JWT_SECRET=your_secure_jwt_secret_here_CHANGE_IN_PRODUCTION\n    90→JWT_EXPIRES_IN=24h\n    91→JWT_REFRESH_EXPIRES_IN=7d\n    92→\n    93→# -----------------------------------------------------------------------------\n    94→# Email Service (SendGrid or AWS SES)\n    95→# -----------------------------------------------------------------------------\n    96→# Provider: 'sendgrid' | 'ses' | 'console' (console = log only, for dev)\n    97→EMAIL_PROVIDER=console\n    98→\n    99→# SendGrid Configuration (if EMAIL_PROVIDER=sendgrid)\n   100→SENDGRID_API_KEY=SG_your_sendgrid_api_key_here\n   101→\n   102→# AWS SES Configuration (if EMAIL_PROVIDER=ses)\n   103→# AWS_SES_REGION=us-east-1\n   104→# AWS_ACCESS_KEY_ID=your_aws_access_key\n   105→# AWS_SECRET_ACCESS_KEY=your_aws_secret_key\n   106→\n   107→# Email addresses\n   108→EMAIL_FROM=SPLICE <noreply@splice.video>\n   109→EMAIL_REPLY_TO=support@splice.video\n   110→\n\n</system-reminder>\n","numLines":113,"startLine":1,"totalLines":113}}}
{"parentUuid":"0d9ea371-d121-4ed4-be30-c448be2d571d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TFtSS5c23N7YELJBVX4sHR","type":"tool_result","content":"     1→     1→/**\n     2→     2→ * Auth Routes\n     3→     3→ *\n     4→     4→ * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n     5→     5→ */\n     6→     6→\n     7→     7→const express = require('express');\n     8→     8→const crypto = require('crypto');\n     9→     9→const { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\n    10→    10→const authLogger = require('../utils/authLogger');\n    11→    11→\n    12→    12→// ============================================================================\n    13→    13→// Email Verification Code Storage\n    14→    14→// In-memory store for verification codes. Maps email -> { code, expires, attempts }\n    15→    15→// Can be upgraded to Redis for distributed deployments.\n    16→    16→// ============================================================================\n    17→    17→\n    18→    18→const verificationCodes = new Map();\n    19→    19→\n    20→    20→// Verification code expiry time (10 minutes)\n    21→    21→const VERIFICATION_CODE_EXPIRY_MS = 10 * 60 * 1000;\n    22→    22→\n    23→    23→// Maximum verification attempts before code is invalidated\n    24→    24→const MAX_VERIFICATION_ATTEMPTS = 5;\n    25→    25→\n    26→    26→// Rate limiting: minimum time between sending codes to same email (60 seconds)\n    27→    27→const SEND_CODE_COOLDOWN_MS = 60 * 1000;\n    28→    28→\n    29→    29→// Track last send time per email for rate limiting\n    30→    30→const lastSendTime = new Map();\n    31→    31→\n    32→    32→// Cleanup interval for expired codes (every 5 minutes)\n    33→    33→const CLEANUP_INTERVAL_MS = 5 * 60 * 1000;\n    34→    34→\n    35→    35→/**\n    36→    36→ * Generate a 6-digit verification code\n    37→    37→ * @returns {string} 6-digit code\n    38→    38→ */\n    39→    39→function generateVerificationCode() {\n    40→    40→  // Generate cryptographically secure random 6-digit code\n    41→    41→  const code = crypto.randomInt(100000, 999999).toString();\n    42→    42→  return code;\n    43→    43→}\n    44→    44→\n    45→    45→/**\n    46→    46→ * Store a verification code for an email\n    47→    47→ * @param {string} email - Email address\n    48→    48→ * @param {string} code - Verification code\n    49→    49→ */\n    50→    50→function storeVerificationCode(email, code) {\n    51→    51→  const normalizedEmail = email.toLowerCase().trim();\n    52→    52→  verificationCodes.set(normalizedEmail, {\n    53→    53→    code,\n    54→    54→    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS,\n    55→    55→    attempts: 0,\n    56→    56→    createdAt: Date.now()\n    57→    57→  });\n    58→    58→  lastSendTime.set(normalizedEmail, Date.now());\n    59→    59→}\n    60→    60→\n    61→    61→/**\n    62→    62→ * Verify a code for an email\n    63→    63→ * @param {string} email - Email address\n    64→    64→ * @param {string} code - Code to verify\n    65→    65→ * @returns {{ valid: boolean, error?: string }}\n    66→    66→ */\n    67→    67→function verifyCode(email, code) {\n    68→    68→  const normalizedEmail = email.toLowerCase().trim();\n    69→    69→  const stored = verificationCodes.get(normalizedEmail);\n    70→    70→\n    71→    71→  if (!stored) {\n    72→    72→    return { valid: false, error: 'No verification code found. Please request a new one.' };\n    73→    73→  }\n    74→    74→\n    75→    75→  // Check if expired\n    76→    76→  if (Date.now() > stored.expires) {\n    77→    77→    verificationCodes.delete(normalizedEmail);\n    78→    78→    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n    79→    79→  }\n    80→    80→\n    81→    81→  // Increment attempt counter\n    82→    82→  stored.attempts++;\n    83→    83→\n    84→    84→  // Check if too many attempts\n    85→    85→  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n    86→    86→    verificationCodes.delete(normalizedEmail);\n    87→    87→    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n    88→    88→  }\n    89→    89→\n    90→    90→  // Check if code matches\n    91→    91→  if (stored.code !== code) {\n    92→    92→    verificationCodes.set(normalizedEmail, stored);\n    93→    93→    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n    94→    94→  }\n    95→    95→\n    96→    96→  // Code is valid - remove it (single use)\n    97→    97→  verificationCodes.delete(normalizedEmail);\n    98→    98→  return { valid: true };\n    99→    99→}\n   100→   100→\n   101→   101→/**\n   102→   102→ * Check if we can send a new code to an email (rate limiting)\n   103→   103→ * @param {string} email - Email address\n   104→   104→ * @returns {{ allowed: boolean, waitSeconds?: number }}\n   105→   105→ */\n   106→   106→function canSendCode(email) {\n   107→   107→  const normalizedEmail = email.toLowerCase().trim();\n   108→   108→  const lastSent = lastSendTime.get(normalizedEmail);\n   109→   109→\n   110→   110→  if (!lastSent) {\n   111→   111→    return { allowed: true };\n   112→   112→  }\n   113→   113→\n   114→   114→  const elapsed = Date.now() - lastSent;\n   115→   115→  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n   116→   116→    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n   117→   117→    return { allowed: false, waitSeconds };\n   118→   118→  }\n   119→   119→\n   120→   120→  return { allowed: true };\n   121→   121→}\n   122→   122→\n   123→   123→/**\n   124→   124→ * Clean up expired verification codes\n   125→   125→ */\n   126→   126→function cleanupVerificationCodes() {\n   127→   127→  const now = Date.now();\n   128→   128→  let cleanedCount = 0;\n   129→   129→\n   130→   130→  for (const [email, data] of verificationCodes.entries()) {\n   131→   131→    if (data.expires <= now) {\n   132→   132→      verificationCodes.delete(email);\n   133→   133→      cleanedCount++;\n   134→   134→    }\n   135→   135→  }\n   136→   136→\n   137→   137→  // Also clean up old lastSendTime entries (older than 1 hour)\n   138→   138→  const oneHourAgo = now - (60 * 60 * 1000);\n   139→   139→  for (const [email, time] of lastSendTime.entries()) {\n   140→   140→    if (time < oneHourAgo) {\n   141→   141→      lastSendTime.delete(email);\n   142→   142→    }\n   143→   143→  }\n   144→   144→\n   145→   145→  if (cleanedCount > 0) {\n   146→   146→    console.log(`[Auth] Verification code cleanup: removed ${cleanedCount} expired codes`);\n   147→   147→  }\n   148→   148→}\n   149→   149→\n   150→   150→// Start periodic cleanup (unref to allow process exit)\n   151→   151→const cleanupTimer = setInterval(cleanupVerificationCodes, CLEANUP_INTERVAL_MS);\n   152→   152→if (cleanupTimer.unref) {\n   153→   153→  cleanupTimer.unref();\n   154→   154→}\n   155→   155→\n   156→   156→/**\n   157→   157→ * Validate email format\n   158→   158→ * @param {string} email - Email to validate\n   159→   159→ * @returns {boolean}\n   160→   160→ */\n   161→   161→function isValidEmail(email) {\n   162→   162→  if (!email || typeof email !== 'string') return false;\n   163→   163→  // Basic email validation regex\n   164→   164→  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n   165→   165→  return emailRegex.test(email.trim());\n   166→   166→}\n   167→   167→\n   168→   168→/**\n   169→   169→ * Create auth routes\n   170→   170→ * @param {Object} options - Route configuration options\n   171→   171→ * @param {Object} options.middleware - Shared middleware (authenticateToken)\n   172→   172→ * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n   173→   173→ * @param {Object} options.authHelpers - Auth helper functions\n   174→   174→ * @returns {express.Router}\n   175→   175→ */\n   176→   176→function createAuthRoutes(options = {}) {\n   177→   177→  const router = express.Router();\n   178→   178→  const { authenticateToken } = options.middleware || {};\n   179→   179→  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n   180→   180→  const { usageTracking, licenseService, emailService } = options.services || {};\n   181→   181→\n   182→   182→  /**\n   183→   183→   * GET /csrf-token - Generate and return a CSRF token\n   184→   184→   *\n   185→   185→   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   186→   186→   * The token is returned in both the response body and an HttpOnly cookie.\n   187→   187→   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   188→   188→   */\n   189→   189→  router.get('/csrf-token', csrfTokenHandler);\n   190→   190→\n   191→   191→  /**\n   192→   192→   * POST /login - Authenticate with license key and get JWT token\n   193→   193→   *\n   194→   194→   * SECURITY: This is the primary authentication endpoint.\n   195→   195→   * Validates license key and returns a JWT token for API access.\n   196→   196→   * CSRF protection applied to prevent cross-site login attacks.\n   197→   197→   */\n   198→   198→  router.post('/login', validateCsrfToken, async (req, res) => {\n   199→   199→    const { licenseKey } = req.body;\n   200→   200→\n   201→   201→    if (!licenseKey) {\n   202→   202→      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n   203→   203→      return res.status(400).json({\n   204→   204→        error: 'License key required',\n   205→   205→        message: 'Please provide your license key to log in'\n   206→   206→      });\n   207→   207→    }\n   208→   208→\n   209→   209→    try {\n   210→   210→      // Validate and activate the license key\n   211→   211→      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n   212→   212→\n   213→   213→      if (!licenseResult.success) {\n   214→   214→        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n   215→   215→        return res.status(401).json({\n   216→   216→          error: 'Invalid license key',\n   217→   217→          message: licenseResult.error || 'The license key is invalid or expired'\n   218→   218→        });\n   219→   219→      }\n   220→   220→\n   221→   221→      // Get user's tier and balance\n   222→   222→      const balance = await usageTracking.getBalance(licenseResult.customerId);\n   223→   223→\n   224→   224→      // Generate JWT tokens\n   225→   225→      const tokenResult = generateToken(licenseResult.customerId, {\n   226→   226→        tier: balance.tier,\n   227→   227→        email: licenseResult.email\n   228→   228→      });\n   229→   229→      const refreshResult = generateRefreshToken(licenseResult.customerId);\n   230→   230→\n   231→   231→      // Log successful login with structured logging\n   232→   232→      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n   233→   233→        email: licenseResult.email,\n   234→   234→        tier: balance.tier\n   235→   235→      });\n   236→   236→\n   237→   237→      res.json({\n   238→   238→        success: true,\n   239→   239→        token: tokenResult.token,\n   240→   240→        tokenType: tokenResult.tokenType,\n   241→   241→        expiresIn: tokenResult.expiresIn,\n   242→   242→        refreshToken: refreshResult.refreshToken,\n   243→   243→        customerId: licenseResult.customerId,\n   244→   244→        tier: balance.tier,\n   245→   245→        hoursRemaining: balance.hoursRemaining\n   246→   246→      });\n   247→   247→    } catch (err) {\n   248→   248→      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n   249→   249→      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n   250→   250→    }\n   251→   251→  });\n   252→   252→\n   253→   253→  /**\n   254→   254→   * POST /refresh - Refresh an expired JWT token\n   255→   255→   *\n   256→   256→   * Uses a refresh token to get a new access token.\n   257→   257→   * CSRF protection applied to prevent token theft via cross-site requests.\n   258→   258→   */\n   259→   259→  router.post('/refresh', validateCsrfToken, async (req, res) => {\n   260→   260→    const { refreshToken } = req.body;\n   261→   261→\n   262→   262→    if (!refreshToken) {\n   263→   263→      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n   264→   264→      return res.status(400).json({\n   265→   265→        error: 'Refresh token required'\n   266→   266→      });\n   267→   267→    }\n   268→   268→\n   269→   269→    try {\n   270→   270→      const decoded = await verifyToken(refreshToken, { req });\n   271→   271→\n   272→   272→      if (!decoded || decoded.type !== 'refresh') {\n   273→   273→        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n   274→   274→        return res.status(401).json({\n   275→   275→          error: 'Invalid refresh token',\n   276→   276→          message: 'Please log in again'\n   277→   277→        });\n   278→   278→      }\n   279→   279→\n   280→   280→      // Get current user info\n   281→   281→      const balance = await usageTracking.getBalance(decoded.sub);\n   282→   282→\n   283→   283→      // Generate new access token\n   284→   284→      const tokenResult = generateToken(decoded.sub, {\n   285→   285→        tier: balance.tier\n   286→   286→      });\n   287→   287→\n   288→   288→      // Log successful token refresh\n   289→   289→      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n   290→   290→\n   291→   291→      res.json({\n   292→   292→        success: true,\n   293→   293→        token: tokenResult.token,\n   294→   294→        tokenType: tokenResult.tokenType,\n   295→   295→        expiresIn: tokenResult.expiresIn\n   296→   296→      });\n   297→   297→    } catch (err) {\n   298→   298→      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n   299→   299→      res.status(401).json({\n   300→   300→        error: 'Failed to refresh token',\n   301→   301→        message: 'Please log in again'\n   302→   302→      });\n   303→   303→    }\n   304→   304→  });\n   305→   305→\n   306→   306→  /**\n   307→   307→   * POST /logout - Invalidate tokens by adding to blacklist\n   308→   308→   *\n   309→   309→   * Adds the current token's jti to the blacklist so it cannot be reused.\n   310→   310→   * Also accepts an optional refreshToken to revoke both tokens at once.\n   311→   311→   * CSRF protection applied to prevent forced logout attacks.\n   312→   312→   */\n   313→   313→  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n   314→   314→    const { refreshToken } = req.body;\n   315→   315→    let refreshTokenRevoked = false;\n   316→   316→\n   317→   317→    // Blacklist the access token using the blacklistToken function from authHelpers\n   318→   318→    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n   319→   319→      if (blacklistToken) {\n   320→   320→        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n   321→   321→          userId: req.stripeCustomerId,\n   322→   322→          reason: 'logout'\n   323→   323→        });\n   324→   324→      } else {\n   325→   325→        console.warn('[Auth] Logout: blacklistToken function not available');\n   326→   326→      }\n   327→   327→    } else {\n   328→   328→      // Token doesn't have jti - log warning but continue\n   329→   329→      // This handles tokens generated before jti was added\n   330→   330→      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n   331→   331→    }\n   332→   332→\n   333→   333→    // Optionally blacklist the refresh token too\n   334→   334→    if (refreshToken && blacklistToken) {\n   335→   335→      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n   336→   336→      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n   337→   337→      if (decoded && decoded.jti && decoded.exp) {\n   338→   338→        await blacklistToken(decoded.jti, decoded.exp, {\n   339→   339→          userId: req.stripeCustomerId,\n   340→   340→          reason: 'logout_refresh'\n   341→   341→        });\n   342→   342→        refreshTokenRevoked = true;\n   343→   343→      }\n   344→   344→    }\n   345→   345→\n   346→   346→    // Log successful logout with structured logging\n   347→   347→    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n   348→   348→      jti: req.tokenData?.jti,\n   349→   349→      refreshTokenRevoked\n   350→   350→    });\n   351→   351→\n   352→   352→    res.json({\n   353→   353→      success: true,\n   354→   354→      message: 'Logged out successfully'\n   355→   355→    });\n   356→   356→  });\n   357→   357→\n   358→   358→  // ==========================================================================\n   359→   359→  // Email Verification Endpoints\n   360→   360→  // ==========================================================================\n   361→   361→\n   362→   362→  /**\n   363→   363→   * POST /send-verification - Send a verification code to an email address\n   364→   364→   *\n   365→   365→   * Request body: { email: string }\n   366→   366→   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   367→   367→   *\n   368→   368→   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   369→   369→   */\n   370→   370→  router.post('/send-verification', validateCsrfToken, async (req, res) => {\n   371→   371→    const { email } = req.body;\n   372→   372→\n   373→   373→    // Validate email\n   374→   374→    if (!email) {\n   375→   375→      return res.status(400).json({\n   376→   376→        error: 'Email required',\n   377→   377→        message: 'Please provide an email address'\n   378→   378→      });\n   379→   379→    }\n   380→   380→\n   381→   381→    if (!isValidEmail(email)) {\n   382→   382→      return res.status(400).json({\n   383→   383→        error: 'Invalid email',\n   384→   384→        message: 'Please provide a valid email address'\n   385→   385→      });\n   386→   386→    }\n   387→   387→\n   388→   388→    // Check rate limiting\n   389→   389→    const rateCheck = canSendCode(email);\n   390→   390→    if (!rateCheck.allowed) {\n   391→   391→      return res.status(429).json({\n   392→   392→        error: 'Too many requests',\n   393→   393→        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n   394→   394→        waitSeconds: rateCheck.waitSeconds\n   395→   395→      });\n   396→   396→    }\n   397→   397→\n   398→   398→    try {\n   399→   399→      // Generate and store verification code\n   400→   400→      const code = generateVerificationCode();\n   401→   401→      storeVerificationCode(email, code);\n   402→   402→\n   403→   403→      // Send verification email\n   404→   404→      if (emailService && emailService.sendEmailVerificationCode) {\n   405→   405→        await emailService.sendEmailVerificationCode(email, code, 10);\n   406→   406→        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n   407→   407→      } else {\n   408→   408→        // Fallback for development - log to console\n   409→   409→        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n   410→   410→      }\n   411→   411→\n   412→   412→      res.json({\n   413→   413→        success: true,\n   414→   414→        message: 'Verification code sent. Please check your email.',\n   415→   415→        expiresInMinutes: 10\n   416→   416→      });\n   417→   417→    } catch (err) {\n   418→   418→      console.error('[Auth] Send verification error:', err.message);\n   419→   419→      res.status(500).json({\n   420→   420→        error: 'Failed to send verification code',\n   421→   421→        message: 'Please try again later'\n   422→   422→      });\n   423→   423→    }\n   424→   424→  });\n   425→   425→\n   426→   426→  /**\n   427→   427→   * POST /verify-email - Verify an email address with a code\n   428→   428→   *\n   429→   429→   * Request body: { email: string, code: string }\n   430→   430→   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   431→   431→   *\n   432→   432→   * SECURITY: Limited attempts per code. CSRF protection applied.\n   433→   433→   */\n   434→   434→  router.post('/verify-email', validateCsrfToken, async (req, res) => {\n   435→   435→    const { email, code } = req.body;\n   436→   436→\n   437→   437→    // Validate inputs\n   438→   438→    if (!email) {\n   439→   439→      return res.status(400).json({\n   440→   440→        error: 'Email required',\n   441→   441→        message: 'Please provide an email address'\n   442→   442→      });\n   443→   443→    }\n   444→   444→\n   445→   445→    if (!code) {\n   446→   446→      return res.status(400).json({\n   447→   447→        error: 'Code required',\n   448→   448→        message: 'Please provide the verification code'\n   449→   449→      });\n   450→   450→    }\n   451→   451→\n   452→   452→    if (!isValidEmail(email)) {\n   453→   453→      return res.status(400).json({\n   454→   454→        error: 'Invalid email',\n   455→   455→        message: 'Please provide a valid email address'\n   456→   456→      });\n   457→   457→    }\n   458→   458→\n   459→   459→    // Validate code format (6 digits)\n   460→   460→    const codeStr = String(code).trim();\n   461→   461→    if (!/^\\d{6}$/.test(codeStr)) {\n   462→   462→      return res.status(400).json({\n   463→   463→        error: 'Invalid code format',\n   464→   464→        message: 'Verification code must be 6 digits'\n   465→   465→      });\n   466→   466→    }\n   467→   467→\n   468→   468→    try {\n   469→   469→      // Verify the code\n   470→   470→      const result = verifyCode(email, codeStr);\n   471→   471→\n   472→   472→      if (!result.valid) {\n   473→   473→        return res.status(400).json({\n   474→   474→          success: false,\n   475→   475→          verified: false,\n   476→   476→          error: 'Verification failed',\n   477→   477→          message: result.error\n   478→   478→        });\n   479→   479→      }\n   480→   480→\n   481→   481→      // Mark email as verified in the database\n   482→   482→      if (usageTracking && usageTracking.markEmailVerified) {\n   483→   483→        const dbResult = await usageTracking.markEmailVerified(email);\n   484→   484→        if (!dbResult.success) {\n   485→   485→          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n   486→   486→        }\n   487→   487→      }\n   488→   488→\n   489→   489→      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n   490→   490→\n   491→   491→      // Email verified successfully\n   492→   492→      res.json({\n   493→   493→        success: true,\n   494→   494→        verified: true,\n   495→   495→        message: 'Email verified successfully'\n   496→   496→      });\n   497→   497→    } catch (err) {\n   498→   498→      console.error('[Auth] Verify email error:', err.message);\n   499→   499→      res.status(500).json({\n   500→   500→        error: 'Verification failed',\n   501→   501→        message: 'Please try again later'\n   502→   502→      });\n   503→   503→    }\n   504→   504→  });\n   505→   505→\n   506→   506→  return router;\n   507→   507→}\n   508→   508→\n   509→   509→module.exports = createAuthRoutes;\n   510→   510→\n   511→\n   512→</system-reminder>\n   513→\n\n</system-reminder>\n"}]},"uuid":"3766b35d-be71-47d9-801d-cc7a62e7677b","timestamp":"2025-12-30T02:11:00.425Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/.claude/projects/-Users-imorgado-SPLICE/4c7927f9-7798-44a0-91df-62c31e2c57cc/tool-results/toolu_01FPQijBPwrYqf6dyyw3t52d.txt","content":"     1→/**\n     2→ * Auth Routes\n     3→ *\n     4→ * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n     5→ */\n     6→\n     7→const express = require('express');\n     8→const crypto = require('crypto');\n     9→const { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\n    10→const authLogger = require('../utils/authLogger');\n    11→\n    12→// ============================================================================\n    13→// Email Verification Code Storage\n    14→// In-memory store for verification codes. Maps email -> { code, expires, attempts }\n    15→// Can be upgraded to Redis for distributed deployments.\n    16→// ============================================================================\n    17→\n    18→const verificationCodes = new Map();\n    19→\n    20→// Verification code expiry time (10 minutes)\n    21→const VERIFICATION_CODE_EXPIRY_MS = 10 * 60 * 1000;\n    22→\n    23→// Maximum verification attempts before code is invalidated\n    24→const MAX_VERIFICATION_ATTEMPTS = 5;\n    25→\n    26→// Rate limiting: minimum time between sending codes to same email (60 seconds)\n    27→const SEND_CODE_COOLDOWN_MS = 60 * 1000;\n    28→\n    29→// Track last send time per email for rate limiting\n    30→const lastSendTime = new Map();\n    31→\n    32→// Cleanup interval for expired codes (every 5 minutes)\n    33→const CLEANUP_INTERVAL_MS = 5 * 60 * 1000;\n    34→\n    35→/**\n    36→ * Generate a 6-digit verification code\n    37→ * @returns {string} 6-digit code\n    38→ */\n    39→function generateVerificationCode() {\n    40→  // Generate cryptographically secure random 6-digit code\n    41→  const code = crypto.randomInt(100000, 999999).toString();\n    42→  return code;\n    43→}\n    44→\n    45→/**\n    46→ * Store a verification code for an email\n    47→ * @param {string} email - Email address\n    48→ * @param {string} code - Verification code\n    49→ */\n    50→function storeVerificationCode(email, code) {\n    51→  const normalizedEmail = email.toLowerCase().trim();\n    52→  verificationCodes.set(normalizedEmail, {\n    53→    code,\n    54→    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS,\n    55→    attempts: 0,\n    56→    createdAt: Date.now()\n    57→  });\n    58→  lastSendTime.set(normalizedEmail, Date.now());\n    59→}\n    60→\n    61→/**\n    62→ * Verify a code for an email\n    63→ * @param {string} email - Email address\n    64→ * @param {string} code - Code to verify\n    65→ * @returns {{ valid: boolean, error?: string }}\n    66→ */\n    67→function verifyCode(email, code) {\n    68→  const normalizedEmail = email.toLowerCase().trim();\n    69→  const stored = verificationCodes.get(normalizedEmail);\n    70→\n    71→  if (!stored) {\n    72→    return { valid: false, error: 'No verification code found. Please request a new one.' };\n    73→  }\n    74→\n    75→  // Check if expired\n    76→  if (Date.now() > stored.expires) {\n    77→    verificationCodes.delete(normalizedEmail);\n    78→    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n    79→  }\n    80→\n    81→  // Increment attempt counter\n    82→  stored.attempts++;\n    83→\n    84→  // Check if too many attempts\n    85→  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n    86→    verificationCodes.delete(normalizedEmail);\n    87→    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n    88→  }\n    89→\n    90→  // Check if code matches\n    91→  if (stored.code !== code) {\n    92→    verificationCodes.set(normalizedEmail, stored);\n    93→    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n    94→  }\n    95→\n    96→  // Code is valid - remove it (single use)\n    97→  verificationCodes.delete(normalizedEmail);\n    98→  return { valid: true };\n    99→}\n   100→\n   101→/**\n   102→ * Check if we can send a new code to an email (rate limiting)\n   103→ * @param {string} email - Email address\n   104→ * @returns {{ allowed: boolean, waitSeconds?: number }}\n   105→ */\n   106→function canSendCode(email) {\n   107→  const normalizedEmail = email.toLowerCase().trim();\n   108→  const lastSent = lastSendTime.get(normalizedEmail);\n   109→\n   110→  if (!lastSent) {\n   111→    return { allowed: true };\n   112→  }\n   113→\n   114→  const elapsed = Date.now() - lastSent;\n   115→  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n   116→    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n   117→    return { allowed: false, waitSeconds };\n   118→  }\n   119→\n   120→  return { allowed: true };\n   121→}\n   122→\n   123→/**\n   124→ * Clean up expired verification codes\n   125→ */\n   126→function cleanupVerificationCodes() {\n   127→  const now = Date.now();\n   128→  let cleanedCount = 0;\n   129→\n   130→  for (const [email, data] of verificationCodes.entries()) {\n   131→    if (data.expires <= now) {\n   132→      verificationCodes.delete(email);\n   133→      cleanedCount++;\n   134→    }\n   135→  }\n   136→\n   137→  // Also clean up old lastSendTime entries (older than 1 hour)\n   138→  const oneHourAgo = now - (60 * 60 * 1000);\n   139→  for (const [email, time] of lastSendTime.entries()) {\n   140→    if (time < oneHourAgo) {\n   141→      lastSendTime.delete(email);\n   142→    }\n   143→  }\n   144→\n   145→  if (cleanedCount > 0) {\n   146→    console.log(`[Auth] Verification code cleanup: removed ${cleanedCount} expired codes`);\n   147→  }\n   148→}\n   149→\n   150→// Start periodic cleanup (unref to allow process exit)\n   151→const cleanupTimer = setInterval(cleanupVerificationCodes, CLEANUP_INTERVAL_MS);\n   152→if (cleanupTimer.unref) {\n   153→  cleanupTimer.unref();\n   154→}\n   155→\n   156→/**\n   157→ * Validate email format\n   158→ * @param {string} email - Email to validate\n   159→ * @returns {boolean}\n   160→ */\n   161→function isValidEmail(email) {\n   162→  if (!email || typeof email !== 'string') return false;\n   163→  // Basic email validation regex\n   164→  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n   165→  return emailRegex.test(email.trim());\n   166→}\n   167→\n   168→/**\n   169→ * Create auth routes\n   170→ * @param {Object} options - Route configuration options\n   171→ * @param {Object} options.middleware - Shared middleware (authenticateToken)\n   172→ * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n   173→ * @param {Object} options.authHelpers - Auth helper functions\n   174→ * @returns {express.Router}\n   175→ */\n   176→function createAuthRoutes(options = {}) {\n   177→  const router = express.Router();\n   178→  const { authenticateToken } = options.middleware || {};\n   179→  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n   180→  const { usageTracking, licenseService, emailService } = options.services || {};\n   181→\n   182→  /**\n   183→   * GET /csrf-token - Generate and return a CSRF token\n   184→   *\n   185→   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   186→   * The token is returned in both the response body and an HttpOnly cookie.\n   187→   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   188→   */\n   189→  router.get('/csrf-token', csrfTokenHandler);\n   190→\n   191→  /**\n   192→   * POST /login - Authenticate with license key and get JWT token\n   193→   *\n   194→   * SECURITY: This is the primary authentication endpoint.\n   195→   * Validates license key and returns a JWT token for API access.\n   196→   * CSRF protection applied to prevent cross-site login attacks.\n   197→   */\n   198→  router.post('/login', validateCsrfToken, async (req, res) => {\n   199→    const { licenseKey } = req.body;\n   200→\n   201→    if (!licenseKey) {\n   202→      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n   203→      return res.status(400).json({\n   204→        error: 'License key required',\n   205→        message: 'Please provide your license key to log in'\n   206→      });\n   207→    }\n   208→\n   209→    try {\n   210→      // Validate and activate the license key\n   211→      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n   212→\n   213→      if (!licenseResult.success) {\n   214→        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n   215→        return res.status(401).json({\n   216→          error: 'Invalid license key',\n   217→          message: licenseResult.error || 'The license key is invalid or expired'\n   218→        });\n   219→      }\n   220→\n   221→      // Get user's tier and balance\n   222→      const balance = await usageTracking.getBalance(licenseResult.customerId);\n   223→\n   224→      // Generate JWT tokens\n   225→      const tokenResult = generateToken(licenseResult.customerId, {\n   226→        tier: balance.tier,\n   227→        email: licenseResult.email\n   228→      });\n   229→      const refreshResult = generateRefreshToken(licenseResult.customerId);\n   230→\n   231→      // Log successful login with structured logging\n   232→      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n   233→        email: licenseResult.email,\n   234→        tier: balance.tier\n   235→      });\n   236→\n   237→      res.json({\n   238→        success: true,\n   239→        token: tokenResult.token,\n   240→        tokenType: tokenResult.tokenType,\n   241→        expiresIn: tokenResult.expiresIn,\n   242→        refreshToken: refreshResult.refreshToken,\n   243→        customerId: licenseResult.customerId,\n   244→        tier: balance.tier,\n   245→        hoursRemaining: balance.hoursRemaining\n   246→      });\n   247→    } catch (err) {\n   248→      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n   249→      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n   250→    }\n   251→  });\n   252→\n   253→  /**\n   254→   * POST /refresh - Refresh an expired JWT token\n   255→   *\n   256→   * Uses a refresh token to get a new access token.\n   257→   * CSRF protection applied to prevent token theft via cross-site requests.\n   258→   */\n   259→  router.post('/refresh', validateCsrfToken, async (req, res) => {\n   260→    const { refreshToken } = req.body;\n   261→\n   262→    if (!refreshToken) {\n   263→      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n   264→      return res.status(400).json({\n   265→        error: 'Refresh token required'\n   266→      });\n   267→    }\n   268→\n   269→    try {\n   270→      const decoded = await verifyToken(refreshToken, { req });\n   271→\n   272→      if (!decoded || decoded.type !== 'refresh') {\n   273→        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n   274→        return res.status(401).json({\n   275→          error: 'Invalid refresh token',\n   276→          message: 'Please log in again'\n   277→        });\n   278→      }\n   279→\n   280→      // Get current user info\n   281→      const balance = await usageTracking.getBalance(decoded.sub);\n   282→\n   283→      // Generate new access token\n   284→      const tokenResult = generateToken(decoded.sub, {\n   285→        tier: balance.tier\n   286→      });\n   287→\n   288→      // Log successful token refresh\n   289→      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n   290→\n   291→      res.json({\n   292→        success: true,\n   293→        token: tokenResult.token,\n   294→        tokenType: tokenResult.tokenType,\n   295→        expiresIn: tokenResult.expiresIn\n   296→      });\n   297→    } catch (err) {\n   298→      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n   299→      res.status(401).json({\n   300→        error: 'Failed to refresh token',\n   301→        message: 'Please log in again'\n   302→      });\n   303→    }\n   304→  });\n   305→\n   306→  /**\n   307→   * POST /logout - Invalidate tokens by adding to blacklist\n   308→   *\n   309→   * Adds the current token's jti to the blacklist so it cannot be reused.\n   310→   * Also accepts an optional refreshToken to revoke both tokens at once.\n   311→   * CSRF protection applied to prevent forced logout attacks.\n   312→   */\n   313→  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n   314→    const { refreshToken } = req.body;\n   315→    let refreshTokenRevoked = false;\n   316→\n   317→    // Blacklist the access token using the blacklistToken function from authHelpers\n   318→    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n   319→      if (blacklistToken) {\n   320→        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n   321→          userId: req.stripeCustomerId,\n   322→          reason: 'logout'\n   323→        });\n   324→      } else {\n   325→        console.warn('[Auth] Logout: blacklistToken function not available');\n   326→      }\n   327→    } else {\n   328→      // Token doesn't have jti - log warning but continue\n   329→      // This handles tokens generated before jti was added\n   330→      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n   331→    }\n   332→\n   333→    // Optionally blacklist the refresh token too\n   334→    if (refreshToken && blacklistToken) {\n   335→      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n   336→      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n   337→      if (decoded && decoded.jti && decoded.exp) {\n   338→        await blacklistToken(decoded.jti, decoded.exp, {\n   339→          userId: req.stripeCustomerId,\n   340→          reason: 'logout_refresh'\n   341→        });\n   342→        refreshTokenRevoked = true;\n   343→      }\n   344→    }\n   345→\n   346→    // Log successful logout with structured logging\n   347→    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n   348→      jti: req.tokenData?.jti,\n   349→      refreshTokenRevoked\n   350→    });\n   351→\n   352→    res.json({\n   353→      success: true,\n   354→      message: 'Logged out successfully'\n   355→    });\n   356→  });\n   357→\n   358→  // ==========================================================================\n   359→  // Email Verification Endpoints\n   360→  // ==========================================================================\n   361→\n   362→  /**\n   363→   * POST /send-verification - Send a verification code to an email address\n   364→   *\n   365→   * Request body: { email: string }\n   366→   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   367→   *\n   368→   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   369→   */\n   370→  router.post('/send-verification', validateCsrfToken, async (req, res) => {\n   371→    const { email } = req.body;\n   372→\n   373→    // Validate email\n   374→    if (!email) {\n   375→      return res.status(400).json({\n   376→        error: 'Email required',\n   377→        message: 'Please provide an email address'\n   378→      });\n   379→    }\n   380→\n   381→    if (!isValidEmail(email)) {\n   382→      return res.status(400).json({\n   383→        error: 'Invalid email',\n   384→        message: 'Please provide a valid email address'\n   385→      });\n   386→    }\n   387→\n   388→    // Check rate limiting\n   389→    const rateCheck = canSendCode(email);\n   390→    if (!rateCheck.allowed) {\n   391→      return res.status(429).json({\n   392→        error: 'Too many requests',\n   393→        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n   394→        waitSeconds: rateCheck.waitSeconds\n   395→      });\n   396→    }\n   397→\n   398→    try {\n   399→      // Generate and store verification code\n   400→      const code = generateVerificationCode();\n   401→      storeVerificationCode(email, code);\n   402→\n   403→      // Send verification email\n   404→      if (emailService && emailService.sendEmailVerificationCode) {\n   405→        await emailService.sendEmailVerificationCode(email, code, 10);\n   406→        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n   407→      } else {\n   408→        // Fallback for development - log to console\n   409→        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n   410→      }\n   411→\n   412→      res.json({\n   413→        success: true,\n   414→        message: 'Verification code sent. Please check your email.',\n   415→        expiresInMinutes: 10\n   416→      });\n   417→    } catch (err) {\n   418→      console.error('[Auth] Send verification error:', err.message);\n   419→      res.status(500).json({\n   420→        error: 'Failed to send verification code',\n   421→        message: 'Please try again later'\n   422→      });\n   423→    }\n   424→  });\n   425→\n   426→  /**\n   427→   * POST /verify-email - Verify an email address with a code\n   428→   *\n   429→   * Request body: { email: string, code: string }\n   430→   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   431→   *\n   432→   * SECURITY: Limited attempts per code. CSRF protection applied.\n   433→   */\n   434→  router.post('/verify-email', validateCsrfToken, async (req, res) => {\n   435→    const { email, code } = req.body;\n   436→\n   437→    // Validate inputs\n   438→    if (!email) {\n   439→      return res.status(400).json({\n   440→        error: 'Email required',\n   441→        message: 'Please provide an email address'\n   442→      });\n   443→    }\n   444→\n   445→    if (!code) {\n   446→      return res.status(400).json({\n   447→        error: 'Code required',\n   448→        message: 'Please provide the verification code'\n   449→      });\n   450→    }\n   451→\n   452→    if (!isValidEmail(email)) {\n   453→      return res.status(400).json({\n   454→        error: 'Invalid email',\n   455→        message: 'Please provide a valid email address'\n   456→      });\n   457→    }\n   458→\n   459→    // Validate code format (6 digits)\n   460→    const codeStr = String(code).trim();\n   461→    if (!/^\\d{6}$/.test(codeStr)) {\n   462→      return res.status(400).json({\n   463→        error: 'Invalid code format',\n   464→        message: 'Verification code must be 6 digits'\n   465→      });\n   466→    }\n   467→\n   468→    try {\n   469→      // Verify the code\n   470→      const result = verifyCode(email, codeStr);\n   471→\n   472→      if (!result.valid) {\n   473→        return res.status(400).json({\n   474→          success: false,\n   475→          verified: false,\n   476→          error: 'Verification failed',\n   477→          message: result.error\n   478→        });\n   479→      }\n   480→\n   481→      // Mark email as verified in the database\n   482→      if (usageTracking && usageTracking.markEmailVerified) {\n   483→        const dbResult = await usageTracking.markEmailVerified(email);\n   484→        if (!dbResult.success) {\n   485→          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n   486→        }\n   487→      }\n   488→\n   489→      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n   490→\n   491→      // Email verified successfully\n   492→      res.json({\n   493→        success: true,\n   494→        verified: true,\n   495→        message: 'Email verified successfully'\n   496→      });\n   497→    } catch (err) {\n   498→      console.error('[Auth] Verify email error:', err.message);\n   499→      res.status(500).json({\n   500→        error: 'Verification failed',\n   501→        message: 'Please try again later'\n   502→      });\n   503→    }\n   504→  });\n   505→\n   506→  return router;\n   507→}\n   508→\n   509→module.exports = createAuthRoutes;\n   510→\n\n</system-reminder>\n","numLines":513,"startLine":1,"totalLines":513}}}
{"parentUuid":"3766b35d-be71-47d9-801d-cc7a62e7677b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012W72QYh2zuVq1ZLBe1fMGT","type":"tool_result","content":"     1→     1→/**\n     2→     2→ * SPLICE Backend Server\n     3→     3→ *\n     4→     4→ * Main entry point for the SPLICE backend API.\n     5→     5→ * Orchestrates the audio analysis pipeline.\n     6→     6→ *\n     7→     7→ * Slices:\n     8→     8→ * - Slice 4: Transcription (services/transcription.js)\n     9→     9→ * - Slice 5: Take Detection (services/takeDetection.js)\n    10→    10→ *\n    11→    11→ * Architecture: Modular routes (see routes/ directory)\n    12→    12→ */\n    13→    13→\n    14→    14→\n    15→    15→require('dotenv').config();\n    16→    16→\n    17→    17→const express = require('express');\n    18→    18→const cors = require('cors');\n    19→    19→const helmet = require('helmet');\n    20→    20→const cookieParser = require('cookie-parser');\n    21→    21→const fs = require('fs');\n    22→    22→const https = require('https');\n    23→    23→const http = require('http');\n    24→    24→const path = require('path');\n    25→    25→const crypto = require('crypto');\n    26→    26→\n    27→    27→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\n    28→    28→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    29→    29→\n    30→    30→// Import services\n    31→    31→const usageTracking = require('./services/usageTracking');\n    32→    32→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\n    33→    33→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\n    34→    34→const referralService = require('./services/referralService');\n    35→    35→const licenseService = require('./services/licenseService');\n    36→    36→const emailService = require('./services/emailService');\n    37→    37→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\n    38→    38→const { getSupportedFormats } = require('./services/captionExporter');\n    39→    39→\n    40→    40→// Import route modules\n    41→    41→const healthRoutes = require('./routes/health');\n    42→    42→const analyzeRoutes = require('./routes/analyze');\n    43→    43→const silencesRoutes = require('./routes/silences');\n    44→    44→const detectionRoutes = require('./routes/detection');\n    45→    45→const exportRoutes = require('./routes/export');\n    46→    46→const multitrackRoutes = require('./routes/multitrack');\n    47→    47→const cutListRoutes = require('./routes/cutList');\n    48→    48→const zoomRoutes = require('./routes/zoom');\n    49→    49→const chaptersRoutes = require('./routes/chapters');\n    50→    50→const youtubeRoutes = require('./routes/youtube');\n    51→    51→const captionsRoutes = require('./routes/captions');\n    52→    52→const textEditRoutes = require('./routes/textEdit');\n    53→    53→const reframeRoutes = require('./routes/reframe');\n    54→    54→const batchRoutes = require('./routes/batch');\n    55→    55→const authRoutes = require('./routes/auth');\n    56→    56→const billingRoutes = require('./routes/billing');\n    57→    57→const referralRoutes = require('./routes/referral');\n    58→    58→const licenseRoutes = require('./routes/license');\n    59→    59→const musicRoutes = require('./routes/music');\n    60→    60→\n    61→    61→// Stripe for webhooks\n    62→    62→const Stripe = require('stripe');\n    63→    63→\n    64→    64→// Validate STRIPE_SECRET_KEY in production - exit if missing\n    65→    65→if (isProduction && !process.env.STRIPE_SECRET_KEY) {\n    66→    66→  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');\n    67→    67→  process.exit(1);\n    68→    68→}\n    69→    69→\n    70→    70→// Validate JWT_SECRET in production - exit if using default\n    71→    71→if (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {\n    72→    72→  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');\n    73→    73→  process.exit(1);\n    74→    74→}\n    75→    75→\n    76→    76→// Validate DATABASE_URL in production\n    77→    77→if (isProduction && !process.env.DATABASE_URL) {\n    78→    78→  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');\n    79→    79→  process.exit(1);\n    80→    80→}\n    81→    81→\n    82→    82→// Validate OPENAI_API_KEY in production\n    83→    83→if (isProduction && !process.env.OPENAI_API_KEY) {\n    84→    84→  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');\n    85→    85→  process.exit(1);\n    86→    86→}\n    87→    87→\n    88→    88→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n    89→    89→\n    90→    90→// =============================================================================\n    91→    91→// PERF-FIX: Static Response Cache\n    92→    92→// Cache static endpoint responses at startup to avoid repeated computation\n    93→    93→// =============================================================================\n    94→    94→\n    95→    95→// Generate ETag from content\n    96→    96→function generateETag(content) {\n    97→    97→  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n    98→    98→}\n    99→    99→\n   100→   100→// Static response cache - populated at startup\n   101→   101→const STATIC_RESPONSE_CACHE = {\n   102→   102→  profanityLanguages: null,\n   103→   103→  profanityBleeps: null,\n   104→   104→  exportFormats: null\n   105→   105→};\n   106→   106→\n   107→   107→// Initialize cache at startup (called after server starts)\n   108→   108→function initializeStaticCache() {\n   109→   109→  // Cache profanity languages\n   110→   110→  const languages = getSupportedLanguages();\n   111→   111→  STATIC_RESPONSE_CACHE.profanityLanguages = {\n   112→   112→    body: { success: true, languages },\n   113→   113→    etag: generateETag({ languages })\n   114→   114→  };\n   115→   115→\n   116→   116→  // Cache profanity bleeps\n   117→   117→  const sounds = getAvailableBleepSounds();\n   118→   118→  STATIC_RESPONSE_CACHE.profanityBleeps = {\n   119→   119→    body: { success: true, sounds },\n   120→   120→    etag: generateETag({ sounds })\n   121→   121→  };\n   122→   122→\n   123→   123→  // Cache export formats\n   124→   124→  const formats = getSupportedFormats();\n   125→   125→  STATIC_RESPONSE_CACHE.exportFormats = {\n   126→   126→    body: { success: true, formats },\n   127→   127→    etag: generateETag({ formats })\n   128→   128→  };\n   129→   129→\n   130→   130→  console.log('[SPLICE] Static response cache initialized');\n   131→   131→}\n   132→   132→\n   133→   133→// Helper to send cached response with ETag\n   134→   134→function sendCachedResponse(req, res, cacheKey) {\n   135→   135→  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n   136→   136→  if (!cached) {\n   137→   137→    return res.status(500).json({ error: 'Cache not initialized' });\n   138→   138→  }\n   139→   139→\n   140→   140→  // Check If-None-Match header for conditional GET\n   141→   141→  const clientETag = req.headers['if-none-match'];\n   142→   142→  if (clientETag === cached.etag) {\n   143→   143→    return res.status(304).end(); // Not Modified\n   144→   144→  }\n   145→   145→\n   146→   146→  // Send cached response with ETag and cache headers\n   147→   147→  res.set('ETag', cached.etag);\n   148→   148→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n   149→   149→  res.json(cached.body);\n   150→   150→}\n   151→   151→\n   152→   152→// =============================================================================\n   153→   153→// Server Configuration\n   154→   154→// =============================================================================\n   155→   155→\n   156→   156→const app = express();\n   157→   157→const PORT = process.env.PORT || 3847;\n   158→   158→\n   159→   159→// HTTPS certificates (generated by mkcert) - only for local development\n   160→   160→let httpsOptions = null;\n   161→   161→if (!isProduction) {\n   162→   162→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n   163→   163→  const certPath = path.join(__dirname, 'localhost+1.pem');\n   164→   164→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n   165→   165→    httpsOptions = {\n   166→   166→      key: fs.readFileSync(keyPath),\n   167→   167→      cert: fs.readFileSync(certPath)\n   168→   168→    };\n   169→   169→  }\n   170→   170→}\n   171→   171→\n   172→   172→// =============================================================================\n   173→   173→// Security Configuration\n   174→   174→// =============================================================================\n   175→   175→\n   176→   176→// CORS whitelist - restrict origins in production\n   177→   177→const CORS_WHITELIST = [\n   178→   178→  'http://localhost:3000',\n   179→   179→  'http://localhost:3847',\n   180→   180→  'https://localhost:3847',\n   181→   181→  'http://127.0.0.1:3000',\n   182→   182→  'http://127.0.0.1:3847',\n   183→   183→  'https://127.0.0.1:3847',\n   184→   184→  'https://splice.app',\n   185→   185→  'https://www.splice.app',\n   186→   186→  'https://splice-api-production.up.railway.app',\n   187→   187→  'https://splice-website.vercel.app',\n   188→   188→  // Adobe CEP/UXP panels run from file:// or bolt://\n   189→   189→  'file://',\n   190→   190→  'bolt://'\n   191→   191→];\n   192→   192→\n   193→   193→const corsOptions = {\n   194→   194→  origin: function (origin, callback) {\n   195→   195→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n   196→   196→    if (!origin) {\n   197→   197→      return callback(null, true);\n   198→   198→    }\n   199→   199→    // Check if origin is in whitelist\n   200→   200→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n   201→   201→      return callback(null, true);\n   202→   202→    }\n   203→   203→    // In development, allow all origins with warning\n   204→   204→    if (!isProduction) {\n   205→   205→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n   206→   206→      return callback(null, true);\n   207→   207→    }\n   208→   208→    // In production, reject non-whitelisted origins\n   209→   209→    console.error(`[CORS] Blocked request from: ${origin}`);\n   210→   210→    return callback(new Error('Not allowed by CORS'));\n   211→   211→  },\n   212→   212→  credentials: true,\n   213→   213→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n   214→   214→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n   215→   215→};\n   216→   216→\n   217→   217→app.use(cors(corsOptions));\n   218→   218→\n   219→   219→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n   220→   220→// This ensures rate limiting and logging use the correct client IP\n   221→   221→if (isProduction) {\n   222→   222→  app.set('trust proxy', 1);\n   223→   223→}\n   224→   224→\n   225→   225→// IP-based rate limiting (100 requests/minute per IP)\n   226→   226→app.use(ipRateLimit);\n   227→   227→\n   228→   228→// Security headers via helmet\n   229→   229→app.use(helmet({\n   230→   230→  contentSecurityPolicy: {\n   231→   231→    directives: {\n   232→   232→      defaultSrc: [\"'self'\"],\n   233→   233→      scriptSrc: [\"'self'\"],\n   234→   234→      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n   235→   235→      imgSrc: [\"'self'\", 'data:', 'https:'],\n   236→   236→      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n   237→   237→      fontSrc: [\"'self'\"],\n   238→   238→      objectSrc: [\"'none'\"],\n   239→   239→      mediaSrc: [\"'self'\"],\n   240→   240→      frameSrc: [\"'none'\"]\n   241→   241→    }\n   242→   242→  },\n   243→   243→  hsts: {\n   244→   244→    maxAge: 31536000,\n   245→   245→    includeSubDomains: true,\n   246→   246→    preload: true\n   247→   247→  },\n   248→   248→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n   249→   249→  noSniff: true,\n   250→   250→  xssFilter: true,\n   251→   251→  hidePoweredBy: true\n   252→   252→}));\n   253→   253→\n   254→   254→// Helper to determine tier from price ID with logging\n   255→   255→// Supports both monthly and annual pricing\n   256→   256→function getTierFromPriceId(priceId) {\n   257→   257→  // Monthly prices\n   258→   258→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   259→   259→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   260→   260→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   261→   261→\n   262→   262→  // Annual prices (same tier, just different billing period)\n   263→   263→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n   264→   264→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n   265→   265→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n   266→   266→\n   267→   267→  // Log unknown price ID for debugging\n   268→   268→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   269→   269→  return 'starter';\n   270→   270→}\n   271→   271→\n   272→   272→// =============================================================================\n   273→   273→// Stripe Webhook (must be before express.json())\n   274→   274→// =============================================================================\n   275→   275→\n   276→   276→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   277→   277→  const sig = req.headers['stripe-signature'];\n   278→   278→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   279→   279→\n   280→   280→  let event;\n   281→   281→\n   282→   282→  try {\n   283→   283→    if (webhookSecret) {\n   284→   284→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   285→   285→    } else if (isProduction) {\n   286→   286→      // SECURITY: Reject unsigned webhooks in production\n   287→   287→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   288→   288→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   289→   289→    } else {\n   290→   290→      // For local development testing only\n   291→   291→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   292→   292→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   293→   293→      event = JSON.parse(bodyString);\n   294→   294→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   295→   295→    }\n   296→   296→  } catch (err) {\n   297→   297→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   298→   298→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   299→   299→  }\n   300→   300→\n   301→   301→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   302→   302→\n   303→   303→  // Idempotency check - skip if already processed\n   304→   304→  if (await usageTracking.isEventProcessed(event.id)) {\n   305→   305→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   306→   306→    return res.json({ received: true, skipped: true });\n   307→   307→  }\n   308→   308→\n   309→   309→  try {\n   310→   310→    switch (event.type) {\n   311→   311→      case 'customer.subscription.created':\n   312→   312→      case 'customer.subscription.updated': {\n   313→   313→        const subscription = event.data.object;\n   314→   314→        const customerId = subscription.customer;\n   315→   315→\n   316→   316→        // Validate customerId\n   317→   317→        if (!customerId) {\n   318→   318→          console.error('[SPLICE] Missing customer ID in subscription event');\n   319→   319→          return res.status(400).json({ error: 'Missing customer ID' });\n   320→   320→        }\n   321→   321→\n   322→   322→        // Get tier from price ID\n   323→   323→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   324→   324→        const tier = getTierFromPriceId(priceId);\n   325→   325→\n   326→   326→        // Update user tier and reset hours\n   327→   327→        await usageTracking.updateTier(customerId, tier);\n   328→   328→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   329→   329→\n   330→   330→        // Initialize music credits for new subscriptions\n   331→   331→        if (event.type === 'customer.subscription.created') {\n   332→   332→          await usageTracking.resetMusicCredits(customerId, tier);\n   333→   333→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n   334→   334→        }\n   335→   335→\n   336→   336→        // Update trial end date if present\n   337→   337→        if (subscription.trial_end) {\n   338→   338→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n   339→   339→        }\n   340→   340→\n   341→   341→        // Generate license key for new subscriptions with retry and delivery\n   342→   342→        if (event.type === 'customer.subscription.created') {\n   343→   343→          let licenseResult = null;\n   344→   344→          let retryCount = 0;\n   345→   345→          const maxRetries = 3;\n   346→   346→\n   347→   347→          // Retry mechanism for license key generation\n   348→   348→          while (retryCount < maxRetries) {\n   349→   349→            licenseResult = await licenseService.generateLicenseKey(customerId);\n   350→   350→            if (licenseResult.success) {\n   351→   351→              break;\n   352→   352→            }\n   353→   353→            retryCount++;\n   354→   354→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n   355→   355→            // Wait before retry (exponential backoff)\n   356→   356→            if (retryCount < maxRetries) {\n   357→   357→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n   358→   358→            }\n   359→   359→          }\n   360→   360→\n   361→   361→          if (licenseResult && licenseResult.success) {\n   362→   362→            // SECURITY: Mask license key in logs\n   363→   363→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n   364→   364→\n   365→   365→            // Store license key in Stripe subscription metadata as backup\n   366→   366→            try {\n   367→   367→              await stripe.subscriptions.update(subscription.id, {\n   368→   368→                metadata: {\n   369→   369→                  license_key: licenseResult.key,\n   370→   370→                  license_generated_at: new Date().toISOString()\n   371→   371→                }\n   372→   372→              });\n   373→   373→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n   374→   374→            } catch (stripeErr) {\n   375→   375→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n   376→   376→            }\n   377→   377→\n   378→   378→            // Get customer email and send license key\n   379→   379→            try {\n   380→   380→              const customer = await stripe.customers.retrieve(customerId);\n   381→   381→              if (customer.email) {\n   382→   382→                // SECURITY: Mask sensitive data in logs\n   383→   383→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n   384→   384→\n   385→   385→                // Send license key email\n   386→   386→                try {\n   387→   387→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n   388→   388→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n   389→   389→                } catch (sendErr) {\n   390→   390→                  // Log but don't fail - license is stored in Stripe metadata as backup\n   391→   391→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n   392→   392→                }\n   393→   393→\n   394→   394→                // Store email in database for reference\n   395→   395→                await usageTracking.updateTier(customerId, tier, customer.email);\n   396→   396→              } else {\n   397→   397→                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n   398→   398→              }\n   399→   399→            } catch (emailErr) {\n   400→   400→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n   401→   401→            }\n   402→   402→          } else {\n   403→   403→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n   404→   404→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n   405→   405→            console.error(`[SPLICE] ${errorMsg}`);\n   406→   406→            return res.status(500).json({ error: errorMsg });\n   407→   407→          }\n   408→   408→        }\n   409→   409→        break;\n   410→   410→      }\n   411→   411→\n   412→   412→      case 'customer.subscription.deleted': {\n   413→   413→        const subscription = event.data.object;\n   414→   414→        const customerId = subscription.customer;\n   415→   415→\n   416→   416→        // Validate customerId\n   417→   417→        if (!customerId) {\n   418→   418→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   419→   419→          return res.status(400).json({ error: 'Missing customer ID' });\n   420→   420→        }\n   421→   421→\n   422→   422→        // Downgrade to cancelled (0 hours)\n   423→   423→        await usageTracking.updateTier(customerId, 'cancelled');\n   424→   424→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   425→   425→        break;\n   426→   426→      }\n   427→   427→\n   428→   428→      case 'invoice.payment_succeeded': {\n   429→   429→        const invoice = event.data.object;\n   430→   430→        const customerId = invoice.customer;\n   431→   431→        const subscriptionId = invoice.subscription;\n   432→   432→\n   433→   433→        // Validate customerId\n   434→   434→        if (!customerId) {\n   435→   435→          console.error('[SPLICE] Missing customer ID in invoice event');\n   436→   436→          return res.status(400).json({ error: 'Missing customer ID' });\n   437→   437→        }\n   438→   438→\n   439→   439→        // Reset hours on successful payment (new billing period)\n   440→   440→        let tier = 'starter';\n   441→   441→        if (subscriptionId) {\n   442→   442→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   443→   443→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   444→   444→          tier = getTierFromPriceId(priceId);\n   445→   445→\n   446→   446→          await usageTracking.resetHours(customerId, tier);\n   447→   447→          await usageTracking.resetMusicCredits(customerId, tier);\n   448→   448→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n   449→   449→        }\n   450→   450→\n   451→   451→        // Check for affiliate coupon and record commission\n   452→   452→        const discount = invoice.discount;\n   453→   453→        if (discount && discount.coupon) {\n   454→   454→          const couponId = discount.coupon.id;\n   455→   455→          // Check if this is an affiliate code (like JIMMYN)\n   456→   456→          if (referralService.AFFILIATE_CODES[couponId]) {\n   457→   457→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n   458→   458→            await referralService.recordAffiliateCommission(\n   459→   459→              couponId,\n   460→   460→              customerId,\n   461→   461→              amountPaid,\n   462→   462→              tier\n   463→   463→            );\n   464→   464→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n   465→   465→          }\n   466→   466→        }\n   467→   467→        break;\n   468→   468→      }\n   469→   469→\n   470→   470→      case 'invoice.payment_failed': {\n   471→   471→        const invoice = event.data.object;\n   472→   472→        const customerId = invoice.customer;\n   473→   473→        const attemptCount = invoice.attempt_count || 1;\n   474→   474→\n   475→   475→        // Validate customerId\n   476→   476→        if (!customerId) {\n   477→   477→          console.error('[SPLICE] Missing customer ID in payment_failed event');\n   478→   478→          return res.status(400).json({ error: 'Missing customer ID' });\n   479→   479→        }\n   480→   480→\n   481→   481→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n   482→   482→\n   483→   483→        // Stripe will retry automatically per retry settings\n   484→   484→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n   485→   485→        // Send warning email on final attempt\n   486→   486→        if (attemptCount >= 3) {\n   487→   487→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n   488→   488→          // Send warning email to customer about impending cancellation\n   489→   489→          try {\n   490→   490→            const customer = await stripe.customers.retrieve(customerId);\n   491→   491→            if (customer.email) {\n   492→   492→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n   493→   493→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n   494→   494→            }\n   495→   495→          } catch (emailErr) {\n   496→   496→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n   497→   497→          }\n   498→   498→        }\n   499→   499→        break;\n   500→   500→      }\n   501→   501→\n   502→   502→      case 'customer.deleted': {\n   503→   503→        const customer = event.data.object;\n   504→   504→        const customerId = customer.id;\n   505→   505→\n   506→   506→        // Validate customerId\n   507→   507→        if (!customerId) {\n   508→   508→          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n   509→   509→          return res.status(400).json({ error: 'Missing customer ID' });\n   510→   510→        }\n   511→   511→\n   512→   512→        // Clean up user data - downgrade to cancelled\n   513→   513→        await usageTracking.updateTier(customerId, 'cancelled');\n   514→   514→        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n   515→   515→        break;\n   516→   516→      }\n   517→   517→\n   518→   518→      default:\n   519→   519→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   520→   520→    }\n   521→   521→\n   522→   522→    // Record event as processed (idempotency)\n   523→   523→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   524→   524→\n   525→   525→    res.json({ received: true });\n   526→   526→  } catch (err) {\n   527→   527→    console.error('[SPLICE] Webhook handler error:', err);\n   528→   528→    res.status(500).json({ error: err.message });\n   529→   529→  }\n   530→   530→});\n   531→   531→\n   532→   532→// Parse JSON body for all other routes\n   533→   533→// SECURITY: Limit JSON body size to prevent DoS attacks\n   534→   534→app.use(express.json({ limit: '10mb' }));\n   535→   535→\n   536→   536→// Parse cookies for CSRF token validation\n   537→   537→app.use(cookieParser());\n   538→   538→\n   539→   539→// =============================================================================\n   540→   540→// Route Configuration Options\n   541→   541→// =============================================================================\n   542→   542→\n   543→   543→const routeOptions = {\n   544→   544→  middleware: {\n   545→   545→    requireCredits,\n   546→   546→    requireFeature,\n   547→   547→    authenticateToken\n   548→   548→  },\n   549→   549→  services: {\n   550→   550→    usageTracking,\n   551→   551→    referralService,\n   552→   552→    licenseService,\n   553→   553→    emailService,\n   554→   554→    stripe\n   555→   555→  },\n   556→   556→  authHelpers: {\n   557→   557→    generateToken,\n   558→   558→    generateRefreshToken,\n   559→   559→    verifyToken,\n   560→   560→    maskSensitiveData,\n   561→   561→    blacklistToken\n   562→   562→  },\n   563→   563→  staticCache: STATIC_RESPONSE_CACHE,\n   564→   564→  sendCachedResponse\n   565→   565→};\n   566→   566→\n   567→   567→// =============================================================================\n   568→   568→// Mount Routes\n   569→   569→// =============================================================================\n   570→   570→\n   571→   571→// Health check and system endpoints (no prefix)\n   572→   572→app.use('/', healthRoutes(routeOptions));\n   573→   573→\n   574→   574→// Core analysis endpoints\n   575→   575→app.use('/', analyzeRoutes(routeOptions));\n   576→   576→app.use('/', silencesRoutes(routeOptions));\n   577→   577→app.use('/', detectionRoutes(routeOptions));\n   578→   578→\n   579→   579→// Export endpoints\n   580→   580→app.use('/export', exportRoutes(routeOptions));\n   581→   581→\n   582→   582→// Multitrack/Multicam endpoints\n   583→   583→app.use('/multitrack', multitrackRoutes(routeOptions));\n   584→   584→\n   585→   585→// Cut list generation\n   586→   586→app.use('/cut-list', cutListRoutes(routeOptions));\n   587→   587→\n   588→   588→// Legacy XML processing endpoint (backwards compatibility)\n   589→   589→const { processXMLFile } = require('./services/xmlProcessor');\n   590→   590→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n   591→   591→  const {\n   592→   592→    xmlPath,\n   593→   593→    silences,\n   594→   594→    removeGaps = true,\n   595→   595→    outputPath = null\n   596→   596→  } = req.body;\n   597→   597→\n   598→   598→  if (!xmlPath) {\n   599→   599→    return res.status(400).json({ error: 'xmlPath is required' });\n   600→   600→  }\n   601→   601→\n   602→   602→  if (!silences || !Array.isArray(silences)) {\n   603→   603→    return res.status(400).json({ error: 'silences array is required' });\n   604→   604→  }\n   605→   605→\n   606→   606→  if (!fs.existsSync(xmlPath)) {\n   607→   607→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n   608→   608→  }\n   609→   609→\n   610→   610→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n   611→   611→\n   612→   612→  try {\n   613→   613→    const result = await processXMLFile(xmlPath, silences, {\n   614→   614→      outputPath,\n   615→   615→      removeGaps\n   616→   616→    });\n   617→   617→\n   618→   618→    res.json({\n   619→   619→      success: true,\n   620→   620→      inputPath: xmlPath,\n   621→   621→      outputPath: result.outputPath,\n   622→   622→      stats: result.stats\n   623→   623→    });\n   624→   624→  } catch (err) {\n   625→   625→    console.error('[SPLICE] XML processing error:', err);\n   626→   626→    res.status(500).json({ error: err.message });\n   627→   627→  }\n   628→   628→});\n   629→   629→\n   630→   630→// Auto zoom endpoints\n   631→   631→app.use('/zoom', zoomRoutes(routeOptions));\n   632→   632→\n   633→   633→// Chapter detection endpoints\n   634→   634→app.use('/chapters', chaptersRoutes(routeOptions));\n   635→   635→\n   636→   636→// YouTube content generation\n   637→   637→app.use('/youtube', youtubeRoutes(routeOptions));\n   638→   638→\n   639→   639→// Animated captions endpoints\n   640→   640→app.use('/captions', captionsRoutes(routeOptions));\n   641→   641→\n   642→   642→// Text-based editing endpoints\n   643→   643→app.use('/text-edit', textEditRoutes(routeOptions));\n   644→   644→\n   645→   645→// Social reframe endpoints\n   646→   646→app.use('/reframe', reframeRoutes(routeOptions));\n   647→   647→app.use('/faces', reframeRoutes.facesRouter(routeOptions));\n   648→   648→\n   649→   649→// Batch processing endpoints\n   650→   650→app.use('/batch', batchRoutes(routeOptions));\n   651→   651→\n   652→   652→// Authentication endpoints\n   653→   653→app.use('/auth', authRoutes(routeOptions));\n   654→   654→\n   655→   655→// Billing and credits endpoints\n   656→   656→app.use('/', billingRoutes(routeOptions));\n   657→   657→\n   658→   658→// Referral system endpoints\n   659→   659→app.use('/referral', referralRoutes(routeOptions));\n   660→   660→\n   661→   661→// License key endpoints\n   662→   662→app.use('/license', licenseRoutes(routeOptions));\n   663→   663→\n   664→   664→// AI Music generation endpoints\n   665→   665→app.use('/music', musicRoutes(routeOptions));\n   666→   666→\n   667→   667→// =============================================================================\n   668→   668→// Start Server\n   669→   669→// =============================================================================\n   670→   670→\n   671→   671→// Track active server for graceful shutdown\n   672→   672→let server = null;\n   673→   673→\n   674→   674→// Initialize database and start server\n   675→   675→async function startServer() {\n   676→   676→  try {\n   677→   677→    await usageTracking.initDatabase();\n   678→   678→    await referralService.initReferralTables();\n   679→   679→    await licenseService.initLicenseTables();\n   680→   680→    console.log('[SPLICE] Database initialized');\n   681→   681→\n   682→   682→    // PERF-FIX: Initialize static response cache at startup\n   683→   683→    initializeStaticCache();\n   684→   684→\n   685→   685→    if (isProduction || !httpsOptions) {\n   686→   686→      // Production: Railway provides TLS termination, use HTTP\n   687→   687→      server = http.createServer(app).listen(PORT, () => {\n   688→   688→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n   689→   689→      });\n   690→   690→    } else {\n   691→   691→      // Development: Use HTTPS with local certificates\n   692→   692→      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n   693→   693→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n   694→   694→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n   695→   695→      });\n   696→   696→    }\n   697→   697→  } catch (err) {\n   698→   698→    console.error('[SPLICE] Failed to start server:', err);\n   699→   699→    process.exit(1);\n   700→   700→  }\n   701→   701→}\n   702→   702→\n   703→   703→// =============================================================================\n   704→   704→// Graceful Shutdown\n   705→   705→// =============================================================================\n   706→   706→\n   707→   707→async function gracefulShutdown(signal) {\n   708→   708→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n   709→   709→\n   710→   710→  // Stop accepting new connections\n   711→   711→  if (server) {\n   712→   712→    server.close(() => {\n   713→   713→      console.log('[SPLICE] HTTP server closed');\n   714→   714→    });\n   715→   715→  }\n   716→   716→\n   717→   717→  // Close database pool\n   718→   718→  try {\n   719→   719→    await usageTracking.closePool();\n   720→   720→    console.log('[SPLICE] Database pool closed');\n   721→   721→  } catch (err) {\n   722→   722→    console.error('[SPLICE] Error closing database pool:', err.message);\n   723→   723→  }\n   724→   724→\n   725→   725→  // Give ongoing requests time to complete (max 10 seconds)\n   726→   726→  setTimeout(() => {\n   727→   727→    console.log('[SPLICE] Graceful shutdown complete');\n   728→   728→    process.exit(0);\n   729→   729→  }, 10000);\n   730→   730→}\n   731→   731→\n   732→   732→// Handle termination signals\n   733→   733→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n   734→   734→process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n   735→   735→\n   736→   736→// Handle uncaught exceptions\n   737→   737→process.on('uncaughtException', (err) => {\n   738→   738→  console.error('[SPLICE] Uncaught exception:', err);\n   739→   739→  gracefulShutdown('uncaughtException');\n   740→   740→});\n   741→   741→\n   742→   742→process.on('unhandledRejection', (reason, promise) => {\n   743→   743→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n   744→   744→});\n   745→   745→\n   746→   746→startServer();\n   747→   747→\n   748→\n   749→</system-reminder>\n   750→\n\n</system-reminder>\n"}]},"uuid":"c95b953d-e475-450f-b4ff-f0ae1ea3ec6e","timestamp":"2025-12-30T02:11:00.679Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/.claude/projects/-Users-imorgado-SPLICE/4c7927f9-7798-44a0-91df-62c31e2c57cc/tool-results/toolu_01KVwWA1Cs4EXibQyJ4e9aXN.txt","content":"     1→/**\n     2→ * SPLICE Backend Server\n     3→ *\n     4→ * Main entry point for the SPLICE backend API.\n     5→ * Orchestrates the audio analysis pipeline.\n     6→ *\n     7→ * Slices:\n     8→ * - Slice 4: Transcription (services/transcription.js)\n     9→ * - Slice 5: Take Detection (services/takeDetection.js)\n    10→ *\n    11→ * Architecture: Modular routes (see routes/ directory)\n    12→ */\n    13→\n    14→\n    15→require('dotenv').config();\n    16→\n    17→const express = require('express');\n    18→const cors = require('cors');\n    19→const helmet = require('helmet');\n    20→const cookieParser = require('cookie-parser');\n    21→const fs = require('fs');\n    22→const https = require('https');\n    23→const http = require('http');\n    24→const path = require('path');\n    25→const crypto = require('crypto');\n    26→\n    27→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\n    28→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    29→\n    30→// Import services\n    31→const usageTracking = require('./services/usageTracking');\n    32→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\n    33→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\n    34→const referralService = require('./services/referralService');\n    35→const licenseService = require('./services/licenseService');\n    36→const emailService = require('./services/emailService');\n    37→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\n    38→const { getSupportedFormats } = require('./services/captionExporter');\n    39→\n    40→// Import route modules\n    41→const healthRoutes = require('./routes/health');\n    42→const analyzeRoutes = require('./routes/analyze');\n    43→const silencesRoutes = require('./routes/silences');\n    44→const detectionRoutes = require('./routes/detection');\n    45→const exportRoutes = require('./routes/export');\n    46→const multitrackRoutes = require('./routes/multitrack');\n    47→const cutListRoutes = require('./routes/cutList');\n    48→const zoomRoutes = require('./routes/zoom');\n    49→const chaptersRoutes = require('./routes/chapters');\n    50→const youtubeRoutes = require('./routes/youtube');\n    51→const captionsRoutes = require('./routes/captions');\n    52→const textEditRoutes = require('./routes/textEdit');\n    53→const reframeRoutes = require('./routes/reframe');\n    54→const batchRoutes = require('./routes/batch');\n    55→const authRoutes = require('./routes/auth');\n    56→const billingRoutes = require('./routes/billing');\n    57→const referralRoutes = require('./routes/referral');\n    58→const licenseRoutes = require('./routes/license');\n    59→const musicRoutes = require('./routes/music');\n    60→\n    61→// Stripe for webhooks\n    62→const Stripe = require('stripe');\n    63→\n    64→// Validate STRIPE_SECRET_KEY in production - exit if missing\n    65→if (isProduction && !process.env.STRIPE_SECRET_KEY) {\n    66→  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');\n    67→  process.exit(1);\n    68→}\n    69→\n    70→// Validate JWT_SECRET in production - exit if using default\n    71→if (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {\n    72→  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');\n    73→  process.exit(1);\n    74→}\n    75→\n    76→// Validate DATABASE_URL in production\n    77→if (isProduction && !process.env.DATABASE_URL) {\n    78→  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');\n    79→  process.exit(1);\n    80→}\n    81→\n    82→// Validate OPENAI_API_KEY in production\n    83→if (isProduction && !process.env.OPENAI_API_KEY) {\n    84→  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');\n    85→  process.exit(1);\n    86→}\n    87→\n    88→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n    89→\n    90→// =============================================================================\n    91→// PERF-FIX: Static Response Cache\n    92→// Cache static endpoint responses at startup to avoid repeated computation\n    93→// =============================================================================\n    94→\n    95→// Generate ETag from content\n    96→function generateETag(content) {\n    97→  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n    98→}\n    99→\n   100→// Static response cache - populated at startup\n   101→const STATIC_RESPONSE_CACHE = {\n   102→  profanityLanguages: null,\n   103→  profanityBleeps: null,\n   104→  exportFormats: null\n   105→};\n   106→\n   107→// Initialize cache at startup (called after server starts)\n   108→function initializeStaticCache() {\n   109→  // Cache profanity languages\n   110→  const languages = getSupportedLanguages();\n   111→  STATIC_RESPONSE_CACHE.profanityLanguages = {\n   112→    body: { success: true, languages },\n   113→    etag: generateETag({ languages })\n   114→  };\n   115→\n   116→  // Cache profanity bleeps\n   117→  const sounds = getAvailableBleepSounds();\n   118→  STATIC_RESPONSE_CACHE.profanityBleeps = {\n   119→    body: { success: true, sounds },\n   120→    etag: generateETag({ sounds })\n   121→  };\n   122→\n   123→  // Cache export formats\n   124→  const formats = getSupportedFormats();\n   125→  STATIC_RESPONSE_CACHE.exportFormats = {\n   126→    body: { success: true, formats },\n   127→    etag: generateETag({ formats })\n   128→  };\n   129→\n   130→  console.log('[SPLICE] Static response cache initialized');\n   131→}\n   132→\n   133→// Helper to send cached response with ETag\n   134→function sendCachedResponse(req, res, cacheKey) {\n   135→  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n   136→  if (!cached) {\n   137→    return res.status(500).json({ error: 'Cache not initialized' });\n   138→  }\n   139→\n   140→  // Check If-None-Match header for conditional GET\n   141→  const clientETag = req.headers['if-none-match'];\n   142→  if (clientETag === cached.etag) {\n   143→    return res.status(304).end(); // Not Modified\n   144→  }\n   145→\n   146→  // Send cached response with ETag and cache headers\n   147→  res.set('ETag', cached.etag);\n   148→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n   149→  res.json(cached.body);\n   150→}\n   151→\n   152→// =============================================================================\n   153→// Server Configuration\n   154→// =============================================================================\n   155→\n   156→const app = express();\n   157→const PORT = process.env.PORT || 3847;\n   158→\n   159→// HTTPS certificates (generated by mkcert) - only for local development\n   160→let httpsOptions = null;\n   161→if (!isProduction) {\n   162→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n   163→  const certPath = path.join(__dirname, 'localhost+1.pem');\n   164→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n   165→    httpsOptions = {\n   166→      key: fs.readFileSync(keyPath),\n   167→      cert: fs.readFileSync(certPath)\n   168→    };\n   169→  }\n   170→}\n   171→\n   172→// =============================================================================\n   173→// Security Configuration\n   174→// =============================================================================\n   175→\n   176→// CORS whitelist - restrict origins in production\n   177→const CORS_WHITELIST = [\n   178→  'http://localhost:3000',\n   179→  'http://localhost:3847',\n   180→  'https://localhost:3847',\n   181→  'http://127.0.0.1:3000',\n   182→  'http://127.0.0.1:3847',\n   183→  'https://127.0.0.1:3847',\n   184→  'https://splice.app',\n   185→  'https://www.splice.app',\n   186→  'https://splice-api-production.up.railway.app',\n   187→  'https://splice-website.vercel.app',\n   188→  // Adobe CEP/UXP panels run from file:// or bolt://\n   189→  'file://',\n   190→  'bolt://'\n   191→];\n   192→\n   193→const corsOptions = {\n   194→  origin: function (origin, callback) {\n   195→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n   196→    if (!origin) {\n   197→      return callback(null, true);\n   198→    }\n   199→    // Check if origin is in whitelist\n   200→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n   201→      return callback(null, true);\n   202→    }\n   203→    // In development, allow all origins with warning\n   204→    if (!isProduction) {\n   205→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n   206→      return callback(null, true);\n   207→    }\n   208→    // In production, reject non-whitelisted origins\n   209→    console.error(`[CORS] Blocked request from: ${origin}`);\n   210→    return callback(new Error('Not allowed by CORS'));\n   211→  },\n   212→  credentials: true,\n   213→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n   214→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n   215→};\n   216→\n   217→app.use(cors(corsOptions));\n   218→\n   219→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n   220→// This ensures rate limiting and logging use the correct client IP\n   221→if (isProduction) {\n   222→  app.set('trust proxy', 1);\n   223→}\n   224→\n   225→// IP-based rate limiting (100 requests/minute per IP)\n   226→app.use(ipRateLimit);\n   227→\n   228→// Security headers via helmet\n   229→app.use(helmet({\n   230→  contentSecurityPolicy: {\n   231→    directives: {\n   232→      defaultSrc: [\"'self'\"],\n   233→      scriptSrc: [\"'self'\"],\n   234→      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n   235→      imgSrc: [\"'self'\", 'data:', 'https:'],\n   236→      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n   237→      fontSrc: [\"'self'\"],\n   238→      objectSrc: [\"'none'\"],\n   239→      mediaSrc: [\"'self'\"],\n   240→      frameSrc: [\"'none'\"]\n   241→    }\n   242→  },\n   243→  hsts: {\n   244→    maxAge: 31536000,\n   245→    includeSubDomains: true,\n   246→    preload: true\n   247→  },\n   248→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n   249→  noSniff: true,\n   250→  xssFilter: true,\n   251→  hidePoweredBy: true\n   252→}));\n   253→\n   254→// Helper to determine tier from price ID with logging\n   255→// Supports both monthly and annual pricing\n   256→function getTierFromPriceId(priceId) {\n   257→  // Monthly prices\n   258→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   259→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   260→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   261→\n   262→  // Annual prices (same tier, just different billing period)\n   263→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n   264→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n   265→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n   266→\n   267→  // Log unknown price ID for debugging\n   268→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   269→  return 'starter';\n   270→}\n   271→\n   272→// =============================================================================\n   273→// Stripe Webhook (must be before express.json())\n   274→// =============================================================================\n   275→\n   276→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   277→  const sig = req.headers['stripe-signature'];\n   278→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   279→\n   280→  let event;\n   281→\n   282→  try {\n   283→    if (webhookSecret) {\n   284→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   285→    } else if (isProduction) {\n   286→      // SECURITY: Reject unsigned webhooks in production\n   287→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   288→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   289→    } else {\n   290→      // For local development testing only\n   291→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   292→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   293→      event = JSON.parse(bodyString);\n   294→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   295→    }\n   296→  } catch (err) {\n   297→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   298→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   299→  }\n   300→\n   301→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   302→\n   303→  // Idempotency check - skip if already processed\n   304→  if (await usageTracking.isEventProcessed(event.id)) {\n   305→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   306→    return res.json({ received: true, skipped: true });\n   307→  }\n   308→\n   309→  try {\n   310→    switch (event.type) {\n   311→      case 'customer.subscription.created':\n   312→      case 'customer.subscription.updated': {\n   313→        const subscription = event.data.object;\n   314→        const customerId = subscription.customer;\n   315→\n   316→        // Validate customerId\n   317→        if (!customerId) {\n   318→          console.error('[SPLICE] Missing customer ID in subscription event');\n   319→          return res.status(400).json({ error: 'Missing customer ID' });\n   320→        }\n   321→\n   322→        // Get tier from price ID\n   323→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   324→        const tier = getTierFromPriceId(priceId);\n   325→\n   326→        // Update user tier and reset hours\n   327→        await usageTracking.updateTier(customerId, tier);\n   328→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   329→\n   330→        // Initialize music credits for new subscriptions\n   331→        if (event.type === 'customer.subscription.created') {\n   332→          await usageTracking.resetMusicCredits(customerId, tier);\n   333→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n   334→        }\n   335→\n   336→        // Update trial end date if present\n   337→        if (subscription.trial_end) {\n   338→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n   339→        }\n   340→\n   341→        // Generate license key for new subscriptions with retry and delivery\n   342→        if (event.type === 'customer.subscription.created') {\n   343→          let licenseResult = null;\n   344→          let retryCount = 0;\n   345→          const maxRetries = 3;\n   346→\n   347→          // Retry mechanism for license key generation\n   348→          while (retryCount < maxRetries) {\n   349→            licenseResult = await licenseService.generateLicenseKey(customerId);\n   350→            if (licenseResult.success) {\n   351→              break;\n   352→            }\n   353→            retryCount++;\n   354→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n   355→            // Wait before retry (exponential backoff)\n   356→            if (retryCount < maxRetries) {\n   357→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n   358→            }\n   359→          }\n   360→\n   361→          if (licenseResult && licenseResult.success) {\n   362→            // SECURITY: Mask license key in logs\n   363→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n   364→\n   365→            // Store license key in Stripe subscription metadata as backup\n   366→            try {\n   367→              await stripe.subscriptions.update(subscription.id, {\n   368→                metadata: {\n   369→                  license_key: licenseResult.key,\n   370→                  license_generated_at: new Date().toISOString()\n   371→                }\n   372→              });\n   373→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n   374→            } catch (stripeErr) {\n   375→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n   376→            }\n   377→\n   378→            // Get customer email and send license key\n   379→            try {\n   380→              const customer = await stripe.customers.retrieve(customerId);\n   381→              if (customer.email) {\n   382→                // SECURITY: Mask sensitive data in logs\n   383→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n   384→\n   385→                // Send license key email\n   386→                try {\n   387→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n   388→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n   389→                } catch (sendErr) {\n   390→                  // Log but don't fail - license is stored in Stripe metadata as backup\n   391→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n   392→                }\n   393→\n   394→                // Store email in database for reference\n   395→                await usageTracking.updateTier(customerId, tier, customer.email);\n   396→              } else {\n   397→                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n   398→              }\n   399→            } catch (emailErr) {\n   400→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n   401→            }\n   402→          } else {\n   403→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n   404→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n   405→            console.error(`[SPLICE] ${errorMsg}`);\n   406→            return res.status(500).json({ error: errorMsg });\n   407→          }\n   408→        }\n   409→        break;\n   410→      }\n   411→\n   412→      case 'customer.subscription.deleted': {\n   413→        const subscription = event.data.object;\n   414→        const customerId = subscription.customer;\n   415→\n   416→        // Validate customerId\n   417→        if (!customerId) {\n   418→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   419→          return res.status(400).json({ error: 'Missing customer ID' });\n   420→        }\n   421→\n   422→        // Downgrade to cancelled (0 hours)\n   423→        await usageTracking.updateTier(customerId, 'cancelled');\n   424→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   425→        break;\n   426→      }\n   427→\n   428→      case 'invoice.payment_succeeded': {\n   429→        const invoice = event.data.object;\n   430→        const customerId = invoice.customer;\n   431→        const subscriptionId = invoice.subscription;\n   432→\n   433→        // Validate customerId\n   434→        if (!customerId) {\n   435→          console.error('[SPLICE] Missing customer ID in invoice event');\n   436→          return res.status(400).json({ error: 'Missing customer ID' });\n   437→        }\n   438→\n   439→        // Reset hours on successful payment (new billing period)\n   440→        let tier = 'starter';\n   441→        if (subscriptionId) {\n   442→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   443→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   444→          tier = getTierFromPriceId(priceId);\n   445→\n   446→          await usageTracking.resetHours(customerId, tier);\n   447→          await usageTracking.resetMusicCredits(customerId, tier);\n   448→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n   449→        }\n   450→\n   451→        // Check for affiliate coupon and record commission\n   452→        const discount = invoice.discount;\n   453→        if (discount && discount.coupon) {\n   454→          const couponId = discount.coupon.id;\n   455→          // Check if this is an affiliate code (like JIMMYN)\n   456→          if (referralService.AFFILIATE_CODES[couponId]) {\n   457→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n   458→            await referralService.recordAffiliateCommission(\n   459→              couponId,\n   460→              customerId,\n   461→              amountPaid,\n   462→              tier\n   463→            );\n   464→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n   465→          }\n   466→        }\n   467→        break;\n   468→      }\n   469→\n   470→      case 'invoice.payment_failed': {\n   471→        const invoice = event.data.object;\n   472→        const customerId = invoice.customer;\n   473→        const attemptCount = invoice.attempt_count || 1;\n   474→\n   475→        // Validate customerId\n   476→        if (!customerId) {\n   477→          console.error('[SPLICE] Missing customer ID in payment_failed event');\n   478→          return res.status(400).json({ error: 'Missing customer ID' });\n   479→        }\n   480→\n   481→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n   482→\n   483→        // Stripe will retry automatically per retry settings\n   484→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n   485→        // Send warning email on final attempt\n   486→        if (attemptCount >= 3) {\n   487→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n   488→          // Send warning email to customer about impending cancellation\n   489→          try {\n   490→            const customer = await stripe.customers.retrieve(customerId);\n   491→            if (customer.email) {\n   492→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n   493→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n   494→            }\n   495→          } catch (emailErr) {\n   496→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n   497→          }\n   498→        }\n   499→        break;\n   500→      }\n   501→\n   502→      case 'customer.deleted': {\n   503→        const customer = event.data.object;\n   504→        const customerId = customer.id;\n   505→\n   506→        // Validate customerId\n   507→        if (!customerId) {\n   508→          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n   509→          return res.status(400).json({ error: 'Missing customer ID' });\n   510→        }\n   511→\n   512→        // Clean up user data - downgrade to cancelled\n   513→        await usageTracking.updateTier(customerId, 'cancelled');\n   514→        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n   515→        break;\n   516→      }\n   517→\n   518→      default:\n   519→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   520→    }\n   521→\n   522→    // Record event as processed (idempotency)\n   523→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   524→\n   525→    res.json({ received: true });\n   526→  } catch (err) {\n   527→    console.error('[SPLICE] Webhook handler error:', err);\n   528→    res.status(500).json({ error: err.message });\n   529→  }\n   530→});\n   531→\n   532→// Parse JSON body for all other routes\n   533→// SECURITY: Limit JSON body size to prevent DoS attacks\n   534→app.use(express.json({ limit: '10mb' }));\n   535→\n   536→// Parse cookies for CSRF token validation\n   537→app.use(cookieParser());\n   538→\n   539→// =============================================================================\n   540→// Route Configuration Options\n   541→// =============================================================================\n   542→\n   543→const routeOptions = {\n   544→  middleware: {\n   545→    requireCredits,\n   546→    requireFeature,\n   547→    authenticateToken\n   548→  },\n   549→  services: {\n   550→    usageTracking,\n   551→    referralService,\n   552→    licenseService,\n   553→    emailService,\n   554→    stripe\n   555→  },\n   556→  authHelpers: {\n   557→    generateToken,\n   558→    generateRefreshToken,\n   559→    verifyToken,\n   560→    maskSensitiveData,\n   561→    blacklistToken\n   562→  },\n   563→  staticCache: STATIC_RESPONSE_CACHE,\n   564→  sendCachedResponse\n   565→};\n   566→\n   567→// =============================================================================\n   568→// Mount Routes\n   569→// =============================================================================\n   570→\n   571→// Health check and system endpoints (no prefix)\n   572→app.use('/', healthRoutes(routeOptions));\n   573→\n   574→// Core analysis endpoints\n   575→app.use('/', analyzeRoutes(routeOptions));\n   576→app.use('/', silencesRoutes(routeOptions));\n   577→app.use('/', detectionRoutes(routeOptions));\n   578→\n   579→// Export endpoints\n   580→app.use('/export', exportRoutes(routeOptions));\n   581→\n   582→// Multitrack/Multicam endpoints\n   583→app.use('/multitrack', multitrackRoutes(routeOptions));\n   584→\n   585→// Cut list generation\n   586→app.use('/cut-list', cutListRoutes(routeOptions));\n   587→\n   588→// Legacy XML processing endpoint (backwards compatibility)\n   589→const { processXMLFile } = require('./services/xmlProcessor');\n   590→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n   591→  const {\n   592→    xmlPath,\n   593→    silences,\n   594→    removeGaps = true,\n   595→    outputPath = null\n   596→  } = req.body;\n   597→\n   598→  if (!xmlPath) {\n   599→    return res.status(400).json({ error: 'xmlPath is required' });\n   600→  }\n   601→\n   602→  if (!silences || !Array.isArray(silences)) {\n   603→    return res.status(400).json({ error: 'silences array is required' });\n   604→  }\n   605→\n   606→  if (!fs.existsSync(xmlPath)) {\n   607→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n   608→  }\n   609→\n   610→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n   611→\n   612→  try {\n   613→    const result = await processXMLFile(xmlPath, silences, {\n   614→      outputPath,\n   615→      removeGaps\n   616→    });\n   617→\n   618→    res.json({\n   619→      success: true,\n   620→      inputPath: xmlPath,\n   621→      outputPath: result.outputPath,\n   622→      stats: result.stats\n   623→    });\n   624→  } catch (err) {\n   625→    console.error('[SPLICE] XML processing error:', err);\n   626→    res.status(500).json({ error: err.message });\n   627→  }\n   628→});\n   629→\n   630→// Auto zoom endpoints\n   631→app.use('/zoom', zoomRoutes(routeOptions));\n   632→\n   633→// Chapter detection endpoints\n   634→app.use('/chapters', chaptersRoutes(routeOptions));\n   635→\n   636→// YouTube content generation\n   637→app.use('/youtube', youtubeRoutes(routeOptions));\n   638→\n   639→// Animated captions endpoints\n   640→app.use('/captions', captionsRoutes(routeOptions));\n   641→\n   642→// Text-based editing endpoints\n   643→app.use('/text-edit', textEditRoutes(routeOptions));\n   644→\n   645→// Social reframe endpoints\n   646→app.use('/reframe', reframeRoutes(routeOptions));\n   647→app.use('/faces', reframeRoutes.facesRouter(routeOptions));\n   648→\n   649→// Batch processing endpoints\n   650→app.use('/batch', batchRoutes(routeOptions));\n   651→\n   652→// Authentication endpoints\n   653→app.use('/auth', authRoutes(routeOptions));\n   654→\n   655→// Billing and credits endpoints\n   656→app.use('/', billingRoutes(routeOptions));\n   657→\n   658→// Referral system endpoints\n   659→app.use('/referral', referralRoutes(routeOptions));\n   660→\n   661→// License key endpoints\n   662→app.use('/license', licenseRoutes(routeOptions));\n   663→\n   664→// AI Music generation endpoints\n   665→app.use('/music', musicRoutes(routeOptions));\n   666→\n   667→// =============================================================================\n   668→// Start Server\n   669→// =============================================================================\n   670→\n   671→// Track active server for graceful shutdown\n   672→let server = null;\n   673→\n   674→// Initialize database and start server\n   675→async function startServer() {\n   676→  try {\n   677→    await usageTracking.initDatabase();\n   678→    await referralService.initReferralTables();\n   679→    await licenseService.initLicenseTables();\n   680→    console.log('[SPLICE] Database initialized');\n   681→\n   682→    // PERF-FIX: Initialize static response cache at startup\n   683→    initializeStaticCache();\n   684→\n   685→    if (isProduction || !httpsOptions) {\n   686→      // Production: Railway provides TLS termination, use HTTP\n   687→      server = http.createServer(app).listen(PORT, () => {\n   688→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n   689→      });\n   690→    } else {\n   691→      // Development: Use HTTPS with local certificates\n   692→      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n   693→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n   694→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n   695→      });\n   696→    }\n   697→  } catch (err) {\n   698→    console.error('[SPLICE] Failed to start server:', err);\n   699→    process.exit(1);\n   700→  }\n   701→}\n   702→\n   703→// =============================================================================\n   704→// Graceful Shutdown\n   705→// =============================================================================\n   706→\n   707→async function gracefulShutdown(signal) {\n   708→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n   709→\n   710→  // Stop accepting new connections\n   711→  if (server) {\n   712→    server.close(() => {\n   713→      console.log('[SPLICE] HTTP server closed');\n   714→    });\n   715→  }\n   716→\n   717→  // Close database pool\n   718→  try {\n   719→    await usageTracking.closePool();\n   720→    console.log('[SPLICE] Database pool closed');\n   721→  } catch (err) {\n   722→    console.error('[SPLICE] Error closing database pool:', err.message);\n   723→  }\n   724→\n   725→  // Give ongoing requests time to complete (max 10 seconds)\n   726→  setTimeout(() => {\n   727→    console.log('[SPLICE] Graceful shutdown complete');\n   728→    process.exit(0);\n   729→  }, 10000);\n   730→}\n   731→\n   732→// Handle termination signals\n   733→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n   734→process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n   735→\n   736→// Handle uncaught exceptions\n   737→process.on('uncaughtException', (err) => {\n   738→  console.error('[SPLICE] Uncaught exception:', err);\n   739→  gracefulShutdown('uncaughtException');\n   740→});\n   741→\n   742→process.on('unhandledRejection', (reason, promise) => {\n   743→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n   744→});\n   745→\n   746→startServer();\n   747→\n\n</system-reminder>\n","numLines":750,"startLine":1,"totalLines":750}}}
{"parentUuid":"c95b953d-e475-450f-b4ff-f0ae1ea3ec6e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UbeP6VxfwJMftqJqdq24Am","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also check the usageTracking service for database schema validation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9727,"cache_creation_input_tokens":12332,"cache_read_input_tokens":77903,"cache_creation":{"ephemeral_5m_input_tokens":12332,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4RmRVvuufSQkiHWvMf","type":"assistant","uuid":"62574810-5298-422f-99b1-ed956094f435","timestamp":"2025-12-30T02:11:05.271Z"}
{"parentUuid":"62574810-5298-422f-99b1-ed956094f435","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UbeP6VxfwJMftqJqdq24Am","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015hpzqsu7UXvJLjdjZSgMcH","name":"Read","input":{"file_path":"/Users/imorgado/.claude/projects/-Users-imorgado-SPLICE/4c7927f9-7798-44a0-91df-62c31e2c57cc/tool-results/toolu_019CDuEAm1dmvpxw2NK963Tx.txt","limit":500}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9727,"cache_creation_input_tokens":12332,"cache_read_input_tokens":77903,"cache_creation":{"ephemeral_5m_input_tokens":12332,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4RmRVvuufSQkiHWvMf","type":"assistant","uuid":"26cda874-6edf-4ec4-ab8c-2b5468eccaea","timestamp":"2025-12-30T02:11:08.744Z"}
{"parentUuid":"26cda874-6edf-4ec4-ab8c-2b5468eccaea","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015hpzqsu7UXvJLjdjZSgMcH","type":"tool_result","content":"     1→     1→/**\n     2→     2→ * Usage Tracking Service\n     3→     3→ *\n     4→     4→ * Tracks user credit balances and usage for billing.\n     5→     5→ * Uses PostgreSQL for persistence.\n     6→     6→ */\n     7→     7→\n     8→     8→const { Pool } = require('pg');\n     9→     9→const { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n    10→    10→\n    11→    11→// PostgreSQL connection pool with proper limits\n    12→    12→// SSL Configuration:\n    13→    13→// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n    14→    14→// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n    15→    15→// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\n    16→    16→const sslConfig = process.env.NODE_ENV === 'production' ? {\n    17→    17→  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n    18→    18→  ca: process.env.DATABASE_SSL_CA || undefined\n    19→    19→} : false;\n    20→    20→\n    21→    21→const pool = new Pool({\n    22→    22→  connectionString: process.env.DATABASE_URL,\n    23→    23→  ssl: sslConfig,\n    24→    24→  // PERFORMANCE: Set connection pool limits\n    25→    25→  max: 20,                    // Maximum number of clients in the pool\n    26→    26→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n    27→    27→  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n    28→    28→});\n    29→    29→\n    30→    30→// Hours per tier (regular processing)\n    31→    31→// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n    32→    32→// Target margins: 79-82%\n    33→    33→const TIER_HOURS = {\n    34→    34→  starter: 4,    // 4 hrs/month\n    35→    35→  pro: 15,       // 15 hrs/month\n    36→    36→  team: 50,      // 50 hrs/month\n    37→    37→  cancelled: 0\n    38→    38→};\n    39→    39→\n    40→    40→// Overage rate for processing hours beyond included\n    41→    41→const HOURS_OVERAGE_RATE = 2.00; // $2/hour\n    42→    42→\n    43→    43→// Isolation minutes per tier (sized to maintain 80% margins)\n    44→    44→const TIER_ISOLATION_MINUTES = {\n    45→    45→  starter: 0,     // No isolation access\n    46→    46→  pro: 45,        // 45 minutes included\n    47→    47→  team: 180,      // 3 hours included\n    48→    48→  cancelled: 0\n    49→    49→};\n    50→    50→\n    51→    51→// Convert to hours for database storage\n    52→    52→const TIER_ISOLATION_HOURS = {\n    53→    53→  starter: 0,\n    54→    54→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n    55→    55→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n    56→    56→  cancelled: 0\n    57→    57→};\n    58→    58→\n    59→    59→// Overage rate for isolation beyond included minutes\n    60→    60→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n    61→    61→\n    62→    62→/**\n    63→    63→ * Initialize database tables\n    64→    64→ */\n    65→    65→async function initDatabase() {\n    66→    66→  const client = await pool.connect();\n    67→    67→  try {\n    68→    68→    await client.query(`\n    69→    69→      CREATE TABLE IF NOT EXISTS users (\n    70→    70→        id SERIAL PRIMARY KEY,\n    71→    71→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n    72→    72→        email VARCHAR(255),\n    73→    73→        tier VARCHAR(50) DEFAULT 'starter',\n    74→    74→        hours_remaining DECIMAL(10,4) DEFAULT 15,\n    75→    75→        hours_total DECIMAL(10,4) DEFAULT 15,\n    76→    76→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n    77→    77→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n    78→    78→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    79→    79→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    80→    80→      )\n    81→    81→    `);\n    82→    82→\n    83→    83→    // Add isolation columns if they don't exist (for existing databases)\n    84→    84→    await client.query(`\n    85→    85→      DO $$\n    86→    86→      BEGIN\n    87→    87→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n    88→    88→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n    89→    89→        END IF;\n    90→    90→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n    91→    91→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n    92→    92→        END IF;\n    93→    93→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n    94→    94→          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n    95→    95→        END IF;\n    96→    96→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified') THEN\n    97→    97→          ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;\n    98→    98→        END IF;\n    99→    99→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified_at') THEN\n   100→   100→          ALTER TABLE users ADD COLUMN email_verified_at TIMESTAMP;\n   101→   101→        END IF;\n   102→   102→      END $$;\n   103→   103→    `);\n   104→   104→\n   105→   105→    await client.query(`\n   106→   106→      CREATE TABLE IF NOT EXISTS usage_log (\n   107→   107→        id SERIAL PRIMARY KEY,\n   108→   108→        user_id INTEGER REFERENCES users(id),\n   109→   109→        stripe_customer_id VARCHAR(255),\n   110→   110→        audio_duration_seconds DECIMAL(10,2),\n   111→   111→        hours_used DECIMAL(10,6),\n   112→   112→        endpoint VARCHAR(100),\n   113→   113→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   114→   114→      )\n   115→   115→    `);\n   116→   116→\n   117→   117→    await client.query(`\n   118→   118→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n   119→   119→    `);\n   120→   120→\n   121→   121→    await client.query(`\n   122→   122→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n   123→   123→    `);\n   124→   124→\n   125→   125→    // PERFORMANCE: Add composite index for efficient customer usage history queries\n   126→   126→    await client.query(`\n   127→   127→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n   128→   128→      ON usage_log(stripe_customer_id, created_at DESC)\n   129→   129→    `);\n   130→   130→\n   131→   131→    // Webhook events table for idempotency\n   132→   132→    await client.query(`\n   133→   133→      CREATE TABLE IF NOT EXISTS webhook_events (\n   134→   134→        id SERIAL PRIMARY KEY,\n   135→   135→        event_id VARCHAR(255) UNIQUE NOT NULL,\n   136→   136→        event_type VARCHAR(100),\n   137→   137→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   138→   138→      )\n   139→   139→    `);\n   140→   140→\n   141→   141→    await client.query(`\n   142→   142→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n   143→   143→    `);\n   144→   144→\n   145→   145→    console.log('[UsageTracking] Database initialized');\n   146→   146→  } finally {\n   147→   147→    client.release();\n   148→   148→  }\n   149→   149→}\n   150→   150→\n   151→   151→/**\n   152→   152→ * Get or create a user by Stripe customer ID\n   153→   153→ * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n   154→   154→ */\n   155→   155→async function getOrCreateUser(stripeCustomerId, email = null) {\n   156→   156→  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n   157→   157→  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n   158→   158→  const result = await pool.query(\n   159→   159→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   160→   160→     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   161→   161→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   162→   162→     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n   163→   163→     RETURNING *`,\n   164→   164→    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n   165→   165→  );\n   166→   166→\n   167→   167→  return result.rows[0];\n   168→   168→}\n   169→   169→\n   170→   170→/**\n   171→   171→ * Check if a customer exists in the database (without creating)\n   172→   172→ * SECURITY: Used to validate legacy auth attempts\n   173→   173→ */\n   174→   174→async function customerExists(stripeCustomerId) {\n   175→   175→  if (!stripeCustomerId) return false;\n   176→   176→\n   177→   177→  try {\n   178→   178→    const result = await pool.query(\n   179→   179→      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n   180→   180→      [stripeCustomerId]\n   181→   181→    );\n   182→   182→    return result.rows.length > 0;\n   183→   183→  } catch (err) {\n   184→   184→    console.error('[SPLICE] customerExists check failed:', err.message);\n   185→   185→    return false;\n   186→   186→  }\n   187→   187→}\n   188→   188→\n   189→   189→/**\n   190→   190→ * Get user's current credit balance\n   191→   191→ */\n   192→   192→async function getBalance(stripeCustomerId) {\n   193→   193→  const user = await getOrCreateUser(stripeCustomerId);\n   194→   194→  const hoursTotal = parseFloat(user.hours_total);\n   195→   195→  const hoursRemaining = parseFloat(user.hours_remaining);\n   196→   196→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   197→   197→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   198→   198→\n   199→   199→  // Tier display names\n   200→   200→  const tierNames = {\n   201→   201→    starter: 'Starter',\n   202→   202→    pro: 'Pro',\n   203→   203→    team: 'Team',\n   204→   204→    cancelled: 'Cancelled'\n   205→   205→  };\n   206→   206→\n   207→   207→  // Calculate trial days remaining\n   208→   208→  let trialDaysRemaining = null;\n   209→   209→  let isOnTrial = false;\n   210→   210→  if (user.trial_end) {\n   211→   211→    const trialEnd = new Date(user.trial_end);\n   212→   212→    const now = new Date();\n   213→   213→    const diffMs = trialEnd.getTime() - now.getTime();\n   214→   214→    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n   215→   215→    if (diffDays > 0) {\n   216→   216→      trialDaysRemaining = diffDays;\n   217→   217→      isOnTrial = true;\n   218→   218→    }\n   219→   219→  }\n   220→   220→\n   221→   221→  return {\n   222→   222→    hoursRemaining,\n   223→   223→    hoursTotal,\n   224→   224→    isolationHoursRemaining,\n   225→   225→    isolationHoursTotal,\n   226→   226→    tier: user.tier,\n   227→   227→    tierName: tierNames[user.tier] || user.tier,\n   228→   228→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   229→   229→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   230→   230→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   231→   231→    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   232→   232→    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n   233→   233→    trialDaysRemaining,\n   234→   234→    isOnTrial,\n   235→   235→    email: user.email,\n   236→   236→    emailVerified: user.email_verified === true\n   237→   237→  };\n   238→   238→}\n   239→   239→\n   240→   240→/**\n   241→   241→ * Check if user has enough credits for estimated duration\n   242→   242→ */\n   243→   243→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n   244→   244→  const balance = await getBalance(stripeCustomerId);\n   245→   245→  const estimatedHours = estimatedSeconds / 3600;\n   246→   246→  return balance.hoursRemaining >= estimatedHours;\n   247→   247→}\n   248→   248→\n   249→   249→/**\n   250→   250→ * Reserve credits atomically using SELECT ... FOR UPDATE\n   251→   251→ * This prevents race conditions where multiple requests pass credit check\n   252→   252→ * before any deduction occurs.\n   253→   253→ *\n   254→   254→ * @param {string} stripeCustomerId - Customer ID\n   255→   255→ * @param {number} estimatedSeconds - Estimated processing time in seconds\n   256→   256→ * @param {string} endpoint - Endpoint name for tracking\n   257→   257→ * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n   258→   258→ */\n   259→   259→async function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n   260→   260→  const estimatedHours = estimatedSeconds / 3600;\n   261→   261→  const client = await pool.connect();\n   262→   262→\n   263→   263→  try {\n   264→   264→    await client.query('BEGIN');\n   265→   265→\n   266→   266→    // Lock the row for this customer - prevents concurrent modifications\n   267→   267→    const result = await client.query(\n   268→   268→      `SELECT id, hours_remaining FROM users\n   269→   269→       WHERE stripe_customer_id = $1\n   270→   270→       FOR UPDATE`,\n   271→   271→      [stripeCustomerId]\n   272→   272→    );\n   273→   273→\n   274→   274→    if (result.rows.length === 0) {\n   275→   275→      // Create user if doesn't exist (within transaction)\n   276→   276→      const newUser = await client.query(\n   277→   277→        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n   278→   278→         VALUES ($1, 'starter', $2, $2)\n   279→   279→         RETURNING id, hours_remaining`,\n   280→   280→        [stripeCustomerId, TIER_HOURS.starter]\n   281→   281→      );\n   282→   282→      result.rows = newUser.rows;\n   283→   283→    }\n   284→   284→\n   285→   285→    const user = result.rows[0];\n   286→   286→    const hoursRemaining = parseFloat(user.hours_remaining);\n   287→   287→\n   288→   288→    // Check if enough credits\n   289→   289→    if (hoursRemaining < estimatedHours) {\n   290→   290→      await client.query('ROLLBACK');\n   291→   291→      return {\n   292→   292→        success: false,\n   293→   293→        error: 'Insufficient credits',\n   294→   294→        hoursRemaining,\n   295→   295→        hoursRequired: estimatedHours\n   296→   296→      };\n   297→   297→    }\n   298→   298→\n   299→   299→    // Generate unique reservation ID\n   300→   300→    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   301→   301→\n   302→   302→    // Reserve credits by deducting the estimated amount\n   303→   303→    await client.query(\n   304→   304→      `UPDATE users\n   305→   305→       SET hours_remaining = hours_remaining - $1,\n   306→   306→           updated_at = CURRENT_TIMESTAMP\n   307→   307→       WHERE stripe_customer_id = $2`,\n   308→   308→      [estimatedHours, stripeCustomerId]\n   309→   309→    );\n   310→   310→\n   311→   311→    // Log the reservation\n   312→   312→    await client.query(\n   313→   313→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   314→   314→       VALUES ($1, $2, $3, $4, $5)`,\n   315→   315→      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n   316→   316→    );\n   317→   317→\n   318→   318→    await client.query('COMMIT');\n   319→   319→\n   320→   320→    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n   321→   321→\n   322→   322→    return {\n   323→   323→      success: true,\n   324→   324→      reservationId,\n   325→   325→      hoursReserved: estimatedHours,\n   326→   326→      hoursRemaining: hoursRemaining - estimatedHours\n   327→   327→    };\n   328→   328→  } catch (err) {\n   329→   329→    await client.query('ROLLBACK');\n   330→   330→    console.error('[UsageTracking] Reservation error:', err);\n   331→   331→    throw err;\n   332→   332→  } finally {\n   333→   333→    client.release();\n   334→   334→  }\n   335→   335→}\n   336→   336→\n   337→   337→/**\n   338→   338→ * Confirm a reservation (finalize usage) or adjust for actual duration\n   339→   339→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   340→   340→ *\n   341→   341→ * @param {string} stripeCustomerId - Customer ID\n   342→   342→ * @param {number} actualSeconds - Actual processing time in seconds\n   343→   343→ * @param {number} reservedSeconds - Originally reserved seconds\n   344→   344→ * @param {string} endpoint - Endpoint name\n   345→   345→ * @returns {Promise<object>} Updated balance\n   346→   346→ */\n   347→   347→async function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n   348→   348→  const actualHours = actualSeconds / 3600;\n   349→   349→  const reservedHours = reservedSeconds / 3600;\n   350→   350→  const difference = reservedHours - actualHours;\n   351→   351→\n   352→   352→  const client = await pool.connect();\n   353→   353→  try {\n   354→   354→    await client.query('BEGIN');\n   355→   355→\n   356→   356→    // Lock the row and get current state\n   357→   357→    const result = await client.query(\n   358→   358→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   359→   359→       FROM users\n   360→   360→       WHERE stripe_customer_id = $1\n   361→   361→       FOR UPDATE`,\n   362→   362→      [stripeCustomerId]\n   363→   363→    );\n   364→   364→\n   365→   365→    if (result.rows.length === 0) {\n   366→   366→      await client.query('ROLLBACK');\n   367→   367→      throw new Error('User not found');\n   368→   368→    }\n   369→   369→\n   370→   370→    let user = result.rows[0];\n   371→   371→\n   372→   372→    // If actual usage was less than reserved, refund the difference\n   373→   373→    if (difference > 0) {\n   374→   374→      const updateResult = await client.query(\n   375→   375→        `UPDATE users\n   376→   376→         SET hours_remaining = hours_remaining + $1,\n   377→   377→             updated_at = CURRENT_TIMESTAMP\n   378→   378→         WHERE stripe_customer_id = $2\n   379→   379→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   380→   380→        [difference, stripeCustomerId]\n   381→   381→      );\n   382→   382→      user = { ...user, ...updateResult.rows[0] };\n   383→   383→\n   384→   384→      // Log the adjustment\n   385→   385→      await client.query(\n   386→   386→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   387→   387→         VALUES ($1, $2, $3, $4, $5)`,\n   388→   388→        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n   389→   389→      );\n   390→   390→    } else if (difference < 0) {\n   391→   391→      // Actual usage was more than reserved - deduct the extra\n   392→   392→      const updateResult = await client.query(\n   393→   393→        `UPDATE users\n   394→   394→         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   395→   395→             updated_at = CURRENT_TIMESTAMP\n   396→   396→         WHERE stripe_customer_id = $2\n   397→   397→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   398→   398→        [-difference, stripeCustomerId]\n   399→   399→      );\n   400→   400→      user = { ...user, ...updateResult.rows[0] };\n   401→   401→\n   402→   402→      // Log the additional usage\n   403→   403→      await client.query(\n   404→   404→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   405→   405→         VALUES ($1, $2, $3, $4, $5)`,\n   406→   406→        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n   407→   407→      );\n   408→   408→    }\n   409→   409→\n   410→   410→    await client.query('COMMIT');\n   411→   411→\n   412→   412→    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n   413→   413→\n   414→   414→    // Build balance from data we already have (no extra SELECT needed)\n   415→   415→    const hoursTotal = parseFloat(user.hours_total);\n   416→   416→    const hoursRemaining = parseFloat(user.hours_remaining);\n   417→   417→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   418→   418→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   419→   419→\n   420→   420→    const tierNames = {\n   421→   421→      starter: 'Starter',\n   422→   422→      pro: 'Pro',\n   423→   423→      team: 'Team',\n   424→   424→      cancelled: 'Cancelled'\n   425→   425→    };\n   426→   426→\n   427→   427→    return {\n   428→   428→      hoursRemaining,\n   429→   429→      hoursTotal,\n   430→   430→      isolationHoursRemaining,\n   431→   431→      isolationHoursTotal,\n   432→   432→      tier: user.tier,\n   433→   433→      tierName: tierNames[user.tier] || user.tier,\n   434→   434→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   435→   435→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   436→   436→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   437→   437→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   438→   438→    };\n   439→   439→  } catch (err) {\n   440→   440→    await client.query('ROLLBACK');\n   441→   441→    throw err;\n   442→   442→  } finally {\n   443→   443→    client.release();\n   444→   444→  }\n   445→   445→}\n   446→   446→\n   447→   447→/**\n   448→   448→ * Release a reservation (refund credits on processing failure)\n   449→   449→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   450→   450→ *\n   451→   451→ * @param {string} stripeCustomerId - Customer ID\n   452→   452→ * @param {number} reservedSeconds - Originally reserved seconds\n   453→   453→ * @param {string} endpoint - Endpoint name\n   454→   454→ * @param {string} reason - Reason for release\n   455→   455→ * @returns {Promise<object>} Updated balance\n   456→   456→ */\n   457→   457→async function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n   458→   458→  const reservedHours = reservedSeconds / 3600;\n   459→   459→\n   460→   460→  const client = await pool.connect();\n   461→   461→  try {\n   462→   462→    await client.query('BEGIN');\n   463→   463→\n   464→   464→    // Lock the row and get id for logging\n   465→   465→    const result = await client.query(\n   466→   466→      `SELECT id FROM users\n   467→   467→       WHERE stripe_customer_id = $1\n   468→   468→       FOR UPDATE`,\n   469→   469→      [stripeCustomerId]\n   470→   470→    );\n   471→   471→\n   472→   472→    if (result.rows.length === 0) {\n   473→   473→      await client.query('ROLLBACK');\n   474→   474→      throw new Error('User not found');\n   475→   475→    }\n   476→   476→\n   477→   477→    const userId = result.rows[0].id;\n   478→   478→\n   479→   479→    // Refund the reserved amount with RETURNING\n   480→   480→    const updateResult = await client.query(\n   481→   481→      `UPDATE users\n   482→   482→       SET hours_remaining = hours_remaining + $1,\n   483→   483→           updated_at = CURRENT_TIMESTAMP\n   484→   484→       WHERE stripe_customer_id = $2\n   485→   485→       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   486→   486→      [reservedHours, stripeCustomerId]\n   487→   487→    );\n   488→   488→\n   489→   489→    const user = updateResult.rows[0];\n   490→   490→\n   491→   491→    // Log the refund\n   492→   492→    await client.query(\n   493→   493→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   494→   494→       VALUES ($1, $2, $3, $4, $5)`,\n   495→   495→      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n   496→   496→    );\n   497→   497→\n   498→   498→    await client.query('COMMIT');\n   499→   499→\n   500→   500→    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n\n</system-reminder>\n"}]},"uuid":"29544240-0327-45e0-9b46-c958a69306d1","timestamp":"2025-12-30T02:11:08.801Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/.claude/projects/-Users-imorgado-SPLICE/4c7927f9-7798-44a0-91df-62c31e2c57cc/tool-results/toolu_019CDuEAm1dmvpxw2NK963Tx.txt","content":"     1→/**\n     2→ * Usage Tracking Service\n     3→ *\n     4→ * Tracks user credit balances and usage for billing.\n     5→ * Uses PostgreSQL for persistence.\n     6→ */\n     7→\n     8→const { Pool } = require('pg');\n     9→const { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n    10→\n    11→// PostgreSQL connection pool with proper limits\n    12→// SSL Configuration:\n    13→// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n    14→// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n    15→// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\n    16→const sslConfig = process.env.NODE_ENV === 'production' ? {\n    17→  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n    18→  ca: process.env.DATABASE_SSL_CA || undefined\n    19→} : false;\n    20→\n    21→const pool = new Pool({\n    22→  connectionString: process.env.DATABASE_URL,\n    23→  ssl: sslConfig,\n    24→  // PERFORMANCE: Set connection pool limits\n    25→  max: 20,                    // Maximum number of clients in the pool\n    26→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n    27→  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n    28→});\n    29→\n    30→// Hours per tier (regular processing)\n    31→// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n    32→// Target margins: 79-82%\n    33→const TIER_HOURS = {\n    34→  starter: 4,    // 4 hrs/month\n    35→  pro: 15,       // 15 hrs/month\n    36→  team: 50,      // 50 hrs/month\n    37→  cancelled: 0\n    38→};\n    39→\n    40→// Overage rate for processing hours beyond included\n    41→const HOURS_OVERAGE_RATE = 2.00; // $2/hour\n    42→\n    43→// Isolation minutes per tier (sized to maintain 80% margins)\n    44→const TIER_ISOLATION_MINUTES = {\n    45→  starter: 0,     // No isolation access\n    46→  pro: 45,        // 45 minutes included\n    47→  team: 180,      // 3 hours included\n    48→  cancelled: 0\n    49→};\n    50→\n    51→// Convert to hours for database storage\n    52→const TIER_ISOLATION_HOURS = {\n    53→  starter: 0,\n    54→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n    55→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n    56→  cancelled: 0\n    57→};\n    58→\n    59→// Overage rate for isolation beyond included minutes\n    60→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n    61→\n    62→/**\n    63→ * Initialize database tables\n    64→ */\n    65→async function initDatabase() {\n    66→  const client = await pool.connect();\n    67→  try {\n    68→    await client.query(`\n    69→      CREATE TABLE IF NOT EXISTS users (\n    70→        id SERIAL PRIMARY KEY,\n    71→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n    72→        email VARCHAR(255),\n    73→        tier VARCHAR(50) DEFAULT 'starter',\n    74→        hours_remaining DECIMAL(10,4) DEFAULT 15,\n    75→        hours_total DECIMAL(10,4) DEFAULT 15,\n    76→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n    77→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n    78→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    79→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    80→      )\n    81→    `);\n    82→\n    83→    // Add isolation columns if they don't exist (for existing databases)\n    84→    await client.query(`\n    85→      DO $$\n    86→      BEGIN\n    87→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n    88→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n    89→        END IF;\n    90→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n    91→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n    92→        END IF;\n    93→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n    94→          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n    95→        END IF;\n    96→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified') THEN\n    97→          ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;\n    98→        END IF;\n    99→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified_at') THEN\n   100→          ALTER TABLE users ADD COLUMN email_verified_at TIMESTAMP;\n   101→        END IF;\n   102→      END $$;\n   103→    `);\n   104→\n   105→    await client.query(`\n   106→      CREATE TABLE IF NOT EXISTS usage_log (\n   107→        id SERIAL PRIMARY KEY,\n   108→        user_id INTEGER REFERENCES users(id),\n   109→        stripe_customer_id VARCHAR(255),\n   110→        audio_duration_seconds DECIMAL(10,2),\n   111→        hours_used DECIMAL(10,6),\n   112→        endpoint VARCHAR(100),\n   113→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   114→      )\n   115→    `);\n   116→\n   117→    await client.query(`\n   118→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n   119→    `);\n   120→\n   121→    await client.query(`\n   122→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n   123→    `);\n   124→\n   125→    // PERFORMANCE: Add composite index for efficient customer usage history queries\n   126→    await client.query(`\n   127→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n   128→      ON usage_log(stripe_customer_id, created_at DESC)\n   129→    `);\n   130→\n   131→    // Webhook events table for idempotency\n   132→    await client.query(`\n   133→      CREATE TABLE IF NOT EXISTS webhook_events (\n   134→        id SERIAL PRIMARY KEY,\n   135→        event_id VARCHAR(255) UNIQUE NOT NULL,\n   136→        event_type VARCHAR(100),\n   137→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   138→      )\n   139→    `);\n   140→\n   141→    await client.query(`\n   142→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n   143→    `);\n   144→\n   145→    console.log('[UsageTracking] Database initialized');\n   146→  } finally {\n   147→    client.release();\n   148→  }\n   149→}\n   150→\n   151→/**\n   152→ * Get or create a user by Stripe customer ID\n   153→ * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n   154→ */\n   155→async function getOrCreateUser(stripeCustomerId, email = null) {\n   156→  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n   157→  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n   158→  const result = await pool.query(\n   159→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   160→     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   161→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   162→     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n   163→     RETURNING *`,\n   164→    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n   165→  );\n   166→\n   167→  return result.rows[0];\n   168→}\n   169→\n   170→/**\n   171→ * Check if a customer exists in the database (without creating)\n   172→ * SECURITY: Used to validate legacy auth attempts\n   173→ */\n   174→async function customerExists(stripeCustomerId) {\n   175→  if (!stripeCustomerId) return false;\n   176→\n   177→  try {\n   178→    const result = await pool.query(\n   179→      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n   180→      [stripeCustomerId]\n   181→    );\n   182→    return result.rows.length > 0;\n   183→  } catch (err) {\n   184→    console.error('[SPLICE] customerExists check failed:', err.message);\n   185→    return false;\n   186→  }\n   187→}\n   188→\n   189→/**\n   190→ * Get user's current credit balance\n   191→ */\n   192→async function getBalance(stripeCustomerId) {\n   193→  const user = await getOrCreateUser(stripeCustomerId);\n   194→  const hoursTotal = parseFloat(user.hours_total);\n   195→  const hoursRemaining = parseFloat(user.hours_remaining);\n   196→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   197→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   198→\n   199→  // Tier display names\n   200→  const tierNames = {\n   201→    starter: 'Starter',\n   202→    pro: 'Pro',\n   203→    team: 'Team',\n   204→    cancelled: 'Cancelled'\n   205→  };\n   206→\n   207→  // Calculate trial days remaining\n   208→  let trialDaysRemaining = null;\n   209→  let isOnTrial = false;\n   210→  if (user.trial_end) {\n   211→    const trialEnd = new Date(user.trial_end);\n   212→    const now = new Date();\n   213→    const diffMs = trialEnd.getTime() - now.getTime();\n   214→    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n   215→    if (diffDays > 0) {\n   216→      trialDaysRemaining = diffDays;\n   217→      isOnTrial = true;\n   218→    }\n   219→  }\n   220→\n   221→  return {\n   222→    hoursRemaining,\n   223→    hoursTotal,\n   224→    isolationHoursRemaining,\n   225→    isolationHoursTotal,\n   226→    tier: user.tier,\n   227→    tierName: tierNames[user.tier] || user.tier,\n   228→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   229→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   230→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   231→    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   232→    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n   233→    trialDaysRemaining,\n   234→    isOnTrial,\n   235→    email: user.email,\n   236→    emailVerified: user.email_verified === true\n   237→  };\n   238→}\n   239→\n   240→/**\n   241→ * Check if user has enough credits for estimated duration\n   242→ */\n   243→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n   244→  const balance = await getBalance(stripeCustomerId);\n   245→  const estimatedHours = estimatedSeconds / 3600;\n   246→  return balance.hoursRemaining >= estimatedHours;\n   247→}\n   248→\n   249→/**\n   250→ * Reserve credits atomically using SELECT ... FOR UPDATE\n   251→ * This prevents race conditions where multiple requests pass credit check\n   252→ * before any deduction occurs.\n   253→ *\n   254→ * @param {string} stripeCustomerId - Customer ID\n   255→ * @param {number} estimatedSeconds - Estimated processing time in seconds\n   256→ * @param {string} endpoint - Endpoint name for tracking\n   257→ * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n   258→ */\n   259→async function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n   260→  const estimatedHours = estimatedSeconds / 3600;\n   261→  const client = await pool.connect();\n   262→\n   263→  try {\n   264→    await client.query('BEGIN');\n   265→\n   266→    // Lock the row for this customer - prevents concurrent modifications\n   267→    const result = await client.query(\n   268→      `SELECT id, hours_remaining FROM users\n   269→       WHERE stripe_customer_id = $1\n   270→       FOR UPDATE`,\n   271→      [stripeCustomerId]\n   272→    );\n   273→\n   274→    if (result.rows.length === 0) {\n   275→      // Create user if doesn't exist (within transaction)\n   276→      const newUser = await client.query(\n   277→        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n   278→         VALUES ($1, 'starter', $2, $2)\n   279→         RETURNING id, hours_remaining`,\n   280→        [stripeCustomerId, TIER_HOURS.starter]\n   281→      );\n   282→      result.rows = newUser.rows;\n   283→    }\n   284→\n   285→    const user = result.rows[0];\n   286→    const hoursRemaining = parseFloat(user.hours_remaining);\n   287→\n   288→    // Check if enough credits\n   289→    if (hoursRemaining < estimatedHours) {\n   290→      await client.query('ROLLBACK');\n   291→      return {\n   292→        success: false,\n   293→        error: 'Insufficient credits',\n   294→        hoursRemaining,\n   295→        hoursRequired: estimatedHours\n   296→      };\n   297→    }\n   298→\n   299→    // Generate unique reservation ID\n   300→    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   301→\n   302→    // Reserve credits by deducting the estimated amount\n   303→    await client.query(\n   304→      `UPDATE users\n   305→       SET hours_remaining = hours_remaining - $1,\n   306→           updated_at = CURRENT_TIMESTAMP\n   307→       WHERE stripe_customer_id = $2`,\n   308→      [estimatedHours, stripeCustomerId]\n   309→    );\n   310→\n   311→    // Log the reservation\n   312→    await client.query(\n   313→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   314→       VALUES ($1, $2, $3, $4, $5)`,\n   315→      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n   316→    );\n   317→\n   318→    await client.query('COMMIT');\n   319→\n   320→    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n   321→\n   322→    return {\n   323→      success: true,\n   324→      reservationId,\n   325→      hoursReserved: estimatedHours,\n   326→      hoursRemaining: hoursRemaining - estimatedHours\n   327→    };\n   328→  } catch (err) {\n   329→    await client.query('ROLLBACK');\n   330→    console.error('[UsageTracking] Reservation error:', err);\n   331→    throw err;\n   332→  } finally {\n   333→    client.release();\n   334→  }\n   335→}\n   336→\n   337→/**\n   338→ * Confirm a reservation (finalize usage) or adjust for actual duration\n   339→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   340→ *\n   341→ * @param {string} stripeCustomerId - Customer ID\n   342→ * @param {number} actualSeconds - Actual processing time in seconds\n   343→ * @param {number} reservedSeconds - Originally reserved seconds\n   344→ * @param {string} endpoint - Endpoint name\n   345→ * @returns {Promise<object>} Updated balance\n   346→ */\n   347→async function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n   348→  const actualHours = actualSeconds / 3600;\n   349→  const reservedHours = reservedSeconds / 3600;\n   350→  const difference = reservedHours - actualHours;\n   351→\n   352→  const client = await pool.connect();\n   353→  try {\n   354→    await client.query('BEGIN');\n   355→\n   356→    // Lock the row and get current state\n   357→    const result = await client.query(\n   358→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   359→       FROM users\n   360→       WHERE stripe_customer_id = $1\n   361→       FOR UPDATE`,\n   362→      [stripeCustomerId]\n   363→    );\n   364→\n   365→    if (result.rows.length === 0) {\n   366→      await client.query('ROLLBACK');\n   367→      throw new Error('User not found');\n   368→    }\n   369→\n   370→    let user = result.rows[0];\n   371→\n   372→    // If actual usage was less than reserved, refund the difference\n   373→    if (difference > 0) {\n   374→      const updateResult = await client.query(\n   375→        `UPDATE users\n   376→         SET hours_remaining = hours_remaining + $1,\n   377→             updated_at = CURRENT_TIMESTAMP\n   378→         WHERE stripe_customer_id = $2\n   379→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   380→        [difference, stripeCustomerId]\n   381→      );\n   382→      user = { ...user, ...updateResult.rows[0] };\n   383→\n   384→      // Log the adjustment\n   385→      await client.query(\n   386→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   387→         VALUES ($1, $2, $3, $4, $5)`,\n   388→        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n   389→      );\n   390→    } else if (difference < 0) {\n   391→      // Actual usage was more than reserved - deduct the extra\n   392→      const updateResult = await client.query(\n   393→        `UPDATE users\n   394→         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   395→             updated_at = CURRENT_TIMESTAMP\n   396→         WHERE stripe_customer_id = $2\n   397→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   398→        [-difference, stripeCustomerId]\n   399→      );\n   400→      user = { ...user, ...updateResult.rows[0] };\n   401→\n   402→      // Log the additional usage\n   403→      await client.query(\n   404→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   405→         VALUES ($1, $2, $3, $4, $5)`,\n   406→        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n   407→      );\n   408→    }\n   409→\n   410→    await client.query('COMMIT');\n   411→\n   412→    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n   413→\n   414→    // Build balance from data we already have (no extra SELECT needed)\n   415→    const hoursTotal = parseFloat(user.hours_total);\n   416→    const hoursRemaining = parseFloat(user.hours_remaining);\n   417→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   418→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   419→\n   420→    const tierNames = {\n   421→      starter: 'Starter',\n   422→      pro: 'Pro',\n   423→      team: 'Team',\n   424→      cancelled: 'Cancelled'\n   425→    };\n   426→\n   427→    return {\n   428→      hoursRemaining,\n   429→      hoursTotal,\n   430→      isolationHoursRemaining,\n   431→      isolationHoursTotal,\n   432→      tier: user.tier,\n   433→      tierName: tierNames[user.tier] || user.tier,\n   434→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   435→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   436→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   437→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   438→    };\n   439→  } catch (err) {\n   440→    await client.query('ROLLBACK');\n   441→    throw err;\n   442→  } finally {\n   443→    client.release();\n   444→  }\n   445→}\n   446→\n   447→/**\n   448→ * Release a reservation (refund credits on processing failure)\n   449→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   450→ *\n   451→ * @param {string} stripeCustomerId - Customer ID\n   452→ * @param {number} reservedSeconds - Originally reserved seconds\n   453→ * @param {string} endpoint - Endpoint name\n   454→ * @param {string} reason - Reason for release\n   455→ * @returns {Promise<object>} Updated balance\n   456→ */\n   457→async function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n   458→  const reservedHours = reservedSeconds / 3600;\n   459→\n   460→  const client = await pool.connect();\n   461→  try {\n   462→    await client.query('BEGIN');\n   463→\n   464→    // Lock the row and get id for logging\n   465→    const result = await client.query(\n   466→      `SELECT id FROM users\n   467→       WHERE stripe_customer_id = $1\n   468→       FOR UPDATE`,\n   469→      [stripeCustomerId]\n   470→    );\n   471→\n   472→    if (result.rows.length === 0) {\n   473→      await client.query('ROLLBACK');\n   474→      throw new Error('User not found');\n   475→    }\n   476→\n   477→    const userId = result.rows[0].id;\n   478→\n   479→    // Refund the reserved amount with RETURNING\n   480→    const updateResult = await client.query(\n   481→      `UPDATE users\n   482→       SET hours_remaining = hours_remaining + $1,\n   483→           updated_at = CURRENT_TIMESTAMP\n   484→       WHERE stripe_customer_id = $2\n   485→       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   486→      [reservedHours, stripeCustomerId]\n   487→    );\n   488→\n   489→    const user = updateResult.rows[0];\n   490→\n   491→    // Log the refund\n   492→    await client.query(\n   493→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   494→       VALUES ($1, $2, $3, $4, $5)`,\n   495→      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n   496→    );\n   497→\n   498→    await client.query('COMMIT');\n   499→\n   500→    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);","numLines":500,"startLine":1,"totalLines":1677}}}
{"parentUuid":"29544240-0327-45e0-9b46-c958a69306d1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"a469bef","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NQQkqgohrf7PPTNr1bXm2C","type":"message","role":"assistant","content":[{"type":"text","text":"I have now gathered sufficient information to provide a comprehensive validation report. Let me compile my findings:\n\n---\n\n# SPLICE Production Release Validation Report\n\n## Overall Verdict: PASS WITH ISSUES\n\nThe SPLICE project demonstrates a solid architecture with comprehensive security measures and proper integration patterns. However, there are several issues that should be addressed before production release.\n\n---\n\n## 1. Backend API Readiness\n\n### Requirements Checklist\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Routes properly mounted | PASS | All routes in `server.js` lines 570-665 are correctly mounted |\n| Auth middleware applied | PASS | `authenticateToken`, `requireCredits` used appropriately |\n| CSRF protection | PASS | `validateCsrfToken` applied to login, refresh, logout, email verification |\n| Rate limiting | PASS | IP rate limiting (`ipRateLimit`) applied globally |\n| Error handling | PASS | Try-catch blocks with proper error responses |\n| Response format consistency | PASS | JSON responses with `success`, `error` pattern |\n\n### Detailed Findings\n\n**File: `/Users/imorgado/SPLICE/splice-backend/server.js`**\n\n- Lines 64-86: Production environment validation is excellent - checks for required env vars and exits if missing\n- Lines 177-215: CORS whitelist properly includes production domains (`splice.app`, `splice-api-production.up.railway.app`, `splice-website.vercel.app`)\n- Line 226: IP rate limiting middleware applied globally\n- Lines 229-252: Helmet security headers configured correctly\n\n---\n\n## 2. Frontend-Backend Integration\n\n### Requirements Checklist\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| API routes forward correctly | PASS | Next.js API routes proxy to backend |\n| CSRF token flow works | PASS | Frontend uses `useCsrf` hook, server validates via `csrfGuard` |\n| Backend URL configuration | PASS | Consistent across frontend and CEP plugin |\n| Authentication flow | PASS | Login, refresh, logout all integrated |\n\n### Detailed Findings\n\n**CEP Plugin Configuration (`/Users/imorgado/SPLICE/splice-cep/panel/js/config.js`):**\n- Line 11: `BACKEND_PROD: 'https://splice-api-production.up.railway.app'` - Correct production URL\n- Lines 21-31: Environment detection properly switches between dev/prod\n\n**Frontend API Routes:**\n- `/Users/imorgado/SPLICE/splice-website/src/app/api/auth/login/route.ts` - Forwards to backend with CSRF\n- `/Users/imorgado/SPLICE/splice-website/src/app/api/contact/route.ts` - Uses `csrfGuard`\n- `/Users/imorgado/SPLICE/splice-website/src/app/api/checkout/route.ts` - Uses `csrfGuard`\n\n---\n\n## 3. Service Dependencies\n\n### Requirements Checklist\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| All imports valid | PASS | No missing require() calls found |\n| Environment variables documented | PASS | `.env.template` comprehensive |\n| Service initialization order | PASS | Database init before server start |\n\n### Detailed Findings\n\n**File: `/Users/imorgado/SPLICE/splice-backend/.env.template`**\n\nAll required environment variables are documented:\n- AI Services (Lines 9-12): GROQ, OpenAI, Replicate\n- Stripe (Lines 17-40): Keys, prices, webhooks, meters\n- Database (Lines 44-45): DATABASE_URL\n- Redis (Lines 49-56): Upstash configuration\n- JWT (Lines 88-91): Secret and expiration\n- Email (Lines 95-109): SendGrid/SES configuration\n\n---\n\n## 4. Database Schema\n\n### Requirements Checklist\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Column names match operations | PASS | All queries use correct column names |\n| Transactions used appropriately | PASS | FOR UPDATE locks prevent race conditions |\n| Migration support | PASS | ALTER TABLE with IF NOT EXISTS pattern |\n\n### Detailed Findings\n\n**File: `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js`**\n\n- Lines 68-81: `users` table schema defined correctly\n- Lines 84-103: Migration logic adds new columns safely (isolation, trial_end, email_verified)\n- Lines 259-335: `reserveCredits` uses `SELECT...FOR UPDATE` to prevent race conditions\n- Lines 347-445: `confirmReservation` properly handles transaction with rollback\n\n**File: `/Users/imorgado/SPLICE/splice-backend/services/licenseService.js`**\n\n- Lines 196-271: `activateLicenseKey` uses `SELECT...FOR UPDATE` within transaction\n\n---\n\n## 5. Plugin Features Integration\n\n### Requirements Checklist\n\n| Feature | Frontend | API Route | Service | Status |\n|---------|----------|-----------|---------|--------|\n| Silence Detection | CEP panel | `/analyze` | `transcription.js` | PASS |\n| Take Detection | CEP panel | `/analyze` | `takeDetection.js` | PASS |\n| Chapters | CEP panel | `/chapters` | mounted at line 634 | PASS |\n| Captions | CEP panel | `/captions` | mounted at line 640 | PASS |\n| Zoom | CEP panel | `/zoom` | mounted at line 631 | PASS |\n| YouTube Content | CEP panel | `/youtube` | mounted at line 637 | PASS |\n| Text Edit | CEP panel | `/text-edit` | mounted at line 643 | PASS |\n| Reframe | CEP panel | `/reframe` | mounted at line 646 | PASS |\n| Multitrack | CEP panel | `/multitrack` | mounted at line 583 | PASS |\n| Music Generation | CEP panel | `/music` | mounted at line 665 | PASS |\n| Cut List | CEP panel | `/cut-list` | mounted at line 586 | PASS |\n| Batch Processing | CEP panel | `/batch` | mounted at line 650 | PASS |\n| Export | CEP panel | `/export` | mounted at line 580 | PASS |\n| Vocal Isolation | CEP panel | `/isolate-vocals` | `vocalIsolation.js` | PASS |\n\n---\n\n## 6. Security Checklist\n\n### Requirements Checklist\n\n| Security Item | Status | Notes |\n|---------------|--------|-------|\n| JWT middleware on protected routes | PASS | `authenticateToken` applied |\n| CSRF on state-changing endpoints | PASS | All POST auth endpoints protected |\n| Rate limiting configured | PASS | IP-based rate limiting |\n| No hardcoded secrets | PASS | All secrets from env vars |\n| Token blacklisting | PASS | In-memory Map with TTL cleanup |\n| Input validation | PASS | Path validation, email validation |\n| XSS prevention | PASS | `escapeHtml` function in email templates |\n\n### Detailed Findings\n\n**File: `/Users/imorgado/SPLICE/splice-backend/middleware/auth.js`**\n- JWT verification with blacklist check\n- `jti` claim for token identification\n\n**File: `/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js`**\n- Double-submit cookie pattern implementation\n- Constant-time comparison to prevent timing attacks\n\n**File: `/Users/imorgado/SPLICE/splice-backend/utils/authLogger.js`**\n- Structured logging with data masking\n- Failed attempt tracking for suspicious activity detection\n\n---\n\n## 7. Production Configuration\n\n### Requirements Checklist\n\n| Item | Status | Notes |\n|------|--------|-------|\n| Production URLs correct | PASS | Railway and Vercel URLs configured |\n| Railway environment detection | PASS | Line 28: checks `RAILWAY_ENVIRONMENT` |\n| CORS origins include production | PASS | Lines 184-190 include all domains |\n| Trust proxy enabled | PASS | Line 222: `app.set('trust proxy', 1)` |\n| Graceful shutdown | PASS | Lines 707-730 handle SIGTERM/SIGINT |\n\n---\n\n## Issues Found\n\n### High Priority\n\n1. **Missing CSRF on Logout in Frontend**\n   - **Location:** `/Users/imorgado/SPLICE/splice-website/src/app/api/auth/logout/route.ts`\n   - **Issue:** The frontend logout route does not include CSRF validation via `csrfGuard`\n   - **Impact:** Logout is still protected by the access token requirement, but CSRF adds defense-in-depth\n   - **Recommendation:** Add `csrfGuard(request)` check similar to contact/checkout routes\n\n2. **Refresh Token CSRF Missing in Frontend**\n   - **Location:** `/Users/imorgado/SPLICE/splice-website/src/app/api/auth/refresh/route.ts`\n   - **Issue:** The frontend refresh route does not forward CSRF tokens to backend\n   - **Impact:** Backend expects CSRF but frontend may not send it\n   - **Recommendation:** Ensure CSRF header is forwarded in the refresh request\n\n### Medium Priority\n\n3. **In-Memory Verification Codes**\n   - **Location:** `/Users/imorgado/SPLICE/splice-backend/routes/auth.js` lines 18-31\n   - **Issue:** Verification codes stored in-memory, not persisted\n   - **Impact:** Codes lost on server restart; cannot scale horizontally without Redis\n   - **Recommendation:** Migrate to Redis for distributed deployments (already have Upstash configured)\n\n4. **In-Memory Token Blacklist**\n   - **Location:** `/Users/imorgado/SPLICE/splice-backend/middleware/auth.js`\n   - **Issue:** Token blacklist is in-memory Map\n   - **Impact:** Blacklisted tokens could work on other instances; lost on restart\n   - **Recommendation:** Use Redis for token blacklist (redisClient.js already exists)\n\n### Low Priority\n\n5. **Email Template ID Missing**\n   - **Location:** `/Users/imorgado/SPLICE/splice-backend/services/emailService.js` line 35\n   - **Issue:** `emailVerification: null` - SendGrid template ID not configured\n   - **Impact:** Falls back to inline template, which works but less maintainable\n   - **Recommendation:** Create SendGrid dynamic template and add ID\n\n6. **Stripe SDK Workaround**\n   - **Location:** `/Users/imorgado/SPLICE/splice-website/src/app/api/checkout/route.ts` lines 93-100\n   - **Issue:** Uses raw fetch instead of Stripe SDK due to Vercel connectivity issues\n   - **Impact:** Works correctly but bypasses SDK features\n   - **Recommendation:** Monitor if SDK works reliably; consider keeping workaround\n\n---\n\n## Recommendations Summary\n\n### Before Production Release (Critical)\n\n1. Verify frontend CSRF forwarding for all auth endpoints\n2. Test the complete login -> refresh -> logout flow end-to-end\n3. Ensure all environment variables are set in Railway\n\n### Soon After Release (High)\n\n1. Migrate verification codes storage to Redis\n2. Migrate token blacklist to Redis for horizontal scaling\n\n### Future Improvements (Medium/Low)\n\n1. Add SendGrid dynamic template for email verification\n2. Consider adding AuthContext provider for better frontend state management\n3. Add more comprehensive integration tests\n\n---\n\n## Files Reviewed\n\n| File Path | Status |\n|-----------|--------|\n| `/Users/imorgado/SPLICE/splice-backend/server.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/.env.template` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/routes/auth.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/middleware/auth.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/services/emailService.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/services/licenseService.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/services/redisClient.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/routes/analyze.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/routes/billing.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-backend/utils/authLogger.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-website/src/app/api/auth/login/route.ts` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-website/src/app/api/auth/me/route.ts` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-website/src/app/api/auth/refresh/route.ts` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-website/src/app/api/auth/logout/route.ts` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-website/src/app/api/contact/route.ts` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-website/src/app/api/checkout/route.ts` | Reviewed |\n| `/Users/imorgado/SPLICE/splice-website/src/lib/csrf-server.ts` | Reviewed |\n\n---\n\n**Validation completed: 2025-12-29**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":18384,"cache_read_input_tokens":90235,"cache_creation":{"ephemeral_5m_input_tokens":18384,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc4SNWsrZWmwJfVDarsP","type":"assistant","uuid":"ba6e7150-c1f1-4499-8cc3-3826d20dda5d","timestamp":"2025-12-30T02:12:17.476Z"}
