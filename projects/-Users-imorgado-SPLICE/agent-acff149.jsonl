{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":"Verify the authentication flow for beta testers (like Danny) to ensure they can log in and use AI features without issues.\n\nRead these files:\n- /Users/imorgado/SPLICE/splice-cep/panel/js/config.js\n- /Users/imorgado/SPLICE/splice-cep/panel/js/credits.js\n- /Users/imorgado/SPLICE/splice-backend/middleware/auth.js\n\nVerify:\n\n1. **Login Flow**:\n   - License key validation format (SPLICE-XXXX-XXXX-XXXX)\n   - POST /auth/login endpoint call\n   - JWT token storage (accessToken, refreshToken, tokenExpiry)\n   - Error messages for invalid keys\n\n2. **Session Management**:\n   - Token expiry checking (isTokenExpired)\n   - Automatic token refresh (refreshAccessToken)\n   - 401 handling with retry\n\n3. **Legacy Auth Support** (for existing users like Danny):\n   - x-stripe-customer-id header fallback\n   - ALLOW_LEGACY_AUTH=true in production\n   - Graceful migration to JWT on re-login\n\n4. **Credits Display**:\n   - fetchCredits() with auth headers\n   - Credit badge states (login, error, ok, low, trial)\n   - Retry on failure\n\n5. **Logout**:\n   - Token clearing\n   - UI reset\n\nIdentify any issues that could prevent Danny or beta testers from:\n- Logging in with their license key\n- Staying logged in during a session\n- Seeing their credit balance\n- Using AI features after login\n\nReturn a detailed auth flow verification report."},"uuid":"2e167cb9-08cd-458c-8309-c0e29fbdb56a","timestamp":"2026-01-12T01:11:52.532Z"}
{"parentUuid":"2e167cb9-08cd-458c-8309-c0e29fbdb56a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AS148r5XrGhpf97LczbfWR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CtrCobf4MdwYYo8JVLjPZs","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":27992,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27992,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2bS8TjnP7bA7TYJarf7","type":"assistant","uuid":"d53a7f8d-2fe4-4891-b8c3-ab2b27dcabc0","timestamp":"2026-01-12T01:11:56.709Z"}
{"parentUuid":"d53a7f8d-2fe4-4891-b8c3-ab2b27dcabc0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AS148r5XrGhpf97LczbfWR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WKRj3TE9yyknerStSyMRbX","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":27992,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27992,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2bS8TjnP7bA7TYJarf7","type":"assistant","uuid":"8a39c5ae-42f6-4f0b-9009-b203daf37b6f","timestamp":"2026-01-12T01:11:57.134Z"}
{"parentUuid":"8a39c5ae-42f6-4f0b-9009-b203daf37b6f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AS148r5XrGhpf97LczbfWR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NDA7qndPXjMjcqRxh3Vqsg","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":27992,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27992,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2bS8TjnP7bA7TYJarf7","type":"assistant","uuid":"fd34d784-31d5-4adf-8386-7b79cca1e544","timestamp":"2026-01-12T01:11:57.453Z"}
{"parentUuid":"fd34d784-31d5-4adf-8386-7b79cca1e544","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WKRj3TE9yyknerStSyMRbX","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Credits Display Module\n     3→ *\n     4→ * Fetches and displays user's remaining hours from the billing backend.\n     5→ * Port of UXP credits.js for CEP compatibility.\n     6→ */\n     7→\n     8→// Track fetch error state for retry UI\n     9→let lastCreditsError = null;\n    10→let creditsRetryCount = 0;\n    11→const MAX_CREDITS_RETRIES = 3;\n    12→\n    13→// Store current credits globally for access checks\n    14→let currentCredits = null;\n    15→\n    16→// Store interval reference for cleanup\n    17→let creditsRefreshInterval = null;\n    18→\n    19→/**\n    20→ * Fetch user's credit balance from backend\n    21→ * @returns {Promise<Object | null>} Credit data including isolation hours, or error object\n    22→ */\n    23→async function fetchCredits() {\n    24→    const settings = getSettings();\n    25→    const customerId = settings.customerId;\n    26→\n    27→    if (!customerId) {\n    28→        console.log('[SPLICE] No customerId configured - credits display disabled');\n    29→        lastCreditsError = null;\n    30→        return null;\n    31→    }\n    32→\n    33→    try {\n    34→        // Ensure we have a valid token before making the request\n    35→        if (typeof ensureValidToken === 'function') {\n    36→            const hasValidToken = await ensureValidToken();\n    37→            if (!hasValidToken && !settings.accessToken) {\n    38→                // No JWT token - will fall back to legacy auth in getAuthHeaders()\n    39→                debugLog('[Credits] No JWT token, using legacy auth');\n    40→            }\n    41→        }\n    42→\n    43→        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    44→            method: 'GET',\n    45→            headers: getAuthHeaders()\n    46→        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n    47→\n    48→        if (!response.ok) {\n    49→            const errorMsg = await parseErrorResponse(response);\n    50→\n    51→            // If unauthorized, try refreshing token and retry once\n    52→            if (response.status === 401 && typeof refreshAccessToken === 'function') {\n    53→                debugLog('[Credits] Got 401, attempting token refresh...');\n    54→                const refreshed = await refreshAccessToken();\n    55→                if (refreshed) {\n    56→                    // Retry with new token\n    57→                    const retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    58→                        method: 'GET',\n    59→                        headers: getAuthHeaders()\n    60→                    }, SPLICE_CONFIG.FETCH_TIMEOUT);\n    61→\n    62→                    if (retryResponse.ok) {\n    63→                        const data = await retryResponse.json();\n    64→                        lastCreditsError = null;\n    65→                        creditsRetryCount = 0;\n    66→                        return {\n    67→                            hoursRemaining: data.hoursRemaining || 0,\n    68→                            hoursTotal: data.hoursTotal || 0,\n    69→                            tierName: data.tierName || 'Free',\n    70→                            tier: data.tier || 'starter',\n    71→                            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n    72→                            isolationHoursTotal: data.isolationHoursTotal || 0,\n    73→                            hasIsolationAccess: data.hasIsolationAccess || false,\n    74→                            isolationOverageRate: data.isolationOverageRate || 0.08,\n    75→                            featureAccess: data.featureAccess || [],\n    76→                            trialDaysRemaining: data.trialDaysRemaining || null,\n    77→                            isOnTrial: data.isOnTrial || false\n    78→                        };\n    79→                    }\n    80→                }\n    81→\n    82→                // Token refresh failed - user needs to re-login\n    83→                console.warn('[SPLICE] Token refresh failed, user needs to re-login');\n    84→                if (typeof clearAuthTokens === 'function') {\n    85→                    clearAuthTokens();\n    86→                }\n    87→                return { _error: true, message: 'Session expired. Please log in again.' };\n    88→            }\n    89→\n    90→            console.error('[SPLICE] Credits fetch failed:', errorMsg);\n    91→            lastCreditsError = errorMsg;\n    92→            return { _error: true, message: errorMsg };\n    93→        }\n    94→\n    95→        const data = await response.json();\n    96→        lastCreditsError = null;\n    97→        creditsRetryCount = 0;\n    98→        return {\n    99→            hoursRemaining: data.hoursRemaining || 0,\n   100→            hoursTotal: data.hoursTotal || 0,\n   101→            tierName: data.tierName || 'Free',\n   102→            tier: data.tier || 'starter',\n   103→            // Isolation hours\n   104→            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n   105→            isolationHoursTotal: data.isolationHoursTotal || 0,\n   106→            hasIsolationAccess: data.hasIsolationAccess || false,\n   107→            isolationOverageRate: data.isolationOverageRate || 0.08,\n   108→            // Feature access\n   109→            featureAccess: data.featureAccess || [],\n   110→            // Trial info\n   111→            trialDaysRemaining: data.trialDaysRemaining || null,\n   112→            isOnTrial: data.isOnTrial || false\n   113→        };\n   114→    } catch (err) {\n   115→        console.error('[SPLICE] Credits fetch error:', err);\n   116→        lastCreditsError = err.message || 'Connection failed';\n   117→        return { _error: true, message: lastCreditsError };\n   118→    }\n   119→}\n   120→\n   121→/**\n   122→ * Clear the credits cache (call on logout)\n   123→ */\n   124→function clearCreditsCache() {\n   125→    currentCredits = null;\n   126→    lastCreditsError = null;\n   127→    creditsRetryCount = 0;\n   128→    console.log('[SPLICE] Credits cache cleared');\n   129→}\n   130→\n   131→/**\n   132→ * Update the credit display in the UI\n   133→ * @param {Object|null} credits - Credit data, error object, or null if unavailable\n   134→ */\n   135→function updateCreditDisplay(credits) {\n   136→    const creditBadge = document.getElementById('creditBadge');\n   137→    if (!creditBadge) return;\n   138→\n   139→    // Handle no customer ID configured\n   140→    if (!credits) {\n   141→        currentCredits = null;\n   142→        creditBadge.style.display = 'flex';\n   143→        creditBadge.textContent = 'Login';\n   144→        creditBadge.title = 'Click to enter license key';\n   145→        creditBadge.classList.remove('ok', 'low');\n   146→        creditBadge.classList.add('login');\n   147→        return;\n   148→    }\n   149→\n   150→    // Handle error state - show error badge with retry\n   151→    if (credits._error) {\n   152→        currentCredits = null;\n   153→        creditBadge.style.display = 'flex';\n   154→        creditBadge.textContent = 'Retry';\n   155→        creditBadge.title = `Error: ${credits.message}\\nClick to retry`;\n   156→        creditBadge.classList.remove('ok', 'low', 'login');\n   157→        creditBadge.classList.add('error');\n   158→        return;\n   159→    }\n   160→\n   161→    // Normal credit display\n   162→    currentCredits = credits;\n   163→    creditBadge.style.display = 'flex';\n   164→\n   165→    // Show referral promo when logged in\n   166→    const referralPromo = document.getElementById('referralPromo');\n   167→    if (referralPromo) {\n   168→        referralPromo.classList.remove('hidden');\n   169→    }\n   170→\n   171→    // Show trial status if on trial\n   172→    if (credits.isOnTrial && credits.trialDaysRemaining) {\n   173→        creditBadge.textContent = `Trial: ${credits.trialDaysRemaining}d`;\n   174→        creditBadge.classList.remove('error', 'login', 'ok', 'low');\n   175→        creditBadge.classList.add('trial');\n   176→    } else {\n   177→        creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n   178→        creditBadge.classList.remove('error', 'login', 'trial');\n   179→    }\n   180→\n   181→    // Build tooltip with isolation info if available\n   182→    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n   183→    if (credits.isOnTrial && credits.trialDaysRemaining) {\n   184→        tooltip = `Trial: ${credits.trialDaysRemaining} days remaining\\n` + tooltip;\n   185→    }\n   186→    if (credits.hasIsolationAccess) {\n   187→        tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n   188→    }\n   189→    creditBadge.title = tooltip;\n   190→\n   191→    // Color based on remaining hours\n   192→    if (credits.hoursRemaining <= 1) {\n   193→        creditBadge.classList.add('low');\n   194→        creditBadge.classList.remove('ok');\n   195→    } else {\n   196→        creditBadge.classList.add('ok');\n   197→        creditBadge.classList.remove('low');\n   198→    }\n   199→\n   200→    // Update isolation checkbox state based on tier access\n   201→    updateIsolationCheckboxState(credits);\n   202→}\n   203→\n   204→/**\n   205→ * Update the isolation checkbox based on tier access\n   206→ */\n   207→function updateIsolationCheckboxState(credits) {\n   208→    const isolatedCheckbox = document.getElementById('sourceIsolated');\n   209→    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n   210→\n   211→    if (!isolatedCheckbox) return;\n   212→\n   213→    if (!credits || !credits.hasIsolationAccess) {\n   214→        // Disable isolation for non-Pro/Team users\n   215→        isolatedCheckbox.disabled = true;\n   216→        isolatedCheckbox.checked = false;\n   217→        if (tierBadge) {\n   218→            tierBadge.textContent = 'Pro+';\n   219→            tierBadge.style.opacity = '1';\n   220→        }\n   221→    } else {\n   222→        // Enable isolation for Pro/Team users\n   223→        isolatedCheckbox.disabled = false;\n   224→        if (tierBadge) {\n   225→            // Show remaining isolation time\n   226→            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n   227→            tierBadge.textContent = `${minsRemaining} min`;\n   228→            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n   229→        }\n   230→    }\n   231→}\n   232→\n   233→/**\n   234→ * Check if user can use isolation and get cost estimate\n   235→ * @param {number} estimatedMinutes - Estimated audio duration in minutes\n   236→ * @returns {Object} Access info with allowed, message, overageCost\n   237→ */\n   238→function checkIsolationAccess(estimatedMinutes = 0) {\n   239→    if (!currentCredits) {\n   240→        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n   241→    }\n   242→\n   243→    if (!currentCredits.hasIsolationAccess) {\n   244→        return {\n   245→            allowed: false,\n   246→            message: 'Vocal isolation requires Pro or Team tier',\n   247→            upgradeRequired: true,\n   248→            overageCost: 0\n   249→        };\n   250→    }\n   251→\n   252→    const estimatedHours = estimatedMinutes / 60;\n   253→    const remaining = currentCredits.isolationHoursRemaining;\n   254→\n   255→    if (remaining >= estimatedHours) {\n   256→        return {\n   257→            allowed: true,\n   258→            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   259→            overageCost: 0\n   260→        };\n   261→    }\n   262→\n   263→    // Calculate overage\n   264→    const overageMinutes = estimatedMinutes - (remaining * 60);\n   265→    const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n   266→\n   267→    return {\n   268→        allowed: true,\n   269→        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n   270→        overageCost,\n   271→        overageMinutes\n   272→    };\n   273→}\n   274→\n   275→/**\n   276→ * Get current credits (for access checks)\n   277→ */\n   278→function getCurrentCredits() {\n   279→    return currentCredits;\n   280→}\n   281→\n   282→/**\n   283→ * Check if user has access to a specific feature based on their tier\n   284→ * @param {string} featureName - The feature to check (e.g., 'social_reframe', 'text_editing', 'multitrack')\n   285→ * @returns {boolean} - True if user has access\n   286→ */\n   287→function hasFeatureAccess(featureName) {\n   288→    if (!currentCredits || !currentCredits.featureAccess) {\n   289→        return false; // Not logged in = no premium features\n   290→    }\n   291→    return currentCredits.featureAccess.includes(featureName);\n   292→}\n   293→\n   294→/**\n   295→ * Get the required tier for a feature\n   296→ * @param {string} featureName - The feature name\n   297→ * @returns {string} - Required tier name\n   298→ */\n   299→function getRequiredTier(featureName) {\n   300→    const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n   301→    const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n   302→\n   303→    if (teamOnlyFeatures.includes(featureName)) {\n   304→        return 'Team';\n   305→    } else if (proFeatures.includes(featureName)) {\n   306→        return 'Pro';\n   307→    }\n   308→    return 'Starter';\n   309→}\n   310→\n   311→/**\n   312→ * Initialize credits display\n   313→ * Fetches credits on load and sets up periodic refresh\n   314→ */\n   315→async function initCredits() {\n   316→    // Clear any existing interval to prevent duplicates\n   317→    if (creditsRefreshInterval) {\n   318→        clearInterval(creditsRefreshInterval);\n   319→    }\n   320→\n   321→    // Initial fetch\n   322→    const credits = await fetchCredits();\n   323→    updateCreditDisplay(credits);\n   324→\n   325→    // Refresh credits every 5 minutes\n   326→    creditsRefreshInterval = setInterval(async () => {\n   327→        const refreshedCredits = await fetchCredits();\n   328→        updateCreditDisplay(refreshedCredits);\n   329→    }, 5 * 60 * 1000);\n   330→}\n   331→\n   332→/**\n   333→ * Cleanup credits module - call on plugin unload\n   334→ */\n   335→function cleanupCredits() {\n   336→    if (creditsRefreshInterval) {\n   337→        clearInterval(creditsRefreshInterval);\n   338→        creditsRefreshInterval = null;\n   339→    }\n   340→}\n   341→\n   342→/**\n   343→ * Manually refresh credits (e.g., after a processing operation)\n   344→ */\n   345→async function refreshCredits() {\n   346→    const credits = await fetchCredits();\n   347→    updateCreditDisplay(credits);\n   348→    return credits;\n   349→}\n   350→\n   351→/**\n   352→ * Retry fetching credits with exponential backoff\n   353→ * Called when user clicks the \"Retry\" badge\n   354→ */\n   355→async function retryFetchCredits() {\n   356→    if (creditsRetryCount >= MAX_CREDITS_RETRIES) {\n   357→        console.warn('[SPLICE] Max retry attempts reached for credits fetch');\n   358→        updateCreditDisplay({\n   359→            _error: true,\n   360→            message: 'Max retries exceeded. Check your connection and try again later.'\n   361→        });\n   362→        creditsRetryCount = 0; // Reset for next attempt\n   363→        return null;\n   364→    }\n   365→\n   366→    creditsRetryCount++;\n   367→    console.log(`[SPLICE] Retrying credits fetch (attempt ${creditsRetryCount}/${MAX_CREDITS_RETRIES})`);\n   368→\n   369→    // Exponential backoff: 1s, 2s, 4s\n   370→    const delay = Math.pow(2, creditsRetryCount - 1) * 1000;\n   371→\n   372→    // Show retrying state\n   373→    const creditBadge = document.getElementById('creditBadge');\n   374→    if (creditBadge) {\n   375→        creditBadge.textContent = `Retry ${creditsRetryCount}...`;\n   376→        creditBadge.classList.add('retrying');\n   377→    }\n   378→\n   379→    await new Promise(resolve => setTimeout(resolve, delay));\n   380→\n   381→    const credits = await fetchCredits();\n   382→\n   383→    if (creditBadge) {\n   384→        creditBadge.classList.remove('retrying');\n   385→    }\n   386→\n   387→    updateCreditDisplay(credits);\n   388→    return credits;\n   389→}\n   390→\n   391→/**\n   392→ * Handle click on credit badge\n   393→ * - If error state: retry fetching\n   394→ * - If login state: open login modal\n   395→ * - Otherwise: refresh credits\n   396→ */\n   397→function handleCreditBadgeClick() {\n   398→    const creditBadge = document.getElementById('creditBadge');\n   399→    if (!creditBadge) return;\n   400→\n   401→    if (creditBadge.classList.contains('error')) {\n   402→        retryFetchCredits();\n   403→    } else if (creditBadge.classList.contains('login')) {\n   404→        // Open login modal (handled in main.js)\n   405→        const loginModal = document.getElementById('loginModal');\n   406→        if (loginModal) {\n   407→            loginModal.classList.remove('hidden');\n   408→        }\n   409→    } else {\n   410→        // Normal state - just refresh\n   411→        refreshCredits();\n   412→    }\n   413→}\n   414→\n   415→// Export for window access\n   416→window.fetchCredits = fetchCredits;\n   417→window.clearCreditsCache = clearCreditsCache;\n   418→window.updateCreditDisplay = updateCreditDisplay;\n   419→window.checkIsolationAccess = checkIsolationAccess;\n   420→window.getCurrentCredits = getCurrentCredits;\n   421→window.hasFeatureAccess = hasFeatureAccess;\n   422→window.getRequiredTier = getRequiredTier;\n   423→window.initCredits = initCredits;\n   424→window.cleanupCredits = cleanupCredits;\n   425→window.refreshCredits = refreshCredits;\n   426→window.retryFetchCredits = retryFetchCredits;\n   427→window.handleCreditBadgeClick = handleCreditBadgeClick;\n   428→\n   429→\n\n</system-reminder>\n"}]},"uuid":"23a77707-7c23-4868-8693-5174d936599d","timestamp":"2026-01-12T01:11:57.491Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js","content":"/**\n * SPLICE CEP Credits Display Module\n *\n * Fetches and displays user's remaining hours from the billing backend.\n * Port of UXP credits.js for CEP compatibility.\n */\n\n// Track fetch error state for retry UI\nlet lastCreditsError = null;\nlet creditsRetryCount = 0;\nconst MAX_CREDITS_RETRIES = 3;\n\n// Store current credits globally for access checks\nlet currentCredits = null;\n\n// Store interval reference for cleanup\nlet creditsRefreshInterval = null;\n\n/**\n * Fetch user's credit balance from backend\n * @returns {Promise<Object | null>} Credit data including isolation hours, or error object\n */\nasync function fetchCredits() {\n    const settings = getSettings();\n    const customerId = settings.customerId;\n\n    if (!customerId) {\n        console.log('[SPLICE] No customerId configured - credits display disabled');\n        lastCreditsError = null;\n        return null;\n    }\n\n    try {\n        // Ensure we have a valid token before making the request\n        if (typeof ensureValidToken === 'function') {\n            const hasValidToken = await ensureValidToken();\n            if (!hasValidToken && !settings.accessToken) {\n                // No JWT token - will fall back to legacy auth in getAuthHeaders()\n                debugLog('[Credits] No JWT token, using legacy auth');\n            }\n        }\n\n        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n            method: 'GET',\n            headers: getAuthHeaders()\n        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n        if (!response.ok) {\n            const errorMsg = await parseErrorResponse(response);\n\n            // If unauthorized, try refreshing token and retry once\n            if (response.status === 401 && typeof refreshAccessToken === 'function') {\n                debugLog('[Credits] Got 401, attempting token refresh...');\n                const refreshed = await refreshAccessToken();\n                if (refreshed) {\n                    // Retry with new token\n                    const retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n                        method: 'GET',\n                        headers: getAuthHeaders()\n                    }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n                    if (retryResponse.ok) {\n                        const data = await retryResponse.json();\n                        lastCreditsError = null;\n                        creditsRetryCount = 0;\n                        return {\n                            hoursRemaining: data.hoursRemaining || 0,\n                            hoursTotal: data.hoursTotal || 0,\n                            tierName: data.tierName || 'Free',\n                            tier: data.tier || 'starter',\n                            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n                            isolationHoursTotal: data.isolationHoursTotal || 0,\n                            hasIsolationAccess: data.hasIsolationAccess || false,\n                            isolationOverageRate: data.isolationOverageRate || 0.08,\n                            featureAccess: data.featureAccess || [],\n                            trialDaysRemaining: data.trialDaysRemaining || null,\n                            isOnTrial: data.isOnTrial || false\n                        };\n                    }\n                }\n\n                // Token refresh failed - user needs to re-login\n                console.warn('[SPLICE] Token refresh failed, user needs to re-login');\n                if (typeof clearAuthTokens === 'function') {\n                    clearAuthTokens();\n                }\n                return { _error: true, message: 'Session expired. Please log in again.' };\n            }\n\n            console.error('[SPLICE] Credits fetch failed:', errorMsg);\n            lastCreditsError = errorMsg;\n            return { _error: true, message: errorMsg };\n        }\n\n        const data = await response.json();\n        lastCreditsError = null;\n        creditsRetryCount = 0;\n        return {\n            hoursRemaining: data.hoursRemaining || 0,\n            hoursTotal: data.hoursTotal || 0,\n            tierName: data.tierName || 'Free',\n            tier: data.tier || 'starter',\n            // Isolation hours\n            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n            isolationHoursTotal: data.isolationHoursTotal || 0,\n            hasIsolationAccess: data.hasIsolationAccess || false,\n            isolationOverageRate: data.isolationOverageRate || 0.08,\n            // Feature access\n            featureAccess: data.featureAccess || [],\n            // Trial info\n            trialDaysRemaining: data.trialDaysRemaining || null,\n            isOnTrial: data.isOnTrial || false\n        };\n    } catch (err) {\n        console.error('[SPLICE] Credits fetch error:', err);\n        lastCreditsError = err.message || 'Connection failed';\n        return { _error: true, message: lastCreditsError };\n    }\n}\n\n/**\n * Clear the credits cache (call on logout)\n */\nfunction clearCreditsCache() {\n    currentCredits = null;\n    lastCreditsError = null;\n    creditsRetryCount = 0;\n    console.log('[SPLICE] Credits cache cleared');\n}\n\n/**\n * Update the credit display in the UI\n * @param {Object|null} credits - Credit data, error object, or null if unavailable\n */\nfunction updateCreditDisplay(credits) {\n    const creditBadge = document.getElementById('creditBadge');\n    if (!creditBadge) return;\n\n    // Handle no customer ID configured\n    if (!credits) {\n        currentCredits = null;\n        creditBadge.style.display = 'flex';\n        creditBadge.textContent = 'Login';\n        creditBadge.title = 'Click to enter license key';\n        creditBadge.classList.remove('ok', 'low');\n        creditBadge.classList.add('login');\n        return;\n    }\n\n    // Handle error state - show error badge with retry\n    if (credits._error) {\n        currentCredits = null;\n        creditBadge.style.display = 'flex';\n        creditBadge.textContent = 'Retry';\n        creditBadge.title = `Error: ${credits.message}\\nClick to retry`;\n        creditBadge.classList.remove('ok', 'low', 'login');\n        creditBadge.classList.add('error');\n        return;\n    }\n\n    // Normal credit display\n    currentCredits = credits;\n    creditBadge.style.display = 'flex';\n\n    // Show referral promo when logged in\n    const referralPromo = document.getElementById('referralPromo');\n    if (referralPromo) {\n        referralPromo.classList.remove('hidden');\n    }\n\n    // Show trial status if on trial\n    if (credits.isOnTrial && credits.trialDaysRemaining) {\n        creditBadge.textContent = `Trial: ${credits.trialDaysRemaining}d`;\n        creditBadge.classList.remove('error', 'login', 'ok', 'low');\n        creditBadge.classList.add('trial');\n    } else {\n        creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n        creditBadge.classList.remove('error', 'login', 'trial');\n    }\n\n    // Build tooltip with isolation info if available\n    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n    if (credits.isOnTrial && credits.trialDaysRemaining) {\n        tooltip = `Trial: ${credits.trialDaysRemaining} days remaining\\n` + tooltip;\n    }\n    if (credits.hasIsolationAccess) {\n        tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n    }\n    creditBadge.title = tooltip;\n\n    // Color based on remaining hours\n    if (credits.hoursRemaining <= 1) {\n        creditBadge.classList.add('low');\n        creditBadge.classList.remove('ok');\n    } else {\n        creditBadge.classList.add('ok');\n        creditBadge.classList.remove('low');\n    }\n\n    // Update isolation checkbox state based on tier access\n    updateIsolationCheckboxState(credits);\n}\n\n/**\n * Update the isolation checkbox based on tier access\n */\nfunction updateIsolationCheckboxState(credits) {\n    const isolatedCheckbox = document.getElementById('sourceIsolated');\n    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n\n    if (!isolatedCheckbox) return;\n\n    if (!credits || !credits.hasIsolationAccess) {\n        // Disable isolation for non-Pro/Team users\n        isolatedCheckbox.disabled = true;\n        isolatedCheckbox.checked = false;\n        if (tierBadge) {\n            tierBadge.textContent = 'Pro+';\n            tierBadge.style.opacity = '1';\n        }\n    } else {\n        // Enable isolation for Pro/Team users\n        isolatedCheckbox.disabled = false;\n        if (tierBadge) {\n            // Show remaining isolation time\n            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n            tierBadge.textContent = `${minsRemaining} min`;\n            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n        }\n    }\n}\n\n/**\n * Check if user can use isolation and get cost estimate\n * @param {number} estimatedMinutes - Estimated audio duration in minutes\n * @returns {Object} Access info with allowed, message, overageCost\n */\nfunction checkIsolationAccess(estimatedMinutes = 0) {\n    if (!currentCredits) {\n        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n    }\n\n    if (!currentCredits.hasIsolationAccess) {\n        return {\n            allowed: false,\n            message: 'Vocal isolation requires Pro or Team tier',\n            upgradeRequired: true,\n            overageCost: 0\n        };\n    }\n\n    const estimatedHours = estimatedMinutes / 60;\n    const remaining = currentCredits.isolationHoursRemaining;\n\n    if (remaining >= estimatedHours) {\n        return {\n            allowed: true,\n            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n            overageCost: 0\n        };\n    }\n\n    // Calculate overage\n    const overageMinutes = estimatedMinutes - (remaining * 60);\n    const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n\n    return {\n        allowed: true,\n        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n        overageCost,\n        overageMinutes\n    };\n}\n\n/**\n * Get current credits (for access checks)\n */\nfunction getCurrentCredits() {\n    return currentCredits;\n}\n\n/**\n * Check if user has access to a specific feature based on their tier\n * @param {string} featureName - The feature to check (e.g., 'social_reframe', 'text_editing', 'multitrack')\n * @returns {boolean} - True if user has access\n */\nfunction hasFeatureAccess(featureName) {\n    if (!currentCredits || !currentCredits.featureAccess) {\n        return false; // Not logged in = no premium features\n    }\n    return currentCredits.featureAccess.includes(featureName);\n}\n\n/**\n * Get the required tier for a feature\n * @param {string} featureName - The feature name\n * @returns {string} - Required tier name\n */\nfunction getRequiredTier(featureName) {\n    const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n    const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n\n    if (teamOnlyFeatures.includes(featureName)) {\n        return 'Team';\n    } else if (proFeatures.includes(featureName)) {\n        return 'Pro';\n    }\n    return 'Starter';\n}\n\n/**\n * Initialize credits display\n * Fetches credits on load and sets up periodic refresh\n */\nasync function initCredits() {\n    // Clear any existing interval to prevent duplicates\n    if (creditsRefreshInterval) {\n        clearInterval(creditsRefreshInterval);\n    }\n\n    // Initial fetch\n    const credits = await fetchCredits();\n    updateCreditDisplay(credits);\n\n    // Refresh credits every 5 minutes\n    creditsRefreshInterval = setInterval(async () => {\n        const refreshedCredits = await fetchCredits();\n        updateCreditDisplay(refreshedCredits);\n    }, 5 * 60 * 1000);\n}\n\n/**\n * Cleanup credits module - call on plugin unload\n */\nfunction cleanupCredits() {\n    if (creditsRefreshInterval) {\n        clearInterval(creditsRefreshInterval);\n        creditsRefreshInterval = null;\n    }\n}\n\n/**\n * Manually refresh credits (e.g., after a processing operation)\n */\nasync function refreshCredits() {\n    const credits = await fetchCredits();\n    updateCreditDisplay(credits);\n    return credits;\n}\n\n/**\n * Retry fetching credits with exponential backoff\n * Called when user clicks the \"Retry\" badge\n */\nasync function retryFetchCredits() {\n    if (creditsRetryCount >= MAX_CREDITS_RETRIES) {\n        console.warn('[SPLICE] Max retry attempts reached for credits fetch');\n        updateCreditDisplay({\n            _error: true,\n            message: 'Max retries exceeded. Check your connection and try again later.'\n        });\n        creditsRetryCount = 0; // Reset for next attempt\n        return null;\n    }\n\n    creditsRetryCount++;\n    console.log(`[SPLICE] Retrying credits fetch (attempt ${creditsRetryCount}/${MAX_CREDITS_RETRIES})`);\n\n    // Exponential backoff: 1s, 2s, 4s\n    const delay = Math.pow(2, creditsRetryCount - 1) * 1000;\n\n    // Show retrying state\n    const creditBadge = document.getElementById('creditBadge');\n    if (creditBadge) {\n        creditBadge.textContent = `Retry ${creditsRetryCount}...`;\n        creditBadge.classList.add('retrying');\n    }\n\n    await new Promise(resolve => setTimeout(resolve, delay));\n\n    const credits = await fetchCredits();\n\n    if (creditBadge) {\n        creditBadge.classList.remove('retrying');\n    }\n\n    updateCreditDisplay(credits);\n    return credits;\n}\n\n/**\n * Handle click on credit badge\n * - If error state: retry fetching\n * - If login state: open login modal\n * - Otherwise: refresh credits\n */\nfunction handleCreditBadgeClick() {\n    const creditBadge = document.getElementById('creditBadge');\n    if (!creditBadge) return;\n\n    if (creditBadge.classList.contains('error')) {\n        retryFetchCredits();\n    } else if (creditBadge.classList.contains('login')) {\n        // Open login modal (handled in main.js)\n        const loginModal = document.getElementById('loginModal');\n        if (loginModal) {\n            loginModal.classList.remove('hidden');\n        }\n    } else {\n        // Normal state - just refresh\n        refreshCredits();\n    }\n}\n\n// Export for window access\nwindow.fetchCredits = fetchCredits;\nwindow.clearCreditsCache = clearCreditsCache;\nwindow.updateCreditDisplay = updateCreditDisplay;\nwindow.checkIsolationAccess = checkIsolationAccess;\nwindow.getCurrentCredits = getCurrentCredits;\nwindow.hasFeatureAccess = hasFeatureAccess;\nwindow.getRequiredTier = getRequiredTier;\nwindow.initCredits = initCredits;\nwindow.cleanupCredits = cleanupCredits;\nwindow.refreshCredits = refreshCredits;\nwindow.retryFetchCredits = retryFetchCredits;\nwindow.handleCreditBadgeClick = handleCreditBadgeClick;\n\n","numLines":429,"startLine":1,"totalLines":429}}}
{"parentUuid":"23a77707-7c23-4868-8693-5174d936599d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NDA7qndPXjMjcqRxh3Vqsg","type":"tool_result","content":"     1→/**\n     2→ * JWT Authentication Middleware\n     3→ *\n     4→ * Primary authentication method: JWT Bearer tokens\n     5→ * Tokens are signed with a secret and contain the customer ID.\n     6→ *\n     7→ * Token Blacklist:\n     8→ * - Primary: Upstash Redis with automatic TTL-based expiry\n     9→ * - Fallback: In-memory Map (for development or Redis failures)\n    10→ *\n    11→ * DEPRECATION NOTICE:\n    12→ * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n    13→ * - Sunset Date: 2026-04-11\n    14→ * - Control: Set ALLOW_LEGACY_AUTH environment variable\n    15→ *   - Production default: false (disabled)\n    16→ *   - Development default: true (enabled for backward compatibility)\n    17→ * - Clients using legacy auth will receive X-Deprecation-Warning headers\n    18→ * - After sunset date, legacy auth will be completely removed\n    19→ *\n    20→ * Migration Guide:\n    21→ * 1. Call POST /auth/login with license key to obtain JWT tokens\n    22→ * 2. Use Authorization: Bearer <token> header for all authenticated requests\n    23→ * 3. Use POST /auth/refresh to refresh expired tokens\n    24→ */\n    25→\n    26→const jwt = require('jsonwebtoken');\n    27→const crypto = require('crypto');\n    28→const authLogger = require('../utils/authLogger');\n    29→const redis = require('../services/redisClient');\n    30→\n    31→// HIGH-007: Database pool for admin RBAC\n    32→let pool = null;\n    33→try {\n    34→  const { Pool } = require('pg');\n    35→  pool = new Pool({\n    36→    connectionString: process.env.DATABASE_URL,\n    37→    ssl: process.env.NODE_ENV === 'production'\n    38→      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n    39→      : false,\n    40→    max: 3, // Small pool just for auth checks\n    41→    idleTimeoutMillis: 30000,\n    42→  });\n    43→} catch (err) {\n    44→  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n    45→}\n    46→\n    47→// JWT configuration\n    48→const JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\n    49→const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\n    50→const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n    51→\n    52→// Redis key prefix for blacklisted tokens\n    53→const BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n    54→\n    55→// Check if running in production\n    56→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    57→\n    58→// =============================================================================\n    59→// Legacy Authentication Deprecation Configuration\n    60→// =============================================================================\n    61→// The x-stripe-customer-id header is deprecated and will be removed.\n    62→// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n    63→\n    64→/**\n    65→ * Legacy auth sunset date (90 days from 2026-01-11)\n    66→ * After this date, legacy auth will be completely removed\n    67→ */\n    68→const LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n    69→\n    70→/**\n    71→ * Whether to allow legacy x-stripe-customer-id header authentication\n    72→ * Defaults to false in production, true in development for backward compatibility\n    73→ */\n    74→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n    75→  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n    76→\n    77→// Log legacy auth configuration on startup\n    78→if (isProduction) {\n    79→  if (ALLOW_LEGACY_AUTH) {\n    80→    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    81→    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    82→    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n    83→  } else {\n    84→    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n    85→  }\n    86→} else {\n    87→  if (ALLOW_LEGACY_AUTH) {\n    88→    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    89→  } else {\n    90→    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n    91→  }\n    92→}\n    93→\n    94→// HIGH-001: Validate JWT_SECRET security requirements\n    95→if (isProduction) {\n    96→  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    97→    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    98→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    99→    process.exit(1);\n   100→  }\n   101→  \n   102→  if (JWT_SECRET.length < 32) {\n   103→    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n   104→    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n   105→    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n   106→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n   107→    process.exit(1);\n   108→  }\n   109→}\n   110→\n   111→/**\n   112→ * Fallback Token Blacklist (In-Memory)\n   113→ * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n   114→ */\n   115→const fallbackBlacklist = new Map();\n   116→\n   117→// Track if we're using fallback mode\n   118→let usingFallback = false;\n   119→\n   120→// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\n   121→const BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n   122→\n   123→/**\n   124→ * Clean up expired entries from the fallback blacklist\n   125→ * Only runs when using in-memory fallback\n   126→ */\n   127→function cleanupFallbackBlacklist() {\n   128→  if (!usingFallback || fallbackBlacklist.size === 0) {\n   129→    return;\n   130→  }\n   131→\n   132→  const now = Math.floor(Date.now() / 1000);\n   133→  let cleanedCount = 0;\n   134→\n   135→  for (const [jti, exp] of fallbackBlacklist.entries()) {\n   136→    if (exp <= now) {\n   137→      fallbackBlacklist.delete(jti);\n   138→      cleanedCount++;\n   139→    }\n   140→  }\n   141→\n   142→  if (cleanedCount > 0) {\n   143→    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n   144→  }\n   145→}\n   146→\n   147→// Start periodic cleanup for fallback (unref to allow process exit)\n   148→const cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\n   149→if (cleanupTimer.unref) {\n   150→  cleanupTimer.unref();\n   151→}\n   152→\n   153→/**\n   154→ * Add a token to the blacklist\n   155→ * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n   156→ * @param {string} jti - JWT ID claim\n   157→ * @param {number} exp - Token expiration timestamp (Unix seconds)\n   158→ * @param {Object} options - Additional options for logging\n   159→ * @param {string} options.userId - User ID for logging\n   160→ * @param {string} options.reason - Reason for revocation (logout, security, admin)\n   161→ * @returns {Promise<boolean>} True if successfully blacklisted\n   162→ */\n   163→async function blacklistToken(jti, exp, options = {}) {\n   164→  if (!jti) {\n   165→    console.warn('[Auth] Cannot blacklist token without jti');\n   166→    return false;\n   167→  }\n   168→\n   169→  const now = Math.floor(Date.now() / 1000);\n   170→  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n   171→\n   172→  // Try Redis first\n   173→  if (redis.isRedisAvailable()) {\n   174→    try {\n   175→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   176→      const success = await redis.set(key, exp, ttlSeconds);\n   177→\n   178→      if (success) {\n   179→        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n   180→        usingFallback = false;\n   181→        // Log token revocation with structured logging\n   182→        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   183→        return true;\n   184→      }\n   185→    } catch (err) {\n   186→      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n   187→    }\n   188→  }\n   189→\n   190→  // Fallback to in-memory\n   191→  usingFallback = true;\n   192→  fallbackBlacklist.set(jti, exp);\n   193→  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n   194→\n   195→  // Log token revocation with structured logging\n   196→  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   197→  return true;\n   198→}\n   199→\n   200→/**\n   201→ * Check if a token is blacklisted\n   202→ * Checks Redis first, then fallback in-memory store\n   203→ * @param {string} jti - JWT ID claim\n   204→ * @returns {Promise<boolean>} True if token is blacklisted\n   205→ */\n   206→async function isTokenBlacklisted(jti) {\n   207→  if (!jti) {\n   208→    return false;\n   209→  }\n   210→\n   211→  // Try Redis first\n   212→  if (redis.isRedisAvailable()) {\n   213→    try {\n   214→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   215→      const exists = await redis.exists(key);\n   216→\n   217→      if (exists) {\n   218→        return true;\n   219→      }\n   220→\n   221→      // Also check fallback in case token was blacklisted during Redis downtime\n   222→      // and Redis is now back up\n   223→      if (fallbackBlacklist.has(jti)) {\n   224→        // Migrate to Redis if token still valid\n   225→        const exp = fallbackBlacklist.get(jti);\n   226→        const now = Math.floor(Date.now() / 1000);\n   227→        if (exp > now) {\n   228→          const ttlSeconds = exp - now;\n   229→          await redis.set(key, exp, ttlSeconds);\n   230→          fallbackBlacklist.delete(jti);\n   231→          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n   232→        } else {\n   233→          // Expired, remove from fallback\n   234→          fallbackBlacklist.delete(jti);\n   235→        }\n   236→        return true;\n   237→      }\n   238→\n   239→      return false;\n   240→    } catch (err) {\n   241→      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n   242→    }\n   243→  }\n   244→\n   245→  // Fallback to in-memory check\n   246→  if (fallbackBlacklist.has(jti)) {\n   247→    const exp = fallbackBlacklist.get(jti);\n   248→    const now = Math.floor(Date.now() / 1000);\n   249→    if (exp > now) {\n   250→      return true;\n   251→    }\n   252→    // Expired, remove it\n   253→    fallbackBlacklist.delete(jti);\n   254→  }\n   255→\n   256→  return false;\n   257→}\n   258→\n   259→/**\n   260→ * Get blacklist statistics (for monitoring)\n   261→ * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n   262→ */\n   263→async function getBlacklistStats() {\n   264→  const redisAvailable = redis.isRedisAvailable();\n   265→  const redisStatus = redis.getRedisStatus();\n   266→\n   267→  return {\n   268→    storage: redisAvailable ? 'redis' : 'memory',\n   269→    redisConnected: redisStatus.connected,\n   270→    redisError: redisStatus.error,\n   271→    fallbackSize: fallbackBlacklist.size,\n   272→    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n   273→    usingFallback\n   274→  };\n   275→}\n   276→\n   277→/**\n   278→ * Generate a JWT token for a customer\n   279→ * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n   280→ * @param {Object} options - Additional options\n   281→ * @param {string} options.tier - User's subscription tier\n   282→ * @param {string} options.email - User's email (optional)\n   283→ * @returns {Object} { token, expiresIn }\n   284→ */\n   285→function generateToken(stripeCustomerId, options = {}) {\n   286→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   287→    throw new Error('Invalid Stripe customer ID');\n   288→  }\n   289→\n   290→  const payload = {\n   291→    sub: stripeCustomerId,\n   292→    type: 'access',\n   293→    tier: options.tier || 'starter',\n   294→    iat: Math.floor(Date.now() / 1000),\n   295→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   296→  };\n   297→\n   298→  if (options.email) {\n   299→    payload.email = options.email;\n   300→  }\n   301→\n   302→  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n   303→\n   304→  return {\n   305→    token,\n   306→    expiresIn: JWT_EXPIRES_IN,\n   307→    tokenType: 'Bearer'\n   308→  };\n   309→}\n   310→\n   311→/**\n   312→ * Generate a refresh token for a customer\n   313→ * @param {string} stripeCustomerId - Stripe customer ID\n   314→ * @returns {Object} { refreshToken, expiresIn }\n   315→ */\n   316→function generateRefreshToken(stripeCustomerId) {\n   317→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   318→    throw new Error('Invalid Stripe customer ID');\n   319→  }\n   320→\n   321→  const payload = {\n   322→    sub: stripeCustomerId,\n   323→    type: 'refresh',\n   324→    iat: Math.floor(Date.now() / 1000),\n   325→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   326→  };\n   327→\n   328→  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n   329→\n   330→  return {\n   331→    refreshToken,\n   332→    expiresIn: JWT_REFRESH_EXPIRES_IN\n   333→  };\n   334→}\n   335→\n   336→/**\n   337→ * Verify and decode a JWT token (async version)\n   338→ * Checks both JWT signature validity and token blacklist status via Redis\n   339→ * @param {string} token - JWT token to verify\n   340→ * @param {Object} options - Verification options\n   341→ * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n   342→ * @param {Object} options.req - Express request object for logging (optional)\n   343→ * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n   344→ */\n   345→async function verifyToken(token, options = {}) {\n   346→  const { checkBlacklist = true, req = null } = options;\n   347→\n   348→  try {\n   349→    const decoded = jwt.verify(token, JWT_SECRET);\n   350→\n   351→    // Check if token has been revoked (blacklisted) - async Redis check\n   352→    if (checkBlacklist && decoded.jti) {\n   353→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   354→      if (isBlacklisted) {\n   355→        if (req) {\n   356→          authLogger.logTokenBlacklisted(req, decoded.jti);\n   357→        }\n   358→        return null;\n   359→      }\n   360→    }\n   361→\n   362→    return decoded;\n   363→  } catch (err) {\n   364→    // Log specific error types for debugging\n   365→    if (err.name === 'TokenExpiredError') {\n   366→      if (req) {\n   367→        authLogger.logTokenExpired(req);\n   368→      }\n   369→    } else if (err.name === 'JsonWebTokenError') {\n   370→      if (req) {\n   371→        authLogger.logTokenInvalid(req, err.message);\n   372→      }\n   373→    }\n   374→    return null;\n   375→  }\n   376→}\n   377→\n   378→/**\n   379→ * Synchronous token verification (for cases where async is not possible)\n   380→ * Does NOT check blacklist - use verifyToken() for full verification\n   381→ * @param {string} token - JWT token to verify\n   382→ * @returns {Object|null} Decoded payload or null if invalid\n   383→ */\n   384→function verifyTokenSync(token) {\n   385→  try {\n   386→    return jwt.verify(token, JWT_SECRET);\n   387→  } catch {\n   388→    return null;\n   389→  }\n   390→}\n   391→\n   392→/**\n   393→ * Extract Bearer token from Authorization header\n   394→ * @param {string} authHeader - Authorization header value\n   395→ * @returns {string|null} Token or null if not found\n   396→ */\n   397→function extractBearerToken(authHeader) {\n   398→  if (!authHeader || typeof authHeader !== 'string') {\n   399→    return null;\n   400→  }\n   401→\n   402→  const parts = authHeader.split(' ');\n   403→  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n   404→    return null;\n   405→  }\n   406→\n   407→  return parts[1];\n   408→}\n   409→\n   410→/**\n   411→ * Middleware to authenticate JWT tokens\n   412→ * Sets req.stripeCustomerId if valid token found\n   413→ *\n   414→ * Authentication Methods:\n   415→ * - Authorization: Bearer <token> (PREFERRED - use this method)\n   416→ * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)\n   417→ *\n   418→ * DEPRECATION: x-stripe-customer-id header\n   419→ * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var\n   420→ * - Production: Disabled by default (returns 401)\n   421→ * - Development: Enabled by default for backward compatibility\n   422→ * - Sunset Date: 2026-04-11 (after which it will be removed entirely)\n   423→ * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers\n   424→ *\n   425→ * @param {Object} req - Express request object\n   426→ * @param {Object} res - Express response object\n   427→ * @param {Function} next - Express next function\n   428→ */\n   429→async function authenticateToken(req, res, next) {\n   430→  // First, try JWT token from Authorization header\n   431→  const authHeader = req.headers['authorization'];\n   432→  const token = extractBearerToken(authHeader);\n   433→\n   434→  if (token) {\n   435→    // First verify JWT signature without blacklist check to get specific error messages\n   436→    const decoded = verifyTokenSync(token);\n   437→\n   438→    if (!decoded || !decoded.sub) {\n   439→      // Token is invalid or expired (signature failed)\n   440→      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n   441→      return res.status(401).json({\n   442→        error: 'Invalid or expired token',\n   443→        message: 'Please log in again to continue'\n   444→      });\n   445→    }\n   446→\n   447→    // Check if token has been revoked (blacklisted) - async Redis check\n   448→    if (decoded.jti) {\n   449→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   450→      if (isBlacklisted) {\n   451→        authLogger.logTokenBlacklisted(req, decoded.jti);\n   452→        return res.status(401).json({\n   453→          error: 'Token has been revoked',\n   454→          message: 'This session has been logged out. Please log in again.'\n   455→        });\n   456→      }\n   457→    }\n   458→\n   459→    // Token is valid and not revoked\n   460→    req.stripeCustomerId = decoded.sub;\n   461→    req.tokenData = decoded;\n   462→    req.rawToken = token; // Store raw token for logout\n   463→    return next();\n   464→  }\n   465→\n   466→  // ==========================================================================\n   467→  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n   468→  // This authentication method is deprecated and will be removed after\n   469→  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n   470→  // ==========================================================================\n   471→  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   472→  if (legacyCustomerId) {\n   473→    // Check if legacy auth is allowed\n   474→    if (!ALLOW_LEGACY_AUTH) {\n   475→      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n   476→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   477→      return res.status(401).json({\n   478→        error: 'Legacy authentication disabled',\n   479→        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n   480→        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n   481→      });\n   482→    }\n   483→\n   484→    // Log deprecation warning with structured logging (once per request)\n   485→    if (!req._legacyAuthWarned) {\n   486→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   487→      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n   488→      req._legacyAuthWarned = true;\n   489→    }\n   490→\n   491→    // Validate format\n   492→    if (!legacyCustomerId.startsWith('cus_')) {\n   493→      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n   494→      return res.status(401).json({\n   495→        error: 'Invalid customer ID format',\n   496→        message: 'Customer ID must start with cus_'\n   497→      });\n   498→    }\n   499→\n   500→    // Set deprecation warning header on the response\n   501→    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n   502→    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n   503→\n   504→    req.stripeCustomerId = legacyCustomerId;\n   505→    req.isLegacyAuth = true;\n   506→    return next();\n   507→  }\n   508→\n   509→  // No authentication provided\n   510→  return res.status(401).json({\n   511→    error: 'Authentication required',\n   512→    message: 'Please provide a valid Bearer token in the Authorization header'\n   513→  });\n   514→}\n   515→\n   516→/**\n   517→ * Optional authentication middleware\n   518→ * Allows unauthenticated access but sets req.stripeCustomerId if token present\n   519→ *\n   520→ * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n   521→ */\n   522→async function optionalAuthentication(req, res, next) {\n   523→  const authHeader = req.headers['authorization'];\n   524→  const token = extractBearerToken(authHeader);\n   525→\n   526→  if (token) {\n   527→    const decoded = await verifyToken(token);\n   528→    if (decoded && decoded.sub) {\n   529→      req.stripeCustomerId = decoded.sub;\n   530→      req.tokenData = decoded;\n   531→    }\n   532→  } else {\n   533→    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n   534→    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   535→    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n   536→      // Only accept legacy auth if allowed\n   537→      if (ALLOW_LEGACY_AUTH) {\n   538→        // Log deprecation warning\n   539→        if (!req._legacyAuthWarned) {\n   540→          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   541→          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n   542→          req._legacyAuthWarned = true;\n   543→        }\n   544→\n   545→        // Set deprecation warning headers\n   546→        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n   547→        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n   548→\n   549→        req.stripeCustomerId = legacyCustomerId;\n   550→        req.isLegacyAuth = true;\n   551→      }\n   552→      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n   553→    }\n   554→  }\n   555→\n   556→  next();\n   557→}\n   558→\n   559→/**\n   560→ * HIGH-007: Database-backed admin role check middleware\n   561→ * Checks the user's role in the database instead of relying on env vars\n   562→ * Requires authenticateToken middleware to run first\n   563→ *\n   564→ * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n   565→ * @param {Object} res - Express response object\n   566→ * @param {Function} next - Express next function\n   567→ */\n   568→async function requireAdmin(req, res, next) {\n   569→  // Must be authenticated first\n   570→  if (!req.stripeCustomerId) {\n   571→    return res.status(401).json({\n   572→      error: 'Authentication required',\n   573→      message: 'Please log in to access this resource'\n   574→    });\n   575→  }\n   576→\n   577→  // Check if database pool is available\n   578→  if (!pool) {\n   579→    console.error('[Auth] Admin check failed: Database pool not available');\n   580→    return res.status(503).json({\n   581→      error: 'Service unavailable',\n   582→      message: 'Admin verification temporarily unavailable'\n   583→    });\n   584→  }\n   585→\n   586→  try {\n   587→    // Query database for user role\n   588→    const result = await pool.query(\n   589→      'SELECT role FROM users WHERE stripe_customer_id = $1',\n   590→      [req.stripeCustomerId]\n   591→    );\n   592→\n   593→    if (!result.rows[0]) {\n   594→      authLogger.logAdminAccessDenied(req, 'User not found in database');\n   595→      return res.status(403).json({\n   596→        error: 'Access denied',\n   597→        message: 'User account not found'\n   598→      });\n   599→    }\n   600→\n   601→    const userRole = result.rows[0].role;\n   602→\n   603→    if (userRole !== 'admin') {\n   604→      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n   605→      return res.status(403).json({\n   606→        error: 'Admin access required',\n   607→        message: 'This action requires administrator privileges'\n   608→      });\n   609→    }\n   610→\n   611→    // User is admin - log and proceed\n   612→    authLogger.logAdminAccess(req);\n   613→    req.isAdmin = true;\n   614→    next();\n   615→  } catch (err) {\n   616→    console.error('[Auth] Admin role check failed:', err.message);\n   617→    return res.status(500).json({\n   618→      error: 'Authorization check failed',\n   619→      message: 'Unable to verify admin privileges'\n   620→    });\n   621→  }\n   622→}\n   623→\n   624→/**\n   625→ * Mask sensitive data for logging\n   626→ * @param {string} key - License key or other sensitive string\n   627→ * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n   628→ */\n   629→function maskSensitiveData(data) {\n   630→  if (!data || typeof data !== 'string') {\n   631→    return '****';\n   632→  }\n   633→\n   634→  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n   635→  if (data.startsWith('SPLICE-')) {\n   636→    const parts = data.split('-');\n   637→    if (parts.length === 5) {\n   638→      return `${parts[0]}-${parts[1]}-****-****-****`;\n   639→    }\n   640→  }\n   641→\n   642→  // For customer IDs (cus_xxxx format)\n   643→  if (data.startsWith('cus_')) {\n   644→    if (data.length > 10) {\n   645→      return `cus_${data.slice(4, 8)}****`;\n   646→    }\n   647→    return 'cus_****';\n   648→  }\n   649→\n   650→  // For JWTs (eyJ... format)\n   651→  if (data.startsWith('eyJ')) {\n   652→    return `${data.slice(0, 10)}...****`;\n   653→  }\n   654→\n   655→  // For emails\n   656→  if (data.includes('@')) {\n   657→    const [local, domain] = data.split('@');\n   658→    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n   659→    return `${maskedLocal}@${domain}`;\n   660→  }\n   661→\n   662→  // Generic masking - show first 4 chars\n   663→  if (data.length > 8) {\n   664→    return `${data.slice(0, 4)}****`;\n   665→  }\n   666→\n   667→  return '****';\n   668→}\n   669→\n   670→module.exports = {\n   671→  generateToken,\n   672→  generateRefreshToken,\n   673→  verifyToken,\n   674→  verifyTokenSync,\n   675→  extractBearerToken,\n   676→  authenticateToken,\n   677→  optionalAuthentication,\n   678→  maskSensitiveData,\n   679→  // HIGH-007: Admin RBAC middleware\n   680→  requireAdmin,\n   681→  // Token blacklist functions\n   682→  blacklistToken,\n   683→  isTokenBlacklisted,\n   684→  getBlacklistStats,\n   685→  // Structured logging\n   686→  authLogger,\n   687→  // Constants\n   688→  JWT_SECRET,\n   689→  JWT_EXPIRES_IN,\n   690→  // Legacy auth deprecation constants\n   691→  LEGACY_AUTH_SUNSET_DATE,\n   692→  ALLOW_LEGACY_AUTH\n   693→};\n   694→\n\n</system-reminder>\n"}]},"uuid":"53e278e7-406a-4d96-ab7a-3474fa832f46","timestamp":"2026-01-12T01:11:57.491Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","content":"/**\n * JWT Authentication Middleware\n *\n * Primary authentication method: JWT Bearer tokens\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n *\n * DEPRECATION NOTICE:\n * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n * - Sunset Date: 2026-04-11\n * - Control: Set ALLOW_LEGACY_AUTH environment variable\n *   - Production default: false (disabled)\n *   - Development default: true (enabled for backward compatibility)\n * - Clients using legacy auth will receive X-Deprecation-Warning headers\n * - After sunset date, legacy auth will be completely removed\n *\n * Migration Guide:\n * 1. Call POST /auth/login with license key to obtain JWT tokens\n * 2. Use Authorization: Bearer <token> header for all authenticated requests\n * 3. Use POST /auth/refresh to refresh expired tokens\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Authentication Methods:\n * - Authorization: Bearer <token> (PREFERRED - use this method)\n * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)\n *\n * DEPRECATION: x-stripe-customer-id header\n * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var\n * - Production: Disabled by default (returns 401)\n * - Development: Enabled by default for backward compatibility\n * - Sunset Date: 2026-04-11 (after which it will be removed entirely)\n * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers\n *\n * @param {Object} req - Express request object\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // ==========================================================================\n  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n  // This authentication method is deprecated and will be removed after\n  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n  // ==========================================================================\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Check if legacy auth is allowed\n    if (!ALLOW_LEGACY_AUTH) {\n      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      return res.status(401).json({\n        error: 'Legacy authentication disabled',\n        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n      });\n    }\n\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    // Set deprecation warning header on the response\n    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n *\n * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      // Only accept legacy auth if allowed\n      if (ALLOW_LEGACY_AUTH) {\n        // Log deprecation warning\n        if (!req._legacyAuthWarned) {\n          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n          req._legacyAuthWarned = true;\n        }\n\n        // Set deprecation warning headers\n        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n        req.stripeCustomerId = legacyCustomerId;\n        req.isLegacyAuth = true;\n      }\n      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN,\n  // Legacy auth deprecation constants\n  LEGACY_AUTH_SUNSET_DATE,\n  ALLOW_LEGACY_AUTH\n};\n","numLines":694,"startLine":1,"totalLines":694}}}
{"parentUuid":"53e278e7-406a-4d96-ab7a-3474fa832f46","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CtrCobf4MdwYYo8JVLjPZs","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Panel Configuration\n     3→ * Backend URLs, paths, and utility functions\n     4→ */\n     5→\n     6→// ============================================================================\n     7→// DEBUG MODE CONFIGURATION\n     8→// ============================================================================\n     9→\n    10→/**\n    11→ * Debug mode flag - enables verbose diagnostic logging\n    12→ * Can be enabled via localStorage for troubleshooting:\n    13→ *   localStorage.setItem('spliceDebugMode', 'true');\n    14→ *\n    15→ * Default: false (production mode - minimal logging)\n    16→ */\n    17→const SPLICE_DEBUG = localStorage.getItem('spliceDebugMode') === 'true';\n    18→\n    19→/**\n    20→ * Debug logging function - only outputs when debug mode is enabled\n    21→ * Use this for diagnostic/development logging that should be silent in production\n    22→ * @param {...any} args - Arguments to log (prefixed with [SPLICE DEBUG])\n    23→ */\n    24→function debugLog(...args) {\n    25→    if (SPLICE_DEBUG) {\n    26→        console.log('[SPLICE DEBUG]', ...args);\n    27→    }\n    28→}\n    29→\n    30→/**\n    31→ * Debug fetch logging - verbose fetch request/response logging\n    32→ * @param {...any} args - Arguments to log (prefixed with [SPLICE FETCH])\n    33→ */\n    34→function debugFetch(...args) {\n    35→    if (SPLICE_DEBUG) {\n    36→        console.log('[SPLICE FETCH]', ...args);\n    37→    }\n    38→}\n    39→\n    40→// ============================================================================\n    41→// BACKEND CONFIGURATION\n    42→// ============================================================================\n    43→const SPLICE_CONFIG = {\n    44→    VERSION: '6.0.3',\n    45→    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    46→    BACKEND_DEV: 'https://127.0.0.1:3847',\n    47→    FETCH_TIMEOUT: 120000, // 2 minutes\n    48→    RETRY_ATTEMPTS: 3,\n    49→    RETRY_DELAY: 1000\n    50→};\n    51→\n    52→/**\n    53→ * Get the backend URL based on environment\n    54→ * FIXED: CEP panels always run from file://, so we default to PROD\n    55→ * Use localStorage to override for local development if needed\n    56→ */\n    57→function getBackendUrl() {\n    58→    // Priority 1: Allow override via localStorage (for local dev testing)\n    59→    const customUrl = localStorage.getItem('spliceBackendUrl');\n    60→    if (customUrl) {\n    61→        debugLog('Using custom backend URL from localStorage:', customUrl);\n    62→        return customUrl;\n    63→    }\n    64→\n    65→    // Priority 2: Default to production backend\n    66→    // (CEP panels always run from file://, so can't reliably detect dev mode)\n    67→    debugLog('Using production backend URL:', SPLICE_CONFIG.BACKEND_PROD);\n    68→    return SPLICE_CONFIG.BACKEND_PROD;\n    69→}\n    70→\n    71→// ============================================================================\n    72→// JSX BRIDGE - Communicate with Premiere Pro\n    73→// ============================================================================\n    74→const jsx = {\n    75→    cs: null,\n    76→    _initPromise: null,\n    77→    _initialized: false,\n    78→\n    79→    /**\n    80→     * Initialize the CSInterface\n    81→     * Returns a promise that resolves when ready (true/false)\n    82→     * Does NOT reject - gracefully handles missing CEP environment\n    83→     */\n    84→    init: function() {\n    85→        if (this._initPromise) return this._initPromise;\n    86→\n    87→        this._initPromise = new Promise((resolve) => {\n    88→            try {\n    89→                if (typeof CSInterface !== 'undefined') {\n    90→                    this.cs = new CSInterface();\n    91→                    // Verify we're in a real CEP environment by checking for __adobe_cep__\n    92→                    if (window.__adobe_cep__) {\n    93→                        this._initialized = true;\n    94→                        debugLog('[JSX] CSInterface initialized successfully (CEP environment detected)');\n    95→                    } else {\n    96→                        // CSInterface exists but no CEP runtime - browser/dev mode\n    97→                        this._initialized = true;\n    98→                        debugLog('[JSX] CSInterface initialized (development/browser mode)');\n    99→                    }\n   100→                } else {\n   101→                    console.warn('[JSX] CSInterface not available - panel may not function correctly');\n   102→                    this._initialized = false;\n   103→                }\n   104→            } catch (err) {\n   105→                console.error('[JSX] Failed to initialize CSInterface:', err);\n   106→                this._initialized = false;\n   107→            }\n   108→            resolve(this._initialized);\n   109→        });\n   110→\n   111→        return this._initPromise;\n   112→    },\n   113→\n   114→    /**\n   115→     * Ensure JSX is initialized before making calls\n   116→     */\n   117→    ensureInitialized: async function() {\n   118→        if (!this._initialized) {\n   119→            await this.init();\n   120→        }\n   121→        if (!this.cs) {\n   122→            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n   123→        }\n   124→    },\n   125→\n   126→    /**\n   127→     * Execute ExtendScript in Premiere Pro\n   128→     * @param {string} script - ExtendScript to execute\n   129→     * @returns {Promise<any>} - Parsed result\n   130→     */\n   131→    evalScript: async function(script) {\n   132→        await this.ensureInitialized();\n   133→\n   134→        return new Promise((resolve, reject) => {\n   135→            this.cs.evalScript(script, (result) => {\n   136→                if (result === 'undefined' || result === undefined) {\n   137→                    resolve(null);\n   138→                    return;\n   139→                }\n   140→\n   141→                // Check for EvalScript error or ExtendScript runtime errors\n   142→                if (typeof result === 'string' && (\n   143→                    result.indexOf('EvalScript error') !== -1 ||\n   144→                    result.indexOf('Error:') !== -1 ||\n   145→                    result.indexOf('TypeError:') !== -1 ||\n   146→                    result.indexOf('ReferenceError:') !== -1\n   147→                )) {\n   148→                    reject(new Error(result));\n   149→                    return;\n   150→                }\n   151→\n   152→                // Try to parse JSON\n   153→                try {\n   154→                    const parsed = JSON.parse(result);\n   155→                    if (parsed.error) {\n   156→                        reject(new Error(parsed.error));\n   157→                    } else {\n   158→                        resolve(parsed);\n   159→                    }\n   160→                } catch (e) {\n   161→                    // Return as-is if not JSON\n   162→                    resolve(result);\n   163→                }\n   164→            });\n   165→        });\n   166→    },\n   167→\n   168→    /**\n   169→     * Call a JSX function with arguments\n   170→     * @param {string} funcName - Function name\n   171→     * @param {...any} args - Arguments to pass\n   172→     * @returns {Promise<any>}\n   173→     */\n   174→    call: async function(funcName, ...args) {\n   175→        await this.ensureInitialized();\n   176→\n   177→        const escapedArgs = args.map(arg => {\n   178→            if (arg === null || arg === undefined) return 'null';\n   179→            if (typeof arg === 'string') {\n   180→                // Escape backslashes first, then other special chars\n   181→                return `'${arg\n   182→                    .replace(/\\\\/g, '\\\\\\\\')\n   183→                    .replace(/'/g, \"\\\\'\")\n   184→                    .replace(/\\r/g, '\\\\r')\n   185→                    .replace(/\\n/g, '\\\\n')\n   186→                    .replace(/\\t/g, '\\\\t')}'`;\n   187→            }\n   188→            if (typeof arg === 'object') {\n   189→                return `'${JSON.stringify(arg)\n   190→                    .replace(/\\\\/g, '\\\\\\\\')\n   191→                    .replace(/'/g, \"\\\\'\")}'`;\n   192→            }\n   193→            return String(arg);\n   194→        });\n   195→\n   196→        const script = `${funcName}(${escapedArgs.join(', ')})`;\n   197→        return this.evalScript(script);\n   198→    }\n   199→};\n   200→\n   201→// ============================================================================\n   202→// FETCH UTILITIES\n   203→// ============================================================================\n   204→\n   205→/**\n   206→ * Fetch with timeout support\n   207→ * @param {string} url - URL to fetch\n   208→ * @param {object} options - Fetch options\n   209→ * @param {number} timeout - Timeout in ms\n   210→ */\n   211→async function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n   212→    // DIAGNOSTIC: Log fetch request details (debug mode only)\n   213→    debugFetch('=== FETCH REQUEST START ===');\n   214→    debugFetch('URL:', url);\n   215→    debugFetch('Method:', options?.method || 'GET');\n   216→    debugFetch('Headers:', options?.headers);\n   217→    debugFetch('Timeout:', timeout);\n   218→    debugFetch('Is CEP environment:', typeof CSInterface !== 'undefined');\n   219→    debugFetch('=================================');\n   220→\n   221→    const controller = new AbortController();\n   222→    const timeoutId = setTimeout(() => controller.abort(), timeout);\n   223→\n   224→    try {\n   225→        const response = await fetch(url, {\n   226→            ...options,\n   227→            signal: controller.signal\n   228→        });\n   229→        clearTimeout(timeoutId);\n   230→\n   231→        // DIAGNOSTIC: Log successful response (debug mode only)\n   232→        debugFetch('=== FETCH RESPONSE SUCCESS ===');\n   233→        debugFetch('Status:', response.status);\n   234→        debugFetch('OK:', response.ok);\n   235→        debugFetch('=================================');\n   236→\n   237→        return response;\n   238→    } catch (error) {\n   239→        clearTimeout(timeoutId);\n   240→\n   241→        // DIAGNOSTIC: Log raw fetch error (debug mode only)\n   242→        debugFetch('=== FETCH ERROR CAUGHT ===');\n   243→        debugFetch('Error name:', error?.name);\n   244→        debugFetch('Error message:', error?.message);\n   245→        debugFetch('Error type:', typeof error);\n   246→        debugFetch('Error constructor:', error?.constructor?.name);\n   247→        debugFetch('Is AbortError:', error.name === 'AbortError');\n   248→        debugFetch('Is TypeError:', error.name === 'TypeError');\n   249→        debugFetch('Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\n   250→        debugFetch('=================================');\n   251→\n   252→        if (error.name === 'AbortError') {\n   253→            throw new Error(`Request timeout after ${timeout}ms`);\n   254→        }\n   255→        throw error;\n   256→    }\n   257→}\n   258→\n   259→/**\n   260→ * Parse error response from backend\n   261→ * @param {Response} response - Fetch response\n   262→ */\n   263→async function parseErrorResponse(response) {\n   264→    try {\n   265→        const data = await response.json();\n   266→        return data.error || data.message || `HTTP ${response.status}`;\n   267→    } catch {\n   268→        return `HTTP ${response.status}: ${response.statusText}`;\n   269→    }\n   270→}\n   271→\n   272→/**\n   273→ * Get auth headers for API requests\n   274→ * Uses JWT Bearer token if available, with legacy fallback\n   275→ */\n   276→function getAuthHeaders() {\n   277→    const headers = { 'Content-Type': 'application/json' };\n   278→    const settings = getSettings();\n   279→\n   280→    // Prefer JWT Bearer token (modern auth)\n   281→    if (settings.accessToken) {\n   282→        headers['Authorization'] = `Bearer ${settings.accessToken}`;\n   283→        return headers;\n   284→    }\n   285→\n   286→    // Legacy fallback for backwards compatibility\n   287→    // This will be removed after 2026-04-11\n   288→    if (settings.customerId) {\n   289→        headers['x-stripe-customer-id'] = settings.customerId;\n   290→        console.warn('[SPLICE] Using deprecated x-stripe-customer-id header. Please re-login to upgrade to JWT auth.');\n   291→    }\n   292→\n   293→    return headers;\n   294→}\n   295→\n   296→/**\n   297→ * Check if the access token is expired or about to expire\n   298→ * @returns {boolean} True if token needs refresh\n   299→ */\n   300→function isTokenExpired() {\n   301→    const settings = getSettings();\n   302→    if (!settings.tokenExpiry) return true;\n   303→\n   304→    // Refresh if less than 5 minutes remaining\n   305→    const bufferMs = 5 * 60 * 1000;\n   306→    return Date.now() >= (settings.tokenExpiry - bufferMs);\n   307→}\n   308→\n   309→/**\n   310→ * Refresh the access token using the refresh token\n   311→ * @returns {Promise<boolean>} True if refresh succeeded\n   312→ */\n   313→async function refreshAccessToken() {\n   314→    const settings = getSettings();\n   315→\n   316→    if (!settings.refreshToken) {\n   317→        debugLog('[Auth] No refresh token available');\n   318→        return false;\n   319→    }\n   320→\n   321→    try {\n   322→        debugLog('[Auth] Refreshing access token...');\n   323→\n   324→        const response = await fetchWithTimeout(`${getBackendUrl()}/auth/refresh`, {\n   325→            method: 'POST',\n   326→            headers: { 'Content-Type': 'application/json' },\n   327→            body: JSON.stringify({ refreshToken: settings.refreshToken })\n   328→        }, 30000);\n   329→\n   330→        if (!response.ok) {\n   331→            const errorMsg = await parseErrorResponse(response);\n   332→            console.error('[Auth] Token refresh failed:', errorMsg);\n   333→\n   334→            // If refresh token is invalid, clear auth and require re-login\n   335→            if (response.status === 401) {\n   336→                clearAuthTokens();\n   337→            }\n   338→            return false;\n   339→        }\n   340→\n   341→        const data = await response.json();\n   342→\n   343→        // Save new access token\n   344→        const expiresInMs = (data.expiresIn || 86400) * 1000; // Default 24h\n   345→        saveSettings({\n   346→            accessToken: data.token,\n   347→            tokenExpiry: Date.now() + expiresInMs\n   348→        });\n   349→\n   350→        debugLog('[Auth] Access token refreshed successfully');\n   351→        return true;\n   352→    } catch (err) {\n   353→        console.error('[Auth] Token refresh error:', err);\n   354→        return false;\n   355→    }\n   356→}\n   357→\n   358→/**\n   359→ * Clear all auth tokens (call on logout or auth failure)\n   360→ */\n   361→function clearAuthTokens() {\n   362→    saveSettings({\n   363→        accessToken: null,\n   364→        refreshToken: null,\n   365→        tokenExpiry: null\n   366→    });\n   367→    debugLog('[Auth] Auth tokens cleared');\n   368→}\n   369→\n   370→/**\n   371→ * Ensure we have a valid access token, refreshing if needed\n   372→ * @returns {Promise<boolean>} True if we have a valid token\n   373→ */\n   374→async function ensureValidToken() {\n   375→    const settings = getSettings();\n   376→\n   377→    // No token at all - need to login\n   378→    if (!settings.accessToken) {\n   379→        return false;\n   380→    }\n   381→\n   382→    // Token not expired - good to go\n   383→    if (!isTokenExpired()) {\n   384→        return true;\n   385→    }\n   386→\n   387→    // Try to refresh\n   388→    return await refreshAccessToken();\n   389→}\n   390→\n   391→// ============================================================================\n   392→// SETTINGS MANAGEMENT\n   393→// ============================================================================\n   394→\n   395→const DEFAULT_SETTINGS = {\n   396→    sensitivity: 50,\n   397→    minSilenceLength: 0.5,\n   398→    sourceIsolated: false,\n   399→    enableTakesDetection: true,\n   400→    enableJCut: false,\n   401→    jcutLeadIn: 0.3,\n   402→    jcutLeadOut: 0.2,\n   403→    enableZoom: false,\n   404→    zoomFrequency: 'medium',\n   405→    zoomPreset: 'medium',\n   406→    zoomPlacement: 'sentence_start',\n   407→    enableChapters: false,\n   408→    maxChapters: 10,\n   409→    minChapterLength: 60,\n   410→    enableProfanity: false,\n   411→    profanityLanguage: 'en',\n   412→    bleepType: 'standard',\n   413→    // Authentication\n   414→    customerId: null,\n   415→    licenseKey: null,\n   416→    accessToken: null,\n   417→    refreshToken: null,\n   418→    tokenExpiry: null,\n   419→    // UI State\n   420→    expandedOptions: false,\n   421→    activePreset: 'podcast',\n   422→    rememberOptions: false\n   423→};\n   424→\n   425→// Current storage version for future migrations\n   426→const SETTINGS_STORAGE_VERSION = 2;\n   427→\n   428→// Fields that contain sensitive data and should be encrypted\n   429→const SENSITIVE_FIELDS = ['customerId', 'licenseKey', 'accessToken', 'refreshToken'];\n   430→\n   431→// ============================================================================\n   432→// ENCRYPTION HELPERS FOR SENSITIVE DATA\n   433→// ============================================================================\n   434→\n   435→/**\n   436→ * Simple obfuscation for localStorage\n   437→ * NOTE: This is NOT cryptographically secure, but provides basic protection\n   438→ * against casual inspection of localStorage. For truly sensitive data,\n   439→ * consider server-side storage or proper encryption libraries.\n   440→ *\n   441→ * @param {any} data - Data to encode\n   442→ * @returns {string|null} Encoded string or null on error\n   443→ */\n   444→function encryptForStorage(data) {\n   445→    try {\n   446→        if (data === null || data === undefined) {\n   447→            return null;\n   448→        }\n   449→        // Double encode to add slight obfuscation layer\n   450→        const jsonStr = JSON.stringify(data);\n   451→        const encoded = encodeURIComponent(jsonStr);\n   452→        return btoa(encoded);\n   453→    } catch (e) {\n   454→        debugLog('[Config] Encryption error:', e);\n   455→        return null;\n   456→    }\n   457→}\n   458→\n   459→/**\n   460→ * Decode obfuscated data from localStorage\n   461→ *\n   462→ * @param {string} data - Encoded string\n   463→ * @returns {any|null} Decoded data or null on error\n   464→ */\n   465→function decryptFromStorage(data) {\n   466→    try {\n   467→        if (!data || typeof data !== 'string') {\n   468→            return null;\n   469→        }\n   470→        const decoded = atob(data);\n   471→        const jsonStr = decodeURIComponent(decoded);\n   472→        return JSON.parse(jsonStr);\n   473→    } catch (e) {\n   474→        // This is expected for unencrypted legacy data - don't log as warning\n   475→        return null;\n   476→    }\n   477→}\n   478→\n   479→/**\n   480→ * Check if a value appears to be encrypted (base64 encoded JSON)\n   481→ *\n   482→ * @param {any} value - Value to check\n   483→ * @returns {boolean} True if value appears to be encrypted\n   484→ */\n   485→function isEncryptedValue(value) {\n   486→    if (!value || typeof value !== 'string') {\n   487→        return false;\n   488→    }\n   489→    // Unencrypted values typically start with known patterns\n   490→    // (e.g., \"cus_\" for Stripe customer IDs, \"SPLICE-\" for license keys)\n   491→    if (value.startsWith('cus_') || value.startsWith('SPLICE-')) {\n   492→        return false;\n   493→    }\n   494→    // Check if it's a valid base64 string that decodes to valid JSON\n   495→    try {\n   496→        const decoded = atob(value);\n   497→        const jsonStr = decodeURIComponent(decoded);\n   498→        JSON.parse(jsonStr);\n   499→        return true;\n   500→    } catch {\n   501→        return false;\n   502→    }\n   503→}\n   504→\n   505→/**\n   506→ * Encrypt sensitive fields in settings object\n   507→ *\n   508→ * @param {Object} settings - Settings object with plaintext sensitive fields\n   509→ * @returns {Object} Settings with encrypted sensitive fields\n   510→ */\n   511→function encryptSensitiveFields(settings) {\n   512→    const encrypted = { ...settings };\n   513→\n   514→    for (const field of SENSITIVE_FIELDS) {\n   515→        if (encrypted[field] !== null && encrypted[field] !== undefined) {\n   516→            // Only encrypt if not already encrypted\n   517→            if (!isEncryptedValue(encrypted[field])) {\n   518→                encrypted[field] = encryptForStorage(encrypted[field]);\n   519→                debugLog(`[Config] Encrypted field: ${field}`);\n   520→            }\n   521→        }\n   522→    }\n   523→\n   524→    return encrypted;\n   525→}\n   526→\n   527→/**\n   528→ * Decrypt sensitive fields in settings object\n   529→ *\n   530→ * @param {Object} settings - Settings object with encrypted sensitive fields\n   531→ * @returns {Object} Settings with decrypted sensitive fields\n   532→ */\n   533→function decryptSensitiveFields(settings) {\n   534→    const decrypted = { ...settings };\n   535→\n   536→    for (const field of SENSITIVE_FIELDS) {\n   537→        if (decrypted[field] !== null && decrypted[field] !== undefined) {\n   538→            // Check if it looks encrypted before attempting to decrypt\n   539→            if (isEncryptedValue(decrypted[field])) {\n   540→                const decryptedValue = decryptFromStorage(decrypted[field]);\n   541→                if (decryptedValue !== null) {\n   542→                    decrypted[field] = decryptedValue;\n   543→                    debugLog(`[Config] Decrypted field: ${field}`);\n   544→                }\n   545→            }\n   546→            // If not encrypted (legacy data), keep the original value\n   547→        }\n   548→    }\n   549→\n   550→    return decrypted;\n   551→}\n   552→\n   553→/**\n   554→ * Internal save function to avoid recursion during migration\n   555→ * @private\n   556→ */\n   557→function _saveSettingsInternal(settings) {\n   558→    try {\n   559→        // Encrypt sensitive fields before storing\n   560→        const toStore = encryptSensitiveFields(settings);\n   561→\n   562→        // Add version marker for future migrations\n   563→        toStore._storageVersion = SETTINGS_STORAGE_VERSION;\n   564→\n   565→        localStorage.setItem('spliceSettings', JSON.stringify(toStore));\n   566→        return true;\n   567→    } catch (e) {\n   568→        console.warn('[Config] Error saving settings:', e);\n   569→        return false;\n   570→    }\n   571→}\n   572→\n   573→/**\n   574→ * Get settings from localStorage\n   575→ * Handles migration from unencrypted to encrypted storage format\n   576→ */\n   577→function getSettings() {\n   578→    try {\n   579→        const stored = localStorage.getItem('spliceSettings');\n   580→        if (stored) {\n   581→            const parsed = JSON.parse(stored);\n   582→\n   583→            // Decrypt sensitive fields (handles both encrypted and legacy unencrypted data)\n   584→            const decrypted = decryptSensitiveFields(parsed);\n   585→\n   586→            // Check if migration is needed (no version marker = legacy data)\n   587→            if (!parsed._storageVersion) {\n   588→                // Migrate legacy data: save with encryption and version marker\n   589→                debugLog('[Config] Migrating legacy settings to encrypted format');\n   590→                const migratedSettings = { ...DEFAULT_SETTINGS, ...decrypted };\n   591→                // Use internal save to avoid infinite recursion\n   592→                _saveSettingsInternal(migratedSettings);\n   593→            }\n   594→\n   595→            // Return merged settings without internal fields\n   596→            const result = { ...DEFAULT_SETTINGS, ...decrypted };\n   597→            delete result._storageVersion;\n   598→            return result;\n   599→        }\n   600→    } catch (e) {\n   601→        console.warn('[Config] Error loading settings:', e);\n   602→    }\n   603→    return { ...DEFAULT_SETTINGS };\n   604→}\n   605→\n   606→/**\n   607→ * Save settings to localStorage\n   608→ * Encrypts sensitive fields before storing\n   609→ */\n   610→function saveSettings(settings) {\n   611→    try {\n   612→        // Get current settings (decrypted) and merge with new settings\n   613→        const current = getSettings();\n   614→        const merged = { ...current, ...settings };\n   615→\n   616→        return _saveSettingsInternal(merged);\n   617→    } catch (e) {\n   618→        console.warn('[Config] Error saving settings:', e);\n   619→        return false;\n   620→    }\n   621→}\n   622→\n   623→/**\n   624→ * Clear specific setting\n   625→ */\n   626→function clearSetting(key) {\n   627→    const settings = getSettings();\n   628→    delete settings[key];\n   629→    _saveSettingsInternal(settings);\n   630→}\n   631→\n   632→// ============================================================================\n   633→// OFFLINE DETECTION\n   634→// ============================================================================\n   635→\n   636→let isOnlineState = true;\n   637→let offlineCheckInterval = null;\n   638→\n   639→/**\n   640→ * Check if online\n   641→ */\n   642→function isOnline() {\n   643→    return isOnlineState && navigator.onLine;\n   644→}\n   645→\n   646→/**\n   647→ * Initialize offline detection\n   648→ */\n   649→function initOfflineDetection() {\n   650→    // Browser events\n   651→    window.addEventListener('online', () => {\n   652→        isOnlineState = true;\n   653→        updateOfflineUI(true);\n   654→    });\n   655→\n   656→    window.addEventListener('offline', () => {\n   657→        isOnlineState = false;\n   658→        updateOfflineUI(false);\n   659→    });\n   660→\n   661→    // Periodic check\n   662→    offlineCheckInterval = setInterval(async () => {\n   663→        try {\n   664→            const response = await fetchWithTimeout(\n   665→                `${getBackendUrl()}/health`,\n   666→                { method: 'GET' },\n   667→                5000\n   668→            );\n   669→            isOnlineState = response.ok;\n   670→        } catch {\n   671→            isOnlineState = false;\n   672→        }\n   673→        updateOfflineUI(isOnlineState);\n   674→    }, 30000);\n   675→}\n   676→\n   677→/**\n   678→ * Update UI based on online state\n   679→ */\n   680→function updateOfflineUI(online) {\n   681→    const goBtn = document.getElementById('goBtn');\n   682→    const status = document.getElementById('status');\n   683→\n   684→    if (goBtn) {\n   685→        goBtn.disabled = !online;\n   686→    }\n   687→\n   688→    if (status) {\n   689→        if (!online) {\n   690→            status.textContent = 'Offline - Check your connection';\n   691→            status.style.color = '#dc3545';\n   692→        } else {\n   693→            // Reset status when back online\n   694→            status.textContent = 'Ready';\n   695→            status.style.color = '#888';\n   696→        }\n   697→    }\n   698→}\n   699→\n   700→// ============================================================================\n   701→// UTILITY FUNCTIONS\n   702→// ============================================================================\n   703→\n   704→/**\n   705→ * SECURITY: Escape HTML to prevent XSS attacks\n   706→ * Use this when inserting untrusted content into innerHTML\n   707→ * @param {string} str - String to escape\n   708→ * @returns {string} Escaped string safe for innerHTML\n   709→ */\n   710→function escapeHtml(str) {\n   711→    if (str === null || str === undefined) return '';\n   712→    if (typeof str !== 'string') str = String(str);\n   713→\n   714→    const escapeMap = {\n   715→        '&': '&amp;',\n   716→        '<': '&lt;',\n   717→        '>': '&gt;',\n   718→        '\"': '&quot;',\n   719→        \"'\": '&#x27;',\n   720→        '/': '&#x2F;',\n   721→        '`': '&#x60;'\n   722→    };\n   723→\n   724→    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n   725→}\n   726→\n   727→/**\n   728→ * SECURITY: Create safe HTML from template with escaped values\n   729→ * @param {TemplateStringsArray} strings - Template strings\n   730→ * @param {...any} values - Values to escape\n   731→ * @returns {string} HTML with escaped values\n   732→ */\n   733→function safeHtml(strings, ...values) {\n   734→    return strings.reduce((result, str, i) => {\n   735→        const value = values[i - 1];\n   736→        const escaped = escapeHtml(value);\n   737→        return result + escaped + str;\n   738→    });\n   739→}\n   740→\n   741→/**\n   742→ * Format time in MM:SS or HH:MM:SS\n   743→ */\n   744→function formatTime(seconds) {\n   745→    if (isNaN(seconds) || seconds < 0) return '0:00';\n   746→\n   747→    const hours = Math.floor(seconds / 3600);\n   748→    const minutes = Math.floor((seconds % 3600) / 60);\n   749→    const secs = Math.floor(seconds % 60);\n   750→\n   751→    if (hours > 0) {\n   752→        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n   753→    }\n   754→    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n   755→}\n   756→\n   757→/**\n   758→ * Set status message\n   759→ */\n   760→function setStatus(message, isError = false) {\n   761→    const status = document.getElementById('status');\n   762→    if (status) {\n   763→        status.textContent = message;\n   764→        status.style.color = isError ? '#dc3545' : '#888';\n   765→    }\n   766→}\n   767→\n   768→/**\n   769→ * Debounce function calls\n   770→ */\n   771→function debounce(func, wait) {\n   772→    let timeout;\n   773→    return function executedFunction(...args) {\n   774→        const later = () => {\n   775→            clearTimeout(timeout);\n   776→            func(...args);\n   777→        };\n   778→        clearTimeout(timeout);\n   779→        timeout = setTimeout(later, wait);\n   780→    };\n   781→}\n   782→\n   783→// ============================================================================\n   784→// PRESET PROFILES\n   785→// ============================================================================\n   786→\n   787→/**\n   788→ * Detection presets for different content types.\n   789→ * Each preset defines optimal settings for a specific use case.\n   790→ */\n   791→const PRESETS = {\n   792→    // Custom - user-defined settings (default)\n   793→    custom: {\n   794→        name: 'Custom',\n   795→        description: 'Your custom settings',\n   796→        icon: 'settings',\n   797→        settings: null // Uses current user settings\n   798→    },\n   799→\n   800→    // Podcast - longer pauses are natural, be conservative\n   801→    podcast: {\n   802→        name: 'Podcast',\n   803→        description: 'Longer natural pauses, J-Cuts enabled',\n   804→        icon: 'mic',\n   805→        settings: {\n   806→            sensitivity: 35,\n   807→            threshold: -35,\n   808→            minSilenceLength: 0.8,\n   809→            paddingStart: 0.15,\n   810→            paddingEnd: 0.15,\n   811→            enableTakesDetection: true,\n   812→            enableJCut: true,\n   813→            jCutLeadIn: 0.3,\n   814→            jCutLeadOut: 0.2\n   815→        }\n   816→    },\n   817→\n   818→    // Interview - balanced, respects speaker pauses\n   819→    interview: {\n   820→        name: 'Interview',\n   821→        description: 'Balanced cuts, J-Cuts for smooth transitions',\n   822→        icon: 'people',\n   823→        settings: {\n   824→            sensitivity: 50,\n   825→            threshold: -32,\n   826→            minSilenceLength: 0.5,\n   827→            paddingStart: 0.12,\n   828→            paddingEnd: 0.08,\n   829→            enableTakesDetection: true,\n   830→            enableJCut: true,\n   831→            jCutLeadIn: 0.25,\n   832→            jCutLeadOut: 0.15\n   833→        }\n   834→    },\n   835→\n   836→    // Reaction video - fast pacing, quick cuts\n   837→    reaction: {\n   838→        name: 'Reaction',\n   839→        description: 'Fast-paced, tight cuts for energy',\n   840→        icon: 'bolt',\n   841→        settings: {\n   842→            sensitivity: 70,\n   843→            threshold: -28,\n   844→            minSilenceLength: 0.3,\n   845→            paddingStart: 0.05,\n   846→            paddingEnd: 0.03,\n   847→            enableTakesDetection: false,\n   848→            enableJCut: false,\n   849→            jCutLeadIn: 0,\n   850→            jCutLeadOut: 0\n   851→        }\n   852→    },\n   853→\n   854→    // Tutorial/Educational - preserve thinking pauses\n   855→    tutorial: {\n   856→        name: 'Tutorial',\n   857→        description: 'Preserves teaching pace, J-Cuts enabled',\n   858→        icon: 'school',\n   859→        settings: {\n   860→            sensitivity: 30,\n   861→            threshold: -38,\n   862→            minSilenceLength: 1.0,\n   863→            paddingStart: 0.2,\n   864→            paddingEnd: 0.15,\n   865→            enableTakesDetection: true,\n   866→            enableJCut: true,\n   867→            jCutLeadIn: 0.35,\n   868→            jCutLeadOut: 0.25\n   869→        }\n   870→    },\n   871→\n   872→    // Vlog/YouTube - punchy edits, engagement-focused\n   873→    vlog: {\n   874→        name: 'Vlog',\n   875→        description: 'Punchy edits for YouTube engagement',\n   876→        icon: 'videocam',\n   877→        settings: {\n   878→            sensitivity: 65,\n   879→            threshold: -30,\n   880→            minSilenceLength: 0.35,\n   881→            paddingStart: 0.08,\n   882→            paddingEnd: 0.05,\n   883→            enableTakesDetection: true,\n   884→            enableJCut: false,\n   885→            jCutLeadIn: 0,\n   886→            jCutLeadOut: 0\n   887→        }\n   888→    }\n   889→};\n   890→\n   891→/**\n   892→ * List of built-in preset IDs\n   893→ */\n   894→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n   895→\n   896→/**\n   897→ * Get all available presets\n   898→ * @returns {Object} All preset definitions\n   899→ */\n   900→function getPresets() {\n   901→    return { ...PRESETS };\n   902→}\n   903→\n   904→/**\n   905→ * Get a specific preset by name\n   906→ * @param {string} presetName - Name of the preset\n   907→ * @returns {Object|null} Preset definition or null if not found\n   908→ */\n   909→function getPreset(presetName) {\n   910→    return PRESETS[presetName] || null;\n   911→}\n   912→\n   913→/**\n   914→ * Check if a preset is a built-in preset\n   915→ * @param {string} id - Preset ID to check\n   916→ * @returns {boolean} True if built-in, false if custom\n   917→ */\n   918→function isBuiltInPreset(id) {\n   919→    return BUILT_IN_PRESET_IDS.includes(id);\n   920→}\n   921→\n   922→/**\n   923→ * Apply a preset to current settings\n   924→ * @param {string} presetName - Name of the preset to apply\n   925→ * @returns {Object} The applied settings\n   926→ */\n   927→function applyPreset(presetName) {\n   928→    const preset = PRESETS[presetName];\n   929→\n   930→    if (!preset) {\n   931→        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n   932→        return getSettings();\n   933→    }\n   934→\n   935→    // Custom preset uses current settings\n   936→    if (presetName === 'custom' || !preset.settings) {\n   937→        saveSettings({ activePreset: 'custom' });\n   938→        return getSettings();\n   939→    }\n   940→\n   941→    // Apply preset settings\n   942→    const newSettings = {\n   943→        ...preset.settings,\n   944→        activePreset: presetName\n   945→    };\n   946→\n   947→    saveSettings(newSettings);\n   948→    debugLog(`Applied preset: ${preset.name}`);\n   949→\n   950→    return getSettings();\n   951→}\n   952→\n   953→/**\n   954→ * Get the currently active preset\n   955→ * @returns {string} Active preset name\n   956→ */\n   957→function getActivePreset() {\n   958→    const settings = getSettings();\n   959→    return settings.activePreset || 'custom';\n   960→}\n   961→\n   962→/**\n   963→ * Initialize preset selector\n   964→ */\n   965→function initPresetSelector() {\n   966→    const presetSelector = document.getElementById('presetSelector');\n   967→    const sensitivitySlider = document.getElementById('sensitivitySlider');\n   968→\n   969→    if (!presetSelector) return;\n   970→\n   971→    // Set initial value from settings\n   972→    const settings = getSettings();\n   973→    presetSelector.value = settings.activePreset || 'podcast';\n   974→\n   975→    // Handle preset change\n   976→    presetSelector.addEventListener('change', () => {\n   977→        const presetId = presetSelector.value;\n   978→        const appliedSettings = applyPreset(presetId);\n   979→\n   980→        // Update sensitivity slider to match preset\n   981→        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n   982→            sensitivitySlider.value = appliedSettings.sensitivity;\n   983→            // Update display value\n   984→            const sensitivityValue = document.getElementById('sensitivityValue');\n   985→            if (sensitivityValue) {\n   986→                sensitivityValue.textContent = appliedSettings.sensitivity;\n   987→            }\n   988→        }\n   989→\n   990→        // Update takes detection checkbox\n   991→        const enableTakesDetection = document.getElementById('enableTakesDetection');\n   992→        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n   993→            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n   994→        }\n   995→\n   996→        // Update J-Cut checkbox\n   997→        const enableJCut = document.getElementById('enableJCut');\n   998→        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n   999→            enableJCut.checked = appliedSettings.enableJCut;\n  1000→            // Toggle J-Cut settings visibility\n  1001→            const jcutSettings = document.getElementById('jcutSettings');\n  1002→            if (jcutSettings) {\n  1003→                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n  1004→            }\n  1005→        }\n  1006→\n  1007→        const preset = getPreset(presetId);\n  1008→        if (preset) {\n  1009→            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n  1010→        }\n  1011→    });\n  1012→\n  1013→    // Switch to custom when user manually changes sensitivity\n  1014→    if (sensitivitySlider) {\n  1015→        sensitivitySlider.addEventListener('change', () => {\n  1016→            if (presetSelector.value !== 'custom') {\n  1017→                presetSelector.value = 'custom';\n  1018→                saveSettings({ activePreset: 'custom' });\n  1019→            }\n  1020→        });\n  1021→    }\n  1022→}\n  1023→\n  1024→// ============================================================================\n  1025→// LOGIN MODAL\n  1026→// ============================================================================\n  1027→\n  1028→/**\n  1029→ * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n  1030→ * Character set excludes confusing chars: 0/O, 1/I/L\n  1031→ */\n  1032→function isValidLicenseKeyFormat(key) {\n  1033→    if (!key || typeof key !== 'string') return false;\n  1034→    const normalized = key.toUpperCase().trim();\n  1035→    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n  1036→    return pattern.test(normalized);\n  1037→}\n  1038→\n  1039→/**\n  1040→ * Initialize login modal handlers\n  1041→ */\n  1042→function initLoginModal() {\n  1043→    const loginModal = document.getElementById('loginModal');\n  1044→    const closeLoginBtn = document.getElementById('closeLoginBtn');\n  1045→    const saveLoginBtn = document.getElementById('saveLoginBtn');\n  1046→    const licenseKeyInput = document.getElementById('licenseKeyInput');\n  1047→    const creditBadge = document.getElementById('creditBadge');\n  1048→\n  1049→    // Handle credit badge click - retry on error, or show login modal\n  1050→    if (creditBadge) {\n  1051→        creditBadge.addEventListener('click', async () => {\n  1052→            if (creditBadge.classList.contains('error')) {\n  1053→                creditBadge.textContent = '...';\n  1054→                if (typeof refreshCredits === 'function') {\n  1055→                    await refreshCredits();\n  1056→                }\n  1057→                return;\n  1058→            }\n  1059→            showLoginModal();\n  1060→        });\n  1061→    }\n  1062→\n  1063→    // Close login modal\n  1064→    if (closeLoginBtn && loginModal) {\n  1065→        closeLoginBtn.addEventListener('click', () => {\n  1066→            loginModal.classList.add('hidden');\n  1067→        });\n  1068→    }\n  1069→\n  1070→    // Close on backdrop click\n  1071→    if (loginModal) {\n  1072→        loginModal.addEventListener('click', (e) => {\n  1073→            if (e.target === loginModal) {\n  1074→                loginModal.classList.add('hidden');\n  1075→            }\n  1076→        });\n  1077→    }\n  1078→\n  1079→    // Activate license key\n  1080→    if (saveLoginBtn) {\n  1081→        saveLoginBtn.addEventListener('click', async () => {\n  1082→            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n  1083→\n  1084→            if (!licenseKey) {\n  1085→                showLoginError('Please enter your license key');\n  1086→                return;\n  1087→            }\n  1088→\n  1089→            if (!isValidLicenseKeyFormat(licenseKey)) {\n  1090→                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n  1091→                return;\n  1092→            }\n  1093→\n  1094→            saveLoginBtn.disabled = true;\n  1095→            saveLoginBtn.textContent = 'Activating...';\n  1096→\n  1097→            try {\n  1098→                // Use /auth/login endpoint which returns JWT tokens\n  1099→                const response = await fetchWithTimeout(`${getBackendUrl()}/auth/login`, {\n  1100→                    method: 'POST',\n  1101→                    headers: { 'Content-Type': 'application/json' },\n  1102→                    body: JSON.stringify({ licenseKey: licenseKey })\n  1103→                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n  1104→\n  1105→                const result = await response.json();\n  1106→\n  1107→                if (!result.success) {\n  1108→                    showLoginError(result.error || 'Activation failed');\n  1109→                    return;\n  1110→                }\n  1111→\n  1112→                // Store JWT tokens and customer info\n  1113→                const expiresInMs = (result.expiresIn || 86400) * 1000; // Default 24h\n  1114→                saveSettings({\n  1115→                    customerId: result.customerId,\n  1116→                    accessToken: result.token,\n  1117→                    refreshToken: result.refreshToken,\n  1118→                    tokenExpiry: Date.now() + expiresInMs,\n  1119→                    licenseKey: licenseKey // Keep for re-authentication\n  1120→                });\n  1121→\n  1122→                loginModal?.classList.add('hidden');\n  1123→\n  1124→                if (typeof refreshCredits === 'function') {\n  1125→                    await refreshCredits();\n  1126→                }\n  1127→\n  1128→                const tierName = result.tier ? result.tier.charAt(0).toUpperCase() + result.tier.slice(1) : 'Unknown';\n  1129→                setStatus(`License activated! ${tierName} tier`);\n  1130→            } catch (err) {\n  1131→                console.error('[SPLICE] License activation error:', err);\n  1132→\n  1133→                // DIAGNOSTIC LOGGING: Capture exact error details (debug mode only)\n  1134→                debugLog('=== CEP LICENSE ACTIVATION ERROR DIAGNOSTICS ===');\n  1135→                debugLog('Error name:', err?.name);\n  1136→                debugLog('Error message:', err?.message);\n  1137→                debugLog('Error stack:', err?.stack);\n  1138→                debugLog('Backend URL:', getBackendUrl());\n  1139→                debugLog('Fetch timeout:', SPLICE_CONFIG.FETCH_TIMEOUT);\n  1140→                debugLog('Is CEP environment:', typeof CSInterface !== 'undefined');\n  1141→                debugLog('User agent:', navigator?.userAgent);\n  1142→                debugLog('Error constructor:', err?.constructor?.name);\n  1143→                debugLog('Is TypeError:', err?.name === 'TypeError');\n  1144→                debugLog('Message contains \"Failed to fetch\":', err?.message?.includes('Failed to fetch'));\n  1145→                debugLog('Message contains \"fetch\":', err?.message?.toLowerCase()?.includes('fetch'));\n  1146→                debugLog('Message contains \"network\":', err?.message?.toLowerCase()?.includes('network'));\n  1147→                debugLog('Message contains \"CORS\":', err?.message?.toLowerCase()?.includes('cors'));\n  1148→                debugLog('Message contains \"SSL\":', err?.message?.toLowerCase()?.includes('ssl'));\n  1149→                debugLog('Message contains \"certificate\":', err?.message?.toLowerCase()?.includes('certificate'));\n  1150→                debugLog('Full error object:', JSON.stringify(err, Object.getOwnPropertyNames(err)));\n  1151→                debugLog('================================================');\n  1152→\n  1153→                // Provide detailed error message based on error type\n  1154→                let errorMessage = 'Connection error. ';\n  1155→\n  1156→                if (err.message === 'Request timed out') {\n  1157→                    errorMessage += 'Server is not responding. Check if backend is running.';\n  1158→                } else if (err.message?.includes('Failed to fetch') || err.name === 'TypeError') {\n  1159→                    errorMessage += `Cannot reach ${getBackendUrl()}. Check network/firewall.`;\n  1160→                } else if (err.message?.includes('CORS')) {\n  1161→                    errorMessage += 'CORS error. Contact support.';\n  1162→                } else if (err.message?.includes('SSL') || err.message?.includes('certificate')) {\n  1163→                    errorMessage += 'SSL certificate error. Try updating your system certificates.';\n  1164→                } else if (err.message) {\n  1165→                    errorMessage += err.message;\n  1166→                } else {\n  1167→                    errorMessage += 'Unknown error. Check console for details.';\n  1168→                }\n  1169→\n  1170→                debugLog('Final error message shown to user:', errorMessage);\n  1171→                showLoginError(errorMessage);\n  1172→            } finally {\n  1173→                saveLoginBtn.disabled = false;\n  1174→                saveLoginBtn.textContent = 'Activate';\n  1175→            }\n  1176→        });\n  1177→    }\n  1178→\n  1179→    // Email lookup\n  1180→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n  1181→    const lookupEmailInput = document.getElementById('lookupEmailInput');\n  1182→\n  1183→    if (lookupLicenseBtn) {\n  1184→        lookupLicenseBtn.addEventListener('click', async () => {\n  1185→            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n  1186→\n  1187→            if (!email) {\n  1188→                showLoginError('Please enter your email address');\n  1189→                return;\n  1190→            }\n  1191→\n  1192→            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  1193→            if (!emailRegex.test(email)) {\n  1194→                showLoginError('Please enter a valid email address');\n  1195→                return;\n  1196→            }\n  1197→\n  1198→            lookupLicenseBtn.disabled = true;\n  1199→            lookupLicenseBtn.textContent = 'Looking up...';\n  1200→\n  1201→            try {\n  1202→                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n  1203→                    method: 'POST',\n  1204→                    headers: { 'Content-Type': 'application/json' },\n  1205→                    body: JSON.stringify({ email })\n  1206→                }, 30000);\n  1207→\n  1208→                const result = await response.json();\n  1209→\n  1210→                // Note: For security, the backend does NOT return the license key directly.\n  1211→                // It sends the key via email to prevent enumeration attacks.\n  1212→                if (result.success) {\n  1213→                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n  1214→                } else {\n  1215→                    showLoginError(result.error || 'Lookup failed. Please try again.');\n  1216→                }\n  1217→            } catch (err) {\n  1218→                console.error('[SPLICE] License lookup error:', err);\n  1219→                showLoginError('Failed to look up license. Please try again.');\n  1220→            } finally {\n  1221→                lookupLicenseBtn.disabled = false;\n  1222→                lookupLicenseBtn.textContent = 'Lookup';\n  1223→            }\n  1224→        });\n  1225→    }\n  1226→\n  1227→    // Handle external URL buttons\n  1228→    // CEP panels cannot use target=\"_blank\" for security reasons.\n  1229→    // Must use CSInterface.openURLInDefaultBrowser() instead.\n  1230→    initExternalLinkButtons();\n  1231→}\n  1232→\n  1233→/**\n  1234→ * Initialize all external link buttons that need CSInterface.openURLInDefaultBrowser()\n  1235→ * CEP panels cannot use target=\"_blank\" due to security restrictions\n  1236→ */\n  1237→function initExternalLinkButtons() {\n  1238→    // Check if CSInterface is available\n  1239→    if (typeof CSInterface === 'undefined') {\n  1240→        console.warn('[SPLICE] CSInterface not available - external links disabled');\n  1241→        return;\n  1242→    }\n  1243→\n  1244→    let cs;\n  1245→    try {\n  1246→        cs = new CSInterface();\n  1247→    } catch (e) {\n  1248→        console.warn('[SPLICE] Failed to create CSInterface:', e.message);\n  1249→        return;\n  1250→    }\n  1251→\n  1252→    // Buy a License button\n  1253→    const buyLicenseBtn = document.querySelector('.btn-buy-license');\n  1254→\n  1255→    if (buyLicenseBtn) {\n  1256→        buyLicenseBtn.addEventListener('click', (e) => {\n  1257→            e.preventDefault();\n  1258→            e.stopPropagation();\n  1259→\n  1260→            // Visual feedback\n  1261→            buyLicenseBtn.textContent = 'Opening...';\n  1262→            buyLicenseBtn.style.backgroundColor = '#28a745';\n  1263→\n  1264→            try {\n  1265→                cs.openURLInDefaultBrowser('https://spliceclips.com/pricing');\n  1266→\n  1267→                // Reset button after a delay\n  1268→                setTimeout(() => {\n  1269→                    buyLicenseBtn.textContent = 'Buy License';\n  1270→                    buyLicenseBtn.style.backgroundColor = '';\n  1271→                }, 2000);\n  1272→            } catch (err) {\n  1273→                console.error('[SPLICE] Failed to open URL:', err.message);\n  1274→                buyLicenseBtn.textContent = 'Error';\n  1275→                buyLicenseBtn.style.backgroundColor = '#dc3545';\n  1276→            }\n  1277→        });\n  1278→    }\n  1279→    \n  1280→    // View Plans button (in upgrade modal)\n  1281→    const viewPlansBtn = document.querySelector('.btn-view-plans');\n  1282→    if (viewPlansBtn) {\n  1283→        viewPlansBtn.addEventListener('click', (e) => {\n  1284→            e.preventDefault();\n  1285→            e.stopPropagation();\n  1286→            const url = viewPlansBtn.dataset.url || 'https://spliceclips.com/pricing';\n  1287→            cs.openURLInDefaultBrowser(url);\n  1288→        });\n  1289→    }\n  1290→    \n  1291→    // Referral link button\n  1292→    const referralBtn = document.querySelector('.btn-referral');\n  1293→    if (referralBtn) {\n  1294→        referralBtn.addEventListener('click', (e) => {\n  1295→            e.preventDefault();\n  1296→            e.stopPropagation();\n  1297→            const url = referralBtn.dataset.url || 'https://splice.video/referrals';\n  1298→            cs.openURLInDefaultBrowser(url);\n  1299→        });\n  1300→    }\n  1301→}\n  1302→\n  1303→/**\n  1304→ * Show login modal\n  1305→ */\n  1306→function showLoginModal() {\n  1307→    const loginModal = document.getElementById('loginModal');\n  1308→    const loginError = document.getElementById('loginError');\n  1309→    if (loginError) loginError.style.display = 'none';\n  1310→    if (loginModal) loginModal.classList.remove('hidden');\n  1311→}\n  1312→\n  1313→/**\n  1314→ * Show login error message\n  1315→ */\n  1316→function showLoginError(message) {\n  1317→    const loginError = document.getElementById('loginError');\n  1318→    if (loginError) {\n  1319→        loginError.textContent = message;\n  1320→        loginError.style.display = 'block';\n  1321→    }\n  1322→}\n  1323→\n  1324→/**\n  1325→ * Check if user is logged in\n  1326→ */\n  1327→function isLoggedIn() {\n  1328→    const settings = getSettings();\n  1329→    return !!settings.customerId;\n  1330→}\n  1331→\n  1332→/**\n  1333→ * Logout - clear all auth data\n  1334→ */\n  1335→function logout() {\n  1336→    // Clear all auth-related settings\n  1337→    saveSettings({\n  1338→        customerId: null,\n  1339→        accessToken: null,\n  1340→        refreshToken: null,\n  1341→        tokenExpiry: null,\n  1342→        licenseKey: null\n  1343→    });\n  1344→\n  1345→    if (typeof clearCreditsCache === 'function') {\n  1346→        clearCreditsCache();\n  1347→    }\n  1348→    if (typeof updateCreditDisplay === 'function') {\n  1349→        updateCreditDisplay(null);\n  1350→    }\n  1351→    setStatus('Logged out');\n  1352→}\n  1353→\n  1354→// Initialize JSX bridge when loaded\n  1355→document.addEventListener('DOMContentLoaded', () => {\n  1356→    jsx.init();\n  1357→});\n  1358→\n  1359→// Export for modules\n  1360→window.SPLICE_CONFIG = SPLICE_CONFIG;\n  1361→window.SPLICE_DEBUG = SPLICE_DEBUG;\n  1362→window.debugLog = debugLog;\n  1363→window.debugFetch = debugFetch;\n  1364→window.getBackendUrl = getBackendUrl;\n  1365→window.fetchWithTimeout = fetchWithTimeout;\n  1366→window.parseErrorResponse = parseErrorResponse;\n  1367→window.getAuthHeaders = getAuthHeaders;\n  1368→window.getSettings = getSettings;\n  1369→window.saveSettings = saveSettings;\n  1370→window.clearSetting = clearSetting;\n  1371→window.isOnline = isOnline;\n  1372→window.initOfflineDetection = initOfflineDetection;\n  1373→window.formatTime = formatTime;\n  1374→window.setStatus = setStatus;\n  1375→window.debounce = debounce;\n  1376→window.jsx = jsx;\n  1377→window.PRESETS = PRESETS;\n  1378→window.getPresets = getPresets;\n  1379→window.getPreset = getPreset;\n  1380→window.applyPreset = applyPreset;\n  1381→window.getActivePreset = getActivePreset;\n  1382→window.isBuiltInPreset = isBuiltInPreset;\n  1383→window.initPresetSelector = initPresetSelector;\n  1384→window.initLoginModal = initLoginModal;\n  1385→window.showLoginModal = showLoginModal;\n  1386→window.isLoggedIn = isLoggedIn;\n  1387→window.logout = logout;\n  1388→window.escapeHtml = escapeHtml;\n  1389→window.safeHtml = safeHtml;\n  1390→// JWT Auth functions\n  1391→window.isTokenExpired = isTokenExpired;\n  1392→window.refreshAccessToken = refreshAccessToken;\n  1393→window.clearAuthTokens = clearAuthTokens;\n  1394→window.ensureValidToken = ensureValidToken;\n  1395→\n\n</system-reminder>\n"}]},"uuid":"38683c4e-6cd4-40de-ac2b-c9ce58aee833","timestamp":"2026-01-12T01:11:57.650Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js","content":"/**\n * SPLICE CEP Panel Configuration\n * Backend URLs, paths, and utility functions\n */\n\n// ============================================================================\n// DEBUG MODE CONFIGURATION\n// ============================================================================\n\n/**\n * Debug mode flag - enables verbose diagnostic logging\n * Can be enabled via localStorage for troubleshooting:\n *   localStorage.setItem('spliceDebugMode', 'true');\n *\n * Default: false (production mode - minimal logging)\n */\nconst SPLICE_DEBUG = localStorage.getItem('spliceDebugMode') === 'true';\n\n/**\n * Debug logging function - only outputs when debug mode is enabled\n * Use this for diagnostic/development logging that should be silent in production\n * @param {...any} args - Arguments to log (prefixed with [SPLICE DEBUG])\n */\nfunction debugLog(...args) {\n    if (SPLICE_DEBUG) {\n        console.log('[SPLICE DEBUG]', ...args);\n    }\n}\n\n/**\n * Debug fetch logging - verbose fetch request/response logging\n * @param {...any} args - Arguments to log (prefixed with [SPLICE FETCH])\n */\nfunction debugFetch(...args) {\n    if (SPLICE_DEBUG) {\n        console.log('[SPLICE FETCH]', ...args);\n    }\n}\n\n// ============================================================================\n// BACKEND CONFIGURATION\n// ============================================================================\nconst SPLICE_CONFIG = {\n    VERSION: '6.0.3',\n    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    BACKEND_DEV: 'https://127.0.0.1:3847',\n    FETCH_TIMEOUT: 120000, // 2 minutes\n    RETRY_ATTEMPTS: 3,\n    RETRY_DELAY: 1000\n};\n\n/**\n * Get the backend URL based on environment\n * FIXED: CEP panels always run from file://, so we default to PROD\n * Use localStorage to override for local development if needed\n */\nfunction getBackendUrl() {\n    // Priority 1: Allow override via localStorage (for local dev testing)\n    const customUrl = localStorage.getItem('spliceBackendUrl');\n    if (customUrl) {\n        debugLog('Using custom backend URL from localStorage:', customUrl);\n        return customUrl;\n    }\n\n    // Priority 2: Default to production backend\n    // (CEP panels always run from file://, so can't reliably detect dev mode)\n    debugLog('Using production backend URL:', SPLICE_CONFIG.BACKEND_PROD);\n    return SPLICE_CONFIG.BACKEND_PROD;\n}\n\n// ============================================================================\n// JSX BRIDGE - Communicate with Premiere Pro\n// ============================================================================\nconst jsx = {\n    cs: null,\n    _initPromise: null,\n    _initialized: false,\n\n    /**\n     * Initialize the CSInterface\n     * Returns a promise that resolves when ready (true/false)\n     * Does NOT reject - gracefully handles missing CEP environment\n     */\n    init: function() {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = new Promise((resolve) => {\n            try {\n                if (typeof CSInterface !== 'undefined') {\n                    this.cs = new CSInterface();\n                    // Verify we're in a real CEP environment by checking for __adobe_cep__\n                    if (window.__adobe_cep__) {\n                        this._initialized = true;\n                        debugLog('[JSX] CSInterface initialized successfully (CEP environment detected)');\n                    } else {\n                        // CSInterface exists but no CEP runtime - browser/dev mode\n                        this._initialized = true;\n                        debugLog('[JSX] CSInterface initialized (development/browser mode)');\n                    }\n                } else {\n                    console.warn('[JSX] CSInterface not available - panel may not function correctly');\n                    this._initialized = false;\n                }\n            } catch (err) {\n                console.error('[JSX] Failed to initialize CSInterface:', err);\n                this._initialized = false;\n            }\n            resolve(this._initialized);\n        });\n\n        return this._initPromise;\n    },\n\n    /**\n     * Ensure JSX is initialized before making calls\n     */\n    ensureInitialized: async function() {\n        if (!this._initialized) {\n            await this.init();\n        }\n        if (!this.cs) {\n            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n        }\n    },\n\n    /**\n     * Execute ExtendScript in Premiere Pro\n     * @param {string} script - ExtendScript to execute\n     * @returns {Promise<any>} - Parsed result\n     */\n    evalScript: async function(script) {\n        await this.ensureInitialized();\n\n        return new Promise((resolve, reject) => {\n            this.cs.evalScript(script, (result) => {\n                if (result === 'undefined' || result === undefined) {\n                    resolve(null);\n                    return;\n                }\n\n                // Check for EvalScript error or ExtendScript runtime errors\n                if (typeof result === 'string' && (\n                    result.indexOf('EvalScript error') !== -1 ||\n                    result.indexOf('Error:') !== -1 ||\n                    result.indexOf('TypeError:') !== -1 ||\n                    result.indexOf('ReferenceError:') !== -1\n                )) {\n                    reject(new Error(result));\n                    return;\n                }\n\n                // Try to parse JSON\n                try {\n                    const parsed = JSON.parse(result);\n                    if (parsed.error) {\n                        reject(new Error(parsed.error));\n                    } else {\n                        resolve(parsed);\n                    }\n                } catch (e) {\n                    // Return as-is if not JSON\n                    resolve(result);\n                }\n            });\n        });\n    },\n\n    /**\n     * Call a JSX function with arguments\n     * @param {string} funcName - Function name\n     * @param {...any} args - Arguments to pass\n     * @returns {Promise<any>}\n     */\n    call: async function(funcName, ...args) {\n        await this.ensureInitialized();\n\n        const escapedArgs = args.map(arg => {\n            if (arg === null || arg === undefined) return 'null';\n            if (typeof arg === 'string') {\n                // Escape backslashes first, then other special chars\n                return `'${arg\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")\n                    .replace(/\\r/g, '\\\\r')\n                    .replace(/\\n/g, '\\\\n')\n                    .replace(/\\t/g, '\\\\t')}'`;\n            }\n            if (typeof arg === 'object') {\n                return `'${JSON.stringify(arg)\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")}'`;\n            }\n            return String(arg);\n        });\n\n        const script = `${funcName}(${escapedArgs.join(', ')})`;\n        return this.evalScript(script);\n    }\n};\n\n// ============================================================================\n// FETCH UTILITIES\n// ============================================================================\n\n/**\n * Fetch with timeout support\n * @param {string} url - URL to fetch\n * @param {object} options - Fetch options\n * @param {number} timeout - Timeout in ms\n */\nasync function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n    // DIAGNOSTIC: Log fetch request details (debug mode only)\n    debugFetch('=== FETCH REQUEST START ===');\n    debugFetch('URL:', url);\n    debugFetch('Method:', options?.method || 'GET');\n    debugFetch('Headers:', options?.headers);\n    debugFetch('Timeout:', timeout);\n    debugFetch('Is CEP environment:', typeof CSInterface !== 'undefined');\n    debugFetch('=================================');\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n        const response = await fetch(url, {\n            ...options,\n            signal: controller.signal\n        });\n        clearTimeout(timeoutId);\n\n        // DIAGNOSTIC: Log successful response (debug mode only)\n        debugFetch('=== FETCH RESPONSE SUCCESS ===');\n        debugFetch('Status:', response.status);\n        debugFetch('OK:', response.ok);\n        debugFetch('=================================');\n\n        return response;\n    } catch (error) {\n        clearTimeout(timeoutId);\n\n        // DIAGNOSTIC: Log raw fetch error (debug mode only)\n        debugFetch('=== FETCH ERROR CAUGHT ===');\n        debugFetch('Error name:', error?.name);\n        debugFetch('Error message:', error?.message);\n        debugFetch('Error type:', typeof error);\n        debugFetch('Error constructor:', error?.constructor?.name);\n        debugFetch('Is AbortError:', error.name === 'AbortError');\n        debugFetch('Is TypeError:', error.name === 'TypeError');\n        debugFetch('Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\n        debugFetch('=================================');\n\n        if (error.name === 'AbortError') {\n            throw new Error(`Request timeout after ${timeout}ms`);\n        }\n        throw error;\n    }\n}\n\n/**\n * Parse error response from backend\n * @param {Response} response - Fetch response\n */\nasync function parseErrorResponse(response) {\n    try {\n        const data = await response.json();\n        return data.error || data.message || `HTTP ${response.status}`;\n    } catch {\n        return `HTTP ${response.status}: ${response.statusText}`;\n    }\n}\n\n/**\n * Get auth headers for API requests\n * Uses JWT Bearer token if available, with legacy fallback\n */\nfunction getAuthHeaders() {\n    const headers = { 'Content-Type': 'application/json' };\n    const settings = getSettings();\n\n    // Prefer JWT Bearer token (modern auth)\n    if (settings.accessToken) {\n        headers['Authorization'] = `Bearer ${settings.accessToken}`;\n        return headers;\n    }\n\n    // Legacy fallback for backwards compatibility\n    // This will be removed after 2026-04-11\n    if (settings.customerId) {\n        headers['x-stripe-customer-id'] = settings.customerId;\n        console.warn('[SPLICE] Using deprecated x-stripe-customer-id header. Please re-login to upgrade to JWT auth.');\n    }\n\n    return headers;\n}\n\n/**\n * Check if the access token is expired or about to expire\n * @returns {boolean} True if token needs refresh\n */\nfunction isTokenExpired() {\n    const settings = getSettings();\n    if (!settings.tokenExpiry) return true;\n\n    // Refresh if less than 5 minutes remaining\n    const bufferMs = 5 * 60 * 1000;\n    return Date.now() >= (settings.tokenExpiry - bufferMs);\n}\n\n/**\n * Refresh the access token using the refresh token\n * @returns {Promise<boolean>} True if refresh succeeded\n */\nasync function refreshAccessToken() {\n    const settings = getSettings();\n\n    if (!settings.refreshToken) {\n        debugLog('[Auth] No refresh token available');\n        return false;\n    }\n\n    try {\n        debugLog('[Auth] Refreshing access token...');\n\n        const response = await fetchWithTimeout(`${getBackendUrl()}/auth/refresh`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ refreshToken: settings.refreshToken })\n        }, 30000);\n\n        if (!response.ok) {\n            const errorMsg = await parseErrorResponse(response);\n            console.error('[Auth] Token refresh failed:', errorMsg);\n\n            // If refresh token is invalid, clear auth and require re-login\n            if (response.status === 401) {\n                clearAuthTokens();\n            }\n            return false;\n        }\n\n        const data = await response.json();\n\n        // Save new access token\n        const expiresInMs = (data.expiresIn || 86400) * 1000; // Default 24h\n        saveSettings({\n            accessToken: data.token,\n            tokenExpiry: Date.now() + expiresInMs\n        });\n\n        debugLog('[Auth] Access token refreshed successfully');\n        return true;\n    } catch (err) {\n        console.error('[Auth] Token refresh error:', err);\n        return false;\n    }\n}\n\n/**\n * Clear all auth tokens (call on logout or auth failure)\n */\nfunction clearAuthTokens() {\n    saveSettings({\n        accessToken: null,\n        refreshToken: null,\n        tokenExpiry: null\n    });\n    debugLog('[Auth] Auth tokens cleared');\n}\n\n/**\n * Ensure we have a valid access token, refreshing if needed\n * @returns {Promise<boolean>} True if we have a valid token\n */\nasync function ensureValidToken() {\n    const settings = getSettings();\n\n    // No token at all - need to login\n    if (!settings.accessToken) {\n        return false;\n    }\n\n    // Token not expired - good to go\n    if (!isTokenExpired()) {\n        return true;\n    }\n\n    // Try to refresh\n    return await refreshAccessToken();\n}\n\n// ============================================================================\n// SETTINGS MANAGEMENT\n// ============================================================================\n\nconst DEFAULT_SETTINGS = {\n    sensitivity: 50,\n    minSilenceLength: 0.5,\n    sourceIsolated: false,\n    enableTakesDetection: true,\n    enableJCut: false,\n    jcutLeadIn: 0.3,\n    jcutLeadOut: 0.2,\n    enableZoom: false,\n    zoomFrequency: 'medium',\n    zoomPreset: 'medium',\n    zoomPlacement: 'sentence_start',\n    enableChapters: false,\n    maxChapters: 10,\n    minChapterLength: 60,\n    enableProfanity: false,\n    profanityLanguage: 'en',\n    bleepType: 'standard',\n    // Authentication\n    customerId: null,\n    licenseKey: null,\n    accessToken: null,\n    refreshToken: null,\n    tokenExpiry: null,\n    // UI State\n    expandedOptions: false,\n    activePreset: 'podcast',\n    rememberOptions: false\n};\n\n// Current storage version for future migrations\nconst SETTINGS_STORAGE_VERSION = 2;\n\n// Fields that contain sensitive data and should be encrypted\nconst SENSITIVE_FIELDS = ['customerId', 'licenseKey', 'accessToken', 'refreshToken'];\n\n// ============================================================================\n// ENCRYPTION HELPERS FOR SENSITIVE DATA\n// ============================================================================\n\n/**\n * Simple obfuscation for localStorage\n * NOTE: This is NOT cryptographically secure, but provides basic protection\n * against casual inspection of localStorage. For truly sensitive data,\n * consider server-side storage or proper encryption libraries.\n *\n * @param {any} data - Data to encode\n * @returns {string|null} Encoded string or null on error\n */\nfunction encryptForStorage(data) {\n    try {\n        if (data === null || data === undefined) {\n            return null;\n        }\n        // Double encode to add slight obfuscation layer\n        const jsonStr = JSON.stringify(data);\n        const encoded = encodeURIComponent(jsonStr);\n        return btoa(encoded);\n    } catch (e) {\n        debugLog('[Config] Encryption error:', e);\n        return null;\n    }\n}\n\n/**\n * Decode obfuscated data from localStorage\n *\n * @param {string} data - Encoded string\n * @returns {any|null} Decoded data or null on error\n */\nfunction decryptFromStorage(data) {\n    try {\n        if (!data || typeof data !== 'string') {\n            return null;\n        }\n        const decoded = atob(data);\n        const jsonStr = decodeURIComponent(decoded);\n        return JSON.parse(jsonStr);\n    } catch (e) {\n        // This is expected for unencrypted legacy data - don't log as warning\n        return null;\n    }\n}\n\n/**\n * Check if a value appears to be encrypted (base64 encoded JSON)\n *\n * @param {any} value - Value to check\n * @returns {boolean} True if value appears to be encrypted\n */\nfunction isEncryptedValue(value) {\n    if (!value || typeof value !== 'string') {\n        return false;\n    }\n    // Unencrypted values typically start with known patterns\n    // (e.g., \"cus_\" for Stripe customer IDs, \"SPLICE-\" for license keys)\n    if (value.startsWith('cus_') || value.startsWith('SPLICE-')) {\n        return false;\n    }\n    // Check if it's a valid base64 string that decodes to valid JSON\n    try {\n        const decoded = atob(value);\n        const jsonStr = decodeURIComponent(decoded);\n        JSON.parse(jsonStr);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Encrypt sensitive fields in settings object\n *\n * @param {Object} settings - Settings object with plaintext sensitive fields\n * @returns {Object} Settings with encrypted sensitive fields\n */\nfunction encryptSensitiveFields(settings) {\n    const encrypted = { ...settings };\n\n    for (const field of SENSITIVE_FIELDS) {\n        if (encrypted[field] !== null && encrypted[field] !== undefined) {\n            // Only encrypt if not already encrypted\n            if (!isEncryptedValue(encrypted[field])) {\n                encrypted[field] = encryptForStorage(encrypted[field]);\n                debugLog(`[Config] Encrypted field: ${field}`);\n            }\n        }\n    }\n\n    return encrypted;\n}\n\n/**\n * Decrypt sensitive fields in settings object\n *\n * @param {Object} settings - Settings object with encrypted sensitive fields\n * @returns {Object} Settings with decrypted sensitive fields\n */\nfunction decryptSensitiveFields(settings) {\n    const decrypted = { ...settings };\n\n    for (const field of SENSITIVE_FIELDS) {\n        if (decrypted[field] !== null && decrypted[field] !== undefined) {\n            // Check if it looks encrypted before attempting to decrypt\n            if (isEncryptedValue(decrypted[field])) {\n                const decryptedValue = decryptFromStorage(decrypted[field]);\n                if (decryptedValue !== null) {\n                    decrypted[field] = decryptedValue;\n                    debugLog(`[Config] Decrypted field: ${field}`);\n                }\n            }\n            // If not encrypted (legacy data), keep the original value\n        }\n    }\n\n    return decrypted;\n}\n\n/**\n * Internal save function to avoid recursion during migration\n * @private\n */\nfunction _saveSettingsInternal(settings) {\n    try {\n        // Encrypt sensitive fields before storing\n        const toStore = encryptSensitiveFields(settings);\n\n        // Add version marker for future migrations\n        toStore._storageVersion = SETTINGS_STORAGE_VERSION;\n\n        localStorage.setItem('spliceSettings', JSON.stringify(toStore));\n        return true;\n    } catch (e) {\n        console.warn('[Config] Error saving settings:', e);\n        return false;\n    }\n}\n\n/**\n * Get settings from localStorage\n * Handles migration from unencrypted to encrypted storage format\n */\nfunction getSettings() {\n    try {\n        const stored = localStorage.getItem('spliceSettings');\n        if (stored) {\n            const parsed = JSON.parse(stored);\n\n            // Decrypt sensitive fields (handles both encrypted and legacy unencrypted data)\n            const decrypted = decryptSensitiveFields(parsed);\n\n            // Check if migration is needed (no version marker = legacy data)\n            if (!parsed._storageVersion) {\n                // Migrate legacy data: save with encryption and version marker\n                debugLog('[Config] Migrating legacy settings to encrypted format');\n                const migratedSettings = { ...DEFAULT_SETTINGS, ...decrypted };\n                // Use internal save to avoid infinite recursion\n                _saveSettingsInternal(migratedSettings);\n            }\n\n            // Return merged settings without internal fields\n            const result = { ...DEFAULT_SETTINGS, ...decrypted };\n            delete result._storageVersion;\n            return result;\n        }\n    } catch (e) {\n        console.warn('[Config] Error loading settings:', e);\n    }\n    return { ...DEFAULT_SETTINGS };\n}\n\n/**\n * Save settings to localStorage\n * Encrypts sensitive fields before storing\n */\nfunction saveSettings(settings) {\n    try {\n        // Get current settings (decrypted) and merge with new settings\n        const current = getSettings();\n        const merged = { ...current, ...settings };\n\n        return _saveSettingsInternal(merged);\n    } catch (e) {\n        console.warn('[Config] Error saving settings:', e);\n        return false;\n    }\n}\n\n/**\n * Clear specific setting\n */\nfunction clearSetting(key) {\n    const settings = getSettings();\n    delete settings[key];\n    _saveSettingsInternal(settings);\n}\n\n// ============================================================================\n// OFFLINE DETECTION\n// ============================================================================\n\nlet isOnlineState = true;\nlet offlineCheckInterval = null;\n\n/**\n * Check if online\n */\nfunction isOnline() {\n    return isOnlineState && navigator.onLine;\n}\n\n/**\n * Initialize offline detection\n */\nfunction initOfflineDetection() {\n    // Browser events\n    window.addEventListener('online', () => {\n        isOnlineState = true;\n        updateOfflineUI(true);\n    });\n\n    window.addEventListener('offline', () => {\n        isOnlineState = false;\n        updateOfflineUI(false);\n    });\n\n    // Periodic check\n    offlineCheckInterval = setInterval(async () => {\n        try {\n            const response = await fetchWithTimeout(\n                `${getBackendUrl()}/health`,\n                { method: 'GET' },\n                5000\n            );\n            isOnlineState = response.ok;\n        } catch {\n            isOnlineState = false;\n        }\n        updateOfflineUI(isOnlineState);\n    }, 30000);\n}\n\n/**\n * Update UI based on online state\n */\nfunction updateOfflineUI(online) {\n    const goBtn = document.getElementById('goBtn');\n    const status = document.getElementById('status');\n\n    if (goBtn) {\n        goBtn.disabled = !online;\n    }\n\n    if (status) {\n        if (!online) {\n            status.textContent = 'Offline - Check your connection';\n            status.style.color = '#dc3545';\n        } else {\n            // Reset status when back online\n            status.textContent = 'Ready';\n            status.style.color = '#888';\n        }\n    }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * SECURITY: Escape HTML to prevent XSS attacks\n * Use this when inserting untrusted content into innerHTML\n * @param {string} str - String to escape\n * @returns {string} Escaped string safe for innerHTML\n */\nfunction escapeHtml(str) {\n    if (str === null || str === undefined) return '';\n    if (typeof str !== 'string') str = String(str);\n\n    const escapeMap = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;',\n        '/': '&#x2F;',\n        '`': '&#x60;'\n    };\n\n    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n}\n\n/**\n * SECURITY: Create safe HTML from template with escaped values\n * @param {TemplateStringsArray} strings - Template strings\n * @param {...any} values - Values to escape\n * @returns {string} HTML with escaped values\n */\nfunction safeHtml(strings, ...values) {\n    return strings.reduce((result, str, i) => {\n        const value = values[i - 1];\n        const escaped = escapeHtml(value);\n        return result + escaped + str;\n    });\n}\n\n/**\n * Format time in MM:SS or HH:MM:SS\n */\nfunction formatTime(seconds) {\n    if (isNaN(seconds) || seconds < 0) return '0:00';\n\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n\n    if (hours > 0) {\n        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Set status message\n */\nfunction setStatus(message, isError = false) {\n    const status = document.getElementById('status');\n    if (status) {\n        status.textContent = message;\n        status.style.color = isError ? '#dc3545' : '#888';\n    }\n}\n\n/**\n * Debounce function calls\n */\nfunction debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n        const later = () => {\n            clearTimeout(timeout);\n            func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n\n// ============================================================================\n// PRESET PROFILES\n// ============================================================================\n\n/**\n * Detection presets for different content types.\n * Each preset defines optimal settings for a specific use case.\n */\nconst PRESETS = {\n    // Custom - user-defined settings (default)\n    custom: {\n        name: 'Custom',\n        description: 'Your custom settings',\n        icon: 'settings',\n        settings: null // Uses current user settings\n    },\n\n    // Podcast - longer pauses are natural, be conservative\n    podcast: {\n        name: 'Podcast',\n        description: 'Longer natural pauses, J-Cuts enabled',\n        icon: 'mic',\n        settings: {\n            sensitivity: 35,\n            threshold: -35,\n            minSilenceLength: 0.8,\n            paddingStart: 0.15,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.3,\n            jCutLeadOut: 0.2\n        }\n    },\n\n    // Interview - balanced, respects speaker pauses\n    interview: {\n        name: 'Interview',\n        description: 'Balanced cuts, J-Cuts for smooth transitions',\n        icon: 'people',\n        settings: {\n            sensitivity: 50,\n            threshold: -32,\n            minSilenceLength: 0.5,\n            paddingStart: 0.12,\n            paddingEnd: 0.08,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.25,\n            jCutLeadOut: 0.15\n        }\n    },\n\n    // Reaction video - fast pacing, quick cuts\n    reaction: {\n        name: 'Reaction',\n        description: 'Fast-paced, tight cuts for energy',\n        icon: 'bolt',\n        settings: {\n            sensitivity: 70,\n            threshold: -28,\n            minSilenceLength: 0.3,\n            paddingStart: 0.05,\n            paddingEnd: 0.03,\n            enableTakesDetection: false,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    },\n\n    // Tutorial/Educational - preserve thinking pauses\n    tutorial: {\n        name: 'Tutorial',\n        description: 'Preserves teaching pace, J-Cuts enabled',\n        icon: 'school',\n        settings: {\n            sensitivity: 30,\n            threshold: -38,\n            minSilenceLength: 1.0,\n            paddingStart: 0.2,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.35,\n            jCutLeadOut: 0.25\n        }\n    },\n\n    // Vlog/YouTube - punchy edits, engagement-focused\n    vlog: {\n        name: 'Vlog',\n        description: 'Punchy edits for YouTube engagement',\n        icon: 'videocam',\n        settings: {\n            sensitivity: 65,\n            threshold: -30,\n            minSilenceLength: 0.35,\n            paddingStart: 0.08,\n            paddingEnd: 0.05,\n            enableTakesDetection: true,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    }\n};\n\n/**\n * List of built-in preset IDs\n */\nconst BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n\n/**\n * Get all available presets\n * @returns {Object} All preset definitions\n */\nfunction getPresets() {\n    return { ...PRESETS };\n}\n\n/**\n * Get a specific preset by name\n * @param {string} presetName - Name of the preset\n * @returns {Object|null} Preset definition or null if not found\n */\nfunction getPreset(presetName) {\n    return PRESETS[presetName] || null;\n}\n\n/**\n * Check if a preset is a built-in preset\n * @param {string} id - Preset ID to check\n * @returns {boolean} True if built-in, false if custom\n */\nfunction isBuiltInPreset(id) {\n    return BUILT_IN_PRESET_IDS.includes(id);\n}\n\n/**\n * Apply a preset to current settings\n * @param {string} presetName - Name of the preset to apply\n * @returns {Object} The applied settings\n */\nfunction applyPreset(presetName) {\n    const preset = PRESETS[presetName];\n\n    if (!preset) {\n        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n        return getSettings();\n    }\n\n    // Custom preset uses current settings\n    if (presetName === 'custom' || !preset.settings) {\n        saveSettings({ activePreset: 'custom' });\n        return getSettings();\n    }\n\n    // Apply preset settings\n    const newSettings = {\n        ...preset.settings,\n        activePreset: presetName\n    };\n\n    saveSettings(newSettings);\n    debugLog(`Applied preset: ${preset.name}`);\n\n    return getSettings();\n}\n\n/**\n * Get the currently active preset\n * @returns {string} Active preset name\n */\nfunction getActivePreset() {\n    const settings = getSettings();\n    return settings.activePreset || 'custom';\n}\n\n/**\n * Initialize preset selector\n */\nfunction initPresetSelector() {\n    const presetSelector = document.getElementById('presetSelector');\n    const sensitivitySlider = document.getElementById('sensitivitySlider');\n\n    if (!presetSelector) return;\n\n    // Set initial value from settings\n    const settings = getSettings();\n    presetSelector.value = settings.activePreset || 'podcast';\n\n    // Handle preset change\n    presetSelector.addEventListener('change', () => {\n        const presetId = presetSelector.value;\n        const appliedSettings = applyPreset(presetId);\n\n        // Update sensitivity slider to match preset\n        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n            sensitivitySlider.value = appliedSettings.sensitivity;\n            // Update display value\n            const sensitivityValue = document.getElementById('sensitivityValue');\n            if (sensitivityValue) {\n                sensitivityValue.textContent = appliedSettings.sensitivity;\n            }\n        }\n\n        // Update takes detection checkbox\n        const enableTakesDetection = document.getElementById('enableTakesDetection');\n        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n        }\n\n        // Update J-Cut checkbox\n        const enableJCut = document.getElementById('enableJCut');\n        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n            enableJCut.checked = appliedSettings.enableJCut;\n            // Toggle J-Cut settings visibility\n            const jcutSettings = document.getElementById('jcutSettings');\n            if (jcutSettings) {\n                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n            }\n        }\n\n        const preset = getPreset(presetId);\n        if (preset) {\n            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n        }\n    });\n\n    // Switch to custom when user manually changes sensitivity\n    if (sensitivitySlider) {\n        sensitivitySlider.addEventListener('change', () => {\n            if (presetSelector.value !== 'custom') {\n                presetSelector.value = 'custom';\n                saveSettings({ activePreset: 'custom' });\n            }\n        });\n    }\n}\n\n// ============================================================================\n// LOGIN MODAL\n// ============================================================================\n\n/**\n * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n * Character set excludes confusing chars: 0/O, 1/I/L\n */\nfunction isValidLicenseKeyFormat(key) {\n    if (!key || typeof key !== 'string') return false;\n    const normalized = key.toUpperCase().trim();\n    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n    return pattern.test(normalized);\n}\n\n/**\n * Initialize login modal handlers\n */\nfunction initLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const closeLoginBtn = document.getElementById('closeLoginBtn');\n    const saveLoginBtn = document.getElementById('saveLoginBtn');\n    const licenseKeyInput = document.getElementById('licenseKeyInput');\n    const creditBadge = document.getElementById('creditBadge');\n\n    // Handle credit badge click - retry on error, or show login modal\n    if (creditBadge) {\n        creditBadge.addEventListener('click', async () => {\n            if (creditBadge.classList.contains('error')) {\n                creditBadge.textContent = '...';\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n                return;\n            }\n            showLoginModal();\n        });\n    }\n\n    // Close login modal\n    if (closeLoginBtn && loginModal) {\n        closeLoginBtn.addEventListener('click', () => {\n            loginModal.classList.add('hidden');\n        });\n    }\n\n    // Close on backdrop click\n    if (loginModal) {\n        loginModal.addEventListener('click', (e) => {\n            if (e.target === loginModal) {\n                loginModal.classList.add('hidden');\n            }\n        });\n    }\n\n    // Activate license key\n    if (saveLoginBtn) {\n        saveLoginBtn.addEventListener('click', async () => {\n            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n\n            if (!licenseKey) {\n                showLoginError('Please enter your license key');\n                return;\n            }\n\n            if (!isValidLicenseKeyFormat(licenseKey)) {\n                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n                return;\n            }\n\n            saveLoginBtn.disabled = true;\n            saveLoginBtn.textContent = 'Activating...';\n\n            try {\n                // Use /auth/login endpoint which returns JWT tokens\n                const response = await fetchWithTimeout(`${getBackendUrl()}/auth/login`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ licenseKey: licenseKey })\n                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n                const result = await response.json();\n\n                if (!result.success) {\n                    showLoginError(result.error || 'Activation failed');\n                    return;\n                }\n\n                // Store JWT tokens and customer info\n                const expiresInMs = (result.expiresIn || 86400) * 1000; // Default 24h\n                saveSettings({\n                    customerId: result.customerId,\n                    accessToken: result.token,\n                    refreshToken: result.refreshToken,\n                    tokenExpiry: Date.now() + expiresInMs,\n                    licenseKey: licenseKey // Keep for re-authentication\n                });\n\n                loginModal?.classList.add('hidden');\n\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n\n                const tierName = result.tier ? result.tier.charAt(0).toUpperCase() + result.tier.slice(1) : 'Unknown';\n                setStatus(`License activated! ${tierName} tier`);\n            } catch (err) {\n                console.error('[SPLICE] License activation error:', err);\n\n                // DIAGNOSTIC LOGGING: Capture exact error details (debug mode only)\n                debugLog('=== CEP LICENSE ACTIVATION ERROR DIAGNOSTICS ===');\n                debugLog('Error name:', err?.name);\n                debugLog('Error message:', err?.message);\n                debugLog('Error stack:', err?.stack);\n                debugLog('Backend URL:', getBackendUrl());\n                debugLog('Fetch timeout:', SPLICE_CONFIG.FETCH_TIMEOUT);\n                debugLog('Is CEP environment:', typeof CSInterface !== 'undefined');\n                debugLog('User agent:', navigator?.userAgent);\n                debugLog('Error constructor:', err?.constructor?.name);\n                debugLog('Is TypeError:', err?.name === 'TypeError');\n                debugLog('Message contains \"Failed to fetch\":', err?.message?.includes('Failed to fetch'));\n                debugLog('Message contains \"fetch\":', err?.message?.toLowerCase()?.includes('fetch'));\n                debugLog('Message contains \"network\":', err?.message?.toLowerCase()?.includes('network'));\n                debugLog('Message contains \"CORS\":', err?.message?.toLowerCase()?.includes('cors'));\n                debugLog('Message contains \"SSL\":', err?.message?.toLowerCase()?.includes('ssl'));\n                debugLog('Message contains \"certificate\":', err?.message?.toLowerCase()?.includes('certificate'));\n                debugLog('Full error object:', JSON.stringify(err, Object.getOwnPropertyNames(err)));\n                debugLog('================================================');\n\n                // Provide detailed error message based on error type\n                let errorMessage = 'Connection error. ';\n\n                if (err.message === 'Request timed out') {\n                    errorMessage += 'Server is not responding. Check if backend is running.';\n                } else if (err.message?.includes('Failed to fetch') || err.name === 'TypeError') {\n                    errorMessage += `Cannot reach ${getBackendUrl()}. Check network/firewall.`;\n                } else if (err.message?.includes('CORS')) {\n                    errorMessage += 'CORS error. Contact support.';\n                } else if (err.message?.includes('SSL') || err.message?.includes('certificate')) {\n                    errorMessage += 'SSL certificate error. Try updating your system certificates.';\n                } else if (err.message) {\n                    errorMessage += err.message;\n                } else {\n                    errorMessage += 'Unknown error. Check console for details.';\n                }\n\n                debugLog('Final error message shown to user:', errorMessage);\n                showLoginError(errorMessage);\n            } finally {\n                saveLoginBtn.disabled = false;\n                saveLoginBtn.textContent = 'Activate';\n            }\n        });\n    }\n\n    // Email lookup\n    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n    const lookupEmailInput = document.getElementById('lookupEmailInput');\n\n    if (lookupLicenseBtn) {\n        lookupLicenseBtn.addEventListener('click', async () => {\n            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n\n            if (!email) {\n                showLoginError('Please enter your email address');\n                return;\n            }\n\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(email)) {\n                showLoginError('Please enter a valid email address');\n                return;\n            }\n\n            lookupLicenseBtn.disabled = true;\n            lookupLicenseBtn.textContent = 'Looking up...';\n\n            try {\n                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ email })\n                }, 30000);\n\n                const result = await response.json();\n\n                // Note: For security, the backend does NOT return the license key directly.\n                // It sends the key via email to prevent enumeration attacks.\n                if (result.success) {\n                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n                } else {\n                    showLoginError(result.error || 'Lookup failed. Please try again.');\n                }\n            } catch (err) {\n                console.error('[SPLICE] License lookup error:', err);\n                showLoginError('Failed to look up license. Please try again.');\n            } finally {\n                lookupLicenseBtn.disabled = false;\n                lookupLicenseBtn.textContent = 'Lookup';\n            }\n        });\n    }\n\n    // Handle external URL buttons\n    // CEP panels cannot use target=\"_blank\" for security reasons.\n    // Must use CSInterface.openURLInDefaultBrowser() instead.\n    initExternalLinkButtons();\n}\n\n/**\n * Initialize all external link buttons that need CSInterface.openURLInDefaultBrowser()\n * CEP panels cannot use target=\"_blank\" due to security restrictions\n */\nfunction initExternalLinkButtons() {\n    // Check if CSInterface is available\n    if (typeof CSInterface === 'undefined') {\n        console.warn('[SPLICE] CSInterface not available - external links disabled');\n        return;\n    }\n\n    let cs;\n    try {\n        cs = new CSInterface();\n    } catch (e) {\n        console.warn('[SPLICE] Failed to create CSInterface:', e.message);\n        return;\n    }\n\n    // Buy a License button\n    const buyLicenseBtn = document.querySelector('.btn-buy-license');\n\n    if (buyLicenseBtn) {\n        buyLicenseBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n\n            // Visual feedback\n            buyLicenseBtn.textContent = 'Opening...';\n            buyLicenseBtn.style.backgroundColor = '#28a745';\n\n            try {\n                cs.openURLInDefaultBrowser('https://spliceclips.com/pricing');\n\n                // Reset button after a delay\n                setTimeout(() => {\n                    buyLicenseBtn.textContent = 'Buy License';\n                    buyLicenseBtn.style.backgroundColor = '';\n                }, 2000);\n            } catch (err) {\n                console.error('[SPLICE] Failed to open URL:', err.message);\n                buyLicenseBtn.textContent = 'Error';\n                buyLicenseBtn.style.backgroundColor = '#dc3545';\n            }\n        });\n    }\n    \n    // View Plans button (in upgrade modal)\n    const viewPlansBtn = document.querySelector('.btn-view-plans');\n    if (viewPlansBtn) {\n        viewPlansBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const url = viewPlansBtn.dataset.url || 'https://spliceclips.com/pricing';\n            cs.openURLInDefaultBrowser(url);\n        });\n    }\n    \n    // Referral link button\n    const referralBtn = document.querySelector('.btn-referral');\n    if (referralBtn) {\n        referralBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const url = referralBtn.dataset.url || 'https://splice.video/referrals';\n            cs.openURLInDefaultBrowser(url);\n        });\n    }\n}\n\n/**\n * Show login modal\n */\nfunction showLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const loginError = document.getElementById('loginError');\n    if (loginError) loginError.style.display = 'none';\n    if (loginModal) loginModal.classList.remove('hidden');\n}\n\n/**\n * Show login error message\n */\nfunction showLoginError(message) {\n    const loginError = document.getElementById('loginError');\n    if (loginError) {\n        loginError.textContent = message;\n        loginError.style.display = 'block';\n    }\n}\n\n/**\n * Check if user is logged in\n */\nfunction isLoggedIn() {\n    const settings = getSettings();\n    return !!settings.customerId;\n}\n\n/**\n * Logout - clear all auth data\n */\nfunction logout() {\n    // Clear all auth-related settings\n    saveSettings({\n        customerId: null,\n        accessToken: null,\n        refreshToken: null,\n        tokenExpiry: null,\n        licenseKey: null\n    });\n\n    if (typeof clearCreditsCache === 'function') {\n        clearCreditsCache();\n    }\n    if (typeof updateCreditDisplay === 'function') {\n        updateCreditDisplay(null);\n    }\n    setStatus('Logged out');\n}\n\n// Initialize JSX bridge when loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    jsx.init();\n});\n\n// Export for modules\nwindow.SPLICE_CONFIG = SPLICE_CONFIG;\nwindow.SPLICE_DEBUG = SPLICE_DEBUG;\nwindow.debugLog = debugLog;\nwindow.debugFetch = debugFetch;\nwindow.getBackendUrl = getBackendUrl;\nwindow.fetchWithTimeout = fetchWithTimeout;\nwindow.parseErrorResponse = parseErrorResponse;\nwindow.getAuthHeaders = getAuthHeaders;\nwindow.getSettings = getSettings;\nwindow.saveSettings = saveSettings;\nwindow.clearSetting = clearSetting;\nwindow.isOnline = isOnline;\nwindow.initOfflineDetection = initOfflineDetection;\nwindow.formatTime = formatTime;\nwindow.setStatus = setStatus;\nwindow.debounce = debounce;\nwindow.jsx = jsx;\nwindow.PRESETS = PRESETS;\nwindow.getPresets = getPresets;\nwindow.getPreset = getPreset;\nwindow.applyPreset = applyPreset;\nwindow.getActivePreset = getActivePreset;\nwindow.isBuiltInPreset = isBuiltInPreset;\nwindow.initPresetSelector = initPresetSelector;\nwindow.initLoginModal = initLoginModal;\nwindow.showLoginModal = showLoginModal;\nwindow.isLoggedIn = isLoggedIn;\nwindow.logout = logout;\nwindow.escapeHtml = escapeHtml;\nwindow.safeHtml = safeHtml;\n// JWT Auth functions\nwindow.isTokenExpired = isTokenExpired;\nwindow.refreshAccessToken = refreshAccessToken;\nwindow.clearAuthTokens = clearAuthTokens;\nwindow.ensureValidToken = ensureValidToken;\n","numLines":1395,"startLine":1,"totalLines":1395}}}
{"parentUuid":"38683c4e-6cd4-40de-ac2b-c9ce58aee833","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R8hkSuJVcxMmSmUC3cevSP","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also check the backend login route and the credits endpoint to complete the verification:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14820,"cache_creation_input_tokens":16914,"cache_read_input_tokens":27992,"cache_creation":{"ephemeral_5m_input_tokens":16914,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2bSVu5dsyeyXTm63Ft2","type":"assistant","uuid":"4b4e1f06-1041-4a40-8c01-69a4b26c297b","timestamp":"2026-01-12T01:12:02.631Z"}
{"parentUuid":"4b4e1f06-1041-4a40-8c01-69a4b26c297b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R8hkSuJVcxMmSmUC3cevSP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014BkUXTF7AxC85yA7UX5Doy","name":"Grep","input":{"pattern":"POST.*\\/auth\\/login|app\\.post.*login","path":"/Users/imorgado/SPLICE/splice-backend","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14820,"cache_creation_input_tokens":16914,"cache_read_input_tokens":27992,"cache_creation":{"ephemeral_5m_input_tokens":16914,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2bSVu5dsyeyXTm63Ft2","type":"assistant","uuid":"9ca3bf9f-670b-4f6b-9545-933823d137aa","timestamp":"2026-01-12T01:12:03.980Z"}
{"parentUuid":"9ca3bf9f-670b-4f6b-9545-933823d137aa","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R8hkSuJVcxMmSmUC3cevSP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Dw47KcKrFbopd4F1uZYNfi","name":"Glob","input":{"pattern":"**/routes/auth*.js","path":"/Users/imorgado/SPLICE/splice-backend"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14820,"cache_creation_input_tokens":16914,"cache_read_input_tokens":27992,"cache_creation":{"ephemeral_5m_input_tokens":16914,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2bSVu5dsyeyXTm63Ft2","type":"assistant","uuid":"af4b5058-7739-49a9-bd3a-7b9a05871ba3","timestamp":"2026-01-12T01:12:04.478Z"}
{"parentUuid":"af4b5058-7739-49a9-bd3a-7b9a05871ba3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014BkUXTF7AxC85yA7UX5Doy","type":"tool_result","content":"Found 4 files\nsplice-backend/middleware/auth.js\nsplice-backend/tests/auth.test.js\nsplice-backend/STRESS-TEST-REPORT.md\nsplice-backend/tests/stress-test.js"}]},"uuid":"b56cc9b6-5659-41c8-89a4-189d8fe53de7","timestamp":"2026-01-12T01:12:04.529Z","toolUseResult":{"mode":"files_with_matches","filenames":["splice-backend/middleware/auth.js","splice-backend/tests/auth.test.js","splice-backend/STRESS-TEST-REPORT.md","splice-backend/tests/stress-test.js"],"numFiles":4}}
{"parentUuid":"b56cc9b6-5659-41c8-89a4-189d8fe53de7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dw47KcKrFbopd4F1uZYNfi","type":"tool_result","content":"/Users/imorgado/SPLICE/splice-backend/routes/auth.js"}]},"uuid":"944486a6-b009-4600-9225-92961e2b4d05","timestamp":"2026-01-12T01:12:04.622Z","toolUseResult":{"filenames":["/Users/imorgado/SPLICE/splice-backend/routes/auth.js"],"durationMs":108,"numFiles":1,"truncated":false}}
{"parentUuid":"944486a6-b009-4600-9225-92961e2b4d05","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_012SFvHZ1Wph1Ces2gytEdBr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GX8ajd2JQMQZjv9BWtTyUa","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15156,"cache_read_input_tokens":44906,"cache_creation":{"ephemeral_5m_input_tokens":15156,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CX2bT1fydrK9bZWbKJKfM","type":"assistant","uuid":"6f8f8cef-6091-4aca-add5-58d175ff4bda","timestamp":"2026-01-12T01:12:08.491Z"}
{"parentUuid":"6f8f8cef-6091-4aca-add5-58d175ff4bda","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_012SFvHZ1Wph1Ces2gytEdBr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PvTMJ8pNHXqDwyiacSMUfp","name":"Grep","input":{"pattern":"\\/credits|GET.*credits","path":"/Users/imorgado/SPLICE/splice-backend/routes","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15156,"cache_read_input_tokens":44906,"cache_creation":{"ephemeral_5m_input_tokens":15156,"ephemeral_1h_input_tokens":0},"output_tokens":165,"service_tier":"standard"}},"requestId":"req_011CX2bT1fydrK9bZWbKJKfM","type":"assistant","uuid":"9117f475-d0fa-4fca-8767-674acbd34649","timestamp":"2026-01-12T01:12:09.244Z"}
{"parentUuid":"9117f475-d0fa-4fca-8767-674acbd34649","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GX8ajd2JQMQZjv9BWtTyUa","type":"tool_result","content":"     1→/**\n     2→ * Auth Routes\n     3→ *\n     4→ * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n     5→ *\n     6→ * SECURITY: Enhanced with endpoint-specific rate limiting for sensitive operations\n     7→ * HIGH-003: Added IP-based rate limiting for email verification endpoints\n     8→ * MEDIUM-004: Redis-backed verification codes for horizontal scaling\n     9→ */\n    10→\n    11→const express = require('express');\n    12→const crypto = require('crypto');\n    13→const { rateLimit } = require('express-rate-limit');\n    14→const { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\n    15→const { endpointRateLimit } = require('../middleware/rateLimiter');\n    16→const authLogger = require('../utils/authLogger');\n    17→const redis = require('../services/redisClient');\n    18→\n    19→// ============================================================================\n    20→// HIGH-003: IP-Based Rate Limiting for Email Verification\n    21→// Prevents abuse of email verification endpoints regardless of email\n    22→// ============================================================================\n    23→\n    24→/**\n    25→ * IP-based rate limiter for email verification endpoints\n    26→ * Limits: 5 requests per 15 minutes per IP address\n    27→ */\n    28→const emailVerificationLimiter = rateLimit({\n    29→  windowMs: 15 * 60 * 1000, // 15 minutes\n    30→  max: 5, // 5 requests per IP per window\n    31→  keyGenerator: (req) => {\n    32→    // Use X-Forwarded-For header in production (behind proxy)\n    33→    return req.ip || req.headers['x-forwarded-for']?.split(',')[0]?.trim() || 'unknown';\n    34→  },\n    35→  message: {\n    36→    error: 'Too many verification attempts',\n    37→    message: 'Too many verification requests from this IP. Please try again later.',\n    38→    retryAfter: 15 * 60 // 15 minutes in seconds\n    39→  },\n    40→  standardHeaders: true, // Return rate limit info in RateLimit-* headers\n    41→  legacyHeaders: false, // Disable X-RateLimit-* headers\n    42→  handler: (req, res, next, options) => {\n    43→    console.warn(`[Auth] IP rate limit exceeded for email verification: ${req.ip}`);\n    44→    res.status(429).json(options.message);\n    45→  }\n    46→});\n    47→\n    48→// ============================================================================\n    49→// Email Verification Code Storage\n    50→// MEDIUM-004: Redis-backed storage for horizontal scaling\n    51→// Fallback to in-memory storage when Redis is unavailable\n    52→// ============================================================================\n    53→\n    54→// Fallback in-memory storage (used when Redis is unavailable)\n    55→const fallbackVerificationCodes = new Map();\n    56→const fallbackLastSendTime = new Map();\n    57→\n    58→// Verification code expiry time (10 minutes = 600 seconds)\n    59→const VERIFICATION_CODE_TTL_SECONDS = 600;\n    60→const VERIFICATION_CODE_EXPIRY_MS = VERIFICATION_CODE_TTL_SECONDS * 1000;\n    61→\n    62→// Maximum verification attempts before code is invalidated\n    63→const MAX_VERIFICATION_ATTEMPTS = 5;\n    64→\n    65→// Rate limiting: minimum time between sending codes to same email (60 seconds)\n    66→const SEND_CODE_COOLDOWN_SECONDS = 60;\n    67→const SEND_CODE_COOLDOWN_MS = SEND_CODE_COOLDOWN_SECONDS * 1000;\n    68→\n    69→// Redis key prefixes\n    70→const REDIS_KEY_VERIFY = 'verify:';\n    71→const REDIS_KEY_SEND_TIME = 'verify:sendtime:';\n    72→\n    73→/**\n    74→ * Generate a 6-digit verification code\n    75→ * @returns {string} 6-digit code\n    76→ */\n    77→function generateVerificationCode() {\n    78→  // Generate cryptographically secure random 6-digit code\n    79→  const code = crypto.randomInt(100000, 999999).toString();\n    80→  return code;\n    81→}\n    82→\n    83→/**\n    84→ * Store a verification code for an email (Redis-backed with fallback)\n    85→ * @param {string} email - Email address\n    86→ * @param {string} code - Verification code\n    87→ * @returns {Promise<void>}\n    88→ */\n    89→async function storeVerificationCode(email, code) {\n    90→  const normalizedEmail = email.toLowerCase().trim();\n    91→  const data = {\n    92→    code,\n    93→    createdAt: Date.now(),\n    94→    attempts: 0\n    95→  };\n    96→\n    97→  // Try Redis first\n    98→  if (redis.isRedisAvailable()) {\n    99→    try {\n   100→      const verifyKey = `${REDIS_KEY_VERIFY}${normalizedEmail}`;\n   101→      const sendTimeKey = `${REDIS_KEY_SEND_TIME}${normalizedEmail}`;\n   102→      \n   103→      await redis.set(verifyKey, data, VERIFICATION_CODE_TTL_SECONDS);\n   104→      await redis.set(sendTimeKey, Date.now(), SEND_CODE_COOLDOWN_SECONDS * 2); // Keep send time a bit longer\n   105→      return;\n   106→    } catch (err) {\n   107→      console.warn('[Auth] Redis store failed, using fallback:', err.message);\n   108→    }\n   109→  }\n   110→\n   111→  // Fallback to in-memory storage\n   112→  fallbackVerificationCodes.set(normalizedEmail, {\n   113→    ...data,\n   114→    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS\n   115→  });\n   116→  fallbackLastSendTime.set(normalizedEmail, Date.now());\n   117→}\n   118→\n   119→/**\n   120→ * Verify a code for an email (Redis-backed with fallback)\n   121→ * @param {string} email - Email address\n   122→ * @param {string} code - Code to verify\n   123→ * @returns {Promise<{ valid: boolean, error?: string }>}\n   124→ */\n   125→async function verifyCode(email, code) {\n   126→  const normalizedEmail = email.toLowerCase().trim();\n   127→\n   128→  // Try Redis first\n   129→  if (redis.isRedisAvailable()) {\n   130→    try {\n   131→      const verifyKey = `${REDIS_KEY_VERIFY}${normalizedEmail}`;\n   132→      const stored = await redis.get(verifyKey);\n   133→\n   134→      if (!stored) {\n   135→        return { valid: false, error: 'No verification code found. Please request a new one.' };\n   136→      }\n   137→\n   138→      // Increment attempt counter\n   139→      stored.attempts = (stored.attempts || 0) + 1;\n   140→\n   141→      // Check if too many attempts\n   142→      if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n   143→        await redis.del(verifyKey);\n   144→        return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n   145→      }\n   146→\n   147→      // Check if code matches\n   148→      if (stored.code !== code) {\n   149→        // Update attempts count in Redis (keep remaining TTL)\n   150→        const ttl = await redis.ttl(verifyKey);\n   151→        if (ttl > 0) {\n   152→          await redis.set(verifyKey, stored, ttl);\n   153→        }\n   154→        return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n   155→      }\n   156→\n   157→      // Code is valid - remove it (single use)\n   158→      await redis.del(verifyKey);\n   159→      return { valid: true };\n   160→    } catch (err) {\n   161→      console.warn('[Auth] Redis verify failed, using fallback:', err.message);\n   162→    }\n   163→  }\n   164→\n   165→  // Fallback to in-memory storage\n   166→  const stored = fallbackVerificationCodes.get(normalizedEmail);\n   167→\n   168→  if (!stored) {\n   169→    return { valid: false, error: 'No verification code found. Please request a new one.' };\n   170→  }\n   171→\n   172→  // Check if expired\n   173→  if (Date.now() > stored.expires) {\n   174→    fallbackVerificationCodes.delete(normalizedEmail);\n   175→    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n   176→  }\n   177→\n   178→  // Increment attempt counter\n   179→  stored.attempts++;\n   180→\n   181→  // Check if too many attempts\n   182→  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n   183→    fallbackVerificationCodes.delete(normalizedEmail);\n   184→    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n   185→  }\n   186→\n   187→  // Check if code matches\n   188→  if (stored.code !== code) {\n   189→    fallbackVerificationCodes.set(normalizedEmail, stored);\n   190→    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n   191→  }\n   192→\n   193→  // Code is valid - remove it (single use)\n   194→  fallbackVerificationCodes.delete(normalizedEmail);\n   195→  return { valid: true };\n   196→}\n   197→\n   198→/**\n   199→ * Check if we can send a new code to an email (rate limiting, Redis-backed)\n   200→ * @param {string} email - Email address\n   201→ * @returns {Promise<{ allowed: boolean, waitSeconds?: number }>}\n   202→ */\n   203→async function canSendCode(email) {\n   204→  const normalizedEmail = email.toLowerCase().trim();\n   205→\n   206→  // Try Redis first\n   207→  if (redis.isRedisAvailable()) {\n   208→    try {\n   209→      const sendTimeKey = `${REDIS_KEY_SEND_TIME}${normalizedEmail}`;\n   210→      const lastSent = await redis.get(sendTimeKey);\n   211→\n   212→      if (!lastSent) {\n   213→        return { allowed: true };\n   214→      }\n   215→\n   216→      const elapsed = Date.now() - lastSent;\n   217→      if (elapsed < SEND_CODE_COOLDOWN_MS) {\n   218→        const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n   219→        return { allowed: false, waitSeconds };\n   220→      }\n   221→\n   222→      return { allowed: true };\n   223→    } catch (err) {\n   224→      console.warn('[Auth] Redis canSendCode failed, using fallback:', err.message);\n   225→    }\n   226→  }\n   227→\n   228→  // Fallback to in-memory storage\n   229→  const lastSent = fallbackLastSendTime.get(normalizedEmail);\n   230→\n   231→  if (!lastSent) {\n   232→    return { allowed: true };\n   233→  }\n   234→\n   235→  const elapsed = Date.now() - lastSent;\n   236→  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n   237→    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n   238→    return { allowed: false, waitSeconds };\n   239→  }\n   240→\n   241→  return { allowed: true };\n   242→}\n   243→\n   244→// Cleanup for fallback in-memory storage (only needed when Redis is unavailable)\n   245→// Redis handles expiration automatically via TTL\n   246→function cleanupFallbackStorage() {\n   247→  const now = Date.now();\n   248→  let cleanedCount = 0;\n   249→\n   250→  for (const [email, data] of fallbackVerificationCodes.entries()) {\n   251→    if (data.expires <= now) {\n   252→      fallbackVerificationCodes.delete(email);\n   253→      cleanedCount++;\n   254→    }\n   255→  }\n   256→\n   257→  // Also clean up old lastSendTime entries (older than 1 hour)\n   258→  const oneHourAgo = now - (60 * 60 * 1000);\n   259→  for (const [email, time] of fallbackLastSendTime.entries()) {\n   260→    if (time < oneHourAgo) {\n   261→      fallbackLastSendTime.delete(email);\n   262→    }\n   263→  }\n   264→\n   265→  if (cleanedCount > 0) {\n   266→    console.log(`[Auth] Fallback storage cleanup: removed ${cleanedCount} expired codes`);\n   267→  }\n   268→}\n   269→\n   270→// Start periodic cleanup for fallback storage (unref to allow process exit)\n   271→const cleanupTimer = setInterval(cleanupFallbackStorage, 5 * 60 * 1000);\n   272→if (cleanupTimer.unref) {\n   273→  cleanupTimer.unref();\n   274→}\n   275→\n   276→/**\n   277→ * Validate email format\n   278→ * @param {string} email - Email to validate\n   279→ * @returns {boolean}\n   280→ */\n   281→function isValidEmail(email) {\n   282→  if (!email || typeof email !== 'string') return false;\n   283→  // Basic email validation regex\n   284→  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n   285→  return emailRegex.test(email.trim());\n   286→}\n   287→\n   288→/**\n   289→ * Create auth routes\n   290→ * @param {Object} options - Route configuration options\n   291→ * @param {Object} options.middleware - Shared middleware (authenticateToken)\n   292→ * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n   293→ * @param {Object} options.authHelpers - Auth helper functions\n   294→ * @returns {express.Router}\n   295→ */\n   296→function createAuthRoutes(options = {}) {\n   297→  const router = express.Router();\n   298→  const { authenticateToken } = options.middleware || {};\n   299→  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n   300→  const { usageTracking, licenseService, emailService } = options.services || {};\n   301→\n   302→  /**\n   303→   * GET /csrf-token - Generate and return a CSRF token\n   304→   *\n   305→   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   306→   * The token is returned in both the response body and an HttpOnly cookie.\n   307→   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   308→   */\n   309→  router.get('/csrf-token', csrfTokenHandler);\n   310→\n   311→  /**\n   312→   * POST /login - Authenticate with license key and get JWT token\n   313→   *\n   314→   * SECURITY: This is the primary authentication endpoint.\n   315→   * Validates license key and returns a JWT token for API access.\n   316→   * NOTE: CSRF disabled - license key auth is not vulnerable to CSRF\n   317→   * (user must know the key, it's not auto-submitted like cookies)\n   318→   */\n   319→  router.post('/login', async (req, res) => {\n   320→    const { licenseKey } = req.body;\n   321→\n   322→    if (!licenseKey) {\n   323→      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n   324→      return res.status(400).json({\n   325→        error: 'License key required',\n   326→        message: 'Please provide your license key to log in'\n   327→      });\n   328→    }\n   329→\n   330→    try {\n   331→      // Validate and activate the license key\n   332→      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n   333→\n   334→      if (!licenseResult.success) {\n   335→        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n   336→        return res.status(401).json({\n   337→          error: 'Invalid license key',\n   338→          message: licenseResult.error || 'The license key is invalid or expired'\n   339→        });\n   340→      }\n   341→\n   342→      // Get user's tier and balance\n   343→      const balance = await usageTracking.getBalance(licenseResult.customerId);\n   344→\n   345→      // Generate JWT tokens\n   346→      const tokenResult = generateToken(licenseResult.customerId, {\n   347→        tier: balance.tier,\n   348→        email: licenseResult.email\n   349→      });\n   350→      const refreshResult = generateRefreshToken(licenseResult.customerId);\n   351→\n   352→      // Log successful login with structured logging\n   353→      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n   354→        email: licenseResult.email,\n   355→        tier: balance.tier\n   356→      });\n   357→\n   358→      res.json({\n   359→        success: true,\n   360→        token: tokenResult.token,\n   361→        tokenType: tokenResult.tokenType,\n   362→        expiresIn: tokenResult.expiresIn,\n   363→        refreshToken: refreshResult.refreshToken,\n   364→        customerId: licenseResult.customerId,\n   365→        tier: balance.tier,\n   366→        hoursRemaining: balance.hoursRemaining\n   367→      });\n   368→    } catch (err) {\n   369→      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n   370→      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n   371→    }\n   372→  });\n   373→\n   374→  /**\n   375→   * POST /refresh - Refresh an expired JWT token\n   376→   *\n   377→   * Uses a refresh token to get a new access token.\n   378→   * NOTE: CSRF disabled for cross-domain compatibility during beta.\n   379→   */\n   380→  router.post('/refresh', async (req, res) => {\n   381→    const { refreshToken } = req.body;\n   382→\n   383→    if (!refreshToken) {\n   384→      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n   385→      return res.status(400).json({\n   386→        error: 'Refresh token required'\n   387→      });\n   388→    }\n   389→\n   390→    try {\n   391→      const decoded = await verifyToken(refreshToken, { req });\n   392→\n   393→      if (!decoded || decoded.type !== 'refresh') {\n   394→        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n   395→        return res.status(401).json({\n   396→          error: 'Invalid refresh token',\n   397→          message: 'Please log in again'\n   398→        });\n   399→      }\n   400→\n   401→      // Get current user info\n   402→      const balance = await usageTracking.getBalance(decoded.sub);\n   403→\n   404→      // Generate new access token\n   405→      const tokenResult = generateToken(decoded.sub, {\n   406→        tier: balance.tier\n   407→      });\n   408→\n   409→      // Log successful token refresh\n   410→      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n   411→\n   412→      res.json({\n   413→        success: true,\n   414→        token: tokenResult.token,\n   415→        tokenType: tokenResult.tokenType,\n   416→        expiresIn: tokenResult.expiresIn\n   417→      });\n   418→    } catch (err) {\n   419→      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n   420→      res.status(401).json({\n   421→        error: 'Failed to refresh token',\n   422→        message: 'Please log in again'\n   423→      });\n   424→    }\n   425→  });\n   426→\n   427→  /**\n   428→   * POST /logout - Invalidate tokens by adding to blacklist\n   429→   *\n   430→   * Adds the current token's jti to the blacklist so it cannot be reused.\n   431→   * Also accepts an optional refreshToken to revoke both tokens at once.\n   432→   * CSRF protection applied to prevent forced logout attacks.\n   433→   */\n   434→  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n   435→    const { refreshToken } = req.body;\n   436→    let refreshTokenRevoked = false;\n   437→\n   438→    // Blacklist the access token using the blacklistToken function from authHelpers\n   439→    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n   440→      if (blacklistToken) {\n   441→        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n   442→          userId: req.stripeCustomerId,\n   443→          reason: 'logout'\n   444→        });\n   445→      } else {\n   446→        console.warn('[Auth] Logout: blacklistToken function not available');\n   447→      }\n   448→    } else {\n   449→      // Token doesn't have jti - log warning but continue\n   450→      // This handles tokens generated before jti was added\n   451→      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n   452→    }\n   453→\n   454→    // Optionally blacklist the refresh token too\n   455→    if (refreshToken && blacklistToken) {\n   456→      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n   457→      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n   458→      if (decoded && decoded.jti && decoded.exp) {\n   459→        await blacklistToken(decoded.jti, decoded.exp, {\n   460→          userId: req.stripeCustomerId,\n   461→          reason: 'logout_refresh'\n   462→        });\n   463→        refreshTokenRevoked = true;\n   464→      }\n   465→    }\n   466→\n   467→    // Log successful logout with structured logging\n   468→    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n   469→      jti: req.tokenData?.jti,\n   470→      refreshTokenRevoked\n   471→    });\n   472→\n   473→    res.json({\n   474→      success: true,\n   475→      message: 'Logged out successfully'\n   476→    });\n   477→  });\n   478→\n   479→  // ==========================================================================\n   480→  // Email Verification Endpoints\n   481→  // ==========================================================================\n   482→\n   483→  /**\n   484→   * POST /send-verification - Send a verification code to an email address\n   485→   *\n   486→   * Request body: { email: string }\n   487→   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   488→   *\n   489→   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   490→   * HIGH-003: Added IP-based rate limiting (5 requests per 15 minutes per IP)\n   491→   */\n   492→  router.post('/send-verification', emailVerificationLimiter, validateCsrfToken, async (req, res) => {\n   493→    const { email } = req.body;\n   494→\n   495→    // Validate email\n   496→    if (!email) {\n   497→      return res.status(400).json({\n   498→        error: 'Email required',\n   499→        message: 'Please provide an email address'\n   500→      });\n   501→    }\n   502→\n   503→    if (!isValidEmail(email)) {\n   504→      return res.status(400).json({\n   505→        error: 'Invalid email',\n   506→        message: 'Please provide a valid email address'\n   507→      });\n   508→    }\n   509→\n   510→    // Check rate limiting (async - Redis backed)\n   511→    const rateCheck = await canSendCode(email);\n   512→    if (!rateCheck.allowed) {\n   513→      return res.status(429).json({\n   514→        error: 'Too many requests',\n   515→        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n   516→        waitSeconds: rateCheck.waitSeconds\n   517→      });\n   518→    }\n   519→\n   520→    try {\n   521→      // Generate and store verification code (async - Redis backed)\n   522→      const code = generateVerificationCode();\n   523→      await storeVerificationCode(email, code);\n   524→\n   525→      // Send verification email\n   526→      if (emailService && emailService.sendEmailVerificationCode) {\n   527→        await emailService.sendEmailVerificationCode(email, code, 10);\n   528→        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n   529→      } else {\n   530→        // Fallback for development - log to console\n   531→        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n   532→      }\n   533→\n   534→      res.json({\n   535→        success: true,\n   536→        message: 'Verification code sent. Please check your email.',\n   537→        expiresInMinutes: 10\n   538→      });\n   539→    } catch (err) {\n   540→      console.error('[Auth] Send verification error:', err.message);\n   541→      res.status(500).json({\n   542→        error: 'Failed to send verification code',\n   543→        message: 'Please try again later'\n   544→      });\n   545→    }\n   546→  });\n   547→\n   548→  /**\n   549→   * POST /verify-email - Verify an email address with a code\n   550→   *\n   551→   * Request body: { email: string, code: string }\n   552→   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   553→   *\n   554→   * SECURITY: Limited attempts per code. CSRF protection applied.\n   555→   * HIGH-003: Added IP-based rate limiting (5 requests per 15 minutes per IP)\n   556→   */\n   557→  router.post('/verify-email', emailVerificationLimiter, validateCsrfToken, async (req, res) => {\n   558→    const { email, code } = req.body;\n   559→\n   560→    // Validate inputs\n   561→    if (!email) {\n   562→      return res.status(400).json({\n   563→        error: 'Email required',\n   564→        message: 'Please provide an email address'\n   565→      });\n   566→    }\n   567→\n   568→    if (!code) {\n   569→      return res.status(400).json({\n   570→        error: 'Code required',\n   571→        message: 'Please provide the verification code'\n   572→      });\n   573→    }\n   574→\n   575→    if (!isValidEmail(email)) {\n   576→      return res.status(400).json({\n   577→        error: 'Invalid email',\n   578→        message: 'Please provide a valid email address'\n   579→      });\n   580→    }\n   581→\n   582→    // Validate code format (6 digits)\n   583→    const codeStr = String(code).trim();\n   584→    if (!/^\\d{6}$/.test(codeStr)) {\n   585→      return res.status(400).json({\n   586→        error: 'Invalid code format',\n   587→        message: 'Verification code must be 6 digits'\n   588→      });\n   589→    }\n   590→\n   591→    try {\n   592→      // Verify the code (async - Redis backed)\n   593→      const result = await verifyCode(email, codeStr);\n   594→\n   595→      if (!result.valid) {\n   596→        return res.status(400).json({\n   597→          success: false,\n   598→          verified: false,\n   599→          error: 'Verification failed',\n   600→          message: result.error\n   601→        });\n   602→      }\n   603→\n   604→      // Mark email as verified in the database\n   605→      if (usageTracking && usageTracking.markEmailVerified) {\n   606→        const dbResult = await usageTracking.markEmailVerified(email);\n   607→        if (!dbResult.success) {\n   608→          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n   609→        }\n   610→      }\n   611→\n   612→      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n   613→\n   614→      // Email verified successfully\n   615→      res.json({\n   616→        success: true,\n   617→        verified: true,\n   618→        message: 'Email verified successfully'\n   619→      });\n   620→    } catch (err) {\n   621→      console.error('[Auth] Verify email error:', err.message);\n   622→      res.status(500).json({\n   623→        error: 'Verification failed',\n   624→        message: 'Please try again later'\n   625→      });\n   626→    }\n   627→  });\n   628→\n   629→  return router;\n   630→}\n   631→\n   632→module.exports = createAuthRoutes;\n   633→\n\n</system-reminder>\n"}]},"uuid":"80a501de-02a4-4490-995e-c3b50e658a1c","timestamp":"2026-01-12T01:12:09.291Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/auth.js","content":"/**\n * Auth Routes\n *\n * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n *\n * SECURITY: Enhanced with endpoint-specific rate limiting for sensitive operations\n * HIGH-003: Added IP-based rate limiting for email verification endpoints\n * MEDIUM-004: Redis-backed verification codes for horizontal scaling\n */\n\nconst express = require('express');\nconst crypto = require('crypto');\nconst { rateLimit } = require('express-rate-limit');\nconst { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\nconst { endpointRateLimit } = require('../middleware/rateLimiter');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// ============================================================================\n// HIGH-003: IP-Based Rate Limiting for Email Verification\n// Prevents abuse of email verification endpoints regardless of email\n// ============================================================================\n\n/**\n * IP-based rate limiter for email verification endpoints\n * Limits: 5 requests per 15 minutes per IP address\n */\nconst emailVerificationLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 requests per IP per window\n  keyGenerator: (req) => {\n    // Use X-Forwarded-For header in production (behind proxy)\n    return req.ip || req.headers['x-forwarded-for']?.split(',')[0]?.trim() || 'unknown';\n  },\n  message: {\n    error: 'Too many verification attempts',\n    message: 'Too many verification requests from this IP. Please try again later.',\n    retryAfter: 15 * 60 // 15 minutes in seconds\n  },\n  standardHeaders: true, // Return rate limit info in RateLimit-* headers\n  legacyHeaders: false, // Disable X-RateLimit-* headers\n  handler: (req, res, next, options) => {\n    console.warn(`[Auth] IP rate limit exceeded for email verification: ${req.ip}`);\n    res.status(429).json(options.message);\n  }\n});\n\n// ============================================================================\n// Email Verification Code Storage\n// MEDIUM-004: Redis-backed storage for horizontal scaling\n// Fallback to in-memory storage when Redis is unavailable\n// ============================================================================\n\n// Fallback in-memory storage (used when Redis is unavailable)\nconst fallbackVerificationCodes = new Map();\nconst fallbackLastSendTime = new Map();\n\n// Verification code expiry time (10 minutes = 600 seconds)\nconst VERIFICATION_CODE_TTL_SECONDS = 600;\nconst VERIFICATION_CODE_EXPIRY_MS = VERIFICATION_CODE_TTL_SECONDS * 1000;\n\n// Maximum verification attempts before code is invalidated\nconst MAX_VERIFICATION_ATTEMPTS = 5;\n\n// Rate limiting: minimum time between sending codes to same email (60 seconds)\nconst SEND_CODE_COOLDOWN_SECONDS = 60;\nconst SEND_CODE_COOLDOWN_MS = SEND_CODE_COOLDOWN_SECONDS * 1000;\n\n// Redis key prefixes\nconst REDIS_KEY_VERIFY = 'verify:';\nconst REDIS_KEY_SEND_TIME = 'verify:sendtime:';\n\n/**\n * Generate a 6-digit verification code\n * @returns {string} 6-digit code\n */\nfunction generateVerificationCode() {\n  // Generate cryptographically secure random 6-digit code\n  const code = crypto.randomInt(100000, 999999).toString();\n  return code;\n}\n\n/**\n * Store a verification code for an email (Redis-backed with fallback)\n * @param {string} email - Email address\n * @param {string} code - Verification code\n * @returns {Promise<void>}\n */\nasync function storeVerificationCode(email, code) {\n  const normalizedEmail = email.toLowerCase().trim();\n  const data = {\n    code,\n    createdAt: Date.now(),\n    attempts: 0\n  };\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const verifyKey = `${REDIS_KEY_VERIFY}${normalizedEmail}`;\n      const sendTimeKey = `${REDIS_KEY_SEND_TIME}${normalizedEmail}`;\n      \n      await redis.set(verifyKey, data, VERIFICATION_CODE_TTL_SECONDS);\n      await redis.set(sendTimeKey, Date.now(), SEND_CODE_COOLDOWN_SECONDS * 2); // Keep send time a bit longer\n      return;\n    } catch (err) {\n      console.warn('[Auth] Redis store failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory storage\n  fallbackVerificationCodes.set(normalizedEmail, {\n    ...data,\n    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS\n  });\n  fallbackLastSendTime.set(normalizedEmail, Date.now());\n}\n\n/**\n * Verify a code for an email (Redis-backed with fallback)\n * @param {string} email - Email address\n * @param {string} code - Code to verify\n * @returns {Promise<{ valid: boolean, error?: string }>}\n */\nasync function verifyCode(email, code) {\n  const normalizedEmail = email.toLowerCase().trim();\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const verifyKey = `${REDIS_KEY_VERIFY}${normalizedEmail}`;\n      const stored = await redis.get(verifyKey);\n\n      if (!stored) {\n        return { valid: false, error: 'No verification code found. Please request a new one.' };\n      }\n\n      // Increment attempt counter\n      stored.attempts = (stored.attempts || 0) + 1;\n\n      // Check if too many attempts\n      if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n        await redis.del(verifyKey);\n        return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n      }\n\n      // Check if code matches\n      if (stored.code !== code) {\n        // Update attempts count in Redis (keep remaining TTL)\n        const ttl = await redis.ttl(verifyKey);\n        if (ttl > 0) {\n          await redis.set(verifyKey, stored, ttl);\n        }\n        return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n      }\n\n      // Code is valid - remove it (single use)\n      await redis.del(verifyKey);\n      return { valid: true };\n    } catch (err) {\n      console.warn('[Auth] Redis verify failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory storage\n  const stored = fallbackVerificationCodes.get(normalizedEmail);\n\n  if (!stored) {\n    return { valid: false, error: 'No verification code found. Please request a new one.' };\n  }\n\n  // Check if expired\n  if (Date.now() > stored.expires) {\n    fallbackVerificationCodes.delete(normalizedEmail);\n    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n  }\n\n  // Increment attempt counter\n  stored.attempts++;\n\n  // Check if too many attempts\n  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n    fallbackVerificationCodes.delete(normalizedEmail);\n    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n  }\n\n  // Check if code matches\n  if (stored.code !== code) {\n    fallbackVerificationCodes.set(normalizedEmail, stored);\n    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n  }\n\n  // Code is valid - remove it (single use)\n  fallbackVerificationCodes.delete(normalizedEmail);\n  return { valid: true };\n}\n\n/**\n * Check if we can send a new code to an email (rate limiting, Redis-backed)\n * @param {string} email - Email address\n * @returns {Promise<{ allowed: boolean, waitSeconds?: number }>}\n */\nasync function canSendCode(email) {\n  const normalizedEmail = email.toLowerCase().trim();\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const sendTimeKey = `${REDIS_KEY_SEND_TIME}${normalizedEmail}`;\n      const lastSent = await redis.get(sendTimeKey);\n\n      if (!lastSent) {\n        return { allowed: true };\n      }\n\n      const elapsed = Date.now() - lastSent;\n      if (elapsed < SEND_CODE_COOLDOWN_MS) {\n        const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n        return { allowed: false, waitSeconds };\n      }\n\n      return { allowed: true };\n    } catch (err) {\n      console.warn('[Auth] Redis canSendCode failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory storage\n  const lastSent = fallbackLastSendTime.get(normalizedEmail);\n\n  if (!lastSent) {\n    return { allowed: true };\n  }\n\n  const elapsed = Date.now() - lastSent;\n  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n    return { allowed: false, waitSeconds };\n  }\n\n  return { allowed: true };\n}\n\n// Cleanup for fallback in-memory storage (only needed when Redis is unavailable)\n// Redis handles expiration automatically via TTL\nfunction cleanupFallbackStorage() {\n  const now = Date.now();\n  let cleanedCount = 0;\n\n  for (const [email, data] of fallbackVerificationCodes.entries()) {\n    if (data.expires <= now) {\n      fallbackVerificationCodes.delete(email);\n      cleanedCount++;\n    }\n  }\n\n  // Also clean up old lastSendTime entries (older than 1 hour)\n  const oneHourAgo = now - (60 * 60 * 1000);\n  for (const [email, time] of fallbackLastSendTime.entries()) {\n    if (time < oneHourAgo) {\n      fallbackLastSendTime.delete(email);\n    }\n  }\n\n  if (cleanedCount > 0) {\n    console.log(`[Auth] Fallback storage cleanup: removed ${cleanedCount} expired codes`);\n  }\n}\n\n// Start periodic cleanup for fallback storage (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackStorage, 5 * 60 * 1000);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Validate email format\n * @param {string} email - Email to validate\n * @returns {boolean}\n */\nfunction isValidEmail(email) {\n  if (!email || typeof email !== 'string') return false;\n  // Basic email validation regex\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email.trim());\n}\n\n/**\n * Create auth routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (authenticateToken)\n * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n * @param {Object} options.authHelpers - Auth helper functions\n * @returns {express.Router}\n */\nfunction createAuthRoutes(options = {}) {\n  const router = express.Router();\n  const { authenticateToken } = options.middleware || {};\n  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n  const { usageTracking, licenseService, emailService } = options.services || {};\n\n  /**\n   * GET /csrf-token - Generate and return a CSRF token\n   *\n   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   * The token is returned in both the response body and an HttpOnly cookie.\n   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   */\n  router.get('/csrf-token', csrfTokenHandler);\n\n  /**\n   * POST /login - Authenticate with license key and get JWT token\n   *\n   * SECURITY: This is the primary authentication endpoint.\n   * Validates license key and returns a JWT token for API access.\n   * NOTE: CSRF disabled - license key auth is not vulnerable to CSRF\n   * (user must know the key, it's not auto-submitted like cookies)\n   */\n  router.post('/login', async (req, res) => {\n    const { licenseKey } = req.body;\n\n    if (!licenseKey) {\n      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n      return res.status(400).json({\n        error: 'License key required',\n        message: 'Please provide your license key to log in'\n      });\n    }\n\n    try {\n      // Validate and activate the license key\n      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n\n      if (!licenseResult.success) {\n        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n        return res.status(401).json({\n          error: 'Invalid license key',\n          message: licenseResult.error || 'The license key is invalid or expired'\n        });\n      }\n\n      // Get user's tier and balance\n      const balance = await usageTracking.getBalance(licenseResult.customerId);\n\n      // Generate JWT tokens\n      const tokenResult = generateToken(licenseResult.customerId, {\n        tier: balance.tier,\n        email: licenseResult.email\n      });\n      const refreshResult = generateRefreshToken(licenseResult.customerId);\n\n      // Log successful login with structured logging\n      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n        email: licenseResult.email,\n        tier: balance.tier\n      });\n\n      res.json({\n        success: true,\n        token: tokenResult.token,\n        tokenType: tokenResult.tokenType,\n        expiresIn: tokenResult.expiresIn,\n        refreshToken: refreshResult.refreshToken,\n        customerId: licenseResult.customerId,\n        tier: balance.tier,\n        hoursRemaining: balance.hoursRemaining\n      });\n    } catch (err) {\n      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n    }\n  });\n\n  /**\n   * POST /refresh - Refresh an expired JWT token\n   *\n   * Uses a refresh token to get a new access token.\n   * NOTE: CSRF disabled for cross-domain compatibility during beta.\n   */\n  router.post('/refresh', async (req, res) => {\n    const { refreshToken } = req.body;\n\n    if (!refreshToken) {\n      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n      return res.status(400).json({\n        error: 'Refresh token required'\n      });\n    }\n\n    try {\n      const decoded = await verifyToken(refreshToken, { req });\n\n      if (!decoded || decoded.type !== 'refresh') {\n        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n        return res.status(401).json({\n          error: 'Invalid refresh token',\n          message: 'Please log in again'\n        });\n      }\n\n      // Get current user info\n      const balance = await usageTracking.getBalance(decoded.sub);\n\n      // Generate new access token\n      const tokenResult = generateToken(decoded.sub, {\n        tier: balance.tier\n      });\n\n      // Log successful token refresh\n      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n\n      res.json({\n        success: true,\n        token: tokenResult.token,\n        tokenType: tokenResult.tokenType,\n        expiresIn: tokenResult.expiresIn\n      });\n    } catch (err) {\n      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n      res.status(401).json({\n        error: 'Failed to refresh token',\n        message: 'Please log in again'\n      });\n    }\n  });\n\n  /**\n   * POST /logout - Invalidate tokens by adding to blacklist\n   *\n   * Adds the current token's jti to the blacklist so it cannot be reused.\n   * Also accepts an optional refreshToken to revoke both tokens at once.\n   * CSRF protection applied to prevent forced logout attacks.\n   */\n  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n    const { refreshToken } = req.body;\n    let refreshTokenRevoked = false;\n\n    // Blacklist the access token using the blacklistToken function from authHelpers\n    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n      if (blacklistToken) {\n        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n          userId: req.stripeCustomerId,\n          reason: 'logout'\n        });\n      } else {\n        console.warn('[Auth] Logout: blacklistToken function not available');\n      }\n    } else {\n      // Token doesn't have jti - log warning but continue\n      // This handles tokens generated before jti was added\n      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n    }\n\n    // Optionally blacklist the refresh token too\n    if (refreshToken && blacklistToken) {\n      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n      if (decoded && decoded.jti && decoded.exp) {\n        await blacklistToken(decoded.jti, decoded.exp, {\n          userId: req.stripeCustomerId,\n          reason: 'logout_refresh'\n        });\n        refreshTokenRevoked = true;\n      }\n    }\n\n    // Log successful logout with structured logging\n    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n      jti: req.tokenData?.jti,\n      refreshTokenRevoked\n    });\n\n    res.json({\n      success: true,\n      message: 'Logged out successfully'\n    });\n  });\n\n  // ==========================================================================\n  // Email Verification Endpoints\n  // ==========================================================================\n\n  /**\n   * POST /send-verification - Send a verification code to an email address\n   *\n   * Request body: { email: string }\n   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   *\n   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   * HIGH-003: Added IP-based rate limiting (5 requests per 15 minutes per IP)\n   */\n  router.post('/send-verification', emailVerificationLimiter, validateCsrfToken, async (req, res) => {\n    const { email } = req.body;\n\n    // Validate email\n    if (!email) {\n      return res.status(400).json({\n        error: 'Email required',\n        message: 'Please provide an email address'\n      });\n    }\n\n    if (!isValidEmail(email)) {\n      return res.status(400).json({\n        error: 'Invalid email',\n        message: 'Please provide a valid email address'\n      });\n    }\n\n    // Check rate limiting (async - Redis backed)\n    const rateCheck = await canSendCode(email);\n    if (!rateCheck.allowed) {\n      return res.status(429).json({\n        error: 'Too many requests',\n        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n        waitSeconds: rateCheck.waitSeconds\n      });\n    }\n\n    try {\n      // Generate and store verification code (async - Redis backed)\n      const code = generateVerificationCode();\n      await storeVerificationCode(email, code);\n\n      // Send verification email\n      if (emailService && emailService.sendEmailVerificationCode) {\n        await emailService.sendEmailVerificationCode(email, code, 10);\n        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n      } else {\n        // Fallback for development - log to console\n        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n      }\n\n      res.json({\n        success: true,\n        message: 'Verification code sent. Please check your email.',\n        expiresInMinutes: 10\n      });\n    } catch (err) {\n      console.error('[Auth] Send verification error:', err.message);\n      res.status(500).json({\n        error: 'Failed to send verification code',\n        message: 'Please try again later'\n      });\n    }\n  });\n\n  /**\n   * POST /verify-email - Verify an email address with a code\n   *\n   * Request body: { email: string, code: string }\n   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   *\n   * SECURITY: Limited attempts per code. CSRF protection applied.\n   * HIGH-003: Added IP-based rate limiting (5 requests per 15 minutes per IP)\n   */\n  router.post('/verify-email', emailVerificationLimiter, validateCsrfToken, async (req, res) => {\n    const { email, code } = req.body;\n\n    // Validate inputs\n    if (!email) {\n      return res.status(400).json({\n        error: 'Email required',\n        message: 'Please provide an email address'\n      });\n    }\n\n    if (!code) {\n      return res.status(400).json({\n        error: 'Code required',\n        message: 'Please provide the verification code'\n      });\n    }\n\n    if (!isValidEmail(email)) {\n      return res.status(400).json({\n        error: 'Invalid email',\n        message: 'Please provide a valid email address'\n      });\n    }\n\n    // Validate code format (6 digits)\n    const codeStr = String(code).trim();\n    if (!/^\\d{6}$/.test(codeStr)) {\n      return res.status(400).json({\n        error: 'Invalid code format',\n        message: 'Verification code must be 6 digits'\n      });\n    }\n\n    try {\n      // Verify the code (async - Redis backed)\n      const result = await verifyCode(email, codeStr);\n\n      if (!result.valid) {\n        return res.status(400).json({\n          success: false,\n          verified: false,\n          error: 'Verification failed',\n          message: result.error\n        });\n      }\n\n      // Mark email as verified in the database\n      if (usageTracking && usageTracking.markEmailVerified) {\n        const dbResult = await usageTracking.markEmailVerified(email);\n        if (!dbResult.success) {\n          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n        }\n      }\n\n      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n\n      // Email verified successfully\n      res.json({\n        success: true,\n        verified: true,\n        message: 'Email verified successfully'\n      });\n    } catch (err) {\n      console.error('[Auth] Verify email error:', err.message);\n      res.status(500).json({\n        error: 'Verification failed',\n        message: 'Please try again later'\n      });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createAuthRoutes;\n","numLines":633,"startLine":1,"totalLines":633}}}
{"parentUuid":"80a501de-02a4-4490-995e-c3b50e658a1c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PvTMJ8pNHXqDwyiacSMUfp","type":"tool_result","content":"Found 3 files\nsplice-backend/routes/health.js\nsplice-backend/routes/billing.js\nsplice-backend/routes/music.js"}]},"uuid":"aeb6fb2b-2f40-4098-a0e6-13df4571eead","timestamp":"2026-01-12T01:12:09.301Z","toolUseResult":{"mode":"files_with_matches","filenames":["splice-backend/routes/health.js","splice-backend/routes/billing.js","splice-backend/routes/music.js"],"numFiles":3}}
{"parentUuid":"aeb6fb2b-2f40-4098-a0e6-13df4571eead","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MPNVhAAUFpP3G5UjrAGc1v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BWJmCtpYo6MMQPLn6kRC31","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/billing.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8429,"cache_read_input_tokens":60062,"cache_creation":{"ephemeral_5m_input_tokens":8429,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CX2bTMiyiLb4zSGbiGKpd","type":"assistant","uuid":"d707f4b2-73a1-46f9-9f44-61119cb8ce49","timestamp":"2026-01-12T01:12:13.323Z"}
{"parentUuid":"d707f4b2-73a1-46f9-9f44-61119cb8ce49","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BWJmCtpYo6MMQPLn6kRC31","type":"tool_result","content":"     1→/**\n     2→ * Billing Routes\n     3→ *\n     4→ * Credits and usage history endpoints\n     5→ */\n     6→\n     7→const express = require('express');\n     8→\n     9→/**\n    10→ * Create billing routes\n    11→ * @param {Object} options - Route configuration options\n    12→ * @param {Object} options.services - Shared services (usageTracking)\n    13→ * @param {Object} options.authHelpers - Auth helper functions (verifyToken)\n    14→ * @returns {express.Router}\n    15→ */\n    16→function createBillingRoutes(options = {}) {\n    17→  const router = express.Router();\n    18→  const { usageTracking } = options.services || {};\n    19→  const { verifyToken } = options.authHelpers || {};\n    20→\n    21→  /**\n    22→   * GET /credits - Get user's credit balance\n    23→   *\n    24→   * Supports both JWT (Authorization: Bearer) and legacy x-stripe-customer-id header\n    25→   */\n    26→  router.get('/credits', async (req, res) => {\n    27→    // Support both JWT and legacy auth\n    28→    let stripeCustomerId = null;\n    29→\n    30→    // Try JWT first\n    31→    const authHeader = req.headers['authorization'];\n    32→    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n    33→      const token = authHeader.slice(7);\n    34→      const decoded = await verifyToken(token);\n    35→      if (decoded && decoded.sub) {\n    36→        stripeCustomerId = decoded.sub;\n    37→      }\n    38→    }\n    39→\n    40→    // Fallback to legacy header\n    41→    if (!stripeCustomerId) {\n    42→      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    43→    }\n    44→\n    45→    if (!stripeCustomerId) {\n    46→      return res.status(401).json({\n    47→        error: 'Authentication required',\n    48→        message: 'Please provide a valid Bearer token or log in again'\n    49→      });\n    50→    }\n    51→\n    52→    try {\n    53→      const balance = await usageTracking.getBalance(stripeCustomerId);\n    54→      res.json({\n    55→        success: true,\n    56→        ...balance\n    57→      });\n    58→    } catch (err) {\n    59→      console.error('[SPLICE] Credits error:', err);\n    60→      res.status(500).json({ error: err.message });\n    61→    }\n    62→  });\n    63→\n    64→  /**\n    65→   * GET /usage-history - Get user's usage history\n    66→   */\n    67→  router.get('/usage-history', async (req, res) => {\n    68→    // Support both JWT and legacy auth\n    69→    let stripeCustomerId = null;\n    70→\n    71→    const authHeader = req.headers['authorization'];\n    72→    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n    73→      const token = authHeader.slice(7);\n    74→      const decoded = await verifyToken(token);\n    75→      if (decoded && decoded.sub) {\n    76→        stripeCustomerId = decoded.sub;\n    77→      }\n    78→    }\n    79→\n    80→    if (!stripeCustomerId) {\n    81→      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    82→    }\n    83→\n    84→    if (!stripeCustomerId) {\n    85→      return res.status(401).json({\n    86→        error: 'Authentication required',\n    87→        message: 'Please provide a valid Bearer token or log in again'\n    88→      });\n    89→    }\n    90→\n    91→    try {\n    92→      const history = await usageTracking.getUsageHistory(stripeCustomerId);\n    93→      res.json({\n    94→        success: true,\n    95→        history\n    96→      });\n    97→    } catch (err) {\n    98→      console.error('[SPLICE] Usage history error:', err);\n    99→      res.status(500).json({ error: err.message });\n   100→    }\n   101→  });\n   102→\n   103→  return router;\n   104→}\n   105→\n   106→module.exports = createBillingRoutes;\n   107→\n\n</system-reminder>\n"}]},"uuid":"74429994-a834-455f-9cbe-f3af2549aac4","timestamp":"2026-01-12T01:12:13.365Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/billing.js","content":"/**\n * Billing Routes\n *\n * Credits and usage history endpoints\n */\n\nconst express = require('express');\n\n/**\n * Create billing routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.services - Shared services (usageTracking)\n * @param {Object} options.authHelpers - Auth helper functions (verifyToken)\n * @returns {express.Router}\n */\nfunction createBillingRoutes(options = {}) {\n  const router = express.Router();\n  const { usageTracking } = options.services || {};\n  const { verifyToken } = options.authHelpers || {};\n\n  /**\n   * GET /credits - Get user's credit balance\n   *\n   * Supports both JWT (Authorization: Bearer) and legacy x-stripe-customer-id header\n   */\n  router.get('/credits', async (req, res) => {\n    // Support both JWT and legacy auth\n    let stripeCustomerId = null;\n\n    // Try JWT first\n    const authHeader = req.headers['authorization'];\n    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n      const token = authHeader.slice(7);\n      const decoded = await verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n      }\n    }\n\n    // Fallback to legacy header\n    if (!stripeCustomerId) {\n      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please provide a valid Bearer token or log in again'\n      });\n    }\n\n    try {\n      const balance = await usageTracking.getBalance(stripeCustomerId);\n      res.json({\n        success: true,\n        ...balance\n      });\n    } catch (err) {\n      console.error('[SPLICE] Credits error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * GET /usage-history - Get user's usage history\n   */\n  router.get('/usage-history', async (req, res) => {\n    // Support both JWT and legacy auth\n    let stripeCustomerId = null;\n\n    const authHeader = req.headers['authorization'];\n    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n      const token = authHeader.slice(7);\n      const decoded = await verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n      }\n    }\n\n    if (!stripeCustomerId) {\n      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please provide a valid Bearer token or log in again'\n      });\n    }\n\n    try {\n      const history = await usageTracking.getUsageHistory(stripeCustomerId);\n      res.json({\n        success: true,\n        history\n      });\n    } catch (err) {\n      console.error('[SPLICE] Usage history error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createBillingRoutes;\n","numLines":107,"startLine":1,"totalLines":107}}}
{"parentUuid":"74429994-a834-455f-9cbe-f3af2549aac4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"acff149","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CDH5h9e9WYDHJbHaoZG2Eh","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have all the information needed to provide a comprehensive verification report. Let me compile the findings:\n\n---\n\n# Authentication Flow Verification Report for Beta Testers\n\n## Executive Summary\n\n**Overall Verdict: PASS WITH ISSUES**\n\nThe authentication flow is functionally complete and should work for beta testers like Danny. However, there are several issues that could cause confusion or potential failures under certain conditions.\n\n---\n\n## Requirements Checklist\n\n### 1. Login Flow\n\n| Requirement | Status | Details |\n|-------------|--------|---------|\n| License key validation format (SPLICE-XXXX-XXXX-XXXX) | MET | Properly validated in `config.js` line 1032-1036 with correct character set excluding confusing chars (0/O, 1/I/L) |\n| POST /auth/login endpoint call | MET | Backend route defined in `routes/auth.js` lines 319-372, client calls in `config.js` lines 1098-1103 |\n| JWT token storage (accessToken, refreshToken, tokenExpiry) | MET | Stored correctly in `config.js` lines 1114-1119 with encrypted localStorage |\n| Error messages for invalid keys | MET | Detailed error handling with specific messages for different failure modes (lines 1154-1171) |\n\n**Code Evidence - Login Request:**\n```javascript\n// config.js lines 1098-1103\nconst response = await fetchWithTimeout(`${getBackendUrl()}/auth/login`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ licenseKey: licenseKey })\n}, SPLICE_CONFIG.FETCH_TIMEOUT);\n```\n\n**Code Evidence - Token Storage:**\n```javascript\n// config.js lines 1114-1119\nsaveSettings({\n    customerId: result.customerId,\n    accessToken: result.token,\n    refreshToken: result.refreshToken,\n    tokenExpiry: Date.now() + expiresInMs,\n    licenseKey: licenseKey\n});\n```\n\n---\n\n### 2. Session Management\n\n| Requirement | Status | Details |\n|-------------|--------|---------|\n| Token expiry checking (isTokenExpired) | MET | `isTokenExpired()` function at lines 300-307 with 5-minute buffer |\n| Automatic token refresh (refreshAccessToken) | MET | `refreshAccessToken()` function at lines 313-356 |\n| 401 handling with retry | MET | Implemented in `credits.js` lines 51-88 |\n\n**Code Evidence - Token Expiry Check:**\n```javascript\n// config.js lines 300-307\nfunction isTokenExpired() {\n    const settings = getSettings();\n    if (!settings.tokenExpiry) return true;\n    // Refresh if less than 5 minutes remaining\n    const bufferMs = 5 * 60 * 1000;\n    return Date.now() >= (settings.tokenExpiry - bufferMs);\n}\n```\n\n**Code Evidence - 401 Retry Logic:**\n```javascript\n// credits.js lines 51-88\nif (response.status === 401 && typeof refreshAccessToken === 'function') {\n    debugLog('[Credits] Got 401, attempting token refresh...');\n    const refreshed = await refreshAccessToken();\n    if (refreshed) {\n        // Retry with new token\n        const retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n            method: 'GET',\n            headers: getAuthHeaders()\n        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n        // ... handle retry response\n    }\n}\n```\n\n---\n\n### 3. Legacy Auth Support (for existing users like Danny)\n\n| Requirement | Status | Details |\n|-------------|--------|---------|\n| x-stripe-customer-id header fallback | MET | Supported in `getAuthHeaders()` lines 276-294 and backend `auth.js` lines 471-507 |\n| ALLOW_LEGACY_AUTH=true in production | PARTIALLY MET | Default is FALSE in production - must be explicitly set |\n| Graceful migration to JWT on re-login | MET | Login stores new JWT tokens, legacy header only used as fallback |\n\n**ISSUE FOUND - Legacy Auth Default:**\n\nThe `ALLOW_LEGACY_AUTH` environment variable defaults to `false` in production:\n\n```javascript\n// auth.js lines 74-75\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n```\n\n**Impact:** If Danny or other beta testers have old cached sessions using `x-stripe-customer-id` header (without JWT), they will receive 401 errors unless:\n1. They re-login to get JWT tokens, OR\n2. `ALLOW_LEGACY_AUTH=true` is set in Railway environment\n\n**Recommendation:** Verify that `ALLOW_LEGACY_AUTH=true` is set in Railway production environment to support existing beta testers during migration period.\n\n---\n\n### 4. Credits Display\n\n| Requirement | Status | Details |\n|-------------|--------|---------|\n| fetchCredits() with auth headers | MET | `credits.js` lines 23-119 with proper `getAuthHeaders()` usage |\n| Credit badge states (login, error, ok, low, trial) | MET | All states implemented in `updateCreditDisplay()` lines 135-199 |\n| Retry on failure | MET | `retryFetchCredits()` with exponential backoff at lines 355-388 |\n\n**Code Evidence - Credit Badge States:**\n```javascript\n// credits.js line 147 - Login state\ncreditBadge.classList.add('login');\n\n// credits.js line 157 - Error state  \ncreditBadge.classList.add('error');\n\n// credits.js line 175 - Trial state\ncreditBadge.classList.add('trial');\n\n// credits.js lines 192-198 - OK/Low states\nif (credits.hoursRemaining <= 1) {\n    creditBadge.classList.add('low');\n} else {\n    creditBadge.classList.add('ok');\n}\n```\n\n---\n\n### 5. Logout\n\n| Requirement | Status | Details |\n|-------------|--------|---------|\n| Token clearing | MET | `clearAuthTokens()` at lines 361-368 and `logout()` at lines 1335-1352 |\n| UI reset | MET | Calls `clearCreditsCache()` and `updateCreditDisplay(null)` |\n\n**Code Evidence - Logout:**\n```javascript\n// config.js lines 1335-1352\nfunction logout() {\n    saveSettings({\n        customerId: null,\n        accessToken: null,\n        refreshToken: null,\n        tokenExpiry: null,\n        licenseKey: null\n    });\n    if (typeof clearCreditsCache === 'function') {\n        clearCreditsCache();\n    }\n    if (typeof updateCreditDisplay === 'function') {\n        updateCreditDisplay(null);\n    }\n    setStatus('Logged out');\n}\n```\n\n---\n\n## Detailed Findings\n\n### Issue 1: CSRF Token Not Sent with Login (Medium Priority)\n\n**Location:** `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js` lines 1098-1103\n\n**Finding:** The login request does NOT include a CSRF token, but the backend route at `routes/auth.js` line 319 does NOT require CSRF validation for login (intentionally):\n\n```javascript\n// Backend: routes/auth.js line 319 - No CSRF middleware\nrouter.post('/login', async (req, res) => {\n```\n\n**Status:** This is CORRECT and by design. The comment at line 316-317 explains:\n> NOTE: CSRF disabled - license key auth is not vulnerable to CSRF (user must know the key, it's not auto-submitted like cookies)\n\n**Verdict:** NOT AN ISSUE\n\n---\n\n### Issue 2: Billing Route Does Not Use ALLOW_LEGACY_AUTH Check (Medium Priority)\n\n**Location:** `/Users/imorgado/SPLICE/splice-backend/routes/billing.js` lines 40-42\n\n**Finding:** The `/credits` endpoint directly accepts `x-stripe-customer-id` header without checking `ALLOW_LEGACY_AUTH`:\n\n```javascript\n// billing.js lines 40-42\nif (!stripeCustomerId) {\n  stripeCustomerId = req.headers['x-stripe-customer-id'];\n}\n```\n\n**Impact:** This means legacy auth always works for the credits endpoint regardless of `ALLOW_LEGACY_AUTH` setting, which is inconsistent with the main `authenticateToken` middleware behavior.\n\n**Priority:** Medium - Could lead to confusion but works in beta testers' favor.\n\n**Recommendation:** Either:\n1. Apply the `authenticateToken` middleware to billing routes for consistency, OR\n2. Document that `/credits` endpoint intentionally allows legacy auth\n\n---\n\n### Issue 3: Token Refresh Does Not Require CSRF (Low Priority)\n\n**Location:** `/Users/imorgado/SPLICE/splice-backend/routes/auth.js` line 380\n\n**Finding:** The `/auth/refresh` endpoint does not require CSRF validation:\n\n```javascript\n// routes/auth.js line 380\nrouter.post('/refresh', async (req, res) => {\n```\n\n**Impact:** This is intentional for cross-domain compatibility during beta (comment at line 378-379). However, the client at `config.js` line 324 also does not send CSRF:\n\n```javascript\n// config.js lines 324-327\nconst response = await fetchWithTimeout(`${getBackendUrl()}/auth/refresh`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ refreshToken: settings.refreshToken })\n}, 30000);\n```\n\n**Status:** Consistent between client and server.\n\n**Verdict:** NOT AN ISSUE - Working as designed for beta.\n\n---\n\n### Issue 4: ensureValidToken() Not Always Called Before API Requests (Low Priority)\n\n**Location:** `/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js` lines 34-41\n\n**Finding:** The `fetchCredits()` function correctly calls `ensureValidToken()` before making requests:\n\n```javascript\nif (typeof ensureValidToken === 'function') {\n    const hasValidToken = await ensureValidToken();\n    if (!hasValidToken && !settings.accessToken) {\n        debugLog('[Credits] No JWT token, using legacy auth');\n    }\n}\n```\n\n**Status:** This is correct behavior and gracefully handles both JWT and legacy auth.\n\n**Verdict:** NOT AN ISSUE\n\n---\n\n### Issue 5: Debug Mode Logging (Info)\n\n**Location:** `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js` lines 11-38\n\n**Finding:** Debug mode can be enabled via localStorage for troubleshooting:\n\n```javascript\n// Enable debug mode\nlocalStorage.setItem('spliceDebugMode', 'true');\n```\n\n**Status:** Useful for beta testers experiencing issues.\n\n**Recommendation:** Document this for Danny and other beta testers to enable verbose logging if needed.\n\n---\n\n## Potential Issues for Beta Testers\n\n### Scenario 1: Danny Has Old Cached Session\n\n**Risk:** If Danny's panel has `customerId` stored but no JWT tokens (from before JWT was implemented), and `ALLOW_LEGACY_AUTH=false`:\n\n1. Credits fetch will work (billing route allows legacy auth)\n2. Other authenticated endpoints may fail with 401\n\n**Solution:** \n- Danny should re-login with license key to get fresh JWT tokens\n- OR set `ALLOW_LEGACY_AUTH=true` in Railway environment\n\n### Scenario 2: Token Refresh Failure\n\n**Risk:** If refresh token expires (7 days) or is blacklisted, user gets \"Session expired. Please log in again.\"\n\n**Handling:** \n- `credits.js` lines 82-87 properly handles this by calling `clearAuthTokens()` and returning error message\n- User sees \"Retry\" badge and can click to attempt re-login\n\n### Scenario 3: Network/CORS Issues\n\n**Risk:** CEP panels may have network restrictions.\n\n**Handling:**\n- Detailed error messages at `config.js` lines 1154-1171 differentiate between timeout, network, CORS, and SSL errors\n- Debug mode provides verbose fetch logging\n\n---\n\n## Recommendations Summary\n\n| Priority | Recommendation | Action |\n|----------|---------------|--------|\n| High | Verify `ALLOW_LEGACY_AUTH=true` in Railway | Check Railway environment variables |\n| Medium | Document debug mode for beta testers | Create troubleshooting guide |\n| Medium | Consider applying `authenticateToken` middleware to billing routes for consistency | Code change in billing.js |\n| Low | Add CSRF to refresh endpoint after beta | Future enhancement |\n\n---\n\n## Files Reviewed\n\n1. `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js` - CEP panel configuration and auth functions\n2. `/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js` - Credits display and fetching\n3. `/Users/imorgado/SPLICE/splice-backend/middleware/auth.js` - JWT authentication middleware\n4. `/Users/imorgado/SPLICE/splice-backend/routes/auth.js` - Authentication endpoints\n5. `/Users/imorgado/SPLICE/splice-backend/routes/billing.js` - Credits endpoint\n\n---\n\n## Conclusion\n\nThe authentication flow is **well-implemented** and should work correctly for beta testers like Danny. The main concerns are:\n\n1. **Ensure `ALLOW_LEGACY_AUTH=true`** is set in production for existing beta testers\n2. **Instruct Danny to re-login** if experiencing issues, which will migrate him to JWT auth\n3. **Enable debug mode** if troubleshooting is needed: `localStorage.setItem('spliceDebugMode', 'true')`\n\nThe code includes proper:\n- License key format validation\n- JWT token generation and storage\n- Automatic token refresh on 401\n- Legacy auth fallback (when enabled)\n- Retry logic with exponential backoff\n- Detailed error messages for troubleshooting"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1271,"cache_read_input_tokens":68491,"cache_creation":{"ephemeral_5m_input_tokens":1271,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2bTf7zLAc3KenPfN3BP","type":"assistant","uuid":"59911571-e532-4cfa-8c4b-e07146004b6e","timestamp":"2026-01-12T01:13:13.586Z"}
