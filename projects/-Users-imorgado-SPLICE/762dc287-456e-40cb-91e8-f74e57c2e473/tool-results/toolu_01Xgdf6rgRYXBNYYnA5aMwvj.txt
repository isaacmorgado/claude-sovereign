The file /Users/imorgado/SPLICE/splice-backend/services/transcription.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     9→
    10→const fs = require('fs');
    11→const OpenAI = require('openai');
    12→
    13→// Initialize OpenAI client
    14→const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    15→
    16→// In-memory cache: { wavPath: { mtime, result } }
    17→const transcriptCache = new Map();
    18→
    19→// Cache configuration
    20→const MAX_CACHE_SIZE = 50;
    21→
    22→/**
    23→ * Retry function with exponential backoff
    24→ * @param {Function} fn - Async function to retry
    25→ * @param {number} retries - Number of retry attempts (default: 3)
    26→ * @param {number} baseDelay - Base delay in ms (default: 1000)
    27→ * @returns {Promise<any>} Result of the function
    28→ */
    29→async function withRetry(fn, retries = 3, baseDelay = 1000) {
    30→  let lastError;
    31→
    32→  for (let attempt = 0; attempt <= retries; attempt++) {
    33→    try {
    34→      return await fn();
    35→    } catch (err) {
    36→      lastError = err;
    37→
    38→      // Don't retry on quota exceeded - fail immediately
    39→      if (err.code === 'insufficient_quota' || err.message?.includes('quota')) {
    40→        throw new Error('OpenAI API quota exceeded. Please check your billing at https://platform.openai.com/account/billing');
    41→      }
    42→
    43→      // Don't retry on the last attempt
    44→      if (attempt === retries) {
    45→        break;
    46→      }
    47→
    48→      // Calculate delay with exponential backoff + jitter
    49→      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 500;
    50→
    51→      // Only retry on retryable errors
    52→      const isRetryable =
    53→        err.status === 429 ||                          // Rate limit
    54→        err.status === 500 ||                          // Server error
    55→        err.status === 502 ||                          // Bad gateway
    56→        err.status === 503 ||                          // Service unavailable
    57→        err.code === 'ECONNRESET' ||                   // Connection reset
    58→        err.code === 'ETIMEDOUT' ||                    // Timeout
    59→        err.message?.includes('Connection error') ||   // Connection error
    60→        err.message?.includes('network');              // Network error
    61→
    62→      if (!isRetryable) {
    63→        throw err;
    64→      }
    65→
    66→      console.log(`[SPLICE] Retry ${attempt + 1}/${retries} after ${Math.round(delay)}ms: ${err.message}`);
    67→      await new Promise(resolve => setTimeout(resolve, delay));
    68→    }
    69→  }
    70→
    71→  throw lastError;
    72→}
    73→
    74→/**
    75→ * LRU cache set with size limit
    76→ * Evicts oldest entries when cache exceeds MAX_CACHE_SIZE
    77→ * @param {string} key - Cache key
    78→ * @param {any} value - Value to cache
    79→ */
    80→function cacheSet(key, value) {
    81→  // Evict oldest entries if at capacity
    82→  while (transcriptCache.size >= MAX_CACHE_SIZE) {
    83→    const oldestKey = transcriptCache.keys().next().value;
    84→    transcriptCache.delete(oldestKey);
    85→    console.log(`[SPLICE] Cache eviction: removed ${oldestKey}`);
    86→  }
    87→
    88→  transcriptCache.set(key, value);
    89→}
    90→
    91→/**
    92→ * Transcribe audio file using GPT-4o-mini-transcribe (with caching)
    93→ * @param {string} wavPath - Path to the WAV file