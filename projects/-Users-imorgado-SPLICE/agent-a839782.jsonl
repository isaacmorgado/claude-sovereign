{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","type":"user","message":{"role":"user","content":"Analyze music credit deduction for race conditions with MEDIUM thoroughness:\n\n1. Check splice-backend/services/usageTracking.js lines 1000-1100 specifically\n2. Look for how music credits are deducted - is there SELECT...FOR UPDATE or atomic transaction?\n3. Search for any transaction handling in the credit deduction flow\n\nReport:\n- Current credit deduction implementation\n- Is it atomic/race-condition safe?\n- What specific changes are needed for SELECT...FOR UPDATE?"},"uuid":"45750bdf-070f-4750-b11b-54a6789c7e68","timestamp":"2025-12-30T00:26:10.074Z"}
{"parentUuid":"45750bdf-070f-4750-b11b-54a6789c7e68","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013i2RUoHypns5CVFK2zq8LZ","type":"message","role":"assistant","content":[{"type":"text","text":"I'll analyze the music credit deduction for race conditions with medium thoroughness. Let me start by examining the usage tracking service and searching for relevant implementation details."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":18600,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":18600,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvS4kraUcoZVJ3J6ad1","type":"assistant","uuid":"69b2f3df-832c-48a9-9f64-6301e3c7013e","timestamp":"2025-12-30T00:26:11.783Z"}
{"parentUuid":"69b2f3df-832c-48a9-9f64-6301e3c7013e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013i2RUoHypns5CVFK2zq8LZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HPUw1ds1SmKCge6RSYaMw2","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":18600,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":18600,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvS4kraUcoZVJ3J6ad1","type":"assistant","uuid":"c97ec574-97af-45cb-a08e-c6f61f1451f1","timestamp":"2025-12-30T00:26:12.104Z"}
{"parentUuid":"c97ec574-97af-45cb-a08e-c6f61f1451f1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013i2RUoHypns5CVFK2zq8LZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VCi8EZ3UQnkRWLkNaMPeHq","name":"Grep","input":{"pattern":"deduct|credit|transaction|UPDATE|SELECT.*FOR","path":"/Users/imorgado/SPLICE/splice-backend/services","type":"js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":18600,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":18600,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvS4kraUcoZVJ3J6ad1","type":"assistant","uuid":"475e9c27-65a4-469d-a367-1b6557b7e12b","timestamp":"2025-12-30T00:26:12.603Z"}
{"parentUuid":"475e9c27-65a4-469d-a367-1b6557b7e12b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VCi8EZ3UQnkRWLkNaMPeHq","type":"tool_result","content":"Found 6 files\nsplice-backend/services/referralService.js\nsplice-backend/services/licenseService.js\nsplice-backend/services/usageTracking.js\nsplice-backend/services/emailService.js\nsplice-backend/services/stripeUsageReporting.js\nsplice-backend/services/repetitionDetection.js"}]},"uuid":"d88ca7fb-e8b8-40c4-9bc0-513a9acbd4e8","timestamp":"2025-12-30T00:26:12.685Z","toolUseResult":{"mode":"files_with_matches","filenames":["splice-backend/services/referralService.js","splice-backend/services/licenseService.js","splice-backend/services/usageTracking.js","splice-backend/services/emailService.js","splice-backend/services/stripeUsageReporting.js","splice-backend/services/repetitionDetection.js"],"numFiles":6}}
{"parentUuid":"d88ca7fb-e8b8-40c4-9bc0-513a9acbd4e8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HPUw1ds1SmKCge6RSYaMw2","type":"tool_result","content":"     1→/**\n     2→ * Usage Tracking Service\n     3→ *\n     4→ * Tracks user credit balances and usage for billing.\n     5→ * Uses PostgreSQL for persistence.\n     6→ */\n     7→\n     8→const { Pool } = require('pg');\n     9→const { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n    10→\n    11→// PostgreSQL connection pool with proper limits\n    12→// SSL Configuration:\n    13→// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n    14→// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n    15→// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\n    16→const sslConfig = process.env.NODE_ENV === 'production' ? {\n    17→  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n    18→  ca: process.env.DATABASE_SSL_CA || undefined\n    19→} : false;\n    20→\n    21→const pool = new Pool({\n    22→  connectionString: process.env.DATABASE_URL,\n    23→  ssl: sslConfig,\n    24→  // PERFORMANCE: Set connection pool limits\n    25→  max: 20,                    // Maximum number of clients in the pool\n    26→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n    27→  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n    28→});\n    29→\n    30→// Hours per tier (regular processing)\n    31→// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n    32→// Target margins: 79-82%\n    33→const TIER_HOURS = {\n    34→  starter: 4,    // 4 hrs/month\n    35→  pro: 15,       // 15 hrs/month\n    36→  team: 50,      // 50 hrs/month\n    37→  cancelled: 0\n    38→};\n    39→\n    40→// Overage rate for processing hours beyond included\n    41→const HOURS_OVERAGE_RATE = 2.00; // $2/hour\n    42→\n    43→// Isolation minutes per tier (sized to maintain 80% margins)\n    44→const TIER_ISOLATION_MINUTES = {\n    45→  starter: 0,     // No isolation access\n    46→  pro: 45,        // 45 minutes included\n    47→  team: 180,      // 3 hours included\n    48→  cancelled: 0\n    49→};\n    50→\n    51→// Convert to hours for database storage\n    52→const TIER_ISOLATION_HOURS = {\n    53→  starter: 0,\n    54→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n    55→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n    56→  cancelled: 0\n    57→};\n    58→\n    59→// Overage rate for isolation beyond included minutes\n    60→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n    61→\n    62→/**\n    63→ * Initialize database tables\n    64→ */\n    65→async function initDatabase() {\n    66→  const client = await pool.connect();\n    67→  try {\n    68→    await client.query(`\n    69→      CREATE TABLE IF NOT EXISTS users (\n    70→        id SERIAL PRIMARY KEY,\n    71→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n    72→        email VARCHAR(255),\n    73→        tier VARCHAR(50) DEFAULT 'starter',\n    74→        hours_remaining DECIMAL(10,4) DEFAULT 15,\n    75→        hours_total DECIMAL(10,4) DEFAULT 15,\n    76→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n    77→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n    78→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    79→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    80→      )\n    81→    `);\n    82→\n    83→    // Add isolation columns if they don't exist (for existing databases)\n    84→    await client.query(`\n    85→      DO $$\n    86→      BEGIN\n    87→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n    88→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n    89→        END IF;\n    90→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n    91→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n    92→        END IF;\n    93→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n    94→          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n    95→        END IF;\n    96→      END $$;\n    97→    `);\n    98→\n    99→    await client.query(`\n   100→      CREATE TABLE IF NOT EXISTS usage_log (\n   101→        id SERIAL PRIMARY KEY,\n   102→        user_id INTEGER REFERENCES users(id),\n   103→        stripe_customer_id VARCHAR(255),\n   104→        audio_duration_seconds DECIMAL(10,2),\n   105→        hours_used DECIMAL(10,6),\n   106→        endpoint VARCHAR(100),\n   107→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   108→      )\n   109→    `);\n   110→\n   111→    await client.query(`\n   112→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n   113→    `);\n   114→\n   115→    await client.query(`\n   116→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n   117→    `);\n   118→\n   119→    // PERFORMANCE: Add composite index for efficient customer usage history queries\n   120→    await client.query(`\n   121→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n   122→      ON usage_log(stripe_customer_id, created_at DESC)\n   123→    `);\n   124→\n   125→    // Webhook events table for idempotency\n   126→    await client.query(`\n   127→      CREATE TABLE IF NOT EXISTS webhook_events (\n   128→        id SERIAL PRIMARY KEY,\n   129→        event_id VARCHAR(255) UNIQUE NOT NULL,\n   130→        event_type VARCHAR(100),\n   131→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   132→      )\n   133→    `);\n   134→\n   135→    await client.query(`\n   136→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n   137→    `);\n   138→\n   139→    console.log('[UsageTracking] Database initialized');\n   140→  } finally {\n   141→    client.release();\n   142→  }\n   143→}\n   144→\n   145→/**\n   146→ * Get or create a user by Stripe customer ID\n   147→ * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n   148→ */\n   149→async function getOrCreateUser(stripeCustomerId, email = null) {\n   150→  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n   151→  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n   152→  const result = await pool.query(\n   153→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   154→     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   155→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   156→     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n   157→     RETURNING *`,\n   158→    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n   159→  );\n   160→\n   161→  return result.rows[0];\n   162→}\n   163→\n   164→/**\n   165→ * Check if a customer exists in the database (without creating)\n   166→ * SECURITY: Used to validate legacy auth attempts\n   167→ */\n   168→async function customerExists(stripeCustomerId) {\n   169→  if (!stripeCustomerId) return false;\n   170→\n   171→  try {\n   172→    const result = await pool.query(\n   173→      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n   174→      [stripeCustomerId]\n   175→    );\n   176→    return result.rows.length > 0;\n   177→  } catch (err) {\n   178→    console.error('[SPLICE] customerExists check failed:', err.message);\n   179→    return false;\n   180→  }\n   181→}\n   182→\n   183→/**\n   184→ * Get user's current credit balance\n   185→ */\n   186→async function getBalance(stripeCustomerId) {\n   187→  const user = await getOrCreateUser(stripeCustomerId);\n   188→  const hoursTotal = parseFloat(user.hours_total);\n   189→  const hoursRemaining = parseFloat(user.hours_remaining);\n   190→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   191→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   192→\n   193→  // Tier display names\n   194→  const tierNames = {\n   195→    starter: 'Starter',\n   196→    pro: 'Pro',\n   197→    team: 'Team',\n   198→    cancelled: 'Cancelled'\n   199→  };\n   200→\n   201→  // Calculate trial days remaining\n   202→  let trialDaysRemaining = null;\n   203→  let isOnTrial = false;\n   204→  if (user.trial_end) {\n   205→    const trialEnd = new Date(user.trial_end);\n   206→    const now = new Date();\n   207→    const diffMs = trialEnd.getTime() - now.getTime();\n   208→    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n   209→    if (diffDays > 0) {\n   210→      trialDaysRemaining = diffDays;\n   211→      isOnTrial = true;\n   212→    }\n   213→  }\n   214→\n   215→  return {\n   216→    hoursRemaining,\n   217→    hoursTotal,\n   218→    isolationHoursRemaining,\n   219→    isolationHoursTotal,\n   220→    tier: user.tier,\n   221→    tierName: tierNames[user.tier] || user.tier,\n   222→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   223→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   224→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   225→    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   226→    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n   227→    trialDaysRemaining,\n   228→    isOnTrial\n   229→  };\n   230→}\n   231→\n   232→/**\n   233→ * Check if user has enough credits for estimated duration\n   234→ */\n   235→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n   236→  const balance = await getBalance(stripeCustomerId);\n   237→  const estimatedHours = estimatedSeconds / 3600;\n   238→  return balance.hoursRemaining >= estimatedHours;\n   239→}\n   240→\n   241→/**\n   242→ * Reserve credits atomically using SELECT ... FOR UPDATE\n   243→ * This prevents race conditions where multiple requests pass credit check\n   244→ * before any deduction occurs.\n   245→ *\n   246→ * @param {string} stripeCustomerId - Customer ID\n   247→ * @param {number} estimatedSeconds - Estimated processing time in seconds\n   248→ * @param {string} endpoint - Endpoint name for tracking\n   249→ * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n   250→ */\n   251→async function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n   252→  const estimatedHours = estimatedSeconds / 3600;\n   253→  const client = await pool.connect();\n   254→\n   255→  try {\n   256→    await client.query('BEGIN');\n   257→\n   258→    // Lock the row for this customer - prevents concurrent modifications\n   259→    const result = await client.query(\n   260→      `SELECT id, hours_remaining FROM users\n   261→       WHERE stripe_customer_id = $1\n   262→       FOR UPDATE`,\n   263→      [stripeCustomerId]\n   264→    );\n   265→\n   266→    if (result.rows.length === 0) {\n   267→      // Create user if doesn't exist (within transaction)\n   268→      const newUser = await client.query(\n   269→        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n   270→         VALUES ($1, 'starter', $2, $2)\n   271→         RETURNING id, hours_remaining`,\n   272→        [stripeCustomerId, TIER_HOURS.starter]\n   273→      );\n   274→      result.rows = newUser.rows;\n   275→    }\n   276→\n   277→    const user = result.rows[0];\n   278→    const hoursRemaining = parseFloat(user.hours_remaining);\n   279→\n   280→    // Check if enough credits\n   281→    if (hoursRemaining < estimatedHours) {\n   282→      await client.query('ROLLBACK');\n   283→      return {\n   284→        success: false,\n   285→        error: 'Insufficient credits',\n   286→        hoursRemaining,\n   287→        hoursRequired: estimatedHours\n   288→      };\n   289→    }\n   290→\n   291→    // Generate unique reservation ID\n   292→    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   293→\n   294→    // Reserve credits by deducting the estimated amount\n   295→    await client.query(\n   296→      `UPDATE users\n   297→       SET hours_remaining = hours_remaining - $1,\n   298→           updated_at = CURRENT_TIMESTAMP\n   299→       WHERE stripe_customer_id = $2`,\n   300→      [estimatedHours, stripeCustomerId]\n   301→    );\n   302→\n   303→    // Log the reservation\n   304→    await client.query(\n   305→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   306→       VALUES ($1, $2, $3, $4, $5)`,\n   307→      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n   308→    );\n   309→\n   310→    await client.query('COMMIT');\n   311→\n   312→    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n   313→\n   314→    return {\n   315→      success: true,\n   316→      reservationId,\n   317→      hoursReserved: estimatedHours,\n   318→      hoursRemaining: hoursRemaining - estimatedHours\n   319→    };\n   320→  } catch (err) {\n   321→    await client.query('ROLLBACK');\n   322→    console.error('[UsageTracking] Reservation error:', err);\n   323→    throw err;\n   324→  } finally {\n   325→    client.release();\n   326→  }\n   327→}\n   328→\n   329→/**\n   330→ * Confirm a reservation (finalize usage) or adjust for actual duration\n   331→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   332→ *\n   333→ * @param {string} stripeCustomerId - Customer ID\n   334→ * @param {number} actualSeconds - Actual processing time in seconds\n   335→ * @param {number} reservedSeconds - Originally reserved seconds\n   336→ * @param {string} endpoint - Endpoint name\n   337→ * @returns {Promise<object>} Updated balance\n   338→ */\n   339→async function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n   340→  const actualHours = actualSeconds / 3600;\n   341→  const reservedHours = reservedSeconds / 3600;\n   342→  const difference = reservedHours - actualHours;\n   343→\n   344→  const client = await pool.connect();\n   345→  try {\n   346→    await client.query('BEGIN');\n   347→\n   348→    // Lock the row and get current state\n   349→    const result = await client.query(\n   350→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   351→       FROM users\n   352→       WHERE stripe_customer_id = $1\n   353→       FOR UPDATE`,\n   354→      [stripeCustomerId]\n   355→    );\n   356→\n   357→    if (result.rows.length === 0) {\n   358→      await client.query('ROLLBACK');\n   359→      throw new Error('User not found');\n   360→    }\n   361→\n   362→    let user = result.rows[0];\n   363→\n   364→    // If actual usage was less than reserved, refund the difference\n   365→    if (difference > 0) {\n   366→      const updateResult = await client.query(\n   367→        `UPDATE users\n   368→         SET hours_remaining = hours_remaining + $1,\n   369→             updated_at = CURRENT_TIMESTAMP\n   370→         WHERE stripe_customer_id = $2\n   371→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   372→        [difference, stripeCustomerId]\n   373→      );\n   374→      user = { ...user, ...updateResult.rows[0] };\n   375→\n   376→      // Log the adjustment\n   377→      await client.query(\n   378→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   379→         VALUES ($1, $2, $3, $4, $5)`,\n   380→        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n   381→      );\n   382→    } else if (difference < 0) {\n   383→      // Actual usage was more than reserved - deduct the extra\n   384→      const updateResult = await client.query(\n   385→        `UPDATE users\n   386→         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   387→             updated_at = CURRENT_TIMESTAMP\n   388→         WHERE stripe_customer_id = $2\n   389→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   390→        [-difference, stripeCustomerId]\n   391→      );\n   392→      user = { ...user, ...updateResult.rows[0] };\n   393→\n   394→      // Log the additional usage\n   395→      await client.query(\n   396→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   397→         VALUES ($1, $2, $3, $4, $5)`,\n   398→        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n   399→      );\n   400→    }\n   401→\n   402→    await client.query('COMMIT');\n   403→\n   404→    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n   405→\n   406→    // Build balance from data we already have (no extra SELECT needed)\n   407→    const hoursTotal = parseFloat(user.hours_total);\n   408→    const hoursRemaining = parseFloat(user.hours_remaining);\n   409→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   410→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   411→\n   412→    const tierNames = {\n   413→      starter: 'Starter',\n   414→      pro: 'Pro',\n   415→      team: 'Team',\n   416→      cancelled: 'Cancelled'\n   417→    };\n   418→\n   419→    return {\n   420→      hoursRemaining,\n   421→      hoursTotal,\n   422→      isolationHoursRemaining,\n   423→      isolationHoursTotal,\n   424→      tier: user.tier,\n   425→      tierName: tierNames[user.tier] || user.tier,\n   426→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   427→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   428→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   429→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   430→    };\n   431→  } catch (err) {\n   432→    await client.query('ROLLBACK');\n   433→    throw err;\n   434→  } finally {\n   435→    client.release();\n   436→  }\n   437→}\n   438→\n   439→/**\n   440→ * Release a reservation (refund credits on processing failure)\n   441→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   442→ *\n   443→ * @param {string} stripeCustomerId - Customer ID\n   444→ * @param {number} reservedSeconds - Originally reserved seconds\n   445→ * @param {string} endpoint - Endpoint name\n   446→ * @param {string} reason - Reason for release\n   447→ * @returns {Promise<object>} Updated balance\n   448→ */\n   449→async function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n   450→  const reservedHours = reservedSeconds / 3600;\n   451→\n   452→  const client = await pool.connect();\n   453→  try {\n   454→    await client.query('BEGIN');\n   455→\n   456→    // Lock the row and get id for logging\n   457→    const result = await client.query(\n   458→      `SELECT id FROM users\n   459→       WHERE stripe_customer_id = $1\n   460→       FOR UPDATE`,\n   461→      [stripeCustomerId]\n   462→    );\n   463→\n   464→    if (result.rows.length === 0) {\n   465→      await client.query('ROLLBACK');\n   466→      throw new Error('User not found');\n   467→    }\n   468→\n   469→    const userId = result.rows[0].id;\n   470→\n   471→    // Refund the reserved amount with RETURNING\n   472→    const updateResult = await client.query(\n   473→      `UPDATE users\n   474→       SET hours_remaining = hours_remaining + $1,\n   475→           updated_at = CURRENT_TIMESTAMP\n   476→       WHERE stripe_customer_id = $2\n   477→       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   478→      [reservedHours, stripeCustomerId]\n   479→    );\n   480→\n   481→    const user = updateResult.rows[0];\n   482→\n   483→    // Log the refund\n   484→    await client.query(\n   485→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   486→       VALUES ($1, $2, $3, $4, $5)`,\n   487→      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n   488→    );\n   489→\n   490→    await client.query('COMMIT');\n   491→\n   492→    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n   493→\n   494→    // Build balance from RETURNING data (no extra SELECT needed)\n   495→    const hoursTotal = parseFloat(user.hours_total);\n   496→    const hoursRemaining = parseFloat(user.hours_remaining);\n   497→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   498→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   499→\n   500→    const tierNames = {\n   501→      starter: 'Starter',\n   502→      pro: 'Pro',\n   503→      team: 'Team',\n   504→      cancelled: 'Cancelled'\n   505→    };\n   506→\n   507→    return {\n   508→      hoursRemaining,\n   509→      hoursTotal,\n   510→      isolationHoursRemaining,\n   511→      isolationHoursTotal,\n   512→      tier: user.tier,\n   513→      tierName: tierNames[user.tier] || user.tier,\n   514→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   515→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   516→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   517→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   518→    };\n   519→  } catch (err) {\n   520→    await client.query('ROLLBACK');\n   521→    throw err;\n   522→  } finally {\n   523→    client.release();\n   524→  }\n   525→}\n   526→\n   527→/**\n   528→ * Check if user can use vocal isolation\n   529→ * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n   530→ */\n   531→async function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n   532→  const balance = await getBalance(stripeCustomerId);\n   533→\n   534→  // Starter tier has no isolation access\n   535→  if (!balance.hasIsolationAccess) {\n   536→    return {\n   537→      allowed: false,\n   538→      reason: 'upgrade_required',\n   539→      message: 'Vocal isolation requires Pro or Team tier',\n   540→      hasIncludedHours: false,\n   541→      overageRequired: false,\n   542→      overageCost: 0\n   543→    };\n   544→  }\n   545→\n   546→  const estimatedHours = estimatedMinutes / 60;\n   547→  const remainingIncluded = balance.isolationHoursRemaining;\n   548→\n   549→  // Check if within included hours\n   550→  if (remainingIncluded >= estimatedHours) {\n   551→    return {\n   552→      allowed: true,\n   553→      reason: 'included',\n   554→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   555→      hasIncludedHours: true,\n   556→      overageRequired: false,\n   557→      overageCost: 0,\n   558→      isolationHoursRemaining: remainingIncluded - estimatedHours\n   559→    };\n   560→  }\n   561→\n   562→  // Calculate overage\n   563→  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n   564→  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   565→\n   566→  return {\n   567→    allowed: true,\n   568→    reason: 'overage',\n   569→    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n   570→    hasIncludedHours: remainingIncluded > 0,\n   571→    overageRequired: true,\n   572→    overageMinutes,\n   573→    overageCost,\n   574→    isolationHoursRemaining: 0\n   575→  };\n   576→}\n   577→\n   578→/**\n   579→ * Deduct isolation usage from user's balance\n   580→ * Returns overage cost if beyond included hours\n   581→ * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n   582→ */\n   583→async function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n   584→  const durationMinutes = audioDurationSeconds / 60;\n   585→  const durationHours = audioDurationSeconds / 3600;\n   586→\n   587→  const client = await pool.connect();\n   588→  try {\n   589→    await client.query('BEGIN');\n   590→\n   591→    // Lock the row for this customer - prevents concurrent modifications\n   592→    const userResult = await client.query(\n   593→      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n   594→       FROM users WHERE stripe_customer_id = $1\n   595→       FOR UPDATE`,\n   596→      [stripeCustomerId]\n   597→    );\n   598→\n   599→    if (userResult.rows.length === 0) {\n   600→      await client.query('ROLLBACK');\n   601→      throw new Error('User not found');\n   602→    }\n   603→\n   604→    const user = userResult.rows[0];\n   605→    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n   606→\n   607→    let overageCost = 0;\n   608→    let hoursFromIncluded = 0;\n   609→    let overageMinutes = 0;\n   610→\n   611→    if (remainingIncluded >= durationHours) {\n   612→      // Fully covered by included hours\n   613→      hoursFromIncluded = durationHours;\n   614→    } else {\n   615→      // Partial or full overage\n   616→      hoursFromIncluded = remainingIncluded;\n   617→      overageMinutes = durationMinutes - (remainingIncluded * 60);\n   618→      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   619→    }\n   620→\n   621→    // Update isolation balance with RETURNING to get new values\n   622→    const updateResult = await client.query(\n   623→      `UPDATE users\n   624→       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n   625→           updated_at = CURRENT_TIMESTAMP\n   626→       WHERE stripe_customer_id = $2\n   627→       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n   628→      [durationHours, stripeCustomerId]\n   629→    );\n   630→\n   631→    const updatedUser = updateResult.rows[0];\n   632→\n   633→    // Log usage (mark as isolation)\n   634→    await client.query(\n   635→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   636→       VALUES ($1, $2, $3, $4, $5)`,\n   637→      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n   638→    );\n   639→\n   640→    await client.query('COMMIT');\n   641→\n   642→    // Build balance from RETURNING data (no extra SELECT needed)\n   643→    const hoursTotal = parseFloat(updatedUser.hours_total);\n   644→    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n   645→    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n   646→    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n   647→\n   648→    const tierNames = {\n   649→      starter: 'Starter',\n   650→      pro: 'Pro',\n   651→      team: 'Team',\n   652→      cancelled: 'Cancelled'\n   653→    };\n   654→\n   655→    return {\n   656→      hoursRemaining,\n   657→      hoursTotal,\n   658→      isolationHoursRemaining,\n   659→      isolationHoursTotal,\n   660→      tier: updatedUser.tier,\n   661→      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n   662→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   663→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   664→      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n   665→      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   666→      isolationUsed: {\n   667→        durationMinutes,\n   668→        hoursFromIncluded,\n   669→        overageMinutes,\n   670→        overageCost\n   671→      }\n   672→    };\n   673→  } catch (err) {\n   674→    await client.query('ROLLBACK');\n   675→    throw err;\n   676→  } finally {\n   677→    client.release();\n   678→  }\n   679→}\n   680→\n   681→/**\n   682→ * Deduct usage from user's balance\n   683→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   684→ * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n   685→ * Reports overage to Stripe for billing when user exceeds included hours\n   686→ */\n   687→async function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n   688→  const hoursUsed = audioDurationSeconds / 3600;\n   689→\n   690→  const client = await pool.connect();\n   691→  try {\n   692→    await client.query('BEGIN');\n   693→\n   694→    // First get current balance to calculate overage\n   695→    const currentResult = await client.query(\n   696→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   697→       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n   698→      [stripeCustomerId]\n   699→    );\n   700→\n   701→    if (currentResult.rows.length === 0) {\n   702→      await client.query('ROLLBACK');\n   703→      throw new Error('User not found');\n   704→    }\n   705→\n   706→    const currentUser = currentResult.rows[0];\n   707→    const currentRemaining = parseFloat(currentUser.hours_remaining);\n   708→\n   709→    // Calculate overage (hours used beyond what's remaining)\n   710→    let overageHours = 0;\n   711→    if (hoursUsed > currentRemaining) {\n   712→      overageHours = hoursUsed - currentRemaining;\n   713→    }\n   714→\n   715→    // Update balance (clamp at 0)\n   716→    const updateResult = await client.query(\n   717→      `UPDATE users\n   718→       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   719→           updated_at = CURRENT_TIMESTAMP\n   720→       WHERE stripe_customer_id = $2\n   721→       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   722→      [hoursUsed, stripeCustomerId]\n   723→    );\n   724→\n   725→    const user = updateResult.rows[0];\n   726→\n   727→    // Log usage\n   728→    await client.query(\n   729→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   730→       VALUES ($1, $2, $3, $4, $5)`,\n   731→      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n   732→    );\n   733→\n   734→    await client.query('COMMIT');\n   735→\n   736→    // Report overage to Stripe if any (after commit to not block transaction)\n   737→    let overageCharge = 0;\n   738→    if (overageHours > 0) {\n   739→      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n   740→      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n   741→      if (usageReport.success) {\n   742→        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n   743→      } else {\n   744→        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n   745→      }\n   746→    }\n   747→\n   748→    // Build balance from RETURNING data (no extra SELECT needed)\n   749→    const hoursTotal = parseFloat(user.hours_total);\n   750→    const hoursRemaining = parseFloat(user.hours_remaining);\n   751→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   752→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   753→\n   754→    const tierNames = {\n   755→      starter: 'Starter',\n   756→      pro: 'Pro',\n   757→      team: 'Team',\n   758→      cancelled: 'Cancelled'\n   759→    };\n   760→\n   761→    return {\n   762→      hoursRemaining,\n   763→      hoursTotal,\n   764→      isolationHoursRemaining,\n   765→      isolationHoursTotal,\n   766→      tier: user.tier,\n   767→      tierName: tierNames[user.tier] || user.tier,\n   768→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   769→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   770→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   771→      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   772→      overageHours,\n   773→      overageCharge\n   774→    };\n   775→  } catch (err) {\n   776→    await client.query('ROLLBACK');\n   777→    throw err;\n   778→  } finally {\n   779→    client.release();\n   780→  }\n   781→}\n   782→\n   783→/**\n   784→ * Reset user's hours for new billing period\n   785→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   786→ */\n   787→async function resetHours(stripeCustomerId, tier) {\n   788→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   789→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   790→\n   791→  const result = await pool.query(\n   792→    `UPDATE users\n   793→     SET hours_remaining = $1, hours_total = $1,\n   794→         isolation_hours_remaining = $2, isolation_hours_total = $2,\n   795→         tier = $3, updated_at = CURRENT_TIMESTAMP\n   796→     WHERE stripe_customer_id = $4\n   797→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   798→    [hours, isolationHours, tier, stripeCustomerId]\n   799→  );\n   800→\n   801→  if (result.rows.length === 0) {\n   802→    // User doesn't exist, create and return default balance\n   803→    return await getBalance(stripeCustomerId);\n   804→  }\n   805→\n   806→  const user = result.rows[0];\n   807→  const hoursTotal = parseFloat(user.hours_total);\n   808→  const hoursRemaining = parseFloat(user.hours_remaining);\n   809→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   810→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   811→\n   812→  const tierNames = {\n   813→    starter: 'Starter',\n   814→    pro: 'Pro',\n   815→    team: 'Team',\n   816→    cancelled: 'Cancelled'\n   817→  };\n   818→\n   819→  return {\n   820→    hoursRemaining,\n   821→    hoursTotal,\n   822→    isolationHoursRemaining,\n   823→    isolationHoursTotal,\n   824→    tier: user.tier,\n   825→    tierName: tierNames[user.tier] || user.tier,\n   826→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   827→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   828→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   829→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   830→  };\n   831→}\n   832→\n   833→/**\n   834→ * Update user's tier (from Stripe webhook)\n   835→ * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n   836→ */\n   837→async function updateTier(stripeCustomerId, tier, email = null) {\n   838→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   839→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   840→\n   841→  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n   842→  const result = await pool.query(\n   843→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   844→     VALUES ($1, $2, $3, $4, $4, $5, $5)\n   845→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   846→     SET tier = $3, hours_remaining = $4, hours_total = $4,\n   847→         isolation_hours_remaining = $5, isolation_hours_total = $5,\n   848→         updated_at = CURRENT_TIMESTAMP\n   849→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   850→    [stripeCustomerId, email, tier, hours, isolationHours]\n   851→  );\n   852→\n   853→  const user = result.rows[0];\n   854→  const hoursTotal = parseFloat(user.hours_total);\n   855→  const hoursRemaining = parseFloat(user.hours_remaining);\n   856→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   857→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   858→\n   859→  const tierNames = {\n   860→    starter: 'Starter',\n   861→    pro: 'Pro',\n   862→    team: 'Team',\n   863→    cancelled: 'Cancelled'\n   864→  };\n   865→\n   866→  return {\n   867→    hoursRemaining,\n   868→    hoursTotal,\n   869→    isolationHoursRemaining,\n   870→    isolationHoursTotal,\n   871→    tier: user.tier,\n   872→    tierName: tierNames[user.tier] || user.tier,\n   873→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   874→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   875→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   876→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   877→  };\n   878→}\n   879→\n   880→/**\n   881→ * Get usage history for a user\n   882→ */\n   883→async function getUsageHistory(stripeCustomerId, limit = 50) {\n   884→  const result = await pool.query(\n   885→    `SELECT * FROM usage_log\n   886→     WHERE stripe_customer_id = $1\n   887→     ORDER BY created_at DESC\n   888→     LIMIT $2`,\n   889→    [stripeCustomerId, limit]\n   890→  );\n   891→  return result.rows;\n   892→}\n   893→\n   894→/**\n   895→ * Check if webhook event has already been processed (idempotency)\n   896→ */\n   897→async function isEventProcessed(eventId) {\n   898→  const result = await pool.query(\n   899→    'SELECT id FROM webhook_events WHERE event_id = $1',\n   900→    [eventId]\n   901→  );\n   902→  return result.rows.length > 0;\n   903→}\n   904→\n   905→/**\n   906→ * Record a processed webhook event\n   907→ */\n   908→async function recordWebhookEvent(eventId, eventType) {\n   909→  try {\n   910→    await pool.query(\n   911→      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n   912→      [eventId, eventType]\n   913→    );\n   914→  } catch (err) {\n   915→    // Ignore duplicate key errors (race condition safety)\n   916→    if (err.code !== '23505') throw err;\n   917→  }\n   918→}\n   919→\n   920→// =============================================================================\n   921→// Music Credits Functions (Phase 4 - AI Music Feature)\n   922→// =============================================================================\n   923→\n   924→// Music credits per tier\n   925→// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n   926→const TIER_MUSIC_CREDITS = {\n   927→  starter: 2,    // 2 songs/month\n   928→  pro: 10,       // 10 songs/month\n   929→  team: 50,      // 50 songs/month\n   930→  cancelled: 0\n   931→};\n   932→\n   933→// Feature access by tier - defines which features each tier can use\n   934→const TIER_FEATURES = {\n   935→  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n   936→  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n   937→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n   938→    'profanity_detection', 'chapter_detection'],\n   939→  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n   940→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n   941→    'profanity_detection', 'chapter_detection', 'multitrack',\n   942→    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n   943→  cancelled: []\n   944→};\n   945→\n   946→/**\n   947→ * Check if a tier has access to a specific feature\n   948→ * @param {string} tier - User's tier (starter, pro, team)\n   949→ * @param {string} feature - Feature name to check\n   950→ * @returns {boolean}\n   951→ */\n   952→function hasFeatureAccess(tier, feature) {\n   953→  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n   954→  return tierFeatures.includes(feature);\n   955→}\n   956→\n   957→// Flat overage rate for music (simplified pricing)\n   958→const MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n   959→\n   960→// Legacy overage rates (kept for backwards compatibility)\n   961→const MUSIC_OVERAGE_RATES = {\n   962→  starter: 1.00,  // $1.00/song\n   963→  pro: 1.00,      // $1.00/song\n   964→  team: 1.00      // $1.00/song\n   965→};\n   966→\n   967→/**\n   968→ * Get music credits balance for a customer\n   969→ * @param {string} stripeCustomerId - Stripe customer ID\n   970→ * @returns {Promise<{remaining: number, total: number, tier: string}>}\n   971→ */\n   972→async function getMusicCredits(stripeCustomerId) {\n   973→  const result = await pool.query(\n   974→    `SELECT music_credits_remaining, music_credits_total, tier\n   975→     FROM users\n   976→     WHERE stripe_customer_id = $1`,\n   977→    [stripeCustomerId]\n   978→  );\n   979→\n   980→  if (result.rows.length === 0) {\n   981→    return { remaining: 0, total: 0, tier: 'starter' };\n   982→  }\n   983→\n   984→  const row = result.rows[0];\n   985→  return {\n   986→    remaining: row.music_credits_remaining || 0,\n   987→    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n   988→    tier: row.tier || 'starter'\n   989→  };\n   990→}\n   991→\n   992→/**\n   993→ * Check if customer has music credits available\n   994→ * @param {string} stripeCustomerId - Stripe customer ID\n   995→ * @returns {Promise<boolean>}\n   996→ */\n   997→async function hasMusicCredits(stripeCustomerId) {\n   998→  const credits = await getMusicCredits(stripeCustomerId);\n   999→  return credits.remaining > 0;\n  1000→}\n  1001→\n  1002→/**\n  1003→ * Deduct one music credit from customer\n  1004→ * @param {string} stripeCustomerId - Stripe customer ID\n  1005→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1006→ */\n  1007→async function deductMusicCredit(stripeCustomerId) {\n  1008→  const client = await pool.connect();\n  1009→  try {\n  1010→    await client.query('BEGIN');\n  1011→\n  1012→    // Lock row for update\n  1013→    const result = await client.query(\n  1014→      `SELECT music_credits_remaining, tier\n  1015→       FROM users\n  1016→       WHERE stripe_customer_id = $1\n  1017→       FOR UPDATE`,\n  1018→      [stripeCustomerId]\n  1019→    );\n  1020→\n  1021→    if (result.rows.length === 0) {\n  1022→      await client.query('ROLLBACK');\n  1023→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1024→    }\n  1025→\n  1026→    const { music_credits_remaining } = result.rows[0];\n  1027→    let charged = 0;\n  1028→\n  1029→    if (music_credits_remaining > 0) {\n  1030→      // Deduct from included credits\n  1031→      await client.query(\n  1032→        `UPDATE users\n  1033→         SET music_credits_remaining = music_credits_remaining - 1,\n  1034→             updated_at = CURRENT_TIMESTAMP\n  1035→         WHERE stripe_customer_id = $1`,\n  1036→        [stripeCustomerId]\n  1037→      );\n  1038→    } else {\n  1039→      // Overage - charge flat rate ($1/song)\n  1040→      charged = MUSIC_OVERAGE_RATE;\n  1041→\n  1042→      // Report overage to Stripe meter for billing\n  1043→      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n  1044→      if (usageReport.success) {\n  1045→        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n  1046→      } else {\n  1047→        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n  1048→      }\n  1049→    }\n  1050→\n  1051→    // Log the usage\n  1052→    await client.query(\n  1053→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1054→       VALUES ($1, 1, $2)\n  1055→       ON CONFLICT DO NOTHING`,\n  1056→      [stripeCustomerId, charged]\n  1057→    );\n  1058→\n  1059→    await client.query('COMMIT');\n  1060→\n  1061→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1062→    return {\n  1063→      success: true,\n  1064→      remaining: newCredits.remaining,\n  1065→      charged\n  1066→    };\n  1067→\n  1068→  } catch (err) {\n  1069→    await client.query('ROLLBACK');\n  1070→    console.error('[SPLICE] Music credit deduction error:', err.message);\n  1071→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1072→  } finally {\n  1073→    client.release();\n  1074→  }\n  1075→}\n  1076→\n  1077→/**\n  1078→ * Reset music credits based on tier (called on subscription renewal)\n  1079→ * @param {string} stripeCustomerId - Stripe customer ID\n  1080→ * @param {string} tier - Subscription tier\n  1081→ */\n  1082→async function resetMusicCredits(stripeCustomerId, tier) {\n  1083→  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  1084→\n  1085→  await pool.query(\n  1086→    `UPDATE users\n  1087→     SET music_credits_remaining = $2,\n  1088→         music_credits_total = $2,\n  1089→         music_credits_reset_at = CURRENT_TIMESTAMP,\n  1090→         updated_at = CURRENT_TIMESTAMP\n  1091→     WHERE stripe_customer_id = $1`,\n  1092→    [stripeCustomerId, credits]\n  1093→  );\n  1094→}\n  1095→\n  1096→/**\n  1097→ * Add music credits (for promotional or overage purchases)\n  1098→ * @param {string} stripeCustomerId - Stripe customer ID\n  1099→ * @param {number} credits - Number of credits to add\n  1100→ * @returns {Promise<{success: boolean, newBalance: number}>}\n  1101→ */\n  1102→async function addMusicCredits(stripeCustomerId, credits) {\n  1103→  const result = await pool.query(\n  1104→    `UPDATE users\n  1105→     SET music_credits_remaining = music_credits_remaining + $2,\n  1106→         updated_at = CURRENT_TIMESTAMP\n  1107→     WHERE stripe_customer_id = $1\n  1108→     RETURNING music_credits_remaining`,\n  1109→    [stripeCustomerId, credits]\n  1110→  );\n  1111→\n  1112→  if (result.rows.length === 0) {\n  1113→    return { success: false, newBalance: 0 };\n  1114→  }\n  1115→\n  1116→  return {\n  1117→    success: true,\n  1118→    newBalance: result.rows[0].music_credits_remaining\n  1119→  };\n  1120→}\n  1121→\n  1122→/**\n  1123→ * Get music usage history for a customer\n  1124→ * @param {string} stripeCustomerId - Stripe customer ID\n  1125→ * @param {number} limit - Max records to return\n  1126→ * @returns {Promise<Object[]>}\n  1127→ */\n  1128→async function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  1129→  const result = await pool.query(\n  1130→    `SELECT * FROM music_usage_log\n  1131→     WHERE stripe_customer_id = $1\n  1132→     ORDER BY created_at DESC\n  1133→     LIMIT $2`,\n  1134→    [stripeCustomerId, limit]\n  1135→  );\n  1136→  return result.rows;\n  1137→}\n  1138→\n  1139→/**\n  1140→ * Initialize music credits columns (migration helper)\n  1141→ */\n  1142→async function initMusicCreditsColumns() {\n  1143→  const client = await pool.connect();\n  1144→  try {\n  1145→    // Add music credits columns if they don't exist\n  1146→    await client.query(`\n  1147→      DO $$\n  1148→      BEGIN\n  1149→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n  1150→          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n  1151→        END IF;\n  1152→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n  1153→          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n  1154→        END IF;\n  1155→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n  1156→          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n  1157→        END IF;\n  1158→      END $$;\n  1159→    `);\n  1160→\n  1161→    // Create music usage log table\n  1162→    await client.query(`\n  1163→      CREATE TABLE IF NOT EXISTS music_usage_log (\n  1164→        id SERIAL PRIMARY KEY,\n  1165→        stripe_customer_id VARCHAR(255) NOT NULL,\n  1166→        credits_used INTEGER DEFAULT 1,\n  1167→        overage_charged DECIMAL(10,2) DEFAULT 0,\n  1168→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n  1169→      )\n  1170→    `);\n  1171→\n  1172→    await client.query(`\n  1173→      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n  1174→      ON music_usage_log(stripe_customer_id)\n  1175→    `);\n  1176→\n  1177→    console.log('[SPLICE] Music credits columns initialized');\n  1178→  } finally {\n  1179→    client.release();\n  1180→  }\n  1181→}\n  1182→\n  1183→// Variations credits cost (equivalent to 2.5 music credits)\n  1184→const VARIATIONS_CREDIT_COST = 2.5;\n  1185→\n  1186→// Overage rates for variations (higher than single music due to 3 parallel generations)\n  1187→const VARIATIONS_OVERAGE_RATES = {\n  1188→  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  1189→  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  1190→  team: 0.50      // $0.50/variations (2.5x $0.20)\n  1191→};\n  1192→\n  1193→// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\n  1194→const SCENE_AWARE_CREDIT_COST = 1.5;\n  1195→\n  1196→// Overage rates for scene-aware music (75% margin)\n  1197→const SCENE_AWARE_OVERAGE_RATES = {\n  1198→  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  1199→  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  1200→  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n  1201→};\n  1202→\n  1203→/**\n  1204→ * Check if customer has enough credits for variations (2.5 credits)\n  1205→ * @param {string} stripeCustomerId - Stripe customer ID\n  1206→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1207→ */\n  1208→async function checkVariationsCredits(stripeCustomerId) {\n  1209→  const credits = await getMusicCredits(stripeCustomerId);\n  1210→  const creditsRequired = VARIATIONS_CREDIT_COST;\n  1211→\n  1212→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1213→  // Or if they're on a paid tier (overage allowed)\n  1214→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1215→\n  1216→  return {\n  1217→    canGenerate,\n  1218→    creditsAvailable: credits.remaining,\n  1219→    creditsRequired,\n  1220→    tier: credits.tier\n  1221→  };\n  1222→}\n  1223→\n  1224→/**\n  1225→ * Deduct variations credit from customer (2.5 credits worth)\n  1226→ * @param {string} stripeCustomerId - Stripe customer ID\n  1227→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1228→ */\n  1229→async function deductVariationsCredit(stripeCustomerId) {\n  1230→  const client = await pool.connect();\n  1231→  try {\n  1232→    await client.query('BEGIN');\n  1233→\n  1234→    // Lock row for update\n  1235→    const result = await client.query(\n  1236→      `SELECT music_credits_remaining, tier\n  1237→       FROM users\n  1238→       WHERE stripe_customer_id = $1\n  1239→       FOR UPDATE`,\n  1240→      [stripeCustomerId]\n  1241→    );\n  1242→\n  1243→    if (result.rows.length === 0) {\n  1244→      await client.query('ROLLBACK');\n  1245→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1246→    }\n  1247→\n  1248→    const { music_credits_remaining, tier } = result.rows[0];\n  1249→    let charged = 0;\n  1250→    let creditsDeducted = 0;\n  1251→\n  1252→    // Determine how many credits to deduct vs overage to charge\n  1253→    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n  1254→      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n  1255→      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n  1256→      await client.query(\n  1257→        `UPDATE users\n  1258→         SET music_credits_remaining = music_credits_remaining - $2,\n  1259→             updated_at = CURRENT_TIMESTAMP\n  1260→         WHERE stripe_customer_id = $1`,\n  1261→        [stripeCustomerId, creditsDeducted]\n  1262→      );\n  1263→    } else if (music_credits_remaining > 0) {\n  1264→      // Partial credits - deduct what they have and charge overage for the rest\n  1265→      const creditsPortion = music_credits_remaining;\n  1266→      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n  1267→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1268→      charged = overagePortion * overageRate;\n  1269→\n  1270→      creditsDeducted = creditsPortion;\n  1271→      await client.query(\n  1272→        `UPDATE users\n  1273→         SET music_credits_remaining = 0,\n  1274→             updated_at = CURRENT_TIMESTAMP\n  1275→         WHERE stripe_customer_id = $1`,\n  1276→        [stripeCustomerId]\n  1277→      );\n  1278→\n  1279→      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1280→    } else {\n  1281→      // No credits - full overage\n  1282→      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n  1283→      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1284→    }\n  1285→\n  1286→    // Log the usage\n  1287→    await client.query(\n  1288→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1289→       VALUES ($1, $2, $3)\n  1290→       ON CONFLICT DO NOTHING`,\n  1291→      [stripeCustomerId, creditsDeducted, charged]\n  1292→    );\n  1293→\n  1294→    await client.query('COMMIT');\n  1295→\n  1296→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1297→    return {\n  1298→      success: true,\n  1299→      remaining: newCredits.remaining,\n  1300→      creditsDeducted,\n  1301→      charged\n  1302→    };\n  1303→\n  1304→  } catch (err) {\n  1305→    await client.query('ROLLBACK');\n  1306→    console.error('[SPLICE] Variations credit deduction error:', err.message);\n  1307→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1308→  } finally {\n  1309→    client.release();\n  1310→  }\n  1311→}\n  1312→\n  1313→/**\n  1314→ * Check if customer has enough credits for scene-aware music (1.5 credits)\n  1315→ * @param {string} stripeCustomerId - Stripe customer ID\n  1316→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1317→ */\n  1318→async function checkSceneAwareCredits(stripeCustomerId) {\n  1319→  const credits = await getMusicCredits(stripeCustomerId);\n  1320→  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n  1321→\n  1322→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1323→  // Or if they're on a paid tier (overage allowed)\n  1324→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1325→\n  1326→  return {\n  1327→    canGenerate,\n  1328→    creditsAvailable: credits.remaining,\n  1329→    creditsRequired,\n  1330→    tier: credits.tier\n  1331→  };\n  1332→}\n  1333→\n  1334→/**\n  1335→ * Deduct scene-aware music credit from customer (1.5 credits worth)\n  1336→ * @param {string} stripeCustomerId - Stripe customer ID\n  1337→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1338→ */\n  1339→async function deductSceneAwareCredit(stripeCustomerId) {\n  1340→  const client = await pool.connect();\n  1341→  try {\n  1342→    await client.query('BEGIN');\n  1343→\n  1344→    // Lock row for update\n  1345→    const result = await client.query(\n  1346→      `SELECT music_credits_remaining, tier\n  1347→       FROM users\n  1348→       WHERE stripe_customer_id = $1\n  1349→       FOR UPDATE`,\n  1350→      [stripeCustomerId]\n  1351→    );\n  1352→\n  1353→    if (result.rows.length === 0) {\n  1354→      await client.query('ROLLBACK');\n  1355→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1356→    }\n  1357→\n  1358→    const { music_credits_remaining, tier } = result.rows[0];\n  1359→    let charged = 0;\n  1360→    let creditsDeducted = 0;\n  1361→\n  1362→    // Determine how many credits to deduct vs overage to charge\n  1363→    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n  1364→      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n  1365→      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n  1366→      await client.query(\n  1367→        `UPDATE users\n  1368→         SET music_credits_remaining = music_credits_remaining - $2,\n  1369→             updated_at = CURRENT_TIMESTAMP\n  1370→         WHERE stripe_customer_id = $1`,\n  1371→        [stripeCustomerId, creditsDeducted]\n  1372→      );\n  1373→    } else if (music_credits_remaining > 0) {\n  1374→      // Partial credits - deduct what they have and charge overage for the rest\n  1375→      const creditsPortion = music_credits_remaining;\n  1376→      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n  1377→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1378→      charged = overagePortion * overageRate;\n  1379→\n  1380→      creditsDeducted = creditsPortion;\n  1381→      await client.query(\n  1382→        `UPDATE users\n  1383→         SET music_credits_remaining = 0,\n  1384→             updated_at = CURRENT_TIMESTAMP\n  1385→         WHERE stripe_customer_id = $1`,\n  1386→        [stripeCustomerId]\n  1387→      );\n  1388→\n  1389→      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1390→    } else {\n  1391→      // No credits - full overage\n  1392→      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n  1393→      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1394→    }\n  1395→\n  1396→    // Log the usage\n  1397→    await client.query(\n  1398→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1399→       VALUES ($1, $2, $3)\n  1400→       ON CONFLICT DO NOTHING`,\n  1401→      [stripeCustomerId, creditsDeducted, charged]\n  1402→    );\n  1403→\n  1404→    await client.query('COMMIT');\n  1405→\n  1406→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1407→    return {\n  1408→      success: true,\n  1409→      remaining: newCredits.remaining,\n  1410→      creditsDeducted,\n  1411→      charged\n  1412→    };\n  1413→\n  1414→  } catch (err) {\n  1415→    await client.query('ROLLBACK');\n  1416→    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n  1417→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1418→  } finally {\n  1419→    client.release();\n  1420→  }\n  1421→}\n  1422→\n  1423→/**\n  1424→ * Close the database connection pool\n  1425→ * Used for graceful shutdown\n  1426→ */\n  1427→async function closePool() {\n  1428→  await pool.end();\n  1429→}\n  1430→\n  1431→/**\n  1432→ * Update trial end date for a customer\n  1433→ * @param {string} stripeCustomerId - Customer ID\n  1434→ * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n  1435→ */\n  1436→async function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  1437→  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n  1438→\n  1439→  await pool.query(\n  1440→    `UPDATE users\n  1441→     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n  1442→     WHERE stripe_customer_id = $1`,\n  1443→    [stripeCustomerId, trialEnd]\n  1444→  );\n  1445→\n  1446→  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n  1447→}\n  1448→\n  1449→/**\n  1450→ * Check database connectivity\n  1451→ * Used for health checks\n  1452→ */\n  1453→async function checkDatabase() {\n  1454→  const client = await pool.connect();\n  1455→  try {\n  1456→    const result = await client.query('SELECT 1 as health');\n  1457→    return result.rows[0].health === 1;\n  1458→  } finally {\n  1459→    client.release();\n  1460→  }\n  1461→}\n  1462→\n  1463→module.exports = {\n  1464→  initDatabase,\n  1465→  getOrCreateUser,\n  1466→  customerExists,\n  1467→  getBalance,\n  1468→  hasCredits,\n  1469→  reserveCredits,\n  1470→  confirmReservation,\n  1471→  releaseReservation,\n  1472→  checkIsolationAccess,\n  1473→  deductUsage,\n  1474→  deductIsolationUsage,\n  1475→  resetHours,\n  1476→  updateTier,\n  1477→  getUsageHistory,\n  1478→  isEventProcessed,\n  1479→  recordWebhookEvent,\n  1480→  // Music credits functions\n  1481→  getMusicCredits,\n  1482→  hasMusicCredits,\n  1483→  deductMusicCredit,\n  1484→  resetMusicCredits,\n  1485→  addMusicCredits,\n  1486→  getMusicUsageHistory,\n  1487→  initMusicCreditsColumns,\n  1488→  // Variations credits functions\n  1489→  checkVariationsCredits,\n  1490→  deductVariationsCredit,\n  1491→  // Scene-aware credits functions\n  1492→  checkSceneAwareCredits,\n  1493→  deductSceneAwareCredit,\n  1494→  // Pool management\n  1495→  closePool,\n  1496→  checkDatabase,\n  1497→  // Trial management\n  1498→  updateTrialEnd,\n  1499→  // Constants\n  1500→  TIER_HOURS,\n  1501→  TIER_ISOLATION_MINUTES,\n  1502→  TIER_ISOLATION_HOURS,\n  1503→  ISOLATION_OVERAGE_RATE,\n  1504→  HOURS_OVERAGE_RATE,\n  1505→  TIER_MUSIC_CREDITS,\n  1506→  MUSIC_OVERAGE_RATE,\n  1507→  MUSIC_OVERAGE_RATES,\n  1508→  VARIATIONS_CREDIT_COST,\n  1509→  VARIATIONS_OVERAGE_RATES,\n  1510→  SCENE_AWARE_CREDIT_COST,\n  1511→  SCENE_AWARE_OVERAGE_RATES,\n  1512→  // Feature access\n  1513→  TIER_FEATURES,\n  1514→  hasFeatureAccess\n  1515→};\n  1516→\n\n</system-reminder>\n"}]},"uuid":"a075d96a-a5e6-4895-b8f4-560b1cfa2af0","timestamp":"2025-12-30T00:26:12.894Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"/**\n * Usage Tracking Service\n *\n * Tracks user credit balances and usage for billing.\n * Uses PostgreSQL for persistence.\n */\n\nconst { Pool } = require('pg');\nconst { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n\n// PostgreSQL connection pool with proper limits\n// SSL Configuration:\n// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\nconst sslConfig = process.env.NODE_ENV === 'production' ? {\n  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n  ca: process.env.DATABASE_SSL_CA || undefined\n} : false;\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: sslConfig,\n  // PERFORMANCE: Set connection pool limits\n  max: 20,                    // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n});\n\n// Hours per tier (regular processing)\n// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n// Target margins: 79-82%\nconst TIER_HOURS = {\n  starter: 4,    // 4 hrs/month\n  pro: 15,       // 15 hrs/month\n  team: 50,      // 50 hrs/month\n  cancelled: 0\n};\n\n// Overage rate for processing hours beyond included\nconst HOURS_OVERAGE_RATE = 2.00; // $2/hour\n\n// Isolation minutes per tier (sized to maintain 80% margins)\nconst TIER_ISOLATION_MINUTES = {\n  starter: 0,     // No isolation access\n  pro: 45,        // 45 minutes included\n  team: 180,      // 3 hours included\n  cancelled: 0\n};\n\n// Convert to hours for database storage\nconst TIER_ISOLATION_HOURS = {\n  starter: 0,\n  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n  cancelled: 0\n};\n\n// Overage rate for isolation beyond included minutes\nconst ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n\n/**\n * Initialize database tables\n */\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n        email VARCHAR(255),\n        tier VARCHAR(50) DEFAULT 'starter',\n        hours_remaining DECIMAL(10,4) DEFAULT 15,\n        hours_total DECIMAL(10,4) DEFAULT 15,\n        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Add isolation columns if they don't exist (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS usage_log (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        stripe_customer_id VARCHAR(255),\n        audio_duration_seconds DECIMAL(10,2),\n        hours_used DECIMAL(10,6),\n        endpoint VARCHAR(100),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    `);\n\n    // PERFORMANCE: Add composite index for efficient customer usage history queries\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n      ON usage_log(stripe_customer_id, created_at DESC)\n    `);\n\n    // Webhook events table for idempotency\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id SERIAL PRIMARY KEY,\n        event_id VARCHAR(255) UNIQUE NOT NULL,\n        event_type VARCHAR(100),\n        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n    `);\n\n    console.log('[UsageTracking] Database initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get or create a user by Stripe customer ID\n * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n */\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n     RETURNING *`,\n    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n  );\n\n  return result.rows[0];\n}\n\n/**\n * Check if a customer exists in the database (without creating)\n * SECURITY: Used to validate legacy auth attempts\n */\nasync function customerExists(stripeCustomerId) {\n  if (!stripeCustomerId) return false;\n\n  try {\n    const result = await pool.query(\n      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n      [stripeCustomerId]\n    );\n    return result.rows.length > 0;\n  } catch (err) {\n    console.error('[SPLICE] customerExists check failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get user's current credit balance\n */\nasync function getBalance(stripeCustomerId) {\n  const user = await getOrCreateUser(stripeCustomerId);\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  // Tier display names\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  // Calculate trial days remaining\n  let trialDaysRemaining = null;\n  let isOnTrial = false;\n  if (user.trial_end) {\n    const trialEnd = new Date(user.trial_end);\n    const now = new Date();\n    const diffMs = trialEnd.getTime() - now.getTime();\n    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n    if (diffDays > 0) {\n      trialDaysRemaining = diffDays;\n      isOnTrial = true;\n    }\n  }\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n    trialDaysRemaining,\n    isOnTrial\n  };\n}\n\n/**\n * Check if user has enough credits for estimated duration\n */\nasync function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n  const balance = await getBalance(stripeCustomerId);\n  const estimatedHours = estimatedSeconds / 3600;\n  return balance.hoursRemaining >= estimatedHours;\n}\n\n/**\n * Reserve credits atomically using SELECT ... FOR UPDATE\n * This prevents race conditions where multiple requests pass credit check\n * before any deduction occurs.\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} estimatedSeconds - Estimated processing time in seconds\n * @param {string} endpoint - Endpoint name for tracking\n * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n */\nasync function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n  const estimatedHours = estimatedSeconds / 3600;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, hours_remaining FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      // Create user if doesn't exist (within transaction)\n      const newUser = await client.query(\n        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n         VALUES ($1, 'starter', $2, $2)\n         RETURNING id, hours_remaining`,\n        [stripeCustomerId, TIER_HOURS.starter]\n      );\n      result.rows = newUser.rows;\n    }\n\n    const user = result.rows[0];\n    const hoursRemaining = parseFloat(user.hours_remaining);\n\n    // Check if enough credits\n    if (hoursRemaining < estimatedHours) {\n      await client.query('ROLLBACK');\n      return {\n        success: false,\n        error: 'Insufficient credits',\n        hoursRemaining,\n        hoursRequired: estimatedHours\n      };\n    }\n\n    // Generate unique reservation ID\n    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Reserve credits by deducting the estimated amount\n    await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining - $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [estimatedHours, stripeCustomerId]\n    );\n\n    // Log the reservation\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n\n    return {\n      success: true,\n      reservationId,\n      hoursReserved: estimatedHours,\n      hoursRemaining: hoursRemaining - estimatedHours\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[UsageTracking] Reservation error:', err);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Confirm a reservation (finalize usage) or adjust for actual duration\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} actualSeconds - Actual processing time in seconds\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @returns {Promise<object>} Updated balance\n */\nasync function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n  const actualHours = actualSeconds / 3600;\n  const reservedHours = reservedSeconds / 3600;\n  const difference = reservedHours - actualHours;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get current state\n    const result = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    let user = result.rows[0];\n\n    // If actual usage was less than reserved, refund the difference\n    if (difference > 0) {\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = hours_remaining + $1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the adjustment\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n      );\n    } else if (difference < 0) {\n      // Actual usage was more than reserved - deduct the extra\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [-difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the additional usage\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n      );\n    }\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n\n    // Build balance from data we already have (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Release a reservation (refund credits on processing failure)\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @param {string} reason - Reason for release\n * @returns {Promise<object>} Updated balance\n */\nasync function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n  const reservedHours = reservedSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get id for logging\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const userId = result.rows[0].id;\n\n    // Refund the reserved amount with RETURNING\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining + $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [reservedHours, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log the refund\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if user can use vocal isolation\n * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n */\nasync function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n  const balance = await getBalance(stripeCustomerId);\n\n  // Starter tier has no isolation access\n  if (!balance.hasIsolationAccess) {\n    return {\n      allowed: false,\n      reason: 'upgrade_required',\n      message: 'Vocal isolation requires Pro or Team tier',\n      hasIncludedHours: false,\n      overageRequired: false,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remainingIncluded = balance.isolationHoursRemaining;\n\n  // Check if within included hours\n  if (remainingIncluded >= estimatedHours) {\n    return {\n      allowed: true,\n      reason: 'included',\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      hasIncludedHours: true,\n      overageRequired: false,\n      overageCost: 0,\n      isolationHoursRemaining: remainingIncluded - estimatedHours\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n\n  return {\n    allowed: true,\n    reason: 'overage',\n    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n    hasIncludedHours: remainingIncluded > 0,\n    overageRequired: true,\n    overageMinutes,\n    overageCost,\n    isolationHoursRemaining: 0\n  };\n}\n\n/**\n * Deduct isolation usage from user's balance\n * Returns overage cost if beyond included hours\n * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n */\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n  const durationMinutes = audioDurationSeconds / 60;\n  const durationHours = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const userResult = await client.query(\n      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n       FROM users WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n\n    let overageCost = 0;\n    let hoursFromIncluded = 0;\n    let overageMinutes = 0;\n\n    if (remainingIncluded >= durationHours) {\n      // Fully covered by included hours\n      hoursFromIncluded = durationHours;\n    } else {\n      // Partial or full overage\n      hoursFromIncluded = remainingIncluded;\n      overageMinutes = durationMinutes - (remainingIncluded * 60);\n      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n    }\n\n    // Update isolation balance with RETURNING to get new values\n    const updateResult = await client.query(\n      `UPDATE users\n       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n      [durationHours, stripeCustomerId]\n    );\n\n    const updatedUser = updateResult.rows[0];\n\n    // Log usage (mark as isolation)\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(updatedUser.hours_total);\n    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: updatedUser.tier,\n      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      isolationUsed: {\n        durationMinutes,\n        hoursFromIncluded,\n        overageMinutes,\n        overageCost\n      }\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct usage from user's balance\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n * Reports overage to Stripe for billing when user exceeds included hours\n */\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // First get current balance to calculate overage\n    const currentResult = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (currentResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const currentUser = currentResult.rows[0];\n    const currentRemaining = parseFloat(currentUser.hours_remaining);\n\n    // Calculate overage (hours used beyond what's remaining)\n    let overageHours = 0;\n    if (hoursUsed > currentRemaining) {\n      overageHours = hoursUsed - currentRemaining;\n    }\n\n    // Update balance (clamp at 0)\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [hoursUsed, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log usage\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Report overage to Stripe if any (after commit to not block transaction)\n    let overageCharge = 0;\n    if (overageHours > 0) {\n      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n      } else {\n        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      overageHours,\n      overageCharge\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset user's hours for new billing period\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n */\nasync function resetHours(stripeCustomerId, tier) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  const result = await pool.query(\n    `UPDATE users\n     SET hours_remaining = $1, hours_total = $1,\n         isolation_hours_remaining = $2, isolation_hours_total = $2,\n         tier = $3, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $4\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [hours, isolationHours, tier, stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    // User doesn't exist, create and return default balance\n    return await getBalance(stripeCustomerId);\n  }\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Update user's tier (from Stripe webhook)\n * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n */\nasync function updateTier(stripeCustomerId, tier, email = null) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, $3, $4, $4, $5, $5)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET tier = $3, hours_remaining = $4, hours_total = $4,\n         isolation_hours_remaining = $5, isolation_hours_total = $5,\n         updated_at = CURRENT_TIMESTAMP\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [stripeCustomerId, email, tier, hours, isolationHours]\n  );\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Get usage history for a user\n */\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Check if webhook event has already been processed (idempotency)\n */\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n\n/**\n * Record a processed webhook event\n */\nasync function recordWebhookEvent(eventId, eventType) {\n  try {\n    await pool.query(\n      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n      [eventId, eventType]\n    );\n  } catch (err) {\n    // Ignore duplicate key errors (race condition safety)\n    if (err.code !== '23505') throw err;\n  }\n}\n\n// =============================================================================\n// Music Credits Functions (Phase 4 - AI Music Feature)\n// =============================================================================\n\n// Music credits per tier\n// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\nconst TIER_MUSIC_CREDITS = {\n  starter: 2,    // 2 songs/month\n  pro: 10,       // 10 songs/month\n  team: 50,      // 50 songs/month\n  cancelled: 0\n};\n\n// Feature access by tier - defines which features each tier can use\nconst TIER_FEATURES = {\n  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection'],\n  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection', 'multitrack',\n    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n  cancelled: []\n};\n\n/**\n * Check if a tier has access to a specific feature\n * @param {string} tier - User's tier (starter, pro, team)\n * @param {string} feature - Feature name to check\n * @returns {boolean}\n */\nfunction hasFeatureAccess(tier, feature) {\n  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n  return tierFeatures.includes(feature);\n}\n\n// Flat overage rate for music (simplified pricing)\nconst MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n\n// Legacy overage rates (kept for backwards compatibility)\nconst MUSIC_OVERAGE_RATES = {\n  starter: 1.00,  // $1.00/song\n  pro: 1.00,      // $1.00/song\n  team: 1.00      // $1.00/song\n};\n\n/**\n * Get music credits balance for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{remaining: number, total: number, tier: string}>}\n */\nasync function getMusicCredits(stripeCustomerId) {\n  const result = await pool.query(\n    `SELECT music_credits_remaining, music_credits_total, tier\n     FROM users\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { remaining: 0, total: 0, tier: 'starter' };\n  }\n\n  const row = result.rows[0];\n  return {\n    remaining: row.music_credits_remaining || 0,\n    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n    tier: row.tier || 'starter'\n  };\n}\n\n/**\n * Check if customer has music credits available\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<boolean>}\n */\nasync function hasMusicCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  return credits.remaining > 0;\n}\n\n/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining } = result.rows[0];\n    let charged = 0;\n\n    if (music_credits_remaining > 0) {\n      // Deduct from included credits\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - 1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n    } else {\n      // Overage - charge flat rate ($1/song)\n      charged = MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, 1, $2)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset music credits based on tier (called on subscription renewal)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {string} tier - Subscription tier\n */\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n\n  await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = $2,\n         music_credits_total = $2,\n         music_credits_reset_at = CURRENT_TIMESTAMP,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, credits]\n  );\n}\n\n/**\n * Add music credits (for promotional or overage purchases)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} credits - Number of credits to add\n * @returns {Promise<{success: boolean, newBalance: number}>}\n */\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const result = await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = music_credits_remaining + $2,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1\n     RETURNING music_credits_remaining`,\n    [stripeCustomerId, credits]\n  );\n\n  if (result.rows.length === 0) {\n    return { success: false, newBalance: 0 };\n  }\n\n  return {\n    success: true,\n    newBalance: result.rows[0].music_credits_remaining\n  };\n}\n\n/**\n * Get music usage history for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} limit - Max records to return\n * @returns {Promise<Object[]>}\n */\nasync function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM music_usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Initialize music credits columns (migration helper)\n */\nasync function initMusicCreditsColumns() {\n  const client = await pool.connect();\n  try {\n    // Add music credits columns if they don't exist\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    // Create music usage log table\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS music_usage_log (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        credits_used INTEGER DEFAULT 1,\n        overage_charged DECIMAL(10,2) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n      ON music_usage_log(stripe_customer_id)\n    `);\n\n    console.log('[SPLICE] Music credits columns initialized');\n  } finally {\n    client.release();\n  }\n}\n\n// Variations credits cost (equivalent to 2.5 music credits)\nconst VARIATIONS_CREDIT_COST = 2.5;\n\n// Overage rates for variations (higher than single music due to 3 parallel generations)\nconst VARIATIONS_OVERAGE_RATES = {\n  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  team: 0.50      // $0.50/variations (2.5x $0.20)\n};\n\n// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\nconst SCENE_AWARE_CREDIT_COST = 1.5;\n\n// Overage rates for scene-aware music (75% margin)\nconst SCENE_AWARE_OVERAGE_RATES = {\n  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n};\n\n/**\n * Check if customer has enough credits for variations (2.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkVariationsCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = VARIATIONS_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct variations credit from customer (2.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductVariationsCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Variations credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if customer has enough credits for scene-aware music (1.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkSceneAwareCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct scene-aware music credit from customer (1.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductSceneAwareCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Close the database connection pool\n * Used for graceful shutdown\n */\nasync function closePool() {\n  await pool.end();\n}\n\n/**\n * Update trial end date for a customer\n * @param {string} stripeCustomerId - Customer ID\n * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n */\nasync function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n\n  await pool.query(\n    `UPDATE users\n     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, trialEnd]\n  );\n\n  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n}\n\n/**\n * Check database connectivity\n * Used for health checks\n */\nasync function checkDatabase() {\n  const client = await pool.connect();\n  try {\n    const result = await client.query('SELECT 1 as health');\n    return result.rows[0].health === 1;\n  } finally {\n    client.release();\n  }\n}\n\nmodule.exports = {\n  initDatabase,\n  getOrCreateUser,\n  customerExists,\n  getBalance,\n  hasCredits,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  checkIsolationAccess,\n  deductUsage,\n  deductIsolationUsage,\n  resetHours,\n  updateTier,\n  getUsageHistory,\n  isEventProcessed,\n  recordWebhookEvent,\n  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  resetMusicCredits,\n  addMusicCredits,\n  getMusicUsageHistory,\n  initMusicCreditsColumns,\n  // Variations credits functions\n  checkVariationsCredits,\n  deductVariationsCredit,\n  // Scene-aware credits functions\n  checkSceneAwareCredits,\n  deductSceneAwareCredit,\n  // Pool management\n  closePool,\n  checkDatabase,\n  // Trial management\n  updateTrialEnd,\n  // Constants\n  TIER_HOURS,\n  TIER_ISOLATION_MINUTES,\n  TIER_ISOLATION_HOURS,\n  ISOLATION_OVERAGE_RATE,\n  HOURS_OVERAGE_RATE,\n  TIER_MUSIC_CREDITS,\n  MUSIC_OVERAGE_RATE,\n  MUSIC_OVERAGE_RATES,\n  VARIATIONS_CREDIT_COST,\n  VARIATIONS_OVERAGE_RATES,\n  SCENE_AWARE_CREDIT_COST,\n  SCENE_AWARE_OVERAGE_RATES,\n  // Feature access\n  TIER_FEATURES,\n  hasFeatureAccess\n};\n","numLines":1516,"startLine":1,"totalLines":1516}}}
{"parentUuid":"a075d96a-a5e6-4895-b8f4-560b1cfa2af0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JpCt9cPgkY27SrMYquhA7v","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me examine the music credit deduction functions more closely and check for any potential issues:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":112,"cache_creation_input_tokens":21469,"cache_read_input_tokens":18600,"cache_creation":{"ephemeral_5m_input_tokens":21469,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSGUZCd9p3brTHDrFP","type":"assistant","uuid":"ec9050c3-af2e-4403-afdc-50531f1dc73c","timestamp":"2025-12-30T00:26:15.138Z"}
{"parentUuid":"ec9050c3-af2e-4403-afdc-50531f1dc73c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JpCt9cPgkY27SrMYquhA7v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Yb76bQFcKv8vrQTT7qmamC","name":"Grep","input":{"pattern":"deductMusicCredit|FOR UPDATE|BEGIN|COMMIT|ROLLBACK","path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","output_mode":"content","head_limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":112,"cache_creation_input_tokens":21469,"cache_read_input_tokens":18600,"cache_creation":{"ephemeral_5m_input_tokens":21469,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSGUZCd9p3brTHDrFP","type":"assistant","uuid":"9f11238c-5768-45e9-b32a-8268933da890","timestamp":"2025-12-30T00:26:15.993Z"}
{"parentUuid":"9f11238c-5768-45e9-b32a-8268933da890","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01JpCt9cPgkY27SrMYquhA7v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KkcgVGdicBFzbbCP6mWobG","name":"Grep","input":{"pattern":"addMusicCredits|resetMusicCredits","path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","output_mode":"content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":112,"cache_creation_input_tokens":21469,"cache_read_input_tokens":18600,"cache_creation":{"ephemeral_5m_input_tokens":21469,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSGUZCd9p3brTHDrFP","type":"assistant","uuid":"9149b45a-1b6b-4412-ad2c-6515ff49c974","timestamp":"2025-12-30T00:26:16.356Z"}
{"parentUuid":"9149b45a-1b6b-4412-ad2c-6515ff49c974","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Yb76bQFcKv8vrQTT7qmamC","type":"tool_result","content":"86:      BEGIN\n242: * Reserve credits atomically using SELECT ... FOR UPDATE\n256:    await client.query('BEGIN');\n262:       FOR UPDATE`,\n282:      await client.query('ROLLBACK');\n310:    await client.query('COMMIT');\n321:    await client.query('ROLLBACK');\n346:    await client.query('BEGIN');\n353:       FOR UPDATE`,\n358:      await client.query('ROLLBACK');\n402:    await client.query('COMMIT');\n432:    await client.query('ROLLBACK');\n454:    await client.query('BEGIN');\n460:       FOR UPDATE`,\n465:      await client.query('ROLLBACK');\n490:    await client.query('COMMIT');\n520:    await client.query('ROLLBACK');\n581: * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n589:    await client.query('BEGIN');\n595:       FOR UPDATE`,\n600:      await client.query('ROLLBACK');\n640:    await client.query('COMMIT');\n674:    await client.query('ROLLBACK');\n692:    await client.query('BEGIN');\n697:       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n702:      await client.query('ROLLBACK');\n734:    await client.query('COMMIT');\n776:    await client.query('ROLLBACK');\n1007:async function deductMusicCredit(stripeCustomerId) {\n1010:    await client.query('BEGIN');\n1017:       FOR UPDATE`,\n1022:      await client.query('ROLLBACK');\n1059:    await client.query('COMMIT');\n1069:    await client.query('ROLLBACK');\n1148:      BEGIN\n1232:    await client.query('BEGIN');\n1239:       FOR UPDATE`,\n1244:      await client.query('ROLLBACK');\n1294:    await client.query('COMMIT');\n1305:    await client.query('ROLLBACK');\n1342:    await client.query('BEGIN');\n1349:       FOR UPDATE`,\n1354:      await client.query('ROLLBACK');\n1404:    await client.query('COMMIT');\n1415:    await client.query('ROLLBACK');\n1483:  deductMusicCredit,\n\n[Showing results with pagination = limit: 50, offset: 0]"}]},"uuid":"6fc05ea2-6b25-48ea-845b-06fa20eb0708","timestamp":"2025-12-30T00:26:16.440Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"86:      BEGIN\n242: * Reserve credits atomically using SELECT ... FOR UPDATE\n256:    await client.query('BEGIN');\n262:       FOR UPDATE`,\n282:      await client.query('ROLLBACK');\n310:    await client.query('COMMIT');\n321:    await client.query('ROLLBACK');\n346:    await client.query('BEGIN');\n353:       FOR UPDATE`,\n358:      await client.query('ROLLBACK');\n402:    await client.query('COMMIT');\n432:    await client.query('ROLLBACK');\n454:    await client.query('BEGIN');\n460:       FOR UPDATE`,\n465:      await client.query('ROLLBACK');\n490:    await client.query('COMMIT');\n520:    await client.query('ROLLBACK');\n581: * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n589:    await client.query('BEGIN');\n595:       FOR UPDATE`,\n600:      await client.query('ROLLBACK');\n640:    await client.query('COMMIT');\n674:    await client.query('ROLLBACK');\n692:    await client.query('BEGIN');\n697:       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n702:      await client.query('ROLLBACK');\n734:    await client.query('COMMIT');\n776:    await client.query('ROLLBACK');\n1007:async function deductMusicCredit(stripeCustomerId) {\n1010:    await client.query('BEGIN');\n1017:       FOR UPDATE`,\n1022:      await client.query('ROLLBACK');\n1059:    await client.query('COMMIT');\n1069:    await client.query('ROLLBACK');\n1148:      BEGIN\n1232:    await client.query('BEGIN');\n1239:       FOR UPDATE`,\n1244:      await client.query('ROLLBACK');\n1294:    await client.query('COMMIT');\n1305:    await client.query('ROLLBACK');\n1342:    await client.query('BEGIN');\n1349:       FOR UPDATE`,\n1354:      await client.query('ROLLBACK');\n1404:    await client.query('COMMIT');\n1415:    await client.query('ROLLBACK');\n1483:  deductMusicCredit,","numLines":46,"appliedLimit":50}}
{"parentUuid":"6fc05ea2-6b25-48ea-845b-06fa20eb0708","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KkcgVGdicBFzbbCP6mWobG","type":"tool_result","content":"1082:async function resetMusicCredits(stripeCustomerId, tier) {\n1102:async function addMusicCredits(stripeCustomerId, credits) {\n1484:  resetMusicCredits,\n1485:  addMusicCredits,"}]},"uuid":"a43a50d3-97f7-4b16-9417-cc1650e68cc0","timestamp":"2025-12-30T00:26:16.441Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"1082:async function resetMusicCredits(stripeCustomerId, tier) {\n1102:async function addMusicCredits(stripeCustomerId, credits) {\n1484:  resetMusicCredits,\n1485:  addMusicCredits,","numLines":4}}
{"parentUuid":"a43a50d3-97f7-4b16-9417-cc1650e68cc0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018WQ4QoZgbCeqohuq2hd6zc","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect. Now let me examine the specific functions around music credit handling more carefully:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1096,"cache_read_input_tokens":40069,"cache_creation":{"ephemeral_5m_input_tokens":1096,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSXfN3DtuHqGMkEkCZ","type":"assistant","uuid":"fa8700ca-5b9a-42e9-bf97-24e7bf2754e3","timestamp":"2025-12-30T00:26:17.737Z"}
{"parentUuid":"fa8700ca-5b9a-42e9-bf97-24e7bf2754e3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018WQ4QoZgbCeqohuq2hd6zc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01L2LefzBUu1Jr74J2VsAm7J","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","offset":1002,"limit":120}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1096,"cache_read_input_tokens":40069,"cache_creation":{"ephemeral_5m_input_tokens":1096,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSXfN3DtuHqGMkEkCZ","type":"assistant","uuid":"d66b9ecd-e018-41cc-9b3b-5e21ff3d6b07","timestamp":"2025-12-30T00:26:18.051Z"}
{"parentUuid":"d66b9ecd-e018-41cc-9b3b-5e21ff3d6b07","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L2LefzBUu1Jr74J2VsAm7J","type":"tool_result","content":"  1002→/**\n  1003→ * Deduct one music credit from customer\n  1004→ * @param {string} stripeCustomerId - Stripe customer ID\n  1005→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1006→ */\n  1007→async function deductMusicCredit(stripeCustomerId) {\n  1008→  const client = await pool.connect();\n  1009→  try {\n  1010→    await client.query('BEGIN');\n  1011→\n  1012→    // Lock row for update\n  1013→    const result = await client.query(\n  1014→      `SELECT music_credits_remaining, tier\n  1015→       FROM users\n  1016→       WHERE stripe_customer_id = $1\n  1017→       FOR UPDATE`,\n  1018→      [stripeCustomerId]\n  1019→    );\n  1020→\n  1021→    if (result.rows.length === 0) {\n  1022→      await client.query('ROLLBACK');\n  1023→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1024→    }\n  1025→\n  1026→    const { music_credits_remaining } = result.rows[0];\n  1027→    let charged = 0;\n  1028→\n  1029→    if (music_credits_remaining > 0) {\n  1030→      // Deduct from included credits\n  1031→      await client.query(\n  1032→        `UPDATE users\n  1033→         SET music_credits_remaining = music_credits_remaining - 1,\n  1034→             updated_at = CURRENT_TIMESTAMP\n  1035→         WHERE stripe_customer_id = $1`,\n  1036→        [stripeCustomerId]\n  1037→      );\n  1038→    } else {\n  1039→      // Overage - charge flat rate ($1/song)\n  1040→      charged = MUSIC_OVERAGE_RATE;\n  1041→\n  1042→      // Report overage to Stripe meter for billing\n  1043→      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n  1044→      if (usageReport.success) {\n  1045→        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n  1046→      } else {\n  1047→        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n  1048→      }\n  1049→    }\n  1050→\n  1051→    // Log the usage\n  1052→    await client.query(\n  1053→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1054→       VALUES ($1, 1, $2)\n  1055→       ON CONFLICT DO NOTHING`,\n  1056→      [stripeCustomerId, charged]\n  1057→    );\n  1058→\n  1059→    await client.query('COMMIT');\n  1060→\n  1061→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1062→    return {\n  1063→      success: true,\n  1064→      remaining: newCredits.remaining,\n  1065→      charged\n  1066→    };\n  1067→\n  1068→  } catch (err) {\n  1069→    await client.query('ROLLBACK');\n  1070→    console.error('[SPLICE] Music credit deduction error:', err.message);\n  1071→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1072→  } finally {\n  1073→    client.release();\n  1074→  }\n  1075→}\n  1076→\n  1077→/**\n  1078→ * Reset music credits based on tier (called on subscription renewal)\n  1079→ * @param {string} stripeCustomerId - Stripe customer ID\n  1080→ * @param {string} tier - Subscription tier\n  1081→ */\n  1082→async function resetMusicCredits(stripeCustomerId, tier) {\n  1083→  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  1084→\n  1085→  await pool.query(\n  1086→    `UPDATE users\n  1087→     SET music_credits_remaining = $2,\n  1088→         music_credits_total = $2,\n  1089→         music_credits_reset_at = CURRENT_TIMESTAMP,\n  1090→         updated_at = CURRENT_TIMESTAMP\n  1091→     WHERE stripe_customer_id = $1`,\n  1092→    [stripeCustomerId, credits]\n  1093→  );\n  1094→}\n  1095→\n  1096→/**\n  1097→ * Add music credits (for promotional or overage purchases)\n  1098→ * @param {string} stripeCustomerId - Stripe customer ID\n  1099→ * @param {number} credits - Number of credits to add\n  1100→ * @returns {Promise<{success: boolean, newBalance: number}>}\n  1101→ */\n  1102→async function addMusicCredits(stripeCustomerId, credits) {\n  1103→  const result = await pool.query(\n  1104→    `UPDATE users\n  1105→     SET music_credits_remaining = music_credits_remaining + $2,\n  1106→         updated_at = CURRENT_TIMESTAMP\n  1107→     WHERE stripe_customer_id = $1\n  1108→     RETURNING music_credits_remaining`,\n  1109→    [stripeCustomerId, credits]\n  1110→  );\n  1111→\n  1112→  if (result.rows.length === 0) {\n  1113→    return { success: false, newBalance: 0 };\n  1114→  }\n  1115→\n  1116→  return {\n  1117→    success: true,\n  1118→    newBalance: result.rows[0].music_credits_remaining\n  1119→  };\n  1120→}\n  1121→\n\n</system-reminder>\n"}]},"uuid":"58383a8d-904d-4db0-b0b2-70deb66276b8","timestamp":"2025-12-30T00:26:18.140Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining } = result.rows[0];\n    let charged = 0;\n\n    if (music_credits_remaining > 0) {\n      // Deduct from included credits\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - 1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n    } else {\n      // Overage - charge flat rate ($1/song)\n      charged = MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, 1, $2)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset music credits based on tier (called on subscription renewal)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {string} tier - Subscription tier\n */\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n\n  await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = $2,\n         music_credits_total = $2,\n         music_credits_reset_at = CURRENT_TIMESTAMP,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, credits]\n  );\n}\n\n/**\n * Add music credits (for promotional or overage purchases)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} credits - Number of credits to add\n * @returns {Promise<{success: boolean, newBalance: number}>}\n */\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const result = await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = music_credits_remaining + $2,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1\n     RETURNING music_credits_remaining`,\n    [stripeCustomerId, credits]\n  );\n\n  if (result.rows.length === 0) {\n    return { success: false, newBalance: 0 };\n  }\n\n  return {\n    success: true,\n    newBalance: result.rows[0].music_credits_remaining\n  };\n}\n","numLines":120,"startLine":1002,"totalLines":1516}}}
{"parentUuid":"58383a8d-904d-4db0-b0b2-70deb66276b8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01N7xazgvzbk1pU4sKmNPpiu","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the variations and scene-aware credit functions as well:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1859,"cache_read_input_tokens":41165,"cache_creation":{"ephemeral_5m_input_tokens":1859,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSeuSJmRTLxkqhpQr1","type":"assistant","uuid":"e83b338e-45d7-4cec-a54e-eebd0d56be8a","timestamp":"2025-12-30T00:26:19.703Z"}
{"parentUuid":"e83b338e-45d7-4cec-a54e-eebd0d56be8a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01N7xazgvzbk1pU4sKmNPpiu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JcBpHhVCZEezRStaWsgbbj","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","offset":1229,"limit":85}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1859,"cache_read_input_tokens":41165,"cache_creation":{"ephemeral_5m_input_tokens":1859,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSeuSJmRTLxkqhpQr1","type":"assistant","uuid":"dd069724-5ede-4bfb-9b93-84970b1cd709","timestamp":"2025-12-30T00:26:20.372Z"}
{"parentUuid":"dd069724-5ede-4bfb-9b93-84970b1cd709","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01N7xazgvzbk1pU4sKmNPpiu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Brp3U8aQMayGVCBx4gsE6K","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","offset":1339,"limit":85}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":1859,"cache_read_input_tokens":41165,"cache_creation":{"ephemeral_5m_input_tokens":1859,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSeuSJmRTLxkqhpQr1","type":"assistant","uuid":"a5ffbf36-da34-4a06-831a-550068cc44cf","timestamp":"2025-12-30T00:26:20.673Z"}
{"parentUuid":"a5ffbf36-da34-4a06-831a-550068cc44cf","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JcBpHhVCZEezRStaWsgbbj","type":"tool_result","content":"  1229→async function deductVariationsCredit(stripeCustomerId) {\n  1230→  const client = await pool.connect();\n  1231→  try {\n  1232→    await client.query('BEGIN');\n  1233→\n  1234→    // Lock row for update\n  1235→    const result = await client.query(\n  1236→      `SELECT music_credits_remaining, tier\n  1237→       FROM users\n  1238→       WHERE stripe_customer_id = $1\n  1239→       FOR UPDATE`,\n  1240→      [stripeCustomerId]\n  1241→    );\n  1242→\n  1243→    if (result.rows.length === 0) {\n  1244→      await client.query('ROLLBACK');\n  1245→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1246→    }\n  1247→\n  1248→    const { music_credits_remaining, tier } = result.rows[0];\n  1249→    let charged = 0;\n  1250→    let creditsDeducted = 0;\n  1251→\n  1252→    // Determine how many credits to deduct vs overage to charge\n  1253→    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n  1254→      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n  1255→      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n  1256→      await client.query(\n  1257→        `UPDATE users\n  1258→         SET music_credits_remaining = music_credits_remaining - $2,\n  1259→             updated_at = CURRENT_TIMESTAMP\n  1260→         WHERE stripe_customer_id = $1`,\n  1261→        [stripeCustomerId, creditsDeducted]\n  1262→      );\n  1263→    } else if (music_credits_remaining > 0) {\n  1264→      // Partial credits - deduct what they have and charge overage for the rest\n  1265→      const creditsPortion = music_credits_remaining;\n  1266→      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n  1267→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1268→      charged = overagePortion * overageRate;\n  1269→\n  1270→      creditsDeducted = creditsPortion;\n  1271→      await client.query(\n  1272→        `UPDATE users\n  1273→         SET music_credits_remaining = 0,\n  1274→             updated_at = CURRENT_TIMESTAMP\n  1275→         WHERE stripe_customer_id = $1`,\n  1276→        [stripeCustomerId]\n  1277→      );\n  1278→\n  1279→      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1280→    } else {\n  1281→      // No credits - full overage\n  1282→      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n  1283→      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1284→    }\n  1285→\n  1286→    // Log the usage\n  1287→    await client.query(\n  1288→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1289→       VALUES ($1, $2, $3)\n  1290→       ON CONFLICT DO NOTHING`,\n  1291→      [stripeCustomerId, creditsDeducted, charged]\n  1292→    );\n  1293→\n  1294→    await client.query('COMMIT');\n  1295→\n  1296→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1297→    return {\n  1298→      success: true,\n  1299→      remaining: newCredits.remaining,\n  1300→      creditsDeducted,\n  1301→      charged\n  1302→    };\n  1303→\n  1304→  } catch (err) {\n  1305→    await client.query('ROLLBACK');\n  1306→    console.error('[SPLICE] Variations credit deduction error:', err.message);\n  1307→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1308→  } finally {\n  1309→    client.release();\n  1310→  }\n  1311→}\n  1312→\n  1313→/**\n\n</system-reminder>\n"}]},"uuid":"eb4a55ae-b1e5-4a3b-ae80-6467e8f4a22e","timestamp":"2025-12-30T00:26:20.725Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"async function deductVariationsCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Variations credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**","numLines":85,"startLine":1229,"totalLines":1516}}}
{"parentUuid":"eb4a55ae-b1e5-4a3b-ae80-6467e8f4a22e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Brp3U8aQMayGVCBx4gsE6K","type":"tool_result","content":"  1339→async function deductSceneAwareCredit(stripeCustomerId) {\n  1340→  const client = await pool.connect();\n  1341→  try {\n  1342→    await client.query('BEGIN');\n  1343→\n  1344→    // Lock row for update\n  1345→    const result = await client.query(\n  1346→      `SELECT music_credits_remaining, tier\n  1347→       FROM users\n  1348→       WHERE stripe_customer_id = $1\n  1349→       FOR UPDATE`,\n  1350→      [stripeCustomerId]\n  1351→    );\n  1352→\n  1353→    if (result.rows.length === 0) {\n  1354→      await client.query('ROLLBACK');\n  1355→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1356→    }\n  1357→\n  1358→    const { music_credits_remaining, tier } = result.rows[0];\n  1359→    let charged = 0;\n  1360→    let creditsDeducted = 0;\n  1361→\n  1362→    // Determine how many credits to deduct vs overage to charge\n  1363→    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n  1364→      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n  1365→      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n  1366→      await client.query(\n  1367→        `UPDATE users\n  1368→         SET music_credits_remaining = music_credits_remaining - $2,\n  1369→             updated_at = CURRENT_TIMESTAMP\n  1370→         WHERE stripe_customer_id = $1`,\n  1371→        [stripeCustomerId, creditsDeducted]\n  1372→      );\n  1373→    } else if (music_credits_remaining > 0) {\n  1374→      // Partial credits - deduct what they have and charge overage for the rest\n  1375→      const creditsPortion = music_credits_remaining;\n  1376→      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n  1377→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1378→      charged = overagePortion * overageRate;\n  1379→\n  1380→      creditsDeducted = creditsPortion;\n  1381→      await client.query(\n  1382→        `UPDATE users\n  1383→         SET music_credits_remaining = 0,\n  1384→             updated_at = CURRENT_TIMESTAMP\n  1385→         WHERE stripe_customer_id = $1`,\n  1386→        [stripeCustomerId]\n  1387→      );\n  1388→\n  1389→      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1390→    } else {\n  1391→      // No credits - full overage\n  1392→      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n  1393→      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1394→    }\n  1395→\n  1396→    // Log the usage\n  1397→    await client.query(\n  1398→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1399→       VALUES ($1, $2, $3)\n  1400→       ON CONFLICT DO NOTHING`,\n  1401→      [stripeCustomerId, creditsDeducted, charged]\n  1402→    );\n  1403→\n  1404→    await client.query('COMMIT');\n  1405→\n  1406→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1407→    return {\n  1408→      success: true,\n  1409→      remaining: newCredits.remaining,\n  1410→      creditsDeducted,\n  1411→      charged\n  1412→    };\n  1413→\n  1414→  } catch (err) {\n  1415→    await client.query('ROLLBACK');\n  1416→    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n  1417→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1418→  } finally {\n  1419→    client.release();\n  1420→  }\n  1421→}\n  1422→\n  1423→/**\n\n</system-reminder>\n"}]},"uuid":"fa661286-73d6-419c-8dc4-5cd5ce8cad78","timestamp":"2025-12-30T00:26:20.725Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"async function deductSceneAwareCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**","numLines":85,"startLine":1339,"totalLines":1516}}}
{"parentUuid":"fa661286-73d6-419c-8dc4-5cd5ce8cad78","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011YU3U9D8nnw7ZXcfYCvVdd","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the database schema initialization to understand the full picture:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":2890,"cache_read_input_tokens":43024,"cache_creation":{"ephemeral_5m_input_tokens":2890,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSqzRrYX4NxsQxnYQE","type":"assistant","uuid":"65444b4e-1256-4837-b1bf-9b3ff9960307","timestamp":"2025-12-30T00:26:21.987Z"}
{"parentUuid":"65444b4e-1256-4837-b1bf-9b3ff9960307","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011YU3U9D8nnw7ZXcfYCvVdd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AsvERBYPLSKzXtwzb3xYfZ","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","offset":1142,"limit":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":2890,"cache_read_input_tokens":43024,"cache_creation":{"ephemeral_5m_input_tokens":2890,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSqzRrYX4NxsQxnYQE","type":"assistant","uuid":"2c44b155-cd08-4a5c-8106-72505acd2aac","timestamp":"2025-12-30T00:26:22.691Z"}
{"parentUuid":"2c44b155-cd08-4a5c-8106-72505acd2aac","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AsvERBYPLSKzXtwzb3xYfZ","type":"tool_result","content":"  1142→async function initMusicCreditsColumns() {\n  1143→  const client = await pool.connect();\n  1144→  try {\n  1145→    // Add music credits columns if they don't exist\n  1146→    await client.query(`\n  1147→      DO $$\n  1148→      BEGIN\n  1149→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n  1150→          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n  1151→        END IF;\n  1152→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n  1153→          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n  1154→        END IF;\n  1155→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n  1156→          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n  1157→        END IF;\n  1158→      END $$;\n  1159→    `);\n  1160→\n  1161→    // Create music usage log table\n  1162→    await client.query(`\n  1163→      CREATE TABLE IF NOT EXISTS music_usage_log (\n  1164→        id SERIAL PRIMARY KEY,\n  1165→        stripe_customer_id VARCHAR(255) NOT NULL,\n  1166→        credits_used INTEGER DEFAULT 1,\n  1167→        overage_charged DECIMAL(10,2) DEFAULT 0,\n  1168→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n  1169→      )\n  1170→    `);\n  1171→\n  1172→    await client.query(`\n  1173→      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n  1174→      ON music_usage_log(stripe_customer_id)\n  1175→    `);\n  1176→\n  1177→    console.log('[SPLICE] Music credits columns initialized');\n  1178→  } finally {\n  1179→    client.release();\n  1180→  }\n  1181→}\n\n</system-reminder>\n"}]},"uuid":"318f973d-36f0-4d10-b860-3ffc23a48b60","timestamp":"2025-12-30T00:26:22.742Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"async function initMusicCreditsColumns() {\n  const client = await pool.connect();\n  try {\n    // Add music credits columns if they don't exist\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    // Create music usage log table\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS music_usage_log (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        credits_used INTEGER DEFAULT 1,\n        overage_charged DECIMAL(10,2) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n      ON music_usage_log(stripe_customer_id)\n    `);\n\n    console.log('[SPLICE] Music credits columns initialized');\n  } finally {\n    client.release();\n  }\n}","numLines":40,"startLine":1142,"totalLines":1516}}}
{"parentUuid":"318f973d-36f0-4d10-b860-3ffc23a48b60","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5d8dde70-47da-4221-8add-3e18da9f045d","version":"2.0.76","gitBranch":"main","agentId":"a839782","slug":"structured-meandering-whisper","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018JoYkspFGGELHqUEdzucjk","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now I have a comprehensive understanding of the music credit deduction implementation. Let me compile my analysis report.\n\n## Analysis Report: Music Credit Deduction Race Conditions\n\n### Current Implementation Summary\n\nThe music credit deduction system is implemented in `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js` (lines 1007-1075 for the primary function, with variations at lines 1229-1311 and scene-aware at lines 1339-1421).\n\n### Race Condition Safety Assessment: ATOMIC & SAFE\n\n**Status: EXCELLENT** - The implementation is **atomic and race-condition safe**. Here's why:\n\n#### 1. **SELECT...FOR UPDATE Implemented Correctly**\n\nAll three credit deduction functions use proper row-level locking:\n\n```javascript\n// Lines 1013-1019 (deductMusicCredit)\nconst result = await client.query(\n  `SELECT music_credits_remaining, tier\n   FROM users\n   WHERE stripe_customer_id = $1\n   FOR UPDATE`,  // <-- Row-level exclusive lock\n  [stripeCustomerId]\n);\n```\n\nSame pattern in:\n- `deductVariationsCredit` (lines 1235-1241)\n- `deductSceneAwareCredit` (lines 1345-1351)\n\n#### 2. **Full Transaction Control**\n\nEach function uses explicit transaction boundaries:\n- `BEGIN` transaction (line 1010)\n- `SELECT...FOR UPDATE` to lock the row\n- Conditional logic determines credit vs overage\n- `UPDATE` statement(s) to deduct/charge\n- `COMMIT` on success (line 1059)\n- `ROLLBACK` on error or user-not-found (lines 1022, 1069)\n\n#### 3. **Atomic Operations Pattern**\n\nThe transaction ensures:\n1. Only one transaction at a time can hold the lock for a user\n2. Other concurrent requests block until the lock is released\n3. All operations (SELECT, UPDATE, INSERT) complete together or not at all\n4. No dirty reads or lost updates possible\n\n### Potential Issues Identified\n\n#### Issue #1: **Post-Commit Query Race Condition** (Minor)\n**Lines 1061, 1296, 1406**\n\nAfter `COMMIT`, the code calls `getMusicCredits()` again:\n```javascript\nawait client.query('COMMIT');\n\nconst newCredits = await getMusicCredits(stripeCustomerId);  // NEW QUERY\nreturn {\n  success: true,\n  remaining: newCredits.remaining,  // Could differ from actual deduction\n  charged\n};\n```\n\n**Problem**: Another request could modify credits between COMMIT and this SELECT.\n\n**Risk Level**: Low - The charged amount is already correct; the remaining value is informational.\n\n#### Issue #2: **`addMusicCredits` and `resetMusicCredits` Missing Locks** (Moderate)\n**Lines 1082-1093, 1102-1120**\n\nThese functions do NOT use transactions or locks:\n\n```javascript\n// Lines 1102-1110 (addMusicCredits)\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const result = await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = music_credits_remaining + $2,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1\n     RETURNING music_credits_remaining`,\n    [stripeCustomerId, credits]  // NO TRANSACTION, NO FOR UPDATE\n  );\n  // ...\n}\n```\n\n**Problem**: If two concurrent requests call `addMusicCredits` or `resetMusicCredits`, both read-modify-write could race:\n- Request A: Reads 5 credits, adds 3 → writes 8\n- Request B: Reads 5 credits, adds 2 → writes 7 (overwrites A's 8!)\n\n**Real Impact**: Only 7 credits instead of 10.\n\n#### Issue #3: **Stripe Billing Report Outside Transaction** (Minor)\n**Lines 1043, 1294-1302, 1404-1412**\n\nThe Stripe overage reporting happens AFTER commit but is awaited within error handling. If Stripe call fails, the transaction already committed, creating billing discrepancies.\n\n#### Issue #4: **`getMusicCredits` Missing Transaction Isolation** (Low)\n**Lines 972-990**\n\nUsed in check functions, but doesn't use `SELECT...FOR UPDATE`, so it can read stale data between check and deduct.\n\n### Recommended Changes for SELECT...FOR UPDATE\n\n#### For `addMusicCredits` (Priority: HIGH)\n\n**Current (lines 1102-1120):**\n```javascript\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const result = await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = music_credits_remaining + $2,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1\n     RETURNING music_credits_remaining`,\n    [stripeCustomerId, credits]\n  );\n  // ...\n}\n```\n\n**Recommended:**\n```javascript\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const lockResult = await client.query(\n      `SELECT music_credits_remaining FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (lockResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, newBalance: 0 };\n    }\n\n    const result = await client.query(\n      `UPDATE users\n       SET music_credits_remaining = music_credits_remaining + $2,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1\n       RETURNING music_credits_remaining`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n\n    return {\n      success: true,\n      newBalance: result.rows[0].music_credits_remaining\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n```\n\n#### For `resetMusicCredits` (Priority: HIGH)\n\n**Current (lines 1082-1093):**\n```javascript\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  \n  await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = $2,\n         music_credits_total = $2,\n         music_credits_reset_at = CURRENT_TIMESTAMP,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, credits]\n  );\n}\n```\n\n**Recommended:**\n```javascript\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  const client = await pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n\n    // Lock row to prevent concurrent resets\n    await client.query(\n      `SELECT 1 FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    await client.query(\n      `UPDATE users\n       SET music_credits_remaining = $2,\n           music_credits_total = $2,\n           music_credits_reset_at = CURRENT_TIMESTAMP,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n```\n\n#### For `getMusicCredits` Check-Before-Use (Priority: MEDIUM)\n\nThe check functions like `hasMusicCredits` should be consolidated into the deduction flow instead of being separate. Alternatively, use:\n\n```javascript\n// If truly needed as standalone check with lock:\nasync function getMusicCreditsLocked(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    const result = await client.query(\n      `SELECT music_credits_remaining, music_credits_total, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n    await client.query('COMMIT');\n    \n    if (result.rows.length === 0) {\n      return { remaining: 0, total: 0, tier: 'starter' };\n    }\n    \n    const row = result.rows[0];\n    return {\n      remaining: row.music_credits_remaining || 0,\n      total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n      tier: row.tier || 'starter'\n    };\n  } finally {\n    client.release();\n  }\n}\n```\n\n### Summary Table\n\n| Function | Current Status | Atomic? | Race-Safe? | Issue | Priority |\n|----------|---|---|---|---|---|\n| `deductMusicCredit` | Implemented | ✓ Yes | ✓ Yes | Post-commit read | Low |\n| `deductVariationsCredit` | Implemented | ✓ Yes | ✓ Yes | Post-commit read | Low |\n| `deductSceneAwareCredit` | Implemented | ✓ Yes | ✓ Yes | Post-commit read | Low |\n| `addMusicCredits` | **Missing locks** | ✗ No | ✗ No | Lost write | HIGH |\n| `resetMusicCredits` | **Missing locks** | ✗ No | ✗ No | Lost write | HIGH |\n| `getMusicCredits` | Read-only | N/A | ✓ Eventual | Check-then-act gap | Medium |\n\n### Conclusion\n\nThe core deduction functions are **properly implemented with SELECT...FOR UPDATE** and are atomic/race-condition safe. However, **`addMusicCredits` and `resetMusicCredits` need immediate updates** to add transaction and lock support, as they currently suffer from classic lost-write race conditions."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":760,"cache_read_input_tokens":45914,"cache_creation":{"ephemeral_5m_input_tokens":760,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbvSzcMJpqbbFGm9dn8v","type":"assistant","uuid":"c05fd58a-fb3f-425d-a087-a0b291f5e779","timestamp":"2025-12-30T00:26:42.233Z"}
