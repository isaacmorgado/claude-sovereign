     1→/**
     2→ * SPLICE Plugin Main Entry Point
     3→ *
     4→ * Initializes all functionality when the plugin loads.
     5→ * v3.4 - Timeline Markers + Unified Take-Aware Workflow.
     6→ */
     7→
     8→// Initialize Premiere Pro API
     9→const ppro = require('premierepro');
    10→
    11→// ============================================================================
    12→// CACHED DOM ELEMENTS (Performance: avoid repeated getElementById calls)
    13→// ============================================================================
    14→const ui = {};
    15→
    16→function cacheUIElements() {
    17→  ui.status = document.getElementById('status');
    18→
    19→  // Main GO button (unified workflow)
    20→  ui.goBtn = document.getElementById('goBtn');
    21→  ui.optionsToggle = document.getElementById('optionsToggle');
    22→  ui.optionsPanel = document.getElementById('optionsPanel');
    23→
    24→  // Sliders and options
    25→  ui.sensitivitySlider = document.getElementById('sensitivitySlider');
    26→  ui.sourceOriginal = document.getElementById('sourceOriginal');
    27→  ui.sourceIsolated = document.getElementById('sourceIsolated');
    28→
    29→  // Settings checkboxes
    30→  ui.enableTakesDetection = document.getElementById('enableTakesDetection');
    31→  ui.autoMarkBest = document.getElementById('autoMarkBest');
    32→
    33→  // Progress
    34→  ui.progressContainer = document.getElementById('progressContainer');
    35→  ui.progressText = document.getElementById('progressText');
    36→  ui.resultsEmpty = document.getElementById('resultsEmpty');
    37→
    38→  // Combined Preview
    39→  ui.combinedPreview = document.getElementById('combinedPreview');
    40→  ui.previewList = document.getElementById('previewList');
    41→  ui.silenceCountDisplay = document.getElementById('silenceCount');
    42→  ui.takeCountDisplay = document.getElementById('takeCount');
    43→  ui.selectedCount = document.getElementById('selectedCount');
    44→  ui.selectAllSilences = document.getElementById('selectAllSilences');
    45→  ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');
    46→  ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');
    47→  ui.invertSelectionBtn = document.getElementById('invertSelectionBtn');
    48→  ui.reRunDetectionBtn = document.getElementById('reRunDetectionBtn');
    49→
    50→  // Results
    51→  ui.silenceResults = document.getElementById('silenceResults');
    52→  ui.resultsCount = document.getElementById('resultsCount');
    53→  ui.timeSaved = document.getElementById('timeSaved');
    54→  ui.clipsModified = document.getElementById('clipsModified');
    55→
    56→  // Build Sequence button (v3.5)
    57→  ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');
    58→
    59→  // Buttons
    60→  ui.undoBtn = document.getElementById('undoBtn');
    61→  ui.advancedSection = document.getElementById('advancedSection');
    62→
    63→  // Settings modal
    64→  ui.settingsBtn = document.getElementById('settingsBtn');
    65→  ui.settingsModal = document.getElementById('settingsModal');
    66→  ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');
    67→
    68→  // Media folder (v3.5)
    69→  ui.mediaFolderDisplay = document.getElementById('mediaFolderDisplay');
    70→  ui.setMediaFolderBtn = document.getElementById('setMediaFolderBtn');
    71→  ui.clearMediaFolderBtn = document.getElementById('clearMediaFolderBtn');
    72→}
    73→
    74→// ============================================================================
    75→// STATE MANAGEMENT
    76→// ============================================================================
    77→let previewSilences = [];         // All detected silences
    78→let safeSilences = [];            // Silences that don't overlap takes (safe to remove)
    79→let protectedSilences = [];       // Silences that overlap takes (protected)
    80→let previewTakes = [];            // Detected takes (for display)
    81→let selectedSilenceIndices = new Set();
    82→let isOperationInProgress = false;
    83→let pendingUIUpdate = null;
    84→
    85→// Export preview state for other modules (Razor integration)
    86→window.splicePreviewState = {
    87→  getSelectedSilences: () => safeSilences.filter((_, i) => selectedSilenceIndices.has(i)),
    88→  getSelectedTakes: () => previewTakes,
    89→  hasPreview: () => safeSilences.length > 0 || previewTakes.length > 0
    90→};
    91→
    92→// ============================================================================
    93→// INITIALIZATION
    94→// ============================================================================
    95→document.addEventListener('DOMContentLoaded', () => {
    96→  // Cache all DOM elements first
    97→  cacheUIElements();
    98→
    99→  // Settings & UI
   100→  initSettingsUI();
   101→  initSettingsModal();
   102→  initOptionsToggles();
   103→  initHelpButton();
   104→
   105→  // Credits display
   106→  initCredits();
   107→
   108→  // Unified workflow (silences + takes)
   109→  initUnifiedWorkflow();
   110→
   111→  // Preview handlers (event delegation)
   112→  initPreviewHandlers();
   113→
   114→  // Undo handlers
   115→  initUndoHandlers();
   116→
   117→  // Keyboard shortcuts
   118→  initKeyboardShortcuts();
   119→
   120→  // Advanced features (Razor - legacy)
   121→  initSlice9();
   122→
   123→  // Media folder (v3.5)
   124→  initMediaFolderHandlers();
   125→
   126→  console.log('[SPLICE] Plugin initialized v3.5 (Direct DOM Reconstruction)');
   127→});
   128→
   129→// ============================================================================
   130→// DEBOUNCED UI UPDATES (Performance: batch DOM updates)
   131→// ============================================================================
   132→function scheduleUIUpdate(callback) {
   133→  if (pendingUIUpdate) {
   134→    cancelAnimationFrame(pendingUIUpdate);
   135→  }
   136→  pendingUIUpdate = requestAnimationFrame(() => {
   137→    callback();
   138→    pendingUIUpdate = null;
   139→  });
   140→}
   141→
   142→function updateSelectionCounts() {
   143→  scheduleUIUpdate(() => {
   144→    if (ui.selectedCount) {
   145→      ui.selectedCount.textContent = selectedSilenceIndices.size;
   146→    }
   147→    updateApplyButton();
   148→    updateSelectAllCheckbox();
   149→  });
   150→}
   151→
   152→// ============================================================================
   153→// KEYBOARD SHORTCUTS
   154→// ============================================================================
   155→function initKeyboardShortcuts() {
   156→  document.addEventListener('keydown', (e) => {
   157→    // Only handle when combined preview is visible
   158→    const previewVisible = ui.combinedPreview?.style.display !== 'none' &&
   159→                           ui.combinedPreview?.style.display !== '';
   160→
   161→    if (!previewVisible) return;
   162→
   163→    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
   164→    const cmdKey = isMac ? e.metaKey : e.ctrlKey;
   165→
   166→    // Enter - Apply selected
   167→    if (e.key === 'Enter' && !e.shiftKey) {
   168→      e.preventDefault();
   169→      if (selectedSilenceIndices.size > 0) {
   170→        ui.applyPreviewBtn?.click();
   171→      }
   172→    }
   173→
   174→    // Escape - Cancel
   175→    if (e.key === 'Escape') {
   176→      e.preventDefault();
   177→      ui.cancelPreviewBtn?.click();
   178→    }
   179→
   180→    // Cmd/Ctrl+A - Select all
   181→    if (e.key === 'a' && cmdKey) {
   182→      e.preventDefault();
   183→      if (ui.selectAllSilences) {
   184→        ui.selectAllSilences.checked = true;
   185→        selectAllSilences(true);
   186→      }
   187→    }
   188→
   189→    // Cmd/Ctrl+D - Deselect all
   190→    if (e.key === 'd' && cmdKey) {
   191→      e.preventDefault();
   192→      if (ui.selectAllSilences) {
   193→        ui.selectAllSilences.checked = false;
   194→        selectAllSilences(false);
   195→      }
   196→    }
   197→
   198→    // Cmd/Ctrl+I - Invert selection
   199→    if (e.key === 'i' && cmdKey) {
   200→      e.preventDefault();
   201→      invertSilenceSelection();
   202→    }
   203→  });
   204→}
   205→
   206→// ============================================================================
   207→// UNIFIED WORKFLOW (Silence Detection + Takes Detection)
   208→// ============================================================================
   209→function initUnifiedWorkflow() {
   210→  if (!ui.goBtn) return;
   211→
   212→  ui.goBtn.addEventListener('click', async () => {
   213→    // Prevent double-click
   214→    if (isOperationInProgress) {
   215→      setStatus('Operation in progress...');
   216→      return;
   217→    }
   218→
   219→    isOperationInProgress = true;
   220→    ui.goBtn.disabled = true;
   221→
   222→    try {
   223→      showProgress('Preparing audio...');
   224→
   225→      // Step 1: Export audio
   226→      const exportSuccess = await exportAudioInternal();
   227→      if (!exportSuccess) {
   228→        throw new Error('Audio export failed');
   229→      }
   230→
   231→      // Step 2: Get settings
   232→      const sensitivity = parseInt(ui.sensitivitySlider?.value || 50);
   233→      const useIsolated = ui.sourceIsolated?.checked ?? false;
   234→      const detectTakes = ui.enableTakesDetection?.checked ?? true;
   235→
   236→      // Step 3: Vocal isolation if needed
   237→      let audioPath = WAV_PATH;
   238→      if (useIsolated) {
   239→        // Check isolation access before proceeding
   240→        const credits = getCurrentCredits();
   241→        if (!credits || !credits.hasIsolationAccess) {
   242→          throw new Error('Vocal isolation requires Pro or Team tier. Upgrade to access this feature.');
   243→        }
   244→
   245→        // Show overage warning if applicable
   246→        const isolationMins = credits.isolationHoursRemaining * 60;
   247→        if (isolationMins <= 0) {
   248→          const overageRate = credits.isolationOverageRate || 0.08;
   249→          showProgress(`Isolating vocals (overage: $${overageRate}/min)...`);
   250→        } else {
   251→          showProgress(`Isolating vocals (${isolationMins.toFixed(0)} min remaining)...`);
   252→        }
   253→
   254→        const isolateResult = await isolateVocals();
   255→        if (isolateResult.success) {
   256→          audioPath = isolateResult.outputPath;
   257→          // Update credits display after isolation
   258→          await refreshCredits();
   259→        } else {
   260→          throw new Error(isolateResult.error || 'Vocal isolation failed');
   261→        }
   262→      }
   263→
   264→      // Step 4: Run detection (parallel if takes enabled)
   265→      const params = mapSensitivity(sensitivity);
   266→      let silences = [];
   267→      let takes = [];
   268→
   269→      if (detectTakes) {
   270→        // Parallel detection for performance
   271→        showProgress('Detecting silences and analyzing takes...');
   272→        const [silenceResult, transcriptResult] = await Promise.all([
   273→          detectSilences(audioPath, params),
   274→          transcribeAudio()
   275→        ]);
   276→
   277→        silences = silenceResult;
   278→
   279→        // Extract takes from transcript result
   280→        if (transcriptResult.success && transcriptResult.takes) {
   281→          if (transcriptResult.takes.takes) {
   282→            takes = transcriptResult.takes.takes;
   283→          } else if (Array.isArray(transcriptResult.takes)) {
   284→            takes = transcriptResult.takes;
   285→          }
   286→        }
   287→
   288→        // Store transcript for reference
   289→        window.currentTranscript = transcriptResult.transcript;
   290→      } else {
   291→        // Just detect silences
   292→        showProgress('Detecting silences...');
   293→        silences = await detectSilences(audioPath, params);
   294→      }
   295→
   296→      if (silences.length === 0) {
   297→        showEmptyState();
   298→        setStatus('No silences detected. Try increasing sensitivity.');
   299→        return;
   300→      }
   301→
   302→      // Step 5: Filter silences by takes (protect speech)
   303→      const filtered = filterSilencesByTakes(silences, takes);
   304→
   305→      // Step 6: Add timeline markers (clear old ones first)
   306→      showProgress('Adding timeline markers...');
   307→      await clearSpliceMarkers();
   308→      const markerResult = await addTimelineMarkers(filtered.safe, filtered.protected, takes);
   309→
   310→      // Step 7: Show combined preview
   311→      showCombinedPreview(filtered.safe, filtered.protected, takes);
   312→
   313→      const markerInfo = markerResult.added > 0 ? ` (${markerResult.added} markers added)` : '';
   314→      const statusMsg = takes.length > 0
   315→        ? `Found ${silences.length} silences, ${filtered.protected.length} protected by ${takes.length} takes${markerInfo}`
   316→        : `Found ${silences.length} silence(s) - review and apply${markerInfo}`;
   317→      setStatus(statusMsg);
   318→
   319→    } catch (err) {
   320→      showEmptyState();
   321→      setStatus('Error: ' + err.message);
   322→      console.error('[SPLICE] Unified workflow error:', err);
   323→    } finally {
   324→      isOperationInProgress = false;
   325→      ui.goBtn.disabled = false;
   326→    }
   327→  });
   328→}
   329→
   330→// ============================================================================
   331→// TAKE-AWARE SILENCE FILTERING
   332→// ============================================================================
   333→/**
   334→ * Filter silences to protect those that overlap with takes (speech segments).
   335→ * Returns { safe: [], protected: [] }
   336→ */
   337→function filterSilencesByTakes(silences, takes) {
   338→  if (!takes || takes.length === 0) {
   339→    // No takes = all silences are safe to remove
   340→    return { safe: silences, protected: [] };
   341→  }
   342→
   343→  const safe = [];
   344→  const protected_ = [];
   345→
   346→  silences.forEach(silence => {
   347→    // Check if this silence overlaps with any take
   348→    const overlaps = takes.some(take => {
   349→      const takeStart = take.startTime || take.start;
   350→      const takeEnd = take.endTime || take.end;
   351→      // Overlap exists if silence starts before take ends AND silence ends after take starts
   352→      return silence.start < takeEnd && silence.end > takeStart;
   353→    });
   354→
   355→    if (overlaps) {
   356→      protected_.push(silence);
   357→    } else {
   358→      safe.push(silence);
   359→    }
   360→  });
   361→
   362→  console.log(`[SPLICE] Filtered silences: ${safe.length} safe, ${protected_.length} protected`);
   363→  return { safe, protected: protected_ };
   364→}
   365→
   366→// ============================================================================
   367→// TIMELINE MARKERS (Visual indicators on Premiere Pro timeline)
   368→// ============================================================================
   369→/**
   370→ * Add colored markers to the timeline for silences and takes.
   371→ * - Red markers: silences safe to remove
   372→ * - Yellow markers: silences protected by takes
   373→ * - Blue markers: takes (speech segments)
   374→ *
   375→ * @param {Array} safeToRemove - Silences safe to remove
   376→ * @param {Array} protectedSilences - Silences overlapping speech
   377→ * @param {Array} takes - Detected speech segments
   378→ * @returns {Promise<{added: number, errors: number}>}
   379→ */
   380→async function addTimelineMarkers(safeToRemove, protectedSilences, takes) {
   381→  const results = { added: 0, errors: 0 };
   382→
   383→  try {
   384→    const context = await getActiveSequence();
   385→    if (!context) {
   386→      console.warn('[SPLICE] No sequence available for markers');
   387→      return results;
   388→    }
   389→
   390→    const { sequence, project } = context;
   391→
   392→    // Get markers object for the sequence
   393→    const markers = await ppro.Markers.getMarkers(sequence);
   394→    if (!markers) {
   395→      console.warn('[SPLICE] Markers API not available');
   396→      return results;
   397→    }
   398→
   399→    // Collect all marker actions
   400→    const markerActions = [];
   401→
   402→    // Red markers for safe-to-remove silences
   403→    for (const silence of safeToRemove) {
   404→      try {
   405→        const duration = silence.end - silence.start;
   406→
   407→        // Use TickTime API directly (no TICKS_PER_SECOND needed)
   408→        const startTime = ppro.TickTime.createWithSeconds(silence.start);
   409→        const durationTime = ppro.TickTime.createWithSeconds(duration);
   410→
   411→        const action = markers.createAddMarkerAction(
   412→          `SPLICE: Remove (${duration.toFixed(2)}s)`,
   413→          ppro.Marker.MARKER_TYPE_COMMENT,
   414→          startTime,
   415→          durationTime,
   416→          `Silence to remove: ${formatTime(silence.start)} - ${formatTime(silence.end)}`
   417→        );
   418→        markerActions.push({ action, colorIndex: 1, type: 'silence' }); // Red = index 1
   419→      } catch (err) {
   420→        console.error('[SPLICE] Error creating silence marker:', err);
   421→        results.errors++;
   422→      }
   423→    }
   424→
   425→    // Yellow markers for protected silences
   426→    for (const silence of protectedSilences) {
   427→      try {
   428→        const duration = silence.end - silence.start;
   429→
   430→        // Use TickTime API directly (no TICKS_PER_SECOND needed)
   431→        const startTime = ppro.TickTime.createWithSeconds(silence.start);
   432→        const durationTime = ppro.TickTime.createWithSeconds(duration);
   433→
   434→        const action = markers.createAddMarkerAction(
   435→          `SPLICE: Protected (${duration.toFixed(2)}s)`,
   436→          ppro.Marker.MARKER_TYPE_COMMENT,
   437→          startTime,
   438→          durationTime,
   439→          `Protected silence (overlaps speech): ${formatTime(silence.start)} - ${formatTime(silence.end)}`
   440→        );
   441→        markerActions.push({ action, colorIndex: 4, type: 'protected' }); // Yellow = index 4
   442→      } catch (err) {
   443→        console.error('[SPLICE] Error creating protected marker:', err);
   444→        results.errors++;
   445→      }
   446→    }
   447→
   448→    // Blue markers for takes (speech segments)
   449→    for (const take of takes) {
   450→      try {
   451→        const start = take.startTime || take.start;
   452→        const end = take.endTime || take.end;
   453→        const duration = end - start;
   454→        const textPreview = take.text?.substring(0, 30) || 'Speech';
   455→
   456→        // Use TickTime API directly (no TICKS_PER_SECOND needed)
   457→        const startTime = ppro.TickTime.createWithSeconds(start);
   458→        const durationTime = ppro.TickTime.createWithSeconds(duration);
   459→
   460→        const action = markers.createAddMarkerAction(
   461→          `SPLICE: Take`,
   462→          ppro.Marker.MARKER_TYPE_COMMENT,
   463→          startTime,
   464→          durationTime,
   465→          `Speech segment: ${textPreview}${take.text?.length > 30 ? '...' : ''}`
   466→        );
   467→        markerActions.push({ action, colorIndex: 5, type: 'take' }); // Blue = index 5
   468→      } catch (err) {
   469→        console.error('[SPLICE] Error creating take marker:', err);
   470→        results.errors++;
   471→      }
   472→    }
   473→
   474→    // Execute all marker actions in a single transaction
   475→    if (markerActions.length > 0) {
   476→      await project.lockedAccess(async () => {
   477→        await project.executeTransaction((compoundAction) => {
   478→          for (const { action } of markerActions) {
   479→            compoundAction.addAction(action);
   480→          }
   481→        }, 'SPLICE: Add Timeline Markers');
   482→      });
   483→
   484→      results.added = markerActions.length;
   485→      console.log(`[SPLICE] Added ${results.added} timeline markers`);
   486→    }
   487→
   488→  } catch (err) {
   489→    console.error('[SPLICE] Timeline markers error:', err);
   490→    results.errors++;
   491→  }
   492→
   493→  return results;
   494→}
   495→
   496→/**
   497→ * Read current SPLICE marker positions from timeline.
   498→ * This allows users to manually adjust markers before applying.
   499→ * Returns silences based on current marker positions (not original detection).
   500→ */
   501→async function readMarkersAssilences() {
   502→  const silences = [];
   503→
   504→  try {
   505→    const context = await getActiveSequence();
   506→    if (!context) return silences;
   507→
   508→    const { sequence } = context;
   509→    const markers = await ppro.Markers.getMarkers(sequence);
   510→    if (!markers) return silences;
   511→
   512→    const allMarkers = await markers.getMarkers();
   513→    if (!allMarkers || allMarkers.length === 0) return silences;
   514→
   515→    for (const marker of allMarkers) {
   516→      const name = await marker.getName();
   517→
   518→      // Only read "Remove" markers (red ones that will be cut)
   519→      if (name && name.startsWith('SPLICE: Remove')) {
   520→        const startTickTime = await marker.getStart();
   521→        const durationTickTime = await marker.getDuration();
   522→
   523→        // Use TickTime.seconds property to get seconds directly (no TICKS_PER_SECOND needed)
   524→        const start = startTickTime.seconds;
   525→        const duration = durationTickTime.seconds;
   526→        const end = start + duration;
   527→
   528→        silences.push({
   529→          start,
   530→          end,
   531→          duration,
   532→          fromMarker: true  // Flag to indicate this came from marker adjustment
   533→        });
   534→      }
   535→    }
   536→
   537→    // Sort by start time
   538→    silences.sort((a, b) => a.start - b.start);
   539→    console.log(`[SPLICE] Read ${silences.length} silences from adjusted markers`);
   540→
   541→  } catch (err) {
   542→    console.error('[SPLICE] Error reading markers:', err);
   543→  }
   544→
   545→  return silences;
   546→}
   547→
   548→/**
   549→ * Remove all SPLICE markers from the timeline.
   550→ * Call this before adding new markers to avoid duplicates.
   551→ */
   552→async function clearSpliceMarkers() {
   553→  try {
   554→    const context = await getActiveSequence();
   555→    if (!context) return 0;
   556→
   557→    const { sequence, project } = context;
   558→    const markers = await ppro.Markers.getMarkers(sequence);
   559→    if (!markers) return 0;
   560→
   561→    // Get all markers
   562→    const allMarkers = await markers.getMarkers();
   563→    if (!allMarkers || allMarkers.length === 0) return 0;
   564→
   565→    // Filter SPLICE markers
   566→    const spliceMarkers = [];
   567→    for (const marker of allMarkers) {
   568→      const name = await marker.getName();
   569→      if (name && name.startsWith('SPLICE:')) {
   570→        spliceMarkers.push(marker);
   571→      }
   572→    }
   573→
   574→    if (spliceMarkers.length === 0) return 0;
   575→
   576→    // Remove all SPLICE markers in a single transaction
   577→    await project.lockedAccess(async () => {
   578→      await project.executeTransaction((compoundAction) => {
   579→        for (const marker of spliceMarkers) {
   580→          const removeAction = markers.createRemoveMarkerAction(marker);
   581→          compoundAction.addAction(removeAction);
   582→        }
   583→      }, 'SPLICE: Clear Markers');
   584→    });
   585→
   586→    console.log(`[SPLICE] Cleared ${spliceMarkers.length} previous markers`);
   587→    return spliceMarkers.length;
   588→
   589→  } catch (err) {
   590→    console.error('[SPLICE] Error clearing markers:', err);
   591→    return 0;
   592→  }
   593→}
   594→
   595→// ============================================================================
   596→// COMBINED PREVIEW (Silences + Takes with colored markers)
   597→// ============================================================================
   598→/**
   599→ * Show combined preview with:
   600→ * - Red markers: silences safe to remove
   601→ * - Yellow markers: silences protected by takes (won't be removed)
   602→ * - Blue markers: takes (for reference)
   603→ */
   604→function showCombinedPreview(safeToRemove, protectedSilences, takes) {
   605→  // Update global state
   606→  safeSilences = safeToRemove;
   607→  previewSilences = [...safeToRemove, ...protectedSilences];
   608→  previewTakes = takes;
   609→  selectedSilenceIndices = new Set(safeToRemove.map((_, i) => i));
   610→
   611→  // Hide other views
   612→  hideAllViews();
   613→
   614→  // Update summary counts
   615→  if (ui.silenceCountDisplay) ui.silenceCountDisplay.textContent = safeToRemove.length;
   616→  if (ui.takeCountDisplay) ui.takeCountDisplay.textContent = takes.length;
   617→  if (ui.selectedCount) ui.selectedCount.textContent = safeToRemove.length;
   618→
   619→  // Build combined items list (sorted by time)
   620→  const items = [
   621→    ...safeToRemove.map((s, i) => ({ type: 'silence', index: i, start: s.start, end: s.end, data: s })),
   622→    ...protectedSilences.map(s => ({ type: 'protected', start: s.start, end: s.end, data: s })),
   623→    ...takes.map(t => ({ type: 'take', start: t.startTime || t.start, end: t.endTime || t.end, data: t }))
   624→  ].sort((a, b) => a.start - b.start);
   625→
   626→  // Build preview list using DocumentFragment
   627→  const fragment = document.createDocumentFragment();
   628→
   629→  items.forEach((item) => {
   630→    const duration = item.end - item.start;
   631→    const div = document.createElement('div');
   632→
   633→    if (item.type === 'silence') {
   634→      // Safe to remove - red marker with checkbox
   635→      div.className = 'preview-item silence-marker';
   636→      div.dataset.index = item.index;
   637→      div.innerHTML = `
   638→        <input type="checkbox" class="preview-item-check" checked data-index="${item.index}">
   639→        <div class="preview-item-info">
   640→          <div class="preview-item-time">${formatTime(item.start)} - ${formatTime(item.end)}</div>
   641→          <div class="preview-item-duration">${duration.toFixed(2)}s silence</div>
   642→        </div>
   643→        <button class="preview-item-seek" data-time="${item.start}" title="Seek to this silence">&gt;</button>
   644→      `;
   645→    } else if (item.type === 'protected') {
   646→      // Protected by take - yellow marker, no checkbox
   647→      div.className = 'preview-item protected-silence';
   648→      div.innerHTML = `
   649→        <div style="width: 20px; margin-right: 10px;"></div>
   650→        <div class="preview-item-info">
   651→          <div class="preview-item-time">${formatTime(item.start)} - ${formatTime(item.end)}</div>
   652→          <div class="preview-item-duration">${duration.toFixed(2)}s (overlaps speech)</div>
   653→        </div>
   654→        <button class="preview-item-seek" data-time="${item.start}" title="Seek">&gt;</button>
   655→      `;
   656→    } else if (item.type === 'take') {
   657→      // Take (speech segment) - blue marker, no checkbox
   658→      div.className = 'preview-item take-marker';
   659→      const textPreview = item.data.text?.substring(0, 40) || 'Speech segment';
   660→      div.innerHTML = `
   661→        <div style="width: 20px; margin-right: 10px;"></div>
   662→        <div class="preview-item-info">
   663→          <div class="preview-item-time">${formatTime(item.start)} - ${formatTime(item.end)}</div>
   664→          <div class="preview-item-duration">${textPreview}${item.data.text?.length > 40 ? '...' : ''}</div>
   665→        </div>
   666→        <button class="preview-item-seek" data-time="${item.start}" title="Seek to take">&gt;</button>
   667→      `;
   668→    }
   669→
   670→    fragment.appendChild(div);
   671→  });
   672→
   673→  if (ui.previewList) {
   674→    ui.previewList.textContent = '';
   675→    ui.previewList.appendChild(fragment);
   676→  }
   677→
   678→  // Reset UI state
   679→  if (ui.selectAllSilences) ui.selectAllSilences.checked = true;
   680→  updateApplyButton();
   681→
   682→  // Show combined preview section
   683→  if (ui.combinedPreview) ui.combinedPreview.style.display = 'block';
   684→}
   685→
   686→function initPreviewHandlers() {
   687→  // EVENT DELEGATION: Single listener on parent instead of many on children
   688→  if (ui.previewList) {
   689→    // Handle checkbox changes
   690→    ui.previewList.addEventListener('change', (e) => {
   691→      if (e.target.classList.contains('preview-item-check')) {
   692→        const index = parseInt(e.target.dataset.index);
   693→        const item = e.target.closest('.preview-item');
   694→
   695→        if (e.target.checked) {
   696→          selectedSilenceIndices.add(index);
   697→          item?.classList.remove('excluded');
   698→        } else {
   699→          selectedSilenceIndices.delete(index);
   700→          item?.classList.add('excluded');
   701→        }
   702→        updateSelectionCounts();
   703→      }
   704→    });
   705→
   706→    // Handle seek button clicks
   707→    ui.previewList.addEventListener('click', async (e) => {
   708→      if (e.target.classList.contains('preview-item-seek')) {
   709→        e.stopPropagation();
   710→        const btn = e.target;
   711→        const time = parseFloat(btn.dataset.time);
   712→
   713→        // Show loading state
   714→        btn.classList.add('loading');
   715→        btn.textContent = '...';
   716→
   717→        try {
   718→          await seekToTime(time);
   719→        } finally {
   720→          btn.classList.remove('loading');
   721→          btn.textContent = '>';
   722→        }
   723→      }
   724→    });
   725→  }
   726→
   727→  // Apply button
   728→  if (ui.applyPreviewBtn) {
   729→    ui.applyPreviewBtn.addEventListener('click', async () => {
   730→      if (isOperationInProgress) return;
   731→      isOperationInProgress = true;
   732→      ui.applyPreviewBtn.disabled = true;
   733→
   734→      const originalText = ui.applyPreviewBtn.textContent;
   735→      ui.applyPreviewBtn.textContent = 'Applying...';
   736→
   737→      try {
   738→        await applySelectedSilences();
   739→      } catch (err) {
   740→        setStatus('Error: ' + err.message);
   741→        console.error('[SPLICE] Apply error:', err);
   742→      } finally {
   743→        ui.applyPreviewBtn.textContent = originalText;
   744→        ui.applyPreviewBtn.disabled = false;
   745→        isOperationInProgress = false;
   746→      }
   747→    });
   748→  }
   749→
   750→  // Cancel button
   751→  if (ui.cancelPreviewBtn) {
   752→    ui.cancelPreviewBtn.addEventListener('click', async () => {
   753→      await cancelPreview();
   754→    });
   755→  }
   756→
   757→  // Select all checkbox
   758→  if (ui.selectAllSilences) {
   759→    ui.selectAllSilences.addEventListener('change', (e) => {
   760→      selectAllSilences(e.target.checked);
   761→    });
   762→  }
   763→
   764→  // Invert selection button
   765→  if (ui.invertSelectionBtn) {
   766→    ui.invertSelectionBtn.addEventListener('click', () => {
   767→      invertSilenceSelection();
   768→    });
   769→  }
   770→
   771→  // Duration filter buttons
   772→  document.querySelectorAll('.preview-filters .filter-btn[data-min]').forEach(btn => {
   773→    btn.addEventListener('click', () => {
   774→      const min = parseFloat(btn.dataset.min);
   775→      const max = parseFloat(btn.dataset.max);
   776→      selectByDuration(min, max);
   777→    });
   778→  });
   779→
   780→  // Re-run detection button
   781→  if (ui.reRunDetectionBtn) {
   782→    ui.reRunDetectionBtn.addEventListener('click', () => {
   783→      // Hide preview, show options, let user adjust sensitivity
   784→      if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
   785→      if (ui.optionsPanel) ui.optionsPanel.classList.remove('collapsed');
   786→      if (ui.optionsToggle) ui.optionsToggle.classList.add('expanded');
   787→      showEmptyState();
   788→      setStatus('Adjust sensitivity and click GO again');
   789→    });
   790→  }
   791→
   792→  // Build Sequence button (v3.5 - direct DOM reconstruction)
   793→  if (ui.buildSequenceBtn) {
   794→    ui.buildSequenceBtn.addEventListener('click', async () => {
   795→      if (isOperationInProgress) return;
   796→
   797→      // Check if we have detection data
   798→      if (safeSilences.length === 0 && previewTakes.length === 0) {
   799→        setStatus('No detection data. Run analysis first.');
   800→        return;
   801→      }
   802→
   803→      isOperationInProgress = true;
   804→      ui.buildSequenceBtn.disabled = true;
   805→      const originalText = ui.buildSequenceBtn.textContent;
   806→      ui.buildSequenceBtn.textContent = 'Building...';
   807→
   808→      try {
   809→        showProgress('Building new sequence...');
   810→
   811→        const result = await buildSequenceWithCutList();
   812→
   813→        if (result.success) {
   814→          // Hide preview and show success
   815→          if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
   816→          showEmptyState();
   817→
   818→          const metadata = result.metadata || {};
   819→          setStatus(`New sequence created: ${metadata.silencesRemoved || 0} silences removed, ${metadata.takesDetected || 0} takes detected`);
   820→
   821→          // Clear markers after successful build
   822→          await clearSpliceMarkers();
   823→
   824→          // Clear preview state
   825→          previewSilences = [];
   826→          safeSilences = [];
   827→          protectedSilences = [];
   828→          previewTakes = [];
   829→          selectedSilenceIndices.clear();
   830→        } else {
   831→          setStatus('Build failed: ' + (result.error || 'Unknown error'));
   832→        }
   833→
   834→      } catch (err) {
   835→        console.error('[SPLICE] Build sequence error:', err);
   836→        setStatus('Build error: ' + err.message);
   837→      } finally {
   838→        ui.buildSequenceBtn.textContent = originalText;
   839→        ui.buildSequenceBtn.disabled = false;
   840→        isOperationInProgress = false;
   841→      }
   842→    });
   843→  }
   844→}
   845→
   846→function selectAllSilences(checked) {
   847→  selectedSilenceIndices.clear();
   848→
   849→  if (checked) {
   850→    safeSilences.forEach((_, i) => selectedSilenceIndices.add(i));
   851→  }
   852→
   853→  // Batch update DOM (only silence-marker items have checkboxes)
   854→  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {
   855→    const index = parseInt(checkbox.dataset.index);
   856→    checkbox.checked = checked;
   857→    const item = checkbox.closest('.preview-item');
   858→    if (checked) {
   859→      item?.classList.remove('excluded');
   860→    } else {
   861→      item?.classList.add('excluded');
   862→    }
   863→  });
   864→
   865→  updateSelectionCounts();
   866→}
   867→
   868→function invertSilenceSelection() {
   869→  const allIndices = new Set(safeSilences.map((_, i) => i));
   870→  const newSelection = new Set([...allIndices].filter(i => !selectedSilenceIndices.has(i)));
   871→  selectedSilenceIndices = newSelection;
   872→
   873→  // Update DOM
   874→  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {
   875→    const index = parseInt(checkbox.dataset.index);
   876→    const isSelected = selectedSilenceIndices.has(index);
   877→    checkbox.checked = isSelected;
   878→    const item = checkbox.closest('.preview-item');
   879→    if (isSelected) {
   880→      item?.classList.remove('excluded');
   881→    } else {
   882→      item?.classList.add('excluded');
   883→    }
   884→  });
   885→
   886→  updateSelectionCounts();
   887→}
   888→
   889→function selectByDuration(minSec, maxSec) {
   890→  selectedSilenceIndices.clear();
   891→
   892→  safeSilences.forEach((silence, index) => {
   893→    const duration = silence.end - silence.start;
   894→    if (duration >= minSec && duration < maxSec) {
   895→      selectedSilenceIndices.add(index);
   896→    }
   897→  });
   898→
   899→  // Update DOM
   900→  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {
   901→    const index = parseInt(checkbox.dataset.index);
   902→    const isSelected = selectedSilenceIndices.has(index);
   903→    checkbox.checked = isSelected;
   904→    const item = checkbox.closest('.preview-item');
   905→    if (isSelected) {
   906→      item?.classList.remove('excluded');
   907→    } else {
   908→      item?.classList.add('excluded');
   909→    }
   910→  });
   911→
   912→  updateSelectionCounts();
   913→  setStatus(`Selected ${selectedSilenceIndices.size} silences (${minSec}s - ${maxSec}s)`);
   914→}
   915→
   916→async function cancelPreview() {
   917→  // Keep silences available for Razor if detected
   918→  const hadSilences = safeSilences.length > 0;
   919→
   920→  previewSilences = [];
   921→  safeSilences = [];
   922→  protectedSilences = [];
   923→  previewTakes = [];
   924→  selectedSilenceIndices.clear();
   925→  showEmptyState();
   926→
   927→  // Clear timeline markers
   928→  const cleared = await clearSpliceMarkers();
   929→  const markerInfo = cleared > 0 ? ` (${cleared} markers removed)` : '';
   930→  setStatus('Preview cancelled' + markerInfo);
   931→
   932→  // Show Razor section if silences were detected
   933→  if (hadSilences && ui.advancedSection) {
   934→    ui.advancedSection.classList.remove('hidden');
   935→  }
   936→}
   937→
   938→async function applySelectedSilences() {
   939→  if (selectedSilenceIndices.size === 0) {
   940→    setStatus('No silences selected');
   941→    return;
   942→  }
   943→
   944→  showProgress('Reading marker positions...');
   945→
   946→  // Read current marker positions from timeline
   947→  // This allows users to manually adjust markers before applying
   948→  const markerSilences = await readMarkersAssilences();
   949→
   950→  let silencesToApply;
   951→  let adjustedCount = 0;
   952→
   953→  if (markerSilences.length > 0) {
   954→    // Use marker positions (may have been adjusted by user)
   955→    silencesToApply = markerSilences;
   956→    adjustedCount = markerSilences.length;
   957→    console.log(`[SPLICE] Using ${adjustedCount} silences from adjusted markers`);
   958→  } else {
   959→    // Fallback to original detection data
   960→    silencesToApply = safeSilences.filter((_, i) => selectedSilenceIndices.has(i));
   961→    console.log(`[SPLICE] Using ${silencesToApply.length} silences from original detection`);
   962→  }
   963→
   964→  if (silencesToApply.length === 0) {
   965→    setStatus('No silences to apply');
   966→    return;
   967→  }
   968→
   969→  // Update global silences for the apply function
   970→  setCurrentSilences(silencesToApply);
   971→
   972→  showProgress('Applying changes...');
   973→
   974→  // Apply to timeline
   975→  const result = await removeSilencesFromTimeline();
   976→
   977→  // Clear markers after applying
   978→  await clearSpliceMarkers();
   979→
   980→  // Hide preview
   981→  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
   982→
   983→  // Show results
   984→  showSilenceResults({
   985→    count: silencesToApply.length,
   986→    timeSaved: silencesToApply.reduce((sum, s) => sum + (s.end - s.start), 0),
   987→    clipsModified: result
   988→  });
   989→
   990→  // Show advanced section
   991→  if (ui.advancedSection) ui.advancedSection.classList.remove('hidden');
   992→
   993→  const adjustedInfo = adjustedCount > 0 ? ' (from adjusted markers)' : '';
   994→  setStatus(`Removed ${silencesToApply.length} silence(s) - ${result} clip(s) modified${adjustedInfo}`);
   995→
   996→  // Refresh credits (await to prevent race conditions)
   997→  try {
   998→    await refreshCredits();
   999→  } catch (err) {
  1000→    console.warn('[SPLICE] Credits refresh failed:', err);
  1001→  }
  1002→
  1003→  // Clear preview state
  1004→  previewSilences = [];
  1005→  safeSilences = [];
  1006→  protectedSilences = [];
  1007→  previewTakes = [];
  1008→  selectedSilenceIndices.clear();
  1009→}
  1010→
  1011→// ============================================================================
  1012→// UI HELPERS
  1013→// ============================================================================
  1014→function updateApplyButton() {
  1015→  if (ui.applyPreviewBtn) {
  1016→    const count = selectedSilenceIndices.size;
  1017→    ui.applyPreviewBtn.disabled = count === 0;
  1018→    ui.applyPreviewBtn.textContent = count === 0 ? 'Select silences' : `Apply ${count} Selected`;
  1019→  }
  1020→}
  1021→
  1022→function updateSelectAllCheckbox() {
  1023→  if (ui.selectAllSilences) {
  1024→    ui.selectAllSilences.checked = selectedSilenceIndices.size === safeSilences.length && safeSilences.length > 0;
  1025→  }
  1026→}
  1027→
  1028→function hideAllViews() {
  1029→  if (ui.progressContainer) ui.progressContainer.style.display = 'none';
  1030→  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'none';
  1031→  if (ui.silenceResults) ui.silenceResults.style.display = 'none';
  1032→  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';
  1033→}
  1034→
  1035→function showProgress(message) {
  1036→  hideAllViews();
  1037→  if (ui.progressContainer) ui.progressContainer.style.display = 'block';
  1038→  if (ui.progressText) ui.progressText.textContent = message;
  1039→}
  1040→
  1041→function showEmptyState() {
  1042→  hideAllViews();
  1043→  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'block';
  1044→  if (ui.advancedSection) ui.advancedSection.classList.add('hidden');
  1045→}
  1046→
  1047→function showSilenceResults({ count, timeSaved, clipsModified }) {
  1048→  hideAllViews();
  1049→
  1050→  // Update the results display
  1051→  if (ui.resultsCount) ui.resultsCount.textContent = count;
  1052→  if (ui.timeSaved) ui.timeSaved.textContent = timeSaved.toFixed(1) + 's';
  1053→  if (ui.clipsModified) ui.clipsModified.textContent = clipsModified;
  1054→
  1055→  if (ui.silenceResults) ui.silenceResults.style.display = 'block';
  1056→}
  1057→
  1058→function formatTime(seconds) {
  1059→  if (typeof seconds !== 'number' || isNaN(seconds)) return '0:00';
  1060→  const mins = Math.floor(seconds / 60);
  1061→  const secs = Math.floor(seconds % 60);
  1062→  return `${mins}:${secs.toString().padStart(2, '0')}`;
  1063→}
  1064→
  1065→function setStatus(message) {
  1066→  if (ui.status) ui.status.textContent = message;
  1067→}
  1068→
  1069→// ============================================================================
  1070→// UNDO HANDLERS
  1071→// ============================================================================
  1072→function initUndoHandlers() {
  1073→  if (ui.undoBtn) {
  1074→    ui.undoBtn.addEventListener('click', () => {
  1075→      try {
  1076→        ppro.app.executeCommand('Edit.Undo');
  1077→        showEmptyState();
  1078→        setStatus('Changes undone');
  1079→      } catch (e) {
  1080→        setStatus('Undo failed - use Cmd+Z');
  1081→      }
  1082→    });
  1083→  }
  1084→}
  1085→
  1086→// ============================================================================
  1087→// MEDIA FOLDER HANDLERS (v3.5)
  1088→// ============================================================================
  1089→function initMediaFolderHandlers() {
  1090→  // Update display on load
  1091→  updateMediaFolderDisplay();
  1092→
  1093→  // Set media folder button
  1094→  if (ui.setMediaFolderBtn) {
  1095→    ui.setMediaFolderBtn.addEventListener('click', async () => {
  1096→      ui.setMediaFolderBtn.disabled = true;
  1097→      ui.setMediaFolderBtn.textContent = 'Selecting...';
  1098→
  1099→      try {
  1100→        const result = await setupMediaFolder();
  1101→        if (result.success) {
  1102→          updateMediaFolderDisplay();
  1103→          setStatus(`Media folder set: ${result.path}`);
  1104→        } else {
  1105→          setStatus(result.error || 'Failed to set media folder');
  1106→        }
  1107→      } catch (err) {
  1108→        setStatus('Error: ' + err.message);
  1109→      } finally {
  1110→        ui.setMediaFolderBtn.disabled = false;
  1111→        ui.setMediaFolderBtn.textContent = 'Set Folder';
  1112→      }
  1113→    });
  1114→  }
  1115→
  1116→  // Clear media folder button
  1117→  if (ui.clearMediaFolderBtn) {
  1118→    ui.clearMediaFolderBtn.addEventListener('click', () => {
  1119→      clearMediaFolder();
  1120→      updateMediaFolderDisplay();
  1121→      setStatus('Media folder cleared');
  1122→    });
  1123→  }
  1124→}
  1125→
  1126→function updateMediaFolderDisplay() {
  1127→  if (ui.mediaFolderDisplay) {
  1128→    const path = getMediaFolderPath();
  1129→    if (path) {
  1130→      // Truncate long paths for display
  1131→      const displayPath = path.length > 40
  1132→        ? '...' + path.slice(-37)
  1133→        : path;
  1134→      ui.mediaFolderDisplay.textContent = displayPath;
  1135→      ui.mediaFolderDisplay.title = path; // Full path on hover
  1136→      ui.mediaFolderDisplay.style.color = '#4a9eff';
  1137→    } else {
  1138→      ui.mediaFolderDisplay.textContent = 'Not configured';
  1139→      ui.mediaFolderDisplay.title = '';
  1140→      ui.mediaFolderDisplay.style.color = '#888';
  1141→    }
  1142→  }
  1143→}
  1144→
  1145→// ============================================================================
  1146→// BUILD SEQUENCE (v3.5 - Direct DOM Reconstruction)
  1147→// ============================================================================
  1148→
  1149→// 1. ROBUST CONSTANTS (Fixes 'undefined' error)
  1150→// We define these integers explicitly because UXP API versions vary on where they store Enums.
  1151→const ProjectItemType = {
  1152→    CLIP: 1,
  1153→    BIN: 2,
  1154→    ROOT: 3,
  1155→    FILE: 4
  1156→};
  1157→
  1158→/**
  1159→ * Find the first media item in the project bin (recursively)
  1160→ * @param {Object} item - ProjectItem (usually rootItem)
  1161→ * @returns {Promise<Object|null>} First media item found or null
  1162→ */
  1163→async function findFirstMediaItem(item) {
  1164→  if (!item) return null;
  1165→
  1166→  // Fix: Use local Constant instead of app.Constants.ProjectItemType
  1167→  if (item.type === ProjectItemType.CLIP) {
  1168→    return item;
  1169→  }
  1170→
  1171→  // Search Children (Bin or Root)
  1172→  // Note: item.children is a collection, check numItems
  1173→  if (item.children && item.children.numItems > 0) {
  1174→    for (let i = 0; i < item.children.numItems; i++) {
  1175→      const child = item.children[i];
  1176→      const found = await findFirstMediaItem(child);
  1177→      if (found) return found;
  1178→    }
  1179→  }
  1180→
  1181→  return null;
  1182→}
  1183→
  1184→/**
  1185→ * Build a sequence from detection data locally
  1186→ * Used for testing via console: await buildSequenceV35(silences)
  1187→ */
  1188→async function buildSequenceV35(silences, takes = []) {
  1189→    if (!window.spliceBuilder) {
  1190→        throw new Error('Builder not initialized. Check if builder.js is loaded.');
  1191→    }
  1192→
  1193→    const app = require('premierepro');
  1194→    const project = await app.Project.getActiveProject();
  1195→    if (!project) throw new Error("No active project found.");
  1196→
  1197→    const rootItem = await project.getRootItem();
  1198→    const sourceProjectItem = await findFirstMediaItem(rootItem);
  1199→
  1200→    if (!sourceProjectItem) {
  1201→        throw new Error('No media items found in project bin.');
  1202→    }
  1203→
  1204→    console.log(`[SPLICE] Found source media: ${sourceProjectItem.name}`);
  1205→
  1206→    return await window.spliceBuilder.buildSequenceFromDetection(silences, takes, sourceProjectItem);
  1207→}
  1208→
  1209→/**
  1210→ * Request a cut list from the backend and build the sequence.
  1211→ * Full v3.5 workflow.
  1212→ */
  1213→async function buildSequenceWithCutList() {
  1214→  if (!window.spliceBuilder) {
  1215→    throw new Error('Builder not initialized');
  1216→  }
  1217→
  1218→  // Ensure BACKEND_URL is available
  1219→  const apiUrl = (typeof BACKEND_URL !== 'undefined') ? BACKEND_URL : 'http://localhost:3000';
  1220→
  1221→  if (typeof showProgress === 'function') showProgress('Getting source clip info...');
  1222→
  1223→  const app = require('premierepro');
  1224→  const project = await app.Project.getActiveProject();
  1225→  if (!project) throw new Error("No active project.");
  1226→
  1227→  const rootItem = await project.getRootItem();
  1228→  const sourceProjectItem = await findFirstMediaItem(rootItem);
  1229→
  1230→  if (!sourceProjectItem) {
  1231→    throw new Error('No media items found in project. Please import a media file first.');
  1232→  }
  1233→
  1234→  // Use properties strictly
  1235→  const sourceName = sourceProjectItem.name;
  1236→  const sourcePath = sourceProjectItem.treePath;
  1237→
  1238→  const durationObj = await sourceProjectItem.getDuration();
  1239→  const duration = durationObj ? durationObj.seconds : 0;
  1240→
  1241→  // Retrieve Globals
  1242→  const silences = window.splicePreviewState?.getSelectedSilences() || (typeof safeSilences !== 'undefined' ? safeSilences : []);
  1243→  const takes = (typeof previewTakes !== 'undefined' ? previewTakes : []);
  1244→
  1245→  if (silences.length === 0 && (!takes || takes.length === 0)) {
  1246→     throw new Error('No detection data found. Run analysis first.');
  1247→  }
  1248→
  1249→  if (typeof showProgress === 'function') showProgress('Generating cut list...');
  1250→
  1251→  const response = await fetch(`${apiUrl}/cut-list`, {
  1252→    method: 'POST',
  1253→    headers: { 'Content-Type': 'application/json' },
  1254→    body: JSON.stringify({
  1255→      sourceName,
  1256→      sourcePath,
  1257→      duration,
  1258→      silences,
  1259→      takes
  1260→    })
  1261→  });
  1262→
  1263→  if (!response.ok) {
  1264→    const err = await response.json();
  1265→    throw new Error(err.error || 'Failed to generate cut list');
  1266→  }
  1267→
  1268→  const data = await response.json();
  1269→  const cutList = data.cutList;
  1270→
  1271→  if (typeof showProgress === 'function') showProgress('Building sequence...');
  1272→
  1273→  const result = await window.spliceBuilder.buildSequenceFromCutList(cutList, sourceProjectItem);
  1274→
  1275→  if (!result.success) {
  1276→    throw new Error(result.error || 'Failed to build sequence');
  1277→  }
  1278→
  1279→  return {
  1280→    success: true,
  1281→    clipsAdded: result.clipsAdded,
  1282→    metadata: cutList.metadata
  1283→  };
  1284→}
  1285→
  1286→// Expose functions globally for UI and testing
  1287→if (typeof window !== 'undefined') {
  1288→    window.buildSequenceV35 = buildSequenceV35;
  1289→    window.buildSequenceWithCutList = buildSequenceWithCutList;
  1290→    window.findFirstMediaItem = findFirstMediaItem;
  1291→}
  1292→
  1293→// ============================================================================
  1294→// TIMELINE SEEK (with proper error handling)
  1295→// ============================================================================
  1296→async function seekToTime(seconds) {
  1297→  // Validate input
  1298→  if (typeof seconds !== 'number' || isNaN(seconds) || !isFinite(seconds)) {
  1299→    setStatus('Invalid seek time');
  1300→    return;
  1301→  }
  1302→
  1303→  if (seconds < 0) {
  1304→    seconds = 0;
  1305→  }
  1306→
  1307→  try {
  1308→    const context = await getActiveSequence();
  1309→    if (!context) {
  1310→      setStatus('No sequence available');
  1311→      return;
  1312→    }
  1313→
  1314→    const { sequence } = context;
  1315→
  1316→    // Use TickTime API to convert seconds to the format needed
  1317→    const position = ppro.TickTime.createWithSeconds(seconds);
  1318→
  1319→    await sequence.setPlayerPosition(position);
  1320→    setStatus(`Seeked to ${formatTime(seconds)}`);
  1321→  } catch (err) {
  1322→    console.error('[SPLICE] Seek error:', err);
  1323→    setStatus('Seek failed: ' + (err.message || 'Unknown error'));
  1324→  }
  1325→}
  1326→
  1327→// ============================================================================
  1328→// AUDIO EXPORT & BACKEND CALLS
  1329→// ============================================================================
  1330→async function exportAudioInternal() {
  1331→  try {
  1332→    const context = await getActiveSequence();
  1333→    if (!context) {
  1334→      throw new Error('No project or sequence open');
  1335→    }
  1336→
  1337→    const { sequence } = context;
  1338→    const encoderManager = ppro.EncoderManager.getManager();
  1339→    if (!encoderManager) {
  1340→      throw new Error('EncoderManager not available');
  1341→    }
  1342→
  1343→    const result = await encoderManager.exportSequence(
  1344→      sequence,
  1345→      ppro.EncoderManager.EXPORT_IMMEDIATELY,
  1346→      WAV_PATH,
  1347→      WAV_PRESET_PATH,
  1348→      true
  1349→    );
  1350→
  1351→    return result;
  1352→  } catch (err) {
  1353→    console.error('[SPLICE] Export error:', err);
  1354→    return false;
  1355→  }
  1356→}
  1357→
  1358→async function isolateVocals() {
  1359→  const response = await fetch(`${BACKEND_URL}/isolate-vocals`, {
  1360→    method: 'POST',
  1361→    headers: { 'Content-Type': 'application/json' },
  1362→    body: JSON.stringify({ audioPath: WAV_PATH })
  1363→  });
  1364→
  1365→  if (!response.ok) {
  1366→    const err = await response.json();
  1367→    return { success: false, error: err.error || 'Isolation request failed' };
  1368→  }
  1369→
  1370→  return await response.json();
  1371→}
  1372→
  1373→async function detectSilences(audioPath, params) {
  1374→  const response = await fetch(`${BACKEND_URL}/silences-audio`, {
  1375→    method: 'POST',
  1376→    headers: { 'Content-Type': 'application/json' },
  1377→    body: JSON.stringify({
  1378→      wavPath: audioPath,
  1379→      threshold: params.dbThreshold,
  1380→      minDuration: params.minDuration,
  1381→      padding: params.padding
  1382→    })
  1383→  });
  1384→
  1385→  if (!response.ok) {
  1386→    const err = await response.json();
  1387→    throw new Error(err.error || 'Silence detection failed');
  1388→  }
  1389→
  1390→  const data = await response.json();
  1391→  if (!data.success) {
  1392→    throw new Error(data.error || 'Silence detection failed');
  1393→  }
  1394→
  1395→  // Store silences globally for razor workflow
  1396→  currentSilences = data.silences;
  1397→
  1398→  return data.silences;
  1399→}
  1400→
  1401→async function transcribeAudio() {
  1402→  const response = await fetch(`${BACKEND_URL}/analyze`, {
  1403→    method: 'POST',
  1404→    headers: { 'Content-Type': 'application/json' },
  1405→    body: JSON.stringify({ wavPath: WAV_PATH })
  1406→  });
  1407→
  1408→  if (!response.ok) {
  1409→    const err = await response.json();
  1410→    return { success: false, error: err.error || 'Transcription failed' };
  1411→  }
  1412→
  1413→  const data = await response.json();
  1414→  return {
  1415→    success: data.success,
  1416→    transcript: data.transcript,
  1417→    takes: data.takes,
  1418→    error: data.error
  1419→  };
  1420→}
  1421→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
