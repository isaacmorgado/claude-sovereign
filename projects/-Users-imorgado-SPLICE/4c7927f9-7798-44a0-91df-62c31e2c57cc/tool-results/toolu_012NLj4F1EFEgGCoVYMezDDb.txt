     1→/**
     2→ * SPLICE CEP Panel - Multitrack UI Module
     3→ * Multi-speaker analysis, auto-balance, and timeline building
     4→ * v4.0.0 - CEP Migration
     5→ */
     6→
     7→// ============================================================================
     8→// STATE
     9→// ============================================================================
    10→let speakerConfig = [];
    11→let analysisResults = null;
    12→let isMultitrackOperationInProgress = false;
    13→
    14→// Speaker colors for visual distinction
    15→const SPEAKER_COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
    16→
    17→// ============================================================================
    18→// DOM ELEMENT CACHE
    19→// ============================================================================
    20→const multitrackUI = {};
    21→
    22→function cacheMultitrackElements() {
    23→    multitrackUI.section = document.getElementById('multitrackSection');
    24→    multitrackUI.toggle = document.getElementById('multitrackToggle');
    25→    multitrackUI.panel = document.getElementById('multitrackPanel');
    26→    multitrackUI.speakerList = document.getElementById('speakerList');
    27→    multitrackUI.addSpeakerBtn = document.getElementById('addSpeakerBtn');
    28→    multitrackUI.wideShotTrack = document.getElementById('wideShotTrack');
    29→
    30→    // Parameters
    31→    multitrackUI.minShotDuration = document.getElementById('minShotDuration');
    32→    multitrackUI.minShotDurationValue = document.getElementById('minShotDurationValue');
    33→    multitrackUI.wideShotPercent = document.getElementById('wideShotPercent');
    34→    multitrackUI.wideShotPercentValue = document.getElementById('wideShotPercentValue');
    35→    multitrackUI.switchingFrequency = document.getElementById('switchingFrequency');
    36→    multitrackUI.switchingFrequencyValue = document.getElementById('switchingFrequencyValue');
    37→    multitrackUI.enableWideShotDetection = document.getElementById('enableWideShotDetection');
    38→
    39→    // Actions
    40→    multitrackUI.analyzeBtn = document.getElementById('analyzeMultitrackBtn');
    41→    multitrackUI.autoBalanceBtn = document.getElementById('autoBalanceBtn');
    42→    multitrackUI.applyBtn = document.getElementById('applyMultitrackBtn');
    43→
    44→    // Preview
    45→    multitrackUI.preview = document.getElementById('multitrackPreview');
    46→    multitrackUI.distributionChart = document.getElementById('distributionChart');
    47→    multitrackUI.speakerStats = document.getElementById('speakerStats');
    48→    multitrackUI.decisionCount = document.getElementById('decisionCount');
    49→    multitrackUI.decisionList = document.getElementById('decisionList');
    50→}
    51→
    52→// ============================================================================
    53→// INITIALIZATION
    54→// ============================================================================
    55→function initMultitrackUI() {
    56→    cacheMultitrackElements();
    57→
    58→    if (!multitrackUI.section) {
    59→        console.warn('[SPLICE Multitrack] Multitrack section not found in DOM');
    60→        return;
    61→    }
    62→
    63→    // Toggle section expand/collapse
    64→    if (multitrackUI.toggle) {
    65→        multitrackUI.toggle.addEventListener('click', toggleMultitrackSection);
    66→    }
    67→
    68→    // Add speaker button
    69→    if (multitrackUI.addSpeakerBtn) {
    70→        multitrackUI.addSpeakerBtn.addEventListener('click', addSpeaker);
    71→    }
    72→
    73→    // Speaker list event delegation (remove buttons, name changes)
    74→    if (multitrackUI.speakerList) {
    75→        multitrackUI.speakerList.addEventListener('click', handleSpeakerListClick);
    76→        multitrackUI.speakerList.addEventListener('change', handleSpeakerListChange);
    77→    }
    78→
    79→    // Parameter sliders
    80→    setupParameterListeners();
    81→
    82→    // Action buttons
    83→    if (multitrackUI.analyzeBtn) {
    84→        multitrackUI.analyzeBtn.addEventListener('click', analyzeMultitrack);
    85→    }
    86→    if (multitrackUI.autoBalanceBtn) {
    87→        multitrackUI.autoBalanceBtn.addEventListener('click', autoBalanceMultitrack);
    88→    }
    89→    if (multitrackUI.applyBtn) {
    90→        multitrackUI.applyBtn.addEventListener('click', applyMultitrackCuts);
    91→    }
    92→
    93→    // Decision list event delegation (seek buttons)
    94→    if (multitrackUI.decisionList) {
    95→        multitrackUI.decisionList.addEventListener('click', handleDecisionListClick);
    96→    }
    97→
    98→    // Initialize speaker config from DOM
    99→    initSpeakerConfigFromDOM();
   100→
   101→    console.log('[SPLICE Multitrack] UI initialized');
   102→}
   103→
   104→// ============================================================================
   105→// SECTION TOGGLE
   106→// ============================================================================
   107→function toggleMultitrackSection() {
   108→    if (!multitrackUI.panel || !multitrackUI.toggle) return;
   109→
   110→    // Check state BEFORE toggling
   111→    const wasCollapsed = multitrackUI.panel.classList.contains('collapsed');
   112→    multitrackUI.panel.classList.toggle('collapsed');
   113→    const icon = multitrackUI.toggle.querySelector('.toggle-icon');
   114→
   115→    if (icon) {
   116→        // If it was collapsed, it's now expanded (show -)
   117→        icon.textContent = wasCollapsed ? '-' : '+';
   118→    }
   119→}
   120→
   121→// ============================================================================
   122→// SPEAKER CONFIGURATION
   123→// ============================================================================
   124→function initSpeakerConfigFromDOM() {
   125→    speakerConfig = [];
   126→    const items = multitrackUI.speakerList?.querySelectorAll('.speaker-item') || [];
   127→
   128→    items.forEach((item, index) => {
   129→        const nameInput = item.querySelector('.speaker-name');
   130→        const trackSelect = item.querySelector('.speaker-track');
   131→
   132→        speakerConfig.push({
   133→            index,
   134→            name: nameInput?.value || `Speaker ${index + 1}`,
   135→            videoTrack: parseInt(trackSelect?.value || index)
   136→        });
   137→    });
   138→}
   139→
   140→function addSpeaker() {
   141→    if (speakerConfig.length >= 4) {
   142→        setStatus('Maximum 4 speakers supported');
   143→        return;
   144→    }
   145→
   146→    const newIndex = speakerConfig.length;
   147→    const defaultName = `Speaker ${newIndex + 1}`;
   148→
   149→    speakerConfig.push({
   150→        index: newIndex,
   151→        name: defaultName,
   152→        videoTrack: newIndex
   153→    });
   154→
   155→    // Add DOM element
   156→    // SECURITY: Escape dynamic content to prevent XSS
   157→    const speakerItem = document.createElement('div');
   158→    speakerItem.className = `speaker-item speaker-${newIndex}`;
   159→    speakerItem.dataset.speakerIndex = newIndex;
   160→    speakerItem.innerHTML = `
   161→        <input type="text" class="speaker-name" value="${escapeHtml(defaultName)}" placeholder="Name" aria-label="Speaker ${newIndex + 1} name">
   162→        <select class="speaker-track" aria-label="Speaker ${newIndex + 1} video track">
   163→            <option value="0" ${newIndex === 0 ? 'selected' : ''}>V1</option>
   164→            <option value="1" ${newIndex === 1 ? 'selected' : ''}>V2</option>
   165→            <option value="2" ${newIndex === 2 ? 'selected' : ''}>V3</option>
   166→            <option value="3" ${newIndex === 3 ? 'selected' : ''}>V4</option>
   167→        </select>
   168→        <button class="speaker-remove-btn" title="Remove speaker" aria-label="Remove speaker ${newIndex + 1}">x</button>
   169→    `;
   170→
   171→    multitrackUI.speakerList.appendChild(speakerItem);
   172→
   173→    // Update remove button visibility
   174→    updateRemoveButtonVisibility();
   175→}
   176→
   177→function removeSpeaker(index) {
   178→    if (speakerConfig.length <= 2) {
   179→        setStatus('Minimum 2 speakers required');
   180→        return;
   181→    }
   182→
   183→    speakerConfig.splice(index, 1);
   184→
   185→    // Remove from DOM
   186→    const item = multitrackUI.speakerList.querySelector(`[data-speaker-index="${index}"]`);
   187→    if (item) {
   188→        item.remove();
   189→    }
   190→
   191→    // Re-index remaining speakers
   192→    reindexSpeakers();
   193→
   194→    // Update remove button visibility
   195→    updateRemoveButtonVisibility();
   196→}
   197→
   198→function reindexSpeakers() {
   199→    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
   200→    items.forEach((item, i) => {
   201→        item.dataset.speakerIndex = i;
   202→        item.className = `speaker-item speaker-${i}`;
   203→
   204→        // Update speakerConfig
   205→        if (speakerConfig[i]) {
   206→            speakerConfig[i].index = i;
   207→        }
   208→    });
   209→}
   210→
   211→function updateRemoveButtonVisibility() {
   212→    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
   213→    const canRemove = items.length > 2;
   214→
   215→    items.forEach(item => {
   216→        const btn = item.querySelector('.speaker-remove-btn');
   217→        if (btn) {
   218→            btn.style.display = canRemove ? 'block' : 'none';
   219→        }
   220→    });
   221→}
   222→
   223→function handleSpeakerListClick(e) {
   224→    const removeBtn = e.target.closest('.speaker-remove-btn');
   225→    if (removeBtn) {
   226→        const item = removeBtn.closest('.speaker-item');
   227→        const index = parseInt(item?.dataset.speakerIndex || 0);
   228→        removeSpeaker(index);
   229→    }
   230→}
   231→
   232→function handleSpeakerListChange(e) {
   233→    const item = e.target.closest('.speaker-item');
   234→    if (!item) return;
   235→
   236→    const index = parseInt(item.dataset.speakerIndex || 0);
   237→
   238→    if (e.target.classList.contains('speaker-name')) {
   239→        speakerConfig[index].name = e.target.value;
   240→    } else if (e.target.classList.contains('speaker-track')) {
   241→        speakerConfig[index].videoTrack = parseInt(e.target.value);
   242→    }
   243→}
   244→
   245→// ============================================================================
   246→// PARAMETER LISTENERS
   247→// ============================================================================
   248→function setupParameterListeners() {
   249→    // Min shot duration slider
   250→    if (multitrackUI.minShotDuration && multitrackUI.minShotDurationValue) {
   251→        multitrackUI.minShotDuration.addEventListener('input', () => {
   252→            multitrackUI.minShotDurationValue.textContent =
   253→                parseFloat(multitrackUI.minShotDuration.value).toFixed(1) + 's';
   254→        });
   255→    }
   256→
   257→    // Wide shot percentage slider
   258→    if (multitrackUI.wideShotPercent && multitrackUI.wideShotPercentValue) {
   259→        multitrackUI.wideShotPercent.addEventListener('input', () => {
   260→            multitrackUI.wideShotPercentValue.textContent =
   261→                multitrackUI.wideShotPercent.value + '%';
   262→        });
   263→    }
   264→
   265→    // Switching frequency slider
   266→    if (multitrackUI.switchingFrequency && multitrackUI.switchingFrequencyValue) {
   267→        multitrackUI.switchingFrequency.addEventListener('input', () => {
   268→            multitrackUI.switchingFrequencyValue.textContent =
   269→                multitrackUI.switchingFrequency.value;
   270→        });
   271→    }
   272→}
   273→
   274→// ============================================================================
   275→// GET SETTINGS
   276→// ============================================================================
   277→function getMultitrackSettings() {
   278→    return {
   279→        minShotDuration: parseFloat(multitrackUI.minShotDuration?.value || 2),
   280→        wideShotPercentage: parseInt(multitrackUI.wideShotPercent?.value || 20),
   281→        switchingFrequency: parseInt(multitrackUI.switchingFrequency?.value || 50),
   282→        wideShotEnabled: multitrackUI.enableWideShotDetection?.checked ?? true,
   283→        wideShotTracks: multitrackUI.wideShotTrack?.value !== '-1'
   284→            ? [parseInt(multitrackUI.wideShotTrack.value)]
   285→            : [],
   286→        speakerNames: speakerConfig.map(s => s.name),
   287→        videoTrackMapping: speakerConfig.reduce((acc, s) => {
   288→            acc[s.index] = s.videoTrack;
   289→            return acc;
   290→        }, {})
   291→    };
   292→}
   293→
   294→// ============================================================================
   295→// GET AUDIO PATH (CEP VERSION)
   296→// ============================================================================
   297→async function getAudioPath() {
   298→    try {
   299→        // Try to get audio path from active sequence
   300→        const seqInfo = await jsx.call('getActiveSequence');
   301→        if (seqInfo && seqInfo.audioPath) {
   302→            return seqInfo.audioPath;
   303→        }
   304→
   305→        // Fallback: export sequence audio for analysis
   306→        const exportResult = await jsx.call('exportSequenceAudioForAnalysis');
   307→        if (exportResult && exportResult.path) {
   308→            return exportResult.path;
   309→        }
   310→
   311→        // Last resort: get first clip audio path
   312→        const clipPath = await jsx.call('getFirstClipAudioPath');
   313→        if (clipPath) {
   314→            return clipPath;
   315→        }
   316→
   317→        throw new Error('Could not determine audio path');
   318→    } catch (e) {
   319→        console.error('[SPLICE Multitrack] Failed to get audio path:', e);
   320→        throw e;
   321→    }
   322→}
   323→
   324→// ============================================================================
   325→// ANALYZE MULTITRACK
   326→// ============================================================================
   327→async function analyzeMultitrack() {
   328→    if (isMultitrackOperationInProgress) return;
   329→
   330→    // Check tier access - Multitrack requires Team tier
   331→    if (typeof hasFeatureAccess === 'function' && !hasFeatureAccess('multitrack')) {
   332→        const requiredTier = typeof getRequiredTier === 'function' ? getRequiredTier('multitrack') : 'Team';
   333→        setStatus(`Multitrack auto-balance requires ${requiredTier} tier`);
   334→        if (typeof showUpgradeModal === 'function') {
   335→            showUpgradeModal('Multitrack Auto-Balance', requiredTier);
   336→        }
   337→        return;
   338→    }
   339→
   340→    // Check online status
   341→    if (typeof isOnline === 'function' && !isOnline()) {
   342→        setStatus('Offline - Check your connection');
   343→        return;
   344→    }
   345→
   346→    isMultitrackOperationInProgress = true;
   347→    if (multitrackUI.analyzeBtn) {
   348→        multitrackUI.analyzeBtn.disabled = true;
   349→        multitrackUI.analyzeBtn.textContent = 'Analyzing...';
   350→    }
   351→
   352→    try {
   353→        setStatus('Exporting audio tracks...');
   354→
   355→        // Get audio path
   356→        const audioPath = await getAudioPath();
   357→        if (!audioPath) {
   358→            throw new Error('Audio export path not initialized');
   359→        }
   360→
   361→        // For now, we use the main audio path
   362→        // In a full implementation, we'd export separate tracks per speaker
   363→        const audioPaths = [audioPath];
   364→
   365→        // Add additional tracks if multi-track sequence
   366→        if (speakerConfig.length > 1) {
   367→            for (let i = 1; i < speakerConfig.length; i++) {
   368→                audioPaths.push(audioPath);
   369→            }
   370→        }
   371→
   372→        setStatus('Analyzing speakers...');
   373→
   374→        const settings = getMultitrackSettings();
   375→        const apiUrl = getBackendUrl();
   376→
   377→        const response = await fetchWithTimeout(`${apiUrl}/multitrack`, {
   378→            method: 'POST',
   379→            headers: getAuthHeaders(),
   380→            body: JSON.stringify({
   381→                audioPaths,
   382→                speakerNames: settings.speakerNames,
   383→                videoTrackMapping: settings.videoTrackMapping,
   384→                wideShotEnabled: settings.wideShotEnabled,
   385→                wideShotPercentage: settings.wideShotPercentage,
   386→                wideShotTracks: settings.wideShotTracks,
   387→                minShotDuration: settings.minShotDuration,
   388→                switchingFrequency: settings.switchingFrequency
   389→            })
   390→        }, 120000);
   391→
   392→        if (!response.ok) {
   393→            const errorMsg = await parseErrorResponse(response);
   394→            throw new Error(errorMsg);
   395→        }
   396→
   397→        const data = await response.json();
   398→        analysisResults = data;
   399→
   400→        // Display results
   401→        displayMultitrackResults(data);
   402→
   403→        // Enable apply button
   404→        if (multitrackUI.applyBtn) {
   405→            multitrackUI.applyBtn.disabled = false;
   406→        }
   407→
   408→        setStatus(`Analysis complete - ${data.decisions?.length || 0} switching decisions`);
   409→
   410→    } catch (err) {
   411→        console.error('[SPLICE Multitrack] Analysis error:', err);
   412→        setStatus('Analysis failed: ' + err.message, true);
   413→    } finally {
   414→        isMultitrackOperationInProgress = false;
   415→        if (multitrackUI.analyzeBtn) {
   416→            multitrackUI.analyzeBtn.disabled = false;
   417→            multitrackUI.analyzeBtn.textContent = 'Analyze';
   418→        }
   419→    }
   420→}
   421→
   422→// ============================================================================
   423→// AUTO-BALANCE
   424→// ============================================================================
   425→async function autoBalanceMultitrack() {
   426→    if (isMultitrackOperationInProgress) return;
   427→
   428→    // Check tier access - Multitrack requires Team tier
   429→    if (typeof hasFeatureAccess === 'function' && !hasFeatureAccess('multitrack')) {
   430→        const requiredTier = typeof getRequiredTier === 'function' ? getRequiredTier('multitrack') : 'Team';
   431→        setStatus(`Multitrack auto-balance requires ${requiredTier} tier`);
   432→        if (typeof showUpgradeModal === 'function') {
   433→            showUpgradeModal('Multitrack Auto-Balance', requiredTier);
   434→        }
   435→        return;
   436→    }
   437→
   438→    // Check online status
   439→    if (typeof isOnline === 'function' && !isOnline()) {
   440→        setStatus('Offline - Check your connection');
   441→        return;
   442→    }
   443→
   444→    isMultitrackOperationInProgress = true;
   445→    if (multitrackUI.autoBalanceBtn) {
   446→        multitrackUI.autoBalanceBtn.disabled = true;
   447→        multitrackUI.autoBalanceBtn.textContent = 'Balancing...';
   448→    }
   449→
   450→    try {
   451→        setStatus('Auto-balancing speaker screentime...');
   452→
   453→        const audioPath = await getAudioPath();
   454→        const audioPaths = [audioPath];
   455→
   456→        // Duplicate for multiple speakers
   457→        for (let i = 1; i < speakerConfig.length; i++) {
   458→            audioPaths.push(audioPath);
   459→        }
   460→
   461→        const settings = getMultitrackSettings();
   462→        const apiUrl = getBackendUrl();
   463→
   464→        const response = await fetchWithTimeout(`${apiUrl}/multitrack/auto-balance`, {
   465→            method: 'POST',
   466→            headers: getAuthHeaders(),
   467→            body: JSON.stringify({
   468→                audioPaths,
   469→                speakerNames: settings.speakerNames,
   470→                videoTrackMapping: settings.videoTrackMapping,
   471→                wideShotEnabled: settings.wideShotEnabled,
   472→                wideShotPercentage: settings.wideShotPercentage,
   473→                wideShotTracks: settings.wideShotTracks,
   474→                minShotDuration: settings.minShotDuration,
   475→                switchingFrequency: settings.switchingFrequency
   476→            })
   477→        }, 120000);
   478→
   479→        if (!response.ok) {
   480→            const errorMsg = await parseErrorResponse(response);
   481→            throw new Error(errorMsg);
   482→        }
   483→
   484→        const data = await response.json();
   485→        analysisResults = data;
   486→
   487→        // Display results
   488→        displayMultitrackResults(data);
   489→
   490→        // Enable apply button
   491→        if (multitrackUI.applyBtn) {
   492→            multitrackUI.applyBtn.disabled = false;
   493→        }
   494→
   495→        const errorInfo = data.finalError ? ` (${data.finalError.toFixed(1)}% deviation)` : '';
   496→        setStatus(`Auto-balance complete${errorInfo}`);
   497→
   498→    } catch (err) {
   499→        console.error('[SPLICE Multitrack] Auto-balance error:', err);
   500→        setStatus('Auto-balance failed: ' + err.message, true);
   501→    } finally {
   502→        isMultitrackOperationInProgress = false;
   503→        if (multitrackUI.autoBalanceBtn) {
   504→            multitrackUI.autoBalanceBtn.disabled = false;
   505→            multitrackUI.autoBalanceBtn.textContent = 'Auto-Balance';
   506→        }
   507→    }
   508→}
   509→
   510→// ============================================================================
   511→// DISPLAY RESULTS
   512→// ============================================================================
   513→function displayMultitrackResults(results) {
   514→    if (!results) return;
   515→
   516→    // Show preview section
   517→    if (multitrackUI.preview) {
   518→        multitrackUI.preview.classList.remove('hidden');
   519→    }
   520→
   521→    // Render distribution chart
   522→    renderDistributionChart(results.metadata);
   523→
   524→    // Render speaker stats
   525→    renderSpeakerStats(results.metadata);
   526→
   527→    // Render decision list
   528→    renderDecisionList(results.decisions || []);
   529→}
   530→
   531→function renderDistributionChart(metadata) {
   532→    if (!multitrackUI.distributionChart || !metadata) return;
   533→
   534→    const speakerPercentages = metadata.speakerPercentages || {};
   535→    const wideShotPct = metadata.wideShotPercentage || 0;
   536→
   537→    const fragment = document.createDocumentFragment();
   538→
   539→    // Add speaker bars
   540→    let speakerIndex = 0;
   541→    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
   542→        if (pct > 0) {
   543→            const bar = document.createElement('div');
   544→            bar.className = `distribution-bar speaker-${speakerIndex % 4}`;
   545→            bar.style.width = `${pct}%`;
   546→            bar.textContent = pct >= 10 ? `${speaker}: ${pct.toFixed(0)}%` : '';
   547→            bar.title = `${speaker}: ${pct.toFixed(1)}%`;
   548→            fragment.appendChild(bar);
   549→        }
   550→        speakerIndex++;
   551→    }
   552→
   553→    // Add wide shot bar
   554→    if (wideShotPct > 0) {
   555→        const bar = document.createElement('div');
   556→        bar.className = 'distribution-bar wide-shot';
   557→        bar.style.width = `${wideShotPct}%`;
   558→        bar.textContent = wideShotPct >= 8 ? `Wide: ${wideShotPct.toFixed(0)}%` : '';
   559→        bar.title = `Wide Shot: ${wideShotPct.toFixed(1)}%`;
   560→        fragment.appendChild(bar);
   561→    }
   562→
   563→    multitrackUI.distributionChart.innerHTML = '';
   564→    multitrackUI.distributionChart.appendChild(fragment);
   565→}
   566→
   567→function renderSpeakerStats(metadata) {
   568→    if (!multitrackUI.speakerStats || !metadata) return;
   569→
   570→    const speakerPercentages = metadata.speakerPercentages || {};
   571→    const wideShotPct = metadata.wideShotPercentage || 0;
   572→
   573→    const fragment = document.createDocumentFragment();
   574→
   575→    // Add speaker stats
   576→    // SECURITY: Escape speaker names to prevent XSS
   577→    let speakerIndex = 0;
   578→    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
   579→        const stat = document.createElement('div');
   580→        stat.className = 'speaker-stat';
   581→        stat.innerHTML = `
   582→            <span class="speaker-stat-dot speaker-${speakerIndex % 4}"></span>
   583→            <span>${escapeHtml(speaker)}: ${escapeHtml(pct.toFixed(1))}%</span>
   584→        `;
   585→        fragment.appendChild(stat);
   586→        speakerIndex++;
   587→    }
   588→
   589→    // Add wide shot stat
   590→    if (wideShotPct > 0) {
   591→        const stat = document.createElement('div');
   592→        stat.className = 'speaker-stat';
   593→        stat.innerHTML = `
   594→            <span class="speaker-stat-dot wide-shot"></span>
   595→            <span>Wide: ${escapeHtml(wideShotPct.toFixed(1))}%</span>
   596→        `;
   597→        fragment.appendChild(stat);
   598→    }
   599→
   600→    // Add avg shot duration
   601→    if (metadata.averageShotDuration) {
   602→        const stat = document.createElement('div');
   603→        stat.className = 'speaker-stat';
   604→        stat.innerHTML = `<span style="color: #888;">Avg: ${escapeHtml(metadata.averageShotDuration.toFixed(1))}s</span>`;
   605→        fragment.appendChild(stat);
   606→    }
   607→
   608→    multitrackUI.speakerStats.innerHTML = '';
   609→    multitrackUI.speakerStats.appendChild(fragment);
   610→}
   611→
   612→function renderDecisionList(decisions) {
   613→    if (!multitrackUI.decisionList) return;
   614→
   615→    // Update count
   616→    if (multitrackUI.decisionCount) {
   617→        multitrackUI.decisionCount.textContent = decisions.length;
   618→    }
   619→
   620→    const fragment = document.createDocumentFragment();
   621→
   622→    // Limit to first 50 for performance
   623→    const displayDecisions = decisions.slice(0, 50);
   624→
   625→    displayDecisions.forEach((decision, i) => {
   626→        const item = document.createElement('div');
   627→        item.className = 'decision-item';
   628→
   629→        const speakerClass = decision.isWideShot ? 'wide-shot' : '';
   630→        const startTime = formatTime(decision.startTime);
   631→        const endTime = formatTime(decision.endTime);
   632→
   633→        // SECURITY: Escape dynamic content to prevent XSS
   634→        item.innerHTML = `
   635→            <span class="decision-time">${escapeHtml(startTime)}-${escapeHtml(endTime)}</span>
   636→            <span class="decision-speaker ${speakerClass}">${escapeHtml(decision.speakerName)}</span>
   637→            <span class="decision-reason">${escapeHtml(decision.reason || '')}</span>
   638→            <button class="decision-seek" data-time="${escapeHtml(decision.startTime)}" title="Seek to ${escapeHtml(startTime)}" aria-label="Seek to ${escapeHtml(startTime)}">&gt;</button>
   639→        `;
   640→
   641→        fragment.appendChild(item);
   642→    });
   643→
   644→    if (decisions.length > 50) {
   645→        const more = document.createElement('div');
   646→        more.className = 'decision-item';
   647→        more.style.justifyContent = 'center';
   648→        more.style.color = '#888';
   649→        more.textContent = `+ ${decisions.length - 50} more decisions`;
   650→        fragment.appendChild(more);
   651→    }
   652→
   653→    multitrackUI.decisionList.innerHTML = '';
   654→    multitrackUI.decisionList.appendChild(fragment);
   655→}
   656→
   657→function handleDecisionListClick(e) {
   658→    const seekBtn = e.target.closest('.decision-seek');
   659→    if (seekBtn) {
   660→        e.stopPropagation();
   661→        const time = parseFloat(seekBtn.dataset.time);
   662→        if (!isNaN(time)) {
   663→            seekToTime(time);
   664→        }
   665→    }
   666→}
   667→
   668→// ============================================================================
   669→// SEEK TO TIME (CEP VERSION)
   670→// ============================================================================
   671→async function seekToTime(seconds) {
   672→    try {
   673→        await jsx.call('seekToTime', seconds);
   674→    } catch (e) {
   675→        console.warn('[SPLICE Multitrack] Failed to seek:', e);
   676→    }
   677→}
   678→
   679→// ============================================================================
   680→// APPLY MULTITRACK CUTS
   681→// ============================================================================
   682→async function applyMultitrackCuts() {
   683→    if (!analysisResults || !analysisResults.decisions) {
   684→        setStatus('No analysis data. Run analysis first.');
   685→        return;
   686→    }
   687→
   688→    if (isMultitrackOperationInProgress) return;
   689→
   690→    isMultitrackOperationInProgress = true;
   691→    if (multitrackUI.applyBtn) {
   692→        multitrackUI.applyBtn.disabled = true;
   693→        multitrackUI.applyBtn.textContent = 'Applying...';
   694→    }
   695→
   696→    try {
   697→        setStatus('Building multitrack sequence...');
   698→
   699→        // Check if builder is available
   700→        if (!window.spliceBuilder) {
   701→            throw new Error('Builder not initialized');
   702→        }
   703→
   704→        // Get active sequence info
   705→        const seqInfo = await jsx.call('getActiveSequence');
   706→        if (!seqInfo) {
   707→            throw new Error('No active sequence');
   708→        }
   709→
   710→        // Create cut list from decisions
   711→        const cutList = {
   712→            version: '3.5',
   713→            source: {
   714→                name: seqInfo.name,
   715→                path: seqInfo.treePath || seqInfo.name
   716→            },
   717→            segments: analysisResults.decisions.map(d => ({
   718→                type: d.isWideShot ? 'wide_shot' : (d.speakerIndex >= 0 ? 'speaker' : 'speech'),
   719→                sourceName: seqInfo.name,
   720→                sourcePath: seqInfo.treePath || seqInfo.name,
   721→                inPoint: d.startTime,
   722→                outPoint: d.endTime,
   723→                speaker: d.speakerName,
   724→                videoTrack: d.videoTrack,
   725→                colorHint: d.isWideShot ? 'yellow' :
   726→                    (d.speakerIndex === 0 ? 'mango' :
   727→                        d.speakerIndex === 1 ? 'caribbean' :
   728→                            d.speakerIndex === 2 ? 'lavender' : 'cerulean')
   729→            })),
   730→            metadata: {
   731→                isMultitrack: true,
   732→                speakerCount: speakerConfig.length,
   733→                decisionCount: analysisResults.decisions.length,
   734→                ...analysisResults.metadata
   735→            }
   736→        };
   737→
   738→        // Build sequence
   739→        const result = await window.spliceBuilder.buildSequenceFromCutList(cutList, {
   740→            suffix: '_MULTITRACK'
   741→        });
   742→
   743→        if (result.success) {
   744→            // Hide preview
   745→            if (multitrackUI.preview) {
   746→                multitrackUI.preview.classList.add('hidden');
   747→            }
   748→
   749→            setStatus(`Multitrack sequence created: ${result.stats?.clipsInserted || 0} clips`);
   750→
   751→            // Clear results
   752→            analysisResults = null;
   753→        } else {
   754→            throw new Error(result.error || 'Failed to build sequence');
   755→        }
   756→
   757→    } catch (err) {
   758→        console.error('[SPLICE Multitrack] Apply error:', err);
   759→        setStatus('Apply failed: ' + err.message, true);
   760→    } finally {
   761→        isMultitrackOperationInProgress = false;
   762→        if (multitrackUI.applyBtn) {
   763→            multitrackUI.applyBtn.disabled = true;
   764→            multitrackUI.applyBtn.textContent = 'Apply';
   765→        }
   766→    }
   767→}
   768→
   769→// ============================================================================
   770→// EXPORTS
   771→// ============================================================================
   772→// Expose for initialization from main.js
   773→if (typeof window !== 'undefined') {
   774→    window.initMultitrackUI = initMultitrackUI;
   775→    window.spliceMultitrack = {
   776→        init: initMultitrackUI,
   777→        analyze: analyzeMultitrack,
   778→        autoBalance: autoBalanceMultitrack,
   779→        apply: applyMultitrackCuts,
   780→        getSettings: getMultitrackSettings,
   781→        getResults: () => analysisResults
   782→    };
   783→}
   784→

</system-reminder>
