     1→/**
     2→ * SPLICE CEP Text Editor Module
     3→ *
     4→ * Provides UI for text-based video editing.
     5→ * Edit video by editing the transcript text.
     6→ * Delete text to delete video, reorder paragraphs to reorder video.
     7→ */
     8→
     9→// ============================================================================
    10→// STATE
    11→// ============================================================================
    12→
    13→const textEditorState = {
    14→  originalTranscript: null,
    15→  editableTranscript: null,
    16→  currentText: '',
    17→  undoStack: [],
    18→  redoStack: [],
    19→  searchResults: [],
    20→  currentSearchIndex: -1,
    21→  isDirty: false,
    22→  isProcessing: false,
    23→  previewChanges: null,
    24→  lastCutList: null
    25→};
    26→
    27→// Maximum undo history size
    28→const MAX_UNDO_STACK = 50;
    29→
    30→// ============================================================================
    31→// DOM ELEMENT CACHE
    32→// ============================================================================
    33→
    34→const textEditorElements = {
    35→  panel: null,
    36→  content: null,
    37→  status: null,
    38→  wordCount: null,
    39→  dirtyIndicator: null,
    40→  undoBtn: null,
    41→  redoBtn: null,
    42→  applyBtn: null,
    43→  previewBtn: null,
    44→  resetBtn: null,
    45→  buildBtn: null,
    46→  searchInput: null,
    47→  searchBtn: null,
    48→  searchNextBtn: null,
    49→  searchPrevBtn: null,
    50→  searchResults: null,
    51→  replaceInput: null,
    52→  replaceBtn: null,
    53→  replaceAllBtn: null,
    54→  previewContainer: null
    55→};
    56→
    57→/**
    58→ * Cache DOM elements for text editor
    59→ */
    60→function cacheTextEditorElements() {
    61→  textEditorElements.panel = document.getElementById('text-editor-panel');
    62→  textEditorElements.content = document.getElementById('text-editor-content');
    63→  textEditorElements.status = document.getElementById('text-editor-status');
    64→  textEditorElements.wordCount = document.getElementById('text-editor-word-count');
    65→  textEditorElements.dirtyIndicator = document.getElementById('text-editor-dirty');
    66→  textEditorElements.undoBtn = document.getElementById('text-editor-undo-btn');
    67→  textEditorElements.redoBtn = document.getElementById('text-editor-redo-btn');
    68→  textEditorElements.applyBtn = document.getElementById('apply-text-edits-btn');
    69→  textEditorElements.previewBtn = document.getElementById('preview-text-edits-btn');
    70→  textEditorElements.resetBtn = document.getElementById('text-editor-reset-btn');
    71→  textEditorElements.buildBtn = document.getElementById('text-editor-build-btn');
    72→  textEditorElements.searchInput = document.getElementById('text-search-input');
    73→  textEditorElements.searchBtn = document.getElementById('text-search-btn');
    74→  textEditorElements.searchNextBtn = document.getElementById('text-search-next-btn');
    75→  textEditorElements.searchPrevBtn = document.getElementById('text-search-prev-btn');
    76→  textEditorElements.searchResults = document.getElementById('text-search-results');
    77→  textEditorElements.replaceInput = document.getElementById('text-replace-input');
    78→  textEditorElements.replaceBtn = document.getElementById('text-replace-btn');
    79→  textEditorElements.replaceAllBtn = document.getElementById('text-replace-all-btn');
    80→  textEditorElements.previewContainer = document.getElementById('text-editor-preview');
    81→}
    82→
    83→// ============================================================================
    84→// INITIALIZATION
    85→// ============================================================================
    86→
    87→/**
    88→ * Initialize text editor module
    89→ */
    90→function initTextEditor() {
    91→  console.log('[SPLICE] Initializing text editor module');
    92→
    93→  // Cache elements
    94→  cacheTextEditorElements();
    95→
    96→  // Setup event listeners
    97→  setupTextEditorListeners();
    98→
    99→  // Setup keyboard shortcuts
   100→  setupKeyboardShortcuts();
   101→
   102→  console.log('[SPLICE] Text editor module initialized');
   103→}
   104→
   105→/**
   106→ * Setup event listeners for text editor
   107→ */
   108→function setupTextEditorListeners() {
   109→  // Text area input - using event delegation
   110→  document.addEventListener('input', (e) => {
   111→    if (e.target.id === 'text-editor-content') {
   112→      handleTextChange(e.target.value);
   113→    }
   114→  });
   115→
   116→  // Button clicks - using event delegation
   117→  document.addEventListener('click', (e) => {
   118→    const id = e.target.id;
   119→
   120→    switch (id) {
   121→      case 'apply-text-edits-btn':
   122→        applyTextEdits();
   123→        break;
   124→      case 'preview-text-edits-btn':
   125→        previewTextEdits();
   126→        break;
   127→      case 'text-editor-undo-btn':
   128→        undoTextEdit();
   129→        break;
   130→      case 'text-editor-redo-btn':
   131→        redoTextEdit();
   132→        break;
   133→      case 'text-search-btn':
   134→        searchInTranscript();
   135→        break;
   136→      case 'text-search-next-btn':
   137→        navigateSearchResult(1);
   138→        break;
   139→      case 'text-search-prev-btn':
   140→        navigateSearchResult(-1);
   141→        break;
   142→      case 'text-replace-btn':
   143→        replaceInTranscript();
   144→        break;
   145→      case 'text-replace-all-btn':
   146→        replaceAllInTranscript();
   147→        break;
   148→      case 'text-editor-reset-btn':
   149→        resetToOriginal();
   150→        break;
   151→      case 'text-editor-build-btn':
   152→        buildSequenceFromEdits();
   153→        break;
   154→    }
   155→
   156→    // Toggle panel collapse
   157→    if (e.target.closest('.text-editor-header')) {
   158→      const panel = document.getElementById('text-editor-panel');
   159→      if (panel) {
   160→        panel.classList.toggle('collapsed');
   161→      }
   162→    }
   163→  });
   164→
   165→  // Search input enter key
   166→  document.addEventListener('keypress', (e) => {
   167→    if (e.target.id === 'text-search-input' && e.key === 'Enter') {
   168→      e.preventDefault();
   169→      searchInTranscript();
   170→    }
   171→  });
   172→}
   173→
   174→/**
   175→ * Setup keyboard shortcuts
   176→ */
   177→function setupKeyboardShortcuts() {
   178→  document.addEventListener('keydown', (e) => {
   179→    // Only handle if text editor is focused
   180→    const editorContent = textEditorElements.content || document.getElementById('text-editor-content');
   181→    if (!editorContent || document.activeElement !== editorContent) return;
   182→
   183→    // Ctrl/Cmd + Z = Undo
   184→    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
   185→      e.preventDefault();
   186→      undoTextEdit();
   187→    }
   188→
   189→    // Ctrl/Cmd + Shift + Z or Ctrl/Cmd + Y = Redo
   190→    if ((e.ctrlKey || e.metaKey) && (e.key === 'Z' || e.key === 'y')) {
   191→      e.preventDefault();
   192→      redoTextEdit();
   193→    }
   194→
   195→    // Ctrl/Cmd + F = Focus search
   196→    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
   197→      e.preventDefault();
   198→      const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
   199→      if (searchInput) searchInput.focus();
   200→    }
   201→  });
   202→}
   203→
   204→// ============================================================================
   205→// TRANSCRIPT LOADING
   206→// ============================================================================
   207→
   208→/**
   209→ * Load transcript into text editor
   210→ * @param {Object} transcript - Transcript from main module
   211→ */
   212→async function loadTranscriptIntoEditor(transcript) {
   213→  // Check tier access - Text-based editing requires Pro or Team
   214→  if (typeof hasFeatureAccess === 'function' && !hasFeatureAccess('text_editing')) {
   215→    const requiredTier = typeof getRequiredTier === 'function' ? getRequiredTier('text_editing') : 'Pro';
   216→    showTextEditorStatus(`Text-based editing requires ${requiredTier} tier or higher`, 'error');
   217→    if (typeof showUpgradeModal === 'function') {
   218→      showUpgradeModal('Text-Based Editing', requiredTier);
   219→    }
   220→    return;
   221→  }
   222→
   223→  if (!transcript) {
   224→    showTextEditorStatus('No transcript available', 'error');
   225→    return;
   226→  }
   227→
   228→  textEditorState.isProcessing = true;
   229→  updateProcessingState(true);
   230→  showTextEditorStatus('Preparing editable transcript...', 'info');
   231→
   232→  try {
   233→    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
   234→    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   235→    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   236→
   237→    const response = await fetchFn(`${backendUrl}/text-edit/prepare`, {
   238→      method: 'POST',
   239→      headers,
   240→      body: JSON.stringify({ transcript })
   241→    });
   242→
   243→    if (!response.ok) {
   244→      const err = await response.json();
   245→      throw new Error(err.error || 'Failed to prepare transcript');
   246→    }
   247→
   248→    const data = await response.json();
   249→
   250→    // Store original and editable transcripts
   251→    textEditorState.originalTranscript = transcript;
   252→    textEditorState.editableTranscript = data.editableTranscript;
   253→    textEditorState.currentText = data.editableTranscript.plainText;
   254→    textEditorState.isDirty = false;
   255→    textEditorState.undoStack = [];
   256→    textEditorState.redoStack = [];
   257→    textEditorState.lastCutList = null;
   258→
   259→    // Render editor
   260→    renderTextEditor();
   261→
   262→    showTextEditorStatus(`Loaded ${data.editableTranscript.totalWords} words`, 'success');
   263→
   264→  } catch (err) {
   265→    console.error('[SPLICE] Text editor load error:', err);
   266→    showTextEditorStatus(err.message, 'error');
   267→  } finally {
   268→    textEditorState.isProcessing = false;
   269→    updateProcessingState(false);
   270→  }
   271→}
   272→
   273→// ============================================================================
   274→// TEXT EDITING
   275→// ============================================================================
   276→
   277→/**
   278→ * Handle text changes in editor
   279→ */
   280→function handleTextChange(newText) {
   281→  // Save current state to undo stack
   282→  if (textEditorState.currentText !== newText) {
   283→    textEditorState.undoStack.push(textEditorState.currentText);
   284→    textEditorState.redoStack = []; // Clear redo stack on new edit
   285→
   286→    // Limit undo stack size
   287→    if (textEditorState.undoStack.length > MAX_UNDO_STACK) {
   288→      textEditorState.undoStack.shift();
   289→    }
   290→  }
   291→
   292→  textEditorState.currentText = newText;
   293→  textEditorState.isDirty = true;
   294→  textEditorState.previewChanges = null; // Clear preview
   295→
   296→  updateEditorStatus();
   297→}
   298→
   299→/**
   300→ * Undo last text edit
   301→ */
   302→function undoTextEdit() {
   303→  if (textEditorState.undoStack.length === 0) {
   304→    showTextEditorStatus('Nothing to undo', 'info');
   305→    return;
   306→  }
   307→
   308→  // Save current to redo stack
   309→  textEditorState.redoStack.push(textEditorState.currentText);
   310→
   311→  // Restore from undo stack
   312→  textEditorState.currentText = textEditorState.undoStack.pop();
   313→
   314→  // Update editor content
   315→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   316→  if (editor) {
   317→    editor.value = textEditorState.currentText;
   318→  }
   319→
   320→  updateEditorStatus();
   321→  showTextEditorStatus('Undo applied', 'info');
   322→}
   323→
   324→/**
   325→ * Redo last undone edit
   326→ */
   327→function redoTextEdit() {
   328→  if (textEditorState.redoStack.length === 0) {
   329→    showTextEditorStatus('Nothing to redo', 'info');
   330→    return;
   331→  }
   332→
   333→  // Save current to undo stack
   334→  textEditorState.undoStack.push(textEditorState.currentText);
   335→
   336→  // Restore from redo stack
   337→  textEditorState.currentText = textEditorState.redoStack.pop();
   338→
   339→  // Update editor content
   340→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   341→  if (editor) {
   342→    editor.value = textEditorState.currentText;
   343→  }
   344→
   345→  updateEditorStatus();
   346→  showTextEditorStatus('Redo applied', 'info');
   347→}
   348→
   349→/**
   350→ * Reset to original transcript
   351→ */
   352→function resetToOriginal() {
   353→  if (!textEditorState.editableTranscript) return;
   354→
   355→  // Save current to undo
   356→  if (textEditorState.isDirty) {
   357→    textEditorState.undoStack.push(textEditorState.currentText);
   358→  }
   359→
   360→  textEditorState.currentText = textEditorState.editableTranscript.plainText;
   361→  textEditorState.isDirty = false;
   362→  textEditorState.previewChanges = null;
   363→
   364→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   365→  if (editor) {
   366→    editor.value = textEditorState.currentText;
   367→  }
   368→
   369→  updateEditorStatus();
   370→  showTextEditorStatus('Reset to original', 'success');
   371→}
   372→
   373→// ============================================================================
   374→// PREVIEW AND APPLY
   375→// ============================================================================
   376→
   377→/**
   378→ * Preview text edits without applying
   379→ */
   380→async function previewTextEdits() {
   381→  if (!textEditorState.editableTranscript || !textEditorState.isDirty) {
   382→    showTextEditorStatus('No changes to preview', 'info');
   383→    return;
   384→  }
   385→
   386→  textEditorState.isProcessing = true;
   387→  updateProcessingState(true);
   388→  showTextEditorStatus('Generating preview...', 'info');
   389→
   390→  try {
   391→    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
   392→    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   393→    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   394→
   395→    const response = await fetchFn(`${backendUrl}/text-edit/preview`, {
   396→      method: 'POST',
   397→      headers,
   398→      body: JSON.stringify({
   399→        transcript: textEditorState.editableTranscript,
   400→        editedText: textEditorState.currentText
   401→      })
   402→    });
   403→
   404→    if (!response.ok) {
   405→      const err = await response.json();
   406→      throw new Error(err.error || 'Preview failed');
   407→    }
   408→
   409→    const data = await response.json();
   410→    textEditorState.previewChanges = data;
   411→
   412→    renderPreview(data);
   413→    showTextEditorStatus(`Preview: ${data.changes.length} changes`, 'success');
   414→
   415→  } catch (err) {
   416→    console.error('[SPLICE] Text edit preview error:', err);
   417→    showTextEditorStatus(err.message, 'error');
   418→  } finally {
   419→    textEditorState.isProcessing = false;
   420→    updateProcessingState(false);
   421→  }
   422→}
   423→
   424→/**
   425→ * Render preview of changes
   426→ */
   427→function renderPreview(preview) {
   428→  const container = textEditorElements.previewContainer || document.getElementById('text-editor-preview');
   429→  if (!container) return;
   430→
   431→  if (!preview.changes || preview.changes.length === 0) {
   432→    container.innerHTML = '<div class="preview-empty">No changes detected</div>';
   433→    return;
   434→  }
   435→
   436→  // SECURITY: Escape user-provided content to prevent XSS
   437→  const html = `
   438→    <div class="preview-summary">
   439→      <span class="preview-stat">${escapeHtml(preview.summary.deletions)} deletions</span>
   440→      <span class="preview-stat">${escapeHtml(preview.summary.reorderings)} reorders</span>
   441→      <span class="preview-stat">${escapeHtml(preview.impact.percentageRemoved)}% removed</span>
   442→    </div>
   443→    <div class="preview-changes">
   444→      ${preview.changes.map(change => `
   445→        <div class="preview-change preview-change-${escapeHtml(change.type)}">
   446→          <span class="change-type">${escapeHtml(change.type)}</span>
   447→          <span class="change-desc">${escapeHtml(change.description)}</span>
   448→          <span class="change-time">${escapeHtml(change.timeRange)}</span>
   449→        </div>
   450→      `).join('')}
   451→    </div>
   452→  `;
   453→
   454→  container.innerHTML = html;
   455→}
   456→
   457→/**
   458→ * Apply text edits and generate cut list
   459→ */
   460→async function applyTextEdits() {
   461→  if (!textEditorState.editableTranscript || !textEditorState.isDirty) {
   462→    showTextEditorStatus('No changes to apply', 'info');
   463→    return;
   464→  }
   465→
   466→  textEditorState.isProcessing = true;
   467→  updateProcessingState(true);
   468→  showTextEditorStatus('Applying edits...', 'info');
   469→
   470→  try {
   471→    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
   472→    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   473→    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   474→
   475→    // Apply edits
   476→    const applyResponse = await fetchFn(`${backendUrl}/text-edit/apply`, {
   477→      method: 'POST',
   478→      headers,
   479→      body: JSON.stringify({
   480→        transcript: textEditorState.editableTranscript,
   481→        editedText: textEditorState.currentText
   482→      })
   483→    });
   484→
   485→    if (!applyResponse.ok) {
   486→      const err = await applyResponse.json();
   487→      throw new Error(err.error || 'Apply failed');
   488→    }
   489→
   490→    const applyData = await applyResponse.json();
   491→
   492→    // Generate cut list from operations
   493→    const cutListResponse = await fetchFn(`${backendUrl}/text-edit/cut-list`, {
   494→      method: 'POST',
   495→      headers,
   496→      body: JSON.stringify({
   497→        operations: applyData.operations,
   498→        sourceInfo: {
   499→          sourceName: textEditorState.originalTranscript?.source?.name || 'source',
   500→          duration: textEditorState.editableTranscript.duration
   501→        }
   502→      })
   503→    });
   504→
   505→    if (!cutListResponse.ok) {
   506→      const err = await cutListResponse.json();
   507→      throw new Error(err.error || 'Cut list generation failed');
   508→    }
   509→
   510→    const cutListData = await cutListResponse.json();
   511→
   512→    // Store cut list for building
   513→    textEditorState.lastCutList = cutListData.cutList;
   514→
   515→    // Update state
   516→    textEditorState.isDirty = false;
   517→
   518→    showTextEditorStatus(
   519→      `Applied ${applyData.stats.deletions} cuts, ${cutListData.summary.segmentCount} segments`,
   520→      'success'
   521→    );
   522→
   523→    // Show build button
   524→    updateBuildButtonState(true);
   525→
   526→  } catch (err) {
   527→    console.error('[SPLICE] Text edit apply error:', err);
   528→    showTextEditorStatus(err.message, 'error');
   529→  } finally {
   530→    textEditorState.isProcessing = false;
   531→    updateProcessingState(false);
   532→  }
   533→}
   534→
   535→/**
   536→ * Build sequence from applied edits
   537→ */
   538→async function buildSequenceFromEdits() {
   539→  if (!textEditorState.lastCutList) {
   540→    showTextEditorStatus('No edits to build. Apply edits first.', 'error');
   541→    return;
   542→  }
   543→
   544→  showTextEditorStatus('Building sequence...', 'info');
   545→
   546→  try {
   547→    // Use builder to create sequence (CEP version via JSX)
   548→    if (window.spliceBuilder?.buildSequenceFromCutList) {
   549→      const result = await window.spliceBuilder.buildSequenceFromCutList(textEditorState.lastCutList);
   550→      if (result && result.success) {
   551→        showTextEditorStatus('Sequence built successfully', 'success');
   552→      } else {
   553→        throw new Error(result?.error || 'Build failed');
   554→      }
   555→    } else if (typeof jsx !== 'undefined' && jsx.call) {
   556→      // Fallback to direct JSX call
   557→      const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(textEditorState.lastCutList));
   558→      if (result && result.success) {
   559→        showTextEditorStatus('Sequence built successfully', 'success');
   560→      } else {
   561→        throw new Error(result?.error || 'Build failed');
   562→      }
   563→    } else {
   564→      showTextEditorStatus('Builder not available', 'error');
   565→    }
   566→  } catch (err) {
   567→    console.error('[SPLICE] Build sequence error:', err);
   568→    showTextEditorStatus(err.message, 'error');
   569→  }
   570→}
   571→
   572→// ============================================================================
   573→// SEARCH AND REPLACE
   574→// ============================================================================
   575→
   576→/**
   577→ * Search in transcript
   578→ */
   579→async function searchInTranscript() {
   580→  const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
   581→  const searchText = searchInput?.value?.trim();
   582→
   583→  if (!searchText) {
   584→    showTextEditorStatus('Enter search text', 'info');
   585→    return;
   586→  }
   587→
   588→  if (!textEditorState.editableTranscript) {
   589→    showTextEditorStatus('No transcript loaded', 'error');
   590→    return;
   591→  }
   592→
   593→  try {
   594→    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
   595→    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   596→    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   597→
   598→    const response = await fetchFn(`${backendUrl}/text-edit/search`, {
   599→      method: 'POST',
   600→      headers,
   601→      body: JSON.stringify({
   602→        transcript: textEditorState.editableTranscript,
   603→        searchText
   604→      })
   605→    });
   606→
   607→    if (!response.ok) {
   608→      const err = await response.json();
   609→      throw new Error(err.error || 'Search failed');
   610→    }
   611→
   612→    const data = await response.json();
   613→    textEditorState.searchResults = data.matches || [];
   614→    textEditorState.currentSearchIndex = data.matches.length > 0 ? 0 : -1;
   615→
   616→    highlightSearchResults();
   617→    showTextEditorStatus(`Found ${data.totalMatches} matches`, 'success');
   618→
   619→  } catch (err) {
   620→    console.error('[SPLICE] Search error:', err);
   621→    showTextEditorStatus(err.message, 'error');
   622→  }
   623→}
   624→
   625→/**
   626→ * Navigate search results
   627→ */
   628→function navigateSearchResult(direction) {
   629→  if (textEditorState.searchResults.length === 0) {
   630→    showTextEditorStatus('No search results', 'info');
   631→    return;
   632→  }
   633→
   634→  textEditorState.currentSearchIndex += direction;
   635→
   636→  // Wrap around
   637→  if (textEditorState.currentSearchIndex >= textEditorState.searchResults.length) {
   638→    textEditorState.currentSearchIndex = 0;
   639→  } else if (textEditorState.currentSearchIndex < 0) {
   640→    textEditorState.currentSearchIndex = textEditorState.searchResults.length - 1;
   641→  }
   642→
   643→  highlightCurrentResult();
   644→  updateSearchResultsDisplay();
   645→}
   646→
   647→/**
   648→ * Highlight search results in editor
   649→ */
   650→function highlightSearchResults() {
   651→  // Update counter
   652→  updateSearchResultsDisplay();
   653→
   654→  if (textEditorState.currentSearchIndex >= 0) {
   655→    highlightCurrentResult();
   656→  }
   657→}
   658→
   659→/**
   660→ * Highlight current search result
   661→ */
   662→function highlightCurrentResult() {
   663→  const result = textEditorState.searchResults[textEditorState.currentSearchIndex];
   664→  if (!result) return;
   665→
   666→  // Scroll to result position in textarea
   667→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   668→  if (editor) {
   669→    // Find text position and scroll
   670→    const text = editor.value;
   671→    const searchPos = text.toLowerCase().indexOf(result.text.toLowerCase());
   672→    if (searchPos >= 0) {
   673→      editor.setSelectionRange(searchPos, searchPos + result.text.length);
   674→      editor.focus();
   675→    }
   676→  }
   677→
   678→  // Show time info - use formatTime from config.js
   679→  const timeStr = typeof formatTime === 'function' ? formatTime(result.start) : `${Math.floor(result.start)}s`;
   680→  showTextEditorStatus(
   681→    `Match ${textEditorState.currentSearchIndex + 1}/${textEditorState.searchResults.length} at ${timeStr}`,
   682→    'info'
   683→  );
   684→}
   685→
   686→/**
   687→ * Update search results display
   688→ */
   689→function updateSearchResultsDisplay() {
   690→  const display = textEditorElements.searchResults || document.getElementById('text-search-results');
   691→  if (display) {
   692→    const current = textEditorState.currentSearchIndex + 1;
   693→    const total = textEditorState.searchResults.length;
   694→    display.textContent = total > 0 ? `${current}/${total}` : '0/0';
   695→  }
   696→}
   697→
   698→/**
   699→ * Replace in transcript
   700→ */
   701→function replaceInTranscript() {
   702→  const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
   703→  const replaceInput = textEditorElements.replaceInput || document.getElementById('text-replace-input');
   704→  const searchText = searchInput?.value?.trim();
   705→  const replaceText = replaceInput?.value || '';
   706→
   707→  if (!searchText) {
   708→    showTextEditorStatus('Enter search text', 'info');
   709→    return;
   710→  }
   711→
   712→  // Replace first occurrence in current text
   713→  const newText = textEditorState.currentText.replace(
   714→    new RegExp(escapeRegex(searchText), 'i'),
   715→    replaceText
   716→  );
   717→
   718→  if (newText !== textEditorState.currentText) {
   719→    handleTextChange(newText);
   720→    const editor = textEditorElements.content || document.getElementById('text-editor-content');
   721→    if (editor) editor.value = newText;
   722→    showTextEditorStatus('Replaced 1 occurrence', 'success');
   723→  } else {
   724→    showTextEditorStatus('No match found', 'info');
   725→  }
   726→}
   727→
   728→/**
   729→ * Replace all occurrences in transcript
   730→ */
   731→function replaceAllInTranscript() {
   732→  const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
   733→  const replaceInput = textEditorElements.replaceInput || document.getElementById('text-replace-input');
   734→  const searchText = searchInput?.value?.trim();
   735→  const replaceText = replaceInput?.value || '';
   736→
   737→  if (!searchText) {
   738→    showTextEditorStatus('Enter search text', 'info');
   739→    return;
   740→  }
   741→
   742→  const regex = new RegExp(escapeRegex(searchText), 'gi');
   743→  const matches = textEditorState.currentText.match(regex);
   744→  const count = matches ? matches.length : 0;
   745→
   746→  if (count > 0) {
   747→    const newText = textEditorState.currentText.replace(regex, replaceText);
   748→    handleTextChange(newText);
   749→    const editor = textEditorElements.content || document.getElementById('text-editor-content');
   750→    if (editor) editor.value = newText;
   751→    showTextEditorStatus(`Replaced ${count} occurrences`, 'success');
   752→  } else {
   753→    showTextEditorStatus('No matches found', 'info');
   754→  }
   755→}
   756→
   757→/**
   758→ * Escape special regex characters
   759→ */
   760→function escapeRegex(string) {
   761→  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
   762→}
   763→
   764→// ============================================================================
   765→// UI RENDERING
   766→// ============================================================================
   767→
   768→/**
   769→ * Render text editor content
   770→ */
   771→function renderTextEditor() {
   772→  const container = textEditorElements.content || document.getElementById('text-editor-content');
   773→  if (!container) return;
   774→
   775→  container.value = textEditorState.currentText;
   776→  updateEditorStatus();
   777→}
   778→
   779→/**
   780→ * Update editor status display
   781→ */
   782→function updateEditorStatus() {
   783→  const wordCount = textEditorElements.wordCount || document.getElementById('text-editor-word-count');
   784→  const dirtyIndicator = textEditorElements.dirtyIndicator || document.getElementById('text-editor-dirty');
   785→  const undoBtn = textEditorElements.undoBtn || document.getElementById('text-editor-undo-btn');
   786→  const redoBtn = textEditorElements.redoBtn || document.getElementById('text-editor-redo-btn');
   787→
   788→  if (wordCount) {
   789→    const words = textEditorState.currentText.split(/\s+/).filter(w => w.length > 0);
   790→    wordCount.textContent = `${words.length} words`;
   791→  }
   792→
   793→  if (dirtyIndicator) {
   794→    dirtyIndicator.style.display = textEditorState.isDirty ? 'inline' : 'none';
   795→  }
   796→
   797→  if (undoBtn) {
   798→    undoBtn.disabled = textEditorState.undoStack.length === 0;
   799→  }
   800→
   801→  if (redoBtn) {
   802→    redoBtn.disabled = textEditorState.redoStack.length === 0;
   803→  }
   804→}
   805→
   806→/**
   807→ * Update processing state UI
   808→ */
   809→function updateProcessingState(isProcessing) {
   810→  const panel = textEditorElements.panel || document.getElementById('text-editor-panel');
   811→  if (panel) {
   812→    const buttons = panel.querySelectorAll('button');
   813→    buttons.forEach(btn => {
   814→      if (!btn.classList.contains('always-enabled')) {
   815→        btn.disabled = isProcessing;
   816→      }
   817→    });
   818→  }
   819→
   820→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   821→  if (editor) {
   822→    editor.disabled = isProcessing;
   823→  }
   824→}
   825→
   826→/**
   827→ * Update build button state
   828→ */
   829→function updateBuildButtonState(enabled) {
   830→  const btn = textEditorElements.buildBtn || document.getElementById('text-editor-build-btn');
   831→  if (btn) {
   832→    btn.disabled = !enabled;
   833→    if (enabled) {
   834→      btn.classList.add('ready');
   835→    } else {
   836→      btn.classList.remove('ready');
   837→    }
   838→  }
   839→}
   840→
   841→/**
   842→ * Show status message
   843→ */
   844→function showTextEditorStatus(message, type = 'info') {
   845→  const statusEl = textEditorElements.status || document.getElementById('text-editor-status');
   846→  if (!statusEl) return;
   847→
   848→  statusEl.textContent = message;
   849→  statusEl.className = `text-editor-status text-editor-status-${type}`;
   850→
   851→  if (type !== 'error') {
   852→    setTimeout(() => {
   853→      statusEl.textContent = '';
   854→      statusEl.className = 'text-editor-status';
   855→    }, 5000);
   856→  }
   857→}
   858→
   859→// ============================================================================
   860→// EXPORTS
   861→// ============================================================================
   862→
   863→// Export for global access
   864→window.spliceTextEditor = {
   865→  init: initTextEditor,
   866→  loadTranscript: loadTranscriptIntoEditor,
   867→  applyEdits: applyTextEdits,
   868→  previewEdits: previewTextEdits,
   869→  undo: undoTextEdit,
   870→  redo: redoTextEdit,
   871→  reset: resetToOriginal,
   872→  search: searchInTranscript,
   873→  buildSequence: buildSequenceFromEdits,
   874→  getState: () => ({ ...textEditorState })
   875→};
   876→
   877→// Also expose individual functions for direct access
   878→window.initTextEditor = initTextEditor;
   879→window.loadTranscriptIntoEditor = loadTranscriptIntoEditor;
   880→

</system-reminder>
