     1→/**
     2→ * SPLICE Backend Server
     3→ *
     4→ * Main entry point for the SPLICE backend API.
     5→ * Orchestrates the audio analysis pipeline.
     6→ *
     7→ * Slices:
     8→ * - Slice 4: Transcription (services/transcription.js)
     9→ * - Slice 5: Take Detection (services/takeDetection.js)
    10→ *
    11→ * Architecture: Modular routes (see routes/ directory)
    12→ */
    13→
    14→
    15→require('dotenv').config();
    16→
    17→const express = require('express');
    18→const cors = require('cors');
    19→const helmet = require('helmet');
    20→const cookieParser = require('cookie-parser');
    21→const fs = require('fs');
    22→const https = require('https');
    23→const http = require('http');
    24→const path = require('path');
    25→const crypto = require('crypto');
    26→
    27→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)
    28→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;
    29→
    30→// Import services
    31→const usageTracking = require('./services/usageTracking');
    32→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');
    33→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');
    34→const referralService = require('./services/referralService');
    35→const licenseService = require('./services/licenseService');
    36→const emailService = require('./services/emailService');
    37→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');
    38→const { getSupportedFormats } = require('./services/captionExporter');
    39→
    40→// Import route modules
    41→const healthRoutes = require('./routes/health');
    42→const analyzeRoutes = require('./routes/analyze');
    43→const silencesRoutes = require('./routes/silences');
    44→const detectionRoutes = require('./routes/detection');
    45→const exportRoutes = require('./routes/export');
    46→const multitrackRoutes = require('./routes/multitrack');
    47→const cutListRoutes = require('./routes/cutList');
    48→const zoomRoutes = require('./routes/zoom');
    49→const chaptersRoutes = require('./routes/chapters');
    50→const youtubeRoutes = require('./routes/youtube');
    51→const captionsRoutes = require('./routes/captions');
    52→const textEditRoutes = require('./routes/textEdit');
    53→const reframeRoutes = require('./routes/reframe');
    54→const batchRoutes = require('./routes/batch');
    55→const authRoutes = require('./routes/auth');
    56→const billingRoutes = require('./routes/billing');
    57→const referralRoutes = require('./routes/referral');
    58→const licenseRoutes = require('./routes/license');
    59→const musicRoutes = require('./routes/music');
    60→
    61→// Stripe for webhooks
    62→const Stripe = require('stripe');
    63→
    64→// Validate STRIPE_SECRET_KEY in production - exit if missing
    65→if (isProduction && !process.env.STRIPE_SECRET_KEY) {
    66→  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');
    67→  process.exit(1);
    68→}
    69→
    70→// Validate JWT_SECRET in production - exit if using default
    71→if (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {
    72→  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');
    73→  process.exit(1);
    74→}
    75→
    76→// Validate DATABASE_URL in production
    77→if (isProduction && !process.env.DATABASE_URL) {
    78→  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');
    79→  process.exit(1);
    80→}
    81→
    82→// Validate OPENAI_API_KEY in production
    83→if (isProduction && !process.env.OPENAI_API_KEY) {
    84→  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');
    85→  process.exit(1);
    86→}
    87→
    88→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
    89→
    90→// =============================================================================
    91→// PERF-FIX: Static Response Cache
    92→// Cache static endpoint responses at startup to avoid repeated computation
    93→// =============================================================================
    94→
    95→// Generate ETag from content
    96→function generateETag(content) {
    97→  return `"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}"`;
    98→}
    99→
   100→// Static response cache - populated at startup
   101→const STATIC_RESPONSE_CACHE = {
   102→  profanityLanguages: null,
   103→  profanityBleeps: null,
   104→  exportFormats: null
   105→};
   106→
   107→// Initialize cache at startup (called after server starts)
   108→function initializeStaticCache() {
   109→  // Cache profanity languages
   110→  const languages = getSupportedLanguages();
   111→  STATIC_RESPONSE_CACHE.profanityLanguages = {
   112→    body: { success: true, languages },
   113→    etag: generateETag({ languages })
   114→  };
   115→
   116→  // Cache profanity bleeps
   117→  const sounds = getAvailableBleepSounds();
   118→  STATIC_RESPONSE_CACHE.profanityBleeps = {
   119→    body: { success: true, sounds },
   120→    etag: generateETag({ sounds })
   121→  };
   122→
   123→  // Cache export formats
   124→  const formats = getSupportedFormats();
   125→  STATIC_RESPONSE_CACHE.exportFormats = {
   126→    body: { success: true, formats },
   127→    etag: generateETag({ formats })
   128→  };
   129→
   130→  console.log('[SPLICE] Static response cache initialized');
   131→}
   132→
   133→// Helper to send cached response with ETag
   134→function sendCachedResponse(req, res, cacheKey) {
   135→  const cached = STATIC_RESPONSE_CACHE[cacheKey];
   136→  if (!cached) {
   137→    return res.status(500).json({ error: 'Cache not initialized' });
   138→  }
   139→
   140→  // Check If-None-Match header for conditional GET
   141→  const clientETag = req.headers['if-none-match'];
   142→  if (clientETag === cached.etag) {
   143→    return res.status(304).end(); // Not Modified
   144→  }
   145→
   146→  // Send cached response with ETag and cache headers
   147→  res.set('ETag', cached.etag);
   148→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours
   149→  res.json(cached.body);
   150→}
   151→
   152→// =============================================================================
   153→// Server Configuration
   154→// =============================================================================
   155→
   156→const app = express();
   157→const PORT = process.env.PORT || 3847;
   158→
   159→// HTTPS certificates (generated by mkcert) - only for local development
   160→let httpsOptions = null;
   161→if (!isProduction) {
   162→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');
   163→  const certPath = path.join(__dirname, 'localhost+1.pem');
   164→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
   165→    httpsOptions = {
   166→      key: fs.readFileSync(keyPath),
   167→      cert: fs.readFileSync(certPath)
   168→    };
   169→  }
   170→}
   171→
   172→// =============================================================================
   173→// Security Configuration
   174→// =============================================================================
   175→
   176→// CORS whitelist - restrict origins in production
   177→const CORS_WHITELIST = [
   178→  'http://localhost:3000',
   179→  'http://localhost:3847',
   180→  'https://localhost:3847',
   181→  'http://127.0.0.1:3000',
   182→  'http://127.0.0.1:3847',
   183→  'https://127.0.0.1:3847',
   184→  'https://splice.app',
   185→  'https://www.splice.app',
   186→  'https://splice-api-production.up.railway.app',
   187→  'https://splice-website.vercel.app',
   188→  // Adobe CEP/UXP panels run from file:// or bolt://
   189→  'file://',
   190→  'bolt://'
   191→];
   192→
   193→const corsOptions = {
   194→  origin: function (origin, callback) {
   195→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)
   196→    if (!origin) {
   197→      return callback(null, true);
   198→    }
   199→    // Check if origin is in whitelist
   200→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {
   201→      return callback(null, true);
   202→    }
   203→    // In development, allow all origins with warning
   204→    if (!isProduction) {
   205→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);
   206→      return callback(null, true);
   207→    }
   208→    // In production, reject non-whitelisted origins
   209→    console.error(`[CORS] Blocked request from: ${origin}`);
   210→    return callback(new Error('Not allowed by CORS'));
   211→  },
   212→  credentials: true,
   213→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
   214→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']
   215→};
   216→
   217→app.use(cors(corsOptions));
   218→
   219→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers
   220→// This ensures rate limiting and logging use the correct client IP
   221→if (isProduction) {
   222→  app.set('trust proxy', 1);
   223→}
   224→
   225→// IP-based rate limiting (100 requests/minute per IP)
   226→app.use(ipRateLimit);
   227→
   228→// Security headers via helmet
   229→app.use(helmet({
   230→  contentSecurityPolicy: {
   231→    directives: {
   232→      defaultSrc: ["'self'"],
   233→      scriptSrc: ["'self'"],
   234→      styleSrc: ["'self'", "'unsafe-inline'"],
   235→      imgSrc: ["'self'", 'data:', 'https:'],
   236→      connectSrc: ["'self'", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],
   237→      fontSrc: ["'self'"],
   238→      objectSrc: ["'none'"],
   239→      mediaSrc: ["'self'"],
   240→      frameSrc: ["'none'"]
   241→    }
   242→  },
   243→  hsts: {
   244→    maxAge: 31536000,
   245→    includeSubDomains: true,
   246→    preload: true
   247→  },
   248→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
   249→  noSniff: true,
   250→  xssFilter: true,
   251→  hidePoweredBy: true
   252→}));
   253→
   254→// Helper to determine tier from price ID with logging
   255→// Supports both monthly and annual pricing
   256→function getTierFromPriceId(priceId) {
   257→  // Monthly prices
   258→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';
   259→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';
   260→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';
   261→
   262→  // Annual prices (same tier, just different billing period)
   263→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';
   264→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';
   265→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';
   266→
   267→  // Log unknown price ID for debugging
   268→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);
   269→  return 'starter';
   270→}
   271→
   272→// =============================================================================
   273→// Stripe Webhook (must be before express.json())
   274→// =============================================================================
   275→
   276→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
   277→  const sig = req.headers['stripe-signature'];
   278→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
   279→
   280→  let event;
   281→
   282→  try {
   283→    if (webhookSecret) {
   284→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
   285→    } else if (isProduction) {
   286→      // SECURITY: Reject unsigned webhooks in production
   287→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');
   288→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });
   289→    } else {
   290→      // For local development testing only
   291→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse
   292→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');
   293→      event = JSON.parse(bodyString);
   294→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');
   295→    }
   296→  } catch (err) {
   297→    console.error('[SPLICE] Webhook signature verification failed:', err.message);
   298→    return res.status(400).json({ error: 'Webhook signature verification failed' });
   299→  }
   300→
   301→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);
   302→
   303→  // Idempotency check - skip if already processed
   304→  if (await usageTracking.isEventProcessed(event.id)) {
   305→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);
   306→    return res.json({ received: true, skipped: true });
   307→  }
   308→
   309→  try {
   310→    switch (event.type) {
   311→      case 'customer.subscription.created':
   312→      case 'customer.subscription.updated': {
   313→        const subscription = event.data.object;
   314→        const customerId = subscription.customer;
   315→
   316→        // Validate customerId
   317→        if (!customerId) {
   318→          console.error('[SPLICE] Missing customer ID in subscription event');
   319→          return res.status(400).json({ error: 'Missing customer ID' });
   320→        }
   321→
   322→        // Get tier from price ID
   323→        const priceId = subscription.items?.data?.[0]?.price?.id;
   324→        const tier = getTierFromPriceId(priceId);
   325→
   326→        // Update user tier and reset hours
   327→        await usageTracking.updateTier(customerId, tier);
   328→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);
   329→
   330→        // Initialize music credits for new subscriptions
   331→        if (event.type === 'customer.subscription.created') {
   332→          await usageTracking.resetMusicCredits(customerId, tier);
   333→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);
   334→        }
   335→
   336→        // Update trial end date if present
   337→        if (subscription.trial_end) {
   338→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);
   339→        }
   340→
   341→        // Generate license key for new subscriptions with retry and delivery
   342→        if (event.type === 'customer.subscription.created') {
   343→          let licenseResult = null;
   344→          let retryCount = 0;
   345→          const maxRetries = 3;
   346→
   347→          // Retry mechanism for license key generation
   348→          while (retryCount < maxRetries) {
   349→            licenseResult = await licenseService.generateLicenseKey(customerId);
   350→            if (licenseResult.success) {
   351→              break;
   352→            }
   353→            retryCount++;
   354→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);
   355→            // Wait before retry (exponential backoff)
   356→            if (retryCount < maxRetries) {
   357→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
   358→            }
   359→          }
   360→
   361→          if (licenseResult && licenseResult.success) {
   362→            // SECURITY: Mask license key in logs
   363→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);
   364→
   365→            // Store license key in Stripe subscription metadata as backup
   366→            try {
   367→              await stripe.subscriptions.update(subscription.id, {
   368→                metadata: {
   369→                  license_key: licenseResult.key,
   370→                  license_generated_at: new Date().toISOString()
   371→                }
   372→              });
   373→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);
   374→            } catch (stripeErr) {
   375→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);
   376→            }
   377→
   378→            // Get customer email and send license key
   379→            try {
   380→              const customer = await stripe.customers.retrieve(customerId);
   381→              if (customer.email) {
   382→                // SECURITY: Mask sensitive data in logs
   383→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);
   384→
   385→                // Send license key email
   386→                try {
   387→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);
   388→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);
   389→                } catch (sendErr) {
   390→                  // Log but don't fail - license is stored in Stripe metadata as backup
   391→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);
   392→                }
   393→
   394→                // Store email in database for reference
   395→                await usageTracking.updateTier(customerId, tier, customer.email);
   396→              } else {
   397→                console.warn(`[SPLICE] No email found for customer ${customerId}`);
   398→              }
   399→            } catch (emailErr) {
   400→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);
   401→            }
   402→          } else {
   403→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry
   404→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;
   405→            console.error(`[SPLICE] ${errorMsg}`);
   406→            return res.status(500).json({ error: errorMsg });
   407→          }
   408→        }
   409→        break;
   410→      }
   411→
   412→      case 'customer.subscription.deleted': {
   413→        const subscription = event.data.object;
   414→        const customerId = subscription.customer;
   415→
   416→        // Validate customerId
   417→        if (!customerId) {
   418→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');
   419→          return res.status(400).json({ error: 'Missing customer ID' });
   420→        }
   421→
   422→        // Downgrade to cancelled (0 hours)
   423→        await usageTracking.updateTier(customerId, 'cancelled');
   424→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);
   425→        break;
   426→      }
   427→
   428→      case 'invoice.payment_succeeded': {
   429→        const invoice = event.data.object;
   430→        const customerId = invoice.customer;
   431→        const subscriptionId = invoice.subscription;
   432→
   433→        // Validate customerId
   434→        if (!customerId) {
   435→          console.error('[SPLICE] Missing customer ID in invoice event');
   436→          return res.status(400).json({ error: 'Missing customer ID' });
   437→        }
   438→
   439→        // Reset hours on successful payment (new billing period)
   440→        let tier = 'starter';
   441→        if (subscriptionId) {
   442→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);
   443→          const priceId = subscription.items?.data?.[0]?.price?.id;
   444→          tier = getTierFromPriceId(priceId);
   445→
   446→          await usageTracking.resetHours(customerId, tier);
   447→          await usageTracking.resetMusicCredits(customerId, tier);
   448→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);
   449→        }
   450→
   451→        // Check for affiliate coupon and record commission
   452→        const discount = invoice.discount;
   453→        if (discount && discount.coupon) {
   454→          const couponId = discount.coupon.id;
   455→          // Check if this is an affiliate code (like JIMMYN)
   456→          if (referralService.AFFILIATE_CODES[couponId]) {
   457→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars
   458→            await referralService.recordAffiliateCommission(
   459→              couponId,
   460→              customerId,
   461→              amountPaid,
   462→              tier
   463→            );
   464→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);
   465→          }
   466→        }
   467→        break;
   468→      }
   469→
   470→      case 'invoice.payment_failed': {
   471→        const invoice = event.data.object;
   472→        const customerId = invoice.customer;
   473→        const attemptCount = invoice.attempt_count || 1;
   474→
   475→        // Validate customerId
   476→        if (!customerId) {
   477→          console.error('[SPLICE] Missing customer ID in payment_failed event');
   478→          return res.status(400).json({ error: 'Missing customer ID' });
   479→        }
   480→
   481→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);
   482→
   483→        // Stripe will retry automatically per retry settings
   484→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted
   485→        // Send warning email on final attempt
   486→        if (attemptCount >= 3) {
   487→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);
   488→          // Send warning email to customer about impending cancellation
   489→          try {
   490→            const customer = await stripe.customers.retrieve(customerId);
   491→            if (customer.email) {
   492→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);
   493→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);
   494→            }
   495→          } catch (emailErr) {
   496→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);
   497→          }
   498→        }
   499→        break;
   500→      }
   501→
   502→      case 'customer.deleted': {
   503→        const customer = event.data.object;
   504→        const customerId = customer.id;
   505→
   506→        // Validate customerId
   507→        if (!customerId) {
   508→          console.error('[SPLICE] Missing customer ID in customer.deleted event');
   509→          return res.status(400).json({ error: 'Missing customer ID' });
   510→        }
   511→
   512→        // Clean up user data - downgrade to cancelled
   513→        await usageTracking.updateTier(customerId, 'cancelled');
   514→        console.log(`[SPLICE] Customer deleted: ${customerId}`);
   515→        break;
   516→      }
   517→
   518→      default:
   519→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);
   520→    }
   521→
   522→    // Record event as processed (idempotency)
   523→    await usageTracking.recordWebhookEvent(event.id, event.type);
   524→
   525→    res.json({ received: true });
   526→  } catch (err) {
   527→    console.error('[SPLICE] Webhook handler error:', err);
   528→    res.status(500).json({ error: err.message });
   529→  }
   530→});
   531→
   532→// Parse JSON body for all other routes
   533→// SECURITY: Limit JSON body size to prevent DoS attacks
   534→app.use(express.json({ limit: '10mb' }));
   535→
   536→// Parse cookies for CSRF token validation
   537→app.use(cookieParser());
   538→
   539→// =============================================================================
   540→// Route Configuration Options
   541→// =============================================================================
   542→
   543→const routeOptions = {
   544→  middleware: {
   545→    requireCredits,
   546→    requireFeature,
   547→    authenticateToken
   548→  },
   549→  services: {
   550→    usageTracking,
   551→    referralService,
   552→    licenseService,
   553→    emailService,
   554→    stripe
   555→  },
   556→  authHelpers: {
   557→    generateToken,
   558→    generateRefreshToken,
   559→    verifyToken,
   560→    maskSensitiveData,
   561→    blacklistToken
   562→  },
   563→  staticCache: STATIC_RESPONSE_CACHE,
   564→  sendCachedResponse
   565→};
   566→
   567→// =============================================================================
   568→// Mount Routes
   569→// =============================================================================
   570→
   571→// Health check and system endpoints (no prefix)
   572→app.use('/', healthRoutes(routeOptions));
   573→
   574→// Core analysis endpoints
   575→app.use('/', analyzeRoutes(routeOptions));
   576→app.use('/', silencesRoutes(routeOptions));
   577→app.use('/', detectionRoutes(routeOptions));
   578→
   579→// Export endpoints
   580→app.use('/export', exportRoutes(routeOptions));
   581→
   582→// Multitrack/Multicam endpoints
   583→app.use('/multitrack', multitrackRoutes(routeOptions));
   584→
   585→// Cut list generation
   586→app.use('/cut-list', cutListRoutes(routeOptions));
   587→
   588→// Legacy XML processing endpoint (backwards compatibility)
   589→const { processXMLFile } = require('./services/xmlProcessor');
   590→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {
   591→  const {
   592→    xmlPath,
   593→    silences,
   594→    removeGaps = true,
   595→    outputPath = null
   596→  } = req.body;
   597→
   598→  if (!xmlPath) {
   599→    return res.status(400).json({ error: 'xmlPath is required' });
   600→  }
   601→
   602→  if (!silences || !Array.isArray(silences)) {
   603→    return res.status(400).json({ error: 'silences array is required' });
   604→  }
   605→
   606→  if (!fs.existsSync(xmlPath)) {
   607→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });
   608→  }
   609→
   610→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);
   611→
   612→  try {
   613→    const result = await processXMLFile(xmlPath, silences, {
   614→      outputPath,
   615→      removeGaps
   616→    });
   617→
   618→    res.json({
   619→      success: true,
   620→      inputPath: xmlPath,
   621→      outputPath: result.outputPath,
   622→      stats: result.stats
   623→    });
   624→  } catch (err) {
   625→    console.error('[SPLICE] XML processing error:', err);
   626→    res.status(500).json({ error: err.message });
   627→  }
   628→});
   629→
   630→// Auto zoom endpoints
   631→app.use('/zoom', zoomRoutes(routeOptions));
   632→
   633→// Chapter detection endpoints
   634→app.use('/chapters', chaptersRoutes(routeOptions));
   635→
   636→// YouTube content generation
   637→app.use('/youtube', youtubeRoutes(routeOptions));
   638→
   639→// Animated captions endpoints
   640→app.use('/captions', captionsRoutes(routeOptions));
   641→
   642→// Text-based editing endpoints
   643→app.use('/text-edit', textEditRoutes(routeOptions));
   644→
   645→// Social reframe endpoints
   646→app.use('/reframe', reframeRoutes(routeOptions));
   647→app.use('/faces', reframeRoutes.facesRouter(routeOptions));
   648→
   649→// Batch processing endpoints
   650→app.use('/batch', batchRoutes(routeOptions));
   651→
   652→// Authentication endpoints
   653→app.use('/auth', authRoutes(routeOptions));
   654→
   655→// Billing and credits endpoints
   656→app.use('/', billingRoutes(routeOptions));
   657→
   658→// Referral system endpoints
   659→app.use('/referral', referralRoutes(routeOptions));
   660→
   661→// License key endpoints
   662→app.use('/license', licenseRoutes(routeOptions));
   663→
   664→// AI Music generation endpoints
   665→app.use('/music', musicRoutes(routeOptions));
   666→
   667→// =============================================================================
   668→// Start Server
   669→// =============================================================================
   670→
   671→// Track active server for graceful shutdown
   672→let server = null;
   673→
   674→// Initialize database and start server
   675→async function startServer() {
   676→  try {
   677→    await usageTracking.initDatabase();
   678→    await referralService.initReferralTables();
   679→    await licenseService.initLicenseTables();
   680→    console.log('[SPLICE] Database initialized');
   681→
   682→    // PERF-FIX: Initialize static response cache at startup
   683→    initializeStaticCache();
   684→
   685→    if (isProduction || !httpsOptions) {
   686→      // Production: Railway provides TLS termination, use HTTP
   687→      server = http.createServer(app).listen(PORT, () => {
   688→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);
   689→      });
   690→    } else {
   691→      // Development: Use HTTPS with local certificates
   692→      server = https.createServer(httpsOptions, app).listen(PORT, () => {
   693→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);
   694→        console.log(`[SPLICE] POST /analyze with { "wavPath": "/path/to/audio.wav" }`);
   695→      });
   696→    }
   697→  } catch (err) {
   698→    console.error('[SPLICE] Failed to start server:', err);
   699→    process.exit(1);
   700→  }
   701→}
   702→
   703→// =============================================================================
   704→// Graceful Shutdown
   705→// =============================================================================
   706→
   707→async function gracefulShutdown(signal) {
   708→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);
   709→
   710→  // Stop accepting new connections
   711→  if (server) {
   712→    server.close(() => {
   713→      console.log('[SPLICE] HTTP server closed');
   714→    });
   715→  }
   716→
   717→  // Close database pool
   718→  try {
   719→    await usageTracking.closePool();
   720→    console.log('[SPLICE] Database pool closed');
   721→  } catch (err) {
   722→    console.error('[SPLICE] Error closing database pool:', err.message);
   723→  }
   724→
   725→  // Give ongoing requests time to complete (max 10 seconds)
   726→  setTimeout(() => {
   727→    console.log('[SPLICE] Graceful shutdown complete');
   728→    process.exit(0);
   729→  }, 10000);
   730→}
   731→
   732→// Handle termination signals
   733→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
   734→process.on('SIGINT', () => gracefulShutdown('SIGINT'));
   735→
   736→// Handle uncaught exceptions
   737→process.on('uncaughtException', (err) => {
   738→  console.error('[SPLICE] Uncaught exception:', err);
   739→  gracefulShutdown('uncaughtException');
   740→});
   741→
   742→process.on('unhandledRejection', (reason, promise) => {
   743→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);
   744→});
   745→
   746→startServer();
   747→

</system-reminder>
