     1→/**
     2→ * Chapters Routes
     3→ *
     4→ * Chapter detection and divider generation endpoints
     5→ */
     6→
     7→const express = require('express');
     8→const fsPromises = require('fs').promises;
     9→const fs = require('fs');
    10→const { transcribeAudio } = require('../services/transcription');
    11→const { detectChapters, detectChaptersFallback, generateChapterDividers, getDividerPresets } = require('../services/chapterDetection');
    12→
    13→// Async file existence check (non-blocking)
    14→async function fileExists(filePath) {
    15→  try {
    16→    await fsPromises.access(filePath, fs.constants.R_OK);
    17→    return true;
    18→  } catch {
    19→    return false;
    20→  }
    21→}
    22→
    23→/**
    24→ * Create chapters routes
    25→ * @param {Object} options - Route configuration options
    26→ * @param {Object} options.middleware - Shared middleware (requireCredits)
    27→ * @returns {express.Router}
    28→ */
    29→function createChaptersRoutes(options = {}) {
    30→  const router = express.Router();
    31→  const { requireCredits } = options.middleware || {};
    32→
    33→  /**
    34→   * POST / - Detect chapters in transcript using AI
    35→   *
    36→   * Analyzes transcript to identify natural topic/chapter boundaries.
    37→   * Returns chapter data with YouTube timestamps and timeline markers.
    38→   *
    39→   * Body:
    40→   * - transcript: Transcript object with text/segments
    41→   * - wavPath: Optional path to audio file (will transcribe if no transcript)
    42→   * - settings: {
    43→   *     maxChapters: number (default 10),
    44→   *     minChapterLength: number in seconds (default 60),
    45→   *     titleStyle: 'standard' | 'youtube' | 'shorts' (default 'standard')
    46→   *   }
    47→   */
    48→  router.post('/', requireCredits({ endpoint: 'chapters' }), async (req, res) => {
    49→    const {
    50→      transcript,
    51→      wavPath,
    52→      settings = {}
    53→    } = req.body;
    54→
    55→    // Get transcript from wavPath if not provided directly
    56→    let transcriptData = transcript;
    57→    if (!transcriptData && wavPath) {
    58→      if (!(await fileExists(wavPath))) {
    59→        return res.status(404).json({ error: `File not found: ${wavPath}` });
    60→      }
    61→      try {
    62→        transcriptData = await transcribeAudio(wavPath);
    63→      } catch (err) {
    64→        return res.status(500).json({ error: `Transcription failed: ${err.message}` });
    65→      }
    66→    }
    67→
    68→    if (!transcriptData) {
    69→      return res.status(400).json({ error: 'transcript or wavPath is required' });
    70→    }
    71→
    72→    console.log(`[SPLICE] Detecting chapters (max ${settings.maxChapters || 10}, style: ${settings.titleStyle || 'standard'})`);
    73→
    74→    try {
    75→      const result = await detectChapters(transcriptData, settings);
    76→
    77→      // Deduct usage (5 seconds per detection)
    78→      const usageSeconds = 5;
    79→      let balance = null;
    80→      if (req.deductUsage) {
    81→        balance = await req.deductUsage(usageSeconds);
    82→      }
    83→
    84→      res.json({
    85→        success: true,
    86→        ...result,
    87→        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined
    88→      });
    89→    } catch (err) {
    90→      console.error('[SPLICE] Chapter detection error:', err);
    91→      res.status(500).json({ error: err.message });
    92→    }
    93→  });
    94→
    95→  /**
    96→   * POST /fallback - Detect chapters without AI (gap-based)
    97→   *
    98→   * Uses silence gaps to identify potential chapter boundaries.
    99→   * Faster but less accurate than AI-based detection.
   100→   */
   101→  router.post('/fallback', requireCredits({ endpoint: 'chapters' }), async (req, res) => {
   102→    const { transcript, settings = {} } = req.body;
   103→
   104→    if (!transcript) {
   105→      return res.status(400).json({ error: 'transcript is required' });
   106→    }
   107→
   108→    try {
   109→      const result = detectChaptersFallback(transcript, settings);
   110→
   111→      res.json({
   112→        success: true,
   113→        ...result
   114→      });
   115→    } catch (err) {
   116→      console.error('[SPLICE] Chapter fallback error:', err);
   117→      res.status(500).json({ error: err.message });
   118→    }
   119→  });
   120→
   121→  /**
   122→   * POST /dividers - Generate chapter divider data for timeline insertion
   123→   *
   124→   * Takes chapter data and generates divider clip information with styling,
   125→   * colors, animation, and timing for inserting visual chapter separators.
   126→   */
   127→  router.post('/dividers', requireCredits({ endpoint: 'chapters' }), async (req, res) => {
   128→    const { chapters, settings = {} } = req.body;
   129→
   130→    if (!chapters || !Array.isArray(chapters) || chapters.length === 0) {
   131→      return res.status(400).json({ error: 'chapters array is required' });
   132→    }
   133→
   134→    // Validate chapter objects
   135→    for (let i = 0; i < chapters.length; i++) {
   136→      const ch = chapters[i];
   137→      if (typeof ch.startTime !== 'number') {
   138→        return res.status(400).json({
   139→          error: `Invalid chapter at index ${i}: startTime must be a number`
   140→        });
   141→      }
   142→      if (!ch.title || typeof ch.title !== 'string') {
   143→        return res.status(400).json({
   144→          error: `Invalid chapter at index ${i}: title is required`
   145→        });
   146→      }
   147→    }
   148→
   149→    try {
   150→      const result = generateChapterDividers(chapters, settings);
   151→
   152→      // Deduct usage
   153→      if (req.deductUsage) {
   154→        await req.deductUsage(result.metadata.count * 0.1); // 0.1 credits per divider
   155→      }
   156→
   157→      res.json({
   158→        success: true,
   159→        ...result
   160→      });
   161→    } catch (err) {
   162→      console.error('[SPLICE] Chapter dividers error:', err);
   163→      res.status(500).json({ error: err.message });
   164→    }
   165→  });
   166→
   167→  /**
   168→   * GET /dividers/presets - Get available divider styles and presets
   169→   */
   170→  router.get('/dividers/presets', (req, res) => {
   171→    res.json(getDividerPresets());
   172→  });
   173→
   174→  return router;
   175→}
   176→
   177→module.exports = createChaptersRoutes;
   178→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
