     1→/**
     2→ * Centralized Error Handling Middleware
     3→ *
     4→ * Provides unified error handling across all endpoints:
     5→ * - Custom error classes for different error types
     6→ * - Consistent JSON response format
     7→ * - Error codes enum for client-side handling
     8→ * - Async handler wrapper to eliminate try-catch boilerplate
     9→ *
    10→ * @module middleware/errorHandler
    11→ */
    12→
    13→// =============================================================================
    14→// Error Codes Enum
    15→// =============================================================================
    16→
    17→/**
    18→ * Standardized error codes for client-side handling
    19→ */
    20→const ErrorCodes = {
    21→  // Authentication errors (401)
    22→  AUTH_REQUIRED: 'AUTH_REQUIRED',
    23→  AUTH_INVALID: 'AUTH_INVALID',
    24→  AUTH_EXPIRED: 'AUTH_EXPIRED',
    25→
    26→  // Validation errors (400)
    27→  VALIDATION_ERROR: 'VALIDATION_ERROR',
    28→  MISSING_FIELD: 'MISSING_FIELD',
    29→  INVALID_FORMAT: 'INVALID_FORMAT',
    30→
    31→  // Resource errors (404)
    32→  NOT_FOUND: 'NOT_FOUND',
    33→  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',
    34→  FILE_NOT_FOUND: 'FILE_NOT_FOUND',
    35→
    36→  // Rate limiting / billing (402, 429)
    37→  RATE_LIMITED: 'RATE_LIMITED',
    38→  CREDITS_EXHAUSTED: 'CREDITS_EXHAUSTED',
    39→  PAYMENT_REQUIRED: 'PAYMENT_REQUIRED',
    40→
    41→  // Permission errors (403)
    42→  ACCESS_DENIED: 'ACCESS_DENIED',
    43→  OWNERSHIP_REQUIRED: 'OWNERSHIP_REQUIRED',
    44→
    45→  // External service errors (502, 503)
    46→  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',
    47→  TRANSCRIPTION_FAILED: 'TRANSCRIPTION_FAILED',
    48→  AI_SERVICE_UNAVAILABLE: 'AI_SERVICE_UNAVAILABLE',
    49→  DEPENDENCY_MISSING: 'DEPENDENCY_MISSING',
    50→
    51→  // File errors (413)
    52→  FILE_TOO_LARGE: 'FILE_TOO_LARGE',
    53→
    54→  // Internal errors (500)
    55→  INTERNAL_ERROR: 'INTERNAL_ERROR',
    56→  DATABASE_ERROR: 'DATABASE_ERROR',
    57→  CONFIGURATION_ERROR: 'CONFIGURATION_ERROR'
    58→};
    59→
    60→// =============================================================================
    61→// Custom Error Classes
    62→// =============================================================================
    63→
    64→/**
    65→ * Base application error class
    66→ * All custom errors extend this class
    67→ */
    68→class AppError extends Error {
    69→  /**
    70→   * @param {string} message - Human-readable error message
    71→   * @param {number} statusCode - HTTP status code (default: 500)
    72→   * @param {string} code - Error code from ErrorCodes enum
    73→   * @param {object} details - Optional additional error details
    74→   */
    75→  constructor(message, statusCode = 500, code = ErrorCodes.INTERNAL_ERROR, details = null) {
    76→    super(message);
    77→    this.name = this.constructor.name;
    78→    this.statusCode = statusCode;
    79→    this.code = code;
    80→    this.details = details;
    81→    this.isOperational = true; // Distinguishes from programming errors
    82→
    83→    Error.captureStackTrace(this, this.constructor);
    84→  }
    85→
    86→  /**
    87→   * Convert error to JSON response format
    88→   */
    89→  toJSON() {
    90→    const response = {
    91→      success: false,
    92→      error: {
    93→        code: this.code,
    94→        message: this.message
    95→      }
    96→    };
    97→
    98→    if (this.details) {
    99→      response.error.details = this.details;
   100→    }
   101→
   102→    return response;
   103→  }
   104→}
   105→
   106→/**
   107→ * Validation error (400) - Invalid input data
   108→ */
   109→class ValidationError extends AppError {
   110→  constructor(message, details = null) {
   111→    super(message, 400, ErrorCodes.VALIDATION_ERROR, details);
   112→  }
   113→
   114→  /**
   115→   * Create a missing field error
   116→   * @param {string} fieldName - Name of the missing field
   117→   */
   118→  static missingField(fieldName) {
   119→    return new ValidationError(
   120→      `${fieldName} is required`,
   121→      { field: fieldName, code: ErrorCodes.MISSING_FIELD }
   122→    );
   123→  }
   124→
   125→  /**
   126→   * Create an invalid format error
   127→   * @param {string} fieldName - Name of the field
   128→   * @param {string} expectedFormat - Description of expected format
   129→   */
   130→  static invalidFormat(fieldName, expectedFormat) {
   131→    return new ValidationError(
   132→      `Invalid ${fieldName} format. Expected: ${expectedFormat}`,
   133→      { field: fieldName, expected: expectedFormat, code: ErrorCodes.INVALID_FORMAT }
   134→    );
   135→  }
   136→}
   137→
   138→/**
   139→ * Authentication error (401) - Missing or invalid credentials
   140→ */
   141→class AuthenticationError extends AppError {
   142→  constructor(message = 'Authentication required', code = ErrorCodes.AUTH_REQUIRED) {
   143→    super(message, 401, code);
   144→  }
   145→
   146→  static required() {
   147→    return new AuthenticationError('Authentication required', ErrorCodes.AUTH_REQUIRED);
   148→  }
   149→
   150→  static invalid() {
   151→    return new AuthenticationError('Invalid credentials', ErrorCodes.AUTH_INVALID);
   152→  }
   153→
   154→  static expired() {
   155→    return new AuthenticationError('Token has expired. Please log in again', ErrorCodes.AUTH_EXPIRED);
   156→  }
   157→}
   158→
   159→/**
   160→ * Not found error (404) - Resource doesn't exist
   161→ */
   162→class NotFoundError extends AppError {
   163→  constructor(message, resourceType = null) {
   164→    const code = resourceType === 'file' ? ErrorCodes.FILE_NOT_FOUND : ErrorCodes.RESOURCE_NOT_FOUND;
   165→    super(message, 404, code, resourceType ? { resourceType } : null);
   166→  }
   167→
   168→  static file(filePath) {
   169→    return new NotFoundError(`File not found: ${filePath}`, 'file');
   170→  }
   171→
   172→  static resource(resourceType, id) {
   173→    return new NotFoundError(`${resourceType} not found${id ? `: ${id}` : ''}`, resourceType);
   174→  }
   175→}
   176→
   177→/**
   178→ * Access denied error (403) - User lacks permission
   179→ */
   180→class AccessDeniedError extends AppError {
   181→  constructor(message = 'Access denied', code = ErrorCodes.ACCESS_DENIED) {
   182→    super(message, 403, code);
   183→  }
   184→
   185→  static ownership() {
   186→    return new AccessDeniedError('Access denied: Resource belongs to another user', ErrorCodes.OWNERSHIP_REQUIRED);
   187→  }
   188→}
   189→
   190→/**
   191→ * Rate limit error (429 or 402) - Too many requests or credits exhausted
   192→ */
   193→class RateLimitError extends AppError {
   194→  constructor(message, details = null) {
   195→    super(message, 429, ErrorCodes.RATE_LIMITED, details);
   196→  }
   197→
   198→  static creditsExhausted(balance = null) {
   199→    const error = new RateLimitError(
   200→      'Insufficient credits. Please upgrade your plan or wait for your next billing cycle',
   201→      balance ? { balance } : null
   202→    );
   203→    error.statusCode = 402;
   204→    error.code = ErrorCodes.CREDITS_EXHAUSTED;
   205→    return error;
   206→  }
   207→}
   208→
   209→/**
   210→ * External service error (502/503) - Third-party service failure
   211→ */
   212→class ExternalServiceError extends AppError {
   213→  constructor(message, serviceName, originalError = null) {
   214→    const details = { service: serviceName };
   215→    if (originalError && originalError.message) {
   216→      details.originalError = originalError.message;
   217→    }
   218→    super(message, 502, ErrorCodes.EXTERNAL_SERVICE_ERROR, details);
   219→    this.serviceName = serviceName;
   220→  }
   221→
   222→  static transcription(originalError = null) {
   223→    const error = new ExternalServiceError(
   224→      'Transcription service failed',
   225→      'whisper',
   226→      originalError
   227→    );
   228→    error.code = ErrorCodes.TRANSCRIPTION_FAILED;
   229→    return error;
   230→  }
   231→
   232→  static unavailable(serviceName) {
   233→    const error = new ExternalServiceError(
   234→      `${serviceName} service is not available`,
   235→      serviceName
   236→    );
   237→    error.statusCode = 503;
   238→    error.code = ErrorCodes.AI_SERVICE_UNAVAILABLE;
   239→    return error;
   240→  }
   241→
   242→  static missingDependency(dependencyName, installHint = null) {
   243→    const details = { dependency: dependencyName };
   244→    if (installHint) {
   245→      details.hint = installHint;
   246→    }
   247→    const error = new ExternalServiceError(
   248→      `${dependencyName} is not installed`,
   249→      dependencyName
   250→    );
   251→    error.statusCode = 500;
   252→    error.code = ErrorCodes.DEPENDENCY_MISSING;
   253→    error.details = details;
   254→    return error;
   255→  }
   256→}
   257→
   258→/**
   259→ * File too large error (413) - Payload exceeds limit
   260→ */
   261→class FileTooLargeError extends AppError {
   262→  constructor(message, details = null) {
   263→    super(message, 413, ErrorCodes.FILE_TOO_LARGE, details);
   264→  }
   265→
   266→  static exceeds(actualSizeMB, maxSizeMB) {
   267→    return new FileTooLargeError(
   268→      `File too large (${actualSizeMB.toFixed(1)}MB). Maximum allowed: ${maxSizeMB}MB`,
   269→      { actualSizeMB, maxSizeMB }
   270→    );
   271→  }
   272→}
   273→
   274→/**
   275→ * Database error (500) - Database operation failed
   276→ */
   277→class DatabaseError extends AppError {
   278→  constructor(message = 'Database operation failed', originalError = null) {
   279→    const details = originalError ? { originalError: originalError.message } : null;
   280→    super(message, 500, ErrorCodes.DATABASE_ERROR, details);
   281→  }
   282→}
   283→
   284→// =============================================================================
   285→// Async Handler Wrapper
   286→// =============================================================================
   287→
   288→/**
   289→ * Wraps async route handlers to automatically catch errors
   290→ * Eliminates try-catch boilerplate in every endpoint
   291→ *
   292→ * @param {Function} fn - Async route handler function
   293→ * @returns {Function} Express middleware function
   294→ *
   295→ * @example
   296→ * app.post('/analyze', requireCredits(), asyncHandler(async (req, res) => {
   297→ *   const result = await someAsyncOperation();
   298→ *   res.json({ success: true, result });
   299→ * }));
   300→ */
   301→function asyncHandler(fn) {
   302→  return (req, res, next) => {
   303→    Promise.resolve(fn(req, res, next)).catch(next);
   304→  };
   305→}
   306→
   307→// =============================================================================
   308→// Global Error Handler Middleware
   309→// =============================================================================
   310→
   311→/**
   312→ * Global error handler middleware
   313→ * Must be registered last in the middleware chain
   314→ *
   315→ * Handles:
   316→ * - AppError subclasses (operational errors)
   317→ * - Standard JavaScript errors
   318→ * - Unknown errors
   319→ *
   320→ * @param {Error} err - Error object
   321→ * @param {Request} req - Express request
   322→ * @param {Response} res - Express response
   323→ * @param {Function} next - Express next function
   324→ */
   325→function errorHandler(err, req, res, _next) {
   326→  // Log error (with stack trace in development)
   327→  const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;
   328→
   329→  if (err.isOperational) {
   330→    // Operational errors - log warning level
   331→    console.warn(`[SPLICE] ${err.name}: ${err.message}`, {
   332→      code: err.code,
   333→      statusCode: err.statusCode,
   334→      path: req.path,
   335→      method: req.method
   336→    });
   337→  } else {
   338→    // Programming errors - log error level with stack
   339→    console.error(`[SPLICE] Unexpected error:`, {
   340→      message: err.message,
   341→      stack: isProduction ? undefined : err.stack,
   342→      path: req.path,
   343→      method: req.method
   344→    });
   345→  }
   346→
   347→  // Handle AppError subclasses
   348→  if (err instanceof AppError) {
   349→    return res.status(err.statusCode).json(err.toJSON());
   350→  }
   351→
   352→  // Handle Stripe errors
   353→  if (err.type && err.type.startsWith('Stripe')) {
   354→    return res.status(400).json({
   355→      success: false,
   356→      error: {
   357→        code: 'STRIPE_ERROR',
   358→        message: isProduction ? 'Payment processing error' : err.message
   359→      }
   360→    });
   361→  }
   362→
   363→  // Handle JSON parse errors
   364→  if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
   365→    return res.status(400).json({
   366→      success: false,
   367→      error: {
   368→        code: ErrorCodes.VALIDATION_ERROR,
   369→        message: 'Invalid JSON in request body'
   370→      }
   371→    });
   372→  }
   373→
   374→  // Handle unknown/unexpected errors
   375→  const response = {
   376→    success: false,
   377→    error: {
   378→      code: ErrorCodes.INTERNAL_ERROR,
   379→      message: isProduction ? 'An unexpected error occurred' : err.message
   380→    }
   381→  };
   382→
   383→  // Include stack trace in development
   384→  if (!isProduction && err.stack) {
   385→    response.error.stack = err.stack;
   386→  }
   387→
   388→  return res.status(500).json(response);
   389→}
   390→
   391→/**
   392→ * 404 handler for unmatched routes
   393→ * Register before the global error handler
   394→ */
   395→function notFoundHandler(req, res, next) {
   396→  next(new NotFoundError(`Route not found: ${req.method} ${req.path}`, 'route'));
   397→}
   398→
   399→// =============================================================================
   400→// Helper Functions
   401→// =============================================================================
   402→
   403→/**
   404→ * SECURITY: Sanitize error message for production
   405→ * Hides internal error details from clients in production
   406→ *
   407→ * @param {Error} err - Error object
   408→ * @param {string} fallbackMessage - Message to show in production
   409→ * @returns {string} Sanitized error message
   410→ */
   411→function sanitizeError(err, fallbackMessage = 'An error occurred') {
   412→  const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;
   413→
   414→  // In production, only show the fallback message
   415→  // Exception: If error is an AppError (operational), show its message
   416→  if (isProduction) {
   417→    if (err instanceof AppError && err.isOperational) {
   418→      return err.message;
   419→    }
   420→    return fallbackMessage;
   421→  }
   422→
   423→  // In development, show full error message
   424→  return err.message || fallbackMessage;
   425→}
   426→
   427→/**
   428→ * SECURITY: Create sanitized error response
   429→ * Use this instead of directly using err.message in responses
   430→ *
   431→ * @param {Error} err - Error object
   432→ * @param {string} fallbackMessage - Message to show in production
   433→ * @returns {Object} Sanitized error response object
   434→ */
   435→function createErrorResponse(err, fallbackMessage = 'An error occurred') {
   436→  return { error: sanitizeError(err, fallbackMessage) };
   437→}
   438→
   439→/**
   440→ * Validate required fields in request body
   441→ * Throws ValidationError if any field is missing
   442→ *
   443→ * @param {object} body - Request body
   444→ * @param {string[]} requiredFields - Array of required field names
   445→ * @throws {ValidationError} If any required field is missing
   446→ */
   447→function validateRequired(body, requiredFields) {
   448→  for (const field of requiredFields) {
   449→    if (body[field] === undefined || body[field] === null || body[field] === '') {
   450→      throw ValidationError.missingField(field);
   451→    }
   452→  }
   453→}
   454→
   455→/**
   456→ * Validate that at least one of the specified fields is present
   457→ *
   458→ * @param {object} body - Request body
   459→ * @param {string[]} fields - Array of field names (at least one required)
   460→ * @param {string} message - Custom error message
   461→ * @throws {ValidationError} If none of the fields are present
   462→ */
   463→function validateOneOf(body, fields, message) {
   464→  const hasOne = fields.some(f => body[f] !== undefined && body[f] !== null && body[f] !== '');
   465→  if (!hasOne) {
   466→    throw new ValidationError(message || `At least one of ${fields.join(', ')} is required`);
   467→  }
   468→}
   469→
   470→/**
   471→ * Validate array field
   472→ *
   473→ * @param {object} body - Request body
   474→ * @param {string} fieldName - Field name
   475→ * @param {object} options - Validation options
   476→ * @param {boolean} options.required - Whether field is required
   477→ * @param {number} options.minLength - Minimum array length
   478→ * @throws {ValidationError} If validation fails
   479→ */
   480→function validateArray(body, fieldName, options = {}) {
   481→  const { required = true, minLength = 0 } = options;
   482→  const value = body[fieldName];
   483→
   484→  if (required && (value === undefined || value === null)) {
   485→    throw ValidationError.missingField(fieldName);
   486→  }
   487→
   488→  if (value !== undefined && value !== null) {
   489→    if (!Array.isArray(value)) {
   490→      throw new ValidationError(`${fieldName} must be an array`);
   491→    }
   492→    if (value.length < minLength) {
   493→      throw new ValidationError(
   494→        `${fieldName} must have at least ${minLength} item${minLength === 1 ? '' : 's'}`
   495→      );
   496→    }
   497→  }
   498→}
   499→
   500→/**
   501→ * Validate numeric field
   502→ *
   503→ * @param {object} body - Request body
   504→ * @param {string} fieldName - Field name
   505→ * @param {object} options - Validation options
   506→ * @param {number} options.min - Minimum value
   507→ * @param {number} options.max - Maximum value
   508→ * @param {boolean} options.required - Whether field is required
   509→ * @throws {ValidationError} If validation fails
   510→ */
   511→function validateNumber(body, fieldName, options = {}) {
   512→  const { min, max, required = false } = options;
   513→  const value = body[fieldName];
   514→
   515→  if (required && (value === undefined || value === null)) {
   516→    throw ValidationError.missingField(fieldName);
   517→  }
   518→
   519→  if (value !== undefined && value !== null) {
   520→    if (typeof value !== 'number' || isNaN(value)) {
   521→      throw new ValidationError(`${fieldName} must be a number`);
   522→    }
   523→    if (min !== undefined && value < min) {
   524→      throw new ValidationError(`${fieldName} must be at least ${min}`);
   525→    }
   526→    if (max !== undefined && value > max) {
   527→      throw new ValidationError(`${fieldName} must be at most ${max}`);
   528→    }
   529→  }
   530→}
   531→
   532→// =============================================================================
   533→// Exports
   534→// =============================================================================
   535→
   536→module.exports = {
   537→  // Error codes
   538→  ErrorCodes,
   539→
   540→  // Error classes
   541→  AppError,
   542→  ValidationError,
   543→  AuthenticationError,
   544→  NotFoundError,
   545→  AccessDeniedError,
   546→  RateLimitError,
   547→  ExternalServiceError,
   548→  FileTooLargeError,
   549→  DatabaseError,
   550→
   551→  // Middleware
   552→  asyncHandler,
   553→  errorHandler,
   554→  notFoundHandler,
   555→
   556→  // Validation helpers
   557→  validateRequired,
   558→  validateOneOf,
   559→  validateArray,
   560→  validateNumber,
   561→
   562→  // Error sanitization
   563→  sanitizeError,
   564→  createErrorResponse
   565→};
   566→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
