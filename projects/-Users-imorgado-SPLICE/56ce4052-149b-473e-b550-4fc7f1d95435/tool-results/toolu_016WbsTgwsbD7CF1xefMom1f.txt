     1→/**
     2→ * Input Validation Middleware
     3→ *
     4→ * Provides type validation and sanitization for API request parameters
     5→ * to prevent type confusion attacks and ensure data integrity.
     6→ */
     7→
     8→/**
     9→ * Validate that a value is a non-empty string
    10→ * @param {any} value - Value to validate
    11→ * @param {string} fieldName - Name of the field for error messages
    12→ * @returns {{valid: boolean, value?: string, error?: string}}
    13→ */
    14→function validateString(value, fieldName, options = {}) {
    15→  const { maxLength = 10000, allowEmpty = false } = options;
    16→
    17→  if (value === null || value === undefined) {
    18→    return { valid: false, error: `${fieldName} is required` };
    19→  }
    20→
    21→  if (typeof value !== 'string') {
    22→    return { valid: false, error: `${fieldName} must be a string` };
    23→  }
    24→
    25→  if (!allowEmpty && value.trim() === '') {
    26→    return { valid: false, error: `${fieldName} cannot be empty` };
    27→  }
    28→
    29→  if (value.length > maxLength) {
    30→    return { valid: false, error: `${fieldName} exceeds maximum length of ${maxLength}` };
    31→  }
    32→
    33→  return { valid: true, value: value.trim() };
    34→}
    35→
    36→/**
    37→ * Validate that a value is a number within range
    38→ * @param {any} value - Value to validate
    39→ * @param {string} fieldName - Name of the field for error messages
    40→ * @param {Object} options - Validation options
    41→ * @returns {{valid: boolean, value?: number, error?: string}}
    42→ */
    43→function validateNumber(value, fieldName, options = {}) {
    44→  const { min = -Infinity, max = Infinity, allowNegative = true } = options;
    45→
    46→  if (value === null || value === undefined) {
    47→    return { valid: false, error: `${fieldName} is required` };
    48→  }
    49→
    50→  const num = typeof value === 'string' ? parseFloat(value) : value;
    51→
    52→  if (typeof num !== 'number' || isNaN(num)) {
    53→    return { valid: false, error: `${fieldName} must be a valid number` };
    54→  }
    55→
    56→  if (!allowNegative && num < 0) {
    57→    return { valid: false, error: `${fieldName} cannot be negative` };
    58→  }
    59→
    60→  if (num < min || num > max) {
    61→    return { valid: false, error: `${fieldName} must be between ${min} and ${max}` };
    62→  }
    63→
    64→  return { valid: true, value: num };
    65→}
    66→
    67→/**
    68→ * Validate that a value is a boolean
    69→ * @param {any} value - Value to validate
    70→ * @param {string} fieldName - Name of the field for error messages
    71→ * @returns {{valid: boolean, value?: boolean, error?: string}}
    72→ */
    73→function validateBoolean(value, fieldName) {
    74→  if (value === null || value === undefined) {
    75→    return { valid: true, value: false }; // Default to false
    76→  }
    77→
    78→  if (typeof value === 'boolean') {
    79→    return { valid: true, value };
    80→  }
    81→
    82→  if (value === 'true' || value === '1') {
    83→    return { valid: true, value: true };
    84→  }
    85→
    86→  if (value === 'false' || value === '0') {
    87→    return { valid: true, value: false };
    88→  }
    89→
    90→  return { valid: false, error: `${fieldName} must be a boolean` };
    91→}
    92→
    93→/**
    94→ * Validate that a value is an array
    95→ * @param {any} value - Value to validate
    96→ * @param {string} fieldName - Name of the field for error messages
    97→ * @param {Object} options - Validation options
    98→ * @returns {{valid: boolean, value?: Array, error?: string}}
    99→ */
   100→function validateArray(value, fieldName, options = {}) {
   101→  const { maxItems = 10000, minItems = 0 } = options;
   102→
   103→  if (value === null || value === undefined) {
   104→    if (minItems > 0) {
   105→      return { valid: false, error: `${fieldName} is required` };
   106→    }
   107→    return { valid: true, value: [] };
   108→  }
   109→
   110→  if (!Array.isArray(value)) {
   111→    return { valid: false, error: `${fieldName} must be an array` };
   112→  }
   113→
   114→  if (value.length < minItems) {
   115→    return { valid: false, error: `${fieldName} must have at least ${minItems} items` };
   116→  }
   117→
   118→  if (value.length > maxItems) {
   119→    return { valid: false, error: `${fieldName} exceeds maximum of ${maxItems} items` };
   120→  }
   121→
   122→  return { valid: true, value };
   123→}
   124→
   125→/**
   126→ * Validate that a value is one of a set of allowed values
   127→ * @param {any} value - Value to validate
   128→ * @param {string} fieldName - Name of the field for error messages
   129→ * @param {Array} allowedValues - Array of allowed values
   130→ * @returns {{valid: boolean, value?: any, error?: string}}
   131→ */
   132→function validateEnum(value, fieldName, allowedValues) {
   133→  if (value === null || value === undefined) {
   134→    return { valid: false, error: `${fieldName} is required` };
   135→  }
   136→
   137→  if (!allowedValues.includes(value)) {
   138→    return { valid: false, error: `${fieldName} must be one of: ${allowedValues.join(', ')}` };
   139→  }
   140→
   141→  return { valid: true, value };
   142→}
   143→
   144→/**
   145→ * Create a validation middleware for a specific endpoint
   146→ * @param {Object} schema - Validation schema
   147→ * @returns {Function} Express middleware
   148→ */
   149→function createValidator(schema) {
   150→  return (req, res, next) => {
   151→    const errors = [];
   152→    const validated = {};
   153→
   154→    for (const [field, rules] of Object.entries(schema)) {
   155→      const value = req.body[field];
   156→      let result;
   157→
   158→      switch (rules.type) {
   159→        case 'string':
   160→          result = validateString(value, field, rules);
   161→          break;
   162→        case 'number':
   163→          result = validateNumber(value, field, rules);
   164→          break;
   165→        case 'boolean':
   166→          result = validateBoolean(value, field);
   167→          break;
   168→        case 'array':
   169→          result = validateArray(value, field, rules);
   170→          break;
   171→        case 'enum':
   172→          result = validateEnum(value, field, rules.values);
   173→          break;
   174→        default:
   175→          result = { valid: true, value };
   176→      }
   177→
   178→      if (!result.valid) {
   179→        if (!rules.optional) {
   180→          errors.push(result.error);
   181→        }
   182→      } else {
   183→        validated[field] = result.value;
   184→      }
   185→    }
   186→
   187→    if (errors.length > 0) {
   188→      return res.status(400).json({
   189→        error: 'Validation failed',
   190→        details: errors
   191→      });
   192→    }
   193→
   194→    // Attach validated data to request
   195→    req.validatedBody = validated;
   196→    next();
   197→  };
   198→}
   199→
   200→/**
   201→ * Common validation schemas for endpoints
   202→ */
   203→const validationSchemas = {
   204→  analyze: {
   205→    wavPath: { type: 'string', maxLength: 1000 },
   206→    detectTakes: { type: 'boolean', optional: true }
   207→  },
   208→  silences: {
   209→    wavPath: { type: 'string', maxLength: 1000 },
   210→    sensitivity: { type: 'number', min: 0, max: 100, optional: true },
   211→    minSilenceLength: { type: 'number', min: 0.1, max: 60, optional: true }
   212→  },
   213→  cutList: {
   214→    sourceName: { type: 'string', maxLength: 500, optional: true },
   215→    sourcePath: { type: 'string', maxLength: 1000, optional: true },
   216→    duration: { type: 'number', min: 0, max: 86400 },
   217→    silences: { type: 'array', maxItems: 10000 }
   218→  },
   219→  chapters: {
   220→    wavPath: { type: 'string', maxLength: 1000 },
   221→    transcript: { type: 'string', maxLength: 1000000, optional: true }
   222→  },
   223→  musicGenerate: {
   224→    mood: { type: 'string', maxLength: 100 },
   225→    duration: { type: 'number', min: 15, max: 600 },
   226→    instruments: { type: 'array', maxItems: 20, optional: true }
   227→  }
   228→};
   229→
   230→module.exports = {
   231→  validateString,
   232→  validateNumber,
   233→  validateBoolean,
   234→  validateArray,
   235→  validateEnum,
   236→  createValidator,
   237→  validationSchemas
   238→};
   239→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
