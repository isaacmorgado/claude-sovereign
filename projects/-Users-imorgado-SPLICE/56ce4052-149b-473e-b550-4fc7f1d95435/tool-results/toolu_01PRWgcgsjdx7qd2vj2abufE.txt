     1→/**
     2→ * Health Check Routes
     3→ *
     4→ * System health and status endpoints
     5→ */
     6→
     7→const express = require('express');
     8→const { isFFprobeInstalled } = require('../services/ffprobeSilence');
     9→const { isReplicateConfigured } = require('../services/vocalIsolation');
    10→const { checkDatabase } = require('../services/usageTracking');
    11→
    12→/**
    13→ * Create health routes
    14→ * @param {Object} options - Route configuration options
    15→ * @returns {express.Router}
    16→ */
    17→function createHealthRoutes(_options = {}) {
    18→  const router = express.Router();
    19→
    20→  /**
    21→   * GET / - API information
    22→   */
    23→  router.get('/', (req, res) => {
    24→    res.json({
    25→      service: 'splice-backend',
    26→      version: '6.0.3',
    27→      endpoints: {
    28→        'GET /': 'This info',
    29→        'GET /health': 'Health check',
    30→        'GET /ffprobe-check': 'Check if FFprobe is installed',
    31→        'GET /replicate-check': 'Check if Replicate API is configured',
    32→        'POST /analyze': 'Analyze WAV file { wavPath }',
    33→        'POST /silences': 'Detect silences via Whisper gaps { wavPath, threshold: 0.5 }',
    34→        'POST /silences-audio': 'Detect silences via FFprobe { wavPath, threshold: -30, minDuration: 0.5, padding: 0.1 }',
    35→        'POST /silences-rms': 'Detect silences via RMS analysis { wavPath, threshold: -30, minSilenceLength: 0.5, paddingStart: 0.1, paddingEnd: 0.05, autoThreshold: false, sensitivity: 50 }',
    36→        'POST /profanity': 'Detect profanity in transcript { wavPath, language: "en", customBlocklist: [], customAllowlist: [] }',
    37→        'GET /profanity/languages': 'Get supported languages for profanity detection',
    38→        'GET /profanity/bleeps': 'Get available bleep sounds',
    39→        'POST /repetitions': 'Detect phrase repetitions and stutters { wavPath, phraseSize: 5, tolerance: 0.7, useOpenAI: false }',
    40→        'POST /fillers': 'Detect filler words (um, uh, like, etc.) { wavPath, customFillers: [] }',
    41→        'POST /stutters': 'Detect single-word stutters only { wavPath, minRepeats: 2 }',
    42→        'POST /export/captions': 'Export transcript to caption format { wavPath, format: srt|vtt|txt|json, outputPath? }',
    43→        'GET /export/formats': 'Get supported caption export formats',
    44→        'POST /multitrack': 'Analyze multiple audio tracks for multicam { audioPaths: [], speakerNames: [], videoTrackMapping: {} }',
    45→        'POST /multitrack/auto-balance': 'Auto-balance speaker screentime { audioPaths: [], speakerNames: [] }',
    46→        'POST /multitrack/advanced-balance': 'Advanced GA-optimized balancing { audioPaths: [], maxConsecutiveSeconds: 30, momentumFactor: 0.7 }',
    47→        'POST /process-xml': 'Process FCP XML { xmlPath, silences, removeGaps: true }',
    48→        'POST /cut-list': 'Generate JSON cut list for DOM building (v3.5) { sourceName, sourcePath, duration, silences, takes?, settings? }',
    49→        'POST /cut-list/takes': 'Generate cut list keeping only takes { sourceName, sourcePath, duration, takes, settings? }',
    50→        'POST /zoom': 'Generate zoom points from transcript { transcript, settings: { frequency, preset, placement } }',
    51→        'GET /zoom/presets': 'Get available zoom presets and frequencies',
    52→        'POST /chapters': 'Detect chapters in transcript using AI { transcript, settings: { maxChapters, minChapterLength } }',
    53→        'POST /chapters/fallback': 'Detect chapters without AI (gap-based) { transcript, settings }',
    54→        'POST /isolate-vocals': 'Isolate vocals from audio { audioPath }',
    55→        'POST /batch/silences': 'Batch process multiple files for silence detection { files: [], options: {} }',
    56→        'GET /batch/status/:jobId': 'Get batch job status',
    57→        'GET /batch/results/:jobId': 'Get full batch job results',
    58→        'GET /batch/jobs': 'List all batch jobs',
    59→        'DELETE /batch/:jobId': 'Delete a batch job',
    60→        'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',
    61→        'GET /usage-history': 'Get usage history (requires x-stripe-customer-id header)',
    62→        'POST /webhooks/stripe': 'Stripe webhook endpoint',
    63→        'GET /referral/code': 'Get or create referral code for user',
    64→        'POST /referral/validate': 'Validate a referral code',
    65→        'POST /referral/apply': 'Apply referral code at signup',
    66→        'GET /referral/stats': 'Get referral statistics for user',
    67→        'POST /license/activate': 'Activate license key { key: "SPLICE-XXXX-XXXX-XXXX" }',
    68→        'GET /license/key': 'Get license key for customer (requires x-stripe-customer-id)',
    69→        'POST /license/resend': 'Resend license key to customer email { customerId? }'
    70→      }
    71→    });
    72→  });
    73→
    74→  /**
    75→   * GET /health - Health check with database connectivity
    76→   */
    77→  router.get('/health', async (req, res) => {
    78→    const health = {
    79→      status: 'ok',
    80→      service: 'splice-backend',
    81→      version: '6.0.3',
    82→      timestamp: new Date().toISOString(),
    83→      checks: {
    84→        database: 'unknown'
    85→      }
    86→    };
    87→
    88→    try {
    89→      const dbHealthy = await checkDatabase();
    90→      health.checks.database = dbHealthy ? 'healthy' : 'unhealthy';
    91→    } catch (err) {
    92→      health.checks.database = 'error';
    93→      health.status = 'degraded';
    94→      console.error('[Health] Database check failed:', err.message);
    95→    }
    96→
    97→    const statusCode = health.status === 'ok' ? 200 : 503;
    98→    res.status(statusCode).json(health);
    99→  });
   100→
   101→  /**
   102→   * GET /ffprobe-check - Check if FFprobe is installed
   103→   */
   104→  router.get('/ffprobe-check', async (req, res) => {
   105→    const installed = await isFFprobeInstalled();
   106→    res.json({
   107→      installed,
   108→      message: installed
   109→        ? 'FFprobe is available'
   110→        : 'FFprobe not found. Install with: brew install ffmpeg'
   111→    });
   112→  });
   113→
   114→  /**
   115→   * GET /replicate-check - Check if Replicate API is configured
   116→   */
   117→  router.get('/replicate-check', async (req, res) => {
   118→    const configured = isReplicateConfigured();
   119→    res.json({
   120→      configured,
   121→      message: configured
   122→        ? 'Replicate API is configured'
   123→        : 'REPLICATE_API_TOKEN not set. Add to .env file.'
   124→    });
   125→  });
   126→
   127→  return router;
   128→}
   129→
   130→module.exports = createHealthRoutes;
   131→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
