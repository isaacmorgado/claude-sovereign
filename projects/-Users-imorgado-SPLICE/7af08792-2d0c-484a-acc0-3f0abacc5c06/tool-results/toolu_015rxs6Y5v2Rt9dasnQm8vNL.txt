   220→const formatSegmentsMatch = takeDetectionSource.match(/function formatSegments\(segments\) \{[\s\S]*?return segments[\s\S]*?\.join\('\\n'\);?\s*\}/);
   221→
   222→test('formatSegments function should be extractable', () => {
   223→  assertTrue(formatSegmentsMatch !== null, 'Should find formatSegments function');
   224→});
   225→
   226→// Create test function from extracted code
   227→if (formatSegmentsMatch) {
   228→  const formatSegmentsCode = formatSegmentsMatch[0];
   229→  const formatSegments = eval(`(${formatSegmentsCode.replace('function formatSegments', 'function')})`);
   230→
   231→  test('formatSegments formats single segment correctly', () => {
   232→    const segments = [{ start: 0, end: 5.5, text: 'Hello world' }];
   233→    const result = formatSegments(segments);
   234→    assertEqual(result, '[0.00-5.50] Hello world', 'Should format segment');
   235→  });
   236→
   237→  test('formatSegments formats multiple segments with newlines', () => {
   238→    const segments = [
   239→      { start: 0, end: 5, text: 'First' },
   240→      { start: 5, end: 10, text: 'Second' }
   241→    ];
   242→    const result = formatSegments(segments);
   243→    assertIncludes(result, '[0.00-5.00] First', 'Should have first segment');
   244→    assertIncludes(result, '[5.00-10.00] Second', 'Should have second segment');
   245→    assertIncludes(result, '\n', 'Should have newline separator');
   246→  });
   247→
   248→  test('formatSegments handles empty segments array', () => {
   249→    const segments = [];
   250→    const result = formatSegments(segments);
   251→    assertEqual(result, '', 'Should return empty string');
   252→  });
   253→}
   254→
   255→// Extract and test createFallbackResponse function
   256→const fallbackMatch = takeDetectionSource.match(/function createFallbackResponse\(duration\) \{[\s\S]*?return \{[\s\S]*?\};\s*\}/);
   257→
   258→test('createFallbackResponse function should be extractable', () => {
   259→  assertTrue(fallbackMatch !== null, 'Should find createFallbackResponse function');
   260→});
   261→
   262→if (fallbackMatch) {
   263→  const fallbackCode = fallbackMatch[0];
   264→  const createFallbackResponse = eval(`(${fallbackCode.replace('function createFallbackResponse', 'function')})`);
   265→
   266→  test('createFallbackResponse returns correct structure', () => {
   267→    const result = createFallbackResponse(60);
   268→    assertTrue(result.takes !== undefined, 'Should have takes array');
   269→    assertTrue(result.analysis !== undefined, 'Should have analysis');
   270→    assertEqual(result.takes.length, 1, 'Should have one take');
   271→  });
   272→
   273→  test('createFallbackResponse uses provided duration', () => {
   274→    const result = createFallbackResponse(120);
   275→    assertEqual(result.takes[0].end, 120, 'Should use provided duration');
   276→    assertEqual(result.takes[0].start, 0, 'Should start at 0');
   277→  });
   278→
   279→  test('createFallbackResponse handles undefined duration', () => {

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
