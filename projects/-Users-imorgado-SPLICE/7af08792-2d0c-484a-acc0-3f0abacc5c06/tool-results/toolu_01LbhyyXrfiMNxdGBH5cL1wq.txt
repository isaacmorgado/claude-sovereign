     1→/**
     2→ * SPLICE CEP Panel - Multitrack UI Module
     3→ * Multi-speaker analysis, auto-balance, and timeline building
     4→ * v4.0.0 - CEP Migration
     5→ */
     6→
     7→// ============================================================================
     8→// STATE
     9→// ============================================================================
    10→let speakerConfig = [];
    11→let analysisResults = null;
    12→let isMultitrackOperationInProgress = false;
    13→
    14→// Speaker colors for visual distinction
    15→const SPEAKER_COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
    16→
    17→// ============================================================================
    18→// DOM ELEMENT CACHE
    19→// ============================================================================
    20→const multitrackUI = {};
    21→
    22→function cacheMultitrackElements() {
    23→    multitrackUI.section = document.getElementById('multitrackSection');
    24→    multitrackUI.toggle = document.getElementById('multitrackToggle');
    25→    multitrackUI.panel = document.getElementById('multitrackPanel');
    26→    multitrackUI.speakerList = document.getElementById('speakerList');
    27→    multitrackUI.addSpeakerBtn = document.getElementById('addSpeakerBtn');
    28→    multitrackUI.wideShotTrack = document.getElementById('wideShotTrack');
    29→
    30→    // Parameters
    31→    multitrackUI.minShotDuration = document.getElementById('minShotDuration');
    32→    multitrackUI.minShotDurationValue = document.getElementById('minShotDurationValue');
    33→    multitrackUI.wideShotPercent = document.getElementById('wideShotPercent');
    34→    multitrackUI.wideShotPercentValue = document.getElementById('wideShotPercentValue');
    35→    multitrackUI.switchingFrequency = document.getElementById('switchingFrequency');
    36→    multitrackUI.switchingFrequencyValue = document.getElementById('switchingFrequencyValue');
    37→    multitrackUI.enableWideShotDetection = document.getElementById('enableWideShotDetection');
    38→
    39→    // Actions
    40→    multitrackUI.analyzeBtn = document.getElementById('analyzeMultitrackBtn');
    41→    multitrackUI.autoBalanceBtn = document.getElementById('autoBalanceBtn');
    42→    multitrackUI.applyBtn = document.getElementById('applyMultitrackBtn');
    43→
    44→    // Preview
    45→    multitrackUI.preview = document.getElementById('multitrackPreview');
    46→    multitrackUI.distributionChart = document.getElementById('distributionChart');
    47→    multitrackUI.speakerStats = document.getElementById('speakerStats');
    48→    multitrackUI.decisionCount = document.getElementById('decisionCount');
    49→    multitrackUI.decisionList = document.getElementById('decisionList');
    50→}
    51→
    52→// ============================================================================
    53→// INITIALIZATION
    54→// ============================================================================
    55→function initMultitrackUI() {
    56→    cacheMultitrackElements();
    57→
    58→    if (!multitrackUI.section) {
    59→        console.warn('[SPLICE Multitrack] Multitrack section not found in DOM');
    60→        return;
    61→    }
    62→
    63→    // Toggle section expand/collapse
    64→    if (multitrackUI.toggle) {
    65→        multitrackUI.toggle.addEventListener('click', toggleMultitrackSection);
    66→    }
    67→
    68→    // Add speaker button
    69→    if (multitrackUI.addSpeakerBtn) {
    70→        multitrackUI.addSpeakerBtn.addEventListener('click', addSpeaker);
    71→    }
    72→
    73→    // Speaker list event delegation (remove buttons, name changes)
    74→    if (multitrackUI.speakerList) {
    75→        multitrackUI.speakerList.addEventListener('click', handleSpeakerListClick);
    76→        multitrackUI.speakerList.addEventListener('change', handleSpeakerListChange);
    77→    }
    78→
    79→    // Parameter sliders
    80→    setupParameterListeners();
    81→
    82→    // Action buttons
    83→    if (multitrackUI.analyzeBtn) {
    84→        multitrackUI.analyzeBtn.addEventListener('click', analyzeMultitrack);
    85→    }
    86→    if (multitrackUI.autoBalanceBtn) {
    87→        multitrackUI.autoBalanceBtn.addEventListener('click', autoBalanceMultitrack);
    88→    }
    89→    if (multitrackUI.applyBtn) {
    90→        multitrackUI.applyBtn.addEventListener('click', applyMultitrackCuts);
    91→    }
    92→
    93→    // Decision list event delegation (seek buttons)
    94→    if (multitrackUI.decisionList) {
    95→        multitrackUI.decisionList.addEventListener('click', handleDecisionListClick);
    96→    }
    97→
    98→    // Initialize speaker config from DOM
    99→    initSpeakerConfigFromDOM();
   100→
   101→    console.log('[SPLICE Multitrack] UI initialized');
   102→}
   103→
   104→// ============================================================================
   105→// SECTION TOGGLE
   106→// ============================================================================
   107→function toggleMultitrackSection() {
   108→    if (!multitrackUI.panel || !multitrackUI.toggle) return;
   109→
   110→    const isNowCollapsed = multitrackUI.panel.classList.toggle('collapsed');
   111→    const icon = multitrackUI.toggle.querySelector('.toggle-icon');
   112→
   113→    if (icon) {
   114→        icon.textContent = isNowCollapsed ? '+' : '-';
   115→    }
   116→}
   117→
   118→// ============================================================================
   119→// SPEAKER CONFIGURATION
   120→// ============================================================================
   121→function initSpeakerConfigFromDOM() {
   122→    speakerConfig = [];
   123→    const items = multitrackUI.speakerList?.querySelectorAll('.speaker-item') || [];
   124→
   125→    items.forEach((item, index) => {
   126→        const nameInput = item.querySelector('.speaker-name');
   127→        const trackSelect = item.querySelector('.speaker-track');
   128→
   129→        speakerConfig.push({
   130→            index,
   131→            name: nameInput?.value || `Speaker ${index + 1}`,
   132→            videoTrack: parseInt(trackSelect?.value || index)
   133→        });
   134→    });
   135→}
   136→
   137→function addSpeaker() {
   138→    if (speakerConfig.length >= 4) {
   139→        setStatus('Maximum 4 speakers supported');
   140→        return;
   141→    }
   142→
   143→    const newIndex = speakerConfig.length;
   144→    const defaultName = `Speaker ${newIndex + 1}`;
   145→
   146→    speakerConfig.push({
   147→        index: newIndex,
   148→        name: defaultName,
   149→        videoTrack: newIndex
   150→    });
   151→
   152→    // Add DOM element
   153→    // SECURITY: Escape dynamic content to prevent XSS
   154→    const speakerItem = document.createElement('div');
   155→    speakerItem.className = `speaker-item speaker-${newIndex}`;
   156→    speakerItem.dataset.speakerIndex = newIndex;
   157→    speakerItem.innerHTML = `
   158→        <input type="text" class="speaker-name" value="${escapeHtml(defaultName)}" placeholder="Name" aria-label="Speaker ${newIndex + 1} name">
   159→        <select class="speaker-track" aria-label="Speaker ${newIndex + 1} video track">
   160→            <option value="0" ${newIndex === 0 ? 'selected' : ''}>V1</option>
   161→            <option value="1" ${newIndex === 1 ? 'selected' : ''}>V2</option>
   162→            <option value="2" ${newIndex === 2 ? 'selected' : ''}>V3</option>
   163→            <option value="3" ${newIndex === 3 ? 'selected' : ''}>V4</option>
   164→        </select>
   165→        <button class="speaker-remove-btn" title="Remove speaker" aria-label="Remove speaker ${newIndex + 1}">x</button>
   166→    `;
   167→
   168→    multitrackUI.speakerList.appendChild(speakerItem);
   169→
   170→    // Update remove button visibility
   171→    updateRemoveButtonVisibility();
   172→}
   173→
   174→function removeSpeaker(index) {
   175→    if (speakerConfig.length <= 2) {
   176→        setStatus('Minimum 2 speakers required');
   177→        return;
   178→    }
   179→
   180→    speakerConfig.splice(index, 1);
   181→
   182→    // Remove from DOM
   183→    const item = multitrackUI.speakerList.querySelector(`[data-speaker-index="${index}"]`);
   184→    if (item) {
   185→        item.remove();
   186→    }
   187→
   188→    // Re-index remaining speakers
   189→    reindexSpeakers();
   190→
   191→    // Update remove button visibility
   192→    updateRemoveButtonVisibility();
   193→}
   194→
   195→function reindexSpeakers() {
   196→    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
   197→    items.forEach((item, i) => {
   198→        item.dataset.speakerIndex = i;
   199→        item.className = `speaker-item speaker-${i}`;
   200→
   201→        // Update speakerConfig
   202→        if (speakerConfig[i]) {
   203→            speakerConfig[i].index = i;
   204→        }
   205→    });
   206→}
   207→
   208→function updateRemoveButtonVisibility() {
   209→    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
   210→    const canRemove = items.length > 2;
   211→
   212→    items.forEach(item => {
   213→        const btn = item.querySelector('.speaker-remove-btn');
   214→        if (btn) {
   215→            btn.style.display = canRemove ? 'block' : 'none';
   216→        }
   217→    });
   218→}
   219→
   220→function handleSpeakerListClick(e) {
   221→    const removeBtn = e.target.closest('.speaker-remove-btn');
   222→    if (removeBtn) {
   223→        const item = removeBtn.closest('.speaker-item');
   224→        const index = parseInt(item?.dataset.speakerIndex || 0);
   225→        removeSpeaker(index);
   226→    }
   227→}
   228→
   229→function handleSpeakerListChange(e) {
   230→    const item = e.target.closest('.speaker-item');
   231→    if (!item) return;
   232→
   233→    const index = parseInt(item.dataset.speakerIndex || 0);
   234→
   235→    if (e.target.classList.contains('speaker-name')) {
   236→        speakerConfig[index].name = e.target.value;
   237→    } else if (e.target.classList.contains('speaker-track')) {
   238→        speakerConfig[index].videoTrack = parseInt(e.target.value);
   239→    }
   240→}
   241→
   242→// ============================================================================
   243→// PARAMETER LISTENERS
   244→// ============================================================================
   245→function setupParameterListeners() {
   246→    // Min shot duration slider
   247→    if (multitrackUI.minShotDuration && multitrackUI.minShotDurationValue) {
   248→        multitrackUI.minShotDuration.addEventListener('input', () => {
   249→            multitrackUI.minShotDurationValue.textContent =
   250→                parseFloat(multitrackUI.minShotDuration.value).toFixed(1) + 's';
   251→        });
   252→    }
   253→
   254→    // Wide shot percentage slider
   255→    if (multitrackUI.wideShotPercent && multitrackUI.wideShotPercentValue) {
   256→        multitrackUI.wideShotPercent.addEventListener('input', () => {
   257→            multitrackUI.wideShotPercentValue.textContent =
   258→                multitrackUI.wideShotPercent.value + '%';
   259→        });
   260→    }
   261→
   262→    // Switching frequency slider
   263→    if (multitrackUI.switchingFrequency && multitrackUI.switchingFrequencyValue) {
   264→        multitrackUI.switchingFrequency.addEventListener('input', () => {
   265→            multitrackUI.switchingFrequencyValue.textContent =
   266→                multitrackUI.switchingFrequency.value;
   267→        });
   268→    }
   269→}
   270→
   271→// ============================================================================
   272→// GET SETTINGS
   273→// ============================================================================
   274→function getMultitrackSettings() {
   275→    return {
   276→        minShotDuration: parseFloat(multitrackUI.minShotDuration?.value || 2),
   277→        wideShotPercentage: parseInt(multitrackUI.wideShotPercent?.value || 20),
   278→        switchingFrequency: parseInt(multitrackUI.switchingFrequency?.value || 50),
   279→        wideShotEnabled: multitrackUI.enableWideShotDetection?.checked ?? true,
   280→        wideShotTracks: multitrackUI.wideShotTrack?.value !== '-1'
   281→            ? [parseInt(multitrackUI.wideShotTrack.value)]
   282→            : [],
   283→        speakerNames: speakerConfig.map(s => s.name),
   284→        videoTrackMapping: speakerConfig.reduce((acc, s) => {
   285→            acc[s.index] = s.videoTrack;
   286→            return acc;
   287→        }, {})
   288→    };
   289→}
   290→
   291→// ============================================================================
   292→// GET AUDIO PATH (CEP VERSION)
   293→// ============================================================================
   294→async function getAudioPath() {
   295→    try {
   296→        // Try to get audio path from active sequence
   297→        const seqInfo = await jsx.call('getActiveSequence');
   298→        if (seqInfo && seqInfo.audioPath) {
   299→            return seqInfo.audioPath;
   300→        }
   301→
   302→        // Fallback: export sequence audio for analysis
   303→        const exportResult = await jsx.call('exportSequenceAudioForAnalysis');
   304→        if (exportResult && exportResult.path) {
   305→            return exportResult.path;
   306→        }
   307→
   308→        // Last resort: get first clip audio path
   309→        const clipPath = await jsx.call('getFirstClipAudioPath');
   310→        if (clipPath) {
   311→            return clipPath;
   312→        }
   313→
   314→        throw new Error('Could not determine audio path');
   315→    } catch (e) {
   316→        console.error('[SPLICE Multitrack] Failed to get audio path:', e);
   317→        throw e;
   318→    }
   319→}
   320→
   321→// ============================================================================
   322→// ANALYZE MULTITRACK
   323→// ============================================================================
   324→async function analyzeMultitrack() {
   325→    if (isMultitrackOperationInProgress) return;
   326→
   327→    // Check online status
   328→    if (typeof isOnline === 'function' && !isOnline()) {
   329→        setStatus('Offline - Check your connection');
   330→        return;
   331→    }
   332→
   333→    isMultitrackOperationInProgress = true;
   334→    if (multitrackUI.analyzeBtn) {
   335→        multitrackUI.analyzeBtn.disabled = true;
   336→        multitrackUI.analyzeBtn.textContent = 'Analyzing...';
   337→    }
   338→
   339→    try {
   340→        setStatus('Exporting audio tracks...');
   341→
   342→        // Get audio path
   343→        const audioPath = await getAudioPath();
   344→        if (!audioPath) {
   345→            throw new Error('Audio export path not initialized');
   346→        }
   347→
   348→        // For now, we use the main audio path
   349→        // In a full implementation, we'd export separate tracks per speaker
   350→        const audioPaths = [audioPath];
   351→
   352→        // Add additional tracks if multi-track sequence
   353→        if (speakerConfig.length > 1) {
   354→            for (let i = 1; i < speakerConfig.length; i++) {
   355→                audioPaths.push(audioPath);
   356→            }
   357→        }
   358→
   359→        setStatus('Analyzing speakers...');
   360→
   361→        const settings = getMultitrackSettings();
   362→        const apiUrl = getBackendUrl();
   363→
   364→        const response = await fetchWithTimeout(`${apiUrl}/multitrack`, {
   365→            method: 'POST',
   366→            headers: getAuthHeaders(),
   367→            body: JSON.stringify({
   368→                audioPaths,
   369→                speakerNames: settings.speakerNames,
   370→                videoTrackMapping: settings.videoTrackMapping,
   371→                wideShotEnabled: settings.wideShotEnabled,
   372→                wideShotPercentage: settings.wideShotPercentage,
   373→                wideShotTracks: settings.wideShotTracks,
   374→                minShotDuration: settings.minShotDuration,
   375→                switchingFrequency: settings.switchingFrequency
   376→            })
   377→        }, 120000);
   378→
   379→        if (!response.ok) {
   380→            const errorMsg = await parseErrorResponse(response);
   381→            throw new Error(errorMsg);
   382→        }
   383→
   384→        const data = await response.json();
   385→        analysisResults = data;
   386→
   387→        // Display results
   388→        displayMultitrackResults(data);
   389→
   390→        // Enable apply button
   391→        if (multitrackUI.applyBtn) {
   392→            multitrackUI.applyBtn.disabled = false;
   393→        }
   394→
   395→        setStatus(`Analysis complete - ${data.decisions?.length || 0} switching decisions`);
   396→
   397→    } catch (err) {
   398→        console.error('[SPLICE Multitrack] Analysis error:', err);
   399→        setStatus('Analysis failed: ' + err.message, true);
   400→    } finally {
   401→        isMultitrackOperationInProgress = false;
   402→        if (multitrackUI.analyzeBtn) {
   403→            multitrackUI.analyzeBtn.disabled = false;
   404→            multitrackUI.analyzeBtn.textContent = 'Analyze';
   405→        }
   406→    }
   407→}
   408→
   409→// ============================================================================
   410→// AUTO-BALANCE
   411→// ============================================================================
   412→async function autoBalanceMultitrack() {
   413→    if (isMultitrackOperationInProgress) return;
   414→
   415→    // Check online status
   416→    if (typeof isOnline === 'function' && !isOnline()) {
   417→        setStatus('Offline - Check your connection');
   418→        return;
   419→    }
   420→
   421→    isMultitrackOperationInProgress = true;
   422→    if (multitrackUI.autoBalanceBtn) {
   423→        multitrackUI.autoBalanceBtn.disabled = true;
   424→        multitrackUI.autoBalanceBtn.textContent = 'Balancing...';
   425→    }
   426→
   427→    try {
   428→        setStatus('Auto-balancing speaker screentime...');
   429→
   430→        const audioPath = await getAudioPath();
   431→        const audioPaths = [audioPath];
   432→
   433→        // Duplicate for multiple speakers
   434→        for (let i = 1; i < speakerConfig.length; i++) {
   435→            audioPaths.push(audioPath);
   436→        }
   437→
   438→        const settings = getMultitrackSettings();
   439→        const apiUrl = getBackendUrl();
   440→
   441→        const response = await fetchWithTimeout(`${apiUrl}/multitrack/auto-balance`, {
   442→            method: 'POST',
   443→            headers: getAuthHeaders(),
   444→            body: JSON.stringify({
   445→                audioPaths,
   446→                speakerNames: settings.speakerNames,
   447→                videoTrackMapping: settings.videoTrackMapping,
   448→                wideShotEnabled: settings.wideShotEnabled,
   449→                wideShotPercentage: settings.wideShotPercentage,
   450→                wideShotTracks: settings.wideShotTracks,
   451→                minShotDuration: settings.minShotDuration,
   452→                switchingFrequency: settings.switchingFrequency
   453→            })
   454→        }, 120000);
   455→
   456→        if (!response.ok) {
   457→            const errorMsg = await parseErrorResponse(response);
   458→            throw new Error(errorMsg);
   459→        }
   460→
   461→        const data = await response.json();
   462→        analysisResults = data;
   463→
   464→        // Display results
   465→        displayMultitrackResults(data);
   466→
   467→        // Enable apply button
   468→        if (multitrackUI.applyBtn) {
   469→            multitrackUI.applyBtn.disabled = false;
   470→        }
   471→
   472→        const errorInfo = data.finalError ? ` (${data.finalError.toFixed(1)}% deviation)` : '';
   473→        setStatus(`Auto-balance complete${errorInfo}`);
   474→
   475→    } catch (err) {
   476→        console.error('[SPLICE Multitrack] Auto-balance error:', err);
   477→        setStatus('Auto-balance failed: ' + err.message, true);
   478→    } finally {
   479→        isMultitrackOperationInProgress = false;
   480→        if (multitrackUI.autoBalanceBtn) {
   481→            multitrackUI.autoBalanceBtn.disabled = false;
   482→            multitrackUI.autoBalanceBtn.textContent = 'Auto-Balance';
   483→        }
   484→    }
   485→}
   486→
   487→// ============================================================================
   488→// DISPLAY RESULTS
   489→// ============================================================================
   490→function displayMultitrackResults(results) {
   491→    if (!results) return;
   492→
   493→    // Show preview section
   494→    if (multitrackUI.preview) {
   495→        multitrackUI.preview.classList.remove('hidden');
   496→    }
   497→
   498→    // Render distribution chart
   499→    renderDistributionChart(results.metadata);
   500→
   501→    // Render speaker stats
   502→    renderSpeakerStats(results.metadata);
   503→
   504→    // Render decision list
   505→    renderDecisionList(results.decisions || []);
   506→}
   507→
   508→function renderDistributionChart(metadata) {
   509→    if (!multitrackUI.distributionChart || !metadata) return;
   510→
   511→    const speakerPercentages = metadata.speakerPercentages || {};
   512→    const wideShotPct = metadata.wideShotPercentage || 0;
   513→
   514→    const fragment = document.createDocumentFragment();
   515→
   516→    // Add speaker bars
   517→    let speakerIndex = 0;
   518→    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
   519→        if (pct > 0) {
   520→            const bar = document.createElement('div');
   521→            bar.className = `distribution-bar speaker-${speakerIndex % 4}`;
   522→            bar.style.width = `${pct}%`;
   523→            bar.textContent = pct >= 10 ? `${speaker}: ${pct.toFixed(0)}%` : '';
   524→            bar.title = `${speaker}: ${pct.toFixed(1)}%`;
   525→            fragment.appendChild(bar);
   526→        }
   527→        speakerIndex++;
   528→    }
   529→
   530→    // Add wide shot bar
   531→    if (wideShotPct > 0) {
   532→        const bar = document.createElement('div');
   533→        bar.className = 'distribution-bar wide-shot';
   534→        bar.style.width = `${wideShotPct}%`;
   535→        bar.textContent = wideShotPct >= 8 ? `Wide: ${wideShotPct.toFixed(0)}%` : '';
   536→        bar.title = `Wide Shot: ${wideShotPct.toFixed(1)}%`;
   537→        fragment.appendChild(bar);
   538→    }
   539→
   540→    multitrackUI.distributionChart.innerHTML = '';
   541→    multitrackUI.distributionChart.appendChild(fragment);
   542→}
   543→
   544→function renderSpeakerStats(metadata) {
   545→    if (!multitrackUI.speakerStats || !metadata) return;
   546→
   547→    const speakerPercentages = metadata.speakerPercentages || {};
   548→    const wideShotPct = metadata.wideShotPercentage || 0;
   549→
   550→    const fragment = document.createDocumentFragment();
   551→
   552→    // Add speaker stats
   553→    let speakerIndex = 0;
   554→    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
   555→        const stat = document.createElement('div');
   556→        stat.className = 'speaker-stat';
   557→        stat.innerHTML = `
   558→            <span class="speaker-stat-dot speaker-${speakerIndex % 4}"></span>
   559→            <span>${speaker}: ${pct.toFixed(1)}%</span>
   560→        `;
   561→        fragment.appendChild(stat);
   562→        speakerIndex++;
   563→    }
   564→
   565→    // Add wide shot stat
   566→    if (wideShotPct > 0) {
   567→        const stat = document.createElement('div');
   568→        stat.className = 'speaker-stat';
   569→        stat.innerHTML = `
   570→            <span class="speaker-stat-dot wide-shot"></span>
   571→            <span>Wide: ${wideShotPct.toFixed(1)}%</span>
   572→        `;
   573→        fragment.appendChild(stat);
   574→    }
   575→
   576→    // Add avg shot duration
   577→    if (metadata.averageShotDuration) {
   578→        const stat = document.createElement('div');
   579→        stat.className = 'speaker-stat';
   580→        stat.innerHTML = `<span style="color: #888;">Avg: ${metadata.averageShotDuration.toFixed(1)}s</span>`;
   581→        fragment.appendChild(stat);
   582→    }
   583→
   584→    multitrackUI.speakerStats.innerHTML = '';
   585→    multitrackUI.speakerStats.appendChild(fragment);
   586→}
   587→
   588→function renderDecisionList(decisions) {
   589→    if (!multitrackUI.decisionList) return;
   590→
   591→    // Update count
   592→    if (multitrackUI.decisionCount) {
   593→        multitrackUI.decisionCount.textContent = decisions.length;
   594→    }
   595→
   596→    const fragment = document.createDocumentFragment();
   597→
   598→    // Limit to first 50 for performance
   599→    const displayDecisions = decisions.slice(0, 50);
   600→
   601→    displayDecisions.forEach((decision, i) => {
   602→        const item = document.createElement('div');
   603→        item.className = 'decision-item';
   604→
   605→        const speakerClass = decision.isWideShot ? 'wide-shot' : '';
   606→        const startTime = formatTime(decision.startTime);
   607→        const endTime = formatTime(decision.endTime);
   608→
   609→        // SECURITY: Escape dynamic content to prevent XSS
   610→        item.innerHTML = `
   611→            <span class="decision-time">${escapeHtml(startTime)}-${escapeHtml(endTime)}</span>
   612→            <span class="decision-speaker ${speakerClass}">${escapeHtml(decision.speakerName)}</span>
   613→            <span class="decision-reason">${escapeHtml(decision.reason || '')}</span>
   614→            <button class="decision-seek" data-time="${escapeHtml(decision.startTime)}" title="Seek to ${escapeHtml(startTime)}" aria-label="Seek to ${escapeHtml(startTime)}">&gt;</button>
   615→        `;
   616→
   617→        fragment.appendChild(item);
   618→    });
   619→
   620→    if (decisions.length > 50) {
   621→        const more = document.createElement('div');
   622→        more.className = 'decision-item';
   623→        more.style.justifyContent = 'center';
   624→        more.style.color = '#888';
   625→        more.textContent = `+ ${decisions.length - 50} more decisions`;
   626→        fragment.appendChild(more);
   627→    }
   628→
   629→    multitrackUI.decisionList.innerHTML = '';
   630→    multitrackUI.decisionList.appendChild(fragment);
   631→}
   632→
   633→function handleDecisionListClick(e) {
   634→    const seekBtn = e.target.closest('.decision-seek');
   635→    if (seekBtn) {
   636→        e.stopPropagation();
   637→        const time = parseFloat(seekBtn.dataset.time);
   638→        if (!isNaN(time)) {
   639→            seekToTime(time);
   640→        }
   641→    }
   642→}
   643→
   644→// ============================================================================
   645→// SEEK TO TIME (CEP VERSION)
   646→// ============================================================================
   647→async function seekToTime(seconds) {
   648→    try {
   649→        await jsx.call('seekToTime', seconds);
   650→    } catch (e) {
   651→        console.warn('[SPLICE Multitrack] Failed to seek:', e);
   652→    }
   653→}
   654→
   655→// ============================================================================
   656→// APPLY MULTITRACK CUTS
   657→// ============================================================================
   658→async function applyMultitrackCuts() {
   659→    if (!analysisResults || !analysisResults.decisions) {
   660→        setStatus('No analysis data. Run analysis first.');
   661→        return;
   662→    }
   663→
   664→    if (isMultitrackOperationInProgress) return;
   665→
   666→    isMultitrackOperationInProgress = true;
   667→    if (multitrackUI.applyBtn) {
   668→        multitrackUI.applyBtn.disabled = true;
   669→        multitrackUI.applyBtn.textContent = 'Applying...';
   670→    }
   671→
   672→    try {
   673→        setStatus('Building multitrack sequence...');
   674→
   675→        // Check if builder is available
   676→        if (!window.spliceBuilder) {
   677→            throw new Error('Builder not initialized');
   678→        }
   679→
   680→        // Get active sequence info
   681→        const seqInfo = await jsx.call('getActiveSequence');
   682→        if (!seqInfo) {
   683→            throw new Error('No active sequence');
   684→        }
   685→
   686→        // Create cut list from decisions
   687→        const cutList = {
   688→            version: '3.5',
   689→            source: {
   690→                name: seqInfo.name,
   691→                path: seqInfo.treePath || seqInfo.name
   692→            },
   693→            segments: analysisResults.decisions.map(d => ({
   694→                type: d.isWideShot ? 'wide_shot' : (d.speakerIndex >= 0 ? 'speaker' : 'speech'),
   695→                sourceName: seqInfo.name,
   696→                sourcePath: seqInfo.treePath || seqInfo.name,
   697→                inPoint: d.startTime,
   698→                outPoint: d.endTime,
   699→                speaker: d.speakerName,
   700→                videoTrack: d.videoTrack,
   701→                colorHint: d.isWideShot ? 'yellow' :
   702→                           (d.speakerIndex === 0 ? 'mango' :
   703→                            d.speakerIndex === 1 ? 'caribbean' :
   704→                            d.speakerIndex === 2 ? 'lavender' : 'cerulean')
   705→            })),
   706→            metadata: {
   707→                isMultitrack: true,
   708→                speakerCount: speakerConfig.length,
   709→                decisionCount: analysisResults.decisions.length,
   710→                ...analysisResults.metadata
   711→            }
   712→        };
   713→
   714→        // Build sequence
   715→        const result = await window.spliceBuilder.buildSequenceFromCutList(cutList, {
   716→            suffix: '_MULTITRACK'
   717→        });
   718→
   719→        if (result.success) {
   720→            // Hide preview
   721→            if (multitrackUI.preview) {
   722→                multitrackUI.preview.classList.add('hidden');
   723→            }
   724→
   725→            setStatus(`Multitrack sequence created: ${result.stats?.clipsInserted || 0} clips`);
   726→
   727→            // Clear results
   728→            analysisResults = null;
   729→        } else {
   730→            throw new Error(result.error || 'Failed to build sequence');
   731→        }
   732→
   733→    } catch (err) {
   734→        console.error('[SPLICE Multitrack] Apply error:', err);
   735→        setStatus('Apply failed: ' + err.message, true);
   736→    } finally {
   737→        isMultitrackOperationInProgress = false;
   738→        if (multitrackUI.applyBtn) {
   739→            multitrackUI.applyBtn.disabled = true;
   740→            multitrackUI.applyBtn.textContent = 'Apply';
   741→        }
   742→    }
   743→}
   744→
   745→// ============================================================================
   746→// EXPORTS
   747→// ============================================================================
   748→// Expose for initialization from main.js
   749→if (typeof window !== 'undefined') {
   750→    window.initMultitrackUI = initMultitrackUI;
   751→    window.spliceMultitrack = {
   752→        init: initMultitrackUI,
   753→        analyze: analyzeMultitrack,
   754→        autoBalance: autoBalanceMultitrack,
   755→        apply: applyMultitrackCuts,
   756→        getSettings: getMultitrackSettings,
   757→        getResults: () => analysisResults
   758→    };
   759→}
   760→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
