     1→/**
     2→ * SPLICE Zoom Generator Service
     3→ *
     4→ * Generates zoom keyframe data for cut list integration.
     5→ * Uses adjustment layers for non-destructive zoom effects.
     6→ *
     7→ * Features:
     8→ * - Preset-based zoom intensity (subtle/medium/dramatic)
     9→ * - Configurable frequency (zooms per minute)
    10→ * - Smart placement at emphasis points (sentence starts, keywords)
    11→ * - Easing curves for smooth animation (power-based)
    12→ */
    13→
    14→// Zoom intensity presets
    15→const ZOOM_PRESETS = {
    16→  subtle: { scale: 110, duration: 0.6, easing: 2 },
    17→  medium: { scale: 120, duration: 0.8, easing: 3 },
    18→  dramatic: { scale: 140, duration: 1.0, easing: 4 }
    19→};
    20→
    21→// Zoom frequency options (seconds between zooms)
    22→const ZOOM_FREQUENCIES = {
    23→  low: 60,      // ~1 per minute
    24→  medium: 30,   // ~2 per minute
    25→  high: 15      // ~4 per minute
    26→};
    27→
    28→// Placement strategies
    29→const PLACEMENT_STRATEGIES = {
    30→  sentence_start: 'sentence_start',
    31→  keywords: 'keywords',
    32→  random: 'random',
    33→  speaker_change: 'speaker_change'
    34→};
    35→
    36→/**
    37→ * Generate zoom points from transcript
    38→ * @param {Object} transcript - Transcript with words and segments
    39→ * @param {Object} settings - Zoom generation settings
    40→ * @returns {Array} Array of zoom point objects
    41→ */
    42→function generateZoomPoints(transcript, settings = {}) {
    43→  const {
    44→    frequency = 'medium',
    45→    preset = 'medium',
    46→    placement = 'sentence_start',
    47→    minGap = 5,           // Minimum seconds between zooms
    48→    maxZooms = 50,        // Maximum total zooms
    49→    excludeFirstSeconds = 3,  // Don't zoom in first N seconds
    50→    excludeLastSeconds = 2    // Don't zoom in last N seconds
    51→  } = settings;
    52→
    53→  if (!transcript || (!transcript.words && !transcript.segments)) {
    54→    console.log('[SPLICE Zoom] No transcript data, returning empty zoom points');
    55→    return [];
    56→  }
    57→
    58→  const zoomPoints = [];
    59→  const presetConfig = ZOOM_PRESETS[preset] || ZOOM_PRESETS.medium;
    60→  const intervalSeconds = ZOOM_FREQUENCIES[frequency] || 30;
    61→
    62→  // Get transcript duration
    63→  const duration = transcript.duration ||
    64→    (transcript.words?.length > 0 ? transcript.words[transcript.words.length - 1].end : 0) ||
    65→    (transcript.segments?.length > 0 ? transcript.segments[transcript.segments.length - 1].end : 0);
    66→
    67→  if (duration <= 0) {
    68→    console.log('[SPLICE Zoom] No duration found, returning empty');
    69→    return [];
    70→  }
    71→
    72→  // Find emphasis points based on placement strategy
    73→  const emphasisPoints = findEmphasisPoints(transcript, placement, duration);
    74→
    75→  // Filter and select zoom points based on frequency
    76→  let lastZoomTime = -Infinity;
    77→
    78→  for (const point of emphasisPoints) {
    79→    // Skip points too close to start/end
    80→    if (point.time < excludeFirstSeconds) continue;
    81→    if (point.time > duration - excludeLastSeconds) continue;
    82→
    83→    // Enforce minimum gap between zooms
    84→    if (point.time - lastZoomTime < Math.max(minGap, intervalSeconds)) continue;
    85→
    86→    // Create zoom point
    87→    zoomPoints.push({
    88→      type: 'zoom',
    89→      startTime: parseFloat(point.time.toFixed(3)),
    90→      duration: presetConfig.duration,
    91→      scale: presetConfig.scale,
    92→      easing: presetConfig.easing,
    93→      centerPoint: point.center || { x: 0.5, y: 0.5 },
    94→      reason: point.reason || 'emphasis'
    95→    });
    96→
    97→    lastZoomTime = point.time;
    98→
    99→    // Limit total zooms
   100→    if (zoomPoints.length >= maxZooms) break;
   101→  }
   102→
   103→  console.log(`[SPLICE Zoom] Generated ${zoomPoints.length} zoom points (${frequency}/${preset})`);
   104→
   105→  return zoomPoints;
   106→}
   107→
   108→/**
   109→ * Find emphasis points in transcript based on placement strategy
   110→ * @param {Object} transcript - Transcript data
   111→ * @param {string} placement - Placement strategy
   112→ * @param {number} duration - Total duration
   113→ * @returns {Array} Array of emphasis points
   114→ */
   115→function findEmphasisPoints(transcript, placement, duration) {
   116→  const points = [];
   117→
   118→  switch (placement) {
   119→    case 'sentence_start':
   120→      return findSentenceStarts(transcript);
   121→
   122→    case 'keywords':
   123→      return findKeywordPositions(transcript);
   124→
   125→    case 'speaker_change':
   126→      return findSpeakerChanges(transcript);
   127→
   128→    case 'random':
   129→    default:
   130→      return generateRandomPoints(duration);
   131→  }
   132→}
   133→
   134→/**
   135→ * Find sentence start positions
   136→ * @param {Object} transcript - Transcript with words
   137→ * @returns {Array} Emphasis points at sentence starts
   138→ */
   139→function findSentenceStarts(transcript) {
   140→  const points = [];
   141→  const words = transcript.words || [];
   142→
   143→  // Sentence ending punctuation
   144→  const sentenceEnders = /[.!?]/;
   145→
   146→  // First word is always a sentence start
   147→  if (words.length > 0) {
   148→    points.push({
   149→      time: words[0].start || 0,
   150→      reason: 'sentence_start',
   151→      center: { x: 0.5, y: 0.5 }
   152→    });
   153→  }
   154→
   155→  // Find words after sentence-ending punctuation
   156→  for (let i = 0; i < words.length - 1; i++) {
   157→    const word = words[i].word || '';
   158→
   159→    if (sentenceEnders.test(word)) {
   160→      const nextWord = words[i + 1];
   161→      if (nextWord && nextWord.start !== undefined) {
   162→        points.push({
   163→          time: nextWord.start,
   164→          reason: 'sentence_start',
   165→          center: { x: 0.5, y: 0.5 }
   166→        });
   167→      }
   168→    }
   169→  }
   170→
   171→  return points;
   172→}
   173→
   174→/**
   175→ * Find keyword positions (emphasis words)
   176→ * @param {Object} transcript - Transcript with words
   177→ * @returns {Array} Emphasis points at keywords
   178→ */
   179→function findKeywordPositions(transcript) {
   180→  const points = [];
   181→  const words = transcript.words || [];
   182→
   183→  // Keywords that often deserve emphasis
   184→  const emphasisWords = new Set([
   185→    'important', 'key', 'critical', 'essential', 'crucial',
   186→    'amazing', 'incredible', 'awesome', 'fantastic', 'wonderful',
   187→    'problem', 'solution', 'answer', 'question', 'reason',
   188→    'first', 'second', 'third', 'finally', 'lastly',
   189→    'however', 'therefore', 'because', 'although', 'moreover',
   190→    'never', 'always', 'must', 'should', 'absolutely',
   191→    'love', 'hate', 'best', 'worst', 'favorite'
   192→  ]);
   193→
   194→  for (const word of words) {
   195→    const normalized = (word.word || '').toLowerCase().replace(/[^a-z]/g, '');
   196→
   197→    if (emphasisWords.has(normalized) && word.start !== undefined) {
   198→      points.push({
   199→        time: word.start,
   200→        reason: `keyword:${normalized}`,
   201→        center: { x: 0.5, y: 0.5 }
   202→      });
   203→    }
   204→  }
   205→
   206→  return points;
   207→}
   208→
   209→/**
   210→ * Find speaker change positions (for multicam)
   211→ * @param {Object} transcript - Transcript with segments
   212→ * @returns {Array} Emphasis points at speaker changes
   213→ */
   214→function findSpeakerChanges(transcript) {
   215→  const points = [];
   216→  const segments = transcript.segments || [];
   217→
   218→  let lastSpeaker = null;
   219→
   220→  for (const segment of segments) {
   221→    const speaker = segment.speaker || segment.speakerId;
   222→
   223→    if (speaker && speaker !== lastSpeaker && segment.start !== undefined) {
   224→      points.push({
   225→        time: segment.start,
   226→        reason: `speaker_change:${speaker}`,
   227→        center: { x: 0.5, y: 0.5 }
   228→      });
   229→      lastSpeaker = speaker;
   230→    }
   231→  }
   232→
   233→  return points;
   234→}
   235→
   236→/**
   237→ * Generate random zoom points
   238→ * @param {number} duration - Total duration
   239→ * @returns {Array} Random emphasis points
   240→ */
   241→function generateRandomPoints(duration) {
   242→  const points = [];
   243→  const numPoints = Math.floor(duration / 20); // Roughly 3 per minute
   244→
   245→  for (let i = 0; i < numPoints; i++) {
   246→    const time = (Math.random() * 0.8 + 0.1) * duration; // 10-90% of duration
   247→    points.push({
   248→      time,
   249→      reason: 'random',
   250→      center: { x: 0.5, y: 0.5 }
   251→    });
   252→  }
   253→
   254→  // Sort by time
   255→  points.sort((a, b) => a.time - b.time);
   256→
   257→  return points;
   258→}
   259→
   260→/**
   261→ * Calculate easing curve value
   262→ * Uses power-based easing for smooth acceleration/deceleration
   263→ * @param {number} t - Progress (0-1)
   264→ * @param {number} power - Easing power (higher = more aggressive)
   265→ * @returns {number} Eased value (0-1)
   266→ */
   267→function easingCurve(t, power) {
   268→  const coefficient = Math.pow(2, power - 1);
   269→  return (1 - Math.pow(2, -power * t)) / coefficient;
   270→}
   271→
   272→/**
   273→ * Generate keyframes for a zoom animation
   274→ * @param {Object} zoom - Zoom point configuration
   275→ * @param {number} frameRate - Frame rate (default 30)
   276→ * @returns {Array} Array of keyframe objects
   277→ */
   278→function generateZoomKeyframes(zoom, frameRate = 30) {
   279→  const keyframes = [];
   280→  const frameCount = Math.ceil(zoom.duration * frameRate);
   281→
   282→  for (let i = 0; i <= frameCount; i++) {
   283→    const t = i / frameCount;
   284→
   285→    // Zoom in during first half, zoom out during second half
   286→    let scale;
   287→    if (t < 0.5) {
   288→      // Zoom in: 100% -> peak
   289→      const easedT = easingCurve(t * 2, zoom.easing);
   290→      scale = 100 + (zoom.scale - 100) * easedT;
   291→    } else {
   292→      // Zoom out: peak -> 100%
   293→      const easedT = easingCurve((t - 0.5) * 2, zoom.easing);
   294→      scale = zoom.scale - (zoom.scale - 100) * easedT;
   295→    }
   296→
   297→    keyframes.push({
   298→      time: parseFloat((zoom.startTime + (i / frameRate)).toFixed(4)),
   299→      scale: [scale, scale],
   300→      anchor: zoom.centerPoint ? [
   301→        zoom.centerPoint.x * 1920, // Assume 1080p - will be scaled in builder
   302→        zoom.centerPoint.y * 1080
   303→      ] : null
   304→    });
   305→  }
   306→
   307→  return keyframes;
   308→}
   309→
   310→/**
   311→ * Add zoom data to a cut list
   312→ * @param {Object} cutList - Existing cut list
   313→ * @param {Array} zoomPoints - Zoom points to add
   314→ * @returns {Object} Cut list with zoom data
   315→ */
   316→function addZoomsToCutList(cutList, zoomPoints) {
   317→  if (!zoomPoints || zoomPoints.length === 0) {
   318→    return cutList;
   319→  }
   320→
   321→  return {
   322→    ...cutList,
   323→    zooms: zoomPoints,
   324→    metadata: {
   325→      ...cutList.metadata,
   326→      hasZooms: true,
   327→      zoomCount: zoomPoints.length
   328→    }
   329→  };
   330→}
   331→
   332→module.exports = {
   333→  generateZoomPoints,
   334→  generateZoomKeyframes,
   335→  addZoomsToCutList,
   336→  easingCurve,
   337→  findEmphasisPoints,
   338→  ZOOM_PRESETS,
   339→  ZOOM_FREQUENCIES,
   340→  PLACEMENT_STRATEGIES
   341→};
   342→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
