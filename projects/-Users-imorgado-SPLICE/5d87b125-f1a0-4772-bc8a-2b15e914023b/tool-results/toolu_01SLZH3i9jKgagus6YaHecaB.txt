     1→/**
     2→ * SPLICE Backend Server
     3→ *
     4→ * Main entry point for the SPLICE backend API.
     5→ * Orchestrates the audio analysis pipeline.
     6→ *
     7→ * Slices:
     8→ * - Slice 4: Transcription (services/transcription.js)
     9→ * - Slice 5: Take Detection (services/takeDetection.js)
    10→ */
    11→
    12→/* global setTimeout, setInterval */
    13→
    14→require('dotenv').config();
    15→
    16→const express = require('express');
    17→const cors = require('cors');
    18→const fs = require('fs');
    19→const fsPromises = require('fs').promises;
    20→const https = require('https');
    21→const http = require('http');
    22→const path = require('path');
    23→
    24→// Async file existence check (non-blocking)
    25→async function fileExists(filePath) {
    26→  try {
    27→    await fsPromises.access(filePath, fs.constants.R_OK);
    28→    return true;
    29→  } catch {
    30→    return false;
    31→  }
    32→}
    33→
    34→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)
    35→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;
    36→
    37→// Import slice services
    38→const { transcribeAudio, transcribeWithWords, transcribeFull } = require('./services/transcription');
    39→const { detectTakes } = require('./services/takeDetection');
    40→const { detectSilences } = require('./services/silenceDetection');
    41→const { detectAudioSilences, isFFprobeInstalled, getAudioDuration } = require('./services/ffprobeSilence');
    42→const { detectSilencesRMS, sensitivityToParams, getWaveformData } = require('./services/rmsSilenceDetection');
    43→const {
    44→  detectProfanity,
    45→  getProfanityList,
    46→  getSupportedLanguages,
    47→  getAvailableBleepSounds,
    48→  parseWordList,
    49→  generateBleepsForSegments,
    50→  cleanupBleepFiles
    51→} = require('./services/profanityDetection');
    52→const {
    53→  detectStutters,
    54→  detectAllRepetitions
    55→} = require('./services/repetitionDetection');
    56→const {
    57→  analyzeMultitrack,
    58→  autoBalanceMultitrack,
    59→  advancedBalanceMultitrack
    60→} = require('./services/multitrackAnalysis');
    61→const {
    62→  toSRT,
    63→  toVTT,
    64→  toPlainText,
    65→  toJSON,
    66→  exportToFile,
    67→  getSupportedFormats
    68→} = require('./services/captionExporter');
    69→const { processXMLFile } = require('./services/xmlProcessor');
    70→const { isolateVocals, isReplicateConfigured } = require('./services/vocalIsolation');
    71→const { generateCutList, generateTakesCutList, validateCutList, alignToFrame, alignToFrameFloor, alignToFrameCeil } = require('./services/cutListGenerator');
    72→const { generateZoomPoints, addZoomsToCutList, ZOOM_PRESETS, ZOOM_FREQUENCIES } = require('./services/zoomGenerator');
    73→const { detectChapters, detectChaptersFallback, formatYouTubeTimestamps } = require('./services/chapterDetection');
    74→
    75→// Usage tracking and billing
    76→const usageTracking = require('./services/usageTracking');
    77→// Rate limiter for usage-based endpoints
    78→const { requireCredits } = require('./middleware/rateLimiter');
    79→// Referral system
    80→const referralService = require('./services/referralService');
    81→// License key system
    82→const licenseService = require('./services/licenseService');
    83→
    84→// Maximum file size for audio processing (500MB)
    85→const MAX_FILE_SIZE_BYTES = 500 * 1024 * 1024;
    86→
    87→/**
    88→ * Validate file size to prevent OOM crashes
    89→ * @param {string} filePath - Path to file
    90→ * @returns {Promise<{valid: boolean, size?: number, error?: string}>}
    91→ */
    92→async function validateFileSize(filePath) {
    93→  try {
    94→    const stats = await require('fs').promises.stat(filePath);
    95→    if (stats.size > MAX_FILE_SIZE_BYTES) {
    96→      return {
    97→        valid: false,
    98→        size: stats.size,
    99→        error: `File too large (${(stats.size / 1024 / 1024).toFixed(1)}MB). Maximum allowed: ${MAX_FILE_SIZE_BYTES / 1024 / 1024}MB`
   100→      };
   101→    }
   102→    return { valid: true, size: stats.size };
   103→  } catch (err) {
   104→    return { valid: false, error: `Cannot access file: ${err.message}` };
   105→  }
   106→}
   107→
   108→// Stripe for webhooks
   109→const Stripe = require('stripe');
   110→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
   111→
   112→// =============================================================================
   113→// Server Configuration
   114→// =============================================================================
   115→
   116→const app = express();
   117→const PORT = process.env.PORT || 3847;
   118→
   119→// HTTPS certificates (generated by mkcert) - only for local development
   120→let httpsOptions = null;
   121→if (!isProduction) {
   122→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');
   123→  const certPath = path.join(__dirname, 'localhost+1.pem');
   124→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
   125→    httpsOptions = {
   126→      key: fs.readFileSync(keyPath),
   127→      cert: fs.readFileSync(certPath)
   128→    };
   129→  }
   130→}
   131→
   132→app.use(cors());
   133→
   134→// Helper to determine tier from price ID with logging
   135→function getTierFromPriceId(priceId) {
   136→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';
   137→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';
   138→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';
   139→
   140→  // Log unknown price ID for debugging
   141→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);
   142→  return 'starter';
   143→}
   144→
   145→// Stripe webhook needs raw body - must be before express.json()
   146→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
   147→  const sig = req.headers['stripe-signature'];
   148→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
   149→
   150→  let event;
   151→
   152→  try {
   153→    if (webhookSecret) {
   154→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
   155→    } else if (isProduction) {
   156→      // SECURITY: Reject unsigned webhooks in production
   157→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');
   158→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });
   159→    } else {
   160→      // For local development testing only
   161→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse
   162→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');
   163→      event = JSON.parse(bodyString);
   164→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');
   165→    }
   166→  } catch (err) {
   167→    console.error('[SPLICE] Webhook signature verification failed:', err.message);
   168→    return res.status(400).json({ error: 'Webhook signature verification failed' });
   169→  }
   170→
   171→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);
   172→
   173→  // Idempotency check - skip if already processed
   174→  if (await usageTracking.isEventProcessed(event.id)) {
   175→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);
   176→    return res.json({ received: true, skipped: true });
   177→  }
   178→
   179→  try {
   180→    switch (event.type) {
   181→      case 'customer.subscription.created':
   182→      case 'customer.subscription.updated': {
   183→        const subscription = event.data.object;
   184→        const customerId = subscription.customer;
   185→
   186→        // Validate customerId
   187→        if (!customerId) {
   188→          console.error('[SPLICE] Missing customer ID in subscription event');
   189→          return res.status(400).json({ error: 'Missing customer ID' });
   190→        }
   191→
   192→        // Get tier from price ID
   193→        const priceId = subscription.items?.data?.[0]?.price?.id;
   194→        const tier = getTierFromPriceId(priceId);
   195→
   196→        // Update user tier and reset hours
   197→        await usageTracking.updateTier(customerId, tier);
   198→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);
   199→
   200→        // Generate license key for new subscriptions with retry and delivery
   201→        if (event.type === 'customer.subscription.created') {
   202→          let licenseResult = null;
   203→          let retryCount = 0;
   204→          const maxRetries = 3;
   205→
   206→          // Retry mechanism for license key generation
   207→          while (retryCount < maxRetries) {
   208→            licenseResult = await licenseService.generateLicenseKey(customerId);
   209→            if (licenseResult.success) {
   210→              break;
   211→            }
   212→            retryCount++;
   213→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);
   214→            // Wait before retry (exponential backoff)
   215→            if (retryCount < maxRetries) {
   216→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
   217→            }
   218→          }
   219→
   220→          if (licenseResult && licenseResult.success) {
   221→            console.log(`[SPLICE] Generated license key for ${customerId}: ${licenseResult.key}`);
   222→
   223→            // Store license key in Stripe subscription metadata as backup
   224→            try {
   225→              await stripe.subscriptions.update(subscription.id, {
   226→                metadata: {
   227→                  license_key: licenseResult.key,
   228→                  license_generated_at: new Date().toISOString()
   229→                }
   230→              });
   231→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);
   232→            } catch (metaErr) {
   233→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, metaErr.message);
   234→            }
   235→
   236→            // Get customer email and send license key
   237→            try {
   238→              const customer = await stripe.customers.retrieve(customerId);
   239→              if (customer.email) {
   240→                // Log email delivery (placeholder for actual email service)
   241→                console.log(`[SPLICE] License key ready for delivery to ${customer.email}: ${licenseResult.key}`);
   242→                // TODO: Integrate with email service (SendGrid, SES, etc.)
   243→                // await sendLicenseKeyEmail(customer.email, licenseResult.key, tier);
   244→
   245→                // Store email in database for reference
   246→                await usageTracking.updateTier(customerId, tier, customer.email);
   247→              } else {
   248→                console.warn(`[SPLICE] No email found for customer ${customerId}`);
   249→              }
   250→            } catch (emailErr) {
   251→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);
   252→            }
   253→          } else {
   254→            console.error(`[SPLICE] Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`);
   255→          }
   256→        }
   257→        break;
   258→      }
   259→
   260→      case 'customer.subscription.deleted': {
   261→        const subscription = event.data.object;
   262→        const customerId = subscription.customer;
   263→
   264→        // Validate customerId
   265→        if (!customerId) {
   266→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');
   267→          return res.status(400).json({ error: 'Missing customer ID' });
   268→        }
   269→
   270→        // Downgrade to cancelled (0 hours)
   271→        await usageTracking.updateTier(customerId, 'cancelled');
   272→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);
   273→        break;
   274→      }
   275→
   276→      case 'invoice.payment_succeeded': {
   277→        const invoice = event.data.object;
   278→        const customerId = invoice.customer;
   279→        const subscriptionId = invoice.subscription;
   280→
   281→        // Validate customerId
   282→        if (!customerId) {
   283→          console.error('[SPLICE] Missing customer ID in invoice event');
   284→          return res.status(400).json({ error: 'Missing customer ID' });
   285→        }
   286→
   287→        // Reset hours on successful payment (new billing period)
   288→        if (subscriptionId) {
   289→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);
   290→          const priceId = subscription.items?.data?.[0]?.price?.id;
   291→          const tier = getTierFromPriceId(priceId);
   292→
   293→          await usageTracking.resetHours(customerId, tier);
   294→          console.log(`[SPLICE] Reset hours for customer ${customerId} (tier: ${tier})`);
   295→        }
   296→        break;
   297→      }
   298→
   299→      default:
   300→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);
   301→    }
   302→
   303→    // Record event as processed (idempotency)
   304→    await usageTracking.recordWebhookEvent(event.id, event.type);
   305→
   306→    res.json({ received: true });
   307→  } catch (err) {
   308→    console.error('[SPLICE] Webhook handler error:', err);
   309→    res.status(500).json({ error: err.message });
   310→  }
   311→});
   312→
   313→app.use(express.json());
   314→
   315→// =============================================================================
   316→// Routes
   317→// =============================================================================
   318→
   319→/**
   320→ * GET / - API information
   321→ */
   322→app.get('/', (req, res) => {
   323→  res.json({
   324→    service: 'splice-backend',
   325→    version: '0.3.0',
   326→    endpoints: {
   327→      'GET /': 'This info',
   328→      'GET /health': 'Health check',
   329→      'GET /ffprobe-check': 'Check if FFprobe is installed',
   330→      'GET /replicate-check': 'Check if Replicate API is configured',
   331→      'POST /analyze': 'Analyze WAV file { wavPath }',
   332→      'POST /silences': 'Detect silences via Whisper gaps { wavPath, threshold: 0.5 }',
   333→      'POST /silences-audio': 'Detect silences via FFprobe { wavPath, threshold: -30, minDuration: 0.5, padding: 0.1 }',
   334→      'POST /silences-rms': 'Detect silences via RMS analysis { wavPath, threshold: -30, minSilenceLength: 0.5, paddingStart: 0.1, paddingEnd: 0.05, autoThreshold: false, sensitivity: 50 }',
   335→      'POST /profanity': 'Detect profanity in transcript { wavPath, language: "en", customBlocklist: [], customAllowlist: [] }',
   336→      'GET /profanity/languages': 'Get supported languages for profanity detection',
   337→      'GET /profanity/bleeps': 'Get available bleep sounds',
   338→      'POST /repetitions': 'Detect phrase repetitions and stutters { wavPath, phraseSize: 5, tolerance: 0.7, useOpenAI: false }',
   339→      'POST /fillers': 'Detect filler words (um, uh, like, etc.) { wavPath, customFillers: [] }',
   340→      'POST /stutters': 'Detect single-word stutters only { wavPath, minRepeats: 2 }',
   341→      'POST /export/captions': 'Export transcript to caption format { wavPath, format: srt|vtt|txt|json, outputPath? }',
   342→      'GET /export/formats': 'Get supported caption export formats',
   343→      'POST /multitrack': 'Analyze multiple audio tracks for multicam { audioPaths: [], speakerNames: [], videoTrackMapping: {} }',
   344→      'POST /multitrack/auto-balance': 'Auto-balance speaker screentime { audioPaths: [], speakerNames: [] }',
   345→      'POST /multitrack/advanced-balance': 'Advanced GA-optimized balancing { audioPaths: [], maxConsecutiveSeconds: 30, momentumFactor: 0.7 }',
   346→      'POST /process-xml': 'Process FCP XML { xmlPath, silences, removeGaps: true }',
   347→      'POST /cut-list': 'Generate JSON cut list for DOM building (v3.5) { sourceName, sourcePath, duration, silences, takes?, settings? }',
   348→      'POST /cut-list/takes': 'Generate cut list keeping only takes { sourceName, sourcePath, duration, takes, settings? }',
   349→      'POST /zoom': 'Generate zoom points from transcript { transcript, settings: { frequency, preset, placement } }',
   350→      'GET /zoom/presets': 'Get available zoom presets and frequencies',
   351→      'POST /chapters': 'Detect chapters in transcript using AI { transcript, settings: { maxChapters, minChapterLength } }',
   352→      'POST /chapters/fallback': 'Detect chapters without AI (gap-based) { transcript, settings }',
   353→      'POST /isolate-vocals': 'Isolate vocals from audio { audioPath }',
   354→      'POST /batch/silences': 'Batch process multiple files for silence detection { files: [], options: {} }',
   355→      'GET /batch/status/:jobId': 'Get batch job status',
   356→      'GET /batch/results/:jobId': 'Get full batch job results',
   357→      'GET /batch/jobs': 'List all batch jobs',
   358→      'DELETE /batch/:jobId': 'Delete a batch job',
   359→      'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',
   360→      'GET /usage-history': 'Get usage history (requires x-stripe-customer-id header)',
   361→      'POST /webhooks/stripe': 'Stripe webhook endpoint',
   362→      'GET /referral/code': 'Get or create referral code for user',
   363→      'POST /referral/validate': 'Validate a referral code',
   364→      'POST /referral/apply': 'Apply referral code at signup',
   365→      'GET /referral/stats': 'Get referral statistics for user',
   366→      'POST /license/activate': 'Activate license key { key: "SPLICE-XXXX-XXXX-XXXX" }',
   367→      'GET /license/key': 'Get license key for customer (requires x-stripe-customer-id)',
   368→      'POST /license/resend': 'Resend license key to customer email { customerId? }'
   369→    }
   370→  });
   371→});
   372→
   373→/**
   374→ * GET /health - Health check
   375→ */
   376→app.get('/health', (req, res) => {
   377→  res.json({ status: 'ok', service: 'splice-backend' });
   378→});
   379→
   380→/**
   381→ * POST /analyze - Main analysis endpoint
   382→ *
   383→ * Pipeline:
   384→ * 1. Validate input (wavPath)
   385→ * 2. Slice 4: Transcribe audio with Whisper
   386→ * 3. Slice 5: Detect takes with GPT-4o-mini
   387→ * 4. Return combined results
   388→ */
   389→app.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {
   390→  const { wavPath } = req.body;
   391→
   392→  // Validate input
   393→  if (!wavPath) {
   394→    return res.status(400).json({ error: 'wavPath is required' });
   395→  }
   396→
   397→  if (!(await fileExists(wavPath))) {
   398→    return res.status(404).json({ error: `File not found: ${wavPath}` });
   399→  }
   400→
   401→  console.log(`[SPLICE] Analyzing: ${wavPath}`);
   402→
   403→  try {
   404→    // Slice 4 - GPT-4o-mini transcription
   405→    const transcript = await transcribeAudio(wavPath);
   406→
   407→    // Slice 5 - GPT-4o-mini take detection
   408→    const takes = await detectTakes(transcript);
   409→
   410→    // Deduct usage based on audio duration
   411→    const audioDuration = transcript.duration || 0;
   412→    let balance = null;
   413→    if (audioDuration > 0 && req.deductUsage) {
   414→      balance = await req.deductUsage(audioDuration);
   415→    }
   416→
   417→    res.json({
   418→      success: true,
   419→      wavPath,
   420→      transcript,
   421→      takes,
   422→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined
   423→    });
   424→  } catch (err) {
   425→    console.error('[SPLICE] Error:', err);
   426→    res.status(500).json({ error: err.message });
   427→  }
   428→});
   429→
   430→/**
   431→ * POST /transcribe/word-level - Get frame-aligned word-level timestamps
   432→ *
   433→ * Returns word-level timestamps with optional frame alignment for precise editing.
   434→ * Uses the unified transcription cache (same API call as /analyze).
   435→ *
   436→ * Body:
   437→ * - wavPath: Path to audio file
   438→ * - frameRate: Optional frame rate for alignment (23.976, 24, 29.97, 30, 60)
   439→ *
   440→ * Returns:
   441→ * - words: Array of {word, start, end, startAligned?, endAligned?}
   442→ * - text: Full transcript text
   443→ * - duration: Audio duration in seconds
   444→ */
   445→app.post('/transcribe/word-level', requireCredits({ endpoint: 'transcribe-word-level' }), async (req, res) => {
   446→  const { wavPath, frameRate = 0 } = req.body;
   447→
   448→  if (!wavPath) {
   449→    return res.status(400).json({ error: 'wavPath is required' });
   450→  }
   451→
   452→  if (!(await fileExists(wavPath))) {
   453→    return res.status(404).json({ error: `File not found: ${wavPath}` });
   454→  }
   455→
   456→  console.log(`[SPLICE] Word-level transcription: ${wavPath} (frameRate: ${frameRate || 'none'})`);
   457→
   458→  try {
   459→    // Use unified transcription (gets both segments and words in one API call)
   460→    const full = await transcribeFull(wavPath);
   461→
   462→    // Apply frame alignment if requested
   463→    let words = full.words || [];
   464→    const hasFrameAlignment = frameRate > 0;
   465→
   466→    if (hasFrameAlignment) {
   467→      words = words.map(w => ({
   468→        word: w.word,
   469→        start: w.start,
   470→        end: w.end,
   471→        // Add frame-aligned versions
   472→        startAligned: parseFloat(alignToFrameFloor(w.start, frameRate).toFixed(6)),
   473→        endAligned: parseFloat(alignToFrameCeil(w.end, frameRate).toFixed(6))
   474→      }));
   475→      console.log(`[SPLICE] Applied ${frameRate}fps frame alignment to ${words.length} words`);
   476→    }
   477→
   478→    // Deduct usage based on audio duration
   479→    const audioDuration = full.duration || 0;
   480→    let balance = null;
   481→    if (audioDuration > 0 && req.deductUsage) {
   482→      balance = await req.deductUsage(audioDuration);
   483→    }
   484→
   485→    res.json({
   486→      success: true,
   487→      wavPath,
   488→      text: full.text,
   489→      words,
   490→      wordCount: words.length,
   491→      duration: full.duration,
   492→      language: full.language,
   493→      frameAligned: hasFrameAlignment,
   494→      frameRate: hasFrameAlignment ? frameRate : null,
   495→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined
   496→    });
   497→  } catch (err) {
   498→    console.error('[SPLICE] Word-level transcription error:', err);
   499→    res.status(500).json({ error: err.message });
   500→  }

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
