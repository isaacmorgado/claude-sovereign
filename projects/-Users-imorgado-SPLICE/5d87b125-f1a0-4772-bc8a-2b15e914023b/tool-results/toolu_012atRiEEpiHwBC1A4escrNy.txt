  1020→});
  1021→
  1022→/**
  1023→ * POST /fillers - Detect filler words (um, uh, like, etc.)
  1024→ *
  1025→ * Transcribes audio and identifies filler words with timestamps.
  1026→ * Returns segments that can be cut or reviewed for removal.
  1027→ * Supports frame alignment for precise video editing.
  1028→ *
  1029→ * Options:
  1030→ * - wavPath: Path to audio file (required unless transcript provided)
  1031→ * - transcript: Pre-existing transcript with word-level timing (optional)
  1032→ * - customFillers: Additional filler words to detect (optional)
  1033→ * - frameRate: Frame rate for alignment (0 = no alignment, 24/30/60 etc.)
  1034→ * - paddingMs: Padding in ms around filler words for cleaner cuts (default 50)
  1035→ */
  1036→app.post('/fillers', requireCredits({ endpoint: 'fillers' }), async (req, res) => {
  1037→  const {
  1038→    wavPath,
  1039→    transcript: providedTranscript,
  1040→    customFillers = [],
  1041→    frameRate = 0, // Optional: align timestamps to frames
  1042→    paddingMs = 50 // Padding around filler words for cleaner cuts
  1043→  } = req.body;
  1044→
  1045→  if (!wavPath && !providedTranscript) {
  1046→    return res.status(400).json({ error: 'wavPath or transcript is required' });
  1047→  }
  1048→
  1049→  if (wavPath && !(await fileExists(wavPath))) {
  1050→    return res.status(404).json({ error: `File not found: ${wavPath}` });
  1051→  }
  1052→
  1053→  console.log(`[SPLICE] Filler word detection: ${wavPath || 'provided transcript'}`);
  1054→
  1055→  try {
  1056→    // Get or create transcript with word-level timestamps
  1057→    let transcript = providedTranscript;
  1058→    if (!transcript && wavPath) {
  1059→      transcript = await transcribeWithWords(wavPath);
  1060→    }
  1061→
  1062→    // Validate transcript has words
  1063→    if (!transcript || !transcript.words || transcript.words.length === 0) {
  1064→      return res.status(400).json({
  1065→        error: 'Transcript must contain word-level timing data'
  1066→      });
  1067→    }
  1068→
  1069→    // Default filler words (common in English speech)
  1070→    const defaultFillers = [
  1071→      'um', 'uh', 'ah', 'er', 'eh',           // Hesitation sounds
  1072→      'like', 'so', 'well', 'right',           // Discourse markers
  1073→      'you know', 'i mean', 'basically',       // Filler phrases
  1074→      'actually', 'literally', 'honestly',     // Overused qualifiers
  1075→      'kind of', 'sort of', 'you see'          // Hedging phrases
  1076→    ];
  1077→
  1078→    // Combine default + custom fillers (lowercase for matching)
  1079→    const fillerSet = new Set([
  1080→      ...defaultFillers,
  1081→      ...customFillers.map(f => f.toLowerCase().trim())
  1082→    ]);
  1083→
  1084→    // Detect filler words
  1085→    const fillers = [];
  1086→    const words = transcript.words;
  1087→
  1088→    for (let i = 0; i < words.length; i++) {
  1089→      const word = words[i];
  1090→      const normalizedWord = word.word.toLowerCase().replace(/[.,!?;:'"]/g, '').trim();
  1091→
  1092→      // Check single-word fillers
  1093→      if (fillerSet.has(normalizedWord)) {
  1094→        fillers.push({
  1095→          word: word.word,
  1096→          normalizedWord,
  1097→          start: word.start,
  1098→          end: word.end,
  1099→          duration: word.end - word.start,

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
