{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","type":"user","message":{"role":"user","content":"Trace the complete E2E user flow in SPLICE:\n\n1. Stripe webhook (server.js:128-233) → What happens when checkout.session.completed fires?\n2. License key generation (licenseService.js) → How is key generated and stored?\n3. Plugin activation (settings.js:initLoginModal:1192-1284) → How does user enter/activate key?\n4. API calls with customer ID (main.js:getAuthHeaders:1407-1414) → How is auth attached to requests?\n5. Usage deduction (usageTracking.js) → How are credits deducted per request?\n6. Credits display (credits.js) → How does UI show remaining balance?\n\nCheck:\n- Is the chain complete with no missing links?\n- Are there any race conditions in the flow?\n- What happens if any step fails?\n- Is error recovery handled?\n\nReport: Flow diagram (text), gaps identified, and fixes required."},"uuid":"c7890d3e-cf0c-4eb9-8426-f8581e908b8a","timestamp":"2025-12-25T23:26:26.028Z"}
{"parentUuid":"c7890d3e-cf0c-4eb9-8426-f8581e908b8a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A1eLA3EKN1ZAgCQfrPrpHc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01L5caHc6W8RXuYHycjN8QgQ","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js","offset":120,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":16579,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":16579,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWUGeDfX8vfJTSHq4PcuM","type":"assistant","uuid":"de551469-1aa2-4497-b434-d0b98688e675","timestamp":"2025-12-25T23:26:29.550Z"}
{"parentUuid":"de551469-1aa2-4497-b434-d0b98688e675","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A1eLA3EKN1ZAgCQfrPrpHc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GKtHFwxkzQSyzCAFUibWAg","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/licenseService.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":16579,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":16579,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWUGeDfX8vfJTSHq4PcuM","type":"assistant","uuid":"9839c68e-f844-40d7-974f-5e97b407550e","timestamp":"2025-12-25T23:26:30.208Z"}
{"parentUuid":"9839c68e-f844-40d7-974f-5e97b407550e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A1eLA3EKN1ZAgCQfrPrpHc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SADRrVX2CnFxSGXcqinEnQ","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":16579,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":16579,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWUGeDfX8vfJTSHq4PcuM","type":"assistant","uuid":"993cdcce-1b79-45f6-b105-3fe03ba5df65","timestamp":"2025-12-25T23:26:30.806Z"}
{"parentUuid":"993cdcce-1b79-45f6-b105-3fe03ba5df65","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A1eLA3EKN1ZAgCQfrPrpHc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A9Bixy2gPv4x5TxWrAunGe","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-plugin/js/settings.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":16579,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":16579,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWUGeDfX8vfJTSHq4PcuM","type":"assistant","uuid":"9dccb755-2457-4e84-9a3c-bd5fb08c0276","timestamp":"2025-12-25T23:26:31.340Z"}
{"parentUuid":"9dccb755-2457-4e84-9a3c-bd5fb08c0276","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A1eLA3EKN1ZAgCQfrPrpHc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019siiEcsCMPyECebreJmkyC","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-plugin/js/main.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":16579,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":16579,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWUGeDfX8vfJTSHq4PcuM","type":"assistant","uuid":"9c9cf5e9-ff0c-4093-91c2-534ee76686ca","timestamp":"2025-12-25T23:26:31.969Z"}
{"parentUuid":"9c9cf5e9-ff0c-4093-91c2-534ee76686ca","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A1eLA3EKN1ZAgCQfrPrpHc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01L14yQJNwAozfoFkozmJHp4","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-plugin/js/credits.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":16579,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":16579,"ephemeral_1h_input_tokens":0},"output_tokens":378,"service_tier":"standard"}},"requestId":"req_011CWUGeDfX8vfJTSHq4PcuM","type":"assistant","uuid":"0c002d05-1797-4d9b-b0bf-a884f2cca5cb","timestamp":"2025-12-25T23:26:32.549Z"}
{"parentUuid":"0c002d05-1797-4d9b-b0bf-a884f2cca5cb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L5caHc6W8RXuYHycjN8QgQ","type":"tool_result","content":"   120→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   121→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   122→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   123→\n   124→  // Log unknown price ID for debugging\n   125→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   126→  return 'starter';\n   127→}\n   128→\n   129→// Stripe webhook needs raw body - must be before express.json()\n   130→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   131→  const sig = req.headers['stripe-signature'];\n   132→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   133→\n   134→  let event;\n   135→\n   136→  try {\n   137→    if (webhookSecret) {\n   138→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   139→    } else if (isProduction) {\n   140→      // SECURITY: Reject unsigned webhooks in production\n   141→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   142→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   143→    } else {\n   144→      // For local development testing only\n   145→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   146→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   147→      event = JSON.parse(bodyString);\n   148→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   149→    }\n   150→  } catch (err) {\n   151→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   152→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   153→  }\n   154→\n   155→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   156→\n   157→  // Idempotency check - skip if already processed\n   158→  if (await usageTracking.isEventProcessed(event.id)) {\n   159→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   160→    return res.json({ received: true, skipped: true });\n   161→  }\n   162→\n   163→  try {\n   164→    switch (event.type) {\n   165→      case 'customer.subscription.created':\n   166→      case 'customer.subscription.updated': {\n   167→        const subscription = event.data.object;\n   168→        const customerId = subscription.customer;\n   169→\n   170→        // Validate customerId\n   171→        if (!customerId) {\n   172→          console.error('[SPLICE] Missing customer ID in subscription event');\n   173→          return res.status(400).json({ error: 'Missing customer ID' });\n   174→        }\n   175→\n   176→        // Get tier from price ID\n   177→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   178→        const tier = getTierFromPriceId(priceId);\n   179→\n   180→        // Update user tier and reset hours\n   181→        await usageTracking.updateTier(customerId, tier);\n   182→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   183→\n   184→        // Generate license key for new subscriptions\n   185→        if (event.type === 'customer.subscription.created') {\n   186→          const licenseResult = await licenseService.generateLicenseKey(customerId);\n   187→          if (licenseResult.success) {\n   188→            console.log(`[SPLICE] Generated license key for ${customerId}: ${licenseResult.key}`);\n   189→          } else {\n   190→            console.error(`[SPLICE] Failed to generate license key: ${licenseResult.error}`);\n   191→          }\n   192→        }\n   193→        break;\n   194→      }\n   195→\n   196→      case 'customer.subscription.deleted': {\n   197→        const subscription = event.data.object;\n   198→        const customerId = subscription.customer;\n   199→\n   200→        // Validate customerId\n   201→        if (!customerId) {\n   202→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   203→          return res.status(400).json({ error: 'Missing customer ID' });\n   204→        }\n   205→\n   206→        // Downgrade to cancelled (0 hours)\n   207→        await usageTracking.updateTier(customerId, 'cancelled');\n   208→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   209→        break;\n   210→      }\n   211→\n   212→      case 'invoice.payment_succeeded': {\n   213→        const invoice = event.data.object;\n   214→        const customerId = invoice.customer;\n   215→        const subscriptionId = invoice.subscription;\n   216→\n   217→        // Validate customerId\n   218→        if (!customerId) {\n   219→          console.error('[SPLICE] Missing customer ID in invoice event');\n   220→          return res.status(400).json({ error: 'Missing customer ID' });\n   221→        }\n   222→\n   223→        // Reset hours on successful payment (new billing period)\n   224→        if (subscriptionId) {\n   225→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   226→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   227→          const tier = getTierFromPriceId(priceId);\n   228→\n   229→          await usageTracking.resetHours(customerId, tier);\n   230→          console.log(`[SPLICE] Reset hours for customer ${customerId} (tier: ${tier})`);\n   231→        }\n   232→        break;\n   233→      }\n   234→\n   235→      default:\n   236→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   237→    }\n   238→\n   239→    // Record event as processed (idempotency)\n   240→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   241→\n   242→    res.json({ received: true });\n   243→  } catch (err) {\n   244→    console.error('[SPLICE] Webhook handler error:', err);\n   245→    res.status(500).json({ error: err.message });\n   246→  }\n   247→});\n   248→\n   249→app.use(express.json());\n   250→\n   251→// =============================================================================\n   252→// Routes\n   253→// =============================================================================\n   254→\n   255→/**\n   256→ * GET / - API information\n   257→ */\n   258→app.get('/', (req, res) => {\n   259→  res.json({\n   260→    service: 'splice-backend',\n   261→    version: '0.3.0',\n   262→    endpoints: {\n   263→      'GET /': 'This info',\n   264→      'GET /health': 'Health check',\n   265→      'GET /ffprobe-check': 'Check if FFprobe is installed',\n   266→      'GET /replicate-check': 'Check if Replicate API is configured',\n   267→      'POST /analyze': 'Analyze WAV file { wavPath }',\n   268→      'POST /silences': 'Detect silences via Whisper gaps { wavPath, threshold: 0.5 }',\n   269→      'POST /silences-audio': 'Detect silences via FFprobe { wavPath, threshold: -30, minDuration: 0.5, padding: 0.1 }',\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"be86821d-5e59-417b-9398-9982026529ba","timestamp":"2025-12-25T23:26:32.599Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n\n  // Log unknown price ID for debugging\n  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n  return 'starter';\n}\n\n// Stripe webhook needs raw body - must be before express.json()\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n  let event;\n\n  try {\n    if (webhookSecret) {\n      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } else if (isProduction) {\n      // SECURITY: Reject unsigned webhooks in production\n      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n    } else {\n      // For local development testing only\n      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n      event = JSON.parse(bodyString);\n      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n    return res.status(400).json({ error: 'Webhook signature verification failed' });\n  }\n\n  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n\n  // Idempotency check - skip if already processed\n  if (await usageTracking.isEventProcessed(event.id)) {\n    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n    return res.json({ received: true, skipped: true });\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Get tier from price ID\n        const priceId = subscription.items?.data?.[0]?.price?.id;\n        const tier = getTierFromPriceId(priceId);\n\n        // Update user tier and reset hours\n        await usageTracking.updateTier(customerId, tier);\n        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n\n        // Generate license key for new subscriptions\n        if (event.type === 'customer.subscription.created') {\n          const licenseResult = await licenseService.generateLicenseKey(customerId);\n          if (licenseResult.success) {\n            console.log(`[SPLICE] Generated license key for ${customerId}: ${licenseResult.key}`);\n          } else {\n            console.error(`[SPLICE] Failed to generate license key: ${licenseResult.error}`);\n          }\n        }\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Downgrade to cancelled (0 hours)\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const subscriptionId = invoice.subscription;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in invoice event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Reset hours on successful payment (new billing period)\n        if (subscriptionId) {\n          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n          const priceId = subscription.items?.data?.[0]?.price?.id;\n          const tier = getTierFromPriceId(priceId);\n\n          await usageTracking.resetHours(customerId, tier);\n          console.log(`[SPLICE] Reset hours for customer ${customerId} (tier: ${tier})`);\n        }\n        break;\n      }\n\n      default:\n        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n    }\n\n    // Record event as processed (idempotency)\n    await usageTracking.recordWebhookEvent(event.id, event.type);\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error('[SPLICE] Webhook handler error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.use(express.json());\n\n// =============================================================================\n// Routes\n// =============================================================================\n\n/**\n * GET / - API information\n */\napp.get('/', (req, res) => {\n  res.json({\n    service: 'splice-backend',\n    version: '0.3.0',\n    endpoints: {\n      'GET /': 'This info',\n      'GET /health': 'Health check',\n      'GET /ffprobe-check': 'Check if FFprobe is installed',\n      'GET /replicate-check': 'Check if Replicate API is configured',\n      'POST /analyze': 'Analyze WAV file { wavPath }',\n      'POST /silences': 'Detect silences via Whisper gaps { wavPath, threshold: 0.5 }',\n      'POST /silences-audio': 'Detect silences via FFprobe { wavPath, threshold: -30, minDuration: 0.5, padding: 0.1 }',","numLines":150,"startLine":120,"totalLines":2176}}}
{"parentUuid":"be86821d-5e59-417b-9398-9982026529ba","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GKtHFwxkzQSyzCAFUibWAg","type":"tool_result","content":"     1→/**\n     2→ * License Key Service\n     3→ *\n     4→ * Generates and validates license keys for user authentication.\n     5→ * License keys are generated when a user purchases a subscription via Stripe.\n     6→ * Format: SPLICE-XXXX-XXXX-XXXX (alphanumeric, no confusing characters)\n     7→ */\n     8→\n     9→const { Pool } = require('pg');\n    10→const crypto = require('crypto');\n    11→\n    12→// Use the same pool configuration as other services\n    13→const pool = new Pool({\n    14→  connectionString: process.env.DATABASE_URL,\n    15→  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    16→  max: 20,\n    17→  idleTimeoutMillis: 30000,\n    18→  connectionTimeoutMillis: 5000\n    19→});\n    20→\n    21→// Characters for key generation (no confusing chars: 0/O, 1/I/L)\n    22→const KEY_CHARS = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';\n    23→\n    24→/**\n    25→ * Initialize license_keys table\n    26→ */\n    27→async function initLicenseTables() {\n    28→  const client = await pool.connect();\n    29→  try {\n    30→    await client.query(`\n    31→      CREATE TABLE IF NOT EXISTS license_keys (\n    32→        id SERIAL PRIMARY KEY,\n    33→        key VARCHAR(21) UNIQUE NOT NULL,\n    34→        stripe_customer_id VARCHAR(255) NOT NULL,\n    35→        created_at TIMESTAMP DEFAULT NOW(),\n    36→        activated_at TIMESTAMP,\n    37→        is_active BOOLEAN DEFAULT TRUE\n    38→      )\n    39→    `);\n    40→\n    41→    // Migrate existing column if needed (for existing databases)\n    42→    await client.query(`\n    43→      DO $$\n    44→      BEGIN\n    45→        IF EXISTS (\n    46→          SELECT 1 FROM information_schema.columns\n    47→          WHERE table_name = 'license_keys'\n    48→          AND column_name = 'key'\n    49→          AND character_maximum_length = 19\n    50→        ) THEN\n    51→          ALTER TABLE license_keys ALTER COLUMN key TYPE VARCHAR(21);\n    52→        END IF;\n    53→      END $$;\n    54→    `);\n    55→\n    56→    // Add indexes for efficient lookups\n    57→    await client.query(`\n    58→      CREATE INDEX IF NOT EXISTS idx_license_keys_key\n    59→      ON license_keys(key)\n    60→    `);\n    61→\n    62→    await client.query(`\n    63→      CREATE INDEX IF NOT EXISTS idx_license_keys_customer\n    64→      ON license_keys(stripe_customer_id)\n    65→    `);\n    66→\n    67→    console.log('[License] Database tables initialized');\n    68→  } finally {\n    69→    client.release();\n    70→  }\n    71→}\n    72→\n    73→/**\n    74→ * Generate a random 4-character segment\n    75→ * @returns {string} 4 uppercase alphanumeric characters\n    76→ */\n    77→function generateSegment() {\n    78→  let segment = '';\n    79→  for (let i = 0; i < 4; i++) {\n    80→    segment += KEY_CHARS.charAt(crypto.randomInt(KEY_CHARS.length));\n    81→  }\n    82→  return segment;\n    83→}\n    84→\n    85→/**\n    86→ * Generate a license key in format SPLICE-XXXX-XXXX-XXXX\n    87→ * @returns {string} License key\n    88→ */\n    89→function generateKeyString() {\n    90→  return `SPLICE-${generateSegment()}-${generateSegment()}-${generateSegment()}`;\n    91→}\n    92→\n    93→/**\n    94→ * Validate license key format\n    95→ * @param {string} key - License key to validate\n    96→ * @returns {boolean} True if format is valid\n    97→ */\n    98→function isValidKeyFormat(key) {\n    99→  if (!key || typeof key !== 'string') return false;\n   100→\n   101→  // Normalize: uppercase and trim\n   102→  const normalized = key.toUpperCase().trim();\n   103→\n   104→  // Must match SPLICE-XXXX-XXXX-XXXX pattern\n   105→  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;\n   106→  return pattern.test(normalized);\n   107→}\n   108→\n   109→/**\n   110→ * Normalize a license key (uppercase, trim)\n   111→ * @param {string} key - License key\n   112→ * @returns {string} Normalized key\n   113→ */\n   114→function normalizeKey(key) {\n   115→  return (key || '').toUpperCase().trim();\n   116→}\n   117→\n   118→/**\n   119→ * Generate a new license key for a Stripe customer\n   120→ *\n   121→ * @param {string} stripeCustomerId - Stripe customer ID\n   122→ * @returns {Promise<{success: boolean, key?: string, error?: string}>}\n   123→ */\n   124→async function generateLicenseKey(stripeCustomerId) {\n   125→  if (!stripeCustomerId) {\n   126→    return { success: false, error: 'Customer ID is required' };\n   127→  }\n   128→\n   129→  const client = await pool.connect();\n   130→  try {\n   131→    // Check if customer already has a key\n   132→    const existing = await client.query(\n   133→      'SELECT key FROM license_keys WHERE stripe_customer_id = $1',\n   134→      [stripeCustomerId]\n   135→    );\n   136→\n   137→    if (existing.rows.length > 0) {\n   138→      return {\n   139→        success: true,\n   140→        key: existing.rows[0].key,\n   141→        existing: true\n   142→      };\n   143→    }\n   144→\n   145→    // Generate unique key with retry logic\n   146→    let key;\n   147→    let attempts = 0;\n   148→    const maxAttempts = 10;\n   149→\n   150→    while (attempts < maxAttempts) {\n   151→      key = generateKeyString();\n   152→      try {\n   153→        await client.query(\n   154→          `INSERT INTO license_keys (key, stripe_customer_id)\n   155→           VALUES ($1, $2)`,\n   156→          [key, stripeCustomerId]\n   157→        );\n   158→        break;\n   159→      } catch (err) {\n   160→        if (err.code === '23505') { // Unique violation\n   161→          attempts++;\n   162→          continue;\n   163→        }\n   164→        throw err;\n   165→      }\n   166→    }\n   167→\n   168→    if (attempts >= maxAttempts) {\n   169→      return { success: false, error: 'Failed to generate unique license key' };\n   170→    }\n   171→\n   172→    console.log(`[License] Generated key for customer ${stripeCustomerId}: ${key}`);\n   173→    return { success: true, key };\n   174→  } finally {\n   175→    client.release();\n   176→  }\n   177→}\n   178→\n   179→/**\n   180→ * Activate a license key\n   181→ *\n   182→ * @param {string} key - License key to activate\n   183→ * @returns {Promise<{success: boolean, customerId?: string, error?: string}>}\n   184→ */\n   185→async function activateLicenseKey(key) {\n   186→  if (!key) {\n   187→    return { success: false, error: 'License key is required' };\n   188→  }\n   189→\n   190→  const normalized = normalizeKey(key);\n   191→\n   192→  if (!isValidKeyFormat(normalized)) {\n   193→    return { success: false, error: 'Invalid license key format. Expected: SPLICE-XXXX-XXXX-XXXX' };\n   194→  }\n   195→\n   196→  const client = await pool.connect();\n   197→  try {\n   198→    // Look up the key\n   199→    const result = await client.query(\n   200→      'SELECT * FROM license_keys WHERE key = $1',\n   201→      [normalized]\n   202→    );\n   203→\n   204→    if (result.rows.length === 0) {\n   205→      return { success: false, error: 'License key not found' };\n   206→    }\n   207→\n   208→    const license = result.rows[0];\n   209→\n   210→    if (!license.is_active) {\n   211→      return { success: false, error: 'License key has been deactivated' };\n   212→    }\n   213→\n   214→    // Update activated_at if not already set\n   215→    if (!license.activated_at) {\n   216→      await client.query(\n   217→        'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n   218→        [license.id]\n   219→      );\n   220→    }\n   221→\n   222→    return {\n   223→      success: true,\n   224→      customerId: license.stripe_customer_id\n   225→    };\n   226→  } finally {\n   227→    client.release();\n   228→  }\n   229→}\n   230→\n   231→/**\n   232→ * Get license key for a customer\n   233→ *\n   234→ * @param {string} stripeCustomerId - Stripe customer ID\n   235→ * @returns {Promise<{success: boolean, key?: string, activated?: boolean, error?: string}>}\n   236→ */\n   237→async function getLicenseByCustomerId(stripeCustomerId) {\n   238→  if (!stripeCustomerId) {\n   239→    return { success: false, error: 'Customer ID is required' };\n   240→  }\n   241→\n   242→  const result = await pool.query(\n   243→    'SELECT * FROM license_keys WHERE stripe_customer_id = $1',\n   244→    [stripeCustomerId]\n   245→  );\n   246→\n   247→  if (result.rows.length === 0) {\n   248→    return { success: false, error: 'No license key found for this customer' };\n   249→  }\n   250→\n   251→  const license = result.rows[0];\n   252→  return {\n   253→    success: true,\n   254→    key: license.key,\n   255→    activated: !!license.activated_at,\n   256→    isActive: license.is_active,\n   257→    createdAt: license.created_at,\n   258→    activatedAt: license.activated_at\n   259→  };\n   260→}\n   261→\n   262→/**\n   263→ * Deactivate a license key\n   264→ *\n   265→ * @param {string} key - License key to deactivate\n   266→ * @returns {Promise<{success: boolean, error?: string}>}\n   267→ */\n   268→async function deactivateLicenseKey(key) {\n   269→  if (!key) {\n   270→    return { success: false, error: 'License key is required' };\n   271→  }\n   272→\n   273→  const normalized = normalizeKey(key);\n   274→\n   275→  const result = await pool.query(\n   276→    'UPDATE license_keys SET is_active = FALSE WHERE key = $1 RETURNING id',\n   277→    [normalized]\n   278→  );\n   279→\n   280→  if (result.rowCount === 0) {\n   281→    return { success: false, error: 'License key not found' };\n   282→  }\n   283→\n   284→  console.log(`[License] Deactivated key: ${normalized}`);\n   285→  return { success: true };\n   286→}\n   287→\n   288→/**\n   289→ * Reactivate a license key\n   290→ *\n   291→ * @param {string} key - License key to reactivate\n   292→ * @returns {Promise<{success: boolean, error?: string}>}\n   293→ */\n   294→async function reactivateLicenseKey(key) {\n   295→  if (!key) {\n   296→    return { success: false, error: 'License key is required' };\n   297→  }\n   298→\n   299→  const normalized = normalizeKey(key);\n   300→\n   301→  const result = await pool.query(\n   302→    'UPDATE license_keys SET is_active = TRUE WHERE key = $1 RETURNING id',\n   303→    [normalized]\n   304→  );\n   305→\n   306→  if (result.rowCount === 0) {\n   307→    return { success: false, error: 'License key not found' };\n   308→  }\n   309→\n   310→  console.log(`[License] Reactivated key: ${normalized}`);\n   311→  return { success: true };\n   312→}\n   313→\n   314→module.exports = {\n   315→  initLicenseTables,\n   316→  generateLicenseKey,\n   317→  activateLicenseKey,\n   318→  getLicenseByCustomerId,\n   319→  deactivateLicenseKey,\n   320→  reactivateLicenseKey,\n   321→  isValidKeyFormat,\n   322→  normalizeKey,\n   323→  // Exposed for testing\n   324→  generateKeyString\n   325→};\n   326→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0ce6f543-13c3-4231-8968-678a952f5f03","timestamp":"2025-12-25T23:26:32.599Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/licenseService.js","content":"/**\n * License Key Service\n *\n * Generates and validates license keys for user authentication.\n * License keys are generated when a user purchases a subscription via Stripe.\n * Format: SPLICE-XXXX-XXXX-XXXX (alphanumeric, no confusing characters)\n */\n\nconst { Pool } = require('pg');\nconst crypto = require('crypto');\n\n// Use the same pool configuration as other services\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 5000\n});\n\n// Characters for key generation (no confusing chars: 0/O, 1/I/L)\nconst KEY_CHARS = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';\n\n/**\n * Initialize license_keys table\n */\nasync function initLicenseTables() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS license_keys (\n        id SERIAL PRIMARY KEY,\n        key VARCHAR(21) UNIQUE NOT NULL,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW(),\n        activated_at TIMESTAMP,\n        is_active BOOLEAN DEFAULT TRUE\n      )\n    `);\n\n    // Migrate existing column if needed (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF EXISTS (\n          SELECT 1 FROM information_schema.columns\n          WHERE table_name = 'license_keys'\n          AND column_name = 'key'\n          AND character_maximum_length = 19\n        ) THEN\n          ALTER TABLE license_keys ALTER COLUMN key TYPE VARCHAR(21);\n        END IF;\n      END $$;\n    `);\n\n    // Add indexes for efficient lookups\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_license_keys_key\n      ON license_keys(key)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_license_keys_customer\n      ON license_keys(stripe_customer_id)\n    `);\n\n    console.log('[License] Database tables initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Generate a random 4-character segment\n * @returns {string} 4 uppercase alphanumeric characters\n */\nfunction generateSegment() {\n  let segment = '';\n  for (let i = 0; i < 4; i++) {\n    segment += KEY_CHARS.charAt(crypto.randomInt(KEY_CHARS.length));\n  }\n  return segment;\n}\n\n/**\n * Generate a license key in format SPLICE-XXXX-XXXX-XXXX\n * @returns {string} License key\n */\nfunction generateKeyString() {\n  return `SPLICE-${generateSegment()}-${generateSegment()}-${generateSegment()}`;\n}\n\n/**\n * Validate license key format\n * @param {string} key - License key to validate\n * @returns {boolean} True if format is valid\n */\nfunction isValidKeyFormat(key) {\n  if (!key || typeof key !== 'string') return false;\n\n  // Normalize: uppercase and trim\n  const normalized = key.toUpperCase().trim();\n\n  // Must match SPLICE-XXXX-XXXX-XXXX pattern\n  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;\n  return pattern.test(normalized);\n}\n\n/**\n * Normalize a license key (uppercase, trim)\n * @param {string} key - License key\n * @returns {string} Normalized key\n */\nfunction normalizeKey(key) {\n  return (key || '').toUpperCase().trim();\n}\n\n/**\n * Generate a new license key for a Stripe customer\n *\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, key?: string, error?: string}>}\n */\nasync function generateLicenseKey(stripeCustomerId) {\n  if (!stripeCustomerId) {\n    return { success: false, error: 'Customer ID is required' };\n  }\n\n  const client = await pool.connect();\n  try {\n    // Check if customer already has a key\n    const existing = await client.query(\n      'SELECT key FROM license_keys WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (existing.rows.length > 0) {\n      return {\n        success: true,\n        key: existing.rows[0].key,\n        existing: true\n      };\n    }\n\n    // Generate unique key with retry logic\n    let key;\n    let attempts = 0;\n    const maxAttempts = 10;\n\n    while (attempts < maxAttempts) {\n      key = generateKeyString();\n      try {\n        await client.query(\n          `INSERT INTO license_keys (key, stripe_customer_id)\n           VALUES ($1, $2)`,\n          [key, stripeCustomerId]\n        );\n        break;\n      } catch (err) {\n        if (err.code === '23505') { // Unique violation\n          attempts++;\n          continue;\n        }\n        throw err;\n      }\n    }\n\n    if (attempts >= maxAttempts) {\n      return { success: false, error: 'Failed to generate unique license key' };\n    }\n\n    console.log(`[License] Generated key for customer ${stripeCustomerId}: ${key}`);\n    return { success: true, key };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Activate a license key\n *\n * @param {string} key - License key to activate\n * @returns {Promise<{success: boolean, customerId?: string, error?: string}>}\n */\nasync function activateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  if (!isValidKeyFormat(normalized)) {\n    return { success: false, error: 'Invalid license key format. Expected: SPLICE-XXXX-XXXX-XXXX' };\n  }\n\n  const client = await pool.connect();\n  try {\n    // Look up the key\n    const result = await client.query(\n      'SELECT * FROM license_keys WHERE key = $1',\n      [normalized]\n    );\n\n    if (result.rows.length === 0) {\n      return { success: false, error: 'License key not found' };\n    }\n\n    const license = result.rows[0];\n\n    if (!license.is_active) {\n      return { success: false, error: 'License key has been deactivated' };\n    }\n\n    // Update activated_at if not already set\n    if (!license.activated_at) {\n      await client.query(\n        'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n        [license.id]\n      );\n    }\n\n    return {\n      success: true,\n      customerId: license.stripe_customer_id\n    };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get license key for a customer\n *\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, key?: string, activated?: boolean, error?: string}>}\n */\nasync function getLicenseByCustomerId(stripeCustomerId) {\n  if (!stripeCustomerId) {\n    return { success: false, error: 'Customer ID is required' };\n  }\n\n  const result = await pool.query(\n    'SELECT * FROM license_keys WHERE stripe_customer_id = $1',\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { success: false, error: 'No license key found for this customer' };\n  }\n\n  const license = result.rows[0];\n  return {\n    success: true,\n    key: license.key,\n    activated: !!license.activated_at,\n    isActive: license.is_active,\n    createdAt: license.created_at,\n    activatedAt: license.activated_at\n  };\n}\n\n/**\n * Deactivate a license key\n *\n * @param {string} key - License key to deactivate\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function deactivateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  const result = await pool.query(\n    'UPDATE license_keys SET is_active = FALSE WHERE key = $1 RETURNING id',\n    [normalized]\n  );\n\n  if (result.rowCount === 0) {\n    return { success: false, error: 'License key not found' };\n  }\n\n  console.log(`[License] Deactivated key: ${normalized}`);\n  return { success: true };\n}\n\n/**\n * Reactivate a license key\n *\n * @param {string} key - License key to reactivate\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function reactivateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  const result = await pool.query(\n    'UPDATE license_keys SET is_active = TRUE WHERE key = $1 RETURNING id',\n    [normalized]\n  );\n\n  if (result.rowCount === 0) {\n    return { success: false, error: 'License key not found' };\n  }\n\n  console.log(`[License] Reactivated key: ${normalized}`);\n  return { success: true };\n}\n\nmodule.exports = {\n  initLicenseTables,\n  generateLicenseKey,\n  activateLicenseKey,\n  getLicenseByCustomerId,\n  deactivateLicenseKey,\n  reactivateLicenseKey,\n  isValidKeyFormat,\n  normalizeKey,\n  // Exposed for testing\n  generateKeyString\n};\n","numLines":326,"startLine":1,"totalLines":326}}}
{"parentUuid":"0ce6f543-13c3-4231-8968-678a952f5f03","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SADRrVX2CnFxSGXcqinEnQ","type":"tool_result","content":"     1→/**\n     2→ * Usage Tracking Service\n     3→ *\n     4→ * Tracks user credit balances and usage for billing.\n     5→ * Uses PostgreSQL for persistence.\n     6→ */\n     7→\n     8→const { Pool } = require('pg');\n     9→\n    10→// PostgreSQL connection pool with proper limits\n    11→const pool = new Pool({\n    12→  connectionString: process.env.DATABASE_URL,\n    13→  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    14→  // PERFORMANCE: Set connection pool limits\n    15→  max: 20,                    // Maximum number of clients in the pool\n    16→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n    17→  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n    18→});\n    19→\n    20→// Hours per tier (regular processing)\n    21→const TIER_HOURS = {\n    22→  starter: 15,\n    23→  pro: 50,\n    24→  team: 150,\n    25→  cancelled: 0\n    26→};\n    27→\n    28→// Isolation minutes per tier (sized to maintain 80% margins)\n    29→const TIER_ISOLATION_MINUTES = {\n    30→  starter: 0,     // No isolation access\n    31→  pro: 45,        // 45 minutes included\n    32→  team: 180,      // 3 hours included\n    33→  cancelled: 0\n    34→};\n    35→\n    36→// Convert to hours for database storage\n    37→const TIER_ISOLATION_HOURS = {\n    38→  starter: 0,\n    39→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n    40→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n    41→  cancelled: 0\n    42→};\n    43→\n    44→// Overage rate for isolation beyond included minutes\n    45→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n    46→\n    47→/**\n    48→ * Initialize database tables\n    49→ */\n    50→async function initDatabase() {\n    51→  const client = await pool.connect();\n    52→  try {\n    53→    await client.query(`\n    54→      CREATE TABLE IF NOT EXISTS users (\n    55→        id SERIAL PRIMARY KEY,\n    56→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n    57→        email VARCHAR(255),\n    58→        tier VARCHAR(50) DEFAULT 'starter',\n    59→        hours_remaining DECIMAL(10,4) DEFAULT 15,\n    60→        hours_total DECIMAL(10,4) DEFAULT 15,\n    61→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n    62→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n    63→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    64→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    65→      )\n    66→    `);\n    67→\n    68→    // Add isolation columns if they don't exist (for existing databases)\n    69→    await client.query(`\n    70→      DO $$\n    71→      BEGIN\n    72→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n    73→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n    74→        END IF;\n    75→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n    76→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n    77→        END IF;\n    78→      END $$;\n    79→    `);\n    80→\n    81→    await client.query(`\n    82→      CREATE TABLE IF NOT EXISTS usage_log (\n    83→        id SERIAL PRIMARY KEY,\n    84→        user_id INTEGER REFERENCES users(id),\n    85→        stripe_customer_id VARCHAR(255),\n    86→        audio_duration_seconds DECIMAL(10,2),\n    87→        hours_used DECIMAL(10,6),\n    88→        endpoint VARCHAR(100),\n    89→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    90→      )\n    91→    `);\n    92→\n    93→    await client.query(`\n    94→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    95→    `);\n    96→\n    97→    await client.query(`\n    98→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    99→    `);\n   100→\n   101→    // PERFORMANCE: Add composite index for efficient customer usage history queries\n   102→    await client.query(`\n   103→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n   104→      ON usage_log(stripe_customer_id, created_at DESC)\n   105→    `);\n   106→\n   107→    // Webhook events table for idempotency\n   108→    await client.query(`\n   109→      CREATE TABLE IF NOT EXISTS webhook_events (\n   110→        id SERIAL PRIMARY KEY,\n   111→        event_id VARCHAR(255) UNIQUE NOT NULL,\n   112→        event_type VARCHAR(100),\n   113→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   114→      )\n   115→    `);\n   116→\n   117→    await client.query(`\n   118→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n   119→    `);\n   120→\n   121→    console.log('[UsageTracking] Database initialized');\n   122→  } finally {\n   123→    client.release();\n   124→  }\n   125→}\n   126→\n   127→/**\n   128→ * Get or create a user by Stripe customer ID\n   129→ */\n   130→async function getOrCreateUser(stripeCustomerId, email = null) {\n   131→  const client = await pool.connect();\n   132→  try {\n   133→    // Try to find existing user\n   134→    let result = await client.query(\n   135→      'SELECT * FROM users WHERE stripe_customer_id = $1',\n   136→      [stripeCustomerId]\n   137→    );\n   138→\n   139→    if (result.rows.length > 0) {\n   140→      return result.rows[0];\n   141→    }\n   142→\n   143→    // Create new user with starter tier (no isolation hours)\n   144→    result = await client.query(\n   145→      `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   146→       VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   147→       RETURNING *`,\n   148→      [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n   149→    );\n   150→\n   151→    return result.rows[0];\n   152→  } finally {\n   153→    client.release();\n   154→  }\n   155→}\n   156→\n   157→/**\n   158→ * Get user's current credit balance\n   159→ */\n   160→async function getBalance(stripeCustomerId) {\n   161→  const user = await getOrCreateUser(stripeCustomerId);\n   162→  const hoursTotal = parseFloat(user.hours_total);\n   163→  const hoursRemaining = parseFloat(user.hours_remaining);\n   164→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   165→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   166→\n   167→  // Tier display names\n   168→  const tierNames = {\n   169→    starter: 'Starter',\n   170→    pro: 'Pro',\n   171→    team: 'Team',\n   172→    cancelled: 'Cancelled'\n   173→  };\n   174→\n   175→  return {\n   176→    hoursRemaining,\n   177→    hoursTotal,\n   178→    isolationHoursRemaining,\n   179→    isolationHoursTotal,\n   180→    tier: user.tier,\n   181→    tierName: tierNames[user.tier] || user.tier,\n   182→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   183→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   184→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   185→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   186→  };\n   187→}\n   188→\n   189→/**\n   190→ * Check if user has enough credits for estimated duration\n   191→ */\n   192→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n   193→  const balance = await getBalance(stripeCustomerId);\n   194→  const estimatedHours = estimatedSeconds / 3600;\n   195→  return balance.hoursRemaining >= estimatedHours;\n   196→}\n   197→\n   198→/**\n   199→ * Check if user can use vocal isolation\n   200→ * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n   201→ */\n   202→async function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n   203→  const balance = await getBalance(stripeCustomerId);\n   204→\n   205→  // Starter tier has no isolation access\n   206→  if (!balance.hasIsolationAccess) {\n   207→    return {\n   208→      allowed: false,\n   209→      reason: 'upgrade_required',\n   210→      message: 'Vocal isolation requires Pro or Team tier',\n   211→      hasIncludedHours: false,\n   212→      overageRequired: false,\n   213→      overageCost: 0\n   214→    };\n   215→  }\n   216→\n   217→  const estimatedHours = estimatedMinutes / 60;\n   218→  const remainingIncluded = balance.isolationHoursRemaining;\n   219→\n   220→  // Check if within included hours\n   221→  if (remainingIncluded >= estimatedHours) {\n   222→    return {\n   223→      allowed: true,\n   224→      reason: 'included',\n   225→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   226→      hasIncludedHours: true,\n   227→      overageRequired: false,\n   228→      overageCost: 0,\n   229→      isolationHoursRemaining: remainingIncluded - estimatedHours\n   230→    };\n   231→  }\n   232→\n   233→  // Calculate overage\n   234→  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n   235→  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   236→\n   237→  return {\n   238→    allowed: true,\n   239→    reason: 'overage',\n   240→    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n   241→    hasIncludedHours: remainingIncluded > 0,\n   242→    overageRequired: true,\n   243→    overageMinutes,\n   244→    overageCost,\n   245→    isolationHoursRemaining: 0\n   246→  };\n   247→}\n   248→\n   249→/**\n   250→ * Deduct isolation usage from user's balance\n   251→ * Returns overage cost if beyond included hours\n   252→ */\n   253→async function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n   254→  const durationMinutes = audioDurationSeconds / 60;\n   255→  const durationHours = audioDurationSeconds / 3600;\n   256→\n   257→  const client = await pool.connect();\n   258→  try {\n   259→    // Get user\n   260→    const userResult = await client.query(\n   261→      'SELECT * FROM users WHERE stripe_customer_id = $1',\n   262→      [stripeCustomerId]\n   263→    );\n   264→\n   265→    if (userResult.rows.length === 0) {\n   266→      throw new Error('User not found');\n   267→    }\n   268→\n   269→    const user = userResult.rows[0];\n   270→    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n   271→\n   272→    let overageCost = 0;\n   273→    let hoursFromIncluded = 0;\n   274→    let overageMinutes = 0;\n   275→\n   276→    if (remainingIncluded >= durationHours) {\n   277→      // Fully covered by included hours\n   278→      hoursFromIncluded = durationHours;\n   279→    } else {\n   280→      // Partial or full overage\n   281→      hoursFromIncluded = remainingIncluded;\n   282→      overageMinutes = durationMinutes - (remainingIncluded * 60);\n   283→      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   284→    }\n   285→\n   286→    // Update isolation balance\n   287→    await client.query(\n   288→      `UPDATE users\n   289→       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n   290→           updated_at = CURRENT_TIMESTAMP\n   291→       WHERE stripe_customer_id = $2`,\n   292→      [durationHours, stripeCustomerId]\n   293→    );\n   294→\n   295→    // Log usage (mark as isolation)\n   296→    await client.query(\n   297→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   298→       VALUES ($1, $2, $3, $4, $5)`,\n   299→      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n   300→    );\n   301→\n   302→    // Return updated balance and overage info\n   303→    const newBalance = await getBalance(stripeCustomerId);\n   304→    return {\n   305→      ...newBalance,\n   306→      isolationUsed: {\n   307→        durationMinutes,\n   308→        hoursFromIncluded,\n   309→        overageMinutes,\n   310→        overageCost\n   311→      }\n   312→    };\n   313→  } finally {\n   314→    client.release();\n   315→  }\n   316→}\n   317→\n   318→/**\n   319→ * Deduct usage from user's balance\n   320→ */\n   321→async function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n   322→  const hoursUsed = audioDurationSeconds / 3600;\n   323→\n   324→  const client = await pool.connect();\n   325→  try {\n   326→    // Get user\n   327→    const userResult = await client.query(\n   328→      'SELECT * FROM users WHERE stripe_customer_id = $1',\n   329→      [stripeCustomerId]\n   330→    );\n   331→\n   332→    if (userResult.rows.length === 0) {\n   333→      throw new Error('User not found');\n   334→    }\n   335→\n   336→    const user = userResult.rows[0];\n   337→\n   338→    // Update balance\n   339→    await client.query(\n   340→      `UPDATE users\n   341→       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   342→           updated_at = CURRENT_TIMESTAMP\n   343→       WHERE stripe_customer_id = $2`,\n   344→      [hoursUsed, stripeCustomerId]\n   345→    );\n   346→\n   347→    // Log usage\n   348→    await client.query(\n   349→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   350→       VALUES ($1, $2, $3, $4, $5)`,\n   351→      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n   352→    );\n   353→\n   354→    // Return updated balance\n   355→    return await getBalance(stripeCustomerId);\n   356→  } finally {\n   357→    client.release();\n   358→  }\n   359→}\n   360→\n   361→/**\n   362→ * Reset user's hours for new billing period\n   363→ */\n   364→async function resetHours(stripeCustomerId, tier) {\n   365→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   366→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   367→\n   368→  await pool.query(\n   369→    `UPDATE users\n   370→     SET hours_remaining = $1, hours_total = $1,\n   371→         isolation_hours_remaining = $2, isolation_hours_total = $2,\n   372→         tier = $3, updated_at = CURRENT_TIMESTAMP\n   373→     WHERE stripe_customer_id = $4`,\n   374→    [hours, isolationHours, tier, stripeCustomerId]\n   375→  );\n   376→\n   377→  return await getBalance(stripeCustomerId);\n   378→}\n   379→\n   380→/**\n   381→ * Update user's tier (from Stripe webhook)\n   382→ */\n   383→async function updateTier(stripeCustomerId, tier, email = null) {\n   384→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   385→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   386→\n   387→  const client = await pool.connect();\n   388→  try {\n   389→    // Check if user exists\n   390→    const result = await client.query(\n   391→      'SELECT * FROM users WHERE stripe_customer_id = $1',\n   392→      [stripeCustomerId]\n   393→    );\n   394→\n   395→    if (result.rows.length === 0) {\n   396→      // Create new user with this tier\n   397→      await client.query(\n   398→        `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   399→         VALUES ($1, $2, $3, $4, $4, $5, $5)`,\n   400→        [stripeCustomerId, email, tier, hours, isolationHours]\n   401→      );\n   402→    } else {\n   403→      // Update existing user\n   404→      await client.query(\n   405→        `UPDATE users\n   406→         SET tier = $1, hours_remaining = $2, hours_total = $2,\n   407→             isolation_hours_remaining = $3, isolation_hours_total = $3,\n   408→             updated_at = CURRENT_TIMESTAMP\n   409→         WHERE stripe_customer_id = $4`,\n   410→        [tier, hours, isolationHours, stripeCustomerId]\n   411→      );\n   412→    }\n   413→\n   414→    return await getBalance(stripeCustomerId);\n   415→  } finally {\n   416→    client.release();\n   417→  }\n   418→}\n   419→\n   420→/**\n   421→ * Get usage history for a user\n   422→ */\n   423→async function getUsageHistory(stripeCustomerId, limit = 50) {\n   424→  const result = await pool.query(\n   425→    `SELECT * FROM usage_log\n   426→     WHERE stripe_customer_id = $1\n   427→     ORDER BY created_at DESC\n   428→     LIMIT $2`,\n   429→    [stripeCustomerId, limit]\n   430→  );\n   431→  return result.rows;\n   432→}\n   433→\n   434→/**\n   435→ * Check if webhook event has already been processed (idempotency)\n   436→ */\n   437→async function isEventProcessed(eventId) {\n   438→  const result = await pool.query(\n   439→    'SELECT id FROM webhook_events WHERE event_id = $1',\n   440→    [eventId]\n   441→  );\n   442→  return result.rows.length > 0;\n   443→}\n   444→\n   445→/**\n   446→ * Record a processed webhook event\n   447→ */\n   448→async function recordWebhookEvent(eventId, eventType) {\n   449→  try {\n   450→    await pool.query(\n   451→      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n   452→      [eventId, eventType]\n   453→    );\n   454→  } catch (err) {\n   455→    // Ignore duplicate key errors (race condition safety)\n   456→    if (err.code !== '23505') throw err;\n   457→  }\n   458→}\n   459→\n   460→module.exports = {\n   461→  initDatabase,\n   462→  getOrCreateUser,\n   463→  getBalance,\n   464→  hasCredits,\n   465→  checkIsolationAccess,\n   466→  deductUsage,\n   467→  deductIsolationUsage,\n   468→  resetHours,\n   469→  updateTier,\n   470→  getUsageHistory,\n   471→  isEventProcessed,\n   472→  recordWebhookEvent,\n   473→  TIER_HOURS,\n   474→  TIER_ISOLATION_MINUTES,\n   475→  TIER_ISOLATION_HOURS,\n   476→  ISOLATION_OVERAGE_RATE\n   477→};\n   478→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"6e77871c-b3fe-473f-bcef-e96c311e311f","timestamp":"2025-12-25T23:26:32.599Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"/**\n * Usage Tracking Service\n *\n * Tracks user credit balances and usage for billing.\n * Uses PostgreSQL for persistence.\n */\n\nconst { Pool } = require('pg');\n\n// PostgreSQL connection pool with proper limits\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n  // PERFORMANCE: Set connection pool limits\n  max: 20,                    // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n});\n\n// Hours per tier (regular processing)\nconst TIER_HOURS = {\n  starter: 15,\n  pro: 50,\n  team: 150,\n  cancelled: 0\n};\n\n// Isolation minutes per tier (sized to maintain 80% margins)\nconst TIER_ISOLATION_MINUTES = {\n  starter: 0,     // No isolation access\n  pro: 45,        // 45 minutes included\n  team: 180,      // 3 hours included\n  cancelled: 0\n};\n\n// Convert to hours for database storage\nconst TIER_ISOLATION_HOURS = {\n  starter: 0,\n  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n  cancelled: 0\n};\n\n// Overage rate for isolation beyond included minutes\nconst ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n\n/**\n * Initialize database tables\n */\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n        email VARCHAR(255),\n        tier VARCHAR(50) DEFAULT 'starter',\n        hours_remaining DECIMAL(10,4) DEFAULT 15,\n        hours_total DECIMAL(10,4) DEFAULT 15,\n        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Add isolation columns if they don't exist (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n        END IF;\n      END $$;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS usage_log (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        stripe_customer_id VARCHAR(255),\n        audio_duration_seconds DECIMAL(10,2),\n        hours_used DECIMAL(10,6),\n        endpoint VARCHAR(100),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    `);\n\n    // PERFORMANCE: Add composite index for efficient customer usage history queries\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n      ON usage_log(stripe_customer_id, created_at DESC)\n    `);\n\n    // Webhook events table for idempotency\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id SERIAL PRIMARY KEY,\n        event_id VARCHAR(255) UNIQUE NOT NULL,\n        event_type VARCHAR(100),\n        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n    `);\n\n    console.log('[UsageTracking] Database initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get or create a user by Stripe customer ID\n */\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  const client = await pool.connect();\n  try {\n    // Try to find existing user\n    let result = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length > 0) {\n      return result.rows[0];\n    }\n\n    // Create new user with starter tier (no isolation hours)\n    result = await client.query(\n      `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n       VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n       RETURNING *`,\n      [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n    );\n\n    return result.rows[0];\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get user's current credit balance\n */\nasync function getBalance(stripeCustomerId) {\n  const user = await getOrCreateUser(stripeCustomerId);\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  // Tier display names\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Check if user has enough credits for estimated duration\n */\nasync function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n  const balance = await getBalance(stripeCustomerId);\n  const estimatedHours = estimatedSeconds / 3600;\n  return balance.hoursRemaining >= estimatedHours;\n}\n\n/**\n * Check if user can use vocal isolation\n * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n */\nasync function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n  const balance = await getBalance(stripeCustomerId);\n\n  // Starter tier has no isolation access\n  if (!balance.hasIsolationAccess) {\n    return {\n      allowed: false,\n      reason: 'upgrade_required',\n      message: 'Vocal isolation requires Pro or Team tier',\n      hasIncludedHours: false,\n      overageRequired: false,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remainingIncluded = balance.isolationHoursRemaining;\n\n  // Check if within included hours\n  if (remainingIncluded >= estimatedHours) {\n    return {\n      allowed: true,\n      reason: 'included',\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      hasIncludedHours: true,\n      overageRequired: false,\n      overageCost: 0,\n      isolationHoursRemaining: remainingIncluded - estimatedHours\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n\n  return {\n    allowed: true,\n    reason: 'overage',\n    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n    hasIncludedHours: remainingIncluded > 0,\n    overageRequired: true,\n    overageMinutes,\n    overageCost,\n    isolationHoursRemaining: 0\n  };\n}\n\n/**\n * Deduct isolation usage from user's balance\n * Returns overage cost if beyond included hours\n */\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n  const durationMinutes = audioDurationSeconds / 60;\n  const durationHours = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    // Get user\n    const userResult = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n\n    let overageCost = 0;\n    let hoursFromIncluded = 0;\n    let overageMinutes = 0;\n\n    if (remainingIncluded >= durationHours) {\n      // Fully covered by included hours\n      hoursFromIncluded = durationHours;\n    } else {\n      // Partial or full overage\n      hoursFromIncluded = remainingIncluded;\n      overageMinutes = durationMinutes - (remainingIncluded * 60);\n      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n    }\n\n    // Update isolation balance\n    await client.query(\n      `UPDATE users\n       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [durationHours, stripeCustomerId]\n    );\n\n    // Log usage (mark as isolation)\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n\n    // Return updated balance and overage info\n    const newBalance = await getBalance(stripeCustomerId);\n    return {\n      ...newBalance,\n      isolationUsed: {\n        durationMinutes,\n        hoursFromIncluded,\n        overageMinutes,\n        overageCost\n      }\n    };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct usage from user's balance\n */\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    // Get user\n    const userResult = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n\n    // Update balance\n    await client.query(\n      `UPDATE users\n       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [hoursUsed, stripeCustomerId]\n    );\n\n    // Log usage\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n    );\n\n    // Return updated balance\n    return await getBalance(stripeCustomerId);\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset user's hours for new billing period\n */\nasync function resetHours(stripeCustomerId, tier) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  await pool.query(\n    `UPDATE users\n     SET hours_remaining = $1, hours_total = $1,\n         isolation_hours_remaining = $2, isolation_hours_total = $2,\n         tier = $3, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $4`,\n    [hours, isolationHours, tier, stripeCustomerId]\n  );\n\n  return await getBalance(stripeCustomerId);\n}\n\n/**\n * Update user's tier (from Stripe webhook)\n */\nasync function updateTier(stripeCustomerId, tier, email = null) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  const client = await pool.connect();\n  try {\n    // Check if user exists\n    const result = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      // Create new user with this tier\n      await client.query(\n        `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n         VALUES ($1, $2, $3, $4, $4, $5, $5)`,\n        [stripeCustomerId, email, tier, hours, isolationHours]\n      );\n    } else {\n      // Update existing user\n      await client.query(\n        `UPDATE users\n         SET tier = $1, hours_remaining = $2, hours_total = $2,\n             isolation_hours_remaining = $3, isolation_hours_total = $3,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $4`,\n        [tier, hours, isolationHours, stripeCustomerId]\n      );\n    }\n\n    return await getBalance(stripeCustomerId);\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get usage history for a user\n */\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Check if webhook event has already been processed (idempotency)\n */\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n\n/**\n * Record a processed webhook event\n */\nasync function recordWebhookEvent(eventId, eventType) {\n  try {\n    await pool.query(\n      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n      [eventId, eventType]\n    );\n  } catch (err) {\n    // Ignore duplicate key errors (race condition safety)\n    if (err.code !== '23505') throw err;\n  }\n}\n\nmodule.exports = {\n  initDatabase,\n  getOrCreateUser,\n  getBalance,\n  hasCredits,\n  checkIsolationAccess,\n  deductUsage,\n  deductIsolationUsage,\n  resetHours,\n  updateTier,\n  getUsageHistory,\n  isEventProcessed,\n  recordWebhookEvent,\n  TIER_HOURS,\n  TIER_ISOLATION_MINUTES,\n  TIER_ISOLATION_HOURS,\n  ISOLATION_OVERAGE_RATE\n};\n","numLines":478,"startLine":1,"totalLines":478}}}
{"parentUuid":"6e77871c-b3fe-473f-bcef-e96c311e311f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L14yQJNwAozfoFkozmJHp4","type":"tool_result","content":"     1→/**\n     2→ * Credits Display Module\n     3→ *\n     4→ * Fetches and displays user's remaining hours from the billing backend.\n     5→ * Requires customerId to be set in settings.\n     6→ */\n     7→\n     8→// Use BACKEND_URL from config.js (defined in index.html before this file)\n     9→// Falls back to production URL if not defined\n    10→function getCreditsBackendUrl() {\n    11→  if (typeof BACKEND_URL !== 'undefined') return BACKEND_URL;\n    12→  return 'https://splice-api-production.up.railway.app';\n    13→}\n    14→\n    15→/**\n    16→ * Fetch user's credit balance from backend\n    17→ * @returns {Promise<Object | null>} Credit data including isolation hours\n    18→ */\n    19→async function fetchCredits() {\n    20→  const settings = getSettings();\n    21→  const customerId = settings.customerId;\n    22→\n    23→  if (!customerId) {\n    24→    console.log('[SPLICE] No customerId configured - credits display disabled');\n    25→    return null;\n    26→  }\n    27→\n    28→  try {\n    29→    const response = await fetch(`${getCreditsBackendUrl()}/credits`, {\n    30→      method: 'GET',\n    31→      headers: {\n    32→        'x-stripe-customer-id': customerId\n    33→      }\n    34→    });\n    35→\n    36→    if (!response.ok) {\n    37→      const err = await response.json().catch(() => ({}));\n    38→      console.error('[SPLICE] Credits fetch failed:', err.error || response.status);\n    39→      return null;\n    40→    }\n    41→\n    42→    const data = await response.json();\n    43→    return {\n    44→      hoursRemaining: data.hoursRemaining || 0,\n    45→      hoursTotal: data.hoursTotal || 0,\n    46→      tierName: data.tierName || 'Free',\n    47→      tier: data.tier || 'starter',\n    48→      // Isolation hours\n    49→      isolationHoursRemaining: data.isolationHoursRemaining || 0,\n    50→      isolationHoursTotal: data.isolationHoursTotal || 0,\n    51→      hasIsolationAccess: data.hasIsolationAccess || false,\n    52→      isolationOverageRate: data.isolationOverageRate || 0.08\n    53→    };\n    54→  } catch (err) {\n    55→    console.error('[SPLICE] Credits fetch error:', err);\n    56→    return null;\n    57→  }\n    58→}\n    59→\n    60→// Store current credits globally for access checks\n    61→let currentCredits = null;\n    62→\n    63→/**\n    64→ * Update the credit display in the UI\n    65→ * @param {Object|null} credits - Credit data or null if unavailable\n    66→ */\n    67→function updateCreditDisplay(credits) {\n    68→  currentCredits = credits;\n    69→\n    70→  const creditBadge = document.getElementById('creditBadge');\n    71→  if (!creditBadge) return;\n    72→\n    73→  if (!credits) {\n    74→    creditBadge.style.display = 'none';\n    75→    return;\n    76→  }\n    77→\n    78→  creditBadge.style.display = 'flex';\n    79→  creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n    80→\n    81→  // Build tooltip with isolation info if available\n    82→  let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n    83→  if (credits.hasIsolationAccess) {\n    84→    tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n    85→  }\n    86→  creditBadge.title = tooltip;\n    87→\n    88→  // Color based on remaining hours\n    89→  if (credits.hoursRemaining <= 1) {\n    90→    creditBadge.classList.add('low');\n    91→    creditBadge.classList.remove('ok');\n    92→  } else {\n    93→    creditBadge.classList.add('ok');\n    94→    creditBadge.classList.remove('low');\n    95→  }\n    96→\n    97→  // Update isolation checkbox state based on tier access\n    98→  updateIsolationCheckboxState(credits);\n    99→}\n   100→\n   101→/**\n   102→ * Update the isolation checkbox based on tier access\n   103→ */\n   104→function updateIsolationCheckboxState(credits) {\n   105→  const isolatedCheckbox = document.getElementById('sourceIsolated');\n   106→  const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n   107→\n   108→  if (!isolatedCheckbox) return;\n   109→\n   110→  if (!credits || !credits.hasIsolationAccess) {\n   111→    // Disable isolation for non-Pro/Team users\n   112→    isolatedCheckbox.disabled = true;\n   113→    isolatedCheckbox.checked = false;\n   114→    if (tierBadge) {\n   115→      tierBadge.textContent = 'Pro+';\n   116→      tierBadge.style.opacity = '1';\n   117→    }\n   118→  } else {\n   119→    // Enable isolation for Pro/Team users\n   120→    isolatedCheckbox.disabled = false;\n   121→    if (tierBadge) {\n   122→      // Show remaining isolation time\n   123→      const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n   124→      tierBadge.textContent = `${minsRemaining} min`;\n   125→      tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n   126→    }\n   127→  }\n   128→}\n   129→\n   130→/**\n   131→ * Check if user can use isolation and get cost estimate\n   132→ * @param {number} estimatedMinutes - Estimated audio duration in minutes\n   133→ * @returns {Object} Access info with allowed, message, overageCost\n   134→ */\n   135→function checkIsolationAccess(estimatedMinutes = 0) {\n   136→  if (!currentCredits) {\n   137→    return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n   138→  }\n   139→\n   140→  if (!currentCredits.hasIsolationAccess) {\n   141→    return {\n   142→      allowed: false,\n   143→      message: 'Vocal isolation requires Pro or Team tier',\n   144→      upgradeRequired: true,\n   145→      overageCost: 0\n   146→    };\n   147→  }\n   148→\n   149→  const estimatedHours = estimatedMinutes / 60;\n   150→  const remaining = currentCredits.isolationHoursRemaining;\n   151→\n   152→  if (remaining >= estimatedHours) {\n   153→    return {\n   154→      allowed: true,\n   155→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   156→      overageCost: 0\n   157→    };\n   158→  }\n   159→\n   160→  // Calculate overage\n   161→  const overageMinutes = estimatedMinutes - (remaining * 60);\n   162→  const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n   163→\n   164→  return {\n   165→    allowed: true,\n   166→    message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n   167→    overageCost,\n   168→    overageMinutes\n   169→  };\n   170→}\n   171→\n   172→/**\n   173→ * Get current credits (for access checks)\n   174→ */\n   175→function getCurrentCredits() {\n   176→  return currentCredits;\n   177→}\n   178→\n   179→/**\n   180→ * Initialize credits display\n   181→ * Fetches credits on load and sets up periodic refresh\n   182→ */\n   183→async function initCredits() {\n   184→  // Initial fetch\n   185→  const credits = await fetchCredits();\n   186→  updateCreditDisplay(credits);\n   187→\n   188→  // Refresh credits every 5 minutes\n   189→  setInterval(async () => {\n   190→    const refreshedCredits = await fetchCredits();\n   191→    updateCreditDisplay(refreshedCredits);\n   192→  }, 5 * 60 * 1000);\n   193→}\n   194→\n   195→/**\n   196→ * Manually refresh credits (e.g., after a processing operation)\n   197→ */\n   198→async function refreshCredits() {\n   199→  const credits = await fetchCredits();\n   200→  updateCreditDisplay(credits);\n   201→  return credits;\n   202→}\n   203→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5f05d851-12f3-4ce7-8cc5-6a17d78671e9","timestamp":"2025-12-25T23:26:32.599Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-plugin/js/credits.js","content":"/**\n * Credits Display Module\n *\n * Fetches and displays user's remaining hours from the billing backend.\n * Requires customerId to be set in settings.\n */\n\n// Use BACKEND_URL from config.js (defined in index.html before this file)\n// Falls back to production URL if not defined\nfunction getCreditsBackendUrl() {\n  if (typeof BACKEND_URL !== 'undefined') return BACKEND_URL;\n  return 'https://splice-api-production.up.railway.app';\n}\n\n/**\n * Fetch user's credit balance from backend\n * @returns {Promise<Object | null>} Credit data including isolation hours\n */\nasync function fetchCredits() {\n  const settings = getSettings();\n  const customerId = settings.customerId;\n\n  if (!customerId) {\n    console.log('[SPLICE] No customerId configured - credits display disabled');\n    return null;\n  }\n\n  try {\n    const response = await fetch(`${getCreditsBackendUrl()}/credits`, {\n      method: 'GET',\n      headers: {\n        'x-stripe-customer-id': customerId\n      }\n    });\n\n    if (!response.ok) {\n      const err = await response.json().catch(() => ({}));\n      console.error('[SPLICE] Credits fetch failed:', err.error || response.status);\n      return null;\n    }\n\n    const data = await response.json();\n    return {\n      hoursRemaining: data.hoursRemaining || 0,\n      hoursTotal: data.hoursTotal || 0,\n      tierName: data.tierName || 'Free',\n      tier: data.tier || 'starter',\n      // Isolation hours\n      isolationHoursRemaining: data.isolationHoursRemaining || 0,\n      isolationHoursTotal: data.isolationHoursTotal || 0,\n      hasIsolationAccess: data.hasIsolationAccess || false,\n      isolationOverageRate: data.isolationOverageRate || 0.08\n    };\n  } catch (err) {\n    console.error('[SPLICE] Credits fetch error:', err);\n    return null;\n  }\n}\n\n// Store current credits globally for access checks\nlet currentCredits = null;\n\n/**\n * Update the credit display in the UI\n * @param {Object|null} credits - Credit data or null if unavailable\n */\nfunction updateCreditDisplay(credits) {\n  currentCredits = credits;\n\n  const creditBadge = document.getElementById('creditBadge');\n  if (!creditBadge) return;\n\n  if (!credits) {\n    creditBadge.style.display = 'none';\n    return;\n  }\n\n  creditBadge.style.display = 'flex';\n  creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n\n  // Build tooltip with isolation info if available\n  let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n  if (credits.hasIsolationAccess) {\n    tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n  }\n  creditBadge.title = tooltip;\n\n  // Color based on remaining hours\n  if (credits.hoursRemaining <= 1) {\n    creditBadge.classList.add('low');\n    creditBadge.classList.remove('ok');\n  } else {\n    creditBadge.classList.add('ok');\n    creditBadge.classList.remove('low');\n  }\n\n  // Update isolation checkbox state based on tier access\n  updateIsolationCheckboxState(credits);\n}\n\n/**\n * Update the isolation checkbox based on tier access\n */\nfunction updateIsolationCheckboxState(credits) {\n  const isolatedCheckbox = document.getElementById('sourceIsolated');\n  const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n\n  if (!isolatedCheckbox) return;\n\n  if (!credits || !credits.hasIsolationAccess) {\n    // Disable isolation for non-Pro/Team users\n    isolatedCheckbox.disabled = true;\n    isolatedCheckbox.checked = false;\n    if (tierBadge) {\n      tierBadge.textContent = 'Pro+';\n      tierBadge.style.opacity = '1';\n    }\n  } else {\n    // Enable isolation for Pro/Team users\n    isolatedCheckbox.disabled = false;\n    if (tierBadge) {\n      // Show remaining isolation time\n      const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n      tierBadge.textContent = `${minsRemaining} min`;\n      tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n    }\n  }\n}\n\n/**\n * Check if user can use isolation and get cost estimate\n * @param {number} estimatedMinutes - Estimated audio duration in minutes\n * @returns {Object} Access info with allowed, message, overageCost\n */\nfunction checkIsolationAccess(estimatedMinutes = 0) {\n  if (!currentCredits) {\n    return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n  }\n\n  if (!currentCredits.hasIsolationAccess) {\n    return {\n      allowed: false,\n      message: 'Vocal isolation requires Pro or Team tier',\n      upgradeRequired: true,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remaining = currentCredits.isolationHoursRemaining;\n\n  if (remaining >= estimatedHours) {\n    return {\n      allowed: true,\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      overageCost: 0\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remaining * 60);\n  const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n\n  return {\n    allowed: true,\n    message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n    overageCost,\n    overageMinutes\n  };\n}\n\n/**\n * Get current credits (for access checks)\n */\nfunction getCurrentCredits() {\n  return currentCredits;\n}\n\n/**\n * Initialize credits display\n * Fetches credits on load and sets up periodic refresh\n */\nasync function initCredits() {\n  // Initial fetch\n  const credits = await fetchCredits();\n  updateCreditDisplay(credits);\n\n  // Refresh credits every 5 minutes\n  setInterval(async () => {\n    const refreshedCredits = await fetchCredits();\n    updateCreditDisplay(refreshedCredits);\n  }, 5 * 60 * 1000);\n}\n\n/**\n * Manually refresh credits (e.g., after a processing operation)\n */\nasync function refreshCredits() {\n  const credits = await fetchCredits();\n  updateCreditDisplay(credits);\n  return credits;\n}\n","numLines":203,"startLine":1,"totalLines":203}}}
{"parentUuid":"5f05d851-12f3-4ce7-8cc5-6a17d78671e9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A9Bixy2gPv4x5TxWrAunGe","type":"tool_result","content":"     1→/**\n     2→ * Settings Management\n     3→ *\n     4→ * Persists user preferences to localStorage\n     5→ * v3.5: Added Persistent Token support for media folder access\n     6→ */\n     7→\n     8→const uxpFs = require('uxp').storage.localFileSystem;\n     9→\n    10→// =============================================================================\n    11→// CUSTOM PRESETS STORAGE (v3.5+)\n    12→// =============================================================================\n    13→\n    14→const CUSTOM_PRESETS_KEY = 'spliceCustomPresets';\n    15→\n    16→/**\n    17→ * Default structure for custom presets storage\n    18→ */\n    19→const DEFAULT_CUSTOM_PRESETS = {\n    20→  version: 1,\n    21→  presets: {},\n    22→  order: []\n    23→};\n    24→\n    25→/**\n    26→ * Load custom presets from localStorage\n    27→ * @returns {Object} Custom presets data structure\n    28→ */\n    29→function loadCustomPresets() {\n    30→  try {\n    31→    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);\n    32→    if (saved) {\n    33→      const parsed = JSON.parse(saved);\n    34→      // Validate structure\n    35→      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {\n    36→        // Return deep copy to avoid mutation issues\n    37→        return {\n    38→          version: parsed.version || 1,\n    39→          presets: { ...parsed.presets },\n    40→          order: [...(parsed.order || [])]\n    41→        };\n    42→      }\n    43→    }\n    44→  } catch (e) {\n    45→    console.warn('[SPLICE] Could not load custom presets:', e);\n    46→  }\n    47→  // Return fresh objects to avoid mutation of defaults\n    48→  return {\n    49→    version: 1,\n    50→    presets: {},\n    51→    order: []\n    52→  };\n    53→}\n    54→\n    55→/**\n    56→ * Save custom presets to localStorage\n    57→ * @param {Object} data - Custom presets data structure\n    58→ * @returns {boolean} Success status\n    59→ */\n    60→function saveCustomPresets(data) {\n    61→  try {\n    62→    if (!data || typeof data !== 'object') {\n    63→      console.warn('[SPLICE] Invalid custom presets data');\n    64→      return false;\n    65→    }\n    66→    // Ensure required fields\n    67→    const toSave = {\n    68→      version: data.version || DEFAULT_CUSTOM_PRESETS.version,\n    69→      presets: data.presets || {},\n    70→      order: data.order || []\n    71→    };\n    72→    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));\n    73→    return true;\n    74→  } catch (e) {\n    75→    console.warn('[SPLICE] Could not save custom presets:', e);\n    76→    return false;\n    77→  }\n    78→}\n    79→\n    80→/**\n    81→ * Generate a slugified ID from a preset name\n    82→ * @param {string} name - Preset name\n    83→ * @returns {string} Slugified ID\n    84→ */\n    85→function slugifyPresetName(name) {\n    86→  return name\n    87→    .toLowerCase()\n    88→    .trim()\n    89→    .replace(/[^a-z0-9]+/g, '-')\n    90→    .replace(/^-+|-+$/g, '')\n    91→    .substring(0, 50) || 'preset';\n    92→}\n    93→\n    94→/**\n    95→ * Generate a unique ID for a custom preset\n    96→ * @param {string} baseName - Base name to slugify\n    97→ * @param {Object} existingPresets - Current presets object\n    98→ * @returns {string} Unique ID\n    99→ */\n   100→function generateUniquePresetId(baseName, existingPresets) {\n   101→  const baseId = slugifyPresetName(baseName);\n   102→  let id = baseId;\n   103→  let counter = 1;\n   104→\n   105→  while (existingPresets[id]) {\n   106→    id = `${baseId}-${counter}`;\n   107→    counter++;\n   108→  }\n   109→\n   110→  return id;\n   111→}\n   112→\n   113→/**\n   114→ * Create a new custom preset\n   115→ * @param {Object} preset - Preset data\n   116→ * @param {string} preset.name - Preset name (required)\n   117→ * @param {string} [preset.description] - Preset description\n   118→ * @param {string} [preset.icon] - Icon name (default: 'settings')\n   119→ * @param {Object} [preset.settings] - Preset settings (uses current if not provided)\n   120→ * @returns {{success: boolean, id?: string, error?: string}}\n   121→ */\n   122→function createCustomPreset(preset) {\n   123→  // Validate input\n   124→  if (!preset || typeof preset !== 'object') {\n   125→    return { success: false, error: 'Invalid preset data' };\n   126→  }\n   127→\n   128→  if (!preset.name || typeof preset.name !== 'string' || !preset.name.trim()) {\n   129→    return { success: false, error: 'Preset name is required' };\n   130→  }\n   131→\n   132→  const name = preset.name.trim();\n   133→\n   134→  // Load current data\n   135→  const data = loadCustomPresets();\n   136→\n   137→  // Generate unique ID\n   138→  const id = generateUniquePresetId(name, data.presets);\n   139→\n   140→  // Get settings from preset or current settings\n   141→  const settings = preset.settings && typeof preset.settings === 'object'\n   142→    ? { ...preset.settings }\n   143→    : getCurrentPresetSettings();\n   144→\n   145→  // Validate settings\n   146→  if (!settings || typeof settings !== 'object') {\n   147→    return { success: false, error: 'Invalid settings' };\n   148→  }\n   149→\n   150→  // Create the preset object\n   151→  const newPreset = {\n   152→    id,\n   153→    name,\n   154→    description: preset.description || '',\n   155→    icon: preset.icon || 'settings',\n   156→    createdAt: new Date().toISOString(),\n   157→    settings\n   158→  };\n   159→\n   160→  // Add to presets and order\n   161→  data.presets[id] = newPreset;\n   162→  data.order.push(id);\n   163→\n   164→  // Save\n   165→  const saved = saveCustomPresets(data);\n   166→  if (!saved) {\n   167→    return { success: false, error: 'Failed to save preset' };\n   168→  }\n   169→\n   170→  console.log(`[SPLICE] Created custom preset: ${name} (${id})`);\n   171→  return { success: true, id };\n   172→}\n   173→\n   174→/**\n   175→ * Get current settings suitable for a preset\n   176→ * @returns {Object} Current preset-compatible settings\n   177→ */\n   178→function getCurrentPresetSettings() {\n   179→  const current = typeof getSettings === 'function' ? getSettings() : {};\n   180→  return {\n   181→    sensitivity: current.sensitivity || 50,\n   182→    threshold: current.threshold || -32,\n   183→    minSilenceLength: current.minSilenceLength || 0.5,\n   184→    paddingStart: current.paddingStart || 0.1,\n   185→    paddingEnd: current.paddingEnd || 0.1,\n   186→    autoMarkBest: current.autoMarkBest !== false,\n   187→    enableTakesDetection: current.enableTakesDetection !== false\n   188→  };\n   189→}\n   190→\n   191→/**\n   192→ * Update an existing custom preset\n   193→ * @param {string} id - Preset ID to update\n   194→ * @param {Object} updates - Fields to update\n   195→ * @param {string} [updates.name] - New name\n   196→ * @param {string} [updates.description] - New description\n   197→ * @param {string} [updates.icon] - New icon\n   198→ * @param {Object} [updates.settings] - New settings (merged with existing)\n   199→ * @returns {{success: boolean, error?: string}}\n   200→ */\n   201→function updateCustomPreset(id, updates) {\n   202→  // Validate input\n   203→  if (!id || typeof id !== 'string') {\n   204→    return { success: false, error: 'Preset ID is required' };\n   205→  }\n   206→\n   207→  if (!updates || typeof updates !== 'object') {\n   208→    return { success: false, error: 'Updates must be an object' };\n   209→  }\n   210→\n   211→  // Load current data\n   212→  const data = loadCustomPresets();\n   213→\n   214→  // Check if preset exists\n   215→  if (!data.presets[id]) {\n   216→    return { success: false, error: 'Preset not found' };\n   217→  }\n   218→\n   219→  const existing = data.presets[id];\n   220→\n   221→  // Apply updates (preserve fields not being updated)\n   222→  const updated = {\n   223→    ...existing,\n   224→    updatedAt: new Date().toISOString()\n   225→  };\n   226→\n   227→  // Update name (with validation)\n   228→  if (updates.name !== undefined) {\n   229→    if (typeof updates.name !== 'string' || !updates.name.trim()) {\n   230→      return { success: false, error: 'Name must be a non-empty string' };\n   231→    }\n   232→    updated.name = updates.name.trim();\n   233→  }\n   234→\n   235→  // Update description\n   236→  if (updates.description !== undefined) {\n   237→    updated.description = String(updates.description);\n   238→  }\n   239→\n   240→  // Update icon\n   241→  if (updates.icon !== undefined) {\n   242→    updated.icon = String(updates.icon);\n   243→  }\n   244→\n   245→  // Update settings (merge with existing)\n   246→  if (updates.settings !== undefined) {\n   247→    if (typeof updates.settings !== 'object') {\n   248→      return { success: false, error: 'Settings must be an object' };\n   249→    }\n   250→    updated.settings = {\n   251→      ...existing.settings,\n   252→      ...updates.settings\n   253→    };\n   254→  }\n   255→\n   256→  // Save updated preset\n   257→  data.presets[id] = updated;\n   258→\n   259→  const saved = saveCustomPresets(data);\n   260→  if (!saved) {\n   261→    return { success: false, error: 'Failed to save preset' };\n   262→  }\n   263→\n   264→  console.log(`[SPLICE] Updated custom preset: ${updated.name} (${id})`);\n   265→  return { success: true };\n   266→}\n   267→\n   268→/**\n   269→ * Get a custom preset by ID\n   270→ * @param {string} id - Preset ID\n   271→ * @returns {Object|null} Preset object or null if not found\n   272→ */\n   273→function getCustomPreset(id) {\n   274→  if (!id || typeof id !== 'string') {\n   275→    return null;\n   276→  }\n   277→\n   278→  const data = loadCustomPresets();\n   279→  return data.presets[id] || null;\n   280→}\n   281→\n   282→/**\n   283→ * Duplicate a custom preset\n   284→ * @param {string} id - Preset ID to duplicate\n   285→ * @returns {{success: boolean, id?: string, error?: string}}\n   286→ */\n   287→function duplicatePreset(id) {\n   288→  // Validate input\n   289→  if (!id || typeof id !== 'string') {\n   290→    return { success: false, error: 'Preset ID is required' };\n   291→  }\n   292→\n   293→  // Get the original preset\n   294→  const original = getPresetById(id);\n   295→  if (!original) {\n   296→    return { success: false, error: 'Preset not found' };\n   297→  }\n   298→\n   299→  // Generate new name with copy suffix\n   300→  let copyName = `${original.name} (Copy)`;\n   301→\n   302→  // Check if copy name already exists and increment if needed\n   303→  const data = loadCustomPresets();\n   304→  let copyNumber = 1;\n   305→  let testId = slugifyPresetName(copyName);\n   306→  while (data.presets[testId]) {\n   307→    copyNumber++;\n   308→    copyName = `${original.name} (Copy ${copyNumber})`;\n   309→    testId = slugifyPresetName(copyName);\n   310→  }\n   311→\n   312→  // Create the duplicate\n   313→  return createCustomPreset({\n   314→    name: copyName,\n   315→    description: original.description || '',\n   316→    icon: original.icon || 'settings',\n   317→    settings: original.settings ? { ...original.settings } : getCurrentPresetSettings()\n   318→  });\n   319→}\n   320→\n   321→/**\n   322→ * Export all custom presets to JSON string\n   323→ * @returns {{success: boolean, data?: string, count?: number, error?: string}}\n   324→ */\n   325→function exportPresets() {\n   326→  try {\n   327→    const data = loadCustomPresets();\n   328→    const customPresets = data.order.map(id => data.presets[id]).filter(Boolean);\n   329→\n   330→    if (customPresets.length === 0) {\n   331→      return { success: false, error: 'No custom presets to export' };\n   332→    }\n   333→\n   334→    const exportData = {\n   335→      version: 1,\n   336→      exportedAt: new Date().toISOString(),\n   337→      presets: customPresets\n   338→    };\n   339→\n   340→    return {\n   341→      success: true,\n   342→      data: JSON.stringify(exportData, null, 2),\n   343→      count: customPresets.length\n   344→    };\n   345→  } catch (e) {\n   346→    return { success: false, error: 'Failed to export presets: ' + e.message };\n   347→  }\n   348→}\n   349→\n   350→/**\n   351→ * Import presets from JSON string\n   352→ * @param {string} jsonString - JSON string containing presets\n   353→ * @param {boolean} merge - If true, merge with existing; if false, skip duplicates\n   354→ * @returns {{success: boolean, imported?: number, skipped?: number, error?: string}}\n   355→ */\n   356→function importPresets(jsonString, merge = true) {\n   357→  try {\n   358→    // Parse JSON\n   359→    const imported = JSON.parse(jsonString);\n   360→\n   361→    // Validate structure\n   362→    if (!imported || !imported.presets || !Array.isArray(imported.presets)) {\n   363→      return { success: false, error: 'Invalid preset file format' };\n   364→    }\n   365→\n   366→    let importedCount = 0;\n   367→    let skippedCount = 0;\n   368→\n   369→    for (const preset of imported.presets) {\n   370→      // Validate each preset has required fields\n   371→      if (!preset.name || typeof preset.name !== 'string') {\n   372→        skippedCount++;\n   373→        continue;\n   374→      }\n   375→\n   376→      // Check if a preset with this name already exists\n   377→      const existingId = slugifyPresetName(preset.name);\n   378→      const existing = getCustomPreset(existingId);\n   379→\n   380→      if (existing && !merge) {\n   381→        // Skip existing if not merging\n   382→        skippedCount++;\n   383→        continue;\n   384→      }\n   385→\n   386→      // If existing and merge mode, create with unique name\n   387→      if (existing && merge) {\n   388→        let newName = `${preset.name} (Imported)`;\n   389→        let counter = 1;\n   390→        while (getCustomPreset(slugifyPresetName(newName))) {\n   391→          counter++;\n   392→          newName = `${preset.name} (Imported ${counter})`;\n   393→        }\n   394→        preset.name = newName;\n   395→      }\n   396→\n   397→      // Create the preset\n   398→      const result = createCustomPreset({\n   399→        name: preset.name,\n   400→        description: preset.description || '',\n   401→        icon: preset.icon || 'settings',\n   402→        settings: preset.settings || getCurrentPresetSettings()\n   403→      });\n   404→\n   405→      if (result.success) {\n   406→        importedCount++;\n   407→      } else {\n   408→        skippedCount++;\n   409→      }\n   410→    }\n   411→\n   412→    if (importedCount === 0 && skippedCount > 0) {\n   413→      return { success: false, error: 'All presets already exist or were invalid', skipped: skippedCount };\n   414→    }\n   415→\n   416→    return {\n   417→      success: true,\n   418→      imported: importedCount,\n   419→      skipped: skippedCount\n   420→    };\n   421→  } catch (e) {\n   422→    if (e instanceof SyntaxError) {\n   423→      return { success: false, error: 'Invalid JSON format' };\n   424→    }\n   425→    return { success: false, error: 'Failed to import presets: ' + e.message };\n   426→  }\n   427→}\n   428→\n   429→/**\n   430→ * Delete a custom preset\n   431→ * @param {string} id - Preset ID to delete\n   432→ * @returns {{success: boolean, error?: string}}\n   433→ */\n   434→function deleteCustomPreset(id) {\n   435→  // Validate input\n   436→  if (!id || typeof id !== 'string') {\n   437→    return { success: false, error: 'Preset ID is required' };\n   438→  }\n   439→\n   440→  // Load current data\n   441→  const data = loadCustomPresets();\n   442→\n   443→  // Check if preset exists\n   444→  if (!data.presets[id]) {\n   445→    return { success: false, error: 'Preset not found' };\n   446→  }\n   447→\n   448→  const presetName = data.presets[id].name;\n   449→\n   450→  // Remove from presets object\n   451→  delete data.presets[id];\n   452→\n   453→  // Remove from order array\n   454→  const orderIndex = data.order.indexOf(id);\n   455→  if (orderIndex !== -1) {\n   456→    data.order.splice(orderIndex, 1);\n   457→  }\n   458→\n   459→  // Save\n   460→  const saved = saveCustomPresets(data);\n   461→  if (!saved) {\n   462→    return { success: false, error: 'Failed to save after deletion' };\n   463→  }\n   464→\n   465→  console.log(`[SPLICE] Deleted custom preset: ${presetName} (${id})`);\n   466→  return { success: true };\n   467→}\n   468→\n   469→/**\n   470→ * List of built-in preset IDs (cannot be modified or deleted)\n   471→ */\n   472→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n   473→\n   474→/**\n   475→ * Check if a preset is a built-in preset\n   476→ * @param {string} id - Preset ID to check\n   477→ * @returns {boolean} True if built-in, false if custom\n   478→ */\n   479→function isBuiltInPreset(id) {\n   480→  return BUILT_IN_PRESET_IDS.includes(id);\n   481→}\n   482→\n   483→/**\n   484→ * Get all presets (built-in + custom merged)\n   485→ * Built-in presets appear first, then custom presets in their creation order.\n   486→ * Each preset has isBuiltIn flag added.\n   487→ *\n   488→ * @returns {Array<Object>} Array of preset objects with metadata\n   489→ */\n   490→function getAllPresets() {\n   491→  // Get built-in presets\n   492→  const builtInPresets = BUILT_IN_PRESET_IDS.map(id => {\n   493→    const preset = PRESETS[id];\n   494→    return {\n   495→      id,\n   496→      name: preset.name,\n   497→      description: preset.description,\n   498→      icon: preset.icon,\n   499→      settings: preset.settings,\n   500→      isBuiltIn: true\n   501→    };\n   502→  });\n   503→\n   504→  // Get custom presets\n   505→  const customData = loadCustomPresets();\n   506→  const customPresets = customData.order.map(id => {\n   507→    const preset = customData.presets[id];\n   508→    if (!preset) return null;\n   509→    return {\n   510→      ...preset,\n   511→      isBuiltIn: false\n   512→    };\n   513→  }).filter(Boolean);\n   514→\n   515→  // Merge: built-in first, then custom\n   516→  return [...builtInPresets, ...customPresets];\n   517→}\n   518→\n   519→/**\n   520→ * Get all preset IDs (built-in + custom)\n   521→ * @returns {Array<string>} Array of preset IDs\n   522→ */\n   523→function getAllPresetIds() {\n   524→  const customData = loadCustomPresets();\n   525→  return [...BUILT_IN_PRESET_IDS, ...customData.order];\n   526→}\n   527→\n   528→/**\n   529→ * Get a preset by ID (built-in or custom)\n   530→ * @param {string} id - Preset ID\n   531→ * @returns {Object|null} Preset object or null if not found\n   532→ */\n   533→function getPresetById(id) {\n   534→  if (!id || typeof id !== 'string') {\n   535→    return null;\n   536→  }\n   537→\n   538→  // Check built-in first\n   539→  if (isBuiltInPreset(id)) {\n   540→    const preset = PRESETS[id];\n   541→    return {\n   542→      id,\n   543→      name: preset.name,\n   544→      description: preset.description,\n   545→      icon: preset.icon,\n   546→      settings: preset.settings,\n   547→      isBuiltIn: true\n   548→    };\n   549→  }\n   550→\n   551→  // Check custom presets\n   552→  const custom = getCustomPreset(id);\n   553→  if (custom) {\n   554→    return {\n   555→      ...custom,\n   556→      isBuiltIn: false\n   557→    };\n   558→  }\n   559→\n   560→  return null;\n   561→}\n   562→\n   563→const DEFAULT_SETTINGS = {\n   564→  sensitivity: 50,\n   565→  audioSource: 'original',\n   566→  autoMarkBest: true,\n   567→  enableTakesDetection: true,\n   568→  rememberOptions: false,\n   569→  optionsExpanded: false,\n   570→  customerId: null,          // Stripe customer ID for billing\n   571→  mediaFolderToken: null,    // Persistent token for media folder access\n   572→  mediaFolderPath: null,     // Path to the media folder (for display)\n   573→  activePreset: 'custom'     // Currently active preset\n   574→};\n   575→\n   576→// =============================================================================\n   577→// PRESET PROFILES\n   578→// =============================================================================\n   579→\n   580→/**\n   581→ * Detection presets for different content types.\n   582→ * Each preset defines optimal settings for a specific use case.\n   583→ */\n   584→const PRESETS = {\n   585→  // Custom - user-defined settings (default)\n   586→  custom: {\n   587→    name: 'Custom',\n   588→    description: 'Your custom settings',\n   589→    icon: 'settings',\n   590→    settings: null // Uses current user settings\n   591→  },\n   592→\n   593→  // Podcast - longer pauses are natural, be conservative\n   594→  podcast: {\n   595→    name: 'Podcast',\n   596→    description: 'Longer natural pauses, conversational flow',\n   597→    icon: 'mic',\n   598→    settings: {\n   599→      sensitivity: 35,           // Lower sensitivity (fewer cuts)\n   600→      threshold: -35,            // Higher threshold (only deep silence)\n   601→      minSilenceLength: 0.8,     // Longer minimum silence\n   602→      paddingStart: 0.15,        // More padding for natural transitions\n   603→      paddingEnd: 0.15,\n   604→      mergeDistance: 0.3,        // Merge nearby silences\n   605→      autoMarkBest: false,       // Don't auto-mark (manual review)\n   606→      enableTakesDetection: true\n   607→    }\n   608→  },\n   609→\n   610→  // Interview - balanced, respects speaker pauses\n   611→  interview: {\n   612→    name: 'Interview',\n   613→    description: 'Balanced cuts, preserves Q&A rhythm',\n   614→    icon: 'people',\n   615→    settings: {\n   616→      sensitivity: 50,           // Medium sensitivity\n   617→      threshold: -32,            // Moderate threshold\n   618→      minSilenceLength: 0.5,     // Standard minimum silence\n   619→      paddingStart: 0.12,        // Moderate padding\n   620→      paddingEnd: 0.08,\n   621→      mergeDistance: 0.2,\n   622→      autoMarkBest: true,\n   623→      enableTakesDetection: true\n   624→    }\n   625→  },\n   626→\n   627→  // Reaction video - fast pacing, quick cuts\n   628→  reaction: {\n   629→    name: 'Reaction',\n   630→    description: 'Fast-paced, tight cuts for energy',\n   631→    icon: 'bolt',\n   632→    settings: {\n   633→      sensitivity: 70,           // Higher sensitivity (more cuts)\n   634→      threshold: -28,            // Lower threshold (catches more silence)\n   635→      minSilenceLength: 0.3,     // Short minimum silence\n   636→      paddingStart: 0.05,        // Minimal padding for snappy edits\n   637→      paddingEnd: 0.03,\n   638→      mergeDistance: 0.15,\n   639→      autoMarkBest: true,\n   640→      enableTakesDetection: false // Usually single-take content\n   641→    }\n   642→  },\n   643→\n   644→  // Tutorial/Educational - preserve thinking pauses\n   645→  tutorial: {\n   646→    name: 'Tutorial',\n   647→    description: 'Preserves teaching pace, minimal cuts',\n   648→    icon: 'school',\n   649→    settings: {\n   650→      sensitivity: 30,           // Low sensitivity\n   651→      threshold: -38,            // Only deep silence\n   652→      minSilenceLength: 1.0,     // Long minimum (preserve demo pauses)\n   653→      paddingStart: 0.2,         // Extra padding for clarity\n   654→      paddingEnd: 0.15,\n   655→      mergeDistance: 0.4,\n   656→      autoMarkBest: false,\n   657→      enableTakesDetection: true\n   658→    }\n   659→  },\n   660→\n   661→  // Vlog/YouTube - punchy edits, engagement-focused\n   662→  vlog: {\n   663→    name: 'Vlog',\n   664→    description: 'Punchy edits for YouTube engagement',\n   665→    icon: 'videocam',\n   666→    settings: {\n   667→      sensitivity: 65,           // Higher sensitivity\n   668→      threshold: -30,            // Moderate-low threshold\n   669→      minSilenceLength: 0.35,    // Short silences\n   670→      paddingStart: 0.08,        // Quick transitions\n   671→      paddingEnd: 0.05,\n   672→      mergeDistance: 0.2,\n   673→      autoMarkBest: true,\n   674→      enableTakesDetection: true\n   675→    }\n   676→  }\n   677→};\n   678→\n   679→/**\n   680→ * Get all available presets\n   681→ * @returns {Object} All preset definitions\n   682→ */\n   683→function getPresets() {\n   684→  return { ...PRESETS };\n   685→}\n   686→\n   687→/**\n   688→ * Get a specific preset by name\n   689→ * @param {string} presetName - Name of the preset\n   690→ * @returns {Object|null} Preset definition or null if not found\n   691→ */\n   692→function getPreset(presetName) {\n   693→  return PRESETS[presetName] || null;\n   694→}\n   695→\n   696→/**\n   697→ * Get preset names as array (for UI)\n   698→ * @returns {Array<string>} Array of preset names\n   699→ */\n   700→function getPresetNames() {\n   701→  return Object.keys(PRESETS);\n   702→}\n   703→\n   704→/**\n   705→ * Apply a preset to current settings\n   706→ * @param {string} presetName - Name of the preset to apply\n   707→ * @returns {Object} The applied settings\n   708→ */\n   709→function applyPreset(presetName) {\n   710→  const preset = PRESETS[presetName];\n   711→\n   712→  if (!preset) {\n   713→    console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n   714→    return getSettings();\n   715→  }\n   716→\n   717→  // Custom preset uses current settings\n   718→  if (presetName === 'custom' || !preset.settings) {\n   719→    saveSettings({ activePreset: 'custom' });\n   720→    return getSettings();\n   721→  }\n   722→\n   723→  // Apply preset settings\n   724→  const newSettings = {\n   725→    ...preset.settings,\n   726→    activePreset: presetName\n   727→  };\n   728→\n   729→  saveSettings(newSettings);\n   730→  console.log(`[SPLICE] Applied preset: ${preset.name}`);\n   731→\n   732→  return getSettings();\n   733→}\n   734→\n   735→/**\n   736→ * Get the currently active preset\n   737→ * @returns {string} Active preset name\n   738→ */\n   739→function getActivePreset() {\n   740→  const settings = getSettings();\n   741→  return settings.activePreset || 'custom';\n   742→}\n   743→\n   744→/**\n   745→ * Check if current settings match a preset\n   746→ * @param {string} presetName - Preset to compare against\n   747→ * @returns {boolean} True if settings match the preset\n   748→ */\n   749→function settingsMatchPreset(presetName) {\n   750→  const preset = PRESETS[presetName];\n   751→  if (!preset || !preset.settings) return presetName === 'custom';\n   752→\n   753→  const current = getSettings();\n   754→\n   755→  // Compare relevant settings\n   756→  return Object.keys(preset.settings).every(key => {\n   757→    if (key === 'activePreset') return true;\n   758→    return current[key] === preset.settings[key];\n   759→  });\n   760→}\n   761→\n   762→let currentSettings = { ...DEFAULT_SETTINGS };\n   763→\n   764→/**\n   765→ * Load settings from localStorage\n   766→ */\n   767→function loadSettings() {\n   768→  try {\n   769→    const saved = localStorage.getItem('spliceSettings');\n   770→    if (saved) {\n   771→      currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };\n   772→    }\n   773→  } catch (e) {\n   774→    console.warn('[SPLICE] Could not load settings:', e);\n   775→    currentSettings = { ...DEFAULT_SETTINGS };\n   776→  }\n   777→  return currentSettings;\n   778→}\n   779→\n   780→/**\n   781→ * Save settings to localStorage\n   782→ */\n   783→function saveSettings(settings) {\n   784→  try {\n   785→    currentSettings = { ...currentSettings, ...settings };\n   786→    localStorage.setItem('spliceSettings', JSON.stringify(currentSettings));\n   787→  } catch (e) {\n   788→    console.warn('[SPLICE] Could not save settings:', e);\n   789→  }\n   790→}\n   791→\n   792→/**\n   793→ * Get current settings\n   794→ */\n   795→function getSettings() {\n   796→  return { ...currentSettings };\n   797→}\n   798→\n   799→/**\n   800→ * Reset settings to defaults\n   801→ */\n   802→function resetSettings() {\n   803→  currentSettings = { ...DEFAULT_SETTINGS };\n   804→  try {\n   805→    localStorage.removeItem('spliceSettings');\n   806→  } catch (e) {\n   807→    console.warn('[SPLICE] Could not clear settings:', e);\n   808→  }\n   809→}\n   810→\n   811→/**\n   812→ * Initialize settings UI components\n   813→ */\n   814→function initSettingsUI() {\n   815→  const settings = loadSettings();\n   816→\n   817→  // Apply saved sensitivity to slider\n   818→  const sensitivitySlider = document.getElementById('sensitivitySlider');\n   819→  if (sensitivitySlider) {\n   820→    sensitivitySlider.value = settings.sensitivity;\n   821→  }\n   822→\n   823→  // Apply saved audio source\n   824→  const sourceOriginal = document.getElementById('sourceOriginal');\n   825→  const sourceIsolated = document.getElementById('sourceIsolated');\n   826→  if (sourceOriginal && sourceIsolated) {\n   827→    sourceOriginal.checked = settings.audioSource === 'original' || settings.audioSource === 'both';\n   828→    sourceIsolated.checked = settings.audioSource === 'isolated' || settings.audioSource === 'both';\n   829→  }\n   830→\n   831→  // Apply auto-mark best setting\n   832→  const autoMarkBest = document.getElementById('autoMarkBest');\n   833→  if (autoMarkBest) {\n   834→    autoMarkBest.checked = settings.autoMarkBest;\n   835→  }\n   836→\n   837→  // Apply takes detection setting\n   838→  const enableTakesDetection = document.getElementById('enableTakesDetection');\n   839→  if (enableTakesDetection) {\n   840→    enableTakesDetection.checked = settings.enableTakesDetection;\n   841→  }\n   842→\n   843→  // Apply remember options setting\n   844→  const rememberOptions = document.getElementById('rememberOptions');\n   845→  if (rememberOptions) {\n   846→    rememberOptions.checked = settings.rememberOptions;\n   847→  }\n   848→\n   849→  // Restore expanded state if remember is enabled\n   850→  if (settings.rememberOptions && settings.optionsExpanded) {\n   851→    toggleOptionsPanel(true);\n   852→  }\n   853→}\n   854→\n   855→/**\n   856→ * Toggle options panel visibility (unified panel)\n   857→ */\n   858→function toggleOptionsPanel(forceState) {\n   859→  const toggle = document.getElementById('optionsToggle');\n   860→  const panel = document.getElementById('optionsPanel');\n   861→\n   862→  if (!toggle || !panel) return;\n   863→\n   864→  const shouldExpand = forceState !== undefined ? forceState : panel.classList.contains('collapsed');\n   865→\n   866→  if (shouldExpand) {\n   867→    panel.classList.remove('collapsed');\n   868→    toggle.classList.add('expanded');\n   869→  } else {\n   870→    panel.classList.add('collapsed');\n   871→    toggle.classList.remove('expanded');\n   872→  }\n   873→\n   874→  // Save state if remember is enabled\n   875→  const settings = getSettings();\n   876→  if (settings.rememberOptions) {\n   877→    saveSettings({ optionsExpanded: shouldExpand });\n   878→  }\n   879→}\n   880→\n   881→/**\n   882→ * Initialize settings modal\n   883→ */\n   884→function initSettingsModal() {\n   885→  const settingsBtn = document.getElementById('settingsBtn');\n   886→  const modal = document.getElementById('settingsModal');\n   887→  const closeBtn = document.getElementById('closeSettingsBtn');\n   888→  const defaultSensitivity = document.getElementById('defaultSensitivity');\n   889→  const rememberOptions = document.getElementById('rememberOptions');\n   890→\n   891→  if (settingsBtn && modal) {\n   892→    settingsBtn.addEventListener('click', () => {\n   893→      modal.classList.remove('hidden');\n   894→      // Sync modal values with current settings\n   895→      const settings = getSettings();\n   896→      if (defaultSensitivity) defaultSensitivity.value = settings.sensitivity;\n   897→      if (rememberOptions) rememberOptions.checked = settings.rememberOptions;\n   898→    });\n   899→  }\n   900→\n   901→  if (closeBtn && modal) {\n   902→    closeBtn.addEventListener('click', () => {\n   903→      modal.classList.add('hidden');\n   904→    });\n   905→  }\n   906→\n   907→  // Close on backdrop click\n   908→  if (modal) {\n   909→    modal.addEventListener('click', (e) => {\n   910→      if (e.target === modal) {\n   911→        modal.classList.add('hidden');\n   912→      }\n   913→    });\n   914→  }\n   915→\n   916→  // Save default sensitivity when changed\n   917→  if (defaultSensitivity) {\n   918→    defaultSensitivity.addEventListener('change', () => {\n   919→      saveSettings({ sensitivity: parseInt(defaultSensitivity.value) });\n   920→      // Also update the main slider\n   921→      const mainSlider = document.getElementById('sensitivitySlider');\n   922→      if (mainSlider) mainSlider.value = defaultSensitivity.value;\n   923→    });\n   924→  }\n   925→\n   926→  // Save remember options when changed\n   927→  if (rememberOptions) {\n   928→    rememberOptions.addEventListener('change', () => {\n   929→      saveSettings({ rememberOptions: rememberOptions.checked });\n   930→    });\n   931→  }\n   932→}\n   933→\n   934→/**\n   935→ * Initialize options toggle (unified panel)\n   936→ */\n   937→function initOptionsToggles() {\n   938→  const toggle = document.getElementById('optionsToggle');\n   939→\n   940→  if (toggle) {\n   941→    toggle.addEventListener('click', () => toggleOptionsPanel());\n   942→  }\n   943→}\n   944→\n   945→/**\n   946→ * Initialize preset selector\n   947→ */\n   948→function initPresetSelector() {\n   949→  const presetSelector = document.getElementById('presetSelector');\n   950→  const sensitivitySlider = document.getElementById('sensitivitySlider');\n   951→\n   952→  if (!presetSelector) return;\n   953→\n   954→  // Set initial value from settings\n   955→  const settings = getSettings();\n   956→  presetSelector.value = settings.activePreset || 'custom';\n   957→\n   958→  // Handle preset change (supports both built-in and custom presets)\n   959→  presetSelector.addEventListener('change', () => {\n   960→    const presetId = presetSelector.value;\n   961→\n   962→    // Get preset info (works for both built-in and custom)\n   963→    const preset = getPresetById(presetId);\n   964→    if (!preset) {\n   965→      console.warn(`[SPLICE] Preset not found: ${presetId}`);\n   966→      return;\n   967→    }\n   968→\n   969→    let appliedSettings;\n   970→\n   971→    if (preset.isBuiltIn) {\n   972→      // Built-in preset: use the existing applyPreset function\n   973→      appliedSettings = applyPreset(presetId);\n   974→    } else {\n   975→      // Custom preset: apply stored settings\n   976→      appliedSettings = preset.settings || {};\n   977→      saveSettings({ activePreset: presetId, ...appliedSettings });\n   978→    }\n   979→\n   980→    // Update sensitivity slider to match preset\n   981→    if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n   982→      sensitivitySlider.value = appliedSettings.sensitivity;\n   983→    }\n   984→\n   985→    // Update takes detection checkbox\n   986→    const enableTakesDetection = document.getElementById('enableTakesDetection');\n   987→    if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n   988→      enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n   989→    }\n   990→\n   991→    // Update auto-mark best checkbox\n   992→    const autoMarkBest = document.getElementById('autoMarkBest');\n   993→    if (autoMarkBest && appliedSettings.autoMarkBest !== undefined) {\n   994→      autoMarkBest.checked = appliedSettings.autoMarkBest;\n   995→    }\n   996→\n   997→    if (typeof setStatus === 'function') {\n   998→      const desc = preset.description ? ` - ${preset.description}` : '';\n   999→      setStatus(`Preset: ${preset.name}${desc}`);\n  1000→    }\n  1001→  });\n  1002→\n  1003→  // Switch to custom when user manually changes sensitivity\n  1004→  if (sensitivitySlider) {\n  1005→    sensitivitySlider.addEventListener('change', () => {\n  1006→      if (presetSelector.value !== 'custom') {\n  1007→        presetSelector.value = 'custom';\n  1008→        saveSettings({ activePreset: 'custom' });\n  1009→      }\n  1010→    });\n  1011→  }\n  1012→}\n  1013→\n  1014→/**\n  1015→ * Initialize help button\n  1016→ */\n  1017→function initHelpButton() {\n  1018→  const helpBtn = document.getElementById('helpBtn');\n  1019→  if (helpBtn) {\n  1020→    helpBtn.addEventListener('click', () => {\n  1021→      setStatus('Silence: removes quiet gaps | Takes: detects repeated content');\n  1022→    });\n  1023→  }\n  1024→}\n  1025→\n  1026→// =============================================================================\n  1027→// PERSISTENT TOKEN MANAGEMENT (v3.5)\n  1028→// =============================================================================\n  1029→\n  1030→/**\n  1031→ * Media folder entry (cached after selection)\n  1032→ * @type {Object|null}\n  1033→ */\n  1034→let mediaFolderEntry = null;\n  1035→\n  1036→/**\n  1037→ * Prompt user to select a media folder and create a persistent token.\n  1038→ * This allows silent file access without repeated permission prompts.\n  1039→ *\n  1040→ * @returns {Promise<{success: boolean, path?: string, error?: string}>}\n  1041→ */\n  1042→async function setupMediaFolder() {\n  1043→  try {\n  1044→    // Open folder picker dialog\n  1045→    const folder = await uxpFs.getFolder();\n  1046→\n  1047→    if (!folder) {\n  1048→      return { success: false, error: 'No folder selected' };\n  1049→    }\n  1050→\n  1051→    // Create a persistent token for this folder\n  1052→    const token = await uxpFs.createPersistentToken(folder);\n  1053→\n  1054→    if (!token) {\n  1055→      return { success: false, error: 'Failed to create persistent token' };\n  1056→    }\n  1057→\n  1058→    // Get the folder path for display\n  1059→    const folderPath = folder.nativePath || folder.name;\n  1060→\n  1061→    // Save to settings\n  1062→    saveSettings({\n  1063→      mediaFolderToken: token,\n  1064→      mediaFolderPath: folderPath\n  1065→    });\n  1066→\n  1067→    // Cache the folder entry\n  1068→    mediaFolderEntry = folder;\n  1069→\n  1070→    console.log(`[SPLICE] Media folder set: ${folderPath}`);\n  1071→\n  1072→    return {\n  1073→      success: true,\n  1074→      path: folderPath,\n  1075→      token\n  1076→    };\n  1077→  } catch (err) {\n  1078→    console.error('[SPLICE] Error setting up media folder:', err);\n  1079→    return { success: false, error: err.message };\n  1080→  }\n  1081→}\n  1082→\n  1083→/**\n  1084→ * Get the media folder entry using the stored persistent token.\n  1085→ * Falls back to prompting if token is invalid.\n  1086→ *\n  1087→ * @returns {Promise<Object|null>} The folder entry or null\n  1088→ */\n  1089→async function getMediaFolder() {\n  1090→  // Return cached entry if available\n  1091→  if (mediaFolderEntry) {\n  1092→    return mediaFolderEntry;\n  1093→  }\n  1094→\n  1095→  const settings = getSettings();\n  1096→\n  1097→  // Try to restore from persistent token\n  1098→  if (settings.mediaFolderToken) {\n  1099→    try {\n  1100→      const folder = await uxpFs.getEntryForPersistentToken(settings.mediaFolderToken);\n  1101→      if (folder) {\n  1102→        mediaFolderEntry = folder;\n  1103→        console.log(`[SPLICE] Restored media folder from token: ${settings.mediaFolderPath}`);\n  1104→        return folder;\n  1105→      }\n  1106→    } catch (err) {\n  1107→      console.warn('[SPLICE] Could not restore media folder from token:', err.message);\n  1108→      // Clear invalid token\n  1109→      saveSettings({ mediaFolderToken: null, mediaFolderPath: null });\n  1110→    }\n  1111→  }\n  1112→\n  1113→  return null;\n  1114→}\n  1115→\n  1116→/**\n  1117→ * Check if a media folder is configured\n  1118→ * @returns {boolean}\n  1119→ */\n  1120→function hasMediaFolder() {\n  1121→  const settings = getSettings();\n  1122→  return !!settings.mediaFolderToken;\n  1123→}\n  1124→\n  1125→/**\n  1126→ * Get the configured media folder path (for display)\n  1127→ * @returns {string|null}\n  1128→ */\n  1129→function getMediaFolderPath() {\n  1130→  const settings = getSettings();\n  1131→  return settings.mediaFolderPath;\n  1132→}\n  1133→\n  1134→/**\n  1135→ * Clear the media folder configuration\n  1136→ */\n  1137→function clearMediaFolder() {\n  1138→  mediaFolderEntry = null;\n  1139→  saveSettings({\n  1140→    mediaFolderToken: null,\n  1141→    mediaFolderPath: null\n  1142→  });\n  1143→  console.log('[SPLICE] Media folder cleared');\n  1144→}\n  1145→\n  1146→/**\n  1147→ * Read a file from the media folder\n  1148→ * @param {string} filename - Name of the file to read\n  1149→ * @returns {Promise<ArrayBuffer|null>} File contents or null\n  1150→ */\n  1151→async function readMediaFile(filename) {\n  1152→  const folder = await getMediaFolder();\n  1153→  if (!folder) {\n  1154→    console.warn('[SPLICE] No media folder configured');\n  1155→    return null;\n  1156→  }\n  1157→\n  1158→  try {\n  1159→    const file = await folder.getEntry(filename);\n  1160→    if (!file) {\n  1161→      console.warn(`[SPLICE] File not found in media folder: ${filename}`);\n  1162→      return null;\n  1163→    }\n  1164→\n  1165→    const contents = await file.read({ format: uxpFs.formats.binary });\n  1166→    return contents;\n  1167→  } catch (err) {\n  1168→    console.error(`[SPLICE] Error reading file ${filename}:`, err);\n  1169→    return null;\n  1170→  }\n  1171→}\n  1172→\n  1173→// =============================================================================\n  1174→// LOGIN MODAL\n  1175→// =============================================================================\n  1176→\n  1177→/**\n  1178→ * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n  1179→ * @param {string} key - License key to validate\n  1180→ * @returns {boolean} True if format is valid\n  1181→ */\n  1182→function isValidLicenseKeyFormat(key) {\n  1183→  if (!key || typeof key !== 'string') return false;\n  1184→  const normalized = key.toUpperCase().trim();\n  1185→  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;\n  1186→  return pattern.test(normalized);\n  1187→}\n  1188→\n  1189→/**\n  1190→ * Initialize login modal handlers\n  1191→ */\n  1192→function initLoginModal() {\n  1193→  const loginModal = document.getElementById('loginModal');\n  1194→  const closeLoginBtn = document.getElementById('closeLoginBtn');\n  1195→  const saveLoginBtn = document.getElementById('saveLoginBtn');\n  1196→  const licenseKeyInput = document.getElementById('licenseKeyInput');\n  1197→  const loginError = document.getElementById('loginError');\n  1198→  const creditBadge = document.getElementById('creditBadge');\n  1199→\n  1200→  // Show login modal when clicking credit badge (always - allows viewing/changing license)\n  1201→  if (creditBadge) {\n  1202→    creditBadge.addEventListener('click', () => {\n  1203→      showLoginModal();\n  1204→    });\n  1205→  }\n  1206→\n  1207→  // Close login modal\n  1208→  if (closeLoginBtn && loginModal) {\n  1209→    closeLoginBtn.addEventListener('click', () => {\n  1210→      loginModal.classList.add('hidden');\n  1211→    });\n  1212→  }\n  1213→\n  1214→  // Close on backdrop click\n  1215→  if (loginModal) {\n  1216→    loginModal.addEventListener('click', (e) => {\n  1217→      if (e.target === loginModal) {\n  1218→        loginModal.classList.add('hidden');\n  1219→      }\n  1220→    });\n  1221→  }\n  1222→\n  1223→  // Activate license key\n  1224→  if (saveLoginBtn) {\n  1225→    saveLoginBtn.addEventListener('click', async () => {\n  1226→      const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n  1227→\n  1228→      if (!licenseKey) {\n  1229→        showLoginError('Please enter your license key');\n  1230→        return;\n  1231→      }\n  1232→\n  1233→      if (!isValidLicenseKeyFormat(licenseKey)) {\n  1234→        showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n  1235→        return;\n  1236→      }\n  1237→\n  1238→      // Show loading state\n  1239→      saveLoginBtn.disabled = true;\n  1240→      saveLoginBtn.textContent = 'Activating...';\n  1241→\n  1242→      try {\n  1243→        // Call license activation API (use BACKEND_URL from config.js)\n  1244→        const baseUrl = typeof BACKEND_URL !== 'undefined' ? BACKEND_URL : 'https://127.0.0.1:3847';\n  1245→        const response = await fetch(`${baseUrl}/license/activate`, {\n  1246→          method: 'POST',\n  1247→          headers: { 'Content-Type': 'application/json' },\n  1248→          body: JSON.stringify({ key: licenseKey })\n  1249→        });\n  1250→\n  1251→        const result = await response.json();\n  1252→\n  1253→        if (!result.success) {\n  1254→          showLoginError(result.error || 'Activation failed');\n  1255→          return;\n  1256→        }\n  1257→\n  1258→        // Save customer ID from activation response\n  1259→        saveSettings({ customerId: result.customerId });\n  1260→\n  1261→        // Hide modal\n  1262→        loginModal?.classList.add('hidden');\n  1263→\n  1264→        // Refresh credits display\n  1265→        if (typeof refreshCredits === 'function') {\n  1266→          await refreshCredits();\n  1267→        }\n  1268→\n  1269→        if (typeof setStatus === 'function') {\n  1270→          setStatus(`License activated! ${result.tierName} tier - ${result.hoursRemaining.toFixed(1)}h remaining`);\n  1271→        }\n  1272→      } catch (err) {\n  1273→        console.error('[SPLICE] License activation error:', err);\n  1274→        showLoginError('Connection error. Check server is running.');\n  1275→      } finally {\n  1276→        saveLoginBtn.disabled = false;\n  1277→        saveLoginBtn.textContent = 'Activate';\n  1278→      }\n  1279→    });\n  1280→  }\n  1281→\n  1282→  // Clear input on modal open (don't show old value for security)\n  1283→  // Customer ID is stored but license key is not displayed\n  1284→}\n  1285→\n  1286→/**\n  1287→ * Show login modal\n  1288→ */\n  1289→function showLoginModal() {\n  1290→  const loginModal = document.getElementById('loginModal');\n  1291→  const loginError = document.getElementById('loginError');\n  1292→\n  1293→  if (loginError) {\n  1294→    loginError.style.display = 'none';\n  1295→  }\n  1296→\n  1297→  if (loginModal) {\n  1298→    loginModal.classList.remove('hidden');\n  1299→  }\n  1300→}\n  1301→\n  1302→/**\n  1303→ * Show login error message\n  1304→ */\n  1305→function showLoginError(message) {\n  1306→  const loginError = document.getElementById('loginError');\n  1307→  if (loginError) {\n  1308→    loginError.textContent = message;\n  1309→    loginError.style.display = 'block';\n  1310→  }\n  1311→}\n  1312→\n  1313→/**\n  1314→ * Check if user is logged in\n  1315→ * @returns {boolean}\n  1316→ */\n  1317→function isLoggedIn() {\n  1318→  const settings = getSettings();\n  1319→  return !!settings.customerId;\n  1320→}\n  1321→\n  1322→/**\n  1323→ * Get customer ID\n  1324→ * @returns {string|null}\n  1325→ */\n  1326→function getCustomerId() {\n  1327→  const settings = getSettings();\n  1328→  return settings.customerId || null;\n  1329→}\n  1330→\n  1331→/**\n  1332→ * Logout - clear customer ID\n  1333→ */\n  1334→function logout() {\n  1335→  saveSettings({ customerId: null });\n  1336→  if (typeof setStatus === 'function') {\n  1337→    setStatus('Logged out');\n  1338→  }\n  1339→}\n  1340→\n  1341→// Load settings on script load\n  1342→loadSettings();\n  1343→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"03f1e522-4831-425b-b6e1-f70e640591ac","timestamp":"2025-12-25T23:26:32.794Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-plugin/js/settings.js","content":"/**\n * Settings Management\n *\n * Persists user preferences to localStorage\n * v3.5: Added Persistent Token support for media folder access\n */\n\nconst uxpFs = require('uxp').storage.localFileSystem;\n\n// =============================================================================\n// CUSTOM PRESETS STORAGE (v3.5+)\n// =============================================================================\n\nconst CUSTOM_PRESETS_KEY = 'spliceCustomPresets';\n\n/**\n * Default structure for custom presets storage\n */\nconst DEFAULT_CUSTOM_PRESETS = {\n  version: 1,\n  presets: {},\n  order: []\n};\n\n/**\n * Load custom presets from localStorage\n * @returns {Object} Custom presets data structure\n */\nfunction loadCustomPresets() {\n  try {\n    const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);\n    if (saved) {\n      const parsed = JSON.parse(saved);\n      // Validate structure\n      if (parsed && typeof parsed === 'object' && parsed.version && parsed.presets) {\n        // Return deep copy to avoid mutation issues\n        return {\n          version: parsed.version || 1,\n          presets: { ...parsed.presets },\n          order: [...(parsed.order || [])]\n        };\n      }\n    }\n  } catch (e) {\n    console.warn('[SPLICE] Could not load custom presets:', e);\n  }\n  // Return fresh objects to avoid mutation of defaults\n  return {\n    version: 1,\n    presets: {},\n    order: []\n  };\n}\n\n/**\n * Save custom presets to localStorage\n * @param {Object} data - Custom presets data structure\n * @returns {boolean} Success status\n */\nfunction saveCustomPresets(data) {\n  try {\n    if (!data || typeof data !== 'object') {\n      console.warn('[SPLICE] Invalid custom presets data');\n      return false;\n    }\n    // Ensure required fields\n    const toSave = {\n      version: data.version || DEFAULT_CUSTOM_PRESETS.version,\n      presets: data.presets || {},\n      order: data.order || []\n    };\n    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(toSave));\n    return true;\n  } catch (e) {\n    console.warn('[SPLICE] Could not save custom presets:', e);\n    return false;\n  }\n}\n\n/**\n * Generate a slugified ID from a preset name\n * @param {string} name - Preset name\n * @returns {string} Slugified ID\n */\nfunction slugifyPresetName(name) {\n  return name\n    .toLowerCase()\n    .trim()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n    .substring(0, 50) || 'preset';\n}\n\n/**\n * Generate a unique ID for a custom preset\n * @param {string} baseName - Base name to slugify\n * @param {Object} existingPresets - Current presets object\n * @returns {string} Unique ID\n */\nfunction generateUniquePresetId(baseName, existingPresets) {\n  const baseId = slugifyPresetName(baseName);\n  let id = baseId;\n  let counter = 1;\n\n  while (existingPresets[id]) {\n    id = `${baseId}-${counter}`;\n    counter++;\n  }\n\n  return id;\n}\n\n/**\n * Create a new custom preset\n * @param {Object} preset - Preset data\n * @param {string} preset.name - Preset name (required)\n * @param {string} [preset.description] - Preset description\n * @param {string} [preset.icon] - Icon name (default: 'settings')\n * @param {Object} [preset.settings] - Preset settings (uses current if not provided)\n * @returns {{success: boolean, id?: string, error?: string}}\n */\nfunction createCustomPreset(preset) {\n  // Validate input\n  if (!preset || typeof preset !== 'object') {\n    return { success: false, error: 'Invalid preset data' };\n  }\n\n  if (!preset.name || typeof preset.name !== 'string' || !preset.name.trim()) {\n    return { success: false, error: 'Preset name is required' };\n  }\n\n  const name = preset.name.trim();\n\n  // Load current data\n  const data = loadCustomPresets();\n\n  // Generate unique ID\n  const id = generateUniquePresetId(name, data.presets);\n\n  // Get settings from preset or current settings\n  const settings = preset.settings && typeof preset.settings === 'object'\n    ? { ...preset.settings }\n    : getCurrentPresetSettings();\n\n  // Validate settings\n  if (!settings || typeof settings !== 'object') {\n    return { success: false, error: 'Invalid settings' };\n  }\n\n  // Create the preset object\n  const newPreset = {\n    id,\n    name,\n    description: preset.description || '',\n    icon: preset.icon || 'settings',\n    createdAt: new Date().toISOString(),\n    settings\n  };\n\n  // Add to presets and order\n  data.presets[id] = newPreset;\n  data.order.push(id);\n\n  // Save\n  const saved = saveCustomPresets(data);\n  if (!saved) {\n    return { success: false, error: 'Failed to save preset' };\n  }\n\n  console.log(`[SPLICE] Created custom preset: ${name} (${id})`);\n  return { success: true, id };\n}\n\n/**\n * Get current settings suitable for a preset\n * @returns {Object} Current preset-compatible settings\n */\nfunction getCurrentPresetSettings() {\n  const current = typeof getSettings === 'function' ? getSettings() : {};\n  return {\n    sensitivity: current.sensitivity || 50,\n    threshold: current.threshold || -32,\n    minSilenceLength: current.minSilenceLength || 0.5,\n    paddingStart: current.paddingStart || 0.1,\n    paddingEnd: current.paddingEnd || 0.1,\n    autoMarkBest: current.autoMarkBest !== false,\n    enableTakesDetection: current.enableTakesDetection !== false\n  };\n}\n\n/**\n * Update an existing custom preset\n * @param {string} id - Preset ID to update\n * @param {Object} updates - Fields to update\n * @param {string} [updates.name] - New name\n * @param {string} [updates.description] - New description\n * @param {string} [updates.icon] - New icon\n * @param {Object} [updates.settings] - New settings (merged with existing)\n * @returns {{success: boolean, error?: string}}\n */\nfunction updateCustomPreset(id, updates) {\n  // Validate input\n  if (!id || typeof id !== 'string') {\n    return { success: false, error: 'Preset ID is required' };\n  }\n\n  if (!updates || typeof updates !== 'object') {\n    return { success: false, error: 'Updates must be an object' };\n  }\n\n  // Load current data\n  const data = loadCustomPresets();\n\n  // Check if preset exists\n  if (!data.presets[id]) {\n    return { success: false, error: 'Preset not found' };\n  }\n\n  const existing = data.presets[id];\n\n  // Apply updates (preserve fields not being updated)\n  const updated = {\n    ...existing,\n    updatedAt: new Date().toISOString()\n  };\n\n  // Update name (with validation)\n  if (updates.name !== undefined) {\n    if (typeof updates.name !== 'string' || !updates.name.trim()) {\n      return { success: false, error: 'Name must be a non-empty string' };\n    }\n    updated.name = updates.name.trim();\n  }\n\n  // Update description\n  if (updates.description !== undefined) {\n    updated.description = String(updates.description);\n  }\n\n  // Update icon\n  if (updates.icon !== undefined) {\n    updated.icon = String(updates.icon);\n  }\n\n  // Update settings (merge with existing)\n  if (updates.settings !== undefined) {\n    if (typeof updates.settings !== 'object') {\n      return { success: false, error: 'Settings must be an object' };\n    }\n    updated.settings = {\n      ...existing.settings,\n      ...updates.settings\n    };\n  }\n\n  // Save updated preset\n  data.presets[id] = updated;\n\n  const saved = saveCustomPresets(data);\n  if (!saved) {\n    return { success: false, error: 'Failed to save preset' };\n  }\n\n  console.log(`[SPLICE] Updated custom preset: ${updated.name} (${id})`);\n  return { success: true };\n}\n\n/**\n * Get a custom preset by ID\n * @param {string} id - Preset ID\n * @returns {Object|null} Preset object or null if not found\n */\nfunction getCustomPreset(id) {\n  if (!id || typeof id !== 'string') {\n    return null;\n  }\n\n  const data = loadCustomPresets();\n  return data.presets[id] || null;\n}\n\n/**\n * Duplicate a custom preset\n * @param {string} id - Preset ID to duplicate\n * @returns {{success: boolean, id?: string, error?: string}}\n */\nfunction duplicatePreset(id) {\n  // Validate input\n  if (!id || typeof id !== 'string') {\n    return { success: false, error: 'Preset ID is required' };\n  }\n\n  // Get the original preset\n  const original = getPresetById(id);\n  if (!original) {\n    return { success: false, error: 'Preset not found' };\n  }\n\n  // Generate new name with copy suffix\n  let copyName = `${original.name} (Copy)`;\n\n  // Check if copy name already exists and increment if needed\n  const data = loadCustomPresets();\n  let copyNumber = 1;\n  let testId = slugifyPresetName(copyName);\n  while (data.presets[testId]) {\n    copyNumber++;\n    copyName = `${original.name} (Copy ${copyNumber})`;\n    testId = slugifyPresetName(copyName);\n  }\n\n  // Create the duplicate\n  return createCustomPreset({\n    name: copyName,\n    description: original.description || '',\n    icon: original.icon || 'settings',\n    settings: original.settings ? { ...original.settings } : getCurrentPresetSettings()\n  });\n}\n\n/**\n * Export all custom presets to JSON string\n * @returns {{success: boolean, data?: string, count?: number, error?: string}}\n */\nfunction exportPresets() {\n  try {\n    const data = loadCustomPresets();\n    const customPresets = data.order.map(id => data.presets[id]).filter(Boolean);\n\n    if (customPresets.length === 0) {\n      return { success: false, error: 'No custom presets to export' };\n    }\n\n    const exportData = {\n      version: 1,\n      exportedAt: new Date().toISOString(),\n      presets: customPresets\n    };\n\n    return {\n      success: true,\n      data: JSON.stringify(exportData, null, 2),\n      count: customPresets.length\n    };\n  } catch (e) {\n    return { success: false, error: 'Failed to export presets: ' + e.message };\n  }\n}\n\n/**\n * Import presets from JSON string\n * @param {string} jsonString - JSON string containing presets\n * @param {boolean} merge - If true, merge with existing; if false, skip duplicates\n * @returns {{success: boolean, imported?: number, skipped?: number, error?: string}}\n */\nfunction importPresets(jsonString, merge = true) {\n  try {\n    // Parse JSON\n    const imported = JSON.parse(jsonString);\n\n    // Validate structure\n    if (!imported || !imported.presets || !Array.isArray(imported.presets)) {\n      return { success: false, error: 'Invalid preset file format' };\n    }\n\n    let importedCount = 0;\n    let skippedCount = 0;\n\n    for (const preset of imported.presets) {\n      // Validate each preset has required fields\n      if (!preset.name || typeof preset.name !== 'string') {\n        skippedCount++;\n        continue;\n      }\n\n      // Check if a preset with this name already exists\n      const existingId = slugifyPresetName(preset.name);\n      const existing = getCustomPreset(existingId);\n\n      if (existing && !merge) {\n        // Skip existing if not merging\n        skippedCount++;\n        continue;\n      }\n\n      // If existing and merge mode, create with unique name\n      if (existing && merge) {\n        let newName = `${preset.name} (Imported)`;\n        let counter = 1;\n        while (getCustomPreset(slugifyPresetName(newName))) {\n          counter++;\n          newName = `${preset.name} (Imported ${counter})`;\n        }\n        preset.name = newName;\n      }\n\n      // Create the preset\n      const result = createCustomPreset({\n        name: preset.name,\n        description: preset.description || '',\n        icon: preset.icon || 'settings',\n        settings: preset.settings || getCurrentPresetSettings()\n      });\n\n      if (result.success) {\n        importedCount++;\n      } else {\n        skippedCount++;\n      }\n    }\n\n    if (importedCount === 0 && skippedCount > 0) {\n      return { success: false, error: 'All presets already exist or were invalid', skipped: skippedCount };\n    }\n\n    return {\n      success: true,\n      imported: importedCount,\n      skipped: skippedCount\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      return { success: false, error: 'Invalid JSON format' };\n    }\n    return { success: false, error: 'Failed to import presets: ' + e.message };\n  }\n}\n\n/**\n * Delete a custom preset\n * @param {string} id - Preset ID to delete\n * @returns {{success: boolean, error?: string}}\n */\nfunction deleteCustomPreset(id) {\n  // Validate input\n  if (!id || typeof id !== 'string') {\n    return { success: false, error: 'Preset ID is required' };\n  }\n\n  // Load current data\n  const data = loadCustomPresets();\n\n  // Check if preset exists\n  if (!data.presets[id]) {\n    return { success: false, error: 'Preset not found' };\n  }\n\n  const presetName = data.presets[id].name;\n\n  // Remove from presets object\n  delete data.presets[id];\n\n  // Remove from order array\n  const orderIndex = data.order.indexOf(id);\n  if (orderIndex !== -1) {\n    data.order.splice(orderIndex, 1);\n  }\n\n  // Save\n  const saved = saveCustomPresets(data);\n  if (!saved) {\n    return { success: false, error: 'Failed to save after deletion' };\n  }\n\n  console.log(`[SPLICE] Deleted custom preset: ${presetName} (${id})`);\n  return { success: true };\n}\n\n/**\n * List of built-in preset IDs (cannot be modified or deleted)\n */\nconst BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n\n/**\n * Check if a preset is a built-in preset\n * @param {string} id - Preset ID to check\n * @returns {boolean} True if built-in, false if custom\n */\nfunction isBuiltInPreset(id) {\n  return BUILT_IN_PRESET_IDS.includes(id);\n}\n\n/**\n * Get all presets (built-in + custom merged)\n * Built-in presets appear first, then custom presets in their creation order.\n * Each preset has isBuiltIn flag added.\n *\n * @returns {Array<Object>} Array of preset objects with metadata\n */\nfunction getAllPresets() {\n  // Get built-in presets\n  const builtInPresets = BUILT_IN_PRESET_IDS.map(id => {\n    const preset = PRESETS[id];\n    return {\n      id,\n      name: preset.name,\n      description: preset.description,\n      icon: preset.icon,\n      settings: preset.settings,\n      isBuiltIn: true\n    };\n  });\n\n  // Get custom presets\n  const customData = loadCustomPresets();\n  const customPresets = customData.order.map(id => {\n    const preset = customData.presets[id];\n    if (!preset) return null;\n    return {\n      ...preset,\n      isBuiltIn: false\n    };\n  }).filter(Boolean);\n\n  // Merge: built-in first, then custom\n  return [...builtInPresets, ...customPresets];\n}\n\n/**\n * Get all preset IDs (built-in + custom)\n * @returns {Array<string>} Array of preset IDs\n */\nfunction getAllPresetIds() {\n  const customData = loadCustomPresets();\n  return [...BUILT_IN_PRESET_IDS, ...customData.order];\n}\n\n/**\n * Get a preset by ID (built-in or custom)\n * @param {string} id - Preset ID\n * @returns {Object|null} Preset object or null if not found\n */\nfunction getPresetById(id) {\n  if (!id || typeof id !== 'string') {\n    return null;\n  }\n\n  // Check built-in first\n  if (isBuiltInPreset(id)) {\n    const preset = PRESETS[id];\n    return {\n      id,\n      name: preset.name,\n      description: preset.description,\n      icon: preset.icon,\n      settings: preset.settings,\n      isBuiltIn: true\n    };\n  }\n\n  // Check custom presets\n  const custom = getCustomPreset(id);\n  if (custom) {\n    return {\n      ...custom,\n      isBuiltIn: false\n    };\n  }\n\n  return null;\n}\n\nconst DEFAULT_SETTINGS = {\n  sensitivity: 50,\n  audioSource: 'original',\n  autoMarkBest: true,\n  enableTakesDetection: true,\n  rememberOptions: false,\n  optionsExpanded: false,\n  customerId: null,          // Stripe customer ID for billing\n  mediaFolderToken: null,    // Persistent token for media folder access\n  mediaFolderPath: null,     // Path to the media folder (for display)\n  activePreset: 'custom'     // Currently active preset\n};\n\n// =============================================================================\n// PRESET PROFILES\n// =============================================================================\n\n/**\n * Detection presets for different content types.\n * Each preset defines optimal settings for a specific use case.\n */\nconst PRESETS = {\n  // Custom - user-defined settings (default)\n  custom: {\n    name: 'Custom',\n    description: 'Your custom settings',\n    icon: 'settings',\n    settings: null // Uses current user settings\n  },\n\n  // Podcast - longer pauses are natural, be conservative\n  podcast: {\n    name: 'Podcast',\n    description: 'Longer natural pauses, conversational flow',\n    icon: 'mic',\n    settings: {\n      sensitivity: 35,           // Lower sensitivity (fewer cuts)\n      threshold: -35,            // Higher threshold (only deep silence)\n      minSilenceLength: 0.8,     // Longer minimum silence\n      paddingStart: 0.15,        // More padding for natural transitions\n      paddingEnd: 0.15,\n      mergeDistance: 0.3,        // Merge nearby silences\n      autoMarkBest: false,       // Don't auto-mark (manual review)\n      enableTakesDetection: true\n    }\n  },\n\n  // Interview - balanced, respects speaker pauses\n  interview: {\n    name: 'Interview',\n    description: 'Balanced cuts, preserves Q&A rhythm',\n    icon: 'people',\n    settings: {\n      sensitivity: 50,           // Medium sensitivity\n      threshold: -32,            // Moderate threshold\n      minSilenceLength: 0.5,     // Standard minimum silence\n      paddingStart: 0.12,        // Moderate padding\n      paddingEnd: 0.08,\n      mergeDistance: 0.2,\n      autoMarkBest: true,\n      enableTakesDetection: true\n    }\n  },\n\n  // Reaction video - fast pacing, quick cuts\n  reaction: {\n    name: 'Reaction',\n    description: 'Fast-paced, tight cuts for energy',\n    icon: 'bolt',\n    settings: {\n      sensitivity: 70,           // Higher sensitivity (more cuts)\n      threshold: -28,            // Lower threshold (catches more silence)\n      minSilenceLength: 0.3,     // Short minimum silence\n      paddingStart: 0.05,        // Minimal padding for snappy edits\n      paddingEnd: 0.03,\n      mergeDistance: 0.15,\n      autoMarkBest: true,\n      enableTakesDetection: false // Usually single-take content\n    }\n  },\n\n  // Tutorial/Educational - preserve thinking pauses\n  tutorial: {\n    name: 'Tutorial',\n    description: 'Preserves teaching pace, minimal cuts',\n    icon: 'school',\n    settings: {\n      sensitivity: 30,           // Low sensitivity\n      threshold: -38,            // Only deep silence\n      minSilenceLength: 1.0,     // Long minimum (preserve demo pauses)\n      paddingStart: 0.2,         // Extra padding for clarity\n      paddingEnd: 0.15,\n      mergeDistance: 0.4,\n      autoMarkBest: false,\n      enableTakesDetection: true\n    }\n  },\n\n  // Vlog/YouTube - punchy edits, engagement-focused\n  vlog: {\n    name: 'Vlog',\n    description: 'Punchy edits for YouTube engagement',\n    icon: 'videocam',\n    settings: {\n      sensitivity: 65,           // Higher sensitivity\n      threshold: -30,            // Moderate-low threshold\n      minSilenceLength: 0.35,    // Short silences\n      paddingStart: 0.08,        // Quick transitions\n      paddingEnd: 0.05,\n      mergeDistance: 0.2,\n      autoMarkBest: true,\n      enableTakesDetection: true\n    }\n  }\n};\n\n/**\n * Get all available presets\n * @returns {Object} All preset definitions\n */\nfunction getPresets() {\n  return { ...PRESETS };\n}\n\n/**\n * Get a specific preset by name\n * @param {string} presetName - Name of the preset\n * @returns {Object|null} Preset definition or null if not found\n */\nfunction getPreset(presetName) {\n  return PRESETS[presetName] || null;\n}\n\n/**\n * Get preset names as array (for UI)\n * @returns {Array<string>} Array of preset names\n */\nfunction getPresetNames() {\n  return Object.keys(PRESETS);\n}\n\n/**\n * Apply a preset to current settings\n * @param {string} presetName - Name of the preset to apply\n * @returns {Object} The applied settings\n */\nfunction applyPreset(presetName) {\n  const preset = PRESETS[presetName];\n\n  if (!preset) {\n    console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n    return getSettings();\n  }\n\n  // Custom preset uses current settings\n  if (presetName === 'custom' || !preset.settings) {\n    saveSettings({ activePreset: 'custom' });\n    return getSettings();\n  }\n\n  // Apply preset settings\n  const newSettings = {\n    ...preset.settings,\n    activePreset: presetName\n  };\n\n  saveSettings(newSettings);\n  console.log(`[SPLICE] Applied preset: ${preset.name}`);\n\n  return getSettings();\n}\n\n/**\n * Get the currently active preset\n * @returns {string} Active preset name\n */\nfunction getActivePreset() {\n  const settings = getSettings();\n  return settings.activePreset || 'custom';\n}\n\n/**\n * Check if current settings match a preset\n * @param {string} presetName - Preset to compare against\n * @returns {boolean} True if settings match the preset\n */\nfunction settingsMatchPreset(presetName) {\n  const preset = PRESETS[presetName];\n  if (!preset || !preset.settings) return presetName === 'custom';\n\n  const current = getSettings();\n\n  // Compare relevant settings\n  return Object.keys(preset.settings).every(key => {\n    if (key === 'activePreset') return true;\n    return current[key] === preset.settings[key];\n  });\n}\n\nlet currentSettings = { ...DEFAULT_SETTINGS };\n\n/**\n * Load settings from localStorage\n */\nfunction loadSettings() {\n  try {\n    const saved = localStorage.getItem('spliceSettings');\n    if (saved) {\n      currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };\n    }\n  } catch (e) {\n    console.warn('[SPLICE] Could not load settings:', e);\n    currentSettings = { ...DEFAULT_SETTINGS };\n  }\n  return currentSettings;\n}\n\n/**\n * Save settings to localStorage\n */\nfunction saveSettings(settings) {\n  try {\n    currentSettings = { ...currentSettings, ...settings };\n    localStorage.setItem('spliceSettings', JSON.stringify(currentSettings));\n  } catch (e) {\n    console.warn('[SPLICE] Could not save settings:', e);\n  }\n}\n\n/**\n * Get current settings\n */\nfunction getSettings() {\n  return { ...currentSettings };\n}\n\n/**\n * Reset settings to defaults\n */\nfunction resetSettings() {\n  currentSettings = { ...DEFAULT_SETTINGS };\n  try {\n    localStorage.removeItem('spliceSettings');\n  } catch (e) {\n    console.warn('[SPLICE] Could not clear settings:', e);\n  }\n}\n\n/**\n * Initialize settings UI components\n */\nfunction initSettingsUI() {\n  const settings = loadSettings();\n\n  // Apply saved sensitivity to slider\n  const sensitivitySlider = document.getElementById('sensitivitySlider');\n  if (sensitivitySlider) {\n    sensitivitySlider.value = settings.sensitivity;\n  }\n\n  // Apply saved audio source\n  const sourceOriginal = document.getElementById('sourceOriginal');\n  const sourceIsolated = document.getElementById('sourceIsolated');\n  if (sourceOriginal && sourceIsolated) {\n    sourceOriginal.checked = settings.audioSource === 'original' || settings.audioSource === 'both';\n    sourceIsolated.checked = settings.audioSource === 'isolated' || settings.audioSource === 'both';\n  }\n\n  // Apply auto-mark best setting\n  const autoMarkBest = document.getElementById('autoMarkBest');\n  if (autoMarkBest) {\n    autoMarkBest.checked = settings.autoMarkBest;\n  }\n\n  // Apply takes detection setting\n  const enableTakesDetection = document.getElementById('enableTakesDetection');\n  if (enableTakesDetection) {\n    enableTakesDetection.checked = settings.enableTakesDetection;\n  }\n\n  // Apply remember options setting\n  const rememberOptions = document.getElementById('rememberOptions');\n  if (rememberOptions) {\n    rememberOptions.checked = settings.rememberOptions;\n  }\n\n  // Restore expanded state if remember is enabled\n  if (settings.rememberOptions && settings.optionsExpanded) {\n    toggleOptionsPanel(true);\n  }\n}\n\n/**\n * Toggle options panel visibility (unified panel)\n */\nfunction toggleOptionsPanel(forceState) {\n  const toggle = document.getElementById('optionsToggle');\n  const panel = document.getElementById('optionsPanel');\n\n  if (!toggle || !panel) return;\n\n  const shouldExpand = forceState !== undefined ? forceState : panel.classList.contains('collapsed');\n\n  if (shouldExpand) {\n    panel.classList.remove('collapsed');\n    toggle.classList.add('expanded');\n  } else {\n    panel.classList.add('collapsed');\n    toggle.classList.remove('expanded');\n  }\n\n  // Save state if remember is enabled\n  const settings = getSettings();\n  if (settings.rememberOptions) {\n    saveSettings({ optionsExpanded: shouldExpand });\n  }\n}\n\n/**\n * Initialize settings modal\n */\nfunction initSettingsModal() {\n  const settingsBtn = document.getElementById('settingsBtn');\n  const modal = document.getElementById('settingsModal');\n  const closeBtn = document.getElementById('closeSettingsBtn');\n  const defaultSensitivity = document.getElementById('defaultSensitivity');\n  const rememberOptions = document.getElementById('rememberOptions');\n\n  if (settingsBtn && modal) {\n    settingsBtn.addEventListener('click', () => {\n      modal.classList.remove('hidden');\n      // Sync modal values with current settings\n      const settings = getSettings();\n      if (defaultSensitivity) defaultSensitivity.value = settings.sensitivity;\n      if (rememberOptions) rememberOptions.checked = settings.rememberOptions;\n    });\n  }\n\n  if (closeBtn && modal) {\n    closeBtn.addEventListener('click', () => {\n      modal.classList.add('hidden');\n    });\n  }\n\n  // Close on backdrop click\n  if (modal) {\n    modal.addEventListener('click', (e) => {\n      if (e.target === modal) {\n        modal.classList.add('hidden');\n      }\n    });\n  }\n\n  // Save default sensitivity when changed\n  if (defaultSensitivity) {\n    defaultSensitivity.addEventListener('change', () => {\n      saveSettings({ sensitivity: parseInt(defaultSensitivity.value) });\n      // Also update the main slider\n      const mainSlider = document.getElementById('sensitivitySlider');\n      if (mainSlider) mainSlider.value = defaultSensitivity.value;\n    });\n  }\n\n  // Save remember options when changed\n  if (rememberOptions) {\n    rememberOptions.addEventListener('change', () => {\n      saveSettings({ rememberOptions: rememberOptions.checked });\n    });\n  }\n}\n\n/**\n * Initialize options toggle (unified panel)\n */\nfunction initOptionsToggles() {\n  const toggle = document.getElementById('optionsToggle');\n\n  if (toggle) {\n    toggle.addEventListener('click', () => toggleOptionsPanel());\n  }\n}\n\n/**\n * Initialize preset selector\n */\nfunction initPresetSelector() {\n  const presetSelector = document.getElementById('presetSelector');\n  const sensitivitySlider = document.getElementById('sensitivitySlider');\n\n  if (!presetSelector) return;\n\n  // Set initial value from settings\n  const settings = getSettings();\n  presetSelector.value = settings.activePreset || 'custom';\n\n  // Handle preset change (supports both built-in and custom presets)\n  presetSelector.addEventListener('change', () => {\n    const presetId = presetSelector.value;\n\n    // Get preset info (works for both built-in and custom)\n    const preset = getPresetById(presetId);\n    if (!preset) {\n      console.warn(`[SPLICE] Preset not found: ${presetId}`);\n      return;\n    }\n\n    let appliedSettings;\n\n    if (preset.isBuiltIn) {\n      // Built-in preset: use the existing applyPreset function\n      appliedSettings = applyPreset(presetId);\n    } else {\n      // Custom preset: apply stored settings\n      appliedSettings = preset.settings || {};\n      saveSettings({ activePreset: presetId, ...appliedSettings });\n    }\n\n    // Update sensitivity slider to match preset\n    if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n      sensitivitySlider.value = appliedSettings.sensitivity;\n    }\n\n    // Update takes detection checkbox\n    const enableTakesDetection = document.getElementById('enableTakesDetection');\n    if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n      enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n    }\n\n    // Update auto-mark best checkbox\n    const autoMarkBest = document.getElementById('autoMarkBest');\n    if (autoMarkBest && appliedSettings.autoMarkBest !== undefined) {\n      autoMarkBest.checked = appliedSettings.autoMarkBest;\n    }\n\n    if (typeof setStatus === 'function') {\n      const desc = preset.description ? ` - ${preset.description}` : '';\n      setStatus(`Preset: ${preset.name}${desc}`);\n    }\n  });\n\n  // Switch to custom when user manually changes sensitivity\n  if (sensitivitySlider) {\n    sensitivitySlider.addEventListener('change', () => {\n      if (presetSelector.value !== 'custom') {\n        presetSelector.value = 'custom';\n        saveSettings({ activePreset: 'custom' });\n      }\n    });\n  }\n}\n\n/**\n * Initialize help button\n */\nfunction initHelpButton() {\n  const helpBtn = document.getElementById('helpBtn');\n  if (helpBtn) {\n    helpBtn.addEventListener('click', () => {\n      setStatus('Silence: removes quiet gaps | Takes: detects repeated content');\n    });\n  }\n}\n\n// =============================================================================\n// PERSISTENT TOKEN MANAGEMENT (v3.5)\n// =============================================================================\n\n/**\n * Media folder entry (cached after selection)\n * @type {Object|null}\n */\nlet mediaFolderEntry = null;\n\n/**\n * Prompt user to select a media folder and create a persistent token.\n * This allows silent file access without repeated permission prompts.\n *\n * @returns {Promise<{success: boolean, path?: string, error?: string}>}\n */\nasync function setupMediaFolder() {\n  try {\n    // Open folder picker dialog\n    const folder = await uxpFs.getFolder();\n\n    if (!folder) {\n      return { success: false, error: 'No folder selected' };\n    }\n\n    // Create a persistent token for this folder\n    const token = await uxpFs.createPersistentToken(folder);\n\n    if (!token) {\n      return { success: false, error: 'Failed to create persistent token' };\n    }\n\n    // Get the folder path for display\n    const folderPath = folder.nativePath || folder.name;\n\n    // Save to settings\n    saveSettings({\n      mediaFolderToken: token,\n      mediaFolderPath: folderPath\n    });\n\n    // Cache the folder entry\n    mediaFolderEntry = folder;\n\n    console.log(`[SPLICE] Media folder set: ${folderPath}`);\n\n    return {\n      success: true,\n      path: folderPath,\n      token\n    };\n  } catch (err) {\n    console.error('[SPLICE] Error setting up media folder:', err);\n    return { success: false, error: err.message };\n  }\n}\n\n/**\n * Get the media folder entry using the stored persistent token.\n * Falls back to prompting if token is invalid.\n *\n * @returns {Promise<Object|null>} The folder entry or null\n */\nasync function getMediaFolder() {\n  // Return cached entry if available\n  if (mediaFolderEntry) {\n    return mediaFolderEntry;\n  }\n\n  const settings = getSettings();\n\n  // Try to restore from persistent token\n  if (settings.mediaFolderToken) {\n    try {\n      const folder = await uxpFs.getEntryForPersistentToken(settings.mediaFolderToken);\n      if (folder) {\n        mediaFolderEntry = folder;\n        console.log(`[SPLICE] Restored media folder from token: ${settings.mediaFolderPath}`);\n        return folder;\n      }\n    } catch (err) {\n      console.warn('[SPLICE] Could not restore media folder from token:', err.message);\n      // Clear invalid token\n      saveSettings({ mediaFolderToken: null, mediaFolderPath: null });\n    }\n  }\n\n  return null;\n}\n\n/**\n * Check if a media folder is configured\n * @returns {boolean}\n */\nfunction hasMediaFolder() {\n  const settings = getSettings();\n  return !!settings.mediaFolderToken;\n}\n\n/**\n * Get the configured media folder path (for display)\n * @returns {string|null}\n */\nfunction getMediaFolderPath() {\n  const settings = getSettings();\n  return settings.mediaFolderPath;\n}\n\n/**\n * Clear the media folder configuration\n */\nfunction clearMediaFolder() {\n  mediaFolderEntry = null;\n  saveSettings({\n    mediaFolderToken: null,\n    mediaFolderPath: null\n  });\n  console.log('[SPLICE] Media folder cleared');\n}\n\n/**\n * Read a file from the media folder\n * @param {string} filename - Name of the file to read\n * @returns {Promise<ArrayBuffer|null>} File contents or null\n */\nasync function readMediaFile(filename) {\n  const folder = await getMediaFolder();\n  if (!folder) {\n    console.warn('[SPLICE] No media folder configured');\n    return null;\n  }\n\n  try {\n    const file = await folder.getEntry(filename);\n    if (!file) {\n      console.warn(`[SPLICE] File not found in media folder: ${filename}`);\n      return null;\n    }\n\n    const contents = await file.read({ format: uxpFs.formats.binary });\n    return contents;\n  } catch (err) {\n    console.error(`[SPLICE] Error reading file ${filename}:`, err);\n    return null;\n  }\n}\n\n// =============================================================================\n// LOGIN MODAL\n// =============================================================================\n\n/**\n * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n * @param {string} key - License key to validate\n * @returns {boolean} True if format is valid\n */\nfunction isValidLicenseKeyFormat(key) {\n  if (!key || typeof key !== 'string') return false;\n  const normalized = key.toUpperCase().trim();\n  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;\n  return pattern.test(normalized);\n}\n\n/**\n * Initialize login modal handlers\n */\nfunction initLoginModal() {\n  const loginModal = document.getElementById('loginModal');\n  const closeLoginBtn = document.getElementById('closeLoginBtn');\n  const saveLoginBtn = document.getElementById('saveLoginBtn');\n  const licenseKeyInput = document.getElementById('licenseKeyInput');\n  const loginError = document.getElementById('loginError');\n  const creditBadge = document.getElementById('creditBadge');\n\n  // Show login modal when clicking credit badge (always - allows viewing/changing license)\n  if (creditBadge) {\n    creditBadge.addEventListener('click', () => {\n      showLoginModal();\n    });\n  }\n\n  // Close login modal\n  if (closeLoginBtn && loginModal) {\n    closeLoginBtn.addEventListener('click', () => {\n      loginModal.classList.add('hidden');\n    });\n  }\n\n  // Close on backdrop click\n  if (loginModal) {\n    loginModal.addEventListener('click', (e) => {\n      if (e.target === loginModal) {\n        loginModal.classList.add('hidden');\n      }\n    });\n  }\n\n  // Activate license key\n  if (saveLoginBtn) {\n    saveLoginBtn.addEventListener('click', async () => {\n      const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n\n      if (!licenseKey) {\n        showLoginError('Please enter your license key');\n        return;\n      }\n\n      if (!isValidLicenseKeyFormat(licenseKey)) {\n        showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n        return;\n      }\n\n      // Show loading state\n      saveLoginBtn.disabled = true;\n      saveLoginBtn.textContent = 'Activating...';\n\n      try {\n        // Call license activation API (use BACKEND_URL from config.js)\n        const baseUrl = typeof BACKEND_URL !== 'undefined' ? BACKEND_URL : 'https://127.0.0.1:3847';\n        const response = await fetch(`${baseUrl}/license/activate`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ key: licenseKey })\n        });\n\n        const result = await response.json();\n\n        if (!result.success) {\n          showLoginError(result.error || 'Activation failed');\n          return;\n        }\n\n        // Save customer ID from activation response\n        saveSettings({ customerId: result.customerId });\n\n        // Hide modal\n        loginModal?.classList.add('hidden');\n\n        // Refresh credits display\n        if (typeof refreshCredits === 'function') {\n          await refreshCredits();\n        }\n\n        if (typeof setStatus === 'function') {\n          setStatus(`License activated! ${result.tierName} tier - ${result.hoursRemaining.toFixed(1)}h remaining`);\n        }\n      } catch (err) {\n        console.error('[SPLICE] License activation error:', err);\n        showLoginError('Connection error. Check server is running.');\n      } finally {\n        saveLoginBtn.disabled = false;\n        saveLoginBtn.textContent = 'Activate';\n      }\n    });\n  }\n\n  // Clear input on modal open (don't show old value for security)\n  // Customer ID is stored but license key is not displayed\n}\n\n/**\n * Show login modal\n */\nfunction showLoginModal() {\n  const loginModal = document.getElementById('loginModal');\n  const loginError = document.getElementById('loginError');\n\n  if (loginError) {\n    loginError.style.display = 'none';\n  }\n\n  if (loginModal) {\n    loginModal.classList.remove('hidden');\n  }\n}\n\n/**\n * Show login error message\n */\nfunction showLoginError(message) {\n  const loginError = document.getElementById('loginError');\n  if (loginError) {\n    loginError.textContent = message;\n    loginError.style.display = 'block';\n  }\n}\n\n/**\n * Check if user is logged in\n * @returns {boolean}\n */\nfunction isLoggedIn() {\n  const settings = getSettings();\n  return !!settings.customerId;\n}\n\n/**\n * Get customer ID\n * @returns {string|null}\n */\nfunction getCustomerId() {\n  const settings = getSettings();\n  return settings.customerId || null;\n}\n\n/**\n * Logout - clear customer ID\n */\nfunction logout() {\n  saveSettings({ customerId: null });\n  if (typeof setStatus === 'function') {\n    setStatus('Logged out');\n  }\n}\n\n// Load settings on script load\nloadSettings();\n","numLines":1343,"startLine":1,"totalLines":1343}}}
{"parentUuid":"03f1e522-4831-425b-b6e1-f70e640591ac","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019siiEcsCMPyECebreJmkyC","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Plugin Main Entry Point\n     3→ *\n     4→ * Initializes all functionality when the plugin loads.\n     5→ * v3.4 - Timeline Markers + Unified Take-Aware Workflow.\n     6→ */\n     7→\n     8→// Initialize Premiere Pro API\n     9→const ppro = require('premierepro');\n    10→\n    11→// ============================================================================\n    12→// CACHED DOM ELEMENTS (Performance: avoid repeated getElementById calls)\n    13→// ============================================================================\n    14→const ui = {};\n    15→\n    16→function cacheUIElements() {\n    17→  ui.status = document.getElementById('status');\n    18→\n    19→  // Main GO button (unified workflow)\n    20→  ui.goBtn = document.getElementById('goBtn');\n    21→  ui.optionsToggle = document.getElementById('optionsToggle');\n    22→  ui.optionsPanel = document.getElementById('optionsPanel');\n    23→\n    24→  // Sliders and options\n    25→  ui.sensitivitySlider = document.getElementById('sensitivitySlider');\n    26→  ui.sourceOriginal = document.getElementById('sourceOriginal');\n    27→  ui.sourceIsolated = document.getElementById('sourceIsolated');\n    28→\n    29→  // Settings checkboxes\n    30→  ui.enableTakesDetection = document.getElementById('enableTakesDetection');\n    31→  ui.autoMarkBest = document.getElementById('autoMarkBest');\n    32→\n    33→  // Progress\n    34→  ui.progressContainer = document.getElementById('progressContainer');\n    35→  ui.progressText = document.getElementById('progressText');\n    36→  ui.resultsEmpty = document.getElementById('resultsEmpty');\n    37→\n    38→  // Combined Preview\n    39→  ui.combinedPreview = document.getElementById('combinedPreview');\n    40→  ui.previewList = document.getElementById('previewList');\n    41→  ui.silenceCountDisplay = document.getElementById('silenceCount');\n    42→  ui.takeCountDisplay = document.getElementById('takeCount');\n    43→  ui.selectedCount = document.getElementById('selectedCount');\n    44→  ui.selectAllSilences = document.getElementById('selectAllSilences');\n    45→  ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');\n    46→  ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');\n    47→  ui.invertSelectionBtn = document.getElementById('invertSelectionBtn');\n    48→  ui.reRunDetectionBtn = document.getElementById('reRunDetectionBtn');\n    49→\n    50→  // Results\n    51→  ui.silenceResults = document.getElementById('silenceResults');\n    52→  ui.resultsCount = document.getElementById('resultsCount');\n    53→  ui.timeSaved = document.getElementById('timeSaved');\n    54→  ui.clipsModified = document.getElementById('clipsModified');\n    55→\n    56→  // Build Sequence button (v3.5)\n    57→  ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');\n    58→\n    59→  // Buttons\n    60→  ui.undoBtn = document.getElementById('undoBtn');\n    61→  ui.advancedSection = document.getElementById('advancedSection');\n    62→\n    63→  // Settings modal\n    64→  ui.settingsBtn = document.getElementById('settingsBtn');\n    65→  ui.settingsModal = document.getElementById('settingsModal');\n    66→  ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');\n    67→\n    68→  // Media folder (v3.5)\n    69→  ui.mediaFolderDisplay = document.getElementById('mediaFolderDisplay');\n    70→  ui.setMediaFolderBtn = document.getElementById('setMediaFolderBtn');\n    71→  ui.clearMediaFolderBtn = document.getElementById('clearMediaFolderBtn');\n    72→\n    73→  // Custom Presets (v3.5)\n    74→  ui.savePresetBtn = document.getElementById('savePresetBtn');\n    75→  ui.managePresetsBtn = document.getElementById('managePresetsBtn');\n    76→  ui.presetModal = document.getElementById('presetModal');\n    77→  ui.presetModalTitle = document.getElementById('presetModalTitle');\n    78→  ui.closePresetModalBtn = document.getElementById('closePresetModalBtn');\n    79→  ui.presetNameInput = document.getElementById('presetNameInput');\n    80→  ui.presetDescInput = document.getElementById('presetDescInput');\n    81→  ui.presetIconPicker = document.getElementById('presetIconPicker');\n    82→  ui.presetEditId = document.getElementById('presetEditId');\n    83→  ui.presetSelectedIcon = document.getElementById('presetSelectedIcon');\n    84→  ui.savePresetConfirmBtn = document.getElementById('savePresetConfirmBtn');\n    85→  ui.presetModalError = document.getElementById('presetModalError');\n    86→  ui.managePresetsModal = document.getElementById('managePresetsModal');\n    87→  ui.closeManagePresetsBtn = document.getElementById('closeManagePresetsBtn');\n    88→  ui.presetsList = document.getElementById('presetsList');\n    89→  ui.noCustomPresets = document.getElementById('noCustomPresets');\n    90→  ui.presetSelector = document.getElementById('presetSelector');\n    91→\n    92→  // Preset settings inputs (Phase 3)\n    93→  ui.presetSensitivity = document.getElementById('presetSensitivity');\n    94→  ui.presetSensitivityValue = document.getElementById('presetSensitivityValue');\n    95→  ui.presetThreshold = document.getElementById('presetThreshold');\n    96→\n    97→  // Export/Import buttons (Phase 3)\n    98→  ui.exportPresetsBtn = document.getElementById('exportPresetsBtn');\n    99→  ui.importPresetsBtn = document.getElementById('importPresetsBtn');\n   100→  ui.importPresetsFile = document.getElementById('importPresetsFile');\n   101→}\n   102→\n   103→// ============================================================================\n   104→// STATE MANAGEMENT\n   105→// ============================================================================\n   106→let previewSilences = [];         // All detected silences\n   107→let safeSilences = [];            // Silences that don't overlap takes (safe to remove)\n   108→let protectedSilences = [];       // Silences that overlap takes (protected)\n   109→let previewTakes = [];            // Detected takes (for display)\n   110→let selectedSilenceIndices = new Set();\n   111→let isOperationInProgress = false;\n   112→let pendingUIUpdate = null;\n   113→\n   114→// Export preview state for other modules (Razor integration)\n   115→window.splicePreviewState = {\n   116→  getSelectedSilences: () => safeSilences.filter((_, i) => selectedSilenceIndices.has(i)),\n   117→  getSelectedTakes: () => previewTakes,\n   118→  hasPreview: () => safeSilences.length > 0 || previewTakes.length > 0\n   119→};\n   120→\n   121→// ============================================================================\n   122→// INITIALIZATION\n   123→// ============================================================================\n   124→document.addEventListener('DOMContentLoaded', () => {\n   125→  // Cache all DOM elements first\n   126→  cacheUIElements();\n   127→\n   128→  // Settings & UI\n   129→  initSettingsUI();\n   130→  initSettingsModal();\n   131→  initLoginModal();\n   132→  initOptionsToggles();\n   133→  initPresetSelector();\n   134→  initHelpButton();\n   135→\n   136→  // Credits display\n   137→  initCredits();\n   138→\n   139→  // Unified workflow (silences + takes)\n   140→  initUnifiedWorkflow();\n   141→\n   142→  // Preview handlers (event delegation)\n   143→  initPreviewHandlers();\n   144→\n   145→  // Undo handlers\n   146→  initUndoHandlers();\n   147→\n   148→  // Keyboard shortcuts\n   149→  initKeyboardShortcuts();\n   150→\n   151→  // Advanced features (Razor - legacy)\n   152→  initSlice9();\n   153→\n   154→  // Batch processing\n   155→  initBatchHandlers();\n   156→\n   157→  // Media folder (v3.5)\n   158→  initMediaFolderHandlers();\n   159→\n   160→  // Custom Presets UI (v3.5)\n   161→  initCustomPresetsUI();\n   162→\n   163→  console.log('[SPLICE] Plugin initialized v3.5 (Direct DOM Reconstruction)');\n   164→});\n   165→\n   166→// ============================================================================\n   167→// DEBOUNCED UI UPDATES (Performance: batch DOM updates)\n   168→// ============================================================================\n   169→function scheduleUIUpdate(callback) {\n   170→  if (pendingUIUpdate) {\n   171→    cancelAnimationFrame(pendingUIUpdate);\n   172→  }\n   173→  pendingUIUpdate = requestAnimationFrame(() => {\n   174→    callback();\n   175→    pendingUIUpdate = null;\n   176→  });\n   177→}\n   178→\n   179→function updateSelectionCounts() {\n   180→  scheduleUIUpdate(() => {\n   181→    if (ui.selectedCount) {\n   182→      ui.selectedCount.textContent = selectedSilenceIndices.size;\n   183→    }\n   184→    updateApplyButton();\n   185→    updateSelectAllCheckbox();\n   186→  });\n   187→}\n   188→\n   189→// ============================================================================\n   190→// KEYBOARD SHORTCUTS\n   191→// ============================================================================\n   192→function initKeyboardShortcuts() {\n   193→  document.addEventListener('keydown', (e) => {\n   194→    // Only handle when combined preview is visible\n   195→    const previewVisible = ui.combinedPreview?.style.display !== 'none' &&\n   196→                           ui.combinedPreview?.style.display !== '';\n   197→\n   198→    if (!previewVisible) return;\n   199→\n   200→    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;\n   201→    const cmdKey = isMac ? e.metaKey : e.ctrlKey;\n   202→\n   203→    // Enter - Apply selected\n   204→    if (e.key === 'Enter' && !e.shiftKey) {\n   205→      e.preventDefault();\n   206→      if (selectedSilenceIndices.size > 0) {\n   207→        ui.applyPreviewBtn?.click();\n   208→      }\n   209→    }\n   210→\n   211→    // Escape - Cancel\n   212→    if (e.key === 'Escape') {\n   213→      e.preventDefault();\n   214→      ui.cancelPreviewBtn?.click();\n   215→    }\n   216→\n   217→    // Cmd/Ctrl+A - Select all\n   218→    if (e.key === 'a' && cmdKey) {\n   219→      e.preventDefault();\n   220→      if (ui.selectAllSilences) {\n   221→        ui.selectAllSilences.checked = true;\n   222→        selectAllSilences(true);\n   223→      }\n   224→    }\n   225→\n   226→    // Cmd/Ctrl+D - Deselect all\n   227→    if (e.key === 'd' && cmdKey) {\n   228→      e.preventDefault();\n   229→      if (ui.selectAllSilences) {\n   230→        ui.selectAllSilences.checked = false;\n   231→        selectAllSilences(false);\n   232→      }\n   233→    }\n   234→\n   235→    // Cmd/Ctrl+I - Invert selection\n   236→    if (e.key === 'i' && cmdKey) {\n   237→      e.preventDefault();\n   238→      invertSilenceSelection();\n   239→    }\n   240→  });\n   241→}\n   242→\n   243→// ============================================================================\n   244→// UNIFIED WORKFLOW (Silence Detection + Takes Detection)\n   245→// ============================================================================\n   246→function initUnifiedWorkflow() {\n   247→  if (!ui.goBtn) return;\n   248→\n   249→  ui.goBtn.addEventListener('click', async () => {\n   250→    // Prevent double-click\n   251→    if (isOperationInProgress) {\n   252→      setStatus('Operation in progress...');\n   253→      return;\n   254→    }\n   255→\n   256→    isOperationInProgress = true;\n   257→    ui.goBtn.disabled = true;\n   258→\n   259→    try {\n   260→      showProgress('Preparing audio...');\n   261→\n   262→      // Step 1: Export audio\n   263→      const exportSuccess = await exportAudioInternal();\n   264→      if (!exportSuccess) {\n   265→        throw new Error('Audio export failed');\n   266→      }\n   267→\n   268→      // Step 2: Get settings\n   269→      const sensitivity = parseInt(ui.sensitivitySlider?.value || 50);\n   270→      const useIsolated = ui.sourceIsolated?.checked ?? false;\n   271→      const detectTakes = ui.enableTakesDetection?.checked ?? true;\n   272→\n   273→      // Step 3: Vocal isolation if needed\n   274→      let audioPath = WAV_PATH;\n   275→      if (useIsolated) {\n   276→        // Check isolation access before proceeding\n   277→        const credits = getCurrentCredits();\n   278→        if (!credits || !credits.hasIsolationAccess) {\n   279→          throw new Error('Vocal isolation requires Pro or Team tier. Upgrade to access this feature.');\n   280→        }\n   281→\n   282→        // Show overage warning if applicable\n   283→        const isolationMins = credits.isolationHoursRemaining * 60;\n   284→        if (isolationMins <= 0) {\n   285→          const overageRate = credits.isolationOverageRate || 0.08;\n   286→          showProgress(`Isolating vocals (overage: $${overageRate}/min)...`);\n   287→        } else {\n   288→          showProgress(`Isolating vocals (${isolationMins.toFixed(0)} min remaining)...`);\n   289→        }\n   290→\n   291→        const isolateResult = await isolateVocals();\n   292→        if (isolateResult.success) {\n   293→          audioPath = isolateResult.outputPath;\n   294→          // Update credits display after isolation\n   295→          await refreshCredits();\n   296→        } else {\n   297→          throw new Error(isolateResult.error || 'Vocal isolation failed');\n   298→        }\n   299→      }\n   300→\n   301→      // Step 4: Run detection (parallel if takes enabled)\n   302→      const params = mapSensitivity(sensitivity);\n   303→      let silences = [];\n   304→      let takes = [];\n   305→\n   306→      if (detectTakes) {\n   307→        // Parallel detection for performance\n   308→        showProgress('Detecting silences and analyzing takes...');\n   309→        const [silenceResult, transcriptResult] = await Promise.all([\n   310→          detectSilences(audioPath, params),\n   311→          transcribeAudio()\n   312→        ]);\n   313→\n   314→        silences = silenceResult;\n   315→\n   316→        // Extract takes from transcript result\n   317→        if (transcriptResult.success && transcriptResult.takes) {\n   318→          if (transcriptResult.takes.takes) {\n   319→            takes = transcriptResult.takes.takes;\n   320→          } else if (Array.isArray(transcriptResult.takes)) {\n   321→            takes = transcriptResult.takes;\n   322→          }\n   323→        }\n   324→\n   325→        // Store transcript for reference\n   326→        window.currentTranscript = transcriptResult.transcript;\n   327→      } else {\n   328→        // Just detect silences\n   329→        showProgress('Detecting silences...');\n   330→        silences = await detectSilences(audioPath, params);\n   331→      }\n   332→\n   333→      if (silences.length === 0) {\n   334→        showEmptyState();\n   335→        setStatus('No silences detected. Try increasing sensitivity.');\n   336→        return;\n   337→      }\n   338→\n   339→      // Step 5: Filter silences by takes (protect speech)\n   340→      const filtered = filterSilencesByTakes(silences, takes);\n   341→\n   342→      // Step 6: Add timeline markers (clear old ones first)\n   343→      showProgress('Adding timeline markers...');\n   344→      await clearSpliceMarkers();\n   345→      const markerResult = await addTimelineMarkers(filtered.safe, filtered.protected, takes);\n   346→\n   347→      // Step 7: Show combined preview\n   348→      showCombinedPreview(filtered.safe, filtered.protected, takes);\n   349→\n   350→      const markerInfo = markerResult.added > 0 ? ` (${markerResult.added} markers added)` : '';\n   351→      const statusMsg = takes.length > 0\n   352→        ? `Found ${silences.length} silences, ${filtered.protected.length} protected by ${takes.length} takes${markerInfo}`\n   353→        : `Found ${silences.length} silence(s) - review and apply${markerInfo}`;\n   354→      setStatus(statusMsg);\n   355→\n   356→    } catch (err) {\n   357→      showEmptyState();\n   358→      setStatus('Error: ' + err.message);\n   359→      console.error('[SPLICE] Unified workflow error:', err);\n   360→    } finally {\n   361→      isOperationInProgress = false;\n   362→      ui.goBtn.disabled = false;\n   363→    }\n   364→  });\n   365→}\n   366→\n   367→// ============================================================================\n   368→// TAKE-AWARE SILENCE FILTERING\n   369→// ============================================================================\n   370→/**\n   371→ * Filter silences to protect those that overlap with takes (speech segments).\n   372→ * Returns { safe: [], protected: [] }\n   373→ */\n   374→function filterSilencesByTakes(silences, takes) {\n   375→  if (!takes || takes.length === 0) {\n   376→    // No takes = all silences are safe to remove\n   377→    return { safe: silences, protected: [] };\n   378→  }\n   379→\n   380→  const safe = [];\n   381→  const protected_ = [];\n   382→\n   383→  silences.forEach(silence => {\n   384→    // Check if this silence overlaps with any take\n   385→    const overlaps = takes.some(take => {\n   386→      const takeStart = take.startTime || take.start;\n   387→      const takeEnd = take.endTime || take.end;\n   388→      // Overlap exists if silence starts before take ends AND silence ends after take starts\n   389→      return silence.start < takeEnd && silence.end > takeStart;\n   390→    });\n   391→\n   392→    if (overlaps) {\n   393→      protected_.push(silence);\n   394→    } else {\n   395→      safe.push(silence);\n   396→    }\n   397→  });\n   398→\n   399→  console.log(`[SPLICE] Filtered silences: ${safe.length} safe, ${protected_.length} protected`);\n   400→  return { safe, protected: protected_ };\n   401→}\n   402→\n   403→// ============================================================================\n   404→// TIMELINE MARKERS (Visual indicators on Premiere Pro timeline)\n   405→// ============================================================================\n   406→/**\n   407→ * Add colored markers to the timeline for silences and takes.\n   408→ * - Red markers: silences safe to remove\n   409→ * - Yellow markers: silences protected by takes\n   410→ * - Blue markers: takes (speech segments)\n   411→ *\n   412→ * @param {Array} safeToRemove - Silences safe to remove\n   413→ * @param {Array} protectedSilences - Silences overlapping speech\n   414→ * @param {Array} takes - Detected speech segments\n   415→ * @returns {Promise<{added: number, errors: number}>}\n   416→ */\n   417→async function addTimelineMarkers(safeToRemove, protectedSilences, takes) {\n   418→  const results = { added: 0, errors: 0 };\n   419→\n   420→  try {\n   421→    const context = await getActiveSequence();\n   422→    if (!context) {\n   423→      console.warn('[SPLICE] No sequence available for markers');\n   424→      return results;\n   425→    }\n   426→\n   427→    const { sequence, project } = context;\n   428→\n   429→    // Get markers object for the sequence\n   430→    const markers = await ppro.Markers.getMarkers(sequence);\n   431→    if (!markers) {\n   432→      console.warn('[SPLICE] Markers API not available');\n   433→      return results;\n   434→    }\n   435→\n   436→    // Collect all marker actions\n   437→    const markerActions = [];\n   438→\n   439→    // Red markers for safe-to-remove silences\n   440→    for (const silence of safeToRemove) {\n   441→      try {\n   442→        const duration = silence.end - silence.start;\n   443→\n   444→        // Use TickTime API directly (no TICKS_PER_SECOND needed)\n   445→        const startTime = ppro.TickTime.createWithSeconds(silence.start);\n   446→        const durationTime = ppro.TickTime.createWithSeconds(duration);\n   447→\n   448→        const action = markers.createAddMarkerAction(\n   449→          `SPLICE: Remove (${duration.toFixed(2)}s)`,\n   450→          ppro.Marker.MARKER_TYPE_COMMENT,\n   451→          startTime,\n   452→          durationTime,\n   453→          `Silence to remove: ${formatTime(silence.start)} - ${formatTime(silence.end)}`\n   454→        );\n   455→        markerActions.push({ action, colorIndex: 1, type: 'silence' }); // Red = index 1\n   456→      } catch (err) {\n   457→        console.error('[SPLICE] Error creating silence marker:', err);\n   458→        results.errors++;\n   459→      }\n   460→    }\n   461→\n   462→    // Yellow markers for protected silences\n   463→    for (const silence of protectedSilences) {\n   464→      try {\n   465→        const duration = silence.end - silence.start;\n   466→\n   467→        // Use TickTime API directly (no TICKS_PER_SECOND needed)\n   468→        const startTime = ppro.TickTime.createWithSeconds(silence.start);\n   469→        const durationTime = ppro.TickTime.createWithSeconds(duration);\n   470→\n   471→        const action = markers.createAddMarkerAction(\n   472→          `SPLICE: Protected (${duration.toFixed(2)}s)`,\n   473→          ppro.Marker.MARKER_TYPE_COMMENT,\n   474→          startTime,\n   475→          durationTime,\n   476→          `Protected silence (overlaps speech): ${formatTime(silence.start)} - ${formatTime(silence.end)}`\n   477→        );\n   478→        markerActions.push({ action, colorIndex: 4, type: 'protected' }); // Yellow = index 4\n   479→      } catch (err) {\n   480→        console.error('[SPLICE] Error creating protected marker:', err);\n   481→        results.errors++;\n   482→      }\n   483→    }\n   484→\n   485→    // Blue markers for takes (speech segments)\n   486→    for (const take of takes) {\n   487→      try {\n   488→        const start = take.startTime || take.start;\n   489→        const end = take.endTime || take.end;\n   490→        const duration = end - start;\n   491→        const textPreview = take.text?.substring(0, 30) || 'Speech';\n   492→\n   493→        // Use TickTime API directly (no TICKS_PER_SECOND needed)\n   494→        const startTime = ppro.TickTime.createWithSeconds(start);\n   495→        const durationTime = ppro.TickTime.createWithSeconds(duration);\n   496→\n   497→        const action = markers.createAddMarkerAction(\n   498→          `SPLICE: Take`,\n   499→          ppro.Marker.MARKER_TYPE_COMMENT,\n   500→          startTime,\n   501→          durationTime,\n   502→          `Speech segment: ${textPreview}${take.text?.length > 30 ? '...' : ''}`\n   503→        );\n   504→        markerActions.push({ action, colorIndex: 5, type: 'take' }); // Blue = index 5\n   505→      } catch (err) {\n   506→        console.error('[SPLICE] Error creating take marker:', err);\n   507→        results.errors++;\n   508→      }\n   509→    }\n   510→\n   511→    // Execute all marker actions in a single transaction\n   512→    if (markerActions.length > 0) {\n   513→      await project.lockedAccess(async () => {\n   514→        await project.executeTransaction((compoundAction) => {\n   515→          for (const { action } of markerActions) {\n   516→            compoundAction.addAction(action);\n   517→          }\n   518→        }, 'SPLICE: Add Timeline Markers');\n   519→      });\n   520→\n   521→      results.added = markerActions.length;\n   522→      console.log(`[SPLICE] Added ${results.added} timeline markers`);\n   523→    }\n   524→\n   525→  } catch (err) {\n   526→    console.error('[SPLICE] Timeline markers error:', err);\n   527→    results.errors++;\n   528→  }\n   529→\n   530→  return results;\n   531→}\n   532→\n   533→/**\n   534→ * Read current SPLICE marker positions from timeline.\n   535→ * This allows users to manually adjust markers before applying.\n   536→ * Returns silences based on current marker positions (not original detection).\n   537→ */\n   538→async function readMarkersAssilences() {\n   539→  const silences = [];\n   540→\n   541→  try {\n   542→    const context = await getActiveSequence();\n   543→    if (!context) return silences;\n   544→\n   545→    const { sequence } = context;\n   546→    const markers = await ppro.Markers.getMarkers(sequence);\n   547→    if (!markers) return silences;\n   548→\n   549→    const allMarkers = await markers.getMarkers();\n   550→    if (!allMarkers || allMarkers.length === 0) return silences;\n   551→\n   552→    for (const marker of allMarkers) {\n   553→      const name = await marker.getName();\n   554→\n   555→      // Only read \"Remove\" markers (red ones that will be cut)\n   556→      if (name && name.startsWith('SPLICE: Remove')) {\n   557→        const startTickTime = await marker.getStart();\n   558→        const durationTickTime = await marker.getDuration();\n   559→\n   560→        // Use TickTime.seconds property to get seconds directly (no TICKS_PER_SECOND needed)\n   561→        const start = startTickTime.seconds;\n   562→        const duration = durationTickTime.seconds;\n   563→        const end = start + duration;\n   564→\n   565→        silences.push({\n   566→          start,\n   567→          end,\n   568→          duration,\n   569→          fromMarker: true  // Flag to indicate this came from marker adjustment\n   570→        });\n   571→      }\n   572→    }\n   573→\n   574→    // Sort by start time\n   575→    silences.sort((a, b) => a.start - b.start);\n   576→    console.log(`[SPLICE] Read ${silences.length} silences from adjusted markers`);\n   577→\n   578→  } catch (err) {\n   579→    console.error('[SPLICE] Error reading markers:', err);\n   580→  }\n   581→\n   582→  return silences;\n   583→}\n   584→\n   585→/**\n   586→ * Remove all SPLICE markers from the timeline.\n   587→ * Call this before adding new markers to avoid duplicates.\n   588→ */\n   589→async function clearSpliceMarkers() {\n   590→  try {\n   591→    const context = await getActiveSequence();\n   592→    if (!context) return 0;\n   593→\n   594→    const { sequence, project } = context;\n   595→    const markers = await ppro.Markers.getMarkers(sequence);\n   596→    if (!markers) return 0;\n   597→\n   598→    // Get all markers\n   599→    const allMarkers = await markers.getMarkers();\n   600→    if (!allMarkers || allMarkers.length === 0) return 0;\n   601→\n   602→    // Filter SPLICE markers\n   603→    const spliceMarkers = [];\n   604→    for (const marker of allMarkers) {\n   605→      const name = await marker.getName();\n   606→      if (name && name.startsWith('SPLICE:')) {\n   607→        spliceMarkers.push(marker);\n   608→      }\n   609→    }\n   610→\n   611→    if (spliceMarkers.length === 0) return 0;\n   612→\n   613→    // Remove all SPLICE markers in a single transaction\n   614→    await project.lockedAccess(async () => {\n   615→      await project.executeTransaction((compoundAction) => {\n   616→        for (const marker of spliceMarkers) {\n   617→          const removeAction = markers.createRemoveMarkerAction(marker);\n   618→          compoundAction.addAction(removeAction);\n   619→        }\n   620→      }, 'SPLICE: Clear Markers');\n   621→    });\n   622→\n   623→    console.log(`[SPLICE] Cleared ${spliceMarkers.length} previous markers`);\n   624→    return spliceMarkers.length;\n   625→\n   626→  } catch (err) {\n   627→    console.error('[SPLICE] Error clearing markers:', err);\n   628→    return 0;\n   629→  }\n   630→}\n   631→\n   632→// ============================================================================\n   633→// COMBINED PREVIEW (Silences + Takes with colored markers)\n   634→// ============================================================================\n   635→/**\n   636→ * Show combined preview with:\n   637→ * - Red markers: silences safe to remove\n   638→ * - Yellow markers: silences protected by takes (won't be removed)\n   639→ * - Blue markers: takes (for reference)\n   640→ */\n   641→function showCombinedPreview(safeToRemove, protectedSilences, takes) {\n   642→  // Update global state\n   643→  safeSilences = safeToRemove;\n   644→  previewSilences = [...safeToRemove, ...protectedSilences];\n   645→  previewTakes = takes;\n   646→  selectedSilenceIndices = new Set(safeToRemove.map((_, i) => i));\n   647→\n   648→  // Hide other views\n   649→  hideAllViews();\n   650→\n   651→  // Update summary counts\n   652→  if (ui.silenceCountDisplay) ui.silenceCountDisplay.textContent = safeToRemove.length;\n   653→  if (ui.takeCountDisplay) ui.takeCountDisplay.textContent = takes.length;\n   654→  if (ui.selectedCount) ui.selectedCount.textContent = safeToRemove.length;\n   655→\n   656→  // Build combined items list (sorted by time)\n   657→  const items = [\n   658→    ...safeToRemove.map((s, i) => ({ type: 'silence', index: i, start: s.start, end: s.end, data: s })),\n   659→    ...protectedSilences.map(s => ({ type: 'protected', start: s.start, end: s.end, data: s })),\n   660→    ...takes.map(t => ({ type: 'take', start: t.startTime || t.start, end: t.endTime || t.end, data: t }))\n   661→  ].sort((a, b) => a.start - b.start);\n   662→\n   663→  // Build preview list using DocumentFragment\n   664→  const fragment = document.createDocumentFragment();\n   665→\n   666→  items.forEach((item) => {\n   667→    const duration = item.end - item.start;\n   668→    const div = document.createElement('div');\n   669→\n   670→    if (item.type === 'silence') {\n   671→      // Safe to remove - red marker with checkbox\n   672→      div.className = 'preview-item silence-marker';\n   673→      div.dataset.index = item.index;\n   674→      div.innerHTML = `\n   675→        <input type=\"checkbox\" class=\"preview-item-check\" checked data-index=\"${item.index}\">\n   676→        <div class=\"preview-item-info\">\n   677→          <div class=\"preview-item-time\">${formatTime(item.start)} - ${formatTime(item.end)}</div>\n   678→          <div class=\"preview-item-duration\">${duration.toFixed(2)}s silence</div>\n   679→        </div>\n   680→        <button class=\"preview-item-seek\" data-time=\"${item.start}\" title=\"Seek to this silence\">&gt;</button>\n   681→      `;\n   682→    } else if (item.type === 'protected') {\n   683→      // Protected by take - yellow marker, no checkbox\n   684→      div.className = 'preview-item protected-silence';\n   685→      div.innerHTML = `\n   686→        <div style=\"width: 20px; margin-right: 10px;\"></div>\n   687→        <div class=\"preview-item-info\">\n   688→          <div class=\"preview-item-time\">${formatTime(item.start)} - ${formatTime(item.end)}</div>\n   689→          <div class=\"preview-item-duration\">${duration.toFixed(2)}s (overlaps speech)</div>\n   690→        </div>\n   691→        <button class=\"preview-item-seek\" data-time=\"${item.start}\" title=\"Seek\">&gt;</button>\n   692→      `;\n   693→    } else if (item.type === 'take') {\n   694→      // Take (speech segment) - blue marker, no checkbox\n   695→      div.className = 'preview-item take-marker';\n   696→      const textPreview = item.data.text?.substring(0, 40) || 'Speech segment';\n   697→      div.innerHTML = `\n   698→        <div style=\"width: 20px; margin-right: 10px;\"></div>\n   699→        <div class=\"preview-item-info\">\n   700→          <div class=\"preview-item-time\">${formatTime(item.start)} - ${formatTime(item.end)}</div>\n   701→          <div class=\"preview-item-duration\">${textPreview}${item.data.text?.length > 40 ? '...' : ''}</div>\n   702→        </div>\n   703→        <button class=\"preview-item-seek\" data-time=\"${item.start}\" title=\"Seek to take\">&gt;</button>\n   704→      `;\n   705→    }\n   706→\n   707→    fragment.appendChild(div);\n   708→  });\n   709→\n   710→  if (ui.previewList) {\n   711→    ui.previewList.textContent = '';\n   712→    ui.previewList.appendChild(fragment);\n   713→  }\n   714→\n   715→  // Reset UI state\n   716→  if (ui.selectAllSilences) ui.selectAllSilences.checked = true;\n   717→  updateApplyButton();\n   718→\n   719→  // Show combined preview section\n   720→  if (ui.combinedPreview) ui.combinedPreview.style.display = 'block';\n   721→}\n   722→\n   723→function initPreviewHandlers() {\n   724→  // EVENT DELEGATION: Single listener on parent instead of many on children\n   725→  if (ui.previewList) {\n   726→    // Handle checkbox changes\n   727→    ui.previewList.addEventListener('change', (e) => {\n   728→      if (e.target.classList.contains('preview-item-check')) {\n   729→        const index = parseInt(e.target.dataset.index);\n   730→        const item = e.target.closest('.preview-item');\n   731→\n   732→        if (e.target.checked) {\n   733→          selectedSilenceIndices.add(index);\n   734→          item?.classList.remove('excluded');\n   735→        } else {\n   736→          selectedSilenceIndices.delete(index);\n   737→          item?.classList.add('excluded');\n   738→        }\n   739→        updateSelectionCounts();\n   740→      }\n   741→    });\n   742→\n   743→    // Handle seek button clicks\n   744→    ui.previewList.addEventListener('click', async (e) => {\n   745→      if (e.target.classList.contains('preview-item-seek')) {\n   746→        e.stopPropagation();\n   747→        const btn = e.target;\n   748→        const time = parseFloat(btn.dataset.time);\n   749→\n   750→        // Show loading state\n   751→        btn.classList.add('loading');\n   752→        btn.textContent = '...';\n   753→\n   754→        try {\n   755→          await seekToTime(time);\n   756→        } finally {\n   757→          btn.classList.remove('loading');\n   758→          btn.textContent = '>';\n   759→        }\n   760→      }\n   761→    });\n   762→  }\n   763→\n   764→  // Apply button\n   765→  if (ui.applyPreviewBtn) {\n   766→    ui.applyPreviewBtn.addEventListener('click', async () => {\n   767→      if (isOperationInProgress) return;\n   768→      isOperationInProgress = true;\n   769→      ui.applyPreviewBtn.disabled = true;\n   770→\n   771→      const originalText = ui.applyPreviewBtn.textContent;\n   772→      ui.applyPreviewBtn.textContent = 'Applying...';\n   773→\n   774→      try {\n   775→        await applySelectedSilences();\n   776→      } catch (err) {\n   777→        setStatus('Error: ' + err.message);\n   778→        console.error('[SPLICE] Apply error:', err);\n   779→      } finally {\n   780→        ui.applyPreviewBtn.textContent = originalText;\n   781→        ui.applyPreviewBtn.disabled = false;\n   782→        isOperationInProgress = false;\n   783→      }\n   784→    });\n   785→  }\n   786→\n   787→  // Cancel button\n   788→  if (ui.cancelPreviewBtn) {\n   789→    ui.cancelPreviewBtn.addEventListener('click', async () => {\n   790→      await cancelPreview();\n   791→    });\n   792→  }\n   793→\n   794→  // Select all checkbox\n   795→  if (ui.selectAllSilences) {\n   796→    ui.selectAllSilences.addEventListener('change', (e) => {\n   797→      selectAllSilences(e.target.checked);\n   798→    });\n   799→  }\n   800→\n   801→  // Invert selection button\n   802→  if (ui.invertSelectionBtn) {\n   803→    ui.invertSelectionBtn.addEventListener('click', () => {\n   804→      invertSilenceSelection();\n   805→    });\n   806→  }\n   807→\n   808→  // Duration filter buttons\n   809→  document.querySelectorAll('.preview-filters .filter-btn[data-min]').forEach(btn => {\n   810→    btn.addEventListener('click', () => {\n   811→      const min = parseFloat(btn.dataset.min);\n   812→      const max = parseFloat(btn.dataset.max);\n   813→      selectByDuration(min, max);\n   814→    });\n   815→  });\n   816→\n   817→  // Re-run detection button\n   818→  if (ui.reRunDetectionBtn) {\n   819→    ui.reRunDetectionBtn.addEventListener('click', () => {\n   820→      // Hide preview, show options, let user adjust sensitivity\n   821→      if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';\n   822→      if (ui.optionsPanel) ui.optionsPanel.classList.remove('collapsed');\n   823→      if (ui.optionsToggle) ui.optionsToggle.classList.add('expanded');\n   824→      showEmptyState();\n   825→      setStatus('Adjust sensitivity and click GO again');\n   826→    });\n   827→  }\n   828→\n   829→  // Build Sequence button (v3.5 - direct DOM reconstruction)\n   830→  if (ui.buildSequenceBtn) {\n   831→    ui.buildSequenceBtn.addEventListener('click', async () => {\n   832→      if (isOperationInProgress) return;\n   833→\n   834→      // Check if we have detection data\n   835→      if (safeSilences.length === 0 && previewTakes.length === 0) {\n   836→        setStatus('No detection data. Run analysis first.');\n   837→        return;\n   838→      }\n   839→\n   840→      isOperationInProgress = true;\n   841→      ui.buildSequenceBtn.disabled = true;\n   842→      const originalText = ui.buildSequenceBtn.textContent;\n   843→      ui.buildSequenceBtn.textContent = 'Building...';\n   844→\n   845→      try {\n   846→        showProgress('Building new sequence...');\n   847→\n   848→        const result = await buildSequenceWithCutList();\n   849→\n   850→        if (result.success) {\n   851→          // Hide preview and show success\n   852→          if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';\n   853→          showEmptyState();\n   854→\n   855→          const metadata = result.metadata || {};\n   856→          setStatus(`New sequence created: ${metadata.silencesRemoved || 0} silences removed, ${metadata.takesDetected || 0} takes detected`);\n   857→\n   858→          // Clear markers after successful build\n   859→          await clearSpliceMarkers();\n   860→\n   861→          // Clear preview state\n   862→          previewSilences = [];\n   863→          safeSilences = [];\n   864→          protectedSilences = [];\n   865→          previewTakes = [];\n   866→          selectedSilenceIndices.clear();\n   867→        } else {\n   868→          // User-friendly error messages\n   869→          const errorMsg = result.error || 'Unknown error';\n   870→          setStatus('Build failed: ' + formatBuildError(errorMsg));\n   871→        }\n   872→\n   873→      } catch (err) {\n   874→        console.error('[SPLICE] Build sequence error:', err);\n   875→        // User-friendly error messages with recovery hints\n   876→        setStatus('Build error: ' + formatBuildError(err.message));\n   877→      } finally {\n   878→        ui.buildSequenceBtn.textContent = originalText;\n   879→        ui.buildSequenceBtn.disabled = false;\n   880→        isOperationInProgress = false;\n   881→      }\n   882→    });\n   883→  }\n   884→}\n   885→\n   886→function selectAllSilences(checked) {\n   887→  selectedSilenceIndices.clear();\n   888→\n   889→  if (checked) {\n   890→    safeSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n   891→  }\n   892→\n   893→  // Batch update DOM (only silence-marker items have checkboxes)\n   894→  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {\n   895→    const index = parseInt(checkbox.dataset.index);\n   896→    checkbox.checked = checked;\n   897→    const item = checkbox.closest('.preview-item');\n   898→    if (checked) {\n   899→      item?.classList.remove('excluded');\n   900→    } else {\n   901→      item?.classList.add('excluded');\n   902→    }\n   903→  });\n   904→\n   905→  updateSelectionCounts();\n   906→}\n   907→\n   908→function invertSilenceSelection() {\n   909→  const allIndices = new Set(safeSilences.map((_, i) => i));\n   910→  const newSelection = new Set([...allIndices].filter(i => !selectedSilenceIndices.has(i)));\n   911→  selectedSilenceIndices = newSelection;\n   912→\n   913→  // Update DOM\n   914→  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {\n   915→    const index = parseInt(checkbox.dataset.index);\n   916→    const isSelected = selectedSilenceIndices.has(index);\n   917→    checkbox.checked = isSelected;\n   918→    const item = checkbox.closest('.preview-item');\n   919→    if (isSelected) {\n   920→      item?.classList.remove('excluded');\n   921→    } else {\n   922→      item?.classList.add('excluded');\n   923→    }\n   924→  });\n   925→\n   926→  updateSelectionCounts();\n   927→}\n   928→\n   929→function selectByDuration(minSec, maxSec) {\n   930→  selectedSilenceIndices.clear();\n   931→\n   932→  safeSilences.forEach((silence, index) => {\n   933→    const duration = silence.end - silence.start;\n   934→    if (duration >= minSec && duration < maxSec) {\n   935→      selectedSilenceIndices.add(index);\n   936→    }\n   937→  });\n   938→\n   939→  // Update DOM\n   940→  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {\n   941→    const index = parseInt(checkbox.dataset.index);\n   942→    const isSelected = selectedSilenceIndices.has(index);\n   943→    checkbox.checked = isSelected;\n   944→    const item = checkbox.closest('.preview-item');\n   945→    if (isSelected) {\n   946→      item?.classList.remove('excluded');\n   947→    } else {\n   948→      item?.classList.add('excluded');\n   949→    }\n   950→  });\n   951→\n   952→  updateSelectionCounts();\n   953→  setStatus(`Selected ${selectedSilenceIndices.size} silences (${minSec}s - ${maxSec}s)`);\n   954→}\n   955→\n   956→async function cancelPreview() {\n   957→  // Keep silences available for Razor if detected\n   958→  const hadSilences = safeSilences.length > 0;\n   959→\n   960→  previewSilences = [];\n   961→  safeSilences = [];\n   962→  protectedSilences = [];\n   963→  previewTakes = [];\n   964→  selectedSilenceIndices.clear();\n   965→  showEmptyState();\n   966→\n   967→  // Clear timeline markers\n   968→  const cleared = await clearSpliceMarkers();\n   969→  const markerInfo = cleared > 0 ? ` (${cleared} markers removed)` : '';\n   970→  setStatus('Preview cancelled' + markerInfo);\n   971→\n   972→  // Show Razor section if silences were detected\n   973→  if (hadSilences && ui.advancedSection) {\n   974→    ui.advancedSection.classList.remove('hidden');\n   975→  }\n   976→}\n   977→\n   978→async function applySelectedSilences() {\n   979→  if (selectedSilenceIndices.size === 0) {\n   980→    setStatus('No silences selected');\n   981→    return;\n   982→  }\n   983→\n   984→  showProgress('Reading marker positions...');\n   985→\n   986→  // Read current marker positions from timeline\n   987→  // This allows users to manually adjust markers before applying\n   988→  const markerSilences = await readMarkersAssilences();\n   989→\n   990→  let silencesToApply;\n   991→  let adjustedCount = 0;\n   992→\n   993→  if (markerSilences.length > 0) {\n   994→    // Use marker positions (may have been adjusted by user)\n   995→    silencesToApply = markerSilences;\n   996→    adjustedCount = markerSilences.length;\n   997→    console.log(`[SPLICE] Using ${adjustedCount} silences from adjusted markers`);\n   998→  } else {\n   999→    // Fallback to original detection data\n  1000→    silencesToApply = safeSilences.filter((_, i) => selectedSilenceIndices.has(i));\n  1001→    console.log(`[SPLICE] Using ${silencesToApply.length} silences from original detection`);\n  1002→  }\n  1003→\n  1004→  if (silencesToApply.length === 0) {\n  1005→    setStatus('No silences to apply');\n  1006→    return;\n  1007→  }\n  1008→\n  1009→  // Update global silences for the apply function\n  1010→  setCurrentSilences(silencesToApply);\n  1011→\n  1012→  showProgress('Applying changes...');\n  1013→\n  1014→  // Apply to timeline\n  1015→  const result = await removeSilencesFromTimeline();\n  1016→\n  1017→  // Clear markers after applying\n  1018→  await clearSpliceMarkers();\n  1019→\n  1020→  // Hide preview\n  1021→  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';\n  1022→\n  1023→  // Show results\n  1024→  showSilenceResults({\n  1025→    count: silencesToApply.length,\n  1026→    timeSaved: silencesToApply.reduce((sum, s) => sum + (s.end - s.start), 0),\n  1027→    clipsModified: result\n  1028→  });\n  1029→\n  1030→  // Show advanced section\n  1031→  if (ui.advancedSection) ui.advancedSection.classList.remove('hidden');\n  1032→\n  1033→  const adjustedInfo = adjustedCount > 0 ? ' (from adjusted markers)' : '';\n  1034→  setStatus(`Removed ${silencesToApply.length} silence(s) - ${result} clip(s) modified${adjustedInfo}`);\n  1035→\n  1036→  // Refresh credits (await to prevent race conditions)\n  1037→  try {\n  1038→    await refreshCredits();\n  1039→  } catch (err) {\n  1040→    console.warn('[SPLICE] Credits refresh failed:', err);\n  1041→  }\n  1042→\n  1043→  // Clear preview state\n  1044→  previewSilences = [];\n  1045→  safeSilences = [];\n  1046→  protectedSilences = [];\n  1047→  previewTakes = [];\n  1048→  selectedSilenceIndices.clear();\n  1049→}\n  1050→\n  1051→// ============================================================================\n  1052→// UI HELPERS\n  1053→// ============================================================================\n  1054→function updateApplyButton() {\n  1055→  if (ui.applyPreviewBtn) {\n  1056→    const count = selectedSilenceIndices.size;\n  1057→    ui.applyPreviewBtn.disabled = count === 0;\n  1058→    ui.applyPreviewBtn.textContent = count === 0 ? 'Select silences' : `Apply ${count} Selected`;\n  1059→  }\n  1060→}\n  1061→\n  1062→function updateSelectAllCheckbox() {\n  1063→  if (ui.selectAllSilences) {\n  1064→    ui.selectAllSilences.checked = selectedSilenceIndices.size === safeSilences.length && safeSilences.length > 0;\n  1065→  }\n  1066→}\n  1067→\n  1068→function hideAllViews() {\n  1069→  if (ui.progressContainer) ui.progressContainer.style.display = 'none';\n  1070→  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'none';\n  1071→  if (ui.silenceResults) ui.silenceResults.style.display = 'none';\n  1072→  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';\n  1073→}\n  1074→\n  1075→function showProgress(message) {\n  1076→  hideAllViews();\n  1077→  if (ui.progressContainer) ui.progressContainer.style.display = 'block';\n  1078→  if (ui.progressText) ui.progressText.textContent = message;\n  1079→}\n  1080→\n  1081→function showEmptyState() {\n  1082→  hideAllViews();\n  1083→  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'block';\n  1084→  if (ui.advancedSection) ui.advancedSection.classList.add('hidden');\n  1085→}\n  1086→\n  1087→function showSilenceResults({ count, timeSaved, clipsModified }) {\n  1088→  hideAllViews();\n  1089→\n  1090→  // Update the results display\n  1091→  if (ui.resultsCount) ui.resultsCount.textContent = count;\n  1092→  if (ui.timeSaved) ui.timeSaved.textContent = timeSaved.toFixed(1) + 's';\n  1093→  if (ui.clipsModified) ui.clipsModified.textContent = clipsModified;\n  1094→\n  1095→  if (ui.silenceResults) ui.silenceResults.style.display = 'block';\n  1096→}\n  1097→\n  1098→function formatTime(seconds) {\n  1099→  if (typeof seconds !== 'number' || isNaN(seconds)) return '0:00';\n  1100→  const mins = Math.floor(seconds / 60);\n  1101→  const secs = Math.floor(seconds % 60);\n  1102→  return `${mins}:${secs.toString().padStart(2, '0')}`;\n  1103→}\n  1104→\n  1105→/**\n  1106→ * Format build errors into user-friendly messages\n  1107→ * @param {string} error - Raw error message\n  1108→ * @returns {string} User-friendly error message\n  1109→ */\n  1110→function formatBuildError(error) {\n  1111→  if (!error) return 'Unknown error occurred';\n  1112→\n  1113→  // Map technical errors to user-friendly messages\n  1114→  const errorMap = {\n  1115→    'Builder not initialized': 'Builder module failed to load. Try restarting the plugin.',\n  1116→    'No active project': 'No project is open. Please open or create a project first.',\n  1117→    'No media items found': 'No media files in project. Import media before building.',\n  1118→    'No detection data': 'Run analysis first (click GO button).',\n  1119→    'Failed to generate cut list': 'Server error generating cuts. Check your connection.',\n  1120→    'Failed to build sequence': 'Premiere Pro sequence build failed. Try again.',\n  1121→    'fetch failed': 'Network error. Check if backend server is running.',\n  1122→    'NetworkError': 'Cannot connect to server. Check your internet connection.',\n  1123→    'Insufficient credits': 'Out of credits. Upgrade your plan to continue.',\n  1124→    'Authentication required': 'Login required. Click the credits badge to log in.'\n  1125→  };\n  1126→\n  1127→  // Check for matching error patterns\n  1128→  for (const [pattern, friendly] of Object.entries(errorMap)) {\n  1129→    if (error.includes(pattern)) {\n  1130→      return friendly;\n  1131→    }\n  1132→  }\n  1133→\n  1134→  // Return original if no match (already reasonably clear)\n  1135→  return error;\n  1136→}\n  1137→\n  1138→function setStatus(message) {\n  1139→  if (ui.status) ui.status.textContent = message;\n  1140→}\n  1141→\n  1142→// ============================================================================\n  1143→// UNDO HANDLERS\n  1144→// ============================================================================\n  1145→function initUndoHandlers() {\n  1146→  if (ui.undoBtn) {\n  1147→    ui.undoBtn.addEventListener('click', () => {\n  1148→      try {\n  1149→        ppro.app.executeCommand('Edit.Undo');\n  1150→        showEmptyState();\n  1151→        setStatus('Changes undone');\n  1152→      } catch (e) {\n  1153→        setStatus('Undo failed - use Cmd+Z');\n  1154→      }\n  1155→    });\n  1156→  }\n  1157→}\n  1158→\n  1159→// ============================================================================\n  1160→// MEDIA FOLDER HANDLERS (v3.5)\n  1161→// ============================================================================\n  1162→function initMediaFolderHandlers() {\n  1163→  // Update display on load\n  1164→  updateMediaFolderDisplay();\n  1165→\n  1166→  // Set media folder button\n  1167→  if (ui.setMediaFolderBtn) {\n  1168→    ui.setMediaFolderBtn.addEventListener('click', async () => {\n  1169→      ui.setMediaFolderBtn.disabled = true;\n  1170→      ui.setMediaFolderBtn.textContent = 'Selecting...';\n  1171→\n  1172→      try {\n  1173→        const result = await setupMediaFolder();\n  1174→        if (result.success) {\n  1175→          updateMediaFolderDisplay();\n  1176→          setStatus(`Media folder set: ${result.path}`);\n  1177→        } else {\n  1178→          setStatus(result.error || 'Failed to set media folder');\n  1179→        }\n  1180→      } catch (err) {\n  1181→        setStatus('Error: ' + err.message);\n  1182→      } finally {\n  1183→        ui.setMediaFolderBtn.disabled = false;\n  1184→        ui.setMediaFolderBtn.textContent = 'Set Folder';\n  1185→      }\n  1186→    });\n  1187→  }\n  1188→\n  1189→  // Clear media folder button\n  1190→  if (ui.clearMediaFolderBtn) {\n  1191→    ui.clearMediaFolderBtn.addEventListener('click', () => {\n  1192→      clearMediaFolder();\n  1193→      updateMediaFolderDisplay();\n  1194→      setStatus('Media folder cleared');\n  1195→    });\n  1196→  }\n  1197→}\n  1198→\n  1199→function updateMediaFolderDisplay() {\n  1200→  if (ui.mediaFolderDisplay) {\n  1201→    const path = getMediaFolderPath();\n  1202→    if (path) {\n  1203→      // Truncate long paths for display\n  1204→      const displayPath = path.length > 40\n  1205→        ? '...' + path.slice(-37)\n  1206→        : path;\n  1207→      ui.mediaFolderDisplay.textContent = displayPath;\n  1208→      ui.mediaFolderDisplay.title = path; // Full path on hover\n  1209→      ui.mediaFolderDisplay.style.color = '#4a9eff';\n  1210→    } else {\n  1211→      ui.mediaFolderDisplay.textContent = 'Not configured';\n  1212→      ui.mediaFolderDisplay.title = '';\n  1213→      ui.mediaFolderDisplay.style.color = '#888';\n  1214→    }\n  1215→  }\n  1216→}\n  1217→\n  1218→// ============================================================================\n  1219→// BUILD SEQUENCE (v3.5 - Direct DOM Reconstruction)\n  1220→// ============================================================================\n  1221→\n  1222→// 1. ROBUST CONSTANTS (Fixes 'undefined' error)\n  1223→// We define these integers explicitly because UXP API versions vary on where they store Enums.\n  1224→const ProjectItemType = {\n  1225→    CLIP: 1,\n  1226→    BIN: 2,\n  1227→    ROOT: 3,\n  1228→    FILE: 4\n  1229→};\n  1230→\n  1231→/**\n  1232→ * Find the first media item in the project bin (recursively)\n  1233→ * @param {Object} item - ProjectItem (usually rootItem)\n  1234→ * @returns {Promise<Object|null>} First media item found or null\n  1235→ */\n  1236→async function findFirstMediaItem(item) {\n  1237→  if (!item) return null;\n  1238→\n  1239→  // Fix: Use local Constant instead of app.Constants.ProjectItemType\n  1240→  if (item.type === ProjectItemType.CLIP) {\n  1241→    return item;\n  1242→  }\n  1243→\n  1244→  // Search Children (Bin or Root)\n  1245→  // Note: item.children is a collection, check numItems\n  1246→  if (item.children && item.children.numItems > 0) {\n  1247→    for (let i = 0; i < item.children.numItems; i++) {\n  1248→      const child = item.children[i];\n  1249→      const found = await findFirstMediaItem(child);\n  1250→      if (found) return found;\n  1251→    }\n  1252→  }\n  1253→\n  1254→  return null;\n  1255→}\n  1256→\n  1257→/**\n  1258→ * Build a sequence from detection data locally\n  1259→ * Used for testing via console: await buildSequenceV35(silences)\n  1260→ */\n  1261→async function buildSequenceV35(silences, takes = []) {\n  1262→    if (!window.spliceBuilder) {\n  1263→        throw new Error('Builder not initialized. Check if builder.js is loaded.');\n  1264→    }\n  1265→\n  1266→    const app = require('premierepro');\n  1267→    const project = await app.Project.getActiveProject();\n  1268→    if (!project) throw new Error(\"No active project found.\");\n  1269→\n  1270→    const rootItem = await project.getRootItem();\n  1271→    const sourceProjectItem = await findFirstMediaItem(rootItem);\n  1272→\n  1273→    if (!sourceProjectItem) {\n  1274→        throw new Error('No media items found in project bin.');\n  1275→    }\n  1276→\n  1277→    console.log(`[SPLICE] Found source media: ${sourceProjectItem.name}`);\n  1278→\n  1279→    return await window.spliceBuilder.buildSequenceFromDetection(silences, takes, sourceProjectItem);\n  1280→}\n  1281→\n  1282→/**\n  1283→ * Request a cut list from the backend and build the sequence.\n  1284→ * Full v3.5 workflow.\n  1285→ */\n  1286→async function buildSequenceWithCutList() {\n  1287→  if (!window.spliceBuilder) {\n  1288→    throw new Error('Builder not initialized');\n  1289→  }\n  1290→\n  1291→  // Ensure BACKEND_URL is available\n  1292→  const apiUrl = (typeof BACKEND_URL !== 'undefined') ? BACKEND_URL : 'http://localhost:3000';\n  1293→\n  1294→  if (typeof showProgress === 'function') showProgress('Getting source clip info...');\n  1295→\n  1296→  const app = require('premierepro');\n  1297→  const project = await app.Project.getActiveProject();\n  1298→  if (!project) throw new Error(\"No active project.\");\n  1299→\n  1300→  const rootItem = await project.getRootItem();\n  1301→  const sourceProjectItem = await findFirstMediaItem(rootItem);\n  1302→\n  1303→  if (!sourceProjectItem) {\n  1304→    throw new Error('No media items found in project. Please import a media file first.');\n  1305→  }\n  1306→\n  1307→  // Use properties strictly\n  1308→  const sourceName = sourceProjectItem.name;\n  1309→  const sourcePath = sourceProjectItem.treePath;\n  1310→\n  1311→  const durationObj = await sourceProjectItem.getDuration();\n  1312→  const duration = durationObj ? durationObj.seconds : 0;\n  1313→\n  1314→  // Retrieve Globals\n  1315→  const silences = window.splicePreviewState?.getSelectedSilences() || (typeof safeSilences !== 'undefined' ? safeSilences : []);\n  1316→  const takes = (typeof previewTakes !== 'undefined' ? previewTakes : []);\n  1317→\n  1318→  if (silences.length === 0 && (!takes || takes.length === 0)) {\n  1319→     throw new Error('No detection data found. Run analysis first.');\n  1320→  }\n  1321→\n  1322→  if (typeof showProgress === 'function') showProgress('Generating cut list...');\n  1323→\n  1324→  const response = await fetch(`${apiUrl}/cut-list`, {\n  1325→    method: 'POST',\n  1326→    headers: getAuthHeaders(),\n  1327→    body: JSON.stringify({\n  1328→      sourceName,\n  1329→      sourcePath,\n  1330→      duration,\n  1331→      silences,\n  1332→      takes\n  1333→    })\n  1334→  });\n  1335→\n  1336→  if (!response.ok) {\n  1337→    const err = await response.json();\n  1338→    throw new Error(err.error || 'Failed to generate cut list');\n  1339→  }\n  1340→\n  1341→  const data = await response.json();\n  1342→  const cutList = data.cutList;\n  1343→\n  1344→  if (typeof showProgress === 'function') showProgress('Building sequence...');\n  1345→\n  1346→  const result = await window.spliceBuilder.buildSequenceFromCutList(cutList, sourceProjectItem);\n  1347→\n  1348→  if (!result.success) {\n  1349→    throw new Error(result.error || 'Failed to build sequence');\n  1350→  }\n  1351→\n  1352→  return {\n  1353→    success: true,\n  1354→    clipsAdded: result.clipsAdded,\n  1355→    metadata: cutList.metadata\n  1356→  };\n  1357→}\n  1358→\n  1359→// Expose functions globally for UI and testing\n  1360→if (typeof window !== 'undefined') {\n  1361→    window.buildSequenceV35 = buildSequenceV35;\n  1362→    window.buildSequenceWithCutList = buildSequenceWithCutList;\n  1363→    window.findFirstMediaItem = findFirstMediaItem;\n  1364→}\n  1365→\n  1366→// ============================================================================\n  1367→// TIMELINE SEEK (with proper error handling)\n  1368→// ============================================================================\n  1369→async function seekToTime(seconds) {\n  1370→  // Validate input\n  1371→  if (typeof seconds !== 'number' || isNaN(seconds) || !isFinite(seconds)) {\n  1372→    setStatus('Invalid seek time');\n  1373→    return;\n  1374→  }\n  1375→\n  1376→  if (seconds < 0) {\n  1377→    seconds = 0;\n  1378→  }\n  1379→\n  1380→  try {\n  1381→    const context = await getActiveSequence();\n  1382→    if (!context) {\n  1383→      setStatus('No sequence available');\n  1384→      return;\n  1385→    }\n  1386→\n  1387→    const { sequence } = context;\n  1388→\n  1389→    // Use TickTime API to convert seconds to the format needed\n  1390→    const position = ppro.TickTime.createWithSeconds(seconds);\n  1391→\n  1392→    await sequence.setPlayerPosition(position);\n  1393→    setStatus(`Seeked to ${formatTime(seconds)}`);\n  1394→  } catch (err) {\n  1395→    console.error('[SPLICE] Seek error:', err);\n  1396→    setStatus('Seek failed: ' + (err.message || 'Unknown error'));\n  1397→  }\n  1398→}\n  1399→\n  1400→// ============================================================================\n  1401→// AUTH HEADERS HELPER\n  1402→// ============================================================================\n  1403→/**\n  1404→ * Build request headers with authentication\n  1405→ * @returns {Object} Headers object with Content-Type and x-stripe-customer-id\n  1406→ */\n  1407→function getAuthHeaders() {\n  1408→  const headers = { 'Content-Type': 'application/json' };\n  1409→  const settings = getSettings();\n  1410→  if (settings.customerId) {\n  1411→    headers['x-stripe-customer-id'] = settings.customerId;\n  1412→  }\n  1413→  return headers;\n  1414→}\n  1415→\n  1416→// ============================================================================\n  1417→// AUDIO EXPORT & BACKEND CALLS\n  1418→// ============================================================================\n  1419→async function exportAudioInternal() {\n  1420→  try {\n  1421→    const context = await getActiveSequence();\n  1422→    if (!context) {\n  1423→      throw new Error('No project or sequence open');\n  1424→    }\n  1425→\n  1426→    const { sequence } = context;\n  1427→    const encoderManager = ppro.EncoderManager.getManager();\n  1428→    if (!encoderManager) {\n  1429→      throw new Error('EncoderManager not available');\n  1430→    }\n  1431→\n  1432→    const result = await encoderManager.exportSequence(\n  1433→      sequence,\n  1434→      ppro.EncoderManager.EXPORT_IMMEDIATELY,\n  1435→      WAV_PATH,\n  1436→      WAV_PRESET_PATH,\n  1437→      true\n  1438→    );\n  1439→\n  1440→    return result;\n  1441→  } catch (err) {\n  1442→    console.error('[SPLICE] Export error:', err);\n  1443→    return false;\n  1444→  }\n  1445→}\n  1446→\n  1447→async function isolateVocals() {\n  1448→  const response = await fetch(`${BACKEND_URL}/isolate-vocals`, {\n  1449→    method: 'POST',\n  1450→    headers: getAuthHeaders(),\n  1451→    body: JSON.stringify({ audioPath: WAV_PATH })\n  1452→  });\n  1453→\n  1454→  if (!response.ok) {\n  1455→    const err = await response.json();\n  1456→    return { success: false, error: err.error || 'Isolation request failed' };\n  1457→  }\n  1458→\n  1459→  return await response.json();\n  1460→}\n  1461→\n  1462→async function detectSilences(audioPath, params) {\n  1463→  const response = await fetch(`${BACKEND_URL}/silences-audio`, {\n  1464→    method: 'POST',\n  1465→    headers: getAuthHeaders(),\n  1466→    body: JSON.stringify({\n  1467→      wavPath: audioPath,\n  1468→      threshold: params.dbThreshold,\n  1469→      minDuration: params.minDuration,\n  1470→      padding: params.padding\n  1471→    })\n  1472→  });\n  1473→\n  1474→  if (!response.ok) {\n  1475→    const err = await response.json();\n  1476→    throw new Error(err.error || 'Silence detection failed');\n  1477→  }\n  1478→\n  1479→  const data = await response.json();\n  1480→  if (!data.success) {\n  1481→    throw new Error(data.error || 'Silence detection failed');\n  1482→  }\n  1483→\n  1484→  // Store silences globally for razor workflow\n  1485→  currentSilences = data.silences;\n  1486→\n  1487→  return data.silences;\n  1488→}\n  1489→\n  1490→async function transcribeAudio() {\n  1491→  const response = await fetch(`${BACKEND_URL}/analyze`, {\n  1492→    method: 'POST',\n  1493→    headers: getAuthHeaders(),\n  1494→    body: JSON.stringify({ wavPath: WAV_PATH })\n  1495→  });\n  1496→\n  1497→  if (!response.ok) {\n  1498→    const err = await response.json();\n  1499→    return { success: false, error: err.error || 'Transcription failed' };\n  1500→  }\n  1501→\n  1502→  const data = await response.json();\n  1503→  return {\n  1504→    success: data.success,\n  1505→    transcript: data.transcript,\n  1506→    takes: data.takes,\n  1507→    error: data.error\n  1508→  };\n  1509→}\n  1510→\n  1511→// ============================================================================\n  1512→// BATCH PROCESSING\n  1513→// ============================================================================\n  1514→let batchQueue = [];\n  1515→let currentBatchJobId = null;\n  1516→\n  1517→/**\n  1518→ * Initialize batch processing handlers\n  1519→ */\n  1520→function initBatchHandlers() {\n  1521→  const addToBatchBtn = document.getElementById('addToBatchBtn');\n  1522→  const startBatchBtn = document.getElementById('startBatchBtn');\n  1523→  const clearBatchBtn = document.getElementById('clearBatchBtn');\n  1524→  const batchSection = document.getElementById('batchSection');\n  1525→\n  1526→  // Show batch section in settings or after first detection\n  1527→  if (batchSection) {\n  1528→    batchSection.classList.remove('hidden');\n  1529→  }\n  1530→\n  1531→  // Add files to batch queue\n  1532→  if (addToBatchBtn) {\n  1533→    addToBatchBtn.addEventListener('click', async () => {\n  1534→      try {\n  1535→        const uxpFs = require('uxp').storage.localFileSystem;\n  1536→        const files = await uxpFs.getFileForOpening({\n  1537→          allowMultiple: true,\n  1538→          types: ['wav', 'mp3', 'mp4', 'mov', 'aac', 'm4a']\n  1539→        });\n  1540→\n  1541→        if (files && files.length > 0) {\n  1542→          for (const file of files) {\n  1543→            const path = file.nativePath || file.name;\n  1544→            if (!batchQueue.includes(path)) {\n  1545→              batchQueue.push(path);\n  1546→            }\n  1547→          }\n  1548→          updateBatchQueueDisplay();\n  1549→          setStatus(`Added ${files.length} file(s) to batch queue`);\n  1550→        }\n  1551→      } catch (err) {\n  1552→        setStatus('Error adding files: ' + err.message);\n  1553→      }\n  1554→    });\n  1555→  }\n  1556→\n  1557→  // Start batch processing\n  1558→  if (startBatchBtn) {\n  1559→    startBatchBtn.addEventListener('click', async () => {\n  1560→      if (batchQueue.length === 0) {\n  1561→        setStatus('No files in batch queue');\n  1562→        return;\n  1563→      }\n  1564→\n  1565→      startBatchBtn.disabled = true;\n  1566→      addToBatchBtn.disabled = true;\n  1567→\n  1568→      try {\n  1569→        await runBatchProcessing();\n  1570→      } finally {\n  1571→        startBatchBtn.disabled = false;\n  1572→        addToBatchBtn.disabled = false;\n  1573→      }\n  1574→    });\n  1575→  }\n  1576→\n  1577→  // Clear batch queue\n  1578→  if (clearBatchBtn) {\n  1579→    clearBatchBtn.addEventListener('click', () => {\n  1580→      batchQueue = [];\n  1581→      currentBatchJobId = null;\n  1582→      updateBatchQueueDisplay();\n  1583→      setStatus('Batch queue cleared');\n  1584→    });\n  1585→  }\n  1586→}\n  1587→\n  1588→/**\n  1589→ * Update batch queue display\n  1590→ */\n  1591→function updateBatchQueueDisplay() {\n  1592→  const batchEmpty = document.getElementById('batchEmpty');\n  1593→  const batchList = document.getElementById('batchList');\n  1594→  const startBatchBtn = document.getElementById('startBatchBtn');\n  1595→\n  1596→  if (batchQueue.length === 0) {\n  1597→    if (batchEmpty) batchEmpty.style.display = 'block';\n  1598→    if (batchList) batchList.innerHTML = '';\n  1599→    if (startBatchBtn) startBatchBtn.disabled = true;\n  1600→    return;\n  1601→  }\n  1602→\n  1603→  if (batchEmpty) batchEmpty.style.display = 'none';\n  1604→  if (startBatchBtn) startBatchBtn.disabled = false;\n  1605→\n  1606→  if (batchList) {\n  1607→    batchList.innerHTML = batchQueue.map((path, i) => {\n  1608→      const fileName = path.split('/').pop();\n  1609→      return `<div style=\"display: flex; justify-content: space-between; align-items: center; padding: 4px 6px; background: #2a2a2a; border-radius: 3px; margin-bottom: 2px; font-size: 9px;\">\n  1610→        <span style=\"overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 180px;\" title=\"${path}\">${fileName}</span>\n  1611→        <button onclick=\"removeBatchItem(${i})\" style=\"background: transparent; border: none; color: #888; cursor: pointer; font-size: 10px;\">x</button>\n  1612→      </div>`;\n  1613→    }).join('');\n  1614→  }\n  1615→}\n  1616→\n  1617→/**\n  1618→ * Remove item from batch queue\n  1619→ */\n  1620→function removeBatchItem(index) {\n  1621→  batchQueue.splice(index, 1);\n  1622→  updateBatchQueueDisplay();\n  1623→}\n  1624→\n  1625→/**\n  1626→ * Run batch processing\n  1627→ */\n  1628→async function runBatchProcessing() {\n  1629→  const batchProgress = document.getElementById('batchProgress');\n  1630→  const batchProgressBar = document.getElementById('batchProgressBar');\n  1631→  const batchProgressText = document.getElementById('batchProgressText');\n  1632→\n  1633→  if (batchProgress) batchProgress.style.display = 'block';\n  1634→\n  1635→  try {\n  1636→    // Get settings\n  1637→    const sensitivity = parseInt(document.getElementById('sensitivitySlider')?.value || 50);\n  1638→    const params = mapSensitivity(sensitivity);\n  1639→\n  1640→    // Call batch endpoint\n  1641→    const response = await fetch(`${BACKEND_URL}/batch/silences`, {\n  1642→      method: 'POST',\n  1643→      headers: getAuthHeaders(),\n  1644→      body: JSON.stringify({\n  1645→        files: batchQueue,\n  1646→        options: {\n  1647→          sensitivity,\n  1648→          threshold: params.dbThreshold,\n  1649→          minSilenceLength: params.minDuration,\n  1650→          paddingStart: params.padding,\n  1651→          paddingEnd: params.padding / 2\n  1652→        }\n  1653→      })\n  1654→    });\n  1655→\n  1656→    if (!response.ok) {\n  1657→      const err = await response.json();\n  1658→      throw new Error(err.error || 'Batch request failed');\n  1659→    }\n  1660→\n  1661→    const data = await response.json();\n  1662→    currentBatchJobId = data.jobId;\n  1663→    setStatus(`Batch job started: ${data.jobId}`);\n  1664→\n  1665→    // Poll for status\n  1666→    await pollBatchStatus(currentBatchJobId, batchProgressBar, batchProgressText);\n  1667→\n  1668→  } catch (err) {\n  1669→    setStatus('Batch error: ' + err.message);\n  1670→  } finally {\n  1671→    if (batchProgress) batchProgress.style.display = 'none';\n  1672→  }\n  1673→}\n  1674→\n  1675→/**\n  1676→ * Poll batch job status\n  1677→ */\n  1678→async function pollBatchStatus(jobId, progressBar, progressText) {\n  1679→  const pollInterval = 2000; // 2 seconds\n  1680→  const maxPolls = 300; // 10 minutes max\n  1681→  let polls = 0;\n  1682→\n  1683→  while (polls < maxPolls) {\n  1684→    try {\n  1685→      const response = await fetch(`${BACKEND_URL}/batch/status/${jobId}`, {\n  1686→        headers: getAuthHeaders()\n  1687→      });\n  1688→\n  1689→      if (!response.ok) {\n  1690→        throw new Error('Failed to get batch status');\n  1691→      }\n  1692→\n  1693→      const data = await response.json();\n  1694→      const job = data.job;\n  1695→\n  1696→      // Update progress\n  1697→      if (progressBar) progressBar.value = job.progress.percentage;\n  1698→      if (progressText) progressText.textContent = `${job.progress.completed + job.progress.failed} / ${job.progress.total} files`;\n  1699→\n  1700→      // Check if complete\n  1701→      if (job.status !== 'processing') {\n  1702→        if (job.status === 'completed') {\n  1703→          setStatus(`Batch complete: ${job.progress.completed} files processed`);\n  1704→        } else if (job.status === 'completed_with_errors') {\n  1705→          setStatus(`Batch complete with ${job.progress.failed} error(s)`);\n  1706→        } else {\n  1707→          setStatus('Batch failed');\n  1708→        }\n  1709→\n  1710→        // Clear queue on completion\n  1711→        batchQueue = [];\n  1712→        updateBatchQueueDisplay();\n  1713→        return;\n  1714→      }\n  1715→\n  1716→      await new Promise(resolve => setTimeout(resolve, pollInterval));\n  1717→      polls++;\n  1718→    } catch (err) {\n  1719→      setStatus('Polling error: ' + err.message);\n  1720→      return;\n  1721→    }\n  1722→  }\n  1723→\n  1724→  setStatus('Batch timed out');\n  1725→}\n  1726→\n  1727→// Expose for inline onclick\n  1728→if (typeof window !== 'undefined') {\n  1729→  window.removeBatchItem = removeBatchItem;\n  1730→}\n  1731→\n  1732→// ============================================================================\n  1733→// CUSTOM PRESETS UI (v3.5)\n  1734→// ============================================================================\n  1735→\n  1736→/**\n  1737→ * Icon mapping for display\n  1738→ */\n  1739→const PRESET_ICON_MAP = {\n  1740→  'settings': '*',\n  1741→  'mic': 'M',\n  1742→  'people': 'P',\n  1743→  'bolt': '!',\n  1744→  'school': 'E',\n  1745→  'videocam': 'V',\n  1746→  'star': 'S',\n  1747→  'heart': 'H'\n  1748→};\n  1749→\n  1750→/**\n  1751→ * Initialize custom presets UI handlers\n  1752→ */\n  1753→function initCustomPresetsUI() {\n  1754→  // Refresh preset dropdown on load\n  1755→  refreshPresetDropdown();\n  1756→\n  1757→  // Save Preset button (+)\n  1758→  if (ui.savePresetBtn) {\n  1759→    ui.savePresetBtn.addEventListener('click', () => {\n  1760→      showPresetModal();\n  1761→    });\n  1762→  }\n  1763→\n  1764→  // Manage Presets button (...)\n  1765→  if (ui.managePresetsBtn) {\n  1766→    ui.managePresetsBtn.addEventListener('click', () => {\n  1767→      showManagePresetsModal();\n  1768→    });\n  1769→  }\n  1770→\n  1771→  // Close Preset Modal\n  1772→  if (ui.closePresetModalBtn) {\n  1773→    ui.closePresetModalBtn.addEventListener('click', () => {\n  1774→      hidePresetModal();\n  1775→    });\n  1776→  }\n  1777→\n  1778→  // Close on backdrop click\n  1779→  if (ui.presetModal) {\n  1780→    ui.presetModal.addEventListener('click', (e) => {\n  1781→      if (e.target === ui.presetModal) {\n  1782→        hidePresetModal();\n  1783→      }\n  1784→    });\n  1785→  }\n  1786→\n  1787→  // Icon picker\n  1788→  if (ui.presetIconPicker) {\n  1789→    ui.presetIconPicker.addEventListener('click', (e) => {\n  1790→      const btn = e.target.closest('.preset-icon-option');\n  1791→      if (btn) {\n  1792→        selectPresetIcon(btn.dataset.icon);\n  1793→      }\n  1794→    });\n  1795→  }\n  1796→\n  1797→  // Sensitivity slider value display (Phase 3)\n  1798→  if (ui.presetSensitivity && ui.presetSensitivityValue) {\n  1799→    ui.presetSensitivity.addEventListener('input', () => {\n  1800→      ui.presetSensitivityValue.textContent = ui.presetSensitivity.value;\n  1801→    });\n  1802→  }\n  1803→\n  1804→  // Save Preset Confirm\n  1805→  if (ui.savePresetConfirmBtn) {\n  1806→    ui.savePresetConfirmBtn.addEventListener('click', () => {\n  1807→      savePresetFromModal();\n  1808→    });\n  1809→  }\n  1810→\n  1811→  // Close Manage Presets Modal\n  1812→  if (ui.closeManagePresetsBtn) {\n  1813→    ui.closeManagePresetsBtn.addEventListener('click', () => {\n  1814→      hideManagePresetsModal();\n  1815→    });\n  1816→  }\n  1817→\n  1818→  // Close on backdrop click\n  1819→  if (ui.managePresetsModal) {\n  1820→    ui.managePresetsModal.addEventListener('click', (e) => {\n  1821→      if (e.target === ui.managePresetsModal) {\n  1822→        hideManagePresetsModal();\n  1823→      }\n  1824→    });\n  1825→  }\n  1826→\n  1827→  // Event delegation for preset list actions\n  1828→  if (ui.presetsList) {\n  1829→    ui.presetsList.addEventListener('click', (e) => {\n  1830→      const editBtn = e.target.closest('.preset-edit-btn');\n  1831→      const deleteBtn = e.target.closest('.preset-delete-btn');\n  1832→      const duplicateBtn = e.target.closest('.preset-duplicate-btn');\n  1833→\n  1834→      if (editBtn) {\n  1835→        const presetId = editBtn.dataset.presetId;\n  1836→        editPreset(presetId);\n  1837→      }\n  1838→\n  1839→      if (deleteBtn) {\n  1840→        const presetId = deleteBtn.dataset.presetId;\n  1841→        const presetName = deleteBtn.dataset.presetName;\n  1842→        deletePresetWithConfirm(presetId, presetName);\n  1843→      }\n  1844→\n  1845→      if (duplicateBtn) {\n  1846→        const presetId = duplicateBtn.dataset.presetId;\n  1847→        const presetName = duplicateBtn.dataset.presetName;\n  1848→        duplicatePresetFromUI(presetId, presetName);\n  1849→      }\n  1850→    });\n  1851→  }\n  1852→\n  1853→  // Export presets button (Phase 3)\n  1854→  if (ui.exportPresetsBtn) {\n  1855→    ui.exportPresetsBtn.addEventListener('click', () => {\n  1856→      exportPresetsToFile();\n  1857→    });\n  1858→  }\n  1859→\n  1860→  // Import presets button (Phase 3)\n  1861→  if (ui.importPresetsBtn && ui.importPresetsFile) {\n  1862→    ui.importPresetsBtn.addEventListener('click', () => {\n  1863→      ui.importPresetsFile.click();\n  1864→    });\n  1865→\n  1866→    ui.importPresetsFile.addEventListener('change', (e) => {\n  1867→      if (e.target.files && e.target.files[0]) {\n  1868→        importPresetsFromFile(e.target.files[0]);\n  1869→        e.target.value = ''; // Reset for next import\n  1870→      }\n  1871→    });\n  1872→  }\n  1873→}\n  1874→\n  1875→/**\n  1876→ * Refresh the preset dropdown with all presets (built-in + custom)\n  1877→ */\n  1878→function refreshPresetDropdown() {\n  1879→  if (!ui.presetSelector) return;\n  1880→\n  1881→  const presets = getAllPresets();\n  1882→  const currentValue = ui.presetSelector.value;\n  1883→\n  1884→  // Clear existing options\n  1885→  ui.presetSelector.innerHTML = '';\n  1886→\n  1887→  // Add all presets\n  1888→  presets.forEach(preset => {\n  1889→    const option = document.createElement('option');\n  1890→    option.value = preset.id;\n  1891→\n  1892→    // Format: \"Name - Description\" or just \"Name\"\n  1893→    const desc = preset.description ? ` - ${preset.description}` : '';\n  1894→    option.textContent = preset.name + desc;\n  1895→\n  1896→    // Add custom marker for custom presets\n  1897→    if (!preset.isBuiltIn) {\n  1898→      option.textContent = `${preset.name}${desc}`;\n  1899→      option.style.color = '#28a745';\n  1900→    }\n  1901→\n  1902→    ui.presetSelector.appendChild(option);\n  1903→  });\n  1904→\n  1905→  // Restore selection if it still exists\n  1906→  if ([...ui.presetSelector.options].some(opt => opt.value === currentValue)) {\n  1907→    ui.presetSelector.value = currentValue;\n  1908→  } else {\n  1909→    ui.presetSelector.value = 'custom';\n  1910→  }\n  1911→}\n  1912→\n  1913→/**\n  1914→ * Show the preset modal for creating a new preset\n  1915→ */\n  1916→function showPresetModal(editId = null) {\n  1917→  if (!ui.presetModal) return;\n  1918→\n  1919→  // Reset form\n  1920→  ui.presetNameInput.value = '';\n  1921→  ui.presetDescInput.value = '';\n  1922→  ui.presetEditId.value = '';\n  1923→  ui.presetSelectedIcon.value = 'settings';\n  1924→  selectPresetIcon('settings');\n  1925→  hidePresetError();\n  1926→\n  1927→  // Get current settings as defaults\n  1928→  const currentSettings = getSettings();\n  1929→  const defaultSensitivity = currentSettings.sensitivity || 50;\n  1930→  const defaultThreshold = currentSettings.threshold || -32;\n  1931→\n  1932→  if (editId) {\n  1933→    // Edit mode\n  1934→    const preset = getPresetById(editId);\n  1935→    if (preset && !preset.isBuiltIn) {\n  1936→      ui.presetModalTitle.textContent = 'Edit Preset';\n  1937→      ui.presetNameInput.value = preset.name;\n  1938→      ui.presetDescInput.value = preset.description || '';\n  1939→      ui.presetEditId.value = editId;\n  1940→      ui.presetSelectedIcon.value = preset.icon || 'settings';\n  1941→      selectPresetIcon(preset.icon || 'settings');\n  1942→      ui.savePresetConfirmBtn.textContent = 'Update Preset';\n  1943→\n  1944→      // Populate settings from preset (Phase 3)\n  1945→      const presetSensitivity = preset.settings?.sensitivity ?? defaultSensitivity;\n  1946→      const presetThreshold = preset.settings?.threshold ?? defaultThreshold;\n  1947→      if (ui.presetSensitivity) {\n  1948→        ui.presetSensitivity.value = presetSensitivity;\n  1949→        if (ui.presetSensitivityValue) ui.presetSensitivityValue.textContent = presetSensitivity;\n  1950→      }\n  1951→      if (ui.presetThreshold) {\n  1952→        ui.presetThreshold.value = presetThreshold;\n  1953→      }\n  1954→    }\n  1955→  } else {\n  1956→    // Create mode - use current settings from main UI\n  1957→    ui.presetModalTitle.textContent = 'Save Preset';\n  1958→    ui.savePresetConfirmBtn.textContent = 'Save Preset';\n  1959→\n  1960→    // Get sensitivity from main slider if available\n  1961→    const mainSensitivity = ui.sensitivitySlider?.value ?? defaultSensitivity;\n  1962→    if (ui.presetSensitivity) {\n  1963→      ui.presetSensitivity.value = mainSensitivity;\n  1964→      if (ui.presetSensitivityValue) ui.presetSensitivityValue.textContent = mainSensitivity;\n  1965→    }\n  1966→    if (ui.presetThreshold) {\n  1967→      ui.presetThreshold.value = defaultThreshold;\n  1968→    }\n  1969→  }\n  1970→\n  1971→  ui.presetModal.classList.remove('hidden');\n  1972→  ui.presetNameInput.focus();\n  1973→}\n  1974→\n  1975→/**\n  1976→ * Hide the preset modal\n  1977→ */\n  1978→function hidePresetModal() {\n  1979→  if (ui.presetModal) {\n  1980→    ui.presetModal.classList.add('hidden');\n  1981→  }\n  1982→}\n  1983→\n  1984→/**\n  1985→ * Select an icon in the preset modal\n  1986→ */\n  1987→function selectPresetIcon(iconName) {\n  1988→  if (!ui.presetIconPicker || !ui.presetSelectedIcon) return;\n  1989→\n  1990→  // Update hidden input\n  1991→  ui.presetSelectedIcon.value = iconName;\n  1992→\n  1993→  // Update visual selection\n  1994→  ui.presetIconPicker.querySelectorAll('.preset-icon-option').forEach(btn => {\n  1995→    if (btn.dataset.icon === iconName) {\n  1996→      btn.classList.add('selected');\n  1997→    } else {\n  1998→      btn.classList.remove('selected');\n  1999→    }\n  2000→  });\n  2001→}\n  2002→\n  2003→/**\n  2004→ * Show error message in preset modal\n  2005→ */\n  2006→function showPresetError(message) {\n  2007→  if (ui.presetModalError) {\n  2008→    ui.presetModalError.textContent = message;\n  2009→    ui.presetModalError.style.display = 'block';\n  2010→  }\n  2011→}\n  2012→\n  2013→/**\n  2014→ * Hide error message in preset modal\n  2015→ */\n  2016→function hidePresetError() {\n  2017→  if (ui.presetModalError) {\n  2018→    ui.presetModalError.style.display = 'none';\n  2019→  }\n  2020→}\n  2021→\n  2022→/**\n  2023→ * Save preset from modal (create or update)\n  2024→ */\n  2025→function savePresetFromModal() {\n  2026→  const name = ui.presetNameInput?.value?.trim();\n  2027→  const description = ui.presetDescInput?.value?.trim() || '';\n  2028→  const icon = ui.presetSelectedIcon?.value || 'settings';\n  2029→  const editId = ui.presetEditId?.value;\n  2030→\n  2031→  if (!name) {\n  2032→    showPresetError('Please enter a preset name');\n  2033→    return;\n  2034→  }\n  2035→\n  2036→  // Capture settings from modal inputs (Phase 3)\n  2037→  const sensitivityRaw = parseInt(ui.presetSensitivity?.value);\n  2038→  const thresholdRaw = parseInt(ui.presetThreshold?.value);\n  2039→  const sensitivity = isNaN(sensitivityRaw) ? 50 : sensitivityRaw;\n  2040→  const threshold = isNaN(thresholdRaw) ? -32 : thresholdRaw;\n  2041→\n  2042→  // Get base settings and override with modal values\n  2043→  const baseSettings = getCurrentPresetSettings();\n  2044→  const settings = {\n  2045→    ...baseSettings,\n  2046→    sensitivity,\n  2047→    threshold\n  2048→  };\n  2049→\n  2050→  let result;\n  2051→\n  2052→  if (editId) {\n  2053→    // Update existing preset (including settings)\n  2054→    result = updateCustomPreset(editId, {\n  2055→      name,\n  2056→      description,\n  2057→      icon,\n  2058→      settings\n  2059→    });\n  2060→\n  2061→    if (result.success) {\n  2062→      setStatus(`Preset \"${name}\" updated`);\n  2063→    }\n  2064→  } else {\n  2065→    // Create new preset with modal settings\n  2066→    result = createCustomPreset({\n  2067→      name,\n  2068→      description,\n  2069→      icon,\n  2070→      settings\n  2071→    });\n  2072→\n  2073→    if (result.success) {\n  2074→      setStatus(`Preset \"${name}\" saved`);\n  2075→      // Select the newly created preset\n  2076→      refreshPresetDropdown();\n  2077→      if (ui.presetSelector) {\n  2078→        ui.presetSelector.value = result.id;\n  2079→      }\n  2080→    }\n  2081→  }\n  2082→\n  2083→  if (result.success) {\n  2084→    hidePresetModal();\n  2085→    refreshPresetDropdown();\n  2086→  } else {\n  2087→    showPresetError(result.error || 'Failed to save preset');\n  2088→  }\n  2089→}\n  2090→\n  2091→/**\n  2092→ * Show the manage presets modal\n  2093→ */\n  2094→function showManagePresetsModal() {\n  2095→  if (!ui.managePresetsModal) return;\n  2096→\n  2097→  renderPresetsList();\n  2098→  ui.managePresetsModal.classList.remove('hidden');\n  2099→}\n  2100→\n  2101→/**\n  2102→ * Hide the manage presets modal\n  2103→ */\n  2104→function hideManagePresetsModal() {\n  2105→  if (ui.managePresetsModal) {\n  2106→    ui.managePresetsModal.classList.add('hidden');\n  2107→  }\n  2108→}\n  2109→\n  2110→/**\n  2111→ * Render the presets list in the manage modal\n  2112→ */\n  2113→function renderPresetsList() {\n  2114→  if (!ui.presetsList) return;\n  2115→\n  2116→  const presets = getAllPresets();\n  2117→  const customPresets = presets.filter(p => !p.isBuiltIn);\n  2118→\n  2119→  // Show/hide empty state\n  2120→  if (ui.noCustomPresets) {\n  2121→    ui.noCustomPresets.style.display = customPresets.length === 0 ? 'block' : 'none';\n  2122→  }\n  2123→\n  2124→  // Build HTML\n  2125→  const fragment = document.createDocumentFragment();\n  2126→\n  2127→  presets.forEach(preset => {\n  2128→    const div = document.createElement('div');\n  2129→    div.className = `preset-list-item ${preset.isBuiltIn ? 'built-in' : 'custom'}`;\n  2130→\n  2131→    const iconChar = PRESET_ICON_MAP[preset.icon] || '*';\n  2132→    const desc = preset.description || (preset.isBuiltIn ? 'Built-in preset' : 'Custom preset');\n  2133→\n  2134→    if (preset.isBuiltIn) {\n  2135→      // Built-in presets: only duplicate button (Phase 3)\n  2136→      div.innerHTML = `\n  2137→        <div class=\"preset-list-item-icon\">${iconChar}</div>\n  2138→        <div class=\"preset-list-item-info\">\n  2139→          <div class=\"preset-list-item-name\">${preset.name}</div>\n  2140→          <div class=\"preset-list-item-desc\">${desc}</div>\n  2141→        </div>\n  2142→        <div class=\"preset-list-item-actions\">\n  2143→          <button class=\"preset-duplicate-btn\" data-preset-id=\"${preset.id}\" data-preset-name=\"${preset.name}\" title=\"Duplicate preset\">D</button>\n  2144→        </div>\n  2145→      `;\n  2146→    } else {\n  2147→      // Custom presets: duplicate/edit/delete buttons (Phase 3)\n  2148→      div.innerHTML = `\n  2149→        <div class=\"preset-list-item-icon\">${iconChar}</div>\n  2150→        <div class=\"preset-list-item-info\">\n  2151→          <div class=\"preset-list-item-name\">${preset.name}</div>\n  2152→          <div class=\"preset-list-item-desc\">${desc}</div>\n  2153→        </div>\n  2154→        <div class=\"preset-list-item-actions\">\n  2155→          <button class=\"preset-duplicate-btn\" data-preset-id=\"${preset.id}\" data-preset-name=\"${preset.name}\" title=\"Duplicate preset\">D</button>\n  2156→          <button class=\"preset-edit-btn\" data-preset-id=\"${preset.id}\" title=\"Edit preset\">E</button>\n  2157→          <button class=\"preset-delete-btn delete\" data-preset-id=\"${preset.id}\" data-preset-name=\"${preset.name}\" title=\"Delete preset\">X</button>\n  2158→        </div>\n  2159→      `;\n  2160→    }\n  2161→\n  2162→    fragment.appendChild(div);\n  2163→  });\n  2164→\n  2165→  ui.presetsList.innerHTML = '';\n  2166→  ui.presetsList.appendChild(fragment);\n  2167→}\n  2168→\n  2169→/**\n  2170→ * Edit a preset\n  2171→ */\n  2172→function editPreset(presetId) {\n  2173→  hideManagePresetsModal();\n  2174→  showPresetModal(presetId);\n  2175→}\n  2176→\n  2177→/**\n  2178→ * Delete a preset with confirmation\n  2179→ */\n  2180→function deletePresetWithConfirm(presetId, presetName) {\n  2181→  // Simple confirmation (UXP doesn't have native confirm)\n  2182→  const confirmed = confirm(`Delete preset \"${presetName}\"?`);\n  2183→  if (!confirmed) return;\n  2184→\n  2185→  const result = deleteCustomPreset(presetId);\n  2186→\n  2187→  if (result.success) {\n  2188→    setStatus(`Preset \"${presetName}\" deleted`);\n  2189→    renderPresetsList();\n  2190→    refreshPresetDropdown();\n  2191→  } else {\n  2192→    setStatus('Failed to delete preset: ' + (result.error || 'Unknown error'));\n  2193→  }\n  2194→}\n  2195→\n  2196→/**\n  2197→ * Duplicate a preset from the UI (Phase 3)\n  2198→ */\n  2199→function duplicatePresetFromUI(presetId, presetName) {\n  2200→  const result = duplicatePreset(presetId);\n  2201→\n  2202→  if (result.success) {\n  2203→    setStatus(`Created copy of \"${presetName}\"`);\n  2204→    renderPresetsList();\n  2205→    refreshPresetDropdown();\n  2206→\n  2207→    // Select the new copy in dropdown\n  2208→    if (ui.presetSelector && result.id) {\n  2209→      ui.presetSelector.value = result.id;\n  2210→    }\n  2211→  } else {\n  2212→    setStatus('Failed to duplicate preset: ' + (result.error || 'Unknown error'));\n  2213→  }\n  2214→}\n  2215→\n  2216→/**\n  2217→ * Export presets to a JSON file (Phase 3)\n  2218→ */\n  2219→async function exportPresetsToFile() {\n  2220→  const result = exportPresets();\n  2221→\n  2222→  if (!result.success) {\n  2223→    setStatus(result.error || 'No presets to export');\n  2224→    return;\n  2225→  }\n  2226→\n  2227→  try {\n  2228→    // Create a blob and download it\n  2229→    const blob = new Blob([result.data], { type: 'application/json' });\n  2230→    const filename = `splice-presets-${new Date().toISOString().slice(0, 10)}.json`;\n  2231→\n  2232→    // UXP approach: use file system API\n  2233→    const uxpFs = require('uxp').storage.localFileSystem;\n  2234→    const file = await uxpFs.getFileForSaving(filename, { types: ['json'] });\n  2235→\n  2236→    if (file) {\n  2237→      await file.write(result.data);\n  2238→      setStatus(`Exported ${result.count} preset(s) to ${file.name}`);\n  2239→    } else {\n  2240→      setStatus('Export cancelled');\n  2241→    }\n  2242→  } catch (err) {\n  2243→    console.error('[SPLICE] Export error:', err);\n  2244→    setStatus('Export failed: ' + err.message);\n  2245→  }\n  2246→}\n  2247→\n  2248→/**\n  2249→ * Import presets from a JSON file (Phase 3)\n  2250→ */\n  2251→async function importPresetsFromFile(file) {\n  2252→  try {\n  2253→    // Read file contents\n  2254→    const reader = new FileReader();\n  2255→\n  2256→    reader.onload = (e) => {\n  2257→      const jsonString = e.target.result;\n  2258→      const result = importPresets(jsonString, true);\n  2259→\n  2260→      if (result.success) {\n  2261→        setStatus(`Imported ${result.imported} preset(s)${result.skipped > 0 ? `, ${result.skipped} skipped` : ''}`);\n  2262→        renderPresetsList();\n  2263→        refreshPresetDropdown();\n  2264→      } else {\n  2265→        setStatus('Import failed: ' + (result.error || 'Unknown error'));\n  2266→      }\n  2267→    };\n  2268→\n  2269→    reader.onerror = () => {\n  2270→      setStatus('Failed to read file');\n  2271→    };\n  2272→\n  2273→    reader.readAsText(file);\n  2274→  } catch (err) {\n  2275→    console.error('[SPLICE] Import error:', err);\n  2276→    setStatus('Import failed: ' + err.message);\n  2277→  }\n  2278→}\n  2279→\n  2280→/**\n  2281→ * Apply a preset and update UI controls\n  2282→ * Called when user selects a preset from dropdown\n  2283→ */\n  2284→function applyPresetAndUpdateUI(presetId) {\n  2285→  const preset = getPresetById(presetId);\n  2286→  if (!preset) return;\n  2287→\n  2288→  // For custom presets, apply the settings\n  2289→  if (!preset.isBuiltIn) {\n  2290→    const settings = preset.settings;\n  2291→    if (settings) {\n  2292→      // Update sensitivity slider\n  2293→      if (ui.sensitivitySlider && settings.sensitivity !== undefined) {\n  2294→        ui.sensitivitySlider.value = settings.sensitivity;\n  2295→      }\n  2296→\n  2297→      // Update takes detection checkbox\n  2298→      if (ui.enableTakesDetection && settings.enableTakesDetection !== undefined) {\n  2299→        ui.enableTakesDetection.checked = settings.enableTakesDetection;\n  2300→      }\n  2301→\n  2302→      // Update auto-mark best checkbox\n  2303→      if (ui.autoMarkBest && settings.autoMarkBest !== undefined) {\n  2304→        ui.autoMarkBest.checked = settings.autoMarkBest;\n  2305→      }\n  2306→\n  2307→      // Save as active preset\n  2308→      saveSettings({ activePreset: presetId, ...settings });\n  2309→    }\n  2310→  } else {\n  2311→    // Built-in preset: use applyPreset from settings.js\n  2312→    const appliedSettings = applyPreset(presetId);\n  2313→\n  2314→    // Update sensitivity slider to match preset\n  2315→    if (ui.sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n  2316→      ui.sensitivitySlider.value = appliedSettings.sensitivity;\n  2317→    }\n  2318→\n  2319→    // Update takes detection checkbox\n  2320→    if (ui.enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n  2321→      ui.enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n  2322→    }\n  2323→\n  2324→    // Update auto-mark best checkbox\n  2325→    if (ui.autoMarkBest && appliedSettings.autoMarkBest !== undefined) {\n  2326→      ui.autoMarkBest.checked = appliedSettings.autoMarkBest;\n  2327→    }\n  2328→  }\n  2329→\n  2330→  setStatus(`Applied preset: ${preset.name}`);\n  2331→}\n  2332→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3bebefc6-a57e-438f-a0c2-118f1cf23e63","timestamp":"2025-12-25T23:26:32.931Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-plugin/js/main.js","content":"/**\n * SPLICE Plugin Main Entry Point\n *\n * Initializes all functionality when the plugin loads.\n * v3.4 - Timeline Markers + Unified Take-Aware Workflow.\n */\n\n// Initialize Premiere Pro API\nconst ppro = require('premierepro');\n\n// ============================================================================\n// CACHED DOM ELEMENTS (Performance: avoid repeated getElementById calls)\n// ============================================================================\nconst ui = {};\n\nfunction cacheUIElements() {\n  ui.status = document.getElementById('status');\n\n  // Main GO button (unified workflow)\n  ui.goBtn = document.getElementById('goBtn');\n  ui.optionsToggle = document.getElementById('optionsToggle');\n  ui.optionsPanel = document.getElementById('optionsPanel');\n\n  // Sliders and options\n  ui.sensitivitySlider = document.getElementById('sensitivitySlider');\n  ui.sourceOriginal = document.getElementById('sourceOriginal');\n  ui.sourceIsolated = document.getElementById('sourceIsolated');\n\n  // Settings checkboxes\n  ui.enableTakesDetection = document.getElementById('enableTakesDetection');\n  ui.autoMarkBest = document.getElementById('autoMarkBest');\n\n  // Progress\n  ui.progressContainer = document.getElementById('progressContainer');\n  ui.progressText = document.getElementById('progressText');\n  ui.resultsEmpty = document.getElementById('resultsEmpty');\n\n  // Combined Preview\n  ui.combinedPreview = document.getElementById('combinedPreview');\n  ui.previewList = document.getElementById('previewList');\n  ui.silenceCountDisplay = document.getElementById('silenceCount');\n  ui.takeCountDisplay = document.getElementById('takeCount');\n  ui.selectedCount = document.getElementById('selectedCount');\n  ui.selectAllSilences = document.getElementById('selectAllSilences');\n  ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');\n  ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');\n  ui.invertSelectionBtn = document.getElementById('invertSelectionBtn');\n  ui.reRunDetectionBtn = document.getElementById('reRunDetectionBtn');\n\n  // Results\n  ui.silenceResults = document.getElementById('silenceResults');\n  ui.resultsCount = document.getElementById('resultsCount');\n  ui.timeSaved = document.getElementById('timeSaved');\n  ui.clipsModified = document.getElementById('clipsModified');\n\n  // Build Sequence button (v3.5)\n  ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');\n\n  // Buttons\n  ui.undoBtn = document.getElementById('undoBtn');\n  ui.advancedSection = document.getElementById('advancedSection');\n\n  // Settings modal\n  ui.settingsBtn = document.getElementById('settingsBtn');\n  ui.settingsModal = document.getElementById('settingsModal');\n  ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');\n\n  // Media folder (v3.5)\n  ui.mediaFolderDisplay = document.getElementById('mediaFolderDisplay');\n  ui.setMediaFolderBtn = document.getElementById('setMediaFolderBtn');\n  ui.clearMediaFolderBtn = document.getElementById('clearMediaFolderBtn');\n\n  // Custom Presets (v3.5)\n  ui.savePresetBtn = document.getElementById('savePresetBtn');\n  ui.managePresetsBtn = document.getElementById('managePresetsBtn');\n  ui.presetModal = document.getElementById('presetModal');\n  ui.presetModalTitle = document.getElementById('presetModalTitle');\n  ui.closePresetModalBtn = document.getElementById('closePresetModalBtn');\n  ui.presetNameInput = document.getElementById('presetNameInput');\n  ui.presetDescInput = document.getElementById('presetDescInput');\n  ui.presetIconPicker = document.getElementById('presetIconPicker');\n  ui.presetEditId = document.getElementById('presetEditId');\n  ui.presetSelectedIcon = document.getElementById('presetSelectedIcon');\n  ui.savePresetConfirmBtn = document.getElementById('savePresetConfirmBtn');\n  ui.presetModalError = document.getElementById('presetModalError');\n  ui.managePresetsModal = document.getElementById('managePresetsModal');\n  ui.closeManagePresetsBtn = document.getElementById('closeManagePresetsBtn');\n  ui.presetsList = document.getElementById('presetsList');\n  ui.noCustomPresets = document.getElementById('noCustomPresets');\n  ui.presetSelector = document.getElementById('presetSelector');\n\n  // Preset settings inputs (Phase 3)\n  ui.presetSensitivity = document.getElementById('presetSensitivity');\n  ui.presetSensitivityValue = document.getElementById('presetSensitivityValue');\n  ui.presetThreshold = document.getElementById('presetThreshold');\n\n  // Export/Import buttons (Phase 3)\n  ui.exportPresetsBtn = document.getElementById('exportPresetsBtn');\n  ui.importPresetsBtn = document.getElementById('importPresetsBtn');\n  ui.importPresetsFile = document.getElementById('importPresetsFile');\n}\n\n// ============================================================================\n// STATE MANAGEMENT\n// ============================================================================\nlet previewSilences = [];         // All detected silences\nlet safeSilences = [];            // Silences that don't overlap takes (safe to remove)\nlet protectedSilences = [];       // Silences that overlap takes (protected)\nlet previewTakes = [];            // Detected takes (for display)\nlet selectedSilenceIndices = new Set();\nlet isOperationInProgress = false;\nlet pendingUIUpdate = null;\n\n// Export preview state for other modules (Razor integration)\nwindow.splicePreviewState = {\n  getSelectedSilences: () => safeSilences.filter((_, i) => selectedSilenceIndices.has(i)),\n  getSelectedTakes: () => previewTakes,\n  hasPreview: () => safeSilences.length > 0 || previewTakes.length > 0\n};\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\ndocument.addEventListener('DOMContentLoaded', () => {\n  // Cache all DOM elements first\n  cacheUIElements();\n\n  // Settings & UI\n  initSettingsUI();\n  initSettingsModal();\n  initLoginModal();\n  initOptionsToggles();\n  initPresetSelector();\n  initHelpButton();\n\n  // Credits display\n  initCredits();\n\n  // Unified workflow (silences + takes)\n  initUnifiedWorkflow();\n\n  // Preview handlers (event delegation)\n  initPreviewHandlers();\n\n  // Undo handlers\n  initUndoHandlers();\n\n  // Keyboard shortcuts\n  initKeyboardShortcuts();\n\n  // Advanced features (Razor - legacy)\n  initSlice9();\n\n  // Batch processing\n  initBatchHandlers();\n\n  // Media folder (v3.5)\n  initMediaFolderHandlers();\n\n  // Custom Presets UI (v3.5)\n  initCustomPresetsUI();\n\n  console.log('[SPLICE] Plugin initialized v3.5 (Direct DOM Reconstruction)');\n});\n\n// ============================================================================\n// DEBOUNCED UI UPDATES (Performance: batch DOM updates)\n// ============================================================================\nfunction scheduleUIUpdate(callback) {\n  if (pendingUIUpdate) {\n    cancelAnimationFrame(pendingUIUpdate);\n  }\n  pendingUIUpdate = requestAnimationFrame(() => {\n    callback();\n    pendingUIUpdate = null;\n  });\n}\n\nfunction updateSelectionCounts() {\n  scheduleUIUpdate(() => {\n    if (ui.selectedCount) {\n      ui.selectedCount.textContent = selectedSilenceIndices.size;\n    }\n    updateApplyButton();\n    updateSelectAllCheckbox();\n  });\n}\n\n// ============================================================================\n// KEYBOARD SHORTCUTS\n// ============================================================================\nfunction initKeyboardShortcuts() {\n  document.addEventListener('keydown', (e) => {\n    // Only handle when combined preview is visible\n    const previewVisible = ui.combinedPreview?.style.display !== 'none' &&\n                           ui.combinedPreview?.style.display !== '';\n\n    if (!previewVisible) return;\n\n    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;\n    const cmdKey = isMac ? e.metaKey : e.ctrlKey;\n\n    // Enter - Apply selected\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      if (selectedSilenceIndices.size > 0) {\n        ui.applyPreviewBtn?.click();\n      }\n    }\n\n    // Escape - Cancel\n    if (e.key === 'Escape') {\n      e.preventDefault();\n      ui.cancelPreviewBtn?.click();\n    }\n\n    // Cmd/Ctrl+A - Select all\n    if (e.key === 'a' && cmdKey) {\n      e.preventDefault();\n      if (ui.selectAllSilences) {\n        ui.selectAllSilences.checked = true;\n        selectAllSilences(true);\n      }\n    }\n\n    // Cmd/Ctrl+D - Deselect all\n    if (e.key === 'd' && cmdKey) {\n      e.preventDefault();\n      if (ui.selectAllSilences) {\n        ui.selectAllSilences.checked = false;\n        selectAllSilences(false);\n      }\n    }\n\n    // Cmd/Ctrl+I - Invert selection\n    if (e.key === 'i' && cmdKey) {\n      e.preventDefault();\n      invertSilenceSelection();\n    }\n  });\n}\n\n// ============================================================================\n// UNIFIED WORKFLOW (Silence Detection + Takes Detection)\n// ============================================================================\nfunction initUnifiedWorkflow() {\n  if (!ui.goBtn) return;\n\n  ui.goBtn.addEventListener('click', async () => {\n    // Prevent double-click\n    if (isOperationInProgress) {\n      setStatus('Operation in progress...');\n      return;\n    }\n\n    isOperationInProgress = true;\n    ui.goBtn.disabled = true;\n\n    try {\n      showProgress('Preparing audio...');\n\n      // Step 1: Export audio\n      const exportSuccess = await exportAudioInternal();\n      if (!exportSuccess) {\n        throw new Error('Audio export failed');\n      }\n\n      // Step 2: Get settings\n      const sensitivity = parseInt(ui.sensitivitySlider?.value || 50);\n      const useIsolated = ui.sourceIsolated?.checked ?? false;\n      const detectTakes = ui.enableTakesDetection?.checked ?? true;\n\n      // Step 3: Vocal isolation if needed\n      let audioPath = WAV_PATH;\n      if (useIsolated) {\n        // Check isolation access before proceeding\n        const credits = getCurrentCredits();\n        if (!credits || !credits.hasIsolationAccess) {\n          throw new Error('Vocal isolation requires Pro or Team tier. Upgrade to access this feature.');\n        }\n\n        // Show overage warning if applicable\n        const isolationMins = credits.isolationHoursRemaining * 60;\n        if (isolationMins <= 0) {\n          const overageRate = credits.isolationOverageRate || 0.08;\n          showProgress(`Isolating vocals (overage: $${overageRate}/min)...`);\n        } else {\n          showProgress(`Isolating vocals (${isolationMins.toFixed(0)} min remaining)...`);\n        }\n\n        const isolateResult = await isolateVocals();\n        if (isolateResult.success) {\n          audioPath = isolateResult.outputPath;\n          // Update credits display after isolation\n          await refreshCredits();\n        } else {\n          throw new Error(isolateResult.error || 'Vocal isolation failed');\n        }\n      }\n\n      // Step 4: Run detection (parallel if takes enabled)\n      const params = mapSensitivity(sensitivity);\n      let silences = [];\n      let takes = [];\n\n      if (detectTakes) {\n        // Parallel detection for performance\n        showProgress('Detecting silences and analyzing takes...');\n        const [silenceResult, transcriptResult] = await Promise.all([\n          detectSilences(audioPath, params),\n          transcribeAudio()\n        ]);\n\n        silences = silenceResult;\n\n        // Extract takes from transcript result\n        if (transcriptResult.success && transcriptResult.takes) {\n          if (transcriptResult.takes.takes) {\n            takes = transcriptResult.takes.takes;\n          } else if (Array.isArray(transcriptResult.takes)) {\n            takes = transcriptResult.takes;\n          }\n        }\n\n        // Store transcript for reference\n        window.currentTranscript = transcriptResult.transcript;\n      } else {\n        // Just detect silences\n        showProgress('Detecting silences...');\n        silences = await detectSilences(audioPath, params);\n      }\n\n      if (silences.length === 0) {\n        showEmptyState();\n        setStatus('No silences detected. Try increasing sensitivity.');\n        return;\n      }\n\n      // Step 5: Filter silences by takes (protect speech)\n      const filtered = filterSilencesByTakes(silences, takes);\n\n      // Step 6: Add timeline markers (clear old ones first)\n      showProgress('Adding timeline markers...');\n      await clearSpliceMarkers();\n      const markerResult = await addTimelineMarkers(filtered.safe, filtered.protected, takes);\n\n      // Step 7: Show combined preview\n      showCombinedPreview(filtered.safe, filtered.protected, takes);\n\n      const markerInfo = markerResult.added > 0 ? ` (${markerResult.added} markers added)` : '';\n      const statusMsg = takes.length > 0\n        ? `Found ${silences.length} silences, ${filtered.protected.length} protected by ${takes.length} takes${markerInfo}`\n        : `Found ${silences.length} silence(s) - review and apply${markerInfo}`;\n      setStatus(statusMsg);\n\n    } catch (err) {\n      showEmptyState();\n      setStatus('Error: ' + err.message);\n      console.error('[SPLICE] Unified workflow error:', err);\n    } finally {\n      isOperationInProgress = false;\n      ui.goBtn.disabled = false;\n    }\n  });\n}\n\n// ============================================================================\n// TAKE-AWARE SILENCE FILTERING\n// ============================================================================\n/**\n * Filter silences to protect those that overlap with takes (speech segments).\n * Returns { safe: [], protected: [] }\n */\nfunction filterSilencesByTakes(silences, takes) {\n  if (!takes || takes.length === 0) {\n    // No takes = all silences are safe to remove\n    return { safe: silences, protected: [] };\n  }\n\n  const safe = [];\n  const protected_ = [];\n\n  silences.forEach(silence => {\n    // Check if this silence overlaps with any take\n    const overlaps = takes.some(take => {\n      const takeStart = take.startTime || take.start;\n      const takeEnd = take.endTime || take.end;\n      // Overlap exists if silence starts before take ends AND silence ends after take starts\n      return silence.start < takeEnd && silence.end > takeStart;\n    });\n\n    if (overlaps) {\n      protected_.push(silence);\n    } else {\n      safe.push(silence);\n    }\n  });\n\n  console.log(`[SPLICE] Filtered silences: ${safe.length} safe, ${protected_.length} protected`);\n  return { safe, protected: protected_ };\n}\n\n// ============================================================================\n// TIMELINE MARKERS (Visual indicators on Premiere Pro timeline)\n// ============================================================================\n/**\n * Add colored markers to the timeline for silences and takes.\n * - Red markers: silences safe to remove\n * - Yellow markers: silences protected by takes\n * - Blue markers: takes (speech segments)\n *\n * @param {Array} safeToRemove - Silences safe to remove\n * @param {Array} protectedSilences - Silences overlapping speech\n * @param {Array} takes - Detected speech segments\n * @returns {Promise<{added: number, errors: number}>}\n */\nasync function addTimelineMarkers(safeToRemove, protectedSilences, takes) {\n  const results = { added: 0, errors: 0 };\n\n  try {\n    const context = await getActiveSequence();\n    if (!context) {\n      console.warn('[SPLICE] No sequence available for markers');\n      return results;\n    }\n\n    const { sequence, project } = context;\n\n    // Get markers object for the sequence\n    const markers = await ppro.Markers.getMarkers(sequence);\n    if (!markers) {\n      console.warn('[SPLICE] Markers API not available');\n      return results;\n    }\n\n    // Collect all marker actions\n    const markerActions = [];\n\n    // Red markers for safe-to-remove silences\n    for (const silence of safeToRemove) {\n      try {\n        const duration = silence.end - silence.start;\n\n        // Use TickTime API directly (no TICKS_PER_SECOND needed)\n        const startTime = ppro.TickTime.createWithSeconds(silence.start);\n        const durationTime = ppro.TickTime.createWithSeconds(duration);\n\n        const action = markers.createAddMarkerAction(\n          `SPLICE: Remove (${duration.toFixed(2)}s)`,\n          ppro.Marker.MARKER_TYPE_COMMENT,\n          startTime,\n          durationTime,\n          `Silence to remove: ${formatTime(silence.start)} - ${formatTime(silence.end)}`\n        );\n        markerActions.push({ action, colorIndex: 1, type: 'silence' }); // Red = index 1\n      } catch (err) {\n        console.error('[SPLICE] Error creating silence marker:', err);\n        results.errors++;\n      }\n    }\n\n    // Yellow markers for protected silences\n    for (const silence of protectedSilences) {\n      try {\n        const duration = silence.end - silence.start;\n\n        // Use TickTime API directly (no TICKS_PER_SECOND needed)\n        const startTime = ppro.TickTime.createWithSeconds(silence.start);\n        const durationTime = ppro.TickTime.createWithSeconds(duration);\n\n        const action = markers.createAddMarkerAction(\n          `SPLICE: Protected (${duration.toFixed(2)}s)`,\n          ppro.Marker.MARKER_TYPE_COMMENT,\n          startTime,\n          durationTime,\n          `Protected silence (overlaps speech): ${formatTime(silence.start)} - ${formatTime(silence.end)}`\n        );\n        markerActions.push({ action, colorIndex: 4, type: 'protected' }); // Yellow = index 4\n      } catch (err) {\n        console.error('[SPLICE] Error creating protected marker:', err);\n        results.errors++;\n      }\n    }\n\n    // Blue markers for takes (speech segments)\n    for (const take of takes) {\n      try {\n        const start = take.startTime || take.start;\n        const end = take.endTime || take.end;\n        const duration = end - start;\n        const textPreview = take.text?.substring(0, 30) || 'Speech';\n\n        // Use TickTime API directly (no TICKS_PER_SECOND needed)\n        const startTime = ppro.TickTime.createWithSeconds(start);\n        const durationTime = ppro.TickTime.createWithSeconds(duration);\n\n        const action = markers.createAddMarkerAction(\n          `SPLICE: Take`,\n          ppro.Marker.MARKER_TYPE_COMMENT,\n          startTime,\n          durationTime,\n          `Speech segment: ${textPreview}${take.text?.length > 30 ? '...' : ''}`\n        );\n        markerActions.push({ action, colorIndex: 5, type: 'take' }); // Blue = index 5\n      } catch (err) {\n        console.error('[SPLICE] Error creating take marker:', err);\n        results.errors++;\n      }\n    }\n\n    // Execute all marker actions in a single transaction\n    if (markerActions.length > 0) {\n      await project.lockedAccess(async () => {\n        await project.executeTransaction((compoundAction) => {\n          for (const { action } of markerActions) {\n            compoundAction.addAction(action);\n          }\n        }, 'SPLICE: Add Timeline Markers');\n      });\n\n      results.added = markerActions.length;\n      console.log(`[SPLICE] Added ${results.added} timeline markers`);\n    }\n\n  } catch (err) {\n    console.error('[SPLICE] Timeline markers error:', err);\n    results.errors++;\n  }\n\n  return results;\n}\n\n/**\n * Read current SPLICE marker positions from timeline.\n * This allows users to manually adjust markers before applying.\n * Returns silences based on current marker positions (not original detection).\n */\nasync function readMarkersAssilences() {\n  const silences = [];\n\n  try {\n    const context = await getActiveSequence();\n    if (!context) return silences;\n\n    const { sequence } = context;\n    const markers = await ppro.Markers.getMarkers(sequence);\n    if (!markers) return silences;\n\n    const allMarkers = await markers.getMarkers();\n    if (!allMarkers || allMarkers.length === 0) return silences;\n\n    for (const marker of allMarkers) {\n      const name = await marker.getName();\n\n      // Only read \"Remove\" markers (red ones that will be cut)\n      if (name && name.startsWith('SPLICE: Remove')) {\n        const startTickTime = await marker.getStart();\n        const durationTickTime = await marker.getDuration();\n\n        // Use TickTime.seconds property to get seconds directly (no TICKS_PER_SECOND needed)\n        const start = startTickTime.seconds;\n        const duration = durationTickTime.seconds;\n        const end = start + duration;\n\n        silences.push({\n          start,\n          end,\n          duration,\n          fromMarker: true  // Flag to indicate this came from marker adjustment\n        });\n      }\n    }\n\n    // Sort by start time\n    silences.sort((a, b) => a.start - b.start);\n    console.log(`[SPLICE] Read ${silences.length} silences from adjusted markers`);\n\n  } catch (err) {\n    console.error('[SPLICE] Error reading markers:', err);\n  }\n\n  return silences;\n}\n\n/**\n * Remove all SPLICE markers from the timeline.\n * Call this before adding new markers to avoid duplicates.\n */\nasync function clearSpliceMarkers() {\n  try {\n    const context = await getActiveSequence();\n    if (!context) return 0;\n\n    const { sequence, project } = context;\n    const markers = await ppro.Markers.getMarkers(sequence);\n    if (!markers) return 0;\n\n    // Get all markers\n    const allMarkers = await markers.getMarkers();\n    if (!allMarkers || allMarkers.length === 0) return 0;\n\n    // Filter SPLICE markers\n    const spliceMarkers = [];\n    for (const marker of allMarkers) {\n      const name = await marker.getName();\n      if (name && name.startsWith('SPLICE:')) {\n        spliceMarkers.push(marker);\n      }\n    }\n\n    if (spliceMarkers.length === 0) return 0;\n\n    // Remove all SPLICE markers in a single transaction\n    await project.lockedAccess(async () => {\n      await project.executeTransaction((compoundAction) => {\n        for (const marker of spliceMarkers) {\n          const removeAction = markers.createRemoveMarkerAction(marker);\n          compoundAction.addAction(removeAction);\n        }\n      }, 'SPLICE: Clear Markers');\n    });\n\n    console.log(`[SPLICE] Cleared ${spliceMarkers.length} previous markers`);\n    return spliceMarkers.length;\n\n  } catch (err) {\n    console.error('[SPLICE] Error clearing markers:', err);\n    return 0;\n  }\n}\n\n// ============================================================================\n// COMBINED PREVIEW (Silences + Takes with colored markers)\n// ============================================================================\n/**\n * Show combined preview with:\n * - Red markers: silences safe to remove\n * - Yellow markers: silences protected by takes (won't be removed)\n * - Blue markers: takes (for reference)\n */\nfunction showCombinedPreview(safeToRemove, protectedSilences, takes) {\n  // Update global state\n  safeSilences = safeToRemove;\n  previewSilences = [...safeToRemove, ...protectedSilences];\n  previewTakes = takes;\n  selectedSilenceIndices = new Set(safeToRemove.map((_, i) => i));\n\n  // Hide other views\n  hideAllViews();\n\n  // Update summary counts\n  if (ui.silenceCountDisplay) ui.silenceCountDisplay.textContent = safeToRemove.length;\n  if (ui.takeCountDisplay) ui.takeCountDisplay.textContent = takes.length;\n  if (ui.selectedCount) ui.selectedCount.textContent = safeToRemove.length;\n\n  // Build combined items list (sorted by time)\n  const items = [\n    ...safeToRemove.map((s, i) => ({ type: 'silence', index: i, start: s.start, end: s.end, data: s })),\n    ...protectedSilences.map(s => ({ type: 'protected', start: s.start, end: s.end, data: s })),\n    ...takes.map(t => ({ type: 'take', start: t.startTime || t.start, end: t.endTime || t.end, data: t }))\n  ].sort((a, b) => a.start - b.start);\n\n  // Build preview list using DocumentFragment\n  const fragment = document.createDocumentFragment();\n\n  items.forEach((item) => {\n    const duration = item.end - item.start;\n    const div = document.createElement('div');\n\n    if (item.type === 'silence') {\n      // Safe to remove - red marker with checkbox\n      div.className = 'preview-item silence-marker';\n      div.dataset.index = item.index;\n      div.innerHTML = `\n        <input type=\"checkbox\" class=\"preview-item-check\" checked data-index=\"${item.index}\">\n        <div class=\"preview-item-info\">\n          <div class=\"preview-item-time\">${formatTime(item.start)} - ${formatTime(item.end)}</div>\n          <div class=\"preview-item-duration\">${duration.toFixed(2)}s silence</div>\n        </div>\n        <button class=\"preview-item-seek\" data-time=\"${item.start}\" title=\"Seek to this silence\">&gt;</button>\n      `;\n    } else if (item.type === 'protected') {\n      // Protected by take - yellow marker, no checkbox\n      div.className = 'preview-item protected-silence';\n      div.innerHTML = `\n        <div style=\"width: 20px; margin-right: 10px;\"></div>\n        <div class=\"preview-item-info\">\n          <div class=\"preview-item-time\">${formatTime(item.start)} - ${formatTime(item.end)}</div>\n          <div class=\"preview-item-duration\">${duration.toFixed(2)}s (overlaps speech)</div>\n        </div>\n        <button class=\"preview-item-seek\" data-time=\"${item.start}\" title=\"Seek\">&gt;</button>\n      `;\n    } else if (item.type === 'take') {\n      // Take (speech segment) - blue marker, no checkbox\n      div.className = 'preview-item take-marker';\n      const textPreview = item.data.text?.substring(0, 40) || 'Speech segment';\n      div.innerHTML = `\n        <div style=\"width: 20px; margin-right: 10px;\"></div>\n        <div class=\"preview-item-info\">\n          <div class=\"preview-item-time\">${formatTime(item.start)} - ${formatTime(item.end)}</div>\n          <div class=\"preview-item-duration\">${textPreview}${item.data.text?.length > 40 ? '...' : ''}</div>\n        </div>\n        <button class=\"preview-item-seek\" data-time=\"${item.start}\" title=\"Seek to take\">&gt;</button>\n      `;\n    }\n\n    fragment.appendChild(div);\n  });\n\n  if (ui.previewList) {\n    ui.previewList.textContent = '';\n    ui.previewList.appendChild(fragment);\n  }\n\n  // Reset UI state\n  if (ui.selectAllSilences) ui.selectAllSilences.checked = true;\n  updateApplyButton();\n\n  // Show combined preview section\n  if (ui.combinedPreview) ui.combinedPreview.style.display = 'block';\n}\n\nfunction initPreviewHandlers() {\n  // EVENT DELEGATION: Single listener on parent instead of many on children\n  if (ui.previewList) {\n    // Handle checkbox changes\n    ui.previewList.addEventListener('change', (e) => {\n      if (e.target.classList.contains('preview-item-check')) {\n        const index = parseInt(e.target.dataset.index);\n        const item = e.target.closest('.preview-item');\n\n        if (e.target.checked) {\n          selectedSilenceIndices.add(index);\n          item?.classList.remove('excluded');\n        } else {\n          selectedSilenceIndices.delete(index);\n          item?.classList.add('excluded');\n        }\n        updateSelectionCounts();\n      }\n    });\n\n    // Handle seek button clicks\n    ui.previewList.addEventListener('click', async (e) => {\n      if (e.target.classList.contains('preview-item-seek')) {\n        e.stopPropagation();\n        const btn = e.target;\n        const time = parseFloat(btn.dataset.time);\n\n        // Show loading state\n        btn.classList.add('loading');\n        btn.textContent = '...';\n\n        try {\n          await seekToTime(time);\n        } finally {\n          btn.classList.remove('loading');\n          btn.textContent = '>';\n        }\n      }\n    });\n  }\n\n  // Apply button\n  if (ui.applyPreviewBtn) {\n    ui.applyPreviewBtn.addEventListener('click', async () => {\n      if (isOperationInProgress) return;\n      isOperationInProgress = true;\n      ui.applyPreviewBtn.disabled = true;\n\n      const originalText = ui.applyPreviewBtn.textContent;\n      ui.applyPreviewBtn.textContent = 'Applying...';\n\n      try {\n        await applySelectedSilences();\n      } catch (err) {\n        setStatus('Error: ' + err.message);\n        console.error('[SPLICE] Apply error:', err);\n      } finally {\n        ui.applyPreviewBtn.textContent = originalText;\n        ui.applyPreviewBtn.disabled = false;\n        isOperationInProgress = false;\n      }\n    });\n  }\n\n  // Cancel button\n  if (ui.cancelPreviewBtn) {\n    ui.cancelPreviewBtn.addEventListener('click', async () => {\n      await cancelPreview();\n    });\n  }\n\n  // Select all checkbox\n  if (ui.selectAllSilences) {\n    ui.selectAllSilences.addEventListener('change', (e) => {\n      selectAllSilences(e.target.checked);\n    });\n  }\n\n  // Invert selection button\n  if (ui.invertSelectionBtn) {\n    ui.invertSelectionBtn.addEventListener('click', () => {\n      invertSilenceSelection();\n    });\n  }\n\n  // Duration filter buttons\n  document.querySelectorAll('.preview-filters .filter-btn[data-min]').forEach(btn => {\n    btn.addEventListener('click', () => {\n      const min = parseFloat(btn.dataset.min);\n      const max = parseFloat(btn.dataset.max);\n      selectByDuration(min, max);\n    });\n  });\n\n  // Re-run detection button\n  if (ui.reRunDetectionBtn) {\n    ui.reRunDetectionBtn.addEventListener('click', () => {\n      // Hide preview, show options, let user adjust sensitivity\n      if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';\n      if (ui.optionsPanel) ui.optionsPanel.classList.remove('collapsed');\n      if (ui.optionsToggle) ui.optionsToggle.classList.add('expanded');\n      showEmptyState();\n      setStatus('Adjust sensitivity and click GO again');\n    });\n  }\n\n  // Build Sequence button (v3.5 - direct DOM reconstruction)\n  if (ui.buildSequenceBtn) {\n    ui.buildSequenceBtn.addEventListener('click', async () => {\n      if (isOperationInProgress) return;\n\n      // Check if we have detection data\n      if (safeSilences.length === 0 && previewTakes.length === 0) {\n        setStatus('No detection data. Run analysis first.');\n        return;\n      }\n\n      isOperationInProgress = true;\n      ui.buildSequenceBtn.disabled = true;\n      const originalText = ui.buildSequenceBtn.textContent;\n      ui.buildSequenceBtn.textContent = 'Building...';\n\n      try {\n        showProgress('Building new sequence...');\n\n        const result = await buildSequenceWithCutList();\n\n        if (result.success) {\n          // Hide preview and show success\n          if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';\n          showEmptyState();\n\n          const metadata = result.metadata || {};\n          setStatus(`New sequence created: ${metadata.silencesRemoved || 0} silences removed, ${metadata.takesDetected || 0} takes detected`);\n\n          // Clear markers after successful build\n          await clearSpliceMarkers();\n\n          // Clear preview state\n          previewSilences = [];\n          safeSilences = [];\n          protectedSilences = [];\n          previewTakes = [];\n          selectedSilenceIndices.clear();\n        } else {\n          // User-friendly error messages\n          const errorMsg = result.error || 'Unknown error';\n          setStatus('Build failed: ' + formatBuildError(errorMsg));\n        }\n\n      } catch (err) {\n        console.error('[SPLICE] Build sequence error:', err);\n        // User-friendly error messages with recovery hints\n        setStatus('Build error: ' + formatBuildError(err.message));\n      } finally {\n        ui.buildSequenceBtn.textContent = originalText;\n        ui.buildSequenceBtn.disabled = false;\n        isOperationInProgress = false;\n      }\n    });\n  }\n}\n\nfunction selectAllSilences(checked) {\n  selectedSilenceIndices.clear();\n\n  if (checked) {\n    safeSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n  }\n\n  // Batch update DOM (only silence-marker items have checkboxes)\n  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {\n    const index = parseInt(checkbox.dataset.index);\n    checkbox.checked = checked;\n    const item = checkbox.closest('.preview-item');\n    if (checked) {\n      item?.classList.remove('excluded');\n    } else {\n      item?.classList.add('excluded');\n    }\n  });\n\n  updateSelectionCounts();\n}\n\nfunction invertSilenceSelection() {\n  const allIndices = new Set(safeSilences.map((_, i) => i));\n  const newSelection = new Set([...allIndices].filter(i => !selectedSilenceIndices.has(i)));\n  selectedSilenceIndices = newSelection;\n\n  // Update DOM\n  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {\n    const index = parseInt(checkbox.dataset.index);\n    const isSelected = selectedSilenceIndices.has(index);\n    checkbox.checked = isSelected;\n    const item = checkbox.closest('.preview-item');\n    if (isSelected) {\n      item?.classList.remove('excluded');\n    } else {\n      item?.classList.add('excluded');\n    }\n  });\n\n  updateSelectionCounts();\n}\n\nfunction selectByDuration(minSec, maxSec) {\n  selectedSilenceIndices.clear();\n\n  safeSilences.forEach((silence, index) => {\n    const duration = silence.end - silence.start;\n    if (duration >= minSec && duration < maxSec) {\n      selectedSilenceIndices.add(index);\n    }\n  });\n\n  // Update DOM\n  document.querySelectorAll('.preview-item.silence-marker .preview-item-check').forEach((checkbox) => {\n    const index = parseInt(checkbox.dataset.index);\n    const isSelected = selectedSilenceIndices.has(index);\n    checkbox.checked = isSelected;\n    const item = checkbox.closest('.preview-item');\n    if (isSelected) {\n      item?.classList.remove('excluded');\n    } else {\n      item?.classList.add('excluded');\n    }\n  });\n\n  updateSelectionCounts();\n  setStatus(`Selected ${selectedSilenceIndices.size} silences (${minSec}s - ${maxSec}s)`);\n}\n\nasync function cancelPreview() {\n  // Keep silences available for Razor if detected\n  const hadSilences = safeSilences.length > 0;\n\n  previewSilences = [];\n  safeSilences = [];\n  protectedSilences = [];\n  previewTakes = [];\n  selectedSilenceIndices.clear();\n  showEmptyState();\n\n  // Clear timeline markers\n  const cleared = await clearSpliceMarkers();\n  const markerInfo = cleared > 0 ? ` (${cleared} markers removed)` : '';\n  setStatus('Preview cancelled' + markerInfo);\n\n  // Show Razor section if silences were detected\n  if (hadSilences && ui.advancedSection) {\n    ui.advancedSection.classList.remove('hidden');\n  }\n}\n\nasync function applySelectedSilences() {\n  if (selectedSilenceIndices.size === 0) {\n    setStatus('No silences selected');\n    return;\n  }\n\n  showProgress('Reading marker positions...');\n\n  // Read current marker positions from timeline\n  // This allows users to manually adjust markers before applying\n  const markerSilences = await readMarkersAssilences();\n\n  let silencesToApply;\n  let adjustedCount = 0;\n\n  if (markerSilences.length > 0) {\n    // Use marker positions (may have been adjusted by user)\n    silencesToApply = markerSilences;\n    adjustedCount = markerSilences.length;\n    console.log(`[SPLICE] Using ${adjustedCount} silences from adjusted markers`);\n  } else {\n    // Fallback to original detection data\n    silencesToApply = safeSilences.filter((_, i) => selectedSilenceIndices.has(i));\n    console.log(`[SPLICE] Using ${silencesToApply.length} silences from original detection`);\n  }\n\n  if (silencesToApply.length === 0) {\n    setStatus('No silences to apply');\n    return;\n  }\n\n  // Update global silences for the apply function\n  setCurrentSilences(silencesToApply);\n\n  showProgress('Applying changes...');\n\n  // Apply to timeline\n  const result = await removeSilencesFromTimeline();\n\n  // Clear markers after applying\n  await clearSpliceMarkers();\n\n  // Hide preview\n  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';\n\n  // Show results\n  showSilenceResults({\n    count: silencesToApply.length,\n    timeSaved: silencesToApply.reduce((sum, s) => sum + (s.end - s.start), 0),\n    clipsModified: result\n  });\n\n  // Show advanced section\n  if (ui.advancedSection) ui.advancedSection.classList.remove('hidden');\n\n  const adjustedInfo = adjustedCount > 0 ? ' (from adjusted markers)' : '';\n  setStatus(`Removed ${silencesToApply.length} silence(s) - ${result} clip(s) modified${adjustedInfo}`);\n\n  // Refresh credits (await to prevent race conditions)\n  try {\n    await refreshCredits();\n  } catch (err) {\n    console.warn('[SPLICE] Credits refresh failed:', err);\n  }\n\n  // Clear preview state\n  previewSilences = [];\n  safeSilences = [];\n  protectedSilences = [];\n  previewTakes = [];\n  selectedSilenceIndices.clear();\n}\n\n// ============================================================================\n// UI HELPERS\n// ============================================================================\nfunction updateApplyButton() {\n  if (ui.applyPreviewBtn) {\n    const count = selectedSilenceIndices.size;\n    ui.applyPreviewBtn.disabled = count === 0;\n    ui.applyPreviewBtn.textContent = count === 0 ? 'Select silences' : `Apply ${count} Selected`;\n  }\n}\n\nfunction updateSelectAllCheckbox() {\n  if (ui.selectAllSilences) {\n    ui.selectAllSilences.checked = selectedSilenceIndices.size === safeSilences.length && safeSilences.length > 0;\n  }\n}\n\nfunction hideAllViews() {\n  if (ui.progressContainer) ui.progressContainer.style.display = 'none';\n  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'none';\n  if (ui.silenceResults) ui.silenceResults.style.display = 'none';\n  if (ui.combinedPreview) ui.combinedPreview.style.display = 'none';\n}\n\nfunction showProgress(message) {\n  hideAllViews();\n  if (ui.progressContainer) ui.progressContainer.style.display = 'block';\n  if (ui.progressText) ui.progressText.textContent = message;\n}\n\nfunction showEmptyState() {\n  hideAllViews();\n  if (ui.resultsEmpty) ui.resultsEmpty.style.display = 'block';\n  if (ui.advancedSection) ui.advancedSection.classList.add('hidden');\n}\n\nfunction showSilenceResults({ count, timeSaved, clipsModified }) {\n  hideAllViews();\n\n  // Update the results display\n  if (ui.resultsCount) ui.resultsCount.textContent = count;\n  if (ui.timeSaved) ui.timeSaved.textContent = timeSaved.toFixed(1) + 's';\n  if (ui.clipsModified) ui.clipsModified.textContent = clipsModified;\n\n  if (ui.silenceResults) ui.silenceResults.style.display = 'block';\n}\n\nfunction formatTime(seconds) {\n  if (typeof seconds !== 'number' || isNaN(seconds)) return '0:00';\n  const mins = Math.floor(seconds / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Format build errors into user-friendly messages\n * @param {string} error - Raw error message\n * @returns {string} User-friendly error message\n */\nfunction formatBuildError(error) {\n  if (!error) return 'Unknown error occurred';\n\n  // Map technical errors to user-friendly messages\n  const errorMap = {\n    'Builder not initialized': 'Builder module failed to load. Try restarting the plugin.',\n    'No active project': 'No project is open. Please open or create a project first.',\n    'No media items found': 'No media files in project. Import media before building.',\n    'No detection data': 'Run analysis first (click GO button).',\n    'Failed to generate cut list': 'Server error generating cuts. Check your connection.',\n    'Failed to build sequence': 'Premiere Pro sequence build failed. Try again.',\n    'fetch failed': 'Network error. Check if backend server is running.',\n    'NetworkError': 'Cannot connect to server. Check your internet connection.',\n    'Insufficient credits': 'Out of credits. Upgrade your plan to continue.',\n    'Authentication required': 'Login required. Click the credits badge to log in.'\n  };\n\n  // Check for matching error patterns\n  for (const [pattern, friendly] of Object.entries(errorMap)) {\n    if (error.includes(pattern)) {\n      return friendly;\n    }\n  }\n\n  // Return original if no match (already reasonably clear)\n  return error;\n}\n\nfunction setStatus(message) {\n  if (ui.status) ui.status.textContent = message;\n}\n\n// ============================================================================\n// UNDO HANDLERS\n// ============================================================================\nfunction initUndoHandlers() {\n  if (ui.undoBtn) {\n    ui.undoBtn.addEventListener('click', () => {\n      try {\n        ppro.app.executeCommand('Edit.Undo');\n        showEmptyState();\n        setStatus('Changes undone');\n      } catch (e) {\n        setStatus('Undo failed - use Cmd+Z');\n      }\n    });\n  }\n}\n\n// ============================================================================\n// MEDIA FOLDER HANDLERS (v3.5)\n// ============================================================================\nfunction initMediaFolderHandlers() {\n  // Update display on load\n  updateMediaFolderDisplay();\n\n  // Set media folder button\n  if (ui.setMediaFolderBtn) {\n    ui.setMediaFolderBtn.addEventListener('click', async () => {\n      ui.setMediaFolderBtn.disabled = true;\n      ui.setMediaFolderBtn.textContent = 'Selecting...';\n\n      try {\n        const result = await setupMediaFolder();\n        if (result.success) {\n          updateMediaFolderDisplay();\n          setStatus(`Media folder set: ${result.path}`);\n        } else {\n          setStatus(result.error || 'Failed to set media folder');\n        }\n      } catch (err) {\n        setStatus('Error: ' + err.message);\n      } finally {\n        ui.setMediaFolderBtn.disabled = false;\n        ui.setMediaFolderBtn.textContent = 'Set Folder';\n      }\n    });\n  }\n\n  // Clear media folder button\n  if (ui.clearMediaFolderBtn) {\n    ui.clearMediaFolderBtn.addEventListener('click', () => {\n      clearMediaFolder();\n      updateMediaFolderDisplay();\n      setStatus('Media folder cleared');\n    });\n  }\n}\n\nfunction updateMediaFolderDisplay() {\n  if (ui.mediaFolderDisplay) {\n    const path = getMediaFolderPath();\n    if (path) {\n      // Truncate long paths for display\n      const displayPath = path.length > 40\n        ? '...' + path.slice(-37)\n        : path;\n      ui.mediaFolderDisplay.textContent = displayPath;\n      ui.mediaFolderDisplay.title = path; // Full path on hover\n      ui.mediaFolderDisplay.style.color = '#4a9eff';\n    } else {\n      ui.mediaFolderDisplay.textContent = 'Not configured';\n      ui.mediaFolderDisplay.title = '';\n      ui.mediaFolderDisplay.style.color = '#888';\n    }\n  }\n}\n\n// ============================================================================\n// BUILD SEQUENCE (v3.5 - Direct DOM Reconstruction)\n// ============================================================================\n\n// 1. ROBUST CONSTANTS (Fixes 'undefined' error)\n// We define these integers explicitly because UXP API versions vary on where they store Enums.\nconst ProjectItemType = {\n    CLIP: 1,\n    BIN: 2,\n    ROOT: 3,\n    FILE: 4\n};\n\n/**\n * Find the first media item in the project bin (recursively)\n * @param {Object} item - ProjectItem (usually rootItem)\n * @returns {Promise<Object|null>} First media item found or null\n */\nasync function findFirstMediaItem(item) {\n  if (!item) return null;\n\n  // Fix: Use local Constant instead of app.Constants.ProjectItemType\n  if (item.type === ProjectItemType.CLIP) {\n    return item;\n  }\n\n  // Search Children (Bin or Root)\n  // Note: item.children is a collection, check numItems\n  if (item.children && item.children.numItems > 0) {\n    for (let i = 0; i < item.children.numItems; i++) {\n      const child = item.children[i];\n      const found = await findFirstMediaItem(child);\n      if (found) return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Build a sequence from detection data locally\n * Used for testing via console: await buildSequenceV35(silences)\n */\nasync function buildSequenceV35(silences, takes = []) {\n    if (!window.spliceBuilder) {\n        throw new Error('Builder not initialized. Check if builder.js is loaded.');\n    }\n\n    const app = require('premierepro');\n    const project = await app.Project.getActiveProject();\n    if (!project) throw new Error(\"No active project found.\");\n\n    const rootItem = await project.getRootItem();\n    const sourceProjectItem = await findFirstMediaItem(rootItem);\n\n    if (!sourceProjectItem) {\n        throw new Error('No media items found in project bin.');\n    }\n\n    console.log(`[SPLICE] Found source media: ${sourceProjectItem.name}`);\n\n    return await window.spliceBuilder.buildSequenceFromDetection(silences, takes, sourceProjectItem);\n}\n\n/**\n * Request a cut list from the backend and build the sequence.\n * Full v3.5 workflow.\n */\nasync function buildSequenceWithCutList() {\n  if (!window.spliceBuilder) {\n    throw new Error('Builder not initialized');\n  }\n\n  // Ensure BACKEND_URL is available\n  const apiUrl = (typeof BACKEND_URL !== 'undefined') ? BACKEND_URL : 'http://localhost:3000';\n\n  if (typeof showProgress === 'function') showProgress('Getting source clip info...');\n\n  const app = require('premierepro');\n  const project = await app.Project.getActiveProject();\n  if (!project) throw new Error(\"No active project.\");\n\n  const rootItem = await project.getRootItem();\n  const sourceProjectItem = await findFirstMediaItem(rootItem);\n\n  if (!sourceProjectItem) {\n    throw new Error('No media items found in project. Please import a media file first.');\n  }\n\n  // Use properties strictly\n  const sourceName = sourceProjectItem.name;\n  const sourcePath = sourceProjectItem.treePath;\n\n  const durationObj = await sourceProjectItem.getDuration();\n  const duration = durationObj ? durationObj.seconds : 0;\n\n  // Retrieve Globals\n  const silences = window.splicePreviewState?.getSelectedSilences() || (typeof safeSilences !== 'undefined' ? safeSilences : []);\n  const takes = (typeof previewTakes !== 'undefined' ? previewTakes : []);\n\n  if (silences.length === 0 && (!takes || takes.length === 0)) {\n     throw new Error('No detection data found. Run analysis first.');\n  }\n\n  if (typeof showProgress === 'function') showProgress('Generating cut list...');\n\n  const response = await fetch(`${apiUrl}/cut-list`, {\n    method: 'POST',\n    headers: getAuthHeaders(),\n    body: JSON.stringify({\n      sourceName,\n      sourcePath,\n      duration,\n      silences,\n      takes\n    })\n  });\n\n  if (!response.ok) {\n    const err = await response.json();\n    throw new Error(err.error || 'Failed to generate cut list');\n  }\n\n  const data = await response.json();\n  const cutList = data.cutList;\n\n  if (typeof showProgress === 'function') showProgress('Building sequence...');\n\n  const result = await window.spliceBuilder.buildSequenceFromCutList(cutList, sourceProjectItem);\n\n  if (!result.success) {\n    throw new Error(result.error || 'Failed to build sequence');\n  }\n\n  return {\n    success: true,\n    clipsAdded: result.clipsAdded,\n    metadata: cutList.metadata\n  };\n}\n\n// Expose functions globally for UI and testing\nif (typeof window !== 'undefined') {\n    window.buildSequenceV35 = buildSequenceV35;\n    window.buildSequenceWithCutList = buildSequenceWithCutList;\n    window.findFirstMediaItem = findFirstMediaItem;\n}\n\n// ============================================================================\n// TIMELINE SEEK (with proper error handling)\n// ============================================================================\nasync function seekToTime(seconds) {\n  // Validate input\n  if (typeof seconds !== 'number' || isNaN(seconds) || !isFinite(seconds)) {\n    setStatus('Invalid seek time');\n    return;\n  }\n\n  if (seconds < 0) {\n    seconds = 0;\n  }\n\n  try {\n    const context = await getActiveSequence();\n    if (!context) {\n      setStatus('No sequence available');\n      return;\n    }\n\n    const { sequence } = context;\n\n    // Use TickTime API to convert seconds to the format needed\n    const position = ppro.TickTime.createWithSeconds(seconds);\n\n    await sequence.setPlayerPosition(position);\n    setStatus(`Seeked to ${formatTime(seconds)}`);\n  } catch (err) {\n    console.error('[SPLICE] Seek error:', err);\n    setStatus('Seek failed: ' + (err.message || 'Unknown error'));\n  }\n}\n\n// ============================================================================\n// AUTH HEADERS HELPER\n// ============================================================================\n/**\n * Build request headers with authentication\n * @returns {Object} Headers object with Content-Type and x-stripe-customer-id\n */\nfunction getAuthHeaders() {\n  const headers = { 'Content-Type': 'application/json' };\n  const settings = getSettings();\n  if (settings.customerId) {\n    headers['x-stripe-customer-id'] = settings.customerId;\n  }\n  return headers;\n}\n\n// ============================================================================\n// AUDIO EXPORT & BACKEND CALLS\n// ============================================================================\nasync function exportAudioInternal() {\n  try {\n    const context = await getActiveSequence();\n    if (!context) {\n      throw new Error('No project or sequence open');\n    }\n\n    const { sequence } = context;\n    const encoderManager = ppro.EncoderManager.getManager();\n    if (!encoderManager) {\n      throw new Error('EncoderManager not available');\n    }\n\n    const result = await encoderManager.exportSequence(\n      sequence,\n      ppro.EncoderManager.EXPORT_IMMEDIATELY,\n      WAV_PATH,\n      WAV_PRESET_PATH,\n      true\n    );\n\n    return result;\n  } catch (err) {\n    console.error('[SPLICE] Export error:', err);\n    return false;\n  }\n}\n\nasync function isolateVocals() {\n  const response = await fetch(`${BACKEND_URL}/isolate-vocals`, {\n    method: 'POST',\n    headers: getAuthHeaders(),\n    body: JSON.stringify({ audioPath: WAV_PATH })\n  });\n\n  if (!response.ok) {\n    const err = await response.json();\n    return { success: false, error: err.error || 'Isolation request failed' };\n  }\n\n  return await response.json();\n}\n\nasync function detectSilences(audioPath, params) {\n  const response = await fetch(`${BACKEND_URL}/silences-audio`, {\n    method: 'POST',\n    headers: getAuthHeaders(),\n    body: JSON.stringify({\n      wavPath: audioPath,\n      threshold: params.dbThreshold,\n      minDuration: params.minDuration,\n      padding: params.padding\n    })\n  });\n\n  if (!response.ok) {\n    const err = await response.json();\n    throw new Error(err.error || 'Silence detection failed');\n  }\n\n  const data = await response.json();\n  if (!data.success) {\n    throw new Error(data.error || 'Silence detection failed');\n  }\n\n  // Store silences globally for razor workflow\n  currentSilences = data.silences;\n\n  return data.silences;\n}\n\nasync function transcribeAudio() {\n  const response = await fetch(`${BACKEND_URL}/analyze`, {\n    method: 'POST',\n    headers: getAuthHeaders(),\n    body: JSON.stringify({ wavPath: WAV_PATH })\n  });\n\n  if (!response.ok) {\n    const err = await response.json();\n    return { success: false, error: err.error || 'Transcription failed' };\n  }\n\n  const data = await response.json();\n  return {\n    success: data.success,\n    transcript: data.transcript,\n    takes: data.takes,\n    error: data.error\n  };\n}\n\n// ============================================================================\n// BATCH PROCESSING\n// ============================================================================\nlet batchQueue = [];\nlet currentBatchJobId = null;\n\n/**\n * Initialize batch processing handlers\n */\nfunction initBatchHandlers() {\n  const addToBatchBtn = document.getElementById('addToBatchBtn');\n  const startBatchBtn = document.getElementById('startBatchBtn');\n  const clearBatchBtn = document.getElementById('clearBatchBtn');\n  const batchSection = document.getElementById('batchSection');\n\n  // Show batch section in settings or after first detection\n  if (batchSection) {\n    batchSection.classList.remove('hidden');\n  }\n\n  // Add files to batch queue\n  if (addToBatchBtn) {\n    addToBatchBtn.addEventListener('click', async () => {\n      try {\n        const uxpFs = require('uxp').storage.localFileSystem;\n        const files = await uxpFs.getFileForOpening({\n          allowMultiple: true,\n          types: ['wav', 'mp3', 'mp4', 'mov', 'aac', 'm4a']\n        });\n\n        if (files && files.length > 0) {\n          for (const file of files) {\n            const path = file.nativePath || file.name;\n            if (!batchQueue.includes(path)) {\n              batchQueue.push(path);\n            }\n          }\n          updateBatchQueueDisplay();\n          setStatus(`Added ${files.length} file(s) to batch queue`);\n        }\n      } catch (err) {\n        setStatus('Error adding files: ' + err.message);\n      }\n    });\n  }\n\n  // Start batch processing\n  if (startBatchBtn) {\n    startBatchBtn.addEventListener('click', async () => {\n      if (batchQueue.length === 0) {\n        setStatus('No files in batch queue');\n        return;\n      }\n\n      startBatchBtn.disabled = true;\n      addToBatchBtn.disabled = true;\n\n      try {\n        await runBatchProcessing();\n      } finally {\n        startBatchBtn.disabled = false;\n        addToBatchBtn.disabled = false;\n      }\n    });\n  }\n\n  // Clear batch queue\n  if (clearBatchBtn) {\n    clearBatchBtn.addEventListener('click', () => {\n      batchQueue = [];\n      currentBatchJobId = null;\n      updateBatchQueueDisplay();\n      setStatus('Batch queue cleared');\n    });\n  }\n}\n\n/**\n * Update batch queue display\n */\nfunction updateBatchQueueDisplay() {\n  const batchEmpty = document.getElementById('batchEmpty');\n  const batchList = document.getElementById('batchList');\n  const startBatchBtn = document.getElementById('startBatchBtn');\n\n  if (batchQueue.length === 0) {\n    if (batchEmpty) batchEmpty.style.display = 'block';\n    if (batchList) batchList.innerHTML = '';\n    if (startBatchBtn) startBatchBtn.disabled = true;\n    return;\n  }\n\n  if (batchEmpty) batchEmpty.style.display = 'none';\n  if (startBatchBtn) startBatchBtn.disabled = false;\n\n  if (batchList) {\n    batchList.innerHTML = batchQueue.map((path, i) => {\n      const fileName = path.split('/').pop();\n      return `<div style=\"display: flex; justify-content: space-between; align-items: center; padding: 4px 6px; background: #2a2a2a; border-radius: 3px; margin-bottom: 2px; font-size: 9px;\">\n        <span style=\"overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 180px;\" title=\"${path}\">${fileName}</span>\n        <button onclick=\"removeBatchItem(${i})\" style=\"background: transparent; border: none; color: #888; cursor: pointer; font-size: 10px;\">x</button>\n      </div>`;\n    }).join('');\n  }\n}\n\n/**\n * Remove item from batch queue\n */\nfunction removeBatchItem(index) {\n  batchQueue.splice(index, 1);\n  updateBatchQueueDisplay();\n}\n\n/**\n * Run batch processing\n */\nasync function runBatchProcessing() {\n  const batchProgress = document.getElementById('batchProgress');\n  const batchProgressBar = document.getElementById('batchProgressBar');\n  const batchProgressText = document.getElementById('batchProgressText');\n\n  if (batchProgress) batchProgress.style.display = 'block';\n\n  try {\n    // Get settings\n    const sensitivity = parseInt(document.getElementById('sensitivitySlider')?.value || 50);\n    const params = mapSensitivity(sensitivity);\n\n    // Call batch endpoint\n    const response = await fetch(`${BACKEND_URL}/batch/silences`, {\n      method: 'POST',\n      headers: getAuthHeaders(),\n      body: JSON.stringify({\n        files: batchQueue,\n        options: {\n          sensitivity,\n          threshold: params.dbThreshold,\n          minSilenceLength: params.minDuration,\n          paddingStart: params.padding,\n          paddingEnd: params.padding / 2\n        }\n      })\n    });\n\n    if (!response.ok) {\n      const err = await response.json();\n      throw new Error(err.error || 'Batch request failed');\n    }\n\n    const data = await response.json();\n    currentBatchJobId = data.jobId;\n    setStatus(`Batch job started: ${data.jobId}`);\n\n    // Poll for status\n    await pollBatchStatus(currentBatchJobId, batchProgressBar, batchProgressText);\n\n  } catch (err) {\n    setStatus('Batch error: ' + err.message);\n  } finally {\n    if (batchProgress) batchProgress.style.display = 'none';\n  }\n}\n\n/**\n * Poll batch job status\n */\nasync function pollBatchStatus(jobId, progressBar, progressText) {\n  const pollInterval = 2000; // 2 seconds\n  const maxPolls = 300; // 10 minutes max\n  let polls = 0;\n\n  while (polls < maxPolls) {\n    try {\n      const response = await fetch(`${BACKEND_URL}/batch/status/${jobId}`, {\n        headers: getAuthHeaders()\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to get batch status');\n      }\n\n      const data = await response.json();\n      const job = data.job;\n\n      // Update progress\n      if (progressBar) progressBar.value = job.progress.percentage;\n      if (progressText) progressText.textContent = `${job.progress.completed + job.progress.failed} / ${job.progress.total} files`;\n\n      // Check if complete\n      if (job.status !== 'processing') {\n        if (job.status === 'completed') {\n          setStatus(`Batch complete: ${job.progress.completed} files processed`);\n        } else if (job.status === 'completed_with_errors') {\n          setStatus(`Batch complete with ${job.progress.failed} error(s)`);\n        } else {\n          setStatus('Batch failed');\n        }\n\n        // Clear queue on completion\n        batchQueue = [];\n        updateBatchQueueDisplay();\n        return;\n      }\n\n      await new Promise(resolve => setTimeout(resolve, pollInterval));\n      polls++;\n    } catch (err) {\n      setStatus('Polling error: ' + err.message);\n      return;\n    }\n  }\n\n  setStatus('Batch timed out');\n}\n\n// Expose for inline onclick\nif (typeof window !== 'undefined') {\n  window.removeBatchItem = removeBatchItem;\n}\n\n// ============================================================================\n// CUSTOM PRESETS UI (v3.5)\n// ============================================================================\n\n/**\n * Icon mapping for display\n */\nconst PRESET_ICON_MAP = {\n  'settings': '*',\n  'mic': 'M',\n  'people': 'P',\n  'bolt': '!',\n  'school': 'E',\n  'videocam': 'V',\n  'star': 'S',\n  'heart': 'H'\n};\n\n/**\n * Initialize custom presets UI handlers\n */\nfunction initCustomPresetsUI() {\n  // Refresh preset dropdown on load\n  refreshPresetDropdown();\n\n  // Save Preset button (+)\n  if (ui.savePresetBtn) {\n    ui.savePresetBtn.addEventListener('click', () => {\n      showPresetModal();\n    });\n  }\n\n  // Manage Presets button (...)\n  if (ui.managePresetsBtn) {\n    ui.managePresetsBtn.addEventListener('click', () => {\n      showManagePresetsModal();\n    });\n  }\n\n  // Close Preset Modal\n  if (ui.closePresetModalBtn) {\n    ui.closePresetModalBtn.addEventListener('click', () => {\n      hidePresetModal();\n    });\n  }\n\n  // Close on backdrop click\n  if (ui.presetModal) {\n    ui.presetModal.addEventListener('click', (e) => {\n      if (e.target === ui.presetModal) {\n        hidePresetModal();\n      }\n    });\n  }\n\n  // Icon picker\n  if (ui.presetIconPicker) {\n    ui.presetIconPicker.addEventListener('click', (e) => {\n      const btn = e.target.closest('.preset-icon-option');\n      if (btn) {\n        selectPresetIcon(btn.dataset.icon);\n      }\n    });\n  }\n\n  // Sensitivity slider value display (Phase 3)\n  if (ui.presetSensitivity && ui.presetSensitivityValue) {\n    ui.presetSensitivity.addEventListener('input', () => {\n      ui.presetSensitivityValue.textContent = ui.presetSensitivity.value;\n    });\n  }\n\n  // Save Preset Confirm\n  if (ui.savePresetConfirmBtn) {\n    ui.savePresetConfirmBtn.addEventListener('click', () => {\n      savePresetFromModal();\n    });\n  }\n\n  // Close Manage Presets Modal\n  if (ui.closeManagePresetsBtn) {\n    ui.closeManagePresetsBtn.addEventListener('click', () => {\n      hideManagePresetsModal();\n    });\n  }\n\n  // Close on backdrop click\n  if (ui.managePresetsModal) {\n    ui.managePresetsModal.addEventListener('click', (e) => {\n      if (e.target === ui.managePresetsModal) {\n        hideManagePresetsModal();\n      }\n    });\n  }\n\n  // Event delegation for preset list actions\n  if (ui.presetsList) {\n    ui.presetsList.addEventListener('click', (e) => {\n      const editBtn = e.target.closest('.preset-edit-btn');\n      const deleteBtn = e.target.closest('.preset-delete-btn');\n      const duplicateBtn = e.target.closest('.preset-duplicate-btn');\n\n      if (editBtn) {\n        const presetId = editBtn.dataset.presetId;\n        editPreset(presetId);\n      }\n\n      if (deleteBtn) {\n        const presetId = deleteBtn.dataset.presetId;\n        const presetName = deleteBtn.dataset.presetName;\n        deletePresetWithConfirm(presetId, presetName);\n      }\n\n      if (duplicateBtn) {\n        const presetId = duplicateBtn.dataset.presetId;\n        const presetName = duplicateBtn.dataset.presetName;\n        duplicatePresetFromUI(presetId, presetName);\n      }\n    });\n  }\n\n  // Export presets button (Phase 3)\n  if (ui.exportPresetsBtn) {\n    ui.exportPresetsBtn.addEventListener('click', () => {\n      exportPresetsToFile();\n    });\n  }\n\n  // Import presets button (Phase 3)\n  if (ui.importPresetsBtn && ui.importPresetsFile) {\n    ui.importPresetsBtn.addEventListener('click', () => {\n      ui.importPresetsFile.click();\n    });\n\n    ui.importPresetsFile.addEventListener('change', (e) => {\n      if (e.target.files && e.target.files[0]) {\n        importPresetsFromFile(e.target.files[0]);\n        e.target.value = ''; // Reset for next import\n      }\n    });\n  }\n}\n\n/**\n * Refresh the preset dropdown with all presets (built-in + custom)\n */\nfunction refreshPresetDropdown() {\n  if (!ui.presetSelector) return;\n\n  const presets = getAllPresets();\n  const currentValue = ui.presetSelector.value;\n\n  // Clear existing options\n  ui.presetSelector.innerHTML = '';\n\n  // Add all presets\n  presets.forEach(preset => {\n    const option = document.createElement('option');\n    option.value = preset.id;\n\n    // Format: \"Name - Description\" or just \"Name\"\n    const desc = preset.description ? ` - ${preset.description}` : '';\n    option.textContent = preset.name + desc;\n\n    // Add custom marker for custom presets\n    if (!preset.isBuiltIn) {\n      option.textContent = `${preset.name}${desc}`;\n      option.style.color = '#28a745';\n    }\n\n    ui.presetSelector.appendChild(option);\n  });\n\n  // Restore selection if it still exists\n  if ([...ui.presetSelector.options].some(opt => opt.value === currentValue)) {\n    ui.presetSelector.value = currentValue;\n  } else {\n    ui.presetSelector.value = 'custom';\n  }\n}\n\n/**\n * Show the preset modal for creating a new preset\n */\nfunction showPresetModal(editId = null) {\n  if (!ui.presetModal) return;\n\n  // Reset form\n  ui.presetNameInput.value = '';\n  ui.presetDescInput.value = '';\n  ui.presetEditId.value = '';\n  ui.presetSelectedIcon.value = 'settings';\n  selectPresetIcon('settings');\n  hidePresetError();\n\n  // Get current settings as defaults\n  const currentSettings = getSettings();\n  const defaultSensitivity = currentSettings.sensitivity || 50;\n  const defaultThreshold = currentSettings.threshold || -32;\n\n  if (editId) {\n    // Edit mode\n    const preset = getPresetById(editId);\n    if (preset && !preset.isBuiltIn) {\n      ui.presetModalTitle.textContent = 'Edit Preset';\n      ui.presetNameInput.value = preset.name;\n      ui.presetDescInput.value = preset.description || '';\n      ui.presetEditId.value = editId;\n      ui.presetSelectedIcon.value = preset.icon || 'settings';\n      selectPresetIcon(preset.icon || 'settings');\n      ui.savePresetConfirmBtn.textContent = 'Update Preset';\n\n      // Populate settings from preset (Phase 3)\n      const presetSensitivity = preset.settings?.sensitivity ?? defaultSensitivity;\n      const presetThreshold = preset.settings?.threshold ?? defaultThreshold;\n      if (ui.presetSensitivity) {\n        ui.presetSensitivity.value = presetSensitivity;\n        if (ui.presetSensitivityValue) ui.presetSensitivityValue.textContent = presetSensitivity;\n      }\n      if (ui.presetThreshold) {\n        ui.presetThreshold.value = presetThreshold;\n      }\n    }\n  } else {\n    // Create mode - use current settings from main UI\n    ui.presetModalTitle.textContent = 'Save Preset';\n    ui.savePresetConfirmBtn.textContent = 'Save Preset';\n\n    // Get sensitivity from main slider if available\n    const mainSensitivity = ui.sensitivitySlider?.value ?? defaultSensitivity;\n    if (ui.presetSensitivity) {\n      ui.presetSensitivity.value = mainSensitivity;\n      if (ui.presetSensitivityValue) ui.presetSensitivityValue.textContent = mainSensitivity;\n    }\n    if (ui.presetThreshold) {\n      ui.presetThreshold.value = defaultThreshold;\n    }\n  }\n\n  ui.presetModal.classList.remove('hidden');\n  ui.presetNameInput.focus();\n}\n\n/**\n * Hide the preset modal\n */\nfunction hidePresetModal() {\n  if (ui.presetModal) {\n    ui.presetModal.classList.add('hidden');\n  }\n}\n\n/**\n * Select an icon in the preset modal\n */\nfunction selectPresetIcon(iconName) {\n  if (!ui.presetIconPicker || !ui.presetSelectedIcon) return;\n\n  // Update hidden input\n  ui.presetSelectedIcon.value = iconName;\n\n  // Update visual selection\n  ui.presetIconPicker.querySelectorAll('.preset-icon-option').forEach(btn => {\n    if (btn.dataset.icon === iconName) {\n      btn.classList.add('selected');\n    } else {\n      btn.classList.remove('selected');\n    }\n  });\n}\n\n/**\n * Show error message in preset modal\n */\nfunction showPresetError(message) {\n  if (ui.presetModalError) {\n    ui.presetModalError.textContent = message;\n    ui.presetModalError.style.display = 'block';\n  }\n}\n\n/**\n * Hide error message in preset modal\n */\nfunction hidePresetError() {\n  if (ui.presetModalError) {\n    ui.presetModalError.style.display = 'none';\n  }\n}\n\n/**\n * Save preset from modal (create or update)\n */\nfunction savePresetFromModal() {\n  const name = ui.presetNameInput?.value?.trim();\n  const description = ui.presetDescInput?.value?.trim() || '';\n  const icon = ui.presetSelectedIcon?.value || 'settings';\n  const editId = ui.presetEditId?.value;\n\n  if (!name) {\n    showPresetError('Please enter a preset name');\n    return;\n  }\n\n  // Capture settings from modal inputs (Phase 3)\n  const sensitivityRaw = parseInt(ui.presetSensitivity?.value);\n  const thresholdRaw = parseInt(ui.presetThreshold?.value);\n  const sensitivity = isNaN(sensitivityRaw) ? 50 : sensitivityRaw;\n  const threshold = isNaN(thresholdRaw) ? -32 : thresholdRaw;\n\n  // Get base settings and override with modal values\n  const baseSettings = getCurrentPresetSettings();\n  const settings = {\n    ...baseSettings,\n    sensitivity,\n    threshold\n  };\n\n  let result;\n\n  if (editId) {\n    // Update existing preset (including settings)\n    result = updateCustomPreset(editId, {\n      name,\n      description,\n      icon,\n      settings\n    });\n\n    if (result.success) {\n      setStatus(`Preset \"${name}\" updated`);\n    }\n  } else {\n    // Create new preset with modal settings\n    result = createCustomPreset({\n      name,\n      description,\n      icon,\n      settings\n    });\n\n    if (result.success) {\n      setStatus(`Preset \"${name}\" saved`);\n      // Select the newly created preset\n      refreshPresetDropdown();\n      if (ui.presetSelector) {\n        ui.presetSelector.value = result.id;\n      }\n    }\n  }\n\n  if (result.success) {\n    hidePresetModal();\n    refreshPresetDropdown();\n  } else {\n    showPresetError(result.error || 'Failed to save preset');\n  }\n}\n\n/**\n * Show the manage presets modal\n */\nfunction showManagePresetsModal() {\n  if (!ui.managePresetsModal) return;\n\n  renderPresetsList();\n  ui.managePresetsModal.classList.remove('hidden');\n}\n\n/**\n * Hide the manage presets modal\n */\nfunction hideManagePresetsModal() {\n  if (ui.managePresetsModal) {\n    ui.managePresetsModal.classList.add('hidden');\n  }\n}\n\n/**\n * Render the presets list in the manage modal\n */\nfunction renderPresetsList() {\n  if (!ui.presetsList) return;\n\n  const presets = getAllPresets();\n  const customPresets = presets.filter(p => !p.isBuiltIn);\n\n  // Show/hide empty state\n  if (ui.noCustomPresets) {\n    ui.noCustomPresets.style.display = customPresets.length === 0 ? 'block' : 'none';\n  }\n\n  // Build HTML\n  const fragment = document.createDocumentFragment();\n\n  presets.forEach(preset => {\n    const div = document.createElement('div');\n    div.className = `preset-list-item ${preset.isBuiltIn ? 'built-in' : 'custom'}`;\n\n    const iconChar = PRESET_ICON_MAP[preset.icon] || '*';\n    const desc = preset.description || (preset.isBuiltIn ? 'Built-in preset' : 'Custom preset');\n\n    if (preset.isBuiltIn) {\n      // Built-in presets: only duplicate button (Phase 3)\n      div.innerHTML = `\n        <div class=\"preset-list-item-icon\">${iconChar}</div>\n        <div class=\"preset-list-item-info\">\n          <div class=\"preset-list-item-name\">${preset.name}</div>\n          <div class=\"preset-list-item-desc\">${desc}</div>\n        </div>\n        <div class=\"preset-list-item-actions\">\n          <button class=\"preset-duplicate-btn\" data-preset-id=\"${preset.id}\" data-preset-name=\"${preset.name}\" title=\"Duplicate preset\">D</button>\n        </div>\n      `;\n    } else {\n      // Custom presets: duplicate/edit/delete buttons (Phase 3)\n      div.innerHTML = `\n        <div class=\"preset-list-item-icon\">${iconChar}</div>\n        <div class=\"preset-list-item-info\">\n          <div class=\"preset-list-item-name\">${preset.name}</div>\n          <div class=\"preset-list-item-desc\">${desc}</div>\n        </div>\n        <div class=\"preset-list-item-actions\">\n          <button class=\"preset-duplicate-btn\" data-preset-id=\"${preset.id}\" data-preset-name=\"${preset.name}\" title=\"Duplicate preset\">D</button>\n          <button class=\"preset-edit-btn\" data-preset-id=\"${preset.id}\" title=\"Edit preset\">E</button>\n          <button class=\"preset-delete-btn delete\" data-preset-id=\"${preset.id}\" data-preset-name=\"${preset.name}\" title=\"Delete preset\">X</button>\n        </div>\n      `;\n    }\n\n    fragment.appendChild(div);\n  });\n\n  ui.presetsList.innerHTML = '';\n  ui.presetsList.appendChild(fragment);\n}\n\n/**\n * Edit a preset\n */\nfunction editPreset(presetId) {\n  hideManagePresetsModal();\n  showPresetModal(presetId);\n}\n\n/**\n * Delete a preset with confirmation\n */\nfunction deletePresetWithConfirm(presetId, presetName) {\n  // Simple confirmation (UXP doesn't have native confirm)\n  const confirmed = confirm(`Delete preset \"${presetName}\"?`);\n  if (!confirmed) return;\n\n  const result = deleteCustomPreset(presetId);\n\n  if (result.success) {\n    setStatus(`Preset \"${presetName}\" deleted`);\n    renderPresetsList();\n    refreshPresetDropdown();\n  } else {\n    setStatus('Failed to delete preset: ' + (result.error || 'Unknown error'));\n  }\n}\n\n/**\n * Duplicate a preset from the UI (Phase 3)\n */\nfunction duplicatePresetFromUI(presetId, presetName) {\n  const result = duplicatePreset(presetId);\n\n  if (result.success) {\n    setStatus(`Created copy of \"${presetName}\"`);\n    renderPresetsList();\n    refreshPresetDropdown();\n\n    // Select the new copy in dropdown\n    if (ui.presetSelector && result.id) {\n      ui.presetSelector.value = result.id;\n    }\n  } else {\n    setStatus('Failed to duplicate preset: ' + (result.error || 'Unknown error'));\n  }\n}\n\n/**\n * Export presets to a JSON file (Phase 3)\n */\nasync function exportPresetsToFile() {\n  const result = exportPresets();\n\n  if (!result.success) {\n    setStatus(result.error || 'No presets to export');\n    return;\n  }\n\n  try {\n    // Create a blob and download it\n    const blob = new Blob([result.data], { type: 'application/json' });\n    const filename = `splice-presets-${new Date().toISOString().slice(0, 10)}.json`;\n\n    // UXP approach: use file system API\n    const uxpFs = require('uxp').storage.localFileSystem;\n    const file = await uxpFs.getFileForSaving(filename, { types: ['json'] });\n\n    if (file) {\n      await file.write(result.data);\n      setStatus(`Exported ${result.count} preset(s) to ${file.name}`);\n    } else {\n      setStatus('Export cancelled');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Export error:', err);\n    setStatus('Export failed: ' + err.message);\n  }\n}\n\n/**\n * Import presets from a JSON file (Phase 3)\n */\nasync function importPresetsFromFile(file) {\n  try {\n    // Read file contents\n    const reader = new FileReader();\n\n    reader.onload = (e) => {\n      const jsonString = e.target.result;\n      const result = importPresets(jsonString, true);\n\n      if (result.success) {\n        setStatus(`Imported ${result.imported} preset(s)${result.skipped > 0 ? `, ${result.skipped} skipped` : ''}`);\n        renderPresetsList();\n        refreshPresetDropdown();\n      } else {\n        setStatus('Import failed: ' + (result.error || 'Unknown error'));\n      }\n    };\n\n    reader.onerror = () => {\n      setStatus('Failed to read file');\n    };\n\n    reader.readAsText(file);\n  } catch (err) {\n    console.error('[SPLICE] Import error:', err);\n    setStatus('Import failed: ' + err.message);\n  }\n}\n\n/**\n * Apply a preset and update UI controls\n * Called when user selects a preset from dropdown\n */\nfunction applyPresetAndUpdateUI(presetId) {\n  const preset = getPresetById(presetId);\n  if (!preset) return;\n\n  // For custom presets, apply the settings\n  if (!preset.isBuiltIn) {\n    const settings = preset.settings;\n    if (settings) {\n      // Update sensitivity slider\n      if (ui.sensitivitySlider && settings.sensitivity !== undefined) {\n        ui.sensitivitySlider.value = settings.sensitivity;\n      }\n\n      // Update takes detection checkbox\n      if (ui.enableTakesDetection && settings.enableTakesDetection !== undefined) {\n        ui.enableTakesDetection.checked = settings.enableTakesDetection;\n      }\n\n      // Update auto-mark best checkbox\n      if (ui.autoMarkBest && settings.autoMarkBest !== undefined) {\n        ui.autoMarkBest.checked = settings.autoMarkBest;\n      }\n\n      // Save as active preset\n      saveSettings({ activePreset: presetId, ...settings });\n    }\n  } else {\n    // Built-in preset: use applyPreset from settings.js\n    const appliedSettings = applyPreset(presetId);\n\n    // Update sensitivity slider to match preset\n    if (ui.sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n      ui.sensitivitySlider.value = appliedSettings.sensitivity;\n    }\n\n    // Update takes detection checkbox\n    if (ui.enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n      ui.enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n    }\n\n    // Update auto-mark best checkbox\n    if (ui.autoMarkBest && appliedSettings.autoMarkBest !== undefined) {\n      ui.autoMarkBest.checked = appliedSettings.autoMarkBest;\n    }\n  }\n\n  setStatus(`Applied preset: ${preset.name}`);\n}\n","numLines":2332,"startLine":1,"totalLines":2332}}}
{"parentUuid":"3bebefc6-a57e-438f-a0c2-118f1cf23e63","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Pi3naMmQbjvHHnNpgwMUvm","type":"message","role":"assistant","content":[{"type":"text","text":"Let me continue reading more of the server.js file to see the license activation endpoint and credits endpoint, and also check for the requireCredits middleware:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2591,"cache_creation_input_tokens":58180,"cache_read_input_tokens":16579,"cache_creation":{"ephemeral_5m_input_tokens":58180,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWUGen5AiaUr63Kuvnpvd","type":"assistant","uuid":"42b83508-a909-4b9d-8757-c26330ddb7ea","timestamp":"2025-12-25T23:26:37.563Z"}
{"parentUuid":"42b83508-a909-4b9d-8757-c26330ddb7ea","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Pi3naMmQbjvHHnNpgwMUvm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016U6QiuxBFx53yjLgMGzSAM","name":"Grep","input":{"pattern":"/license/activate|/credits|requireCredits","path":"/Users/imorgado/SPLICE/splice-backend/server.js","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2591,"cache_creation_input_tokens":58180,"cache_read_input_tokens":16579,"cache_creation":{"ephemeral_5m_input_tokens":58180,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWUGen5AiaUr63Kuvnpvd","type":"assistant","uuid":"960508f6-a634-44f4-9a56-b697c9019b83","timestamp":"2025-12-25T23:26:39.317Z"}
{"parentUuid":"960508f6-a634-44f4-9a56-b697c9019b83","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Pi3naMmQbjvHHnNpgwMUvm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0152jQ1mSubRF6R95tuWkBj5","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js","offset":280,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2591,"cache_creation_input_tokens":58180,"cache_read_input_tokens":16579,"cache_creation":{"ephemeral_5m_input_tokens":58180,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWUGen5AiaUr63Kuvnpvd","type":"assistant","uuid":"73a3f27c-ad54-470e-9b43-c8b48be92a65","timestamp":"2025-12-25T23:26:40.351Z"}
{"parentUuid":"73a3f27c-ad54-470e-9b43-c8b48be92a65","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0152jQ1mSubRF6R95tuWkBj5","type":"tool_result","content":"   280→      'POST /multitrack/auto-balance': 'Auto-balance speaker screentime { audioPaths: [], speakerNames: [] }',\n   281→      'POST /process-xml': 'Process FCP XML { xmlPath, silences, removeGaps: true }',\n   282→      'POST /cut-list': 'Generate JSON cut list for DOM building (v3.5) { sourceName, sourcePath, duration, silences, takes?, settings? }',\n   283→      'POST /cut-list/takes': 'Generate cut list keeping only takes { sourceName, sourcePath, duration, takes, settings? }',\n   284→      'POST /isolate-vocals': 'Isolate vocals from audio { audioPath }',\n   285→      'POST /batch/silences': 'Batch process multiple files for silence detection { files: [], options: {} }',\n   286→      'GET /batch/status/:jobId': 'Get batch job status',\n   287→      'GET /batch/results/:jobId': 'Get full batch job results',\n   288→      'GET /batch/jobs': 'List all batch jobs',\n   289→      'DELETE /batch/:jobId': 'Delete a batch job',\n   290→      'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',\n   291→      'GET /usage-history': 'Get usage history (requires x-stripe-customer-id header)',\n   292→      'POST /webhooks/stripe': 'Stripe webhook endpoint',\n   293→      'GET /referral/code': 'Get or create referral code for user',\n   294→      'POST /referral/validate': 'Validate a referral code',\n   295→      'POST /referral/apply': 'Apply referral code at signup',\n   296→      'GET /referral/stats': 'Get referral statistics for user',\n   297→      'POST /license/activate': 'Activate license key { key: \"SPLICE-XXXX-XXXX-XXXX\" }',\n   298→      'GET /license/key': 'Get license key for customer (requires x-stripe-customer-id)'\n   299→    }\n   300→  });\n   301→});\n   302→\n   303→/**\n   304→ * GET /health - Health check\n   305→ */\n   306→app.get('/health', (req, res) => {\n   307→  res.json({ status: 'ok', service: 'splice-backend' });\n   308→});\n   309→\n   310→/**\n   311→ * POST /analyze - Main analysis endpoint\n   312→ *\n   313→ * Pipeline:\n   314→ * 1. Validate input (wavPath)\n   315→ * 2. Slice 4: Transcribe audio with Groq Whisper\n   316→ * 3. Slice 5: Detect takes with GPT-4o-mini\n   317→ * 4. Return combined results\n   318→ */\n   319→app.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n   320→  const { wavPath } = req.body;\n   321→\n   322→  // Validate input\n   323→  if (!wavPath) {\n   324→    return res.status(400).json({ error: 'wavPath is required' });\n   325→  }\n   326→\n   327→  if (!fs.existsSync(wavPath)) {\n   328→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   329→  }\n   330→\n   331→  console.log(`[SPLICE] Analyzing: ${wavPath}`);\n   332→\n   333→  try {\n   334→    // Slice 4 - GPT-4o-mini transcription\n   335→    const transcript = await transcribeAudio(wavPath);\n   336→\n   337→    // Slice 5 - GPT-4o-mini take detection\n   338→    const takes = await detectTakes(transcript);\n   339→\n   340→    // Deduct usage based on audio duration\n   341→    const audioDuration = transcript.duration || 0;\n   342→    let balance = null;\n   343→    if (audioDuration > 0 && req.deductUsage) {\n   344→      balance = await req.deductUsage(audioDuration);\n   345→    }\n   346→\n   347→    res.json({\n   348→      success: true,\n   349→      wavPath,\n   350→      transcript,\n   351→      takes,\n   352→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   353→    });\n   354→  } catch (err) {\n   355→    console.error('[SPLICE] Error:', err);\n   356→    res.status(500).json({ error: err.message });\n   357→  }\n   358→});\n   359→\n   360→/**\n   361→ * POST /silences - Detect silent gaps in audio\n   362→ *\n   363→ * Pipeline:\n   364→ * 1. Transcribe audio with Whisper (reuses transcription)\n   365→ * 2. Analyze gaps between segments\n   366→ * 3. Return silence regions\n   367→ */\n   368→app.post('/silences', requireCredits({ endpoint: 'silences' }), async (req, res) => {\n   369→  const { wavPath, threshold = 0.5 } = req.body;\n   370→\n   371→  if (!wavPath) {\n   372→    return res.status(400).json({ error: 'wavPath is required' });\n   373→  }\n   374→\n   375→  if (!fs.existsSync(wavPath)) {\n   376→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   377→  }\n   378→\n   379→  console.log(`[SPLICE] Detecting silences: ${wavPath} (threshold: ${threshold}s)`);\n   380→\n   381→  try {\n   382→    const transcript = await transcribeAudio(wavPath);\n   383→    const silences = detectSilences(transcript.segments, threshold);\n   384→\n   385→    // Deduct usage based on audio duration\n   386→    const audioDuration = transcript.duration || 0;\n   387→    let balance = null;\n   388→    if (audioDuration > 0 && req.deductUsage) {\n   389→      balance = await req.deductUsage(audioDuration);\n   390→    }\n   391→\n   392→    res.json({\n   393→      success: true,\n   394→      wavPath,\n   395→      threshold,\n   396→      silences,\n   397→      count: silences.length,\n   398→      totalSilenceDuration: silences.reduce((sum, s) => sum + s.duration, 0).toFixed(2),\n   399→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   400→    });\n   401→  } catch (err) {\n   402→    console.error('[SPLICE] Silence detection error:', err);\n   403→    res.status(500).json({ error: err.message });\n   404→  }\n   405→});\n   406→\n   407→/**\n   408→ * POST /silences-audio - Detect silences using FFprobe audio analysis\n   409→ *\n   410→ * Uses actual audio levels (dB threshold) instead of transcript gaps.\n   411→ * More accurate for detecting silence vs background noise.\n   412→ */\n   413→app.post('/silences-audio', requireCredits({ endpoint: 'silences-audio' }), async (req, res) => {\n   414→  const {\n   415→    wavPath,\n   416→    threshold = -30,\n   417→    minDuration = 0.5,\n   418→    padding = 0.1\n   419→  } = req.body;\n   420→\n   421→  if (!wavPath) {\n   422→    return res.status(400).json({ error: 'wavPath is required' });\n   423→  }\n   424→\n   425→  if (!fs.existsSync(wavPath)) {\n   426→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   427→  }\n   428→\n   429→  // Check FFprobe availability\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7d5fc6e3-3460-4220-adeb-86a3119026bb","timestamp":"2025-12-25T23:26:40.453Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"      'POST /multitrack/auto-balance': 'Auto-balance speaker screentime { audioPaths: [], speakerNames: [] }',\n      'POST /process-xml': 'Process FCP XML { xmlPath, silences, removeGaps: true }',\n      'POST /cut-list': 'Generate JSON cut list for DOM building (v3.5) { sourceName, sourcePath, duration, silences, takes?, settings? }',\n      'POST /cut-list/takes': 'Generate cut list keeping only takes { sourceName, sourcePath, duration, takes, settings? }',\n      'POST /isolate-vocals': 'Isolate vocals from audio { audioPath }',\n      'POST /batch/silences': 'Batch process multiple files for silence detection { files: [], options: {} }',\n      'GET /batch/status/:jobId': 'Get batch job status',\n      'GET /batch/results/:jobId': 'Get full batch job results',\n      'GET /batch/jobs': 'List all batch jobs',\n      'DELETE /batch/:jobId': 'Delete a batch job',\n      'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',\n      'GET /usage-history': 'Get usage history (requires x-stripe-customer-id header)',\n      'POST /webhooks/stripe': 'Stripe webhook endpoint',\n      'GET /referral/code': 'Get or create referral code for user',\n      'POST /referral/validate': 'Validate a referral code',\n      'POST /referral/apply': 'Apply referral code at signup',\n      'GET /referral/stats': 'Get referral statistics for user',\n      'POST /license/activate': 'Activate license key { key: \"SPLICE-XXXX-XXXX-XXXX\" }',\n      'GET /license/key': 'Get license key for customer (requires x-stripe-customer-id)'\n    }\n  });\n});\n\n/**\n * GET /health - Health check\n */\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok', service: 'splice-backend' });\n});\n\n/**\n * POST /analyze - Main analysis endpoint\n *\n * Pipeline:\n * 1. Validate input (wavPath)\n * 2. Slice 4: Transcribe audio with Groq Whisper\n * 3. Slice 5: Detect takes with GPT-4o-mini\n * 4. Return combined results\n */\napp.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n  const { wavPath } = req.body;\n\n  // Validate input\n  if (!wavPath) {\n    return res.status(400).json({ error: 'wavPath is required' });\n  }\n\n  if (!fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  console.log(`[SPLICE] Analyzing: ${wavPath}`);\n\n  try {\n    // Slice 4 - GPT-4o-mini transcription\n    const transcript = await transcribeAudio(wavPath);\n\n    // Slice 5 - GPT-4o-mini take detection\n    const takes = await detectTakes(transcript);\n\n    // Deduct usage based on audio duration\n    const audioDuration = transcript.duration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      transcript,\n      takes,\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /silences - Detect silent gaps in audio\n *\n * Pipeline:\n * 1. Transcribe audio with Whisper (reuses transcription)\n * 2. Analyze gaps between segments\n * 3. Return silence regions\n */\napp.post('/silences', requireCredits({ endpoint: 'silences' }), async (req, res) => {\n  const { wavPath, threshold = 0.5 } = req.body;\n\n  if (!wavPath) {\n    return res.status(400).json({ error: 'wavPath is required' });\n  }\n\n  if (!fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  console.log(`[SPLICE] Detecting silences: ${wavPath} (threshold: ${threshold}s)`);\n\n  try {\n    const transcript = await transcribeAudio(wavPath);\n    const silences = detectSilences(transcript.segments, threshold);\n\n    // Deduct usage based on audio duration\n    const audioDuration = transcript.duration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      threshold,\n      silences,\n      count: silences.length,\n      totalSilenceDuration: silences.reduce((sum, s) => sum + s.duration, 0).toFixed(2),\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Silence detection error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /silences-audio - Detect silences using FFprobe audio analysis\n *\n * Uses actual audio levels (dB threshold) instead of transcript gaps.\n * More accurate for detecting silence vs background noise.\n */\napp.post('/silences-audio', requireCredits({ endpoint: 'silences-audio' }), async (req, res) => {\n  const {\n    wavPath,\n    threshold = -30,\n    minDuration = 0.5,\n    padding = 0.1\n  } = req.body;\n\n  if (!wavPath) {\n    return res.status(400).json({ error: 'wavPath is required' });\n  }\n\n  if (!fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  // Check FFprobe availability","numLines":150,"startLine":280,"totalLines":2176}}}
{"parentUuid":"7d5fc6e3-3460-4220-adeb-86a3119026bb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016U6QiuxBFx53yjLgMGzSAM","type":"tool_result","content":"62:const { requireCredits } = require('./middleware/rateLimiter');\n290:      'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',\n297:      'POST /license/activate': 'Activate license key { key: \"SPLICE-XXXX-XXXX-XXXX\" }',\n319:app.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n368:app.post('/silences', requireCredits({ endpoint: 'silences' }), async (req, res) => {\n413:app.post('/silences-audio', requireCredits({ endpoint: 'silences-audio' }), async (req, res) => {\n494:app.post('/silences-rms', requireCredits({ endpoint: 'silences-rms' }), async (req, res) => {\n580:app.post('/profanity', requireCredits({ endpoint: 'profanity' }), async (req, res) => {\n703:app.post('/repetitions', requireCredits({ endpoint: 'repetitions' }), async (req, res) => {\n783:app.post('/fillers', requireCredits({ endpoint: 'fillers' }), async (req, res) => {\n915:app.post('/stutters', requireCredits({ endpoint: 'stutters' }), async (req, res) => {\n1006:app.post('/export/captions', requireCredits({ endpoint: 'export-captions' }), async (req, res) => {\n1129:app.post('/multitrack', requireCredits({ endpoint: 'multitrack' }), async (req, res) => {\n1206:app.post('/multitrack/auto-balance', requireCredits({ endpoint: 'multitrack-auto-balance' }), async (req, res) => {\n1466:app.post('/isolate-vocals', requireCredits({ endpoint: 'isolate-vocals' }), async (req, res) => {\n1623:app.post('/batch/silences', requireCredits({ endpoint: 'batch-silences' }), async (req, res) => {\n1882: * GET /credits - Get user's credit balance\n1886:app.get('/credits', async (req, res) => {\n2057: * POST /license/activate - Activate a license key\n2062:app.post('/license/activate', async (req, res) => {"}]},"uuid":"c7aa1799-43d7-4696-905c-6c275c13e244","timestamp":"2025-12-25T23:26:40.825Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"62:const { requireCredits } = require('./middleware/rateLimiter');\n290:      'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',\n297:      'POST /license/activate': 'Activate license key { key: \"SPLICE-XXXX-XXXX-XXXX\" }',\n319:app.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n368:app.post('/silences', requireCredits({ endpoint: 'silences' }), async (req, res) => {\n413:app.post('/silences-audio', requireCredits({ endpoint: 'silences-audio' }), async (req, res) => {\n494:app.post('/silences-rms', requireCredits({ endpoint: 'silences-rms' }), async (req, res) => {\n580:app.post('/profanity', requireCredits({ endpoint: 'profanity' }), async (req, res) => {\n703:app.post('/repetitions', requireCredits({ endpoint: 'repetitions' }), async (req, res) => {\n783:app.post('/fillers', requireCredits({ endpoint: 'fillers' }), async (req, res) => {\n915:app.post('/stutters', requireCredits({ endpoint: 'stutters' }), async (req, res) => {\n1006:app.post('/export/captions', requireCredits({ endpoint: 'export-captions' }), async (req, res) => {\n1129:app.post('/multitrack', requireCredits({ endpoint: 'multitrack' }), async (req, res) => {\n1206:app.post('/multitrack/auto-balance', requireCredits({ endpoint: 'multitrack-auto-balance' }), async (req, res) => {\n1466:app.post('/isolate-vocals', requireCredits({ endpoint: 'isolate-vocals' }), async (req, res) => {\n1623:app.post('/batch/silences', requireCredits({ endpoint: 'batch-silences' }), async (req, res) => {\n1882: * GET /credits - Get user's credit balance\n1886:app.get('/credits', async (req, res) => {\n2057: * POST /license/activate - Activate a license key\n2062:app.post('/license/activate', async (req, res) => {","numLines":20}}
{"parentUuid":"c7aa1799-43d7-4696-905c-6c275c13e244","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q6dSGTpCy5xFFNwk3dVev5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017C6EEbnQvHadraBUxXnKer","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js","offset":1880,"limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2246,"cache_creation_input_tokens":3562,"cache_read_input_tokens":74759,"cache_creation":{"ephemeral_5m_input_tokens":3562,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWUGfKoPm8EEjhSpKYbDr","type":"assistant","uuid":"91cefcf1-c4ad-4ac4-bdb5-c104d65ee351","timestamp":"2025-12-25T23:26:44.637Z"}
{"parentUuid":"91cefcf1-c4ad-4ac4-bdb5-c104d65ee351","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q6dSGTpCy5xFFNwk3dVev5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P83DzeaUnrv1NPjr7MZjZw","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2246,"cache_creation_input_tokens":3562,"cache_read_input_tokens":74759,"cache_creation":{"ephemeral_5m_input_tokens":3562,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWUGfKoPm8EEjhSpKYbDr","type":"assistant","uuid":"c00b79e9-21ab-46a5-b3f3-52003145b880","timestamp":"2025-12-25T23:26:45.257Z"}
{"parentUuid":"c00b79e9-21ab-46a5-b3f3-52003145b880","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017C6EEbnQvHadraBUxXnKer","type":"tool_result","content":"  1880→\n  1881→/**\n  1882→ * GET /credits - Get user's credit balance\n  1883→ *\n  1884→ * Requires x-stripe-customer-id header\n  1885→ */\n  1886→app.get('/credits', async (req, res) => {\n  1887→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  1888→\n  1889→  if (!stripeCustomerId) {\n  1890→    return res.status(401).json({\n  1891→      error: 'Authentication required',\n  1892→      message: 'Missing x-stripe-customer-id header'\n  1893→    });\n  1894→  }\n  1895→\n  1896→  try {\n  1897→    const balance = await usageTracking.getBalance(stripeCustomerId);\n  1898→    res.json({\n  1899→      success: true,\n  1900→      ...balance\n  1901→    });\n  1902→  } catch (err) {\n  1903→    console.error('[SPLICE] Credits error:', err);\n  1904→    res.status(500).json({ error: err.message });\n  1905→  }\n  1906→});\n  1907→\n  1908→/**\n  1909→ * GET /usage-history - Get user's usage history\n  1910→ */\n  1911→app.get('/usage-history', async (req, res) => {\n  1912→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  1913→\n  1914→  if (!stripeCustomerId) {\n  1915→    return res.status(401).json({\n  1916→      error: 'Authentication required',\n  1917→      message: 'Missing x-stripe-customer-id header'\n  1918→    });\n  1919→  }\n  1920→\n  1921→  try {\n  1922→    const history = await usageTracking.getUsageHistory(stripeCustomerId);\n  1923→    res.json({\n  1924→      success: true,\n  1925→      history\n  1926→    });\n  1927→  } catch (err) {\n  1928→    console.error('[SPLICE] Usage history error:', err);\n  1929→    res.status(500).json({ error: err.message });\n  1930→  }\n  1931→});\n  1932→\n  1933→// =============================================================================\n  1934→// Referral System Endpoints\n  1935→// =============================================================================\n  1936→\n  1937→/**\n  1938→ * GET /referral/code - Get or create referral code for user\n  1939→ *\n  1940→ * Requires x-stripe-customer-id header\n  1941→ */\n  1942→app.get('/referral/code', async (req, res) => {\n  1943→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  1944→\n  1945→  if (!stripeCustomerId) {\n  1946→    return res.status(401).json({\n  1947→      error: 'Authentication required',\n  1948→      message: 'Missing x-stripe-customer-id header'\n  1949→    });\n  1950→  }\n  1951→\n  1952→  try {\n  1953→    const codeInfo = await referralService.getOrCreateCode(stripeCustomerId);\n  1954→    res.json({\n  1955→      success: true,\n  1956→      ...codeInfo\n  1957→    });\n  1958→  } catch (err) {\n  1959→    console.error('[SPLICE] Referral code error:', err);\n  1960→    res.status(500).json({ error: err.message });\n  1961→  }\n  1962→});\n  1963→\n  1964→/**\n  1965→ * POST /referral/validate - Validate a referral code\n  1966→ *\n  1967→ * Body: { code: string, customerId?: string }\n  1968→ */\n  1969→app.post('/referral/validate', async (req, res) => {\n  1970→  const { code, customerId } = req.body;\n  1971→\n  1972→  if (!code) {\n  1973→    return res.status(400).json({\n  1974→      error: 'Missing code',\n  1975→      message: 'Referral code is required'\n  1976→    });\n  1977→  }\n  1978→\n  1979→  try {\n  1980→    const result = await referralService.validateCode(code, customerId);\n  1981→    res.json({\n  1982→      success: true,\n  1983→      ...result\n  1984→    });\n  1985→  } catch (err) {\n  1986→    console.error('[SPLICE] Referral validate error:', err);\n  1987→    res.status(500).json({ error: err.message });\n  1988→  }\n  1989→});\n  1990→\n  1991→/**\n  1992→ * POST /referral/apply - Apply referral code at signup\n  1993→ *\n  1994→ * Body: { code: string, customerId: string }\n  1995→ */\n  1996→app.post('/referral/apply', async (req, res) => {\n  1997→  const { code, customerId } = req.body;\n  1998→\n  1999→  if (!code || !customerId) {\n  2000→    return res.status(400).json({\n  2001→      error: 'Missing required fields',\n  2002→      message: 'Both code and customerId are required'\n  2003→    });\n  2004→  }\n  2005→\n  2006→  try {\n  2007→    const result = await referralService.applyCode(code, customerId, stripe);\n  2008→    res.json({\n  2009→      success: true,\n  2010→      ...result\n  2011→    });\n  2012→  } catch (err) {\n  2013→    console.error('[SPLICE] Referral apply error:', err);\n  2014→    // Return user-friendly errors for validation failures\n  2015→    if (err.message.includes('Cannot use your own') ||\n  2016→        err.message.includes('already used') ||\n  2017→        err.message.includes('not found') ||\n  2018→        err.message.includes('no longer active')) {\n  2019→      return res.status(400).json({ error: err.message });\n  2020→    }\n  2021→    res.status(500).json({ error: err.message });\n  2022→  }\n  2023→});\n  2024→\n  2025→/**\n  2026→ * GET /referral/stats - Get referral statistics for user\n  2027→ *\n  2028→ * Requires x-stripe-customer-id header\n  2029→ */\n  2030→app.get('/referral/stats', async (req, res) => {\n  2031→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  2032→\n  2033→  if (!stripeCustomerId) {\n  2034→    return res.status(401).json({\n  2035→      error: 'Authentication required',\n  2036→      message: 'Missing x-stripe-customer-id header'\n  2037→    });\n  2038→  }\n  2039→\n  2040→  try {\n  2041→    const stats = await referralService.getStats(stripeCustomerId);\n  2042→    res.json({\n  2043→      success: true,\n  2044→      ...stats\n  2045→    });\n  2046→  } catch (err) {\n  2047→    console.error('[SPLICE] Referral stats error:', err);\n  2048→    res.status(500).json({ error: err.message });\n  2049→  }\n  2050→});\n  2051→\n  2052→// =============================================================================\n  2053→// License Key Endpoints\n  2054→// =============================================================================\n  2055→\n  2056→/**\n  2057→ * POST /license/activate - Activate a license key\n  2058→ *\n  2059→ * Body: { key: \"SPLICE-XXXX-XXXX-XXXX\" }\n  2060→ * Returns: { success, customerId, tier, hoursRemaining }\n  2061→ */\n  2062→app.post('/license/activate', async (req, res) => {\n  2063→  const { key } = req.body;\n  2064→\n  2065→  if (!key) {\n  2066→    return res.status(400).json({\n  2067→      error: 'Missing license key',\n  2068→      message: 'License key is required'\n  2069→    });\n  2070→  }\n  2071→\n  2072→  // Validate format\n  2073→  if (!licenseService.isValidKeyFormat(key)) {\n  2074→    return res.status(400).json({\n  2075→      error: 'Invalid license key format',\n  2076→      message: 'License key should be in format: SPLICE-XXXX-XXXX-XXXX'\n  2077→    });\n  2078→  }\n  2079→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3085aea3-421c-4822-91cf-e44ce6d4bb3d","timestamp":"2025-12-25T23:26:45.325Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"\n/**\n * GET /credits - Get user's credit balance\n *\n * Requires x-stripe-customer-id header\n */\napp.get('/credits', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const balance = await usageTracking.getBalance(stripeCustomerId);\n    res.json({\n      success: true,\n      ...balance\n    });\n  } catch (err) {\n    console.error('[SPLICE] Credits error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * GET /usage-history - Get user's usage history\n */\napp.get('/usage-history', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const history = await usageTracking.getUsageHistory(stripeCustomerId);\n    res.json({\n      success: true,\n      history\n    });\n  } catch (err) {\n    console.error('[SPLICE] Usage history error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// =============================================================================\n// Referral System Endpoints\n// =============================================================================\n\n/**\n * GET /referral/code - Get or create referral code for user\n *\n * Requires x-stripe-customer-id header\n */\napp.get('/referral/code', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const codeInfo = await referralService.getOrCreateCode(stripeCustomerId);\n    res.json({\n      success: true,\n      ...codeInfo\n    });\n  } catch (err) {\n    console.error('[SPLICE] Referral code error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /referral/validate - Validate a referral code\n *\n * Body: { code: string, customerId?: string }\n */\napp.post('/referral/validate', async (req, res) => {\n  const { code, customerId } = req.body;\n\n  if (!code) {\n    return res.status(400).json({\n      error: 'Missing code',\n      message: 'Referral code is required'\n    });\n  }\n\n  try {\n    const result = await referralService.validateCode(code, customerId);\n    res.json({\n      success: true,\n      ...result\n    });\n  } catch (err) {\n    console.error('[SPLICE] Referral validate error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /referral/apply - Apply referral code at signup\n *\n * Body: { code: string, customerId: string }\n */\napp.post('/referral/apply', async (req, res) => {\n  const { code, customerId } = req.body;\n\n  if (!code || !customerId) {\n    return res.status(400).json({\n      error: 'Missing required fields',\n      message: 'Both code and customerId are required'\n    });\n  }\n\n  try {\n    const result = await referralService.applyCode(code, customerId, stripe);\n    res.json({\n      success: true,\n      ...result\n    });\n  } catch (err) {\n    console.error('[SPLICE] Referral apply error:', err);\n    // Return user-friendly errors for validation failures\n    if (err.message.includes('Cannot use your own') ||\n        err.message.includes('already used') ||\n        err.message.includes('not found') ||\n        err.message.includes('no longer active')) {\n      return res.status(400).json({ error: err.message });\n    }\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * GET /referral/stats - Get referral statistics for user\n *\n * Requires x-stripe-customer-id header\n */\napp.get('/referral/stats', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const stats = await referralService.getStats(stripeCustomerId);\n    res.json({\n      success: true,\n      ...stats\n    });\n  } catch (err) {\n    console.error('[SPLICE] Referral stats error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// =============================================================================\n// License Key Endpoints\n// =============================================================================\n\n/**\n * POST /license/activate - Activate a license key\n *\n * Body: { key: \"SPLICE-XXXX-XXXX-XXXX\" }\n * Returns: { success, customerId, tier, hoursRemaining }\n */\napp.post('/license/activate', async (req, res) => {\n  const { key } = req.body;\n\n  if (!key) {\n    return res.status(400).json({\n      error: 'Missing license key',\n      message: 'License key is required'\n    });\n  }\n\n  // Validate format\n  if (!licenseService.isValidKeyFormat(key)) {\n    return res.status(400).json({\n      error: 'Invalid license key format',\n      message: 'License key should be in format: SPLICE-XXXX-XXXX-XXXX'\n    });\n  }\n","numLines":200,"startLine":1880,"totalLines":2176}}}
{"parentUuid":"3085aea3-421c-4822-91cf-e44ce6d4bb3d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P83DzeaUnrv1NPjr7MZjZw","type":"tool_result","content":"     1→/**\n     2→ * Rate Limiter Middleware\n     3→ *\n     4→ * Checks if user has sufficient credits before processing.\n     5→ * Returns 402 Payment Required if insufficient credits.\n     6→ */\n     7→\n     8→const { hasCredits, deductUsage, getBalance } = require('../services/usageTracking');\n     9→\n    10→/**\n    11→ * Middleware to check credits before processing\n    12→ *\n    13→ * Expects req.stripeCustomerId to be set by auth middleware\n    14→ * Optionally uses req.estimatedDuration (in seconds) for pre-check\n    15→ */\n    16→function requireCredits(options = {}) {\n    17→  const { endpoint = 'unknown' } = options;\n    18→\n    19→  return async (req, res, next) => {\n    20→    const stripeCustomerId = req.stripeCustomerId || req.headers['x-stripe-customer-id'];\n    21→\n    22→    if (!stripeCustomerId) {\n    23→      return res.status(401).json({\n    24→        error: 'Authentication required',\n    25→        message: 'Missing Stripe customer ID'\n    26→      });\n    27→    }\n    28→\n    29→    // Store for later use\n    30→    req.stripeCustomerId = stripeCustomerId;\n    31→\n    32→    try {\n    33→      // Check if user has any credits\n    34→      const hasCreds = await hasCredits(stripeCustomerId, req.estimatedDuration || 0);\n    35→\n    36→      if (!hasCreds) {\n    37→        const balance = await getBalance(stripeCustomerId);\n    38→        return res.status(402).json({\n    39→          error: 'Insufficient credits',\n    40→          message: 'Please upgrade your plan or wait for your next billing cycle',\n    41→          balance: {\n    42→            hoursRemaining: balance.hoursRemaining,\n    43→            tier: balance.tier\n    44→          }\n    45→        });\n    46→      }\n    47→\n    48→      // Attach helper function to deduct after processing\n    49→      req.deductUsage = async (audioDurationSeconds) => {\n    50→        return await deductUsage(stripeCustomerId, audioDurationSeconds, endpoint);\n    51→      };\n    52→\n    53→      next();\n    54→    } catch (err) {\n    55→      console.error('[RateLimiter] Error checking credits:', err);\n    56→      return res.status(500).json({\n    57→        error: 'Credit check failed',\n    58→        message: err.message\n    59→      });\n    60→    }\n    61→  };\n    62→}\n    63→\n    64→/**\n    65→ * Middleware to track usage after successful response\n    66→ *\n    67→ * Call this after processing to deduct actual usage\n    68→ */\n    69→function trackUsage(endpoint = 'unknown') {\n    70→  return async (req, res, next) => {\n    71→    // Store original json method\n    72→    const originalJson = res.json.bind(res);\n    73→\n    74→    // Override json to track usage on success\n    75→    res.json = async (data) => {\n    76→      // Only deduct on successful responses\n    77→      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n    78→        try {\n    79→          const balance = await deductUsage(\n    80→            req.stripeCustomerId,\n    81→            req.audioDuration,\n    82→            endpoint\n    83→          );\n    84→          // Attach updated balance to response\n    85→          data.balance = balance;\n    86→        } catch (err) {\n    87→          console.error('[RateLimiter] Error deducting usage:', err);\n    88→        }\n    89→      }\n    90→      return originalJson(data);\n    91→    };\n    92→\n    93→    next();\n    94→  };\n    95→}\n    96→\n    97→module.exports = {\n    98→  requireCredits,\n    99→  trackUsage\n   100→};\n   101→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b0814dd0-90f6-4131-a304-f6735e4ad44f","timestamp":"2025-12-25T23:26:45.325Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js","content":"/**\n * Rate Limiter Middleware\n *\n * Checks if user has sufficient credits before processing.\n * Returns 402 Payment Required if insufficient credits.\n */\n\nconst { hasCredits, deductUsage, getBalance } = require('../services/usageTracking');\n\n/**\n * Middleware to check credits before processing\n *\n * Expects req.stripeCustomerId to be set by auth middleware\n * Optionally uses req.estimatedDuration (in seconds) for pre-check\n */\nfunction requireCredits(options = {}) {\n  const { endpoint = 'unknown' } = options;\n\n  return async (req, res, next) => {\n    const stripeCustomerId = req.stripeCustomerId || req.headers['x-stripe-customer-id'];\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Missing Stripe customer ID'\n      });\n    }\n\n    // Store for later use\n    req.stripeCustomerId = stripeCustomerId;\n\n    try {\n      // Check if user has any credits\n      const hasCreds = await hasCredits(stripeCustomerId, req.estimatedDuration || 0);\n\n      if (!hasCreds) {\n        const balance = await getBalance(stripeCustomerId);\n        return res.status(402).json({\n          error: 'Insufficient credits',\n          message: 'Please upgrade your plan or wait for your next billing cycle',\n          balance: {\n            hoursRemaining: balance.hoursRemaining,\n            tier: balance.tier\n          }\n        });\n      }\n\n      // Attach helper function to deduct after processing\n      req.deductUsage = async (audioDurationSeconds) => {\n        return await deductUsage(stripeCustomerId, audioDurationSeconds, endpoint);\n      };\n\n      next();\n    } catch (err) {\n      console.error('[RateLimiter] Error checking credits:', err);\n      return res.status(500).json({\n        error: 'Credit check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Middleware to track usage after successful response\n *\n * Call this after processing to deduct actual usage\n */\nfunction trackUsage(endpoint = 'unknown') {\n  return async (req, res, next) => {\n    // Store original json method\n    const originalJson = res.json.bind(res);\n\n    // Override json to track usage on success\n    res.json = async (data) => {\n      // Only deduct on successful responses\n      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n        try {\n          const balance = await deductUsage(\n            req.stripeCustomerId,\n            req.audioDuration,\n            endpoint\n          );\n          // Attach updated balance to response\n          data.balance = balance;\n        } catch (err) {\n          console.error('[RateLimiter] Error deducting usage:', err);\n        }\n      }\n      return originalJson(data);\n    };\n\n    next();\n  };\n}\n\nmodule.exports = {\n  requireCredits,\n  trackUsage\n};\n","numLines":101,"startLine":1,"totalLines":101}}}
{"parentUuid":"b0814dd0-90f6-4131-a304-f6735e4ad44f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UGQcELXmmfkQ4yMJmAAvHT","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the rest of the license activation endpoint:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":6135,"cache_read_input_tokens":78321,"cache_creation":{"ephemeral_5m_input_tokens":6135,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWUGfeP6PJStgaKWf79hj","type":"assistant","uuid":"3c3f7a26-8ccf-4a1e-bc60-e844c3b9d5c9","timestamp":"2025-12-25T23:26:47.822Z"}
{"parentUuid":"3c3f7a26-8ccf-4a1e-bc60-e844c3b9d5c9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UGQcELXmmfkQ4yMJmAAvHT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013kZs3w2A7DsNkVnuKcSrzR","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js","offset":2078,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":6135,"cache_read_input_tokens":78321,"cache_creation":{"ephemeral_5m_input_tokens":6135,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWUGfeP6PJStgaKWf79hj","type":"assistant","uuid":"b2b7c731-6577-48af-81c8-60505ab6db3b","timestamp":"2025-12-25T23:26:49.111Z"}
{"parentUuid":"b2b7c731-6577-48af-81c8-60505ab6db3b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013kZs3w2A7DsNkVnuKcSrzR","type":"tool_result","content":"  2078→  }\n  2079→\n  2080→  try {\n  2081→    // Activate the key\n  2082→    const result = await licenseService.activateLicenseKey(key);\n  2083→\n  2084→    if (!result.success) {\n  2085→      return res.status(400).json({\n  2086→        success: false,\n  2087→        error: result.error\n  2088→      });\n  2089→    }\n  2090→\n  2091→    // Get the customer's balance and tier info\n  2092→    const balance = await usageTracking.getBalance(result.customerId);\n  2093→\n  2094→    res.json({\n  2095→      success: true,\n  2096→      customerId: result.customerId,\n  2097→      tier: balance.tier,\n  2098→      tierName: balance.tierName,\n  2099→      hoursRemaining: balance.hoursRemaining,\n  2100→      hoursTotal: balance.hoursTotal\n  2101→    });\n  2102→  } catch (err) {\n  2103→    console.error('[SPLICE] License activation error:', err);\n  2104→    res.status(500).json({ error: err.message });\n  2105→  }\n  2106→});\n  2107→\n  2108→/**\n  2109→ * GET /license/key - Get license key for a customer (for display/resend)\n  2110→ *\n  2111→ * Requires x-stripe-customer-id header\n  2112→ */\n  2113→app.get('/license/key', async (req, res) => {\n  2114→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  2115→\n  2116→  if (!stripeCustomerId) {\n  2117→    return res.status(401).json({\n  2118→      error: 'Authentication required',\n  2119→      message: 'Missing x-stripe-customer-id header'\n  2120→    });\n  2121→  }\n  2122→\n  2123→  try {\n  2124→    const result = await licenseService.getLicenseByCustomerId(stripeCustomerId);\n  2125→\n  2126→    if (!result.success) {\n  2127→      return res.status(404).json({\n  2128→        success: false,\n  2129→        error: result.error\n  2130→      });\n  2131→    }\n  2132→\n  2133→    res.json({\n  2134→      success: true,\n  2135→      key: result.key,\n  2136→      activated: result.activated,\n  2137→      createdAt: result.createdAt\n  2138→    });\n  2139→  } catch (err) {\n  2140→    console.error('[SPLICE] License lookup error:', err);\n  2141→    res.status(500).json({ error: err.message });\n  2142→  }\n  2143→});\n  2144→\n  2145→// =============================================================================\n  2146→// Start Server\n  2147→// =============================================================================\n  2148→\n  2149→// Initialize database and start server\n  2150→async function startServer() {\n  2151→  try {\n  2152→    await usageTracking.initDatabase();\n  2153→    await referralService.initReferralTables();\n  2154→    await licenseService.initLicenseTables();\n  2155→    console.log('[SPLICE] Database initialized');\n  2156→\n  2157→    if (isProduction || !httpsOptions) {\n  2158→      // Production: Railway provides TLS termination, use HTTP\n  2159→      http.createServer(app).listen(PORT, () => {\n  2160→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n  2161→      });\n  2162→    } else {\n  2163→      // Development: Use HTTPS with local certificates\n  2164→      https.createServer(httpsOptions, app).listen(PORT, () => {\n  2165→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n  2166→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n  2167→      });\n  2168→    }\n  2169→  } catch (err) {\n  2170→    console.error('[SPLICE] Failed to start server:', err);\n  2171→    process.exit(1);\n  2172→  }\n  2173→}\n  2174→\n  2175→startServer();\n  2176→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"17d788c2-fbed-4b18-97df-1cbfbc0a4571","timestamp":"2025-12-25T23:26:49.234Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"  }\n\n  try {\n    // Activate the key\n    const result = await licenseService.activateLicenseKey(key);\n\n    if (!result.success) {\n      return res.status(400).json({\n        success: false,\n        error: result.error\n      });\n    }\n\n    // Get the customer's balance and tier info\n    const balance = await usageTracking.getBalance(result.customerId);\n\n    res.json({\n      success: true,\n      customerId: result.customerId,\n      tier: balance.tier,\n      tierName: balance.tierName,\n      hoursRemaining: balance.hoursRemaining,\n      hoursTotal: balance.hoursTotal\n    });\n  } catch (err) {\n    console.error('[SPLICE] License activation error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * GET /license/key - Get license key for a customer (for display/resend)\n *\n * Requires x-stripe-customer-id header\n */\napp.get('/license/key', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const result = await licenseService.getLicenseByCustomerId(stripeCustomerId);\n\n    if (!result.success) {\n      return res.status(404).json({\n        success: false,\n        error: result.error\n      });\n    }\n\n    res.json({\n      success: true,\n      key: result.key,\n      activated: result.activated,\n      createdAt: result.createdAt\n    });\n  } catch (err) {\n    console.error('[SPLICE] License lookup error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\n// Initialize database and start server\nasync function startServer() {\n  try {\n    await usageTracking.initDatabase();\n    await referralService.initReferralTables();\n    await licenseService.initLicenseTables();\n    console.log('[SPLICE] Database initialized');\n\n    if (isProduction || !httpsOptions) {\n      // Production: Railway provides TLS termination, use HTTP\n      http.createServer(app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n      });\n    } else {\n      // Development: Use HTTPS with local certificates\n      https.createServer(httpsOptions, app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n      });\n    }\n  } catch (err) {\n    console.error('[SPLICE] Failed to start server:', err);\n    process.exit(1);\n  }\n}\n\nstartServer();\n","numLines":99,"startLine":2078,"totalLines":2176}}}
{"parentUuid":"17d788c2-fbed-4b18-97df-1cbfbc0a4571","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a7e01bf","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_012aztC2AqRsYMwTQtPCbpnz","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have all the information needed to provide a comprehensive E2E flow analysis. Let me compile my findings:\n\n---\n\n# SPLICE E2E User Flow Validation Report\n\n## Overall Verdict: PASS WITH ISSUES\n\nThe flow is functional end-to-end, but there are several gaps and potential race conditions that should be addressed.\n\n---\n\n## Complete E2E Flow Diagram (Text)\n\n```\n+=====================================================================+\n|                         USER PURCHASE FLOW                          |\n+=====================================================================+\n\n[1] Stripe Checkout Completed\n         |\n         v\n+------------------+      POST /webhooks/stripe\n|   Stripe sends   | -----> server.js:130-247\n| checkout.session |\n|   .completed     |\n+------------------+\n         |\n         v\n+------------------+      isEventProcessed()\n|   Idempotency    | <--- usageTracking.js:437-443\n|     Check        |\n+------------------+\n         |\n    (Not processed)\n         v\n+------------------+      customer.subscription.created\n|   Handle Event   | -----> server.js:165-193\n|                  |\n+------------------+\n         |\n         +-------------------------------------------+\n         |                                           |\n         v                                           v\n+------------------+                      +--------------------+\n|   updateTier()   |                      | generateLicenseKey |\n| usageTracking    |                      |  licenseService    |\n|   :383-418       |                      |   :124-177         |\n+------------------+                      +--------------------+\n         |                                           |\n         v                                           v\n+------------------+                      +--------------------+\n| Creates/Updates  |                      | Insert license_keys|\n|  users table     |                      |  (SPLICE-XXXX...)  |\n| hours_remaining  |                      +--------------------+\n+------------------+\n         |\n         v\n+------------------+      recordWebhookEvent()\n|   Mark Event     | -----> usageTracking.js:448-458\n|   Processed      |\n+------------------+\n\n\n+=====================================================================+\n|                      USER ACTIVATION FLOW                           |\n+=====================================================================+\n\n[2] User Receives License Key (via email/dashboard)\n         |\n         v\n+------------------+      Click creditBadge\n|  Plugin: Click   | -----> settings.js:1201-1205\n|  Credit Badge    |\n+------------------+\n         |\n         v\n+------------------+      showLoginModal()\n|   Login Modal    | -----> settings.js:1289-1300\n|    Opens         |\n+------------------+\n         |\n    (User enters key)\n         v\n+------------------+      saveLoginBtn click\n|   Activate Btn   | -----> settings.js:1225-1279\n|     Click        |\n+------------------+\n         |\n         v\n+------------------+      POST /license/activate\n|   API Call       | -----> server.js:2062-2106\n|   License/activate|\n+------------------+\n         |\n         v\n+------------------+      activateLicenseKey()\n|   Validate &     | -----> licenseService.js:185-229\n|   Activate Key   |\n+------------------+\n         |\n         v\n+------------------+      getBalance()\n|   Get User       | -----> usageTracking.js:160-187\n|   Balance        |\n+------------------+\n         |\n         v\n+------------------+      saveSettings({ customerId })\n|   Store Customer | -----> settings.js:1259\n|   ID Locally     |\n+------------------+\n         |\n         v\n+------------------+      refreshCredits()\n|   Update Credit  | -----> credits.js:198-202\n|   Display        |\n+------------------+\n\n\n+=====================================================================+\n|                        API USAGE FLOW                               |\n+=====================================================================+\n\n[3] User Clicks GO Button\n         |\n         v\n+------------------+      getAuthHeaders()\n|   Build Headers  | -----> main.js:1407-1414\n|   w/ Customer ID |\n+------------------+\n         |\n         v\n+------------------+      fetch(BACKEND_URL/silences-audio)\n|   API Request    | -----> main.js:1463-1488\n|   with header    |\n|   x-stripe-      |\n|   customer-id    |\n+------------------+\n         |\n         v\n+------------------+      requireCredits() middleware\n|   Rate Limit     | -----> rateLimiter.js:16-62\n|   Check          |\n+------------------+\n         |\n    (Has credits?)\n    /           \\\n   No            Yes\n   |              |\n   v              v\n+--------+   +------------------+\n| 402    |   |   Process        |\n| Return |   |   Request        |\n+--------+   +------------------+\n                    |\n                    v\n             +------------------+      req.deductUsage()\n             |   Deduct Usage   | -----> rateLimiter.js:49-51\n             |   (after success)|\n             +------------------+\n                    |\n                    v\n             +------------------+      deductUsage()\n             |   Update DB      | -----> usageTracking.js:321-359\n             |   hours_remaining|\n             +------------------+\n\n\n+=====================================================================+\n|                      CREDITS DISPLAY FLOW                           |\n+=====================================================================+\n\n[4] Credits Display\n         |\n         v\n+------------------+      initCredits()\n|   On Plugin Load | -----> credits.js:183-193\n+------------------+\n         |\n         v\n+------------------+      fetchCredits()\n|   GET /credits   | -----> credits.js:19-58\n+------------------+\n         |\n         v\n+------------------+      getBalance()\n|   Backend Query  | -----> server.js:1886-1906\n+------------------+\n         |\n         v\n+------------------+      updateCreditDisplay()\n|   Update UI      | -----> credits.js:67-99\n|   Badge + Tooltip|\n+------------------+\n```\n\n---\n\n## Requirements Checklist\n\n### Step 1: Stripe Webhook (server.js:128-233)\n\n| Requirement | Status | Evidence |\n|-------------|--------|----------|\n| Signature verification | MET | server.js:137-152 - Uses `stripe.webhooks.constructEvent()` in production |\n| Idempotency check | MET | server.js:158-161 - Checks `isEventProcessed()` before handling |\n| customer.subscription.created handling | MET | server.js:165-193 - Calls `updateTier()` + `generateLicenseKey()` |\n| License key generation on new subscription | MET | server.js:185-192 - Generates key for new subscriptions |\n| Event recorded after processing | MET | server.js:240 - `recordWebhookEvent()` at end |\n\n### Step 2: License Key Generation (licenseService.js)\n\n| Requirement | Status | Evidence |\n|-------------|--------|----------|\n| Key format SPLICE-XXXX-XXXX-XXXX | MET | licenseService.js:86-91 - `generateKeyString()` |\n| No confusing characters (0/O, 1/I/L) | MET | licenseService.js:22 - `KEY_CHARS` excludes them |\n| Retry on collision | MET | licenseService.js:150-166 - 10 attempt max |\n| Check for existing key | MET | licenseService.js:132-143 - Returns existing key if found |\n| Database storage | MET | licenseService.js:153-157 - Inserts into `license_keys` |\n\n### Step 3: Plugin Activation (settings.js:1192-1284)\n\n| Requirement | Status | Evidence |\n|-------------|--------|----------|\n| Login modal opens on badge click | MET | settings.js:1201-1205 - `creditBadge.addEventListener('click')` |\n| Key format validation client-side | MET | settings.js:1182-1187 - `isValidLicenseKeyFormat()` |\n| API call to /license/activate | MET | settings.js:1244-1251 - fetch POST |\n| Customer ID stored locally | MET | settings.js:1259 - `saveSettings({ customerId })` |\n| Credits refresh after activation | MET | settings.js:1265-1267 - `refreshCredits()` |\n| Error handling | MET | settings.js:1272-1278 - try/catch with user-friendly message |\n\n### Step 4: API Calls with Customer ID (main.js:1407-1414)\n\n| Requirement | Status | Evidence |\n|-------------|--------|----------|\n| getAuthHeaders() function exists | MET | main.js:1407-1414 |\n| Includes x-stripe-customer-id header | MET | main.js:1411 - `headers['x-stripe-customer-id'] = settings.customerId` |\n| Used in all API calls | MET | main.js:1451, 1464, 1491 - All fetch calls use `getAuthHeaders()` |\n\n### Step 5: Usage Deduction (usageTracking.js)\n\n| Requirement | Status | Evidence |\n|-------------|--------|----------|\n| requireCredits middleware | MET | rateLimiter.js:16-62 - Checks before processing |\n| Deducts after successful processing | MET | rateLimiter.js:49-51 - `req.deductUsage` attached |\n| Updates hours_remaining | MET | usageTracking.js:339-345 - `GREATEST(0, hours_remaining - $1)` |\n| Logs usage to usage_log | MET | usageTracking.js:348-352 - INSERT into usage_log |\n| 402 on insufficient credits | MET | rateLimiter.js:38-46 |\n\n### Step 6: Credits Display (credits.js)\n\n| Requirement | Status | Evidence |\n|-------------|--------|----------|\n| Fetches on load | MET | credits.js:183-186 - `initCredits()` |\n| Periodic refresh | MET | credits.js:189-192 - 5-minute interval |\n| Displays hours remaining | MET | credits.js:79 - `credits.hoursRemaining.toFixed(1)` |\n| Color coding for low credits | MET | credits.js:89-95 - low/ok classes |\n| Isolation access display | MET | credits.js:104-128 - `updateIsolationCheckboxState()` |\n\n---\n\n## Detailed Findings\n\n### ISSUE 1: Missing checkout.session.completed Handler (High Priority)\n\n**Finding:** The webhook handler only processes `customer.subscription.created`, `customer.subscription.updated`, `customer.subscription.deleted`, and `invoice.payment_succeeded`. There is NO explicit handler for `checkout.session.completed`.\n\n**Impact:** When a user completes Stripe Checkout, the `checkout.session.completed` event is sent, but SPLICE only handles `customer.subscription.created`. This works because Stripe sends both events, but:\n1. The subscription event may arrive AFTER the checkout event\n2. If there's a delay, the user might try to activate before the license exists\n\n**Location:** server.js:163-237\n\n**Recommendation:** Add explicit handling for `checkout.session.completed` to ensure immediate processing, or document that the flow relies on `subscription.created` arriving promptly.\n\n---\n\n### ISSUE 2: Race Condition in License Key Delivery (Medium Priority)\n\n**Finding:** There is no mechanism to notify the user of their license key after purchase. The key is generated but not delivered.\n\n**Evidence:**\n- `generateLicenseKey()` creates the key (licenseService.js:124-177)\n- Key is stored in database\n- NO email is sent\n- NO Stripe metadata is updated\n- User has no way to GET their key until they have a customerId\n\n**Impact:** Users complete purchase but don't know their license key. They would need to contact support.\n\n**Recommendation:** \n1. Add email notification after license generation using Stripe customer email\n2. OR store license key in Stripe subscription metadata\n3. OR add a \"Resend License Key\" feature via Stripe customer portal\n\n---\n\n### ISSUE 3: No Error Recovery for Webhook Failures (Medium Priority)\n\n**Finding:** If `generateLicenseKey()` fails (line 186-191), the error is logged but the webhook still returns 200 success.\n\n**Evidence:** server.js:189-191\n```javascript\nif (licenseResult.success) {\n  console.log(...);\n} else {\n  console.error(...); // Only logs, no recovery\n}\n```\n\n**Impact:** Customer's tier is updated but no license key is created. User cannot activate.\n\n**Recommendation:** \n1. Add retry mechanism for failed key generation\n2. OR queue failed generations for later retry\n3. OR return 500 to trigger Stripe retry\n\n---\n\n### ISSUE 4: No Local Cache Invalidation on Logout (Low Priority)\n\n**Finding:** When user logs out (`logout()` in settings.js:1334-1339), the local settings are cleared but `currentCredits` in credits.js is NOT cleared.\n\n**Evidence:** \n- settings.js:1335 - `saveSettings({ customerId: null })`\n- credits.js:61 - `currentCredits` remains populated\n\n**Impact:** After logout, stale credit data may persist in memory until next refresh. Could show incorrect balance briefly.\n\n**Recommendation:** Add `currentCredits = null` call in logout, or expose a `clearCredits()` function.\n\n---\n\n### ISSUE 5: Potential Race in Usage Deduction (Low Priority)\n\n**Finding:** Multiple concurrent requests could both pass the `hasCredits` check before either deducts, potentially allowing over-usage.\n\n**Evidence:** \n- rateLimiter.js:34 - `hasCredits()` check\n- Line 49-51 - Deduction happens AFTER processing\n\n**Impact:** During parallel processing of multiple requests, total usage could exceed balance slightly before any deduction occurs.\n\n**Recommendation:** \n1. Use database-level locking for credit checks\n2. OR use optimistic locking with retry on conflict\n3. OR pre-deduct and refund on failure\n\n---\n\n### ISSUE 6: Missing Validation of Customer Existence (Low Priority)\n\n**Finding:** The `/credits` endpoint calls `getBalance()` which calls `getOrCreateUser()` - this automatically creates a user record for ANY customer ID passed.\n\n**Evidence:** usageTracking.js:130-155 - Creates user if not found\n\n**Impact:** Anyone can create user records by passing arbitrary customer IDs to the API.\n\n**Recommendation:** Validate that the Stripe customer ID exists in Stripe before creating local records, OR require license activation first.\n\n---\n\n## Gap Analysis Summary\n\n| Gap | Severity | Chain Break? | Fix Effort |\n|-----|----------|--------------|------------|\n| No license key delivery mechanism | HIGH | Yes | 4 hrs |\n| No checkout.session.completed handler | MEDIUM | No (subscription.created works) | 1 hr |\n| No webhook failure recovery | MEDIUM | Potential | 2 hrs |\n| No credits cache invalidation on logout | LOW | No | 30 min |\n| Race condition in concurrent requests | LOW | No | 3 hrs |\n| Missing customer ID validation | LOW | No | 2 hrs |\n\n---\n\n## Flow Completeness Assessment\n\n| Step | Complete? | Notes |\n|------|-----------|-------|\n| 1. Stripe webhook -> tier update | YES | Works correctly |\n| 2. Stripe webhook -> license generation | PARTIAL | Generated but not delivered |\n| 3. User receives license key | NO | Missing delivery mechanism |\n| 4. User enters key in plugin | YES | Modal UI works |\n| 5. Key activation -> customerId stored | YES | Full chain works |\n| 6. API calls with auth header | YES | All endpoints use getAuthHeaders() |\n| 7. Usage deduction | YES | Middleware + deduct pattern works |\n| 8. Credits display updates | YES | Real-time + periodic refresh |\n\n---\n\n## Recommendations Summary (Priority Order)\n\n1. **CRITICAL:** Implement license key delivery after purchase (email via Stripe, webhook, or Stripe metadata)\n\n2. **HIGH:** Add retry/recovery for failed license key generation in webhook handler\n\n3. **MEDIUM:** Add explicit `checkout.session.completed` handler for immediate processing\n\n4. **LOW:** Clear credits cache on logout\n\n5. **LOW:** Add database-level locking for concurrent usage checks\n\n6. **LOW:** Validate Stripe customer IDs before creating local user records\n\n---\n\n## Files Analyzed\n\n| File | Path | Lines Reviewed |\n|------|------|----------------|\n| server.js | `/Users/imorgado/SPLICE/splice-backend/server.js` | 120-247, 280-430, 1880-2176 |\n| licenseService.js | `/Users/imorgado/SPLICE/splice-backend/services/licenseService.js` | 1-326 (complete) |\n| usageTracking.js | `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js` | 1-478 (complete) |\n| rateLimiter.js | `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js` | 1-101 (complete) |\n| settings.js | `/Users/imorgado/SPLICE/splice-plugin/js/settings.js` | 1-1343 (complete) |\n| main.js | `/Users/imorgado/SPLICE/splice-plugin/js/main.js` | 1-2332 (complete) |\n| credits.js | `/Users/imorgado/SPLICE/splice-plugin/js/credits.js` | 1-203 (complete) |"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1519,"cache_read_input_tokens":84456,"cache_creation":{"ephemeral_5m_input_tokens":1519,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWUGfx4iW9hjgkXxN8g9m","type":"assistant","uuid":"ee3d568b-7c67-4348-918f-aefcb0270304","timestamp":"2025-12-25T23:28:16.370Z"}
