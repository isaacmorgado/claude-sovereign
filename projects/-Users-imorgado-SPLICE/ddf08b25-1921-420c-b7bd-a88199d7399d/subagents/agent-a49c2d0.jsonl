{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","type":"user","message":{"role":"user","content":"Fix the HIGH race condition in splice-backend/routes/music.js around line 888-889.\n\nCurrent code does sequential credit deductions without transaction:\n```javascript\nfor (let i = 0; i < creditCost; i++) {\n  await usageTracking.deductMusicCredit(customerId);\n}\n```\n\nFix by:\n1. Find or create a deductMusicCredits(customerId, count) function in usageTracking.js\n2. Use a single atomic database operation with FOR UPDATE lock\n3. Update the music.js route to use the new atomic function\n\nThis prevents users from exploiting race conditions to generate music without proper credit deduction."},"uuid":"44df6bdc-2f70-4cb4-8e99-8745a14fda56","timestamp":"2026-01-13T04:21:59.108Z"}
{"parentUuid":"44df6bdc-2f70-4cb4-8e99-8745a14fda56","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_0148xHKHVztA8yo1iPBV11fb","type":"message","role":"assistant","content":[{"type":"text","text":"I'll fix this race condition by creating an atomic credit deduction function and updating the music route to use it. Let me start by examining the current code."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":13829,"cache_read_input_tokens":19313,"cache_creation":{"ephemeral_5m_input_tokens":13829,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX4jjsaUmKAgUzm9b4vg5","type":"assistant","uuid":"29259cec-dade-4164-9d17-ae99f7205aab","timestamp":"2026-01-13T04:22:03.832Z"}
{"parentUuid":"29259cec-dade-4164-9d17-ae99f7205aab","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_0148xHKHVztA8yo1iPBV11fb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Li7sLBhV77SXiuy6gheqGP","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/music.js","offset":880,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":13829,"cache_read_input_tokens":19313,"cache_creation":{"ephemeral_5m_input_tokens":13829,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX4jjsaUmKAgUzm9b4vg5","type":"assistant","uuid":"f8165b7b-a80c-4f83-8c5a-f20f64700622","timestamp":"2026-01-13T04:22:04.898Z"}
{"parentUuid":"f8165b7b-a80c-4f83-8c5a-f20f64700622","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_0148xHKHVztA8yo1iPBV11fb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KpKKzpoU3xG2NXEHy691k3","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":13829,"cache_read_input_tokens":19313,"cache_creation":{"ephemeral_5m_input_tokens":13829,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX4jjsaUmKAgUzm9b4vg5","type":"assistant","uuid":"554ba023-1dfb-4b54-8511-e27badd7e66e","timestamp":"2026-01-13T04:22:05.275Z"}
{"parentUuid":"f8165b7b-a80c-4f83-8c5a-f20f64700622","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Li7sLBhV77SXiuy6gheqGP","type":"tool_result","content":"   880→          type: 'timeline',\n   881→          chapterCount: String(result.chapters.length)\n   882→        });\n   883→\n   884→        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n   885→      }\n   886→\n   887→      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)\n   888→      for (let i = 0; i < creditCost; i++) {\n   889→        await usageTracking.deductMusicCredit(customerId);\n   890→      }\n   891→\n   892→      res.json({\n   893→        success: true,\n   894→        duration: result.duration,\n   895→        chapters: result.chapters,\n   896→        metadata: result.metadata,\n   897→        audioUrl: signedUrl,\n   898→        r2Key,\n   899→        creditCost,\n   900→        estimate\n   901→      });\n   902→\n   903→    } catch (err) {\n   904→      console.error('[SPLICE Timeline] Generation error:', err.message);\n   905→      res.status(500).json({ error: err.message || 'Timeline generation failed' });\n   906→    }\n   907→  });\n   908→\n   909→  return router;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4d000682-1394-4fcc-a07a-984d71f19916","timestamp":"2026-01-13T04:22:05.337Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/music.js","content":"          type: 'timeline',\n          chapterCount: String(result.chapters.length)\n        });\n\n        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n      }\n\n      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)\n      for (let i = 0; i < creditCost; i++) {\n        await usageTracking.deductMusicCredit(customerId);\n      }\n\n      res.json({\n        success: true,\n        duration: result.duration,\n        chapters: result.chapters,\n        metadata: result.metadata,\n        audioUrl: signedUrl,\n        r2Key,\n        creditCost,\n        estimate\n      });\n\n    } catch (err) {\n      console.error('[SPLICE Timeline] Generation error:', err.message);\n      res.status(500).json({ error: err.message || 'Timeline generation failed' });\n    }\n  });\n\n  return router;","numLines":30,"startLine":880,"totalLines":913}},"sourceToolAssistantUUID":"f8165b7b-a80c-4f83-8c5a-f20f64700622"}
{"parentUuid":"554ba023-1dfb-4b54-8511-e27badd7e66e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KpKKzpoU3xG2NXEHy691k3","type":"tool_result","content":"     1→/**\n     2→ * Usage Tracking Service\n     3→ *\n     4→ * Tracks user credit balances and usage for billing.\n     5→ * Uses PostgreSQL for persistence.\n     6→ */\n     7→\n     8→const { Pool } = require('pg');\n     9→const { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n    10→\n    11→// PostgreSQL connection pool with proper limits\n    12→// SSL Configuration:\n    13→// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n    14→// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n    15→// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\n    16→const sslConfig = process.env.NODE_ENV === 'production' ? {\n    17→  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n    18→  ca: process.env.DATABASE_SSL_CA || undefined\n    19→} : false;\n    20→\n    21→const pool = new Pool({\n    22→  connectionString: process.env.DATABASE_URL,\n    23→  ssl: sslConfig,\n    24→  // PERFORMANCE: Set connection pool limits\n    25→  max: 20,                    // Maximum number of clients in the pool\n    26→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n    27→  // MEDIUM-007: Database Query Timeouts - prevent long-running queries from exhausting pool\n    28→  connectionTimeoutMillis: 10000,  // 10 seconds to acquire connection (increased for reliability)\n    29→  statement_timeout: 30000,        // 30 seconds max query execution time\n    30→  query_timeout: 30000             // 30 seconds max total query time including queue\n    31→});\n    32→\n    33→// Hours per tier (regular processing)\n    34→// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n    35→// Target margins: 79-82%\n    36→const TIER_HOURS = {\n    37→  starter: 4,    // 4 hrs/month\n    38→  pro: 15,       // 15 hrs/month\n    39→  team: 50,      // 50 hrs/month\n    40→  cancelled: 0\n    41→};\n    42→\n    43→// Overage rate for processing hours beyond included\n    44→const HOURS_OVERAGE_RATE = 2.00; // $2/hour\n    45→\n    46→// Isolation minutes per tier (sized to maintain 80% margins)\n    47→const TIER_ISOLATION_MINUTES = {\n    48→  starter: 0,     // No isolation access\n    49→  pro: 45,        // 45 minutes included\n    50→  team: 180,      // 3 hours included\n    51→  cancelled: 0\n    52→};\n    53→\n    54→// Convert to hours for database storage\n    55→const TIER_ISOLATION_HOURS = {\n    56→  starter: 0,\n    57→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n    58→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n    59→  cancelled: 0\n    60→};\n    61→\n    62→// Overage rate for isolation beyond included minutes\n    63→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n    64→\n    65→/**\n    66→ * Initialize database tables\n    67→ */\n    68→async function initDatabase() {\n    69→  const client = await pool.connect();\n    70→  try {\n    71→    await client.query(`\n    72→      CREATE TABLE IF NOT EXISTS users (\n    73→        id SERIAL PRIMARY KEY,\n    74→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n    75→        email VARCHAR(255),\n    76→        tier VARCHAR(50) DEFAULT 'starter',\n    77→        hours_remaining DECIMAL(10,4) DEFAULT 15,\n    78→        hours_total DECIMAL(10,4) DEFAULT 15,\n    79→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n    80→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n    81→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    82→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    83→      )\n    84→    `);\n    85→\n    86→    // Add isolation columns if they don't exist (for existing databases)\n    87→    await client.query(`\n    88→      DO $$\n    89→      BEGIN\n    90→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n    91→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n    92→        END IF;\n    93→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n    94→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n    95→        END IF;\n    96→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n    97→          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n    98→        END IF;\n    99→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified') THEN\n   100→          ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;\n   101→        END IF;\n   102→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified_at') THEN\n   103→          ALTER TABLE users ADD COLUMN email_verified_at TIMESTAMP;\n   104→        END IF;\n   105→      END $$;\n   106→    `);\n   107→\n   108→    await client.query(`\n   109→      CREATE TABLE IF NOT EXISTS usage_log (\n   110→        id SERIAL PRIMARY KEY,\n   111→        user_id INTEGER REFERENCES users(id),\n   112→        stripe_customer_id VARCHAR(255),\n   113→        audio_duration_seconds DECIMAL(10,2),\n   114→        hours_used DECIMAL(10,6),\n   115→        endpoint VARCHAR(100),\n   116→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   117→      )\n   118→    `);\n   119→\n   120→    await client.query(`\n   121→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n   122→    `);\n   123→\n   124→    await client.query(`\n   125→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n   126→    `);\n   127→\n   128→    // PERFORMANCE: Add composite index for efficient customer usage history queries\n   129→    await client.query(`\n   130→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n   131→      ON usage_log(stripe_customer_id, created_at DESC)\n   132→    `);\n   133→\n   134→    // Webhook events table for idempotency\n   135→    await client.query(`\n   136→      CREATE TABLE IF NOT EXISTS webhook_events (\n   137→        id SERIAL PRIMARY KEY,\n   138→        event_id VARCHAR(255) UNIQUE NOT NULL,\n   139→        event_type VARCHAR(100),\n   140→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   141→      )\n   142→    `);\n   143→\n   144→    await client.query(`\n   145→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n   146→    `);\n   147→\n   148→    console.log('[UsageTracking] Database initialized');\n   149→  } finally {\n   150→    client.release();\n   151→  }\n   152→}\n   153→\n   154→/**\n   155→ * Get or create a user by Stripe customer ID\n   156→ * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n   157→ */\n   158→async function getOrCreateUser(stripeCustomerId, email = null) {\n   159→  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n   160→  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n   161→  const result = await pool.query(\n   162→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   163→     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   164→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   165→     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n   166→     RETURNING *`,\n   167→    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n   168→  );\n   169→\n   170→  return result.rows[0];\n   171→}\n   172→\n   173→/**\n   174→ * Check if a customer exists in the database (without creating)\n   175→ * SECURITY: Used to validate legacy auth attempts\n   176→ */\n   177→async function customerExists(stripeCustomerId) {\n   178→  if (!stripeCustomerId) return false;\n   179→\n   180→  try {\n   181→    const result = await pool.query(\n   182→      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n   183→      [stripeCustomerId]\n   184→    );\n   185→    return result.rows.length > 0;\n   186→  } catch (err) {\n   187→    console.error('[SPLICE] customerExists check failed:', err.message);\n   188→    return false;\n   189→  }\n   190→}\n   191→\n   192→/**\n   193→ * Get user's current credit balance\n   194→ */\n   195→async function getBalance(stripeCustomerId) {\n   196→  const user = await getOrCreateUser(stripeCustomerId);\n   197→  const hoursTotal = parseFloat(user.hours_total);\n   198→  const hoursRemaining = parseFloat(user.hours_remaining);\n   199→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   200→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   201→\n   202→  // Tier display names\n   203→  const tierNames = {\n   204→    starter: 'Starter',\n   205→    pro: 'Pro',\n   206→    team: 'Team',\n   207→    cancelled: 'Cancelled'\n   208→  };\n   209→\n   210→  // Calculate trial days remaining\n   211→  let trialDaysRemaining = null;\n   212→  let isOnTrial = false;\n   213→  if (user.trial_end) {\n   214→    const trialEnd = new Date(user.trial_end);\n   215→    const now = new Date();\n   216→    const diffMs = trialEnd.getTime() - now.getTime();\n   217→    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n   218→    if (diffDays > 0) {\n   219→      trialDaysRemaining = diffDays;\n   220→      isOnTrial = true;\n   221→    }\n   222→  }\n   223→\n   224→  return {\n   225→    hoursRemaining,\n   226→    hoursTotal,\n   227→    isolationHoursRemaining,\n   228→    isolationHoursTotal,\n   229→    tier: user.tier,\n   230→    tierName: tierNames[user.tier] || user.tier,\n   231→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   232→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   233→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   234→    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   235→    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n   236→    trialDaysRemaining,\n   237→    isOnTrial,\n   238→    email: user.email,\n   239→    emailVerified: user.email_verified === true\n   240→  };\n   241→}\n   242→\n   243→/**\n   244→ * Check if user has enough credits for estimated duration\n   245→ */\n   246→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n   247→  const balance = await getBalance(stripeCustomerId);\n   248→  const estimatedHours = estimatedSeconds / 3600;\n   249→  return balance.hoursRemaining >= estimatedHours;\n   250→}\n   251→\n   252→/**\n   253→ * Reserve credits atomically using SELECT ... FOR UPDATE\n   254→ * This prevents race conditions where multiple requests pass credit check\n   255→ * before any deduction occurs.\n   256→ *\n   257→ * @param {string} stripeCustomerId - Customer ID\n   258→ * @param {number} estimatedSeconds - Estimated processing time in seconds\n   259→ * @param {string} endpoint - Endpoint name for tracking\n   260→ * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n   261→ */\n   262→async function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n   263→  const estimatedHours = estimatedSeconds / 3600;\n   264→  const client = await pool.connect();\n   265→\n   266→  try {\n   267→    await client.query('BEGIN');\n   268→\n   269→    // Lock the row for this customer - prevents concurrent modifications\n   270→    const result = await client.query(\n   271→      `SELECT id, hours_remaining FROM users\n   272→       WHERE stripe_customer_id = $1\n   273→       FOR UPDATE`,\n   274→      [stripeCustomerId]\n   275→    );\n   276→\n   277→    if (result.rows.length === 0) {\n   278→      // Create user if doesn't exist (within transaction)\n   279→      const newUser = await client.query(\n   280→        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n   281→         VALUES ($1, 'starter', $2, $2)\n   282→         RETURNING id, hours_remaining`,\n   283→        [stripeCustomerId, TIER_HOURS.starter]\n   284→      );\n   285→      result.rows = newUser.rows;\n   286→    }\n   287→\n   288→    const user = result.rows[0];\n   289→    const hoursRemaining = parseFloat(user.hours_remaining);\n   290→\n   291→    // Check if enough credits\n   292→    if (hoursRemaining < estimatedHours) {\n   293→      await client.query('ROLLBACK');\n   294→      return {\n   295→        success: false,\n   296→        error: 'Insufficient credits',\n   297→        hoursRemaining,\n   298→        hoursRequired: estimatedHours\n   299→      };\n   300→    }\n   301→\n   302→    // Generate unique reservation ID\n   303→    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   304→\n   305→    // Reserve credits by deducting the estimated amount\n   306→    await client.query(\n   307→      `UPDATE users\n   308→       SET hours_remaining = hours_remaining - $1,\n   309→           updated_at = CURRENT_TIMESTAMP\n   310→       WHERE stripe_customer_id = $2`,\n   311→      [estimatedHours, stripeCustomerId]\n   312→    );\n   313→\n   314→    // Log the reservation\n   315→    await client.query(\n   316→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   317→       VALUES ($1, $2, $3, $4, $5)`,\n   318→      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n   319→    );\n   320→\n   321→    await client.query('COMMIT');\n   322→\n   323→    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n   324→\n   325→    return {\n   326→      success: true,\n   327→      reservationId,\n   328→      hoursReserved: estimatedHours,\n   329→      hoursRemaining: hoursRemaining - estimatedHours\n   330→    };\n   331→  } catch (err) {\n   332→    await client.query('ROLLBACK');\n   333→    console.error('[UsageTracking] Reservation error:', err);\n   334→    throw err;\n   335→  } finally {\n   336→    client.release();\n   337→  }\n   338→}\n   339→\n   340→/**\n   341→ * Confirm a reservation (finalize usage) or adjust for actual duration\n   342→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   343→ *\n   344→ * @param {string} stripeCustomerId - Customer ID\n   345→ * @param {number} actualSeconds - Actual processing time in seconds\n   346→ * @param {number} reservedSeconds - Originally reserved seconds\n   347→ * @param {string} endpoint - Endpoint name\n   348→ * @returns {Promise<object>} Updated balance\n   349→ */\n   350→async function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n   351→  const actualHours = actualSeconds / 3600;\n   352→  const reservedHours = reservedSeconds / 3600;\n   353→  const difference = reservedHours - actualHours;\n   354→\n   355→  const client = await pool.connect();\n   356→  try {\n   357→    await client.query('BEGIN');\n   358→\n   359→    // Lock the row and get current state\n   360→    const result = await client.query(\n   361→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   362→       FROM users\n   363→       WHERE stripe_customer_id = $1\n   364→       FOR UPDATE`,\n   365→      [stripeCustomerId]\n   366→    );\n   367→\n   368→    if (result.rows.length === 0) {\n   369→      await client.query('ROLLBACK');\n   370→      throw new Error('User not found');\n   371→    }\n   372→\n   373→    let user = result.rows[0];\n   374→\n   375→    // If actual usage was less than reserved, refund the difference\n   376→    if (difference > 0) {\n   377→      const updateResult = await client.query(\n   378→        `UPDATE users\n   379→         SET hours_remaining = hours_remaining + $1,\n   380→             updated_at = CURRENT_TIMESTAMP\n   381→         WHERE stripe_customer_id = $2\n   382→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   383→        [difference, stripeCustomerId]\n   384→      );\n   385→      user = { ...user, ...updateResult.rows[0] };\n   386→\n   387→      // Log the adjustment\n   388→      await client.query(\n   389→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   390→         VALUES ($1, $2, $3, $4, $5)`,\n   391→        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n   392→      );\n   393→    } else if (difference < 0) {\n   394→      // Actual usage was more than reserved - deduct the extra\n   395→      const updateResult = await client.query(\n   396→        `UPDATE users\n   397→         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   398→             updated_at = CURRENT_TIMESTAMP\n   399→         WHERE stripe_customer_id = $2\n   400→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   401→        [-difference, stripeCustomerId]\n   402→      );\n   403→      user = { ...user, ...updateResult.rows[0] };\n   404→\n   405→      // Log the additional usage\n   406→      await client.query(\n   407→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   408→         VALUES ($1, $2, $3, $4, $5)`,\n   409→        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n   410→      );\n   411→    }\n   412→\n   413→    await client.query('COMMIT');\n   414→\n   415→    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n   416→\n   417→    // Build balance from data we already have (no extra SELECT needed)\n   418→    const hoursTotal = parseFloat(user.hours_total);\n   419→    const hoursRemaining = parseFloat(user.hours_remaining);\n   420→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   421→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   422→\n   423→    const tierNames = {\n   424→      starter: 'Starter',\n   425→      pro: 'Pro',\n   426→      team: 'Team',\n   427→      cancelled: 'Cancelled'\n   428→    };\n   429→\n   430→    return {\n   431→      hoursRemaining,\n   432→      hoursTotal,\n   433→      isolationHoursRemaining,\n   434→      isolationHoursTotal,\n   435→      tier: user.tier,\n   436→      tierName: tierNames[user.tier] || user.tier,\n   437→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   438→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   439→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   440→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   441→    };\n   442→  } catch (err) {\n   443→    await client.query('ROLLBACK');\n   444→    throw err;\n   445→  } finally {\n   446→    client.release();\n   447→  }\n   448→}\n   449→\n   450→/**\n   451→ * Release a reservation (refund credits on processing failure)\n   452→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   453→ *\n   454→ * @param {string} stripeCustomerId - Customer ID\n   455→ * @param {number} reservedSeconds - Originally reserved seconds\n   456→ * @param {string} endpoint - Endpoint name\n   457→ * @param {string} reason - Reason for release\n   458→ * @returns {Promise<object>} Updated balance\n   459→ */\n   460→async function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n   461→  const reservedHours = reservedSeconds / 3600;\n   462→\n   463→  const client = await pool.connect();\n   464→  try {\n   465→    await client.query('BEGIN');\n   466→\n   467→    // Lock the row and get id for logging\n   468→    const result = await client.query(\n   469→      `SELECT id FROM users\n   470→       WHERE stripe_customer_id = $1\n   471→       FOR UPDATE`,\n   472→      [stripeCustomerId]\n   473→    );\n   474→\n   475→    if (result.rows.length === 0) {\n   476→      await client.query('ROLLBACK');\n   477→      throw new Error('User not found');\n   478→    }\n   479→\n   480→    const userId = result.rows[0].id;\n   481→\n   482→    // Refund the reserved amount with RETURNING\n   483→    const updateResult = await client.query(\n   484→      `UPDATE users\n   485→       SET hours_remaining = hours_remaining + $1,\n   486→           updated_at = CURRENT_TIMESTAMP\n   487→       WHERE stripe_customer_id = $2\n   488→       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   489→      [reservedHours, stripeCustomerId]\n   490→    );\n   491→\n   492→    const user = updateResult.rows[0];\n   493→\n   494→    // Log the refund\n   495→    await client.query(\n   496→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   497→       VALUES ($1, $2, $3, $4, $5)`,\n   498→      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n   499→    );\n   500→\n   501→    await client.query('COMMIT');\n   502→\n   503→    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n   504→\n   505→    // Build balance from RETURNING data (no extra SELECT needed)\n   506→    const hoursTotal = parseFloat(user.hours_total);\n   507→    const hoursRemaining = parseFloat(user.hours_remaining);\n   508→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   509→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   510→\n   511→    const tierNames = {\n   512→      starter: 'Starter',\n   513→      pro: 'Pro',\n   514→      team: 'Team',\n   515→      cancelled: 'Cancelled'\n   516→    };\n   517→\n   518→    return {\n   519→      hoursRemaining,\n   520→      hoursTotal,\n   521→      isolationHoursRemaining,\n   522→      isolationHoursTotal,\n   523→      tier: user.tier,\n   524→      tierName: tierNames[user.tier] || user.tier,\n   525→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   526→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   527→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   528→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   529→    };\n   530→  } catch (err) {\n   531→    await client.query('ROLLBACK');\n   532→    throw err;\n   533→  } finally {\n   534→    client.release();\n   535→  }\n   536→}\n   537→\n   538→/**\n   539→ * Check if user can use vocal isolation\n   540→ * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n   541→ */\n   542→async function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n   543→  const balance = await getBalance(stripeCustomerId);\n   544→\n   545→  // Starter tier has no isolation access\n   546→  if (!balance.hasIsolationAccess) {\n   547→    return {\n   548→      allowed: false,\n   549→      reason: 'upgrade_required',\n   550→      message: 'Vocal isolation requires Pro or Team tier',\n   551→      hasIncludedHours: false,\n   552→      overageRequired: false,\n   553→      overageCost: 0\n   554→    };\n   555→  }\n   556→\n   557→  const estimatedHours = estimatedMinutes / 60;\n   558→  const remainingIncluded = balance.isolationHoursRemaining;\n   559→\n   560→  // Check if within included hours\n   561→  if (remainingIncluded >= estimatedHours) {\n   562→    return {\n   563→      allowed: true,\n   564→      reason: 'included',\n   565→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   566→      hasIncludedHours: true,\n   567→      overageRequired: false,\n   568→      overageCost: 0,\n   569→      isolationHoursRemaining: remainingIncluded - estimatedHours\n   570→    };\n   571→  }\n   572→\n   573→  // Calculate overage\n   574→  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n   575→  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   576→\n   577→  return {\n   578→    allowed: true,\n   579→    reason: 'overage',\n   580→    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n   581→    hasIncludedHours: remainingIncluded > 0,\n   582→    overageRequired: true,\n   583→    overageMinutes,\n   584→    overageCost,\n   585→    isolationHoursRemaining: 0\n   586→  };\n   587→}\n   588→\n   589→/**\n   590→ * Deduct isolation usage from user's balance\n   591→ * Returns overage cost if beyond included hours\n   592→ * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n   593→ */\n   594→async function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n   595→  const durationMinutes = audioDurationSeconds / 60;\n   596→  const durationHours = audioDurationSeconds / 3600;\n   597→\n   598→  const client = await pool.connect();\n   599→  try {\n   600→    await client.query('BEGIN');\n   601→\n   602→    // Lock the row for this customer - prevents concurrent modifications\n   603→    const userResult = await client.query(\n   604→      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n   605→       FROM users WHERE stripe_customer_id = $1\n   606→       FOR UPDATE`,\n   607→      [stripeCustomerId]\n   608→    );\n   609→\n   610→    if (userResult.rows.length === 0) {\n   611→      await client.query('ROLLBACK');\n   612→      throw new Error('User not found');\n   613→    }\n   614→\n   615→    const user = userResult.rows[0];\n   616→    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n   617→\n   618→    let overageCost = 0;\n   619→    let hoursFromIncluded = 0;\n   620→    let overageMinutes = 0;\n   621→\n   622→    if (remainingIncluded >= durationHours) {\n   623→      // Fully covered by included hours\n   624→      hoursFromIncluded = durationHours;\n   625→    } else {\n   626→      // Partial or full overage\n   627→      hoursFromIncluded = remainingIncluded;\n   628→      overageMinutes = durationMinutes - (remainingIncluded * 60);\n   629→      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   630→    }\n   631→\n   632→    // Update isolation balance with RETURNING to get new values\n   633→    const updateResult = await client.query(\n   634→      `UPDATE users\n   635→       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n   636→           updated_at = CURRENT_TIMESTAMP\n   637→       WHERE stripe_customer_id = $2\n   638→       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n   639→      [durationHours, stripeCustomerId]\n   640→    );\n   641→\n   642→    const updatedUser = updateResult.rows[0];\n   643→\n   644→    // Log usage (mark as isolation)\n   645→    await client.query(\n   646→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   647→       VALUES ($1, $2, $3, $4, $5)`,\n   648→      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n   649→    );\n   650→\n   651→    await client.query('COMMIT');\n   652→\n   653→    // Build balance from RETURNING data (no extra SELECT needed)\n   654→    const hoursTotal = parseFloat(updatedUser.hours_total);\n   655→    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n   656→    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n   657→    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n   658→\n   659→    const tierNames = {\n   660→      starter: 'Starter',\n   661→      pro: 'Pro',\n   662→      team: 'Team',\n   663→      cancelled: 'Cancelled'\n   664→    };\n   665→\n   666→    return {\n   667→      hoursRemaining,\n   668→      hoursTotal,\n   669→      isolationHoursRemaining,\n   670→      isolationHoursTotal,\n   671→      tier: updatedUser.tier,\n   672→      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n   673→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   674→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   675→      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n   676→      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   677→      isolationUsed: {\n   678→        durationMinutes,\n   679→        hoursFromIncluded,\n   680→        overageMinutes,\n   681→        overageCost\n   682→      }\n   683→    };\n   684→  } catch (err) {\n   685→    await client.query('ROLLBACK');\n   686→    throw err;\n   687→  } finally {\n   688→    client.release();\n   689→  }\n   690→}\n   691→\n   692→/**\n   693→ * Deduct usage from user's balance\n   694→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   695→ * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n   696→ * Reports overage to Stripe for billing when user exceeds included hours\n   697→ */\n   698→async function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n   699→  const hoursUsed = audioDurationSeconds / 3600;\n   700→\n   701→  const client = await pool.connect();\n   702→  try {\n   703→    await client.query('BEGIN');\n   704→\n   705→    // First get current balance to calculate overage\n   706→    const currentResult = await client.query(\n   707→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   708→       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n   709→      [stripeCustomerId]\n   710→    );\n   711→\n   712→    if (currentResult.rows.length === 0) {\n   713→      await client.query('ROLLBACK');\n   714→      throw new Error('User not found');\n   715→    }\n   716→\n   717→    const currentUser = currentResult.rows[0];\n   718→    const currentRemaining = parseFloat(currentUser.hours_remaining);\n   719→\n   720→    // Calculate overage (hours used beyond what's remaining)\n   721→    let overageHours = 0;\n   722→    if (hoursUsed > currentRemaining) {\n   723→      overageHours = hoursUsed - currentRemaining;\n   724→    }\n   725→\n   726→    // Update balance (clamp at 0)\n   727→    const updateResult = await client.query(\n   728→      `UPDATE users\n   729→       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   730→           updated_at = CURRENT_TIMESTAMP\n   731→       WHERE stripe_customer_id = $2\n   732→       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   733→      [hoursUsed, stripeCustomerId]\n   734→    );\n   735→\n   736→    const user = updateResult.rows[0];\n   737→\n   738→    // Log usage\n   739→    await client.query(\n   740→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   741→       VALUES ($1, $2, $3, $4, $5)`,\n   742→      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n   743→    );\n   744→\n   745→    await client.query('COMMIT');\n   746→\n   747→    // Report overage to Stripe if any (after commit to not block transaction)\n   748→    let overageCharge = 0;\n   749→    if (overageHours > 0) {\n   750→      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n   751→      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n   752→      if (usageReport.success) {\n   753→        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n   754→      } else {\n   755→        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n   756→      }\n   757→    }\n   758→\n   759→    // Build balance from RETURNING data (no extra SELECT needed)\n   760→    const hoursTotal = parseFloat(user.hours_total);\n   761→    const hoursRemaining = parseFloat(user.hours_remaining);\n   762→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   763→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   764→\n   765→    const tierNames = {\n   766→      starter: 'Starter',\n   767→      pro: 'Pro',\n   768→      team: 'Team',\n   769→      cancelled: 'Cancelled'\n   770→    };\n   771→\n   772→    return {\n   773→      hoursRemaining,\n   774→      hoursTotal,\n   775→      isolationHoursRemaining,\n   776→      isolationHoursTotal,\n   777→      tier: user.tier,\n   778→      tierName: tierNames[user.tier] || user.tier,\n   779→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   780→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   781→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   782→      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   783→      overageHours,\n   784→      overageCharge\n   785→    };\n   786→  } catch (err) {\n   787→    await client.query('ROLLBACK');\n   788→    throw err;\n   789→  } finally {\n   790→    client.release();\n   791→  }\n   792→}\n   793→\n   794→/**\n   795→ * Reset user's hours for new billing period\n   796→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   797→ */\n   798→async function resetHours(stripeCustomerId, tier) {\n   799→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   800→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   801→\n   802→  const result = await pool.query(\n   803→    `UPDATE users\n   804→     SET hours_remaining = $1, hours_total = $1,\n   805→         isolation_hours_remaining = $2, isolation_hours_total = $2,\n   806→         tier = $3, updated_at = CURRENT_TIMESTAMP\n   807→     WHERE stripe_customer_id = $4\n   808→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   809→    [hours, isolationHours, tier, stripeCustomerId]\n   810→  );\n   811→\n   812→  if (result.rows.length === 0) {\n   813→    // User doesn't exist, create and return default balance\n   814→    return await getBalance(stripeCustomerId);\n   815→  }\n   816→\n   817→  const user = result.rows[0];\n   818→  const hoursTotal = parseFloat(user.hours_total);\n   819→  const hoursRemaining = parseFloat(user.hours_remaining);\n   820→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   821→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   822→\n   823→  const tierNames = {\n   824→    starter: 'Starter',\n   825→    pro: 'Pro',\n   826→    team: 'Team',\n   827→    cancelled: 'Cancelled'\n   828→  };\n   829→\n   830→  return {\n   831→    hoursRemaining,\n   832→    hoursTotal,\n   833→    isolationHoursRemaining,\n   834→    isolationHoursTotal,\n   835→    tier: user.tier,\n   836→    tierName: tierNames[user.tier] || user.tier,\n   837→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   838→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   839→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   840→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   841→  };\n   842→}\n   843→\n   844→/**\n   845→ * Update user's tier (from Stripe webhook)\n   846→ * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n   847→ */\n   848→async function updateTier(stripeCustomerId, tier, email = null) {\n   849→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   850→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   851→\n   852→  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n   853→  const result = await pool.query(\n   854→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   855→     VALUES ($1, $2, $3, $4, $4, $5, $5)\n   856→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   857→     SET tier = $3, hours_remaining = $4, hours_total = $4,\n   858→         isolation_hours_remaining = $5, isolation_hours_total = $5,\n   859→         updated_at = CURRENT_TIMESTAMP\n   860→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   861→    [stripeCustomerId, email, tier, hours, isolationHours]\n   862→  );\n   863→\n   864→  const user = result.rows[0];\n   865→  const hoursTotal = parseFloat(user.hours_total);\n   866→  const hoursRemaining = parseFloat(user.hours_remaining);\n   867→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   868→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   869→\n   870→  const tierNames = {\n   871→    starter: 'Starter',\n   872→    pro: 'Pro',\n   873→    team: 'Team',\n   874→    cancelled: 'Cancelled'\n   875→  };\n   876→\n   877→  return {\n   878→    hoursRemaining,\n   879→    hoursTotal,\n   880→    isolationHoursRemaining,\n   881→    isolationHoursTotal,\n   882→    tier: user.tier,\n   883→    tierName: tierNames[user.tier] || user.tier,\n   884→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   885→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   886→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   887→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   888→  };\n   889→}\n   890→\n   891→/**\n   892→ * Get usage history for a user\n   893→ */\n   894→async function getUsageHistory(stripeCustomerId, limit = 50) {\n   895→  const result = await pool.query(\n   896→    `SELECT * FROM usage_log\n   897→     WHERE stripe_customer_id = $1\n   898→     ORDER BY created_at DESC\n   899→     LIMIT $2`,\n   900→    [stripeCustomerId, limit]\n   901→  );\n   902→  return result.rows;\n   903→}\n   904→\n   905→/**\n   906→ * Check if webhook event has already been processed (idempotency)\n   907→ */\n   908→async function isEventProcessed(eventId) {\n   909→  const result = await pool.query(\n   910→    'SELECT id FROM webhook_events WHERE event_id = $1',\n   911→    [eventId]\n   912→  );\n   913→  return result.rows.length > 0;\n   914→}\n   915→\n   916→/**\n   917→ * Record a processed webhook event\n   918→ */\n   919→async function recordWebhookEvent(eventId, eventType) {\n   920→  try {\n   921→    await pool.query(\n   922→      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n   923→      [eventId, eventType]\n   924→    );\n   925→  } catch (err) {\n   926→    // Ignore duplicate key errors (race condition safety)\n   927→    if (err.code !== '23505') throw err;\n   928→  }\n   929→}\n   930→\n   931→// =============================================================================\n   932→// Music Credits Functions (Phase 4 - AI Music Feature)\n   933→// =============================================================================\n   934→\n   935→// Music credits per tier\n   936→// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n   937→const TIER_MUSIC_CREDITS = {\n   938→  starter: 2,    // 2 songs/month\n   939→  pro: 10,       // 10 songs/month\n   940→  team: 50,      // 50 songs/month\n   941→  cancelled: 0\n   942→};\n   943→\n   944→// Feature access by tier - defines which features each tier can use\n   945→const TIER_FEATURES = {\n   946→  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n   947→  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n   948→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n   949→    'profanity_detection', 'chapter_detection'],\n   950→  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n   951→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n   952→    'profanity_detection', 'chapter_detection', 'multitrack',\n   953→    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n   954→  cancelled: []\n   955→};\n   956→\n   957→/**\n   958→ * Check if a tier has access to a specific feature\n   959→ * @param {string} tier - User's tier (starter, pro, team)\n   960→ * @param {string} feature - Feature name to check\n   961→ * @returns {boolean}\n   962→ */\n   963→function hasFeatureAccess(tier, feature) {\n   964→  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n   965→  return tierFeatures.includes(feature);\n   966→}\n   967→\n   968→// Flat overage rate for music (simplified pricing)\n   969→const MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n   970→\n   971→// Legacy overage rates (kept for backwards compatibility)\n   972→const MUSIC_OVERAGE_RATES = {\n   973→  starter: 1.00,  // $1.00/song\n   974→  pro: 1.00,      // $1.00/song\n   975→  team: 1.00      // $1.00/song\n   976→};\n   977→\n   978→/**\n   979→ * Get music credits balance for a customer\n   980→ * @param {string} stripeCustomerId - Stripe customer ID\n   981→ * @returns {Promise<{remaining: number, total: number, tier: string}>}\n   982→ */\n   983→async function getMusicCredits(stripeCustomerId) {\n   984→  const result = await pool.query(\n   985→    `SELECT music_credits_remaining, music_credits_total, tier\n   986→     FROM users\n   987→     WHERE stripe_customer_id = $1`,\n   988→    [stripeCustomerId]\n   989→  );\n   990→\n   991→  if (result.rows.length === 0) {\n   992→    return { remaining: 0, total: 0, tier: 'starter' };\n   993→  }\n   994→\n   995→  const row = result.rows[0];\n   996→  return {\n   997→    remaining: row.music_credits_remaining || 0,\n   998→    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n   999→    tier: row.tier || 'starter'\n  1000→  };\n  1001→}\n  1002→\n  1003→/**\n  1004→ * Check if customer has music credits available\n  1005→ * @param {string} stripeCustomerId - Stripe customer ID\n  1006→ * @returns {Promise<boolean>}\n  1007→ */\n  1008→async function hasMusicCredits(stripeCustomerId) {\n  1009→  const credits = await getMusicCredits(stripeCustomerId);\n  1010→  return credits.remaining > 0;\n  1011→}\n  1012→\n  1013→/**\n  1014→ * Deduct one music credit from customer\n  1015→ * @param {string} stripeCustomerId - Stripe customer ID\n  1016→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1017→ */\n  1018→async function deductMusicCredit(stripeCustomerId) {\n  1019→  const client = await pool.connect();\n  1020→  try {\n  1021→    await client.query('BEGIN');\n  1022→\n  1023→    // Lock row for update\n  1024→    const result = await client.query(\n  1025→      `SELECT music_credits_remaining, tier\n  1026→       FROM users\n  1027→       WHERE stripe_customer_id = $1\n  1028→       FOR UPDATE`,\n  1029→      [stripeCustomerId]\n  1030→    );\n  1031→\n  1032→    if (result.rows.length === 0) {\n  1033→      await client.query('ROLLBACK');\n  1034→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1035→    }\n  1036→\n  1037→    const { music_credits_remaining } = result.rows[0];\n  1038→    let charged = 0;\n  1039→\n  1040→    if (music_credits_remaining > 0) {\n  1041→      // Deduct from included credits\n  1042→      await client.query(\n  1043→        `UPDATE users\n  1044→         SET music_credits_remaining = music_credits_remaining - 1,\n  1045→             updated_at = CURRENT_TIMESTAMP\n  1046→         WHERE stripe_customer_id = $1`,\n  1047→        [stripeCustomerId]\n  1048→      );\n  1049→    } else {\n  1050→      // Overage - charge flat rate ($1/song)\n  1051→      charged = MUSIC_OVERAGE_RATE;\n  1052→\n  1053→      // Report overage to Stripe meter for billing\n  1054→      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n  1055→      if (usageReport.success) {\n  1056→        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n  1057→      } else {\n  1058→        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n  1059→      }\n  1060→    }\n  1061→\n  1062→    // Log the usage\n  1063→    await client.query(\n  1064→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1065→       VALUES ($1, 1, $2)\n  1066→       ON CONFLICT DO NOTHING`,\n  1067→      [stripeCustomerId, charged]\n  1068→    );\n  1069→\n  1070→    await client.query('COMMIT');\n  1071→\n  1072→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1073→    return {\n  1074→      success: true,\n  1075→      remaining: newCredits.remaining,\n  1076→      charged\n  1077→    };\n  1078→\n  1079→  } catch (err) {\n  1080→    await client.query('ROLLBACK');\n  1081→    console.error('[SPLICE] Music credit deduction error:', err.message);\n  1082→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1083→  } finally {\n  1084→    client.release();\n  1085→  }\n  1086→}\n  1087→\n  1088→/**\n  1089→ * Reset music credits based on tier (called on subscription renewal)\n  1090→ * @param {string} stripeCustomerId - Stripe customer ID\n  1091→ * @param {string} tier - Subscription tier\n  1092→ */\n  1093→async function resetMusicCredits(stripeCustomerId, tier) {\n  1094→  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  1095→  const client = await pool.connect();\n  1096→\n  1097→  try {\n  1098→    await client.query('BEGIN');\n  1099→\n  1100→    // Lock row for update to prevent race conditions\n  1101→    const result = await client.query(\n  1102→      `SELECT id FROM users\n  1103→       WHERE stripe_customer_id = $1\n  1104→       FOR UPDATE`,\n  1105→      [stripeCustomerId]\n  1106→    );\n  1107→\n  1108→    if (result.rows.length === 0) {\n  1109→      await client.query('ROLLBACK');\n  1110→      console.warn(`[SPLICE] resetMusicCredits: User not found for ${stripeCustomerId}`);\n  1111→      return;\n  1112→    }\n  1113→\n  1114→    await client.query(\n  1115→      `UPDATE users\n  1116→       SET music_credits_remaining = $2,\n  1117→           music_credits_total = $2,\n  1118→           music_credits_reset_at = CURRENT_TIMESTAMP,\n  1119→           updated_at = CURRENT_TIMESTAMP\n  1120→       WHERE stripe_customer_id = $1`,\n  1121→      [stripeCustomerId, credits]\n  1122→    );\n  1123→\n  1124→    await client.query('COMMIT');\n  1125→  } catch (err) {\n  1126→    await client.query('ROLLBACK');\n  1127→    console.error('[SPLICE] Music credit reset error:', err.message);\n  1128→    throw err;\n  1129→  } finally {\n  1130→    client.release();\n  1131→  }\n  1132→}\n  1133→\n  1134→/**\n  1135→ * Add music credits (for promotional or overage purchases)\n  1136→ * @param {string} stripeCustomerId - Stripe customer ID\n  1137→ * @param {number} credits - Number of credits to add\n  1138→ * @returns {Promise<{success: boolean, newBalance: number}>}\n  1139→ */\n  1140→async function addMusicCredits(stripeCustomerId, credits) {\n  1141→  const client = await pool.connect();\n  1142→  try {\n  1143→    await client.query('BEGIN');\n  1144→\n  1145→    // Lock row for update to prevent concurrent modification\n  1146→    const lockResult = await client.query(\n  1147→      `SELECT music_credits_remaining\n  1148→       FROM users\n  1149→       WHERE stripe_customer_id = $1\n  1150→       FOR UPDATE`,\n  1151→      [stripeCustomerId]\n  1152→    );\n  1153→\n  1154→    if (lockResult.rows.length === 0) {\n  1155→      await client.query('ROLLBACK');\n  1156→      return { success: false, newBalance: 0, error: 'User not found' };\n  1157→    }\n  1158→\n  1159→    // Update the credits\n  1160→    const result = await client.query(\n  1161→      `UPDATE users\n  1162→       SET music_credits_remaining = music_credits_remaining + $2,\n  1163→           updated_at = CURRENT_TIMESTAMP\n  1164→       WHERE stripe_customer_id = $1\n  1165→       RETURNING music_credits_remaining`,\n  1166→      [stripeCustomerId, credits]\n  1167→    );\n  1168→\n  1169→    await client.query('COMMIT');\n  1170→\n  1171→    return {\n  1172→      success: true,\n  1173→      newBalance: result.rows[0].music_credits_remaining\n  1174→    };\n  1175→\n  1176→  } catch (err) {\n  1177→    await client.query('ROLLBACK');\n  1178→    console.error('[SPLICE] Music credit addition error:', err.message);\n  1179→    return { success: false, newBalance: 0, error: err.message };\n  1180→  } finally {\n  1181→    client.release();\n  1182→  }\n  1183→}\n  1184→\n  1185→/**\n  1186→ * Get music usage history for a customer\n  1187→ * @param {string} stripeCustomerId - Stripe customer ID\n  1188→ * @param {number} limit - Max records to return\n  1189→ * @returns {Promise<Object[]>}\n  1190→ */\n  1191→async function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  1192→  const result = await pool.query(\n  1193→    `SELECT * FROM music_usage_log\n  1194→     WHERE stripe_customer_id = $1\n  1195→     ORDER BY created_at DESC\n  1196→     LIMIT $2`,\n  1197→    [stripeCustomerId, limit]\n  1198→  );\n  1199→  return result.rows;\n  1200→}\n  1201→\n  1202→/**\n  1203→ * Initialize music credits columns (migration helper)\n  1204→ */\n  1205→async function initMusicCreditsColumns() {\n  1206→  const client = await pool.connect();\n  1207→  try {\n  1208→    // Add music credits columns if they don't exist\n  1209→    // CRITICAL-003: Default music credits should be 2 (Starter tier), not 5\n  1210→    await client.query(`\n  1211→      DO $$\n  1212→      BEGIN\n  1213→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n  1214→          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 2;\n  1215→        END IF;\n  1216→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n  1217→          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 2;\n  1218→        END IF;\n  1219→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n  1220→          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n  1221→        END IF;\n  1222→      END $$;\n  1223→    `);\n  1224→\n  1225→    // Create music usage log table\n  1226→    await client.query(`\n  1227→      CREATE TABLE IF NOT EXISTS music_usage_log (\n  1228→        id SERIAL PRIMARY KEY,\n  1229→        stripe_customer_id VARCHAR(255) NOT NULL,\n  1230→        credits_used INTEGER DEFAULT 1,\n  1231→        overage_charged DECIMAL(10,2) DEFAULT 0,\n  1232→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n  1233→      )\n  1234→    `);\n  1235→\n  1236→    await client.query(`\n  1237→      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n  1238→      ON music_usage_log(stripe_customer_id)\n  1239→    `);\n  1240→\n  1241→    console.log('[SPLICE] Music credits columns initialized');\n  1242→  } finally {\n  1243→    client.release();\n  1244→  }\n  1245→}\n  1246→\n  1247→// Variations credits cost (equivalent to 2.5 music credits)\n  1248→const VARIATIONS_CREDIT_COST = 2.5;\n  1249→\n  1250→// Overage rates for variations (higher than single music due to 3 parallel generations)\n  1251→const VARIATIONS_OVERAGE_RATES = {\n  1252→  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  1253→  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  1254→  team: 0.50      // $0.50/variations (2.5x $0.20)\n  1255→};\n  1256→\n  1257→// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\n  1258→const SCENE_AWARE_CREDIT_COST = 1.5;\n  1259→\n  1260→// Overage rates for scene-aware music (75% margin)\n  1261→const SCENE_AWARE_OVERAGE_RATES = {\n  1262→  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  1263→  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  1264→  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n  1265→};\n  1266→\n  1267→/**\n  1268→ * Check if customer has enough credits for variations (2.5 credits)\n  1269→ * @param {string} stripeCustomerId - Stripe customer ID\n  1270→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1271→ */\n  1272→async function checkVariationsCredits(stripeCustomerId) {\n  1273→  const credits = await getMusicCredits(stripeCustomerId);\n  1274→  const creditsRequired = VARIATIONS_CREDIT_COST;\n  1275→\n  1276→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1277→  // Or if they're on a paid tier (overage allowed)\n  1278→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1279→\n  1280→  return {\n  1281→    canGenerate,\n  1282→    creditsAvailable: credits.remaining,\n  1283→    creditsRequired,\n  1284→    tier: credits.tier\n  1285→  };\n  1286→}\n  1287→\n  1288→/**\n  1289→ * Deduct variations credit from customer (2.5 credits worth)\n  1290→ * @param {string} stripeCustomerId - Stripe customer ID\n  1291→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1292→ */\n  1293→async function deductVariationsCredit(stripeCustomerId) {\n  1294→  const client = await pool.connect();\n  1295→  try {\n  1296→    await client.query('BEGIN');\n  1297→\n  1298→    // Lock row for update\n  1299→    const result = await client.query(\n  1300→      `SELECT music_credits_remaining, tier\n  1301→       FROM users\n  1302→       WHERE stripe_customer_id = $1\n  1303→       FOR UPDATE`,\n  1304→      [stripeCustomerId]\n  1305→    );\n  1306→\n  1307→    if (result.rows.length === 0) {\n  1308→      await client.query('ROLLBACK');\n  1309→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1310→    }\n  1311→\n  1312→    const { music_credits_remaining, tier } = result.rows[0];\n  1313→    let charged = 0;\n  1314→    let creditsDeducted = 0;\n  1315→\n  1316→    // Determine how many credits to deduct vs overage to charge\n  1317→    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n  1318→      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n  1319→      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n  1320→      await client.query(\n  1321→        `UPDATE users\n  1322→         SET music_credits_remaining = music_credits_remaining - $2,\n  1323→             updated_at = CURRENT_TIMESTAMP\n  1324→         WHERE stripe_customer_id = $1`,\n  1325→        [stripeCustomerId, creditsDeducted]\n  1326→      );\n  1327→    } else if (music_credits_remaining > 0) {\n  1328→      // Partial credits - deduct what they have and charge overage for the rest\n  1329→      const creditsPortion = music_credits_remaining;\n  1330→      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n  1331→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1332→      charged = overagePortion * overageRate;\n  1333→\n  1334→      creditsDeducted = creditsPortion;\n  1335→      await client.query(\n  1336→        `UPDATE users\n  1337→         SET music_credits_remaining = 0,\n  1338→             updated_at = CURRENT_TIMESTAMP\n  1339→         WHERE stripe_customer_id = $1`,\n  1340→        [stripeCustomerId]\n  1341→      );\n  1342→\n  1343→      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1344→    } else {\n  1345→      // No credits - full overage\n  1346→      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n  1347→      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1348→    }\n  1349→\n  1350→    // Log the usage\n  1351→    await client.query(\n  1352→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1353→       VALUES ($1, $2, $3)\n  1354→       ON CONFLICT DO NOTHING`,\n  1355→      [stripeCustomerId, creditsDeducted, charged]\n  1356→    );\n  1357→\n  1358→    await client.query('COMMIT');\n  1359→\n  1360→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1361→    return {\n  1362→      success: true,\n  1363→      remaining: newCredits.remaining,\n  1364→      creditsDeducted,\n  1365→      charged\n  1366→    };\n  1367→\n  1368→  } catch (err) {\n  1369→    await client.query('ROLLBACK');\n  1370→    console.error('[SPLICE] Variations credit deduction error:', err.message);\n  1371→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1372→  } finally {\n  1373→    client.release();\n  1374→  }\n  1375→}\n  1376→\n  1377→/**\n  1378→ * Check if customer has enough credits for scene-aware music (1.5 credits)\n  1379→ * @param {string} stripeCustomerId - Stripe customer ID\n  1380→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1381→ */\n  1382→async function checkSceneAwareCredits(stripeCustomerId) {\n  1383→  const credits = await getMusicCredits(stripeCustomerId);\n  1384→  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n  1385→\n  1386→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1387→  // Or if they're on a paid tier (overage allowed)\n  1388→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1389→\n  1390→  return {\n  1391→    canGenerate,\n  1392→    creditsAvailable: credits.remaining,\n  1393→    creditsRequired,\n  1394→    tier: credits.tier\n  1395→  };\n  1396→}\n  1397→\n  1398→/**\n  1399→ * Deduct scene-aware music credit from customer (1.5 credits worth)\n  1400→ * @param {string} stripeCustomerId - Stripe customer ID\n  1401→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1402→ */\n  1403→async function deductSceneAwareCredit(stripeCustomerId) {\n  1404→  const client = await pool.connect();\n  1405→  try {\n  1406→    await client.query('BEGIN');\n  1407→\n  1408→    // Lock row for update\n  1409→    const result = await client.query(\n  1410→      `SELECT music_credits_remaining, tier\n  1411→       FROM users\n  1412→       WHERE stripe_customer_id = $1\n  1413→       FOR UPDATE`,\n  1414→      [stripeCustomerId]\n  1415→    );\n  1416→\n  1417→    if (result.rows.length === 0) {\n  1418→      await client.query('ROLLBACK');\n  1419→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1420→    }\n  1421→\n  1422→    const { music_credits_remaining, tier } = result.rows[0];\n  1423→    let charged = 0;\n  1424→    let creditsDeducted = 0;\n  1425→\n  1426→    // Determine how many credits to deduct vs overage to charge\n  1427→    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n  1428→      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n  1429→      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n  1430→      await client.query(\n  1431→        `UPDATE users\n  1432→         SET music_credits_remaining = music_credits_remaining - $2,\n  1433→             updated_at = CURRENT_TIMESTAMP\n  1434→         WHERE stripe_customer_id = $1`,\n  1435→        [stripeCustomerId, creditsDeducted]\n  1436→      );\n  1437→    } else if (music_credits_remaining > 0) {\n  1438→      // Partial credits - deduct what they have and charge overage for the rest\n  1439→      const creditsPortion = music_credits_remaining;\n  1440→      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n  1441→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1442→      charged = overagePortion * overageRate;\n  1443→\n  1444→      creditsDeducted = creditsPortion;\n  1445→      await client.query(\n  1446→        `UPDATE users\n  1447→         SET music_credits_remaining = 0,\n  1448→             updated_at = CURRENT_TIMESTAMP\n  1449→         WHERE stripe_customer_id = $1`,\n  1450→        [stripeCustomerId]\n  1451→      );\n  1452→\n  1453→      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1454→    } else {\n  1455→      // No credits - full overage\n  1456→      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n  1457→      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1458→    }\n  1459→\n  1460→    // Log the usage\n  1461→    await client.query(\n  1462→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1463→       VALUES ($1, $2, $3)\n  1464→       ON CONFLICT DO NOTHING`,\n  1465→      [stripeCustomerId, creditsDeducted, charged]\n  1466→    );\n  1467→\n  1468→    await client.query('COMMIT');\n  1469→\n  1470→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1471→    return {\n  1472→      success: true,\n  1473→      remaining: newCredits.remaining,\n  1474→      creditsDeducted,\n  1475→      charged\n  1476→    };\n  1477→\n  1478→  } catch (err) {\n  1479→    await client.query('ROLLBACK');\n  1480→    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n  1481→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1482→  } finally {\n  1483→    client.release();\n  1484→  }\n  1485→}\n  1486→\n  1487→/**\n  1488→ * Close the database connection pool\n  1489→ * Used for graceful shutdown\n  1490→ */\n  1491→async function closePool() {\n  1492→  await pool.end();\n  1493→}\n  1494→\n  1495→/**\n  1496→ * Update trial end date for a customer\n  1497→ * @param {string} stripeCustomerId - Customer ID\n  1498→ * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n  1499→ */\n  1500→async function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  1501→  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n  1502→\n  1503→  await pool.query(\n  1504→    `UPDATE users\n  1505→     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n  1506→     WHERE stripe_customer_id = $1`,\n  1507→    [stripeCustomerId, trialEnd]\n  1508→  );\n  1509→\n  1510→  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n  1511→}\n  1512→\n  1513→/**\n  1514→ * Check database connectivity\n  1515→ * Used for health checks\n  1516→ */\n  1517→async function checkDatabase() {\n  1518→  const client = await pool.connect();\n  1519→  try {\n  1520→    const result = await client.query('SELECT 1 as health');\n  1521→    return result.rows[0].health === 1;\n  1522→  } finally {\n  1523→    client.release();\n  1524→  }\n  1525→}\n  1526→\n  1527→// =============================================================================\n  1528→// Email Verification Functions\n  1529→// =============================================================================\n  1530→\n  1531→/**\n  1532→ * Mark a user's email as verified\n  1533→ * @param {string} email - Email address that was verified\n  1534→ * @returns {Promise<{success: boolean, error?: string}>}\n  1535→ */\n  1536→async function markEmailVerified(email) {\n  1537→  if (!email) {\n  1538→    return { success: false, error: 'Email is required' };\n  1539→  }\n  1540→\n  1541→  const normalizedEmail = email.toLowerCase().trim();\n  1542→\n  1543→  try {\n  1544→    const result = await pool.query(\n  1545→      `UPDATE users\n  1546→       SET email_verified = TRUE,\n  1547→           email_verified_at = CURRENT_TIMESTAMP,\n  1548→           updated_at = CURRENT_TIMESTAMP\n  1549→       WHERE LOWER(email) = $1\n  1550→       RETURNING stripe_customer_id, email_verified`,\n  1551→      [normalizedEmail]\n  1552→    );\n  1553→\n  1554→    if (result.rows.length === 0) {\n  1555→      // No user found with this email - this is OK for new signups\n  1556→      console.log(`[SPLICE] No user found for email verification: ${normalizedEmail}`);\n  1557→      return { success: true, userFound: false };\n  1558→    }\n  1559→\n  1560→    console.log(`[SPLICE] Email verified for user: ${result.rows[0].stripe_customer_id}`);\n  1561→    return { success: true, userFound: true, customerId: result.rows[0].stripe_customer_id };\n  1562→  } catch (err) {\n  1563→    console.error('[SPLICE] markEmailVerified error:', err.message);\n  1564→    return { success: false, error: err.message };\n  1565→  }\n  1566→}\n  1567→\n  1568→/**\n  1569→ * Check if a user's email is verified\n  1570→ * @param {string} stripeCustomerId - Stripe customer ID\n  1571→ * @returns {Promise<{verified: boolean, verifiedAt?: Date}>}\n  1572→ */\n  1573→async function isEmailVerified(stripeCustomerId) {\n  1574→  try {\n  1575→    const result = await pool.query(\n  1576→      `SELECT email_verified, email_verified_at\n  1577→       FROM users\n  1578→       WHERE stripe_customer_id = $1`,\n  1579→      [stripeCustomerId]\n  1580→    );\n  1581→\n  1582→    if (result.rows.length === 0) {\n  1583→      return { verified: false };\n  1584→    }\n  1585→\n  1586→    return {\n  1587→      verified: result.rows[0].email_verified === true,\n  1588→      verifiedAt: result.rows[0].email_verified_at\n  1589→    };\n  1590→  } catch (err) {\n  1591→    console.error('[SPLICE] isEmailVerified error:', err.message);\n  1592→    return { verified: false };\n  1593→  }\n  1594→}\n  1595→\n  1596→/**\n  1597→ * Get user by email address\n  1598→ * @param {string} email - Email address\n  1599→ * @returns {Promise<Object|null>} User object or null\n  1600→ */\n  1601→async function getUserByEmail(email) {\n  1602→  if (!email) return null;\n  1603→\n  1604→  const normalizedEmail = email.toLowerCase().trim();\n  1605→\n  1606→  try {\n  1607→    const result = await pool.query(\n  1608→      `SELECT stripe_customer_id, email, tier, email_verified, email_verified_at\n  1609→       FROM users\n  1610→       WHERE LOWER(email) = $1`,\n  1611→      [normalizedEmail]\n  1612→    );\n  1613→\n  1614→    return result.rows.length > 0 ? result.rows[0] : null;\n  1615→  } catch (err) {\n  1616→    console.error('[SPLICE] getUserByEmail error:', err.message);\n  1617→    return null;\n  1618→  }\n  1619→}\n  1620→\n  1621→module.exports = {\n  1622→  initDatabase,\n  1623→  getOrCreateUser,\n  1624→  customerExists,\n  1625→  getBalance,\n  1626→  hasCredits,\n  1627→  reserveCredits,\n  1628→  confirmReservation,\n  1629→  releaseReservation,\n  1630→  checkIsolationAccess,\n  1631→  deductUsage,\n  1632→  deductIsolationUsage,\n  1633→  resetHours,\n  1634→  updateTier,\n  1635→  getUsageHistory,\n  1636→  isEventProcessed,\n  1637→  recordWebhookEvent,\n  1638→  // Music credits functions\n  1639→  getMusicCredits,\n  1640→  hasMusicCredits,\n  1641→  deductMusicCredit,\n  1642→  resetMusicCredits,\n  1643→  addMusicCredits,\n  1644→  getMusicUsageHistory,\n  1645→  initMusicCreditsColumns,\n  1646→  // Variations credits functions\n  1647→  checkVariationsCredits,\n  1648→  deductVariationsCredit,\n  1649→  // Scene-aware credits functions\n  1650→  checkSceneAwareCredits,\n  1651→  deductSceneAwareCredit,\n  1652→  // Pool management\n  1653→  closePool,\n  1654→  checkDatabase,\n  1655→  // Trial management\n  1656→  updateTrialEnd,\n  1657→  // Email verification functions\n  1658→  markEmailVerified,\n  1659→  isEmailVerified,\n  1660→  getUserByEmail,\n  1661→  // Constants\n  1662→  TIER_HOURS,\n  1663→  TIER_ISOLATION_MINUTES,\n  1664→  TIER_ISOLATION_HOURS,\n  1665→  ISOLATION_OVERAGE_RATE,\n  1666→  HOURS_OVERAGE_RATE,\n  1667→  TIER_MUSIC_CREDITS,\n  1668→  MUSIC_OVERAGE_RATE,\n  1669→  MUSIC_OVERAGE_RATES,\n  1670→  VARIATIONS_CREDIT_COST,\n  1671→  VARIATIONS_OVERAGE_RATES,\n  1672→  SCENE_AWARE_CREDIT_COST,\n  1673→  SCENE_AWARE_OVERAGE_RATES,\n  1674→  // Feature access\n  1675→  TIER_FEATURES,\n  1676→  hasFeatureAccess\n  1677→};\n  1678→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d6d29a19-1295-4bab-97c0-3e73274acbb8","timestamp":"2026-01-13T04:22:05.494Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"/**\n * Usage Tracking Service\n *\n * Tracks user credit balances and usage for billing.\n * Uses PostgreSQL for persistence.\n */\n\nconst { Pool } = require('pg');\nconst { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n\n// PostgreSQL connection pool with proper limits\n// SSL Configuration:\n// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\nconst sslConfig = process.env.NODE_ENV === 'production' ? {\n  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n  ca: process.env.DATABASE_SSL_CA || undefined\n} : false;\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: sslConfig,\n  // PERFORMANCE: Set connection pool limits\n  max: 20,                    // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n  // MEDIUM-007: Database Query Timeouts - prevent long-running queries from exhausting pool\n  connectionTimeoutMillis: 10000,  // 10 seconds to acquire connection (increased for reliability)\n  statement_timeout: 30000,        // 30 seconds max query execution time\n  query_timeout: 30000             // 30 seconds max total query time including queue\n});\n\n// Hours per tier (regular processing)\n// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n// Target margins: 79-82%\nconst TIER_HOURS = {\n  starter: 4,    // 4 hrs/month\n  pro: 15,       // 15 hrs/month\n  team: 50,      // 50 hrs/month\n  cancelled: 0\n};\n\n// Overage rate for processing hours beyond included\nconst HOURS_OVERAGE_RATE = 2.00; // $2/hour\n\n// Isolation minutes per tier (sized to maintain 80% margins)\nconst TIER_ISOLATION_MINUTES = {\n  starter: 0,     // No isolation access\n  pro: 45,        // 45 minutes included\n  team: 180,      // 3 hours included\n  cancelled: 0\n};\n\n// Convert to hours for database storage\nconst TIER_ISOLATION_HOURS = {\n  starter: 0,\n  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n  cancelled: 0\n};\n\n// Overage rate for isolation beyond included minutes\nconst ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n\n/**\n * Initialize database tables\n */\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n        email VARCHAR(255),\n        tier VARCHAR(50) DEFAULT 'starter',\n        hours_remaining DECIMAL(10,4) DEFAULT 15,\n        hours_total DECIMAL(10,4) DEFAULT 15,\n        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Add isolation columns if they don't exist (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified') THEN\n          ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified_at') THEN\n          ALTER TABLE users ADD COLUMN email_verified_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS usage_log (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        stripe_customer_id VARCHAR(255),\n        audio_duration_seconds DECIMAL(10,2),\n        hours_used DECIMAL(10,6),\n        endpoint VARCHAR(100),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    `);\n\n    // PERFORMANCE: Add composite index for efficient customer usage history queries\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n      ON usage_log(stripe_customer_id, created_at DESC)\n    `);\n\n    // Webhook events table for idempotency\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id SERIAL PRIMARY KEY,\n        event_id VARCHAR(255) UNIQUE NOT NULL,\n        event_type VARCHAR(100),\n        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n    `);\n\n    console.log('[UsageTracking] Database initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get or create a user by Stripe customer ID\n * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n */\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n     RETURNING *`,\n    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n  );\n\n  return result.rows[0];\n}\n\n/**\n * Check if a customer exists in the database (without creating)\n * SECURITY: Used to validate legacy auth attempts\n */\nasync function customerExists(stripeCustomerId) {\n  if (!stripeCustomerId) return false;\n\n  try {\n    const result = await pool.query(\n      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n      [stripeCustomerId]\n    );\n    return result.rows.length > 0;\n  } catch (err) {\n    console.error('[SPLICE] customerExists check failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get user's current credit balance\n */\nasync function getBalance(stripeCustomerId) {\n  const user = await getOrCreateUser(stripeCustomerId);\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  // Tier display names\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  // Calculate trial days remaining\n  let trialDaysRemaining = null;\n  let isOnTrial = false;\n  if (user.trial_end) {\n    const trialEnd = new Date(user.trial_end);\n    const now = new Date();\n    const diffMs = trialEnd.getTime() - now.getTime();\n    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n    if (diffDays > 0) {\n      trialDaysRemaining = diffDays;\n      isOnTrial = true;\n    }\n  }\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n    trialDaysRemaining,\n    isOnTrial,\n    email: user.email,\n    emailVerified: user.email_verified === true\n  };\n}\n\n/**\n * Check if user has enough credits for estimated duration\n */\nasync function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n  const balance = await getBalance(stripeCustomerId);\n  const estimatedHours = estimatedSeconds / 3600;\n  return balance.hoursRemaining >= estimatedHours;\n}\n\n/**\n * Reserve credits atomically using SELECT ... FOR UPDATE\n * This prevents race conditions where multiple requests pass credit check\n * before any deduction occurs.\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} estimatedSeconds - Estimated processing time in seconds\n * @param {string} endpoint - Endpoint name for tracking\n * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n */\nasync function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n  const estimatedHours = estimatedSeconds / 3600;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, hours_remaining FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      // Create user if doesn't exist (within transaction)\n      const newUser = await client.query(\n        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n         VALUES ($1, 'starter', $2, $2)\n         RETURNING id, hours_remaining`,\n        [stripeCustomerId, TIER_HOURS.starter]\n      );\n      result.rows = newUser.rows;\n    }\n\n    const user = result.rows[0];\n    const hoursRemaining = parseFloat(user.hours_remaining);\n\n    // Check if enough credits\n    if (hoursRemaining < estimatedHours) {\n      await client.query('ROLLBACK');\n      return {\n        success: false,\n        error: 'Insufficient credits',\n        hoursRemaining,\n        hoursRequired: estimatedHours\n      };\n    }\n\n    // Generate unique reservation ID\n    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Reserve credits by deducting the estimated amount\n    await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining - $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [estimatedHours, stripeCustomerId]\n    );\n\n    // Log the reservation\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n\n    return {\n      success: true,\n      reservationId,\n      hoursReserved: estimatedHours,\n      hoursRemaining: hoursRemaining - estimatedHours\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[UsageTracking] Reservation error:', err);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Confirm a reservation (finalize usage) or adjust for actual duration\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} actualSeconds - Actual processing time in seconds\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @returns {Promise<object>} Updated balance\n */\nasync function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n  const actualHours = actualSeconds / 3600;\n  const reservedHours = reservedSeconds / 3600;\n  const difference = reservedHours - actualHours;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get current state\n    const result = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    let user = result.rows[0];\n\n    // If actual usage was less than reserved, refund the difference\n    if (difference > 0) {\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = hours_remaining + $1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the adjustment\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n      );\n    } else if (difference < 0) {\n      // Actual usage was more than reserved - deduct the extra\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [-difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the additional usage\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n      );\n    }\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n\n    // Build balance from data we already have (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Release a reservation (refund credits on processing failure)\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @param {string} reason - Reason for release\n * @returns {Promise<object>} Updated balance\n */\nasync function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n  const reservedHours = reservedSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get id for logging\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const userId = result.rows[0].id;\n\n    // Refund the reserved amount with RETURNING\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining + $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [reservedHours, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log the refund\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if user can use vocal isolation\n * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n */\nasync function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n  const balance = await getBalance(stripeCustomerId);\n\n  // Starter tier has no isolation access\n  if (!balance.hasIsolationAccess) {\n    return {\n      allowed: false,\n      reason: 'upgrade_required',\n      message: 'Vocal isolation requires Pro or Team tier',\n      hasIncludedHours: false,\n      overageRequired: false,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remainingIncluded = balance.isolationHoursRemaining;\n\n  // Check if within included hours\n  if (remainingIncluded >= estimatedHours) {\n    return {\n      allowed: true,\n      reason: 'included',\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      hasIncludedHours: true,\n      overageRequired: false,\n      overageCost: 0,\n      isolationHoursRemaining: remainingIncluded - estimatedHours\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n\n  return {\n    allowed: true,\n    reason: 'overage',\n    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n    hasIncludedHours: remainingIncluded > 0,\n    overageRequired: true,\n    overageMinutes,\n    overageCost,\n    isolationHoursRemaining: 0\n  };\n}\n\n/**\n * Deduct isolation usage from user's balance\n * Returns overage cost if beyond included hours\n * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n */\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n  const durationMinutes = audioDurationSeconds / 60;\n  const durationHours = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const userResult = await client.query(\n      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n       FROM users WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n\n    let overageCost = 0;\n    let hoursFromIncluded = 0;\n    let overageMinutes = 0;\n\n    if (remainingIncluded >= durationHours) {\n      // Fully covered by included hours\n      hoursFromIncluded = durationHours;\n    } else {\n      // Partial or full overage\n      hoursFromIncluded = remainingIncluded;\n      overageMinutes = durationMinutes - (remainingIncluded * 60);\n      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n    }\n\n    // Update isolation balance with RETURNING to get new values\n    const updateResult = await client.query(\n      `UPDATE users\n       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n      [durationHours, stripeCustomerId]\n    );\n\n    const updatedUser = updateResult.rows[0];\n\n    // Log usage (mark as isolation)\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(updatedUser.hours_total);\n    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: updatedUser.tier,\n      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      isolationUsed: {\n        durationMinutes,\n        hoursFromIncluded,\n        overageMinutes,\n        overageCost\n      }\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct usage from user's balance\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n * Reports overage to Stripe for billing when user exceeds included hours\n */\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // First get current balance to calculate overage\n    const currentResult = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (currentResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const currentUser = currentResult.rows[0];\n    const currentRemaining = parseFloat(currentUser.hours_remaining);\n\n    // Calculate overage (hours used beyond what's remaining)\n    let overageHours = 0;\n    if (hoursUsed > currentRemaining) {\n      overageHours = hoursUsed - currentRemaining;\n    }\n\n    // Update balance (clamp at 0)\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [hoursUsed, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log usage\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Report overage to Stripe if any (after commit to not block transaction)\n    let overageCharge = 0;\n    if (overageHours > 0) {\n      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n      } else {\n        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      overageHours,\n      overageCharge\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset user's hours for new billing period\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n */\nasync function resetHours(stripeCustomerId, tier) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  const result = await pool.query(\n    `UPDATE users\n     SET hours_remaining = $1, hours_total = $1,\n         isolation_hours_remaining = $2, isolation_hours_total = $2,\n         tier = $3, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $4\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [hours, isolationHours, tier, stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    // User doesn't exist, create and return default balance\n    return await getBalance(stripeCustomerId);\n  }\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Update user's tier (from Stripe webhook)\n * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n */\nasync function updateTier(stripeCustomerId, tier, email = null) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, $3, $4, $4, $5, $5)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET tier = $3, hours_remaining = $4, hours_total = $4,\n         isolation_hours_remaining = $5, isolation_hours_total = $5,\n         updated_at = CURRENT_TIMESTAMP\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [stripeCustomerId, email, tier, hours, isolationHours]\n  );\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Get usage history for a user\n */\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Check if webhook event has already been processed (idempotency)\n */\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n\n/**\n * Record a processed webhook event\n */\nasync function recordWebhookEvent(eventId, eventType) {\n  try {\n    await pool.query(\n      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n      [eventId, eventType]\n    );\n  } catch (err) {\n    // Ignore duplicate key errors (race condition safety)\n    if (err.code !== '23505') throw err;\n  }\n}\n\n// =============================================================================\n// Music Credits Functions (Phase 4 - AI Music Feature)\n// =============================================================================\n\n// Music credits per tier\n// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\nconst TIER_MUSIC_CREDITS = {\n  starter: 2,    // 2 songs/month\n  pro: 10,       // 10 songs/month\n  team: 50,      // 50 songs/month\n  cancelled: 0\n};\n\n// Feature access by tier - defines which features each tier can use\nconst TIER_FEATURES = {\n  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection'],\n  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection', 'multitrack',\n    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n  cancelled: []\n};\n\n/**\n * Check if a tier has access to a specific feature\n * @param {string} tier - User's tier (starter, pro, team)\n * @param {string} feature - Feature name to check\n * @returns {boolean}\n */\nfunction hasFeatureAccess(tier, feature) {\n  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n  return tierFeatures.includes(feature);\n}\n\n// Flat overage rate for music (simplified pricing)\nconst MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n\n// Legacy overage rates (kept for backwards compatibility)\nconst MUSIC_OVERAGE_RATES = {\n  starter: 1.00,  // $1.00/song\n  pro: 1.00,      // $1.00/song\n  team: 1.00      // $1.00/song\n};\n\n/**\n * Get music credits balance for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{remaining: number, total: number, tier: string}>}\n */\nasync function getMusicCredits(stripeCustomerId) {\n  const result = await pool.query(\n    `SELECT music_credits_remaining, music_credits_total, tier\n     FROM users\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { remaining: 0, total: 0, tier: 'starter' };\n  }\n\n  const row = result.rows[0];\n  return {\n    remaining: row.music_credits_remaining || 0,\n    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n    tier: row.tier || 'starter'\n  };\n}\n\n/**\n * Check if customer has music credits available\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<boolean>}\n */\nasync function hasMusicCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  return credits.remaining > 0;\n}\n\n/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining } = result.rows[0];\n    let charged = 0;\n\n    if (music_credits_remaining > 0) {\n      // Deduct from included credits\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - 1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n    } else {\n      // Overage - charge flat rate ($1/song)\n      charged = MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, 1, $2)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset music credits based on tier (called on subscription renewal)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {string} tier - Subscription tier\n */\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update to prevent race conditions\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      console.warn(`[SPLICE] resetMusicCredits: User not found for ${stripeCustomerId}`);\n      return;\n    }\n\n    await client.query(\n      `UPDATE users\n       SET music_credits_remaining = $2,\n           music_credits_total = $2,\n           music_credits_reset_at = CURRENT_TIMESTAMP,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit reset error:', err.message);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Add music credits (for promotional or overage purchases)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} credits - Number of credits to add\n * @returns {Promise<{success: boolean, newBalance: number}>}\n */\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update to prevent concurrent modification\n    const lockResult = await client.query(\n      `SELECT music_credits_remaining\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (lockResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, newBalance: 0, error: 'User not found' };\n    }\n\n    // Update the credits\n    const result = await client.query(\n      `UPDATE users\n       SET music_credits_remaining = music_credits_remaining + $2,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1\n       RETURNING music_credits_remaining`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n\n    return {\n      success: true,\n      newBalance: result.rows[0].music_credits_remaining\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit addition error:', err.message);\n    return { success: false, newBalance: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get music usage history for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} limit - Max records to return\n * @returns {Promise<Object[]>}\n */\nasync function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM music_usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Initialize music credits columns (migration helper)\n */\nasync function initMusicCreditsColumns() {\n  const client = await pool.connect();\n  try {\n    // Add music credits columns if they don't exist\n    // CRITICAL-003: Default music credits should be 2 (Starter tier), not 5\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 2;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 2;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    // Create music usage log table\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS music_usage_log (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        credits_used INTEGER DEFAULT 1,\n        overage_charged DECIMAL(10,2) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n      ON music_usage_log(stripe_customer_id)\n    `);\n\n    console.log('[SPLICE] Music credits columns initialized');\n  } finally {\n    client.release();\n  }\n}\n\n// Variations credits cost (equivalent to 2.5 music credits)\nconst VARIATIONS_CREDIT_COST = 2.5;\n\n// Overage rates for variations (higher than single music due to 3 parallel generations)\nconst VARIATIONS_OVERAGE_RATES = {\n  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  team: 0.50      // $0.50/variations (2.5x $0.20)\n};\n\n// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\nconst SCENE_AWARE_CREDIT_COST = 1.5;\n\n// Overage rates for scene-aware music (75% margin)\nconst SCENE_AWARE_OVERAGE_RATES = {\n  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n};\n\n/**\n * Check if customer has enough credits for variations (2.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkVariationsCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = VARIATIONS_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct variations credit from customer (2.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductVariationsCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Variations credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if customer has enough credits for scene-aware music (1.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkSceneAwareCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct scene-aware music credit from customer (1.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductSceneAwareCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Close the database connection pool\n * Used for graceful shutdown\n */\nasync function closePool() {\n  await pool.end();\n}\n\n/**\n * Update trial end date for a customer\n * @param {string} stripeCustomerId - Customer ID\n * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n */\nasync function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n\n  await pool.query(\n    `UPDATE users\n     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, trialEnd]\n  );\n\n  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n}\n\n/**\n * Check database connectivity\n * Used for health checks\n */\nasync function checkDatabase() {\n  const client = await pool.connect();\n  try {\n    const result = await client.query('SELECT 1 as health');\n    return result.rows[0].health === 1;\n  } finally {\n    client.release();\n  }\n}\n\n// =============================================================================\n// Email Verification Functions\n// =============================================================================\n\n/**\n * Mark a user's email as verified\n * @param {string} email - Email address that was verified\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function markEmailVerified(email) {\n  if (!email) {\n    return { success: false, error: 'Email is required' };\n  }\n\n  const normalizedEmail = email.toLowerCase().trim();\n\n  try {\n    const result = await pool.query(\n      `UPDATE users\n       SET email_verified = TRUE,\n           email_verified_at = CURRENT_TIMESTAMP,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE LOWER(email) = $1\n       RETURNING stripe_customer_id, email_verified`,\n      [normalizedEmail]\n    );\n\n    if (result.rows.length === 0) {\n      // No user found with this email - this is OK for new signups\n      console.log(`[SPLICE] No user found for email verification: ${normalizedEmail}`);\n      return { success: true, userFound: false };\n    }\n\n    console.log(`[SPLICE] Email verified for user: ${result.rows[0].stripe_customer_id}`);\n    return { success: true, userFound: true, customerId: result.rows[0].stripe_customer_id };\n  } catch (err) {\n    console.error('[SPLICE] markEmailVerified error:', err.message);\n    return { success: false, error: err.message };\n  }\n}\n\n/**\n * Check if a user's email is verified\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{verified: boolean, verifiedAt?: Date}>}\n */\nasync function isEmailVerified(stripeCustomerId) {\n  try {\n    const result = await pool.query(\n      `SELECT email_verified, email_verified_at\n       FROM users\n       WHERE stripe_customer_id = $1`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      return { verified: false };\n    }\n\n    return {\n      verified: result.rows[0].email_verified === true,\n      verifiedAt: result.rows[0].email_verified_at\n    };\n  } catch (err) {\n    console.error('[SPLICE] isEmailVerified error:', err.message);\n    return { verified: false };\n  }\n}\n\n/**\n * Get user by email address\n * @param {string} email - Email address\n * @returns {Promise<Object|null>} User object or null\n */\nasync function getUserByEmail(email) {\n  if (!email) return null;\n\n  const normalizedEmail = email.toLowerCase().trim();\n\n  try {\n    const result = await pool.query(\n      `SELECT stripe_customer_id, email, tier, email_verified, email_verified_at\n       FROM users\n       WHERE LOWER(email) = $1`,\n      [normalizedEmail]\n    );\n\n    return result.rows.length > 0 ? result.rows[0] : null;\n  } catch (err) {\n    console.error('[SPLICE] getUserByEmail error:', err.message);\n    return null;\n  }\n}\n\nmodule.exports = {\n  initDatabase,\n  getOrCreateUser,\n  customerExists,\n  getBalance,\n  hasCredits,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  checkIsolationAccess,\n  deductUsage,\n  deductIsolationUsage,\n  resetHours,\n  updateTier,\n  getUsageHistory,\n  isEventProcessed,\n  recordWebhookEvent,\n  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  resetMusicCredits,\n  addMusicCredits,\n  getMusicUsageHistory,\n  initMusicCreditsColumns,\n  // Variations credits functions\n  checkVariationsCredits,\n  deductVariationsCredit,\n  // Scene-aware credits functions\n  checkSceneAwareCredits,\n  deductSceneAwareCredit,\n  // Pool management\n  closePool,\n  checkDatabase,\n  // Trial management\n  updateTrialEnd,\n  // Email verification functions\n  markEmailVerified,\n  isEmailVerified,\n  getUserByEmail,\n  // Constants\n  TIER_HOURS,\n  TIER_ISOLATION_MINUTES,\n  TIER_ISOLATION_HOURS,\n  ISOLATION_OVERAGE_RATE,\n  HOURS_OVERAGE_RATE,\n  TIER_MUSIC_CREDITS,\n  MUSIC_OVERAGE_RATE,\n  MUSIC_OVERAGE_RATES,\n  VARIATIONS_CREDIT_COST,\n  VARIATIONS_OVERAGE_RATES,\n  SCENE_AWARE_CREDIT_COST,\n  SCENE_AWARE_OVERAGE_RATES,\n  // Feature access\n  TIER_FEATURES,\n  hasFeatureAccess\n};\n","numLines":1678,"startLine":1,"totalLines":1678}},"sourceToolAssistantUUID":"554ba023-1dfb-4b54-8511-e27badd7e66e"}
{"parentUuid":"d6d29a19-1295-4bab-97c0-3e73274acbb8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ELSYrgGeCMkf7wUr227Mxe","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand the codebase. I can see:\n1. The race condition in `music.js` at lines 888-889 where credits are deducted in a loop\n2. The `usageTracking.js` has a single-credit `deductMusicCredit` function but no atomic multi-credit function\n\nLet me create the atomic `deductMusicCredits` function and update the music route."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":24064,"cache_read_input_tokens":33142,"cache_creation":{"ephemeral_5m_input_tokens":24064,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX4jkLTVSq9JcZma6tUGB","type":"assistant","uuid":"66535818-7825-469a-b994-c5b5c3fff85c","timestamp":"2026-01-13T04:22:10.613Z"}
{"parentUuid":"66535818-7825-469a-b994-c5b5c3fff85c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ELSYrgGeCMkf7wUr227Mxe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Cn8aT5LxnKGDChjD4s2mew","name":"Edit","input":{"replace_all":false,"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","old_string":"/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {","new_string":"/**\n * Deduct multiple music credits atomically from customer\n * Uses SELECT...FOR UPDATE to prevent race conditions\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} count - Number of credits to deduct (default: 1)\n * @returns {Promise<{success: boolean, remaining: number, charged: number, creditsDeducted: number}>}\n */\nasync function deductMusicCredits(stripeCustomerId, count = 1) {\n  if (count < 1) {\n    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'Invalid credit count' };\n  }\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'User not found' };\n    }\n\n    const { id: userId, music_credits_remaining, tier } = result.rows[0];\n    const currentCredits = music_credits_remaining || 0;\n\n    let charged = 0;\n    let creditsDeducted = 0;\n    let overageCount = 0;\n\n    if (currentCredits >= count) {\n      // Have enough credits - deduct all from included\n      creditsDeducted = count;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, count]\n      );\n    } else if (currentCredits > 0) {\n      // Partial credits - deduct what they have, charge overage for the rest\n      creditsDeducted = currentCredits;\n      overageCount = count - currentCredits;\n      charged = overageCount * MUSIC_OVERAGE_RATE;\n\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      // Report overage to Stripe meter for billing\n      if (overageCount > 0) {\n        const usageReport = await reportMusicOverage(stripeCustomerId, overageCount);\n        if (usageReport.success) {\n          console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${overageCount} songs ($${charged.toFixed(2)})`);\n        } else {\n          console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n        }\n      }\n\n      console.log(`[SPLICE] Partial credit deduction: ${stripeCustomerId} used ${creditsDeducted} credits, ${overageCount} overage ($${charged.toFixed(2)})`);\n    } else {\n      // No credits - full overage\n      overageCount = count;\n      charged = count * MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, count);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${count} songs ($${charged.toFixed(2)})`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n\n      console.log(`[SPLICE] Full overage: ${stripeCustomerId} charged $${charged.toFixed(2)} for ${count} songs`);\n    }\n\n    // Log the usage - single atomic log entry for the batch\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    // Get final credit balance\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      overageCount,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credits deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":24064,"cache_read_input_tokens":33142,"cache_creation":{"ephemeral_5m_input_tokens":24064,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX4jkLTVSq9JcZma6tUGB","type":"assistant","uuid":"2ea80dae-5789-4480-9aa1-ccf93faddf11","timestamp":"2026-01-13T04:22:25.292Z"}
{"parentUuid":"2ea80dae-5789-4480-9aa1-ccf93faddf11","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Cn8aT5LxnKGDChjD4s2mew","type":"tool_result","content":"The file /Users/imorgado/SPLICE/splice-backend/services/usageTracking.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1009→  const credits = await getMusicCredits(stripeCustomerId);\n  1010→  return credits.remaining > 0;\n  1011→}\n  1012→\n  1013→/**\n  1014→ * Deduct multiple music credits atomically from customer\n  1015→ * Uses SELECT...FOR UPDATE to prevent race conditions\n  1016→ * @param {string} stripeCustomerId - Stripe customer ID\n  1017→ * @param {number} count - Number of credits to deduct (default: 1)\n  1018→ * @returns {Promise<{success: boolean, remaining: number, charged: number, creditsDeducted: number}>}\n  1019→ */\n  1020→async function deductMusicCredits(stripeCustomerId, count = 1) {\n  1021→  if (count < 1) {\n  1022→    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'Invalid credit count' };\n  1023→  }\n  1024→\n  1025→  const client = await pool.connect();\n  1026→  try {\n  1027→    await client.query('BEGIN');\n  1028→\n  1029→    // Lock row for update - prevents concurrent modifications\n  1030→    const result = await client.query(\n  1031→      `SELECT id, music_credits_remaining, tier\n  1032→       FROM users\n  1033→       WHERE stripe_customer_id = $1\n  1034→       FOR UPDATE`,\n  1035→      [stripeCustomerId]\n  1036→    );\n  1037→\n  1038→    if (result.rows.length === 0) {\n  1039→      await client.query('ROLLBACK');\n  1040→      return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'User not found' };\n  1041→    }\n  1042→\n  1043→    const { id: userId, music_credits_remaining, tier } = result.rows[0];\n  1044→    const currentCredits = music_credits_remaining || 0;\n  1045→\n  1046→    let charged = 0;\n  1047→    let creditsDeducted = 0;\n  1048→    let overageCount = 0;\n  1049→\n  1050→    if (currentCredits >= count) {\n  1051→      // Have enough credits - deduct all from included\n  1052→      creditsDeducted = count;\n  1053→      await client.query(\n  1054→        `UPDATE users\n  1055→         SET music_credits_remaining = music_credits_remaining - $2,\n  1056→             updated_at = CURRENT_TIMESTAMP\n  1057→         WHERE stripe_customer_id = $1`,\n  1058→        [stripeCustomerId, count]\n  1059→      );\n  1060→    } else if (currentCredits > 0) {\n  1061→      // Partial credits - deduct what they have, charge overage for the rest\n  1062→      creditsDeducted = currentCredits;\n  1063→      overageCount = count - currentCredits;\n  1064→      charged = overageCount * MUSIC_OVERAGE_RATE;\n  1065→\n  1066→      await client.query(\n  1067→        `UPDATE users\n  1068→         SET music_credits_remaining = 0,\n  1069→             updated_at = CURRENT_TIMESTAMP\n  1070→         WHERE stripe_customer_id = $1`,\n  1071→        [stripeCustomerId]\n  1072→      );\n  1073→\n  1074→      // Report overage to Stripe meter for billing\n  1075→      if (overageCount > 0) {\n  1076→        const usageReport = await reportMusicOverage(stripeCustomerId, overageCount);\n  1077→        if (usageReport.success) {\n  1078→          console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${overageCount} songs ($${charged.toFixed(2)})`);\n  1079→        } else {\n  1080→          console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n  1081→        }\n  1082→      }\n  1083→\n  1084→      console.log(`[SPLICE] Partial credit deduction: ${stripeCustomerId} used ${creditsDeducted} credits, ${overageCount} overage ($${charged.toFixed(2)})`);\n  1085→    } else {\n  1086→      // No credits - full overage\n  1087→      overageCount = count;\n  1088→      charged = count * MUSIC_OVERAGE_RATE;\n  1089→\n  1090→      // Report overage to Stripe meter for billing\n  1091→      const usageReport = await reportMusicOverage(stripeCustomerId, count);\n  1092→      if (usageReport.success) {\n  1093→        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${count} songs ($${charged.toFixed(2)})`);\n  1094→      } else {\n  1095→        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n  1096→      }\n  1097→\n  1098→      console.log(`[SPLICE] Full overage: ${stripeCustomerId} charged $${charged.toFixed(2)} for ${count} songs`);\n  1099→    }\n  1100→\n  1101→    // Log the usage - single atomic log entry for the batch\n  1102→    await client.query(\n  1103→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1104→       VALUES ($1, $2, $3)`,\n  1105→      [stripeCustomerId, creditsDeducted, charged]\n  1106→    );\n  1107→\n  1108→    await client.query('COMMIT');\n  1109→\n  1110→    // Get final credit balance\n  1111→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1112→    return {\n  1113→      success: true,\n  1114→      remaining: newCredits.remaining,\n  1115→      creditsDeducted,\n  1116→      overageCount,\n  1117→      charged\n  1118→    };\n  1119→\n  1120→  } catch (err) {\n  1121→    await client.query('ROLLBACK');\n  1122→    console.error('[SPLICE] Music credits deduction error:', err.message);\n  1123→    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: err.message };\n  1124→  } finally {\n  1125→    client.release();\n  1126→  }\n  1127→}\n  1128→\n  1129→/**\n  1130→ * Deduct one music credit from customer\n  1131→ * @param {string} stripeCustomerId - Stripe customer ID\n  1132→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1133→ */\n  1134→async function deductMusicCredit(stripeCustomerId) {\n  1135→  const client = await pool.connect();\n  1136→  try {\n  1137→    await client.query('BEGIN');\n  1138→"}]},"uuid":"4f22f57c-3266-4f2d-bbc8-c4e8633f6faf","timestamp":"2026-01-13T04:22:25.359Z","toolUseResult":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","oldString":"/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {","newString":"/**\n * Deduct multiple music credits atomically from customer\n * Uses SELECT...FOR UPDATE to prevent race conditions\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} count - Number of credits to deduct (default: 1)\n * @returns {Promise<{success: boolean, remaining: number, charged: number, creditsDeducted: number}>}\n */\nasync function deductMusicCredits(stripeCustomerId, count = 1) {\n  if (count < 1) {\n    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'Invalid credit count' };\n  }\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'User not found' };\n    }\n\n    const { id: userId, music_credits_remaining, tier } = result.rows[0];\n    const currentCredits = music_credits_remaining || 0;\n\n    let charged = 0;\n    let creditsDeducted = 0;\n    let overageCount = 0;\n\n    if (currentCredits >= count) {\n      // Have enough credits - deduct all from included\n      creditsDeducted = count;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, count]\n      );\n    } else if (currentCredits > 0) {\n      // Partial credits - deduct what they have, charge overage for the rest\n      creditsDeducted = currentCredits;\n      overageCount = count - currentCredits;\n      charged = overageCount * MUSIC_OVERAGE_RATE;\n\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      // Report overage to Stripe meter for billing\n      if (overageCount > 0) {\n        const usageReport = await reportMusicOverage(stripeCustomerId, overageCount);\n        if (usageReport.success) {\n          console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${overageCount} songs ($${charged.toFixed(2)})`);\n        } else {\n          console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n        }\n      }\n\n      console.log(`[SPLICE] Partial credit deduction: ${stripeCustomerId} used ${creditsDeducted} credits, ${overageCount} overage ($${charged.toFixed(2)})`);\n    } else {\n      // No credits - full overage\n      overageCount = count;\n      charged = count * MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, count);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${count} songs ($${charged.toFixed(2)})`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n\n      console.log(`[SPLICE] Full overage: ${stripeCustomerId} charged $${charged.toFixed(2)} for ${count} songs`);\n    }\n\n    // Log the usage - single atomic log entry for the batch\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    // Get final credit balance\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      overageCount,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credits deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {","originalFile":"/**\n * Usage Tracking Service\n *\n * Tracks user credit balances and usage for billing.\n * Uses PostgreSQL for persistence.\n */\n\nconst { Pool } = require('pg');\nconst { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n\n// PostgreSQL connection pool with proper limits\n// SSL Configuration:\n// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\nconst sslConfig = process.env.NODE_ENV === 'production' ? {\n  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n  ca: process.env.DATABASE_SSL_CA || undefined\n} : false;\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: sslConfig,\n  // PERFORMANCE: Set connection pool limits\n  max: 20,                    // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n  // MEDIUM-007: Database Query Timeouts - prevent long-running queries from exhausting pool\n  connectionTimeoutMillis: 10000,  // 10 seconds to acquire connection (increased for reliability)\n  statement_timeout: 30000,        // 30 seconds max query execution time\n  query_timeout: 30000             // 30 seconds max total query time including queue\n});\n\n// Hours per tier (regular processing)\n// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n// Target margins: 79-82%\nconst TIER_HOURS = {\n  starter: 4,    // 4 hrs/month\n  pro: 15,       // 15 hrs/month\n  team: 50,      // 50 hrs/month\n  cancelled: 0\n};\n\n// Overage rate for processing hours beyond included\nconst HOURS_OVERAGE_RATE = 2.00; // $2/hour\n\n// Isolation minutes per tier (sized to maintain 80% margins)\nconst TIER_ISOLATION_MINUTES = {\n  starter: 0,     // No isolation access\n  pro: 45,        // 45 minutes included\n  team: 180,      // 3 hours included\n  cancelled: 0\n};\n\n// Convert to hours for database storage\nconst TIER_ISOLATION_HOURS = {\n  starter: 0,\n  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n  cancelled: 0\n};\n\n// Overage rate for isolation beyond included minutes\nconst ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n\n/**\n * Initialize database tables\n */\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n        email VARCHAR(255),\n        tier VARCHAR(50) DEFAULT 'starter',\n        hours_remaining DECIMAL(10,4) DEFAULT 15,\n        hours_total DECIMAL(10,4) DEFAULT 15,\n        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Add isolation columns if they don't exist (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified') THEN\n          ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified_at') THEN\n          ALTER TABLE users ADD COLUMN email_verified_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS usage_log (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        stripe_customer_id VARCHAR(255),\n        audio_duration_seconds DECIMAL(10,2),\n        hours_used DECIMAL(10,6),\n        endpoint VARCHAR(100),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    `);\n\n    // PERFORMANCE: Add composite index for efficient customer usage history queries\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n      ON usage_log(stripe_customer_id, created_at DESC)\n    `);\n\n    // Webhook events table for idempotency\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id SERIAL PRIMARY KEY,\n        event_id VARCHAR(255) UNIQUE NOT NULL,\n        event_type VARCHAR(100),\n        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n    `);\n\n    console.log('[UsageTracking] Database initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get or create a user by Stripe customer ID\n * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n */\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n     RETURNING *`,\n    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n  );\n\n  return result.rows[0];\n}\n\n/**\n * Check if a customer exists in the database (without creating)\n * SECURITY: Used to validate legacy auth attempts\n */\nasync function customerExists(stripeCustomerId) {\n  if (!stripeCustomerId) return false;\n\n  try {\n    const result = await pool.query(\n      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n      [stripeCustomerId]\n    );\n    return result.rows.length > 0;\n  } catch (err) {\n    console.error('[SPLICE] customerExists check failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get user's current credit balance\n */\nasync function getBalance(stripeCustomerId) {\n  const user = await getOrCreateUser(stripeCustomerId);\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  // Tier display names\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  // Calculate trial days remaining\n  let trialDaysRemaining = null;\n  let isOnTrial = false;\n  if (user.trial_end) {\n    const trialEnd = new Date(user.trial_end);\n    const now = new Date();\n    const diffMs = trialEnd.getTime() - now.getTime();\n    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n    if (diffDays > 0) {\n      trialDaysRemaining = diffDays;\n      isOnTrial = true;\n    }\n  }\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n    trialDaysRemaining,\n    isOnTrial,\n    email: user.email,\n    emailVerified: user.email_verified === true\n  };\n}\n\n/**\n * Check if user has enough credits for estimated duration\n */\nasync function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n  const balance = await getBalance(stripeCustomerId);\n  const estimatedHours = estimatedSeconds / 3600;\n  return balance.hoursRemaining >= estimatedHours;\n}\n\n/**\n * Reserve credits atomically using SELECT ... FOR UPDATE\n * This prevents race conditions where multiple requests pass credit check\n * before any deduction occurs.\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} estimatedSeconds - Estimated processing time in seconds\n * @param {string} endpoint - Endpoint name for tracking\n * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n */\nasync function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n  const estimatedHours = estimatedSeconds / 3600;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, hours_remaining FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      // Create user if doesn't exist (within transaction)\n      const newUser = await client.query(\n        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n         VALUES ($1, 'starter', $2, $2)\n         RETURNING id, hours_remaining`,\n        [stripeCustomerId, TIER_HOURS.starter]\n      );\n      result.rows = newUser.rows;\n    }\n\n    const user = result.rows[0];\n    const hoursRemaining = parseFloat(user.hours_remaining);\n\n    // Check if enough credits\n    if (hoursRemaining < estimatedHours) {\n      await client.query('ROLLBACK');\n      return {\n        success: false,\n        error: 'Insufficient credits',\n        hoursRemaining,\n        hoursRequired: estimatedHours\n      };\n    }\n\n    // Generate unique reservation ID\n    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Reserve credits by deducting the estimated amount\n    await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining - $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [estimatedHours, stripeCustomerId]\n    );\n\n    // Log the reservation\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n\n    return {\n      success: true,\n      reservationId,\n      hoursReserved: estimatedHours,\n      hoursRemaining: hoursRemaining - estimatedHours\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[UsageTracking] Reservation error:', err);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Confirm a reservation (finalize usage) or adjust for actual duration\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} actualSeconds - Actual processing time in seconds\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @returns {Promise<object>} Updated balance\n */\nasync function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n  const actualHours = actualSeconds / 3600;\n  const reservedHours = reservedSeconds / 3600;\n  const difference = reservedHours - actualHours;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get current state\n    const result = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    let user = result.rows[0];\n\n    // If actual usage was less than reserved, refund the difference\n    if (difference > 0) {\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = hours_remaining + $1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the adjustment\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n      );\n    } else if (difference < 0) {\n      // Actual usage was more than reserved - deduct the extra\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [-difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the additional usage\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n      );\n    }\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n\n    // Build balance from data we already have (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Release a reservation (refund credits on processing failure)\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @param {string} reason - Reason for release\n * @returns {Promise<object>} Updated balance\n */\nasync function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n  const reservedHours = reservedSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get id for logging\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const userId = result.rows[0].id;\n\n    // Refund the reserved amount with RETURNING\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining + $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [reservedHours, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log the refund\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if user can use vocal isolation\n * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n */\nasync function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n  const balance = await getBalance(stripeCustomerId);\n\n  // Starter tier has no isolation access\n  if (!balance.hasIsolationAccess) {\n    return {\n      allowed: false,\n      reason: 'upgrade_required',\n      message: 'Vocal isolation requires Pro or Team tier',\n      hasIncludedHours: false,\n      overageRequired: false,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remainingIncluded = balance.isolationHoursRemaining;\n\n  // Check if within included hours\n  if (remainingIncluded >= estimatedHours) {\n    return {\n      allowed: true,\n      reason: 'included',\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      hasIncludedHours: true,\n      overageRequired: false,\n      overageCost: 0,\n      isolationHoursRemaining: remainingIncluded - estimatedHours\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n\n  return {\n    allowed: true,\n    reason: 'overage',\n    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n    hasIncludedHours: remainingIncluded > 0,\n    overageRequired: true,\n    overageMinutes,\n    overageCost,\n    isolationHoursRemaining: 0\n  };\n}\n\n/**\n * Deduct isolation usage from user's balance\n * Returns overage cost if beyond included hours\n * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n */\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n  const durationMinutes = audioDurationSeconds / 60;\n  const durationHours = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const userResult = await client.query(\n      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n       FROM users WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n\n    let overageCost = 0;\n    let hoursFromIncluded = 0;\n    let overageMinutes = 0;\n\n    if (remainingIncluded >= durationHours) {\n      // Fully covered by included hours\n      hoursFromIncluded = durationHours;\n    } else {\n      // Partial or full overage\n      hoursFromIncluded = remainingIncluded;\n      overageMinutes = durationMinutes - (remainingIncluded * 60);\n      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n    }\n\n    // Update isolation balance with RETURNING to get new values\n    const updateResult = await client.query(\n      `UPDATE users\n       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n      [durationHours, stripeCustomerId]\n    );\n\n    const updatedUser = updateResult.rows[0];\n\n    // Log usage (mark as isolation)\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(updatedUser.hours_total);\n    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: updatedUser.tier,\n      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      isolationUsed: {\n        durationMinutes,\n        hoursFromIncluded,\n        overageMinutes,\n        overageCost\n      }\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct usage from user's balance\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n * Reports overage to Stripe for billing when user exceeds included hours\n */\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // First get current balance to calculate overage\n    const currentResult = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (currentResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const currentUser = currentResult.rows[0];\n    const currentRemaining = parseFloat(currentUser.hours_remaining);\n\n    // Calculate overage (hours used beyond what's remaining)\n    let overageHours = 0;\n    if (hoursUsed > currentRemaining) {\n      overageHours = hoursUsed - currentRemaining;\n    }\n\n    // Update balance (clamp at 0)\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [hoursUsed, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log usage\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Report overage to Stripe if any (after commit to not block transaction)\n    let overageCharge = 0;\n    if (overageHours > 0) {\n      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n      } else {\n        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      overageHours,\n      overageCharge\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset user's hours for new billing period\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n */\nasync function resetHours(stripeCustomerId, tier) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  const result = await pool.query(\n    `UPDATE users\n     SET hours_remaining = $1, hours_total = $1,\n         isolation_hours_remaining = $2, isolation_hours_total = $2,\n         tier = $3, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $4\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [hours, isolationHours, tier, stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    // User doesn't exist, create and return default balance\n    return await getBalance(stripeCustomerId);\n  }\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Update user's tier (from Stripe webhook)\n * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n */\nasync function updateTier(stripeCustomerId, tier, email = null) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, $3, $4, $4, $5, $5)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET tier = $3, hours_remaining = $4, hours_total = $4,\n         isolation_hours_remaining = $5, isolation_hours_total = $5,\n         updated_at = CURRENT_TIMESTAMP\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [stripeCustomerId, email, tier, hours, isolationHours]\n  );\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Get usage history for a user\n */\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Check if webhook event has already been processed (idempotency)\n */\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n\n/**\n * Record a processed webhook event\n */\nasync function recordWebhookEvent(eventId, eventType) {\n  try {\n    await pool.query(\n      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n      [eventId, eventType]\n    );\n  } catch (err) {\n    // Ignore duplicate key errors (race condition safety)\n    if (err.code !== '23505') throw err;\n  }\n}\n\n// =============================================================================\n// Music Credits Functions (Phase 4 - AI Music Feature)\n// =============================================================================\n\n// Music credits per tier\n// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\nconst TIER_MUSIC_CREDITS = {\n  starter: 2,    // 2 songs/month\n  pro: 10,       // 10 songs/month\n  team: 50,      // 50 songs/month\n  cancelled: 0\n};\n\n// Feature access by tier - defines which features each tier can use\nconst TIER_FEATURES = {\n  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection'],\n  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection', 'multitrack',\n    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n  cancelled: []\n};\n\n/**\n * Check if a tier has access to a specific feature\n * @param {string} tier - User's tier (starter, pro, team)\n * @param {string} feature - Feature name to check\n * @returns {boolean}\n */\nfunction hasFeatureAccess(tier, feature) {\n  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n  return tierFeatures.includes(feature);\n}\n\n// Flat overage rate for music (simplified pricing)\nconst MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n\n// Legacy overage rates (kept for backwards compatibility)\nconst MUSIC_OVERAGE_RATES = {\n  starter: 1.00,  // $1.00/song\n  pro: 1.00,      // $1.00/song\n  team: 1.00      // $1.00/song\n};\n\n/**\n * Get music credits balance for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{remaining: number, total: number, tier: string}>}\n */\nasync function getMusicCredits(stripeCustomerId) {\n  const result = await pool.query(\n    `SELECT music_credits_remaining, music_credits_total, tier\n     FROM users\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { remaining: 0, total: 0, tier: 'starter' };\n  }\n\n  const row = result.rows[0];\n  return {\n    remaining: row.music_credits_remaining || 0,\n    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n    tier: row.tier || 'starter'\n  };\n}\n\n/**\n * Check if customer has music credits available\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<boolean>}\n */\nasync function hasMusicCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  return credits.remaining > 0;\n}\n\n/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining } = result.rows[0];\n    let charged = 0;\n\n    if (music_credits_remaining > 0) {\n      // Deduct from included credits\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - 1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n    } else {\n      // Overage - charge flat rate ($1/song)\n      charged = MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, 1, $2)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset music credits based on tier (called on subscription renewal)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {string} tier - Subscription tier\n */\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update to prevent race conditions\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      console.warn(`[SPLICE] resetMusicCredits: User not found for ${stripeCustomerId}`);\n      return;\n    }\n\n    await client.query(\n      `UPDATE users\n       SET music_credits_remaining = $2,\n           music_credits_total = $2,\n           music_credits_reset_at = CURRENT_TIMESTAMP,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit reset error:', err.message);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Add music credits (for promotional or overage purchases)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} credits - Number of credits to add\n * @returns {Promise<{success: boolean, newBalance: number}>}\n */\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update to prevent concurrent modification\n    const lockResult = await client.query(\n      `SELECT music_credits_remaining\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (lockResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, newBalance: 0, error: 'User not found' };\n    }\n\n    // Update the credits\n    const result = await client.query(\n      `UPDATE users\n       SET music_credits_remaining = music_credits_remaining + $2,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1\n       RETURNING music_credits_remaining`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n\n    return {\n      success: true,\n      newBalance: result.rows[0].music_credits_remaining\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit addition error:', err.message);\n    return { success: false, newBalance: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get music usage history for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} limit - Max records to return\n * @returns {Promise<Object[]>}\n */\nasync function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM music_usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Initialize music credits columns (migration helper)\n */\nasync function initMusicCreditsColumns() {\n  const client = await pool.connect();\n  try {\n    // Add music credits columns if they don't exist\n    // CRITICAL-003: Default music credits should be 2 (Starter tier), not 5\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 2;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 2;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    // Create music usage log table\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS music_usage_log (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        credits_used INTEGER DEFAULT 1,\n        overage_charged DECIMAL(10,2) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n      ON music_usage_log(stripe_customer_id)\n    `);\n\n    console.log('[SPLICE] Music credits columns initialized');\n  } finally {\n    client.release();\n  }\n}\n\n// Variations credits cost (equivalent to 2.5 music credits)\nconst VARIATIONS_CREDIT_COST = 2.5;\n\n// Overage rates for variations (higher than single music due to 3 parallel generations)\nconst VARIATIONS_OVERAGE_RATES = {\n  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  team: 0.50      // $0.50/variations (2.5x $0.20)\n};\n\n// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\nconst SCENE_AWARE_CREDIT_COST = 1.5;\n\n// Overage rates for scene-aware music (75% margin)\nconst SCENE_AWARE_OVERAGE_RATES = {\n  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n};\n\n/**\n * Check if customer has enough credits for variations (2.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkVariationsCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = VARIATIONS_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct variations credit from customer (2.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductVariationsCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Variations credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if customer has enough credits for scene-aware music (1.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkSceneAwareCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct scene-aware music credit from customer (1.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductSceneAwareCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Close the database connection pool\n * Used for graceful shutdown\n */\nasync function closePool() {\n  await pool.end();\n}\n\n/**\n * Update trial end date for a customer\n * @param {string} stripeCustomerId - Customer ID\n * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n */\nasync function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n\n  await pool.query(\n    `UPDATE users\n     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, trialEnd]\n  );\n\n  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n}\n\n/**\n * Check database connectivity\n * Used for health checks\n */\nasync function checkDatabase() {\n  const client = await pool.connect();\n  try {\n    const result = await client.query('SELECT 1 as health');\n    return result.rows[0].health === 1;\n  } finally {\n    client.release();\n  }\n}\n\n// =============================================================================\n// Email Verification Functions\n// =============================================================================\n\n/**\n * Mark a user's email as verified\n * @param {string} email - Email address that was verified\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function markEmailVerified(email) {\n  if (!email) {\n    return { success: false, error: 'Email is required' };\n  }\n\n  const normalizedEmail = email.toLowerCase().trim();\n\n  try {\n    const result = await pool.query(\n      `UPDATE users\n       SET email_verified = TRUE,\n           email_verified_at = CURRENT_TIMESTAMP,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE LOWER(email) = $1\n       RETURNING stripe_customer_id, email_verified`,\n      [normalizedEmail]\n    );\n\n    if (result.rows.length === 0) {\n      // No user found with this email - this is OK for new signups\n      console.log(`[SPLICE] No user found for email verification: ${normalizedEmail}`);\n      return { success: true, userFound: false };\n    }\n\n    console.log(`[SPLICE] Email verified for user: ${result.rows[0].stripe_customer_id}`);\n    return { success: true, userFound: true, customerId: result.rows[0].stripe_customer_id };\n  } catch (err) {\n    console.error('[SPLICE] markEmailVerified error:', err.message);\n    return { success: false, error: err.message };\n  }\n}\n\n/**\n * Check if a user's email is verified\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{verified: boolean, verifiedAt?: Date}>}\n */\nasync function isEmailVerified(stripeCustomerId) {\n  try {\n    const result = await pool.query(\n      `SELECT email_verified, email_verified_at\n       FROM users\n       WHERE stripe_customer_id = $1`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      return { verified: false };\n    }\n\n    return {\n      verified: result.rows[0].email_verified === true,\n      verifiedAt: result.rows[0].email_verified_at\n    };\n  } catch (err) {\n    console.error('[SPLICE] isEmailVerified error:', err.message);\n    return { verified: false };\n  }\n}\n\n/**\n * Get user by email address\n * @param {string} email - Email address\n * @returns {Promise<Object|null>} User object or null\n */\nasync function getUserByEmail(email) {\n  if (!email) return null;\n\n  const normalizedEmail = email.toLowerCase().trim();\n\n  try {\n    const result = await pool.query(\n      `SELECT stripe_customer_id, email, tier, email_verified, email_verified_at\n       FROM users\n       WHERE LOWER(email) = $1`,\n      [normalizedEmail]\n    );\n\n    return result.rows.length > 0 ? result.rows[0] : null;\n  } catch (err) {\n    console.error('[SPLICE] getUserByEmail error:', err.message);\n    return null;\n  }\n}\n\nmodule.exports = {\n  initDatabase,\n  getOrCreateUser,\n  customerExists,\n  getBalance,\n  hasCredits,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  checkIsolationAccess,\n  deductUsage,\n  deductIsolationUsage,\n  resetHours,\n  updateTier,\n  getUsageHistory,\n  isEventProcessed,\n  recordWebhookEvent,\n  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  resetMusicCredits,\n  addMusicCredits,\n  getMusicUsageHistory,\n  initMusicCreditsColumns,\n  // Variations credits functions\n  checkVariationsCredits,\n  deductVariationsCredit,\n  // Scene-aware credits functions\n  checkSceneAwareCredits,\n  deductSceneAwareCredit,\n  // Pool management\n  closePool,\n  checkDatabase,\n  // Trial management\n  updateTrialEnd,\n  // Email verification functions\n  markEmailVerified,\n  isEmailVerified,\n  getUserByEmail,\n  // Constants\n  TIER_HOURS,\n  TIER_ISOLATION_MINUTES,\n  TIER_ISOLATION_HOURS,\n  ISOLATION_OVERAGE_RATE,\n  HOURS_OVERAGE_RATE,\n  TIER_MUSIC_CREDITS,\n  MUSIC_OVERAGE_RATE,\n  MUSIC_OVERAGE_RATES,\n  VARIATIONS_CREDIT_COST,\n  VARIATIONS_OVERAGE_RATES,\n  SCENE_AWARE_CREDIT_COST,\n  SCENE_AWARE_OVERAGE_RATES,\n  // Feature access\n  TIER_FEATURES,\n  hasFeatureAccess\n};\n","structuredPatch":[{"oldStart":1011,"oldLines":6,"newStart":1011,"newLines":122,"lines":[" }"," "," /**","+ * Deduct multiple music credits atomically from customer","+ * Uses SELECT...FOR UPDATE to prevent race conditions","+ * @param {string} stripeCustomerId - Stripe customer ID","+ * @param {number} count - Number of credits to deduct (default: 1)","+ * @returns {Promise<{success: boolean, remaining: number, charged: number, creditsDeducted: number}>}","+ */","+async function deductMusicCredits(stripeCustomerId, count = 1) {","+  if (count < 1) {","+    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'Invalid credit count' };","+  }","+","+  const client = await pool.connect();","+  try {","+    await client.query('BEGIN');","+","+    // Lock row for update - prevents concurrent modifications","+    const result = await client.query(","+      `SELECT id, music_credits_remaining, tier","+       FROM users","+       WHERE stripe_customer_id = $1","+       FOR UPDATE`,","+      [stripeCustomerId]","+    );","+","+    if (result.rows.length === 0) {","+      await client.query('ROLLBACK');","+      return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'User not found' };","+    }","+","+    const { id: userId, music_credits_remaining, tier } = result.rows[0];","+    const currentCredits = music_credits_remaining || 0;","+","+    let charged = 0;","+    let creditsDeducted = 0;","+    let overageCount = 0;","+","+    if (currentCredits >= count) {","+      // Have enough credits - deduct all from included","+      creditsDeducted = count;","+      await client.query(","+        `UPDATE users","+         SET music_credits_remaining = music_credits_remaining - $2,","+             updated_at = CURRENT_TIMESTAMP","+         WHERE stripe_customer_id = $1`,","+        [stripeCustomerId, count]","+      );","+    } else if (currentCredits > 0) {","+      // Partial credits - deduct what they have, charge overage for the rest","+      creditsDeducted = currentCredits;","+      overageCount = count - currentCredits;","+      charged = overageCount * MUSIC_OVERAGE_RATE;","+","+      await client.query(","+        `UPDATE users","+         SET music_credits_remaining = 0,","+             updated_at = CURRENT_TIMESTAMP","+         WHERE stripe_customer_id = $1`,","+        [stripeCustomerId]","+      );","+","+      // Report overage to Stripe meter for billing","+      if (overageCount > 0) {","+        const usageReport = await reportMusicOverage(stripeCustomerId, overageCount);","+        if (usageReport.success) {","+          console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${overageCount} songs ($${charged.toFixed(2)})`);","+        } else {","+          console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);","+        }","+      }","+","+      console.log(`[SPLICE] Partial credit deduction: ${stripeCustomerId} used ${creditsDeducted} credits, ${overageCount} overage ($${charged.toFixed(2)})`);","+    } else {","+      // No credits - full overage","+      overageCount = count;","+      charged = count * MUSIC_OVERAGE_RATE;","+","+      // Report overage to Stripe meter for billing","+      const usageReport = await reportMusicOverage(stripeCustomerId, count);","+      if (usageReport.success) {","+        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${count} songs ($${charged.toFixed(2)})`);","+      } else {","+        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);","+      }","+","+      console.log(`[SPLICE] Full overage: ${stripeCustomerId} charged $${charged.toFixed(2)} for ${count} songs`);","+    }","+","+    // Log the usage - single atomic log entry for the batch","+    await client.query(","+      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)","+       VALUES ($1, $2, $3)`,","+      [stripeCustomerId, creditsDeducted, charged]","+    );","+","+    await client.query('COMMIT');","+","+    // Get final credit balance","+    const newCredits = await getMusicCredits(stripeCustomerId);","+    return {","+      success: true,","+      remaining: newCredits.remaining,","+      creditsDeducted,","+      overageCount,","+      charged","+    };","+","+  } catch (err) {","+    await client.query('ROLLBACK');","+    console.error('[SPLICE] Music credits deduction error:', err.message);","+    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: err.message };","+  } finally {","+    client.release();","+  }","+}","+","+/**","  * Deduct one music credit from customer","  * @param {string} stripeCustomerId - Stripe customer ID","  * @returns {Promise<{success: boolean, remaining: number, charged: number}>}"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"2ea80dae-5789-4480-9aa1-ccf93faddf11"}
{"parentUuid":"2d19d87b-e80a-41a0-b034-6e54a34a9add","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RcuTubcv6qMR1v4ouu9zHa","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to export the new function. Let me find and update the exports."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3567,"cache_read_input_tokens":57206,"cache_creation":{"ephemeral_5m_input_tokens":3567,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CX4jmud4pHhCwsQz77kYB","type":"assistant","uuid":"44f4cff4-e4e6-473e-a23a-342e538230a0","timestamp":"2026-01-13T04:22:31.440Z"}
{"parentUuid":"44f4cff4-e4e6-473e-a23a-342e538230a0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RcuTubcv6qMR1v4ouu9zHa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CyTMCEGUWvK7KrpMMeX6nG","name":"Edit","input":{"replace_all":false,"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","old_string":"  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  resetMusicCredits,","new_string":"  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  deductMusicCredits,\n  resetMusicCredits,"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3567,"cache_read_input_tokens":57206,"cache_creation":{"ephemeral_5m_input_tokens":3567,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CX4jmud4pHhCwsQz77kYB","type":"assistant","uuid":"0afcdf38-309b-4219-8edb-39d3bcab340f","timestamp":"2026-01-13T04:22:32.945Z"}
{"parentUuid":"0afcdf38-309b-4219-8edb-39d3bcab340f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CyTMCEGUWvK7KrpMMeX6nG","type":"tool_result","content":"The file /Users/imorgado/SPLICE/splice-backend/services/usageTracking.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1750→  updateTier,\n  1751→  getUsageHistory,\n  1752→  isEventProcessed,\n  1753→  recordWebhookEvent,\n  1754→  // Music credits functions\n  1755→  getMusicCredits,\n  1756→  hasMusicCredits,\n  1757→  deductMusicCredit,\n  1758→  deductMusicCredits,\n  1759→  resetMusicCredits,\n  1760→  addMusicCredits,\n  1761→  getMusicUsageHistory,\n  1762→  initMusicCreditsColumns,\n  1763→  // Variations credits functions"}]},"uuid":"e3536d35-d157-4f5c-a3de-c2017f5b29d8","timestamp":"2026-01-13T04:22:33.003Z","toolUseResult":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","oldString":"  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  resetMusicCredits,","newString":"  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  deductMusicCredits,\n  resetMusicCredits,","originalFile":"/**\n * Usage Tracking Service\n *\n * Tracks user credit balances and usage for billing.\n * Uses PostgreSQL for persistence.\n */\n\nconst { Pool } = require('pg');\nconst { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n\n// PostgreSQL connection pool with proper limits\n// SSL Configuration:\n// - Railway managed PostgreSQL uses internal certificates, requires rejectUnauthorized: false\n// - For other providers, set DATABASE_SSL_CA env var with CA certificate content\n// - Set DATABASE_SSL_REJECT_UNAUTHORIZED=true to enable strict SSL validation\nconst sslConfig = process.env.NODE_ENV === 'production' ? {\n  rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED === 'true',\n  ca: process.env.DATABASE_SSL_CA || undefined\n} : false;\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: sslConfig,\n  // PERFORMANCE: Set connection pool limits\n  max: 20,                    // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n  // MEDIUM-007: Database Query Timeouts - prevent long-running queries from exhausting pool\n  connectionTimeoutMillis: 10000,  // 10 seconds to acquire connection (increased for reliability)\n  statement_timeout: 30000,        // 30 seconds max query execution time\n  query_timeout: 30000             // 30 seconds max total query time including queue\n});\n\n// Hours per tier (regular processing)\n// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n// Target margins: 79-82%\nconst TIER_HOURS = {\n  starter: 4,    // 4 hrs/month\n  pro: 15,       // 15 hrs/month\n  team: 50,      // 50 hrs/month\n  cancelled: 0\n};\n\n// Overage rate for processing hours beyond included\nconst HOURS_OVERAGE_RATE = 2.00; // $2/hour\n\n// Isolation minutes per tier (sized to maintain 80% margins)\nconst TIER_ISOLATION_MINUTES = {\n  starter: 0,     // No isolation access\n  pro: 45,        // 45 minutes included\n  team: 180,      // 3 hours included\n  cancelled: 0\n};\n\n// Convert to hours for database storage\nconst TIER_ISOLATION_HOURS = {\n  starter: 0,\n  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n  cancelled: 0\n};\n\n// Overage rate for isolation beyond included minutes\nconst ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n\n/**\n * Initialize database tables\n */\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n        email VARCHAR(255),\n        tier VARCHAR(50) DEFAULT 'starter',\n        hours_remaining DECIMAL(10,4) DEFAULT 15,\n        hours_total DECIMAL(10,4) DEFAULT 15,\n        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Add isolation columns if they don't exist (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified') THEN\n          ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'email_verified_at') THEN\n          ALTER TABLE users ADD COLUMN email_verified_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS usage_log (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        stripe_customer_id VARCHAR(255),\n        audio_duration_seconds DECIMAL(10,2),\n        hours_used DECIMAL(10,6),\n        endpoint VARCHAR(100),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    `);\n\n    // PERFORMANCE: Add composite index for efficient customer usage history queries\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n      ON usage_log(stripe_customer_id, created_at DESC)\n    `);\n\n    // Webhook events table for idempotency\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id SERIAL PRIMARY KEY,\n        event_id VARCHAR(255) UNIQUE NOT NULL,\n        event_type VARCHAR(100),\n        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n    `);\n\n    console.log('[UsageTracking] Database initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get or create a user by Stripe customer ID\n * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n */\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n     RETURNING *`,\n    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n  );\n\n  return result.rows[0];\n}\n\n/**\n * Check if a customer exists in the database (without creating)\n * SECURITY: Used to validate legacy auth attempts\n */\nasync function customerExists(stripeCustomerId) {\n  if (!stripeCustomerId) return false;\n\n  try {\n    const result = await pool.query(\n      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n      [stripeCustomerId]\n    );\n    return result.rows.length > 0;\n  } catch (err) {\n    console.error('[SPLICE] customerExists check failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get user's current credit balance\n */\nasync function getBalance(stripeCustomerId) {\n  const user = await getOrCreateUser(stripeCustomerId);\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  // Tier display names\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  // Calculate trial days remaining\n  let trialDaysRemaining = null;\n  let isOnTrial = false;\n  if (user.trial_end) {\n    const trialEnd = new Date(user.trial_end);\n    const now = new Date();\n    const diffMs = trialEnd.getTime() - now.getTime();\n    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n    if (diffDays > 0) {\n      trialDaysRemaining = diffDays;\n      isOnTrial = true;\n    }\n  }\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n    trialDaysRemaining,\n    isOnTrial,\n    email: user.email,\n    emailVerified: user.email_verified === true\n  };\n}\n\n/**\n * Check if user has enough credits for estimated duration\n */\nasync function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n  const balance = await getBalance(stripeCustomerId);\n  const estimatedHours = estimatedSeconds / 3600;\n  return balance.hoursRemaining >= estimatedHours;\n}\n\n/**\n * Reserve credits atomically using SELECT ... FOR UPDATE\n * This prevents race conditions where multiple requests pass credit check\n * before any deduction occurs.\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} estimatedSeconds - Estimated processing time in seconds\n * @param {string} endpoint - Endpoint name for tracking\n * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n */\nasync function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n  const estimatedHours = estimatedSeconds / 3600;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, hours_remaining FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      // Create user if doesn't exist (within transaction)\n      const newUser = await client.query(\n        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n         VALUES ($1, 'starter', $2, $2)\n         RETURNING id, hours_remaining`,\n        [stripeCustomerId, TIER_HOURS.starter]\n      );\n      result.rows = newUser.rows;\n    }\n\n    const user = result.rows[0];\n    const hoursRemaining = parseFloat(user.hours_remaining);\n\n    // Check if enough credits\n    if (hoursRemaining < estimatedHours) {\n      await client.query('ROLLBACK');\n      return {\n        success: false,\n        error: 'Insufficient credits',\n        hoursRemaining,\n        hoursRequired: estimatedHours\n      };\n    }\n\n    // Generate unique reservation ID\n    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Reserve credits by deducting the estimated amount\n    await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining - $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [estimatedHours, stripeCustomerId]\n    );\n\n    // Log the reservation\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n\n    return {\n      success: true,\n      reservationId,\n      hoursReserved: estimatedHours,\n      hoursRemaining: hoursRemaining - estimatedHours\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[UsageTracking] Reservation error:', err);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Confirm a reservation (finalize usage) or adjust for actual duration\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} actualSeconds - Actual processing time in seconds\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @returns {Promise<object>} Updated balance\n */\nasync function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n  const actualHours = actualSeconds / 3600;\n  const reservedHours = reservedSeconds / 3600;\n  const difference = reservedHours - actualHours;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get current state\n    const result = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    let user = result.rows[0];\n\n    // If actual usage was less than reserved, refund the difference\n    if (difference > 0) {\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = hours_remaining + $1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the adjustment\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n      );\n    } else if (difference < 0) {\n      // Actual usage was more than reserved - deduct the extra\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [-difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the additional usage\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n      );\n    }\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n\n    // Build balance from data we already have (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Release a reservation (refund credits on processing failure)\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @param {string} reason - Reason for release\n * @returns {Promise<object>} Updated balance\n */\nasync function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n  const reservedHours = reservedSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get id for logging\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const userId = result.rows[0].id;\n\n    // Refund the reserved amount with RETURNING\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining + $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [reservedHours, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log the refund\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if user can use vocal isolation\n * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n */\nasync function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n  const balance = await getBalance(stripeCustomerId);\n\n  // Starter tier has no isolation access\n  if (!balance.hasIsolationAccess) {\n    return {\n      allowed: false,\n      reason: 'upgrade_required',\n      message: 'Vocal isolation requires Pro or Team tier',\n      hasIncludedHours: false,\n      overageRequired: false,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remainingIncluded = balance.isolationHoursRemaining;\n\n  // Check if within included hours\n  if (remainingIncluded >= estimatedHours) {\n    return {\n      allowed: true,\n      reason: 'included',\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      hasIncludedHours: true,\n      overageRequired: false,\n      overageCost: 0,\n      isolationHoursRemaining: remainingIncluded - estimatedHours\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n\n  return {\n    allowed: true,\n    reason: 'overage',\n    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n    hasIncludedHours: remainingIncluded > 0,\n    overageRequired: true,\n    overageMinutes,\n    overageCost,\n    isolationHoursRemaining: 0\n  };\n}\n\n/**\n * Deduct isolation usage from user's balance\n * Returns overage cost if beyond included hours\n * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n */\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n  const durationMinutes = audioDurationSeconds / 60;\n  const durationHours = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const userResult = await client.query(\n      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n       FROM users WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n\n    let overageCost = 0;\n    let hoursFromIncluded = 0;\n    let overageMinutes = 0;\n\n    if (remainingIncluded >= durationHours) {\n      // Fully covered by included hours\n      hoursFromIncluded = durationHours;\n    } else {\n      // Partial or full overage\n      hoursFromIncluded = remainingIncluded;\n      overageMinutes = durationMinutes - (remainingIncluded * 60);\n      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n    }\n\n    // Update isolation balance with RETURNING to get new values\n    const updateResult = await client.query(\n      `UPDATE users\n       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n      [durationHours, stripeCustomerId]\n    );\n\n    const updatedUser = updateResult.rows[0];\n\n    // Log usage (mark as isolation)\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(updatedUser.hours_total);\n    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: updatedUser.tier,\n      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      isolationUsed: {\n        durationMinutes,\n        hoursFromIncluded,\n        overageMinutes,\n        overageCost\n      }\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct usage from user's balance\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n * Reports overage to Stripe for billing when user exceeds included hours\n */\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // First get current balance to calculate overage\n    const currentResult = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (currentResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const currentUser = currentResult.rows[0];\n    const currentRemaining = parseFloat(currentUser.hours_remaining);\n\n    // Calculate overage (hours used beyond what's remaining)\n    let overageHours = 0;\n    if (hoursUsed > currentRemaining) {\n      overageHours = hoursUsed - currentRemaining;\n    }\n\n    // Update balance (clamp at 0)\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [hoursUsed, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log usage\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Report overage to Stripe if any (after commit to not block transaction)\n    let overageCharge = 0;\n    if (overageHours > 0) {\n      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n      } else {\n        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      overageHours,\n      overageCharge\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset user's hours for new billing period\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n */\nasync function resetHours(stripeCustomerId, tier) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  const result = await pool.query(\n    `UPDATE users\n     SET hours_remaining = $1, hours_total = $1,\n         isolation_hours_remaining = $2, isolation_hours_total = $2,\n         tier = $3, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $4\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [hours, isolationHours, tier, stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    // User doesn't exist, create and return default balance\n    return await getBalance(stripeCustomerId);\n  }\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Update user's tier (from Stripe webhook)\n * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n */\nasync function updateTier(stripeCustomerId, tier, email = null) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, $3, $4, $4, $5, $5)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET tier = $3, hours_remaining = $4, hours_total = $4,\n         isolation_hours_remaining = $5, isolation_hours_total = $5,\n         updated_at = CURRENT_TIMESTAMP\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [stripeCustomerId, email, tier, hours, isolationHours]\n  );\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Get usage history for a user\n */\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Check if webhook event has already been processed (idempotency)\n */\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n\n/**\n * Record a processed webhook event\n */\nasync function recordWebhookEvent(eventId, eventType) {\n  try {\n    await pool.query(\n      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n      [eventId, eventType]\n    );\n  } catch (err) {\n    // Ignore duplicate key errors (race condition safety)\n    if (err.code !== '23505') throw err;\n  }\n}\n\n// =============================================================================\n// Music Credits Functions (Phase 4 - AI Music Feature)\n// =============================================================================\n\n// Music credits per tier\n// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\nconst TIER_MUSIC_CREDITS = {\n  starter: 2,    // 2 songs/month\n  pro: 10,       // 10 songs/month\n  team: 50,      // 50 songs/month\n  cancelled: 0\n};\n\n// Feature access by tier - defines which features each tier can use\nconst TIER_FEATURES = {\n  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection'],\n  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection', 'multitrack',\n    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n  cancelled: []\n};\n\n/**\n * Check if a tier has access to a specific feature\n * @param {string} tier - User's tier (starter, pro, team)\n * @param {string} feature - Feature name to check\n * @returns {boolean}\n */\nfunction hasFeatureAccess(tier, feature) {\n  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n  return tierFeatures.includes(feature);\n}\n\n// Flat overage rate for music (simplified pricing)\nconst MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n\n// Legacy overage rates (kept for backwards compatibility)\nconst MUSIC_OVERAGE_RATES = {\n  starter: 1.00,  // $1.00/song\n  pro: 1.00,      // $1.00/song\n  team: 1.00      // $1.00/song\n};\n\n/**\n * Get music credits balance for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{remaining: number, total: number, tier: string}>}\n */\nasync function getMusicCredits(stripeCustomerId) {\n  const result = await pool.query(\n    `SELECT music_credits_remaining, music_credits_total, tier\n     FROM users\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { remaining: 0, total: 0, tier: 'starter' };\n  }\n\n  const row = result.rows[0];\n  return {\n    remaining: row.music_credits_remaining || 0,\n    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n    tier: row.tier || 'starter'\n  };\n}\n\n/**\n * Check if customer has music credits available\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<boolean>}\n */\nasync function hasMusicCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  return credits.remaining > 0;\n}\n\n/**\n * Deduct multiple music credits atomically from customer\n * Uses SELECT...FOR UPDATE to prevent race conditions\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} count - Number of credits to deduct (default: 1)\n * @returns {Promise<{success: boolean, remaining: number, charged: number, creditsDeducted: number}>}\n */\nasync function deductMusicCredits(stripeCustomerId, count = 1) {\n  if (count < 1) {\n    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'Invalid credit count' };\n  }\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: 'User not found' };\n    }\n\n    const { id: userId, music_credits_remaining, tier } = result.rows[0];\n    const currentCredits = music_credits_remaining || 0;\n\n    let charged = 0;\n    let creditsDeducted = 0;\n    let overageCount = 0;\n\n    if (currentCredits >= count) {\n      // Have enough credits - deduct all from included\n      creditsDeducted = count;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, count]\n      );\n    } else if (currentCredits > 0) {\n      // Partial credits - deduct what they have, charge overage for the rest\n      creditsDeducted = currentCredits;\n      overageCount = count - currentCredits;\n      charged = overageCount * MUSIC_OVERAGE_RATE;\n\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      // Report overage to Stripe meter for billing\n      if (overageCount > 0) {\n        const usageReport = await reportMusicOverage(stripeCustomerId, overageCount);\n        if (usageReport.success) {\n          console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${overageCount} songs ($${charged.toFixed(2)})`);\n        } else {\n          console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n        }\n      }\n\n      console.log(`[SPLICE] Partial credit deduction: ${stripeCustomerId} used ${creditsDeducted} credits, ${overageCount} overage ($${charged.toFixed(2)})`);\n    } else {\n      // No credits - full overage\n      overageCount = count;\n      charged = count * MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, count);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - ${count} songs ($${charged.toFixed(2)})`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n\n      console.log(`[SPLICE] Full overage: ${stripeCustomerId} charged $${charged.toFixed(2)} for ${count} songs`);\n    }\n\n    // Log the usage - single atomic log entry for the batch\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    // Get final credit balance\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      overageCount,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credits deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, creditsDeducted: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining } = result.rows[0];\n    let charged = 0;\n\n    if (music_credits_remaining > 0) {\n      // Deduct from included credits\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - 1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n    } else {\n      // Overage - charge flat rate ($1/song)\n      charged = MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, 1, $2)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset music credits based on tier (called on subscription renewal)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {string} tier - Subscription tier\n */\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update to prevent race conditions\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      console.warn(`[SPLICE] resetMusicCredits: User not found for ${stripeCustomerId}`);\n      return;\n    }\n\n    await client.query(\n      `UPDATE users\n       SET music_credits_remaining = $2,\n           music_credits_total = $2,\n           music_credits_reset_at = CURRENT_TIMESTAMP,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit reset error:', err.message);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Add music credits (for promotional or overage purchases)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} credits - Number of credits to add\n * @returns {Promise<{success: boolean, newBalance: number}>}\n */\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update to prevent concurrent modification\n    const lockResult = await client.query(\n      `SELECT music_credits_remaining\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (lockResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, newBalance: 0, error: 'User not found' };\n    }\n\n    // Update the credits\n    const result = await client.query(\n      `UPDATE users\n       SET music_credits_remaining = music_credits_remaining + $2,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $1\n       RETURNING music_credits_remaining`,\n      [stripeCustomerId, credits]\n    );\n\n    await client.query('COMMIT');\n\n    return {\n      success: true,\n      newBalance: result.rows[0].music_credits_remaining\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit addition error:', err.message);\n    return { success: false, newBalance: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get music usage history for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} limit - Max records to return\n * @returns {Promise<Object[]>}\n */\nasync function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM music_usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Initialize music credits columns (migration helper)\n */\nasync function initMusicCreditsColumns() {\n  const client = await pool.connect();\n  try {\n    // Add music credits columns if they don't exist\n    // CRITICAL-003: Default music credits should be 2 (Starter tier), not 5\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 2;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 2;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    // Create music usage log table\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS music_usage_log (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        credits_used INTEGER DEFAULT 1,\n        overage_charged DECIMAL(10,2) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n      ON music_usage_log(stripe_customer_id)\n    `);\n\n    console.log('[SPLICE] Music credits columns initialized');\n  } finally {\n    client.release();\n  }\n}\n\n// Variations credits cost (equivalent to 2.5 music credits)\nconst VARIATIONS_CREDIT_COST = 2.5;\n\n// Overage rates for variations (higher than single music due to 3 parallel generations)\nconst VARIATIONS_OVERAGE_RATES = {\n  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  team: 0.50      // $0.50/variations (2.5x $0.20)\n};\n\n// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\nconst SCENE_AWARE_CREDIT_COST = 1.5;\n\n// Overage rates for scene-aware music (75% margin)\nconst SCENE_AWARE_OVERAGE_RATES = {\n  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n};\n\n/**\n * Check if customer has enough credits for variations (2.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkVariationsCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = VARIATIONS_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct variations credit from customer (2.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductVariationsCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Variations credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if customer has enough credits for scene-aware music (1.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkSceneAwareCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct scene-aware music credit from customer (1.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductSceneAwareCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Close the database connection pool\n * Used for graceful shutdown\n */\nasync function closePool() {\n  await pool.end();\n}\n\n/**\n * Update trial end date for a customer\n * @param {string} stripeCustomerId - Customer ID\n * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n */\nasync function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n\n  await pool.query(\n    `UPDATE users\n     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, trialEnd]\n  );\n\n  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n}\n\n/**\n * Check database connectivity\n * Used for health checks\n */\nasync function checkDatabase() {\n  const client = await pool.connect();\n  try {\n    const result = await client.query('SELECT 1 as health');\n    return result.rows[0].health === 1;\n  } finally {\n    client.release();\n  }\n}\n\n// =============================================================================\n// Email Verification Functions\n// =============================================================================\n\n/**\n * Mark a user's email as verified\n * @param {string} email - Email address that was verified\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function markEmailVerified(email) {\n  if (!email) {\n    return { success: false, error: 'Email is required' };\n  }\n\n  const normalizedEmail = email.toLowerCase().trim();\n\n  try {\n    const result = await pool.query(\n      `UPDATE users\n       SET email_verified = TRUE,\n           email_verified_at = CURRENT_TIMESTAMP,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE LOWER(email) = $1\n       RETURNING stripe_customer_id, email_verified`,\n      [normalizedEmail]\n    );\n\n    if (result.rows.length === 0) {\n      // No user found with this email - this is OK for new signups\n      console.log(`[SPLICE] No user found for email verification: ${normalizedEmail}`);\n      return { success: true, userFound: false };\n    }\n\n    console.log(`[SPLICE] Email verified for user: ${result.rows[0].stripe_customer_id}`);\n    return { success: true, userFound: true, customerId: result.rows[0].stripe_customer_id };\n  } catch (err) {\n    console.error('[SPLICE] markEmailVerified error:', err.message);\n    return { success: false, error: err.message };\n  }\n}\n\n/**\n * Check if a user's email is verified\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{verified: boolean, verifiedAt?: Date}>}\n */\nasync function isEmailVerified(stripeCustomerId) {\n  try {\n    const result = await pool.query(\n      `SELECT email_verified, email_verified_at\n       FROM users\n       WHERE stripe_customer_id = $1`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      return { verified: false };\n    }\n\n    return {\n      verified: result.rows[0].email_verified === true,\n      verifiedAt: result.rows[0].email_verified_at\n    };\n  } catch (err) {\n    console.error('[SPLICE] isEmailVerified error:', err.message);\n    return { verified: false };\n  }\n}\n\n/**\n * Get user by email address\n * @param {string} email - Email address\n * @returns {Promise<Object|null>} User object or null\n */\nasync function getUserByEmail(email) {\n  if (!email) return null;\n\n  const normalizedEmail = email.toLowerCase().trim();\n\n  try {\n    const result = await pool.query(\n      `SELECT stripe_customer_id, email, tier, email_verified, email_verified_at\n       FROM users\n       WHERE LOWER(email) = $1`,\n      [normalizedEmail]\n    );\n\n    return result.rows.length > 0 ? result.rows[0] : null;\n  } catch (err) {\n    console.error('[SPLICE] getUserByEmail error:', err.message);\n    return null;\n  }\n}\n\nmodule.exports = {\n  initDatabase,\n  getOrCreateUser,\n  customerExists,\n  getBalance,\n  hasCredits,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  checkIsolationAccess,\n  deductUsage,\n  deductIsolationUsage,\n  resetHours,\n  updateTier,\n  getUsageHistory,\n  isEventProcessed,\n  recordWebhookEvent,\n  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  resetMusicCredits,\n  addMusicCredits,\n  getMusicUsageHistory,\n  initMusicCreditsColumns,\n  // Variations credits functions\n  checkVariationsCredits,\n  deductVariationsCredit,\n  // Scene-aware credits functions\n  checkSceneAwareCredits,\n  deductSceneAwareCredit,\n  // Pool management\n  closePool,\n  checkDatabase,\n  // Trial management\n  updateTrialEnd,\n  // Email verification functions\n  markEmailVerified,\n  isEmailVerified,\n  getUserByEmail,\n  // Constants\n  TIER_HOURS,\n  TIER_ISOLATION_MINUTES,\n  TIER_ISOLATION_HOURS,\n  ISOLATION_OVERAGE_RATE,\n  HOURS_OVERAGE_RATE,\n  TIER_MUSIC_CREDITS,\n  MUSIC_OVERAGE_RATE,\n  MUSIC_OVERAGE_RATES,\n  VARIATIONS_CREDIT_COST,\n  VARIATIONS_OVERAGE_RATES,\n  SCENE_AWARE_CREDIT_COST,\n  SCENE_AWARE_OVERAGE_RATES,\n  // Feature access\n  TIER_FEATURES,\n  hasFeatureAccess\n};\n","structuredPatch":[{"oldStart":1755,"oldLines":6,"newStart":1755,"newLines":7,"lines":["   getMusicCredits,","   hasMusicCredits,","   deductMusicCredit,","+  deductMusicCredits,","   resetMusicCredits,","   addMusicCredits,","   getMusicUsageHistory,"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"0afcdf38-309b-4219-8edb-39d3bcab340f"}
{"parentUuid":"8414c444-e331-484d-9a88-d8fe064f2905","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_01N8EaBGDLsL29NGGEgR7tmd","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the music.js route to use the new atomic function. First, let me see the exact context around lines 887-891."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":452,"cache_read_input_tokens":60773,"cache_creation":{"ephemeral_5m_input_tokens":452,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX4jnTbAqMJ2GLHr2WvU3","type":"assistant","uuid":"cbe865df-cf93-4627-b5b0-b8cf88e1e3c0","timestamp":"2026-01-13T04:22:37.538Z"}
{"parentUuid":"cbe865df-cf93-4627-b5b0-b8cf88e1e3c0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_01N8EaBGDLsL29NGGEgR7tmd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MYDtkHPEX9Ek4uBLu6V79n","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/music.js","offset":880,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":452,"cache_read_input_tokens":60773,"cache_creation":{"ephemeral_5m_input_tokens":452,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX4jnTbAqMJ2GLHr2WvU3","type":"assistant","uuid":"16ef1f3f-c0d0-4ab9-80e1-0c7e3c799e02","timestamp":"2026-01-13T04:22:38.264Z"}
{"parentUuid":"16ef1f3f-c0d0-4ab9-80e1-0c7e3c799e02","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MYDtkHPEX9Ek4uBLu6V79n","type":"tool_result","content":"   880→          type: 'timeline',\n   881→          chapterCount: String(result.chapters.length)\n   882→        });\n   883→\n   884→        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n   885→      }\n   886→\n   887→      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)\n   888→      for (let i = 0; i < creditCost; i++) {\n   889→        await usageTracking.deductMusicCredit(customerId);\n   890→      }\n   891→\n   892→      res.json({\n   893→        success: true,\n   894→        duration: result.duration,\n   895→        chapters: result.chapters,\n   896→        metadata: result.metadata,\n   897→        audioUrl: signedUrl,\n   898→        r2Key,\n   899→        creditCost,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"fc2f2d8f-c48a-47f1-8af9-e3372ee2c777","timestamp":"2026-01-13T04:22:38.334Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/music.js","content":"          type: 'timeline',\n          chapterCount: String(result.chapters.length)\n        });\n\n        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n      }\n\n      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)\n      for (let i = 0; i < creditCost; i++) {\n        await usageTracking.deductMusicCredit(customerId);\n      }\n\n      res.json({\n        success: true,\n        duration: result.duration,\n        chapters: result.chapters,\n        metadata: result.metadata,\n        audioUrl: signedUrl,\n        r2Key,\n        creditCost,","numLines":20,"startLine":880,"totalLines":913}},"sourceToolAssistantUUID":"16ef1f3f-c0d0-4ab9-80e1-0c7e3c799e02"}
{"parentUuid":"fc2f2d8f-c48a-47f1-8af9-e3372ee2c777","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WQ2ANDQWXcL8Puy4yWfus6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PFaXqn68CkfASo4APKtFAP","name":"Edit","input":{"replace_all":false,"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/music.js","old_string":"      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)\n      for (let i = 0; i < creditCost; i++) {\n        await usageTracking.deductMusicCredit(customerId);\n      }","new_string":"      // Deduct timeline credits atomically (prevents race condition exploitation)\n      const deductResult = await usageTracking.deductMusicCredits(customerId, creditCost);\n      if (!deductResult.success) {\n        console.error(`[SPLICE Timeline] Credit deduction failed: ${deductResult.error}`);\n        // Generation already completed, log the error but don't fail the response\n      }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":464,"cache_read_input_tokens":61225,"cache_creation":{"ephemeral_5m_input_tokens":464,"ephemeral_1h_input_tokens":0},"output_tokens":283,"service_tier":"standard"}},"requestId":"req_011CX4jnkrVcJ6eVHVT7yNDP","type":"assistant","uuid":"df7f07f4-f5b2-4586-a5a8-3a42b90229eb","timestamp":"2026-01-13T04:22:43.588Z"}
{"parentUuid":"df7f07f4-f5b2-4586-a5a8-3a42b90229eb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PFaXqn68CkfASo4APKtFAP","type":"tool_result","content":"The file /Users/imorgado/SPLICE/splice-backend/routes/music.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   883→\n   884→        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n   885→      }\n   886→\n   887→      // Deduct timeline credits atomically (prevents race condition exploitation)\n   888→      const deductResult = await usageTracking.deductMusicCredits(customerId, creditCost);\n   889→      if (!deductResult.success) {\n   890→        console.error(`[SPLICE Timeline] Credit deduction failed: ${deductResult.error}`);\n   891→        // Generation already completed, log the error but don't fail the response\n   892→      }\n   893→\n   894→      res.json({\n   895→        success: true,\n   896→        duration: result.duration,"}]},"uuid":"3b4789f5-18a0-4c5e-967f-ed04ae35809c","timestamp":"2026-01-13T04:22:43.651Z","toolUseResult":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/music.js","oldString":"      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)\n      for (let i = 0; i < creditCost; i++) {\n        await usageTracking.deductMusicCredit(customerId);\n      }","newString":"      // Deduct timeline credits atomically (prevents race condition exploitation)\n      const deductResult = await usageTracking.deductMusicCredits(customerId, creditCost);\n      if (!deductResult.success) {\n        console.error(`[SPLICE Timeline] Credit deduction failed: ${deductResult.error}`);\n        // Generation already completed, log the error but don't fail the response\n      }","originalFile":"/**\n * Music Routes\n *\n * AI Music generation endpoints (Phase 8)\n */\n\nconst express = require('express');\n\n// Lazy-load music services to prevent startup failures if deps missing\nlet musicQueue, songIdentification, musicGeneration, r2Storage, musicAlignment, musicTimeline;\nlet musicServicesLoaded = false;\nlet musicGenerationLoaded = false;\n\n/**\n * Load only musicGeneration service (no Redis dependency)\n * Used by /moods and /instruments endpoints\n */\nfunction loadMusicGenerationOnly() {\n  if (!musicGenerationLoaded) {\n    try {\n      musicGeneration = require('../services/musicGeneration');\n      musicGenerationLoaded = true;\n    } catch (err) {\n      console.warn('[SPLICE] Music generation service not available:', err.message);\n    }\n  }\n}\n\n/**\n * Load all music services including Redis-dependent ones\n * Used by endpoints that need queue functionality\n */\nfunction loadMusicServices() {\n  if (!musicServicesLoaded) {\n    try {\n      // Load musicGeneration first (no Redis dependency)\n      loadMusicGenerationOnly();\n\n      // Load Redis-dependent services with timeout protection\n      songIdentification = require('../services/songIdentification');\n      r2Storage = require('../services/r2Storage');\n      musicAlignment = require('../services/musicAlignment');\n      musicTimeline = require('../services/musicTimeline');\n\n      // Load musicQueue last (Redis-dependent, may throw)\n      try {\n        musicQueue = require('../services/musicQueue');\n      } catch (queueErr) {\n        console.warn('[SPLICE] Music queue not available (Redis not configured):', queueErr.message);\n        // Continue without queue - some endpoints will return 503\n      }\n\n      musicServicesLoaded = true;\n    } catch (err) {\n      console.warn('[SPLICE] Music services not available:', err.message);\n    }\n  }\n}\n\n/**\n * Create music routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (requireCredits)\n * @param {Object} options.services - Shared services (usageTracking)\n * @returns {express.Router}\n */\nfunction createMusicRoutes(options = {}) {\n  const router = express.Router();\n  const { requireCredits } = options.middleware || {};\n  const { usageTracking } = options.services || {};\n\n  // Note: Services are now loaded lazily on first route access\n  // This prevents Redis dependency from blocking startup\n\n  /**\n   * POST /identify - Identify song from YouTube URL\n   */\n  router.post('/identify', requireCredits, async (req, res) => {\n    const { youtubeUrl } = req.body;\n\n    if (!youtubeUrl) {\n      return res.status(400).json({ error: 'youtubeUrl is required' });\n    }\n\n    if (!songIdentification) {\n      return res.status(503).json({ error: 'Song identification service not available' });\n    }\n\n    try {\n      // Validate URL\n      const validation = songIdentification.validateYouTubeUrl(youtubeUrl);\n      if (!validation.valid) {\n        return res.status(400).json({ error: validation.error });\n      }\n\n      // Check dependencies\n      const deps = await songIdentification.checkDependencies();\n      if (!deps.ytdlp) {\n        return res.status(503).json({ error: 'yt-dlp is not installed on server' });\n      }\n      if (!deps.ffmpeg) {\n        return res.status(503).json({ error: 'FFmpeg is not installed on server' });\n      }\n\n      // Check ACRCloud credentials\n      if (!songIdentification.hasACRCloudCredentials()) {\n        return res.status(503).json({ error: 'ACRCloud credentials not configured' });\n      }\n\n      // Identify song\n      const result = await songIdentification.identifyFromYouTube(youtubeUrl);\n\n      res.json(result);\n\n    } catch (err) {\n      console.error('[SPLICE] Song identification error:', err.message);\n      res.status(500).json({ error: err.message || 'Song identification failed' });\n    }\n  });\n\n  /**\n   * POST /generate - Start music generation job\n   */\n  router.post('/generate', requireCredits, async (req, res) => {\n    const { youtubeUrl, prompt, duration, mood, instruments, referenceSong } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      // Validate options if musicGeneration is available\n      if (musicGeneration) {\n        const validation = musicGeneration.validateOptions({ duration, mood, instruments });\n        if (!validation.valid) {\n          return res.status(400).json({ error: validation.errors.join(', ') });\n        }\n      }\n\n      // Add job to queue\n      const result = await musicQueue.addMusicJob({\n        customerId,\n        youtubeUrl,\n        prompt,\n        duration: duration || 60,\n        mood: mood || 'neutral',\n        instruments: instruments || [],\n        referenceSong\n      });\n\n      res.json({\n        success: true,\n        jobId: result.jobId,\n        status: result.status,\n        estimatedTime: result.estimatedTime,\n        statusUrl: `/music/status/${result.jobId}`\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Music generation error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to start music generation' });\n    }\n  });\n\n  /**\n   * POST /generate-variations - Generate 3 song variations for user selection\n   */\n  router.post('/generate-variations', requireCredits, async (req, res) => {\n    const { prompt, duration, mood, instruments, referenceSong } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      // Validate options if musicGeneration is available\n      if (musicGeneration) {\n        const validation = musicGeneration.validateOptions({ duration, mood, instruments });\n        if (!validation.valid) {\n          return res.status(400).json({ error: validation.errors.join(', ') });\n        }\n      }\n\n      // Check for variations credits (2.5 credits = 3 music credits equivalent)\n      const hasCredits = await usageTracking.checkVariationsCredits(customerId);\n      if (!hasCredits.canGenerate) {\n        return res.status(402).json({\n          error: 'Insufficient credits for variations',\n          creditsRequired: 2.5,\n          creditsAvailable: hasCredits.creditsAvailable\n        });\n      }\n\n      // Add variations job to queue\n      const result = await musicQueue.addVariationsJob({\n        customerId,\n        prompt,\n        duration: duration || 60,\n        mood: mood || 'neutral',\n        instruments: instruments || [],\n        referenceSong\n      });\n\n      res.json({\n        success: true,\n        jobId: result.jobId,\n        status: result.status,\n        isVariations: true,\n        estimatedTime: result.estimatedTime,\n        statusUrl: `/music/variations/status/${result.jobId}`\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Music variations error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to start variations generation' });\n    }\n  });\n\n  /**\n   * POST /generate-scene-aware - Generate music with transcript analysis\n   */\n  router.post('/generate-scene-aware', requireCredits, async (req, res) => {\n    const { segments, prompt, duration, mood, instruments, referenceSong } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    // Validate segments\n    if (!segments || !Array.isArray(segments) || segments.length === 0) {\n      return res.status(400).json({ error: 'Transcript segments are required' });\n    }\n\n    try {\n      // Validate scene-aware options\n      if (musicGeneration) {\n        const validation = musicGeneration.validateSceneAwareOptions(segments, { duration, mood, instruments });\n        if (!validation.valid) {\n          return res.status(400).json({ error: validation.errors.join(', ') });\n        }\n      }\n\n      // Check for scene-aware credits (1.5 credits)\n      const hasCredits = await usageTracking.checkSceneAwareCredits(customerId);\n      if (!hasCredits.canGenerate) {\n        return res.status(402).json({\n          error: 'Insufficient credits for scene-aware music',\n          creditsRequired: 1.5,\n          creditsAvailable: hasCredits.creditsAvailable\n        });\n      }\n\n      // Add scene-aware job to queue with scene analysis flag\n      const result = await musicQueue.addMusicJob({\n        customerId,\n        prompt,\n        duration: duration || 60,\n        mood: mood || 'neutral',\n        instruments: instruments || [],\n        referenceSong,\n        isSceneAware: true,\n        segments\n      });\n\n      res.json({\n        success: true,\n        jobId: result.jobId,\n        status: result.status,\n        isSceneAware: true,\n        estimatedTime: result.estimatedTime,\n        statusUrl: `/music/status/${result.jobId}`\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Scene-aware music error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to start scene-aware music generation' });\n    }\n  });\n\n  /**\n   * GET /variations/status/:jobId - Get variations job status with detailed progress\n   */\n  router.get('/variations/status/:jobId', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      const status = await musicQueue.getVariationsJobStatus(jobId);\n\n      if (!status) {\n        return res.status(404).json({ error: 'Job not found' });\n      }\n\n      // Verify ownership\n      if (status.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Not authorized to access this job' });\n      }\n\n      res.json(status);\n\n    } catch (err) {\n      console.error('[SPLICE] Variations status error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get job status' });\n    }\n  });\n\n  /**\n   * POST /variations/:jobId/select - Select a variation to finalize\n   */\n  router.post('/variations/:jobId/select', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const { variationIndex } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    if (variationIndex === undefined || variationIndex === null) {\n      return res.status(400).json({ error: 'variationIndex is required' });\n    }\n\n    const index = parseInt(variationIndex);\n    if (isNaN(index) || index < 0 || index > 2) {\n      return res.status(400).json({ error: 'variationIndex must be 0, 1, or 2' });\n    }\n\n    try {\n      // Select the variation\n      const result = await musicQueue.selectVariation(jobId, index, customerId);\n\n      // Deduct variations credits (2.5 credits)\n      await usageTracking.deductVariationsCredit(customerId);\n\n      res.json({\n        success: true,\n        ...result\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Variation selection error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to select variation' });\n    }\n  });\n\n  /**\n   * GET /status/:jobId - Get job status\n   */\n  router.get('/status/:jobId', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      const status = await musicQueue.getJobStatus(jobId);\n\n      if (!status) {\n        return res.status(404).json({ error: 'Job not found' });\n      }\n\n      // Verify ownership\n      if (status.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n\n      res.json(status);\n\n    } catch (err) {\n      console.error('[SPLICE] Job status error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get job status' });\n    }\n  });\n\n  /**\n   * GET /library - Get user's music library\n   */\n  router.get('/library', requireCredits, async (req, res) => {\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      const jobs = await musicQueue.getCustomerJobs(customerId, {\n        limit: parseInt(req.query.limit) || 50,\n        offset: parseInt(req.query.offset) || 0\n      });\n\n      // Filter to only completed jobs for library\n      const library = jobs.filter(j => j.status === 'completed');\n\n      res.json(library);\n\n    } catch (err) {\n      console.error('[SPLICE] Music library error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to load music library' });\n    }\n  });\n\n  /**\n   * GET /credits - Get music credits balance\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/credits', requireCredits, async (req, res) => {\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    try {\n      // Get credits from database using usageTracking\n      const credits = await usageTracking.getMusicCredits(customerId);\n\n      res.json(credits);\n\n    } catch (err) {\n      console.error('[SPLICE] Music credits error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get credits' });\n    }\n  });\n\n  /**\n   * GET /moods - Get available mood presets\n   * Note: Uses lightweight loader (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/moods', (req, res) => {\n    loadMusicGenerationOnly();\n    if (!musicGeneration) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    res.json(musicGeneration.getAvailableMoods());\n  });\n\n  /**\n   * GET /instruments - Get available instrument presets\n   * Note: Uses lightweight loader (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/instruments', (req, res) => {\n    loadMusicGenerationOnly();\n    if (!musicGeneration) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    res.json(musicGeneration.getAvailableInstruments());\n  });\n\n  /**\n   * GET /queue-stats - Get queue statistics (admin only)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   * SECURITY: Restricted to admin customers only\n   */\n  router.get('/queue-stats', requireCredits, async (req, res) => {\n    // SECURITY: Check for admin access\n    // Only allow specific admin customer IDs (configured via env var)\n    const adminCustomerIds = (process.env.ADMIN_CUSTOMER_IDS || '').split(',').filter(Boolean);\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId || (adminCustomerIds.length > 0 && !adminCustomerIds.includes(customerId))) {\n      return res.status(403).json({ error: 'Admin access required' });\n    }\n\n    loadMusicServices();\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    try {\n      const stats = await musicQueue.getQueueStats();\n      res.json(stats);\n    } catch (err) {\n      console.error('[SPLICE] Queue stats error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get queue stats' });\n    }\n  });\n\n  /**\n   * GET /alignment-options - Get alignment configuration options\n   * Note: Loads alignment service on demand (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/alignment-options', (req, res) => {\n    // Load alignment service on demand if not already loaded\n    if (!musicAlignment) {\n      try {\n        musicAlignment = require('../services/musicAlignment');\n      } catch (err) {\n        console.warn('[SPLICE] Music alignment service not available:', err.message);\n        return res.status(503).json({ error: 'Music alignment service not available' });\n      }\n    }\n\n    res.json({\n      fadeDuration: {\n        default: musicAlignment.DEFAULT_FADE_DURATION,\n        min: musicAlignment.MIN_FADE_DURATION,\n        max: musicAlignment.MAX_FADE_DURATION\n      },\n      searchWindow: {\n        default: musicAlignment.BEAT_SEARCH_WINDOW,\n        min: 0.5,\n        max: 10\n      },\n      minAudioDuration: musicAlignment.MIN_AUDIO_DURATION\n    });\n  });\n\n  /**\n   * GET /timeline-options - Get timeline generation options and presets\n   * Note: Loads timeline service on demand (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/timeline-options', (req, res) => {\n    // Load timeline service on demand if not already loaded\n    if (!musicTimeline) {\n      try {\n        musicTimeline = require('../services/musicTimeline');\n      } catch (err) {\n        console.warn('[SPLICE] Music timeline service not available:', err.message);\n        return res.status(503).json({ error: 'Music timeline service not available' });\n      }\n    }\n\n    res.json(musicTimeline.getTimelinePresets());\n  });\n\n  /**\n   * POST /timeline-estimate - Estimate timeline generation time\n   * Note: Loads timeline service on demand (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.post('/timeline-estimate', (req, res) => {\n    const { transcript, maxChapters, minChapterLength } = req.body;\n\n    // Load timeline service on demand if not already loaded\n    if (!musicTimeline) {\n      try {\n        musicTimeline = require('../services/musicTimeline');\n      } catch (err) {\n        console.warn('[SPLICE] Music timeline service not available:', err.message);\n        return res.status(503).json({ error: 'Music timeline service not available' });\n      }\n    }\n\n    if (!transcript || !transcript.duration) {\n      return res.status(400).json({ error: 'transcript with duration is required' });\n    }\n\n    const estimate = musicTimeline.estimateGenerationTime(transcript, {\n      maxChapters,\n      minChapterLength\n    });\n\n    res.json(estimate);\n  });\n\n  /**\n   * GET /:jobId - Get music with signed download URL\n   * IMPORTANT: This is a catch-all route - must be defined AFTER all specific routes\n   */\n  router.get('/:jobId', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue || !r2Storage) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    try {\n      const status = await musicQueue.getJobStatus(jobId);\n\n      if (!status) {\n        return res.status(404).json({ error: 'Music not found' });\n      }\n\n      // Verify ownership\n      if (status.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n\n      if (status.status !== 'completed') {\n        return res.status(400).json({ error: 'Music generation not complete' });\n      }\n\n      // Generate signed download URLs\n      const masterKey = r2Storage.generateStorageKey(customerId, jobId, 'master.wav');\n      const previewKey = r2Storage.generateStorageKey(customerId, jobId, 'preview.mp3');\n\n      const [downloadUrl, previewUrl] = await Promise.all([\n        r2Storage.getSignedDownloadUrl(masterKey, 3600), // 1 hour\n        r2Storage.getSignedDownloadUrl(previewKey, 3600).catch(() => null)\n      ]);\n\n      res.json({\n        success: true,\n        music: {\n          jobId,\n          title: status.data.musicResult?.title || 'Generated Music',\n          duration: status.data.duration,\n          mood: status.data.mood,\n          downloadUrl,\n          previewUrl,\n          createdAt: status.createdAt,\n          completedAt: status.completedAt\n        }\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Get music error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get music' });\n    }\n  });\n\n  /**\n   * DELETE /:jobId - Delete music from library\n   */\n  router.delete('/:jobId', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue || !r2Storage) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    try {\n      const status = await musicQueue.getJobStatus(jobId);\n\n      if (!status) {\n        return res.status(404).json({ error: 'Music not found' });\n      }\n\n      // Verify ownership\n      if (status.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n\n      // Delete from R2\n      await r2Storage.deleteJobFiles(customerId, jobId);\n\n      // Note: Job record stays in Redis for history\n      // Could optionally call musicQueue.cancelJob if we want to remove it\n\n      res.json({ success: true, message: 'Music deleted' });\n\n    } catch (err) {\n      console.error('[SPLICE] Delete music error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to delete music' });\n    }\n  });\n\n  /**\n   * POST /align - Align music to video duration with beat-matching\n   */\n  router.post('/align', requireCredits, async (req, res) => {\n    const { jobId, targetDuration, fadeDuration, beatAlign = true, searchWindow } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!jobId) {\n      return res.status(400).json({ error: 'jobId is required' });\n    }\n\n    if (!targetDuration || typeof targetDuration !== 'number') {\n      return res.status(400).json({ error: 'targetDuration (number in seconds) is required' });\n    }\n\n    if (!musicAlignment || !musicQueue || !r2Storage) {\n      return res.status(503).json({ error: 'Music alignment service not available' });\n    }\n\n    try {\n      // Validate options\n      const validation = musicAlignment.validateAlignmentOptions({\n        targetDuration,\n        fadeDuration,\n        searchWindow\n      });\n      if (!validation.valid) {\n        return res.status(400).json({ error: validation.errors.join(', ') });\n      }\n\n      // Get job and verify ownership\n      const job = await musicQueue.getJobStatus(jobId);\n      if (!job) {\n        return res.status(404).json({ error: 'Job not found' });\n      }\n      if (job.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n      if (job.status !== 'completed') {\n        return res.status(400).json({ error: 'Job must be completed before alignment' });\n      }\n\n      // Download the master audio from R2\n      const masterKey = r2Storage.generateStorageKey(customerId, jobId, 'master.wav');\n      const audioBuffer = await r2Storage.downloadFile(masterKey);\n\n      // Perform alignment with beat detection\n      const result = await musicAlignment.trimToLength(audioBuffer, targetDuration, {\n        fadeDuration: fadeDuration || musicAlignment.DEFAULT_FADE_DURATION,\n        beatAlign,\n        searchWindow: searchWindow || musicAlignment.BEAT_SEARCH_WINDOW\n      });\n\n      // Generate aligned file key\n      const alignedKey = r2Storage.generateStorageKey(customerId, jobId, `aligned_${Math.round(targetDuration)}s.wav`);\n\n      // Upload aligned audio to R2\n      await r2Storage.uploadBuffer(alignedKey, result.buffer, 'audio/wav');\n\n      // Get signed URL for download\n      const downloadUrl = await r2Storage.getSignedDownloadUrl(alignedKey, 3600);\n\n      res.json({\n        success: true,\n        jobId,\n        targetDuration,\n        actualDuration: result.cutTime,\n        wasAligned: result.wasAligned,\n        beatCount: result.beats.length,\n        downloadUrl,\n        alignedKey\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Music align error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to align music' });\n    }\n  });\n\n  /**\n   * POST /analyze-beats - Analyze beats in audio without trimming\n   */\n  router.post('/analyze-beats', requireCredits, async (req, res) => {\n    const { jobId } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!jobId) {\n      return res.status(400).json({ error: 'jobId is required' });\n    }\n\n    if (!musicAlignment || !musicQueue || !r2Storage) {\n      return res.status(503).json({ error: 'Music alignment service not available' });\n    }\n\n    try {\n      // Get job and verify ownership\n      const job = await musicQueue.getJobStatus(jobId);\n      if (!job) {\n        return res.status(404).json({ error: 'Job not found' });\n      }\n      if (job.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n      if (job.status !== 'completed') {\n        return res.status(400).json({ error: 'Job must be completed before analysis' });\n      }\n\n      // Download the master audio from R2\n      const masterKey = r2Storage.generateStorageKey(customerId, jobId, 'master.wav');\n      const audioBuffer = await r2Storage.downloadFile(masterKey);\n\n      // Analyze beats\n      const analysis = await musicAlignment.analyzeBeats(audioBuffer);\n\n      res.json({\n        success: true,\n        jobId,\n        duration: analysis.duration,\n        beatCount: analysis.beatCount,\n        bpm: analysis.bpm,\n        beats: analysis.beats\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Beat analysis error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to analyze beats' });\n    }\n  });\n\n  /**\n   * POST /generate-timeline - Generate per-chapter mood-matched music\n   * Billing: 3 credits per timeline job (multiple generations + assembly)\n   */\n  router.post('/generate-timeline', requireCredits, async (req, res) => {\n    const { transcript, maxChapters, minChapterLength, crossfadeDuration, instruments, prompt } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    loadMusicServices();\n    if (!musicTimeline) {\n      return res.status(503).json({ error: 'Music timeline service not available' });\n    }\n\n    if (!musicGeneration || !musicGeneration.hasMurekaCredentials()) {\n      return res.status(503).json({ error: 'Music generation service not configured' });\n    }\n\n    // Validate transcript\n    if (!transcript) {\n      return res.status(400).json({ error: 'transcript is required' });\n    }\n\n    // Validate options\n    const validation = musicTimeline.validateTimelineOptions(transcript, {\n      maxChapters,\n      minChapterLength,\n      crossfadeDuration\n    });\n\n    if (!validation.valid) {\n      return res.status(400).json({ error: validation.errors.join(', ') });\n    }\n\n    try {\n      // Check music credits (timeline costs 3 credits due to multiple generations)\n      const creditCost = 3;\n\n      // Estimate generation time\n      const estimate = musicTimeline.estimateGenerationTime(transcript, {\n        maxChapters: maxChapters || 10,\n        minChapterLength: minChapterLength || 60\n      });\n\n      console.log(`[SPLICE Timeline] Starting generation for ${customerId} - est. ${estimate.estimatedChapters} chapters`);\n\n      // Generate timeline music\n      const result = await musicTimeline.generateTimelineMusic(transcript, {\n        maxChapters: maxChapters || 10,\n        minChapterLength: minChapterLength || 60,\n        crossfadeDuration: crossfadeDuration || 2.0,\n        instruments: instruments || [],\n        prompt: prompt || ''\n      });\n\n      // Upload to R2 if available\n      let r2Key = null;\n      let signedUrl = null;\n\n      if (r2Storage && result.audioBuffer) {\n        const jobId = `timeline_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n        r2Key = `${customerId}/${jobId}/timeline.wav`;\n\n        // Note: uploadMusic signature is (buffer, key, metadata)\n        await r2Storage.uploadMusic(result.audioBuffer, r2Key, {\n          customerId,\n          jobId,\n          type: 'timeline',\n          chapterCount: String(result.chapters.length)\n        });\n\n        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n      }\n\n      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)\n      for (let i = 0; i < creditCost; i++) {\n        await usageTracking.deductMusicCredit(customerId);\n      }\n\n      res.json({\n        success: true,\n        duration: result.duration,\n        chapters: result.chapters,\n        metadata: result.metadata,\n        audioUrl: signedUrl,\n        r2Key,\n        creditCost,\n        estimate\n      });\n\n    } catch (err) {\n      console.error('[SPLICE Timeline] Generation error:', err.message);\n      res.status(500).json({ error: err.message || 'Timeline generation failed' });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createMusicRoutes;\n","structuredPatch":[{"oldStart":884,"oldLines":9,"newStart":884,"newLines":11,"lines":["         signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);","       }"," ","-      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)","-      for (let i = 0; i < creditCost; i++) {","-        await usageTracking.deductMusicCredit(customerId);","+      // Deduct timeline credits atomically (prevents race condition exploitation)","+      const deductResult = await usageTracking.deductMusicCredits(customerId, creditCost);","+      if (!deductResult.success) {","+        console.error(`[SPLICE Timeline] Credit deduction failed: ${deductResult.error}`);","+        // Generation already completed, log the error but don't fail the response","       }"," ","       res.json({"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"df7f07f4-f5b2-4586-a5a8-3a42b90229eb"}
{"parentUuid":"f75ecffc-3b3e-445b-9850-6d69a0b87748","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_013XBwSrwmictmDo2QTFMvUW","type":"message","role":"assistant","content":[{"type":"text","text":"The fix is complete. Let me verify the changes by showing the updated code in context."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":633,"cache_read_input_tokens":61689,"cache_creation":{"ephemeral_5m_input_tokens":633,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX4joc2TFeejRJk7FBtAH","type":"assistant","uuid":"aa2c7510-2061-4730-ad15-bf6b84d04ffb","timestamp":"2026-01-13T04:22:52.980Z"}
{"parentUuid":"aa2c7510-2061-4730-ad15-bf6b84d04ffb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_013XBwSrwmictmDo2QTFMvUW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WkjTGr6yS3526NJ6R9hVkP","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/music.js","offset":883,"limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":633,"cache_read_input_tokens":61689,"cache_creation":{"ephemeral_5m_input_tokens":633,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX4joc2TFeejRJk7FBtAH","type":"assistant","uuid":"6cbbd8f5-421d-4993-82ad-70dc4248feb1","timestamp":"2026-01-13T04:22:53.564Z"}
{"parentUuid":"6cbbd8f5-421d-4993-82ad-70dc4248feb1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WkjTGr6yS3526NJ6R9hVkP","type":"tool_result","content":"   883→\n   884→        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n   885→      }\n   886→\n   887→      // Deduct timeline credits atomically (prevents race condition exploitation)\n   888→      const deductResult = await usageTracking.deductMusicCredits(customerId, creditCost);\n   889→      if (!deductResult.success) {\n   890→        console.error(`[SPLICE Timeline] Credit deduction failed: ${deductResult.error}`);\n   891→        // Generation already completed, log the error but don't fail the response\n   892→      }\n   893→\n   894→      res.json({\n   895→        success: true,\n   896→        duration: result.duration,\n   897→        chapters: result.chapters,\n   898→        metadata: result.metadata,\n   899→        audioUrl: signedUrl,\n   900→        r2Key,\n   901→        creditCost,\n   902→        estimate\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a9664ad5-4e6e-40a6-a296-5688d8b4d33f","timestamp":"2026-01-13T04:22:53.629Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/music.js","content":"\n        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n      }\n\n      // Deduct timeline credits atomically (prevents race condition exploitation)\n      const deductResult = await usageTracking.deductMusicCredits(customerId, creditCost);\n      if (!deductResult.success) {\n        console.error(`[SPLICE Timeline] Credit deduction failed: ${deductResult.error}`);\n        // Generation already completed, log the error but don't fail the response\n      }\n\n      res.json({\n        success: true,\n        duration: result.duration,\n        chapters: result.chapters,\n        metadata: result.metadata,\n        audioUrl: signedUrl,\n        r2Key,\n        creditCost,\n        estimate","numLines":20,"startLine":883,"totalLines":915}},"sourceToolAssistantUUID":"6cbbd8f5-421d-4993-82ad-70dc4248feb1"}
{"parentUuid":"a9664ad5-4e6e-40a6-a296-5688d8b4d33f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-website","sessionId":"ddf08b25-1921-420c-b7bd-a88199d7399d","version":"2.1.6","gitBranch":"main","agentId":"a49c2d0","slug":"glimmering-growing-petal","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UPvMaeV9j7gD5LgMzcndzn","type":"message","role":"assistant","content":[{"type":"text","text":"The fix has been applied. Here is a summary of the changes:\n\n## Summary of Changes\n\n### 1. New atomic function in `usageTracking.js` (lines 1013-1127)\n\nAdded `deductMusicCredits(stripeCustomerId, count)` which:\n- Uses `SELECT ... FOR UPDATE` to lock the user row and prevent concurrent modifications\n- Performs all credit deduction and overage calculation in a single transaction\n- Handles three scenarios:\n  - **Enough credits**: Deducts all from included credits\n  - **Partial credits**: Uses remaining credits, charges overage for the rest\n  - **No credits**: Charges full overage\n- Reports overage to Stripe atomically\n- Creates a single usage log entry for the entire batch\n\n### 2. Updated `music.js` route (lines 887-892)\n\nChanged from vulnerable sequential loop:\n```javascript\n// OLD - Race condition vulnerability\nfor (let i = 0; i < creditCost; i++) {\n  await usageTracking.deductMusicCredit(customerId);\n}\n```\n\nTo atomic single operation:\n```javascript\n// NEW - Atomic deduction with FOR UPDATE lock\nconst deductResult = await usageTracking.deductMusicCredits(customerId, creditCost);\nif (!deductResult.success) {\n  console.error(`[SPLICE Timeline] Credit deduction failed: ${deductResult.error}`);\n}\n```\n\n### 3. Exported new function\n\nAdded `deductMusicCredits` to the module exports in `usageTracking.js` (line 1758).\n\n## Security Impact\n\nThis fix prevents users from exploiting race conditions where:\n- Multiple concurrent requests could each pass the credit check\n- Credits would be deducted sequentially, allowing generation to complete before full deduction\n- Users could generate music without proper credit deduction\n\nThe `FOR UPDATE` lock ensures that only one transaction can modify a user's credits at a time, making the operation atomic."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":464,"cache_read_input_tokens":62322,"cache_creation":{"ephemeral_5m_input_tokens":464,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX4jotJzQJBgSDG2RrzV2","type":"assistant","uuid":"5366b165-5992-4bc9-9a1e-f559b3251827","timestamp":"2026-01-13T04:23:03.368Z"}
