     1→/**
     2→ * Slice 7: Apply Takes to Timeline (CEP Port)
     3→ *
     4→ * Timeline manipulation functions via JSX:
     5→ * - Label clips with take information
     6→ * - Delete non-best takes
     7→ *
     8→ * Port of UXP slice7-apply.js for CEP compatibility.
     9→ */
    10→
    11→/**
    12→ * Label clips on timeline with take information
    13→ * @returns {Promise<number>} Number of clips labeled
    14→ */
    15→async function labelTakesOnTimeline() {
    16→    const takes = getCurrentTakes();
    17→
    18→    if (!takes || takes.length === 0) {
    19→        throw new Error('No takes to label');
    20→    }
    21→
    22→    // Check if sequence is open
    23→    const seqResult = await jsx.call('getActiveSequence');
    24→    if (seqResult.error) {
    25→        throw new Error('No project or sequence open');
    26→    }
    27→
    28→    let labeledCount = 0;
    29→
    30→    // Get clips from all video tracks
    31→    const numVideoTracks = await jsx.call('getNumTracks', 'video');
    32→
    33→    for (let trackIndex = 0; trackIndex < numVideoTracks; trackIndex++) {
    34→        const clipsJson = await jsx.call('getClipsInTrack', trackIndex, 'video');
    35→        const clips = JSON.parse(clipsJson);
    36→
    37→        for (let clipIndex = 0; clipIndex < clips.length; clipIndex++) {
    38→            const clip = clips[clipIndex];
    39→            const clipStart = clip.start;
    40→
    41→            // Find which take this clip belongs to
    42→            for (const take of takes) {
    43→                const takeStart = take.start || take.startTime || 0;
    44→                const takeEnd = take.end || take.endTime || 0;
    45→
    46→                if (clipStart >= takeStart && clipStart < takeEnd) {
    47→                    // Build label
    48→                    const isBest = take.isBest || take.userMarkedBest;
    49→                    const prefix = isBest ? '* ' : '';
    50→                    const takeNum = take.takeNumber || takes.indexOf(take) + 1;
    51→                    const desc = take.shortLabel || take.description || take.text || '';
    52→                    const shortDesc = desc.split(' ').slice(0, 4).join(' ');
    53→                    const label = `${prefix}Take ${takeNum} - ${shortDesc}`;
    54→
    55→                    // Note: CEP doesn't have direct clip rename - using marker instead
    56→                    // Create a marker at the clip start with the label
    57→                    await jsx.call('createMarker', clipStart, label, 0, `Take ${takeNum}`, 5);
    58→                    labeledCount++;
    59→                    break;
    60→                }
    61→            }
    62→        }
    63→    }
    64→
    65→    return labeledCount;
    66→}
    67→
    68→/**
    69→ * Apply best takes - disable non-best takes by removing clips
    70→ * @returns {Promise<number>} Number of clips removed
    71→ */
    72→async function applyBestTakes() {
    73→    const takes = getCurrentTakes();
    74→
    75→    if (!takes || takes.length === 0) {
    76→        throw new Error('No takes to apply');
    77→    }
    78→
    79→    // Check if sequence is open
    80→    const seqResult = await jsx.call('getActiveSequence');
    81→    if (seqResult.error) {
    82→        throw new Error('No project or sequence open');
    83→    }
    84→
    85→    // Sort takes by start time (descending) - work from end to avoid time shifts
    86→    const sortedTakes = [...takes].sort((a, b) => {
    87→        const aStart = a.start || a.startTime || 0;
    88→        const bStart = b.start || b.startTime || 0;
    89→        return bStart - aStart;
    90→    });
    91→
    92→    let removedCount = 0;
    93→    const numVideoTracks = await jsx.call('getNumTracks', 'video');
    94→    const numAudioTracks = await jsx.call('getNumTracks', 'audio');
    95→
    96→    for (const take of sortedTakes) {
    97→        const isBest = take.isBest || take.userMarkedBest;
    98→        if (isBest) {
    99→            continue; // Keep best takes
   100→        }
   101→
   102→        const takeStart = take.start || take.startTime || 0;
   103→        const takeEnd = take.end || take.endTime || 0;
   104→
   105→        // Process video tracks
   106→        for (let trackIndex = 0; trackIndex < numVideoTracks; trackIndex++) {
   107→            const clipsJson = await jsx.call('getClipsInTrack', trackIndex, 'video');
   108→            const clips = JSON.parse(clipsJson);
   109→
   110→            // Process from end to avoid index shifting
   111→            for (let clipIndex = clips.length - 1; clipIndex >= 0; clipIndex--) {
   112→                const clip = clips[clipIndex];
   113→
   114→                // Check if clip is within the non-best take range
   115→                if (clip.start >= takeStart && clip.end <= takeEnd) {
   116→                    await jsx.call('removeClipByIndex', 'video', trackIndex, clipIndex);
   117→                    removedCount++;
   118→                }
   119→            }
   120→        }
   121→
   122→        // Process audio tracks
   123→        for (let trackIndex = 0; trackIndex < numAudioTracks; trackIndex++) {
   124→            const clipsJson = await jsx.call('getClipsInTrack', trackIndex, 'audio');
   125→            const clips = JSON.parse(clipsJson);
   126→
   127→            // Process from end to avoid index shifting
   128→            for (let clipIndex = clips.length - 1; clipIndex >= 0; clipIndex--) {
   129→                const clip = clips[clipIndex];
   130→
   131→                // Check if clip is within the non-best take range
   132→                if (clip.start >= takeStart && clip.end <= takeEnd) {
   133→                    await jsx.call('removeClipByIndex', 'audio', trackIndex, clipIndex);
   134→                    removedCount++;
   135→                }
   136→            }
   137→        }
   138→    }
   139→
   140→    return removedCount;
   141→}
   142→
   143→/**
   144→ * Add take markers to timeline
   145→ * @returns {Promise<number>} Number of markers added
   146→ */
   147→async function addTakeMarkers() {
   148→    const takes = getCurrentTakes();
   149→
   150→    if (!takes || takes.length === 0) {
   151→        throw new Error('No takes to mark');
   152→    }
   153→
   154→    let markerCount = 0;
   155→
   156→    for (const take of takes) {
   157→        const isBest = take.isBest || take.userMarkedBest;
   158→        const takeStart = take.start || take.startTime || 0;
   159→        const takeEnd = take.end || take.endTime || 0;
   160→        const takeNum = take.takeNumber || takes.indexOf(take) + 1;
   161→        const duration = takeEnd - takeStart;
   162→
   163→        const name = `${isBest ? '* ' : ''}Take ${takeNum}`;
   164→        const comments = take.shortLabel || take.description || '';
   165→        const colorIndex = isBest ? 5 : 4; // Cerulean for best, Lavender for others
   166→
   167→        await jsx.call('createMarker', takeStart, name, duration, comments, colorIndex);
   168→        markerCount++;
   169→    }
   170→
   171→    return markerCount;
   172→}
   173→
   174→// Legacy init functions - no longer needed
   175→function initLabelTimeline() {
   176→    // Now called directly via labelTakesOnTimeline()
   177→}
   178→
   179→function initApplyTakes() {
   180→    // Now called directly via applyBestTakes()
   181→}
   182→
   183→// Export for window access
   184→window.labelTakesOnTimeline = labelTakesOnTimeline;
   185→window.applyBestTakes = applyBestTakes;
   186→window.addTakeMarkers = addTakeMarkers;
   187→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
