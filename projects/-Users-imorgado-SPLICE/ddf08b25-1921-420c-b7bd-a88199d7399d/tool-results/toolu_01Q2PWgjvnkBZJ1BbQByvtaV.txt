     1→/**
     2→ * SPLICE CEP Panel - Builder Module
     3→ * Handles sequence building, cut list processing, and Premiere Pro integration
     4→ * v4.0.0 - CEP Migration
     5→ */
     6→
     7→// ============================================================================
     8→// COLOR MAPPING
     9→// ============================================================================
    10→const SPLICE_COLORS = {
    11→    NONE: 0,
    12→    VIOLET: 1,
    13→    IRIS: 2,
    14→    CARIBBEAN: 3,
    15→    LAVENDER: 4,
    16→    CERULEAN: 5,
    17→    FOREST: 6,
    18→    ROSE: 7,
    19→    MANGO: 8,
    20→    PURPLE: 9,
    21→    BLUE: 10,
    22→    TEAL: 11,
    23→    MAGENTA: 12,
    24→    TAN: 13,
    25→    GREEN: 14,
    26→    BROWN: 15,
    27→    YELLOW: 16
    28→};
    29→
    30→const SEGMENT_COLORS = {
    31→    speech: SPLICE_COLORS.FOREST,
    32→    take: SPLICE_COLORS.LAVENDER,
    33→    best_take: SPLICE_COLORS.CERULEAN,
    34→    silence: SPLICE_COLORS.VIOLET,
    35→    wide_shot: SPLICE_COLORS.YELLOW,
    36→    speaker_a: SPLICE_COLORS.MANGO,
    37→    speaker_b: SPLICE_COLORS.CARIBBEAN
    38→};
    39→
    40→const COLOR_HINT_MAP = {
    41→    cerulean: SPLICE_COLORS.CERULEAN,
    42→    lavender: SPLICE_COLORS.LAVENDER,
    43→    forest: SPLICE_COLORS.FOREST,
    44→    mango: SPLICE_COLORS.MANGO,
    45→    caribbean: SPLICE_COLORS.CARIBBEAN,
    46→    yellow: SPLICE_COLORS.YELLOW,
    47→    violet: SPLICE_COLORS.VIOLET,
    48→    rose: SPLICE_COLORS.ROSE,
    49→    blue: SPLICE_COLORS.BLUE,
    50→    green: SPLICE_COLORS.GREEN
    51→};
    52→
    53→// ============================================================================
    54→// PROJECT ITEM CACHE
    55→// ============================================================================
    56→const projectItemCache = {
    57→    byName: new Map(),
    58→    byPath: new Map(),
    59→    projectId: null
    60→};
    61→
    62→/**
    63→ * Build the project item cache for O(1) lookups
    64→ */
    65→async function buildProjectItemCache() {
    66→    try {
    67→        const items = await jsx.call('getAllProjectItems');
    68→
    69→        projectItemCache.byName.clear();
    70→        projectItemCache.byPath.clear();
    71→
    72→        if (Array.isArray(items)) {
    73→            items.forEach(item => {
    74→                if (item.name) {
    75→                    projectItemCache.byName.set(item.name, item);
    76→                }
    77→                if (item.mediaPath) {
    78→                    projectItemCache.byPath.set(item.mediaPath, item);
    79→                }
    80→                if (item.treePath) {
    81→                    projectItemCache.byPath.set(item.treePath, item);
    82→                }
    83→            });
    84→        }
    85→
    86→        console.log(`[Builder] Cached ${projectItemCache.byName.size} project items`);
    87→        return true;
    88→    } catch (e) {
    89→        console.warn('[Builder] Failed to build cache:', e);
    90→        return false;
    91→    }
    92→}
    93→
    94→/**
    95→ * Clear the project item cache
    96→ */
    97→function clearProjectItemCache() {
    98→    projectItemCache.byName.clear();
    99→    projectItemCache.byPath.clear();
   100→    projectItemCache.projectId = null;
   101→}
   102→
   103→/**
   104→ * Find a project item by name (uses cache)
   105→ */
   106→function findProjectItemByName(name) {
   107→    return projectItemCache.byName.get(name) || null;
   108→}
   109→
   110→/**
   111→ * Find a project item by path (uses cache)
   112→ */
   113→function findProjectItemByPath(path) {
   114→    return projectItemCache.byPath.get(path) || null;
   115→}
   116→
   117→// ============================================================================
   118→// SEQUENCE BUILDING
   119→// ============================================================================
   120→
   121→/**
   122→ * Build a new sequence from a cut list
   123→ * @param {Object} cutList - The cut list from the backend
   124→ * @param {Object} options - Build options
   125→ * @returns {Promise<Object>} Build result
   126→ */
   127→async function buildSequenceFromCutList(cutList, options = {}) {
   128→    console.log('[Builder] Starting sequence build...');
   129→
   130→    try {
   131→        // Validate cut list
   132→        if (!cutList || !cutList.segments || cutList.segments.length === 0) {
   133→            throw new Error('Invalid cut list: no segments');
   134→        }
   135→
   136→        // Build cache if needed
   137→        await buildProjectItemCache();
   138→
   139→        // Call JSX to build the sequence
   140→        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));
   141→
   142→        if (result.error) {
   143→            throw new Error(result.error);
   144→        }
   145→
   146→        console.log('[Builder] Sequence built successfully:', result.sequenceName);
   147→        return {
   148→            success: true,
   149→            sequenceName: result.sequenceName,
   150→            stats: result.stats
   151→        };
   152→    } catch (e) {
   153→        console.error('[Builder] Build failed:', e);
   154→        return {
   155→            success: false,
   156→            error: e.message
   157→        };
   158→    }
   159→}
   160→
   161→/**
   162→ * Process a cut list and add color labels
   163→ * @param {Object} cutList - The cut list from the backend
   164→ * @returns {Object} Processed cut list with color indices
   165→ */
   166→function processCutList(cutList) {
   167→    if (!cutList || !cutList.segments) return cutList;
   168→
   169→    cutList.segments = cutList.segments.map(segment => {
   170→        // Determine color index
   171→        let colorIndex = null;
   172→
   173→        if (segment.colorHint && COLOR_HINT_MAP[segment.colorHint] !== undefined) {
   174→            colorIndex = COLOR_HINT_MAP[segment.colorHint];
   175→        } else if (segment.type && SEGMENT_COLORS[segment.type] !== undefined) {
   176→            colorIndex = SEGMENT_COLORS[segment.type];
   177→        }
   178→
   179→        return {
   180→            ...segment,
   181→            colorIndex
   182→        };
   183→    });
   184→
   185→    return cutList;
   186→}
   187→
   188→// ============================================================================
   189→// MARKER OPERATIONS
   190→// ============================================================================
   191→
   192→/**
   193→ * Add markers to the timeline from silence data
   194→ * @param {Array} silences - Array of silence objects
   195→ * @param {Object} options - Marker options
   196→ */
   197→async function addSilenceMarkers(silences, options = {}) {
   198→    const { colorIndex = SPLICE_COLORS.VIOLET, prefix = 'SPLICE: Silence' } = options;
   199→    let added = 0;
   200→
   201→    for (const silence of silences) {
   202→        try {
   203→            const duration = silence.end - silence.start;
   204→            await jsx.call('createMarker', silence.start, prefix, duration, null, colorIndex);
   205→            added++;
   206→        } catch (e) {
   207→            console.warn('[Builder] Failed to add silence marker:', e);
   208→        }
   209→    }
   210→
   211→    return { added };
   212→}
   213→
   214→/**
   215→ * Add markers to the timeline from take data
   216→ * @param {Array} takes - Array of take objects
   217→ * @param {Object} options - Marker options
   218→ */
   219→async function addTakeMarkers(takes, options = {}) {
   220→    const { colorIndex = SPLICE_COLORS.CERULEAN } = options;
   221→    let added = 0;
   222→
   223→    for (const take of takes) {
   224→        try {
   225→            const name = take.label || `Take ${take.takeNumber || added + 1}`;
   226→            const duration = take.end - take.start;
   227→            await jsx.call('createMarker', take.start, name, duration, null, colorIndex);
   228→            added++;
   229→        } catch (e) {
   230→            console.warn('[Builder] Failed to add take marker:', e);
   231→        }
   232→    }
   233→
   234→    return { added };
   235→}
   236→
   237→/**
   238→ * Add chapter markers to the timeline
   239→ * @param {Array} chapters - Array of chapter objects
   240→ */
   241→async function addChapterMarkers(chapters) {
   242→    let added = 0;
   243→
   244→    for (const chapter of chapters) {
   245→        try {
   246→            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);
   247→            added++;
   248→        } catch (e) {
   249→            console.warn('[Builder] Failed to add chapter marker:', e);
   250→        }
   251→    }
   252→
   253→    return { added };
   254→}
   255→
   256→/**
   257→ * Add zoom markers to the timeline
   258→ * @param {Array} zoomPoints - Array of zoom point objects
   259→ */
   260→async function addZoomMarkers(zoomPoints) {
   261→    let added = 0;
   262→
   263→    for (const zoom of zoomPoints) {
   264→        try {
   265→            await jsx.call('addZoomMarker', zoom.startTime, zoom.scale, zoom.duration, zoom.easing);
   266→            added++;
   267→        } catch (e) {
   268→            console.warn('[Builder] Failed to add zoom marker:', e);
   269→        }
   270→    }
   271→
   272→    return { added };
   273→}
   274→
   275→/**
   276→ * Clear all SPLICE markers from the timeline
   277→ */
   278→async function clearSpliceMarkers() {
   279→    try {
   280→        const result = await jsx.call('deleteMarkersByName', 'SPLICE');
   281→        return { deleted: result.deleted || 0 };
   282→    } catch (e) {
   283→        console.warn('[Builder] Failed to clear markers:', e);
   284→        return { deleted: 0 };
   285→    }
   286→}
   287→
   288→// ============================================================================
   289→// RAZOR OPERATIONS
   290→// ============================================================================
   291→
   292→/**
   293→ * Apply razor cuts at silence boundaries
   294→ * FIX: CEP-ERR-009 - Added comprehensive error handling with timeout protection
   295→ * @param {Array} silences - Array of silence objects
   296→ * @param {Object} options - Razor options
   297→ */
   298→async function razorAtSilences(silences, options = {}) {
   299→    const { trackType = 'all', trackIndex = -1 } = options;
   300→
   301→    if (!silences || silences.length === 0) {
   302→        return { cuts: 0 };
   303→    }
   304→
   305→    // Get frame rate with error handling
   306→    let frameRate;
   307→    try {
   308→        frameRate = await jsx.callWithTimeout('getVideoFrameRateInSeconds', [], JSX_TIMEOUTS.QUICK);
   309→        if (!frameRate || frameRate <= 0) {
   310→            throw new Error('Invalid frame rate returned');
   311→        }
   312→    } catch (e) {
   313→        console.error('[Builder] Failed to get frame rate:', e);
   314→        if (typeof logError === 'function') {
   315→            logError('Builder', 'getVideoFrameRateInSeconds', e, { silenceCount: silences.length });
   316→        }
   317→        return { cuts: 0, error: 'Could not determine frame rate: ' + e.message };
   318→    }
   319→
   320→    // Convert silences to frame-aligned cut points
   321→    const cutPoints = [];
   322→    for (const silence of silences) {
   323→        // Align to frame boundaries
   324→        const startFrame = Math.round(silence.start / frameRate);
   325→        const endFrame = Math.round(silence.end / frameRate);
   326→
   327→        cutPoints.push([startFrame, endFrame]);
   328→    }
   329→
   330→    // Batch the cuts with appropriate timeout for large operations
   331→    if (cutPoints.length > 0) {
   332→        try {
   333→            // Use LONG timeout for large batch operations, DEFAULT for smaller ones
   334→            const timeout = cutPoints.length > 50 ? JSX_TIMEOUTS.LONG : JSX_TIMEOUTS.DEFAULT;
   335→            await jsx.callWithTimeout('razorSequenceAtFramesArray', [JSON.stringify(cutPoints)], timeout);
   336→            return { cuts: cutPoints.length * 2 };
   337→        } catch (e) {
   338→            console.error('[Builder] Razor failed:', e);
   339→            if (typeof logError === 'function') {
   340→                logError('Builder', 'razorSequenceAtFramesArray', e, {
   341→                    cutPointCount: cutPoints.length,
   342→                    isTimeout: e.code === 'JSX_TIMEOUT'
   343→                });
   344→            }
   345→            return { cuts: 0, error: e.message };
   346→        }
   347→    }
   348→
   349→    return { cuts: 0 };
   350→}
   351→
   352→/**
   353→ * Delete clips at silence points
   354→ * FIX: CEP-ERR-010 - Added timeout protection and error logging
   355→ * @param {Array} silences - Array of silence objects
   356→ * @param {Object} options - Delete options
   357→ */
   358→async function deleteClipsAtSilences(silences, options = {}) {
   359→    const { trackType = 'video', trackIndex = 0 } = options;
   360→
   361→    if (!silences || silences.length === 0) {
   362→        return { deleted: 0 };
   363→    }
   364→
   365→    try {
   366→        // Use LONG timeout for potentially slow operations on large timelines
   367→        const timeout = silences.length > 50 ? JSX_TIMEOUTS.LONG : JSX_TIMEOUTS.DEFAULT;
   368→        const result = await jsx.callWithTimeout(
   369→            'deleteClipsAtSilencePointsInTrack',
   370→            [
   371→                JSON.stringify(silences.map(s => [s.start, s.end])),
   372→                trackType,
   373→                trackIndex
   374→            ],
   375→            timeout
   376→        );
   377→
   378→        return { deleted: result?.deleted || 0 };
   379→    } catch (e) {
   380→        console.error('[Builder] Delete failed:', e);
   381→        if (typeof logError === 'function') {
   382→            logError('Builder', 'deleteClipsAtSilencePointsInTrack', e, {
   383→                silenceCount: silences.length,
   384→                trackType,
   385→                trackIndex,
   386→                isTimeout: e.code === 'JSX_TIMEOUT'
   387→            });
   388→        }
   389→        return { deleted: 0, error: e.message };
   390→    }
   391→}
   392→
   393→// ============================================================================
   394→// UTILITY FUNCTIONS
   395→// ============================================================================
   396→
   397→/**
   398→ * Get color index for a segment type
   399→ */
   400→function getColorForSegment(type, colorHint) {
   401→    if (colorHint && COLOR_HINT_MAP[colorHint] !== undefined) {
   402→        return COLOR_HINT_MAP[colorHint];
   403→    }
   404→    if (type && SEGMENT_COLORS[type] !== undefined) {
   405→        return SEGMENT_COLORS[type];
   406→    }
   407→    return null;
   408→}
   409→
   410→/**
   411→ * Get the active sequence info
   412→ */
   413→async function getActiveSequence() {
   414→    try {
   415→        return await jsx.call('getActiveSequence');
   416→    } catch (e) {
   417→        console.warn('[Builder] Failed to get active sequence:', e);
   418→        return null;
   419→    }
   420→}
   421→
   422→/**
   423→ * Check if a sequence is open
   424→ */
   425→async function checkSequenceOpen() {
   426→    try {
   427→        const result = await jsx.call('checkSequenceOpen');
   428→        return result === true || result === 'true';
   429→    } catch {
   430→        return false;
   431→    }
   432→}
   433→
   434→/**
   435→ * Clone the current sequence
   436→ * @param {string} newName - Name for the cloned sequence
   437→ */
   438→async function cloneSequence(newName) {
   439→    try {
   440→        return await jsx.call('cloneSequence', newName);
   441→    } catch (e) {
   442→        console.error('[Builder] Clone failed:', e);
   443→        return { error: e.message };
   444→    }
   445→}
   446→
   447→/**
   448→ * Undo the last operation
   449→ */
   450→async function undo() {
   451→    try {
   452→        await jsx.call('undo');
   453→        return { success: true };
   454→    } catch (e) {
   455→        console.warn('[Builder] Undo failed:', e);
   456→        return { success: false, error: e.message };
   457→    }
   458→}
   459→
   460→// ============================================================================
   461→// EXPORTS
   462→// ============================================================================
   463→
   464→window.spliceBuilder = {
   465→    // Constants
   466→    SPLICE_COLORS,
   467→    SEGMENT_COLORS,
   468→    COLOR_HINT_MAP,
   469→
   470→    // Cache
   471→    buildProjectItemCache,
   472→    clearProjectItemCache,
   473→    findProjectItemByName,
   474→    findProjectItemByPath,
   475→
   476→    // Sequence building
   477→    buildSequenceFromCutList,
   478→    processCutList,
   479→
   480→    // Markers
   481→    addSilenceMarkers,
   482→    addTakeMarkers,
   483→    addChapterMarkers,
   484→    addZoomMarkers,
   485→    clearSpliceMarkers,
   486→
   487→    // Razor
   488→    razorAtSilences,
   489→    deleteClipsAtSilences,
   490→
   491→    // Utilities
   492→    getColorForSegment,
   493→    getActiveSequence,
   494→    checkSequenceOpen,
   495→    cloneSequence,
   496→    undo
   497→};
   498→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
