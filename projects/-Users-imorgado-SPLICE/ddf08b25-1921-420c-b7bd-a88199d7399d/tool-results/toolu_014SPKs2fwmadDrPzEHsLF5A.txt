     1→/**
     2→ * SPLICE CEP Music Module
     3→ * AI-powered music generation for video projects
     4→ */
     5→
     6→// ============================================
     7→// STATE
     8→// ============================================
     9→const musicState = {
    10→  jobs: [],
    11→  selectedJob: null,
    12→  isIdentifying: false,
    13→  isGenerating: false,
    14→  identifiedSong: null,
    15→  audioPlayer: null,
    16→  pollInterval: null,
    17→  currentPollingJobId: null,  // Track which job we're polling to prevent race conditions
    18→  variationsJob: null,
    19→  variationsPollingInterval: null,
    20→  variationsAbortController: null,  // FIX: CEP-CRIT-003 - AbortController for variations polling
    21→  currentVariationsJobId: null,  // Track which variations job we're polling
    22→  selectedVariationIndex: null,
    23→  variationPlayers: [null, null, null],
    24→  sceneAwareEnabled: false,
    25→  isAligning: false,
    26→  alignmentOptions: null,
    27→  beatAnalysis: null,
    28→  isGeneratingTimeline: false,
    29→  timelineOptions: null,
    30→  // FIX: CEP-CRIT-006 - AbortControllers for network request cancellation
    31→  identifyAbortController: null,
    32→  generateAbortController: null,
    33→  // FIX: CEP-CRIT-007 - Prevent duplicate event listener registration
    34→  listenersInitialized: false
    35→};
    36→
    37→// ============================================
    38→// CONSTANTS
    39→// ============================================
    40→const MUSIC_POLL_INTERVAL = 5000;
    41→
    42→const MOOD_OPTIONS = [
    43→  { id: 'energetic', name: 'Energetic', description: 'Upbeat, high energy' },
    44→  { id: 'relaxed', name: 'Relaxed', description: 'Calm, peaceful' },
    45→  { id: 'melancholic', name: 'Melancholic', description: 'Sad, emotional' },
    46→  { id: 'intense', name: 'Intense', description: 'Powerful, dramatic' },
    47→  { id: 'happy', name: 'Happy', description: 'Joyful, cheerful' },
    48→  { id: 'mysterious', name: 'Mysterious', description: 'Dark, suspenseful' },
    49→  { id: 'romantic', name: 'Romantic', description: 'Warm, intimate' },
    50→  { id: 'epic', name: 'Epic', description: 'Grand, orchestral' },
    51→  { id: 'chill', name: 'Chill', description: 'Lo-fi, laid-back' },
    52→  { id: 'neutral', name: 'Neutral', description: 'Balanced, versatile' }
    53→];
    54→
    55→const INSTRUMENT_OPTIONS = [
    56→  { id: 'acoustic', name: 'Acoustic', description: 'Guitar, piano, strings' },
    57→  { id: 'electronic', name: 'Electronic', description: 'Synths, beats' },
    58→  { id: 'rock', name: 'Rock', description: 'Electric guitars, drums' },
    59→  { id: 'orchestral', name: 'Orchestral', description: 'Strings, brass, woodwinds' },
    60→  { id: 'minimal', name: 'Minimal', description: 'Piano, ambient' },
    61→  { id: 'hiphop', name: 'Hip-Hop', description: '808s, trap drums' }
    62→];
    63→
    64→const DURATION_OPTIONS = [
    65→  { value: 30, label: '30 seconds' },
    66→  { value: 60, label: '1 minute' },
    67→  { value: 90, label: '1.5 minutes' },
    68→  { value: 120, label: '2 minutes' },
    69→  { value: 180, label: '3 minutes' }
    70→];
    71→
    72→// ============================================
    73→// DOM ELEMENT CACHE
    74→// ============================================
    75→const musicElements = {
    76→  section: null,
    77→  panel: null,
    78→  status: null,
    79→  creditsBadge: null,
    80→  youtubeUrl: null,
    81→  identifyBtn: null,
    82→  referenceDisplay: null,
    83→  moodSelector: null,
    84→  instrumentSelector: null,
    85→  durationSlider: null,
    86→  durationValue: null,
    87→  promptInput: null,
    88→  generateBtn: null,
    89→  variationsCheckbox: null,
    90→  sceneAwareToggle: null,
    91→  timelineBtn: null,
    92→  jobsList: null,
    93→  library: null,
    94→  variationsPanel: null,
    95→  variationsList: null,
    96→  progressContainer: null,
    97→  progressBar: null,
    98→  progressText: null,
    99→  tabGenerate: null,
   100→  tabIdentify: null,
   101→  tabLibrary: null
   102→};
   103→
   104→// ============================================
   105→// AUDIO PLAYER DISPOSAL
   106→// ============================================
   107→
   108→/**
   109→ * FIX: CEP-CRIT-004 - Music Audio Disposal
   110→ * Properly dispose of Audio objects to prevent memory leaks
   111→ * Audio objects hold memory for decoded audio data and event listeners
   112→ * After 100 previews @ ~20MB each = 2GB memory leak
   113→ */
   114→function disposeAudioPlayers() {
   115→  musicState.variationPlayers.forEach((player, index) => {
   116→    if (player) {
   117→      // Pause playback
   118→      player.pause();
   119→
   120→      // Remove all event listeners by cloning and replacing
   121→      // (Audio objects don't expose removeAllListeners)
   122→      const clone = player.cloneNode();
   123→      player.parentNode?.replaceChild(clone, player);
   124→
   125→      // Clear source to release decoded audio buffer
   126→      player.src = '';
   127→      player.srcObject = null;
   128→
   129→      // Force garbage collection of audio data
   130→      player.load();
   131→
   132→      // Null the reference
   133→      musicState.variationPlayers[index] = null;
   134→    }
   135→  });
   136→}
   137→
   138→function cacheMusicElements() {
   139→  musicElements.section = document.getElementById('musicSection');
   140→  musicElements.panel = document.getElementById('music-panel');
   141→  musicElements.status = document.getElementById('music-status');
   142→  musicElements.creditsBadge = document.getElementById('music-credits-badge');
   143→  musicElements.youtubeUrl = document.getElementById('music-youtube-url');
   144→  musicElements.identifyBtn = document.getElementById('music-identify-btn');
   145→  musicElements.referenceDisplay = document.getElementById('music-identify-result');
   146→  musicElements.moodSelector = document.getElementById('music-mood-selector');
   147→  musicElements.instrumentSelector = document.getElementById('music-instrument-selector');
   148→  musicElements.durationSlider = document.getElementById('music-duration-slider');
   149→  musicElements.durationValue = document.getElementById('music-duration-value');
   150→  musicElements.promptInput = document.getElementById('music-custom-prompt');
   151→  musicElements.generateBtn = document.getElementById('music-generate-btn');
   152→  musicElements.variationsCheckbox = document.getElementById('music-variations');
   153→  musicElements.sceneAwareToggle = document.getElementById('music-scene-aware');
   154→  musicElements.timelineBtn = document.getElementById('music-timeline-btn');
   155→  musicElements.jobsList = document.getElementById('music-jobs-list');
   156→  musicElements.library = document.getElementById('music-library-list');
   157→  musicElements.variationsPanel = document.getElementById('music-variations-panel');
   158→  musicElements.variationsList = document.getElementById('music-variations-list');
   159→  musicElements.progressContainer = document.getElementById('music-progress');
   160→  musicElements.progressBar = document.getElementById('music-progress-bar');
   161→  musicElements.progressText = document.getElementById('music-progress-text');
   162→
   163→  // Tab elements
   164→  musicElements.tabGenerate = document.getElementById('music-tab-generate');
   165→  musicElements.tabIdentify = document.getElementById('music-tab-identify');
   166→  musicElements.tabLibrary = document.getElementById('music-tab-library');
   167→}
   168→
   169→// ============================================
   170→// API FUNCTIONS
   171→// ============================================
   172→
   173→async function identifySong(youtubeUrl) {
   174→  // FIX: CEP-CRIT-006 - Abort previous identify request if still pending
   175→  if (musicState.identifyAbortController) {
   176→    musicState.identifyAbortController.abort();
   177→  }
   178→
   179→  // Create new AbortController for this request
   180→  musicState.identifyAbortController = new AbortController();
   181→  const signal = musicState.identifyAbortController.signal;
   182→
   183→  const backendUrl = getBackendUrl();
   184→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   185→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   186→
   187→  try {
   188→    const response = await fetchFn(`${backendUrl}/music/identify`, {
   189→      method: 'POST',
   190→      headers: { ...headers, 'Content-Type': 'application/json' },
   191→      body: JSON.stringify({ youtubeUrl }),
   192→      signal  // Pass AbortController signal
   193→    }, 90000);
   194→
   195→    if (!response.ok) {
   196→      const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   197→      throw new Error(error.message || 'Failed to identify song');
   198→    }
   199→
   200→    musicState.identifyAbortController = null;  // Clear controller on success
   201→    return response.json();
   202→  } catch (error) {
   203→    musicState.identifyAbortController = null;  // Clear controller on error
   204→    if (error.name === 'AbortError') {
   205→      throw new Error('Song identification was cancelled');
   206→    }
   207→    throw error;
   208→  }
   209→}
   210→
   211→async function generateMusicRequest(options) {
   212→  // FIX: CEP-CRIT-006 - Abort previous generate request if still pending
   213→  if (musicState.generateAbortController) {
   214→    musicState.generateAbortController.abort();
   215→  }
   216→
   217→  // Create new AbortController for this request
   218→  musicState.generateAbortController = new AbortController();
   219→  const signal = musicState.generateAbortController.signal;
   220→
   221→  const backendUrl = getBackendUrl();
   222→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   223→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   224→
   225→  try {
   226→    const response = await fetchFn(`${backendUrl}/music/generate`, {
   227→      method: 'POST',
   228→      headers: { ...headers, 'Content-Type': 'application/json' },
   229→      body: JSON.stringify(options),
   230→      signal  // Pass AbortController signal
   231→    });
   232→
   233→    if (!response.ok) {
   234→      const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   235→      throw new Error(error.message || 'Failed to start music generation');
   236→    }
   237→
   238→    musicState.generateAbortController = null;  // Clear controller on success
   239→    return response.json();
   240→  } catch (error) {
   241→    musicState.generateAbortController = null;  // Clear controller on error
   242→    if (error.name === 'AbortError') {
   243→      throw new Error('Music generation was cancelled');
   244→    }
   245→    throw error;
   246→  }
   247→}
   248→
   249→async function getJobStatus(jobId) {
   250→  const backendUrl = getBackendUrl();
   251→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   252→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   253→
   254→  const response = await fetchFn(`${backendUrl}/music/status/${jobId}`, { headers });
   255→
   256→  if (!response.ok) {
   257→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   258→    throw new Error(error.message || 'Failed to get job status');
   259→  }
   260→  return response.json();
   261→}
   262→
   263→async function getMusicLibrary() {
   264→  const backendUrl = getBackendUrl();
   265→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   266→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   267→
   268→  const response = await fetchFn(`${backendUrl}/music/library`, { headers });
   269→
   270→  if (!response.ok) {
   271→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   272→    throw new Error(error.message || 'Failed to load music library');
   273→  }
   274→  return response.json();
   275→}
   276→
   277→async function getMusicFile(jobId) {
   278→  const backendUrl = getBackendUrl();
   279→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   280→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   281→
   282→  const response = await fetchFn(`${backendUrl}/music/${jobId}`, { headers });
   283→
   284→  if (!response.ok) {
   285→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   286→    throw new Error(error.message || 'Failed to get music file');
   287→  }
   288→  return response.json();
   289→}
   290→
   291→async function deleteMusicFile(jobId) {
   292→  const backendUrl = getBackendUrl();
   293→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   294→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   295→
   296→  const response = await fetchFn(`${backendUrl}/music/${jobId}`, { method: 'DELETE', headers });
   297→
   298→  if (!response.ok) {
   299→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   300→    throw new Error(error.message || 'Failed to delete music');
   301→  }
   302→  return response.json();
   303→}
   304→
   305→async function getMusicCredits() {
   306→  const backendUrl = getBackendUrl();
   307→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   308→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   309→
   310→  const response = await fetchFn(`${backendUrl}/music/credits`, { headers });
   311→
   312→  if (!response.ok) {
   313→    return { remaining: 0, total: 0 };
   314→  }
   315→  return response.json();
   316→}
   317→
   318→// ============================================
   319→// VARIATIONS API FUNCTIONS
   320→// ============================================
   321→
   322→async function generateVariationsRequest(options) {
   323→  const backendUrl = getBackendUrl();
   324→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   325→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   326→
   327→  const response = await fetchFn(`${backendUrl}/music/generate-variations`, {
   328→    method: 'POST',
   329→    headers: { ...headers, 'Content-Type': 'application/json' },
   330→    body: JSON.stringify(options)
   331→  });
   332→
   333→  if (!response.ok) {
   334→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   335→    throw new Error(error.message || 'Failed to start variations generation');
   336→  }
   337→  return response.json();
   338→}
   339→
   340→async function getVariationsStatus(jobId, signal = null) {
   341→  const backendUrl = getBackendUrl();
   342→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   343→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   344→
   345→  // FIX: CEP-CRIT-003 - Pass AbortController signal to cancel in-flight requests
   346→  const fetchOptions = { headers };
   347→  if (signal) {
   348→    fetchOptions.signal = signal;
   349→  }
   350→
   351→  const response = await fetchFn(`${backendUrl}/music/variations/status/${jobId}`, fetchOptions);
   352→
   353→  if (!response.ok) {
   354→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   355→    throw new Error(error.message || 'Failed to get variations status');
   356→  }
   357→  return response.json();
   358→}
   359→
   360→async function selectVariation(jobId, variationIndex) {
   361→  const backendUrl = getBackendUrl();
   362→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   363→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   364→
   365→  const response = await fetchFn(`${backendUrl}/music/variations/${jobId}/select`, {
   366→    method: 'POST',
   367→    headers: { ...headers, 'Content-Type': 'application/json' },
   368→    body: JSON.stringify({ variationIndex })
   369→  });
   370→
   371→  if (!response.ok) {
   372→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   373→    throw new Error(error.message || 'Failed to select variation');
   374→  }
   375→  return response.json();
   376→}
   377→
   378→// ============================================
   379→// SCENE-AWARE API FUNCTIONS
   380→// ============================================
   381→
   382→async function generateSceneAwareRequest(options, segments) {
   383→  const backendUrl = getBackendUrl();
   384→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   385→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   386→
   387→  const response = await fetchFn(`${backendUrl}/music/generate-scene-aware`, {
   388→    method: 'POST',
   389→    headers: { ...headers, 'Content-Type': 'application/json' },
   390→    body: JSON.stringify({ ...options, segments })
   391→  });
   392→
   393→  if (!response.ok) {
   394→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   395→    throw new Error(error.message || 'Failed to start scene-aware music generation');
   396→  }
   397→  return response.json();
   398→}
   399→
   400→function getCurrentTranscriptSegments() {
   401→  if (window.currentTranscript && window.currentTranscript.segments) {
   402→    return window.currentTranscript.segments;
   403→  }
   404→  return null;
   405→}
   406→
   407→// ============================================
   408→// ALIGNMENT API FUNCTIONS
   409→// ============================================
   410→
   411→async function alignMusicRequest(jobId, targetDuration, options = {}) {
   412→  const backendUrl = getBackendUrl();
   413→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   414→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   415→
   416→  const response = await fetchFn(`${backendUrl}/music/align`, {
   417→    method: 'POST',
   418→    headers: { ...headers, 'Content-Type': 'application/json' },
   419→    body: JSON.stringify({
   420→      jobId,
   421→      targetDuration,
   422→      fadeDuration: options.fadeDuration,
   423→      beatAlign: options.beatAlign !== false,
   424→      searchWindow: options.searchWindow
   425→    })
   426→  }, 120000);
   427→
   428→  if (!response.ok) {
   429→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   430→    throw new Error(error.message || 'Failed to align music');
   431→  }
   432→  return response.json();
   433→}
   434→
   435→async function analyzeBeatsRequest(jobId) {
   436→  const backendUrl = getBackendUrl();
   437→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   438→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   439→
   440→  const response = await fetchFn(`${backendUrl}/music/analyze-beats`, {
   441→    method: 'POST',
   442→    headers: { ...headers, 'Content-Type': 'application/json' },
   443→    body: JSON.stringify({ jobId })
   444→  }, 60000);
   445→
   446→  if (!response.ok) {
   447→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   448→    throw new Error(error.message || 'Failed to analyze beats');
   449→  }
   450→  return response.json();
   451→}
   452→
   453→async function getAlignmentOptions() {
   454→  const backendUrl = getBackendUrl();
   455→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   456→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   457→
   458→  const response = await fetchFn(`${backendUrl}/music/alignment-options`, { headers });
   459→
   460→  if (!response.ok) {
   461→    return {
   462→      fadeDuration: { default: 2, min: 0.5, max: 5 },
   463→      searchWindow: { default: 3, min: 0.5, max: 10 },
   464→      minAudioDuration: 5
   465→    };
   466→  }
   467→  return response.json();
   468→}
   469→
   470→// ============================================
   471→// TIMELINE API FUNCTIONS
   472→// ============================================
   473→
   474→async function generateTimelineRequest(transcript, options = {}) {
   475→  const backendUrl = getBackendUrl();
   476→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   477→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   478→
   479→  const response = await fetchFn(`${backendUrl}/music/generate-timeline`, {
   480→    method: 'POST',
   481→    headers: { ...headers, 'Content-Type': 'application/json' },
   482→    body: JSON.stringify({
   483→      transcript,
   484→      maxChapters: options.maxChapters || 10,
   485→      minChapterLength: options.minChapterLength || 60,
   486→      crossfadeDuration: options.crossfadeDuration || 2,
   487→      instruments: options.instruments || [],
   488→      prompt: options.prompt || ''
   489→    })
   490→  }, 600000);
   491→
   492→  if (!response.ok) {
   493→    const error = typeof parseErrorResponse === 'function' ? await parseErrorResponse(response) : await response.json();
   494→    throw new Error(error.message || 'Failed to generate timeline music');
   495→  }
   496→  return response.json();
   497→}
   498→
   499→async function getTimelineOptions() {
   500→  const backendUrl = getBackendUrl();
   501→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   502→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   503→
   504→  const response = await fetchFn(`${backendUrl}/music/timeline-options`, { headers });
   505→
   506→  if (!response.ok) {
   507→    return {
   508→      defaults: { maxChapters: 10, minChapterLength: 60, crossfadeDuration: 2 },
   509→      constraints: { minCrossfadeDuration: 0.5, maxCrossfadeDuration: 5 }
   510→    };
   511→  }
   512→  return response.json();
   513→}
   514→
   515→async function estimateTimelineRequest(transcript, options = {}) {
   516→  const backendUrl = getBackendUrl();
   517→  const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   518→  const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   519→
   520→  const response = await fetchFn(`${backendUrl}/music/timeline-estimate`, {
   521→    method: 'POST',
   522→    headers: { ...headers, 'Content-Type': 'application/json' },
   523→    body: JSON.stringify({
   524→      transcript,
   525→      maxChapters: options.maxChapters,
   526→      minChapterLength: options.minChapterLength
   527→    })
   528→  });
   529→
   530→  if (!response.ok) {
   531→    return { estimatedChapters: 3, estimatedMinutes: 12, estimatedTimeDisplay: '10-15 minutes' };
   532→  }
   533→  return response.json();
   534→}
   535→
   536→function getCurrentTranscript() {
   537→  if (window.currentTranscript) {
   538→    return window.currentTranscript;
   539→  }
   540→  return null;
   541→}
   542→
   543→async function getSequenceDuration() {
   544→  try {
   545→    const result = await jsx.call('getSequenceDuration');
   546→    if (result && result.duration) {
   547→      return result.duration;
   548→    }
   549→  } catch (error) {
   550→    console.error('Could not get sequence duration:', error);
   551→  }
   552→  return null;
   553→}
   554→
   555→// ============================================
   556→// INITIALIZATION
   557→// ============================================
   558→
   559→function initMusicModule() {
   560→  console.log('[SPLICE] Initializing music module');
   561→
   562→  cacheMusicElements();
   563→  setupMusicEventListeners();
   564→  setupTabSwitching();
   565→  populateMoodSelector();
   566→  populateInstrumentSelector();
   567→  setupDurationSlider();
   568→  loadMusicLibrary();
   569→  updateMusicCreditsDisplay();
   570→
   571→  console.log('[SPLICE] Music module initialized');
   572→}
   573→
   574→function setupTabSwitching() {
   575→  const tabs = document.querySelectorAll('.music-tab');
   576→  const contents = {
   577→    generate: musicElements.tabGenerate || document.getElementById('music-tab-generate'),
   578→    identify: musicElements.tabIdentify || document.getElementById('music-tab-identify'),
   579→    library: musicElements.tabLibrary || document.getElementById('music-tab-library')
   580→  };
   581→
   582→  tabs.forEach(tab => {
   583→    tab.addEventListener('click', () => {
   584→      const tabName = tab.dataset.tab;
   585→
   586→      // Update tab buttons
   587→      tabs.forEach(t => t.classList.remove('active'));
   588→      tab.classList.add('active');
   589→
   590→      // Update tab content
   591→      Object.entries(contents).forEach(([name, content]) => {
   592→        if (content) {
   593→          content.classList.toggle('active', name === tabName);
   594→        }
   595→      });
   596→
   597→      // Refresh library when switching to library tab
   598→      if (tabName === 'library') {
   599→        loadMusicLibrary();
   600→      }
   601→    });
   602→  });
   603→}
   604→
   605→function setupMusicEventListeners() {
   606→  // FIX: CEP-CRIT-007 - Music Event Duplication
   607→  // Guard flag prevents duplicate listeners (60 requests after 20 tab switches)
   608→  if (musicState.listenersInitialized) {
   609→    console.log('[SPLICE Music] Event listeners already initialized, skipping');
   610→    return;
   611→  }
   612→
   613→  console.log('[SPLICE Music] Initializing event listeners (one-time)');
   614→  musicState.listenersInitialized = true;
   615→
   616→  document.addEventListener('input', (e) => {
   617→    if (e.target.id === 'music-youtube-url') {
   618→      handleYoutubeUrlChange();
   619→    }
   620→  });
   621→
   622→  document.addEventListener('click', (e) => {
   623→    const id = e.target.id;
   624→
   625→    switch (id) {
   626→      case 'music-identify-btn':
   627→        handleIdentifySong();
   628→        break;
   629→      case 'music-generate-btn':
   630→        handleGenerateMusic();
   631→        break;
   632→      case 'musicClearRefBtn':
   633→        handleClearReference();
   634→        break;
   635→      case 'music-timeline-btn':
   636→        showTimelineModal();
   637→        break;
   638→    }
   639→
   640→    // Library action buttons
   641→    if (e.target.classList.contains('music-action-btn')) {
   642→      handleLibraryAction(e);
   643→    }
   644→  });
   645→
   646→  document.addEventListener('change', (e) => {
   647→    if (e.target.id === 'music-scene-aware') {
   648→      handleSceneAwareToggle();
   649→    }
   650→    if (e.target.id === 'music-variations') {
   651→      // Handle variations checkbox - will be checked in handleGenerateMusic
   652→    }
   653→  });
   654→
   655→  updateSceneAwareAvailability();
   656→  updateTimelineAvailability();
   657→}
   658→
   659→function handleSceneAwareToggle() {
   660→  const toggle = musicElements.sceneAwareToggle || document.getElementById('music-scene-aware');
   661→  musicState.sceneAwareEnabled = toggle?.checked || false;
   662→
   663→  const indicator = document.getElementById('sceneAwareIndicator');
   664→  if (indicator) {
   665→    indicator.style.display = musicState.sceneAwareEnabled ? 'block' : 'none';
   666→  }
   667→
   668→  if (musicState.sceneAwareEnabled) {
   669→    const segments = getCurrentTranscriptSegments();
   670→    if (segments) {
   671→      setMusicStatus(`Scene-aware enabled: ${segments.length} segments detected`, 'info');
   672→    } else {
   673→      setMusicStatus('Scene-aware enabled: Run transcription first for best results', 'warning');
   674→    }
   675→  }
   676→}
   677→
   678→function updateSceneAwareAvailability() {
   679→  const toggle = musicElements.sceneAwareToggle || document.getElementById('music-scene-aware');
   680→  const segments = getCurrentTranscriptSegments();
   681→
   682→  if (toggle) {
   683→    toggle.disabled = !segments;
   684→    toggle.parentElement?.classList.toggle('disabled', !segments);
   685→  }
   686→}
   687→
   688→// ============================================
   689→// UI POPULATION (Card-Based)
   690→// ============================================
   691→
   692→function populateMoodSelector() {
   693→  const container = musicElements.moodSelector || document.getElementById('music-mood-selector');
   694→  if (!container) return;
   695→
   696→  container.innerHTML = MOOD_OPTIONS.map(mood =>
   697→    `<div class="music-mood-card ${mood.id === 'neutral' ? 'selected' : ''}" data-mood="${mood.id}" title="${mood.description}">
   698→      <span class="mood-name">${mood.name}</span>
   699→    </div>`
   700→  ).join('');
   701→
   702→  // Add click handlers
   703→  container.querySelectorAll('.music-mood-card').forEach(card => {
   704→    card.addEventListener('click', () => {
   705→      container.querySelectorAll('.music-mood-card').forEach(c => c.classList.remove('selected'));
   706→      card.classList.add('selected');
   707→    });
   708→  });
   709→}
   710→
   711→function populateInstrumentSelector() {
   712→  const container = musicElements.instrumentSelector || document.getElementById('music-instrument-selector');
   713→  if (!container) return;
   714→
   715→  container.innerHTML = INSTRUMENT_OPTIONS.map(inst =>
   716→    `<div class="music-instrument-card ${inst.id === 'acoustic' ? 'selected' : ''}" data-instrument="${inst.id}" title="${inst.description}">
   717→      <span class="instrument-name">${inst.name}</span>
   718→    </div>`
   719→  ).join('');
   720→
   721→  // Add click handlers
   722→  container.querySelectorAll('.music-instrument-card').forEach(card => {
   723→    card.addEventListener('click', () => {
   724→      container.querySelectorAll('.music-instrument-card').forEach(c => c.classList.remove('selected'));
   725→      card.classList.add('selected');
   726→    });
   727→  });
   728→}
   729→
   730→function setupDurationSlider() {
   731→  const slider = musicElements.durationSlider || document.getElementById('music-duration-slider');
   732→  const valueDisplay = musicElements.durationValue || document.getElementById('music-duration-value');
   733→  if (!slider) return;
   734→
   735→  slider.addEventListener('input', () => {
   736→    if (valueDisplay) valueDisplay.textContent = slider.value;
   737→  });
   738→}
   739→
   740→function getSelectedMood() {
   741→  const container = musicElements.moodSelector || document.getElementById('music-mood-selector');
   742→  const selected = container?.querySelector('.music-mood-card.selected');
   743→  return selected?.dataset.mood || 'neutral';
   744→}
   745→
   746→function getSelectedInstrument() {
   747→  const container = musicElements.instrumentSelector || document.getElementById('music-instrument-selector');
   748→  const selected = container?.querySelector('.music-instrument-card.selected');
   749→  return selected?.dataset.instrument || 'acoustic';
   750→}
   751→
   752→function getSelectedDuration() {
   753→  const slider = musicElements.durationSlider || document.getElementById('music-duration-slider');
   754→  return parseInt(slider?.value) || 60;
   755→}
   756→
   757→// ============================================
   758→// YOUTUBE URL HANDLING
   759→// ============================================
   760→
   761→function handleYoutubeUrlChange() {
   762→  const urlInput = musicElements.youtubeUrl || document.getElementById('music-youtube-url');
   763→  const identifyBtn = musicElements.identifyBtn || document.getElementById('music-identify-btn');
   764→
   765→  if (!urlInput || !identifyBtn) return;
   766→
   767→  const url = urlInput.value.trim();
   768→  const isValidUrl = isValidYouTubeUrl(url);
   769→  identifyBtn.disabled = !isValidUrl;
   770→
   771→  if (musicState.identifiedSong) {
   772→    handleClearReference();
   773→  }
   774→}
   775→
   776→function isValidYouTubeUrl(url) {
   777→  if (!url) return false;
   778→  const patterns = [
   779→    /youtube\.com\/watch\?v=[\w-]{11}/,
   780→    /youtu\.be\/[\w-]{11}/,
   781→    /youtube\.com\/embed\/[\w-]{11}/
   782→  ];
   783→  return patterns.some(p => p.test(url));
   784→}
   785→
   786→async function handleIdentifySong() {
   787→  const urlInput = musicElements.youtubeUrl || document.getElementById('music-youtube-url');
   788→  const identifyBtn = musicElements.identifyBtn || document.getElementById('music-identify-btn');
   789→
   790→  if (!urlInput || !identifyBtn) return;
   791→
   792→  const url = urlInput.value.trim();
   793→  if (!isValidYouTubeUrl(url)) {
   794→    setMusicStatus('Invalid YouTube URL', 'error');
   795→    return;
   796→  }
   797→
   798→  try {
   799→    musicState.isIdentifying = true;
   800→    identifyBtn.disabled = true;
   801→    identifyBtn.textContent = 'Identifying...';
   802→    setMusicStatus('Identifying song...', 'info');
   803→
   804→    const result = await identifySong(url);
   805→
   806→    if (result.identified) {
   807→      musicState.identifiedSong = result;
   808→      displayIdentifiedSong(result);
   809→      setMusicStatus(`Identified: ${result.title} by ${result.artist}`, 'success');
   810→    } else {
   811→      setMusicStatus('Could not identify song. You can still generate music.', 'warning');
   812→    }
   813→
   814→  } catch (error) {
   815→    console.error('Identification error:', error);
   816→    setMusicStatus(`Error: ${error.message}`, 'error');
   817→  } finally {
   818→    musicState.isIdentifying = false;
   819→    identifyBtn.disabled = false;
   820→    identifyBtn.textContent = 'Identify';
   821→  }
   822→}
   823→
   824→function displayIdentifiedSong(song) {
   825→  const display = musicElements.referenceDisplay || document.getElementById('music-identify-result');
   826→  if (!display) return;
   827→
   828→  const details = [];
   829→  if (song.bpm) details.push(`${song.bpm} BPM`);
   830→  if (song.key) details.push(song.key);
   831→  if (song.mood) details.push(song.mood);
   832→
   833→  display.innerHTML = `
   834→    <div class="music-reference-card">
   835→      <div class="music-ref-title">${escapeHtml(song.title)}</div>
   836→      <div class="music-ref-artist">${escapeHtml(song.artist)}</div>
   837→      <div class="music-ref-details">${details.join(' - ')}</div>
   838→      <button id="musicClearRefBtn" class="music-clear-ref-btn" title="Clear reference">x</button>
   839→    </div>
   840→  `;
   841→  display.style.display = 'block';
   842→}
   843→
   844→function handleClearReference() {
   845→  musicState.identifiedSong = null;
   846→
   847→  const display = musicElements.referenceDisplay || document.getElementById('music-identify-result');
   848→  if (display) {
   849→    display.innerHTML = '';
   850→    display.style.display = 'none';
   851→  }
   852→
   853→  const urlInput = musicElements.youtubeUrl || document.getElementById('music-youtube-url');
   854→  if (urlInput) urlInput.value = '';
   855→
   856→  const identifyBtn = musicElements.identifyBtn || document.getElementById('music-identify-btn');
   857→  if (identifyBtn) identifyBtn.disabled = true;
   858→}
   859→
   860→// ============================================
   861→// MUSIC GENERATION
   862→// ============================================
   863→
   864→async function handleGenerateMusic() {
   865→  const generateBtn = musicElements.generateBtn || document.getElementById('music-generate-btn');
   866→  const promptInput = musicElements.promptInput || document.getElementById('music-custom-prompt');
   867→  const variationsCheckbox = musicElements.variationsCheckbox || document.getElementById('music-variations');
   868→
   869→  if (!generateBtn) return;
   870→
   871→  // Check if variations mode is enabled
   872→  const generateVariations = variationsCheckbox?.checked || false;
   873→  if (generateVariations) {
   874→    return handleGenerateVariations();
   875→  }
   876→
   877→  try {
   878→    musicState.isGenerating = true;
   879→    generateBtn.disabled = true;
   880→    generateBtn.textContent = 'Starting...';
   881→
   882→    const options = {
   883→      mood: getSelectedMood(),
   884→      instruments: [getSelectedInstrument()],
   885→      duration: getSelectedDuration(),
   886→      prompt: promptInput?.value || '',
   887→      youtubeUrl: musicState.identifiedSong?.sourceUrl || null,
   888→      referenceSong: musicState.identifiedSong || null
   889→    };
   890→
   891→    let result;
   892→
   893→    if (musicState.sceneAwareEnabled) {
   894→      const segments = getCurrentTranscriptSegments();
   895→      if (segments && segments.length > 0) {
   896→        setMusicStatus('Analyzing transcript and generating scene-aware music...', 'info');
   897→        result = await generateSceneAwareRequest(options, segments);
   898→        setMusicStatus(`Scene-aware generation started! Job ID: ${result.jobId}`, 'success');
   899→      } else {
   900→        setMusicStatus('No transcript available, using regular generation...', 'warning');
   901→        result = await generateMusicRequest(options);
   902→        setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
   903→      }
   904→    } else {
   905→      setMusicStatus('Submitting generation request...', 'info');
   906→      result = await generateMusicRequest(options);
   907→      setMusicStatus(`Generation started! Job ID: ${result.jobId}`, 'success');
   908→    }
   909→
   910→    addJobToList(result.jobId, options, result.isSceneAware);
   911→    startPollingJob(result.jobId);
   912→    handleClearReference();
   913→    if (promptInput) promptInput.value = '';
   914→
   915→  } catch (error) {
   916→    console.error('Generation error:', error);
   917→    setMusicStatus(`Error: ${error.message}`, 'error');
   918→  } finally {
   919→    musicState.isGenerating = false;
   920→    generateBtn.disabled = false;
   921→    generateBtn.textContent = 'Generate Music';
   922→  }
   923→}
   924→
   925→// ============================================
   926→// VARIATIONS
   927→// ============================================
   928→
   929→async function handleGenerateVariations() {
   930→  const generateBtn = musicElements.generateBtn || document.getElementById('music-generate-btn');
   931→  const promptInput = musicElements.promptInput || document.getElementById('music-custom-prompt');
   932→
   933→  if (!generateBtn) return;
   934→
   935→  try {
   936→    musicState.isGenerating = true;
   937→    generateBtn.disabled = true;
   938→    generateBtn.textContent = 'Starting...';
   939→    setMusicStatus('Generating 3 variations... This may take 5-8 minutes.', 'info');
   940→
   941→    const options = {
   942→      mood: getSelectedMood(),
   943→      instruments: [getSelectedInstrument()],
   944→      duration: getSelectedDuration(),
   945→      prompt: promptInput?.value || '',
   946→      referenceSong: musicState.identifiedSong || null
   947→    };
   948→
   949→    const result = await generateVariationsRequest(options);
   950→    setMusicStatus(`Variations generation started! Job ID: ${result.jobId}`, 'success');
   951→
   952→    musicState.variationsJob = { jobId: result.jobId, status: 'pending', options };
   953→    startPollingVariations(result.jobId);
   954→    showVariationsPanel();
   955→    handleClearReference();
   956→    if (promptInput) promptInput.value = '';
   957→
   958→  } catch (error) {
   959→    console.error('Variations error:', error);
   960→    setMusicStatus(`Error: ${error.message}`, 'error');
   961→  } finally {
   962→    musicState.isGenerating = false;
   963→    generateBtn.disabled = false;
   964→    generateBtn.textContent = 'Generate 3 Variations';
   965→  }
   966→}
   967→
   968→function startPollingVariations(jobId) {
   969→  // FIX: CEP-CRIT-003 - Music Polling Memory Leak
   970→  // Clear any existing polling AND abort in-flight requests
   971→  if (musicState.variationsPollingInterval) {
   972→    clearInterval(musicState.variationsPollingInterval);
   973→  }
   974→  if (musicState.variationsAbortController) {
   975→    musicState.variationsAbortController.abort();
   976→  }
   977→
   978→  // Create new AbortController for this polling session
   979→  musicState.variationsAbortController = new AbortController();
   980→  const signal = musicState.variationsAbortController.signal;
   981→
   982→  // Track which variations job we're polling for (race condition fix)
   983→  musicState.currentVariationsJobId = jobId;
   984→
   985→  musicState.variationsPollingInterval = setInterval(async () => {
   986→    // Race condition check: verify we're still polling for this job
   987→    if (musicState.currentVariationsJobId !== jobId) {
   988→      return; // A new variations job started polling, ignore this callback
   989→    }
   990→
   991→    try {
   992→      // Pass abort signal to cancel in-flight requests
   993→      const status = await getVariationsStatus(jobId, signal);
   994→
   995→      // Double-check after async operation
   996→      if (musicState.currentVariationsJobId !== jobId) {
   997→        return;
   998→      }
   999→
  1000→      musicState.variationsJob = { ...musicState.variationsJob, ...status };
  1001→      renderVariationsProgress(status);
  1002→
  1003→      if (status.status === 'selecting' || status.status === 'completed') {
  1004→        clearInterval(musicState.variationsPollingInterval);
  1005→        musicState.variationsPollingInterval = null;
  1006→        musicState.currentVariationsJobId = null;
  1007→        if (musicState.variationsAbortController) {
  1008→          musicState.variationsAbortController.abort();
  1009→          musicState.variationsAbortController = null;
  1010→        }
  1011→
  1012→        if (status.variations && status.variations.length > 0) {
  1013→          setMusicStatus('Variations ready! Select your favorite.', 'success');
  1014→          renderVariationsSelection(status.variations);
  1015→        }
  1016→      } else if (status.status === 'failed') {
  1017→        clearInterval(musicState.variationsPollingInterval);
  1018→        musicState.variationsPollingInterval = null;
  1019→        musicState.currentVariationsJobId = null;
  1020→        if (musicState.variationsAbortController) {
  1021→          musicState.variationsAbortController.abort();
  1022→          musicState.variationsAbortController = null;
  1023→        }
  1024→        setMusicStatus(`Variations failed: ${status.failedReason || 'Unknown error'}`, 'error');
  1025→      }
  1026→    } catch (error) {
  1027→      // Don't log errors if request was aborted (expected behavior)
  1028→      if (error.name !== 'AbortError') {
  1029→        console.error('Variations polling error:', error);
  1030→      }
  1031→    }
  1032→  }, MUSIC_POLL_INTERVAL);
  1033→}
  1034→
  1035→function showVariationsPanel() {
  1036→  let panel = musicElements.variationsPanel || document.getElementById('variationsPanel');
  1037→  if (!panel) {
  1038→    panel = document.createElement('div');
  1039→    panel.id = 'variationsPanel';
  1040→    panel.className = 'variations-panel';
  1041→    const section = musicElements.section || document.getElementById('musicSection');
  1042→    if (section) section.appendChild(panel);
  1043→  }
  1044→
  1045→  panel.style.display = 'block';
  1046→  panel.innerHTML = `
  1047→    <div class="variations-header">
  1048→      <h4>Generating 3 Variations</h4>
  1049→      <button id="variationsCancelBtn" class="variations-cancel-btn" title="Cancel">x</button>
  1050→    </div>
  1051→    <div class="variations-progress">
  1052→      <div class="variation-progress-item" data-index="0">
  1053→        <span class="variation-name">Version A</span>
  1054→        <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
  1055→        <span class="progress-text">0%</span>
  1056→      </div>
  1057→      <div class="variation-progress-item" data-index="1">
  1058→        <span class="variation-name">Version B</span>
  1059→        <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
  1060→        <span class="progress-text">0%</span>
  1061→      </div>
  1062→      <div class="variation-progress-item" data-index="2">
  1063→        <span class="variation-name">Version C</span>
  1064→        <div class="progress-bar"><div class="progress-fill" style="width: 0%"></div></div>
  1065→        <span class="progress-text">0%</span>
  1066→      </div>
  1067→    </div>
  1068→    <div id="variationsSelection" class="variations-selection" style="display: none;"></div>
  1069→  `;
  1070→
  1071→  document.getElementById('variationsCancelBtn')?.addEventListener('click', hideVariationsPanel);
  1072→}
  1073→
  1074→function hideVariationsPanel() {
  1075→  const panel = musicElements.variationsPanel || document.getElementById('variationsPanel');
  1076→  if (panel) {
  1077→    panel.style.display = 'none';
  1078→    panel.innerHTML = '';
  1079→  }
  1080→
  1081→  if (musicState.variationsPollingInterval) {
  1082→    clearInterval(musicState.variationsPollingInterval);
  1083→    musicState.variationsPollingInterval = null;
  1084→  }
  1085→
  1086→  // FIX: CEP-CRIT-004 - Properly dispose audio players to prevent memory leak
  1087→  disposeAudioPlayers();
  1088→  musicState.variationPlayers = [null, null, null];
  1089→  musicState.variationsJob = null;
  1090→  musicState.selectedVariationIndex = null;
  1091→}
  1092→
  1093→function renderVariationsProgress(status) {
  1094→  const progressItems = document.querySelectorAll('.variation-progress-item');
  1095→  const variationProgress = status.variationProgress || [0, 0, 0];
  1096→
  1097→  progressItems.forEach((item, index) => {
  1098→    const progress = variationProgress[index] || 0;
  1099→    const fill = item.querySelector('.progress-fill');
  1100→    const text = item.querySelector('.progress-text');
  1101→
  1102→    if (fill) fill.style.width = `${progress}%`;
  1103→    if (text) text.textContent = `${progress}%`;
  1104→    if (progress >= 100) item.classList.add('completed');
  1105→  });
  1106→}
  1107→
  1108→function renderVariationsSelection(variations) {
  1109→  const container = document.getElementById('variationsSelection');
  1110→  if (!container) return;
  1111→
  1112→  // FIX: CEP-CRIT-004 - Dispose old audio players before rendering new variations
  1113→  disposeAudioPlayers();
  1114→  musicState.variationPlayers = [null, null, null];
  1115→
  1116→  const progressContainer = document.querySelector('.variations-progress');
  1117→  if (progressContainer) progressContainer.style.display = 'none';
  1118→
  1119→  container.style.display = 'block';
  1120→  container.innerHTML = `
  1121→    <div class="variations-header">
  1122→      <h4>Select Your Favorite</h4>
  1123→      <p class="variations-subtitle">Preview each variation and choose one to keep</p>
  1124→    </div>
  1125→    <div class="variations-cards">
  1126→      ${variations.map((v, index) => `
  1127→        <div class="variation-card ${v.status === 'failed' ? 'failed' : ''}" data-index="${index}">
  1128→          <div class="variation-card-header">
  1129→            <span class="variation-name">${escapeHtml(v.variationName)}</span>
  1130→            ${v.status === 'failed' ? '<span class="failed-badge">Failed</span>' : ''}
  1131→          </div>
  1132→          ${v.promptDescription ? `<div class="variation-description">${escapeHtml(v.promptDescription)}</div>` : ''}
  1133→          ${v.status !== 'failed' ? `
  1134→            <div class="variation-player" data-index="${index}">
  1135→              <button class="play-btn" data-action="play" data-index="${index}" data-url="${v.previewUrl || ''}">Play</button>
  1136→              <span class="duration">${v.duration ? `${v.duration}s` : '--'}</span>
  1137→            </div>
  1138→            <button class="select-variation-btn btn btn-primary" data-index="${index}">Select This Version</button>
  1139→          ` : `<div class="variation-error">${escapeHtml(v.error || 'Generation failed')}</div>`}
  1140→        </div>
  1141→      `).join('')}
  1142→    </div>
  1143→  `;
  1144→
  1145→  container.querySelectorAll('.play-btn').forEach(btn => btn.addEventListener('click', handleVariationPlay));
  1146→  container.querySelectorAll('.select-variation-btn').forEach(btn => btn.addEventListener('click', handleVariationSelect));
  1147→}
  1148→
  1149→async function handleVariationPlay(event) {
  1150→  const btn = event.target;
  1151→  const index = parseInt(btn.dataset.index);
  1152→  const url = btn.dataset.url;
  1153→
  1154→  if (!url) { setMusicStatus('No preview available', 'warning'); return; }
  1155→
  1156→  musicState.variationPlayers.forEach((player, i) => {
  1157→    if (player && i !== index) {
  1158→      player.pause();
  1159→      const otherBtn = document.querySelector(`.play-btn[data-index="${i}"]`);
  1160→      if (otherBtn) otherBtn.textContent = 'Play';
  1161→    }
  1162→  });
  1163→
  1164→  if (!musicState.variationPlayers[index]) {
  1165→    musicState.variationPlayers[index] = new Audio();
  1166→    musicState.variationPlayers[index].addEventListener('ended', () => { btn.textContent = 'Play'; });
  1167→  }
  1168→
  1169→  const player = musicState.variationPlayers[index];
  1170→
  1171→  if (player.paused || player.src !== url) {
  1172→    player.src = url;
  1173→    try {
  1174→      await player.play();
  1175→      btn.textContent = 'Pause';
  1176→    } catch (error) {
  1177→      console.error('Play error:', error);
  1178→      setMusicStatus('Could not play preview', 'error');
  1179→    }
  1180→  } else {
  1181→    player.pause();
  1182→    btn.textContent = 'Play';
  1183→  }
  1184→}
  1185→
  1186→async function handleVariationSelect(event) {
  1187→  const btn = event.target;
  1188→  const index = parseInt(btn.dataset.index);
  1189→  const jobId = musicState.variationsJob?.jobId;
  1190→
  1191→  if (!jobId) { setMusicStatus('No variations job found', 'error'); return; }
  1192→
  1193→  try {
  1194→    document.querySelectorAll('.select-variation-btn').forEach(b => { b.disabled = true; });
  1195→    btn.textContent = 'Selecting...';
  1196→    setMusicStatus('Finalizing your selection...', 'info');
  1197→
  1198→    const result = await selectVariation(jobId, index);
  1199→    setMusicStatus(`Selected ${result.variationName}! Music added to library.`, 'success');
  1200→
  1201→    musicState.variationPlayers.forEach(player => { if (player) player.pause(); });
  1202→    hideVariationsPanel();
  1203→    loadMusicLibrary();
  1204→    updateMusicCreditsDisplay();
  1205→
  1206→  } catch (error) {
  1207→    console.error('Selection error:', error);
  1208→    setMusicStatus(`Error: ${error.message}`, 'error');
  1209→    document.querySelectorAll('.select-variation-btn').forEach(b => { b.disabled = false; });
  1210→    btn.textContent = 'Select This Version';
  1211→  }
  1212→}
  1213→
  1214→// ============================================
  1215→// JOBS LIST
  1216→// ============================================
  1217→
  1218→function addJobToList(jobId, options, isSceneAware = false) {
  1219→  const job = {
  1220→    jobId,
  1221→    status: 'pending',
  1222→    progress: 0,
  1223→    mood: options.mood,
  1224→    duration: options.duration,
  1225→    isSceneAware,
  1226→    createdAt: new Date().toISOString()
  1227→  };
  1228→  musicState.jobs.unshift(job);
  1229→  renderJobsList();
  1230→}
  1231→
  1232→function startPollingJob(jobId) {
  1233→  // Clear any existing polling
  1234→  if (musicState.pollInterval) clearInterval(musicState.pollInterval);
  1235→
  1236→  // Track which job we're now polling for (race condition fix)
  1237→  musicState.currentPollingJobId = jobId;
  1238→
  1239→  musicState.pollInterval = setInterval(async () => {
  1240→    // Race condition check: verify we're still polling for this job
  1241→    if (musicState.currentPollingJobId !== jobId) {
  1242→      return; // A new job started polling, ignore this callback
  1243→    }
  1244→
  1245→    try {
  1246→      const status = await getJobStatus(jobId);
  1247→
  1248→      // Double-check after async operation
  1249→      if (musicState.currentPollingJobId !== jobId) {
  1250→        return;
  1251→      }
  1252→
  1253→      const jobIndex = musicState.jobs.findIndex(j => j.jobId === jobId);
  1254→      if (jobIndex !== -1) {
  1255→        musicState.jobs[jobIndex] = { ...musicState.jobs[jobIndex], ...status };
  1256→        renderJobsList();
  1257→      }
  1258→
  1259→      if (status.status === 'completed' || status.status === 'failed') {
  1260→        clearInterval(musicState.pollInterval);
  1261→        musicState.pollInterval = null;
  1262→        musicState.currentPollingJobId = null;
  1263→        if (status.status === 'completed') {
  1264→          setMusicStatus('Music generation completed!', 'success');
  1265→          loadMusicLibrary();
  1266→        } else {
  1267→          setMusicStatus(`Generation failed: ${status.failedReason || 'Unknown error'}`, 'error');
  1268→        }
  1269→      }
  1270→    } catch (error) {
  1271→      console.error('Polling error:', error);
  1272→    }
  1273→  }, MUSIC_POLL_INTERVAL);
  1274→}
  1275→
  1276→function renderJobsList() {
  1277→  const container = musicElements.jobsList || document.getElementById('music-jobs-list');
  1278→  if (!container) return;
  1279→
  1280→  if (musicState.jobs.length === 0) {
  1281→    container.innerHTML = '<div class="music-empty">No generation jobs yet</div>';
  1282→    return;
  1283→  }
  1284→
  1285→  // FIX: CEP-CRIT-005 - Music DOM Thrashing
  1286→  // Use DocumentFragment + requestAnimationFrame to prevent 500ms UI freeze
  1287→  // Previously: innerHTML in loop caused reflow on every iteration
  1288→  const fragment = document.createDocumentFragment();
  1289→
  1290→  musicState.jobs.forEach(job => {
  1291→    const jobItem = document.createElement('div');
  1292→    jobItem.className = `music-job-item ${job.status}`;
  1293→    jobItem.setAttribute('data-job-id', job.jobId);
  1294→
  1295→    const statusDiv = document.createElement('div');
  1296→    statusDiv.className = `music-job-status ${job.status}`;
  1297→    jobItem.appendChild(statusDiv);
  1298→
  1299→    const infoDiv = document.createElement('div');
  1300→    infoDiv.className = 'music-job-info';
  1301→
  1302→    const moodSpan = document.createElement('span');
  1303→    moodSpan.className = 'music-job-mood';
  1304→    moodSpan.textContent = `${job.mood || 'Music'}${job.isSceneAware ? ' Scene' : ''}`;
  1305→    infoDiv.appendChild(moodSpan);
  1306→
  1307→    const durationSpan = document.createElement('span');
  1308→    durationSpan.className = 'music-job-duration';
  1309→    durationSpan.textContent = `${job.duration}s`;
  1310→    infoDiv.appendChild(durationSpan);
  1311→
  1312→    jobItem.appendChild(infoDiv);
  1313→
  1314→    const progressDiv = document.createElement('div');
  1315→    progressDiv.className = 'music-job-progress';
  1316→    progressDiv.textContent = job.status === 'completed' ? 'Done' :
  1317→                              job.status === 'failed' ? 'Failed' :
  1318→                              `${job.progress}%`;
  1319→    jobItem.appendChild(progressDiv);
  1320→
  1321→    fragment.appendChild(jobItem);
  1322→  });
  1323→
  1324→  // Batch DOM update in next animation frame to prevent blocking
  1325→  requestAnimationFrame(() => {
  1326→    container.textContent = ''; // Clear efficiently
  1327→    container.appendChild(fragment);
  1328→  });
  1329→}
  1330→
  1331→// ============================================
  1332→// MUSIC LIBRARY
  1333→// ============================================
  1334→
  1335→async function loadMusicLibrary() {
  1336→  const container = musicElements.library || document.getElementById('music-library-list');
  1337→  if (!container) return;
  1338→
  1339→  try {
  1340→    container.innerHTML = '<div class="music-loading">Loading library...</div>';
  1341→    const library = await getMusicLibrary();
  1342→
  1343→    if (library.length === 0) {
  1344→      container.innerHTML = '<div class="music-empty">Your music library is empty</div>';
  1345→      return;
  1346→    }
  1347→
  1348→    // SECURITY: Escape dynamic content to prevent XSS
  1349→    container.innerHTML = library.map(item => {
  1350→      const safeJobId = escapeHtml(item.jobId);
  1351→      return `
  1352→        <div class="music-library-item" data-job-id="${safeJobId}">
  1353→          <div class="music-item-info">
  1354→            <div class="music-item-title">${escapeHtml(item.title || 'Untitled')}</div>
  1355→            <div class="music-item-meta">${escapeHtml(item.duration)}s - ${escapeHtml(item.mood || 'Music')}</div>
  1356→          </div>
  1357→          <div class="music-item-actions">
  1358→            <button class="music-action-btn btn btn-small" data-action="preview" data-job-id="${safeJobId}" title="Preview">Play</button>
  1359→            <button class="music-action-btn btn btn-small" data-action="align" data-job-id="${safeJobId}" title="Align to Video">Align</button>
  1360→            <button class="music-action-btn btn btn-small btn-secondary" data-action="delete" data-job-id="${safeJobId}" title="Delete">Del</button>
  1361→          </div>
  1362→        </div>
  1363→      `;
  1364→    }).join('');
  1365→
  1366→  } catch (error) {
  1367→    console.error('Library load error:', error);
  1368→    container.innerHTML = '<div class="music-error">Failed to load library</div>';
  1369→  }
  1370→}
  1371→
  1372→async function handleLibraryAction(event) {
  1373→  const btn = event.target;
  1374→  const action = btn.dataset.action;
  1375→  const jobId = btn.dataset.jobId;
  1376→
  1377→  switch (action) {
  1378→    case 'preview': await previewMusic(jobId); break;
  1379→    case 'align': await showAlignmentModal(jobId); break;
  1380→    case 'delete': await confirmDeleteMusic(jobId); break;
  1381→  }
  1382→}
  1383→
  1384→async function previewMusic(jobId) {
  1385→  try {
  1386→    setMusicStatus('Loading preview...', 'info');
  1387→    const music = await getMusicFile(jobId);
  1388→
  1389→    if (!music.previewUrl && !music.downloadUrl) {
  1390→      setMusicStatus('No preview available', 'warning');
  1391→      return;
  1392→    }
  1393→
  1394→    if (!musicState.audioPlayer) {
  1395→      musicState.audioPlayer = new Audio();
  1396→      musicState.audioPlayer.addEventListener('ended', () => { setMusicStatus('Preview finished', 'info'); });
  1397→    }
  1398→
  1399→    musicState.audioPlayer.src = music.previewUrl || music.downloadUrl;
  1400→    musicState.audioPlayer.play();
  1401→    setMusicStatus('Playing preview...', 'success');
  1402→
  1403→  } catch (error) {
  1404→    console.error('Preview error:', error);
  1405→    setMusicStatus(`Preview error: ${error.message}`, 'error');
  1406→  }
  1407→}
  1408→
  1409→async function confirmDeleteMusic(jobId) {
  1410→  if (!confirm('Are you sure you want to delete this music file?')) return;
  1411→
  1412→  try {
  1413→    setMusicStatus('Deleting...', 'info');
  1414→    await deleteMusicFile(jobId);
  1415→    setMusicStatus('Music deleted', 'success');
  1416→    loadMusicLibrary();
  1417→  } catch (error) {
  1418→    console.error('Delete error:', error);
  1419→    setMusicStatus(`Delete error: ${error.message}`, 'error');
  1420→  }
  1421→}
  1422→
  1423→// ============================================
  1424→// ALIGNMENT UI
  1425→// ============================================
  1426→
  1427→async function showAlignmentModal(jobId) {
  1428→  try {
  1429→    setMusicStatus('Loading alignment options...', 'info');
  1430→    const options = await getAlignmentOptions();
  1431→    musicState.alignmentOptions = options;
  1432→
  1433→    const sequenceDuration = await getSequenceDuration();
  1434→
  1435→    setMusicStatus('Analyzing beats...', 'info');
  1436→    const beatAnalysis = await analyzeBeatsRequest(jobId);
  1437→    musicState.beatAnalysis = beatAnalysis;
  1438→
  1439→    renderAlignmentModal(jobId, beatAnalysis, options, sequenceDuration);
  1440→    setMusicStatus('', 'info');
  1441→
  1442→  } catch (error) {
  1443→    console.error('Alignment modal error:', error);
  1444→    setMusicStatus(`Error: ${error.message}`, 'error');
  1445→  }
  1446→}
  1447→
  1448→function renderAlignmentModal(jobId, beatAnalysis, options, sequenceDuration) {
  1449→  const modal = document.getElementById('music-align-modal');
  1450→  if (!modal) {
  1451→    console.error('Alignment modal not found in DOM');
  1452→    return;
  1453→  }
  1454→
  1455→  // Populate Info
  1456→  const infoEl = document.getElementById('music-align-info');
  1457→  if (infoEl) {
  1458→    const defaultDuration = sequenceDuration ? Math.round(sequenceDuration) : Math.round(beatAnalysis.duration * 0.8);
  1459→
  1460→    // SECURITY: Escape dynamic content to prevent XSS
  1461→    let html = `
  1462→          <p><strong>Original Duration:</strong> ${escapeHtml(formatDuration(beatAnalysis.duration))}</p>
  1463→          <p><strong>Detected BPM:</strong> ${escapeHtml(beatAnalysis.bpm || 'Unknown')}</p>
  1464→          <p><strong>Beat Count:</strong> ${escapeHtml(beatAnalysis.beatCount)}</p>
  1465→      `;
  1466→    if (sequenceDuration) {
  1467→      html += `<p class="highlight"><strong>Sequence Duration:</strong> ${escapeHtml(formatDuration(sequenceDuration))}</p>`;
  1468→    }
  1469→    infoEl.innerHTML = html;
  1470→
  1471→    // Set default target duration
  1472→    const targetInput = document.getElementById('music-align-target');
  1473→    if (targetInput) {
  1474→      targetInput.value = defaultDuration;
  1475→      targetInput.max = Math.ceil(beatAnalysis.duration);
  1476→    }
  1477→  }
  1478→
  1479→  // Setup Fade Slider
  1480→  const fadeSlider = document.getElementById('music-fade-slider');
  1481→  const fadeValue = document.getElementById('music-fade-value');
  1482→  if (fadeSlider && fadeValue) {
  1483→    fadeSlider.min = options.fadeDuration.min;
  1484→    fadeSlider.max = options.fadeDuration.max;
  1485→    fadeSlider.value = options.fadeDuration.default;
  1486→    fadeValue.textContent = options.fadeDuration.default;
  1487→
  1488→    // Remove old listener to avoid duplicates if any
  1489→    const newSlider = fadeSlider.cloneNode(true);
  1490→    fadeSlider.parentNode.replaceChild(newSlider, fadeSlider);
  1491→
  1492→    newSlider.addEventListener('input', (e) => {
  1493→      if (fadeValue) fadeValue.textContent = e.target.value;
  1494→    });
  1495→  }
  1496→
  1497→  // Setup Match Sequence Button
  1498→  const matchBtn = document.getElementById('music-align-match-seq');
  1499→  if (matchBtn) {
  1500→    if (sequenceDuration) {
  1501→      matchBtn.style.display = 'inline-block';
  1502→      matchBtn.onclick = () => {
  1503→        const targetInput = document.getElementById('music-align-target');
  1504→        if (targetInput) targetInput.value = Math.round(sequenceDuration);
  1505→      };
  1506→    } else {
  1507→      matchBtn.style.display = 'none';
  1508→    }
  1509→  }
  1510→
  1511→  // Setup Confirm Button
  1512→  const confirmBtn = document.getElementById('music-align-btn');
  1513→  if (confirmBtn) {
  1514→    confirmBtn.onclick = (e) => handleAlignmentConfirm(e, jobId);
  1515→    confirmBtn.disabled = false;
  1516→    confirmBtn.textContent = 'Align & Trim';
  1517→  }
  1518→
  1519→  // Setup Close Handlers
  1520→  const closeBtn = document.getElementById('music-align-close');
  1521→  if (closeBtn) closeBtn.onclick = hideAlignmentModal;
  1522→
  1523→  // Show Modal
  1524→  modal.classList.remove('hidden');
  1525→}
  1526→
  1527→function hideAlignmentModal() {
  1528→  const modal = document.getElementById('music-align-modal');
  1529→  if (modal) {
  1530→    modal.classList.add('hidden');
  1531→  }
  1532→  musicState.beatAnalysis = null;
  1533→}
  1534→
  1535→async function handleAlignmentConfirm(event, jobId) {
  1536→  const btn = event.target;
  1537→  // jobId is passed directly now, or fallback to state? 
  1538→  // The original code used dataset.jobId. We passed it in the onclick handler closure.
  1539→
  1540→  const targetInput = document.getElementById('music-align-target');
  1541→  const fadeInput = document.getElementById('music-fade-slider'); // It's a slider now in HTML
  1542→  const beatAlignInput = document.getElementById('music-beat-align');
  1543→
  1544→  const targetDuration = parseFloat(targetInput?.value);
  1545→  const fadeDuration = parseFloat(fadeInput?.value);
  1546→  const beatAlign = beatAlignInput?.checked;
  1547→
  1548→  if (!targetDuration || targetDuration < 5) {
  1549→    setMusicStatus('Target duration must be at least 5 seconds', 'error');
  1550→    return;
  1551→  }
  1552→
  1553→  try {
  1554→    musicState.isAligning = true;
  1555→    btn.disabled = true;
  1556→    btn.textContent = 'Aligning...';
  1557→    setMusicStatus('Aligning music to video duration...', 'info');
  1558→
  1559→    const result = await alignMusicRequest(jobId, targetDuration, { fadeDuration, beatAlign });
  1560→    setMusicStatus(`Aligned! Cut at ${formatDuration(result.actualDuration)} (${result.wasAligned ? 'beat-aligned' : 'exact'})`, 'success');
  1561→    hideAlignmentModal();
  1562→
  1563→    if (result.downloadUrl) {
  1564→      showAlignedDownload(result);
  1565→    }
  1566→
  1567→  } catch (error) {
  1568→    console.error('Alignment error:', error);
  1569→    setMusicStatus(`Alignment failed: ${error.message}`, 'error');
  1570→    btn.disabled = false;
  1571→    btn.textContent = 'Align Music';
  1572→  } finally {
  1573→    musicState.isAligning = false;
  1574→  }
  1575→}
  1576→
  1577→function showAlignedDownload(result) {
  1578→  const notification = document.createElement('div');
  1579→  notification.className = 'alignment-notification';
  1580→
  1581→  // SECURITY: Escape URL to prevent XSS - use encodeURI for URL safety
  1582→  const safeUrl = escapeHtml(result.downloadUrl || '');
  1583→  const safeDuration = escapeHtml(formatDuration(result.actualDuration));
  1584→
  1585→  notification.innerHTML = `
  1586→    <div class="notification-content">
  1587→      <span class="notification-icon">Done</span>
  1588→      <div class="notification-text">
  1589→        <strong>Music Aligned!</strong>
  1590→        <span>Duration: ${safeDuration}</span>
  1591→      </div>
  1592→      <div class="notification-actions">
  1593→        <button class="btn btn-small" data-action="download">Download</button>
  1594→        <button class="btn-close" data-action="close">x</button>
  1595→      </div>
  1596→    </div>
  1597→  `;
  1598→
  1599→  const container = musicElements.section || document.getElementById('musicSection') || document.body;
  1600→  container.appendChild(notification);
  1601→
  1602→  // Store URL safely via JS property instead of data attribute
  1603→  const downloadBtn = notification.querySelector('[data-action="download"]');
  1604→  downloadBtn._downloadUrl = result.downloadUrl;
  1605→  downloadBtn.addEventListener('click', (e) => {
  1606→    window.open(e.target._downloadUrl, '_blank');
  1607→    notification.remove();
  1608→  });
  1609→
  1610→  notification.querySelector('[data-action="close"]').addEventListener('click', () => { notification.remove(); });
  1611→  setTimeout(() => notification.remove(), 30000);
  1612→}
  1613→
  1614→// ============================================
  1615→// TIMELINE UI
  1616→// ============================================
  1617→
  1618→function updateTimelineAvailability() {
  1619→  const btn = musicElements.timelineBtn || document.getElementById('music-timeline-btn');
  1620→  const transcript = getCurrentTranscript();
  1621→
  1622→  if (btn) {
  1623→    btn.disabled = !transcript || !transcript.segments || transcript.segments.length === 0;
  1624→    if (!transcript) {
  1625→      btn.title = 'Run transcription first to enable mood timeline';
  1626→    } else if (!transcript.segments || transcript.segments.length === 0) {
  1627→      btn.title = 'No transcript segments available';
  1628→    } else {
  1629→      btn.title = 'Generate per-chapter music with mood matching';
  1630→    }
  1631→  }
  1632→}
  1633→
  1634→async function showTimelineModal() {
  1635→  const transcript = getCurrentTranscript();
  1636→  if (!transcript) {
  1637→    setMusicStatus('Run transcription first to generate mood timeline', 'error');
  1638→    return;
  1639→  }
  1640→
  1641→  try {
  1642→    setMusicStatus('Loading timeline options...', 'info');
  1643→    const options = await getTimelineOptions();
  1644→    musicState.timelineOptions = options;
  1645→    const estimate = await estimateTimelineRequest(transcript);
  1646→    renderTimelineModal(transcript, options, estimate);
  1647→    setMusicStatus('', 'info');
  1648→  } catch (error) {
  1649→    console.error('Timeline modal error:', error);
  1650→    setMusicStatus(`Error: ${error.message}`, 'error');
  1651→  }
  1652→}
  1653→
  1654→function renderTimelineModal(transcript, options, estimate) {
  1655→  let modal = document.getElementById('timelineModal');
  1656→  if (!modal) {
  1657→    modal = document.createElement('div');
  1658→    modal.id = 'timelineModal';
  1659→    modal.className = 'modal-overlay';
  1660→    document.body.appendChild(modal);
  1661→  }
  1662→
  1663→  const defaults = options.defaults || {};
  1664→  const constraints = options.constraints || {};
  1665→
  1666→  modal.innerHTML = `
  1667→    <div class="modal-content timeline-modal">
  1668→      <div class="modal-header">
  1669→        <h3>Generate Mood Timeline</h3>
  1670→        <button class="modal-close-btn" id="timelineCloseBtn">x</button>
  1671→      </div>
  1672→      <div class="modal-body">
  1673→        <div class="timeline-info">
  1674→          <p>Video Duration: ${formatDuration(transcript.duration)}</p>
  1675→          <p>Transcript Segments: ${transcript.segments?.length || 0}</p>
  1676→          <p><strong>Estimated Chapters: ${estimate.estimatedChapters}</strong></p>
  1677→          <p><strong>Estimated Time: ${estimate.estimatedTimeDisplay}</strong></p>
  1678→        </div>
  1679→        <p>This will analyze your video transcript to detect chapters and their emotional tone, then generate unique music for each chapter with crossfades between them.</p>
  1680→        <p><strong>Cost:</strong> 3 music credits</p>
  1681→        <div class="timeline-form">
  1682→          <div class="form-group">
  1683→            <label for="timelineMaxChapters">Maximum Chapters</label>
  1684→            <input type="number" id="timelineMaxChapters" value="${defaults.maxChapters || 10}" min="1" max="20" step="1">
  1685→          </div>
  1686→          <div class="form-group">
  1687→            <label for="timelineMinLength">Minimum Chapter Length (seconds)</label>
  1688→            <input type="number" id="timelineMinLength" value="${defaults.minChapterLength || 60}" min="30" max="300" step="10">
  1689→          </div>
  1690→          <div class="form-group">
  1691→            <label for="timelineCrossfade">Crossfade Duration (seconds)</label>
  1692→            <input type="number" id="timelineCrossfade" value="${defaults.crossfadeDuration || 2}" min="${constraints.minCrossfadeDuration || 0.5}" max="${constraints.maxCrossfadeDuration || 5}" step="0.5">
  1693→          </div>
  1694→          <div class="form-group">
  1695→            <label for="timelineInstruments">Instrument Style</label>
  1696→            <select id="timelineInstruments">
  1697→              <option value="">Auto-detect from content</option>
  1698→              ${INSTRUMENT_OPTIONS.map(i => `<option value="${i.id}">${i.name} - ${i.description}</option>`).join('')}
  1699→            </select>
  1700→          </div>
  1701→          <div class="form-group">
  1702→            <label for="timelinePrompt">Additional Instructions (optional)</label>
  1703→            <textarea id="timelinePrompt" rows="2" placeholder="E.g., 'Modern electronic feel'"></textarea>
  1704→          </div>
  1705→        </div>
  1706→      </div>
  1707→      <div class="modal-footer">
  1708→        <button type="button" id="timelineCancelBtn" class="btn btn-secondary">Cancel</button>
  1709→        <button type="button" id="timelineConfirmBtn" class="btn btn-primary">Generate Timeline Music (3 credits)</button>
  1710→      </div>
  1711→    </div>
  1712→  `;
  1713→
  1714→  modal.style.display = 'flex';
  1715→
  1716→  document.getElementById('timelineCloseBtn').addEventListener('click', hideTimelineModal);
  1717→  document.getElementById('timelineCancelBtn').addEventListener('click', hideTimelineModal);
  1718→  document.getElementById('timelineConfirmBtn').addEventListener('click', handleTimelineConfirm);
  1719→  modal.addEventListener('click', (e) => { if (e.target === modal) hideTimelineModal(); });
  1720→}
  1721→
  1722→function hideTimelineModal() {
  1723→  const modal = document.getElementById('timelineModal');
  1724→  if (modal) { modal.style.display = 'none'; modal.innerHTML = ''; }
  1725→}
  1726→
  1727→async function handleTimelineConfirm() {
  1728→  const transcript = getCurrentTranscript();
  1729→  if (!transcript) {
  1730→    setMusicStatus('Transcript not available', 'error');
  1731→    return;
  1732→  }
  1733→
  1734→  const maxChapters = parseInt(document.getElementById('timelineMaxChapters').value) || 10;
  1735→  const minChapterLength = parseInt(document.getElementById('timelineMinLength').value) || 60;
  1736→  const crossfadeDuration = parseFloat(document.getElementById('timelineCrossfade').value) || 2;
  1737→  const instruments = document.getElementById('timelineInstruments').value;
  1738→  const prompt = document.getElementById('timelinePrompt').value || '';
  1739→
  1740→  const confirmBtn = document.getElementById('timelineConfirmBtn');
  1741→
  1742→  try {
  1743→    musicState.isGeneratingTimeline = true;
  1744→    confirmBtn.disabled = true;
  1745→    confirmBtn.textContent = 'Generating...';
  1746→
  1747→    setMusicStatus('Generating mood timeline... This may take several minutes.', 'info');
  1748→    hideTimelineModal();
  1749→
  1750→    const result = await generateTimelineRequest(transcript, {
  1751→      maxChapters,
  1752→      minChapterLength,
  1753→      crossfadeDuration,
  1754→      instruments: instruments ? [instruments] : [],
  1755→      prompt
  1756→    });
  1757→
  1758→    setMusicStatus(`Timeline generated! ${result.chapters?.length || 0} chapters, ${formatDuration(result.duration)}`, 'success');
  1759→
  1760→    if (result.audioUrl) {
  1761→      showTimelineResult(result);
  1762→    }
  1763→
  1764→    loadMusicLibrary();
  1765→    updateMusicCreditsDisplay();
  1766→
  1767→  } catch (error) {
  1768→    console.error('Timeline generation error:', error);
  1769→    setMusicStatus(`Timeline generation failed: ${error.message}`, 'error');
  1770→  } finally {
  1771→    musicState.isGeneratingTimeline = false;
  1772→    if (confirmBtn) {
  1773→      confirmBtn.disabled = false;
  1774→      confirmBtn.textContent = 'Generate Timeline Music (3 credits)';
  1775→    }
  1776→  }
  1777→}
  1778→
  1779→function showTimelineResult(result) {
  1780→  let resultPanel = document.getElementById('timelineResultPanel');
  1781→  if (!resultPanel) {
  1782→    resultPanel = document.createElement('div');
  1783→    resultPanel.id = 'timelineResultPanel';
  1784→    resultPanel.className = 'timeline-result-panel';
  1785→    const container = musicElements.section || document.getElementById('musicSection') || document.body;
  1786→    container.insertBefore(resultPanel, container.firstChild);
  1787→  }
  1788→
  1789→  // SECURITY: Escape dynamic content to prevent XSS
  1790→  const chapterList = (result.chapters || []).map((ch, i) => `
  1791→    <div class="timeline-chapter">
  1792→      <span class="chapter-num">${i + 1}</span>
  1793→      <span class="chapter-title">${escapeHtml(ch.title)}</span>
  1794→      <span class="chapter-mood">${escapeHtml(ch.mood || 'neutral')}</span>
  1795→    </div>
  1796→  `).join('');
  1797→
  1798→  resultPanel.innerHTML = `
  1799→    <div class="timeline-result-content">
  1800→      <div class="timeline-result-header">
  1801→        <span class="result-icon">Done</span>
  1802→        <span class="result-title">Mood Timeline Generated!</span>
  1803→        <button class="close-btn" data-action="close">x</button>
  1804→      </div>
  1805→      <div class="timeline-result-stats">
  1806→        <p>Duration: ${escapeHtml(formatDuration(result.duration))}</p>
  1807→        <p>Chapters: ${escapeHtml(result.chapters?.length || 0)}</p>
  1808→        <p>Credits Used: ${escapeHtml(result.creditCost || 3)}</p>
  1809→      </div>
  1810→      <div class="timeline-chapters"><h4>Chapters</h4>${chapterList}</div>
  1811→      <div class="timeline-result-actions">
  1812→        <button class="btn btn-primary" data-action="download" data-url="${escapeHtml(result.audioUrl)}">Download</button>
  1813→      </div>
  1814→    </div>
  1815→  `;
  1816→
  1817→  resultPanel.style.display = 'block';
  1818→
  1819→  resultPanel.querySelector('[data-action="close"]').addEventListener('click', () => { resultPanel.style.display = 'none'; });
  1820→  resultPanel.querySelector('[data-action="download"]').addEventListener('click', (e) => {
  1821→    window.open(e.target.dataset.url, '_blank');
  1822→  });
  1823→
  1824→  setTimeout(() => { if (resultPanel) resultPanel.style.display = 'none'; }, 60000);
  1825→}
  1826→
  1827→// ============================================
  1828→// UTILITY FUNCTIONS
  1829→// ============================================
  1830→
  1831→function formatDuration(seconds) {
  1832→  if (!seconds) return '0:00';
  1833→  const mins = Math.floor(seconds / 60);
  1834→  const secs = Math.round(seconds % 60);
  1835→  return `${mins}:${secs.toString().padStart(2, '0')}`;
  1836→}
  1837→
  1838→async function updateMusicCreditsDisplay() {
  1839→  const badge = musicElements.creditsBadge || document.getElementById('music-credits-badge');
  1840→  if (!badge) return;
  1841→
  1842→  try {
  1843→    const credits = await getMusicCredits();
  1844→    badge.textContent = `${credits.remaining}/${credits.total} songs`;
  1845→    badge.className = 'music-credits-badge';
  1846→    if (credits.remaining === 0) badge.classList.add('empty');
  1847→    else if (credits.remaining <= 2) badge.classList.add('low');
  1848→  } catch (error) {
  1849→    badge.textContent = 'Credits: --';
  1850→  }
  1851→}
  1852→
  1853→function setMusicStatus(message, type = 'info') {
  1854→  const status = musicElements.status || document.getElementById('music-status');
  1855→  if (!status) return;
  1856→
  1857→  status.textContent = message;
  1858→  status.className = `music-status music-status-${type}`;
  1859→  status.style.display = 'block';
  1860→
  1861→  if (type !== 'error') {
  1862→    setTimeout(() => { status.style.display = 'none'; }, 5000);
  1863→  }
  1864→}
  1865→
  1866→function escapeHtml(str) {
  1867→  if (!str) return '';
  1868→  const div = document.createElement('div');
  1869→  div.textContent = str;
  1870→  return div.innerHTML;
  1871→}
  1872→
  1873→// ============================================
  1874→// EXPORTS
  1875→// ============================================
  1876→
  1877→window.musicModule = {
  1878→  init: initMusicModule,
  1879→  identifySong,
  1880→  generateMusicRequest,
  1881→  getMusicLibrary,
  1882→  getMusicCredits,
  1883→  loadMusicLibrary,
  1884→  previewMusic,
  1885→  generateVariationsRequest,
  1886→  getVariationsStatus,
  1887→  selectVariation,
  1888→  handleGenerateVariations,
  1889→  showVariationsPanel,
  1890→  hideVariationsPanel,
  1891→  generateSceneAwareRequest,
  1892→  getCurrentTranscriptSegments,
  1893→  handleSceneAwareToggle,
  1894→  updateSceneAwareAvailability,
  1895→  alignMusicRequest,
  1896→  analyzeBeatsRequest,
  1897→  getAlignmentOptions,
  1898→  showAlignmentModal,
  1899→  hideAlignmentModal,
  1900→  formatDuration,
  1901→  getSequenceDuration,
  1902→  generateTimelineRequest,
  1903→  getTimelineOptions,
  1904→  estimateTimelineRequest,
  1905→  getCurrentTranscript,
  1906→  showTimelineModal,
  1907→  hideTimelineModal,
  1908→  updateTimelineAvailability,
  1909→  MOOD_OPTIONS,
  1910→  INSTRUMENT_OPTIONS,
  1911→  DURATION_OPTIONS
  1912→};
  1913→
  1914→window.initMusicModule = initMusicModule;
  1915→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
