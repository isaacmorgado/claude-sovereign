     1→/**
     2→ * SPLICE CEP Panel Configuration
     3→ * Backend URLs, paths, and utility functions
     4→ */
     5→
     6→// ============================================================================
     7→// DEBUG MODE CONFIGURATION
     8→// ============================================================================
     9→
    10→/**
    11→ * Debug mode flag - enables verbose diagnostic logging
    12→ * Can be enabled via localStorage for troubleshooting:
    13→ *   localStorage.setItem('spliceDebugMode', 'true');
    14→ *
    15→ * Default: false (production mode - minimal logging)
    16→ */
    17→const SPLICE_DEBUG = localStorage.getItem('spliceDebugMode') === 'true';
    18→
    19→/**
    20→ * Debug logging function - only outputs when debug mode is enabled
    21→ * Use this for diagnostic/development logging that should be silent in production
    22→ * @param {...any} args - Arguments to log (prefixed with [SPLICE DEBUG])
    23→ */
    24→function debugLog(...args) {
    25→    if (SPLICE_DEBUG) {
    26→        console.log('[SPLICE DEBUG]', ...args);
    27→    }
    28→}
    29→
    30→/**
    31→ * Debug fetch logging - verbose fetch request/response logging
    32→ * @param {...any} args - Arguments to log (prefixed with [SPLICE FETCH])
    33→ */
    34→function debugFetch(...args) {
    35→    if (SPLICE_DEBUG) {
    36→        console.log('[SPLICE FETCH]', ...args);
    37→    }
    38→}
    39→
    40→// ============================================================================
    41→// BACKEND CONFIGURATION
    42→// ============================================================================
    43→const SPLICE_CONFIG = {
    44→    VERSION: '6.0.3',
    45→    BACKEND_PROD: 'https://splice-api-production.up.railway.app',
    46→    BACKEND_DEV: 'https://127.0.0.1:3847',
    47→    FETCH_TIMEOUT: 120000, // 2 minutes
    48→    RETRY_ATTEMPTS: 3,
    49→    RETRY_DELAY: 1000
    50→};
    51→
    52→/**
    53→ * Get the backend URL based on environment
    54→ * FIXED: CEP panels always run from file://, so we default to PROD
    55→ * Use localStorage to override for local development if needed
    56→ */
    57→function getBackendUrl() {
    58→    // Priority 1: Allow override via localStorage (for local dev testing)
    59→    const customUrl = localStorage.getItem('spliceBackendUrl');
    60→    if (customUrl) {
    61→        debugLog('Using custom backend URL from localStorage:', customUrl);
    62→        return customUrl;
    63→    }
    64→
    65→    // Priority 2: Default to production backend
    66→    // (CEP panels always run from file://, so can't reliably detect dev mode)
    67→    debugLog('Using production backend URL:', SPLICE_CONFIG.BACKEND_PROD);
    68→    return SPLICE_CONFIG.BACKEND_PROD;
    69→}
    70→
    71→// ============================================================================
    72→// JSX BRIDGE - Communicate with Premiere Pro
    73→// ============================================================================
    74→
    75→// JSX timeout configuration (FIX: CEP-CRIT-001 - JSX Bridge Timeout Bug)
    76→const JSX_TIMEOUTS = {
    77→    QUICK: 5000,        // 5s  - simple checks (checkSequenceOpen, getVersion)
    78→    DEFAULT: 30000,     // 30s - most operations (getClips, createMarker)
    79→    LONG: 120000,       // 2m  - export operations, large file I/O
    80→    CRITICAL: 300000    // 5m  - complex timeline operations
    81→};
    82→
    83→const jsx = {
    84→    cs: null,
    85→    _initPromise: null,
    86→    _initialized: false,
    87→    _jsxReady: false,
    88→
    89→    /**
    90→     * Initialize the CSInterface with FireCut-style retry logic
    91→     * Returns a promise that resolves when ready (true/false)
    92→     * Does NOT reject - gracefully handles missing CEP environment
    93→     */
    94→    init: function() {
    95→        if (this._initPromise) return this._initPromise;
    96→
    97→        this._initPromise = this._initWithRetry();
    98→        return this._initPromise;
    99→    },
   100→
   101→    /**
   102→     * FireCut-style retry logic for CSInterface initialization
   103→     * Retries up to 5 times with exponential backoff
   104→     */
   105→    _initWithRetry: async function() {
   106→        const maxRetries = 5;
   107→        const baseDelay = 200; // Start with 200ms, will double each retry
   108→
   109→        for (let attempt = 1; attempt <= maxRetries; attempt++) {
   110→            const success = await this._tryInit(attempt);
   111→            if (success) {
   112→                // After CSInterface init, verify JSX is ready
   113→                const jsxReady = await this._verifyJSXReady();
   114→                if (jsxReady) {
   115→                    this._jsxReady = true;
   116→                    debugLog(`[JSX] Full initialization complete on attempt ${attempt}`);
   117→                    return true;
   118→                } else {
   119→                    debugLog(`[JSX] CSInterface ready but JSX not responding, attempt ${attempt}/${maxRetries}`);
   120→                }
   121→            }
   122→
   123→            if (attempt < maxRetries) {
   124→                const delay = baseDelay * Math.pow(2, attempt - 1);
   125→                debugLog(`[JSX] Init attempt ${attempt} failed, retrying in ${delay}ms...`);
   126→                await this._delay(delay);
   127→            }
   128→        }
   129→
   130→        console.warn('[JSX] Initialization failed after all retries - panel may have limited functionality');
   131→        return this._initialized;
   132→    },
   133→
   134→    /**
   135→     * Single initialization attempt
   136→     */
   137→    _tryInit: function(attempt) {
   138→        return new Promise((resolve) => {
   139→            try {
   140→                if (typeof CSInterface !== 'undefined') {
   141→                    this.cs = new CSInterface();
   142→                    // Verify we're in a real CEP environment by checking for __adobe_cep__
   143→                    if (window.__adobe_cep__) {
   144→                        this._initialized = true;
   145→                        debugLog(`[JSX] CSInterface initialized successfully (CEP environment detected) - attempt ${attempt}`);
   146→                        resolve(true);
   147→                    } else {
   148→                        // CSInterface exists but no CEP runtime - browser/dev mode
   149→                        this._initialized = true;
   150→                        debugLog(`[JSX] CSInterface initialized (development/browser mode) - attempt ${attempt}`);
   151→                        resolve(true);
   152→                    }
   153→                } else {
   154→                    debugLog(`[JSX] CSInterface not yet available - attempt ${attempt}`);
   155→                    resolve(false);
   156→                }
   157→            } catch (err) {
   158→                console.error(`[JSX] Init attempt ${attempt} error:`, err);
   159→                resolve(false);
   160→            }
   161→        });
   162→    },
   163→
   164→    /**
   165→     * FireCut-style JSX readiness verification
   166→     * Tests that hostScript.jsx is actually loaded and responding
   167→     */
   168→    _verifyJSXReady: async function() {
   169→        if (!this.cs) return false;
   170→
   171→        return new Promise((resolve) => {
   172→            const timeout = setTimeout(() => {
   173→                debugLog('[JSX] JSX readiness check timed out');
   174→                resolve(false);
   175→            }, 2000);
   176→
   177→            try {
   178→                // Simple test that hostScript.jsx is loaded and responding
   179→                this.cs.evalScript('(function() { return typeof getActiveSequence === "function" ? "ready" : "not_ready"; })()', (result) => {
   180→                    clearTimeout(timeout);
   181→                    if (result === 'ready') {
   182→                        debugLog('[JSX] JSX bridge verified ready - hostScript.jsx loaded');
   183→                        resolve(true);
   184→                    } else {
   185→                        debugLog('[JSX] JSX functions not yet available:', result);
   186→                        resolve(false);
   187→                    }
   188→                });
   189→            } catch (err) {
   190→                clearTimeout(timeout);
   191→                debugLog('[JSX] JSX readiness check error:', err);
   192→                resolve(false);
   193→            }
   194→        });
   195→    },
   196→
   197→    /**
   198→     * Helper for async delay
   199→     */
   200→    _delay: function(ms) {
   201→        return new Promise(resolve => setTimeout(resolve, ms));
   202→    },
   203→
   204→    /**
   205→     * Ensure JSX is initialized before making calls
   206→     */
   207→    ensureInitialized: async function() {
   208→        if (!this._initialized) {
   209→            await this.init();
   210→        }
   211→        if (!this.cs) {
   212→            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');
   213→        }
   214→    },
   215→
   216→    /**
   217→     * Execute ExtendScript in Premiere Pro with timeout protection
   218→     * FIX: CEP-CRIT-001 - JSX Bridge Timeout Bug
   219→     * @param {string} script - ExtendScript to execute
   220→     * @param {number} timeout - Timeout in ms (default: JSX_TIMEOUTS.DEFAULT)
   221→     * @returns {Promise<any>} - Parsed result
   222→     */
   223→    evalScript: async function(script, timeout = JSX_TIMEOUTS.DEFAULT) {
   224→        await this.ensureInitialized();
   225→
   226→        return new Promise((resolve, reject) => {
   227→            let completed = false;
   228→
   229→            // Timeout handler - rejects if ExtendScript hangs
   230→            const timeoutId = setTimeout(() => {
   231→                if (!completed) {
   232→                    completed = true;
   233→                    const scriptPreview = script.length > 100 ? script.substring(0, 100) + '...' : script;
   234→                    const error = new Error(`ExtendScript timeout after ${timeout}ms: ${scriptPreview}`);
   235→                    error.code = 'JSX_TIMEOUT';
   236→                    console.error('[JSX] Timeout:', scriptPreview);
   237→                    reject(error);
   238→                }
   239→            }, timeout);
   240→
   241→            this.cs.evalScript(script, (result) => {
   242→                // Ignore late callbacks after timeout
   243→                if (completed) {
   244→                    console.warn('[JSX] Late evalScript result received after timeout - ignoring');
   245→                    return;
   246→                }
   247→
   248→                completed = true;
   249→                clearTimeout(timeoutId);
   250→
   251→                if (result === 'undefined' || result === undefined) {
   252→                    resolve(null);
   253→                    return;
   254→                }
   255→
   256→                // Check for EvalScript error or ExtendScript runtime errors
   257→                if (typeof result === 'string' && (
   258→                    result.indexOf('EvalScript error') !== -1 ||
   259→                    result.indexOf('Error:') !== -1 ||
   260→                    result.indexOf('TypeError:') !== -1 ||
   261→                    result.indexOf('ReferenceError:') !== -1
   262→                )) {
   263→                    reject(new Error(result));
   264→                    return;
   265→                }
   266→
   267→                // Try to parse JSON
   268→                try {
   269→                    const parsed = JSON.parse(result);
   270→                    if (parsed.error) {
   271→                        reject(new Error(parsed.error));
   272→                    } else {
   273→                        resolve(parsed);
   274→                    }
   275→                } catch (e) {
   276→                    // Return as-is if not JSON
   277→                    resolve(result);
   278→                }
   279→            });
   280→        });
   281→    },
   282→
   283→    /**
   284→     * Call a JSX function with arguments
   285→     * @param {string} funcName - Function name
   286→     * @param {...any} args - Arguments to pass (last arg can be {timeout: number})
   287→     * @returns {Promise<any>}
   288→     */
   289→    call: async function(funcName, ...args) {
   290→        await this.ensureInitialized();
   291→
   292→        // Check if last argument is an options object with timeout
   293→        let timeout = JSX_TIMEOUTS.DEFAULT;
   294→        let funcArgs = args;
   295→
   296→        if (args.length > 0 && typeof args[args.length - 1] === 'object' && args[args.length - 1] !== null) {
   297→            const lastArg = args[args.length - 1];
   298→            if ('_jsxTimeout' in lastArg) {
   299→                timeout = lastArg._jsxTimeout;
   300→                funcArgs = args.slice(0, -1);
   301→            }
   302→        }
   303→
   304→        const escapedArgs = funcArgs.map(arg => {
   305→            if (arg === null || arg === undefined) return 'null';
   306→            if (typeof arg === 'string') {
   307→                // Escape backslashes first, then other special chars
   308→                return `'${arg
   309→                    .replace(/\\/g, '\\\\')
   310→                    .replace(/'/g, "\\'")
   311→                    .replace(/\r/g, '\\r')
   312→                    .replace(/\n/g, '\\n')
   313→                    .replace(/\t/g, '\\t')}'`;
   314→            }
   315→            if (typeof arg === 'object') {
   316→                return `'${JSON.stringify(arg)
   317→                    .replace(/\\/g, '\\\\')
   318→                    .replace(/'/g, "\\'")}'`;
   319→            }
   320→            return String(arg);
   321→        });
   322→
   323→        const script = `${funcName}(${escapedArgs.join(', ')})`;
   324→        return this.evalScript(script, timeout);
   325→    },
   326→
   327→    /**
   328→     * Call a JSX function with explicit timeout
   329→     * Convenience wrapper for operations that need non-default timeouts
   330→     * @param {string} funcName - Function name
   331→     * @param {Array} args - Arguments array
   332→     * @param {number} timeout - Timeout in ms
   333→     * @returns {Promise<any>}
   334→     */
   335→    callWithTimeout: async function(funcName, args = [], timeout = JSX_TIMEOUTS.DEFAULT) {
   336→        return this.call(funcName, ...args, { _jsxTimeout: timeout });
   337→    }
   338→};
   339→
   340→// ============================================================================
   341→// FETCH UTILITIES
   342→// ============================================================================
   343→
   344→/**
   345→ * Fetch with timeout support
   346→ * @param {string} url - URL to fetch
   347→ * @param {object} options - Fetch options
   348→ * @param {number} timeout - Timeout in ms
   349→ */
   350→async function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {
   351→    // DIAGNOSTIC: Log fetch request details (debug mode only)
   352→    debugFetch('=== FETCH REQUEST START ===');
   353→    debugFetch('URL:', url);
   354→    debugFetch('Method:', options?.method || 'GET');
   355→    debugFetch('Headers:', options?.headers);
   356→    debugFetch('Timeout:', timeout);
   357→    debugFetch('Is CEP environment:', typeof CSInterface !== 'undefined');
   358→    debugFetch('=================================');
   359→
   360→    const controller = new AbortController();
   361→    const timeoutId = setTimeout(() => controller.abort(), timeout);
   362→
   363→    try {
   364→        const response = await fetch(url, {
   365→            ...options,
   366→            signal: controller.signal
   367→        });
   368→        clearTimeout(timeoutId);
   369→
   370→        // DIAGNOSTIC: Log successful response (debug mode only)
   371→        debugFetch('=== FETCH RESPONSE SUCCESS ===');
   372→        debugFetch('Status:', response.status);
   373→        debugFetch('OK:', response.ok);
   374→        debugFetch('=================================');
   375→
   376→        return response;
   377→    } catch (error) {
   378→        clearTimeout(timeoutId);
   379→
   380→        // DIAGNOSTIC: Log raw fetch error (debug mode only)
   381→        debugFetch('=== FETCH ERROR CAUGHT ===');
   382→        debugFetch('Error name:', error?.name);
   383→        debugFetch('Error message:', error?.message);
   384→        debugFetch('Error type:', typeof error);
   385→        debugFetch('Error constructor:', error?.constructor?.name);
   386→        debugFetch('Is AbortError:', error.name === 'AbortError');
   387→        debugFetch('Is TypeError:', error.name === 'TypeError');
   388→        debugFetch('Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));
   389→        debugFetch('=================================');
   390→
   391→        if (error.name === 'AbortError') {
   392→            throw new Error(`Request timeout after ${timeout}ms`);
   393→        }
   394→        throw error;
   395→    }
   396→}
   397→
   398→/**
   399→ * Parse error response from backend
   400→ * @param {Response} response - Fetch response
   401→ */
   402→async function parseErrorResponse(response) {
   403→    try {
   404→        const data = await response.json();
   405→        return data.error || data.message || `HTTP ${response.status}`;
   406→    } catch {
   407→        return `HTTP ${response.status}: ${response.statusText}`;
   408→    }
   409→}
   410→
   411→/**
   412→ * Get auth headers for API requests
   413→ * Uses JWT Bearer token if available, with legacy fallback
   414→ */
   415→function getAuthHeaders() {
   416→    const headers = { 'Content-Type': 'application/json' };
   417→    const settings = getSettings();
   418→
   419→    // Prefer JWT Bearer token (modern auth)
   420→    if (settings.accessToken) {
   421→        headers['Authorization'] = `Bearer ${settings.accessToken}`;
   422→        return headers;
   423→    }
   424→
   425→    // Legacy fallback for backwards compatibility
   426→    // This will be removed after 2026-04-11
   427→    if (settings.customerId) {
   428→        headers['x-stripe-customer-id'] = settings.customerId;
   429→        console.warn('[SPLICE] Using deprecated x-stripe-customer-id header. Please re-login to upgrade to JWT auth.');
   430→    }
   431→
   432→    return headers;
   433→}
   434→
   435→/**
   436→ * Check if the access token is expired or about to expire
   437→ * @returns {boolean} True if token needs refresh
   438→ */
   439→function isTokenExpired() {
   440→    const settings = getSettings();
   441→    if (!settings.tokenExpiry) return true;
   442→
   443→    // Refresh if less than 5 minutes remaining
   444→    const bufferMs = 5 * 60 * 1000;
   445→    return Date.now() >= (settings.tokenExpiry - bufferMs);
   446→}
   447→
   448→/**
   449→ * Refresh the access token using the refresh token
   450→ * @returns {Promise<boolean>} True if refresh succeeded
   451→ */
   452→async function refreshAccessToken() {
   453→    const settings = getSettings();
   454→
   455→    if (!settings.refreshToken) {
   456→        debugLog('[Auth] No refresh token available');
   457→        return false;
   458→    }
   459→
   460→    try {
   461→        debugLog('[Auth] Refreshing access token...');
   462→
   463→        const response = await fetchWithTimeout(`${getBackendUrl()}/auth/refresh`, {
   464→            method: 'POST',
   465→            headers: { 'Content-Type': 'application/json' },
   466→            body: JSON.stringify({ refreshToken: settings.refreshToken })
   467→        }, 30000);
   468→
   469→        if (!response.ok) {
   470→            const errorMsg = await parseErrorResponse(response);
   471→            console.error('[Auth] Token refresh failed:', errorMsg);
   472→
   473→            // If refresh token is invalid, clear auth and require re-login
   474→            if (response.status === 401) {
   475→                clearAuthTokens();
   476→            }
   477→            return false;
   478→        }
   479→
   480→        const data = await response.json();
   481→
   482→        // Save new access token
   483→        const expiresInMs = (data.expiresIn || 86400) * 1000; // Default 24h
   484→        saveSettings({
   485→            accessToken: data.token,
   486→            tokenExpiry: Date.now() + expiresInMs
   487→        });
   488→
   489→        debugLog('[Auth] Access token refreshed successfully');
   490→        return true;
   491→    } catch (err) {
   492→        console.error('[Auth] Token refresh error:', err);
   493→        return false;
   494→    }
   495→}
   496→
   497→/**
   498→ * Clear all auth tokens (call on logout or auth failure)
   499→ */
   500→function clearAuthTokens() {
   501→    saveSettings({
   502→        accessToken: null,
   503→        refreshToken: null,
   504→        tokenExpiry: null
   505→    });
   506→    debugLog('[Auth] Auth tokens cleared');
   507→}
   508→
   509→/**
   510→ * Ensure we have a valid access token, refreshing if needed
   511→ * @returns {Promise<boolean>} True if we have a valid token
   512→ */
   513→async function ensureValidToken() {
   514→    const settings = getSettings();
   515→
   516→    // No token at all - need to login
   517→    if (!settings.accessToken) {
   518→        return false;
   519→    }
   520→
   521→    // Token not expired - good to go
   522→    if (!isTokenExpired()) {
   523→        return true;
   524→    }
   525→
   526→    // Try to refresh
   527→    return await refreshAccessToken();
   528→}
   529→
   530→// ============================================================================
   531→// SETTINGS MANAGEMENT
   532→// ============================================================================
   533→
   534→const DEFAULT_SETTINGS = {
   535→    sensitivity: 50,
   536→    minSilenceLength: 0.5,
   537→    sourceIsolated: false,
   538→    enableTakesDetection: true,
   539→    enableJCut: false,
   540→    jcutLeadIn: 0.3,
   541→    jcutLeadOut: 0.2,
   542→    enableZoom: false,
   543→    zoomFrequency: 'medium',
   544→    zoomPreset: 'medium',
   545→    zoomPlacement: 'sentence_start',
   546→    enableChapters: false,
   547→    maxChapters: 10,
   548→    minChapterLength: 60,
   549→    enableProfanity: false,
   550→    profanityLanguage: 'en',
   551→    bleepType: 'standard',
   552→    // Authentication
   553→    customerId: null,
   554→    licenseKey: null,
   555→    accessToken: null,
   556→    refreshToken: null,
   557→    tokenExpiry: null,
   558→    // UI State
   559→    expandedOptions: false,
   560→    activePreset: 'podcast',
   561→    rememberOptions: false
   562→};
   563→
   564→// Current storage version for future migrations
   565→const SETTINGS_STORAGE_VERSION = 2;
   566→
   567→// Fields that contain sensitive data and should be encrypted
   568→const SENSITIVE_FIELDS = ['customerId', 'licenseKey', 'accessToken', 'refreshToken'];
   569→
   570→// ============================================================================
   571→// ENCRYPTION HELPERS FOR SENSITIVE DATA (CEP-CRIT-002 FIX)
   572→// Uses AES-GCM encryption via Web Crypto API for proper security
   573→// ============================================================================
   574→
   575→// Encryption constants
   576→const SPLICE_ENCRYPTION = {
   577→    ALGORITHM: 'AES-GCM',
   578→    KEY_LENGTH: 256,
   579→    IV_LENGTH: 12,
   580→    TAG_LENGTH: 128,
   581→    SALT: 'SPLICE_PANEL_SALT_v1', // Static salt for key derivation
   582→    ITERATIONS: 100000,
   583→    PREFIX: 'ENC:v1:'  // Prefix to identify encrypted values
   584→};
   585→
   586→// Cached encryption key (derived once per session)
   587→let _encryptionKey = null;
   588→
   589→/**
   590→ * Get or derive the encryption key from a machine-specific identifier
   591→ * Uses PBKDF2 to derive a strong key from available identifiers
   592→ * @returns {Promise<CryptoKey>} The derived encryption key
   593→ */
   594→async function getEncryptionKey() {
   595→    if (_encryptionKey) {
   596→        return _encryptionKey;
   597→    }
   598→
   599→    try {
   600→        // Use a combination of identifiers for key derivation
   601→        // In CEP, we use localStorage ID + app version as the key material
   602→        let keyMaterial = localStorage.getItem('splice_device_id');
   603→        if (!keyMaterial) {
   604→            // Generate a random device ID on first use
   605→            keyMaterial = crypto.randomUUID ? crypto.randomUUID() :
   606→                'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
   607→                    const r = Math.random() * 16 | 0;
   608→                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
   609→                    return v.toString(16);
   610→                });
   611→            localStorage.setItem('splice_device_id', keyMaterial);
   612→        }
   613→
   614→        const encoder = new TextEncoder();
   615→        const keyData = encoder.encode(keyMaterial + SPLICE_ENCRYPTION.SALT);
   616→
   617→        // Import the key material for PBKDF2
   618→        const baseKey = await crypto.subtle.importKey(
   619→            'raw',
   620→            keyData,
   621→            'PBKDF2',
   622→            false,
   623→            ['deriveKey']
   624→        );
   625→
   626→        // Derive the actual AES key
   627→        _encryptionKey = await crypto.subtle.deriveKey(
   628→            {
   629→                name: 'PBKDF2',
   630→                salt: encoder.encode(SPLICE_ENCRYPTION.SALT),
   631→                iterations: SPLICE_ENCRYPTION.ITERATIONS,
   632→                hash: 'SHA-256'
   633→            },
   634→            baseKey,
   635→            {
   636→                name: SPLICE_ENCRYPTION.ALGORITHM,
   637→                length: SPLICE_ENCRYPTION.KEY_LENGTH
   638→            },
   639→            false,
   640→            ['encrypt', 'decrypt']
   641→        );
   642→
   643→        return _encryptionKey;
   644→    } catch (e) {
   645→        debugLog('[Config] Key derivation error:', e);
   646→        return null;
   647→    }
   648→}
   649→
   650→/**
   651→ * Encrypt data for secure localStorage storage using AES-GCM
   652→ *
   653→ * @param {any} data - Data to encrypt
   654→ * @returns {Promise<string|null>} Encrypted string with prefix or null on error
   655→ */
   656→async function encryptForStorageAsync(data) {
   657→    try {
   658→        if (data === null || data === undefined) {
   659→            return null;
   660→        }
   661→
   662→        const key = await getEncryptionKey();
   663→        if (!key) {
   664→            // Fallback to legacy encoding if crypto not available
   665→            debugLog('[Config] Crypto not available, using legacy encoding');
   666→            return legacyEncode(data);
   667→        }
   668→
   669→        const encoder = new TextEncoder();
   670→        const jsonStr = JSON.stringify(data);
   671→        const plaintext = encoder.encode(jsonStr);
   672→
   673→        // Generate random IV
   674→        const iv = crypto.getRandomValues(new Uint8Array(SPLICE_ENCRYPTION.IV_LENGTH));
   675→
   676→        // Encrypt
   677→        const ciphertext = await crypto.subtle.encrypt(
   678→            {
   679→                name: SPLICE_ENCRYPTION.ALGORITHM,
   680→                iv: iv,
   681→                tagLength: SPLICE_ENCRYPTION.TAG_LENGTH
   682→            },
   683→            key,
   684→            plaintext
   685→        );
   686→
   687→        // Combine IV + ciphertext and encode as base64
   688→        const combined = new Uint8Array(iv.length + ciphertext.byteLength);
   689→        combined.set(iv);
   690→        combined.set(new Uint8Array(ciphertext), iv.length);
   691→
   692→        // Convert to base64 with prefix
   693→        const base64 = btoa(String.fromCharCode(...combined));
   694→        return SPLICE_ENCRYPTION.PREFIX + base64;
   695→    } catch (e) {
   696→        debugLog('[Config] Encryption error:', e);
   697→        return legacyEncode(data);
   698→    }
   699→}
   700→
   701→/**
   702→ * Decrypt data from localStorage using AES-GCM
   703→ *
   704→ * @param {string} data - Encrypted string
   705→ * @returns {Promise<any|null>} Decrypted data or null on error
   706→ */
   707→async function decryptFromStorageAsync(data) {
   708→    try {
   709→        if (!data || typeof data !== 'string') {
   710→            return null;
   711→        }
   712→
   713→        // Check if this is the new encrypted format
   714→        if (!data.startsWith(SPLICE_ENCRYPTION.PREFIX)) {
   715→            // Try legacy decoding for backward compatibility
   716→            return legacyDecode(data);
   717→        }
   718→
   719→        const key = await getEncryptionKey();
   720→        if (!key) {
   721→            debugLog('[Config] Crypto not available for decryption');
   722→            return null;
   723→        }
   724→
   725→        // Remove prefix and decode base64
   726→        const base64Data = data.slice(SPLICE_ENCRYPTION.PREFIX.length);
   727→        const combined = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));
   728→
   729→        // Extract IV and ciphertext
   730→        const iv = combined.slice(0, SPLICE_ENCRYPTION.IV_LENGTH);
   731→        const ciphertext = combined.slice(SPLICE_ENCRYPTION.IV_LENGTH);
   732→
   733→        // Decrypt
   734→        const plaintext = await crypto.subtle.decrypt(
   735→            {
   736→                name: SPLICE_ENCRYPTION.ALGORITHM,
   737→                iv: iv,
   738→                tagLength: SPLICE_ENCRYPTION.TAG_LENGTH
   739→            },
   740→            key,
   741→            ciphertext
   742→        );
   743→
   744→        const decoder = new TextDecoder();
   745→        const jsonStr = decoder.decode(plaintext);
   746→        return JSON.parse(jsonStr);
   747→    } catch (e) {
   748→        // Try legacy decoding as fallback
   749→        return legacyDecode(data);
   750→    }
   751→}
   752→
   753→/**
   754→ * Legacy encoding (Base64) for backward compatibility
   755→ * @param {any} data - Data to encode
   756→ * @returns {string|null} Encoded string
   757→ */
   758→function legacyEncode(data) {
   759→    try {
   760→        if (data === null || data === undefined) {
   761→            return null;
   762→        }
   763→        const jsonStr = JSON.stringify(data);
   764→        const encoded = encodeURIComponent(jsonStr);
   765→        return btoa(encoded);
   766→    } catch (e) {
   767→        return null;
   768→    }
   769→}
   770→
   771→/**
   772→ * Legacy decoding (Base64) for backward compatibility
   773→ * @param {string} data - Encoded string
   774→ * @returns {any|null} Decoded data
   775→ */
   776→function legacyDecode(data) {
   777→    try {
   778→        if (!data || typeof data !== 'string') {
   779→            return null;
   780→        }
   781→        // Skip if it has the encryption prefix
   782→        if (data.startsWith(SPLICE_ENCRYPTION.PREFIX)) {
   783→            return null;
   784→        }
   785→        const decoded = atob(data);
   786→        const jsonStr = decodeURIComponent(decoded);
   787→        return JSON.parse(jsonStr);
   788→    } catch (e) {
   789→        return null;
   790→    }
   791→}
   792→
   793→/**
   794→ * Synchronous wrapper for encryption (starts async operation)
   795→ * For backward compatibility with existing sync code
   796→ * @param {any} data - Data to encode
   797→ * @returns {string|null} Encoded string (legacy format until async completes)
   798→ */
   799→function encryptForStorage(data) {
   800→    // Return legacy encoding synchronously
   801→    // The async version should be preferred for new code
   802→    return legacyEncode(data);
   803→}
   804→
   805→/**
   806→ * Synchronous wrapper for decryption
   807→ * For backward compatibility with existing sync code
   808→ * @param {string} data - Encoded string
   809→ * @returns {any|null} Decoded data
   810→ */
   811→function decryptFromStorage(data) {
   812→    // Handle new encrypted format by returning null (needs async)
   813→    if (data && data.startsWith(SPLICE_ENCRYPTION.PREFIX)) {
   814→        debugLog('[Config] Encrypted data requires async decryption');
   815→        return null;
   816→    }
   817→    return legacyDecode(data);
   818→}
   819→
   820→/**
   821→ * Check if a value appears to be encrypted
   822→ *
   823→ * @param {any} value - Value to check
   824→ * @returns {boolean} True if value appears to be encrypted
   825→ */
   826→function isEncryptedValue(value) {
   827→    if (!value || typeof value !== 'string') {
   828→        return false;
   829→    }
   830→    // New encryption format
   831→    if (value.startsWith(SPLICE_ENCRYPTION.PREFIX)) {
   832→        return true;
   833→    }
   834→    // Unencrypted values typically start with known patterns
   835→    if (value.startsWith('cus_') || value.startsWith('SPLICE-')) {
   836→        return false;
   837→    }
   838→    // Check if it's legacy base64 encoded JSON
   839→    try {
   840→        const decoded = atob(value);
   841→        const jsonStr = decodeURIComponent(decoded);
   842→        JSON.parse(jsonStr);
   843→        return true;
   844→    } catch {
   845→        return false;
   846→    }
   847→}
   848→
   849→/**
   850→ * Encrypt sensitive fields in settings object
   851→ *
   852→ * @param {Object} settings - Settings object with plaintext sensitive fields
   853→ * @returns {Object} Settings with encrypted sensitive fields
   854→ */
   855→function encryptSensitiveFields(settings) {
   856→    const encrypted = { ...settings };
   857→
   858→    for (const field of SENSITIVE_FIELDS) {
   859→        if (encrypted[field] !== null && encrypted[field] !== undefined) {
   860→            // Only encrypt if not already encrypted
   861→            if (!isEncryptedValue(encrypted[field])) {
   862→                encrypted[field] = encryptForStorage(encrypted[field]);
   863→                debugLog(`[Config] Encrypted field: ${field}`);
   864→            }
   865→        }
   866→    }
   867→
   868→    return encrypted;
   869→}
   870→
   871→/**
   872→ * Decrypt sensitive fields in settings object
   873→ *
   874→ * @param {Object} settings - Settings object with encrypted sensitive fields
   875→ * @returns {Object} Settings with decrypted sensitive fields
   876→ */
   877→function decryptSensitiveFields(settings) {
   878→    const decrypted = { ...settings };
   879→
   880→    for (const field of SENSITIVE_FIELDS) {
   881→        if (decrypted[field] !== null && decrypted[field] !== undefined) {
   882→            // Check if it looks encrypted before attempting to decrypt
   883→            if (isEncryptedValue(decrypted[field])) {
   884→                const decryptedValue = decryptFromStorage(decrypted[field]);
   885→                if (decryptedValue !== null) {
   886→                    decrypted[field] = decryptedValue;
   887→                    debugLog(`[Config] Decrypted field: ${field}`);
   888→                }
   889→            }
   890→            // If not encrypted (legacy data), keep the original value
   891→        }
   892→    }
   893→
   894→    return decrypted;
   895→}
   896→
   897→/**
   898→ * Internal save function to avoid recursion during migration
   899→ * @private
   900→ */
   901→function _saveSettingsInternal(settings) {
   902→    try {
   903→        // Encrypt sensitive fields before storing
   904→        const toStore = encryptSensitiveFields(settings);
   905→
   906→        // Add version marker for future migrations
   907→        toStore._storageVersion = SETTINGS_STORAGE_VERSION;
   908→
   909→        localStorage.setItem('spliceSettings', JSON.stringify(toStore));
   910→        return true;
   911→    } catch (e) {
   912→        console.warn('[Config] Error saving settings:', e);
   913→        return false;
   914→    }
   915→}
   916→
   917→/**
   918→ * Get settings from localStorage
   919→ * Handles migration from unencrypted to encrypted storage format
   920→ */
   921→function getSettings() {
   922→    try {
   923→        const stored = localStorage.getItem('spliceSettings');
   924→        if (stored) {
   925→            const parsed = JSON.parse(stored);
   926→
   927→            // Decrypt sensitive fields (handles both encrypted and legacy unencrypted data)
   928→            const decrypted = decryptSensitiveFields(parsed);
   929→
   930→            // Check if migration is needed (no version marker = legacy data)
   931→            if (!parsed._storageVersion) {
   932→                // Migrate legacy data: save with encryption and version marker
   933→                debugLog('[Config] Migrating legacy settings to encrypted format');
   934→                const migratedSettings = { ...DEFAULT_SETTINGS, ...decrypted };
   935→                // Use internal save to avoid infinite recursion
   936→                _saveSettingsInternal(migratedSettings);
   937→            }
   938→
   939→            // Return merged settings without internal fields
   940→            const result = { ...DEFAULT_SETTINGS, ...decrypted };
   941→            delete result._storageVersion;
   942→            return result;
   943→        }
   944→    } catch (e) {
   945→        console.warn('[Config] Error loading settings:', e);
   946→    }
   947→    return { ...DEFAULT_SETTINGS };
   948→}
   949→
   950→/**
   951→ * Save settings to localStorage
   952→ * Encrypts sensitive fields before storing
   953→ */
   954→function saveSettings(settings) {
   955→    try {
   956→        // Get current settings (decrypted) and merge with new settings
   957→        const current = getSettings();
   958→        const merged = { ...current, ...settings };
   959→
   960→        return _saveSettingsInternal(merged);
   961→    } catch (e) {
   962→        console.warn('[Config] Error saving settings:', e);
   963→        return false;
   964→    }
   965→}
   966→
   967→/**
   968→ * Clear specific setting
   969→ */
   970→function clearSetting(key) {
   971→    const settings = getSettings();
   972→    delete settings[key];
   973→    _saveSettingsInternal(settings);
   974→}
   975→
   976→// ============================================================================
   977→// OFFLINE DETECTION
   978→// ============================================================================
   979→
   980→let isOnlineState = true;
   981→let offlineCheckInterval = null;
   982→
   983→/**
   984→ * Check if online
   985→ */
   986→function isOnline() {
   987→    return isOnlineState && navigator.onLine;
   988→}
   989→
   990→/**
   991→ * Initialize offline detection
   992→ */
   993→function initOfflineDetection() {
   994→    // Browser events
   995→    window.addEventListener('online', () => {
   996→        isOnlineState = true;
   997→        updateOfflineUI(true);
   998→    });
   999→
  1000→    window.addEventListener('offline', () => {
  1001→        isOnlineState = false;
  1002→        updateOfflineUI(false);
  1003→    });
  1004→
  1005→    // Periodic check
  1006→    offlineCheckInterval = setInterval(async () => {
  1007→        try {
  1008→            const response = await fetchWithTimeout(
  1009→                `${getBackendUrl()}/health`,
  1010→                { method: 'GET' },
  1011→                5000
  1012→            );
  1013→            isOnlineState = response.ok;
  1014→        } catch {
  1015→            isOnlineState = false;
  1016→        }
  1017→        updateOfflineUI(isOnlineState);
  1018→    }, 30000);
  1019→}
  1020→
  1021→/**
  1022→ * Update UI based on online state
  1023→ */
  1024→function updateOfflineUI(online) {
  1025→    const goBtn = document.getElementById('goBtn');
  1026→    const status = document.getElementById('status');
  1027→
  1028→    if (goBtn) {
  1029→        goBtn.disabled = !online;
  1030→    }
  1031→
  1032→    if (status) {
  1033→        if (!online) {
  1034→            status.textContent = 'Offline - Check your connection';
  1035→            status.style.color = '#dc3545';
  1036→        } else {
  1037→            // Reset status when back online
  1038→            status.textContent = 'Ready';
  1039→            status.style.color = '#888';
  1040→        }
  1041→    }
  1042→}
  1043→
  1044→// ============================================================================
  1045→// UTILITY FUNCTIONS
  1046→// ============================================================================
  1047→
  1048→/**
  1049→ * SECURITY: Escape HTML to prevent XSS attacks
  1050→ * Use this when inserting untrusted content into innerHTML
  1051→ * @param {string} str - String to escape
  1052→ * @returns {string} Escaped string safe for innerHTML
  1053→ */
  1054→function escapeHtml(str) {
  1055→    if (str === null || str === undefined) return '';
  1056→    if (typeof str !== 'string') str = String(str);
  1057→
  1058→    const escapeMap = {
  1059→        '&': '&amp;',
  1060→        '<': '&lt;',
  1061→        '>': '&gt;',
  1062→        '"': '&quot;',
  1063→        "'": '&#x27;',
  1064→        '/': '&#x2F;',
  1065→        '`': '&#x60;'
  1066→    };
  1067→
  1068→    return str.replace(/[&<>"'\/`]/g, char => escapeMap[char]);
  1069→}
  1070→
  1071→/**
  1072→ * SECURITY: Create safe HTML from template with escaped values
  1073→ * @param {TemplateStringsArray} strings - Template strings
  1074→ * @param {...any} values - Values to escape
  1075→ * @returns {string} HTML with escaped values
  1076→ */
  1077→function safeHtml(strings, ...values) {
  1078→    return strings.reduce((result, str, i) => {
  1079→        const value = values[i - 1];
  1080→        const escaped = escapeHtml(value);
  1081→        return result + escaped + str;
  1082→    });
  1083→}
  1084→
  1085→/**
  1086→ * Format time in MM:SS or HH:MM:SS
  1087→ */
  1088→function formatTime(seconds) {
  1089→    if (isNaN(seconds) || seconds < 0) return '0:00';
  1090→
  1091→    const hours = Math.floor(seconds / 3600);
  1092→    const minutes = Math.floor((seconds % 3600) / 60);
  1093→    const secs = Math.floor(seconds % 60);
  1094→
  1095→    if (hours > 0) {
  1096→        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  1097→    }
  1098→    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  1099→}
  1100→
  1101→/**
  1102→ * Set status message
  1103→ */
  1104→function setStatus(message, isError = false) {
  1105→    const status = document.getElementById('status');
  1106→    if (status) {
  1107→        status.textContent = message;
  1108→        status.style.color = isError ? '#dc3545' : '#888';
  1109→    }
  1110→}
  1111→
  1112→/**
  1113→ * Debounce function calls
  1114→ */
  1115→function debounce(func, wait) {
  1116→    let timeout;
  1117→    return function executedFunction(...args) {
  1118→        const later = () => {
  1119→            clearTimeout(timeout);
  1120→            func(...args);
  1121→        };
  1122→        clearTimeout(timeout);
  1123→        timeout = setTimeout(later, wait);
  1124→    };
  1125→}
  1126→
  1127→// ============================================================================
  1128→// PRESET PROFILES
  1129→// ============================================================================
  1130→
  1131→/**
  1132→ * Detection presets for different content types.
  1133→ * Each preset defines optimal settings for a specific use case.
  1134→ */
  1135→const PRESETS = {
  1136→    // Custom - user-defined settings (default)
  1137→    custom: {
  1138→        name: 'Custom',
  1139→        description: 'Your custom settings',
  1140→        icon: 'settings',
  1141→        settings: null // Uses current user settings
  1142→    },
  1143→
  1144→    // Podcast - longer pauses are natural, be conservative
  1145→    podcast: {
  1146→        name: 'Podcast',
  1147→        description: 'Longer natural pauses, J-Cuts enabled',
  1148→        icon: 'mic',
  1149→        settings: {
  1150→            sensitivity: 35,
  1151→            threshold: -35,
  1152→            minSilenceLength: 0.8,
  1153→            paddingStart: 0.15,
  1154→            paddingEnd: 0.15,
  1155→            enableTakesDetection: true,
  1156→            enableJCut: true,
  1157→            jCutLeadIn: 0.3,
  1158→            jCutLeadOut: 0.2
  1159→        }
  1160→    },
  1161→
  1162→    // Interview - balanced, respects speaker pauses
  1163→    interview: {
  1164→        name: 'Interview',
  1165→        description: 'Balanced cuts, J-Cuts for smooth transitions',
  1166→        icon: 'people',
  1167→        settings: {
  1168→            sensitivity: 50,
  1169→            threshold: -32,
  1170→            minSilenceLength: 0.5,
  1171→            paddingStart: 0.12,
  1172→            paddingEnd: 0.08,
  1173→            enableTakesDetection: true,
  1174→            enableJCut: true,
  1175→            jCutLeadIn: 0.25,
  1176→            jCutLeadOut: 0.15
  1177→        }
  1178→    },
  1179→
  1180→    // Reaction video - fast pacing, quick cuts
  1181→    reaction: {
  1182→        name: 'Reaction',
  1183→        description: 'Fast-paced, tight cuts for energy',
  1184→        icon: 'bolt',
  1185→        settings: {
  1186→            sensitivity: 70,
  1187→            threshold: -28,
  1188→            minSilenceLength: 0.3,
  1189→            paddingStart: 0.05,
  1190→            paddingEnd: 0.03,
  1191→            enableTakesDetection: false,
  1192→            enableJCut: false,
  1193→            jCutLeadIn: 0,
  1194→            jCutLeadOut: 0
  1195→        }
  1196→    },
  1197→
  1198→    // Tutorial/Educational - preserve thinking pauses
  1199→    tutorial: {
  1200→        name: 'Tutorial',
  1201→        description: 'Preserves teaching pace, J-Cuts enabled',
  1202→        icon: 'school',
  1203→        settings: {
  1204→            sensitivity: 30,
  1205→            threshold: -38,
  1206→            minSilenceLength: 1.0,
  1207→            paddingStart: 0.2,
  1208→            paddingEnd: 0.15,
  1209→            enableTakesDetection: true,
  1210→            enableJCut: true,
  1211→            jCutLeadIn: 0.35,
  1212→            jCutLeadOut: 0.25
  1213→        }
  1214→    },
  1215→
  1216→    // Vlog/YouTube - punchy edits, engagement-focused
  1217→    vlog: {
  1218→        name: 'Vlog',
  1219→        description: 'Punchy edits for YouTube engagement',
  1220→        icon: 'videocam',
  1221→        settings: {
  1222→            sensitivity: 65,
  1223→            threshold: -30,
  1224→            minSilenceLength: 0.35,
  1225→            paddingStart: 0.08,
  1226→            paddingEnd: 0.05,
  1227→            enableTakesDetection: true,
  1228→            enableJCut: false,
  1229→            jCutLeadIn: 0,
  1230→            jCutLeadOut: 0
  1231→        }
  1232→    }
  1233→};
  1234→
  1235→/**
  1236→ * List of built-in preset IDs
  1237→ */
  1238→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];
  1239→
  1240→/**
  1241→ * Get all available presets
  1242→ * @returns {Object} All preset definitions
  1243→ */
  1244→function getPresets() {
  1245→    return { ...PRESETS };
  1246→}
  1247→
  1248→/**
  1249→ * Get a specific preset by name
  1250→ * @param {string} presetName - Name of the preset
  1251→ * @returns {Object|null} Preset definition or null if not found
  1252→ */
  1253→function getPreset(presetName) {
  1254→    return PRESETS[presetName] || null;
  1255→}
  1256→
  1257→/**
  1258→ * Check if a preset is a built-in preset
  1259→ * @param {string} id - Preset ID to check
  1260→ * @returns {boolean} True if built-in, false if custom
  1261→ */
  1262→function isBuiltInPreset(id) {
  1263→    return BUILT_IN_PRESET_IDS.includes(id);
  1264→}
  1265→
  1266→/**
  1267→ * Apply a preset to current settings
  1268→ * @param {string} presetName - Name of the preset to apply
  1269→ * @returns {Object} The applied settings
  1270→ */
  1271→function applyPreset(presetName) {
  1272→    const preset = PRESETS[presetName];
  1273→
  1274→    if (!preset) {
  1275→        console.warn(`[SPLICE] Unknown preset: ${presetName}`);
  1276→        return getSettings();
  1277→    }
  1278→
  1279→    // Custom preset uses current settings
  1280→    if (presetName === 'custom' || !preset.settings) {
  1281→        saveSettings({ activePreset: 'custom' });
  1282→        return getSettings();
  1283→    }
  1284→
  1285→    // Apply preset settings
  1286→    const newSettings = {
  1287→        ...preset.settings,
  1288→        activePreset: presetName
  1289→    };
  1290→
  1291→    saveSettings(newSettings);
  1292→    debugLog(`Applied preset: ${preset.name}`);
  1293→
  1294→    return getSettings();
  1295→}
  1296→
  1297→/**
  1298→ * Get the currently active preset
  1299→ * @returns {string} Active preset name
  1300→ */
  1301→function getActivePreset() {
  1302→    const settings = getSettings();
  1303→    return settings.activePreset || 'custom';
  1304→}
  1305→
  1306→/**
  1307→ * Initialize preset selector
  1308→ */
  1309→function initPresetSelector() {
  1310→    const presetSelector = document.getElementById('presetSelector');
  1311→    const sensitivitySlider = document.getElementById('sensitivitySlider');
  1312→
  1313→    if (!presetSelector) return;
  1314→
  1315→    // Set initial value from settings
  1316→    const settings = getSettings();
  1317→    presetSelector.value = settings.activePreset || 'podcast';
  1318→
  1319→    // Handle preset change
  1320→    presetSelector.addEventListener('change', () => {
  1321→        const presetId = presetSelector.value;
  1322→        const appliedSettings = applyPreset(presetId);
  1323→
  1324→        // Update sensitivity slider to match preset
  1325→        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {
  1326→            sensitivitySlider.value = appliedSettings.sensitivity;
  1327→            // Update display value
  1328→            const sensitivityValue = document.getElementById('sensitivityValue');
  1329→            if (sensitivityValue) {
  1330→                sensitivityValue.textContent = appliedSettings.sensitivity;
  1331→            }
  1332→        }
  1333→
  1334→        // Update takes detection checkbox
  1335→        const enableTakesDetection = document.getElementById('enableTakesDetection');
  1336→        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {
  1337→            enableTakesDetection.checked = appliedSettings.enableTakesDetection;
  1338→        }
  1339→
  1340→        // Update J-Cut checkbox
  1341→        const enableJCut = document.getElementById('enableJCut');
  1342→        if (enableJCut && appliedSettings.enableJCut !== undefined) {
  1343→            enableJCut.checked = appliedSettings.enableJCut;
  1344→            // Toggle J-Cut settings visibility
  1345→            const jcutSettings = document.getElementById('jcutSettings');
  1346→            if (jcutSettings) {
  1347→                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);
  1348→            }
  1349→        }
  1350→
  1351→        const preset = getPreset(presetId);
  1352→        if (preset) {
  1353→            setStatus(`Preset: ${preset.name} - ${preset.description}`);
  1354→        }
  1355→    });
  1356→
  1357→    // Switch to custom when user manually changes sensitivity
  1358→    if (sensitivitySlider) {
  1359→        sensitivitySlider.addEventListener('change', () => {
  1360→            if (presetSelector.value !== 'custom') {
  1361→                presetSelector.value = 'custom';
  1362→                saveSettings({ activePreset: 'custom' });
  1363→            }
  1364→        });
  1365→    }
  1366→}
  1367→
  1368→// ============================================================================
  1369→// LOGIN MODAL
  1370→// ============================================================================
  1371→
  1372→/**
  1373→ * Validate license key format: SPLICE-XXXX-XXXX-XXXX
  1374→ * Character set excludes confusing chars: 0/O, 1/I/L
  1375→ */
  1376→function isValidLicenseKeyFormat(key) {
  1377→    if (!key || typeof key !== 'string') return false;
  1378→    const normalized = key.toUpperCase().trim();
  1379→    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;
  1380→    return pattern.test(normalized);
  1381→}
  1382→
  1383→/**
  1384→ * Initialize login modal handlers
  1385→ */
  1386→function initLoginModal() {
  1387→    const loginModal = document.getElementById('loginModal');
  1388→    const closeLoginBtn = document.getElementById('closeLoginBtn');
  1389→    const saveLoginBtn = document.getElementById('saveLoginBtn');
  1390→    const licenseKeyInput = document.getElementById('licenseKeyInput');
  1391→    const creditBadge = document.getElementById('creditBadge');
  1392→
  1393→    // Handle credit badge click - retry on error, or show login modal
  1394→    if (creditBadge) {
  1395→        creditBadge.addEventListener('click', async () => {
  1396→            if (creditBadge.classList.contains('error')) {
  1397→                creditBadge.textContent = '...';
  1398→                if (typeof refreshCredits === 'function') {
  1399→                    await refreshCredits();
  1400→                }
  1401→                return;
  1402→            }
  1403→            showLoginModal();
  1404→        });
  1405→    }
  1406→
  1407→    // Close login modal
  1408→    if (closeLoginBtn && loginModal) {
  1409→        closeLoginBtn.addEventListener('click', () => {
  1410→            loginModal.classList.add('hidden');
  1411→        });
  1412→    }
  1413→
  1414→    // Close on backdrop click
  1415→    if (loginModal) {
  1416→        loginModal.addEventListener('click', (e) => {
  1417→            if (e.target === loginModal) {
  1418→                loginModal.classList.add('hidden');
  1419→            }
  1420→        });
  1421→    }
  1422→
  1423→    // Activate license key
  1424→    if (saveLoginBtn) {
  1425→        saveLoginBtn.addEventListener('click', async () => {
  1426→            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();
  1427→
  1428→            if (!licenseKey) {
  1429→                showLoginError('Please enter your license key');
  1430→                return;
  1431→            }
  1432→
  1433→            if (!isValidLicenseKeyFormat(licenseKey)) {
  1434→                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');
  1435→                return;
  1436→            }
  1437→
  1438→            saveLoginBtn.disabled = true;
  1439→            saveLoginBtn.textContent = 'Activating...';
  1440→
  1441→            try {
  1442→                // Use /auth/login endpoint which returns JWT tokens
  1443→                const response = await fetchWithTimeout(`${getBackendUrl()}/auth/login`, {
  1444→                    method: 'POST',
  1445→                    headers: { 'Content-Type': 'application/json' },
  1446→                    body: JSON.stringify({ licenseKey: licenseKey })
  1447→                }, SPLICE_CONFIG.FETCH_TIMEOUT);
  1448→
  1449→                const result = await response.json();
  1450→
  1451→                if (!result.success) {
  1452→                    showLoginError(result.error || 'Activation failed');
  1453→                    return;
  1454→                }
  1455→
  1456→                // Store JWT tokens and customer info
  1457→                const expiresInMs = (result.expiresIn || 86400) * 1000; // Default 24h
  1458→                saveSettings({
  1459→                    customerId: result.customerId,
  1460→                    accessToken: result.token,
  1461→                    refreshToken: result.refreshToken,
  1462→                    tokenExpiry: Date.now() + expiresInMs,
  1463→                    licenseKey: licenseKey // Keep for re-authentication
  1464→                });
  1465→
  1466→                loginModal?.classList.add('hidden');
  1467→
  1468→                if (typeof refreshCredits === 'function') {
  1469→                    await refreshCredits();
  1470→                }
  1471→
  1472→                const tierName = result.tier ? result.tier.charAt(0).toUpperCase() + result.tier.slice(1) : 'Unknown';
  1473→                setStatus(`License activated! ${tierName} tier`);
  1474→            } catch (err) {
  1475→                console.error('[SPLICE] License activation error:', err);
  1476→
  1477→                // DIAGNOSTIC LOGGING: Capture exact error details (debug mode only)
  1478→                debugLog('=== CEP LICENSE ACTIVATION ERROR DIAGNOSTICS ===');
  1479→                debugLog('Error name:', err?.name);
  1480→                debugLog('Error message:', err?.message);
  1481→                debugLog('Error stack:', err?.stack);
  1482→                debugLog('Backend URL:', getBackendUrl());
  1483→                debugLog('Fetch timeout:', SPLICE_CONFIG.FETCH_TIMEOUT);
  1484→                debugLog('Is CEP environment:', typeof CSInterface !== 'undefined');
  1485→                debugLog('User agent:', navigator?.userAgent);
  1486→                debugLog('Error constructor:', err?.constructor?.name);
  1487→                debugLog('Is TypeError:', err?.name === 'TypeError');
  1488→                debugLog('Message contains "Failed to fetch":', err?.message?.includes('Failed to fetch'));
  1489→                debugLog('Message contains "fetch":', err?.message?.toLowerCase()?.includes('fetch'));
  1490→                debugLog('Message contains "network":', err?.message?.toLowerCase()?.includes('network'));
  1491→                debugLog('Message contains "CORS":', err?.message?.toLowerCase()?.includes('cors'));
  1492→                debugLog('Message contains "SSL":', err?.message?.toLowerCase()?.includes('ssl'));
  1493→                debugLog('Message contains "certificate":', err?.message?.toLowerCase()?.includes('certificate'));
  1494→                debugLog('Full error object:', JSON.stringify(err, Object.getOwnPropertyNames(err)));
  1495→                debugLog('================================================');
  1496→
  1497→                // Provide detailed error message based on error type
  1498→                let errorMessage = 'Connection error. ';
  1499→
  1500→                if (err.message === 'Request timed out') {
  1501→                    errorMessage += 'Server is not responding. Check if backend is running.';
  1502→                } else if (err.message?.includes('Failed to fetch') || err.name === 'TypeError') {
  1503→                    errorMessage += `Cannot reach ${getBackendUrl()}. Check network/firewall.`;
  1504→                } else if (err.message?.includes('CORS')) {
  1505→                    errorMessage += 'CORS error. Contact support.';
  1506→                } else if (err.message?.includes('SSL') || err.message?.includes('certificate')) {
  1507→                    errorMessage += 'SSL certificate error. Try updating your system certificates.';
  1508→                } else if (err.message) {
  1509→                    errorMessage += err.message;
  1510→                } else {
  1511→                    errorMessage += 'Unknown error. Check console for details.';
  1512→                }
  1513→
  1514→                debugLog('Final error message shown to user:', errorMessage);
  1515→                showLoginError(errorMessage);
  1516→            } finally {
  1517→                saveLoginBtn.disabled = false;
  1518→                saveLoginBtn.textContent = 'Activate';
  1519→            }
  1520→        });
  1521→    }
  1522→
  1523→    // Email lookup
  1524→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');
  1525→    const lookupEmailInput = document.getElementById('lookupEmailInput');
  1526→
  1527→    if (lookupLicenseBtn) {
  1528→        lookupLicenseBtn.addEventListener('click', async () => {
  1529→            const email = lookupEmailInput?.value?.trim()?.toLowerCase();
  1530→
  1531→            if (!email) {
  1532→                showLoginError('Please enter your email address');
  1533→                return;
  1534→            }
  1535→
  1536→            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  1537→            if (!emailRegex.test(email)) {
  1538→                showLoginError('Please enter a valid email address');
  1539→                return;
  1540→            }
  1541→
  1542→            lookupLicenseBtn.disabled = true;
  1543→            lookupLicenseBtn.textContent = 'Looking up...';
  1544→
  1545→            try {
  1546→                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {
  1547→                    method: 'POST',
  1548→                    headers: { 'Content-Type': 'application/json' },
  1549→                    body: JSON.stringify({ email })
  1550→                }, 30000);
  1551→
  1552→                const result = await response.json();
  1553→
  1554→                // Note: For security, the backend does NOT return the license key directly.
  1555→                // It sends the key via email to prevent enumeration attacks.
  1556→                if (result.success) {
  1557→                    setStatus(result.message || 'If a license exists, it will be sent to your email.');
  1558→                } else {
  1559→                    showLoginError(result.error || 'Lookup failed. Please try again.');
  1560→                }
  1561→            } catch (err) {
  1562→                console.error('[SPLICE] License lookup error:', err);
  1563→                showLoginError('Failed to look up license. Please try again.');
  1564→            } finally {
  1565→                lookupLicenseBtn.disabled = false;
  1566→                lookupLicenseBtn.textContent = 'Lookup';
  1567→            }
  1568→        });
  1569→    }
  1570→
  1571→    // Handle external URL buttons
  1572→    // CEP panels cannot use target="_blank" for security reasons.
  1573→    // Must use CSInterface.openURLInDefaultBrowser() instead.
  1574→    initExternalLinkButtons();
  1575→}
  1576→
  1577→/**
  1578→ * Initialize all external link buttons that need CSInterface.openURLInDefaultBrowser()
  1579→ * CEP panels cannot use target="_blank" due to security restrictions
  1580→ */
  1581→function initExternalLinkButtons() {
  1582→    // Check if CSInterface is available
  1583→    if (typeof CSInterface === 'undefined') {
  1584→        console.warn('[SPLICE] CSInterface not available - external links disabled');
  1585→        return;
  1586→    }
  1587→
  1588→    let cs;
  1589→    try {
  1590→        cs = new CSInterface();
  1591→    } catch (e) {
  1592→        console.warn('[SPLICE] Failed to create CSInterface:', e.message);
  1593→        return;
  1594→    }
  1595→
  1596→    // Buy a License button
  1597→    const buyLicenseBtn = document.querySelector('.btn-buy-license');
  1598→
  1599→    if (buyLicenseBtn) {
  1600→        buyLicenseBtn.addEventListener('click', (e) => {
  1601→            e.preventDefault();
  1602→            e.stopPropagation();
  1603→
  1604→            // Visual feedback
  1605→            buyLicenseBtn.textContent = 'Opening...';
  1606→            buyLicenseBtn.style.backgroundColor = '#28a745';
  1607→
  1608→            try {
  1609→                cs.openURLInDefaultBrowser('https://spliceclips.com/pricing');
  1610→
  1611→                // Reset button after a delay
  1612→                setTimeout(() => {
  1613→                    buyLicenseBtn.textContent = 'Buy License';
  1614→                    buyLicenseBtn.style.backgroundColor = '';
  1615→                }, 2000);
  1616→            } catch (err) {
  1617→                console.error('[SPLICE] Failed to open URL:', err.message);
  1618→                buyLicenseBtn.textContent = 'Error';
  1619→                buyLicenseBtn.style.backgroundColor = '#dc3545';
  1620→            }
  1621→        });
  1622→    }
  1623→    
  1624→    // View Plans button (in upgrade modal)
  1625→    const viewPlansBtn = document.querySelector('.btn-view-plans');
  1626→    if (viewPlansBtn) {
  1627→        viewPlansBtn.addEventListener('click', (e) => {
  1628→            e.preventDefault();
  1629→            e.stopPropagation();
  1630→            const url = viewPlansBtn.dataset.url || 'https://spliceclips.com/pricing';
  1631→            cs.openURLInDefaultBrowser(url);
  1632→        });
  1633→    }
  1634→    
  1635→    // Referral link button
  1636→    const referralBtn = document.querySelector('.btn-referral');
  1637→    if (referralBtn) {
  1638→        referralBtn.addEventListener('click', (e) => {
  1639→            e.preventDefault();
  1640→            e.stopPropagation();
  1641→            const url = referralBtn.dataset.url || 'https://splice.video/referrals';
  1642→            cs.openURLInDefaultBrowser(url);
  1643→        });
  1644→    }
  1645→}
  1646→
  1647→/**
  1648→ * Show login modal
  1649→ */
  1650→function showLoginModal() {
  1651→    const loginModal = document.getElementById('loginModal');
  1652→    const loginError = document.getElementById('loginError');
  1653→    if (loginError) loginError.style.display = 'none';
  1654→    if (loginModal) loginModal.classList.remove('hidden');
  1655→}
  1656→
  1657→/**
  1658→ * Show login error message
  1659→ */
  1660→function showLoginError(message) {
  1661→    const loginError = document.getElementById('loginError');
  1662→    if (loginError) {
  1663→        loginError.textContent = message;
  1664→        loginError.style.display = 'block';
  1665→    }
  1666→}
  1667→
  1668→/**
  1669→ * Check if user is logged in
  1670→ */
  1671→function isLoggedIn() {
  1672→    const settings = getSettings();
  1673→    return !!settings.customerId;
  1674→}
  1675→
  1676→/**
  1677→ * Logout - clear all auth data
  1678→ */
  1679→function logout() {
  1680→    // Clear all auth-related settings
  1681→    saveSettings({
  1682→        customerId: null,
  1683→        accessToken: null,
  1684→        refreshToken: null,
  1685→        tokenExpiry: null,
  1686→        licenseKey: null
  1687→    });
  1688→
  1689→    if (typeof clearCreditsCache === 'function') {
  1690→        clearCreditsCache();
  1691→    }
  1692→    if (typeof updateCreditDisplay === 'function') {
  1693→        updateCreditDisplay(null);
  1694→    }
  1695→    setStatus('Logged out');
  1696→}
  1697→
  1698→// ============================================================================
  1699→// CENTRALIZED ERROR LOGGING (FIX: CEP-ERR-007)
  1700→// Captures errors for debugging across different Mac configurations
  1701→// ============================================================================
  1702→
  1703→/**
  1704→ * Error log storage - persisted to localStorage for debugging
  1705→ * Stores the last 50 errors with timestamps and context
  1706→ */
  1707→const ERROR_LOG_KEY = 'spliceErrorLog';
  1708→const MAX_ERROR_LOG_SIZE = 50;
  1709→
  1710→/**
  1711→ * Log an error with context for debugging
  1712→ * FIX: CEP-ERR-007 - Centralized error capture for debugging crashes
  1713→ *
  1714→ * @param {string} module - Module name (e.g., 'JSX', 'Silence', 'Takes')
  1715→ * @param {string} operation - Operation that failed
  1716→ * @param {Error|string} error - Error object or message
  1717→ * @param {Object} context - Additional context for debugging
  1718→ */
  1719→function logError(module, operation, error, context = {}) {
  1720→    const errorEntry = {
  1721→        timestamp: new Date().toISOString(),
  1722→        module,
  1723→        operation,
  1724→        message: error?.message || String(error),
  1725→        stack: error?.stack || null,
  1726→        code: error?.code || null,
  1727→        context: {
  1728→            ...context,
  1729→            userAgent: navigator?.userAgent,
  1730→            isCEP: typeof window.__adobe_cep__ !== 'undefined',
  1731→            isOnline: navigator?.onLine
  1732→        }
  1733→    };
  1734→
  1735→    // Log to console
  1736→    console.error(`[SPLICE ${module}] ${operation}:`, error);
  1737→    if (SPLICE_DEBUG) {
  1738→        console.error('[SPLICE ERROR CONTEXT]', errorEntry);
  1739→    }
  1740→
  1741→    // Persist to localStorage for later debugging
  1742→    try {
  1743→        let errorLog = [];
  1744→        const stored = localStorage.getItem(ERROR_LOG_KEY);
  1745→        if (stored) {
  1746→            errorLog = JSON.parse(stored);
  1747→        }
  1748→
  1749→        // Add new error and trim to max size
  1750→        errorLog.unshift(errorEntry);
  1751→        if (errorLog.length > MAX_ERROR_LOG_SIZE) {
  1752→            errorLog = errorLog.slice(0, MAX_ERROR_LOG_SIZE);
  1753→        }
  1754→
  1755→        localStorage.setItem(ERROR_LOG_KEY, JSON.stringify(errorLog));
  1756→    } catch (e) {
  1757→        // Silent fail - localStorage might be full or unavailable
  1758→        console.warn('[SPLICE] Failed to persist error log:', e);
  1759→    }
  1760→
  1761→    return errorEntry;
  1762→}
  1763→
  1764→/**
  1765→ * Get the stored error log for debugging
  1766→ * @returns {Array} Array of error entries
  1767→ */
  1768→function getErrorLog() {
  1769→    try {
  1770→        const stored = localStorage.getItem(ERROR_LOG_KEY);
  1771→        return stored ? JSON.parse(stored) : [];
  1772→    } catch (e) {
  1773→        return [];
  1774→    }
  1775→}
  1776→
  1777→/**
  1778→ * Clear the error log
  1779→ */
  1780→function clearErrorLog() {
  1781→    try {
  1782→        localStorage.removeItem(ERROR_LOG_KEY);
  1783→    } catch (e) {
  1784→        // Silent fail
  1785→    }
  1786→}
  1787→
  1788→/**
  1789→ * Format error log for display or copy
  1790→ * @returns {string} Formatted error log text
  1791→ */
  1792→function formatErrorLog() {
  1793→    const log = getErrorLog();
  1794→    if (log.length === 0) {
  1795→        return 'No errors logged.';
  1796→    }
  1797→
  1798→    return log.map((entry, i) => {
  1799→        return [
  1800→            `--- Error ${i + 1} ---`,
  1801→            `Time: ${entry.timestamp}`,
  1802→            `Module: ${entry.module}`,
  1803→            `Operation: ${entry.operation}`,
  1804→            `Message: ${entry.message}`,
  1805→            entry.code ? `Code: ${entry.code}` : null,
  1806→            entry.stack ? `Stack: ${entry.stack}` : null,
  1807→            `CEP: ${entry.context?.isCEP ? 'Yes' : 'No'}`,
  1808→            `Online: ${entry.context?.isOnline ? 'Yes' : 'No'}`,
  1809→            ''
  1810→        ].filter(Boolean).join('\n');
  1811→    }).join('\n');
  1812→}
  1813→
  1814→// ============================================================================
  1815→// GLOBAL ERROR HANDLERS (FIX: CEP-ERR-008)
  1816→// Catch unhandled errors and promise rejections
  1817→// ============================================================================
  1818→
  1819→/**
  1820→ * Global error handler for uncaught exceptions
  1821→ */
  1822→window.addEventListener('error', (event) => {
  1823→    logError('Global', 'Uncaught Exception', event.error || event.message, {
  1824→        filename: event.filename,
  1825→        lineno: event.lineno,
  1826→        colno: event.colno
  1827→    });
  1828→});
  1829→
  1830→/**
  1831→ * Global handler for unhandled promise rejections
  1832→ */
  1833→window.addEventListener('unhandledrejection', (event) => {
  1834→    logError('Global', 'Unhandled Promise Rejection', event.reason, {
  1835→        promise: 'rejected'
  1836→    });
  1837→});
  1838→
  1839→// Initialize JSX bridge when loaded
  1840→document.addEventListener('DOMContentLoaded', () => {
  1841→    jsx.init();
  1842→});
  1843→
  1844→// Export for modules
  1845→window.SPLICE_CONFIG = SPLICE_CONFIG;
  1846→window.SPLICE_DEBUG = SPLICE_DEBUG;
  1847→window.JSX_TIMEOUTS = JSX_TIMEOUTS;  // FIX: CEP-CRIT-001 - Export timeout constants
  1848→window.debugLog = debugLog;
  1849→window.debugFetch = debugFetch;
  1850→window.getBackendUrl = getBackendUrl;
  1851→window.fetchWithTimeout = fetchWithTimeout;
  1852→window.parseErrorResponse = parseErrorResponse;
  1853→window.getAuthHeaders = getAuthHeaders;
  1854→window.getSettings = getSettings;
  1855→window.saveSettings = saveSettings;
  1856→window.clearSetting = clearSetting;
  1857→window.isOnline = isOnline;
  1858→window.initOfflineDetection = initOfflineDetection;
  1859→window.formatTime = formatTime;
  1860→window.setStatus = setStatus;
  1861→window.debounce = debounce;
  1862→window.jsx = jsx;
  1863→window.PRESETS = PRESETS;
  1864→window.getPresets = getPresets;
  1865→window.getPreset = getPreset;
  1866→window.applyPreset = applyPreset;
  1867→window.getActivePreset = getActivePreset;
  1868→window.isBuiltInPreset = isBuiltInPreset;
  1869→window.initPresetSelector = initPresetSelector;
  1870→window.initLoginModal = initLoginModal;
  1871→window.showLoginModal = showLoginModal;
  1872→window.isLoggedIn = isLoggedIn;
  1873→window.logout = logout;
  1874→window.escapeHtml = escapeHtml;
  1875→window.safeHtml = safeHtml;
  1876→// JWT Auth functions
  1877→window.isTokenExpired = isTokenExpired;
  1878→window.refreshAccessToken = refreshAccessToken;
  1879→window.clearAuthTokens = clearAuthTokens;
  1880→window.ensureValidToken = ensureValidToken;
  1881→// Error logging functions (FIX: CEP-ERR-007)
  1882→window.logError = logError;
  1883→window.getErrorLog = getErrorLog;
  1884→window.clearErrorLog = clearErrorLog;
  1885→window.formatErrorLog = formatErrorLog;
  1886→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
