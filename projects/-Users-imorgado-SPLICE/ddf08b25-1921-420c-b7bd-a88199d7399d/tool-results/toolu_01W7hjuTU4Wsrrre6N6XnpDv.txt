     1→/**
     2→ * SPLICE CEP Panel - Multitrack UI Module
     3→ * Multi-speaker analysis, auto-balance, and timeline building
     4→ * v4.0.0 - CEP Migration
     5→ */
     6→
     7→// ============================================================================
     8→// STATE
     9→// ============================================================================
    10→let speakerConfig = [];
    11→let analysisResults = null;
    12→let analysisSequenceId = null;  // FIX: CEP-CRIT-014 - Track sequence ID for validation
    13→let isMultitrackOperationInProgress = false;
    14→
    15→// Speaker colors for visual distinction
    16→const SPEAKER_COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
    17→
    18→// ============================================================================
    19→// DOM ELEMENT CACHE
    20→// ============================================================================
    21→const multitrackUI = {};
    22→
    23→function cacheMultitrackElements() {
    24→    multitrackUI.section = document.getElementById('multitrackSection');
    25→    multitrackUI.toggle = document.getElementById('multitrackToggle');
    26→    multitrackUI.panel = document.getElementById('multitrackPanel');
    27→    multitrackUI.speakerList = document.getElementById('speakerList');
    28→    multitrackUI.addSpeakerBtn = document.getElementById('addSpeakerBtn');
    29→    multitrackUI.wideShotTrack = document.getElementById('wideShotTrack');
    30→
    31→    // Parameters
    32→    multitrackUI.minShotDuration = document.getElementById('minShotDuration');
    33→    multitrackUI.minShotDurationValue = document.getElementById('minShotDurationValue');
    34→    multitrackUI.wideShotPercent = document.getElementById('wideShotPercent');
    35→    multitrackUI.wideShotPercentValue = document.getElementById('wideShotPercentValue');
    36→    multitrackUI.switchingFrequency = document.getElementById('switchingFrequency');
    37→    multitrackUI.switchingFrequencyValue = document.getElementById('switchingFrequencyValue');
    38→    multitrackUI.enableWideShotDetection = document.getElementById('enableWideShotDetection');
    39→
    40→    // Actions
    41→    multitrackUI.analyzeBtn = document.getElementById('analyzeMultitrackBtn');
    42→    multitrackUI.autoBalanceBtn = document.getElementById('autoBalanceBtn');
    43→    multitrackUI.applyBtn = document.getElementById('applyMultitrackBtn');
    44→
    45→    // Preview
    46→    multitrackUI.preview = document.getElementById('multitrackPreview');
    47→    multitrackUI.distributionChart = document.getElementById('distributionChart');
    48→    multitrackUI.speakerStats = document.getElementById('speakerStats');
    49→    multitrackUI.decisionCount = document.getElementById('decisionCount');
    50→    multitrackUI.decisionList = document.getElementById('decisionList');
    51→}
    52→
    53→// ============================================================================
    54→// INITIALIZATION
    55→// ============================================================================
    56→function initMultitrackUI() {
    57→    cacheMultitrackElements();
    58→
    59→    if (!multitrackUI.section) {
    60→        console.warn('[SPLICE Multitrack] Multitrack section not found in DOM');
    61→        return;
    62→    }
    63→
    64→    // Toggle section expand/collapse
    65→    if (multitrackUI.toggle) {
    66→        multitrackUI.toggle.addEventListener('click', toggleMultitrackSection);
    67→    }
    68→
    69→    // Add speaker button
    70→    if (multitrackUI.addSpeakerBtn) {
    71→        multitrackUI.addSpeakerBtn.addEventListener('click', addSpeaker);
    72→    }
    73→
    74→    // Speaker list event delegation (remove buttons, name changes)
    75→    if (multitrackUI.speakerList) {
    76→        multitrackUI.speakerList.addEventListener('click', handleSpeakerListClick);
    77→        multitrackUI.speakerList.addEventListener('change', handleSpeakerListChange);
    78→    }
    79→
    80→    // Parameter sliders
    81→    setupParameterListeners();
    82→
    83→    // Action buttons
    84→    if (multitrackUI.analyzeBtn) {
    85→        multitrackUI.analyzeBtn.addEventListener('click', analyzeMultitrack);
    86→    }
    87→    if (multitrackUI.autoBalanceBtn) {
    88→        multitrackUI.autoBalanceBtn.addEventListener('click', autoBalanceMultitrack);
    89→    }
    90→    if (multitrackUI.applyBtn) {
    91→        multitrackUI.applyBtn.addEventListener('click', applyMultitrackCuts);
    92→    }
    93→
    94→    // Decision list event delegation (seek buttons)
    95→    if (multitrackUI.decisionList) {
    96→        multitrackUI.decisionList.addEventListener('click', handleDecisionListClick);
    97→    }
    98→
    99→    // Initialize speaker config from DOM
   100→    initSpeakerConfigFromDOM();
   101→
   102→    console.log('[SPLICE Multitrack] UI initialized');
   103→}
   104→
   105→// ============================================================================
   106→// SECTION TOGGLE
   107→// ============================================================================
   108→function toggleMultitrackSection() {
   109→    if (!multitrackUI.panel || !multitrackUI.toggle) return;
   110→
   111→    // Check state BEFORE toggling
   112→    const wasCollapsed = multitrackUI.panel.classList.contains('collapsed');
   113→    multitrackUI.panel.classList.toggle('collapsed');
   114→    const icon = multitrackUI.toggle.querySelector('.toggle-icon');
   115→
   116→    if (icon) {
   117→        // If it was collapsed, it's now expanded (show -)
   118→        icon.textContent = wasCollapsed ? '-' : '+';
   119→    }
   120→}
   121→
   122→// ============================================================================
   123→// SPEAKER CONFIGURATION
   124→// ============================================================================
   125→function initSpeakerConfigFromDOM() {
   126→    speakerConfig = [];
   127→    const items = multitrackUI.speakerList?.querySelectorAll('.speaker-item') || [];
   128→
   129→    items.forEach((item, index) => {
   130→        const nameInput = item.querySelector('.speaker-name');
   131→        const trackSelect = item.querySelector('.speaker-track');
   132→
   133→        speakerConfig.push({
   134→            index,
   135→            name: nameInput?.value || `Speaker ${index + 1}`,
   136→            videoTrack: parseInt(trackSelect?.value || index)
   137→        });
   138→    });
   139→}
   140→
   141→function addSpeaker() {
   142→    if (speakerConfig.length >= 4) {
   143→        setStatus('Maximum 4 speakers supported');
   144→        return;
   145→    }
   146→
   147→    const newIndex = speakerConfig.length;
   148→    const defaultName = `Speaker ${newIndex + 1}`;
   149→
   150→    speakerConfig.push({
   151→        index: newIndex,
   152→        name: defaultName,
   153→        videoTrack: newIndex
   154→    });
   155→
   156→    // Add DOM element
   157→    // SECURITY: Escape dynamic content to prevent XSS
   158→    const speakerItem = document.createElement('div');
   159→    speakerItem.className = `speaker-item speaker-${newIndex}`;
   160→    speakerItem.dataset.speakerIndex = newIndex;
   161→    speakerItem.innerHTML = `
   162→        <input type="text" class="speaker-name" value="${escapeHtml(defaultName)}" placeholder="Name" aria-label="Speaker ${newIndex + 1} name">
   163→        <select class="speaker-track" aria-label="Speaker ${newIndex + 1} video track">
   164→            <option value="0" ${newIndex === 0 ? 'selected' : ''}>V1</option>
   165→            <option value="1" ${newIndex === 1 ? 'selected' : ''}>V2</option>
   166→            <option value="2" ${newIndex === 2 ? 'selected' : ''}>V3</option>
   167→            <option value="3" ${newIndex === 3 ? 'selected' : ''}>V4</option>
   168→        </select>
   169→        <button class="speaker-remove-btn" title="Remove speaker" aria-label="Remove speaker ${newIndex + 1}">x</button>
   170→    `;
   171→
   172→    multitrackUI.speakerList.appendChild(speakerItem);
   173→
   174→    // Update remove button visibility
   175→    updateRemoveButtonVisibility();
   176→}
   177→
   178→function removeSpeaker(index) {
   179→    if (speakerConfig.length <= 2) {
   180→        setStatus('Minimum 2 speakers required');
   181→        return;
   182→    }
   183→
   184→    speakerConfig.splice(index, 1);
   185→
   186→    // Remove from DOM
   187→    const item = multitrackUI.speakerList.querySelector(`[data-speaker-index="${index}"]`);
   188→    if (item) {
   189→        item.remove();
   190→    }
   191→
   192→    // Re-index remaining speakers
   193→    reindexSpeakers();
   194→
   195→    // Update remove button visibility
   196→    updateRemoveButtonVisibility();
   197→}
   198→
   199→function reindexSpeakers() {
   200→    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
   201→    items.forEach((item, i) => {
   202→        item.dataset.speakerIndex = i;
   203→        item.className = `speaker-item speaker-${i}`;
   204→
   205→        // Update speakerConfig
   206→        if (speakerConfig[i]) {
   207→            speakerConfig[i].index = i;
   208→        }
   209→    });
   210→}
   211→
   212→function updateRemoveButtonVisibility() {
   213→    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
   214→    const canRemove = items.length > 2;
   215→
   216→    items.forEach(item => {
   217→        const btn = item.querySelector('.speaker-remove-btn');
   218→        if (btn) {
   219→            btn.style.display = canRemove ? 'block' : 'none';
   220→        }
   221→    });
   222→}
   223→
   224→function handleSpeakerListClick(e) {
   225→    const removeBtn = e.target.closest('.speaker-remove-btn');
   226→    if (removeBtn) {
   227→        const item = removeBtn.closest('.speaker-item');
   228→        const index = parseInt(item?.dataset.speakerIndex || 0);
   229→        removeSpeaker(index);
   230→    }
   231→}
   232→
   233→function handleSpeakerListChange(e) {
   234→    const item = e.target.closest('.speaker-item');
   235→    if (!item) return;
   236→
   237→    const index = parseInt(item.dataset.speakerIndex || 0);
   238→
   239→    if (e.target.classList.contains('speaker-name')) {
   240→        speakerConfig[index].name = e.target.value;
   241→    } else if (e.target.classList.contains('speaker-track')) {
   242→        speakerConfig[index].videoTrack = parseInt(e.target.value);
   243→    }
   244→}
   245→
   246→// ============================================================================
   247→// PARAMETER LISTENERS
   248→// ============================================================================
   249→function setupParameterListeners() {
   250→    // Min shot duration slider
   251→    if (multitrackUI.minShotDuration && multitrackUI.minShotDurationValue) {
   252→        multitrackUI.minShotDuration.addEventListener('input', () => {
   253→            multitrackUI.minShotDurationValue.textContent =
   254→                parseFloat(multitrackUI.minShotDuration.value).toFixed(1) + 's';
   255→        });
   256→    }
   257→
   258→    // Wide shot percentage slider
   259→    if (multitrackUI.wideShotPercent && multitrackUI.wideShotPercentValue) {
   260→        multitrackUI.wideShotPercent.addEventListener('input', () => {
   261→            multitrackUI.wideShotPercentValue.textContent =
   262→                multitrackUI.wideShotPercent.value + '%';
   263→        });
   264→    }
   265→
   266→    // Switching frequency slider
   267→    if (multitrackUI.switchingFrequency && multitrackUI.switchingFrequencyValue) {
   268→        multitrackUI.switchingFrequency.addEventListener('input', () => {
   269→            multitrackUI.switchingFrequencyValue.textContent =
   270→                multitrackUI.switchingFrequency.value;
   271→        });
   272→    }
   273→}
   274→
   275→// ============================================================================
   276→// GET SETTINGS
   277→// ============================================================================
   278→function getMultitrackSettings() {
   279→    return {
   280→        minShotDuration: parseFloat(multitrackUI.minShotDuration?.value || 2),
   281→        wideShotPercentage: parseInt(multitrackUI.wideShotPercent?.value || 20),
   282→        switchingFrequency: parseInt(multitrackUI.switchingFrequency?.value || 50),
   283→        wideShotEnabled: multitrackUI.enableWideShotDetection?.checked ?? true,
   284→        wideShotTracks: multitrackUI.wideShotTrack?.value !== '-1'
   285→            ? [parseInt(multitrackUI.wideShotTrack.value)]
   286→            : [],
   287→        speakerNames: speakerConfig.map(s => s.name),
   288→        videoTrackMapping: speakerConfig.reduce((acc, s) => {
   289→            acc[s.index] = s.videoTrack;
   290→            return acc;
   291→        }, {})
   292→    };
   293→}
   294→
   295→// ============================================================================
   296→// GET AUDIO PATH (CEP VERSION)
   297→// ============================================================================
   298→async function getAudioPath() {
   299→    // FIX: CEP-CRIT-013 - Multitrack JSX Error Handling
   300→    try {
   301→        // Try to get audio path from active sequence (QUICK timeout)
   302→        const seqInfo = await jsx.callWithTimeout('getActiveSequence', [], JSX_TIMEOUTS.QUICK);
   303→        if (seqInfo && seqInfo.audioPath) {
   304→            return seqInfo.audioPath;
   305→        }
   306→
   307→        // Fallback: export sequence audio for analysis (LONG timeout)
   308→        const exportResult = await jsx.callWithTimeout(
   309→            'exportSequenceAudioForAnalysis',
   310→            [],
   311→            JSX_TIMEOUTS.LONG
   312→        );
   313→        if (exportResult && exportResult.path) {
   314→            return exportResult.path;
   315→        }
   316→
   317→        // Last resort: get first clip audio path (QUICK timeout)
   318→        const clipPath = await jsx.callWithTimeout('getFirstClipAudioPath', [], JSX_TIMEOUTS.QUICK);
   319→        if (clipPath) {
   320→            return clipPath;
   321→        }
   322→
   323→        throw new Error('Could not determine audio path from any source');
   324→    } catch (e) {
   325→        console.error('[SPLICE Multitrack] Failed to get audio path:', e);
   326→
   327→        // Provide actionable error message
   328→        if (e.code === 'JSX_TIMEOUT') {
   329→            throw new Error('Premiere Pro is not responding. Try closing other apps or restarting Premiere.');
   330→        } else if (e.message.includes('no sequence')) {
   331→            throw new Error('Please open a sequence in Premiere Pro first.');
   332→        } else {
   333→            throw new Error(`Audio export failed: ${e.message}`);
   334→        }
   335→    }
   336→}
   337→
   338→// ============================================================================
   339→// ANALYZE MULTITRACK
   340→// ============================================================================
   341→async function analyzeMultitrack() {
   342→    if (isMultitrackOperationInProgress) return;
   343→
   344→    // FIX: CEP-CRIT-012 - Multitrack Race Condition
   345→    // Set flag IMMEDIATELY to prevent double operations
   346→    isMultitrackOperationInProgress = true;
   347→
   348→    // Check tier access - Multitrack requires Team tier
   349→    if (typeof hasFeatureAccess === 'function' && !hasFeatureAccess('multitrack')) {
   350→        const requiredTier = typeof getRequiredTier === 'function' ? getRequiredTier('multitrack') : 'Team';
   351→        setStatus(`Multitrack auto-balance requires ${requiredTier} tier`);
   352→        if (typeof showUpgradeModal === 'function') {
   353→            showUpgradeModal('Multitrack Auto-Balance', requiredTier);
   354→        }
   355→        isMultitrackOperationInProgress = false;  // Reset flag on early return
   356→        return;
   357→    }
   358→
   359→    // Check online status
   360→    if (typeof isOnline === 'function' && !isOnline()) {
   361→        setStatus('Offline - Check your connection');
   362→        isMultitrackOperationInProgress = false;  // Reset flag on early return
   363→        return;
   364→    }
   365→    if (multitrackUI.analyzeBtn) {
   366→        multitrackUI.analyzeBtn.disabled = true;
   367→        multitrackUI.analyzeBtn.textContent = 'Analyzing...';
   368→    }
   369→
   370→    try {
   371→        setStatus('Exporting audio tracks...');
   372→
   373→        // FIX: CEP-CRIT-014 - Get sequence ID for validation
   374→        const seqInfo = await jsx.callWithTimeout('getActiveSequence', [], JSX_TIMEOUTS.QUICK);
   375→        const currentSequenceId = seqInfo?.id || seqInfo?.name || Date.now().toString();
   376→
   377→        // Get audio path
   378→        const audioPath = await getAudioPath();
   379→        if (!audioPath) {
   380→            throw new Error('Audio export path not initialized');
   381→        }
   382→
   383→        // For now, we use the main audio path
   384→        // In a full implementation, we'd export separate tracks per speaker
   385→        const audioPaths = [audioPath];
   386→
   387→        // Add additional tracks if multi-track sequence
   388→        if (speakerConfig.length > 1) {
   389→            for (let i = 1; i < speakerConfig.length; i++) {
   390→                audioPaths.push(audioPath);
   391→            }
   392→        }
   393→
   394→        setStatus('Analyzing speakers...');
   395→
   396→        const settings = getMultitrackSettings();
   397→        const apiUrl = getBackendUrl();
   398→
   399→        const response = await fetchWithTimeout(`${apiUrl}/multitrack`, {
   400→            method: 'POST',
   401→            headers: getAuthHeaders(),
   402→            body: JSON.stringify({
   403→                audioPaths,
   404→                speakerNames: settings.speakerNames,
   405→                videoTrackMapping: settings.videoTrackMapping,
   406→                wideShotEnabled: settings.wideShotEnabled,
   407→                wideShotPercentage: settings.wideShotPercentage,
   408→                wideShotTracks: settings.wideShotTracks,
   409→                minShotDuration: settings.minShotDuration,
   410→                switchingFrequency: settings.switchingFrequency
   411→            })
   412→        }, 120000);
   413→
   414→        if (!response.ok) {
   415→            const errorMsg = await parseErrorResponse(response);
   416→            throw new Error(errorMsg);
   417→        }
   418→
   419→        const data = await response.json();
   420→        analysisResults = data;
   421→        analysisSequenceId = currentSequenceId;  // FIX: CEP-CRIT-014 - Store sequence ID
   422→
   423→        // Display results
   424→        displayMultitrackResults(data);
   425→
   426→        // Enable apply button
   427→        if (multitrackUI.applyBtn) {
   428→            multitrackUI.applyBtn.disabled = false;
   429→        }
   430→
   431→        setStatus(`Analysis complete - ${data.decisions?.length || 0} switching decisions`);
   432→
   433→    } catch (err) {
   434→        console.error('[SPLICE Multitrack] Analysis error:', err);
   435→        setStatus('Analysis failed: ' + err.message, true);
   436→    } finally {
   437→        isMultitrackOperationInProgress = false;
   438→        if (multitrackUI.analyzeBtn) {
   439→            multitrackUI.analyzeBtn.disabled = false;
   440→            multitrackUI.analyzeBtn.textContent = 'Analyze';
   441→        }
   442→    }
   443→}
   444→
   445→// ============================================================================
   446→// AUTO-BALANCE
   447→// ============================================================================
   448→async function autoBalanceMultitrack() {
   449→    if (isMultitrackOperationInProgress) return;
   450→
   451→    // Check tier access - Multitrack requires Team tier
   452→    if (typeof hasFeatureAccess === 'function' && !hasFeatureAccess('multitrack')) {
   453→        const requiredTier = typeof getRequiredTier === 'function' ? getRequiredTier('multitrack') : 'Team';
   454→        setStatus(`Multitrack auto-balance requires ${requiredTier} tier`);
   455→        if (typeof showUpgradeModal === 'function') {
   456→            showUpgradeModal('Multitrack Auto-Balance', requiredTier);
   457→        }
   458→        return;
   459→    }
   460→
   461→    // Check online status
   462→    if (typeof isOnline === 'function' && !isOnline()) {
   463→        setStatus('Offline - Check your connection');
   464→        return;
   465→    }
   466→
   467→    isMultitrackOperationInProgress = true;
   468→    if (multitrackUI.autoBalanceBtn) {
   469→        multitrackUI.autoBalanceBtn.disabled = true;
   470→        multitrackUI.autoBalanceBtn.textContent = 'Balancing...';
   471→    }
   472→
   473→    try {
   474→        setStatus('Auto-balancing speaker screentime...');
   475→
   476→        const audioPath = await getAudioPath();
   477→        const audioPaths = [audioPath];
   478→
   479→        // Duplicate for multiple speakers
   480→        for (let i = 1; i < speakerConfig.length; i++) {
   481→            audioPaths.push(audioPath);
   482→        }
   483→
   484→        const settings = getMultitrackSettings();
   485→        const apiUrl = getBackendUrl();
   486→
   487→        const response = await fetchWithTimeout(`${apiUrl}/multitrack/auto-balance`, {
   488→            method: 'POST',
   489→            headers: getAuthHeaders(),
   490→            body: JSON.stringify({
   491→                audioPaths,
   492→                speakerNames: settings.speakerNames,
   493→                videoTrackMapping: settings.videoTrackMapping,
   494→                wideShotEnabled: settings.wideShotEnabled,
   495→                wideShotPercentage: settings.wideShotPercentage,
   496→                wideShotTracks: settings.wideShotTracks,
   497→                minShotDuration: settings.minShotDuration,
   498→                switchingFrequency: settings.switchingFrequency
   499→            })
   500→        }, 120000);
   501→
   502→        if (!response.ok) {
   503→            const errorMsg = await parseErrorResponse(response);
   504→            throw new Error(errorMsg);
   505→        }
   506→
   507→        const data = await response.json();
   508→        analysisResults = data;
   509→
   510→        // Display results
   511→        displayMultitrackResults(data);
   512→
   513→        // Enable apply button
   514→        if (multitrackUI.applyBtn) {
   515→            multitrackUI.applyBtn.disabled = false;
   516→        }
   517→
   518→        const errorInfo = data.finalError ? ` (${data.finalError.toFixed(1)}% deviation)` : '';
   519→        setStatus(`Auto-balance complete${errorInfo}`);
   520→
   521→    } catch (err) {
   522→        console.error('[SPLICE Multitrack] Auto-balance error:', err);
   523→        setStatus('Auto-balance failed: ' + err.message, true);
   524→    } finally {
   525→        isMultitrackOperationInProgress = false;
   526→        if (multitrackUI.autoBalanceBtn) {
   527→            multitrackUI.autoBalanceBtn.disabled = false;
   528→            multitrackUI.autoBalanceBtn.textContent = 'Auto-Balance';
   529→        }
   530→    }
   531→}
   532→
   533→// ============================================================================
   534→// DISPLAY RESULTS
   535→// ============================================================================
   536→function displayMultitrackResults(results) {
   537→    if (!results) return;
   538→
   539→    // Show preview section
   540→    if (multitrackUI.preview) {
   541→        multitrackUI.preview.classList.remove('hidden');
   542→    }
   543→
   544→    // Render distribution chart
   545→    renderDistributionChart(results.metadata);
   546→
   547→    // Render speaker stats
   548→    renderSpeakerStats(results.metadata);
   549→
   550→    // Render decision list
   551→    renderDecisionList(results.decisions || []);
   552→}
   553→
   554→function renderDistributionChart(metadata) {
   555→    if (!multitrackUI.distributionChart || !metadata) return;
   556→
   557→    const speakerPercentages = metadata.speakerPercentages || {};
   558→    const wideShotPct = metadata.wideShotPercentage || 0;
   559→
   560→    const fragment = document.createDocumentFragment();
   561→
   562→    // Add speaker bars
   563→    let speakerIndex = 0;
   564→    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
   565→        if (pct > 0) {
   566→            const bar = document.createElement('div');
   567→            bar.className = `distribution-bar speaker-${speakerIndex % 4}`;
   568→            bar.style.width = `${pct}%`;
   569→            bar.textContent = pct >= 10 ? `${speaker}: ${pct.toFixed(0)}%` : '';
   570→            bar.title = `${speaker}: ${pct.toFixed(1)}%`;
   571→            fragment.appendChild(bar);
   572→        }
   573→        speakerIndex++;
   574→    }
   575→
   576→    // Add wide shot bar
   577→    if (wideShotPct > 0) {
   578→        const bar = document.createElement('div');
   579→        bar.className = 'distribution-bar wide-shot';
   580→        bar.style.width = `${wideShotPct}%`;
   581→        bar.textContent = wideShotPct >= 8 ? `Wide: ${wideShotPct.toFixed(0)}%` : '';
   582→        bar.title = `Wide Shot: ${wideShotPct.toFixed(1)}%`;
   583→        fragment.appendChild(bar);
   584→    }
   585→
   586→    multitrackUI.distributionChart.innerHTML = '';
   587→    multitrackUI.distributionChart.appendChild(fragment);
   588→}
   589→
   590→function renderSpeakerStats(metadata) {
   591→    if (!multitrackUI.speakerStats || !metadata) return;
   592→
   593→    const speakerPercentages = metadata.speakerPercentages || {};
   594→    const wideShotPct = metadata.wideShotPercentage || 0;
   595→
   596→    const fragment = document.createDocumentFragment();
   597→
   598→    // Add speaker stats
   599→    // SECURITY: Escape speaker names to prevent XSS
   600→    let speakerIndex = 0;
   601→    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
   602→        const stat = document.createElement('div');
   603→        stat.className = 'speaker-stat';
   604→        stat.innerHTML = `
   605→            <span class="speaker-stat-dot speaker-${speakerIndex % 4}"></span>
   606→            <span>${escapeHtml(speaker)}: ${escapeHtml(pct.toFixed(1))}%</span>
   607→        `;
   608→        fragment.appendChild(stat);
   609→        speakerIndex++;
   610→    }
   611→
   612→    // Add wide shot stat
   613→    if (wideShotPct > 0) {
   614→        const stat = document.createElement('div');
   615→        stat.className = 'speaker-stat';
   616→        stat.innerHTML = `
   617→            <span class="speaker-stat-dot wide-shot"></span>
   618→            <span>Wide: ${escapeHtml(wideShotPct.toFixed(1))}%</span>
   619→        `;
   620→        fragment.appendChild(stat);
   621→    }
   622→
   623→    // Add avg shot duration
   624→    if (metadata.averageShotDuration) {
   625→        const stat = document.createElement('div');
   626→        stat.className = 'speaker-stat';
   627→        stat.innerHTML = `<span style="color: #888;">Avg: ${escapeHtml(metadata.averageShotDuration.toFixed(1))}s</span>`;
   628→        fragment.appendChild(stat);
   629→    }
   630→
   631→    multitrackUI.speakerStats.innerHTML = '';
   632→    multitrackUI.speakerStats.appendChild(fragment);
   633→}
   634→
   635→function renderDecisionList(decisions) {
   636→    if (!multitrackUI.decisionList) return;
   637→
   638→    // Update count
   639→    if (multitrackUI.decisionCount) {
   640→        multitrackUI.decisionCount.textContent = decisions.length;
   641→    }
   642→
   643→    const fragment = document.createDocumentFragment();
   644→
   645→    // Limit to first 50 for performance
   646→    const displayDecisions = decisions.slice(0, 50);
   647→
   648→    displayDecisions.forEach((decision, i) => {
   649→        const item = document.createElement('div');
   650→        item.className = 'decision-item';
   651→
   652→        const speakerClass = decision.isWideShot ? 'wide-shot' : '';
   653→        const startTime = formatTime(decision.startTime);
   654→        const endTime = formatTime(decision.endTime);
   655→
   656→        // SECURITY: Escape dynamic content to prevent XSS
   657→        item.innerHTML = `
   658→            <span class="decision-time">${escapeHtml(startTime)}-${escapeHtml(endTime)}</span>
   659→            <span class="decision-speaker ${speakerClass}">${escapeHtml(decision.speakerName)}</span>
   660→            <span class="decision-reason">${escapeHtml(decision.reason || '')}</span>
   661→            <button class="decision-seek" data-time="${escapeHtml(decision.startTime)}" title="Seek to ${escapeHtml(startTime)}" aria-label="Seek to ${escapeHtml(startTime)}">&gt;</button>
   662→        `;
   663→
   664→        fragment.appendChild(item);
   665→    });
   666→
   667→    if (decisions.length > 50) {
   668→        const more = document.createElement('div');
   669→        more.className = 'decision-item';
   670→        more.style.justifyContent = 'center';
   671→        more.style.color = '#888';
   672→        more.textContent = `+ ${decisions.length - 50} more decisions`;
   673→        fragment.appendChild(more);
   674→    }
   675→
   676→    multitrackUI.decisionList.innerHTML = '';
   677→    multitrackUI.decisionList.appendChild(fragment);
   678→}
   679→
   680→function handleDecisionListClick(e) {
   681→    const seekBtn = e.target.closest('.decision-seek');
   682→    if (seekBtn) {
   683→        e.stopPropagation();
   684→        const time = parseFloat(seekBtn.dataset.time);
   685→        if (!isNaN(time)) {
   686→            seekToTime(time);
   687→        }
   688→    }
   689→}
   690→
   691→// ============================================================================
   692→// SEEK TO TIME (CEP VERSION)
   693→// ============================================================================
   694→async function seekToTime(seconds) {
   695→    // FIX: CEP-CRIT-013 - Multitrack JSX Error Handling
   696→    try {
   697→        await jsx.callWithTimeout('seekToTime', [seconds], JSX_TIMEOUTS.QUICK);
   698→    } catch (e) {
   699→        console.warn('[SPLICE Multitrack] Failed to seek:', e);
   700→        // Don't show error to user - seeking is a nice-to-have feature
   701→    }
   702→}
   703→
   704→// ============================================================================
   705→// APPLY MULTITRACK CUTS
   706→// ============================================================================
   707→async function applyMultitrackCuts() {
   708→    if (!analysisResults || !analysisResults.decisions) {
   709→        setStatus('No analysis data. Run analysis first.');
   710→        return;
   711→    }
   712→
   713→    if (isMultitrackOperationInProgress) return;
   714→
   715→    isMultitrackOperationInProgress = true;
   716→    if (multitrackUI.applyBtn) {
   717→        multitrackUI.applyBtn.disabled = true;
   718→        multitrackUI.applyBtn.textContent = 'Applying...';
   719→    }
   720→
   721→    try {
   722→        setStatus('Building multitrack sequence...');
   723→
   724→        // Check if builder is available
   725→        if (!window.spliceBuilder) {
   726→            throw new Error('Builder not initialized');
   727→        }
   728→
   729→        // FIX: CEP-CRIT-013 - Multitrack JSX Error Handling
   730→        // Get active sequence info with timeout
   731→        const seqInfo = await jsx.callWithTimeout('getActiveSequence', [], JSX_TIMEOUTS.QUICK);
   732→        if (!seqInfo) {
   733→            throw new Error('No active sequence. Please open a sequence in Premiere Pro.');
   734→        }
   735→
   736→        // FIX: CEP-CRIT-014 - Validate sequence ID to prevent applying stale results
   737→        const currentSequenceId = seqInfo?.id || seqInfo?.name || Date.now().toString();
   738→        if (analysisSequenceId && currentSequenceId !== analysisSequenceId) {
   739→            throw new Error('Sequence has changed since analysis. Please re-run analysis on the current sequence.');
   740→        }
   741→
   742→        // Create cut list from decisions
   743→        const cutList = {
   744→            version: '3.5',
   745→            source: {
   746→                name: seqInfo.name,
   747→                path: seqInfo.treePath || seqInfo.name
   748→            },
   749→            segments: analysisResults.decisions.map(d => ({
   750→                type: d.isWideShot ? 'wide_shot' : (d.speakerIndex >= 0 ? 'speaker' : 'speech'),
   751→                sourceName: seqInfo.name,
   752→                sourcePath: seqInfo.treePath || seqInfo.name,
   753→                inPoint: d.startTime,
   754→                outPoint: d.endTime,
   755→                speaker: d.speakerName,
   756→                videoTrack: d.videoTrack,
   757→                colorHint: d.isWideShot ? 'yellow' :
   758→                    (d.speakerIndex === 0 ? 'mango' :
   759→                        d.speakerIndex === 1 ? 'caribbean' :
   760→                            d.speakerIndex === 2 ? 'lavender' : 'cerulean')
   761→            })),
   762→            metadata: {
   763→                isMultitrack: true,
   764→                speakerCount: speakerConfig.length,
   765→                decisionCount: analysisResults.decisions.length,
   766→                ...analysisResults.metadata
   767→            }
   768→        };
   769→
   770→        // Build sequence
   771→        const result = await window.spliceBuilder.buildSequenceFromCutList(cutList, {
   772→            suffix: '_MULTITRACK'
   773→        });
   774→
   775→        if (result.success) {
   776→            // Hide preview
   777→            if (multitrackUI.preview) {
   778→                multitrackUI.preview.classList.add('hidden');
   779→            }
   780→
   781→            setStatus(`Multitrack sequence created: ${result.stats?.clipsInserted || 0} clips`);
   782→
   783→            // FIX: CEP-CRIT-014 - Clear results and sequence ID
   784→            analysisResults = null;
   785→            analysisSequenceId = null;
   786→        } else {
   787→            throw new Error(result.error || 'Failed to build sequence');
   788→        }
   789→
   790→    } catch (err) {
   791→        console.error('[SPLICE Multitrack] Apply error:', err);
   792→        setStatus('Apply failed: ' + err.message, true);
   793→    } finally {
   794→        isMultitrackOperationInProgress = false;
   795→        if (multitrackUI.applyBtn) {
   796→            multitrackUI.applyBtn.disabled = true;
   797→            multitrackUI.applyBtn.textContent = 'Apply';
   798→        }
   799→    }
   800→}
   801→
   802→// ============================================================================
   803→// EXPORTS
   804→// ============================================================================
   805→// Expose for initialization from main.js
   806→if (typeof window !== 'undefined') {
   807→    window.initMultitrackUI = initMultitrackUI;
   808→    window.spliceMultitrack = {
   809→        init: initMultitrackUI,
   810→        analyze: analyzeMultitrack,
   811→        autoBalance: autoBalanceMultitrack,
   812→        apply: applyMultitrackCuts,
   813→        getSettings: getMultitrackSettings,
   814→        getResults: () => analysisResults
   815→    };
   816→}
   817→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
