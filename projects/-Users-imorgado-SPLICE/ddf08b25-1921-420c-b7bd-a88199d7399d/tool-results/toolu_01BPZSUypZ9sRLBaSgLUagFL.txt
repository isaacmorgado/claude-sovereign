     1→/**
     2→ * Slice 7: Apply Takes to Timeline (CEP Port)
     3→ *
     4→ * Timeline manipulation functions via JSX:
     5→ * - Label clips with take information
     6→ * - Delete non-best takes
     7→ *
     8→ * Port of UXP slice7-apply.js for CEP compatibility.
     9→ */
    10→
    11→/**
    12→ * Label clips on timeline with take information
    13→ * FIX: CEP-ERR-004 - Added comprehensive error handling for JSX calls
    14→ * @returns {Promise<number>} Number of clips labeled
    15→ */
    16→async function labelTakesOnTimeline() {
    17→    const takes = getCurrentTakes();
    18→
    19→    if (!takes || takes.length === 0) {
    20→        throw new Error('No takes to label');
    21→    }
    22→
    23→    // Check if sequence is open with timeout protection
    24→    let seqResult;
    25→    try {
    26→        seqResult = await jsx.callWithTimeout('getActiveSequence', [], JSX_TIMEOUTS.QUICK);
    27→        if (!seqResult || seqResult.error) {
    28→            throw new Error('No project or sequence open');
    29→        }
    30→    } catch (e) {
    31→        console.error('[SPLICE Takes] Failed to get active sequence:', e);
    32→        if (e.code === 'JSX_TIMEOUT') {
    33→            throw new Error('Premiere Pro is not responding. Try restarting the application.');
    34→        }
    35→        throw new Error('No project or sequence open: ' + e.message);
    36→    }
    37→
    38→    let labeledCount = 0;
    39→    let failCount = 0;
    40→
    41→    // Get clips from all video tracks
    42→    let numVideoTracks = 0;
    43→    try {
    44→        numVideoTracks = await jsx.callWithTimeout('getNumTracks', ['video'], JSX_TIMEOUTS.QUICK);
    45→    } catch (e) {
    46→        console.error('[SPLICE Takes] Failed to get video track count:', e);
    47→        throw new Error('Could not read timeline tracks: ' + e.message);
    48→    }
    49→
    50→    for (let trackIndex = 0; trackIndex < numVideoTracks; trackIndex++) {
    51→        let clips = [];
    52→        try {
    53→            const clipsJson = await jsx.callWithTimeout('getClipsInTrack', [trackIndex, 'video'], JSX_TIMEOUTS.DEFAULT);
    54→            clips = typeof clipsJson === 'string' ? JSON.parse(clipsJson) : clipsJson;
    55→            if (!Array.isArray(clips)) clips = [];
    56→        } catch (e) {
    57→            console.warn('[SPLICE Takes] Failed to get clips from track', trackIndex, ':', e.message);
    58→            continue;
    59→        }
    60→
    61→        for (let clipIndex = 0; clipIndex < clips.length; clipIndex++) {
    62→            const clip = clips[clipIndex];
    63→            if (!clip) continue;
    64→
    65→            const clipStart = clip.start;
    66→
    67→            // Find which take this clip belongs to
    68→            for (const take of takes) {
    69→                const takeStart = take.start || take.startTime || 0;
    70→                const takeEnd = take.end || take.endTime || 0;
    71→
    72→                if (clipStart >= takeStart && clipStart < takeEnd) {
    73→                    // Build label
    74→                    const isBest = take.isBest || take.userMarkedBest;
    75→                    const prefix = isBest ? '* ' : '';
    76→                    const takeNum = take.takeNumber || takes.indexOf(take) + 1;
    77→                    const desc = take.shortLabel || take.description || take.text || '';
    78→                    const shortDesc = desc.split(' ').slice(0, 4).join(' ');
    79→                    const label = `${prefix}Take ${takeNum} - ${shortDesc}`;
    80→
    81→                    // Note: CEP doesn't have direct clip rename - using marker instead
    82→                    // Create a marker at the clip start with the label
    83→                    try {
    84→                        await jsx.callWithTimeout('createMarker', [clipStart, label, 0, `Take ${takeNum}`, 5], JSX_TIMEOUTS.DEFAULT);
    85→                        labeledCount++;
    86→                    } catch (markerErr) {
    87→                        console.warn('[SPLICE Takes] Failed to create marker at', clipStart, ':', markerErr.message);
    88→                        failCount++;
    89→                    }
    90→                    break;
    91→                }
    92→            }
    93→        }
    94→    }
    95→
    96→    if (failCount > 0) {
    97→        console.warn(`[SPLICE Takes] Labeled ${labeledCount} clips, ${failCount} markers failed`);
    98→    }
    99→
   100→    return labeledCount;
   101→}
   102→
   103→/**
   104→ * Apply best takes - disable non-best takes by removing clips
   105→ * FIX: CEP-ERR-005 - Added comprehensive error handling for JSX calls
   106→ * @returns {Promise<number>} Number of clips removed
   107→ */
   108→async function applyBestTakes() {
   109→    const takes = getCurrentTakes();
   110→
   111→    if (!takes || takes.length === 0) {
   112→        throw new Error('No takes to apply');
   113→    }
   114→
   115→    // Check if sequence is open with timeout protection
   116→    let seqResult;
   117→    try {
   118→        seqResult = await jsx.callWithTimeout('getActiveSequence', [], JSX_TIMEOUTS.QUICK);
   119→        if (!seqResult || seqResult.error) {
   120→            throw new Error('No project or sequence open');
   121→        }
   122→    } catch (e) {
   123→        console.error('[SPLICE Takes] Failed to get active sequence:', e);
   124→        if (e.code === 'JSX_TIMEOUT') {
   125→            throw new Error('Premiere Pro is not responding. Try restarting the application.');
   126→        }
   127→        throw new Error('No project or sequence open: ' + e.message);
   128→    }
   129→
   130→    // Sort takes by start time (descending) - work from end to avoid time shifts
   131→    const sortedTakes = [...takes].sort((a, b) => {
   132→        const aStart = a.start || a.startTime || 0;
   133→        const bStart = b.start || b.startTime || 0;
   134→        return bStart - aStart;
   135→    });
   136→
   137→    let removedCount = 0;
   138→    let failCount = 0;
   139→    let numVideoTracks = 0;
   140→    let numAudioTracks = 0;
   141→
   142→    // Get track counts with error handling
   143→    try {
   144→        numVideoTracks = await jsx.callWithTimeout('getNumTracks', ['video'], JSX_TIMEOUTS.QUICK);
   145→        numAudioTracks = await jsx.callWithTimeout('getNumTracks', ['audio'], JSX_TIMEOUTS.QUICK);
   146→    } catch (e) {
   147→        console.error('[SPLICE Takes] Failed to get track counts:', e);
   148→        throw new Error('Could not read timeline tracks: ' + e.message);
   149→    }
   150→
   151→    for (const take of sortedTakes) {
   152→        const isBest = take.isBest || take.userMarkedBest;
   153→        if (isBest) {
   154→            continue; // Keep best takes
   155→        }
   156→
   157→        const takeStart = take.start || take.startTime || 0;
   158→        const takeEnd = take.end || take.endTime || 0;
   159→
   160→        // Process video tracks
   161→        for (let trackIndex = 0; trackIndex < numVideoTracks; trackIndex++) {
   162→            try {
   163→                const clipsJson = await jsx.callWithTimeout('getClipsInTrack', [trackIndex, 'video'], JSX_TIMEOUTS.DEFAULT);
   164→                const clips = typeof clipsJson === 'string' ? JSON.parse(clipsJson) : clipsJson;
   165→                if (!Array.isArray(clips)) continue;
   166→
   167→                // Process from end to avoid index shifting
   168→                for (let clipIndex = clips.length - 1; clipIndex >= 0; clipIndex--) {
   169→                    const clip = clips[clipIndex];
   170→                    if (!clip) continue;
   171→
   172→                    // Check if clip is within the non-best take range
   173→                    if (clip.start >= takeStart && clip.end <= takeEnd) {
   174→                        try {
   175→                            await jsx.callWithTimeout('removeClipByIndex', ['video', trackIndex, clipIndex], JSX_TIMEOUTS.DEFAULT);
   176→                            removedCount++;
   177→                        } catch (removeErr) {
   178→                            console.warn('[SPLICE Takes] Failed to remove video clip:', removeErr.message);
   179→                            failCount++;
   180→                        }
   181→                    }
   182→                }
   183→            } catch (e) {
   184→                console.warn('[SPLICE Takes] Failed to process video track', trackIndex, ':', e.message);
   185→            }
   186→        }
   187→
   188→        // Process audio tracks
   189→        for (let trackIndex = 0; trackIndex < numAudioTracks; trackIndex++) {
   190→            try {
   191→                const clipsJson = await jsx.callWithTimeout('getClipsInTrack', [trackIndex, 'audio'], JSX_TIMEOUTS.DEFAULT);
   192→                const clips = typeof clipsJson === 'string' ? JSON.parse(clipsJson) : clipsJson;
   193→                if (!Array.isArray(clips)) continue;
   194→
   195→                // Process from end to avoid index shifting
   196→                for (let clipIndex = clips.length - 1; clipIndex >= 0; clipIndex--) {
   197→                    const clip = clips[clipIndex];
   198→                    if (!clip) continue;
   199→
   200→                    // Check if clip is within the non-best take range
   201→                    if (clip.start >= takeStart && clip.end <= takeEnd) {
   202→                        try {
   203→                            await jsx.callWithTimeout('removeClipByIndex', ['audio', trackIndex, clipIndex], JSX_TIMEOUTS.DEFAULT);
   204→                            removedCount++;
   205→                        } catch (removeErr) {
   206→                            console.warn('[SPLICE Takes] Failed to remove audio clip:', removeErr.message);
   207→                            failCount++;
   208→                        }
   209→                    }
   210→                }
   211→            } catch (e) {
   212→                console.warn('[SPLICE Takes] Failed to process audio track', trackIndex, ':', e.message);
   213→            }
   214→        }
   215→    }
   216→
   217→    if (failCount > 0) {
   218→        console.warn(`[SPLICE Takes] Removed ${removedCount} clips, ${failCount} removals failed`);
   219→    }
   220→
   221→    return removedCount;
   222→}
   223→
   224→/**
   225→ * Add take markers to timeline
   226→ * FIX: CEP-ERR-006 - Added error handling with partial success support
   227→ * @returns {Promise<number>} Number of markers added
   228→ */
   229→async function addTakeMarkers() {
   230→    const takes = getCurrentTakes();
   231→
   232→    if (!takes || takes.length === 0) {
   233→        throw new Error('No takes to mark');
   234→    }
   235→
   236→    let markerCount = 0;
   237→    let failCount = 0;
   238→
   239→    for (const take of takes) {
   240→        try {
   241→            const isBest = take.isBest || take.userMarkedBest;
   242→            const takeStart = take.start || take.startTime || 0;
   243→            const takeEnd = take.end || take.endTime || 0;
   244→            const takeNum = take.takeNumber || takes.indexOf(take) + 1;
   245→            const duration = takeEnd - takeStart;
   246→
   247→            const name = `${isBest ? '* ' : ''}Take ${takeNum}`;
   248→            const comments = take.shortLabel || take.description || '';
   249→            const colorIndex = isBest ? 5 : 4; // Cerulean for best, Lavender for others
   250→
   251→            await jsx.callWithTimeout('createMarker', [takeStart, name, duration, comments, colorIndex], JSX_TIMEOUTS.DEFAULT);
   252→            markerCount++;
   253→        } catch (e) {
   254→            console.warn('[SPLICE Takes] Failed to add marker for take:', e.message);
   255→            failCount++;
   256→            // Continue adding other markers - partial success is acceptable
   257→        }
   258→    }
   259→
   260→    if (failCount > 0) {
   261→        console.warn(`[SPLICE Takes] Added ${markerCount} markers, ${failCount} failed`);
   262→    }
   263→
   264→    return markerCount;
   265→}
   266→
   267→// Legacy init functions - no longer needed
   268→function initLabelTimeline() {
   269→    // Now called directly via labelTakesOnTimeline()
   270→}
   271→
   272→function initApplyTakes() {
   273→    // Now called directly via applyBestTakes()
   274→}
   275→
   276→// Export for window access
   277→window.labelTakesOnTimeline = labelTakesOnTimeline;
   278→window.applyBestTakes = applyBestTakes;
   279→window.addTakeMarkers = addTakeMarkers;
   280→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
