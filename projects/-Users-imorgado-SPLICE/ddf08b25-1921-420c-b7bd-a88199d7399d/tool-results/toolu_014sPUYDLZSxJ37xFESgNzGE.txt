     1→/**
     2→ * SPLICE Backend Server
     3→ *
     4→ * Main entry point for the SPLICE backend API.
     5→ * Orchestrates the audio analysis pipeline.
     6→ *
     7→ * Slices:
     8→ * - Slice 4: Transcription (services/transcription.js)
     9→ * - Slice 5: Take Detection (services/takeDetection.js)
    10→ *
    11→ * Architecture: Modular routes (see routes/ directory)
    12→ */
    13→
    14→
    15→require('dotenv').config();
    16→
    17→const express = require('express');
    18→const cors = require('cors');
    19→const helmet = require('helmet');
    20→const cookieParser = require('cookie-parser');
    21→const fs = require('fs');
    22→const https = require('https');
    23→const http = require('http');
    24→const path = require('path');
    25→const crypto = require('crypto');
    26→
    27→// MEDIUM-005: Request ID Tracing Middleware
    28→const { requestIdMiddleware } = require('./middleware/requestId');
    29→
    30→// HIGH-008: Sentry Error Monitoring Integration
    31→let Sentry = null;
    32→if (process.env.SENTRY_DSN) {
    33→  try {
    34→    Sentry = require('@sentry/node');
    35→    console.log('[SPLICE] Sentry module loaded, will initialize after app creation');
    36→  } catch (_err) {
    37→    console.warn('[SPLICE] @sentry/node not installed. Run: npm install @sentry/node');
    38→  }
    39→}
    40→
    41→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)
    42→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;
    43→
    44→// Import services
    45→const usageTracking = require('./services/usageTracking');
    46→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');
    47→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');
    48→const referralService = require('./services/referralService');
    49→const licenseService = require('./services/licenseService');
    50→const emailService = require('./services/emailService');
    51→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');
    52→const { getSupportedFormats } = require('./services/captionExporter');
    53→
    54→// Import route modules
    55→const healthRoutes = require('./routes/health');
    56→const analyzeRoutes = require('./routes/analyze');
    57→const silencesRoutes = require('./routes/silences');
    58→const detectionRoutes = require('./routes/detection');
    59→const exportRoutes = require('./routes/export');
    60→const multitrackRoutes = require('./routes/multitrack');
    61→const cutListRoutes = require('./routes/cutList');
    62→const zoomRoutes = require('./routes/zoom');
    63→const chaptersRoutes = require('./routes/chapters');
    64→const youtubeRoutes = require('./routes/youtube');
    65→const captionsRoutes = require('./routes/captions');
    66→const textEditRoutes = require('./routes/textEdit');
    67→const reframeRoutes = require('./routes/reframe');
    68→const batchRoutes = require('./routes/batch');
    69→const authRoutes = require('./routes/auth');
    70→const billingRoutes = require('./routes/billing');
    71→const referralRoutes = require('./routes/referral');
    72→const licenseRoutes = require('./routes/license');
    73→const musicRoutes = require('./routes/music');
    74→
    75→// Music generation worker (BullMQ background processor)
    76→const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');
    77→
    78→// HIGH-011: API Versioning - v1 routes
    79→const v1Routes = require('./routes/v1');
    80→
    81→// Stripe for webhooks
    82→const Stripe = require('stripe');
    83→
    84→// MEDIUM-008: Pin Stripe API version for stability
    85→// This prevents breaking changes when Stripe releases new API versions
    86→// Should match version in services/stripeUsageReporting.js
    87→const STRIPE_API_VERSION = '2024-12-18.acacia';
    88→
    89→// =============================================================================
    90→// SECURITY: Environment Variable Validation
    91→// Validate all required environment variables at startup
    92→// Fail fast with clear error messages if critical secrets are missing
    93→// =============================================================================
    94→
    95→/**
    96→ * Validate required environment variables
    97→ * @returns {Object} { valid: boolean, errors: string[] }
    98→ */
    99→function validateEnvironmentVariables() {
   100→  const errors = [];
   101→  
   102→  // CRITICAL: Core infrastructure secrets
   103→  if (!process.env.STRIPE_SECRET_KEY) {
   104→    errors.push('STRIPE_SECRET_KEY is required (Stripe API key for billing)');
   105→  }
   106→  
   107→  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production') {
   108→    errors.push('JWT_SECRET must be set to a secure random value (not default)');
   109→  } else if (process.env.JWT_SECRET.length < 32) {
   110→    // HIGH-001: Enforce minimum 32 character length for cryptographic security
   111→    errors.push('JWT_SECRET must be at least 32 characters for cryptographic security');
   112→  }
   113→  
   114→  if (!process.env.DATABASE_URL) {
   115→    errors.push('DATABASE_URL is required (PostgreSQL connection string)');
   116→  }
   117→  
   118→  if (!process.env.OPENAI_API_KEY) {
   119→    errors.push('OPENAI_API_KEY is required (OpenAI API for transcription)');
   120→  }
   121→  
   122→  // CRITICAL: Redis required for job queue and rate limiting
   123→  // Support both Railway Redis (REDIS_URL) and Upstash (UPSTASH_REDIS_URL)
   124→  if (!process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {
   125→    errors.push('REDIS_URL or UPSTASH_REDIS_URL is required (Redis for job queue and rate limiting)');
   126→  }
   127→  
   128→  // CRITICAL: Webhook secret required in production
   129→  if (!process.env.STRIPE_WEBHOOK_SECRET) {
   130→    errors.push('STRIPE_WEBHOOK_SECRET is required (Stripe webhook signature verification)');
   131→  }
   132→  
   133→  // CONDITIONAL: Email provider validation
   134→  const emailProvider = process.env.EMAIL_PROVIDER || 'sendgrid';
   135→  if (emailProvider === 'sendgrid' && !process.env.SENDGRID_API_KEY) {
   136→    errors.push('SENDGRID_API_KEY is required when EMAIL_PROVIDER=sendgrid');
   137→  }
   138→  
   139→  // RECOMMENDED: R2 Storage (warn if missing, don't block)
   140→  if (!process.env.R2_ACCOUNT_ID || !process.env.R2_ACCESS_KEY_ID || !process.env.R2_SECRET_ACCESS_KEY) {
   141→    console.warn('[SPLICE] WARNING: R2 storage credentials not configured. Music generation uploads will fail.');
   142→  }
   143→  
   144→  return {
   145→    valid: errors.length === 0,
   146→    errors
   147→  };
   148→}
   149→
   150→// Run validation in production
   151→if (isProduction) {
   152→  const validation = validateEnvironmentVariables();
   153→  
   154→  if (!validation.valid) {
   155→    console.error('[SPLICE] ========================================');
   156→    console.error('[SPLICE] CRITICAL: Missing required environment variables');
   157→    console.error('[SPLICE] ========================================');
   158→    validation.errors.forEach(error => {
   159→      console.error(`[SPLICE]   ❌ ${error}`);
   160→    });
   161→    console.error('[SPLICE] ========================================');
   162→    console.error('[SPLICE] Server startup aborted. Please configure all required environment variables.');
   163→    console.error('[SPLICE] See .env.example for complete documentation.');
   164→    process.exit(1);
   165→  }
   166→  
   167→  console.log('[SPLICE] ✅ Environment validation passed');
   168→}
   169→
   170→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
   171→  apiVersion: STRIPE_API_VERSION
   172→});
   173→
   174→// =============================================================================
   175→// PERF-FIX: Static Response Cache
   176→// Cache static endpoint responses at startup to avoid repeated computation
   177→// =============================================================================
   178→
   179→// Generate ETag from content
   180→function generateETag(content) {
   181→  return `"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}"`;
   182→}
   183→
   184→// Static response cache - populated at startup
   185→const STATIC_RESPONSE_CACHE = {
   186→  profanityLanguages: null,
   187→  profanityBleeps: null,
   188→  exportFormats: null
   189→};
   190→
   191→// Initialize cache at startup (called after server starts)
   192→function initializeStaticCache() {
   193→  // Cache profanity languages
   194→  const languages = getSupportedLanguages();
   195→  STATIC_RESPONSE_CACHE.profanityLanguages = {
   196→    body: { success: true, languages },
   197→    etag: generateETag({ languages })
   198→  };
   199→
   200→  // Cache profanity bleeps
   201→  const sounds = getAvailableBleepSounds();
   202→  STATIC_RESPONSE_CACHE.profanityBleeps = {
   203→    body: { success: true, sounds },
   204→    etag: generateETag({ sounds })
   205→  };
   206→
   207→  // Cache export formats
   208→  const formats = getSupportedFormats();
   209→  STATIC_RESPONSE_CACHE.exportFormats = {
   210→    body: { success: true, formats },
   211→    etag: generateETag({ formats })
   212→  };
   213→
   214→  console.log('[SPLICE] Static response cache initialized');
   215→}
   216→
   217→// Helper to send cached response with ETag
   218→function sendCachedResponse(req, res, cacheKey) {
   219→  const cached = STATIC_RESPONSE_CACHE[cacheKey];
   220→  if (!cached) {
   221→    return res.status(500).json({ error: 'Cache not initialized' });
   222→  }
   223→
   224→  // Check If-None-Match header for conditional GET
   225→  const clientETag = req.headers['if-none-match'];
   226→  if (clientETag === cached.etag) {
   227→    return res.status(304).end(); // Not Modified
   228→  }
   229→
   230→  // Send cached response with ETag and cache headers
   231→  res.set('ETag', cached.etag);
   232→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours
   233→  res.json(cached.body);
   234→}
   235→
   236→// =============================================================================
   237→// Server Configuration
   238→// =============================================================================
   239→
   240→const app = express();
   241→const PORT = process.env.PORT || 3847;
   242→
   243→// HIGH-008: Initialize Sentry after app creation
   244→if (Sentry && process.env.SENTRY_DSN) {
   245→  Sentry.init({
   246→    dsn: process.env.SENTRY_DSN,
   247→    environment: process.env.NODE_ENV || 'development',
   248→    release: process.env.npm_package_version || '6.0.3',
   249→    tracesSampleRate: isProduction ? 0.1 : 1.0, // 10% in prod, 100% in dev
   250→    profilesSampleRate: isProduction ? 0.1 : 0, // Profile only in production
   251→    integrations: [
   252→      // Automatically instrument HTTP requests
   253→      Sentry.httpIntegration({ tracing: true }),
   254→      // Automatically instrument Express
   255→      Sentry.expressIntegration({ app }),
   256→    ],
   257→    // Filter out sensitive data
   258→    beforeSend(event) {
   259→      // Remove sensitive headers
   260→      if (event.request && event.request.headers) {
   261→        delete event.request.headers.authorization;
   262→        delete event.request.headers['x-stripe-customer-id'];
   263→        delete event.request.headers['stripe-signature'];
   264→      }
   265→      return event;
   266→    },
   267→  });
   268→  
   269→  // Add Sentry request handler as first middleware
   270→  app.use(Sentry.Handlers.requestHandler());
   271→  app.use(Sentry.Handlers.tracingHandler());
   272→  
   273→  console.log('[SPLICE] ✅ Sentry error monitoring initialized');
   274→}
   275→
   276→// MEDIUM-005: Request ID Tracing Middleware
   277→// Add early in chain to ensure all requests have correlation IDs for logging
   278→app.use(requestIdMiddleware);
   279→
   280→// HTTPS certificates (generated by mkcert) - only for local development
   281→let httpsOptions = null;
   282→if (!isProduction) {
   283→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');
   284→  const certPath = path.join(__dirname, 'localhost+1.pem');
   285→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
   286→    httpsOptions = {
   287→      key: fs.readFileSync(keyPath),
   288→      cert: fs.readFileSync(certPath)
   289→    };
   290→  }
   291→}
   292→
   293→// =============================================================================
   294→// Security Configuration
   295→// =============================================================================
   296→
   297→// CORS whitelist - restrict origins in production
   298→const CORS_WHITELIST = [
   299→  'http://localhost:3000',
   300→  'http://localhost:3847',
   301→  'https://localhost:3847',
   302→  'http://127.0.0.1:3000',
   303→  'http://127.0.0.1:3847',
   304→  'https://127.0.0.1:3847',
   305→  'https://splice.app',
   306→  'https://www.splice.app',
   307→  'https://spliceclips.com',
   308→  'https://www.spliceclips.com',
   309→  'https://splice-api-production.up.railway.app',
   310→  'https://splice-website.vercel.app',
   311→  // Adobe CEP/UXP panels run from file:// or bolt://
   312→  'file://',
   313→  'bolt://'
   314→];
   315→
   316→const corsOptions = {
   317→  origin: function (origin, callback) {
   318→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)
   319→    if (!origin) {
   320→      return callback(null, true);
   321→    }
   322→    // Check if origin is in whitelist
   323→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {
   324→      return callback(null, true);
   325→    }
   326→    // In development, allow all origins with warning
   327→    if (!isProduction) {
   328→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);
   329→      return callback(null, true);
   330→    }
   331→    // In production, reject non-whitelisted origins
   332→    console.error(`[CORS] Blocked request from: ${origin}`);
   333→    return callback(new Error('Not allowed by CORS'));
   334→  },
   335→  credentials: true,
   336→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
   337→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']
   338→};
   339→
   340→app.use(cors(corsOptions));
   341→
   342→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers
   343→// This ensures rate limiting and logging use the correct client IP
   344→if (isProduction) {
   345→  app.set('trust proxy', 1);
   346→}
   347→
   348→// IP-based rate limiting (100 requests/minute per IP)
   349→app.use(ipRateLimit);
   350→
   351→// Security headers via helmet
   352→app.use(helmet({
   353→  contentSecurityPolicy: {
   354→    directives: {
   355→      defaultSrc: ["'self'"],
   356→      scriptSrc: ["'self'"],
   357→      styleSrc: ["'self'", "'unsafe-inline'"],
   358→      imgSrc: ["'self'", 'data:', 'https:'],
   359→      connectSrc: ["'self'", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],
   360→      fontSrc: ["'self'"],
   361→      objectSrc: ["'none'"],
   362→      mediaSrc: ["'self'"],
   363→      frameSrc: ["'none'"]
   364→    }
   365→  },
   366→  hsts: {
   367→    maxAge: 31536000,
   368→    includeSubDomains: true,
   369→    preload: true
   370→  },
   371→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
   372→  noSniff: true,
   373→  xssFilter: true,
   374→  hidePoweredBy: true
   375→}));
   376→
   377→// Helper to determine tier from price ID with logging
   378→// Supports both monthly and annual pricing
   379→function getTierFromPriceId(priceId) {
   380→  // Monthly prices
   381→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';
   382→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';
   383→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';
   384→
   385→  // Annual prices (same tier, just different billing period)
   386→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';
   387→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';
   388→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';
   389→
   390→  // Log unknown price ID for debugging
   391→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);
   392→  return 'starter';
   393→}
   394→
   395→// =============================================================================
   396→// Stripe Webhook (must be before express.json())
   397→// =============================================================================
   398→
   399→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
   400→  const sig = req.headers['stripe-signature'];
   401→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
   402→
   403→  let event;
   404→
   405→  try {
   406→    if (webhookSecret) {
   407→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
   408→    } else if (isProduction) {
   409→      // SECURITY: Reject unsigned webhooks in production
   410→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');
   411→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });
   412→    } else {
   413→      // For local development testing only
   414→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse
   415→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');
   416→      event = JSON.parse(bodyString);
   417→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');
   418→    }
   419→  } catch (err) {
   420→    console.error('[SPLICE] Webhook signature verification failed:', err.message);
   421→    return res.status(400).json({ error: 'Webhook signature verification failed' });
   422→  }
   423→
   424→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);
   425→
   426→  // Idempotency check - skip if already processed
   427→  if (await usageTracking.isEventProcessed(event.id)) {
   428→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);
   429→    return res.json({ received: true, skipped: true });
   430→  }
   431→
   432→  try {
   433→    switch (event.type) {
   434→      case 'customer.subscription.created':
   435→      case 'customer.subscription.updated': {
   436→        const subscription = event.data.object;
   437→        const customerId = subscription.customer;
   438→
   439→        // Validate customerId
   440→        if (!customerId) {
   441→          console.error('[SPLICE] Missing customer ID in subscription event');
   442→          return res.status(400).json({ error: 'Missing customer ID' });
   443→        }
   444→
   445→        // Get tier from price ID
   446→        const priceId = subscription.items?.data?.[0]?.price?.id;
   447→        const tier = getTierFromPriceId(priceId);
   448→
   449→        // Update user tier and reset hours
   450→        await usageTracking.updateTier(customerId, tier);
   451→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);
   452→
   453→        // Initialize music credits for new subscriptions
   454→        if (event.type === 'customer.subscription.created') {
   455→          await usageTracking.resetMusicCredits(customerId, tier);
   456→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);
   457→        }
   458→
   459→        // Update trial end date if present
   460→        if (subscription.trial_end) {
   461→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);
   462→        }
   463→
   464→        // Generate license key for new subscriptions with retry and delivery
   465→        if (event.type === 'customer.subscription.created') {
   466→          let licenseResult = null;
   467→          let retryCount = 0;
   468→          const maxRetries = 3;
   469→
   470→          // Retry mechanism for license key generation
   471→          while (retryCount < maxRetries) {
   472→            licenseResult = await licenseService.generateLicenseKey(customerId);
   473→            if (licenseResult.success) {
   474→              break;
   475→            }
   476→            retryCount++;
   477→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);
   478→            // Wait before retry (exponential backoff)
   479→            if (retryCount < maxRetries) {
   480→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
   481→            }
   482→          }
   483→
   484→          if (licenseResult && licenseResult.success) {
   485→            // SECURITY: Mask license key in logs
   486→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);
   487→
   488→            // Store license key in Stripe subscription metadata as backup
   489→            try {
   490→              await stripe.subscriptions.update(subscription.id, {
   491→                metadata: {
   492→                  license_key: licenseResult.key,
   493→                  license_generated_at: new Date().toISOString()
   494→                }
   495→              });
   496→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);
   497→            } catch (stripeErr) {
   498→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);
   499→            }
   500→
   501→            // Get customer email and send license key
   502→            try {
   503→              const customer = await stripe.customers.retrieve(customerId);
   504→              if (customer.email) {
   505→                // SECURITY: Mask sensitive data in logs
   506→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);
   507→
   508→                // Send license key email
   509→                try {
   510→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);
   511→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);
   512→                } catch (sendErr) {
   513→                  // Log but don't fail - license is stored in Stripe metadata as backup
   514→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);
   515→                }
   516→
   517→                // Store email in database for reference
   518→                await usageTracking.updateTier(customerId, tier, customer.email);
   519→              } else {
   520→                console.warn(`[SPLICE] No email found for customer ${customerId}`);
   521→              }
   522→            } catch (emailErr) {
   523→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);
   524→            }
   525→          } else {
   526→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry
   527→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;
   528→            console.error(`[SPLICE] ${errorMsg}`);
   529→            return res.status(500).json({ error: errorMsg });
   530→          }
   531→        }
   532→        break;
   533→      }
   534→
   535→      case 'customer.subscription.deleted': {
   536→        const subscription = event.data.object;
   537→        const customerId = subscription.customer;
   538→
   539→        // Validate customerId
   540→        if (!customerId) {
   541→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');
   542→          return res.status(400).json({ error: 'Missing customer ID' });
   543→        }
   544→
   545→        // Downgrade to cancelled (0 hours)
   546→        await usageTracking.updateTier(customerId, 'cancelled');
   547→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);
   548→        break;
   549→      }
   550→
   551→      case 'invoice.payment_succeeded': {
   552→        const invoice = event.data.object;
   553→        const customerId = invoice.customer;
   554→        const subscriptionId = invoice.subscription;
   555→
   556→        // Validate customerId
   557→        if (!customerId) {
   558→          console.error('[SPLICE] Missing customer ID in invoice event');
   559→          return res.status(400).json({ error: 'Missing customer ID' });
   560→        }
   561→
   562→        // Reset hours on successful payment (new billing period)
   563→        let tier = 'starter';
   564→        if (subscriptionId) {
   565→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);
   566→          const priceId = subscription.items?.data?.[0]?.price?.id;
   567→          tier = getTierFromPriceId(priceId);
   568→
   569→          await usageTracking.resetHours(customerId, tier);
   570→          await usageTracking.resetMusicCredits(customerId, tier);
   571→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);
   572→        }
   573→
   574→        // Check for affiliate coupon and record commission
   575→        const discount = invoice.discount;
   576→        if (discount && discount.coupon) {
   577→          const couponId = discount.coupon.id;
   578→          // Check if this is an affiliate code (like JIMMYN)
   579→          if (referralService.AFFILIATE_CODES[couponId]) {
   580→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars
   581→            await referralService.recordAffiliateCommission(
   582→              couponId,
   583→              customerId,
   584→              amountPaid,
   585→              tier
   586→            );
   587→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);
   588→          }
   589→        }
   590→        break;
   591→      }
   592→
   593→      case 'invoice.payment_failed': {
   594→        const invoice = event.data.object;
   595→        const customerId = invoice.customer;
   596→        const attemptCount = invoice.attempt_count || 1;
   597→
   598→        // Validate customerId
   599→        if (!customerId) {
   600→          console.error('[SPLICE] Missing customer ID in payment_failed event');
   601→          return res.status(400).json({ error: 'Missing customer ID' });
   602→        }
   603→
   604→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);
   605→
   606→        // Stripe will retry automatically per retry settings
   607→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted
   608→        // Send warning email on final attempt
   609→        if (attemptCount >= 3) {
   610→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);
   611→          // Send warning email to customer about impending cancellation
   612→          try {
   613→            const customer = await stripe.customers.retrieve(customerId);
   614→            if (customer.email) {
   615→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);
   616→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);
   617→            }
   618→          } catch (emailErr) {
   619→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);
   620→          }
   621→        }
   622→        break;
   623→      }
   624→
   625→      case 'customer.deleted': {
   626→        const customer = event.data.object;
   627→        const customerId = customer.id;
   628→
   629→        // Validate customerId
   630→        if (!customerId) {
   631→          console.error('[SPLICE] Missing customer ID in customer.deleted event');
   632→          return res.status(400).json({ error: 'Missing customer ID' });
   633→        }
   634→
   635→        // Clean up user data - downgrade to cancelled
   636→        await usageTracking.updateTier(customerId, 'cancelled');
   637→        console.log(`[SPLICE] Customer deleted: ${customerId}`);
   638→        break;
   639→      }
   640→
   641→      default:
   642→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);
   643→    }
   644→
   645→    // Record event as processed (idempotency)
   646→    await usageTracking.recordWebhookEvent(event.id, event.type);
   647→
   648→    res.json({ received: true });
   649→  } catch (err) {
   650→    console.error('[SPLICE] Webhook handler error:', err);
   651→    res.status(500).json({ error: err.message });
   652→  }
   653→});
   654→
   655→// Parse JSON body for all other routes
   656→// SECURITY: Limit JSON body size to prevent DoS attacks
   657→app.use(express.json({ limit: '10mb' }));
   658→
   659→// Parse cookies for CSRF token validation
   660→app.use(cookieParser());
   661→
   662→// =============================================================================
   663→// Route Configuration Options
   664→// =============================================================================
   665→
   666→const routeOptions = {
   667→  middleware: {
   668→    requireCredits,
   669→    requireFeature,
   670→    authenticateToken
   671→  },
   672→  services: {
   673→    usageTracking,
   674→    referralService,
   675→    licenseService,
   676→    emailService,
   677→    stripe
   678→  },
   679→  authHelpers: {
   680→    generateToken,
   681→    generateRefreshToken,
   682→    verifyToken,
   683→    maskSensitiveData,
   684→    blacklistToken
   685→  },
   686→  staticCache: STATIC_RESPONSE_CACHE,
   687→  sendCachedResponse
   688→};
   689→
   690→// =============================================================================
   691→// Mount Routes
   692→// =============================================================================
   693→
   694→// Health check and system endpoints (no prefix)
   695→app.use('/', healthRoutes(routeOptions));
   696→
   697→// Core analysis endpoints
   698→app.use('/', analyzeRoutes(routeOptions));
   699→app.use('/', silencesRoutes(routeOptions));
   700→app.use('/', detectionRoutes(routeOptions));
   701→
   702→// Export endpoints
   703→app.use('/export', exportRoutes(routeOptions));
   704→
   705→// Multitrack/Multicam endpoints
   706→app.use('/multitrack', multitrackRoutes(routeOptions));
   707→
   708→// Cut list generation
   709→app.use('/cut-list', cutListRoutes(routeOptions));
   710→
   711→// Legacy XML processing endpoint (backwards compatibility)
   712→const { processXMLFile } = require('./services/xmlProcessor');
   713→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {
   714→  const {
   715→    xmlPath,
   716→    silences,
   717→    removeGaps = true,
   718→    outputPath = null
   719→  } = req.body;
   720→
   721→  if (!xmlPath) {
   722→    return res.status(400).json({ error: 'xmlPath is required' });
   723→  }
   724→
   725→  if (!silences || !Array.isArray(silences)) {
   726→    return res.status(400).json({ error: 'silences array is required' });
   727→  }
   728→
   729→  if (!fs.existsSync(xmlPath)) {
   730→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });
   731→  }
   732→
   733→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);
   734→
   735→  try {
   736→    const result = await processXMLFile(xmlPath, silences, {
   737→      outputPath,
   738→      removeGaps
   739→    });
   740→
   741→    res.json({
   742→      success: true,
   743→      inputPath: xmlPath,
   744→      outputPath: result.outputPath,
   745→      stats: result.stats
   746→    });
   747→  } catch (err) {
   748→    console.error('[SPLICE] XML processing error:', err);
   749→    res.status(500).json({ error: err.message });
   750→  }
   751→});
   752→
   753→// Auto zoom endpoints
   754→app.use('/zoom', zoomRoutes(routeOptions));
   755→
   756→// Chapter detection endpoints
   757→app.use('/chapters', chaptersRoutes(routeOptions));
   758→
   759→// YouTube content generation
   760→app.use('/youtube', youtubeRoutes(routeOptions));
   761→
   762→// Animated captions endpoints
   763→app.use('/captions', captionsRoutes(routeOptions));
   764→
   765→// Text-based editing endpoints
   766→app.use('/text-edit', textEditRoutes(routeOptions));
   767→
   768→// Social reframe endpoints
   769→app.use('/reframe', reframeRoutes(routeOptions));
   770→app.use('/faces', reframeRoutes.facesRouter(routeOptions));
   771→
   772→// Batch processing endpoints
   773→app.use('/batch', batchRoutes(routeOptions));
   774→
   775→// Authentication endpoints
   776→app.use('/auth', authRoutes(routeOptions));
   777→
   778→// Billing and credits endpoints
   779→app.use('/', billingRoutes(routeOptions));
   780→
   781→// Referral system endpoints
   782→app.use('/referral', referralRoutes(routeOptions));
   783→
   784→// License key endpoints
   785→app.use('/license', licenseRoutes(routeOptions));
   786→
   787→// AI Music generation endpoints
   788→app.use('/music', musicRoutes(routeOptions));
   789→
   790→// =============================================================================
   791→// HIGH-011: API Versioning
   792→// Mount versioned routes under /api/v1 prefix
   793→// Maintain backwards compatibility with deprecation warnings
   794→// =============================================================================
   795→
   796→// Mount v1 API routes
   797→app.use('/api/v1', v1Routes(routeOptions));
   798→
   799→// Deprecation warning middleware for unversioned API calls
   800→// This helps clients migrate to versioned endpoints
   801→app.use('/api', (req, res, next) => {
   802→  // Skip if already using versioned endpoint
   803→  if (req.path.startsWith('/v1')) {
   804→    return next();
   805→  }
   806→  
   807→  // Add deprecation warning header
   808→  res.set('X-API-Deprecation-Warning', 'Unversioned API endpoints are deprecated. Please migrate to /api/v1/');
   809→  res.set('X-API-Version', 'unversioned');
   810→  res.set('Deprecation', 'true');
   811→  res.set('Sunset', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toUTCString()); // 90 days from now
   812→  
   813→  next();
   814→});
   815→
   816→// HIGH-008: Add Sentry error handler (must be after all routes)
   817→if (Sentry) {
   818→  app.use(Sentry.Handlers.errorHandler({
   819→    shouldHandleError(error) {
   820→      // Capture all 4xx and 5xx errors
   821→      if (error.status >= 400) {
   822→        return true;
   823→      }
   824→      return true;
   825→    },
   826→  }));
   827→}
   828→
   829→// =============================================================================
   830→// Start Server
   831→// =============================================================================
   832→
   833→// Track active server for graceful shutdown
   834→let server = null;
   835→
   836→// Initialize database and start server
   837→async function startServer() {
   838→  try {
   839→    await usageTracking.initDatabase();
   840→    await referralService.initReferralTables();
   841→    await licenseService.initLicenseTables();
   842→    console.log('[SPLICE] Database initialized');
   843→
   844→    // PERF-FIX: Initialize static response cache at startup
   845→    initializeStaticCache();
   846→
   847→    // Start music generation worker (BullMQ background processor)
   848→    // Only starts if Redis is configured and Replicate API key is available
   849→    if (process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL) {
   850→      if (process.env.REPLICATE_API_TOKEN) {
   851→        try {
   852→          createMusicWorker();
   853→          console.log('[SPLICE] ✅ Music generation worker started');
   854→        } catch (workerErr) {
   855→          console.error('[SPLICE] ⚠️ Failed to start music worker:', workerErr.message);
   856→          // Don't fail server startup - music generation will be unavailable
   857→        }
   858→      } else {
   859→        console.warn('[SPLICE] ⚠️ REPLICATE_API_TOKEN not set - music generation disabled');
   860→      }
   861→    } else {
   862→      console.warn('[SPLICE] ⚠️ Redis not configured - music generation queue disabled');
   863→    }
   864→
   865→    if (isProduction || !httpsOptions) {
   866→      // Production: Railway provides TLS termination, use HTTP
   867→      server = http.createServer(app).listen(PORT, () => {
   868→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);
   869→      });
   870→    } else {
   871→      // Development: Use HTTPS with local certificates
   872→      server = https.createServer(httpsOptions, app).listen(PORT, () => {
   873→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);
   874→        console.log(`[SPLICE] POST /analyze with { "wavPath": "/path/to/audio.wav" }`);
   875→      });
   876→    }
   877→  } catch (err) {
   878→    console.error('[SPLICE] Failed to start server:', err);
   879→    process.exit(1);
   880→  }
   881→}
   882→
   883→// =============================================================================
   884→// Graceful Shutdown
   885→// =============================================================================
   886→
   887→async function gracefulShutdown(signal) {
   888→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);
   889→
   890→  // Stop accepting new connections
   891→  if (server) {
   892→    server.close(() => {
   893→      console.log('[SPLICE] HTTP server closed');
   894→    });
   895→  }
   896→
   897→  // Shutdown music worker (allows in-progress jobs to complete)
   898→  try {
   899→    await shutdownWorker();
   900→    console.log('[SPLICE] Music worker shut down');
   901→  } catch (err) {
   902→    console.error('[SPLICE] Error shutting down music worker:', err.message);
   903→  }
   904→
   905→  // Close database pool
   906→  try {
   907→    await usageTracking.closePool();
   908→    console.log('[SPLICE] Database pool closed');
   909→  } catch (err) {
   910→    console.error('[SPLICE] Error closing database pool:', err.message);
   911→  }
   912→
   913→  // Give ongoing requests time to complete (max 10 seconds)
   914→  setTimeout(() => {
   915→    console.log('[SPLICE] Graceful shutdown complete');
   916→    process.exit(0);
   917→  }, 10000);
   918→}
   919→
   920→// Handle termination signals
   921→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
   922→process.on('SIGINT', () => gracefulShutdown('SIGINT'));
   923→
   924→// Handle uncaught exceptions
   925→process.on('uncaughtException', (err) => {
   926→  console.error('[SPLICE] Uncaught exception:', err);
   927→  gracefulShutdown('uncaughtException');
   928→});
   929→
   930→process.on('unhandledRejection', (reason, promise) => {
   931→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);
   932→});
   933→
   934→startServer();
   935→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
