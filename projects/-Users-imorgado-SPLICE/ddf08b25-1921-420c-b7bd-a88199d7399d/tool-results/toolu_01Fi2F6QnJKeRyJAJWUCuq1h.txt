     1→/**
     2→ * SPLICE Zoom Generator Service
     3→ *
     4→ * Generates zoom keyframe data for cut list integration.
     5→ * Uses adjustment layers for non-destructive zoom effects.
     6→ *
     7→ * Features:
     8→ * - Preset-based zoom intensity (subtle/medium/dramatic)
     9→ * - Configurable frequency (zooms per minute)
    10→ * - Smart placement at emphasis points (sentence starts, keywords)
    11→ * - Easing curves for smooth animation (power-based)
    12→ */
    13→
    14→// Zoom intensity presets
    15→const ZOOM_PRESETS = {
    16→  subtle: { scale: 110, duration: 0.6, easing: 2 },
    17→  medium: { scale: 120, duration: 0.8, easing: 3 },
    18→  dramatic: { scale: 140, duration: 1.0, easing: 4 }
    19→};
    20→
    21→// Zoom frequency options (seconds between zooms)
    22→const ZOOM_FREQUENCIES = {
    23→  low: 60,      // ~1 per minute
    24→  medium: 30,   // ~2 per minute
    25→  high: 15      // ~4 per minute
    26→};
    27→
    28→// Placement strategies
    29→const PLACEMENT_STRATEGIES = {
    30→  sentence_start: 'sentence_start',
    31→  keywords: 'keywords',
    32→  random: 'random',
    33→  speaker_change: 'speaker_change'
    34→};
    35→
    36→/**
    37→ * Generate zoom points from transcript
    38→ * @param {Object} transcript - Transcript with words and segments
    39→ * @param {Object} settings - Zoom generation settings
    40→ * @returns {Array} Array of zoom point objects
    41→ */
    42→function generateZoomPoints(transcript, settings = {}) {
    43→  const {
    44→    frequency = 'medium',
    45→    preset = 'medium',
    46→    placement = 'sentence_start',
    47→    minGap = 5,           // Minimum seconds between zooms
    48→    maxZooms = 50,        // Maximum total zooms
    49→    excludeFirstSeconds = 3,  // Don't zoom in first N seconds
    50→    excludeLastSeconds = 2    // Don't zoom in last N seconds
    51→  } = settings;
    52→
    53→  if (!transcript || (!transcript.words && !transcript.segments)) {
    54→    console.log('[SPLICE Zoom] No transcript data, returning empty zoom points');
    55→    return [];
    56→  }
    57→
    58→  const zoomPoints = [];
    59→  const presetConfig = ZOOM_PRESETS[preset] || ZOOM_PRESETS.medium;
    60→  const intervalSeconds = ZOOM_FREQUENCIES[frequency] || 30;
    61→
    62→  // Get transcript duration
    63→  const duration = transcript.duration ||
    64→    (transcript.words?.length > 0 ? transcript.words[transcript.words.length - 1].end : 0) ||
    65→    (transcript.segments?.length > 0 ? transcript.segments[transcript.segments.length - 1].end : 0);
    66→
    67→  if (duration <= 0) {
    68→    console.log('[SPLICE Zoom] No duration found, returning empty');
    69→    return [];
    70→  }
    71→
    72→  // Find emphasis points based on placement strategy
    73→  const emphasisPoints = findEmphasisPoints(transcript, placement, duration);
    74→
    75→  // Filter and select zoom points based on frequency
    76→  let lastZoomTime = -Infinity;
    77→
    78→  for (const point of emphasisPoints) {
    79→    // Skip points too close to start/end
    80→    if (point.time < excludeFirstSeconds) continue;
    81→    if (point.time > duration - excludeLastSeconds) continue;
    82→
    83→    // Enforce minimum gap between zooms
    84→    if (point.time - lastZoomTime < Math.max(minGap, intervalSeconds)) continue;
    85→
    86→    // Create zoom point
    87→    zoomPoints.push({
    88→      type: 'zoom',
    89→      startTime: parseFloat(point.time.toFixed(3)),
    90→      duration: presetConfig.duration,
    91→      scale: presetConfig.scale,
    92→      easing: presetConfig.easing,
    93→      centerPoint: point.center || { x: 0.5, y: 0.5 },
    94→      reason: point.reason || 'emphasis'
    95→    });
    96→
    97→    lastZoomTime = point.time;
    98→
    99→    // Limit total zooms
   100→    if (zoomPoints.length >= maxZooms) break;
   101→  }
   102→
   103→  console.log(`[SPLICE Zoom] Generated ${zoomPoints.length} zoom points (${frequency}/${preset})`);
   104→
   105→  return zoomPoints;
   106→}
   107→
   108→/**
   109→ * Find emphasis points in transcript based on placement strategy
   110→ * @param {Object} transcript - Transcript data
   111→ * @param {string} placement - Placement strategy
   112→ * @param {number} duration - Total duration
   113→ * @returns {Array} Array of emphasis points
   114→ */
   115→function findEmphasisPoints(transcript, placement, duration) {
   116→  switch (placement) {
   117→    case 'sentence_start':
   118→      return findSentenceStarts(transcript);
   119→
   120→    case 'keywords':
   121→      return findKeywordPositions(transcript);
   122→
   123→    case 'speaker_change':
   124→      return findSpeakerChanges(transcript);
   125→
   126→    case 'random':
   127→    default:
   128→      return generateRandomPoints(duration);
   129→  }
   130→}
   131→
   132→/**
   133→ * Find sentence start positions
   134→ * @param {Object} transcript - Transcript with words
   135→ * @returns {Array} Emphasis points at sentence starts
   136→ */
   137→function findSentenceStarts(transcript) {
   138→  const points = [];
   139→  const words = transcript.words || [];
   140→
   141→  // Sentence ending punctuation
   142→  const sentenceEnders = /[.!?]/;
   143→
   144→  // First word is always a sentence start
   145→  if (words.length > 0) {
   146→    points.push({
   147→      time: words[0].start || 0,
   148→      reason: 'sentence_start',
   149→      center: { x: 0.5, y: 0.5 }
   150→    });
   151→  }
   152→
   153→  // Find words after sentence-ending punctuation
   154→  for (let i = 0; i < words.length - 1; i++) {
   155→    const word = words[i].word || '';
   156→
   157→    if (sentenceEnders.test(word)) {
   158→      const nextWord = words[i + 1];
   159→      if (nextWord && nextWord.start !== undefined) {
   160→        points.push({
   161→          time: nextWord.start,
   162→          reason: 'sentence_start',
   163→          center: { x: 0.5, y: 0.5 }
   164→        });
   165→      }
   166→    }
   167→  }
   168→
   169→  return points;
   170→}
   171→
   172→/**
   173→ * Find keyword positions (emphasis words)
   174→ * @param {Object} transcript - Transcript with words
   175→ * @returns {Array} Emphasis points at keywords
   176→ */
   177→function findKeywordPositions(transcript) {
   178→  const points = [];
   179→  const words = transcript.words || [];
   180→
   181→  // Keywords that often deserve emphasis
   182→  const emphasisWords = new Set([
   183→    'important', 'key', 'critical', 'essential', 'crucial',
   184→    'amazing', 'incredible', 'awesome', 'fantastic', 'wonderful',
   185→    'problem', 'solution', 'answer', 'question', 'reason',
   186→    'first', 'second', 'third', 'finally', 'lastly',
   187→    'however', 'therefore', 'because', 'although', 'moreover',
   188→    'never', 'always', 'must', 'should', 'absolutely',
   189→    'love', 'hate', 'best', 'worst', 'favorite'
   190→  ]);
   191→
   192→  for (const word of words) {
   193→    const normalized = (word.word || '').toLowerCase().replace(/[^a-z]/g, '');
   194→
   195→    if (emphasisWords.has(normalized) && word.start !== undefined) {
   196→      points.push({
   197→        time: word.start,
   198→        reason: `keyword:${normalized}`,
   199→        center: { x: 0.5, y: 0.5 }
   200→      });
   201→    }
   202→  }
   203→
   204→  return points;
   205→}
   206→
   207→/**
   208→ * Find speaker change positions (for multicam)
   209→ * @param {Object} transcript - Transcript with segments
   210→ * @returns {Array} Emphasis points at speaker changes
   211→ */
   212→function findSpeakerChanges(transcript) {
   213→  const points = [];
   214→  const segments = transcript.segments || [];
   215→
   216→  let lastSpeaker = null;
   217→
   218→  for (const segment of segments) {
   219→    const speaker = segment.speaker || segment.speakerId;
   220→
   221→    if (speaker && speaker !== lastSpeaker && segment.start !== undefined) {
   222→      points.push({
   223→        time: segment.start,
   224→        reason: `speaker_change:${speaker}`,
   225→        center: { x: 0.5, y: 0.5 }
   226→      });
   227→      lastSpeaker = speaker;
   228→    }
   229→  }
   230→
   231→  return points;
   232→}
   233→
   234→/**
   235→ * Generate random zoom points
   236→ * @param {number} duration - Total duration
   237→ * @returns {Array} Random emphasis points
   238→ */
   239→function generateRandomPoints(duration) {
   240→  const points = [];
   241→  const numPoints = Math.floor(duration / 20); // Roughly 3 per minute
   242→
   243→  for (let i = 0; i < numPoints; i++) {
   244→    const time = (Math.random() * 0.8 + 0.1) * duration; // 10-90% of duration
   245→    points.push({
   246→      time,
   247→      reason: 'random',
   248→      center: { x: 0.5, y: 0.5 }
   249→    });
   250→  }
   251→
   252→  // Sort by time
   253→  points.sort((a, b) => a.time - b.time);
   254→
   255→  return points;
   256→}
   257→
   258→/**
   259→ * Calculate easing curve value
   260→ * Uses power-based easing for smooth acceleration/deceleration
   261→ * @param {number} t - Progress (0-1)
   262→ * @param {number} power - Easing power (higher = more aggressive)
   263→ * @returns {number} Eased value (0-1)
   264→ */
   265→function easingCurve(t, power) {
   266→  const coefficient = Math.pow(2, power - 1);
   267→  return (1 - Math.pow(2, -power * t)) / coefficient;
   268→}
   269→
   270→/**
   271→ * Generate keyframes for a zoom animation
   272→ * @param {Object} zoom - Zoom point configuration
   273→ * @param {number} frameRate - Frame rate (default 30)
   274→ * @returns {Array} Array of keyframe objects
   275→ */
   276→function generateZoomKeyframes(zoom, frameRate = 30) {
   277→  const keyframes = [];
   278→  const frameCount = Math.ceil(zoom.duration * frameRate);
   279→
   280→  for (let i = 0; i <= frameCount; i++) {
   281→    const t = i / frameCount;
   282→
   283→    // Zoom in during first half, zoom out during second half
   284→    let scale;
   285→    if (t < 0.5) {
   286→      // Zoom in: 100% -> peak
   287→      const easedT = easingCurve(t * 2, zoom.easing);
   288→      scale = 100 + (zoom.scale - 100) * easedT;
   289→    } else {
   290→      // Zoom out: peak -> 100%
   291→      const easedT = easingCurve((t - 0.5) * 2, zoom.easing);
   292→      scale = zoom.scale - (zoom.scale - 100) * easedT;
   293→    }
   294→
   295→    keyframes.push({
   296→      time: parseFloat((zoom.startTime + (i / frameRate)).toFixed(4)),
   297→      scale: [scale, scale],
   298→      anchor: zoom.centerPoint ? [
   299→        zoom.centerPoint.x * 1920, // Assume 1080p - will be scaled in builder
   300→        zoom.centerPoint.y * 1080
   301→      ] : null
   302→    });
   303→  }
   304→
   305→  return keyframes;
   306→}
   307→
   308→/**
   309→ * Add zoom data to a cut list
   310→ * @param {Object} cutList - Existing cut list
   311→ * @param {Array} zoomPoints - Zoom points to add
   312→ * @returns {Object} Cut list with zoom data
   313→ */
   314→function addZoomsToCutList(cutList, zoomPoints) {
   315→  if (!zoomPoints || zoomPoints.length === 0) {
   316→    return cutList;
   317→  }
   318→
   319→  return {
   320→    ...cutList,
   321→    zooms: zoomPoints,
   322→    metadata: {
   323→      ...cutList.metadata,
   324→      hasZooms: true,
   325→      zoomCount: zoomPoints.length
   326→    }
   327→  };
   328→}
   329→
   330→module.exports = {
   331→  generateZoomPoints,
   332→  generateZoomKeyframes,
   333→  addZoomsToCutList,
   334→  easingCurve,
   335→  findEmphasisPoints,
   336→  ZOOM_PRESETS,
   337→  ZOOM_FREQUENCIES,
   338→  PLACEMENT_STRATEGIES
   339→};
   340→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
