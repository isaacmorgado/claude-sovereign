     1→/**
     2→ * Shared Redis Client Service
     3→ * Supports both Upstash REST API and standard Redis (ioredis)
     4→ * - Uses @upstash/redis when UPSTASH_REDIS_REST_URL is configured
     5→ * - Uses ioredis when UPSTASH_REDIS_URL is configured (Railway, standard Redis)
     6→ * - Provides unified API for caching and storage operations
     7→ */
     8→
     9→const { Redis: UpstashRedis } = require('@upstash/redis');
    10→const IORedis = require('ioredis');
    11→
    12→// Singleton instances
    13→let client = null;
    14→let clientType = 'none'; // 'upstash-rest', 'ioredis', or 'none'
    15→let isConnected = false;
    16→let connectionError = null;
    17→
    18→/**
    19→ * Initialize Redis client based on available environment variables
    20→ * Priority: Upstash REST > Standard Redis URL
    21→ * @returns {Object|null} Redis client or null if not configured
    22→ */
    23→function initializeClient() {
    24→  if (client) {
    25→    return client;
    26→  }
    27→
    28→  // Try Upstash REST first (for Upstash-specific deployments)
    29→  const restUrl = process.env.UPSTASH_REDIS_REST_URL;
    30→  const restToken = process.env.UPSTASH_REDIS_REST_TOKEN;
    31→
    32→  if (restUrl && restToken) {
    33→    try {
    34→      client = new UpstashRedis({
    35→        url: restUrl,
    36→        token: restToken,
    37→        automaticDeserialization: true,
    38→      });
    39→      clientType = 'upstash-rest';
    40→      isConnected = true;
    41→      console.log('[Redis] Upstash REST client initialized');
    42→      return client;
    43→    } catch (err) {
    44→      console.error('[Redis] Failed to initialize Upstash REST client:', err.message);
    45→      connectionError = err;
    46→    }
    47→  }
    48→
    49→  // Try standard Redis URL (Railway, Docker, local Redis)
    50→  const redisUrl = process.env.UPSTASH_REDIS_URL || process.env.REDIS_URL;
    51→
    52→  if (redisUrl) {
    53→    try {
    54→      client = new IORedis(redisUrl, {
    55→        maxRetriesPerRequest: 3,
    56→        retryDelayOnFailover: 100,
    57→        lazyConnect: false,
    58→        enableReadyCheck: true,
    59→        connectTimeout: 10000,
    60→      });
    61→
    62→      client.on('connect', () => {
    63→        isConnected = true;
    64→        connectionError = null;
    65→        console.log('[Redis] ioredis client connected');
    66→      });
    67→
    68→      client.on('error', (err) => {
    69→        console.error('[Redis] ioredis error:', err.message);
    70→        connectionError = err;
    71→        // Don't set isConnected to false on transient errors
    72→      });
    73→
    74→      client.on('close', () => {
    75→        console.log('[Redis] ioredis connection closed');
    76→      });
    77→
    78→      clientType = 'ioredis';
    79→      isConnected = true; // Optimistically set, will be updated by events
    80→      console.log('[Redis] ioredis client initialized with URL');
    81→      return client;
    82→    } catch (err) {
    83→      console.error('[Redis] Failed to initialize ioredis client:', err.message);
    84→      connectionError = err;
    85→    }
    86→  }
    87→
    88→  console.warn('[Redis] No Redis configuration found - Redis features disabled');
    89→  console.warn('[Redis] Set UPSTASH_REDIS_URL for standard Redis or UPSTASH_REDIS_REST_URL + UPSTASH_REDIS_REST_TOKEN for Upstash REST');
    90→  connectionError = new Error('Redis not configured');
    91→  return null;
    92→}
    93→
    94→/**
    95→ * Get the Redis client (lazy initialization)
    96→ * @returns {Object|null} Redis client or null if not configured
    97→ */
    98→function getRedisClient() {
    99→  return initializeClient();
   100→}
   101→
   102→/**
   103→ * Check if Redis is available and connected
   104→ * @returns {boolean} True if Redis is available
   105→ */
   106→function isRedisAvailable() {
   107→  const redis = getRedisClient();
   108→  return redis !== null && isConnected;
   109→}
   110→
   111→/**
   112→ * Get Redis connection status
   113→ * @returns {Object} { connected, error, type }
   114→ */
   115→function getRedisStatus() {
   116→  getRedisClient(); // Ensure initialization attempted
   117→  return {
   118→    connected: isConnected && client !== null,
   119→    error: connectionError ? connectionError.message : null,
   120→    type: clientType
   121→  };
   122→}
   123→
   124→/**
   125→ * Ping Redis to check connectivity
   126→ * @returns {Promise<boolean>} True if ping successful
   127→ */
   128→async function pingRedis() {
   129→  const redis = getRedisClient();
   130→  if (!redis) {
   131→    return false;
   132→  }
   133→
   134→  try {
   135→    const result = await redis.ping();
   136→    const success = result === 'PONG' || result === 'pong';
   137→    if (success) {
   138→      isConnected = true;
   139→      connectionError = null;
   140→    }
   141→    return success;
   142→  } catch (err) {
   143→    console.error('[Redis] Ping failed:', err.message);
   144→    isConnected = false;
   145→    connectionError = err;
   146→    return false;
   147→  }
   148→}
   149→
   150→/**
   151→ * Set a value with optional TTL
   152→ * @param {string} key - Redis key
   153→ * @param {any} value - Value to store (will be JSON serialized for ioredis)
   154→ * @param {number} ttlSeconds - Optional TTL in seconds
   155→ * @returns {Promise<boolean>} True if successful
   156→ */
   157→async function set(key, value, ttlSeconds = null) {
   158→  const redis = getRedisClient();
   159→  if (!redis) {
   160→    return false;
   161→  }
   162→
   163→  try {
   164→    // Serialize value for ioredis (Upstash REST handles this automatically)
   165→    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;
   166→
   167→    if (clientType === 'upstash-rest') {
   168→      if (ttlSeconds) {
   169→        await redis.set(key, value, { ex: ttlSeconds });
   170→      } else {
   171→        await redis.set(key, value);
   172→      }
   173→    } else {
   174→      // ioredis syntax
   175→      if (ttlSeconds) {
   176→        await redis.set(key, serializedValue, 'EX', ttlSeconds);
   177→      } else {
   178→        await redis.set(key, serializedValue);
   179→      }
   180→    }
   181→    return true;
   182→  } catch (err) {
   183→    console.error('[Redis] SET failed:', err.message);
   184→    return false;
   185→  }
   186→}
   187→
   188→/**
   189→ * Get a value
   190→ * @param {string} key - Redis key
   191→ * @returns {Promise<any|null>} Value or null if not found
   192→ */
   193→async function get(key) {
   194→  const redis = getRedisClient();
   195→  if (!redis) {
   196→    return null;
   197→  }
   198→
   199→  try {
   200→    const result = await redis.get(key);
   201→    if (result === null) {
   202→      return null;
   203→    }
   204→    // Parse JSON for ioredis (Upstash REST handles this automatically)
   205→    if (clientType === 'ioredis' && typeof result === 'string') {
   206→      try {
   207→        return JSON.parse(result);
   208→      } catch {
   209→        return result; // Return as-is if not JSON
   210→      }
   211→    }
   212→    return result;
   213→  } catch (err) {
   214→    console.error('[Redis] GET failed:', err.message);
   215→    return null;
   216→  }
   217→}
   218→
   219→/**
   220→ * Check if a key exists
   221→ * @param {string} key - Redis key
   222→ * @returns {Promise<boolean>} True if key exists
   223→ */
   224→async function exists(key) {
   225→  const redis = getRedisClient();
   226→  if (!redis) {
   227→    return false;
   228→  }
   229→
   230→  try {
   231→    const result = await redis.exists(key);
   232→    return result === 1 || result === true;
   233→  } catch (err) {
   234→    console.error('[Redis] EXISTS failed:', err.message);
   235→    return false;
   236→  }
   237→}
   238→
   239→/**
   240→ * Delete a key
   241→ * @param {string} key - Redis key
   242→ * @returns {Promise<boolean>} True if deleted
   243→ */
   244→async function del(key) {
   245→  const redis = getRedisClient();
   246→  if (!redis) {
   247→    return false;
   248→  }
   249→
   250→  try {
   251→    await redis.del(key);
   252→    return true;
   253→  } catch (err) {
   254→    console.error('[Redis] DEL failed:', err.message);
   255→    return false;
   256→  }
   257→}
   258→
   259→/**
   260→ * Set a value only if it doesn't exist (SETNX)
   261→ * @param {string} key - Redis key
   262→ * @param {any} value - Value to store
   263→ * @param {number} ttlSeconds - Optional TTL in seconds
   264→ * @returns {Promise<boolean>} True if set (key didn't exist)
   265→ */
   266→async function setNX(key, value, ttlSeconds = null) {
   267→  const redis = getRedisClient();
   268→  if (!redis) {
   269→    return false;
   270→  }
   271→
   272→  try {
   273→    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;
   274→
   275→    if (clientType === 'upstash-rest') {
   276→      const options = { nx: true };
   277→      if (ttlSeconds) {
   278→        options.ex = ttlSeconds;
   279→      }
   280→      const result = await redis.set(key, value, options);
   281→      return result === 'OK';
   282→    } else {
   283→      // ioredis: Use SET with NX option
   284→      const args = [key, serializedValue, 'NX'];
   285→      if (ttlSeconds) {
   286→        args.push('EX', ttlSeconds);
   287→      }
   288→      const result = await redis.set(...args);
   289→      return result === 'OK';
   290→    }
   291→  } catch (err) {
   292→    console.error('[Redis] SETNX failed:', err.message);
   293→    return false;
   294→  }
   295→}
   296→
   297→/**
   298→ * Get TTL of a key
   299→ * @param {string} key - Redis key
   300→ * @returns {Promise<number>} TTL in seconds, -1 if no TTL, -2 if key doesn't exist
   301→ */
   302→async function ttl(key) {
   303→  const redis = getRedisClient();
   304→  if (!redis) {
   305→    return -2;
   306→  }
   307→
   308→  try {
   309→    return await redis.ttl(key);
   310→  } catch (err) {
   311→    console.error('[Redis] TTL failed:', err.message);
   312→    return -2;
   313→  }
   314→}
   315→
   316→/**
   317→ * Gracefully close the Redis connection
   318→ * @returns {Promise<void>}
   319→ */
   320→async function close() {
   321→  if (client && clientType === 'ioredis') {
   322→    try {
   323→      await client.quit();
   324→      console.log('[Redis] ioredis connection closed gracefully');
   325→    } catch (err) {
   326→      console.error('[Redis] Error closing connection:', err.message);
   327→    }
   328→  }
   329→  client = null;
   330→  clientType = 'none';
   331→  isConnected = false;
   332→}
   333→
   334→module.exports = {
   335→  getRedisClient,
   336→  isRedisAvailable,
   337→  getRedisStatus,
   338→  pingRedis,
   339→  close,
   340→  // Convenience methods
   341→  set,
   342→  get,
   343→  exists,
   344→  del,
   345→  setNX,
   346→  ttl
   347→};
   348→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
