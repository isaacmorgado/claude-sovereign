     1â†’/**
     2â†’ * SPLICE Animated Captions Service
     3â†’ *
     4â†’ * Generates word-by-word animated captions with popular styles.
     5â†’ * Supports keyword highlighting, emoji insertion, and multiple export formats.
     6â†’ */
     7â†’
     8â†’const OpenAI = require('openai');
     9â†’
    10â†’// Lazy-load OpenAI client
    11â†’let openai = null;
    12â†’function getOpenAI() {
    13â†’  if (!openai) {
    14â†’    openai = new OpenAI();
    15â†’  }
    16â†’  return openai;
    17â†’}
    18â†’
    19â†’// ============================================================================
    20â†’// TEMPLATE DEFINITIONS
    21â†’// ============================================================================
    22â†’
    23â†’const TEMPLATES = {
    24â†’  mrbeast: {
    25â†’    id: 'mrbeast',
    26â†’    name: 'MrBeast',
    27â†’    description: 'Bold, uppercase, colorful with shake animation',
    28â†’    style: {
    29â†’      fontFamily: 'Impact',
    30â†’      fontSize: 72,
    31â†’      fontWeight: 'bold',
    32â†’      textTransform: 'uppercase',
    33â†’      color: '#FFFFFF',
    34â†’      strokeColor: '#000000',
    35â†’      strokeWidth: 4,
    36â†’      shadowColor: 'rgba(0,0,0,0.8)',
    37â†’      shadowBlur: 8,
    38â†’      position: 'bottom-center',
    39â†’      padding: 20
    40â†’    },
    41â†’    animation: {
    42â†’      type: 'shake-scale',
    43â†’      duration: 0.15,
    44â†’      scale: 1.2,
    45â†’      shake: 3,
    46â†’      easing: 'ease-out'
    47â†’    },
    48â†’    highlight: {
    49â†’      enabled: true,
    50â†’      color: '#FFFF00',
    51â†’      keywords: ['amazing', 'insane', 'crazy', 'million', 'thousand', 'win', 'lose', 'money', 'challenge']
    52â†’    }
    53â†’  },
    54â†’
    55â†’  hormozi: {
    56â†’    id: 'hormozi',
    57â†’    name: 'Hormozi',
    58â†’    description: 'Clean, yellow highlight bar, professional',
    59â†’    style: {
    60â†’      fontFamily: 'Arial Black',
    61â†’      fontSize: 64,
    62â†’      fontWeight: 'bold',
    63â†’      textTransform: 'none',
    64â†’      color: '#FFFFFF',
    65â†’      strokeColor: '#000000',
    66â†’      strokeWidth: 2,
    67â†’      backgroundColor: 'rgba(0,0,0,0.7)',
    68â†’      position: 'bottom-center',
    69â†’      padding: 16
    70â†’    },
    71â†’    animation: {
    72â†’      type: 'slide-in',
    73â†’      duration: 0.2,
    74â†’      direction: 'left',
    75â†’      easing: 'ease-out'
    76â†’    },
    77â†’    highlight: {
    78â†’      enabled: true,
    79â†’      color: '#FFD700',
    80â†’      backgroundColor: '#FFD700',
    81â†’      textColor: '#000000',
    82â†’      keywords: ['money', 'business', 'million', 'profit', 'revenue', 'growth', 'scale']
    83â†’    }
    84â†’  },
    85â†’
    86â†’  gaming: {
    87â†’    id: 'gaming',
    88â†’    name: 'Gaming',
    89â†’    description: 'Neon glow, glitch effects, fast transitions',
    90â†’    style: {
    91â†’      fontFamily: 'Orbitron',
    92â†’      fontSize: 56,
    93â†’      fontWeight: 'bold',
    94â†’      textTransform: 'uppercase',
    95â†’      color: '#00FF00',
    96â†’      strokeColor: '#000000',
    97â†’      strokeWidth: 2,
    98â†’      glowColor: '#00FF00',
    99â†’      glowBlur: 15,
   100â†’      position: 'bottom-center',
   101â†’      padding: 12
   102â†’    },
   103â†’    animation: {
   104â†’      type: 'glitch',
   105â†’      duration: 0.1,
   106â†’      glitchIntensity: 5,
   107â†’      chromatic: true,
   108â†’      easing: 'linear'
   109â†’    },
   110â†’    highlight: {
   111â†’      enabled: true,
   112â†’      color: '#FF00FF',
   113â†’      glowColor: '#FF00FF',
   114â†’      keywords: ['kill', 'win', 'gg', 'clutch', 'epic', 'legendary', 'headshot', 'victory']
   115â†’    }
   116â†’  },
   117â†’
   118â†’  corporate: {
   119â†’    id: 'corporate',
   120â†’    name: 'Corporate',
   121â†’    description: 'Subtle, professional, clean fade animations',
   122â†’    style: {
   123â†’      fontFamily: 'Helvetica Neue',
   124â†’      fontSize: 48,
   125â†’      fontWeight: '500',
   126â†’      textTransform: 'none',
   127â†’      color: '#FFFFFF',
   128â†’      strokeColor: 'transparent',
   129â†’      strokeWidth: 0,
   130â†’      backgroundColor: 'rgba(0,0,0,0.6)',
   131â†’      borderRadius: 8,
   132â†’      position: 'bottom-center',
   133â†’      padding: 20
   134â†’    },
   135â†’    animation: {
   136â†’      type: 'fade',
   137â†’      duration: 0.3,
   138â†’      easing: 'ease-in-out'
   139â†’    },
   140â†’    highlight: {
   141â†’      enabled: false,
   142â†’      color: '#3B82F6',
   143â†’      keywords: []
   144â†’    }
   145â†’  },
   146â†’
   147â†’  karaoke: {
   148â†’    id: 'karaoke',
   149â†’    name: 'Karaoke',
   150â†’    description: 'Word-by-word highlight bar, progressive fill',
   151â†’    style: {
   152â†’      fontFamily: 'Arial',
   153â†’      fontSize: 60,
   154â†’      fontWeight: 'bold',
   155â†’      textTransform: 'none',
   156â†’      color: '#FFFFFF',
   157â†’      highlightColor: '#FFD700',
   158â†’      strokeColor: '#000000',
   159â†’      strokeWidth: 3,
   160â†’      position: 'bottom-center',
   161â†’      padding: 16
   162â†’    },
   163â†’    animation: {
   164â†’      type: 'progressive-fill',
   165â†’      duration: 'word-timed',
   166â†’      fillDirection: 'left-to-right',
   167â†’      easing: 'linear'
   168â†’    },
   169â†’    highlight: {
   170â†’      enabled: true,
   171â†’      mode: 'progressive',
   172â†’      color: '#FFD700',
   173â†’      keywords: []
   174â†’    }
   175â†’  }
   176â†’};
   177â†’
   178â†’// ============================================================================
   179â†’// EMOJI MAPPINGS
   180â†’// ============================================================================
   181â†’
   182â†’const EMOJI_MAPPINGS = {
   183â†’  // Emotions
   184â†’  happy: 'ğŸ˜Š', excited: 'ğŸ‰', sad: 'ğŸ˜¢', angry: 'ğŸ˜ ', love: 'â¤ï¸', laugh: 'ğŸ˜‚',
   185â†’  surprise: 'ğŸ˜®', think: 'ğŸ¤”', cool: 'ğŸ˜', fire: 'ğŸ”¥', hot: 'ğŸ”¥',
   186â†’
   187â†’  // Actions
   188â†’  win: 'ğŸ†', lose: 'ğŸ˜', money: 'ğŸ’°', work: 'ğŸ’¼', sleep: 'ğŸ˜´', eat: 'ğŸ½ï¸',
   189â†’  drink: 'ğŸº', play: 'ğŸ®', music: 'ğŸµ', video: 'ğŸ¬', phone: 'ğŸ“±',
   190â†’
   191â†’  // Objects
   192â†’  car: 'ğŸš—', house: 'ğŸ ', computer: 'ğŸ’»', camera: 'ğŸ“·', book: 'ğŸ“š',
   193â†’
   194â†’  // Emphasis
   195â†’  important: 'âš ï¸', question: 'â“', check: 'âœ…', cross: 'âŒ', star: 'â­',
   196â†’  rocket: 'ğŸš€', target: 'ğŸ¯', idea: 'ğŸ’¡', time: 'â°', point: 'ğŸ‘‰'
   197â†’};
   198â†’
   199â†’// ============================================================================
   200â†’// MAIN FUNCTIONS
   201â†’// ============================================================================
   202â†’
   203â†’/**
   204â†’ * Generate animated captions from transcript
   205â†’ * @param {Object} transcript - Transcript with words array (word, start, end)
   206â†’ * @param {string} templateId - Template to apply
   207â†’ * @param {Object} settings - Custom settings
   208â†’ * @returns {Promise<Object>} Animated caption data
   209â†’ */
   210â†’async function generateAnimatedCaptions(transcript, templateId = 'mrbeast', settings = {}) {
   211â†’  const {
   212â†’    maxWordsPerLine = 4,
   213â†’    highlightKeywords = true,
   214â†’    insertEmojis = false,
   215â†’    emojiFrequency = 'medium', // low, medium, high
   216â†’    customKeywords = []
   217â†’    // language = 'en' - reserved for future i18n
   218â†’  } = settings;
   219â†’
   220â†’  // Get template
   221â†’  const template = TEMPLATES[templateId] || TEMPLATES.mrbeast;
   222â†’
   223â†’  // Extract words from transcript
   224â†’  const words = extractWords(transcript);
   225â†’
   226â†’  if (!words || words.length === 0) {
   227â†’    return {
   228â†’      success: false,
   229â†’      error: 'No words found in transcript',
   230â†’      captions: []
   231â†’    };
   232â†’  }
   233â†’
   234â†’  console.log(`[SPLICE Captions] Generating ${templateId} captions for ${words.length} words`);
   235â†’
   236â†’  // Group words into caption lines
   237â†’  const lines = groupWordsIntoLines(words, maxWordsPerLine);
   238â†’
   239â†’  // Detect keywords if enabled
   240â†’  let keywords = [];
   241â†’  if (highlightKeywords) {
   242â†’    keywords = await detectKeywords(transcript, {
   243â†’      customKeywords,
   244â†’      templateKeywords: template.highlight.keywords || []
   245â†’    });
   246â†’  }
   247â†’
   248â†’  // Generate caption data for each line
   249â†’  const captions = lines.map((line, index) => {
   250â†’    const lineWords = line.words.map(word => {
   251â†’      const isKeyword = keywords.some(kw =>
   252â†’        word.word.toLowerCase().includes(kw.toLowerCase())
   253â†’      );
   254â†’
   255â†’      return {
   256â†’        word: word.word,
   257â†’        start: word.start,
   258â†’        end: word.end,
   259â†’        isKeyword,
   260â†’        emoji: insertEmojis ? getEmojiForWord(word.word, emojiFrequency) : null
   261â†’      };
   262â†’    });
   263â†’
   264â†’    return {
   265â†’      id: `caption_${index}`,
   266â†’      lineNumber: index + 1,
   267â†’      text: line.text,
   268â†’      words: lineWords,
   269â†’      start: line.start,
   270â†’      end: line.end,
   271â†’      duration: line.end - line.start,
   272â†’      template: templateId,
   273â†’      style: { ...template.style },
   274â†’      animation: { ...template.animation }
   275â†’    };
   276â†’  });
   277â†’
   278â†’  // Insert emojis if enabled
   279â†’  let finalCaptions = captions;
   280â†’  if (insertEmojis) {
   281â†’    finalCaptions = addEmojisToCaption(captions, emojiFrequency);
   282â†’  }
   283â†’
   284â†’  return {
   285â†’    success: true,
   286â†’    template: templateId,
   287â†’    templateInfo: {
   288â†’      name: template.name,
   289â†’      description: template.description
   290â†’    },
   291â†’    totalCaptions: finalCaptions.length,
   292â†’    totalWords: words.length,
   293â†’    duration: words[words.length - 1]?.end || 0,
   294â†’    captions: finalCaptions,
   295â†’    keywords: keywords,
   296â†’    metadata: {
   297â†’      maxWordsPerLine,
   298â†’      highlightKeywords,
   299â†’      insertEmojis,
   300â†’      emojiFrequency
   301â†’    }
   302â†’  };
   303â†’}
   304â†’
   305â†’/**
   306â†’ * Detect keywords using AI
   307â†’ * @param {Object} transcript - Transcript data
   308â†’ * @param {Object} options - Detection options
   309â†’ * @returns {Promise<string[]>} Array of keywords
   310â†’ */
   311â†’async function detectKeywords(transcript, options = {}) {
   312â†’  const {
   313â†’    customKeywords = [],
   314â†’    templateKeywords = [],
   315â†’    maxKeywords = 20,
   316â†’    useAI = true
   317â†’  } = options;
   318â†’
   319â†’  // Start with template and custom keywords
   320â†’  let keywords = [...new Set([...templateKeywords, ...customKeywords])];
   321â†’
   322â†’  if (!useAI) {
   323â†’    return keywords.slice(0, maxKeywords);
   324â†’  }
   325â†’
   326â†’  // Extract text
   327â†’  const text = extractText(transcript);
   328â†’  if (!text || text.length < 50) {
   329â†’    return keywords.slice(0, maxKeywords);
   330â†’  }
   331â†’
   332â†’  try {
   333â†’    console.log('[SPLICE Captions] Detecting keywords with AI...');
   334â†’
   335â†’    const response = await getOpenAI().chat.completions.create({
   336â†’      model: 'gpt-4o-mini',
   337â†’      messages: [
   338â†’        {
   339â†’          role: 'system',
   340â†’          content: 'You are a keyword extraction expert. Extract impactful words that should be highlighted in video captions for emphasis and engagement.'
   341â†’        },
   342â†’        {
   343â†’          role: 'user',
   344â†’          content: `Extract ${maxKeywords} keywords from this transcript that would be impactful to highlight in animated captions. Focus on: numbers, emotional words, action words, important nouns, and phrases that viewers would want emphasized.
   345â†’
   346â†’TRANSCRIPT:
   347â†’${text.substring(0, 3000)}
   348â†’
   349â†’Return JSON: { "keywords": ["word1", "word2", ...] }`
   350â†’        }
   351â†’      ],
   352â†’      temperature: 0.5,
   353â†’      max_tokens: 200,
   354â†’      response_format: { type: 'json_object' }
   355â†’    });
   356â†’
   357â†’    const content = response.choices?.[0]?.message?.content;
   358â†’    if (!content) {
   359â†’      throw new Error('No response from AI service');
   360â†’    }
   361â†’    const result = JSON.parse(content);
   362â†’    const aiKeywords = result.keywords || [];
   363â†’
   364â†’    // Merge with existing keywords
   365â†’    keywords = [...new Set([...keywords, ...aiKeywords])];
   366â†’
   367â†’    console.log(`[SPLICE Captions] Detected ${aiKeywords.length} AI keywords`);
   368â†’
   369â†’  } catch (err) {
   370â†’    console.error('[SPLICE Captions] Keyword detection error:', err.message);
   371â†’    // Continue with template/custom keywords only
   372â†’  }
   373â†’
   374â†’  return keywords.slice(0, maxKeywords);
   375â†’}
   376â†’
   377â†’/**
   378â†’ * Insert emojis into transcript based on context
   379â†’ * @param {Object} transcript - Transcript data
   380â†’ * @param {Object} options - Emoji options
   381â†’ * @returns {Promise<Object>} Transcript with emoji suggestions
   382â†’ */
   383â†’async function insertEmojis(transcript, options = {}) {
   384â†’  const {
   385â†’    frequency = 'medium', // low (~1 per 30 words), medium (~1 per 15 words), high (~1 per 8 words)
   386â†’    // position = 'after', // before, after, replace - reserved for future use
   387â†’    useAI = true
   388â†’  } = options;
   389â†’
   390â†’  const frequencyMap = { low: 30, medium: 15, high: 8 };
   391â†’  const interval = frequencyMap[frequency] || 15;
   392â†’
   393â†’  const words = extractWords(transcript);
   394â†’  if (!words || words.length === 0) {
   395â†’    return { success: false, error: 'No words found', emojis: [] };
   396â†’  }
   397â†’
   398â†’  const emojis = [];
   399â†’
   400â†’  if (useAI) {
   401â†’    // Use AI to suggest contextual emojis
   402â†’    try {
   403â†’      const text = extractText(transcript);
   404â†’      const response = await getOpenAI().chat.completions.create({
   405â†’        model: 'gpt-4o-mini',
   406â†’        messages: [
   407â†’          {
   408â†’            role: 'system',
   409â†’            content: 'You suggest contextually appropriate emojis for video captions. Return relevant emojis that match the tone and content.'
   410â†’          },
   411â†’          {
   412â†’            role: 'user',
   413â†’            content: `Suggest emojis to insert into this transcript at approximately every ${interval} words. Return the word index and emoji.
   414â†’
   415â†’TRANSCRIPT (${words.length} words):
   416â†’${text.substring(0, 2000)}
   417â†’
   418â†’Return JSON: { "emojis": [{ "afterWordIndex": 5, "emoji": "ğŸ”¥" }, ...] }`
   419â†’          }
   420â†’        ],
   421â†’        temperature: 0.7,
   422â†’        max_tokens: 300,
   423â†’        response_format: { type: 'json_object' }
   424â†’      });
   425â†’
   426â†’      const content = response.choices?.[0]?.message?.content;
   427â†’      if (!content) {
   428â†’        throw new Error('No response from AI service');
   429â†’      }
   430â†’      const result = JSON.parse(content);
   431â†’      emojis.push(...(result.emojis || []));
   432â†’
   433â†’    } catch (err) {
   434â†’      console.error('[SPLICE Captions] Emoji insertion error:', err.message);
   435â†’      // Fall back to rule-based
   436â†’    }
   437â†’  }
   438â†’
   439â†’  // Rule-based fallback/supplement
   440â†’  if (emojis.length === 0) {
   441â†’    words.forEach((word, index) => {
   442â†’      if (index % interval === 0 && index > 0) {
   443â†’        const emoji = getEmojiForWord(word.word, frequency);
   444â†’        if (emoji) {
   445â†’          emojis.push({ afterWordIndex: index, emoji, word: word.word });
   446â†’        }
   447â†’      }
   448â†’    });
   449â†’  }
   450â†’
   451â†’  return {
   452â†’    success: true,
   453â†’    totalEmojis: emojis.length,
   454â†’    frequency,
   455â†’    emojis
   456â†’  };
   457â†’}
   458â†’
   459â†’/**
   460â†’ * Apply template to caption data
   461â†’ * @param {Object} captionData - Existing caption data
   462â†’ * @param {string} templateId - Template to apply
   463â†’ * @returns {Object} Caption data with new template applied
   464â†’ */
   465â†’function applyTemplate(captionData, templateId) {
   466â†’  const template = TEMPLATES[templateId];
   467â†’  if (!template) {
   468â†’    return {
   469â†’      success: false,
   470â†’      error: `Template '${templateId}' not found`,
   471â†’      availableTemplates: Object.keys(TEMPLATES)
   472â†’    };
   473â†’  }
   474â†’
   475â†’  const updatedCaptions = captionData.captions.map(caption => ({
   476â†’    ...caption,
   477â†’    template: templateId,
   478â†’    style: { ...template.style },
   479â†’    animation: { ...template.animation }
   480â†’  }));
   481â†’
   482â†’  return {
   483â†’    success: true,
   484â†’    template: templateId,
   485â†’    templateInfo: {
   486â†’      name: template.name,
   487â†’      description: template.description
   488â†’    },
   489â†’    captions: updatedCaptions
   490â†’  };
   491â†’}
   492â†’
   493â†’/**
   494â†’ * Generate MOGRT-compatible data for After Effects/Premiere
   495â†’ * @param {Array} captions - Caption data array
   496â†’ * @param {Object} settings - MOGRT settings
   497â†’ * @returns {Object} MOGRT-compatible JSON
   498â†’ */
   499â†’function generateMOGRTData(captions, settings = {}) {
   500â†’  const {
   501â†’    frameRate = 30,
   502â†’    width = 1920,
   503â†’    height = 1080,
   504â†’    outputFormat = 'json'
   505â†’  } = settings;
   506â†’
   507â†’  const mogrtData = {
   508â†’    version: '1.0',
   509â†’    type: 'animated_captions',
   510â†’    composition: {
   511â†’      width,
   512â†’      height,
   513â†’      frameRate,
   514â†’      duration: captions.length > 0 ? captions[captions.length - 1].end : 0
   515â†’    },
   516â†’    layers: captions.map((caption, index) => ({
   517â†’      id: `text_layer_${index}`,
   518â†’      type: 'text',
   519â†’      name: `Caption ${index + 1}`,
   520â†’      inPoint: Math.round(caption.start * frameRate),
   521â†’      outPoint: Math.round(caption.end * frameRate),
   522â†’      inPointSeconds: caption.start,
   523â†’      outPointSeconds: caption.end,
   524â†’      content: {
   525â†’        text: caption.text,
   526â†’        words: caption.words.map(w => ({
   527â†’          text: w.word,
   528â†’          inFrame: Math.round(w.start * frameRate),
   529â†’          outFrame: Math.round(w.end * frameRate),
   530â†’          isKeyword: w.isKeyword || false,
   531â†’          emoji: w.emoji || null
   532â†’        }))
   533â†’      },
   534â†’      style: caption.style,
   535â†’      animation: {
   536â†’        ...caption.animation,
   537â†’        keyframes: generateKeyframes(caption, frameRate)
   538â†’      }
   539â†’    })),
   540â†’    metadata: {
   541â†’      totalLayers: captions.length,
   542â†’      generatedAt: new Date().toISOString(),
   543â†’      generator: 'SPLICE Animated Captions'
   544â†’    }
   545â†’  };
   546â†’
   547â†’  return {
   548â†’    success: true,
   549â†’    format: outputFormat,
   550â†’    data: mogrtData
   551â†’  };
   552â†’}
   553â†’
   554â†’/**
   555â†’ * Export captions burned into video (requires FFmpeg)
   556â†’ * @param {string} videoPath - Source video path
   557â†’ * @param {Array} captions - Caption data
   558â†’ * @param {string} outputPath - Output video path
   559â†’ * @returns {Promise<Object>} Export result
   560â†’ */
   561â†’async function exportBurnedInCaptions(videoPath, captions, outputPath) {
   562â†’  // This would require FFmpeg integration
   563â†’  // For now, return ASS subtitle format that can be burned in
   564â†’
   565â†’  const assContent = generateASSSubtitles(captions);
   566â†’
   567â†’  return {
   568â†’    success: true,
   569â†’    format: 'ass',
   570â†’    subtitleContent: assContent,
   571â†’    ffmpegCommand: `ffmpeg -i "${videoPath}" -vf "ass=captions.ass" -c:a copy "${outputPath}"`,
   572â†’    instructions: 'Save subtitleContent to captions.ass and run the ffmpegCommand'
   573â†’  };
   574â†’}
   575â†’
   576â†’/**
   577â†’ * Get all available templates
   578â†’ * @returns {Object} Templates with metadata
   579â†’ */
   580â†’function getTemplates() {
   581â†’  return {
   582â†’    templates: Object.values(TEMPLATES).map(t => ({
   583â†’      id: t.id,
   584â†’      name: t.name,
   585â†’      description: t.description,
   586â†’      previewStyle: {
   587â†’        fontFamily: t.style.fontFamily,
   588â†’        color: t.style.color,
   589â†’        animation: t.animation.type
   590â†’      }
   591â†’    })),
   592â†’    count: Object.keys(TEMPLATES).length
   593â†’  };
   594â†’}
   595â†’
   596â†’/**
   597â†’ * Get template by ID
   598â†’ * @param {string} templateId - Template ID
   599â†’ * @returns {Object|null} Template or null
   600â†’ */
   601â†’function getTemplateById(templateId) {
   602â†’  return TEMPLATES[templateId] || null;
   603â†’}
   604â†’
   605â†’// ============================================================================
   606â†’// HELPER FUNCTIONS
   607â†’// ============================================================================
   608â†’
   609â†’/**
   610â†’ * Extract words array from transcript
   611â†’ */
   612â†’function extractWords(transcript) {
   613â†’  if (!transcript) return [];
   614â†’
   615â†’  // Direct words array
   616â†’  if (Array.isArray(transcript.words)) {
   617â†’    return transcript.words.map(w => ({
   618â†’      word: w.word || w.text || '',
   619â†’      start: w.start || 0,
   620â†’      end: w.end || 0
   621â†’    }));
   622â†’  }
   623â†’
   624â†’  // Words in segments
   625â†’  if (Array.isArray(transcript.segments)) {
   626â†’    const words = [];
   627â†’    transcript.segments.forEach(seg => {
   628â†’      if (Array.isArray(seg.words)) {
   629â†’        seg.words.forEach(w => {
   630â†’          words.push({
   631â†’            word: w.word || w.text || '',
   632â†’            start: w.start || 0,
   633â†’            end: w.end || 0
   634â†’          });
   635â†’        });
   636â†’      }
   637â†’    });
   638â†’    return words;
   639â†’  }
   640â†’
   641â†’  return [];
   642â†’}
   643â†’
   644â†’/**
   645â†’ * Extract plain text from transcript
   646â†’ */
   647â†’function extractText(transcript) {
   648â†’  if (typeof transcript === 'string') return transcript;
   649â†’  if (transcript.text) return transcript.text;
   650â†’
   651â†’  const words = extractWords(transcript);
   652â†’  return words.map(w => w.word).join(' ');
   653â†’}
   654â†’
   655â†’/**
   656â†’ * Group words into caption lines
   657â†’ */
   658â†’function groupWordsIntoLines(words, maxWordsPerLine = 4) {
   659â†’  const lines = [];
   660â†’  let currentLine = { words: [], text: '', start: 0, end: 0 };
   661â†’
   662â†’  words.forEach((word, index) => {
   663â†’    if (currentLine.words.length === 0) {
   664â†’      currentLine.start = word.start;
   665â†’    }
   666â†’
   667â†’    currentLine.words.push(word);
   668â†’    currentLine.end = word.end;
   669â†’
   670â†’    // Check if we should start a new line
   671â†’    const shouldBreak =
   672â†’      currentLine.words.length >= maxWordsPerLine ||
   673â†’      (word.word.endsWith('.') || word.word.endsWith('!') || word.word.endsWith('?'));
   674â†’
   675â†’    if (shouldBreak || index === words.length - 1) {
   676â†’      currentLine.text = currentLine.words.map(w => w.word).join(' ');
   677â†’      lines.push({ ...currentLine });
   678â†’      currentLine = { words: [], text: '', start: 0, end: 0 };
   679â†’    }
   680â†’  });
   681â†’
   682â†’  return lines;
   683â†’}
   684â†’
   685â†’/**
   686â†’ * Get emoji for a word based on mappings
   687â†’ */
   688â†’function getEmojiForWord(word, frequency = 'medium') {
   689â†’  const lowerWord = word.toLowerCase().replace(/[^a-z]/g, '');
   690â†’
   691â†’  // Direct mapping
   692â†’  if (EMOJI_MAPPINGS[lowerWord]) {
   693â†’    return EMOJI_MAPPINGS[lowerWord];
   694â†’  }
   695â†’
   696â†’  // Partial matches for high frequency
   697â†’  if (frequency === 'high') {
   698â†’    for (const [key, emoji] of Object.entries(EMOJI_MAPPINGS)) {
   699â†’      if (lowerWord.includes(key) || key.includes(lowerWord)) {
   700â†’        return emoji;
   701â†’      }
   702â†’    }
   703â†’  }
   704â†’
   705â†’  return null;
   706â†’}
   707â†’
   708â†’/**
   709â†’ * Add emojis to captions
   710â†’ */
   711â†’function addEmojisToCaption(captions, frequency) {
   712â†’  const frequencyMap = { low: 3, medium: 2, high: 1 };
   713â†’  const interval = frequencyMap[frequency] || 2;
   714â†’
   715â†’  return captions.map((caption, index) => {
   716â†’    if (index % interval === 0) {
   717â†’      // Try to find an emoji for any word in the caption
   718â†’      for (const word of caption.words) {
   719â†’        const emoji = getEmojiForWord(word.word, frequency);
   720â†’        if (emoji) {
   721â†’          return {
   722â†’            ...caption,
   723â†’            emoji,
   724â†’            text: `${caption.text} ${emoji}`
   725â†’          };
   726â†’        }
   727â†’      }
   728â†’    }
   729â†’    return caption;
   730â†’  });
   731â†’}
   732â†’
   733â†’/**
   734â†’ * Generate animation keyframes
   735â†’ */
   736â†’function generateKeyframes(caption, frameRate) {
   737â†’  const { animation, start, end } = caption;
   738â†’  const startFrame = Math.round(start * frameRate);
   739â†’  const endFrame = Math.round(end * frameRate);
   740â†’  const duration = animation.duration === 'word-timed' ?
   741â†’    (end - start) / caption.words.length :
   742â†’    animation.duration;
   743â†’  const durationFrames = Math.round(duration * frameRate);
   744â†’
   745â†’  const keyframes = [];
   746â†’
   747â†’  switch (animation.type) {
   748â†’    case 'shake-scale':
   749â†’      keyframes.push(
   750â†’        { frame: startFrame, scale: 1, x: 0, y: 0, opacity: 0 },
   751â†’        { frame: startFrame + 2, scale: animation.scale || 1.2, x: 0, y: 0, opacity: 1 },
   752â†’        { frame: startFrame + 4, scale: 1, x: animation.shake || 3, y: 0, opacity: 1 },
   753â†’        { frame: startFrame + 6, scale: 1, x: -(animation.shake || 3), y: 0, opacity: 1 },
   754â†’        { frame: startFrame + 8, scale: 1, x: 0, y: 0, opacity: 1 },
   755â†’        { frame: endFrame - 2, scale: 1, x: 0, y: 0, opacity: 1 },
   756â†’        { frame: endFrame, scale: 0.8, x: 0, y: 0, opacity: 0 }
   757â†’      );
   758â†’      break;
   759â†’
   760â†’    case 'slide-in': {
   761â†’      const direction = animation.direction || 'left';
   762â†’      const offset = direction === 'left' ? -100 : 100;
   763â†’      keyframes.push(
   764â†’        { frame: startFrame, x: offset, opacity: 0 },
   765â†’        { frame: startFrame + durationFrames, x: 0, opacity: 1 },
   766â†’        { frame: endFrame - durationFrames, x: 0, opacity: 1 },
   767â†’        { frame: endFrame, x: -offset, opacity: 0 }
   768â†’      );
   769â†’      break;
   770â†’    }
   771â†’
   772â†’    case 'glitch':
   773â†’      keyframes.push(
   774â†’        { frame: startFrame, opacity: 0, glitch: 0 },
   775â†’        { frame: startFrame + 1, opacity: 1, glitch: animation.glitchIntensity || 5 },
   776â†’        { frame: startFrame + 2, opacity: 1, glitch: 0 },
   777â†’        { frame: startFrame + 3, opacity: 0.5, glitch: animation.glitchIntensity || 5 },
   778â†’        { frame: startFrame + 4, opacity: 1, glitch: 0 },
   779â†’        { frame: endFrame, opacity: 0, glitch: 0 }
   780â†’      );
   781â†’      break;
   782â†’
   783â†’    case 'fade':
   784â†’      keyframes.push(
   785â†’        { frame: startFrame, opacity: 0 },
   786â†’        { frame: startFrame + durationFrames, opacity: 1 },
   787â†’        { frame: endFrame - durationFrames, opacity: 1 },
   788â†’        { frame: endFrame, opacity: 0 }
   789â†’      );
   790â†’      break;
   791â†’
   792â†’    case 'progressive-fill':
   793â†’      // For karaoke-style, generate keyframe per word
   794â†’      caption.words.forEach((word, i) => {
   795â†’        const wordStart = Math.round(word.start * frameRate);
   796â†’        // wordEnd could be used for duration-based animations
   797â†’        keyframes.push({
   798â†’          frame: wordStart,
   799â†’          wordIndex: i,
   800â†’          fillProgress: i / caption.words.length,
   801â†’          highlighted: true
   802â†’        });
   803â†’      });
   804â†’      break;
   805â†’
   806â†’    default:
   807â†’      keyframes.push(
   808â†’        { frame: startFrame, opacity: 1 },
   809â†’        { frame: endFrame, opacity: 1 }
   810â†’      );
   811â†’  }
   812â†’
   813â†’  return keyframes;
   814â†’}
   815â†’
   816â†’/**
   817â†’ * Generate ASS subtitle format
   818â†’ */
   819â†’function generateASSSubtitles(captions) {
   820â†’  const template = captions[0]?.style || TEMPLATES.mrbeast.style;
   821â†’
   822â†’  let ass = `[Script Info]
   823â†’Title: SPLICE Animated Captions
   824â†’ScriptType: v4.00+
   825â†’WrapStyle: 0
   826â†’ScaledBorderAndShadow: yes
   827â†’PlayResX: 1920
   828â†’PlayResY: 1080
   829â†’
   830â†’[V4+ Styles]
   831â†’Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
   832â†’Style: Default,${template.fontFamily || 'Arial'},${template.fontSize || 64},&H00FFFFFF,&H000000FF,&H00000000,&H80000000,1,0,0,0,100,100,0,0,1,3,2,2,10,10,50,1
   833â†’
   834â†’[Events]
   835â†’Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
   836â†’`;
   837â†’
   838â†’  captions.forEach(caption => {
   839â†’    const start = formatASSTime(caption.start);
   840â†’    const end = formatASSTime(caption.end);
   841â†’    // Escape special characters and add styling
   842â†’    const text = caption.text.replace(/\\/g, '\\\\').replace(/\n/g, '\\N');
   843â†’    ass += `Dialogue: 0,${start},${end},Default,,0,0,0,,${text}\n`;
   844â†’  });
   845â†’
   846â†’  return ass;
   847â†’}
   848â†’
   849â†’/**
   850â†’ * Format time for ASS subtitles
   851â†’ */
   852â†’function formatASSTime(seconds) {
   853â†’  const h = Math.floor(seconds / 3600);
   854â†’  const m = Math.floor((seconds % 3600) / 60);
   855â†’  const s = Math.floor(seconds % 60);
   856â†’  const cs = Math.floor((seconds % 1) * 100);
   857â†’  return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${cs.toString().padStart(2, '0')}`;
   858â†’}
   859â†’
   860â†’// ============================================================================
   861â†’// EXPORTS
   862â†’// ============================================================================
   863â†’
   864â†’module.exports = {
   865â†’  generateAnimatedCaptions,
   866â†’  detectKeywords,
   867â†’  insertEmojis,
   868â†’  applyTemplate,
   869â†’  generateMOGRTData,
   870â†’  exportBurnedInCaptions,
   871â†’  getTemplates,
   872â†’  getTemplateById,
   873â†’  // Helpers exposed for testing
   874â†’  extractWords,
   875â†’  extractText,
   876â†’  groupWordsIntoLines,
   877â†’  getEmojiForWord,
   878â†’  TEMPLATES,
   879â†’  EMOJI_MAPPINGS
   880â†’};
   881â†’

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
