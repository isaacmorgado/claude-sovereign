     1→/**
     2→ * SPLICE Plugin Configuration
     3→ *
     4→ * Constants and configuration values used across all slices.
     5→ */
     6→
     7→// Backend API configuration
     8→const BACKEND_URL_DEV = 'https://127.0.0.1:3847';
     9→const BACKEND_URL_PROD = 'https://splice-api-production.up.railway.app';
    10→
    11→// Default to dev URL - production detection handled by getBackendUrl()
    12→const BACKEND_URL = BACKEND_URL_DEV;
    13→
    14→/**
    15→ * Get the backend URL with consistent fallback logic.
    16→ * Used across all plugin modules for API calls.
    17→ * @returns {string} Backend API base URL
    18→ */
    19→function getBackendUrl() {
    20→  // Check if explicitly defined
    21→  if (typeof BACKEND_URL !== 'undefined' && BACKEND_URL) {
    22→    return BACKEND_URL;
    23→  }
    24→  // Fallback to dev URL (use 127.0.0.1, not localhost - UXP requirement)
    25→  return BACKEND_URL_DEV;
    26→}
    27→
    28→// File paths - initialized dynamically for cross-platform support
    29→// These are populated by initPaths() on plugin load
    30→let WAV_PATH = null;
    31→let XML_PATH = null;
    32→let WAV_PRESET_PATH = null;
    33→
    34→// Cache for initialized paths
    35→let _pathsInitialized = false;
    36→
    37→/**
    38→ * Initialize file paths using UXP localFileSystem API.
    39→ * Must be called once on plugin load before using file operations.
    40→ * Cross-platform: works on macOS and Windows.
    41→ * @returns {Promise<{wavPath: string, xmlPath: string, presetPath: string|null}>}
    42→ */
    43→async function initPaths() {
    44→  if (_pathsInitialized && WAV_PATH && XML_PATH) {
    45→    return { wavPath: WAV_PATH, xmlPath: XML_PATH, presetPath: WAV_PRESET_PATH };
    46→  }
    47→
    48→  try {
    49→    const { localFileSystem } = require('uxp').storage;
    50→
    51→    // Get UXP temp folder (cross-platform)
    52→    const tempFolder = await localFileSystem.getTemporaryFolder();
    53→
    54→    // Create temp files in UXP temp directory
    55→    const wavFile = await tempFolder.createFile('splice_audio_export.wav', { overwrite: true });
    56→    const xmlFile = await tempFolder.createFile('splice_export.xml', { overwrite: true });
    57→
    58→    WAV_PATH = wavFile.nativePath;
    59→    XML_PATH = xmlFile.nativePath;
    60→
    61→    // Detect Premiere Pro preset path dynamically
    62→    WAV_PRESET_PATH = await detectPresetPath();
    63→
    64→    _pathsInitialized = true;
    65→    console.log('[SPLICE Config] Paths initialized:', { WAV_PATH, XML_PATH, WAV_PRESET_PATH });
    66→
    67→    return { wavPath: WAV_PATH, xmlPath: XML_PATH, presetPath: WAV_PRESET_PATH };
    68→  } catch (err) {
    69→    console.error('[SPLICE Config] Failed to initialize paths:', err);
    70→
    71→    // Fallback to platform-specific temp paths
    72→    const isMac = navigator.platform.toLowerCase().includes('mac');
    73→    const tempDir = isMac ? '/tmp' : (process.env.TEMP || process.env.TMP || 'C:\\Windows\\Temp');
    74→
    75→    WAV_PATH = `${tempDir}/splice_audio_export.wav`;
    76→    XML_PATH = `${tempDir}/splice_export.xml`;
    77→    WAV_PRESET_PATH = await detectPresetPath();
    78→
    79→    _pathsInitialized = true;
    80→    console.log('[SPLICE Config] Using fallback paths:', { WAV_PATH, XML_PATH, WAV_PRESET_PATH });
    81→
    82→    return { wavPath: WAV_PATH, xmlPath: XML_PATH, presetPath: WAV_PRESET_PATH };
    83→  }
    84→}
    85→
    86→/**
    87→ * Detect Premiere Pro encoder preset path dynamically.
    88→ * Searches multiple possible locations for different versions.
    89→ * @returns {Promise<string|null>} Preset path or null if not found
    90→ */
    91→async function detectPresetPath() {
    92→  const isMac = navigator.platform.toLowerCase().includes('mac');
    93→
    94→  // Possible Premiere Pro installation paths
    95→  const possiblePaths = isMac ? [
    96→    // macOS paths - try multiple versions
    97→    '/Applications/Adobe Premiere Pro 2025/Adobe Premiere Pro 2025.app/Contents/Settings/EncoderPresets/Wave48mono16.epr',
    98→    '/Applications/Adobe Premiere Pro (Beta)/Adobe Premiere Pro (Beta).app/Contents/Settings/EncoderPresets/Wave48mono16.epr',
    99→    '/Applications/Adobe Premiere Pro 2024/Adobe Premiere Pro 2024.app/Contents/Settings/EncoderPresets/Wave48mono16.epr',
   100→    '/Applications/Adobe Premiere Pro/Adobe Premiere Pro.app/Contents/Settings/EncoderPresets/Wave48mono16.epr'
   101→  ] : [
   102→    // Windows paths
   103→    'C:\\Program Files\\Adobe\\Adobe Premiere Pro 2025\\Settings\\EncoderPresets\\Wave48mono16.epr',
   104→    'C:\\Program Files\\Adobe\\Adobe Premiere Pro (Beta)\\Settings\\EncoderPresets\\Wave48mono16.epr',
   105→    'C:\\Program Files\\Adobe\\Adobe Premiere Pro 2024\\Settings\\EncoderPresets\\Wave48mono16.epr',
   106→    'C:\\Program Files\\Adobe\\Adobe Premiere Pro\\Settings\\EncoderPresets\\Wave48mono16.epr'
   107→  ];
   108→
   109→  // Try to find existing preset file
   110→  try {
   111→    const { localFileSystem } = require('uxp').storage;
   112→
   113→    for (const path of possiblePaths) {
   114→      try {
   115→        // Use UXP entry API to check if file exists
   116→        const entry = await localFileSystem.getEntryWithUrl('file://' + encodeURI(path));
   117→        if (entry) {
   118→          console.log('[SPLICE Config] Found preset at:', path);
   119→          return path;
   120→        }
   121→      } catch (e) {
   122→        // File doesn't exist at this path, continue checking
   123→      }
   124→    }
   125→  } catch (err) {
   126→    console.warn('[SPLICE Config] Could not check preset paths:', err);
   127→  }
   128→
   129→  // Return first path as fallback (user can manually configure if needed)
   130→  console.warn('[SPLICE Config] Preset path not found, using default');
   131→  return possiblePaths[0];
   132→}
   133→
   134→/**
   135→ * Get initialized paths (async getter).
   136→ * Ensures paths are initialized before returning.
   137→ * @returns {Promise<{wavPath: string, xmlPath: string, presetPath: string|null}>}
   138→ */
   139→async function getPaths() {
   140→  if (!_pathsInitialized) {
   141→    return await initPaths();
   142→  }
   143→  return { wavPath: WAV_PATH, xmlPath: XML_PATH, presetPath: WAV_PRESET_PATH };
   144→}
   145→
   146→/**
   147→ * Check if a path exists and is accessible.
   148→ * @param {string} path - File path to check
   149→ * @returns {Promise<boolean>} True if path exists
   150→ */
   151→async function pathExists(path) {
   152→  if (!path) return false;
   153→
   154→  try {
   155→    const { localFileSystem } = require('uxp').storage;
   156→    const entry = await localFileSystem.getEntryWithUrl('file://' + encodeURI(path));
   157→    return entry !== null;
   158→  } catch {
   159→    return false;
   160→  }
   161→}
   162→
   163→// Premiere Pro timebase (ticks per second)
   164→const TICKS_PER_SECOND = 254016000000;
   165→
   166→// Fetch timeout configuration (milliseconds)
   167→const FETCH_TIMEOUT_DEFAULT = 30000;      // 30 seconds for most requests
   168→const FETCH_TIMEOUT_HEALTH = 5000;        // 5 seconds for health checks
   169→const FETCH_TIMEOUT_PROCESSING = 120000;  // 2 minutes for processing endpoints
   170→
   171→/**
   172→ * Fetch with timeout support (AbortController-based).
   173→ * Prevents UI from freezing if server hangs.
   174→ * @param {string} url - URL to fetch
   175→ * @param {Object} options - Fetch options
   176→ * @param {number} [timeout] - Timeout in milliseconds (default: FETCH_TIMEOUT_DEFAULT)
   177→ * @returns {Promise<Response>} Fetch response
   178→ * @throws {Error} 'Request timed out' if timeout exceeded
   179→ */
   180→async function fetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT_DEFAULT) {
   181→  const controller = new AbortController();
   182→  const timeoutId = setTimeout(() => controller.abort(), timeout);
   183→
   184→  try {
   185→    const response = await fetch(url, {
   186→      ...options,
   187→      signal: controller.signal
   188→    });
   189→    clearTimeout(timeoutId);
   190→    return response;
   191→  } catch (err) {
   192→    clearTimeout(timeoutId);
   193→    if (err.name === 'AbortError') {
   194→      throw new Error('Request timed out');
   195→    }
   196→    throw err;
   197→  }
   198→}
   199→
   200→/**
   201→ * Parse error response from API with consistent fallback.
   202→ * Handles various error response formats gracefully.
   203→ * @param {Response} response - Fetch response object
   204→ * @returns {Promise<string>} Error message string
   205→ */
   206→async function parseErrorResponse(response) {
   207→  try {
   208→    const data = await response.json();
   209→    return data.error || data.message || `Error ${response.status}`;
   210→  } catch {
   211→    return `Error ${response.status}: ${response.statusText || 'Unknown error'}`;
   212→  }
   213→}
   214→
   215→// ============================================================================
   216→// OFFLINE DETECTION
   217→// ============================================================================
   218→
   219→// Track online/offline state
   220→let _isOnline = typeof navigator !== 'undefined' ? navigator.onLine : true;
   221→let _offlineCallbacks = [];
   222→
   223→/**
   224→ * Check if the browser/app is online
   225→ * @returns {boolean} True if online
   226→ */
   227→function isOnline() {
   228→  // navigator.onLine can be undefined in some UXP contexts
   229→  if (typeof navigator !== 'undefined' && typeof navigator.onLine === 'boolean') {
   230→    return navigator.onLine;
   231→  }
   232→  return _isOnline;
   233→}
   234→
   235→/**
   236→ * Register a callback for online/offline state changes
   237→ * @param {Function} callback - Called with (isOnline: boolean) on state change
   238→ * @returns {Function} Unsubscribe function
   239→ */
   240→function onOnlineStateChange(callback) {
   241→  _offlineCallbacks.push(callback);
   242→  return () => {
   243→    _offlineCallbacks = _offlineCallbacks.filter(cb => cb !== callback);
   244→  };
   245→}
   246→
   247→/**
   248→ * Update the UI to reflect online/offline status
   249→ * @param {boolean} online - Current online state
   250→ */
   251→function updateOfflineUI(online) {
   252→  const statusEl = document.getElementById('status');
   253→  const goBtn = document.getElementById('goBtn');
   254→  const offlineIndicator = document.getElementById('offlineIndicator');
   255→
   256→  if (!online) {
   257→    // Show offline state
   258→    if (statusEl && !statusEl.dataset.originalText) {
   259→      statusEl.dataset.originalText = statusEl.textContent;
   260→    }
   261→    if (statusEl) statusEl.textContent = '⚠ Offline - Check your connection';
   262→
   263→    if (goBtn) {
   264→      goBtn.disabled = true;
   265→      goBtn.title = 'Cannot process while offline';
   266→    }
   267→
   268→    // Show offline indicator if it exists
   269→    if (offlineIndicator) {
   270→      offlineIndicator.style.display = 'flex';
   271→    }
   272→  } else {
   273→    // Restore online state
   274→    if (statusEl && statusEl.dataset.originalText) {
   275→      statusEl.textContent = statusEl.dataset.originalText;
   276→      delete statusEl.dataset.originalText;
   277→    }
   278→
   279→    if (goBtn) {
   280→      goBtn.disabled = false;
   281→      goBtn.title = '';
   282→    }
   283→
   284→    // Hide offline indicator
   285→    if (offlineIndicator) {
   286→      offlineIndicator.style.display = 'none';
   287→    }
   288→  }
   289→}
   290→
   291→/**
   292→ * Initialize offline detection listeners
   293→ * Call once on plugin load
   294→ */
   295→function initOfflineDetection() {
   296→  if (typeof window === 'undefined') return;
   297→
   298→  // Initial state
   299→  _isOnline = isOnline();
   300→
   301→  // Listen for online/offline events
   302→  window.addEventListener('online', () => {
   303→    _isOnline = true;
   304→    console.log('[SPLICE] Network: Online');
   305→    updateOfflineUI(true);
   306→    _offlineCallbacks.forEach(cb => cb(true));
   307→  });
   308→
   309→  window.addEventListener('offline', () => {
   310→    _isOnline = false;
   311→    console.log('[SPLICE] Network: Offline');
   312→    updateOfflineUI(false);
   313→    _offlineCallbacks.forEach(cb => cb(false));
   314→  });
   315→
   316→  // Update UI based on initial state
   317→  if (!_isOnline) {
   318→    updateOfflineUI(false);
   319→  }
   320→
   321→  console.log('[SPLICE] Offline detection initialized, online:', _isOnline);
   322→}
   323→
   324→/**
   325→ * Check online status before making API calls
   326→ * @throws {Error} If offline
   327→ */
   328→function requireOnline() {
   329→  if (!isOnline()) {
   330→    throw new Error('No internet connection. Please check your network and try again.');
   331→  }
   332→}
   333→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
