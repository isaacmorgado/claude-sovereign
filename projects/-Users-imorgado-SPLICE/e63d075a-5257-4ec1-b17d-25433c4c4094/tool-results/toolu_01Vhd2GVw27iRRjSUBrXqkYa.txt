     1→/**
     2→ * SPLICE CEP Credits Display Module
     3→ *
     4→ * Fetches and displays user's remaining hours from the billing backend.
     5→ * Port of UXP credits.js for CEP compatibility.
     6→ */
     7→
     8→// Track fetch error state for retry UI
     9→let lastCreditsError = null;
    10→let creditsRetryCount = 0;
    11→const MAX_CREDITS_RETRIES = 3;
    12→
    13→// Store current credits globally for access checks
    14→let currentCredits = null;
    15→
    16→// Store interval reference for cleanup
    17→let creditsRefreshInterval = null;
    18→
    19→/**
    20→ * Fetch user's credit balance from backend
    21→ * @returns {Promise<Object | null>} Credit data including isolation hours, or error object
    22→ */
    23→async function fetchCredits() {
    24→    const settings = getSettings();
    25→    const customerId = settings.customerId;
    26→
    27→    if (!customerId) {
    28→        console.log('[SPLICE] No customerId configured - credits display disabled');
    29→        lastCreditsError = null;
    30→        return null;
    31→    }
    32→
    33→    try {
    34→        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {
    35→            method: 'GET',
    36→            headers: {
    37→                'x-stripe-customer-id': customerId
    38→            }
    39→        }, SPLICE_CONFIG.FETCH_TIMEOUT);
    40→
    41→        if (!response.ok) {
    42→            const errorMsg = await parseErrorResponse(response);
    43→            console.error('[SPLICE] Credits fetch failed:', errorMsg);
    44→            lastCreditsError = errorMsg;
    45→            return { _error: true, message: errorMsg };
    46→        }
    47→
    48→        const data = await response.json();
    49→        lastCreditsError = null;
    50→        creditsRetryCount = 0;
    51→        return {
    52→            hoursRemaining: data.hoursRemaining || 0,
    53→            hoursTotal: data.hoursTotal || 0,
    54→            tierName: data.tierName || 'Free',
    55→            tier: data.tier || 'starter',
    56→            // Isolation hours
    57→            isolationHoursRemaining: data.isolationHoursRemaining || 0,
    58→            isolationHoursTotal: data.isolationHoursTotal || 0,
    59→            hasIsolationAccess: data.hasIsolationAccess || false,
    60→            isolationOverageRate: data.isolationOverageRate || 0.08
    61→        };
    62→    } catch (err) {
    63→        console.error('[SPLICE] Credits fetch error:', err);
    64→        lastCreditsError = err.message || 'Connection failed';
    65→        return { _error: true, message: lastCreditsError };
    66→    }
    67→}
    68→
    69→/**
    70→ * Clear the credits cache (call on logout)
    71→ */
    72→function clearCreditsCache() {
    73→    currentCredits = null;
    74→    lastCreditsError = null;
    75→    creditsRetryCount = 0;
    76→    console.log('[SPLICE] Credits cache cleared');
    77→}
    78→
    79→/**
    80→ * Update the credit display in the UI
    81→ * @param {Object|null} credits - Credit data, error object, or null if unavailable
    82→ */
    83→function updateCreditDisplay(credits) {
    84→    const creditBadge = document.getElementById('creditBadge');
    85→    if (!creditBadge) return;
    86→
    87→    // Handle no customer ID configured
    88→    if (!credits) {
    89→        currentCredits = null;
    90→        creditBadge.style.display = 'flex';
    91→        creditBadge.textContent = 'Login';
    92→        creditBadge.title = 'Click to enter license key';
    93→        creditBadge.classList.remove('ok', 'low');
    94→        creditBadge.classList.add('login');
    95→        return;
    96→    }
    97→
    98→    // Handle error state - show error badge with retry
    99→    if (credits._error) {
   100→        currentCredits = null;
   101→        creditBadge.style.display = 'flex';
   102→        creditBadge.textContent = 'Retry';
   103→        creditBadge.title = `Error: ${credits.message}\nClick to retry`;
   104→        creditBadge.classList.remove('ok', 'low', 'login');
   105→        creditBadge.classList.add('error');
   106→        return;
   107→    }
   108→
   109→    // Normal credit display
   110→    currentCredits = credits;
   111→    creditBadge.style.display = 'flex';
   112→    creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;
   113→    creditBadge.classList.remove('error', 'login');
   114→
   115→    // Build tooltip with isolation info if available
   116→    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;
   117→    if (credits.hasIsolationAccess) {
   118→        tooltip += `\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;
   119→    }
   120→    creditBadge.title = tooltip;
   121→
   122→    // Color based on remaining hours
   123→    if (credits.hoursRemaining <= 1) {
   124→        creditBadge.classList.add('low');
   125→        creditBadge.classList.remove('ok');
   126→    } else {
   127→        creditBadge.classList.add('ok');
   128→        creditBadge.classList.remove('low');
   129→    }
   130→
   131→    // Update isolation checkbox state based on tier access
   132→    updateIsolationCheckboxState(credits);
   133→}
   134→
   135→/**
   136→ * Update the isolation checkbox based on tier access
   137→ */
   138→function updateIsolationCheckboxState(credits) {
   139→    const isolatedCheckbox = document.getElementById('sourceIsolated');
   140→    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');
   141→
   142→    if (!isolatedCheckbox) return;
   143→
   144→    if (!credits || !credits.hasIsolationAccess) {
   145→        // Disable isolation for non-Pro/Team users
   146→        isolatedCheckbox.disabled = true;
   147→        isolatedCheckbox.checked = false;
   148→        if (tierBadge) {
   149→            tierBadge.textContent = 'Pro+';
   150→            tierBadge.style.opacity = '1';
   151→        }
   152→    } else {
   153→        // Enable isolation for Pro/Team users
   154→        isolatedCheckbox.disabled = false;
   155→        if (tierBadge) {
   156→            // Show remaining isolation time
   157→            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);
   158→            tierBadge.textContent = `${minsRemaining} min`;
   159→            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';
   160→        }
   161→    }
   162→}
   163→
   164→/**
   165→ * Check if user can use isolation and get cost estimate
   166→ * @param {number} estimatedMinutes - Estimated audio duration in minutes
   167→ * @returns {Object} Access info with allowed, message, overageCost
   168→ */
   169→function checkIsolationAccess(estimatedMinutes = 0) {
   170→    if (!currentCredits) {
   171→        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };
   172→    }
   173→
   174→    if (!currentCredits.hasIsolationAccess) {
   175→        return {
   176→            allowed: false,
   177→            message: 'Vocal isolation requires Pro or Team tier',
   178→            upgradeRequired: true,
   179→            overageCost: 0
   180→        };
   181→    }
   182→
   183→    const estimatedHours = estimatedMinutes / 60;
   184→    const remaining = currentCredits.isolationHoursRemaining;
   185→
   186→    if (remaining >= estimatedHours) {
   187→        return {
   188→            allowed: true,
   189→            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,
   190→            overageCost: 0
   191→        };
   192→    }
   193→
   194→    // Calculate overage
   195→    const overageMinutes = estimatedMinutes - (remaining * 60);
   196→    const overageCost = overageMinutes * currentCredits.isolationOverageRate;
   197→
   198→    return {
   199→        allowed: true,
   200→        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,
   201→        overageCost,
   202→        overageMinutes
   203→    };
   204→}
   205→
   206→/**
   207→ * Get current credits (for access checks)
   208→ */
   209→function getCurrentCredits() {
   210→    return currentCredits;
   211→}
   212→
   213→/**
   214→ * Initialize credits display
   215→ * Fetches credits on load and sets up periodic refresh
   216→ */
   217→async function initCredits() {
   218→    // Clear any existing interval to prevent duplicates
   219→    if (creditsRefreshInterval) {
   220→        clearInterval(creditsRefreshInterval);
   221→    }
   222→
   223→    // Initial fetch
   224→    const credits = await fetchCredits();
   225→    updateCreditDisplay(credits);
   226→
   227→    // Refresh credits every 5 minutes
   228→    creditsRefreshInterval = setInterval(async () => {
   229→        const refreshedCredits = await fetchCredits();
   230→        updateCreditDisplay(refreshedCredits);
   231→    }, 5 * 60 * 1000);
   232→}
   233→
   234→/**
   235→ * Cleanup credits module - call on plugin unload
   236→ */
   237→function cleanupCredits() {
   238→    if (creditsRefreshInterval) {
   239→        clearInterval(creditsRefreshInterval);
   240→        creditsRefreshInterval = null;
   241→    }
   242→}
   243→
   244→/**
   245→ * Manually refresh credits (e.g., after a processing operation)
   246→ */
   247→async function refreshCredits() {
   248→    const credits = await fetchCredits();
   249→    updateCreditDisplay(credits);
   250→    return credits;
   251→}
   252→
   253→// Export for window access
   254→window.fetchCredits = fetchCredits;
   255→window.clearCreditsCache = clearCreditsCache;
   256→window.updateCreditDisplay = updateCreditDisplay;
   257→window.checkIsolationAccess = checkIsolationAccess;
   258→window.getCurrentCredits = getCurrentCredits;
   259→window.initCredits = initCredits;
   260→window.cleanupCredits = cleanupCredits;
   261→window.refreshCredits = refreshCredits;
   262→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
