     1→/**
     2→ * Credits Display Module
     3→ *
     4→ * Fetches and displays user's remaining hours from the billing backend.
     5→ * Requires customerId to be set in settings.
     6→ *
     7→ * Uses getBackendUrl() from config.js for consistent URL handling.
     8→ */
     9→
    10→// Track fetch error state for retry UI
    11→let lastCreditsError = null;
    12→let creditsRetryCount = 0;
    13→const MAX_CREDITS_RETRIES = 3;
    14→
    15→/**
    16→ * Fetch user's credit balance from backend
    17→ * @returns {Promise<Object | null>} Credit data including isolation hours, or error object
    18→ */
    19→async function fetchCredits() {
    20→  const settings = getSettings();
    21→  const customerId = settings.customerId;
    22→
    23→  if (!customerId) {
    24→    console.log('[SPLICE] No customerId configured - credits display disabled');
    25→    lastCreditsError = null;
    26→    return null;
    27→  }
    28→
    29→  try {
    30→    const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {
    31→      method: 'GET',
    32→      headers: {
    33→        'x-stripe-customer-id': customerId
    34→      }
    35→    }, FETCH_TIMEOUT_DEFAULT);
    36→
    37→    if (!response.ok) {
    38→      const errorMsg = await parseErrorResponse(response);
    39→      console.error('[SPLICE] Credits fetch failed:', errorMsg);
    40→      lastCreditsError = errorMsg;
    41→      return { _error: true, message: errorMsg };
    42→    }
    43→
    44→    const data = await response.json();
    45→    lastCreditsError = null;
    46→    creditsRetryCount = 0;
    47→    return {
    48→      hoursRemaining: data.hoursRemaining || 0,
    49→      hoursTotal: data.hoursTotal || 0,
    50→      tierName: data.tierName || 'Free',
    51→      tier: data.tier || 'starter',
    52→      // Isolation hours
    53→      isolationHoursRemaining: data.isolationHoursRemaining || 0,
    54→      isolationHoursTotal: data.isolationHoursTotal || 0,
    55→      hasIsolationAccess: data.hasIsolationAccess || false,
    56→      isolationOverageRate: data.isolationOverageRate || 0.08
    57→    };
    58→  } catch (err) {
    59→    console.error('[SPLICE] Credits fetch error:', err);
    60→    lastCreditsError = err.message || 'Connection failed';
    61→    return { _error: true, message: lastCreditsError };
    62→  }
    63→}
    64→
    65→// Store current credits globally for access checks
    66→let currentCredits = null;
    67→
    68→/**
    69→ * Clear the credits cache (call on logout)
    70→ * Exported for use by settings.js logout function
    71→ */
    72→function clearCreditsCache() {
    73→  currentCredits = null;
    74→  lastCreditsError = null;
    75→  creditsRetryCount = 0;
    76→  console.log('[SPLICE] Credits cache cleared');
    77→}
    78→
    79→/**
    80→ * Update the credit display in the UI
    81→ * @param {Object|null} credits - Credit data, error object, or null if unavailable
    82→ */
    83→function updateCreditDisplay(credits) {
    84→  const creditBadge = document.getElementById('creditBadge');
    85→  if (!creditBadge) return;
    86→
    87→  // Handle no customer ID configured
    88→  if (!credits) {
    89→    currentCredits = null;
    90→    creditBadge.style.display = 'flex';
    91→    creditBadge.textContent = 'Login';
    92→    creditBadge.title = 'Click to enter license key';
    93→    creditBadge.classList.remove('ok', 'low');
    94→    creditBadge.classList.add('login');
    95→    return;
    96→  }
    97→
    98→  // Handle error state - show error badge with retry
    99→  if (credits._error) {
   100→    currentCredits = null;
   101→    creditBadge.style.display = 'flex';
   102→    creditBadge.textContent = '⚠ Retry';
   103→    creditBadge.title = `Error: ${credits.message}\nClick to retry`;
   104→    creditBadge.classList.remove('ok', 'low', 'login');
   105→    creditBadge.classList.add('error');
   106→    return;
   107→  }
   108→
   109→  // Normal credit display
   110→  currentCredits = credits;
   111→  creditBadge.style.display = 'flex';
   112→  creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;
   113→  creditBadge.classList.remove('error', 'login');
   114→
   115→  // Build tooltip with isolation info if available
   116→  let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;
   117→  if (credits.hasIsolationAccess) {
   118→    tooltip += `\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;
   119→  }
   120→  creditBadge.title = tooltip;
   121→
   122→  // Color based on remaining hours
   123→  if (credits.hoursRemaining <= 1) {
   124→    creditBadge.classList.add('low');
   125→    creditBadge.classList.remove('ok');
   126→  } else {
   127→    creditBadge.classList.add('ok');
   128→    creditBadge.classList.remove('low');
   129→  }
   130→
   131→  // Update isolation checkbox state based on tier access
   132→  updateIsolationCheckboxState(credits);
   133→}
   134→
   135→/**
   136→ * Update the isolation checkbox based on tier access
   137→ */
   138→function updateIsolationCheckboxState(credits) {
   139→  const isolatedCheckbox = document.getElementById('sourceIsolated');
   140→  const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');
   141→
   142→  if (!isolatedCheckbox) return;
   143→
   144→  if (!credits || !credits.hasIsolationAccess) {
   145→    // Disable isolation for non-Pro/Team users
   146→    isolatedCheckbox.disabled = true;
   147→    isolatedCheckbox.checked = false;
   148→    if (tierBadge) {
   149→      tierBadge.textContent = 'Pro+';
   150→      tierBadge.style.opacity = '1';
   151→    }
   152→  } else {
   153→    // Enable isolation for Pro/Team users
   154→    isolatedCheckbox.disabled = false;
   155→    if (tierBadge) {
   156→      // Show remaining isolation time
   157→      const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);
   158→      tierBadge.textContent = `${minsRemaining} min`;
   159→      tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';
   160→    }
   161→  }
   162→}
   163→
   164→/**
   165→ * Check if user can use isolation and get cost estimate
   166→ * @param {number} estimatedMinutes - Estimated audio duration in minutes
   167→ * @returns {Object} Access info with allowed, message, overageCost
   168→ */
   169→function checkIsolationAccess(estimatedMinutes = 0) {
   170→  if (!currentCredits) {
   171→    return { allowed: false, message: 'Credits not loaded', overageCost: 0 };
   172→  }
   173→
   174→  if (!currentCredits.hasIsolationAccess) {
   175→    return {
   176→      allowed: false,
   177→      message: 'Vocal isolation requires Pro or Team tier',
   178→      upgradeRequired: true,
   179→      overageCost: 0
   180→    };
   181→  }
   182→
   183→  const estimatedHours = estimatedMinutes / 60;
   184→  const remaining = currentCredits.isolationHoursRemaining;
   185→
   186→  if (remaining >= estimatedHours) {
   187→    return {
   188→      allowed: true,
   189→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,
   190→      overageCost: 0
   191→    };
   192→  }
   193→
   194→  // Calculate overage
   195→  const overageMinutes = estimatedMinutes - (remaining * 60);
   196→  const overageCost = overageMinutes * currentCredits.isolationOverageRate;
   197→
   198→  return {
   199→    allowed: true,
   200→    message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,
   201→    overageCost,
   202→    overageMinutes
   203→  };
   204→}
   205→
   206→/**
   207→ * Get current credits (for access checks)
   208→ */
   209→function getCurrentCredits() {
   210→  return currentCredits;
   211→}
   212→
   213→// Store interval reference for cleanup
   214→let creditsRefreshInterval = null;
   215→
   216→/**
   217→ * Initialize credits display
   218→ * Fetches credits on load and sets up periodic refresh
   219→ */
   220→async function initCredits() {
   221→  // Clear any existing interval to prevent duplicates
   222→  if (creditsRefreshInterval) {
   223→    clearInterval(creditsRefreshInterval);
   224→  }
   225→
   226→  // Initial fetch
   227→  const credits = await fetchCredits();
   228→  updateCreditDisplay(credits);
   229→
   230→  // Refresh credits every 5 minutes
   231→  creditsRefreshInterval = setInterval(async () => {
   232→    const refreshedCredits = await fetchCredits();
   233→    updateCreditDisplay(refreshedCredits);
   234→  }, 5 * 60 * 1000);
   235→}
   236→
   237→/**
   238→ * Cleanup credits module - call on plugin unload
   239→ */
   240→function cleanupCredits() {
   241→  if (creditsRefreshInterval) {
   242→    clearInterval(creditsRefreshInterval);
   243→    creditsRefreshInterval = null;
   244→  }
   245→}
   246→
   247→/**
   248→ * Manually refresh credits (e.g., after a processing operation)
   249→ */
   250→async function refreshCredits() {
   251→  const credits = await fetchCredits();
   252→  updateCreditDisplay(credits);
   253→  return credits;
   254→}
   255→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
