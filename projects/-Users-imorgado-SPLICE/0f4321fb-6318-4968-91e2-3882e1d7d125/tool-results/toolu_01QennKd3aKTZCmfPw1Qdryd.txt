     1→/**
     2→ * SPLICE CEP Text Editor Module
     3→ *
     4→ * Provides UI for text-based video editing.
     5→ * Edit video by editing the transcript text.
     6→ * Delete text to delete video, reorder paragraphs to reorder video.
     7→ */
     8→
     9→// ============================================================================
    10→// STATE
    11→// ============================================================================
    12→
    13→const textEditorState = {
    14→  originalTranscript: null,
    15→  editableTranscript: null,
    16→  currentText: '',
    17→  undoStack: [],
    18→  redoStack: [],
    19→  searchResults: [],
    20→  currentSearchIndex: -1,
    21→  isDirty: false,
    22→  isProcessing: false,
    23→  previewChanges: null,
    24→  lastCutList: null
    25→};
    26→
    27→// Maximum undo history size
    28→const MAX_UNDO_STACK = 50;
    29→
    30→// ============================================================================
    31→// DOM ELEMENT CACHE
    32→// ============================================================================
    33→
    34→const textEditorElements = {
    35→  panel: null,
    36→  content: null,
    37→  status: null,
    38→  wordCount: null,
    39→  dirtyIndicator: null,
    40→  undoBtn: null,
    41→  redoBtn: null,
    42→  applyBtn: null,
    43→  previewBtn: null,
    44→  resetBtn: null,
    45→  buildBtn: null,
    46→  searchInput: null,
    47→  searchBtn: null,
    48→  searchNextBtn: null,
    49→  searchPrevBtn: null,
    50→  searchResults: null,
    51→  replaceInput: null,
    52→  replaceBtn: null,
    53→  replaceAllBtn: null,
    54→  previewContainer: null
    55→};
    56→
    57→/**
    58→ * Cache DOM elements for text editor
    59→ */
    60→function cacheTextEditorElements() {
    61→  textEditorElements.panel = document.getElementById('text-editor-panel');
    62→  textEditorElements.content = document.getElementById('text-editor-content');
    63→  textEditorElements.status = document.getElementById('text-editor-status');
    64→  textEditorElements.wordCount = document.getElementById('text-editor-word-count');
    65→  textEditorElements.dirtyIndicator = document.getElementById('text-editor-dirty');
    66→  textEditorElements.undoBtn = document.getElementById('text-editor-undo-btn');
    67→  textEditorElements.redoBtn = document.getElementById('text-editor-redo-btn');
    68→  textEditorElements.applyBtn = document.getElementById('apply-text-edits-btn');
    69→  textEditorElements.previewBtn = document.getElementById('preview-text-edits-btn');
    70→  textEditorElements.resetBtn = document.getElementById('text-editor-reset-btn');
    71→  textEditorElements.buildBtn = document.getElementById('text-editor-build-btn');
    72→  textEditorElements.searchInput = document.getElementById('text-search-input');
    73→  textEditorElements.searchBtn = document.getElementById('text-search-btn');
    74→  textEditorElements.searchNextBtn = document.getElementById('text-search-next-btn');
    75→  textEditorElements.searchPrevBtn = document.getElementById('text-search-prev-btn');
    76→  textEditorElements.searchResults = document.getElementById('text-search-results');
    77→  textEditorElements.replaceInput = document.getElementById('text-replace-input');
    78→  textEditorElements.replaceBtn = document.getElementById('text-replace-btn');
    79→  textEditorElements.replaceAllBtn = document.getElementById('text-replace-all-btn');
    80→  textEditorElements.previewContainer = document.getElementById('text-editor-preview');
    81→}
    82→
    83→// ============================================================================
    84→// INITIALIZATION
    85→// ============================================================================
    86→
    87→/**
    88→ * Initialize text editor module
    89→ */
    90→function initTextEditor() {
    91→  console.log('[SPLICE] Initializing text editor module');
    92→
    93→  // Cache elements
    94→  cacheTextEditorElements();
    95→
    96→  // Setup event listeners
    97→  setupTextEditorListeners();
    98→
    99→  // Setup keyboard shortcuts
   100→  setupKeyboardShortcuts();
   101→
   102→  console.log('[SPLICE] Text editor module initialized');
   103→}
   104→
   105→/**
   106→ * Setup event listeners for text editor
   107→ */
   108→function setupTextEditorListeners() {
   109→  // Text area input - using event delegation
   110→  document.addEventListener('input', (e) => {
   111→    if (e.target.id === 'text-editor-content') {
   112→      handleTextChange(e.target.value);
   113→    }
   114→  });
   115→
   116→  // Button clicks - using event delegation
   117→  document.addEventListener('click', (e) => {
   118→    const id = e.target.id;
   119→
   120→    switch (id) {
   121→      case 'apply-text-edits-btn':
   122→        applyTextEdits();
   123→        break;
   124→      case 'preview-text-edits-btn':
   125→        previewTextEdits();
   126→        break;
   127→      case 'text-editor-undo-btn':
   128→        undoTextEdit();
   129→        break;
   130→      case 'text-editor-redo-btn':
   131→        redoTextEdit();
   132→        break;
   133→      case 'text-search-btn':
   134→        searchInTranscript();
   135→        break;
   136→      case 'text-search-next-btn':
   137→        navigateSearchResult(1);
   138→        break;
   139→      case 'text-search-prev-btn':
   140→        navigateSearchResult(-1);
   141→        break;
   142→      case 'text-replace-btn':
   143→        replaceInTranscript();
   144→        break;
   145→      case 'text-replace-all-btn':
   146→        replaceAllInTranscript();
   147→        break;
   148→      case 'text-editor-reset-btn':
   149→        resetToOriginal();
   150→        break;
   151→      case 'text-editor-build-btn':
   152→        buildSequenceFromEdits();
   153→        break;
   154→    }
   155→
   156→    // Toggle panel collapse
   157→    if (e.target.closest('.text-editor-header')) {
   158→      const panel = document.getElementById('text-editor-panel');
   159→      if (panel) {
   160→        panel.classList.toggle('collapsed');
   161→      }
   162→    }
   163→  });
   164→
   165→  // Search input enter key
   166→  document.addEventListener('keypress', (e) => {
   167→    if (e.target.id === 'text-search-input' && e.key === 'Enter') {
   168→      e.preventDefault();
   169→      searchInTranscript();
   170→    }
   171→  });
   172→}
   173→
   174→/**
   175→ * Setup keyboard shortcuts
   176→ */
   177→function setupKeyboardShortcuts() {
   178→  document.addEventListener('keydown', (e) => {
   179→    // Only handle if text editor is focused
   180→    const editorContent = textEditorElements.content || document.getElementById('text-editor-content');
   181→    if (!editorContent || document.activeElement !== editorContent) return;
   182→
   183→    // Ctrl/Cmd + Z = Undo
   184→    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
   185→      e.preventDefault();
   186→      undoTextEdit();
   187→    }
   188→
   189→    // Ctrl/Cmd + Shift + Z or Ctrl/Cmd + Y = Redo
   190→    if ((e.ctrlKey || e.metaKey) && (e.key === 'Z' || e.key === 'y')) {
   191→      e.preventDefault();
   192→      redoTextEdit();
   193→    }
   194→
   195→    // Ctrl/Cmd + F = Focus search
   196→    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
   197→      e.preventDefault();
   198→      const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
   199→      if (searchInput) searchInput.focus();
   200→    }
   201→  });
   202→}
   203→
   204→// ============================================================================
   205→// TRANSCRIPT LOADING
   206→// ============================================================================
   207→
   208→/**
   209→ * Load transcript into text editor
   210→ * @param {Object} transcript - Transcript from main module
   211→ */
   212→async function loadTranscriptIntoEditor(transcript) {
   213→  if (!transcript) {
   214→    showTextEditorStatus('No transcript available', 'error');
   215→    return;
   216→  }
   217→
   218→  textEditorState.isProcessing = true;
   219→  updateProcessingState(true);
   220→  showTextEditorStatus('Preparing editable transcript...', 'info');
   221→
   222→  try {
   223→    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
   224→    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   225→    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   226→
   227→    const response = await fetchFn(`${backendUrl}/text-edit/prepare`, {
   228→      method: 'POST',
   229→      headers,
   230→      body: JSON.stringify({ transcript })
   231→    });
   232→
   233→    if (!response.ok) {
   234→      const err = await response.json();
   235→      throw new Error(err.error || 'Failed to prepare transcript');
   236→    }
   237→
   238→    const data = await response.json();
   239→
   240→    // Store original and editable transcripts
   241→    textEditorState.originalTranscript = transcript;
   242→    textEditorState.editableTranscript = data.editableTranscript;
   243→    textEditorState.currentText = data.editableTranscript.plainText;
   244→    textEditorState.isDirty = false;
   245→    textEditorState.undoStack = [];
   246→    textEditorState.redoStack = [];
   247→    textEditorState.lastCutList = null;
   248→
   249→    // Render editor
   250→    renderTextEditor();
   251→
   252→    showTextEditorStatus(`Loaded ${data.editableTranscript.totalWords} words`, 'success');
   253→
   254→  } catch (err) {
   255→    console.error('[SPLICE] Text editor load error:', err);
   256→    showTextEditorStatus(err.message, 'error');
   257→  } finally {
   258→    textEditorState.isProcessing = false;
   259→    updateProcessingState(false);
   260→  }
   261→}
   262→
   263→// ============================================================================
   264→// TEXT EDITING
   265→// ============================================================================
   266→
   267→/**
   268→ * Handle text changes in editor
   269→ */
   270→function handleTextChange(newText) {
   271→  // Save current state to undo stack
   272→  if (textEditorState.currentText !== newText) {
   273→    textEditorState.undoStack.push(textEditorState.currentText);
   274→    textEditorState.redoStack = []; // Clear redo stack on new edit
   275→
   276→    // Limit undo stack size
   277→    if (textEditorState.undoStack.length > MAX_UNDO_STACK) {
   278→      textEditorState.undoStack.shift();
   279→    }
   280→  }
   281→
   282→  textEditorState.currentText = newText;
   283→  textEditorState.isDirty = true;
   284→  textEditorState.previewChanges = null; // Clear preview
   285→
   286→  updateEditorStatus();
   287→}
   288→
   289→/**
   290→ * Undo last text edit
   291→ */
   292→function undoTextEdit() {
   293→  if (textEditorState.undoStack.length === 0) {
   294→    showTextEditorStatus('Nothing to undo', 'info');
   295→    return;
   296→  }
   297→
   298→  // Save current to redo stack
   299→  textEditorState.redoStack.push(textEditorState.currentText);
   300→
   301→  // Restore from undo stack
   302→  textEditorState.currentText = textEditorState.undoStack.pop();
   303→
   304→  // Update editor content
   305→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   306→  if (editor) {
   307→    editor.value = textEditorState.currentText;
   308→  }
   309→
   310→  updateEditorStatus();
   311→  showTextEditorStatus('Undo applied', 'info');
   312→}
   313→
   314→/**
   315→ * Redo last undone edit
   316→ */
   317→function redoTextEdit() {
   318→  if (textEditorState.redoStack.length === 0) {
   319→    showTextEditorStatus('Nothing to redo', 'info');
   320→    return;
   321→  }
   322→
   323→  // Save current to undo stack
   324→  textEditorState.undoStack.push(textEditorState.currentText);
   325→
   326→  // Restore from redo stack
   327→  textEditorState.currentText = textEditorState.redoStack.pop();
   328→
   329→  // Update editor content
   330→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   331→  if (editor) {
   332→    editor.value = textEditorState.currentText;
   333→  }
   334→
   335→  updateEditorStatus();
   336→  showTextEditorStatus('Redo applied', 'info');
   337→}
   338→
   339→/**
   340→ * Reset to original transcript
   341→ */
   342→function resetToOriginal() {
   343→  if (!textEditorState.editableTranscript) return;
   344→
   345→  // Save current to undo
   346→  if (textEditorState.isDirty) {
   347→    textEditorState.undoStack.push(textEditorState.currentText);
   348→  }
   349→
   350→  textEditorState.currentText = textEditorState.editableTranscript.plainText;
   351→  textEditorState.isDirty = false;
   352→  textEditorState.previewChanges = null;
   353→
   354→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   355→  if (editor) {
   356→    editor.value = textEditorState.currentText;
   357→  }
   358→
   359→  updateEditorStatus();
   360→  showTextEditorStatus('Reset to original', 'success');
   361→}
   362→
   363→// ============================================================================
   364→// PREVIEW AND APPLY
   365→// ============================================================================
   366→
   367→/**
   368→ * Preview text edits without applying
   369→ */
   370→async function previewTextEdits() {
   371→  if (!textEditorState.editableTranscript || !textEditorState.isDirty) {
   372→    showTextEditorStatus('No changes to preview', 'info');
   373→    return;
   374→  }
   375→
   376→  textEditorState.isProcessing = true;
   377→  updateProcessingState(true);
   378→  showTextEditorStatus('Generating preview...', 'info');
   379→
   380→  try {
   381→    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
   382→    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   383→    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   384→
   385→    const response = await fetchFn(`${backendUrl}/text-edit/preview`, {
   386→      method: 'POST',
   387→      headers,
   388→      body: JSON.stringify({
   389→        transcript: textEditorState.editableTranscript,
   390→        editedText: textEditorState.currentText
   391→      })
   392→    });
   393→
   394→    if (!response.ok) {
   395→      const err = await response.json();
   396→      throw new Error(err.error || 'Preview failed');
   397→    }
   398→
   399→    const data = await response.json();
   400→    textEditorState.previewChanges = data;
   401→
   402→    renderPreview(data);
   403→    showTextEditorStatus(`Preview: ${data.changes.length} changes`, 'success');
   404→
   405→  } catch (err) {
   406→    console.error('[SPLICE] Text edit preview error:', err);
   407→    showTextEditorStatus(err.message, 'error');
   408→  } finally {
   409→    textEditorState.isProcessing = false;
   410→    updateProcessingState(false);
   411→  }
   412→}
   413→
   414→/**
   415→ * Render preview of changes
   416→ */
   417→function renderPreview(preview) {
   418→  const container = textEditorElements.previewContainer || document.getElementById('text-editor-preview');
   419→  if (!container) return;
   420→
   421→  if (!preview.changes || preview.changes.length === 0) {
   422→    container.innerHTML = '<div class="preview-empty">No changes detected</div>';
   423→    return;
   424→  }
   425→
   426→  // SECURITY: Escape user-provided content to prevent XSS
   427→  const html = `
   428→    <div class="preview-summary">
   429→      <span class="preview-stat">${escapeHtml(preview.summary.deletions)} deletions</span>
   430→      <span class="preview-stat">${escapeHtml(preview.summary.reorderings)} reorders</span>
   431→      <span class="preview-stat">${escapeHtml(preview.impact.percentageRemoved)}% removed</span>
   432→    </div>
   433→    <div class="preview-changes">
   434→      ${preview.changes.map(change => `
   435→        <div class="preview-change preview-change-${escapeHtml(change.type)}">
   436→          <span class="change-type">${escapeHtml(change.type)}</span>
   437→          <span class="change-desc">${escapeHtml(change.description)}</span>
   438→          <span class="change-time">${escapeHtml(change.timeRange)}</span>
   439→        </div>
   440→      `).join('')}
   441→    </div>
   442→  `;
   443→
   444→  container.innerHTML = html;
   445→}
   446→
   447→/**
   448→ * Apply text edits and generate cut list
   449→ */
   450→async function applyTextEdits() {
   451→  if (!textEditorState.editableTranscript || !textEditorState.isDirty) {
   452→    showTextEditorStatus('No changes to apply', 'info');
   453→    return;
   454→  }
   455→
   456→  textEditorState.isProcessing = true;
   457→  updateProcessingState(true);
   458→  showTextEditorStatus('Applying edits...', 'info');
   459→
   460→  try {
   461→    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
   462→    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   463→    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   464→
   465→    // Apply edits
   466→    const applyResponse = await fetchFn(`${backendUrl}/text-edit/apply`, {
   467→      method: 'POST',
   468→      headers,
   469→      body: JSON.stringify({
   470→        transcript: textEditorState.editableTranscript,
   471→        editedText: textEditorState.currentText
   472→      })
   473→    });
   474→
   475→    if (!applyResponse.ok) {
   476→      const err = await applyResponse.json();
   477→      throw new Error(err.error || 'Apply failed');
   478→    }
   479→
   480→    const applyData = await applyResponse.json();
   481→
   482→    // Generate cut list from operations
   483→    const cutListResponse = await fetchFn(`${backendUrl}/text-edit/cut-list`, {
   484→      method: 'POST',
   485→      headers,
   486→      body: JSON.stringify({
   487→        operations: applyData.operations,
   488→        sourceInfo: {
   489→          sourceName: textEditorState.originalTranscript?.source?.name || 'source',
   490→          duration: textEditorState.editableTranscript.duration
   491→        }
   492→      })
   493→    });
   494→
   495→    if (!cutListResponse.ok) {
   496→      const err = await cutListResponse.json();
   497→      throw new Error(err.error || 'Cut list generation failed');
   498→    }
   499→
   500→    const cutListData = await cutListResponse.json();
   501→
   502→    // Store cut list for building
   503→    textEditorState.lastCutList = cutListData.cutList;
   504→
   505→    // Update state
   506→    textEditorState.isDirty = false;
   507→
   508→    showTextEditorStatus(
   509→      `Applied ${applyData.stats.deletions} cuts, ${cutListData.summary.segmentCount} segments`,
   510→      'success'
   511→    );
   512→
   513→    // Show build button
   514→    updateBuildButtonState(true);
   515→
   516→  } catch (err) {
   517→    console.error('[SPLICE] Text edit apply error:', err);
   518→    showTextEditorStatus(err.message, 'error');
   519→  } finally {
   520→    textEditorState.isProcessing = false;
   521→    updateProcessingState(false);
   522→  }
   523→}
   524→
   525→/**
   526→ * Build sequence from applied edits
   527→ */
   528→async function buildSequenceFromEdits() {
   529→  if (!textEditorState.lastCutList) {
   530→    showTextEditorStatus('No edits to build. Apply edits first.', 'error');
   531→    return;
   532→  }
   533→
   534→  showTextEditorStatus('Building sequence...', 'info');
   535→
   536→  try {
   537→    // Use builder to create sequence (CEP version via JSX)
   538→    if (window.spliceBuilder?.buildSequenceFromCutList) {
   539→      const result = await window.spliceBuilder.buildSequenceFromCutList(textEditorState.lastCutList);
   540→      if (result && result.success) {
   541→        showTextEditorStatus('Sequence built successfully', 'success');
   542→      } else {
   543→        throw new Error(result?.error || 'Build failed');
   544→      }
   545→    } else if (typeof jsx !== 'undefined' && jsx.call) {
   546→      // Fallback to direct JSX call
   547→      const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(textEditorState.lastCutList));
   548→      if (result && result.success) {
   549→        showTextEditorStatus('Sequence built successfully', 'success');
   550→      } else {
   551→        throw new Error(result?.error || 'Build failed');
   552→      }
   553→    } else {
   554→      showTextEditorStatus('Builder not available', 'error');
   555→    }
   556→  } catch (err) {
   557→    console.error('[SPLICE] Build sequence error:', err);
   558→    showTextEditorStatus(err.message, 'error');
   559→  }
   560→}
   561→
   562→// ============================================================================
   563→// SEARCH AND REPLACE
   564→// ============================================================================
   565→
   566→/**
   567→ * Search in transcript
   568→ */
   569→async function searchInTranscript() {
   570→  const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
   571→  const searchText = searchInput?.value?.trim();
   572→
   573→  if (!searchText) {
   574→    showTextEditorStatus('Enter search text', 'info');
   575→    return;
   576→  }
   577→
   578→  if (!textEditorState.editableTranscript) {
   579→    showTextEditorStatus('No transcript loaded', 'error');
   580→    return;
   581→  }
   582→
   583→  try {
   584→    const backendUrl = typeof getBackendUrl === 'function' ? getBackendUrl() : 'https://127.0.0.1:3847';
   585→    const headers = typeof getAuthHeaders === 'function' ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   586→    const fetchFn = typeof fetchWithTimeout === 'function' ? fetchWithTimeout : fetch;
   587→
   588→    const response = await fetchFn(`${backendUrl}/text-edit/search`, {
   589→      method: 'POST',
   590→      headers,
   591→      body: JSON.stringify({
   592→        transcript: textEditorState.editableTranscript,
   593→        searchText
   594→      })
   595→    });
   596→
   597→    if (!response.ok) {
   598→      const err = await response.json();
   599→      throw new Error(err.error || 'Search failed');
   600→    }
   601→
   602→    const data = await response.json();
   603→    textEditorState.searchResults = data.matches || [];
   604→    textEditorState.currentSearchIndex = data.matches.length > 0 ? 0 : -1;
   605→
   606→    highlightSearchResults();
   607→    showTextEditorStatus(`Found ${data.totalMatches} matches`, 'success');
   608→
   609→  } catch (err) {
   610→    console.error('[SPLICE] Search error:', err);
   611→    showTextEditorStatus(err.message, 'error');
   612→  }
   613→}
   614→
   615→/**
   616→ * Navigate search results
   617→ */
   618→function navigateSearchResult(direction) {
   619→  if (textEditorState.searchResults.length === 0) {
   620→    showTextEditorStatus('No search results', 'info');
   621→    return;
   622→  }
   623→
   624→  textEditorState.currentSearchIndex += direction;
   625→
   626→  // Wrap around
   627→  if (textEditorState.currentSearchIndex >= textEditorState.searchResults.length) {
   628→    textEditorState.currentSearchIndex = 0;
   629→  } else if (textEditorState.currentSearchIndex < 0) {
   630→    textEditorState.currentSearchIndex = textEditorState.searchResults.length - 1;
   631→  }
   632→
   633→  highlightCurrentResult();
   634→  updateSearchResultsDisplay();
   635→}
   636→
   637→/**
   638→ * Highlight search results in editor
   639→ */
   640→function highlightSearchResults() {
   641→  // Update counter
   642→  updateSearchResultsDisplay();
   643→
   644→  if (textEditorState.currentSearchIndex >= 0) {
   645→    highlightCurrentResult();
   646→  }
   647→}
   648→
   649→/**
   650→ * Highlight current search result
   651→ */
   652→function highlightCurrentResult() {
   653→  const result = textEditorState.searchResults[textEditorState.currentSearchIndex];
   654→  if (!result) return;
   655→
   656→  // Scroll to result position in textarea
   657→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   658→  if (editor) {
   659→    // Find text position and scroll
   660→    const text = editor.value;
   661→    const searchPos = text.toLowerCase().indexOf(result.text.toLowerCase());
   662→    if (searchPos >= 0) {
   663→      editor.setSelectionRange(searchPos, searchPos + result.text.length);
   664→      editor.focus();
   665→    }
   666→  }
   667→
   668→  // Show time info - use formatTime from config.js
   669→  const timeStr = typeof formatTime === 'function' ? formatTime(result.start) : `${Math.floor(result.start)}s`;
   670→  showTextEditorStatus(
   671→    `Match ${textEditorState.currentSearchIndex + 1}/${textEditorState.searchResults.length} at ${timeStr}`,
   672→    'info'
   673→  );
   674→}
   675→
   676→/**
   677→ * Update search results display
   678→ */
   679→function updateSearchResultsDisplay() {
   680→  const display = textEditorElements.searchResults || document.getElementById('text-search-results');
   681→  if (display) {
   682→    const current = textEditorState.currentSearchIndex + 1;
   683→    const total = textEditorState.searchResults.length;
   684→    display.textContent = total > 0 ? `${current}/${total}` : '0/0';
   685→  }
   686→}
   687→
   688→/**
   689→ * Replace in transcript
   690→ */
   691→function replaceInTranscript() {
   692→  const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
   693→  const replaceInput = textEditorElements.replaceInput || document.getElementById('text-replace-input');
   694→  const searchText = searchInput?.value?.trim();
   695→  const replaceText = replaceInput?.value || '';
   696→
   697→  if (!searchText) {
   698→    showTextEditorStatus('Enter search text', 'info');
   699→    return;
   700→  }
   701→
   702→  // Replace first occurrence in current text
   703→  const newText = textEditorState.currentText.replace(
   704→    new RegExp(escapeRegex(searchText), 'i'),
   705→    replaceText
   706→  );
   707→
   708→  if (newText !== textEditorState.currentText) {
   709→    handleTextChange(newText);
   710→    const editor = textEditorElements.content || document.getElementById('text-editor-content');
   711→    if (editor) editor.value = newText;
   712→    showTextEditorStatus('Replaced 1 occurrence', 'success');
   713→  } else {
   714→    showTextEditorStatus('No match found', 'info');
   715→  }
   716→}
   717→
   718→/**
   719→ * Replace all occurrences in transcript
   720→ */
   721→function replaceAllInTranscript() {
   722→  const searchInput = textEditorElements.searchInput || document.getElementById('text-search-input');
   723→  const replaceInput = textEditorElements.replaceInput || document.getElementById('text-replace-input');
   724→  const searchText = searchInput?.value?.trim();
   725→  const replaceText = replaceInput?.value || '';
   726→
   727→  if (!searchText) {
   728→    showTextEditorStatus('Enter search text', 'info');
   729→    return;
   730→  }
   731→
   732→  const regex = new RegExp(escapeRegex(searchText), 'gi');
   733→  const matches = textEditorState.currentText.match(regex);
   734→  const count = matches ? matches.length : 0;
   735→
   736→  if (count > 0) {
   737→    const newText = textEditorState.currentText.replace(regex, replaceText);
   738→    handleTextChange(newText);
   739→    const editor = textEditorElements.content || document.getElementById('text-editor-content');
   740→    if (editor) editor.value = newText;
   741→    showTextEditorStatus(`Replaced ${count} occurrences`, 'success');
   742→  } else {
   743→    showTextEditorStatus('No matches found', 'info');
   744→  }
   745→}
   746→
   747→/**
   748→ * Escape special regex characters
   749→ */
   750→function escapeRegex(string) {
   751→  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
   752→}
   753→
   754→// ============================================================================
   755→// UI RENDERING
   756→// ============================================================================
   757→
   758→/**
   759→ * Render text editor content
   760→ */
   761→function renderTextEditor() {
   762→  const container = textEditorElements.content || document.getElementById('text-editor-content');
   763→  if (!container) return;
   764→
   765→  container.value = textEditorState.currentText;
   766→  updateEditorStatus();
   767→}
   768→
   769→/**
   770→ * Update editor status display
   771→ */
   772→function updateEditorStatus() {
   773→  const wordCount = textEditorElements.wordCount || document.getElementById('text-editor-word-count');
   774→  const dirtyIndicator = textEditorElements.dirtyIndicator || document.getElementById('text-editor-dirty');
   775→  const undoBtn = textEditorElements.undoBtn || document.getElementById('text-editor-undo-btn');
   776→  const redoBtn = textEditorElements.redoBtn || document.getElementById('text-editor-redo-btn');
   777→
   778→  if (wordCount) {
   779→    const words = textEditorState.currentText.split(/\s+/).filter(w => w.length > 0);
   780→    wordCount.textContent = `${words.length} words`;
   781→  }
   782→
   783→  if (dirtyIndicator) {
   784→    dirtyIndicator.style.display = textEditorState.isDirty ? 'inline' : 'none';
   785→  }
   786→
   787→  if (undoBtn) {
   788→    undoBtn.disabled = textEditorState.undoStack.length === 0;
   789→  }
   790→
   791→  if (redoBtn) {
   792→    redoBtn.disabled = textEditorState.redoStack.length === 0;
   793→  }
   794→}
   795→
   796→/**
   797→ * Update processing state UI
   798→ */
   799→function updateProcessingState(isProcessing) {
   800→  const panel = textEditorElements.panel || document.getElementById('text-editor-panel');
   801→  if (panel) {
   802→    const buttons = panel.querySelectorAll('button');
   803→    buttons.forEach(btn => {
   804→      if (!btn.classList.contains('always-enabled')) {
   805→        btn.disabled = isProcessing;
   806→      }
   807→    });
   808→  }
   809→
   810→  const editor = textEditorElements.content || document.getElementById('text-editor-content');
   811→  if (editor) {
   812→    editor.disabled = isProcessing;
   813→  }
   814→}
   815→
   816→/**
   817→ * Update build button state
   818→ */
   819→function updateBuildButtonState(enabled) {
   820→  const btn = textEditorElements.buildBtn || document.getElementById('text-editor-build-btn');
   821→  if (btn) {
   822→    btn.disabled = !enabled;
   823→    if (enabled) {
   824→      btn.classList.add('ready');
   825→    } else {
   826→      btn.classList.remove('ready');
   827→    }
   828→  }
   829→}
   830→
   831→/**
   832→ * Show status message
   833→ */
   834→function showTextEditorStatus(message, type = 'info') {
   835→  const statusEl = textEditorElements.status || document.getElementById('text-editor-status');
   836→  if (!statusEl) return;
   837→
   838→  statusEl.textContent = message;
   839→  statusEl.className = `text-editor-status text-editor-status-${type}`;
   840→
   841→  if (type !== 'error') {
   842→    setTimeout(() => {
   843→      statusEl.textContent = '';
   844→      statusEl.className = 'text-editor-status';
   845→    }, 5000);
   846→  }
   847→}
   848→
   849→// ============================================================================
   850→// EXPORTS
   851→// ============================================================================
   852→
   853→// Export for global access
   854→window.spliceTextEditor = {
   855→  init: initTextEditor,
   856→  loadTranscript: loadTranscriptIntoEditor,
   857→  applyEdits: applyTextEdits,
   858→  previewEdits: previewTextEdits,
   859→  undo: undoTextEdit,
   860→  redo: redoTextEdit,
   861→  reset: resetToOriginal,
   862→  search: searchInTranscript,
   863→  buildSequence: buildSequenceFromEdits,
   864→  getState: () => ({ ...textEditorState })
   865→};
   866→
   867→// Also expose individual functions for direct access
   868→window.initTextEditor = initTextEditor;
   869→window.loadTranscriptIntoEditor = loadTranscriptIntoEditor;
   870→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
