     1→/**
     2→ * SPLICE CEP Panel - Animated Captions Module
     3→ * Word-by-word animated captions with template gallery and preview
     4→ * v4.0.0 - CEP Migration
     5→ */
     6→
     7→// ============================================================================
     8→// STATE
     9→// ============================================================================
    10→const animatedCaptionsState = {
    11→    templates: [],
    12→    selectedTemplate: 'mrbeast',
    13→    captions: null,
    14→    keywords: [],
    15→    settings: {
    16→        maxWordsPerLine: 4,
    17→        highlightKeywords: true,
    18→        insertEmojis: false,
    19→        emojiFrequency: 'medium'
    20→    },
    21→    isGenerating: false,
    22→    lastTranscript: null
    23→};
    24→
    25→// ============================================================================
    26→// DOM ELEMENT CACHE
    27→// ============================================================================
    28→const captionsUI = {};
    29→
    30→function cacheCaptionElements() {
    31→    captionsUI.section = document.getElementById('captionsSection');
    32→    captionsUI.toggle = document.getElementById('captionsToggle');
    33→    captionsUI.panel = document.getElementById('captionsPanel');
    34→    captionsUI.templateGallery = document.getElementById('captionTemplateGallery');
    35→    captionsUI.previewContainer = document.getElementById('captionPreviewContainer');
    36→    captionsUI.stats = document.getElementById('captionStats');
    37→    captionsUI.status = document.getElementById('captionStatus');
    38→
    39→    // Settings
    40→    captionsUI.wordsPerLine = document.getElementById('captionWordsPerLine');
    41→    captionsUI.highlightKeywords = document.getElementById('captionHighlightKeywords');
    42→    captionsUI.insertEmojis = document.getElementById('captionInsertEmojis');
    43→    captionsUI.emojiFrequency = document.getElementById('captionEmojiFrequency');
    44→
    45→    // Buttons
    46→    captionsUI.generateBtn = document.getElementById('generateCaptionsBtn');
    47→    captionsUI.exportSrtBtn = document.getElementById('exportCaptionsSrtBtn');
    48→    captionsUI.exportMogrtBtn = document.getElementById('exportCaptionsMogrtBtn');
    49→    captionsUI.applyBtn = document.getElementById('applyCaptionsBtn');
    50→    captionsUI.copyBtn = document.getElementById('copyCaptionsBtn');
    51→}
    52→
    53→// ============================================================================
    54→// INITIALIZATION
    55→// ============================================================================
    56→async function initAnimatedCaptions() {
    57→    console.log('[SPLICE Captions] Initializing animated captions module');
    58→
    59→    cacheCaptionElements();
    60→
    61→    if (!captionsUI.section) {
    62→        console.warn('[SPLICE Captions] Captions section not found in DOM');
    63→        return;
    64→    }
    65→
    66→    // Toggle section expand/collapse
    67→    if (captionsUI.toggle) {
    68→        captionsUI.toggle.addEventListener('click', toggleCaptionsSection);
    69→    }
    70→
    71→    // Load templates
    72→    await loadCaptionTemplates();
    73→
    74→    // Setup event listeners
    75→    setupCaptionEventListeners();
    76→
    77→    // Render template gallery
    78→    renderTemplateGallery();
    79→
    80→    console.log('[SPLICE Captions] Module initialized');
    81→}
    82→
    83→// ============================================================================
    84→// SECTION TOGGLE
    85→// ============================================================================
    86→function toggleCaptionsSection() {
    87→    if (!captionsUI.panel || !captionsUI.toggle) return;
    88→
    89→    const isNowCollapsed = captionsUI.panel.classList.toggle('collapsed');
    90→    const icon = captionsUI.toggle.querySelector('.toggle-icon');
    91→
    92→    if (icon) {
    93→        icon.textContent = isNowCollapsed ? '+' : '-';
    94→    }
    95→}
    96→
    97→// ============================================================================
    98→// LOAD TEMPLATES
    99→// ============================================================================
   100→async function loadCaptionTemplates() {
   101→    try {
   102→        const apiUrl = getBackendUrl();
   103→        const response = await fetchWithTimeout(`${apiUrl}/captions/templates`, {
   104→            method: 'GET',
   105→            headers: { 'Content-Type': 'application/json' }
   106→        }, 30000);
   107→
   108→        if (response.ok) {
   109→            const data = await response.json();
   110→            animatedCaptionsState.templates = data.templates || [];
   111→            console.log(`[SPLICE Captions] Loaded ${animatedCaptionsState.templates.length} templates`);
   112→        }
   113→    } catch (err) {
   114→        console.error('[SPLICE Captions] Failed to load templates:', err);
   115→        // Use fallback templates
   116→        animatedCaptionsState.templates = [
   117→            { id: 'mrbeast', name: 'MrBeast', description: 'Bold, uppercase, colorful' },
   118→            { id: 'hormozi', name: 'Hormozi', description: 'Clean, yellow highlight' },
   119→            { id: 'gaming', name: 'Gaming', description: 'Neon glow, glitch effects' },
   120→            { id: 'corporate', name: 'Corporate', description: 'Subtle, professional' },
   121→            { id: 'karaoke', name: 'Karaoke', description: 'Word-by-word highlight' }
   122→        ];
   123→    }
   124→}
   125→
   126→// ============================================================================
   127→// EVENT LISTENERS
   128→// ============================================================================
   129→function setupCaptionEventListeners() {
   130→    // Template gallery delegation
   131→    if (captionsUI.templateGallery) {
   132→        captionsUI.templateGallery.addEventListener('click', (e) => {
   133→            const card = e.target.closest('.caption-template-card');
   134→            if (card) {
   135→                selectCaptionTemplate(card.dataset.templateId);
   136→            }
   137→        });
   138→    }
   139→
   140→    // Generate button
   141→    if (captionsUI.generateBtn) {
   142→        captionsUI.generateBtn.addEventListener('click', generateCaptions);
   143→    }
   144→
   145→    // Export buttons
   146→    if (captionsUI.exportSrtBtn) {
   147→        captionsUI.exportSrtBtn.addEventListener('click', () => exportCaptions('srt'));
   148→    }
   149→    if (captionsUI.exportMogrtBtn) {
   150→        captionsUI.exportMogrtBtn.addEventListener('click', () => exportCaptions('mogrt'));
   151→    }
   152→
   153→    // Apply to timeline button
   154→    if (captionsUI.applyBtn) {
   155→        captionsUI.applyBtn.addEventListener('click', applyCaptionsToTimeline);
   156→    }
   157→
   158→    // Copy button
   159→    if (captionsUI.copyBtn) {
   160→        captionsUI.copyBtn.addEventListener('click', copyCaptionsToClipboard);
   161→    }
   162→
   163→    // Settings changes
   164→    if (captionsUI.wordsPerLine) {
   165→        captionsUI.wordsPerLine.addEventListener('change', (e) => {
   166→            animatedCaptionsState.settings.maxWordsPerLine = parseInt(e.target.value) || 4;
   167→        });
   168→    }
   169→    if (captionsUI.highlightKeywords) {
   170→        captionsUI.highlightKeywords.addEventListener('change', (e) => {
   171→            animatedCaptionsState.settings.highlightKeywords = e.target.checked;
   172→        });
   173→    }
   174→    if (captionsUI.insertEmojis) {
   175→        captionsUI.insertEmojis.addEventListener('change', (e) => {
   176→            animatedCaptionsState.settings.insertEmojis = e.target.checked;
   177→            // Toggle emoji frequency group visibility
   178→            const emojiFrequencyGroup = document.getElementById('emojiFrequencyGroup');
   179→            if (emojiFrequencyGroup) {
   180→                emojiFrequencyGroup.style.display = e.target.checked ? 'block' : 'none';
   181→            }
   182→        });
   183→    }
   184→    if (captionsUI.emojiFrequency) {
   185→        captionsUI.emojiFrequency.addEventListener('change', (e) => {
   186→            animatedCaptionsState.settings.emojiFrequency = e.target.value;
   187→        });
   188→    }
   189→}
   190→
   191→// ============================================================================
   192→// TEMPLATE GALLERY
   193→// ============================================================================
   194→function renderTemplateGallery() {
   195→    if (!captionsUI.templateGallery) return;
   196→
   197→    const fragment = document.createDocumentFragment();
   198→
   199→    animatedCaptionsState.templates.forEach(template => {
   200→        const card = document.createElement('div');
   201→        card.className = `caption-template-card ${animatedCaptionsState.selectedTemplate === template.id ? 'selected' : ''}`;
   202→        card.dataset.templateId = template.id;
   203→        card.setAttribute('role', 'button');
   204→        card.setAttribute('tabindex', '0');
   205→        card.setAttribute('aria-label', `Select ${escapeHtmlCaptions(template.name)} template`);
   206→
   207→        // SECURITY: Escape template data to prevent XSS (even though it comes from backend/fallback)
   208→        const safeId = escapeHtmlCaptions(template.id);
   209→        const safeName = escapeHtmlCaptions(template.name);
   210→        const safeDesc = escapeHtmlCaptions(template.description);
   211→
   212→        card.innerHTML = `
   213→            <div class="template-preview template-preview-${safeId}">
   214→                <span class="template-preview-text">Hello World</span>
   215→            </div>
   216→            <div class="template-info">
   217→                <span class="template-name">${safeName}</span>
   218→                <span class="template-desc">${safeDesc}</span>
   219→            </div>
   220→        `;
   221→
   222→        fragment.appendChild(card);
   223→    });
   224→
   225→    captionsUI.templateGallery.innerHTML = '';
   226→    captionsUI.templateGallery.appendChild(fragment);
   227→}
   228→
   229→function selectCaptionTemplate(templateId) {
   230→    animatedCaptionsState.selectedTemplate = templateId;
   231→
   232→    // Update UI
   233→    document.querySelectorAll('.caption-template-card').forEach(card => {
   234→        card.classList.toggle('selected', card.dataset.templateId === templateId);
   235→    });
   236→
   237→    console.log(`[SPLICE Captions] Selected template: ${templateId}`);
   238→
   239→    // Re-apply template if we have captions
   240→    if (animatedCaptionsState.captions) {
   241→        applyTemplateToExisting(templateId);
   242→    }
   243→}
   244→
   245→async function applyTemplateToExisting(templateId) {
   246→    if (!animatedCaptionsState.captions) return;
   247→
   248→    try {
   249→        const apiUrl = getBackendUrl();
   250→        const response = await fetchWithTimeout(`${apiUrl}/captions/apply-template`, {
   251→            method: 'POST',
   252→            headers: getAuthHeaders(),
   253→            body: JSON.stringify({
   254→                captionData: { captions: animatedCaptionsState.captions },
   255→                templateId
   256→            })
   257→        }, 30000);
   258→
   259→        if (response.ok) {
   260→            const data = await response.json();
   261→            animatedCaptionsState.captions = data.captions;
   262→            renderCaptionPreview();
   263→        }
   264→    } catch (err) {
   265→        console.error('[SPLICE Captions] Failed to apply template:', err);
   266→    }
   267→}
   268→
   269→// ============================================================================
   270→// CAPTION GENERATION
   271→// ============================================================================
   272→async function generateCaptions() {
   273→    const transcript = getLastTranscript();
   274→    if (!transcript) {
   275→        showCaptionStatus('No transcript available. Run transcription first.', 'error');
   276→        return;
   277→    }
   278→
   279→    // Check online status
   280→    if (typeof isOnline === 'function' && !isOnline()) {
   281→        showCaptionStatus('Offline - Check your connection', 'error');
   282→        return;
   283→    }
   284→
   285→    animatedCaptionsState.isGenerating = true;
   286→    updateGenerateButton(true);
   287→    showCaptionStatus('Generating animated captions...', 'info');
   288→
   289→    try {
   290→        const apiUrl = getBackendUrl();
   291→        const response = await fetchWithTimeout(`${apiUrl}/captions/animate`, {
   292→            method: 'POST',
   293→            headers: getAuthHeaders(),
   294→            body: JSON.stringify({
   295→                transcript,
   296→                template: animatedCaptionsState.selectedTemplate,
   297→                settings: animatedCaptionsState.settings
   298→            })
   299→        }, 120000);
   300→
   301→        if (!response.ok) {
   302→            const errorMsg = await parseErrorResponse(response);
   303→            throw new Error(errorMsg);
   304→        }
   305→
   306→        const data = await response.json();
   307→        animatedCaptionsState.captions = data.captions;
   308→        animatedCaptionsState.keywords = data.keywords || [];
   309→
   310→        // Update UI
   311→        renderCaptionPreview();
   312→        updateCaptionStats(data);
   313→        showCaptionExportActions(true);
   314→        showCaptionStatus(`Generated ${data.totalCaptions} caption lines`, 'success');
   315→
   316→    } catch (err) {
   317→        console.error('[SPLICE Captions] Generation error:', err);
   318→        showCaptionStatus(err.message, 'error');
   319→    } finally {
   320→        animatedCaptionsState.isGenerating = false;
   321→        updateGenerateButton(false);
   322→    }
   323→}
   324→
   325→function getLastTranscript() {
   326→    // Try main module state
   327→    if (window.spliceState?.lastTranscript) {
   328→        return window.spliceState.lastTranscript;
   329→    }
   330→    // Try local state
   331→    if (animatedCaptionsState.lastTranscript) {
   332→        return animatedCaptionsState.lastTranscript;
   333→    }
   334→    return null;
   335→}
   336→
   337→function setCaptionTranscript(transcript) {
   338→    animatedCaptionsState.lastTranscript = transcript;
   339→}
   340→
   341→// ============================================================================
   342→// CAPTION PREVIEW
   343→// ============================================================================
   344→function renderCaptionPreview() {
   345→    if (!captionsUI.previewContainer || !animatedCaptionsState.captions) return;
   346→
   347→    const captions = animatedCaptionsState.captions.slice(0, 10);
   348→    const fragment = document.createDocumentFragment();
   349→
   350→    const list = document.createElement('div');
   351→    list.className = 'caption-preview-list';
   352→
   353→    captions.forEach((caption, i) => {
   354→        const item = document.createElement('div');
   355→        item.className = 'caption-preview-item';
   356→        item.dataset.index = i;
   357→
   358→        const hasKeywords = caption.words?.some(w => w.isKeyword);
   359→        item.innerHTML = `
   360→            <span class="caption-time">${formatCaptionTime(caption.start)}</span>
   361→            <span class="caption-text ${hasKeywords ? 'has-keywords' : ''}">${formatCaptionText(caption)}</span>
   362→        `;
   363→
   364→        list.appendChild(item);
   365→    });
   366→
   367→    if (animatedCaptionsState.captions.length > 10) {
   368→        const more = document.createElement('div');
   369→        more.className = 'caption-preview-more';
   370→        more.textContent = `+ ${animatedCaptionsState.captions.length - 10} more captions`;
   371→        list.appendChild(more);
   372→    }
   373→
   374→    fragment.appendChild(list);
   375→
   376→    captionsUI.previewContainer.innerHTML = '';
   377→    captionsUI.previewContainer.appendChild(fragment);
   378→}
   379→
   380→// SECURITY: Escape HTML to prevent XSS
   381→function escapeHtmlCaptions(str) {
   382→    if (!str) return '';
   383→    const div = document.createElement('div');
   384→    div.textContent = str;
   385→    return div.innerHTML;
   386→}
   387→
   388→function formatCaptionText(caption) {
   389→    if (!caption.words) return escapeHtmlCaptions(caption.text);
   390→
   391→    // SECURITY: Escape user-provided word content to prevent XSS
   392→    return caption.words.map(word => {
   393→        const safeWord = escapeHtmlCaptions(word.word);
   394→        if (word.isKeyword) {
   395→            return `<span class="caption-keyword">${safeWord}</span>`;
   396→        }
   397→        if (word.emoji) {
   398→            const safeEmoji = escapeHtmlCaptions(word.emoji);
   399→            return `${safeWord} ${safeEmoji}`;
   400→        }
   401→        return safeWord;
   402→    }).join(' ');
   403→}
   404→
   405→function formatCaptionTime(seconds) {
   406→    const mins = Math.floor(seconds / 60);
   407→    const secs = Math.floor(seconds % 60);
   408→    return `${mins}:${secs.toString().padStart(2, '0')}`;
   409→}
   410→
   411→function updateCaptionStats(data) {
   412→    if (!captionsUI.stats) return;
   413→
   414→    captionsUI.stats.innerHTML = `
   415→        <span class="stat-item">${data.totalCaptions} lines</span>
   416→        <span class="stat-item">${data.totalWords} words</span>
   417→        <span class="stat-item">${data.keywords?.length || 0} keywords</span>
   418→        <span class="stat-item">${formatCaptionTime(data.duration)}</span>
   419→    `;
   420→}
   421→
   422→// ============================================================================
   423→// EXPORT FUNCTIONS
   424→// ============================================================================
   425→async function exportCaptions(format) {
   426→    if (!animatedCaptionsState.captions) {
   427→        showCaptionStatus('No captions to export. Generate captions first.', 'error');
   428→        return;
   429→    }
   430→
   431→    showCaptionStatus(`Exporting ${format.toUpperCase()}...`, 'info');
   432→
   433→    try {
   434→        const apiUrl = getBackendUrl();
   435→        let endpoint, body;
   436→
   437→        if (format === 'mogrt') {
   438→            endpoint = '/captions/export/mogrt';
   439→            body = {
   440→                captions: animatedCaptionsState.captions,
   441→                settings: { frameRate: 30, width: 1920, height: 1080 }
   442→            };
   443→        } else {
   444→            endpoint = '/export/captions';
   445→            body = {
   446→                transcript: { words: flattenCaptionWords() },
   447→                format
   448→            };
   449→        }
   450→
   451→        const response = await fetchWithTimeout(`${apiUrl}${endpoint}`, {
   452→            method: 'POST',
   453→            headers: getAuthHeaders(),
   454→            body: JSON.stringify(body)
   455→        }, 60000);
   456→
   457→        if (!response.ok) {
   458→            const errorMsg = await parseErrorResponse(response);
   459→            throw new Error(errorMsg);
   460→        }
   461→
   462→        const data = await response.json();
   463→
   464→        if (format === 'mogrt') {
   465→            downloadJSON(data.data, 'animated-captions-mogrt.json');
   466→            showCaptionStatus('MOGRT data exported', 'success');
   467→        } else {
   468→            downloadText(data.content, `captions.${format}`);
   469→            showCaptionStatus(`${format.toUpperCase()} exported`, 'success');
   470→        }
   471→
   472→    } catch (err) {
   473→        console.error('[SPLICE Captions] Export error:', err);
   474→        showCaptionStatus(err.message, 'error');
   475→    }
   476→}
   477→
   478→function flattenCaptionWords() {
   479→    if (!animatedCaptionsState.captions) return [];
   480→
   481→    const words = [];
   482→    animatedCaptionsState.captions.forEach(caption => {
   483→        if (caption.words) {
   484→            caption.words.forEach(w => words.push(w));
   485→        }
   486→    });
   487→    return words;
   488→}
   489→
   490→async function copyCaptionsToClipboard() {
   491→    if (!animatedCaptionsState.captions) {
   492→        showCaptionStatus('No captions to copy', 'error');
   493→        return;
   494→    }
   495→
   496→    const text = animatedCaptionsState.captions
   497→        .map(c => `[${formatCaptionTime(c.start)}] ${c.text}`)
   498→        .join('\n');
   499→
   500→    try {
   501→        await navigator.clipboard.writeText(text);
   502→        showCaptionStatus('Captions copied to clipboard', 'success');
   503→    } catch (err) {
   504→        console.error('[SPLICE Captions] Copy failed:', err);
   505→        showCaptionStatus('Failed to copy', 'error');
   506→    }
   507→}
   508→
   509→// ============================================================================
   510→// TIMELINE INTEGRATION
   511→// ============================================================================
   512→async function applyCaptionsToTimeline() {
   513→    if (!animatedCaptionsState.captions) {
   514→        showCaptionStatus('No captions to apply', 'error');
   515→        return;
   516→    }
   517→
   518→    showCaptionStatus('Applying captions to timeline...', 'info');
   519→
   520→    try {
   521→        // Create markers for each caption
   522→        for (const caption of animatedCaptionsState.captions) {
   523→            const duration = caption.end - caption.start;
   524→            await jsx.call('createMarker', caption.start, caption.text, duration, null, 5); // CERULEAN color
   525→        }
   526→
   527→        showCaptionStatus(`Added ${animatedCaptionsState.captions.length} caption markers`, 'success');
   528→    } catch (err) {
   529→        console.error('[SPLICE Captions] Apply error:', err);
   530→        showCaptionStatus(err.message, 'error');
   531→    }
   532→}
   533→
   534→// ============================================================================
   535→// UI HELPERS
   536→// ============================================================================
   537→function showCaptionExportActions(show) {
   538→    const exportActions = document.getElementById('captionExportActions');
   539→    if (exportActions) {
   540→        exportActions.classList.toggle('hidden', !show);
   541→    }
   542→}
   543→
   544→function showCaptionStatus(message, type = 'info') {
   545→    if (!captionsUI.status) return;
   546→
   547→    captionsUI.status.textContent = message;
   548→    captionsUI.status.className = `caption-status caption-status-${type}`;
   549→
   550→    // Auto-clear after 5 seconds for success/info
   551→    if (type !== 'error') {
   552→        setTimeout(() => {
   553→            captionsUI.status.textContent = '';
   554→            captionsUI.status.className = 'caption-status';
   555→        }, 5000);
   556→    }
   557→}
   558→
   559→function updateGenerateButton(isGenerating) {
   560→    if (!captionsUI.generateBtn) return;
   561→
   562→    captionsUI.generateBtn.disabled = isGenerating;
   563→    captionsUI.generateBtn.textContent = isGenerating ? 'Generating...' : 'Generate Captions';
   564→}
   565→
   566→function downloadJSON(data, filename) {
   567→    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
   568→    const url = URL.createObjectURL(blob);
   569→    const a = document.createElement('a');
   570→    a.href = url;
   571→    a.download = filename;
   572→    a.click();
   573→    URL.revokeObjectURL(url);
   574→}
   575→
   576→function downloadText(content, filename) {
   577→    const blob = new Blob([content], { type: 'text/plain' });
   578→    const url = URL.createObjectURL(blob);
   579→    const a = document.createElement('a');
   580→    a.href = url;
   581→    a.download = filename;
   582→    a.click();
   583→    URL.revokeObjectURL(url);
   584→}
   585→
   586→// ============================================================================
   587→// EXPORTS
   588→// ============================================================================
   589→if (typeof window !== 'undefined') {
   590→    window.initAnimatedCaptions = initAnimatedCaptions;
   591→    window.spliceAnimatedCaptions = {
   592→        init: initAnimatedCaptions,
   593→        generate: generateCaptions,
   594→        setTranscript: setCaptionTranscript,
   595→        selectTemplate: selectCaptionTemplate,
   596→        export: exportCaptions,
   597→        applyToTimeline: applyCaptionsToTimeline,
   598→        getState: () => animatedCaptionsState
   599→    };
   600→}
   601→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
