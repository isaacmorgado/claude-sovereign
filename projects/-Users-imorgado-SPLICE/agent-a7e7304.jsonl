{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a7e7304","slug":"fizzy-hatching-flame","type":"user","message":{"role":"user","content":"Debug why sequence selection doesn't work in the SPLICE CEP panel.\n\nRead these files:\n1. splice-cep/panel/js/main.js - look for checkSequenceOpen function and sequence detection logic\n2. splice-cep/jsx/hostScript.jsx - look for checkSequenceOpen, getActiveSequence functions\n\nLook for:\n- What happens when user selects a sequence\n- How the panel detects if a sequence is open\n- Any race conditions or timing issues\n- Error handling gaps\n- The sequence event listeners\n\nIdentify the root cause of why selecting a sequence doesn't work."},"uuid":"0cba7fcb-c929-44c6-83d6-d29c60f5deb0","timestamp":"2026-01-12T09:17:43.440Z"}
{"parentUuid":"0cba7fcb-c929-44c6-83d6-d29c60f5deb0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a7e7304","slug":"fizzy-hatching-flame","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_014heZFYraSWYS4LoTUnQHhk","type":"message","role":"assistant","content":[{"type":"text","text":"I'll help debug the sequence selection issue in the SPLICE CEP panel. Let me start by reading the relevant files to understand the sequence detection logic."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":29104,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":29104,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CX3EUxqSBuv8sKoivN9e3","type":"assistant","uuid":"f4e0fc79-d18e-4980-8e49-a280f3bea9df","timestamp":"2026-01-12T09:17:46.824Z"}
{"parentUuid":"f4e0fc79-d18e-4980-8e49-a280f3bea9df","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a7e7304","slug":"fizzy-hatching-flame","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_014heZFYraSWYS4LoTUnQHhk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019tWbeGVaz8NsX6FM8vMpXk","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/main.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":29104,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":29104,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CX3EUxqSBuv8sKoivN9e3","type":"assistant","uuid":"86da5c94-747a-4e2a-856e-8571163cea06","timestamp":"2026-01-12T09:17:47.530Z"}
{"parentUuid":"86da5c94-747a-4e2a-856e-8571163cea06","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a7e7304","slug":"fizzy-hatching-flame","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_014heZFYraSWYS4LoTUnQHhk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A6h7SLXgbsjeQxfgSqwvWR","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/jsx/hostScript.jsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":29104,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":29104,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CX3EUxqSBuv8sKoivN9e3","type":"assistant","uuid":"7113280e-709e-423c-af08-31c626ce4dcb","timestamp":"2026-01-12T09:17:47.952Z"}
{"parentUuid":"7113280e-709e-423c-af08-31c626ce4dcb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a7e7304","slug":"fizzy-hatching-flame","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019tWbeGVaz8NsX6FM8vMpXk","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Panel - Main Entry Point\n     3→ * v4.0.0 - CEP Migration\n     4→ */\n     5→\n     6→// ============================================================================\n     7→// CACHED DOM ELEMENTS\n     8→// ============================================================================\n     9→const ui = {};\n    10→\n    11→function cacheUIElements() {\n    12→    ui.status = document.getElementById('status');\n    13→    ui.goBtn = document.getElementById('goBtn');\n    14→    ui.optionsToggle = document.getElementById('optionsToggle');\n    15→    ui.optionsPanel = document.getElementById('optionsPanel');\n    16→\n    17→    // DIAGNOSTIC: Log critical element status immediately\n    18→    const criticalElements = {\n    19→        'status': ui.status,\n    20→        'goBtn': ui.goBtn,\n    21→        'optionsToggle': ui.optionsToggle,\n    22→        'optionsPanel': ui.optionsPanel\n    23→    };\n    24→    const missingCritical = Object.entries(criticalElements)\n    25→        .filter(([name, el]) => !el)\n    26→        .map(([name]) => name);\n    27→\n    28→    if (missingCritical.length > 0) {\n    29→        console.error('[SPLICE] CRITICAL: Missing UI elements during cache:', missingCritical);\n    30→        console.error('[SPLICE] DOM readyState:', document.readyState);\n    31→    }\n    32→\n    33→    // Sliders and options\n    34→    ui.sensitivitySlider = document.getElementById('sensitivitySlider');\n    35→    ui.sensitivityValue = document.getElementById('sensitivityValue');\n    36→    ui.sourceOriginal = document.getElementById('sourceOriginal');\n    37→    ui.sourceIsolated = document.getElementById('sourceIsolated');\n    38→\n    39→    // Feature toggles\n    40→    ui.enableTakesDetection = document.getElementById('enableTakesDetection');\n    41→    ui.enableJCut = document.getElementById('enableJCut');\n    42→    ui.jcutSettings = document.getElementById('jcutSettings');\n    43→    ui.jcutLeadIn = document.getElementById('jcutLeadIn');\n    44→    ui.jcutLeadInValue = document.getElementById('jcutLeadInValue');\n    45→    ui.jcutLeadOut = document.getElementById('jcutLeadOut');\n    46→    ui.jcutLeadOutValue = document.getElementById('jcutLeadOutValue');\n    47→\n    48→    // Zoom settings\n    49→    ui.enableZoom = document.getElementById('enableZoom');\n    50→    ui.zoomSettings = document.getElementById('zoomSettings');\n    51→    ui.zoomFrequency = document.getElementById('zoomFrequency');\n    52→    ui.zoomPreset = document.getElementById('zoomPreset');\n    53→    ui.zoomPlacement = document.getElementById('zoomPlacement');\n    54→\n    55→    // Chapter settings\n    56→    ui.enableChapters = document.getElementById('enableChapters');\n    57→    ui.chapterSettings = document.getElementById('chapterSettings');\n    58→    ui.maxChapters = document.getElementById('maxChapters');\n    59→    ui.minChapterLength = document.getElementById('minChapterLength');\n    60→\n    61→    // Profanity settings\n    62→    ui.enableProfanity = document.getElementById('enableProfanity');\n    63→    ui.profanitySettings = document.getElementById('profanitySettings');\n    64→\n    65→    // Filler word settings\n    66→    ui.enableFillerDetection = document.getElementById('enableFillerDetection');\n    67→    ui.fillerSettings = document.getElementById('fillerSettings');\n    68→\n    69→    // Progress\n    70→    ui.progressContainer = document.getElementById('progressContainer');\n    71→    ui.progressBar = document.getElementById('progressBar');\n    72→    ui.progressText = document.getElementById('progressText');\n    73→    ui.resultsEmpty = document.getElementById('resultsEmpty');\n    74→\n    75→    // Preview\n    76→    ui.combinedPreview = document.getElementById('combinedPreview');\n    77→    ui.previewList = document.getElementById('previewList');\n    78→    ui.silenceCount = document.getElementById('silenceCount');\n    79→    ui.takeCount = document.getElementById('takeCount');\n    80→    ui.selectedCount = document.getElementById('selectedCount');\n    81→    ui.selectAllSilences = document.getElementById('selectAllSilences');\n    82→    ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');\n    83→    ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');\n    84→    ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');\n    85→\n    86→    // Results\n    87→    ui.zoomResults = document.getElementById('zoomResults');\n    88→    ui.zoomList = document.getElementById('zoomList');\n    89→    ui.chapterResults = document.getElementById('chapterResults');\n    90→    ui.chapterList = document.getElementById('chapterList');\n    91→    ui.copyYouTubeBtn = document.getElementById('copyYouTubeBtn');\n    92→    ui.addChapterMarkersBtn = document.getElementById('addChapterMarkersBtn');\n    93→\n    94→    // Modals\n    95→    ui.settingsBtn = document.getElementById('settingsBtn');\n    96→    ui.settingsModal = document.getElementById('settingsModal');\n    97→    ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');\n    98→    ui.loginModal = document.getElementById('loginModal');\n    99→    ui.closeLoginBtn = document.getElementById('closeLoginBtn');\n   100→    ui.licenseKeyInput = document.getElementById('licenseKeyInput');\n   101→    ui.saveLoginBtn = document.getElementById('saveLoginBtn');\n   102→\n   103→    // Debug modal\n   104→    ui.debugBtn = document.getElementById('debugBtn');\n   105→    ui.debugModal = document.getElementById('debugModal');\n   106→    ui.closeDebugBtn = document.getElementById('closeDebugBtn');\n   107→    ui.debugQuickDiagnosis = document.getElementById('debugQuickDiagnosis');\n   108→    ui.debugLogs = document.getElementById('debugLogs');\n   109→    ui.runDiagnosticsBtn = document.getElementById('runDiagnosticsBtn');\n   110→    ui.copyDiagnosticsBtn = document.getElementById('copyDiagnosticsBtn');\n   111→\n   112→    // Credit badge\n   113→    ui.creditBadge = document.getElementById('creditBadge');\n   114→\n   115→    // Preset selector\n   116→    ui.presetSelector = document.getElementById('presetSelector');\n   117→}\n   118→\n   119→// ============================================================================\n   120→// STATE MANAGEMENT\n   121→// ============================================================================\n   122→let previewSilences = [];\n   123→let previewTakes = [];\n   124→let currentChapters = [];\n   125→let currentZooms = [];\n   126→let currentProfanity = [];\n   127→let selectedSilenceIndices = new Set();\n   128→let isOperationInProgress = false;\n   129→let lastDetectionResult = null;\n   130→let currentAudioPath = null;\n   131→let currentSequenceInfo = null;\n   132→let currentTranscript = null;\n   133→\n   134→// Global state for captions/reframe modules\n   135→window.spliceState = {\n   136→    lastTranscript: null,\n   137→    currentVideoPath: null,\n   138→    activeSequence: null,\n   139→    audioPath: null\n   140→};\n   141→\n   142→// Also expose transcript globally for music module\n   143→window.currentTranscript = null;\n   144→\n   145→// ============================================================================\n   146→// INITIALIZATION\n   147→// ============================================================================\n   148→document.addEventListener('DOMContentLoaded', async () => {\n   149→    // Premium Loading Experience\n   150→    setTimeout(() => {\n   151→        const loader = document.getElementById('loading-overlay');\n   152→        if (loader) loader.classList.add('hidden');\n   153→    }, 800); // Small delay for smooth perception\n   154→    debugLog('Initializing CEP panel...');\n   155→\n   156→    // Debug: Show init started\n   157→    const statusEl = document.getElementById('status');\n   158→    if (statusEl) statusEl.textContent = 'Initializing...';\n   159→\n   160→    // Cache DOM elements\n   161→    cacheUIElements();\n   162→\n   163→    // Load settings\n   164→    loadSettingsToUI();\n   165→\n   166→    // Initialize UI handlers\n   167→    initOptionsToggle();\n   168→    initSliders();\n   169→    initFeatureToggles();\n   170→    initPresetSelector();\n   171→    initGoButton();\n   172→    initPreviewHandlers();\n   173→    initModals();\n   174→    initLoginModal();\n   175→    initCredits();\n   176→    initHelpButton();\n   177→    initDebugModal();\n   178→\n   179→    // Initialize offline detection\n   180→    if (typeof initOfflineDetection === 'function') {\n   181→        initOfflineDetection();\n   182→    }\n   183→\n   184→    // Initialize multitrack UI\n   185→    if (typeof initMultitrackUI === 'function') {\n   186→        initMultitrackUI();\n   187→    }\n   188→\n   189→    // Initialize animated captions UI\n   190→    if (typeof initAnimatedCaptions === 'function') {\n   191→        initAnimatedCaptions();\n   192→    }\n   193→\n   194→    // Initialize text editor UI\n   195→    if (typeof initTextEditor === 'function') {\n   196→        initTextEditor();\n   197→    }\n   198→\n   199→    // Initialize text editor section toggle\n   200→    initTextEditorToggle();\n   201→\n   202→    // Initialize social reframe UI\n   203→    if (typeof initSocialReframe === 'function') {\n   204→        initSocialReframe();\n   205→    }\n   206→\n   207→    // Initialize social reframe section toggle\n   208→    initSocialReframeToggle();\n   209→\n   210→    // Initialize music UI\n   211→    if (typeof initMusicModule === 'function') {\n   212→        initMusicModule();\n   213→    }\n   214→\n   215→    // Initialize music section toggle\n   216→    initMusicToggle();\n   217→\n   218→    // Initialize JSX bridge first, then check connection\n   219→    // This ensures jsx.init() completes before checkJSXConnection() uses it\n   220→    await jsx.init();\n   221→    await checkJSXConnection();\n   222→\n   223→    // Initialize sequence event listeners for real-time state updates\n   224→    initSequenceEventListeners();\n   225→\n   226→    // DIAGNOSTIC: Verify all critical UI elements are properly initialized\n   227→    verifyUIInitialization();\n   228→\n   229→    setStatus('Ready');\n   230→    debugLog('CEP panel initialized');\n   231→});\n   232→\n   233→/**\n   234→ * Post-initialization diagnostic to verify all critical UI elements\n   235→ * are properly cached and event listeners are attached\n   236→ */\n   237→function verifyUIInitialization() {\n   238→    const criticalElements = {\n   239→        'goBtn': { el: ui.goBtn, desc: 'GO button (main action)' },\n   240→        'settingsBtn': { el: ui.settingsBtn, desc: 'Settings button' },\n   241→        'debugBtn': { el: ui.debugBtn, desc: 'Debug button' },\n   242→        'creditBadge': { el: ui.creditBadge, desc: 'Credit badge' },\n   243→        'status': { el: ui.status, desc: 'Status bar' },\n   244→        'optionsToggle': { el: ui.optionsToggle, desc: 'Options toggle' },\n   245→        'optionsPanel': { el: ui.optionsPanel, desc: 'Options panel' }\n   246→    };\n   247→\n   248→    const missingElements = [];\n   249→    const presentElements = [];\n   250→\n   251→    Object.entries(criticalElements).forEach(([id, { el, desc }]) => {\n   252→        if (!el) {\n   253→            missingElements.push(`#${id} (${desc})`);\n   254→        } else {\n   255→            presentElements.push(id);\n   256→        }\n   257→    });\n   258→\n   259→    if (missingElements.length > 0) {\n   260→        console.error('[SPLICE] ⚠️ UI INITIALIZATION INCOMPLETE');\n   261→        console.error('[SPLICE] Missing critical elements:', missingElements);\n   262→        console.error('[SPLICE] Panel may not function correctly. Check index.html structure.');\n   263→\n   264→        // Show error in status bar if available\n   265→        const statusEl = document.getElementById('status');\n   266→        if (statusEl) {\n   267→            statusEl.textContent = 'Init error: ' + missingElements.length + ' UI elements missing';\n   268→            statusEl.classList.add('error');\n   269→        }\n   270→    } else {\n   271→        console.log('[SPLICE] ✓ All critical UI elements initialized:', presentElements.join(', '));\n   272→    }\n   273→\n   274→    // Verify GO button has click listener\n   275→    if (ui.goBtn) {\n   276→        const listeners = getEventListeners ? getEventListeners(ui.goBtn) : null;\n   277→        if (!listeners || !listeners.click || listeners.click.length === 0) {\n   278→            // Can't check in production, but log that we tried\n   279→            console.log('[SPLICE] GO button present - click handler should be attached');\n   280→        }\n   281→    }\n   282→}\n   283→\n   284→// ============================================================================\n   285→// SEQUENCE EVENT LISTENERS\n   286→// ============================================================================\n   287→/**\n   288→ * Initialize event listeners for sequence state changes\n   289→ * This provides real-time updates when sequences are activated/deactivated\n   290→ */\n   291→function initSequenceEventListeners() {\n   292→    if (!jsx.cs) {\n   293→        console.warn('[SPLICE] Cannot init sequence listeners - CSInterface not available');\n   294→        return;\n   295→    }\n   296→\n   297→    try {\n   298→        // Listen for sequence activation events\n   299→        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceActivated', async (event) => {\n   300→            debugLog('Sequence activated event received');\n   301→            try {\n   302→                const seqInfo = await jsx.call('getActiveSequence');\n   303→                if (seqInfo && !seqInfo.error) {\n   304→                    window.spliceState.activeSequence = seqInfo;\n   305→                    setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));\n   306→                    debugLog('Active sequence updated:', seqInfo.name);\n   307→                }\n   308→            } catch (e) {\n   309→                console.warn('[SPLICE] Failed to get sequence info on activation:', e.message);\n   310→            }\n   311→        });\n   312→\n   313→        // Listen for sequence close/deactivation\n   314→        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceDeactivated', () => {\n   315→            debugLog('Sequence deactivated event');\n   316→            window.spliceState.activeSequence = null;\n   317→            setStatus('No sequence open', true);\n   318→        });\n   319→\n   320→        // Listen for project item selection changes (includes sequences)\n   321→        jsx.cs.addEventListener('com.adobe.csxs.events.SelectionChanged', async () => {\n   322→            // Debounce rapid selection changes\n   323→            if (window._selectionChangeTimeout) {\n   324→                clearTimeout(window._selectionChangeTimeout);\n   325→            }\n   326→            window._selectionChangeTimeout = setTimeout(async () => {\n   327→                try {\n   328→                    const hasSequence = await checkSequenceOpen(0, 0); // Quick check, no retries\n   329→                    if (hasSequence && !window.spliceState.activeSequence) {\n   330→                        const seqInfo = await jsx.call('getActiveSequence');\n   331→                        if (seqInfo && !seqInfo.error) {\n   332→                            window.spliceState.activeSequence = seqInfo;\n   333→                            debugLog('Sequence detected via selection change:', seqInfo.name);\n   334→                        }\n   335→                    }\n   336→                } catch (e) {\n   337→                    // Ignore errors during selection change - it's just for proactive updates\n   338→                }\n   339→            }, 200);\n   340→        });\n   341→\n   342→        debugLog('Sequence event listeners initialized');\n   343→    } catch (e) {\n   344→        console.error('[SPLICE] Failed to init sequence event listeners:', e.message);\n   345→    }\n   346→}\n   347→\n   348→// ============================================================================\n   349→// JSX CONNECTION CHECK\n   350→// ============================================================================\n   351→async function checkJSXConnection() {\n   352→    try {\n   353→        const result = await jsx.call('getVersion');\n   354→        debugLog('JSX connection OK, version:', result);\n   355→        return true;\n   356→    } catch (e) {\n   357→        console.warn('[SPLICE] JSX connection failed:', e.message);\n   358→        setStatus('Premiere Pro connection failed', true);\n   359→        return false;\n   360→    }\n   361→}\n   362→\n   363→/**\n   364→ * Check if a sequence is currently open in the Timeline\n   365→ * Enhanced with logging and retry logic\n   366→ * @param {number} retries - Number of retry attempts (default: 2)\n   367→ * @param {number} delayMs - Delay between retries in ms (default: 300)\n   368→ * @returns {Promise<boolean>} true if sequence is open\n   369→ */\n   370→async function checkSequenceOpen(retries = 2, delayMs = 300) {\n   371→    console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC START ==========');\n   372→    console.log('[SPLICE] checkSequenceOpen: retries=' + retries + ', delayMs=' + delayMs);\n   373→    console.log('[SPLICE] checkSequenceOpen: window.spliceState.activeSequence =', window.spliceState.activeSequence);\n   374→    \n   375→    for (let attempt = 0; attempt <= retries; attempt++) {\n   376→        try {\n   377→            console.log('[SPLICE] checkSequenceOpen: Attempt ' + (attempt + 1) + ' of ' + (retries + 1));\n   378→            console.log('[SPLICE] checkSequenceOpen: Calling jsx.call(\"checkSequenceOpen\")...');\n   379→            const result = await jsx.call('checkSequenceOpen');\n   380→            console.log('[SPLICE] checkSequenceOpen: JSX call returned');\n   381→            console.log('[SPLICE] checkSequenceOpen: result =', result, '(type:', typeof result + ')');\n   382→            debugLog('checkSequenceOpen attempt', attempt + 1, 'result:', result, 'type:', typeof result);\n   383→\n   384→            if (result === true || result === 'true') {\n   385→                console.log('[SPLICE] checkSequenceOpen: Returning TRUE - sequence is open');\n   386→                console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n   387→                return true;\n   388→            }\n   389→\n   390→            // If false, wait and retry (sequence might be loading)\n   391→            if (attempt < retries) {\n   392→                console.log('[SPLICE] checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');\n   393→                debugLog('checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');\n   394→                await new Promise(r => setTimeout(r, delayMs));\n   395→            }\n   396→        } catch (error) {\n   397→            console.error('[SPLICE] checkSequenceOpen: Attempt', attempt + 1, 'failed with exception:', error.message);\n   398→            console.error('[SPLICE] checkSequenceOpen: Error stack:', error.stack);\n   399→\n   400→            // On last attempt, return false but log the actual error\n   401→            if (attempt === retries) {\n   402→                console.error('[SPLICE] checkSequenceOpen: All attempts failed. Last error:', error.message);\n   403→                // Store error for diagnostics\n   404→                window.spliceState.lastSequenceCheckError = error.message;\n   405→                console.log('[SPLICE] checkSequenceOpen: Stored error in window.spliceState.lastSequenceCheckError:', error.message);\n   406→                console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC END (ERROR) ==========');\n   407→                return false;\n   408→            }\n   409→\n   410→            // Wait before retry\n   411→            console.log('[SPLICE] checkSequenceOpen: Waiting', delayMs, 'ms before retry...');\n   412→            await new Promise(r => setTimeout(r, delayMs));\n   413→        }\n   414→    }\n   415→    console.log('[SPLICE] checkSequenceOpen: All attempts completed without finding sequence');\n   416→    console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC END (FALSE) ==========');\n   417→    return false;\n   418→}\n   419→\n   420→// ============================================================================\n   421→// OPTIONS TOGGLE\n   422→// ============================================================================\n   423→function initOptionsToggle() {\n   424→    debugLog('initOptionsToggle - toggle:', !!ui.optionsToggle, 'panel:', !!ui.optionsPanel);\n   425→    if (ui.optionsToggle && ui.optionsPanel) {\n   426→        ui.optionsToggle.addEventListener('click', () => {\n   427→            debugLog('Options toggle clicked');\n   428→            // Check current state BEFORE toggling\n   429→            const wasCollapsed = ui.optionsPanel.classList.contains('collapsed');\n   430→            ui.optionsPanel.classList.toggle('collapsed');\n   431→            // If it was collapsed, it's now expanded (show 'expanded' class)\n   432→            ui.optionsToggle.classList.toggle('expanded', wasCollapsed);\n   433→            saveSettings({ expandedOptions: wasCollapsed });\n   434→        });\n   435→\n   436→        // Restore state\n   437→        const settings = getSettings();\n   438→        if (!settings.expandedOptions) {\n   439→            ui.optionsPanel.classList.add('collapsed');\n   440→            ui.optionsToggle.classList.remove('expanded');\n   441→        } else {\n   442→            ui.optionsToggle.classList.add('expanded');\n   443→            ui.optionsPanel.classList.remove('collapsed');\n   444→        }\n   445→    }\n   446→}\n   447→\n   448→// ============================================================================\n   449→// TEXT EDITOR TOGGLE\n   450→// ============================================================================\n   451→function initTextEditorToggle() {\n   452→    const toggle = document.getElementById('textEditorToggle');\n   453→    const panel = document.getElementById('text-editor-panel');\n   454→    debugLog('initTextEditorToggle - toggle:', !!toggle, 'panel:', !!panel);\n   455→\n   456→    if (toggle && panel) {\n   457→        toggle.addEventListener('click', (e) => {\n   458→            e.preventDefault();\n   459→            e.stopPropagation();\n   460→            debugLog('Text Editor toggle clicked');\n   461→            setStatus('Text Editor: ' + (panel.classList.contains('collapsed') ? 'Opening' : 'Closing'));\n   462→            // Check state BEFORE toggling\n   463→            const wasCollapsed = panel.classList.contains('collapsed');\n   464→            panel.classList.toggle('collapsed');\n   465→            const icon = toggle.querySelector('.toggle-icon');\n   466→            debugLog('wasCollapsed:', wasCollapsed, 'icon:', !!icon);\n   467→            if (icon) {\n   468→                // If it was collapsed, it's now expanded (show -)\n   469→                icon.textContent = wasCollapsed ? '-' : '+';\n   470→            }\n   471→        });\n   472→    } else {\n   473→        console.error('[SPLICE] Text Editor toggle elements not found!');\n   474→    }\n   475→}\n   476→\n   477→// ============================================================================\n   478→// SOCIAL REFRAME TOGGLE\n   479→// ============================================================================\n   480→function initSocialReframeToggle() {\n   481→    const toggle = document.getElementById('socialReframeToggle');\n   482→    const panel = document.getElementById('social-reframe-panel');\n   483→    debugLog('initSocialReframeToggle - toggle:', !!toggle, 'panel:', !!panel);\n   484→\n   485→    if (toggle && panel) {\n   486→        toggle.addEventListener('click', () => {\n   487→            debugLog('Social Reframe toggle clicked');\n   488→            // Check state BEFORE toggling\n   489→            const wasCollapsed = panel.classList.contains('collapsed');\n   490→            panel.classList.toggle('collapsed');\n   491→            const icon = toggle.querySelector('.toggle-icon');\n   492→            if (icon) {\n   493→                // If it was collapsed, it's now expanded (show -)\n   494→                icon.textContent = wasCollapsed ? '-' : '+';\n   495→            }\n   496→        });\n   497→    } else {\n   498→        console.error('[SPLICE] Social Reframe toggle elements not found!');\n   499→    }\n   500→}\n   501→\n   502→// ============================================================================\n   503→// MUSIC TOGGLE\n   504→// ============================================================================\n   505→function initMusicToggle() {\n   506→    const toggle = document.getElementById('musicToggle');\n   507→    const panel = document.getElementById('music-panel');\n   508→    debugLog('initMusicToggle - toggle:', !!toggle, 'panel:', !!panel);\n   509→\n   510→    if (toggle && panel) {\n   511→        toggle.addEventListener('click', () => {\n   512→            debugLog('Music toggle clicked');\n   513→            // Check state BEFORE toggling\n   514→            const wasCollapsed = panel.classList.contains('collapsed');\n   515→            panel.classList.toggle('collapsed');\n   516→            const icon = toggle.querySelector('.toggle-icon');\n   517→            if (icon) {\n   518→                // If it was collapsed, it's now expanded (show -)\n   519→                icon.textContent = wasCollapsed ? '-' : '+';\n   520→            }\n   521→        });\n   522→    } else {\n   523→        console.error('[SPLICE] Music toggle elements not found!');\n   524→    }\n   525→}\n   526→\n   527→// ============================================================================\n   528→// SLIDERS\n   529→// ============================================================================\n   530→function initSliders() {\n   531→    // Sensitivity slider\n   532→    if (ui.sensitivitySlider && ui.sensitivityValue) {\n   533→        ui.sensitivitySlider.addEventListener('input', () => {\n   534→            ui.sensitivityValue.textContent = ui.sensitivitySlider.value;\n   535→            saveSettings({ sensitivity: parseInt(ui.sensitivitySlider.value) });\n   536→        });\n   537→    }\n   538→\n   539→    // J-Cut sliders\n   540→    if (ui.jcutLeadIn && ui.jcutLeadInValue) {\n   541→        ui.jcutLeadIn.addEventListener('input', () => {\n   542→            const val = (ui.jcutLeadIn.value / 100).toFixed(2);\n   543→            ui.jcutLeadInValue.textContent = val + 's';\n   544→            saveSettings({ jcutLeadIn: parseFloat(val) });\n   545→        });\n   546→    }\n   547→\n   548→    if (ui.jcutLeadOut && ui.jcutLeadOutValue) {\n   549→        ui.jcutLeadOut.addEventListener('input', () => {\n   550→            const val = (ui.jcutLeadOut.value / 100).toFixed(2);\n   551→            ui.jcutLeadOutValue.textContent = val + 's';\n   552→            saveSettings({ jcutLeadOut: parseFloat(val) });\n   553→        });\n   554→    }\n   555→}\n   556→\n   557→// ============================================================================\n   558→// FEATURE TOGGLES\n   559→// ============================================================================\n   560→function initFeatureToggles() {\n   561→    // J-Cut toggle\n   562→    if (ui.enableJCut && ui.jcutSettings) {\n   563→        ui.enableJCut.addEventListener('change', () => {\n   564→            ui.jcutSettings.classList.toggle('collapsed', !ui.enableJCut.checked);\n   565→            saveSettings({ enableJCut: ui.enableJCut.checked });\n   566→        });\n   567→    }\n   568→\n   569→    // Zoom toggle\n   570→    if (ui.enableZoom && ui.zoomSettings) {\n   571→        ui.enableZoom.addEventListener('change', () => {\n   572→            ui.zoomSettings.classList.toggle('collapsed', !ui.enableZoom.checked);\n   573→            saveSettings({ enableZoom: ui.enableZoom.checked });\n   574→        });\n   575→    }\n   576→\n   577→    // Chapters toggle\n   578→    if (ui.enableChapters && ui.chapterSettings) {\n   579→        ui.enableChapters.addEventListener('change', () => {\n   580→            ui.chapterSettings.classList.toggle('collapsed', !ui.enableChapters.checked);\n   581→            saveSettings({ enableChapters: ui.enableChapters.checked });\n   582→        });\n   583→    }\n   584→\n   585→    // Takes detection toggle\n   586→    if (ui.enableTakesDetection) {\n   587→        ui.enableTakesDetection.addEventListener('change', () => {\n   588→            saveSettings({ enableTakesDetection: ui.enableTakesDetection.checked });\n   589→        });\n   590→    }\n   591→\n   592→    // Profanity detection toggle\n   593→    if (ui.enableProfanity && ui.profanitySettings) {\n   594→        ui.enableProfanity.addEventListener('change', () => {\n   595→            ui.profanitySettings.classList.toggle('collapsed', !ui.enableProfanity.checked);\n   596→            saveSettings({ enableProfanity: ui.enableProfanity.checked });\n   597→        });\n   598→    }\n   599→\n   600→    // Filler word detection toggle\n   601→    if (ui.enableFillerDetection && ui.fillerSettings) {\n   602→        ui.enableFillerDetection.addEventListener('change', () => {\n   603→            ui.fillerSettings.classList.toggle('collapsed', !ui.enableFillerDetection.checked);\n   604→            saveSettings({ enableFillerDetection: ui.enableFillerDetection.checked });\n   605→        });\n   606→    }\n   607→}\n   608→\n   609→// ============================================================================\n   610→// PRESET SELECTOR\n   611→// ============================================================================\n   612→// PRESETS is defined in config.js\n   613→\n   614→function initPresetSelector() {\n   615→    if (!ui.presetSelector) return;\n   616→\n   617→    ui.presetSelector.addEventListener('change', () => {\n   618→        const presetId = ui.presetSelector.value;\n   619→        applyPreset(presetId);\n   620→    });\n   621→\n   622→    // Load current preset\n   623→    const settings = getSettings();\n   624→    if (settings.activePreset) {\n   625→        ui.presetSelector.value = settings.activePreset;\n   626→    }\n   627→}\n   628→\n   629→function applyPreset(presetId) {\n   630→    const preset = PRESETS[presetId];\n   631→    if (!preset) return;\n   632→\n   633→    // Custom preset - keep current settings\n   634→    if (presetId === 'custom' || !preset.settings) {\n   635→        saveSettings({ activePreset: 'custom' });\n   636→        setStatus('Using custom settings');\n   637→        return;\n   638→    }\n   639→\n   640→    const settings = preset.settings;\n   641→\n   642→    // Apply to UI\n   643→    if (ui.sensitivitySlider && settings.sensitivity !== undefined) {\n   644→        ui.sensitivitySlider.value = settings.sensitivity;\n   645→        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n   646→    }\n   647→\n   648→    if (ui.enableJCut) {\n   649→        ui.enableJCut.checked = settings.enableJCut || false;\n   650→        if (ui.jcutSettings) {\n   651→            ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n   652→        }\n   653→    }\n   654→\n   655→    if (settings.jCutLeadIn !== undefined && ui.jcutLeadIn) {\n   656→        ui.jcutLeadIn.value = Math.round(settings.jCutLeadIn * 100);\n   657→        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jCutLeadIn + 's';\n   658→    }\n   659→\n   660→    if (settings.jCutLeadOut !== undefined && ui.jcutLeadOut) {\n   661→        ui.jcutLeadOut.value = Math.round(settings.jCutLeadOut * 100);\n   662→        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jCutLeadOut + 's';\n   663→    }\n   664→\n   665→    // Save merged settings\n   666→    saveSettings({\n   667→        activePreset: presetId,\n   668→        sensitivity: settings.sensitivity,\n   669→        threshold: settings.threshold,\n   670→        minSilenceLength: settings.minSilenceLength,\n   671→        paddingStart: settings.paddingStart,\n   672→        paddingEnd: settings.paddingEnd,\n   673→        enableTakesDetection: settings.enableTakesDetection,\n   674→        enableJCut: settings.enableJCut || false,\n   675→        jcutLeadIn: settings.jCutLeadIn || 0.3,\n   676→        jcutLeadOut: settings.jCutLeadOut || 0.2\n   677→    });\n   678→\n   679→    setStatus(`Applied ${preset.name} preset`);\n   680→}\n   681→\n   682→// ============================================================================\n   683→// LOAD SETTINGS TO UI\n   684→// ============================================================================\n   685→function loadSettingsToUI() {\n   686→    const settings = getSettings();\n   687→\n   688→    if (ui.sensitivitySlider) {\n   689→        ui.sensitivitySlider.value = settings.sensitivity;\n   690→        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n   691→    }\n   692→\n   693→    if (ui.enableTakesDetection) ui.enableTakesDetection.checked = settings.enableTakesDetection;\n   694→    if (ui.enableJCut) ui.enableJCut.checked = settings.enableJCut;\n   695→    if (ui.enableZoom) ui.enableZoom.checked = settings.enableZoom;\n   696→    if (ui.enableChapters) ui.enableChapters.checked = settings.enableChapters;\n   697→\n   698→    if (ui.jcutSettings) ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n   699→    if (ui.zoomSettings) ui.zoomSettings.classList.toggle('collapsed', !settings.enableZoom);\n   700→    if (ui.chapterSettings) ui.chapterSettings.classList.toggle('collapsed', !settings.enableChapters);\n   701→\n   702→    if (ui.jcutLeadIn) {\n   703→        ui.jcutLeadIn.value = Math.round(settings.jcutLeadIn * 100);\n   704→        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jcutLeadIn + 's';\n   705→    }\n   706→    if (ui.jcutLeadOut) {\n   707→        ui.jcutLeadOut.value = Math.round(settings.jcutLeadOut * 100);\n   708→        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jcutLeadOut + 's';\n   709→    }\n   710→\n   711→    if (ui.presetSelector && settings.activePreset) {\n   712→        ui.presetSelector.value = settings.activePreset;\n   713→    }\n   714→}\n   715→\n   716→// ============================================================================\n   717→// GO BUTTON - MAIN WORKFLOW\n   718→// ============================================================================\n   719→function initGoButton() {\n   720→    if (!ui.goBtn) {\n   721→        console.error('[SPLICE] initGoButton FAILED: #goBtn element not found in DOM');\n   722→        console.error('[SPLICE] Check that index.html contains <button id=\"goBtn\">');\n   723→        return;\n   724→    }\n   725→\n   726→    ui.goBtn.addEventListener('click', async () => {\n   727→        if (isOperationInProgress) return;\n   728→        await runDetection();\n   729→    });\n   730→    console.log('[SPLICE] initGoButton: GO button initialized successfully');\n   731→}\n   732→\n   733→async function runDetection() {\n   734→    if (isOperationInProgress) return;\n   735→\n   736→    // Check sequence with enhanced error messaging\n   737→    const hasSequence = await checkSequenceOpen();\n   738→    if (!hasSequence) {\n   739→        // Check if there was a communication error vs just no sequence\n   740→        const lastError = window.spliceState.lastSequenceCheckError;\n   741→        if (lastError && (lastError.includes('CEP') || lastError.includes('communication') || lastError.includes('evalScript'))) {\n   742→            setStatus('Premiere Pro connection issue - try reopening panel', true);\n   743→            console.error('[SPLICE] runDetection: JSX communication failure:', lastError);\n   744→        } else {\n   745→            setStatus('Please open a sequence in the Timeline first', true);\n   746→            debugLog('runDetection: No active sequence in Timeline');\n   747→        }\n   748→        // Clear the error for next check\n   749→        window.spliceState.lastSequenceCheckError = null;\n   750→        return;\n   751→    }\n   752→\n   753→    // Check online\n   754→    if (!isOnline()) {\n   755→        setStatus('Offline - Check your connection', true);\n   756→        return;\n   757→    }\n   758→\n   759→    isOperationInProgress = true;\n   760→    ui.goBtn.disabled = true;\n   761→    showProgress('Detecting silences...');\n   762→\n   763→    try {\n   764→        const settings = getSettings();\n   765→\n   766→        // Get sequence info\n   767→        const seqInfo = await jsx.call('getActiveSequence');\n   768→        debugLog('Sequence info:', seqInfo);\n   769→\n   770→        // Store sequence info for later use\n   771→        currentSequenceInfo = seqInfo;\n   772→        window.spliceState.activeSequence = seqInfo;\n   773→        if (seqInfo && seqInfo.videoPath) {\n   774→            window.spliceState.currentVideoPath = seqInfo.videoPath;\n   775→        }\n   776→\n   777→        // Export audio via JSX for silence detection\n   778→        updateProgress(10, 'Exporting audio...');\n   779→\n   780→        let audioFilePath = null;\n   781→        try {\n   782→            // Get sequence info for audio export\n   783→            const exportResult = await jsx.call('exportSequenceAudioForAnalysis');\n   784→            if (exportResult && exportResult.success && exportResult.outputPath) {\n   785→                audioFilePath = exportResult.outputPath;\n   786→                debugLog('Audio exported to:', audioFilePath);\n   787→            } else if (exportResult && exportResult.error) {\n   788→                throw new Error(exportResult.error);\n   789→            }\n   790→        } catch (exportError) {\n   791→            console.warn('[SPLICE] Audio export failed, trying fallback:', exportError.message);\n   792→            // Try to get audio from first clip in timeline\n   793→            try {\n   794→                const clipInfo = await jsx.call('getFirstClipAudioPath');\n   795→                if (clipInfo && clipInfo.path) {\n   796→                    audioFilePath = clipInfo.path;\n   797→                    debugLog('Using clip audio path:', audioFilePath);\n   798→                }\n   799→            } catch (clipError) {\n   800→                console.warn('[SPLICE] Fallback audio path failed:', clipError.message);\n   801→            }\n   802→        }\n   803→\n   804→        if (!audioFilePath) {\n   805→            throw new Error('Could not export or locate audio file. Please ensure sequence has audio tracks.');\n   806→        }\n   807→\n   808→        // Store audio path globally for other modules\n   809→        currentAudioPath = audioFilePath;\n   810→        window.spliceState.audioPath = audioFilePath;\n   811→\n   812→        // Call backend for silence detection with audio file path\n   813→        updateProgress(30, 'Detecting silences...');\n   814→        const silenceResponse = await fetchWithTimeout(\n   815→            `${getBackendUrl()}/silences-rms`,\n   816→            {\n   817→                method: 'POST',\n   818→                headers: getAuthHeaders(),\n   819→                body: JSON.stringify({\n   820→                    wavPath: audioFilePath,\n   821→                    sensitivity: settings.sensitivity,\n   822→                    minSilenceLength: settings.minSilenceLength || 0.5\n   823→                })\n   824→            }\n   825→        );\n   826→\n   827→        if (!silenceResponse.ok) {\n   828→            throw new Error(await parseErrorResponse(silenceResponse));\n   829→        }\n   830→\n   831→        const silenceData = await silenceResponse.json();\n   832→        previewSilences = silenceData.silences || [];\n   833→\n   834→        // Detect takes if enabled\n   835→        if (settings.enableTakesDetection) {\n   836→            updateProgress(60, 'Detecting takes...');\n   837→            try {\n   838→                const analyzeResponse = await fetchWithTimeout(\n   839→                    `${getBackendUrl()}/analyze`,\n   840→                    {\n   841→                        method: 'POST',\n   842→                        headers: getAuthHeaders(),\n   843→                        body: JSON.stringify({\n   844→                            wavPath: audioFilePath,\n   845→                            detectTakes: true\n   846→                        })\n   847→                    }\n   848→                );\n   849→\n   850→                if (analyzeResponse.ok) {\n   851→                    const analyzeData = await analyzeResponse.json();\n   852→                    previewTakes = analyzeData.takes || [];\n   853→\n   854→                    // Store transcript for captions/music modules\n   855→                    if (analyzeData.transcript) {\n   856→                        currentTranscript = analyzeData.transcript;\n   857→                        window.currentTranscript = analyzeData.transcript;\n   858→                        window.spliceState.lastTranscript = analyzeData.transcript;\n   859→                    }\n   860→                } else {\n   861→                    // Handle specific error codes\n   862→                    const errorMsg = await parseErrorResponse(analyzeResponse);\n   863→                    if (analyzeResponse.status === 402) {\n   864→                        console.warn('[SPLICE] Takes detection skipped: insufficient credits');\n   865→                        setStatus('Takes detection skipped: insufficient credits', true);\n   866→                    } else if (analyzeResponse.status === 401) {\n   867→                        console.warn('[SPLICE] Takes detection skipped: authentication required');\n   868→                    } else {\n   869→                        console.warn('[SPLICE] Takes detection failed:', errorMsg);\n   870→                    }\n   871→                }\n   872→            } catch (e) {\n   873→                console.warn('[SPLICE] Takes detection failed:', e.message);\n   874→            }\n   875→        }\n   876→\n   877→        // Detect profanity if enabled\n   878→        if (settings.enableProfanity) {\n   879→            updateProgress(65, 'Detecting profanity...');\n   880→            try {\n   881→                const profanityResponse = await fetchWithTimeout(\n   882→                    `${getBackendUrl()}/profanity`,\n   883→                    {\n   884→                        method: 'POST',\n   885→                        headers: getAuthHeaders(),\n   886→                        body: JSON.stringify({\n   887→                            wavPath: audioFilePath,\n   888→                            language: settings.profanityLanguage || 'en',\n   889→                            bleepType: settings.bleepType || 'standard'\n   890→                        })\n   891→                    }\n   892→                );\n   893→\n   894→                if (profanityResponse.ok) {\n   895→                    const profanityData = await profanityResponse.json();\n   896→                    // Backend returns 'words' array, not 'instances'\n   897→                    currentProfanity = profanityData.words || profanityData.instances || [];\n   898→                    if (currentProfanity.length > 0) {\n   899→                        debugLog(`Found ${currentProfanity.length} profanity instances`);\n   900→                    }\n   901→                } else {\n   902→                    console.warn('[SPLICE] Profanity detection failed:', await parseErrorResponse(profanityResponse));\n   903→                }\n   904→            } catch (e) {\n   905→                console.warn('[SPLICE] Profanity detection failed:', e.message);\n   906→            }\n   907→        }\n   908→\n   909→        // Detect chapters if enabled\n   910→        if (settings.enableChapters) {\n   911→            updateProgress(80, 'Detecting chapters...');\n   912→            try {\n   913→                const chapterResponse = await fetchWithTimeout(\n   914→                    `${getBackendUrl()}/chapters`,\n   915→                    {\n   916→                        method: 'POST',\n   917→                        headers: getAuthHeaders(),\n   918→                        body: JSON.stringify({\n   919→                            wavPath: audioFilePath,\n   920→                            transcript: currentTranscript,\n   921→                            maxChapters: settings.maxChapters || 10,\n   922→                            minChapterLength: settings.minChapterLength || 60\n   923→                        })\n   924→                    }\n   925→                );\n   926→\n   927→                if (chapterResponse.ok) {\n   928→                    const chapterData = await chapterResponse.json();\n   929→                    currentChapters = chapterData.chapters || [];\n   930→                } else {\n   931→                    const errorMsg = await parseErrorResponse(chapterResponse);\n   932→                    console.warn('[SPLICE] Chapter detection failed:', errorMsg);\n   933→                    // Don't block workflow, just notify user\n   934→                    setStatus('Chapter detection skipped: ' + errorMsg, true);\n   935→                }\n   936→            } catch (e) {\n   937→                console.warn('[SPLICE] Chapter detection failed:', e);\n   938→                setStatus('Chapter detection failed - continuing without chapters', true);\n   939→            }\n   940→        }\n   941→\n   942→        // Detect zoom points if enabled\n   943→        if (settings.enableZoom) {\n   944→            updateProgress(90, 'Detecting zoom points...');\n   945→            try {\n   946→                const zoomResponse = await fetchWithTimeout(\n   947→                    `${getBackendUrl()}/zoom`,\n   948→                    {\n   949→                        method: 'POST',\n   950→                        headers: getAuthHeaders(),\n   951→                        body: JSON.stringify({\n   952→                            wavPath: audioFilePath,\n   953→                            transcript: currentTranscript,\n   954→                            frequency: settings.zoomFrequency || 'medium',\n   955→                            preset: settings.zoomPreset || 'medium',\n   956→                            placement: settings.zoomPlacement || 'sentence_start'\n   957→                        })\n   958→                    }\n   959→                );\n   960→\n   961→                if (zoomResponse.ok) {\n   962→                    const zoomData = await zoomResponse.json();\n   963→                    currentZooms = zoomData.zoomPoints || [];\n   964→                } else {\n   965→                    const errorMsg = await parseErrorResponse(zoomResponse);\n   966→                    console.warn('[SPLICE] Zoom detection failed:', errorMsg);\n   967→                    setStatus('Zoom detection skipped: ' + errorMsg, true);\n   968→                }\n   969→            } catch (e) {\n   970→                console.warn('[SPLICE] Zoom detection failed:', e);\n   971→                setStatus('Zoom detection failed - continuing without zoom points', true);\n   972→            }\n   973→        }\n   974→\n   975→        // Store results\n   976→        lastDetectionResult = {\n   977→            silences: previewSilences,\n   978→            takes: previewTakes,\n   979→            chapters: currentChapters,\n   980→            zooms: currentZooms\n   981→        };\n   982→\n   983→        // Show preview\n   984→        hideProgress();\n   985→        showCombinedPreview();\n   986→        setStatus(`Found ${previewSilences.length} silences, ${previewTakes.length} takes`);\n   987→\n   988→    } catch (error) {\n   989→        console.error('[SPLICE] Detection error:', error);\n   990→        setStatus('Detection failed: ' + error.message, true);\n   991→        hideProgress();\n   992→    } finally {\n   993→        isOperationInProgress = false;\n   994→        ui.goBtn.disabled = false;\n   995→    }\n   996→}\n   997→\n   998→// ============================================================================\n   999→// PROGRESS UI\n  1000→// ============================================================================\n  1001→function showProgress(message) {\n  1002→    if (ui.progressContainer) ui.progressContainer.classList.remove('hidden');\n  1003→    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n  1004→    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n  1005→    updateProgress(0, message);\n  1006→}\n  1007→\n  1008→function updateProgress(percent, message) {\n  1009→    if (ui.progressBar) ui.progressBar.style.width = percent + '%';\n  1010→    if (ui.progressText) ui.progressText.textContent = message || '';\n  1011→}\n  1012→\n  1013→function hideProgress() {\n  1014→    if (ui.progressContainer) ui.progressContainer.classList.add('hidden');\n  1015→}\n  1016→\n  1017→// ============================================================================\n  1018→// COMBINED PREVIEW\n  1019→// ============================================================================\n  1020→function showCombinedPreview() {\n  1021→    if (!ui.combinedPreview) return;\n  1022→\n  1023→    ui.combinedPreview.classList.remove('hidden');\n  1024→    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n  1025→\n  1026→    // Update counts\n  1027→    if (ui.silenceCount) ui.silenceCount.textContent = previewSilences.length;\n  1028→    if (ui.takeCount) ui.takeCount.textContent = previewTakes.length;\n  1029→\n  1030→    // Select all by default\n  1031→    selectedSilenceIndices.clear();\n  1032→    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n  1033→    updateSelectedCount();\n  1034→\n  1035→    // Render preview list\n  1036→    renderPreviewList();\n  1037→\n  1038→    // Show chapter results if available\n  1039→    if (currentChapters.length > 0 && ui.chapterResults) {\n  1040→        ui.chapterResults.classList.remove('hidden');\n  1041→        renderChapterList();\n  1042→    }\n  1043→\n  1044→    // Show zoom results if available\n  1045→    if (currentZooms.length > 0 && ui.zoomResults) {\n  1046→        ui.zoomResults.classList.remove('hidden');\n  1047→    }\n  1048→}\n  1049→\n  1050→function renderPreviewList() {\n  1051→    if (!ui.previewList) return;\n  1052→\n  1053→    const html = [];\n  1054→\n  1055→    // Render silences\n  1056→    previewSilences.forEach((silence, i) => {\n  1057→        const isSelected = selectedSilenceIndices.has(i);\n  1058→        const duration = silence.end - silence.start;\n  1059→        html.push(`\n  1060→            <div class=\"preview-item ${isSelected ? '' : 'excluded'}\" data-index=\"${i}\" data-type=\"silence\">\n  1061→                <input type=\"checkbox\" class=\"preview-item-check\" ${isSelected ? 'checked' : ''}>\n  1062→                <div class=\"preview-item-info\">\n  1063→                    <div class=\"preview-item-time\">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>\n  1064→                    <div class=\"preview-item-duration\">${duration.toFixed(2)}s silence</div>\n  1065→                </div>\n  1066→            </div>\n  1067→        `);\n  1068→    });\n  1069→\n  1070→    // Render takes\n  1071→    previewTakes.forEach((take, i) => {\n  1072→        // SECURITY: Escape take label to prevent XSS\n  1073→        const safeLabel = escapeHtml(take.label || 'Take ' + (take.takeNumber || i + 1));\n  1074→        html.push(`\n  1075→            <div class=\"preview-item take-item\" data-index=\"${i}\" data-type=\"take\">\n  1076→                <div class=\"preview-item-icon\">🎬</div>\n  1077→                <div class=\"preview-item-info\">\n  1078→                    <div class=\"preview-item-time\">${formatTime(take.start)} - ${formatTime(take.end)}</div>\n  1079→                    <div class=\"preview-item-label\">${safeLabel}</div>\n  1080→                </div>\n  1081→            </div>\n  1082→        `);\n  1083→    });\n  1084→\n  1085→    ui.previewList.innerHTML = html.join('');\n  1086→\n  1087→    // Add click handlers\n  1088→    ui.previewList.querySelectorAll('.preview-item').forEach(item => {\n  1089→        item.addEventListener('click', (e) => {\n  1090→            const index = parseInt(item.dataset.index);\n  1091→            const type = item.dataset.type;\n  1092→\n  1093→            if (e.target.classList.contains('preview-item-check')) {\n  1094→                // Checkbox clicked\n  1095→                toggleSilenceSelection(index);\n  1096→            } else {\n  1097→                // Item clicked - seek to time\n  1098→                const data = type === 'silence' ? previewSilences[index] : previewTakes[index];\n  1099→                seekToTime(data.start);\n  1100→            }\n  1101→        });\n  1102→    });\n  1103→}\n  1104→\n  1105→function toggleSilenceSelection(index) {\n  1106→    if (selectedSilenceIndices.has(index)) {\n  1107→        selectedSilenceIndices.delete(index);\n  1108→    } else {\n  1109→        selectedSilenceIndices.add(index);\n  1110→    }\n  1111→    updateSelectedCount();\n  1112→    renderPreviewList();\n  1113→}\n  1114→\n  1115→function updateSelectedCount() {\n  1116→    if (ui.selectedCount) {\n  1117→        ui.selectedCount.textContent = selectedSilenceIndices.size;\n  1118→    }\n  1119→    if (ui.selectAllSilences) {\n  1120→        ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length;\n  1121→    }\n  1122→}\n  1123→\n  1124→async function seekToTime(seconds) {\n  1125→    try {\n  1126→        // Check if there's an active sequence before seeking\n  1127→        if (!app?.project?.activeSequence) {\n  1128→            debugLog('No active sequence to seek in');\n  1129→            return;\n  1130→        }\n  1131→        // Use JSX to set playhead position\n  1132→        // Note: setPlayerPosition expects ticks as a string without quotes around the number value\n  1133→        const ticks = Math.round(seconds * 254016000000);\n  1134→        await jsx.evalScript(`app.project.activeSequence.setPlayerPosition(${ticks})`);\n  1135→    } catch (e) {\n  1136→        console.warn('[SPLICE] Seek failed:', e);\n  1137→    }\n  1138→}\n  1139→\n  1140→// ============================================================================\n  1141→// CHAPTER LIST\n  1142→// ============================================================================\n  1143→function renderChapterList() {\n  1144→    if (!ui.chapterList) return;\n  1145→\n  1146→    const html = currentChapters.map((chapter, i) => {\n  1147→        // SECURITY: Escape chapter title to prevent XSS\n  1148→        const safeTitle = escapeHtml(chapter.title);\n  1149→        return `\n  1150→            <div class=\"chapter-item\" data-index=\"${i}\">\n  1151→                <div class=\"chapter-time\">${formatTime(chapter.startTime)}</div>\n  1152→                <div class=\"chapter-title\">${safeTitle}</div>\n  1153→            </div>\n  1154→        `;\n  1155→    }).join('');\n  1156→\n  1157→    ui.chapterList.innerHTML = html;\n  1158→\n  1159→    // Add click handlers\n  1160→    ui.chapterList.querySelectorAll('.chapter-item').forEach(item => {\n  1161→        item.addEventListener('click', () => {\n  1162→            const index = parseInt(item.dataset.index);\n  1163→            seekToTime(currentChapters[index].startTime);\n  1164→        });\n  1165→    });\n  1166→}\n  1167→\n  1168→// ============================================================================\n  1169→// PREVIEW HANDLERS\n  1170→// ============================================================================\n  1171→function initPreviewHandlers() {\n  1172→    // Select all checkbox\n  1173→    if (ui.selectAllSilences) {\n  1174→        ui.selectAllSilences.addEventListener('change', () => {\n  1175→            if (ui.selectAllSilences.checked) {\n  1176→                previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n  1177→            } else {\n  1178→                selectedSilenceIndices.clear();\n  1179→            }\n  1180→            updateSelectedCount();\n  1181→            renderPreviewList();\n  1182→        });\n  1183→    }\n  1184→\n  1185→    // Apply button\n  1186→    if (ui.applyPreviewBtn) {\n  1187→        ui.applyPreviewBtn.addEventListener('click', applyPreviewAndMarkers);\n  1188→    }\n  1189→\n  1190→    // Cancel button\n  1191→    if (ui.cancelPreviewBtn) {\n  1192→        ui.cancelPreviewBtn.addEventListener('click', hidePreview);\n  1193→    }\n  1194→\n  1195→    // Build sequence button\n  1196→    if (ui.buildSequenceBtn) {\n  1197→        ui.buildSequenceBtn.addEventListener('click', buildSequence);\n  1198→    }\n  1199→\n  1200→    // Copy YouTube timestamps\n  1201→    if (ui.copyYouTubeBtn) {\n  1202→        ui.copyYouTubeBtn.addEventListener('click', copyYouTubeTimestamps);\n  1203→    }\n  1204→\n  1205→    // Add chapter markers\n  1206→    if (ui.addChapterMarkersBtn) {\n  1207→        ui.addChapterMarkersBtn.addEventListener('click', addChapterMarkers);\n  1208→    }\n  1209→\n  1210→    // Apply zoom markers\n  1211→    const applyZoomsBtn = document.getElementById('applyZoomsBtn');\n  1212→    if (applyZoomsBtn) {\n  1213→        applyZoomsBtn.addEventListener('click', applyZoomMarkers);\n  1214→    }\n  1215→}\n  1216→\n  1217→async function applyPreviewAndMarkers() {\n  1218→    if (isOperationInProgress) return;\n  1219→\n  1220→    isOperationInProgress = true;\n  1221→    setStatus('Adding markers...');\n  1222→\n  1223→    try {\n  1224→        // Add silence markers\n  1225→        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n  1226→        for (const silence of selectedSilences) {\n  1227→            await jsx.call('createMarker', silence.start, 'SPLICE: Silence', silence.end - silence.start, null, 1);\n  1228→        }\n  1229→\n  1230→        // Add take markers\n  1231→        for (const take of previewTakes) {\n  1232→            await jsx.call('createMarker', take.start, take.label || `Take ${take.takeNumber}`, take.end - take.start, null, 5);\n  1233→        }\n  1234→\n  1235→        setStatus(`Added ${selectedSilences.length + previewTakes.length} markers`);\n  1236→    } catch (error) {\n  1237→        setStatus('Failed to add markers: ' + error.message, true);\n  1238→    } finally {\n  1239→        isOperationInProgress = false;\n  1240→    }\n  1241→}\n  1242→\n  1243→function hidePreview() {\n  1244→    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n  1245→    if (ui.chapterResults) ui.chapterResults.classList.add('hidden');\n  1246→    if (ui.zoomResults) ui.zoomResults.classList.add('hidden');\n  1247→    if (ui.resultsEmpty) ui.resultsEmpty.classList.remove('hidden');\n  1248→    previewSilences = [];\n  1249→    previewTakes = [];\n  1250→    selectedSilenceIndices.clear();\n  1251→}\n  1252→\n  1253→async function buildSequence() {\n  1254→    if (isOperationInProgress) return;\n  1255→\n  1256→    isOperationInProgress = true;\n  1257→    setStatus('Building sequence...');\n  1258→\n  1259→    try {\n  1260→        const settings = getSettings();\n  1261→\n  1262→        // Ensure we have sequence info\n  1263→        if (!currentSequenceInfo) {\n  1264→            currentSequenceInfo = await jsx.call('getActiveSequence');\n  1265→        }\n  1266→\n  1267→        // Create cut list from selected silences\n  1268→        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n  1269→\n  1270→        // Calculate total duration from sequence info or last silence\n  1271→        let duration = 0;\n  1272→        if (currentSequenceInfo && currentSequenceInfo.duration) {\n  1273→            duration = currentSequenceInfo.duration;\n  1274→        } else if (previewSilences.length > 0) {\n  1275→            const lastSilence = previewSilences[previewSilences.length - 1];\n  1276→            duration = lastSilence.end + 10; // Add buffer\n  1277→        }\n  1278→\n  1279→        // Call backend to generate cut list\n  1280→        const cutListResponse = await fetchWithTimeout(\n  1281→            `${getBackendUrl()}/cut-list`,\n  1282→            {\n  1283→                method: 'POST',\n  1284→                headers: getAuthHeaders(),\n  1285→                body: JSON.stringify({\n  1286→                    sourceName: currentSequenceInfo?.name || 'Untitled Sequence',\n  1287→                    sourcePath: currentSequenceInfo?.treePath || currentSequenceInfo?.name || 'Untitled',\n  1288→                    duration: duration,\n  1289→                    silences: selectedSilences,\n  1290→                    takes: previewTakes,\n  1291→                    enableTakes: settings.enableTakesDetection,\n  1292→                    jCutOffset: settings.enableJCut ? settings.jcutLeadIn : 0,\n  1293→                    lCutOffset: settings.enableJCut ? settings.jcutLeadOut : 0\n  1294→                })\n  1295→            }\n  1296→        );\n  1297→\n  1298→        if (!cutListResponse.ok) {\n  1299→            throw new Error(await parseErrorResponse(cutListResponse));\n  1300→        }\n  1301→\n  1302→        const cutList = await cutListResponse.json();\n  1303→\n  1304→        // Build sequence via JSX\n  1305→        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));\n  1306→\n  1307→        if (result && result.success) {\n  1308→            setStatus(`Built sequence: ${result.sequenceName}`);\n  1309→            hidePreview();\n  1310→        } else {\n  1311→            throw new Error(result?.error || 'Build failed');\n  1312→        }\n  1313→    } catch (error) {\n  1314→        setStatus('Build failed: ' + error.message, true);\n  1315→    } finally {\n  1316→        isOperationInProgress = false;\n  1317→    }\n  1318→}\n  1319→\n  1320→function copyYouTubeTimestamps() {\n  1321→    if (currentChapters.length === 0) return;\n  1322→\n  1323→    const timestamps = currentChapters.map(ch =>\n  1324→        `${formatTime(ch.startTime)} ${ch.title}`\n  1325→    ).join('\\n');\n  1326→\n  1327→    navigator.clipboard.writeText(timestamps).then(() => {\n  1328→        setStatus('Copied YouTube timestamps');\n  1329→    }).catch(() => {\n  1330→        setStatus('Failed to copy', true);\n  1331→    });\n  1332→}\n  1333→\n  1334→async function addChapterMarkers() {\n  1335→    if (isOperationInProgress || currentChapters.length === 0) return;\n  1336→\n  1337→    isOperationInProgress = true;\n  1338→    setStatus('Adding chapter markers...');\n  1339→\n  1340→    try {\n  1341→        for (const chapter of currentChapters) {\n  1342→            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);\n  1343→        }\n  1344→        setStatus(`Added ${currentChapters.length} chapter markers`);\n  1345→    } catch (error) {\n  1346→        setStatus('Failed to add markers: ' + error.message, true);\n  1347→    } finally {\n  1348→        isOperationInProgress = false;\n  1349→    }\n  1350→}\n  1351→\n  1352→/**\n  1353→ * Apply zoom point markers to the timeline\n  1354→ */\n  1355→async function applyZoomMarkers() {\n  1356→    if (isOperationInProgress || currentZooms.length === 0) return;\n  1357→\n  1358→    isOperationInProgress = true;\n  1359→    setStatus('Adding zoom markers...');\n  1360→\n  1361→    try {\n  1362→        for (const zoom of currentZooms) {\n  1363→            // Create a marker for each zoom point with zoom intensity info\n  1364→            const comment = `Zoom ${zoom.intensity || 'medium'} - ${zoom.reason || 'emphasis'}`;\n  1365→            await jsx.call('createMarker', zoom.time, 'SPLICE: Zoom', 0.5, comment, 3);\n  1366→        }\n  1367→        setStatus(`Added ${currentZooms.length} zoom markers`);\n  1368→    } catch (error) {\n  1369→        setStatus('Failed to add zoom markers: ' + error.message, true);\n  1370→    } finally {\n  1371→        isOperationInProgress = false;\n  1372→    }\n  1373→}\n  1374→\n  1375→// ============================================================================\n  1376→// MODALS\n  1377→// ============================================================================\n  1378→function initModals() {\n  1379→    // Settings modal\n  1380→    if (ui.settingsBtn && ui.settingsModal) {\n  1381→        ui.settingsBtn.addEventListener('click', () => {\n  1382→            ui.settingsModal.classList.remove('hidden');\n  1383→            // Sync remember options checkbox with current settings\n  1384→            const rememberOptions = document.getElementById('rememberOptions');\n  1385→            if (rememberOptions) {\n  1386→                rememberOptions.checked = getSettings().rememberOptions;\n  1387→            }\n  1388→        });\n  1389→        console.log('[SPLICE] initModals: Settings button initialized');\n  1390→    } else {\n  1391→        console.error('[SPLICE] initModals: Settings modal FAILED -',\n  1392→            !ui.settingsBtn ? '#settingsBtn missing' : '',\n  1393→            !ui.settingsModal ? '#settingsModal missing' : '');\n  1394→    }\n  1395→\n  1396→    if (ui.closeSettingsBtn && ui.settingsModal) {\n  1397→        ui.closeSettingsBtn.addEventListener('click', () => {\n  1398→            ui.settingsModal.classList.add('hidden');\n  1399→        });\n  1400→    }\n  1401→\n  1402→    // Remember options checkbox\n  1403→    const rememberOptions = document.getElementById('rememberOptions');\n  1404→    if (rememberOptions) {\n  1405→        rememberOptions.addEventListener('change', () => {\n  1406→            saveSettings({ rememberOptions: rememberOptions.checked });\n  1407→            if (rememberOptions.checked) {\n  1408→                setStatus('Options will be remembered');\n  1409→            } else {\n  1410→                setStatus('Options will reset to defaults');\n  1411→            }\n  1412→        });\n  1413→    }\n  1414→\n  1415→    // Credit badge click handler (handles login, retry, and refresh)\n  1416→    if (ui.creditBadge) {\n  1417→        ui.creditBadge.addEventListener('click', () => {\n  1418→            // Use the centralized handler from credits.js\n  1419→            if (typeof handleCreditBadgeClick === 'function') {\n  1420→                handleCreditBadgeClick();\n  1421→            } else {\n  1422→                // Fallback if credits.js not loaded yet\n  1423→                const settings = getSettings();\n  1424→                if (!settings.customerId) {\n  1425→                    showLoginModal();\n  1426→                }\n  1427→            }\n  1428→        });\n  1429→        console.log('[SPLICE] initModals: Credit badge initialized');\n  1430→    } else {\n  1431→        console.error('[SPLICE] initModals: Credit badge FAILED - #creditBadge missing');\n  1432→    }\n  1433→\n  1434→    if (ui.closeLoginBtn && ui.loginModal) {\n  1435→        ui.closeLoginBtn.addEventListener('click', () => {\n  1436→            ui.loginModal.classList.add('hidden');\n  1437→        });\n  1438→    }\n  1439→\n  1440→    // Note: saveLoginBtn handler is registered in initLoginModal() (config.js)\n  1441→    // to avoid duplicate event listeners\n  1442→\n  1443→    // License lookup button\n  1444→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n  1445→    if (lookupLicenseBtn) {\n  1446→        lookupLicenseBtn.addEventListener('click', lookupLicense);\n  1447→    }\n  1448→\n  1449→    // Close modals on backdrop click\n  1450→    document.querySelectorAll('.modal').forEach(modal => {\n  1451→        modal.addEventListener('click', (e) => {\n  1452→            if (e.target === modal) {\n  1453→                modal.classList.add('hidden');\n  1454→            }\n  1455→        });\n  1456→    });\n  1457→\n  1458→    // ACCESSIBILITY: Close modals on Escape key press\n  1459→    document.addEventListener('keydown', (e) => {\n  1460→        if (e.key === 'Escape') {\n  1461→            const openModal = document.querySelector('.modal:not(.hidden)');\n  1462→            if (openModal) {\n  1463→                openModal.classList.add('hidden');\n  1464→                // Announce to screen readers\n  1465→                announceToScreenReader('Dialog closed');\n  1466→            }\n  1467→        }\n  1468→    });\n  1469→}\n  1470→\n  1471→/**\n  1472→ * ACCESSIBILITY: Announce message to screen readers via ARIA live region\n  1473→ * @param {string} message - Message to announce\n  1474→ * @param {string} priority - 'polite' or 'assertive'\n  1475→ */\n  1476→function announceToScreenReader(message, priority = 'polite') {\n  1477→    // Use existing status element or create temporary one\n  1478→    const statusEl = document.getElementById('status');\n  1479→    if (statusEl && priority === 'polite') {\n  1480→        const originalText = statusEl.textContent;\n  1481→        statusEl.textContent = message;\n  1482→        // Restore after announcement\n  1483→        setTimeout(() => {\n  1484→            if (statusEl.textContent === message) {\n  1485→                statusEl.textContent = originalText;\n  1486→            }\n  1487→        }, 1000);\n  1488→        return;\n  1489→    }\n  1490→\n  1491→    // Create temporary live region for assertive announcements\n  1492→    const liveRegion = document.createElement('div');\n  1493→    liveRegion.setAttribute('role', 'alert');\n  1494→    liveRegion.setAttribute('aria-live', priority);\n  1495→    liveRegion.setAttribute('aria-atomic', 'true');\n  1496→    liveRegion.className = 'sr-only';\n  1497→    liveRegion.style.cssText = 'position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0;';\n  1498→    liveRegion.textContent = message;\n  1499→    document.body.appendChild(liveRegion);\n  1500→\n  1501→    // Remove after announcement\n  1502→    setTimeout(() => liveRegion.remove(), 1000);\n  1503→}\n  1504→\n  1505→function showLoginModal() {\n  1506→    if (ui.loginModal) ui.loginModal.classList.remove('hidden');\n  1507→}\n  1508→\n  1509→/**\n  1510→ * Show upgrade modal when user tries to access a gated feature\n  1511→ * @param {string} featureName - Display name of the feature\n  1512→ * @param {string} requiredTier - Required tier (Pro, Team)\n  1513→ */\n  1514→function showUpgradeModal(featureName, requiredTier = 'Pro') {\n  1515→    const modal = document.getElementById('upgradeModal');\n  1516→    const featureText = document.getElementById('upgradeFeatureName');\n  1517→    const tierText = document.getElementById('upgradeRequiredTier');\n  1518→\n  1519→    if (featureText) {\n  1520→        featureText.textContent = featureName;\n  1521→    }\n  1522→    if (tierText) {\n  1523→        tierText.textContent = requiredTier;\n  1524→    }\n  1525→    if (modal) {\n  1526→        modal.classList.remove('hidden');\n  1527→    }\n  1528→}\n  1529→\n  1530→/**\n  1531→ * Close the upgrade modal\n  1532→ */\n  1533→function closeUpgradeModal() {\n  1534→    const modal = document.getElementById('upgradeModal');\n  1535→    if (modal) {\n  1536→        modal.classList.add('hidden');\n  1537→    }\n  1538→}\n  1539→\n  1540→// Expose showUpgradeModal and closeUpgradeModal globally for feature modules\n  1541→window.showUpgradeModal = showUpgradeModal;\n  1542→window.closeUpgradeModal = closeUpgradeModal;\n  1543→\n  1544→async function activateLicense() {\n  1545→    if (!ui.licenseKeyInput) return;\n  1546→\n  1547→    const licenseKey = ui.licenseKeyInput.value.trim();\n  1548→    if (!licenseKey) {\n  1549→        setStatus('Please enter a license key', true);\n  1550→        return;\n  1551→    }\n  1552→\n  1553→    try {\n  1554→        const response = await fetchWithTimeout(\n  1555→            `${getBackendUrl()}/license/activate`,\n  1556→            {\n  1557→                method: 'POST',\n  1558→                headers: { 'Content-Type': 'application/json' },\n  1559→                body: JSON.stringify({ key: licenseKey })\n  1560→            }\n  1561→        );\n  1562→\n  1563→        if (!response.ok) {\n  1564→            throw new Error(await parseErrorResponse(response));\n  1565→        }\n  1566→\n  1567→        const data = await response.json();\n  1568→        saveSettings({\n  1569→            customerId: data.customerId,\n  1570→            licenseKey: licenseKey\n  1571→        });\n  1572→\n  1573→        if (ui.loginModal) ui.loginModal.classList.add('hidden');\n  1574→        setStatus('License activated');\n  1575→        updateCredits();\n  1576→    } catch (error) {\n  1577→        setStatus('Activation failed: ' + error.message, true);\n  1578→    }\n  1579→}\n  1580→\n  1581→/**\n  1582→ * Look up license key by email address\n  1583→ */\n  1584→async function lookupLicense() {\n  1585→    const lookupEmailInput = document.getElementById('lookupEmailInput');\n  1586→    const licenseKeyInput = document.getElementById('licenseKeyInput');\n  1587→\n  1588→    if (!lookupEmailInput) return;\n  1589→\n  1590→    const email = lookupEmailInput.value.trim().toLowerCase();\n  1591→    if (!email) {\n  1592→        setStatus('Please enter your email address', true);\n  1593→        return;\n  1594→    }\n  1595→\n  1596→    // Basic email validation\n  1597→    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  1598→    if (!emailRegex.test(email)) {\n  1599→        setStatus('Please enter a valid email address', true);\n  1600→        return;\n  1601→    }\n  1602→\n  1603→    const lookupBtn = document.getElementById('lookupLicenseBtn');\n  1604→    if (lookupBtn) {\n  1605→        lookupBtn.disabled = true;\n  1606→        lookupBtn.textContent = 'Looking up...';\n  1607→    }\n  1608→\n  1609→    try {\n  1610→        const response = await fetchWithTimeout(\n  1611→            `${getBackendUrl()}/license/lookup`,\n  1612→            {\n  1613→                method: 'POST',\n  1614→                headers: { 'Content-Type': 'application/json' },\n  1615→                body: JSON.stringify({ email })\n  1616→            },\n  1617→            30000\n  1618→        );\n  1619→\n  1620→        const result = await response.json();\n  1621→\n  1622→        // Note: For security, the backend does NOT return the license key directly.\n  1623→        // It sends the key via email to prevent enumeration attacks.\n  1624→        if (result.success) {\n  1625→            setStatus(result.message || 'If a license exists, it has been sent to your email.');\n  1626→        } else {\n  1627→            setStatus(result.error || 'Lookup failed. Please try again.', true);\n  1628→        }\n  1629→    } catch (error) {\n  1630→        setStatus('Lookup failed: ' + error.message, true);\n  1631→    } finally {\n  1632→        if (lookupBtn) {\n  1633→            lookupBtn.disabled = false;\n  1634→            lookupBtn.textContent = 'Lookup';\n  1635→        }\n  1636→    }\n  1637→}\n  1638→\n  1639→// ============================================================================\n  1640→// CREDITS\n  1641→// ============================================================================\n  1642→function initCredits() {\n  1643→    updateCredits();\n  1644→}\n  1645→\n  1646→async function updateCredits() {\n  1647→    if (!ui.creditBadge) return;\n  1648→\n  1649→    const settings = getSettings();\n  1650→    if (!settings.customerId) {\n  1651→        ui.creditBadge.className = 'credit-badge login';\n  1652→        ui.creditBadge.textContent = 'Login';\n  1653→        ui.creditBadge.style.display = 'flex';\n  1654→        return;\n  1655→    }\n  1656→\n  1657→    try {\n  1658→        const response = await fetchWithTimeout(\n  1659→            `${getBackendUrl()}/credits`,\n  1660→            {\n  1661→                method: 'GET',\n  1662→                headers: getAuthHeaders()\n  1663→            }\n  1664→        );\n  1665→\n  1666→        if (response.ok) {\n  1667→            const data = await response.json();\n  1668→            // Backend returns hoursRemaining (not remainingMinutes)\n  1669→            const hours = (data.hoursRemaining || 0).toFixed(1);\n  1670→            ui.creditBadge.textContent = `${hours}h`;\n  1671→            // Low warning when less than 1 hour remaining\n  1672→            ui.creditBadge.className = data.hoursRemaining < 1 ? 'credit-badge low' : 'credit-badge ok';\n  1673→            ui.creditBadge.style.display = 'flex';\n  1674→        } else {\n  1675→            ui.creditBadge.className = 'credit-badge error';\n  1676→            ui.creditBadge.textContent = 'Error';\n  1677→            ui.creditBadge.style.display = 'flex';\n  1678→        }\n  1679→    } catch {\n  1680→        ui.creditBadge.className = 'credit-badge error';\n  1681→        ui.creditBadge.textContent = 'Offline';\n  1682→        ui.creditBadge.style.display = 'flex';\n  1683→    }\n  1684→}\n  1685→\n  1686→// ============================================================================\n  1687→// HELP BUTTON\n  1688→// ============================================================================\n  1689→function initHelpButton() {\n  1690→    const helpBtn = document.getElementById('helpBtn');\n  1691→    if (helpBtn) {\n  1692→        helpBtn.addEventListener('click', () => {\n  1693→            setStatus('Silence: removes quiet gaps | Takes: detects repeated content | Chapters: AI topic segmentation');\n  1694→        });\n  1695→    }\n  1696→}\n  1697→\n  1698→// ============================================================================\n  1699→// DEBUG MODAL\n  1700→// ============================================================================\n  1701→function initDebugModal() {\n  1702→    if (!ui.debugBtn || !ui.debugModal) {\n  1703→        console.error('[SPLICE] initDebugModal FAILED: Missing elements -',\n  1704→            !ui.debugBtn ? '#debugBtn' : '',\n  1705→            !ui.debugModal ? '#debugModal' : '');\n  1706→        return;\n  1707→    }\n  1708→\n  1709→    // Open debug modal\n  1710→    ui.debugBtn.addEventListener('click', () => {\n  1711→        ui.debugModal.classList.remove('hidden');\n  1712→        // Clear previous logs and show placeholder\n  1713→        if (ui.debugLogs) {\n  1714→            ui.debugLogs.innerHTML = '<p class=\"debug-placeholder\">Click \"Run Diagnostics\" to collect diagnostic information.</p>';\n  1715→        }\n  1716→        if (ui.debugQuickDiagnosis) {\n  1717→            ui.debugQuickDiagnosis.textContent = 'Click \"Run Diagnostics\" to check';\n  1718→        }\n  1719→    });\n  1720→\n  1721→    // Close debug modal\n  1722→    if (ui.closeDebugBtn) {\n  1723→        ui.closeDebugBtn.addEventListener('click', () => {\n  1724→            ui.debugModal.classList.add('hidden');\n  1725→        });\n  1726→    }\n  1727→\n  1728→    // Run diagnostics button\n  1729→    if (ui.runDiagnosticsBtn) {\n  1730→        ui.runDiagnosticsBtn.addEventListener('click', async () => {\n  1731→            await runDiagnostics();\n  1732→        });\n  1733→    }\n  1734→\n  1735→    // Copy diagnostics button\n  1736→    if (ui.copyDiagnosticsBtn) {\n  1737→        ui.copyDiagnosticsBtn.addEventListener('click', () => {\n  1738→            copyDiagnosticsToClipboard();\n  1739→        });\n  1740→    }\n  1741→}\n  1742→\n  1743→// ============================================================================\n  1744→// DIAGNOSTICS\n  1745→// ============================================================================\n  1746→let diagnosticLogs = [];\n  1747→\n  1748→async function runDiagnostics() {\n  1749→    if (!ui.debugLogs || !ui.debugQuickDiagnosis) return;\n  1750→\n  1751→    diagnosticLogs = [];\n  1752→    ui.debugLogs.innerHTML = '<p class=\"debug-running\">Running diagnostics... Please wait...</p>';\n  1753→\n  1754→    try {\n  1755→        // Test 0: Check CEP environment\n  1756→        addDiagnosticLog('Test 0: Checking CEP environment...');\n  1757→        if (window.__adobe_cep__) {\n  1758→            addDiagnosticLog('✓ CEP runtime detected (window.__adobe_cep__ exists)');\n  1759→        } else {\n  1760→            addDiagnosticLog('✗ CEP runtime NOT detected - running in browser mode');\n  1761→        }\n  1762→\n  1763→        // Test 0.5: Basic ExtendScript test (doesn't require hostScript.jsx)\n  1764→        addDiagnosticLog('Test 0.5: Testing basic ExtendScript...');\n  1765→        try {\n  1766→            const basicResult = await jsx.evalScript('1 + 1');\n  1767→            addDiagnosticLog('✓ Basic ExtendScript works: 1+1 = ' + basicResult);\n  1768→        } catch (e) {\n  1769→            addDiagnosticLog('✗ Basic ExtendScript FAILED: ' + e.message);\n  1770→            addDiagnosticLog('  → This means Premiere Pro cannot run ANY ExtendScript');\n  1771→            addDiagnosticLog('  → Make sure CEP debug mode is enabled and Premiere was restarted');\n  1772→        }\n  1773→\n  1774→        // Test 0.6: Check if hostScript.jsx functions are loaded\n  1775→        addDiagnosticLog('Test 0.6: Checking if hostScript.jsx is loaded...');\n  1776→        try {\n  1777→            const typeofGetVersion = await jsx.evalScript('typeof getVersion');\n  1778→            if (typeofGetVersion === 'function') {\n  1779→                addDiagnosticLog('✓ hostScript.jsx is loaded (getVersion exists)');\n  1780→            } else {\n  1781→                addDiagnosticLog('✗ hostScript.jsx NOT loaded (getVersion type: ' + typeofGetVersion + ')');\n  1782→                addDiagnosticLog('  → The JSX file may not be in the correct location');\n  1783→            }\n  1784→        } catch (e) {\n  1785→            addDiagnosticLog('✗ hostScript check FAILED: ' + e.message);\n  1786→        }\n  1787→\n  1788→        // Test 1: JSX Connection\n  1789→        addDiagnosticLog('Test 1: Checking JSX connection...');\n  1790→        try {\n  1791→            const version = await jsx.call('getVersion');\n  1792→            addDiagnosticLog('✓ JSX connection OK, version: ' + version);\n  1793→        } catch (e) {\n  1794→            addDiagnosticLog('✗ JSX connection FAILED: ' + e.message);\n  1795→        }\n  1796→\n  1797→        // Test 2: Check for active sequence\n  1798→        addDiagnosticLog('Test 2: Checking for active sequence...');\n  1799→        try {\n  1800→            const hasSequence = await checkSequenceOpen(0, 0); // No retries for diagnostics\n  1801→            addDiagnosticLog('✓ checkSequenceOpen() returned: ' + hasSequence);\n  1802→        } catch (e) {\n  1803→            addDiagnosticLog('✗ checkSequenceOpen() FAILED: ' + e.message);\n  1804→        }\n  1805→\n  1806→        // Test 3: Get sequence info\n  1807→        addDiagnosticLog('Test 3: Getting sequence info...');\n  1808→        try {\n  1809→            const seqInfo = await jsx.call('getActiveSequence');\n  1810→            if (seqInfo && !seqInfo.error) {\n  1811→                addDiagnosticLog('✓ Sequence found: ' + (seqInfo.name || 'Unknown'));\n  1812→                addDiagnosticLog('  - Sequence ID: ' + (seqInfo.sequenceID || 'N/A'));\n  1813→                addDiagnosticLog('  - Duration: ' + (seqInfo.duration || 'N/A'));\n  1814→                addDiagnosticLog('  - Frame size: ' + (seqInfo.frameSizeHorizontal || 'N/A') + 'x' + (seqInfo.frameSizeVertical || 'N/A'));\n  1815→            } else {\n  1816→                addDiagnosticLog('✗ No active sequence found');\n  1817→            }\n  1818→        } catch (e) {\n  1819→            addDiagnosticLog('✗ getActiveSequence() FAILED: ' + e.message);\n  1820→        }\n  1821→\n  1822→        // Test 4: Check project sequences\n  1823→        addDiagnosticLog('Test 4: Checking all project sequences...');\n  1824→        try {\n  1825→            const sequences = await jsx.call('getAllSequences');\n  1826→            if (sequences && sequences.length > 0) {\n  1827→                addDiagnosticLog('✓ Total sequences in project: ' + sequences.length);\n  1828→                sequences.forEach((seq, i) => {\n  1829→                    addDiagnosticLog('  - Sequence ' + i + ': ' + (seq.name || 'Unnamed'));\n  1830→                });\n  1831→            } else {\n  1832→                addDiagnosticLog('✗ No sequences found in project');\n  1833→            }\n  1834→        } catch (e) {\n  1835→            addDiagnosticLog('✗ getAllSequences() FAILED: ' + e.message);\n  1836→        }\n  1837→\n  1838→        // Test 5: Check for active sequence via DOM\n  1839→        addDiagnosticLog('Test 5: Checking app.project.activeSequence...');\n  1840→        try {\n  1841→            const result = await jsx.evalScript(`\n  1842→                (function() {\n  1843→                    try {\n  1844→                        if (app && app.project && app.project.activeSequence) {\n  1845→                            return JSON.stringify({\n  1846→                                success: true,\n  1847→                                name: app.project.activeSequence.name,\n  1848→                                id: app.project.activeSequence.sequenceID\n  1849→                            });\n  1850→                        } else {\n  1851→                            return JSON.stringify({\n  1852→                                success: false,\n  1853→                                reason: app ? (app.project ? 'app.project.activeSequence is null' : 'app.project is null') : 'app is null'\n  1854→                            });\n  1855→                        }\n  1856→                    } catch (e) {\n  1857→                        return JSON.stringify({ success: false, reason: 'Error: ' + e.message });\n  1858→                    }\n  1859→                })()\n  1860→            `);\n  1861→            const data = JSON.parse(result);\n  1862→            if (data.success) {\n  1863→                addDiagnosticLog('✓ app.project.activeSequence found: ' + data.name + ' (ID: ' + data.id + ')');\n  1864→            } else {\n  1865→                addDiagnosticLog('✗ app.project.activeSequence NOT found: ' + data.reason);\n  1866→            }\n  1867→        } catch (e) {\n  1868→            addDiagnosticLog('✗ DOM check FAILED: ' + e.message);\n  1869→        }\n  1870→\n  1871→        // Test 6: Check QE DOM availability\n  1872→        addDiagnosticLog('Test 6: Checking QE DOM availability...');\n  1873→        try {\n  1874→            const qeResult = await jsx.evalScript(`\n  1875→                (function() {\n  1876→                    try {\n  1877→                        if (typeof qe !== 'undefined' && qe !== null) {\n  1878→                            return JSON.stringify({ available: true });\n  1879→                        } else {\n  1880→                            return JSON.stringify({ available: false });\n  1881→                        }\n  1882→                    } catch (e) {\n  1883→                        return JSON.stringify({ available: false, error: e.message });\n  1884→                    }\n  1885→                })()\n  1886→            `);\n  1887→            const qeData = JSON.parse(qeResult);\n  1888→            if (qeData.available) {\n  1889→                addDiagnosticLog('✓ QE DOM is available');\n  1890→            } else {\n  1891→                addDiagnosticLog('✗ QE DOM is NOT available' + (qeData.error ? ': ' + qeData.error : ''));\n  1892→            }\n  1893→        } catch (e) {\n  1894→            addDiagnosticLog('✗ QE DOM check FAILED: ' + e.message);\n  1895→        }\n  1896→\n  1897→        // Display quick diagnosis\n  1898→        updateQuickDiagnosis();\n  1899→\n  1900→        // Display all logs\n  1901→        displayDiagnosticLogs();\n  1902→\n  1903→    } catch (error) {\n  1904→        addDiagnosticLog('DIAGNOSTICS ERROR: ' + error.message);\n  1905→        displayDiagnosticLogs();\n  1906→    }\n  1907→}\n  1908→\n  1909→function addDiagnosticLog(message) {\n  1910→    diagnosticLogs.push(message);\n  1911→    console.log('[SPLICE DEBUG] ' + message);\n  1912→}\n  1913→\n  1914→function displayDiagnosticLogs() {\n  1915→    if (!ui.debugLogs) return;\n  1916→\n  1917→    const html = diagnosticLogs.map(log => {\n  1918→        return `<div class=\"debug-log-entry\">${escapeHtml(log)}</div>`;\n  1919→    }).join('');\n  1920→\n  1921→    ui.debugLogs.innerHTML = html;\n  1922→}\n  1923→\n  1924→function updateQuickDiagnosis() {\n  1925→    if (!ui.debugQuickDiagnosis) return;\n  1926→\n  1927→    const logs = diagnosticLogs.join(' ');\n  1928→    let diagnosis = '';\n  1929→    let solution = '';\n  1930→\n  1931→    // Analyze logs for common issues\n  1932→    if (logs.includes('JSX connection FAILED')) {\n  1933→        diagnosis = '❌ JSX Connection Failed';\n  1934→        solution = 'The panel cannot communicate with Premiere Pro. Try: 1) Close and reopen the panel, 2) Restart Premiere Pro, 3) Check if plugin is properly installed.';\n  1935→    } else if (logs.includes('checkSequenceOpen() returned: false') && logs.includes('No active sequence found')) {\n  1936→        diagnosis = '❌ No Active Sequence';\n  1937→        solution = 'No sequence is active in the Timeline. Double-click a sequence in the Project panel to open it in the Timeline.';\n  1938→    } else if (logs.includes('app.project.activeSequence NOT found') && logs.includes('Sequence found')) {\n  1939→        diagnosis = '❌ Sequence Not Active';\n  1940→        solution = 'A sequence exists but is not the active sequence. Click on the sequence tab in the Timeline to make it active.';\n  1941→    } else if (logs.includes('checkSequenceOpen() returned: true') && logs.includes('app.project.activeSequence found')) {\n  1942→        diagnosis = '✅ Everything Looks Good';\n  1943→        solution = 'The plugin is working correctly. The sequence is detected and active. Try pressing GO again.';\n  1944→    } else if (logs.includes('No sequences found in project')) {\n  1945→        diagnosis = '❌ No Sequences in Project';\n  1946→        solution = 'Create a sequence in Premiere Pro first (File > New > Sequence), then open it in the Timeline.';\n  1947→    } else {\n  1948→        diagnosis = '⚠️ Unknown Issue';\n  1949→        solution = 'Copy the diagnostic logs below and send them to support for further assistance.';\n  1950→    }\n  1951→\n  1952→    ui.debugQuickDiagnosis.innerHTML = `\n  1953→        <div class=\"diagnosis-result\">\n  1954→            <div class=\"diagnosis-title\">${diagnosis}</div>\n  1955→            <div class=\"diagnosis-solution\">${solution}</div>\n  1956→        </div>\n  1957→    `;\n  1958→}\n  1959→\n  1960→function copyDiagnosticsToClipboard() {\n  1961→    const text = diagnosticLogs.join('\\n');\n  1962→    navigator.clipboard.writeText(text).then(() => {\n  1963→        if (ui.copyDiagnosticsBtn) {\n  1964→            ui.copyDiagnosticsBtn.textContent = 'Copied!';\n  1965→            setTimeout(() => {\n  1966→                ui.copyDiagnosticsBtn.textContent = 'Copy to Clipboard';\n  1967→            }, 2000);\n  1968→        }\n  1969→    }).catch(err => {\n  1970→        setStatus('Failed to copy: ' + err.message, true);\n  1971→    });\n  1972→}\n  1973→\n  1974→// Export for debugging\n  1975→window.spliceDebug = {\n  1976→    getState: () => ({\n  1977→        silences: previewSilences,\n  1978→        takes: previewTakes,\n  1979→        chapters: currentChapters,\n  1980→        zooms: currentZooms,\n  1981→        selected: Array.from(selectedSilenceIndices)\n  1982→    }),\n  1983→    jsx,\n  1984→    runDetection\n  1985→};\n  1986→\n\n</system-reminder>\n"}]},"uuid":"9c069539-aadb-4843-8842-46496e8ceda3","timestamp":"2026-01-12T09:17:48.124Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/main.js","content":"/**\n * SPLICE CEP Panel - Main Entry Point\n * v4.0.0 - CEP Migration\n */\n\n// ============================================================================\n// CACHED DOM ELEMENTS\n// ============================================================================\nconst ui = {};\n\nfunction cacheUIElements() {\n    ui.status = document.getElementById('status');\n    ui.goBtn = document.getElementById('goBtn');\n    ui.optionsToggle = document.getElementById('optionsToggle');\n    ui.optionsPanel = document.getElementById('optionsPanel');\n\n    // DIAGNOSTIC: Log critical element status immediately\n    const criticalElements = {\n        'status': ui.status,\n        'goBtn': ui.goBtn,\n        'optionsToggle': ui.optionsToggle,\n        'optionsPanel': ui.optionsPanel\n    };\n    const missingCritical = Object.entries(criticalElements)\n        .filter(([name, el]) => !el)\n        .map(([name]) => name);\n\n    if (missingCritical.length > 0) {\n        console.error('[SPLICE] CRITICAL: Missing UI elements during cache:', missingCritical);\n        console.error('[SPLICE] DOM readyState:', document.readyState);\n    }\n\n    // Sliders and options\n    ui.sensitivitySlider = document.getElementById('sensitivitySlider');\n    ui.sensitivityValue = document.getElementById('sensitivityValue');\n    ui.sourceOriginal = document.getElementById('sourceOriginal');\n    ui.sourceIsolated = document.getElementById('sourceIsolated');\n\n    // Feature toggles\n    ui.enableTakesDetection = document.getElementById('enableTakesDetection');\n    ui.enableJCut = document.getElementById('enableJCut');\n    ui.jcutSettings = document.getElementById('jcutSettings');\n    ui.jcutLeadIn = document.getElementById('jcutLeadIn');\n    ui.jcutLeadInValue = document.getElementById('jcutLeadInValue');\n    ui.jcutLeadOut = document.getElementById('jcutLeadOut');\n    ui.jcutLeadOutValue = document.getElementById('jcutLeadOutValue');\n\n    // Zoom settings\n    ui.enableZoom = document.getElementById('enableZoom');\n    ui.zoomSettings = document.getElementById('zoomSettings');\n    ui.zoomFrequency = document.getElementById('zoomFrequency');\n    ui.zoomPreset = document.getElementById('zoomPreset');\n    ui.zoomPlacement = document.getElementById('zoomPlacement');\n\n    // Chapter settings\n    ui.enableChapters = document.getElementById('enableChapters');\n    ui.chapterSettings = document.getElementById('chapterSettings');\n    ui.maxChapters = document.getElementById('maxChapters');\n    ui.minChapterLength = document.getElementById('minChapterLength');\n\n    // Profanity settings\n    ui.enableProfanity = document.getElementById('enableProfanity');\n    ui.profanitySettings = document.getElementById('profanitySettings');\n\n    // Filler word settings\n    ui.enableFillerDetection = document.getElementById('enableFillerDetection');\n    ui.fillerSettings = document.getElementById('fillerSettings');\n\n    // Progress\n    ui.progressContainer = document.getElementById('progressContainer');\n    ui.progressBar = document.getElementById('progressBar');\n    ui.progressText = document.getElementById('progressText');\n    ui.resultsEmpty = document.getElementById('resultsEmpty');\n\n    // Preview\n    ui.combinedPreview = document.getElementById('combinedPreview');\n    ui.previewList = document.getElementById('previewList');\n    ui.silenceCount = document.getElementById('silenceCount');\n    ui.takeCount = document.getElementById('takeCount');\n    ui.selectedCount = document.getElementById('selectedCount');\n    ui.selectAllSilences = document.getElementById('selectAllSilences');\n    ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');\n    ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');\n    ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');\n\n    // Results\n    ui.zoomResults = document.getElementById('zoomResults');\n    ui.zoomList = document.getElementById('zoomList');\n    ui.chapterResults = document.getElementById('chapterResults');\n    ui.chapterList = document.getElementById('chapterList');\n    ui.copyYouTubeBtn = document.getElementById('copyYouTubeBtn');\n    ui.addChapterMarkersBtn = document.getElementById('addChapterMarkersBtn');\n\n    // Modals\n    ui.settingsBtn = document.getElementById('settingsBtn');\n    ui.settingsModal = document.getElementById('settingsModal');\n    ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');\n    ui.loginModal = document.getElementById('loginModal');\n    ui.closeLoginBtn = document.getElementById('closeLoginBtn');\n    ui.licenseKeyInput = document.getElementById('licenseKeyInput');\n    ui.saveLoginBtn = document.getElementById('saveLoginBtn');\n\n    // Debug modal\n    ui.debugBtn = document.getElementById('debugBtn');\n    ui.debugModal = document.getElementById('debugModal');\n    ui.closeDebugBtn = document.getElementById('closeDebugBtn');\n    ui.debugQuickDiagnosis = document.getElementById('debugQuickDiagnosis');\n    ui.debugLogs = document.getElementById('debugLogs');\n    ui.runDiagnosticsBtn = document.getElementById('runDiagnosticsBtn');\n    ui.copyDiagnosticsBtn = document.getElementById('copyDiagnosticsBtn');\n\n    // Credit badge\n    ui.creditBadge = document.getElementById('creditBadge');\n\n    // Preset selector\n    ui.presetSelector = document.getElementById('presetSelector');\n}\n\n// ============================================================================\n// STATE MANAGEMENT\n// ============================================================================\nlet previewSilences = [];\nlet previewTakes = [];\nlet currentChapters = [];\nlet currentZooms = [];\nlet currentProfanity = [];\nlet selectedSilenceIndices = new Set();\nlet isOperationInProgress = false;\nlet lastDetectionResult = null;\nlet currentAudioPath = null;\nlet currentSequenceInfo = null;\nlet currentTranscript = null;\n\n// Global state for captions/reframe modules\nwindow.spliceState = {\n    lastTranscript: null,\n    currentVideoPath: null,\n    activeSequence: null,\n    audioPath: null\n};\n\n// Also expose transcript globally for music module\nwindow.currentTranscript = null;\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\ndocument.addEventListener('DOMContentLoaded', async () => {\n    // Premium Loading Experience\n    setTimeout(() => {\n        const loader = document.getElementById('loading-overlay');\n        if (loader) loader.classList.add('hidden');\n    }, 800); // Small delay for smooth perception\n    debugLog('Initializing CEP panel...');\n\n    // Debug: Show init started\n    const statusEl = document.getElementById('status');\n    if (statusEl) statusEl.textContent = 'Initializing...';\n\n    // Cache DOM elements\n    cacheUIElements();\n\n    // Load settings\n    loadSettingsToUI();\n\n    // Initialize UI handlers\n    initOptionsToggle();\n    initSliders();\n    initFeatureToggles();\n    initPresetSelector();\n    initGoButton();\n    initPreviewHandlers();\n    initModals();\n    initLoginModal();\n    initCredits();\n    initHelpButton();\n    initDebugModal();\n\n    // Initialize offline detection\n    if (typeof initOfflineDetection === 'function') {\n        initOfflineDetection();\n    }\n\n    // Initialize multitrack UI\n    if (typeof initMultitrackUI === 'function') {\n        initMultitrackUI();\n    }\n\n    // Initialize animated captions UI\n    if (typeof initAnimatedCaptions === 'function') {\n        initAnimatedCaptions();\n    }\n\n    // Initialize text editor UI\n    if (typeof initTextEditor === 'function') {\n        initTextEditor();\n    }\n\n    // Initialize text editor section toggle\n    initTextEditorToggle();\n\n    // Initialize social reframe UI\n    if (typeof initSocialReframe === 'function') {\n        initSocialReframe();\n    }\n\n    // Initialize social reframe section toggle\n    initSocialReframeToggle();\n\n    // Initialize music UI\n    if (typeof initMusicModule === 'function') {\n        initMusicModule();\n    }\n\n    // Initialize music section toggle\n    initMusicToggle();\n\n    // Initialize JSX bridge first, then check connection\n    // This ensures jsx.init() completes before checkJSXConnection() uses it\n    await jsx.init();\n    await checkJSXConnection();\n\n    // Initialize sequence event listeners for real-time state updates\n    initSequenceEventListeners();\n\n    // DIAGNOSTIC: Verify all critical UI elements are properly initialized\n    verifyUIInitialization();\n\n    setStatus('Ready');\n    debugLog('CEP panel initialized');\n});\n\n/**\n * Post-initialization diagnostic to verify all critical UI elements\n * are properly cached and event listeners are attached\n */\nfunction verifyUIInitialization() {\n    const criticalElements = {\n        'goBtn': { el: ui.goBtn, desc: 'GO button (main action)' },\n        'settingsBtn': { el: ui.settingsBtn, desc: 'Settings button' },\n        'debugBtn': { el: ui.debugBtn, desc: 'Debug button' },\n        'creditBadge': { el: ui.creditBadge, desc: 'Credit badge' },\n        'status': { el: ui.status, desc: 'Status bar' },\n        'optionsToggle': { el: ui.optionsToggle, desc: 'Options toggle' },\n        'optionsPanel': { el: ui.optionsPanel, desc: 'Options panel' }\n    };\n\n    const missingElements = [];\n    const presentElements = [];\n\n    Object.entries(criticalElements).forEach(([id, { el, desc }]) => {\n        if (!el) {\n            missingElements.push(`#${id} (${desc})`);\n        } else {\n            presentElements.push(id);\n        }\n    });\n\n    if (missingElements.length > 0) {\n        console.error('[SPLICE] ⚠️ UI INITIALIZATION INCOMPLETE');\n        console.error('[SPLICE] Missing critical elements:', missingElements);\n        console.error('[SPLICE] Panel may not function correctly. Check index.html structure.');\n\n        // Show error in status bar if available\n        const statusEl = document.getElementById('status');\n        if (statusEl) {\n            statusEl.textContent = 'Init error: ' + missingElements.length + ' UI elements missing';\n            statusEl.classList.add('error');\n        }\n    } else {\n        console.log('[SPLICE] ✓ All critical UI elements initialized:', presentElements.join(', '));\n    }\n\n    // Verify GO button has click listener\n    if (ui.goBtn) {\n        const listeners = getEventListeners ? getEventListeners(ui.goBtn) : null;\n        if (!listeners || !listeners.click || listeners.click.length === 0) {\n            // Can't check in production, but log that we tried\n            console.log('[SPLICE] GO button present - click handler should be attached');\n        }\n    }\n}\n\n// ============================================================================\n// SEQUENCE EVENT LISTENERS\n// ============================================================================\n/**\n * Initialize event listeners for sequence state changes\n * This provides real-time updates when sequences are activated/deactivated\n */\nfunction initSequenceEventListeners() {\n    if (!jsx.cs) {\n        console.warn('[SPLICE] Cannot init sequence listeners - CSInterface not available');\n        return;\n    }\n\n    try {\n        // Listen for sequence activation events\n        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceActivated', async (event) => {\n            debugLog('Sequence activated event received');\n            try {\n                const seqInfo = await jsx.call('getActiveSequence');\n                if (seqInfo && !seqInfo.error) {\n                    window.spliceState.activeSequence = seqInfo;\n                    setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));\n                    debugLog('Active sequence updated:', seqInfo.name);\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Failed to get sequence info on activation:', e.message);\n            }\n        });\n\n        // Listen for sequence close/deactivation\n        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceDeactivated', () => {\n            debugLog('Sequence deactivated event');\n            window.spliceState.activeSequence = null;\n            setStatus('No sequence open', true);\n        });\n\n        // Listen for project item selection changes (includes sequences)\n        jsx.cs.addEventListener('com.adobe.csxs.events.SelectionChanged', async () => {\n            // Debounce rapid selection changes\n            if (window._selectionChangeTimeout) {\n                clearTimeout(window._selectionChangeTimeout);\n            }\n            window._selectionChangeTimeout = setTimeout(async () => {\n                try {\n                    const hasSequence = await checkSequenceOpen(0, 0); // Quick check, no retries\n                    if (hasSequence && !window.spliceState.activeSequence) {\n                        const seqInfo = await jsx.call('getActiveSequence');\n                        if (seqInfo && !seqInfo.error) {\n                            window.spliceState.activeSequence = seqInfo;\n                            debugLog('Sequence detected via selection change:', seqInfo.name);\n                        }\n                    }\n                } catch (e) {\n                    // Ignore errors during selection change - it's just for proactive updates\n                }\n            }, 200);\n        });\n\n        debugLog('Sequence event listeners initialized');\n    } catch (e) {\n        console.error('[SPLICE] Failed to init sequence event listeners:', e.message);\n    }\n}\n\n// ============================================================================\n// JSX CONNECTION CHECK\n// ============================================================================\nasync function checkJSXConnection() {\n    try {\n        const result = await jsx.call('getVersion');\n        debugLog('JSX connection OK, version:', result);\n        return true;\n    } catch (e) {\n        console.warn('[SPLICE] JSX connection failed:', e.message);\n        setStatus('Premiere Pro connection failed', true);\n        return false;\n    }\n}\n\n/**\n * Check if a sequence is currently open in the Timeline\n * Enhanced with logging and retry logic\n * @param {number} retries - Number of retry attempts (default: 2)\n * @param {number} delayMs - Delay between retries in ms (default: 300)\n * @returns {Promise<boolean>} true if sequence is open\n */\nasync function checkSequenceOpen(retries = 2, delayMs = 300) {\n    console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC START ==========');\n    console.log('[SPLICE] checkSequenceOpen: retries=' + retries + ', delayMs=' + delayMs);\n    console.log('[SPLICE] checkSequenceOpen: window.spliceState.activeSequence =', window.spliceState.activeSequence);\n    \n    for (let attempt = 0; attempt <= retries; attempt++) {\n        try {\n            console.log('[SPLICE] checkSequenceOpen: Attempt ' + (attempt + 1) + ' of ' + (retries + 1));\n            console.log('[SPLICE] checkSequenceOpen: Calling jsx.call(\"checkSequenceOpen\")...');\n            const result = await jsx.call('checkSequenceOpen');\n            console.log('[SPLICE] checkSequenceOpen: JSX call returned');\n            console.log('[SPLICE] checkSequenceOpen: result =', result, '(type:', typeof result + ')');\n            debugLog('checkSequenceOpen attempt', attempt + 1, 'result:', result, 'type:', typeof result);\n\n            if (result === true || result === 'true') {\n                console.log('[SPLICE] checkSequenceOpen: Returning TRUE - sequence is open');\n                console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n                return true;\n            }\n\n            // If false, wait and retry (sequence might be loading)\n            if (attempt < retries) {\n                console.log('[SPLICE] checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');\n                debugLog('checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');\n                await new Promise(r => setTimeout(r, delayMs));\n            }\n        } catch (error) {\n            console.error('[SPLICE] checkSequenceOpen: Attempt', attempt + 1, 'failed with exception:', error.message);\n            console.error('[SPLICE] checkSequenceOpen: Error stack:', error.stack);\n\n            // On last attempt, return false but log the actual error\n            if (attempt === retries) {\n                console.error('[SPLICE] checkSequenceOpen: All attempts failed. Last error:', error.message);\n                // Store error for diagnostics\n                window.spliceState.lastSequenceCheckError = error.message;\n                console.log('[SPLICE] checkSequenceOpen: Stored error in window.spliceState.lastSequenceCheckError:', error.message);\n                console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC END (ERROR) ==========');\n                return false;\n            }\n\n            // Wait before retry\n            console.log('[SPLICE] checkSequenceOpen: Waiting', delayMs, 'ms before retry...');\n            await new Promise(r => setTimeout(r, delayMs));\n        }\n    }\n    console.log('[SPLICE] checkSequenceOpen: All attempts completed without finding sequence');\n    console.log('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC END (FALSE) ==========');\n    return false;\n}\n\n// ============================================================================\n// OPTIONS TOGGLE\n// ============================================================================\nfunction initOptionsToggle() {\n    debugLog('initOptionsToggle - toggle:', !!ui.optionsToggle, 'panel:', !!ui.optionsPanel);\n    if (ui.optionsToggle && ui.optionsPanel) {\n        ui.optionsToggle.addEventListener('click', () => {\n            debugLog('Options toggle clicked');\n            // Check current state BEFORE toggling\n            const wasCollapsed = ui.optionsPanel.classList.contains('collapsed');\n            ui.optionsPanel.classList.toggle('collapsed');\n            // If it was collapsed, it's now expanded (show 'expanded' class)\n            ui.optionsToggle.classList.toggle('expanded', wasCollapsed);\n            saveSettings({ expandedOptions: wasCollapsed });\n        });\n\n        // Restore state\n        const settings = getSettings();\n        if (!settings.expandedOptions) {\n            ui.optionsPanel.classList.add('collapsed');\n            ui.optionsToggle.classList.remove('expanded');\n        } else {\n            ui.optionsToggle.classList.add('expanded');\n            ui.optionsPanel.classList.remove('collapsed');\n        }\n    }\n}\n\n// ============================================================================\n// TEXT EDITOR TOGGLE\n// ============================================================================\nfunction initTextEditorToggle() {\n    const toggle = document.getElementById('textEditorToggle');\n    const panel = document.getElementById('text-editor-panel');\n    debugLog('initTextEditorToggle - toggle:', !!toggle, 'panel:', !!panel);\n\n    if (toggle && panel) {\n        toggle.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            debugLog('Text Editor toggle clicked');\n            setStatus('Text Editor: ' + (panel.classList.contains('collapsed') ? 'Opening' : 'Closing'));\n            // Check state BEFORE toggling\n            const wasCollapsed = panel.classList.contains('collapsed');\n            panel.classList.toggle('collapsed');\n            const icon = toggle.querySelector('.toggle-icon');\n            debugLog('wasCollapsed:', wasCollapsed, 'icon:', !!icon);\n            if (icon) {\n                // If it was collapsed, it's now expanded (show -)\n                icon.textContent = wasCollapsed ? '-' : '+';\n            }\n        });\n    } else {\n        console.error('[SPLICE] Text Editor toggle elements not found!');\n    }\n}\n\n// ============================================================================\n// SOCIAL REFRAME TOGGLE\n// ============================================================================\nfunction initSocialReframeToggle() {\n    const toggle = document.getElementById('socialReframeToggle');\n    const panel = document.getElementById('social-reframe-panel');\n    debugLog('initSocialReframeToggle - toggle:', !!toggle, 'panel:', !!panel);\n\n    if (toggle && panel) {\n        toggle.addEventListener('click', () => {\n            debugLog('Social Reframe toggle clicked');\n            // Check state BEFORE toggling\n            const wasCollapsed = panel.classList.contains('collapsed');\n            panel.classList.toggle('collapsed');\n            const icon = toggle.querySelector('.toggle-icon');\n            if (icon) {\n                // If it was collapsed, it's now expanded (show -)\n                icon.textContent = wasCollapsed ? '-' : '+';\n            }\n        });\n    } else {\n        console.error('[SPLICE] Social Reframe toggle elements not found!');\n    }\n}\n\n// ============================================================================\n// MUSIC TOGGLE\n// ============================================================================\nfunction initMusicToggle() {\n    const toggle = document.getElementById('musicToggle');\n    const panel = document.getElementById('music-panel');\n    debugLog('initMusicToggle - toggle:', !!toggle, 'panel:', !!panel);\n\n    if (toggle && panel) {\n        toggle.addEventListener('click', () => {\n            debugLog('Music toggle clicked');\n            // Check state BEFORE toggling\n            const wasCollapsed = panel.classList.contains('collapsed');\n            panel.classList.toggle('collapsed');\n            const icon = toggle.querySelector('.toggle-icon');\n            if (icon) {\n                // If it was collapsed, it's now expanded (show -)\n                icon.textContent = wasCollapsed ? '-' : '+';\n            }\n        });\n    } else {\n        console.error('[SPLICE] Music toggle elements not found!');\n    }\n}\n\n// ============================================================================\n// SLIDERS\n// ============================================================================\nfunction initSliders() {\n    // Sensitivity slider\n    if (ui.sensitivitySlider && ui.sensitivityValue) {\n        ui.sensitivitySlider.addEventListener('input', () => {\n            ui.sensitivityValue.textContent = ui.sensitivitySlider.value;\n            saveSettings({ sensitivity: parseInt(ui.sensitivitySlider.value) });\n        });\n    }\n\n    // J-Cut sliders\n    if (ui.jcutLeadIn && ui.jcutLeadInValue) {\n        ui.jcutLeadIn.addEventListener('input', () => {\n            const val = (ui.jcutLeadIn.value / 100).toFixed(2);\n            ui.jcutLeadInValue.textContent = val + 's';\n            saveSettings({ jcutLeadIn: parseFloat(val) });\n        });\n    }\n\n    if (ui.jcutLeadOut && ui.jcutLeadOutValue) {\n        ui.jcutLeadOut.addEventListener('input', () => {\n            const val = (ui.jcutLeadOut.value / 100).toFixed(2);\n            ui.jcutLeadOutValue.textContent = val + 's';\n            saveSettings({ jcutLeadOut: parseFloat(val) });\n        });\n    }\n}\n\n// ============================================================================\n// FEATURE TOGGLES\n// ============================================================================\nfunction initFeatureToggles() {\n    // J-Cut toggle\n    if (ui.enableJCut && ui.jcutSettings) {\n        ui.enableJCut.addEventListener('change', () => {\n            ui.jcutSettings.classList.toggle('collapsed', !ui.enableJCut.checked);\n            saveSettings({ enableJCut: ui.enableJCut.checked });\n        });\n    }\n\n    // Zoom toggle\n    if (ui.enableZoom && ui.zoomSettings) {\n        ui.enableZoom.addEventListener('change', () => {\n            ui.zoomSettings.classList.toggle('collapsed', !ui.enableZoom.checked);\n            saveSettings({ enableZoom: ui.enableZoom.checked });\n        });\n    }\n\n    // Chapters toggle\n    if (ui.enableChapters && ui.chapterSettings) {\n        ui.enableChapters.addEventListener('change', () => {\n            ui.chapterSettings.classList.toggle('collapsed', !ui.enableChapters.checked);\n            saveSettings({ enableChapters: ui.enableChapters.checked });\n        });\n    }\n\n    // Takes detection toggle\n    if (ui.enableTakesDetection) {\n        ui.enableTakesDetection.addEventListener('change', () => {\n            saveSettings({ enableTakesDetection: ui.enableTakesDetection.checked });\n        });\n    }\n\n    // Profanity detection toggle\n    if (ui.enableProfanity && ui.profanitySettings) {\n        ui.enableProfanity.addEventListener('change', () => {\n            ui.profanitySettings.classList.toggle('collapsed', !ui.enableProfanity.checked);\n            saveSettings({ enableProfanity: ui.enableProfanity.checked });\n        });\n    }\n\n    // Filler word detection toggle\n    if (ui.enableFillerDetection && ui.fillerSettings) {\n        ui.enableFillerDetection.addEventListener('change', () => {\n            ui.fillerSettings.classList.toggle('collapsed', !ui.enableFillerDetection.checked);\n            saveSettings({ enableFillerDetection: ui.enableFillerDetection.checked });\n        });\n    }\n}\n\n// ============================================================================\n// PRESET SELECTOR\n// ============================================================================\n// PRESETS is defined in config.js\n\nfunction initPresetSelector() {\n    if (!ui.presetSelector) return;\n\n    ui.presetSelector.addEventListener('change', () => {\n        const presetId = ui.presetSelector.value;\n        applyPreset(presetId);\n    });\n\n    // Load current preset\n    const settings = getSettings();\n    if (settings.activePreset) {\n        ui.presetSelector.value = settings.activePreset;\n    }\n}\n\nfunction applyPreset(presetId) {\n    const preset = PRESETS[presetId];\n    if (!preset) return;\n\n    // Custom preset - keep current settings\n    if (presetId === 'custom' || !preset.settings) {\n        saveSettings({ activePreset: 'custom' });\n        setStatus('Using custom settings');\n        return;\n    }\n\n    const settings = preset.settings;\n\n    // Apply to UI\n    if (ui.sensitivitySlider && settings.sensitivity !== undefined) {\n        ui.sensitivitySlider.value = settings.sensitivity;\n        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n    }\n\n    if (ui.enableJCut) {\n        ui.enableJCut.checked = settings.enableJCut || false;\n        if (ui.jcutSettings) {\n            ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n        }\n    }\n\n    if (settings.jCutLeadIn !== undefined && ui.jcutLeadIn) {\n        ui.jcutLeadIn.value = Math.round(settings.jCutLeadIn * 100);\n        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jCutLeadIn + 's';\n    }\n\n    if (settings.jCutLeadOut !== undefined && ui.jcutLeadOut) {\n        ui.jcutLeadOut.value = Math.round(settings.jCutLeadOut * 100);\n        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jCutLeadOut + 's';\n    }\n\n    // Save merged settings\n    saveSettings({\n        activePreset: presetId,\n        sensitivity: settings.sensitivity,\n        threshold: settings.threshold,\n        minSilenceLength: settings.minSilenceLength,\n        paddingStart: settings.paddingStart,\n        paddingEnd: settings.paddingEnd,\n        enableTakesDetection: settings.enableTakesDetection,\n        enableJCut: settings.enableJCut || false,\n        jcutLeadIn: settings.jCutLeadIn || 0.3,\n        jcutLeadOut: settings.jCutLeadOut || 0.2\n    });\n\n    setStatus(`Applied ${preset.name} preset`);\n}\n\n// ============================================================================\n// LOAD SETTINGS TO UI\n// ============================================================================\nfunction loadSettingsToUI() {\n    const settings = getSettings();\n\n    if (ui.sensitivitySlider) {\n        ui.sensitivitySlider.value = settings.sensitivity;\n        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n    }\n\n    if (ui.enableTakesDetection) ui.enableTakesDetection.checked = settings.enableTakesDetection;\n    if (ui.enableJCut) ui.enableJCut.checked = settings.enableJCut;\n    if (ui.enableZoom) ui.enableZoom.checked = settings.enableZoom;\n    if (ui.enableChapters) ui.enableChapters.checked = settings.enableChapters;\n\n    if (ui.jcutSettings) ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n    if (ui.zoomSettings) ui.zoomSettings.classList.toggle('collapsed', !settings.enableZoom);\n    if (ui.chapterSettings) ui.chapterSettings.classList.toggle('collapsed', !settings.enableChapters);\n\n    if (ui.jcutLeadIn) {\n        ui.jcutLeadIn.value = Math.round(settings.jcutLeadIn * 100);\n        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jcutLeadIn + 's';\n    }\n    if (ui.jcutLeadOut) {\n        ui.jcutLeadOut.value = Math.round(settings.jcutLeadOut * 100);\n        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jcutLeadOut + 's';\n    }\n\n    if (ui.presetSelector && settings.activePreset) {\n        ui.presetSelector.value = settings.activePreset;\n    }\n}\n\n// ============================================================================\n// GO BUTTON - MAIN WORKFLOW\n// ============================================================================\nfunction initGoButton() {\n    if (!ui.goBtn) {\n        console.error('[SPLICE] initGoButton FAILED: #goBtn element not found in DOM');\n        console.error('[SPLICE] Check that index.html contains <button id=\"goBtn\">');\n        return;\n    }\n\n    ui.goBtn.addEventListener('click', async () => {\n        if (isOperationInProgress) return;\n        await runDetection();\n    });\n    console.log('[SPLICE] initGoButton: GO button initialized successfully');\n}\n\nasync function runDetection() {\n    if (isOperationInProgress) return;\n\n    // Check sequence with enhanced error messaging\n    const hasSequence = await checkSequenceOpen();\n    if (!hasSequence) {\n        // Check if there was a communication error vs just no sequence\n        const lastError = window.spliceState.lastSequenceCheckError;\n        if (lastError && (lastError.includes('CEP') || lastError.includes('communication') || lastError.includes('evalScript'))) {\n            setStatus('Premiere Pro connection issue - try reopening panel', true);\n            console.error('[SPLICE] runDetection: JSX communication failure:', lastError);\n        } else {\n            setStatus('Please open a sequence in the Timeline first', true);\n            debugLog('runDetection: No active sequence in Timeline');\n        }\n        // Clear the error for next check\n        window.spliceState.lastSequenceCheckError = null;\n        return;\n    }\n\n    // Check online\n    if (!isOnline()) {\n        setStatus('Offline - Check your connection', true);\n        return;\n    }\n\n    isOperationInProgress = true;\n    ui.goBtn.disabled = true;\n    showProgress('Detecting silences...');\n\n    try {\n        const settings = getSettings();\n\n        // Get sequence info\n        const seqInfo = await jsx.call('getActiveSequence');\n        debugLog('Sequence info:', seqInfo);\n\n        // Store sequence info for later use\n        currentSequenceInfo = seqInfo;\n        window.spliceState.activeSequence = seqInfo;\n        if (seqInfo && seqInfo.videoPath) {\n            window.spliceState.currentVideoPath = seqInfo.videoPath;\n        }\n\n        // Export audio via JSX for silence detection\n        updateProgress(10, 'Exporting audio...');\n\n        let audioFilePath = null;\n        try {\n            // Get sequence info for audio export\n            const exportResult = await jsx.call('exportSequenceAudioForAnalysis');\n            if (exportResult && exportResult.success && exportResult.outputPath) {\n                audioFilePath = exportResult.outputPath;\n                debugLog('Audio exported to:', audioFilePath);\n            } else if (exportResult && exportResult.error) {\n                throw new Error(exportResult.error);\n            }\n        } catch (exportError) {\n            console.warn('[SPLICE] Audio export failed, trying fallback:', exportError.message);\n            // Try to get audio from first clip in timeline\n            try {\n                const clipInfo = await jsx.call('getFirstClipAudioPath');\n                if (clipInfo && clipInfo.path) {\n                    audioFilePath = clipInfo.path;\n                    debugLog('Using clip audio path:', audioFilePath);\n                }\n            } catch (clipError) {\n                console.warn('[SPLICE] Fallback audio path failed:', clipError.message);\n            }\n        }\n\n        if (!audioFilePath) {\n            throw new Error('Could not export or locate audio file. Please ensure sequence has audio tracks.');\n        }\n\n        // Store audio path globally for other modules\n        currentAudioPath = audioFilePath;\n        window.spliceState.audioPath = audioFilePath;\n\n        // Call backend for silence detection with audio file path\n        updateProgress(30, 'Detecting silences...');\n        const silenceResponse = await fetchWithTimeout(\n            `${getBackendUrl()}/silences-rms`,\n            {\n                method: 'POST',\n                headers: getAuthHeaders(),\n                body: JSON.stringify({\n                    wavPath: audioFilePath,\n                    sensitivity: settings.sensitivity,\n                    minSilenceLength: settings.minSilenceLength || 0.5\n                })\n            }\n        );\n\n        if (!silenceResponse.ok) {\n            throw new Error(await parseErrorResponse(silenceResponse));\n        }\n\n        const silenceData = await silenceResponse.json();\n        previewSilences = silenceData.silences || [];\n\n        // Detect takes if enabled\n        if (settings.enableTakesDetection) {\n            updateProgress(60, 'Detecting takes...');\n            try {\n                const analyzeResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/analyze`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            detectTakes: true\n                        })\n                    }\n                );\n\n                if (analyzeResponse.ok) {\n                    const analyzeData = await analyzeResponse.json();\n                    previewTakes = analyzeData.takes || [];\n\n                    // Store transcript for captions/music modules\n                    if (analyzeData.transcript) {\n                        currentTranscript = analyzeData.transcript;\n                        window.currentTranscript = analyzeData.transcript;\n                        window.spliceState.lastTranscript = analyzeData.transcript;\n                    }\n                } else {\n                    // Handle specific error codes\n                    const errorMsg = await parseErrorResponse(analyzeResponse);\n                    if (analyzeResponse.status === 402) {\n                        console.warn('[SPLICE] Takes detection skipped: insufficient credits');\n                        setStatus('Takes detection skipped: insufficient credits', true);\n                    } else if (analyzeResponse.status === 401) {\n                        console.warn('[SPLICE] Takes detection skipped: authentication required');\n                    } else {\n                        console.warn('[SPLICE] Takes detection failed:', errorMsg);\n                    }\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Takes detection failed:', e.message);\n            }\n        }\n\n        // Detect profanity if enabled\n        if (settings.enableProfanity) {\n            updateProgress(65, 'Detecting profanity...');\n            try {\n                const profanityResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/profanity`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            language: settings.profanityLanguage || 'en',\n                            bleepType: settings.bleepType || 'standard'\n                        })\n                    }\n                );\n\n                if (profanityResponse.ok) {\n                    const profanityData = await profanityResponse.json();\n                    // Backend returns 'words' array, not 'instances'\n                    currentProfanity = profanityData.words || profanityData.instances || [];\n                    if (currentProfanity.length > 0) {\n                        debugLog(`Found ${currentProfanity.length} profanity instances`);\n                    }\n                } else {\n                    console.warn('[SPLICE] Profanity detection failed:', await parseErrorResponse(profanityResponse));\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Profanity detection failed:', e.message);\n            }\n        }\n\n        // Detect chapters if enabled\n        if (settings.enableChapters) {\n            updateProgress(80, 'Detecting chapters...');\n            try {\n                const chapterResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/chapters`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            transcript: currentTranscript,\n                            maxChapters: settings.maxChapters || 10,\n                            minChapterLength: settings.minChapterLength || 60\n                        })\n                    }\n                );\n\n                if (chapterResponse.ok) {\n                    const chapterData = await chapterResponse.json();\n                    currentChapters = chapterData.chapters || [];\n                } else {\n                    const errorMsg = await parseErrorResponse(chapterResponse);\n                    console.warn('[SPLICE] Chapter detection failed:', errorMsg);\n                    // Don't block workflow, just notify user\n                    setStatus('Chapter detection skipped: ' + errorMsg, true);\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Chapter detection failed:', e);\n                setStatus('Chapter detection failed - continuing without chapters', true);\n            }\n        }\n\n        // Detect zoom points if enabled\n        if (settings.enableZoom) {\n            updateProgress(90, 'Detecting zoom points...');\n            try {\n                const zoomResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/zoom`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            transcript: currentTranscript,\n                            frequency: settings.zoomFrequency || 'medium',\n                            preset: settings.zoomPreset || 'medium',\n                            placement: settings.zoomPlacement || 'sentence_start'\n                        })\n                    }\n                );\n\n                if (zoomResponse.ok) {\n                    const zoomData = await zoomResponse.json();\n                    currentZooms = zoomData.zoomPoints || [];\n                } else {\n                    const errorMsg = await parseErrorResponse(zoomResponse);\n                    console.warn('[SPLICE] Zoom detection failed:', errorMsg);\n                    setStatus('Zoom detection skipped: ' + errorMsg, true);\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Zoom detection failed:', e);\n                setStatus('Zoom detection failed - continuing without zoom points', true);\n            }\n        }\n\n        // Store results\n        lastDetectionResult = {\n            silences: previewSilences,\n            takes: previewTakes,\n            chapters: currentChapters,\n            zooms: currentZooms\n        };\n\n        // Show preview\n        hideProgress();\n        showCombinedPreview();\n        setStatus(`Found ${previewSilences.length} silences, ${previewTakes.length} takes`);\n\n    } catch (error) {\n        console.error('[SPLICE] Detection error:', error);\n        setStatus('Detection failed: ' + error.message, true);\n        hideProgress();\n    } finally {\n        isOperationInProgress = false;\n        ui.goBtn.disabled = false;\n    }\n}\n\n// ============================================================================\n// PROGRESS UI\n// ============================================================================\nfunction showProgress(message) {\n    if (ui.progressContainer) ui.progressContainer.classList.remove('hidden');\n    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n    updateProgress(0, message);\n}\n\nfunction updateProgress(percent, message) {\n    if (ui.progressBar) ui.progressBar.style.width = percent + '%';\n    if (ui.progressText) ui.progressText.textContent = message || '';\n}\n\nfunction hideProgress() {\n    if (ui.progressContainer) ui.progressContainer.classList.add('hidden');\n}\n\n// ============================================================================\n// COMBINED PREVIEW\n// ============================================================================\nfunction showCombinedPreview() {\n    if (!ui.combinedPreview) return;\n\n    ui.combinedPreview.classList.remove('hidden');\n    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n\n    // Update counts\n    if (ui.silenceCount) ui.silenceCount.textContent = previewSilences.length;\n    if (ui.takeCount) ui.takeCount.textContent = previewTakes.length;\n\n    // Select all by default\n    selectedSilenceIndices.clear();\n    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n    updateSelectedCount();\n\n    // Render preview list\n    renderPreviewList();\n\n    // Show chapter results if available\n    if (currentChapters.length > 0 && ui.chapterResults) {\n        ui.chapterResults.classList.remove('hidden');\n        renderChapterList();\n    }\n\n    // Show zoom results if available\n    if (currentZooms.length > 0 && ui.zoomResults) {\n        ui.zoomResults.classList.remove('hidden');\n    }\n}\n\nfunction renderPreviewList() {\n    if (!ui.previewList) return;\n\n    const html = [];\n\n    // Render silences\n    previewSilences.forEach((silence, i) => {\n        const isSelected = selectedSilenceIndices.has(i);\n        const duration = silence.end - silence.start;\n        html.push(`\n            <div class=\"preview-item ${isSelected ? '' : 'excluded'}\" data-index=\"${i}\" data-type=\"silence\">\n                <input type=\"checkbox\" class=\"preview-item-check\" ${isSelected ? 'checked' : ''}>\n                <div class=\"preview-item-info\">\n                    <div class=\"preview-item-time\">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>\n                    <div class=\"preview-item-duration\">${duration.toFixed(2)}s silence</div>\n                </div>\n            </div>\n        `);\n    });\n\n    // Render takes\n    previewTakes.forEach((take, i) => {\n        // SECURITY: Escape take label to prevent XSS\n        const safeLabel = escapeHtml(take.label || 'Take ' + (take.takeNumber || i + 1));\n        html.push(`\n            <div class=\"preview-item take-item\" data-index=\"${i}\" data-type=\"take\">\n                <div class=\"preview-item-icon\">🎬</div>\n                <div class=\"preview-item-info\">\n                    <div class=\"preview-item-time\">${formatTime(take.start)} - ${formatTime(take.end)}</div>\n                    <div class=\"preview-item-label\">${safeLabel}</div>\n                </div>\n            </div>\n        `);\n    });\n\n    ui.previewList.innerHTML = html.join('');\n\n    // Add click handlers\n    ui.previewList.querySelectorAll('.preview-item').forEach(item => {\n        item.addEventListener('click', (e) => {\n            const index = parseInt(item.dataset.index);\n            const type = item.dataset.type;\n\n            if (e.target.classList.contains('preview-item-check')) {\n                // Checkbox clicked\n                toggleSilenceSelection(index);\n            } else {\n                // Item clicked - seek to time\n                const data = type === 'silence' ? previewSilences[index] : previewTakes[index];\n                seekToTime(data.start);\n            }\n        });\n    });\n}\n\nfunction toggleSilenceSelection(index) {\n    if (selectedSilenceIndices.has(index)) {\n        selectedSilenceIndices.delete(index);\n    } else {\n        selectedSilenceIndices.add(index);\n    }\n    updateSelectedCount();\n    renderPreviewList();\n}\n\nfunction updateSelectedCount() {\n    if (ui.selectedCount) {\n        ui.selectedCount.textContent = selectedSilenceIndices.size;\n    }\n    if (ui.selectAllSilences) {\n        ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length;\n    }\n}\n\nasync function seekToTime(seconds) {\n    try {\n        // Check if there's an active sequence before seeking\n        if (!app?.project?.activeSequence) {\n            debugLog('No active sequence to seek in');\n            return;\n        }\n        // Use JSX to set playhead position\n        // Note: setPlayerPosition expects ticks as a string without quotes around the number value\n        const ticks = Math.round(seconds * 254016000000);\n        await jsx.evalScript(`app.project.activeSequence.setPlayerPosition(${ticks})`);\n    } catch (e) {\n        console.warn('[SPLICE] Seek failed:', e);\n    }\n}\n\n// ============================================================================\n// CHAPTER LIST\n// ============================================================================\nfunction renderChapterList() {\n    if (!ui.chapterList) return;\n\n    const html = currentChapters.map((chapter, i) => {\n        // SECURITY: Escape chapter title to prevent XSS\n        const safeTitle = escapeHtml(chapter.title);\n        return `\n            <div class=\"chapter-item\" data-index=\"${i}\">\n                <div class=\"chapter-time\">${formatTime(chapter.startTime)}</div>\n                <div class=\"chapter-title\">${safeTitle}</div>\n            </div>\n        `;\n    }).join('');\n\n    ui.chapterList.innerHTML = html;\n\n    // Add click handlers\n    ui.chapterList.querySelectorAll('.chapter-item').forEach(item => {\n        item.addEventListener('click', () => {\n            const index = parseInt(item.dataset.index);\n            seekToTime(currentChapters[index].startTime);\n        });\n    });\n}\n\n// ============================================================================\n// PREVIEW HANDLERS\n// ============================================================================\nfunction initPreviewHandlers() {\n    // Select all checkbox\n    if (ui.selectAllSilences) {\n        ui.selectAllSilences.addEventListener('change', () => {\n            if (ui.selectAllSilences.checked) {\n                previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n            } else {\n                selectedSilenceIndices.clear();\n            }\n            updateSelectedCount();\n            renderPreviewList();\n        });\n    }\n\n    // Apply button\n    if (ui.applyPreviewBtn) {\n        ui.applyPreviewBtn.addEventListener('click', applyPreviewAndMarkers);\n    }\n\n    // Cancel button\n    if (ui.cancelPreviewBtn) {\n        ui.cancelPreviewBtn.addEventListener('click', hidePreview);\n    }\n\n    // Build sequence button\n    if (ui.buildSequenceBtn) {\n        ui.buildSequenceBtn.addEventListener('click', buildSequence);\n    }\n\n    // Copy YouTube timestamps\n    if (ui.copyYouTubeBtn) {\n        ui.copyYouTubeBtn.addEventListener('click', copyYouTubeTimestamps);\n    }\n\n    // Add chapter markers\n    if (ui.addChapterMarkersBtn) {\n        ui.addChapterMarkersBtn.addEventListener('click', addChapterMarkers);\n    }\n\n    // Apply zoom markers\n    const applyZoomsBtn = document.getElementById('applyZoomsBtn');\n    if (applyZoomsBtn) {\n        applyZoomsBtn.addEventListener('click', applyZoomMarkers);\n    }\n}\n\nasync function applyPreviewAndMarkers() {\n    if (isOperationInProgress) return;\n\n    isOperationInProgress = true;\n    setStatus('Adding markers...');\n\n    try {\n        // Add silence markers\n        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n        for (const silence of selectedSilences) {\n            await jsx.call('createMarker', silence.start, 'SPLICE: Silence', silence.end - silence.start, null, 1);\n        }\n\n        // Add take markers\n        for (const take of previewTakes) {\n            await jsx.call('createMarker', take.start, take.label || `Take ${take.takeNumber}`, take.end - take.start, null, 5);\n        }\n\n        setStatus(`Added ${selectedSilences.length + previewTakes.length} markers`);\n    } catch (error) {\n        setStatus('Failed to add markers: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\nfunction hidePreview() {\n    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n    if (ui.chapterResults) ui.chapterResults.classList.add('hidden');\n    if (ui.zoomResults) ui.zoomResults.classList.add('hidden');\n    if (ui.resultsEmpty) ui.resultsEmpty.classList.remove('hidden');\n    previewSilences = [];\n    previewTakes = [];\n    selectedSilenceIndices.clear();\n}\n\nasync function buildSequence() {\n    if (isOperationInProgress) return;\n\n    isOperationInProgress = true;\n    setStatus('Building sequence...');\n\n    try {\n        const settings = getSettings();\n\n        // Ensure we have sequence info\n        if (!currentSequenceInfo) {\n            currentSequenceInfo = await jsx.call('getActiveSequence');\n        }\n\n        // Create cut list from selected silences\n        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n\n        // Calculate total duration from sequence info or last silence\n        let duration = 0;\n        if (currentSequenceInfo && currentSequenceInfo.duration) {\n            duration = currentSequenceInfo.duration;\n        } else if (previewSilences.length > 0) {\n            const lastSilence = previewSilences[previewSilences.length - 1];\n            duration = lastSilence.end + 10; // Add buffer\n        }\n\n        // Call backend to generate cut list\n        const cutListResponse = await fetchWithTimeout(\n            `${getBackendUrl()}/cut-list`,\n            {\n                method: 'POST',\n                headers: getAuthHeaders(),\n                body: JSON.stringify({\n                    sourceName: currentSequenceInfo?.name || 'Untitled Sequence',\n                    sourcePath: currentSequenceInfo?.treePath || currentSequenceInfo?.name || 'Untitled',\n                    duration: duration,\n                    silences: selectedSilences,\n                    takes: previewTakes,\n                    enableTakes: settings.enableTakesDetection,\n                    jCutOffset: settings.enableJCut ? settings.jcutLeadIn : 0,\n                    lCutOffset: settings.enableJCut ? settings.jcutLeadOut : 0\n                })\n            }\n        );\n\n        if (!cutListResponse.ok) {\n            throw new Error(await parseErrorResponse(cutListResponse));\n        }\n\n        const cutList = await cutListResponse.json();\n\n        // Build sequence via JSX\n        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));\n\n        if (result && result.success) {\n            setStatus(`Built sequence: ${result.sequenceName}`);\n            hidePreview();\n        } else {\n            throw new Error(result?.error || 'Build failed');\n        }\n    } catch (error) {\n        setStatus('Build failed: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\nfunction copyYouTubeTimestamps() {\n    if (currentChapters.length === 0) return;\n\n    const timestamps = currentChapters.map(ch =>\n        `${formatTime(ch.startTime)} ${ch.title}`\n    ).join('\\n');\n\n    navigator.clipboard.writeText(timestamps).then(() => {\n        setStatus('Copied YouTube timestamps');\n    }).catch(() => {\n        setStatus('Failed to copy', true);\n    });\n}\n\nasync function addChapterMarkers() {\n    if (isOperationInProgress || currentChapters.length === 0) return;\n\n    isOperationInProgress = true;\n    setStatus('Adding chapter markers...');\n\n    try {\n        for (const chapter of currentChapters) {\n            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);\n        }\n        setStatus(`Added ${currentChapters.length} chapter markers`);\n    } catch (error) {\n        setStatus('Failed to add markers: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\n/**\n * Apply zoom point markers to the timeline\n */\nasync function applyZoomMarkers() {\n    if (isOperationInProgress || currentZooms.length === 0) return;\n\n    isOperationInProgress = true;\n    setStatus('Adding zoom markers...');\n\n    try {\n        for (const zoom of currentZooms) {\n            // Create a marker for each zoom point with zoom intensity info\n            const comment = `Zoom ${zoom.intensity || 'medium'} - ${zoom.reason || 'emphasis'}`;\n            await jsx.call('createMarker', zoom.time, 'SPLICE: Zoom', 0.5, comment, 3);\n        }\n        setStatus(`Added ${currentZooms.length} zoom markers`);\n    } catch (error) {\n        setStatus('Failed to add zoom markers: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\n// ============================================================================\n// MODALS\n// ============================================================================\nfunction initModals() {\n    // Settings modal\n    if (ui.settingsBtn && ui.settingsModal) {\n        ui.settingsBtn.addEventListener('click', () => {\n            ui.settingsModal.classList.remove('hidden');\n            // Sync remember options checkbox with current settings\n            const rememberOptions = document.getElementById('rememberOptions');\n            if (rememberOptions) {\n                rememberOptions.checked = getSettings().rememberOptions;\n            }\n        });\n        console.log('[SPLICE] initModals: Settings button initialized');\n    } else {\n        console.error('[SPLICE] initModals: Settings modal FAILED -',\n            !ui.settingsBtn ? '#settingsBtn missing' : '',\n            !ui.settingsModal ? '#settingsModal missing' : '');\n    }\n\n    if (ui.closeSettingsBtn && ui.settingsModal) {\n        ui.closeSettingsBtn.addEventListener('click', () => {\n            ui.settingsModal.classList.add('hidden');\n        });\n    }\n\n    // Remember options checkbox\n    const rememberOptions = document.getElementById('rememberOptions');\n    if (rememberOptions) {\n        rememberOptions.addEventListener('change', () => {\n            saveSettings({ rememberOptions: rememberOptions.checked });\n            if (rememberOptions.checked) {\n                setStatus('Options will be remembered');\n            } else {\n                setStatus('Options will reset to defaults');\n            }\n        });\n    }\n\n    // Credit badge click handler (handles login, retry, and refresh)\n    if (ui.creditBadge) {\n        ui.creditBadge.addEventListener('click', () => {\n            // Use the centralized handler from credits.js\n            if (typeof handleCreditBadgeClick === 'function') {\n                handleCreditBadgeClick();\n            } else {\n                // Fallback if credits.js not loaded yet\n                const settings = getSettings();\n                if (!settings.customerId) {\n                    showLoginModal();\n                }\n            }\n        });\n        console.log('[SPLICE] initModals: Credit badge initialized');\n    } else {\n        console.error('[SPLICE] initModals: Credit badge FAILED - #creditBadge missing');\n    }\n\n    if (ui.closeLoginBtn && ui.loginModal) {\n        ui.closeLoginBtn.addEventListener('click', () => {\n            ui.loginModal.classList.add('hidden');\n        });\n    }\n\n    // Note: saveLoginBtn handler is registered in initLoginModal() (config.js)\n    // to avoid duplicate event listeners\n\n    // License lookup button\n    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n    if (lookupLicenseBtn) {\n        lookupLicenseBtn.addEventListener('click', lookupLicense);\n    }\n\n    // Close modals on backdrop click\n    document.querySelectorAll('.modal').forEach(modal => {\n        modal.addEventListener('click', (e) => {\n            if (e.target === modal) {\n                modal.classList.add('hidden');\n            }\n        });\n    });\n\n    // ACCESSIBILITY: Close modals on Escape key press\n    document.addEventListener('keydown', (e) => {\n        if (e.key === 'Escape') {\n            const openModal = document.querySelector('.modal:not(.hidden)');\n            if (openModal) {\n                openModal.classList.add('hidden');\n                // Announce to screen readers\n                announceToScreenReader('Dialog closed');\n            }\n        }\n    });\n}\n\n/**\n * ACCESSIBILITY: Announce message to screen readers via ARIA live region\n * @param {string} message - Message to announce\n * @param {string} priority - 'polite' or 'assertive'\n */\nfunction announceToScreenReader(message, priority = 'polite') {\n    // Use existing status element or create temporary one\n    const statusEl = document.getElementById('status');\n    if (statusEl && priority === 'polite') {\n        const originalText = statusEl.textContent;\n        statusEl.textContent = message;\n        // Restore after announcement\n        setTimeout(() => {\n            if (statusEl.textContent === message) {\n                statusEl.textContent = originalText;\n            }\n        }, 1000);\n        return;\n    }\n\n    // Create temporary live region for assertive announcements\n    const liveRegion = document.createElement('div');\n    liveRegion.setAttribute('role', 'alert');\n    liveRegion.setAttribute('aria-live', priority);\n    liveRegion.setAttribute('aria-atomic', 'true');\n    liveRegion.className = 'sr-only';\n    liveRegion.style.cssText = 'position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0;';\n    liveRegion.textContent = message;\n    document.body.appendChild(liveRegion);\n\n    // Remove after announcement\n    setTimeout(() => liveRegion.remove(), 1000);\n}\n\nfunction showLoginModal() {\n    if (ui.loginModal) ui.loginModal.classList.remove('hidden');\n}\n\n/**\n * Show upgrade modal when user tries to access a gated feature\n * @param {string} featureName - Display name of the feature\n * @param {string} requiredTier - Required tier (Pro, Team)\n */\nfunction showUpgradeModal(featureName, requiredTier = 'Pro') {\n    const modal = document.getElementById('upgradeModal');\n    const featureText = document.getElementById('upgradeFeatureName');\n    const tierText = document.getElementById('upgradeRequiredTier');\n\n    if (featureText) {\n        featureText.textContent = featureName;\n    }\n    if (tierText) {\n        tierText.textContent = requiredTier;\n    }\n    if (modal) {\n        modal.classList.remove('hidden');\n    }\n}\n\n/**\n * Close the upgrade modal\n */\nfunction closeUpgradeModal() {\n    const modal = document.getElementById('upgradeModal');\n    if (modal) {\n        modal.classList.add('hidden');\n    }\n}\n\n// Expose showUpgradeModal and closeUpgradeModal globally for feature modules\nwindow.showUpgradeModal = showUpgradeModal;\nwindow.closeUpgradeModal = closeUpgradeModal;\n\nasync function activateLicense() {\n    if (!ui.licenseKeyInput) return;\n\n    const licenseKey = ui.licenseKeyInput.value.trim();\n    if (!licenseKey) {\n        setStatus('Please enter a license key', true);\n        return;\n    }\n\n    try {\n        const response = await fetchWithTimeout(\n            `${getBackendUrl()}/license/activate`,\n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ key: licenseKey })\n            }\n        );\n\n        if (!response.ok) {\n            throw new Error(await parseErrorResponse(response));\n        }\n\n        const data = await response.json();\n        saveSettings({\n            customerId: data.customerId,\n            licenseKey: licenseKey\n        });\n\n        if (ui.loginModal) ui.loginModal.classList.add('hidden');\n        setStatus('License activated');\n        updateCredits();\n    } catch (error) {\n        setStatus('Activation failed: ' + error.message, true);\n    }\n}\n\n/**\n * Look up license key by email address\n */\nasync function lookupLicense() {\n    const lookupEmailInput = document.getElementById('lookupEmailInput');\n    const licenseKeyInput = document.getElementById('licenseKeyInput');\n\n    if (!lookupEmailInput) return;\n\n    const email = lookupEmailInput.value.trim().toLowerCase();\n    if (!email) {\n        setStatus('Please enter your email address', true);\n        return;\n    }\n\n    // Basic email validation\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n        setStatus('Please enter a valid email address', true);\n        return;\n    }\n\n    const lookupBtn = document.getElementById('lookupLicenseBtn');\n    if (lookupBtn) {\n        lookupBtn.disabled = true;\n        lookupBtn.textContent = 'Looking up...';\n    }\n\n    try {\n        const response = await fetchWithTimeout(\n            `${getBackendUrl()}/license/lookup`,\n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ email })\n            },\n            30000\n        );\n\n        const result = await response.json();\n\n        // Note: For security, the backend does NOT return the license key directly.\n        // It sends the key via email to prevent enumeration attacks.\n        if (result.success) {\n            setStatus(result.message || 'If a license exists, it has been sent to your email.');\n        } else {\n            setStatus(result.error || 'Lookup failed. Please try again.', true);\n        }\n    } catch (error) {\n        setStatus('Lookup failed: ' + error.message, true);\n    } finally {\n        if (lookupBtn) {\n            lookupBtn.disabled = false;\n            lookupBtn.textContent = 'Lookup';\n        }\n    }\n}\n\n// ============================================================================\n// CREDITS\n// ============================================================================\nfunction initCredits() {\n    updateCredits();\n}\n\nasync function updateCredits() {\n    if (!ui.creditBadge) return;\n\n    const settings = getSettings();\n    if (!settings.customerId) {\n        ui.creditBadge.className = 'credit-badge login';\n        ui.creditBadge.textContent = 'Login';\n        ui.creditBadge.style.display = 'flex';\n        return;\n    }\n\n    try {\n        const response = await fetchWithTimeout(\n            `${getBackendUrl()}/credits`,\n            {\n                method: 'GET',\n                headers: getAuthHeaders()\n            }\n        );\n\n        if (response.ok) {\n            const data = await response.json();\n            // Backend returns hoursRemaining (not remainingMinutes)\n            const hours = (data.hoursRemaining || 0).toFixed(1);\n            ui.creditBadge.textContent = `${hours}h`;\n            // Low warning when less than 1 hour remaining\n            ui.creditBadge.className = data.hoursRemaining < 1 ? 'credit-badge low' : 'credit-badge ok';\n            ui.creditBadge.style.display = 'flex';\n        } else {\n            ui.creditBadge.className = 'credit-badge error';\n            ui.creditBadge.textContent = 'Error';\n            ui.creditBadge.style.display = 'flex';\n        }\n    } catch {\n        ui.creditBadge.className = 'credit-badge error';\n        ui.creditBadge.textContent = 'Offline';\n        ui.creditBadge.style.display = 'flex';\n    }\n}\n\n// ============================================================================\n// HELP BUTTON\n// ============================================================================\nfunction initHelpButton() {\n    const helpBtn = document.getElementById('helpBtn');\n    if (helpBtn) {\n        helpBtn.addEventListener('click', () => {\n            setStatus('Silence: removes quiet gaps | Takes: detects repeated content | Chapters: AI topic segmentation');\n        });\n    }\n}\n\n// ============================================================================\n// DEBUG MODAL\n// ============================================================================\nfunction initDebugModal() {\n    if (!ui.debugBtn || !ui.debugModal) {\n        console.error('[SPLICE] initDebugModal FAILED: Missing elements -',\n            !ui.debugBtn ? '#debugBtn' : '',\n            !ui.debugModal ? '#debugModal' : '');\n        return;\n    }\n\n    // Open debug modal\n    ui.debugBtn.addEventListener('click', () => {\n        ui.debugModal.classList.remove('hidden');\n        // Clear previous logs and show placeholder\n        if (ui.debugLogs) {\n            ui.debugLogs.innerHTML = '<p class=\"debug-placeholder\">Click \"Run Diagnostics\" to collect diagnostic information.</p>';\n        }\n        if (ui.debugQuickDiagnosis) {\n            ui.debugQuickDiagnosis.textContent = 'Click \"Run Diagnostics\" to check';\n        }\n    });\n\n    // Close debug modal\n    if (ui.closeDebugBtn) {\n        ui.closeDebugBtn.addEventListener('click', () => {\n            ui.debugModal.classList.add('hidden');\n        });\n    }\n\n    // Run diagnostics button\n    if (ui.runDiagnosticsBtn) {\n        ui.runDiagnosticsBtn.addEventListener('click', async () => {\n            await runDiagnostics();\n        });\n    }\n\n    // Copy diagnostics button\n    if (ui.copyDiagnosticsBtn) {\n        ui.copyDiagnosticsBtn.addEventListener('click', () => {\n            copyDiagnosticsToClipboard();\n        });\n    }\n}\n\n// ============================================================================\n// DIAGNOSTICS\n// ============================================================================\nlet diagnosticLogs = [];\n\nasync function runDiagnostics() {\n    if (!ui.debugLogs || !ui.debugQuickDiagnosis) return;\n\n    diagnosticLogs = [];\n    ui.debugLogs.innerHTML = '<p class=\"debug-running\">Running diagnostics... Please wait...</p>';\n\n    try {\n        // Test 0: Check CEP environment\n        addDiagnosticLog('Test 0: Checking CEP environment...');\n        if (window.__adobe_cep__) {\n            addDiagnosticLog('✓ CEP runtime detected (window.__adobe_cep__ exists)');\n        } else {\n            addDiagnosticLog('✗ CEP runtime NOT detected - running in browser mode');\n        }\n\n        // Test 0.5: Basic ExtendScript test (doesn't require hostScript.jsx)\n        addDiagnosticLog('Test 0.5: Testing basic ExtendScript...');\n        try {\n            const basicResult = await jsx.evalScript('1 + 1');\n            addDiagnosticLog('✓ Basic ExtendScript works: 1+1 = ' + basicResult);\n        } catch (e) {\n            addDiagnosticLog('✗ Basic ExtendScript FAILED: ' + e.message);\n            addDiagnosticLog('  → This means Premiere Pro cannot run ANY ExtendScript');\n            addDiagnosticLog('  → Make sure CEP debug mode is enabled and Premiere was restarted');\n        }\n\n        // Test 0.6: Check if hostScript.jsx functions are loaded\n        addDiagnosticLog('Test 0.6: Checking if hostScript.jsx is loaded...');\n        try {\n            const typeofGetVersion = await jsx.evalScript('typeof getVersion');\n            if (typeofGetVersion === 'function') {\n                addDiagnosticLog('✓ hostScript.jsx is loaded (getVersion exists)');\n            } else {\n                addDiagnosticLog('✗ hostScript.jsx NOT loaded (getVersion type: ' + typeofGetVersion + ')');\n                addDiagnosticLog('  → The JSX file may not be in the correct location');\n            }\n        } catch (e) {\n            addDiagnosticLog('✗ hostScript check FAILED: ' + e.message);\n        }\n\n        // Test 1: JSX Connection\n        addDiagnosticLog('Test 1: Checking JSX connection...');\n        try {\n            const version = await jsx.call('getVersion');\n            addDiagnosticLog('✓ JSX connection OK, version: ' + version);\n        } catch (e) {\n            addDiagnosticLog('✗ JSX connection FAILED: ' + e.message);\n        }\n\n        // Test 2: Check for active sequence\n        addDiagnosticLog('Test 2: Checking for active sequence...');\n        try {\n            const hasSequence = await checkSequenceOpen(0, 0); // No retries for diagnostics\n            addDiagnosticLog('✓ checkSequenceOpen() returned: ' + hasSequence);\n        } catch (e) {\n            addDiagnosticLog('✗ checkSequenceOpen() FAILED: ' + e.message);\n        }\n\n        // Test 3: Get sequence info\n        addDiagnosticLog('Test 3: Getting sequence info...');\n        try {\n            const seqInfo = await jsx.call('getActiveSequence');\n            if (seqInfo && !seqInfo.error) {\n                addDiagnosticLog('✓ Sequence found: ' + (seqInfo.name || 'Unknown'));\n                addDiagnosticLog('  - Sequence ID: ' + (seqInfo.sequenceID || 'N/A'));\n                addDiagnosticLog('  - Duration: ' + (seqInfo.duration || 'N/A'));\n                addDiagnosticLog('  - Frame size: ' + (seqInfo.frameSizeHorizontal || 'N/A') + 'x' + (seqInfo.frameSizeVertical || 'N/A'));\n            } else {\n                addDiagnosticLog('✗ No active sequence found');\n            }\n        } catch (e) {\n            addDiagnosticLog('✗ getActiveSequence() FAILED: ' + e.message);\n        }\n\n        // Test 4: Check project sequences\n        addDiagnosticLog('Test 4: Checking all project sequences...');\n        try {\n            const sequences = await jsx.call('getAllSequences');\n            if (sequences && sequences.length > 0) {\n                addDiagnosticLog('✓ Total sequences in project: ' + sequences.length);\n                sequences.forEach((seq, i) => {\n                    addDiagnosticLog('  - Sequence ' + i + ': ' + (seq.name || 'Unnamed'));\n                });\n            } else {\n                addDiagnosticLog('✗ No sequences found in project');\n            }\n        } catch (e) {\n            addDiagnosticLog('✗ getAllSequences() FAILED: ' + e.message);\n        }\n\n        // Test 5: Check for active sequence via DOM\n        addDiagnosticLog('Test 5: Checking app.project.activeSequence...');\n        try {\n            const result = await jsx.evalScript(`\n                (function() {\n                    try {\n                        if (app && app.project && app.project.activeSequence) {\n                            return JSON.stringify({\n                                success: true,\n                                name: app.project.activeSequence.name,\n                                id: app.project.activeSequence.sequenceID\n                            });\n                        } else {\n                            return JSON.stringify({\n                                success: false,\n                                reason: app ? (app.project ? 'app.project.activeSequence is null' : 'app.project is null') : 'app is null'\n                            });\n                        }\n                    } catch (e) {\n                        return JSON.stringify({ success: false, reason: 'Error: ' + e.message });\n                    }\n                })()\n            `);\n            const data = JSON.parse(result);\n            if (data.success) {\n                addDiagnosticLog('✓ app.project.activeSequence found: ' + data.name + ' (ID: ' + data.id + ')');\n            } else {\n                addDiagnosticLog('✗ app.project.activeSequence NOT found: ' + data.reason);\n            }\n        } catch (e) {\n            addDiagnosticLog('✗ DOM check FAILED: ' + e.message);\n        }\n\n        // Test 6: Check QE DOM availability\n        addDiagnosticLog('Test 6: Checking QE DOM availability...');\n        try {\n            const qeResult = await jsx.evalScript(`\n                (function() {\n                    try {\n                        if (typeof qe !== 'undefined' && qe !== null) {\n                            return JSON.stringify({ available: true });\n                        } else {\n                            return JSON.stringify({ available: false });\n                        }\n                    } catch (e) {\n                        return JSON.stringify({ available: false, error: e.message });\n                    }\n                })()\n            `);\n            const qeData = JSON.parse(qeResult);\n            if (qeData.available) {\n                addDiagnosticLog('✓ QE DOM is available');\n            } else {\n                addDiagnosticLog('✗ QE DOM is NOT available' + (qeData.error ? ': ' + qeData.error : ''));\n            }\n        } catch (e) {\n            addDiagnosticLog('✗ QE DOM check FAILED: ' + e.message);\n        }\n\n        // Display quick diagnosis\n        updateQuickDiagnosis();\n\n        // Display all logs\n        displayDiagnosticLogs();\n\n    } catch (error) {\n        addDiagnosticLog('DIAGNOSTICS ERROR: ' + error.message);\n        displayDiagnosticLogs();\n    }\n}\n\nfunction addDiagnosticLog(message) {\n    diagnosticLogs.push(message);\n    console.log('[SPLICE DEBUG] ' + message);\n}\n\nfunction displayDiagnosticLogs() {\n    if (!ui.debugLogs) return;\n\n    const html = diagnosticLogs.map(log => {\n        return `<div class=\"debug-log-entry\">${escapeHtml(log)}</div>`;\n    }).join('');\n\n    ui.debugLogs.innerHTML = html;\n}\n\nfunction updateQuickDiagnosis() {\n    if (!ui.debugQuickDiagnosis) return;\n\n    const logs = diagnosticLogs.join(' ');\n    let diagnosis = '';\n    let solution = '';\n\n    // Analyze logs for common issues\n    if (logs.includes('JSX connection FAILED')) {\n        diagnosis = '❌ JSX Connection Failed';\n        solution = 'The panel cannot communicate with Premiere Pro. Try: 1) Close and reopen the panel, 2) Restart Premiere Pro, 3) Check if plugin is properly installed.';\n    } else if (logs.includes('checkSequenceOpen() returned: false') && logs.includes('No active sequence found')) {\n        diagnosis = '❌ No Active Sequence';\n        solution = 'No sequence is active in the Timeline. Double-click a sequence in the Project panel to open it in the Timeline.';\n    } else if (logs.includes('app.project.activeSequence NOT found') && logs.includes('Sequence found')) {\n        diagnosis = '❌ Sequence Not Active';\n        solution = 'A sequence exists but is not the active sequence. Click on the sequence tab in the Timeline to make it active.';\n    } else if (logs.includes('checkSequenceOpen() returned: true') && logs.includes('app.project.activeSequence found')) {\n        diagnosis = '✅ Everything Looks Good';\n        solution = 'The plugin is working correctly. The sequence is detected and active. Try pressing GO again.';\n    } else if (logs.includes('No sequences found in project')) {\n        diagnosis = '❌ No Sequences in Project';\n        solution = 'Create a sequence in Premiere Pro first (File > New > Sequence), then open it in the Timeline.';\n    } else {\n        diagnosis = '⚠️ Unknown Issue';\n        solution = 'Copy the diagnostic logs below and send them to support for further assistance.';\n    }\n\n    ui.debugQuickDiagnosis.innerHTML = `\n        <div class=\"diagnosis-result\">\n            <div class=\"diagnosis-title\">${diagnosis}</div>\n            <div class=\"diagnosis-solution\">${solution}</div>\n        </div>\n    `;\n}\n\nfunction copyDiagnosticsToClipboard() {\n    const text = diagnosticLogs.join('\\n');\n    navigator.clipboard.writeText(text).then(() => {\n        if (ui.copyDiagnosticsBtn) {\n            ui.copyDiagnosticsBtn.textContent = 'Copied!';\n            setTimeout(() => {\n                ui.copyDiagnosticsBtn.textContent = 'Copy to Clipboard';\n            }, 2000);\n        }\n    }).catch(err => {\n        setStatus('Failed to copy: ' + err.message, true);\n    });\n}\n\n// Export for debugging\nwindow.spliceDebug = {\n    getState: () => ({\n        silences: previewSilences,\n        takes: previewTakes,\n        chapters: currentChapters,\n        zooms: currentZooms,\n        selected: Array.from(selectedSilenceIndices)\n    }),\n    jsx,\n    runDetection\n};\n","numLines":1986,"startLine":1,"totalLines":1986}}}
{"parentUuid":"9c069539-aadb-4843-8842-46496e8ceda3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a7e7304","slug":"fizzy-hatching-flame","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A6h7SLXgbsjeQxfgSqwvWR","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Host Script\n     3→ * ExtendScript for Premiere Pro\n     4→ *\n     5→ * Provides all Premiere Pro API functions called via jsx.evalScript()\n     6→ * Based on proven patterns from FireCut and SPLICE UXP builder\n     7→ */\n     8→\n     9→// ============================================================================\n    10→// GLOBAL CONSTANTS & STATE\n    11→// ============================================================================\n    12→var SPLICE_VERSION = \"6.0.3\";\n    13→var TICKS_PER_SECOND = 254016000000;\n    14→var time_tolerance = 0.01; // 10ms tolerance for clip matching\n    15→var temp_bin = null;\n    16→var sequence_default_timecode = null;\n    17→\n    18→// Color label indices (Premiere Pro standard)\n    19→var COLOR_LABELS = {\n    20→    NONE: 0,\n    21→    VIOLET: 1,\n    22→    IRIS: 2,\n    23→    CARIBBEAN: 3,\n    24→    LAVENDER: 4,\n    25→    CERULEAN: 5,\n    26→    FOREST: 6,\n    27→    ROSE: 7,\n    28→    MANGO: 8,\n    29→    PURPLE: 9,\n    30→    BLUE: 10,\n    31→    TEAL: 11,\n    32→    MAGENTA: 12,\n    33→    TAN: 13,\n    34→    GREEN: 14,\n    35→    BROWN: 15,\n    36→    YELLOW: 16\n    37→};\n    38→\n    39→// Segment type to color mapping\n    40→var SEGMENT_COLORS = {\n    41→    speech: COLOR_LABELS.FOREST,\n    42→    take: COLOR_LABELS.LAVENDER,\n    43→    best_take: COLOR_LABELS.CERULEAN,\n    44→    silence: COLOR_LABELS.VIOLET,\n    45→    wide_shot: COLOR_LABELS.YELLOW,\n    46→    speaker_a: COLOR_LABELS.MANGO,\n    47→    speaker_b: COLOR_LABELS.CARIBBEAN\n    48→};\n    49→\n    50→// Timecode display formats\n    51→var TIMECODES = {\n    52→    TIMEDISPLAY_Frames: 4\n    53→};\n    54→\n    55→// Translation map for localized effect names\n    56→var translations = {\n    57→    \"Motion\": [\"Motion\", \"Mouvement\", \"Bewegung\", \"Movimiento\", \"Movimento\"],\n    58→    \"Transform\": [\"Transform\", \"Transformation\", \"Transformieren\", \"Transformar\"],\n    59→    \"Scale\": [\"Scale\", \"Echelle\", \"Skalierung\", \"Escala\"],\n    60→    \"Scale Height\": [\"Scale Height\", \"Hauteur de l'echelle\", \"Skalierungshoehe\"],\n    61→    \"Scale Width\": [\"Scale Width\", \"Largeur de l'echelle\", \"Skalierungsbreite\"],\n    62→    \"Position\": [\"Position\", \"Posicion\", \"Posicao\"],\n    63→    \"Anchor Point\": [\"Anchor Point\", \"Point d'ancrage\", \"Ankerpunkt\"],\n    64→    \"Rotation\": [\"Rotation\", \"Rotacion\", \"Rotacao\"],\n    65→    \"Opacity\": [\"Opacity\", \"Opacite\", \"Deckkraft\", \"Opacidad\"]\n    66→};\n    67→\n    68→// Project item types\n    69→var project_item_type = {\n    70→    \"clip\": 1,\n    71→    \"bin\": 2,\n    72→    \"root\": 3,\n    73→    \"file\": 4\n    74→};\n    75→\n    76→// ============================================================================\n    77→// SECURITY: INPUT VALIDATION UTILITIES (CEP-CRIT-001)\n    78→// Prevents path traversal, command injection, and null byte attacks\n    79→// ============================================================================\n    80→\n    81→/**\n    82→ * Validate and sanitize file paths to prevent path traversal attacks\n    83→ * @param {string} path - File path to validate\n    84→ * @returns {Object} { valid: boolean, path: string, error: string }\n    85→ */\n    86→function validateFilePath(path) {\n    87→    if (!path || typeof path !== 'string') {\n    88→        return { valid: false, path: null, error: 'Invalid path: must be a non-empty string' };\n    89→    }\n    90→\n    91→    // Check for null bytes (CVE potential)\n    92→    if (path.indexOf('\\0') !== -1 || path.indexOf('\\x00') !== -1) {\n    93→        return { valid: false, path: null, error: 'Invalid path: null bytes detected' };\n    94→    }\n    95→\n    96→    // Normalize path separators\n    97→    var normalized = path.replace(/\\\\/g, '/');\n    98→\n    99→    // Check for directory traversal attempts\n   100→    if (normalized.indexOf('../') !== -1 || normalized.indexOf('..\\\\') !== -1) {\n   101→        return { valid: false, path: null, error: 'Invalid path: directory traversal detected' };\n   102→    }\n   103→\n   104→    // Check for potentially dangerous characters in paths (command injection)\n   105→    var dangerousChars = /[`$();|&<>]/;\n   106→    if (dangerousChars.test(path)) {\n   107→        return { valid: false, path: null, error: 'Invalid path: dangerous characters detected' };\n   108→    }\n   109→\n   110→    // Check for protocol handlers that could be exploited\n   111→    var protocolPattern = /^[a-zA-Z][a-zA-Z0-9+.-]*:/;\n   112→    if (protocolPattern.test(path) && !path.match(/^[A-Z]:\\//i)) {\n   113→        // Allow Windows drive letters (C:/) but block other protocols (javascript:, data:, etc.)\n   114→        return { valid: false, path: null, error: 'Invalid path: protocol handlers not allowed' };\n   115→    }\n   116→\n   117→    return { valid: true, path: path, error: null };\n   118→}\n   119→\n   120→/**\n   121→ * Validate sequence name to prevent XSS and injection\n   122→ * @param {string} name - Sequence name to validate\n   123→ * @returns {Object} { valid: boolean, name: string, error: string }\n   124→ */\n   125→function validateSequenceName(name) {\n   126→    if (!name || typeof name !== 'string') {\n   127→        return { valid: false, name: null, error: 'Invalid name: must be a non-empty string' };\n   128→    }\n   129→\n   130→    // Check for null bytes\n   131→    if (name.indexOf('\\0') !== -1) {\n   132→        return { valid: false, name: null, error: 'Invalid name: null bytes detected' };\n   133→    }\n   134→\n   135→    // Check for potentially dangerous characters (file system reserved on Windows)\n   136→    var invalidChars = /[<>:\"|?*]/;\n   137→    if (invalidChars.test(name)) {\n   138→        return { valid: false, name: null, error: 'Invalid name: contains reserved characters' };\n   139→    }\n   140→\n   141→    // Limit length to prevent buffer overflows\n   142→    if (name.length > 255) {\n   143→        return { valid: false, name: null, error: 'Invalid name: exceeds maximum length (255)' };\n   144→    }\n   145→\n   146→    return { valid: true, name: name, error: null };\n   147→}\n   148→\n   149→/**\n   150→ * Validate numeric parameters to prevent injection and DoS\n   151→ * @param {*} value - Value to validate\n   152→ * @param {number} min - Minimum allowed value\n   153→ * @param {number} max - Maximum allowed value\n   154→ * @param {string} paramName - Parameter name for error messages\n   155→ * @returns {Object} { valid: boolean, value: number, error: string }\n   156→ */\n   157→function validateNumericParam(value, min, max, paramName) {\n   158→    if (value === undefined || value === null) {\n   159→        return { valid: false, value: null, error: paramName + ' is required' };\n   160→    }\n   161→\n   162→    var num = parseFloat(value);\n   163→    if (isNaN(num)) {\n   164→        return { valid: false, value: null, error: paramName + ' must be a number' };\n   165→    }\n   166→\n   167→    if (num < min || num > max) {\n   168→        return { valid: false, value: null, error: paramName + ' must be between ' + min + ' and ' + max };\n   169→    }\n   170→\n   171→    return { valid: true, value: num, error: null };\n   172→}\n   173→\n   174→/**\n   175→ * Sanitize string for safe use in Premiere Pro operations\n   176→ * @param {string} str - String to sanitize\n   177→ * @returns {string} Sanitized string\n   178→ */\n   179→function sanitizeString(str) {\n   180→    if (!str || typeof str !== 'string') {\n   181→        return '';\n   182→    }\n   183→\n   184→    // Remove null bytes\n   185→    str = str.replace(/\\0/g, '');\n   186→\n   187→    // Escape special characters that could be problematic in ExtendScript\n   188→    str = str.replace(/[\\r\\n]/g, ' ');\n   189→\n   190→    return str;\n   191→}\n   192→\n   193→/**\n   194→ * Validate array of time values (for markers, cuts, etc.)\n   195→ * @param {Array} times - Array of time values\n   196→ * @param {number} maxLength - Maximum array length (DoS prevention)\n   197→ * @returns {Object} { valid: boolean, times: Array, error: string }\n   198→ */\n   199→function validateTimeArray(times, maxLength) {\n   200→    if (!times || !Array.isArray(times)) {\n   201→        return { valid: false, times: null, error: 'Times must be an array' };\n   202→    }\n   203→\n   204→    maxLength = maxLength || 10000; // Default limit\n   205→    if (times.length > maxLength) {\n   206→        return { valid: false, times: null, error: 'Too many time values (max: ' + maxLength + ')' };\n   207→    }\n   208→\n   209→    for (var i = 0; i < times.length; i++) {\n   210→        var validation = validateNumericParam(times[i], 0, Number.MAX_VALUE, 'time[' + i + ']');\n   211→        if (!validation.valid) {\n   212→            return { valid: false, times: null, error: validation.error };\n   213→        }\n   214→    }\n   215→\n   216→    return { valid: true, times: times, error: null };\n   217→}\n   218→\n   219→// ============================================================================\n   220→// INITIALIZATION\n   221→// ============================================================================\n   222→\n   223→/**\n   224→ * Check if QE (Quality Engine) DOM is available\n   225→ * QE provides extended functionality not available in standard DOM\n   226→ */\n   227→function isQEAvailable() {\n   228→    try {\n   229→        return typeof qe !== 'undefined' && qe !== null && qe.project;\n   230→    } catch (e) {\n   231→        return false;\n   232→    }\n   233→}\n   234→\n   235→/**\n   236→ * Enable QE DOM if not already enabled\n   237→ * @returns {boolean} true if QE is now available\n   238→ */\n   239→function enableQE() {\n   240→    try {\n   241→        if (isQEAvailable()) return true;\n   242→        app.enableQE();\n   243→        return isQEAvailable();\n   244→    } catch (e) {\n   245→        $.writeln('[SPLICE] enableQE failed: ' + e.message);\n   246→        return false;\n   247→    }\n   248→}\n   249→\n   250→/**\n   251→ * Safe wrapper for QE operations\n   252→ * @param {Function} operation - The QE operation to execute\n   253→ * @param {string} operationName - Name for error reporting\n   254→ * @returns {Object} Result or error object\n   255→ */\n   256→function safeQEOperation(operation, operationName) {\n   257→    try {\n   258→        if (!isQEAvailable()) {\n   259→            if (!enableQE()) {\n   260→                return { error: \"QE not available. Please ensure Premiere Pro supports QE DOM.\" };\n   261→            }\n   262→        }\n   263→        return operation();\n   264→    } catch (e) {\n   265→        return { error: operationName + \" failed: \" + e.message };\n   266→    }\n   267→}\n   268→\n   269→function initialise() {\n   270→    try {\n   271→        storeDefaultTimecode();\n   272→        // Try to enable QE on startup\n   273→        var qeStatus = enableQE();\n   274→        return JSON.stringify({ success: true, version: SPLICE_VERSION, qeAvailable: qeStatus });\n   275→    } catch (e) {\n   276→        $.writeln('[SPLICE] initialise error: ' + e.message);\n   277→        return JSON.stringify({ success: false, error: e.message, version: SPLICE_VERSION });\n   278→    }\n   279→}\n   280→\n   281→function storeDefaultTimecode() {\n   282→    try {\n   283→        if (app && app.project && app.project.activeSequence) {\n   284→            sequence_default_timecode = app.project.activeSequence.getSettings().videoDisplayFormat;\n   285→        }\n   286→    } catch (e) {\n   287→        $.writeln('[SPLICE] storeDefaultTimecode failed: ' + e.message);\n   288→    }\n   289→}\n   290→\n   291→/**\n   292→ * Check if a sequence is currently open/active in the Timeline\n   293→ * Uses multiple fallbacks to ensure accurate detection\n   294→ * @returns {boolean} true if a sequence is open\n   295→ */\n   296→function checkSequenceOpen() {\n   297→    try {\n   298→        $.writeln('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC START ==========');\n   299→        \n   300→        // Check if app exists\n   301→        if (!app) {\n   302→            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app object does not exist');\n   303→            return false;\n   304→        }\n   305→        $.writeln('[SPLICE] checkSequenceOpen: app object exists');\n   306→        \n   307→        // Check if project exists\n   308→        if (!app.project) {\n   309→            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app.project does not exist');\n   310→            return false;\n   311→        }\n   312→        $.writeln('[SPLICE] checkSequenceOpen: app.project exists');\n   313→        \n   314→        // Check if sequences collection exists\n   315→        if (!app.project.sequences) {\n   316→            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app.project.sequences does not exist');\n   317→            return false;\n   318→        }\n   319→        $.writeln('[SPLICE] checkSequenceOpen: app.project.sequences exists');\n   320→        \n   321→        // Log total number of sequences\n   322→        var numSequences = app.project.sequences.numSequences;\n   323→        $.writeln('[SPLICE] checkSequenceOpen: Total sequences in project: ' + numSequences);\n   324→        \n   325→        // List all sequences with their details\n   326→        for (var i = 0; i < numSequences; i++) {\n   327→            var seq = app.project.sequences[i];\n   328→            if (seq) {\n   329→                $.writeln('[SPLICE] checkSequenceOpen:   - Sequence ' + i + ': name=\"' + seq.name + '\", id=' + seq.sequenceID);\n   330→            }\n   331→        }\n   332→        \n   333→        // Primary check: Standard DOM - Check for activeSequence\n   334→        $.writeln('[SPLICE] checkSequenceOpen: Checking app.project.activeSequence...');\n   335→        if (app.project.activeSequence) {\n   336→            var activeSeq = app.project.activeSequence;\n   337→            $.writeln('[SPLICE] checkSequenceOpen: SUCCESS - Found active sequence via DOM');\n   338→            $.writeln('[SPLICE] checkSequenceOpen:   - name: ' + activeSeq.name);\n   339→            $.writeln('[SPLICE] checkSequenceOpen:   - sequenceID: ' + activeSeq.sequenceID);\n   340→            $.writeln('[SPLICE] checkSequenceOpen:   - videoTracks: ' + activeSeq.videoTracks.numTracks);\n   341→            $.writeln('[SPLICE] checkSequenceOpen:   - audioTracks: ' + activeSeq.audioTracks.numTracks);\n   342→            $.writeln('[SPLICE] checkSequenceOpen:   - frameSize: ' + activeSeq.frameSizeHorizontal + 'x' + activeSeq.frameSizeVertical);\n   343→            $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n   344→            return true;\n   345→        }\n   346→        $.writeln('[SPLICE] checkSequenceOpen: app.project.activeSequence is null/undefined');\n   347→\n   348→        // Fallback: Try QE DOM (requires enableQE first)\n   349→        $.writeln('[SPLICE] checkSequenceOpen: Trying QE DOM fallback...');\n   350→        if (enableQE()) {\n   351→            try {\n   352→                $.writeln('[SPLICE] checkSequenceOpen: QE DOM is enabled');\n   353→                var qeSeq = qe.project.getActiveSequence();\n   354→                if (qeSeq && qeSeq.name) {\n   355→                    $.writeln('[SPLICE] checkSequenceOpen: SUCCESS - Found active sequence via QE DOM: ' + qeSeq.name);\n   356→                    $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n   357→                    return true;\n   358→                }\n   359→                $.writeln('[SPLICE] checkSequenceOpen: QE DOM returned null or sequence without name');\n   360→            } catch (qeErr) {\n   361→                $.writeln('[SPLICE] checkSequenceOpen: QE sequence check failed: ' + qeErr.message);\n   362→            }\n   363→        } else {\n   364→            $.writeln('[SPLICE] checkSequenceOpen: QE DOM is NOT available/enabled');\n   365→        }\n   366→\n   367→        $.writeln('[SPLICE] checkSequenceOpen: No active sequence found in either DOM or QE DOM');\n   368→        $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (FALSE) ==========');\n   369→        return false;\n   370→    } catch (e) {\n   371→        $.writeln('[SPLICE] checkSequenceOpen: EXCEPTION - ' + e.message);\n   372→        $.writeln('[SPLICE] checkSequenceOpen: Stack: ' + (e.stack || 'no stack available'));\n   373→        $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (ERROR) ==========');\n   374→        return false;\n   375→    }\n   376→}\n   377→\n   378→function getVersion() {\n   379→    return SPLICE_VERSION;\n   380→}\n   381→\n   382→// ============================================================================\n   383→// TIME CONVERSION UTILITIES\n   384→// ============================================================================\n   385→\n   386→/**\n   387→ * Get the actual frames per second from the sequence\n   388→ * videoFrameRate.seconds gives seconds per frame, so we need to invert it\n   389→ */\n   390→function getActualFrameRate() {\n   391→    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n   392→    // secsPerFrame is e.g., 0.03333... for 30fps, so 1/secsPerFrame = 30\n   393→    return 1 / secsPerFrame;\n   394→}\n   395→\n   396→function quantise_time(time_seconds) {\n   397→    // Get seconds per frame (e.g., 0.0333 for 30fps)\n   398→    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n   399→    // Round to nearest frame boundary\n   400→    return secsPerFrame * Math.round(time_seconds / secsPerFrame);\n   401→}\n   402→\n   403→function frames_to_time(number_of_frames) {\n   404→    // seconds per frame * number of frames = total seconds\n   405→    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n   406→    return number_of_frames * secsPerFrame;\n   407→}\n   408→\n   409→function frames_to_ticks(number_of_frames) {\n   410→    // Convert frames to ticks: frames * seconds_per_frame * ticks_per_second\n   411→    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n   412→    return number_of_frames * secsPerFrame * TICKS_PER_SECOND;\n   413→}\n   414→\n   415→function seconds_to_ticks(seconds) {\n   416→    return seconds * TICKS_PER_SECOND;\n   417→}\n   418→\n   419→function ticks_to_seconds(ticks) {\n   420→    return ticks / TICKS_PER_SECOND;\n   421→}\n   422→\n   423→function getVideoFrameRateInSeconds() {\n   424→    try {\n   425→        var seq = app.project.activeSequence;\n   426→        if (!seq) {\n   427→            $.writeln('[SPLICE] getVideoFrameRateInSeconds: No active sequence');\n   428→            return null;\n   429→        }\n   430→        return seq.getSettings().videoFrameRate.seconds;\n   431→    } catch (e) {\n   432→        $.writeln('[SPLICE] getVideoFrameRateInSeconds error: ' + e.message);\n   433→        return null;\n   434→    }\n   435→}\n   436→\n   437→function secondsToCurrentTimecode(seconds) {\n   438→    var seq = app.project.activeSequence;\n   439→    if (seq) {\n   440→        var t = new Time();\n   441→        t.seconds = parseFloat(seconds);\n   442→        var settings = app.project.activeSequence.getSettings();\n   443→        return t.getFormatted(settings.videoFrameRate, settings.videoDisplayFormat);\n   444→    }\n   445→    return false;\n   446→}\n   447→\n   448→// ============================================================================\n   449→// TIMECODE FORMAT\n   450→// ============================================================================\n   451→\n   452→function setTimecodeToFrames() {\n   453→    var seq = app.project.activeSequence;\n   454→    if (seq) {\n   455→        var currentSeqSettings = app.project.activeSequence.getSettings();\n   456→        if (currentSeqSettings.videoDisplayFormat != TIMECODES.TIMEDISPLAY_Frames) {\n   457→            currentSeqSettings.videoDisplayFormat = TIMECODES.TIMEDISPLAY_Frames;\n   458→            app.project.activeSequence.setSettings(currentSeqSettings);\n   459→        }\n   460→    }\n   461→}\n   462→\n   463→function setTimecodeToDefault() {\n   464→    var seq = app.project.activeSequence;\n   465→    if (seq && sequence_default_timecode) {\n   466→        var currentSeqSettings = app.project.activeSequence.getSettings();\n   467→        currentSeqSettings.videoDisplayFormat = sequence_default_timecode;\n   468→        app.project.activeSequence.setSettings(currentSeqSettings);\n   469→    }\n   470→}\n   471→\n   472→function getTimecodeFormat() {\n   473→    return app.project.activeSequence.getSettings().videoDisplayFormat;\n   474→}\n   475→\n   476→function setTimecodeFormat(format) {\n   477→    format = parseInt(format);\n   478→    var seq = app.project.activeSequence;\n   479→    if (seq) {\n   480→        var currentSeqSettings = app.project.activeSequence.getSettings();\n   481→        currentSeqSettings.videoDisplayFormat = format;\n   482→        app.project.activeSequence.setSettings(currentSeqSettings);\n   483→    }\n   484→    return true;\n   485→}\n   486→\n   487→// ============================================================================\n   488→// SEQUENCE & PROJECT OPERATIONS\n   489→// ============================================================================\n   490→\n   491→function getActiveSequence() {\n   492→    try {\n   493→        var seq = app.project.activeSequence;\n   494→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   495→\n   496→        // Safely get settings with fallbacks\n   497→        var frameRate = null;\n   498→        try {\n   499→            var settings = seq.getSettings();\n   500→            if (settings && settings.videoFrameRate) {\n   501→                frameRate = settings.videoFrameRate.seconds;\n   502→            }\n   503→        } catch (settingsErr) {\n   504→            $.writeln('[SPLICE] getActiveSequence: Failed to get settings: ' + settingsErr.message);\n   505→        }\n   506→\n   507→        return JSON.stringify({\n   508→            name: seq.name || \"Unknown\",\n   509→            id: seq.sequenceID || null,\n   510→            duration: seq.end || 0,\n   511→            videoTrackCount: seq.videoTracks ? seq.videoTracks.numTracks : 0,\n   512→            audioTrackCount: seq.audioTracks ? seq.audioTracks.numTracks : 0,\n   513→            frameRate: frameRate,\n   514→            width: seq.frameSizeHorizontal || 0,\n   515→            height: seq.frameSizeVertical || 0\n   516→        });\n   517→    } catch (e) {\n   518→        $.writeln('[SPLICE] getActiveSequence error: ' + e.message);\n   519→        return JSON.stringify({ error: \"getActiveSequence failed: \" + e.message });\n   520→    }\n   521→}\n   522→\n   523→function getAllSequences() {\n   524→    try {\n   525→        if (!app || !app.project || !app.project.sequences) {\n   526→            return JSON.stringify({ error: \"No project open\" });\n   527→        }\n   528→\n   529→        var sequences = [];\n   530→        var numSeqs = app.project.sequences.numSequences;\n   531→\n   532→        for (var i = 0; i < numSeqs; i++) {\n   533→            var seq = app.project.sequences[i];\n   534→            if (seq) {\n   535→                sequences.push({\n   536→                    name: seq.name || \"Unknown\",\n   537→                    id: seq.sequenceID || null,\n   538→                    index: i\n   539→                });\n   540→            }\n   541→        }\n   542→\n   543→        return JSON.stringify(sequences);\n   544→    } catch (e) {\n   545→        $.writeln('[SPLICE] getAllSequences error: ' + e.message);\n   546→        return JSON.stringify({ error: \"getAllSequences failed: \" + e.message });\n   547→    }\n   548→}\n   549→\n   550→function getSequenceSettings() {\n   551→    var seq = app.project.activeSequence;\n   552→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   553→\n   554→    var settings = seq.getSettings();\n   555→    return JSON.stringify({\n   556→        frameRate: settings.videoFrameRate.seconds,\n   557→        width: settings.videoFrameWidth,\n   558→        height: settings.videoFrameHeight,\n   559→        displayFormat: settings.videoDisplayFormat\n   560→    });\n   561→}\n   562→\n   563→function cloneSequence(newName) {\n   564→    var seq = app.project.activeSequence;\n   565→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   566→\n   567→    try {\n   568→        // Clone the sequence\n   569→        seq.clone();\n   570→\n   571→        // Find the cloned sequence (last one with matching name pattern)\n   572→        var clonedSeq = null;\n   573→        for (var i = app.project.sequences.numSequences - 1; i >= 0; i--) {\n   574→            var s = app.project.sequences[i];\n   575→            if (s.name.indexOf(seq.name) === 0 && s.sequenceID !== seq.sequenceID) {\n   576→                clonedSeq = s;\n   577→                break;\n   578→            }\n   579→        }\n   580→\n   581→        if (clonedSeq && newName) {\n   582→            clonedSeq.name = newName;\n   583→        }\n   584→\n   585→        return JSON.stringify({\n   586→            success: true,\n   587→            sequenceId: clonedSeq ? clonedSeq.sequenceID : null,\n   588→            name: clonedSeq ? clonedSeq.name : newName\n   589→        });\n   590→    } catch (e) {\n   591→        return JSON.stringify({ error: e.message });\n   592→    }\n   593→}\n   594→\n   595→function createNewSequence(name) {\n   596→    try {\n   597→        app.project.createNewSequence(name);\n   598→        var seq = app.project.activeSequence;\n   599→        return JSON.stringify({\n   600→            success: true,\n   601→            sequenceId: seq.sequenceID,\n   602→            name: seq.name\n   603→        });\n   604→    } catch (e) {\n   605→        return JSON.stringify({ error: e.message });\n   606→    }\n   607→}\n   608→\n   609→function setActiveSequence(sequenceId) {\n   610→    for (var i = 0; i < app.project.sequences.numSequences; i++) {\n   611→        if (app.project.sequences[i].sequenceID === sequenceId) {\n   612→            app.project.activeSequence = app.project.sequences[i];\n   613→            return JSON.stringify({ success: true });\n   614→        }\n   615→    }\n   616→    return JSON.stringify({ error: \"Sequence not found\" });\n   617→}\n   618→\n   619→/**\n   620→ * Seek playhead to a specific time in seconds\n   621→ */\n   622→function seekToTime(seconds) {\n   623→    var seq = app.project.activeSequence;\n   624→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   625→\n   626→    try {\n   627→        // Convert seconds to ticks\n   628→        var ticks = seconds * TICKS_PER_SECOND;\n   629→\n   630→        // Create a Time object and set position\n   631→        var playerPos = seq.getPlayerPosition();\n   632→        playerPos.seconds = seconds;\n   633→        seq.setPlayerPosition(playerPos.ticks.toString());\n   634→\n   635→        return JSON.stringify({ success: true, position: seconds });\n   636→    } catch (e) {\n   637→        return JSON.stringify({ error: e.message });\n   638→    }\n   639→}\n   640→\n   641→/**\n   642→ * Get current playhead position in seconds\n   643→ */\n   644→function getPlayerPosition() {\n   645→    var seq = app.project.activeSequence;\n   646→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   647→\n   648→    try {\n   649→        var pos = seq.getPlayerPosition();\n   650→        return JSON.stringify({\n   651→            ticks: pos.ticks,\n   652→            seconds: pos.seconds\n   653→        });\n   654→    } catch (e) {\n   655→        return JSON.stringify({ error: e.message });\n   656→    }\n   657→}\n   658→\n   659→// ============================================================================\n   660→// RAZOR OPERATIONS\n   661→// ============================================================================\n   662→\n   663→function razorSequenceAtFrames(frames) {\n   664→    if (!isQEAvailable() && !enableQE()) {\n   665→        return JSON.stringify({ error: \"QE not available for razor operation\" });\n   666→    }\n   667→    try {\n   668→        frames = String(frames);\n   669→        setTimecodeToFrames();\n   670→        qe.project.getActiveSequence().razor(frames);\n   671→        return JSON.stringify({ success: true });\n   672→    } catch (e) {\n   673→        return JSON.stringify({ error: \"Razor failed: \" + e.message });\n   674→    }\n   675→}\n   676→\n   677→function razorSequenceAtSeconds(seconds) {\n   678→    try {\n   679→        var frames = parseInt(Math.round(seconds / app.project.activeSequence.getSettings().videoFrameRate.seconds)).toString();\n   680→        return razorSequenceAtFrames(frames);\n   681→    } catch (e) {\n   682→        return JSON.stringify({ error: \"Razor at seconds failed: \" + e.message });\n   683→    }\n   684→}\n   685→\n   686→function razorSequenceAtFramesArray(silences_array) {\n   687→    if (!isQEAvailable() && !enableQE()) {\n   688→        return JSON.stringify({ error: \"QE not available for razor operation\" });\n   689→    }\n   690→    try {\n   691→        setTimecodeToFrames();\n   692→        silences_array = JSON.parse(silences_array);\n   693→        var razorCount = 0;\n   694→        for (var i = 0; i < silences_array.length; i++) {\n   695→            for (var j = 0; j < silences_array[i].length; j++) {\n   696→                var frames = String(silences_array[i][j]);\n   697→                qe.project.getActiveSequence().razor(frames);\n   698→                razorCount++;\n   699→            }\n   700→        }\n   701→        return JSON.stringify({ success: true, razorCount: razorCount });\n   702→    } catch (e) {\n   703→        return JSON.stringify({ error: \"Razor array failed: \" + e.message });\n   704→    }\n   705→}\n   706→\n   707→function razorTrackAtFrames(trackType, trackIndex, frames) {\n   708→    if (!isQEAvailable() && !enableQE()) {\n   709→        return JSON.stringify({ error: \"QE not available for track razor\" });\n   710→    }\n   711→    try {\n   712→        frames = String(frames);\n   713→        setTimecodeToFrames();\n   714→        if (trackType == \"video\") {\n   715→            qe.project.getActiveSequence().getVideoTrackAt(trackIndex).razor(frames);\n   716→        } else if (trackType == \"audio\") {\n   717→            qe.project.getActiveSequence().getAudioTrackAt(trackIndex).razor(frames);\n   718→        }\n   719→        return JSON.stringify({ success: true });\n   720→    } catch (e) {\n   721→        return JSON.stringify({ error: \"Track razor failed: \" + e.message });\n   722→    }\n   723→}\n   724→\n   725→function razorTrackAtSeconds(trackType, trackIndex, seconds) {\n   726→    try {\n   727→        var frames = parseInt(Math.round(seconds / app.project.activeSequence.getSettings().videoFrameRate.seconds)).toString();\n   728→        return razorTrackAtFrames(trackType, trackIndex, frames);\n   729→    } catch (e) {\n   730→        return JSON.stringify({ error: \"Track razor at seconds failed: \" + e.message });\n   731→    }\n   732→}\n   733→\n   734→// ============================================================================\n   735→// CLIP OPERATIONS\n   736→// ============================================================================\n   737→\n   738→/**\n   739→ * Get currently selected clips in the timeline\n   740→ * @returns {string} JSON with selected clip data or error\n   741→ */\n   742→function getSelectedClips() {\n   743→    try {\n   744→        var seq = app.project.activeSequence;\n   745→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   746→\n   747→        var selection = seq.getSelection();\n   748→        var clips = [];\n   749→\n   750→        for (var i = 0; i < selection.length; i++) {\n   751→            var clip = selection[i];\n   752→            clips.push({\n   753→                index: i,\n   754→                name: clip.name,\n   755→                start: clip.start.seconds,\n   756→                end: clip.end.seconds,\n   757→                duration: clip.duration.seconds,\n   758→                inPoint: clip.inPoint ? clip.inPoint.seconds : null,\n   759→                outPoint: clip.outPoint ? clip.outPoint.seconds : null,\n   760→                mediaPath: clip.projectItem ? clip.projectItem.getMediaPath() : null\n   761→            });\n   762→        }\n   763→\n   764→        $.writeln('[SPLICE] getSelectedClips: Found ' + clips.length + ' selected clips');\n   765→        return JSON.stringify({\n   766→            count: clips.length,\n   767→            clips: clips\n   768→        });\n   769→    } catch (e) {\n   770→        $.writeln('[SPLICE] getSelectedClips error: ' + e.message);\n   771→        return JSON.stringify({ error: \"getSelectedClips failed: \" + e.message });\n   772→    }\n   773→}\n   774→\n   775→function getClipsInTrack(trackIndex, trackType) {\n   776→    try {\n   777→        var seq = app.project.activeSequence;\n   778→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   779→\n   780→        var tracks = trackType === \"audio\" ? seq.audioTracks : seq.videoTracks;\n   781→        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n   782→            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex + \" (max: \" + (tracks.numTracks - 1) + \")\" });\n   783→        }\n   784→\n   785→        var clips = [];\n   786→        var trackClips = tracks[trackIndex].clips;\n   787→        for (var i = 0; i < trackClips.numItems; i++) {\n   788→            var clip = trackClips[i];\n   789→            clips.push({\n   790→                index: i,\n   791→                name: clip.name,\n   792→                start: clip.start.seconds,\n   793→                end: clip.end.seconds,\n   794→                duration: clip.duration.seconds,\n   795→                inPoint: clip.inPoint.seconds,\n   796→                outPoint: clip.outPoint.seconds,\n   797→                mediaPath: clip.projectItem ? clip.projectItem.getMediaPath() : null\n   798→            });\n   799→        }\n   800→        return JSON.stringify(clips);\n   801→    } catch (e) {\n   802→        $.writeln('[SPLICE] getClipsInTrack error: ' + e.message);\n   803→        return JSON.stringify({ error: \"getClipsInTrack failed: \" + e.message });\n   804→    }\n   805→}\n   806→\n   807→function getClipsInTrack_Timings_Seconds(trackIndex, trackType) {\n   808→    try {\n   809→        var seq = app.project.activeSequence;\n   810→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   811→\n   812→        var tracks = trackType === \"audio\" ? seq.audioTracks : seq.videoTracks;\n   813→        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n   814→            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex });\n   815→        }\n   816→\n   817→        var clips = [];\n   818→        var trackClips = tracks[trackIndex].clips;\n   819→        for (var i = 0; i < trackClips.numItems; i++) {\n   820→            clips.push([\n   821→                trackClips[i].start.seconds,\n   822→                trackClips[i].end.seconds\n   823→            ]);\n   824→        }\n   825→        return JSON.stringify(clips);\n   826→    } catch (e) {\n   827→        $.writeln('[SPLICE] getClipsInTrack_Timings_Seconds error: ' + e.message);\n   828→        return JSON.stringify({ error: \"getClipsInTrack_Timings_Seconds failed: \" + e.message });\n   829→    }\n   830→}\n   831→\n   832→function deleteClipsAtSilencePointsInTrack(silences, trackType, trackIndex) {\n   833→    try {\n   834→        var seq = app.project.activeSequence;\n   835→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   836→\n   837→        // Validate trackType\n   838→        if (trackType !== \"video\" && trackType !== \"audio\") {\n   839→            return JSON.stringify({ error: \"Invalid track type: \" + trackType });\n   840→        }\n   841→\n   842→        // Parse silences JSON\n   843→        var silencesArr;\n   844→        try {\n   845→            silencesArr = JSON.parse(silences);\n   846→        } catch (parseErr) {\n   847→            return JSON.stringify({ error: \"Invalid silences JSON: \" + parseErr.message });\n   848→        }\n   849→\n   850→        // Get tracks and validate index\n   851→        var tracks = trackType === \"video\" ? seq.videoTracks : seq.audioTracks;\n   852→        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n   853→            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex + \" (max: \" + (tracks.numTracks - 1) + \")\" });\n   854→        }\n   855→\n   856→        var clips = tracks[trackIndex].clips;\n   857→        var deleted = 0;\n   858→\n   859→        // Iterate backwards to avoid index shifting (use numItems, not length)\n   860→        for (var i = clips.numItems - 1; i >= 0; i--) {\n   861→            var clip = clips[i];\n   862→            var start = clip.start.seconds;\n   863→            var end = clip.end.seconds;\n   864→            var center = (start + end) / 2;\n   865→\n   866→            for (var j = 0; j < silencesArr.length; j++) {\n   867→                var silence = silencesArr[j];\n   868→                var silenceCenter = (silence[0] + silence[1]) / 2;\n   869→                if (silenceCenter > start && silenceCenter < end) {\n   870→                    clip.remove(false, false);\n   871→                    deleted++;\n   872→                    break;\n   873→                }\n   874→            }\n   875→        }\n   876→\n   877→        $.writeln('[SPLICE] deleteClipsAtSilencePointsInTrack: Deleted ' + deleted + ' clips from ' + trackType + ' track ' + trackIndex);\n   878→        return JSON.stringify({ deleted: deleted });\n   879→    } catch (e) {\n   880→        $.writeln('[SPLICE] deleteClipsAtSilencePointsInTrack error: ' + e.message);\n   881→        return JSON.stringify({ error: \"deleteClipsAtSilencePointsInTrack failed: \" + e.message });\n   882→    }\n   883→}\n   884→\n   885→function makeRemainingClipsContiguousInTrack(silences, deltas, trackType, trackIndex) {\n   886→    silences = JSON.parse(silences);\n   887→    deltas = JSON.parse(deltas);\n   888→\n   889→    var clips;\n   890→    if (trackType == \"video\") {\n   891→        clips = app.project.activeSequence.videoTracks[trackIndex].clips;\n   892→    } else if (trackType == \"audio\") {\n   893→        clips = app.project.activeSequence.audioTracks[trackIndex].clips;\n   894→    }\n   895→\n   896→    for (var i = 0; i < clips.length; i++) {\n   897→        var clip = clips[i];\n   898→        var end = clip.end.seconds;\n   899→        var num_silences = -1;\n   900→\n   901→        for (var j = 0; j < silences.length; j++) {\n   902→            if (end > silences[j][1]) {\n   903→                num_silences++;\n   904→            }\n   905→        }\n   906→\n   907→        if (num_silences > -1 && num_silences < deltas.length) {\n   908→            var delta = deltas[num_silences];\n   909→            var t_start = clip.start;\n   910→            t_start.seconds = t_start.seconds - delta;\n   911→            clip.start = t_start;\n   912→            var t_end = clip.end;\n   913→            t_end.seconds = t_end.seconds - delta;\n   914→            clip.end = t_end;\n   915→        }\n   916→    }\n   917→    return JSON.stringify({ success: true });\n   918→}\n   919→\n   920→function removeClipByIndex(trackType, trackIndex, clipIndex) {\n   921→    try {\n   922→        if (trackType == \"video\") {\n   923→            app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex].remove(false, false);\n   924→        } else if (trackType == \"audio\") {\n   925→            app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex].remove(false, false);\n   926→        }\n   927→        return JSON.stringify({ success: true });\n   928→    } catch (e) {\n   929→        return JSON.stringify({ error: e.message });\n   930→    }\n   931→}\n   932→\n   933→function setClipInOutPoints(trackType, trackIndex, clipIndex, inPoint, outPoint) {\n   934→    try {\n   935→        var clip;\n   936→        if (trackType == \"video\") {\n   937→            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n   938→        } else if (trackType == \"audio\") {\n   939→            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n   940→        }\n   941→\n   942→        if (inPoint !== null) {\n   943→            var inTime = new Time();\n   944→            inTime.seconds = inPoint;\n   945→            clip.inPoint = inTime;\n   946→        }\n   947→        if (outPoint !== null) {\n   948→            var outTime = new Time();\n   949→            outTime.seconds = outPoint;\n   950→            clip.outPoint = outTime;\n   951→        }\n   952→        return JSON.stringify({ success: true });\n   953→    } catch (e) {\n   954→        return JSON.stringify({ error: e.message });\n   955→    }\n   956→}\n   957→\n   958→function setClipStartEnd(trackType, trackIndex, clipIndex, startSeconds, endSeconds) {\n   959→    try {\n   960→        var clip;\n   961→        if (trackType == \"video\") {\n   962→            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n   963→        } else if (trackType == \"audio\") {\n   964→            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n   965→        }\n   966→\n   967→        if (startSeconds !== null) {\n   968→            var startTime = clip.start;\n   969→            startTime.seconds = startSeconds;\n   970→            clip.start = startTime;\n   971→        }\n   972→        if (endSeconds !== null) {\n   973→            var endTime = clip.end;\n   974→            endTime.seconds = endSeconds;\n   975→            clip.end = endTime;\n   976→        }\n   977→        return JSON.stringify({ success: true });\n   978→    } catch (e) {\n   979→        return JSON.stringify({ error: e.message });\n   980→    }\n   981→}\n   982→\n   983→// ============================================================================\n   984→// TRACK OPERATIONS\n   985→// ============================================================================\n   986→\n   987→function getTrackNames(trackType) {\n   988→    if (!isQEAvailable() && !enableQE()) {\n   989→        // Fallback: use standard DOM\n   990→        var ret = [];\n   991→        try {\n   992→            if (trackType == \"video\") {\n   993→                for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n   994→                    ret.push(\"V\" + (i + 1));\n   995→                }\n   996→            } else if (trackType == \"audio\") {\n   997→                for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n   998→                    ret.push(\"A\" + (i + 1));\n   999→                }\n  1000→            }\n  1001→        } catch (e) {\n  1002→            return JSON.stringify({ error: \"Failed to get track names: \" + e.message });\n  1003→        }\n  1004→        return JSON.stringify(ret);\n  1005→    }\n  1006→\n  1007→    try {\n  1008→        var ret = [];\n  1009→        if (trackType == \"video\") {\n  1010→            for (var i = 0; i < qe.project.getActiveSequence().numVideoTracks; i++) {\n  1011→                ret.push(qe.project.getActiveSequence().getVideoTrackAt(i).name);\n  1012→            }\n  1013→        } else if (trackType == \"audio\") {\n  1014→            for (var i = 0; i < qe.project.getActiveSequence().numAudioTracks; i++) {\n  1015→                ret.push(qe.project.getActiveSequence().getAudioTrackAt(i).name);\n  1016→            }\n  1017→        }\n  1018→        return JSON.stringify(ret);\n  1019→    } catch (e) {\n  1020→        return JSON.stringify({ error: \"Failed to get track names: \" + e.message });\n  1021→    }\n  1022→}\n  1023→\n  1024→function getNumTracks(trackType) {\n  1025→    try {\n  1026→        if (trackType == \"video\") {\n  1027→            return app.project.activeSequence.videoTracks.numTracks;\n  1028→        } else if (trackType == \"audio\") {\n  1029→            return app.project.activeSequence.audioTracks.numTracks;\n  1030→        }\n  1031→        return 0;\n  1032→    } catch (e) {\n  1033→        return JSON.stringify({ error: \"Failed to get track count: \" + e.message });\n  1034→    }\n  1035→}\n  1036→\n  1037→function addVideoTrack() {\n  1038→    if (!isQEAvailable() && !enableQE()) {\n  1039→        return JSON.stringify({ error: \"QE not available for adding tracks\" });\n  1040→    }\n  1041→    try {\n  1042→        var trackId = qe.project.getActiveSequence().numVideoTracks;\n  1043→        qe.project.getActiveSequence().addTracks(1, trackId, 0, 0);\n  1044→        return JSON.stringify({ success: true, trackId: trackId });\n  1045→    } catch (e) {\n  1046→        return JSON.stringify({ error: \"Failed to add video track: \" + e.message });\n  1047→    }\n  1048→}\n  1049→\n  1050→function addAudioTrack() {\n  1051→    if (!isQEAvailable() && !enableQE()) {\n  1052→        return JSON.stringify({ error: \"QE not available for adding tracks\" });\n  1053→    }\n  1054→    try {\n  1055→        var trackId = qe.project.getActiveSequence().numAudioTracks;\n  1056→        qe.project.getActiveSequence().addTracks(0, 0, 1, 1, trackId);\n  1057→        return JSON.stringify({ success: true, trackId: trackId });\n  1058→    } catch (e) {\n  1059→        return JSON.stringify({ error: \"Failed to add audio track: \" + e.message });\n  1060→    }\n  1061→}\n  1062→\n  1063→function removeVideoTrack(trackIndex) {\n  1064→    if (!isQEAvailable() && !enableQE()) {\n  1065→        return JSON.stringify({ error: \"QE not available for removing tracks\" });\n  1066→    }\n  1067→    try {\n  1068→        qe.project.getActiveSequence().removeVideoTrack(trackIndex);\n  1069→        return JSON.stringify({ success: true });\n  1070→    } catch (e) {\n  1071→        return JSON.stringify({ error: \"Failed to remove video track: \" + e.message });\n  1072→    }\n  1073→}\n  1074→\n  1075→function removeAudioTrack(trackIndex) {\n  1076→    if (!isQEAvailable() && !enableQE()) {\n  1077→        return JSON.stringify({ error: \"QE not available for removing tracks\" });\n  1078→    }\n  1079→    try {\n  1080→        qe.project.getActiveSequence().removeAudioTrack(trackIndex);\n  1081→        return JSON.stringify({ success: true });\n  1082→    } catch (e) {\n  1083→        return JSON.stringify({ error: \"Failed to remove audio track: \" + e.message });\n  1084→    }\n  1085→}\n  1086→\n  1087→// ============================================================================\n  1088→// MUTE STATE\n  1089→// ============================================================================\n  1090→\n  1091→function getMuteState() {\n  1092→    var mute_state_video = [];\n  1093→    for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n  1094→        mute_state_video.push(app.project.activeSequence.videoTracks[i].isMuted());\n  1095→    }\n  1096→    var mute_state_audio = [];\n  1097→    for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n  1098→        mute_state_audio.push(app.project.activeSequence.audioTracks[i].isMuted());\n  1099→    }\n  1100→    return JSON.stringify({ audio: mute_state_audio, video: mute_state_video });\n  1101→}\n  1102→\n  1103→function setMuteState(mute_state) {\n  1104→    mute_state = JSON.parse(mute_state);\n  1105→    for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n  1106→        if (i < mute_state.video.length) {\n  1107→            app.project.activeSequence.videoTracks[i].setMute(mute_state.video[i]);\n  1108→        }\n  1109→    }\n  1110→    for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n  1111→        if (i < mute_state.audio.length) {\n  1112→            app.project.activeSequence.audioTracks[i].setMute(mute_state.audio[i]);\n  1113→        }\n  1114→    }\n  1115→    return true;\n  1116→}\n  1117→\n  1118→// ============================================================================\n  1119→// PROJECT ITEM OPERATIONS\n  1120→// ============================================================================\n  1121→\n  1122→function findItemByName(bin, name) {\n  1123→    for (var i = 0; i < bin.children.numItems; i++) {\n  1124→        if (bin.children[i].name === name) {\n  1125→            return bin.children[i];\n  1126→        }\n  1127→        if (bin.children[i].children !== undefined) {\n  1128→            var item = findItemByName(bin.children[i], name);\n  1129→            if (item) return item;\n  1130→        }\n  1131→    }\n  1132→    return null;\n  1133→}\n  1134→\n  1135→function findItemByPath(bin, path) {\n  1136→    for (var i = 0; i < bin.children.numItems; i++) {\n  1137→        var item = bin.children[i];\n  1138→        if (item.getMediaPath && item.getMediaPath() === path) {\n  1139→            return item;\n  1140→        }\n  1141→        if (item.children !== undefined) {\n  1142→            var found = findItemByPath(item, path);\n  1143→            if (found) return found;\n  1144→        }\n  1145→    }\n  1146→    return null;\n  1147→}\n  1148→\n  1149→function importFile(filePath) {\n  1150→    try {\n  1151→        var success = app.project.importFiles([filePath], true, app.project.rootItem, false);\n  1152→        if (success) {\n  1153→            // Find the imported item\n  1154→            var item = findItemByPath(app.project.rootItem, filePath);\n  1155→            return JSON.stringify({\n  1156→                success: true,\n  1157→                nodeId: item ? item.nodeId : null\n  1158→            });\n  1159→        }\n  1160→        return JSON.stringify({ error: \"Import failed\" });\n  1161→    } catch (e) {\n  1162→        return JSON.stringify({ error: e.message });\n  1163→    }\n  1164→}\n  1165→\n  1166→function getSpliceBin() {\n  1167→    var rootItemChildren = app.project.rootItem.children;\n  1168→    var spliceBin = null;\n  1169→\n  1170→    for (var i = 0; i < rootItemChildren.numItems; i++) {\n  1171→        if (rootItemChildren[i].name === \"SPLICE\" && rootItemChildren[i].type === 2) {\n  1172→            spliceBin = rootItemChildren[i];\n  1173→            break;\n  1174→        }\n  1175→    }\n  1176→\n  1177→    if (!spliceBin) {\n  1178→        app.project.rootItem.createBin(\"SPLICE\");\n  1179→        return getSpliceBin();\n  1180→    }\n  1181→\n  1182→    return spliceBin;\n  1183→}\n  1184→\n  1185→function getAllProjectItems() {\n  1186→    var items = [];\n  1187→\n  1188→    function collectItems(bin, path) {\n  1189→        for (var i = 0; i < bin.children.numItems; i++) {\n  1190→            var item = bin.children[i];\n  1191→            var itemPath = path + \"/\" + item.name;\n  1192→\n  1193→            items.push({\n  1194→                nodeId: item.nodeId,\n  1195→                name: item.name,\n  1196→                type: item.type,\n  1197→                treePath: itemPath,\n  1198→                mediaPath: item.getMediaPath ? item.getMediaPath() : null\n  1199→            });\n  1200→\n  1201→            if (item.children !== undefined && item.type === 2) {\n  1202→                collectItems(item, itemPath);\n  1203→            }\n  1204→        }\n  1205→    }\n  1206→\n  1207→    collectItems(app.project.rootItem, \"\");\n  1208→    return JSON.stringify(items);\n  1209→}\n  1210→\n  1211→// ============================================================================\n  1212→// CLIP INSERTION\n  1213→// ============================================================================\n  1214→\n  1215→function insertClipAtTime(projectItemNodeId, trackIndex, startSeconds, trackType) {\n  1216→    try {\n  1217→        var item = findItemByNodeId(app.project.rootItem, projectItemNodeId);\n  1218→        if (!item) {\n  1219→            return JSON.stringify({ error: \"Project item not found\" });\n  1220→        }\n  1221→\n  1222→        var targetTime = new Time();\n  1223→        targetTime.seconds = startSeconds;\n  1224→\n  1225→        if (trackType === \"video\") {\n  1226→            app.project.activeSequence.videoTracks[trackIndex].insertClip(item, targetTime);\n  1227→        } else if (trackType === \"audio\") {\n  1228→            app.project.activeSequence.audioTracks[trackIndex].insertClip(item, targetTime);\n  1229→        }\n  1230→\n  1231→        return JSON.stringify({ success: true });\n  1232→    } catch (e) {\n  1233→        return JSON.stringify({ error: e.message });\n  1234→    }\n  1235→}\n  1236→\n  1237→function findItemByNodeId(bin, nodeId) {\n  1238→    for (var i = 0; i < bin.children.numItems; i++) {\n  1239→        if (bin.children[i].nodeId === nodeId) {\n  1240→            return bin.children[i];\n  1241→        }\n  1242→        if (bin.children[i].children !== undefined) {\n  1243→            var found = findItemByNodeId(bin.children[i], nodeId);\n  1244→            if (found) return found;\n  1245→        }\n  1246→    }\n  1247→    return null;\n  1248→}\n  1249→\n  1250→// ============================================================================\n  1251→// MARKER OPERATIONS\n  1252→// ============================================================================\n  1253→\n  1254→function createMarker(timeSeconds, name, duration, comments, colorIndex) {\n  1255→    try {\n  1256→        var seq = app.project.activeSequence;\n  1257→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1258→\n  1259→        var markers = seq.markers;\n  1260→        var marker = markers.createMarker(timeSeconds);\n  1261→\n  1262→        if (name) marker.name = name;\n  1263→        if (comments) marker.comments = comments;\n  1264→        if (colorIndex !== undefined) marker.setColorByIndex(colorIndex);\n  1265→        if (duration && duration > 0) {\n  1266→            // Set marker end time properly using a Time object\n  1267→            var endTime = new Time();\n  1268→            endTime.seconds = marker.start.seconds + duration;\n  1269→            marker.end = endTime;\n  1270→        }\n  1271→\n  1272→        return JSON.stringify({\n  1273→            success: true,\n  1274→            guid: marker.guid\n  1275→        });\n  1276→    } catch (e) {\n  1277→        return JSON.stringify({ error: e.message });\n  1278→    }\n  1279→}\n  1280→\n  1281→function getMarkers() {\n  1282→    try {\n  1283→        var seq = app.project.activeSequence;\n  1284→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1285→\n  1286→        var markers = seq.markers;\n  1287→        var result = [];\n  1288→\n  1289→        for (var i = 0; i < markers.numMarkers; i++) {\n  1290→            var marker = markers[i];\n  1291→            result.push({\n  1292→                guid: marker.guid,\n  1293→                name: marker.name,\n  1294→                comments: marker.comments,\n  1295→                start: marker.start.seconds,\n  1296→                end: marker.end.seconds,\n  1297→                type: marker.type\n  1298→            });\n  1299→        }\n  1300→\n  1301→        return JSON.stringify(result);\n  1302→    } catch (e) {\n  1303→        return JSON.stringify({ error: e.message });\n  1304→    }\n  1305→}\n  1306→\n  1307→function deleteMarker(markerGuid) {\n  1308→    try {\n  1309→        var seq = app.project.activeSequence;\n  1310→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1311→\n  1312→        var markers = seq.markers;\n  1313→        for (var i = 0; i < markers.numMarkers; i++) {\n  1314→            if (markers[i].guid === markerGuid) {\n  1315→                markers[i].remove();\n  1316→                return JSON.stringify({ success: true });\n  1317→            }\n  1318→        }\n  1319→        return JSON.stringify({ error: \"Marker not found\" });\n  1320→    } catch (e) {\n  1321→        return JSON.stringify({ error: e.message });\n  1322→    }\n  1323→}\n  1324→\n  1325→function deleteAllMarkers() {\n  1326→    try {\n  1327→        var seq = app.project.activeSequence;\n  1328→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1329→\n  1330→        var markers = seq.markers;\n  1331→        var count = markers.numMarkers;\n  1332→\n  1333→        // Delete from end to beginning to avoid index shifting\n  1334→        for (var i = count - 1; i >= 0; i--) {\n  1335→            markers[i].remove();\n  1336→        }\n  1337→\n  1338→        return JSON.stringify({ success: true, deleted: count });\n  1339→    } catch (e) {\n  1340→        return JSON.stringify({ error: e.message });\n  1341→    }\n  1342→}\n  1343→\n  1344→function deleteMarkersByName(namePattern) {\n  1345→    try {\n  1346→        var seq = app.project.activeSequence;\n  1347→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1348→\n  1349→        var markers = seq.markers;\n  1350→        var deleted = 0;\n  1351→\n  1352→        for (var i = markers.numMarkers - 1; i >= 0; i--) {\n  1353→            if (markers[i].name && markers[i].name.indexOf(namePattern) !== -1) {\n  1354→                markers[i].remove();\n  1355→                deleted++;\n  1356→            }\n  1357→        }\n  1358→\n  1359→        return JSON.stringify({ success: true, deleted: deleted });\n  1360→    } catch (e) {\n  1361→        return JSON.stringify({ error: e.message });\n  1362→    }\n  1363→}\n  1364→\n  1365→// ============================================================================\n  1366→// COLOR LABEL OPERATIONS\n  1367→// ============================================================================\n  1368→\n  1369→function setClipColorLabel(trackType, trackIndex, clipIndex, colorIndex) {\n  1370→    try {\n  1371→        var clip;\n  1372→        if (trackType == \"video\") {\n  1373→            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n  1374→        } else if (trackType == \"audio\") {\n  1375→            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n  1376→        }\n  1377→\n  1378→        if (clip && clip.projectItem) {\n  1379→            clip.projectItem.setColorLabel(colorIndex);\n  1380→        }\n  1381→        return JSON.stringify({ success: true });\n  1382→    } catch (e) {\n  1383→        return JSON.stringify({ error: e.message });\n  1384→    }\n  1385→}\n  1386→\n  1387→function setProjectItemColorLabel(nodeId, colorIndex) {\n  1388→    try {\n  1389→        var item = findItemByNodeId(app.project.rootItem, nodeId);\n  1390→        if (item) {\n  1391→            item.setColorLabel(colorIndex);\n  1392→            return JSON.stringify({ success: true });\n  1393→        }\n  1394→        return JSON.stringify({ error: \"Item not found\" });\n  1395→    } catch (e) {\n  1396→        return JSON.stringify({ error: e.message });\n  1397→    }\n  1398→}\n  1399→\n  1400→// ============================================================================\n  1401→// SEQUENCE BUILDING (CORE v3.5 FUNCTIONALITY)\n  1402→// ============================================================================\n  1403→\n  1404→function buildSequenceFromCutList(cutListJson) {\n  1405→    try {\n  1406→        var cutList = JSON.parse(cutListJson);\n  1407→        var seq = app.project.activeSequence;\n  1408→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1409→\n  1410→        // Clone the sequence\n  1411→        var newSequenceName = seq.name + \"_SPLICE\";\n  1412→        seq.clone();\n  1413→\n  1414→        // Find the cloned sequence\n  1415→        var newSeq = null;\n  1416→        for (var i = app.project.sequences.numSequences - 1; i >= 0; i--) {\n  1417→            var s = app.project.sequences[i];\n  1418→            if (s.name.indexOf(seq.name) === 0 && s.sequenceID !== seq.sequenceID) {\n  1419→                newSeq = s;\n  1420→                break;\n  1421→            }\n  1422→        }\n  1423→\n  1424→        if (!newSeq) {\n  1425→            return JSON.stringify({ error: \"Failed to clone sequence\" });\n  1426→        }\n  1427→\n  1428→        newSeq.name = newSequenceName;\n  1429→        app.project.activeSequence = newSeq;\n  1430→\n  1431→        // Clear all clips from the new sequence\n  1432→        clearSequence();\n  1433→\n  1434→        // Insert segments\n  1435→        var currentPosition = 0;\n  1436→        var stats = {\n  1437→            segmentsInserted: 0,\n  1438→            totalDuration: 0\n  1439→        };\n  1440→\n  1441→        for (var i = 0; i < cutList.segments.length; i++) {\n  1442→            var segment = cutList.segments[i];\n  1443→\n  1444→            // Find the source project item\n  1445→            var sourceItem = null;\n  1446→            if (segment.sourcePath) {\n  1447→                sourceItem = findItemByPath(app.project.rootItem, segment.sourcePath);\n  1448→            }\n  1449→            if (!sourceItem && segment.sourceName) {\n  1450→                sourceItem = findItemByName(app.project.rootItem, segment.sourceName);\n  1451→            }\n  1452→\n  1453→            if (!sourceItem) continue;\n  1454→\n  1455→            // Set color label\n  1456→            if (segment.colorHint && SEGMENT_COLORS[segment.colorHint]) {\n  1457→                sourceItem.setColorLabel(SEGMENT_COLORS[segment.colorHint]);\n  1458→            } else if (segment.type && SEGMENT_COLORS[segment.type]) {\n  1459→                sourceItem.setColorLabel(SEGMENT_COLORS[segment.type]);\n  1460→            }\n  1461→\n  1462→            // Insert clip at current position\n  1463→            var targetTime = new Time();\n  1464→            targetTime.seconds = currentPosition;\n  1465→\n  1466→            newSeq.videoTracks[0].insertClip(sourceItem, targetTime);\n  1467→\n  1468→            // Set in/out points\n  1469→            var clipDuration = segment.outPoint - segment.inPoint;\n  1470→            var videoClips = newSeq.videoTracks[0].clips;\n  1471→            var insertedClip = videoClips[videoClips.numItems - 1];\n  1472→\n  1473→            if (insertedClip) {\n  1474→                var inTime = new Time();\n  1475→                inTime.seconds = segment.inPoint;\n  1476→                insertedClip.inPoint = inTime;\n  1477→\n  1478→                var outTime = new Time();\n  1479→                outTime.seconds = segment.outPoint;\n  1480→                insertedClip.outPoint = outTime;\n  1481→\n  1482→                // Set clip name if takeLabel provided\n  1483→                if (segment.takeLabel) {\n  1484→                    insertedClip.name = segment.takeLabel;\n  1485→                }\n  1486→            }\n  1487→\n  1488→            currentPosition += clipDuration;\n  1489→            stats.segmentsInserted++;\n  1490→            stats.totalDuration += clipDuration;\n  1491→        }\n  1492→\n  1493→        return JSON.stringify({\n  1494→            success: true,\n  1495→            sequenceName: newSequenceName,\n  1496→            stats: stats\n  1497→        });\n  1498→    } catch (e) {\n  1499→        return JSON.stringify({ error: e.message });\n  1500→    }\n  1501→}\n  1502→\n  1503→function clearSequence() {\n  1504→    try {\n  1505→        var seq = app.project.activeSequence;\n  1506→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1507→\n  1508→        var removed = { video: 0, audio: 0 };\n  1509→\n  1510→        // Remove all video clips\n  1511→        for (var t = 0; t < seq.videoTracks.numTracks; t++) {\n  1512→            var clips = seq.videoTracks[t].clips;\n  1513→            for (var i = clips.numItems - 1; i >= 0; i--) {\n  1514→                clips[i].remove(false, false);\n  1515→                removed.video++;\n  1516→            }\n  1517→        }\n  1518→\n  1519→        // Remove all audio clips\n  1520→        for (var t = 0; t < seq.audioTracks.numTracks; t++) {\n  1521→            var clips = seq.audioTracks[t].clips;\n  1522→            for (var i = clips.numItems - 1; i >= 0; i--) {\n  1523→                clips[i].remove(false, false);\n  1524→                removed.audio++;\n  1525→            }\n  1526→        }\n  1527→\n  1528→        $.writeln('[SPLICE] clearSequence: Removed ' + removed.video + ' video clips, ' + removed.audio + ' audio clips');\n  1529→        return JSON.stringify({ success: true, removed: removed });\n  1530→    } catch (e) {\n  1531→        $.writeln('[SPLICE] clearSequence error: ' + e.message);\n  1532→        return JSON.stringify({ error: \"Clear sequence failed: \" + e.message });\n  1533→    }\n  1534→}\n  1535→\n  1536→// ============================================================================\n  1537→// WORK AREA\n  1538→// ============================================================================\n  1539→\n  1540→function getWorkArea() {\n  1541→    var seq = app.project.activeSequence;\n  1542→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1543→\n  1544→    return JSON.stringify({\n  1545→        inPoint: seq.getInPoint(),\n  1546→        outPoint: seq.getOutPoint()\n  1547→    });\n  1548→}\n  1549→\n  1550→function setWorkArea(inPoint, outPoint) {\n  1551→    var seq = app.project.activeSequence;\n  1552→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1553→\n  1554→    seq.setInPoint(inPoint);\n  1555→    seq.setOutPoint(outPoint);\n  1556→    return JSON.stringify({ success: true });\n  1557→}\n  1558→\n  1559→// ============================================================================\n  1560→// AUDIO EXPORT\n  1561→// ============================================================================\n  1562→\n  1563→function exportSequenceAudio(outputPath, inPoint, outPoint) {\n  1564→    try {\n  1565→        var seq = app.project.activeSequence;\n  1566→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1567→\n  1568→        // Use the AME (Adobe Media Encoder) for export\n  1569→        var encoder = app.encoder;\n  1570→        if (!encoder) {\n  1571→            return JSON.stringify({ error: \"Media Encoder not available\" });\n  1572→        }\n  1573→\n  1574→        // Create export preset for WAV\n  1575→        var presetPath = encoder.getDefaultPresetPath();\n  1576→\n  1577→        // Queue the export\n  1578→        encoder.encodeSequence(\n  1579→            seq,\n  1580→            outputPath,\n  1581→            presetPath,\n  1582→            0, // WorkAreaType: 0 = entire, 1 = work area\n  1583→            false // removeOnCompletion\n  1584→        );\n  1585→\n  1586→        return JSON.stringify({ success: true, outputPath: outputPath });\n  1587→    } catch (e) {\n  1588→        return JSON.stringify({ error: e.message });\n  1589→    }\n  1590→}\n  1591→\n  1592→/**\n  1593→ * Export sequence audio for SPLICE analysis\n  1594→ * Uses AME to export WAV audio to temp folder\n  1595→ * @returns {Object} { success, outputPath } or { error }\n  1596→ */\n  1597→function exportSequenceAudioForAnalysis() {\n  1598→    try {\n  1599→        var seq = app.project.activeSequence;\n  1600→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1601→\n  1602→        // Generate temp file path\n  1603→        var tempFolder = Folder.temp.fsName;\n  1604→        var timestamp = new Date().getTime();\n  1605→        var outputPath = tempFolder + \"/splice_audio_\" + timestamp + \".wav\";\n  1606→\n  1607→        // Check if we have audio tracks with content\n  1608→        var hasAudio = false;\n  1609→        for (var i = 0; i < seq.audioTracks.numTracks; i++) {\n  1610→            if (seq.audioTracks[i].clips.numItems > 0) {\n  1611→                hasAudio = true;\n  1612→                break;\n  1613→            }\n  1614→        }\n  1615→\n  1616→        if (!hasAudio) {\n  1617→            return JSON.stringify({ error: \"Sequence has no audio clips\" });\n  1618→        }\n  1619→\n  1620→        // Use AME for export if available\n  1621→        if (app.encoder && app.encoder.encodeSequence) {\n  1622→            // Find audio-only preset or use default\n  1623→            var presetPath = null;\n  1624→            try {\n  1625→                // Try to find WAV preset in common locations\n  1626→                var presetFolders = [\n  1627→                    Folder.appData.fsName + \"/Adobe/Common/AME/15.0/Presets\",\n  1628→                    Folder.appData.fsName + \"/Adobe/Common/AME/14.0/Presets\",\n  1629→                    app.path + \"/MediaIO/systempresets/58534430_4d756c74-6962697400000000/WAV 48kHz.epr\"\n  1630→                ];\n  1631→\n  1632→                for (var i = 0; i < presetFolders.length; i++) {\n  1633→                    var presetFile = new File(presetFolders[i]);\n  1634→                    if (presetFile.exists) {\n  1635→                        presetPath = presetFile.fsName;\n  1636→                        break;\n  1637→                    }\n  1638→                }\n  1639→\n  1640→                // Fall back to default preset\n  1641→                if (!presetPath) {\n  1642→                    presetPath = app.encoder.getDefaultPresetPath();\n  1643→                }\n  1644→            } catch (e) {\n  1645→                presetPath = app.encoder.getDefaultPresetPath();\n  1646→            }\n  1647→\n  1648→            // Start the encode\n  1649→            var success = app.encoder.encodeSequence(\n  1650→                seq,\n  1651→                outputPath,\n  1652→                presetPath,\n  1653→                0, // WorkAreaType: 0 = entire sequence\n  1654→                false // removeOnCompletion\n  1655→            );\n  1656→\n  1657→            if (success) {\n  1658→                return JSON.stringify({ success: true, outputPath: outputPath, method: \"ame\" });\n  1659→            }\n  1660→        }\n  1661→\n  1662→        // Fallback: Try to get the source audio path from first clip\n  1663→        return getFirstClipAudioPath();\n  1664→\n  1665→    } catch (e) {\n  1666→        return JSON.stringify({ error: e.message });\n  1667→    }\n  1668→}\n  1669→\n  1670→/**\n  1671→ * Get the audio/video file path from the first clip in the timeline\n  1672→ * Used as fallback when AME export is not available\n  1673→ * @returns {Object} { success, path } or { error }\n  1674→ */\n  1675→function getFirstClipAudioPath() {\n  1676→    try {\n  1677→        var seq = app.project.activeSequence;\n  1678→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1679→\n  1680→        // First try audio tracks\n  1681→        for (var i = 0; i < seq.audioTracks.numTracks; i++) {\n  1682→            var track = seq.audioTracks[i];\n  1683→            if (track.clips.numItems > 0) {\n  1684→                var clip = track.clips[0];\n  1685→                if (clip.projectItem && clip.projectItem.getMediaPath) {\n  1686→                    var mediaPath = clip.projectItem.getMediaPath();\n  1687→                    if (mediaPath && mediaPath.length > 0) {\n  1688→                        return JSON.stringify({ success: true, path: mediaPath, method: \"audio_track\" });\n  1689→                    }\n  1690→                }\n  1691→            }\n  1692→        }\n  1693→\n  1694→        // Fall back to video tracks (which may have linked audio)\n  1695→        for (var i = 0; i < seq.videoTracks.numTracks; i++) {\n  1696→            var track = seq.videoTracks[i];\n  1697→            if (track.clips.numItems > 0) {\n  1698→                var clip = track.clips[0];\n  1699→                if (clip.projectItem && clip.projectItem.getMediaPath) {\n  1700→                    var mediaPath = clip.projectItem.getMediaPath();\n  1701→                    if (mediaPath && mediaPath.length > 0) {\n  1702→                        return JSON.stringify({ success: true, path: mediaPath, method: \"video_track\" });\n  1703→                    }\n  1704→                }\n  1705→            }\n  1706→        }\n  1707→\n  1708→        return JSON.stringify({ error: \"No clips with media paths found in sequence\" });\n  1709→    } catch (e) {\n  1710→        return JSON.stringify({ error: e.message });\n  1711→    }\n  1712→}\n  1713→\n  1714→// ============================================================================\n  1715→// UTILITY FUNCTIONS\n  1716→// ============================================================================\n  1717→\n  1718→function moveClipByNTracks(currentTrackId, clipStartTime, nTracksToMove, trackType) {\n  1719→    if (!isQEAvailable() && !enableQE()) {\n  1720→        return JSON.stringify({ error: \"QE not available for moving clips between tracks\" });\n  1721→    }\n  1722→\n  1723→    try {\n  1724→        var accuracy = 3;\n  1725→        var search_start_time = clipStartTime.toFixed(accuracy);\n  1726→\n  1727→        if (trackType == \"audio\") {\n  1728→            var numClipsInTrack = qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).numItems;\n  1729→            for (var j = 0; j < numClipsInTrack; j++) {\n  1730→                if (qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).getItemAt(j).start.secs.toFixed(accuracy) == search_start_time) {\n  1731→                    qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).getItemAt(j).moveToTrack(0, nTracksToMove, \"0\");\n  1732→                    return JSON.stringify({ success: true });\n  1733→                }\n  1734→            }\n  1735→        } else if (trackType == \"video\") {\n  1736→            var numClipsInTrack = qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).numItems;\n  1737→            for (var j = 0; j < numClipsInTrack; j++) {\n  1738→                if (qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).getItemAt(j).start.secs.toFixed(accuracy) == search_start_time) {\n  1739→                    qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).getItemAt(j).moveToTrack(nTracksToMove, 0, \"0\");\n  1740→                    return JSON.stringify({ success: true });\n  1741→                }\n  1742→            }\n  1743→        }\n  1744→        return JSON.stringify({ error: \"Clip not found at specified time\" });\n  1745→    } catch (e) {\n  1746→        return JSON.stringify({ error: \"Move clip failed: \" + e.message });\n  1747→    }\n  1748→}\n  1749→\n  1750→function linkIdenticalClipsInTracks(videoTrackIndex, audioTrackIndex) {\n  1751→    var selected_clips = app.project.activeSequence.getSelection();\n  1752→    for (var i = 0; i < selected_clips.length; i++) {\n  1753→        selected_clips[i].setSelected(false, false);\n  1754→    }\n  1755→\n  1756→    var video_clips = app.project.activeSequence.videoTracks[videoTrackIndex].clips;\n  1757→    var audio_clips = app.project.activeSequence.audioTracks[audioTrackIndex].clips;\n  1758→\n  1759→    for (var i = 0; i < video_clips.numItems; i++) {\n  1760→        var video_clip = video_clips[i];\n  1761→        var video_start = video_clip.start.seconds;\n  1762→\n  1763→        for (var j = 0; j < audio_clips.numItems; j++) {\n  1764→            var audio_clip = audio_clips[j];\n  1765→            var audio_start = audio_clip.start.seconds;\n  1766→\n  1767→            if (Math.abs(video_start - audio_start) < time_tolerance) {\n  1768→                video_clip.setSelected(true, false);\n  1769→                audio_clip.setSelected(true, false);\n  1770→                app.project.activeSequence.linkSelection();\n  1771→                video_clip.setSelected(false, false);\n  1772→                audio_clip.setSelected(false, false);\n  1773→                break;\n  1774→            }\n  1775→        }\n  1776→    }\n  1777→    return true;\n  1778→}\n  1779→\n  1780→// ============================================================================\n  1781→// ZOOM OPERATIONS (Phase 3)\n  1782→// ============================================================================\n  1783→\n  1784→function addZoomMarker(startSeconds, scale, duration, easing) {\n  1785→    try {\n  1786→        var name = \"ZOOM: \" + scale + \"%\";\n  1787→        var comments = \"Duration: \" + duration + \"s | Easing: \" + (easing || \"ease-in-out\");\n  1788→        return createMarker(startSeconds, name, duration, comments, COLOR_LABELS.YELLOW);\n  1789→    } catch (e) {\n  1790→        return JSON.stringify({ error: e.message });\n  1791→    }\n  1792→}\n  1793→\n  1794→// ============================================================================\n  1795→// CHAPTER OPERATIONS (Phase 3)\n  1796→// ============================================================================\n  1797→\n  1798→function addChapterMarker(timeSeconds, title, description) {\n  1799→    try {\n  1800→        var seq = app.project.activeSequence;\n  1801→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1802→\n  1803→        var markers = seq.markers;\n  1804→        var marker = markers.createMarker(timeSeconds);\n  1805→\n  1806→        marker.name = title;\n  1807→        if (description) marker.comments = description;\n  1808→        marker.setColorByIndex(COLOR_LABELS.BLUE);\n  1809→        marker.setTypeAsChapter();\n  1810→\n  1811→        return JSON.stringify({\n  1812→            success: true,\n  1813→            guid: marker.guid\n  1814→        });\n  1815→    } catch (e) {\n  1816→        return JSON.stringify({ error: e.message });\n  1817→    }\n  1818→}\n  1819→\n  1820→function getChapterMarkers() {\n  1821→    try {\n  1822→        var seq = app.project.activeSequence;\n  1823→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1824→\n  1825→        var markers = seq.markers;\n  1826→        var chapters = [];\n  1827→\n  1828→        for (var i = 0; i < markers.numMarkers; i++) {\n  1829→            var marker = markers[i];\n  1830→            if (marker.type === \"Chapter\") {\n  1831→                chapters.push({\n  1832→                    guid: marker.guid,\n  1833→                    name: marker.name,\n  1834→                    comments: marker.comments,\n  1835→                    start: marker.start.seconds\n  1836→                });\n  1837→            }\n  1838→        }\n  1839→\n  1840→        return JSON.stringify(chapters);\n  1841→    } catch (e) {\n  1842→        return JSON.stringify({ error: e.message });\n  1843→    }\n  1844→}\n  1845→\n  1846→// ============================================================================\n  1847→// UNDO OPERATIONS\n  1848→// ============================================================================\n  1849→\n  1850→function undo() {\n  1851→    app.project.undo();\n  1852→    return true;\n  1853→}\n  1854→\n  1855→function redo() {\n  1856→    app.project.redo();\n  1857→    return true;\n  1858→}\n  1859→\n  1860→// ============================================================================\n  1861→// DEBUG / LOGGING\n  1862→// ============================================================================\n  1863→\n  1864→function log(message) {\n  1865→    $.writeln(\"[SPLICE] \" + message);\n  1866→}\n  1867→\n  1868→function getDebugInfo() {\n  1869→    return JSON.stringify({\n  1870→        version: SPLICE_VERSION,\n  1871→        hasActiveSequence: app.project.activeSequence ? true : false,\n  1872→        sequenceName: app.project.activeSequence ? app.project.activeSequence.name : null,\n  1873→        numSequences: app.project.sequences.numSequences,\n  1874→        numProjectItems: app.project.rootItem.children.numItems\n  1875→    });\n  1876→}\n  1877→\n  1878→// NOTE: Do NOT auto-initialize on load - CEP will call initialise() explicitly\n  1879→// when the panel is ready. Auto-initialization can fail if no project is open.\n  1880→$.writeln('[SPLICE] hostScript.jsx loaded - version ' + SPLICE_VERSION);\n  1881→\n\n</system-reminder>\n"}]},"uuid":"8395d273-205c-4783-80a0-e2d82a48c751","timestamp":"2026-01-12T09:17:48.191Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/jsx/hostScript.jsx","content":"/**\n * SPLICE CEP Host Script\n * ExtendScript for Premiere Pro\n *\n * Provides all Premiere Pro API functions called via jsx.evalScript()\n * Based on proven patterns from FireCut and SPLICE UXP builder\n */\n\n// ============================================================================\n// GLOBAL CONSTANTS & STATE\n// ============================================================================\nvar SPLICE_VERSION = \"6.0.3\";\nvar TICKS_PER_SECOND = 254016000000;\nvar time_tolerance = 0.01; // 10ms tolerance for clip matching\nvar temp_bin = null;\nvar sequence_default_timecode = null;\n\n// Color label indices (Premiere Pro standard)\nvar COLOR_LABELS = {\n    NONE: 0,\n    VIOLET: 1,\n    IRIS: 2,\n    CARIBBEAN: 3,\n    LAVENDER: 4,\n    CERULEAN: 5,\n    FOREST: 6,\n    ROSE: 7,\n    MANGO: 8,\n    PURPLE: 9,\n    BLUE: 10,\n    TEAL: 11,\n    MAGENTA: 12,\n    TAN: 13,\n    GREEN: 14,\n    BROWN: 15,\n    YELLOW: 16\n};\n\n// Segment type to color mapping\nvar SEGMENT_COLORS = {\n    speech: COLOR_LABELS.FOREST,\n    take: COLOR_LABELS.LAVENDER,\n    best_take: COLOR_LABELS.CERULEAN,\n    silence: COLOR_LABELS.VIOLET,\n    wide_shot: COLOR_LABELS.YELLOW,\n    speaker_a: COLOR_LABELS.MANGO,\n    speaker_b: COLOR_LABELS.CARIBBEAN\n};\n\n// Timecode display formats\nvar TIMECODES = {\n    TIMEDISPLAY_Frames: 4\n};\n\n// Translation map for localized effect names\nvar translations = {\n    \"Motion\": [\"Motion\", \"Mouvement\", \"Bewegung\", \"Movimiento\", \"Movimento\"],\n    \"Transform\": [\"Transform\", \"Transformation\", \"Transformieren\", \"Transformar\"],\n    \"Scale\": [\"Scale\", \"Echelle\", \"Skalierung\", \"Escala\"],\n    \"Scale Height\": [\"Scale Height\", \"Hauteur de l'echelle\", \"Skalierungshoehe\"],\n    \"Scale Width\": [\"Scale Width\", \"Largeur de l'echelle\", \"Skalierungsbreite\"],\n    \"Position\": [\"Position\", \"Posicion\", \"Posicao\"],\n    \"Anchor Point\": [\"Anchor Point\", \"Point d'ancrage\", \"Ankerpunkt\"],\n    \"Rotation\": [\"Rotation\", \"Rotacion\", \"Rotacao\"],\n    \"Opacity\": [\"Opacity\", \"Opacite\", \"Deckkraft\", \"Opacidad\"]\n};\n\n// Project item types\nvar project_item_type = {\n    \"clip\": 1,\n    \"bin\": 2,\n    \"root\": 3,\n    \"file\": 4\n};\n\n// ============================================================================\n// SECURITY: INPUT VALIDATION UTILITIES (CEP-CRIT-001)\n// Prevents path traversal, command injection, and null byte attacks\n// ============================================================================\n\n/**\n * Validate and sanitize file paths to prevent path traversal attacks\n * @param {string} path - File path to validate\n * @returns {Object} { valid: boolean, path: string, error: string }\n */\nfunction validateFilePath(path) {\n    if (!path || typeof path !== 'string') {\n        return { valid: false, path: null, error: 'Invalid path: must be a non-empty string' };\n    }\n\n    // Check for null bytes (CVE potential)\n    if (path.indexOf('\\0') !== -1 || path.indexOf('\\x00') !== -1) {\n        return { valid: false, path: null, error: 'Invalid path: null bytes detected' };\n    }\n\n    // Normalize path separators\n    var normalized = path.replace(/\\\\/g, '/');\n\n    // Check for directory traversal attempts\n    if (normalized.indexOf('../') !== -1 || normalized.indexOf('..\\\\') !== -1) {\n        return { valid: false, path: null, error: 'Invalid path: directory traversal detected' };\n    }\n\n    // Check for potentially dangerous characters in paths (command injection)\n    var dangerousChars = /[`$();|&<>]/;\n    if (dangerousChars.test(path)) {\n        return { valid: false, path: null, error: 'Invalid path: dangerous characters detected' };\n    }\n\n    // Check for protocol handlers that could be exploited\n    var protocolPattern = /^[a-zA-Z][a-zA-Z0-9+.-]*:/;\n    if (protocolPattern.test(path) && !path.match(/^[A-Z]:\\//i)) {\n        // Allow Windows drive letters (C:/) but block other protocols (javascript:, data:, etc.)\n        return { valid: false, path: null, error: 'Invalid path: protocol handlers not allowed' };\n    }\n\n    return { valid: true, path: path, error: null };\n}\n\n/**\n * Validate sequence name to prevent XSS and injection\n * @param {string} name - Sequence name to validate\n * @returns {Object} { valid: boolean, name: string, error: string }\n */\nfunction validateSequenceName(name) {\n    if (!name || typeof name !== 'string') {\n        return { valid: false, name: null, error: 'Invalid name: must be a non-empty string' };\n    }\n\n    // Check for null bytes\n    if (name.indexOf('\\0') !== -1) {\n        return { valid: false, name: null, error: 'Invalid name: null bytes detected' };\n    }\n\n    // Check for potentially dangerous characters (file system reserved on Windows)\n    var invalidChars = /[<>:\"|?*]/;\n    if (invalidChars.test(name)) {\n        return { valid: false, name: null, error: 'Invalid name: contains reserved characters' };\n    }\n\n    // Limit length to prevent buffer overflows\n    if (name.length > 255) {\n        return { valid: false, name: null, error: 'Invalid name: exceeds maximum length (255)' };\n    }\n\n    return { valid: true, name: name, error: null };\n}\n\n/**\n * Validate numeric parameters to prevent injection and DoS\n * @param {*} value - Value to validate\n * @param {number} min - Minimum allowed value\n * @param {number} max - Maximum allowed value\n * @param {string} paramName - Parameter name for error messages\n * @returns {Object} { valid: boolean, value: number, error: string }\n */\nfunction validateNumericParam(value, min, max, paramName) {\n    if (value === undefined || value === null) {\n        return { valid: false, value: null, error: paramName + ' is required' };\n    }\n\n    var num = parseFloat(value);\n    if (isNaN(num)) {\n        return { valid: false, value: null, error: paramName + ' must be a number' };\n    }\n\n    if (num < min || num > max) {\n        return { valid: false, value: null, error: paramName + ' must be between ' + min + ' and ' + max };\n    }\n\n    return { valid: true, value: num, error: null };\n}\n\n/**\n * Sanitize string for safe use in Premiere Pro operations\n * @param {string} str - String to sanitize\n * @returns {string} Sanitized string\n */\nfunction sanitizeString(str) {\n    if (!str || typeof str !== 'string') {\n        return '';\n    }\n\n    // Remove null bytes\n    str = str.replace(/\\0/g, '');\n\n    // Escape special characters that could be problematic in ExtendScript\n    str = str.replace(/[\\r\\n]/g, ' ');\n\n    return str;\n}\n\n/**\n * Validate array of time values (for markers, cuts, etc.)\n * @param {Array} times - Array of time values\n * @param {number} maxLength - Maximum array length (DoS prevention)\n * @returns {Object} { valid: boolean, times: Array, error: string }\n */\nfunction validateTimeArray(times, maxLength) {\n    if (!times || !Array.isArray(times)) {\n        return { valid: false, times: null, error: 'Times must be an array' };\n    }\n\n    maxLength = maxLength || 10000; // Default limit\n    if (times.length > maxLength) {\n        return { valid: false, times: null, error: 'Too many time values (max: ' + maxLength + ')' };\n    }\n\n    for (var i = 0; i < times.length; i++) {\n        var validation = validateNumericParam(times[i], 0, Number.MAX_VALUE, 'time[' + i + ']');\n        if (!validation.valid) {\n            return { valid: false, times: null, error: validation.error };\n        }\n    }\n\n    return { valid: true, times: times, error: null };\n}\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\n\n/**\n * Check if QE (Quality Engine) DOM is available\n * QE provides extended functionality not available in standard DOM\n */\nfunction isQEAvailable() {\n    try {\n        return typeof qe !== 'undefined' && qe !== null && qe.project;\n    } catch (e) {\n        return false;\n    }\n}\n\n/**\n * Enable QE DOM if not already enabled\n * @returns {boolean} true if QE is now available\n */\nfunction enableQE() {\n    try {\n        if (isQEAvailable()) return true;\n        app.enableQE();\n        return isQEAvailable();\n    } catch (e) {\n        $.writeln('[SPLICE] enableQE failed: ' + e.message);\n        return false;\n    }\n}\n\n/**\n * Safe wrapper for QE operations\n * @param {Function} operation - The QE operation to execute\n * @param {string} operationName - Name for error reporting\n * @returns {Object} Result or error object\n */\nfunction safeQEOperation(operation, operationName) {\n    try {\n        if (!isQEAvailable()) {\n            if (!enableQE()) {\n                return { error: \"QE not available. Please ensure Premiere Pro supports QE DOM.\" };\n            }\n        }\n        return operation();\n    } catch (e) {\n        return { error: operationName + \" failed: \" + e.message };\n    }\n}\n\nfunction initialise() {\n    try {\n        storeDefaultTimecode();\n        // Try to enable QE on startup\n        var qeStatus = enableQE();\n        return JSON.stringify({ success: true, version: SPLICE_VERSION, qeAvailable: qeStatus });\n    } catch (e) {\n        $.writeln('[SPLICE] initialise error: ' + e.message);\n        return JSON.stringify({ success: false, error: e.message, version: SPLICE_VERSION });\n    }\n}\n\nfunction storeDefaultTimecode() {\n    try {\n        if (app && app.project && app.project.activeSequence) {\n            sequence_default_timecode = app.project.activeSequence.getSettings().videoDisplayFormat;\n        }\n    } catch (e) {\n        $.writeln('[SPLICE] storeDefaultTimecode failed: ' + e.message);\n    }\n}\n\n/**\n * Check if a sequence is currently open/active in the Timeline\n * Uses multiple fallbacks to ensure accurate detection\n * @returns {boolean} true if a sequence is open\n */\nfunction checkSequenceOpen() {\n    try {\n        $.writeln('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC START ==========');\n        \n        // Check if app exists\n        if (!app) {\n            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app object does not exist');\n            return false;\n        }\n        $.writeln('[SPLICE] checkSequenceOpen: app object exists');\n        \n        // Check if project exists\n        if (!app.project) {\n            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app.project does not exist');\n            return false;\n        }\n        $.writeln('[SPLICE] checkSequenceOpen: app.project exists');\n        \n        // Check if sequences collection exists\n        if (!app.project.sequences) {\n            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app.project.sequences does not exist');\n            return false;\n        }\n        $.writeln('[SPLICE] checkSequenceOpen: app.project.sequences exists');\n        \n        // Log total number of sequences\n        var numSequences = app.project.sequences.numSequences;\n        $.writeln('[SPLICE] checkSequenceOpen: Total sequences in project: ' + numSequences);\n        \n        // List all sequences with their details\n        for (var i = 0; i < numSequences; i++) {\n            var seq = app.project.sequences[i];\n            if (seq) {\n                $.writeln('[SPLICE] checkSequenceOpen:   - Sequence ' + i + ': name=\"' + seq.name + '\", id=' + seq.sequenceID);\n            }\n        }\n        \n        // Primary check: Standard DOM - Check for activeSequence\n        $.writeln('[SPLICE] checkSequenceOpen: Checking app.project.activeSequence...');\n        if (app.project.activeSequence) {\n            var activeSeq = app.project.activeSequence;\n            $.writeln('[SPLICE] checkSequenceOpen: SUCCESS - Found active sequence via DOM');\n            $.writeln('[SPLICE] checkSequenceOpen:   - name: ' + activeSeq.name);\n            $.writeln('[SPLICE] checkSequenceOpen:   - sequenceID: ' + activeSeq.sequenceID);\n            $.writeln('[SPLICE] checkSequenceOpen:   - videoTracks: ' + activeSeq.videoTracks.numTracks);\n            $.writeln('[SPLICE] checkSequenceOpen:   - audioTracks: ' + activeSeq.audioTracks.numTracks);\n            $.writeln('[SPLICE] checkSequenceOpen:   - frameSize: ' + activeSeq.frameSizeHorizontal + 'x' + activeSeq.frameSizeVertical);\n            $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n            return true;\n        }\n        $.writeln('[SPLICE] checkSequenceOpen: app.project.activeSequence is null/undefined');\n\n        // Fallback: Try QE DOM (requires enableQE first)\n        $.writeln('[SPLICE] checkSequenceOpen: Trying QE DOM fallback...');\n        if (enableQE()) {\n            try {\n                $.writeln('[SPLICE] checkSequenceOpen: QE DOM is enabled');\n                var qeSeq = qe.project.getActiveSequence();\n                if (qeSeq && qeSeq.name) {\n                    $.writeln('[SPLICE] checkSequenceOpen: SUCCESS - Found active sequence via QE DOM: ' + qeSeq.name);\n                    $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n                    return true;\n                }\n                $.writeln('[SPLICE] checkSequenceOpen: QE DOM returned null or sequence without name');\n            } catch (qeErr) {\n                $.writeln('[SPLICE] checkSequenceOpen: QE sequence check failed: ' + qeErr.message);\n            }\n        } else {\n            $.writeln('[SPLICE] checkSequenceOpen: QE DOM is NOT available/enabled');\n        }\n\n        $.writeln('[SPLICE] checkSequenceOpen: No active sequence found in either DOM or QE DOM');\n        $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (FALSE) ==========');\n        return false;\n    } catch (e) {\n        $.writeln('[SPLICE] checkSequenceOpen: EXCEPTION - ' + e.message);\n        $.writeln('[SPLICE] checkSequenceOpen: Stack: ' + (e.stack || 'no stack available'));\n        $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (ERROR) ==========');\n        return false;\n    }\n}\n\nfunction getVersion() {\n    return SPLICE_VERSION;\n}\n\n// ============================================================================\n// TIME CONVERSION UTILITIES\n// ============================================================================\n\n/**\n * Get the actual frames per second from the sequence\n * videoFrameRate.seconds gives seconds per frame, so we need to invert it\n */\nfunction getActualFrameRate() {\n    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n    // secsPerFrame is e.g., 0.03333... for 30fps, so 1/secsPerFrame = 30\n    return 1 / secsPerFrame;\n}\n\nfunction quantise_time(time_seconds) {\n    // Get seconds per frame (e.g., 0.0333 for 30fps)\n    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n    // Round to nearest frame boundary\n    return secsPerFrame * Math.round(time_seconds / secsPerFrame);\n}\n\nfunction frames_to_time(number_of_frames) {\n    // seconds per frame * number of frames = total seconds\n    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n    return number_of_frames * secsPerFrame;\n}\n\nfunction frames_to_ticks(number_of_frames) {\n    // Convert frames to ticks: frames * seconds_per_frame * ticks_per_second\n    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n    return number_of_frames * secsPerFrame * TICKS_PER_SECOND;\n}\n\nfunction seconds_to_ticks(seconds) {\n    return seconds * TICKS_PER_SECOND;\n}\n\nfunction ticks_to_seconds(ticks) {\n    return ticks / TICKS_PER_SECOND;\n}\n\nfunction getVideoFrameRateInSeconds() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) {\n            $.writeln('[SPLICE] getVideoFrameRateInSeconds: No active sequence');\n            return null;\n        }\n        return seq.getSettings().videoFrameRate.seconds;\n    } catch (e) {\n        $.writeln('[SPLICE] getVideoFrameRateInSeconds error: ' + e.message);\n        return null;\n    }\n}\n\nfunction secondsToCurrentTimecode(seconds) {\n    var seq = app.project.activeSequence;\n    if (seq) {\n        var t = new Time();\n        t.seconds = parseFloat(seconds);\n        var settings = app.project.activeSequence.getSettings();\n        return t.getFormatted(settings.videoFrameRate, settings.videoDisplayFormat);\n    }\n    return false;\n}\n\n// ============================================================================\n// TIMECODE FORMAT\n// ============================================================================\n\nfunction setTimecodeToFrames() {\n    var seq = app.project.activeSequence;\n    if (seq) {\n        var currentSeqSettings = app.project.activeSequence.getSettings();\n        if (currentSeqSettings.videoDisplayFormat != TIMECODES.TIMEDISPLAY_Frames) {\n            currentSeqSettings.videoDisplayFormat = TIMECODES.TIMEDISPLAY_Frames;\n            app.project.activeSequence.setSettings(currentSeqSettings);\n        }\n    }\n}\n\nfunction setTimecodeToDefault() {\n    var seq = app.project.activeSequence;\n    if (seq && sequence_default_timecode) {\n        var currentSeqSettings = app.project.activeSequence.getSettings();\n        currentSeqSettings.videoDisplayFormat = sequence_default_timecode;\n        app.project.activeSequence.setSettings(currentSeqSettings);\n    }\n}\n\nfunction getTimecodeFormat() {\n    return app.project.activeSequence.getSettings().videoDisplayFormat;\n}\n\nfunction setTimecodeFormat(format) {\n    format = parseInt(format);\n    var seq = app.project.activeSequence;\n    if (seq) {\n        var currentSeqSettings = app.project.activeSequence.getSettings();\n        currentSeqSettings.videoDisplayFormat = format;\n        app.project.activeSequence.setSettings(currentSeqSettings);\n    }\n    return true;\n}\n\n// ============================================================================\n// SEQUENCE & PROJECT OPERATIONS\n// ============================================================================\n\nfunction getActiveSequence() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Safely get settings with fallbacks\n        var frameRate = null;\n        try {\n            var settings = seq.getSettings();\n            if (settings && settings.videoFrameRate) {\n                frameRate = settings.videoFrameRate.seconds;\n            }\n        } catch (settingsErr) {\n            $.writeln('[SPLICE] getActiveSequence: Failed to get settings: ' + settingsErr.message);\n        }\n\n        return JSON.stringify({\n            name: seq.name || \"Unknown\",\n            id: seq.sequenceID || null,\n            duration: seq.end || 0,\n            videoTrackCount: seq.videoTracks ? seq.videoTracks.numTracks : 0,\n            audioTrackCount: seq.audioTracks ? seq.audioTracks.numTracks : 0,\n            frameRate: frameRate,\n            width: seq.frameSizeHorizontal || 0,\n            height: seq.frameSizeVertical || 0\n        });\n    } catch (e) {\n        $.writeln('[SPLICE] getActiveSequence error: ' + e.message);\n        return JSON.stringify({ error: \"getActiveSequence failed: \" + e.message });\n    }\n}\n\nfunction getAllSequences() {\n    try {\n        if (!app || !app.project || !app.project.sequences) {\n            return JSON.stringify({ error: \"No project open\" });\n        }\n\n        var sequences = [];\n        var numSeqs = app.project.sequences.numSequences;\n\n        for (var i = 0; i < numSeqs; i++) {\n            var seq = app.project.sequences[i];\n            if (seq) {\n                sequences.push({\n                    name: seq.name || \"Unknown\",\n                    id: seq.sequenceID || null,\n                    index: i\n                });\n            }\n        }\n\n        return JSON.stringify(sequences);\n    } catch (e) {\n        $.writeln('[SPLICE] getAllSequences error: ' + e.message);\n        return JSON.stringify({ error: \"getAllSequences failed: \" + e.message });\n    }\n}\n\nfunction getSequenceSettings() {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    var settings = seq.getSettings();\n    return JSON.stringify({\n        frameRate: settings.videoFrameRate.seconds,\n        width: settings.videoFrameWidth,\n        height: settings.videoFrameHeight,\n        displayFormat: settings.videoDisplayFormat\n    });\n}\n\nfunction cloneSequence(newName) {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    try {\n        // Clone the sequence\n        seq.clone();\n\n        // Find the cloned sequence (last one with matching name pattern)\n        var clonedSeq = null;\n        for (var i = app.project.sequences.numSequences - 1; i >= 0; i--) {\n            var s = app.project.sequences[i];\n            if (s.name.indexOf(seq.name) === 0 && s.sequenceID !== seq.sequenceID) {\n                clonedSeq = s;\n                break;\n            }\n        }\n\n        if (clonedSeq && newName) {\n            clonedSeq.name = newName;\n        }\n\n        return JSON.stringify({\n            success: true,\n            sequenceId: clonedSeq ? clonedSeq.sequenceID : null,\n            name: clonedSeq ? clonedSeq.name : newName\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction createNewSequence(name) {\n    try {\n        app.project.createNewSequence(name);\n        var seq = app.project.activeSequence;\n        return JSON.stringify({\n            success: true,\n            sequenceId: seq.sequenceID,\n            name: seq.name\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction setActiveSequence(sequenceId) {\n    for (var i = 0; i < app.project.sequences.numSequences; i++) {\n        if (app.project.sequences[i].sequenceID === sequenceId) {\n            app.project.activeSequence = app.project.sequences[i];\n            return JSON.stringify({ success: true });\n        }\n    }\n    return JSON.stringify({ error: \"Sequence not found\" });\n}\n\n/**\n * Seek playhead to a specific time in seconds\n */\nfunction seekToTime(seconds) {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    try {\n        // Convert seconds to ticks\n        var ticks = seconds * TICKS_PER_SECOND;\n\n        // Create a Time object and set position\n        var playerPos = seq.getPlayerPosition();\n        playerPos.seconds = seconds;\n        seq.setPlayerPosition(playerPos.ticks.toString());\n\n        return JSON.stringify({ success: true, position: seconds });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n/**\n * Get current playhead position in seconds\n */\nfunction getPlayerPosition() {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    try {\n        var pos = seq.getPlayerPosition();\n        return JSON.stringify({\n            ticks: pos.ticks,\n            seconds: pos.seconds\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// RAZOR OPERATIONS\n// ============================================================================\n\nfunction razorSequenceAtFrames(frames) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for razor operation\" });\n    }\n    try {\n        frames = String(frames);\n        setTimecodeToFrames();\n        qe.project.getActiveSequence().razor(frames);\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: \"Razor failed: \" + e.message });\n    }\n}\n\nfunction razorSequenceAtSeconds(seconds) {\n    try {\n        var frames = parseInt(Math.round(seconds / app.project.activeSequence.getSettings().videoFrameRate.seconds)).toString();\n        return razorSequenceAtFrames(frames);\n    } catch (e) {\n        return JSON.stringify({ error: \"Razor at seconds failed: \" + e.message });\n    }\n}\n\nfunction razorSequenceAtFramesArray(silences_array) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for razor operation\" });\n    }\n    try {\n        setTimecodeToFrames();\n        silences_array = JSON.parse(silences_array);\n        var razorCount = 0;\n        for (var i = 0; i < silences_array.length; i++) {\n            for (var j = 0; j < silences_array[i].length; j++) {\n                var frames = String(silences_array[i][j]);\n                qe.project.getActiveSequence().razor(frames);\n                razorCount++;\n            }\n        }\n        return JSON.stringify({ success: true, razorCount: razorCount });\n    } catch (e) {\n        return JSON.stringify({ error: \"Razor array failed: \" + e.message });\n    }\n}\n\nfunction razorTrackAtFrames(trackType, trackIndex, frames) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for track razor\" });\n    }\n    try {\n        frames = String(frames);\n        setTimecodeToFrames();\n        if (trackType == \"video\") {\n            qe.project.getActiveSequence().getVideoTrackAt(trackIndex).razor(frames);\n        } else if (trackType == \"audio\") {\n            qe.project.getActiveSequence().getAudioTrackAt(trackIndex).razor(frames);\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: \"Track razor failed: \" + e.message });\n    }\n}\n\nfunction razorTrackAtSeconds(trackType, trackIndex, seconds) {\n    try {\n        var frames = parseInt(Math.round(seconds / app.project.activeSequence.getSettings().videoFrameRate.seconds)).toString();\n        return razorTrackAtFrames(trackType, trackIndex, frames);\n    } catch (e) {\n        return JSON.stringify({ error: \"Track razor at seconds failed: \" + e.message });\n    }\n}\n\n// ============================================================================\n// CLIP OPERATIONS\n// ============================================================================\n\n/**\n * Get currently selected clips in the timeline\n * @returns {string} JSON with selected clip data or error\n */\nfunction getSelectedClips() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var selection = seq.getSelection();\n        var clips = [];\n\n        for (var i = 0; i < selection.length; i++) {\n            var clip = selection[i];\n            clips.push({\n                index: i,\n                name: clip.name,\n                start: clip.start.seconds,\n                end: clip.end.seconds,\n                duration: clip.duration.seconds,\n                inPoint: clip.inPoint ? clip.inPoint.seconds : null,\n                outPoint: clip.outPoint ? clip.outPoint.seconds : null,\n                mediaPath: clip.projectItem ? clip.projectItem.getMediaPath() : null\n            });\n        }\n\n        $.writeln('[SPLICE] getSelectedClips: Found ' + clips.length + ' selected clips');\n        return JSON.stringify({\n            count: clips.length,\n            clips: clips\n        });\n    } catch (e) {\n        $.writeln('[SPLICE] getSelectedClips error: ' + e.message);\n        return JSON.stringify({ error: \"getSelectedClips failed: \" + e.message });\n    }\n}\n\nfunction getClipsInTrack(trackIndex, trackType) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var tracks = trackType === \"audio\" ? seq.audioTracks : seq.videoTracks;\n        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex + \" (max: \" + (tracks.numTracks - 1) + \")\" });\n        }\n\n        var clips = [];\n        var trackClips = tracks[trackIndex].clips;\n        for (var i = 0; i < trackClips.numItems; i++) {\n            var clip = trackClips[i];\n            clips.push({\n                index: i,\n                name: clip.name,\n                start: clip.start.seconds,\n                end: clip.end.seconds,\n                duration: clip.duration.seconds,\n                inPoint: clip.inPoint.seconds,\n                outPoint: clip.outPoint.seconds,\n                mediaPath: clip.projectItem ? clip.projectItem.getMediaPath() : null\n            });\n        }\n        return JSON.stringify(clips);\n    } catch (e) {\n        $.writeln('[SPLICE] getClipsInTrack error: ' + e.message);\n        return JSON.stringify({ error: \"getClipsInTrack failed: \" + e.message });\n    }\n}\n\nfunction getClipsInTrack_Timings_Seconds(trackIndex, trackType) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var tracks = trackType === \"audio\" ? seq.audioTracks : seq.videoTracks;\n        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex });\n        }\n\n        var clips = [];\n        var trackClips = tracks[trackIndex].clips;\n        for (var i = 0; i < trackClips.numItems; i++) {\n            clips.push([\n                trackClips[i].start.seconds,\n                trackClips[i].end.seconds\n            ]);\n        }\n        return JSON.stringify(clips);\n    } catch (e) {\n        $.writeln('[SPLICE] getClipsInTrack_Timings_Seconds error: ' + e.message);\n        return JSON.stringify({ error: \"getClipsInTrack_Timings_Seconds failed: \" + e.message });\n    }\n}\n\nfunction deleteClipsAtSilencePointsInTrack(silences, trackType, trackIndex) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Validate trackType\n        if (trackType !== \"video\" && trackType !== \"audio\") {\n            return JSON.stringify({ error: \"Invalid track type: \" + trackType });\n        }\n\n        // Parse silences JSON\n        var silencesArr;\n        try {\n            silencesArr = JSON.parse(silences);\n        } catch (parseErr) {\n            return JSON.stringify({ error: \"Invalid silences JSON: \" + parseErr.message });\n        }\n\n        // Get tracks and validate index\n        var tracks = trackType === \"video\" ? seq.videoTracks : seq.audioTracks;\n        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex + \" (max: \" + (tracks.numTracks - 1) + \")\" });\n        }\n\n        var clips = tracks[trackIndex].clips;\n        var deleted = 0;\n\n        // Iterate backwards to avoid index shifting (use numItems, not length)\n        for (var i = clips.numItems - 1; i >= 0; i--) {\n            var clip = clips[i];\n            var start = clip.start.seconds;\n            var end = clip.end.seconds;\n            var center = (start + end) / 2;\n\n            for (var j = 0; j < silencesArr.length; j++) {\n                var silence = silencesArr[j];\n                var silenceCenter = (silence[0] + silence[1]) / 2;\n                if (silenceCenter > start && silenceCenter < end) {\n                    clip.remove(false, false);\n                    deleted++;\n                    break;\n                }\n            }\n        }\n\n        $.writeln('[SPLICE] deleteClipsAtSilencePointsInTrack: Deleted ' + deleted + ' clips from ' + trackType + ' track ' + trackIndex);\n        return JSON.stringify({ deleted: deleted });\n    } catch (e) {\n        $.writeln('[SPLICE] deleteClipsAtSilencePointsInTrack error: ' + e.message);\n        return JSON.stringify({ error: \"deleteClipsAtSilencePointsInTrack failed: \" + e.message });\n    }\n}\n\nfunction makeRemainingClipsContiguousInTrack(silences, deltas, trackType, trackIndex) {\n    silences = JSON.parse(silences);\n    deltas = JSON.parse(deltas);\n\n    var clips;\n    if (trackType == \"video\") {\n        clips = app.project.activeSequence.videoTracks[trackIndex].clips;\n    } else if (trackType == \"audio\") {\n        clips = app.project.activeSequence.audioTracks[trackIndex].clips;\n    }\n\n    for (var i = 0; i < clips.length; i++) {\n        var clip = clips[i];\n        var end = clip.end.seconds;\n        var num_silences = -1;\n\n        for (var j = 0; j < silences.length; j++) {\n            if (end > silences[j][1]) {\n                num_silences++;\n            }\n        }\n\n        if (num_silences > -1 && num_silences < deltas.length) {\n            var delta = deltas[num_silences];\n            var t_start = clip.start;\n            t_start.seconds = t_start.seconds - delta;\n            clip.start = t_start;\n            var t_end = clip.end;\n            t_end.seconds = t_end.seconds - delta;\n            clip.end = t_end;\n        }\n    }\n    return JSON.stringify({ success: true });\n}\n\nfunction removeClipByIndex(trackType, trackIndex, clipIndex) {\n    try {\n        if (trackType == \"video\") {\n            app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex].remove(false, false);\n        } else if (trackType == \"audio\") {\n            app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex].remove(false, false);\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction setClipInOutPoints(trackType, trackIndex, clipIndex, inPoint, outPoint) {\n    try {\n        var clip;\n        if (trackType == \"video\") {\n            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n        } else if (trackType == \"audio\") {\n            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n        }\n\n        if (inPoint !== null) {\n            var inTime = new Time();\n            inTime.seconds = inPoint;\n            clip.inPoint = inTime;\n        }\n        if (outPoint !== null) {\n            var outTime = new Time();\n            outTime.seconds = outPoint;\n            clip.outPoint = outTime;\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction setClipStartEnd(trackType, trackIndex, clipIndex, startSeconds, endSeconds) {\n    try {\n        var clip;\n        if (trackType == \"video\") {\n            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n        } else if (trackType == \"audio\") {\n            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n        }\n\n        if (startSeconds !== null) {\n            var startTime = clip.start;\n            startTime.seconds = startSeconds;\n            clip.start = startTime;\n        }\n        if (endSeconds !== null) {\n            var endTime = clip.end;\n            endTime.seconds = endSeconds;\n            clip.end = endTime;\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// TRACK OPERATIONS\n// ============================================================================\n\nfunction getTrackNames(trackType) {\n    if (!isQEAvailable() && !enableQE()) {\n        // Fallback: use standard DOM\n        var ret = [];\n        try {\n            if (trackType == \"video\") {\n                for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n                    ret.push(\"V\" + (i + 1));\n                }\n            } else if (trackType == \"audio\") {\n                for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n                    ret.push(\"A\" + (i + 1));\n                }\n            }\n        } catch (e) {\n            return JSON.stringify({ error: \"Failed to get track names: \" + e.message });\n        }\n        return JSON.stringify(ret);\n    }\n\n    try {\n        var ret = [];\n        if (trackType == \"video\") {\n            for (var i = 0; i < qe.project.getActiveSequence().numVideoTracks; i++) {\n                ret.push(qe.project.getActiveSequence().getVideoTrackAt(i).name);\n            }\n        } else if (trackType == \"audio\") {\n            for (var i = 0; i < qe.project.getActiveSequence().numAudioTracks; i++) {\n                ret.push(qe.project.getActiveSequence().getAudioTrackAt(i).name);\n            }\n        }\n        return JSON.stringify(ret);\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to get track names: \" + e.message });\n    }\n}\n\nfunction getNumTracks(trackType) {\n    try {\n        if (trackType == \"video\") {\n            return app.project.activeSequence.videoTracks.numTracks;\n        } else if (trackType == \"audio\") {\n            return app.project.activeSequence.audioTracks.numTracks;\n        }\n        return 0;\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to get track count: \" + e.message });\n    }\n}\n\nfunction addVideoTrack() {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for adding tracks\" });\n    }\n    try {\n        var trackId = qe.project.getActiveSequence().numVideoTracks;\n        qe.project.getActiveSequence().addTracks(1, trackId, 0, 0);\n        return JSON.stringify({ success: true, trackId: trackId });\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to add video track: \" + e.message });\n    }\n}\n\nfunction addAudioTrack() {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for adding tracks\" });\n    }\n    try {\n        var trackId = qe.project.getActiveSequence().numAudioTracks;\n        qe.project.getActiveSequence().addTracks(0, 0, 1, 1, trackId);\n        return JSON.stringify({ success: true, trackId: trackId });\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to add audio track: \" + e.message });\n    }\n}\n\nfunction removeVideoTrack(trackIndex) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for removing tracks\" });\n    }\n    try {\n        qe.project.getActiveSequence().removeVideoTrack(trackIndex);\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to remove video track: \" + e.message });\n    }\n}\n\nfunction removeAudioTrack(trackIndex) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for removing tracks\" });\n    }\n    try {\n        qe.project.getActiveSequence().removeAudioTrack(trackIndex);\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to remove audio track: \" + e.message });\n    }\n}\n\n// ============================================================================\n// MUTE STATE\n// ============================================================================\n\nfunction getMuteState() {\n    var mute_state_video = [];\n    for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n        mute_state_video.push(app.project.activeSequence.videoTracks[i].isMuted());\n    }\n    var mute_state_audio = [];\n    for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n        mute_state_audio.push(app.project.activeSequence.audioTracks[i].isMuted());\n    }\n    return JSON.stringify({ audio: mute_state_audio, video: mute_state_video });\n}\n\nfunction setMuteState(mute_state) {\n    mute_state = JSON.parse(mute_state);\n    for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n        if (i < mute_state.video.length) {\n            app.project.activeSequence.videoTracks[i].setMute(mute_state.video[i]);\n        }\n    }\n    for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n        if (i < mute_state.audio.length) {\n            app.project.activeSequence.audioTracks[i].setMute(mute_state.audio[i]);\n        }\n    }\n    return true;\n}\n\n// ============================================================================\n// PROJECT ITEM OPERATIONS\n// ============================================================================\n\nfunction findItemByName(bin, name) {\n    for (var i = 0; i < bin.children.numItems; i++) {\n        if (bin.children[i].name === name) {\n            return bin.children[i];\n        }\n        if (bin.children[i].children !== undefined) {\n            var item = findItemByName(bin.children[i], name);\n            if (item) return item;\n        }\n    }\n    return null;\n}\n\nfunction findItemByPath(bin, path) {\n    for (var i = 0; i < bin.children.numItems; i++) {\n        var item = bin.children[i];\n        if (item.getMediaPath && item.getMediaPath() === path) {\n            return item;\n        }\n        if (item.children !== undefined) {\n            var found = findItemByPath(item, path);\n            if (found) return found;\n        }\n    }\n    return null;\n}\n\nfunction importFile(filePath) {\n    try {\n        var success = app.project.importFiles([filePath], true, app.project.rootItem, false);\n        if (success) {\n            // Find the imported item\n            var item = findItemByPath(app.project.rootItem, filePath);\n            return JSON.stringify({\n                success: true,\n                nodeId: item ? item.nodeId : null\n            });\n        }\n        return JSON.stringify({ error: \"Import failed\" });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction getSpliceBin() {\n    var rootItemChildren = app.project.rootItem.children;\n    var spliceBin = null;\n\n    for (var i = 0; i < rootItemChildren.numItems; i++) {\n        if (rootItemChildren[i].name === \"SPLICE\" && rootItemChildren[i].type === 2) {\n            spliceBin = rootItemChildren[i];\n            break;\n        }\n    }\n\n    if (!spliceBin) {\n        app.project.rootItem.createBin(\"SPLICE\");\n        return getSpliceBin();\n    }\n\n    return spliceBin;\n}\n\nfunction getAllProjectItems() {\n    var items = [];\n\n    function collectItems(bin, path) {\n        for (var i = 0; i < bin.children.numItems; i++) {\n            var item = bin.children[i];\n            var itemPath = path + \"/\" + item.name;\n\n            items.push({\n                nodeId: item.nodeId,\n                name: item.name,\n                type: item.type,\n                treePath: itemPath,\n                mediaPath: item.getMediaPath ? item.getMediaPath() : null\n            });\n\n            if (item.children !== undefined && item.type === 2) {\n                collectItems(item, itemPath);\n            }\n        }\n    }\n\n    collectItems(app.project.rootItem, \"\");\n    return JSON.stringify(items);\n}\n\n// ============================================================================\n// CLIP INSERTION\n// ============================================================================\n\nfunction insertClipAtTime(projectItemNodeId, trackIndex, startSeconds, trackType) {\n    try {\n        var item = findItemByNodeId(app.project.rootItem, projectItemNodeId);\n        if (!item) {\n            return JSON.stringify({ error: \"Project item not found\" });\n        }\n\n        var targetTime = new Time();\n        targetTime.seconds = startSeconds;\n\n        if (trackType === \"video\") {\n            app.project.activeSequence.videoTracks[trackIndex].insertClip(item, targetTime);\n        } else if (trackType === \"audio\") {\n            app.project.activeSequence.audioTracks[trackIndex].insertClip(item, targetTime);\n        }\n\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction findItemByNodeId(bin, nodeId) {\n    for (var i = 0; i < bin.children.numItems; i++) {\n        if (bin.children[i].nodeId === nodeId) {\n            return bin.children[i];\n        }\n        if (bin.children[i].children !== undefined) {\n            var found = findItemByNodeId(bin.children[i], nodeId);\n            if (found) return found;\n        }\n    }\n    return null;\n}\n\n// ============================================================================\n// MARKER OPERATIONS\n// ============================================================================\n\nfunction createMarker(timeSeconds, name, duration, comments, colorIndex) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var marker = markers.createMarker(timeSeconds);\n\n        if (name) marker.name = name;\n        if (comments) marker.comments = comments;\n        if (colorIndex !== undefined) marker.setColorByIndex(colorIndex);\n        if (duration && duration > 0) {\n            // Set marker end time properly using a Time object\n            var endTime = new Time();\n            endTime.seconds = marker.start.seconds + duration;\n            marker.end = endTime;\n        }\n\n        return JSON.stringify({\n            success: true,\n            guid: marker.guid\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction getMarkers() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var result = [];\n\n        for (var i = 0; i < markers.numMarkers; i++) {\n            var marker = markers[i];\n            result.push({\n                guid: marker.guid,\n                name: marker.name,\n                comments: marker.comments,\n                start: marker.start.seconds,\n                end: marker.end.seconds,\n                type: marker.type\n            });\n        }\n\n        return JSON.stringify(result);\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction deleteMarker(markerGuid) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        for (var i = 0; i < markers.numMarkers; i++) {\n            if (markers[i].guid === markerGuid) {\n                markers[i].remove();\n                return JSON.stringify({ success: true });\n            }\n        }\n        return JSON.stringify({ error: \"Marker not found\" });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction deleteAllMarkers() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var count = markers.numMarkers;\n\n        // Delete from end to beginning to avoid index shifting\n        for (var i = count - 1; i >= 0; i--) {\n            markers[i].remove();\n        }\n\n        return JSON.stringify({ success: true, deleted: count });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction deleteMarkersByName(namePattern) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var deleted = 0;\n\n        for (var i = markers.numMarkers - 1; i >= 0; i--) {\n            if (markers[i].name && markers[i].name.indexOf(namePattern) !== -1) {\n                markers[i].remove();\n                deleted++;\n            }\n        }\n\n        return JSON.stringify({ success: true, deleted: deleted });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// COLOR LABEL OPERATIONS\n// ============================================================================\n\nfunction setClipColorLabel(trackType, trackIndex, clipIndex, colorIndex) {\n    try {\n        var clip;\n        if (trackType == \"video\") {\n            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n        } else if (trackType == \"audio\") {\n            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n        }\n\n        if (clip && clip.projectItem) {\n            clip.projectItem.setColorLabel(colorIndex);\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction setProjectItemColorLabel(nodeId, colorIndex) {\n    try {\n        var item = findItemByNodeId(app.project.rootItem, nodeId);\n        if (item) {\n            item.setColorLabel(colorIndex);\n            return JSON.stringify({ success: true });\n        }\n        return JSON.stringify({ error: \"Item not found\" });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// SEQUENCE BUILDING (CORE v3.5 FUNCTIONALITY)\n// ============================================================================\n\nfunction buildSequenceFromCutList(cutListJson) {\n    try {\n        var cutList = JSON.parse(cutListJson);\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Clone the sequence\n        var newSequenceName = seq.name + \"_SPLICE\";\n        seq.clone();\n\n        // Find the cloned sequence\n        var newSeq = null;\n        for (var i = app.project.sequences.numSequences - 1; i >= 0; i--) {\n            var s = app.project.sequences[i];\n            if (s.name.indexOf(seq.name) === 0 && s.sequenceID !== seq.sequenceID) {\n                newSeq = s;\n                break;\n            }\n        }\n\n        if (!newSeq) {\n            return JSON.stringify({ error: \"Failed to clone sequence\" });\n        }\n\n        newSeq.name = newSequenceName;\n        app.project.activeSequence = newSeq;\n\n        // Clear all clips from the new sequence\n        clearSequence();\n\n        // Insert segments\n        var currentPosition = 0;\n        var stats = {\n            segmentsInserted: 0,\n            totalDuration: 0\n        };\n\n        for (var i = 0; i < cutList.segments.length; i++) {\n            var segment = cutList.segments[i];\n\n            // Find the source project item\n            var sourceItem = null;\n            if (segment.sourcePath) {\n                sourceItem = findItemByPath(app.project.rootItem, segment.sourcePath);\n            }\n            if (!sourceItem && segment.sourceName) {\n                sourceItem = findItemByName(app.project.rootItem, segment.sourceName);\n            }\n\n            if (!sourceItem) continue;\n\n            // Set color label\n            if (segment.colorHint && SEGMENT_COLORS[segment.colorHint]) {\n                sourceItem.setColorLabel(SEGMENT_COLORS[segment.colorHint]);\n            } else if (segment.type && SEGMENT_COLORS[segment.type]) {\n                sourceItem.setColorLabel(SEGMENT_COLORS[segment.type]);\n            }\n\n            // Insert clip at current position\n            var targetTime = new Time();\n            targetTime.seconds = currentPosition;\n\n            newSeq.videoTracks[0].insertClip(sourceItem, targetTime);\n\n            // Set in/out points\n            var clipDuration = segment.outPoint - segment.inPoint;\n            var videoClips = newSeq.videoTracks[0].clips;\n            var insertedClip = videoClips[videoClips.numItems - 1];\n\n            if (insertedClip) {\n                var inTime = new Time();\n                inTime.seconds = segment.inPoint;\n                insertedClip.inPoint = inTime;\n\n                var outTime = new Time();\n                outTime.seconds = segment.outPoint;\n                insertedClip.outPoint = outTime;\n\n                // Set clip name if takeLabel provided\n                if (segment.takeLabel) {\n                    insertedClip.name = segment.takeLabel;\n                }\n            }\n\n            currentPosition += clipDuration;\n            stats.segmentsInserted++;\n            stats.totalDuration += clipDuration;\n        }\n\n        return JSON.stringify({\n            success: true,\n            sequenceName: newSequenceName,\n            stats: stats\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction clearSequence() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var removed = { video: 0, audio: 0 };\n\n        // Remove all video clips\n        for (var t = 0; t < seq.videoTracks.numTracks; t++) {\n            var clips = seq.videoTracks[t].clips;\n            for (var i = clips.numItems - 1; i >= 0; i--) {\n                clips[i].remove(false, false);\n                removed.video++;\n            }\n        }\n\n        // Remove all audio clips\n        for (var t = 0; t < seq.audioTracks.numTracks; t++) {\n            var clips = seq.audioTracks[t].clips;\n            for (var i = clips.numItems - 1; i >= 0; i--) {\n                clips[i].remove(false, false);\n                removed.audio++;\n            }\n        }\n\n        $.writeln('[SPLICE] clearSequence: Removed ' + removed.video + ' video clips, ' + removed.audio + ' audio clips');\n        return JSON.stringify({ success: true, removed: removed });\n    } catch (e) {\n        $.writeln('[SPLICE] clearSequence error: ' + e.message);\n        return JSON.stringify({ error: \"Clear sequence failed: \" + e.message });\n    }\n}\n\n// ============================================================================\n// WORK AREA\n// ============================================================================\n\nfunction getWorkArea() {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    return JSON.stringify({\n        inPoint: seq.getInPoint(),\n        outPoint: seq.getOutPoint()\n    });\n}\n\nfunction setWorkArea(inPoint, outPoint) {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    seq.setInPoint(inPoint);\n    seq.setOutPoint(outPoint);\n    return JSON.stringify({ success: true });\n}\n\n// ============================================================================\n// AUDIO EXPORT\n// ============================================================================\n\nfunction exportSequenceAudio(outputPath, inPoint, outPoint) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Use the AME (Adobe Media Encoder) for export\n        var encoder = app.encoder;\n        if (!encoder) {\n            return JSON.stringify({ error: \"Media Encoder not available\" });\n        }\n\n        // Create export preset for WAV\n        var presetPath = encoder.getDefaultPresetPath();\n\n        // Queue the export\n        encoder.encodeSequence(\n            seq,\n            outputPath,\n            presetPath,\n            0, // WorkAreaType: 0 = entire, 1 = work area\n            false // removeOnCompletion\n        );\n\n        return JSON.stringify({ success: true, outputPath: outputPath });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n/**\n * Export sequence audio for SPLICE analysis\n * Uses AME to export WAV audio to temp folder\n * @returns {Object} { success, outputPath } or { error }\n */\nfunction exportSequenceAudioForAnalysis() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Generate temp file path\n        var tempFolder = Folder.temp.fsName;\n        var timestamp = new Date().getTime();\n        var outputPath = tempFolder + \"/splice_audio_\" + timestamp + \".wav\";\n\n        // Check if we have audio tracks with content\n        var hasAudio = false;\n        for (var i = 0; i < seq.audioTracks.numTracks; i++) {\n            if (seq.audioTracks[i].clips.numItems > 0) {\n                hasAudio = true;\n                break;\n            }\n        }\n\n        if (!hasAudio) {\n            return JSON.stringify({ error: \"Sequence has no audio clips\" });\n        }\n\n        // Use AME for export if available\n        if (app.encoder && app.encoder.encodeSequence) {\n            // Find audio-only preset or use default\n            var presetPath = null;\n            try {\n                // Try to find WAV preset in common locations\n                var presetFolders = [\n                    Folder.appData.fsName + \"/Adobe/Common/AME/15.0/Presets\",\n                    Folder.appData.fsName + \"/Adobe/Common/AME/14.0/Presets\",\n                    app.path + \"/MediaIO/systempresets/58534430_4d756c74-6962697400000000/WAV 48kHz.epr\"\n                ];\n\n                for (var i = 0; i < presetFolders.length; i++) {\n                    var presetFile = new File(presetFolders[i]);\n                    if (presetFile.exists) {\n                        presetPath = presetFile.fsName;\n                        break;\n                    }\n                }\n\n                // Fall back to default preset\n                if (!presetPath) {\n                    presetPath = app.encoder.getDefaultPresetPath();\n                }\n            } catch (e) {\n                presetPath = app.encoder.getDefaultPresetPath();\n            }\n\n            // Start the encode\n            var success = app.encoder.encodeSequence(\n                seq,\n                outputPath,\n                presetPath,\n                0, // WorkAreaType: 0 = entire sequence\n                false // removeOnCompletion\n            );\n\n            if (success) {\n                return JSON.stringify({ success: true, outputPath: outputPath, method: \"ame\" });\n            }\n        }\n\n        // Fallback: Try to get the source audio path from first clip\n        return getFirstClipAudioPath();\n\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n/**\n * Get the audio/video file path from the first clip in the timeline\n * Used as fallback when AME export is not available\n * @returns {Object} { success, path } or { error }\n */\nfunction getFirstClipAudioPath() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // First try audio tracks\n        for (var i = 0; i < seq.audioTracks.numTracks; i++) {\n            var track = seq.audioTracks[i];\n            if (track.clips.numItems > 0) {\n                var clip = track.clips[0];\n                if (clip.projectItem && clip.projectItem.getMediaPath) {\n                    var mediaPath = clip.projectItem.getMediaPath();\n                    if (mediaPath && mediaPath.length > 0) {\n                        return JSON.stringify({ success: true, path: mediaPath, method: \"audio_track\" });\n                    }\n                }\n            }\n        }\n\n        // Fall back to video tracks (which may have linked audio)\n        for (var i = 0; i < seq.videoTracks.numTracks; i++) {\n            var track = seq.videoTracks[i];\n            if (track.clips.numItems > 0) {\n                var clip = track.clips[0];\n                if (clip.projectItem && clip.projectItem.getMediaPath) {\n                    var mediaPath = clip.projectItem.getMediaPath();\n                    if (mediaPath && mediaPath.length > 0) {\n                        return JSON.stringify({ success: true, path: mediaPath, method: \"video_track\" });\n                    }\n                }\n            }\n        }\n\n        return JSON.stringify({ error: \"No clips with media paths found in sequence\" });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\nfunction moveClipByNTracks(currentTrackId, clipStartTime, nTracksToMove, trackType) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for moving clips between tracks\" });\n    }\n\n    try {\n        var accuracy = 3;\n        var search_start_time = clipStartTime.toFixed(accuracy);\n\n        if (trackType == \"audio\") {\n            var numClipsInTrack = qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).numItems;\n            for (var j = 0; j < numClipsInTrack; j++) {\n                if (qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).getItemAt(j).start.secs.toFixed(accuracy) == search_start_time) {\n                    qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).getItemAt(j).moveToTrack(0, nTracksToMove, \"0\");\n                    return JSON.stringify({ success: true });\n                }\n            }\n        } else if (trackType == \"video\") {\n            var numClipsInTrack = qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).numItems;\n            for (var j = 0; j < numClipsInTrack; j++) {\n                if (qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).getItemAt(j).start.secs.toFixed(accuracy) == search_start_time) {\n                    qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).getItemAt(j).moveToTrack(nTracksToMove, 0, \"0\");\n                    return JSON.stringify({ success: true });\n                }\n            }\n        }\n        return JSON.stringify({ error: \"Clip not found at specified time\" });\n    } catch (e) {\n        return JSON.stringify({ error: \"Move clip failed: \" + e.message });\n    }\n}\n\nfunction linkIdenticalClipsInTracks(videoTrackIndex, audioTrackIndex) {\n    var selected_clips = app.project.activeSequence.getSelection();\n    for (var i = 0; i < selected_clips.length; i++) {\n        selected_clips[i].setSelected(false, false);\n    }\n\n    var video_clips = app.project.activeSequence.videoTracks[videoTrackIndex].clips;\n    var audio_clips = app.project.activeSequence.audioTracks[audioTrackIndex].clips;\n\n    for (var i = 0; i < video_clips.numItems; i++) {\n        var video_clip = video_clips[i];\n        var video_start = video_clip.start.seconds;\n\n        for (var j = 0; j < audio_clips.numItems; j++) {\n            var audio_clip = audio_clips[j];\n            var audio_start = audio_clip.start.seconds;\n\n            if (Math.abs(video_start - audio_start) < time_tolerance) {\n                video_clip.setSelected(true, false);\n                audio_clip.setSelected(true, false);\n                app.project.activeSequence.linkSelection();\n                video_clip.setSelected(false, false);\n                audio_clip.setSelected(false, false);\n                break;\n            }\n        }\n    }\n    return true;\n}\n\n// ============================================================================\n// ZOOM OPERATIONS (Phase 3)\n// ============================================================================\n\nfunction addZoomMarker(startSeconds, scale, duration, easing) {\n    try {\n        var name = \"ZOOM: \" + scale + \"%\";\n        var comments = \"Duration: \" + duration + \"s | Easing: \" + (easing || \"ease-in-out\");\n        return createMarker(startSeconds, name, duration, comments, COLOR_LABELS.YELLOW);\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// CHAPTER OPERATIONS (Phase 3)\n// ============================================================================\n\nfunction addChapterMarker(timeSeconds, title, description) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var marker = markers.createMarker(timeSeconds);\n\n        marker.name = title;\n        if (description) marker.comments = description;\n        marker.setColorByIndex(COLOR_LABELS.BLUE);\n        marker.setTypeAsChapter();\n\n        return JSON.stringify({\n            success: true,\n            guid: marker.guid\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction getChapterMarkers() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var chapters = [];\n\n        for (var i = 0; i < markers.numMarkers; i++) {\n            var marker = markers[i];\n            if (marker.type === \"Chapter\") {\n                chapters.push({\n                    guid: marker.guid,\n                    name: marker.name,\n                    comments: marker.comments,\n                    start: marker.start.seconds\n                });\n            }\n        }\n\n        return JSON.stringify(chapters);\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// UNDO OPERATIONS\n// ============================================================================\n\nfunction undo() {\n    app.project.undo();\n    return true;\n}\n\nfunction redo() {\n    app.project.redo();\n    return true;\n}\n\n// ============================================================================\n// DEBUG / LOGGING\n// ============================================================================\n\nfunction log(message) {\n    $.writeln(\"[SPLICE] \" + message);\n}\n\nfunction getDebugInfo() {\n    return JSON.stringify({\n        version: SPLICE_VERSION,\n        hasActiveSequence: app.project.activeSequence ? true : false,\n        sequenceName: app.project.activeSequence ? app.project.activeSequence.name : null,\n        numSequences: app.project.sequences.numSequences,\n        numProjectItems: app.project.rootItem.children.numItems\n    });\n}\n\n// NOTE: Do NOT auto-initialize on load - CEP will call initialise() explicitly\n// when the panel is ready. Auto-initialization can fail if no project is open.\n$.writeln('[SPLICE] hostScript.jsx loaded - version ' + SPLICE_VERSION);\n","numLines":1881,"startLine":1,"totalLines":1881}}}
{"parentUuid":"8395d273-205c-4783-80a0-e2d82a48c751","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a7e7304","slug":"fizzy-hatching-flame","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Vh81GLRqqEseX1eGswFu3L","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me analyze the sequence selection logic to find the root cause of the issue.\n\n## Bug Summary\nUser cannot select a sequence in the SPLICE CEP panel - the \"Please open a sequence in the Timeline first\" error appears even when a sequence is selected/open.\n\n## Root Cause Analysis\n\nAfter examining both files, I've identified **multiple potential root causes**:\n\n### PRIMARY ROOT CAUSE: Event Listener Race Condition\n\n**File:** `splice-cep/panel/js/main.js:321-339`\n\n**The bug:** The `SelectionChanged` event listener has a **200ms debounce** that calls `checkSequenceOpen(0, 0)` with **zero retries**, which will immediately return `false` if the sequence isn't fully loaded yet. This means when a user clicks on a sequence:\n\n1. The `SelectionChanged` event fires\n2. After 200ms debounce, `checkSequenceOpen(0, 0)` is called (NO RETRIES)\n3. If Premiere Pro's internal state hasn't updated yet (common during selection changes), it returns `false`\n4. The panel never updates `window.spliceState.activeSequence`\n5. When the user clicks GO, `runDetection()` calls `checkSequenceOpen()` with default retries (2 attempts)\n6. But by this time, there's a mismatch between what the user sees and what the panel knows\n\n**The smoking gun:** Line 328 in main.js:\n```javascript\nconst hasSequence = await checkSequenceOpen(0, 0); // Quick check, no retries\n```\n\nThis \"quick check\" defeats the purpose of the retry logic and creates a race condition where the panel misses sequence activation events.\n\n### SECONDARY ROOT CAUSE: No Fallback to Direct Check\n\n**File:** `splice-cep/jsx/hostScript.jsx:296-376`\n\n**The bug:** The `checkSequenceOpen()` function only checks `app.project.activeSequence` and QE DOM, but **never validates if a sequence is SELECTED but not yet ACTIVE**. In Premiere Pro:\n\n- **Selected sequence** = User clicked on it in Project Panel\n- **Active sequence** = Sequence is open in Timeline and has focus\n\nThe current logic at line 335-345:\n```javascript\nif (app.project.activeSequence) {\n    // Found active sequence\n    return true;\n}\n```\n\nThis misses the case where a user has **selected** a sequence but hasn't double-clicked to open it in the Timeline yet.\n\n### TERTIARY ROOT CAUSE: Silent Failure in Event Handlers\n\n**File:** `splice-cep/panel/js/main.js:299-311, 314-318`\n\n**The bug:** The event listeners have `try/catch` blocks that **silently swallow errors**:\n\n```javascript\n} catch (e) {\n    console.warn('[SPLICE] Failed to get sequence info on activation:', e.message);\n}\n```\n\nand\n\n```javascript\n} catch (e) {\n    // Ignore errors during selection change - it's just for proactive updates\n}\n```\n\nThis means if there's a CEP communication failure, the user never knows why their sequence selection didn't work.\n\n## Execution Trace\n\n```\nUser selects sequence in Premiere Pro\n    ↓\ncom.adobe.csxs.events.SelectionChanged fires (main.js:321)\n    ↓\nDebounced by 200ms (line 326)\n    ↓\ncheckSequenceOpen(0, 0) called with NO RETRIES (line 328)\n    ↓ [ROOT CAUSE #1]\nReturns false immediately because sequence not yet active\n    ↓\nwindow.spliceState.activeSequence remains null (line 329 condition fails)\n    ↓\nUser clicks GO button\n    ↓\nrunDetection() → checkSequenceOpen() with 2 retries (line 737)\n    ↓ [ROOT CAUSE #2]\nStill returns false if user only SELECTED but didn't ACTIVATE sequence\n    ↓\nError shown: \"Please open a sequence in the Timeline first\" (line 745)\n```\n\n## Fix\n\n**File:** `splice-cep/panel/js/main.js:321-339`\n\n```diff\n// Listen for project item selection changes (includes sequences)\njsx.cs.addEventListener('com.adobe.csxs.events.SelectionChanged', async () => {\n    // Debounce rapid selection changes\n    if (window._selectionChangeTimeout) {\n        clearTimeout(window._selectionChangeTimeout);\n    }\n    window._selectionChangeTimeout = setTimeout(async () => {\n        try {\n-           const hasSequence = await checkSequenceOpen(0, 0); // Quick check, no retries\n+           // FIX: Use retries to handle timing issues when sequence is being activated\n+           const hasSequence = await checkSequenceOpen(2, 300); // Same retry logic as GO button\n            if (hasSequence && !window.spliceState.activeSequence) {\n                const seqInfo = await jsx.call('getActiveSequence');\n                if (seqInfo && !seqInfo.error) {\n                    window.spliceState.activeSequence = seqInfo;\n+                   setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));\n                    debugLog('Sequence detected via selection change:', seqInfo.name);\n                }\n            }\n        } catch (e) {\n-           // Ignore errors during selection change - it's just for proactive updates\n+           // FIX: Log errors so users can diagnose issues\n+           console.warn('[SPLICE] Selection change handler error:', e.message);\n+           debugLog('Selection change failed:', e.message);\n        }\n-   }, 200);\n+   }, 500); // FIX: Increase debounce to 500ms to allow Premiere Pro state to settle\n});\n```\n\n**Reasoning:**\n1. **Increase retry count from 0 to 2**: Matches the retry logic used by the GO button, giving Premiere Pro time to update its internal state\n2. **Increase debounce from 200ms to 500ms**: Selection events can fire rapidly; 500ms ensures the sequence is fully activated before checking\n3. **Log errors instead of ignoring them**: Helps users and developers diagnose CEP communication issues\n4. **Update status bar on success**: Provides visual feedback that the sequence was detected\n\n## Alternative Fix (More Robust)\n\n**File:** `splice-cep/jsx/hostScript.jsx:296-376`\n\nAdd a check for **selected but not active** sequences:\n\n```diff\nfunction checkSequenceOpen() {\n    try {\n        $.writeln('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC START ==========');\n        \n        // ... existing checks ...\n        \n        // Primary check: Standard DOM - Check for activeSequence\n        $.writeln('[SPLICE] checkSequenceOpen: Checking app.project.activeSequence...');\n        if (app.project.activeSequence) {\n            // ... existing success logic ...\n            return true;\n        }\n        $.writeln('[SPLICE] checkSequenceOpen: app.project.activeSequence is null/undefined');\n\n+       // NEW: Check if a sequence is selected (even if not active in Timeline)\n+       $.writeln('[SPLICE] checkSequenceOpen: Checking for selected sequences...');\n+       try {\n+           var selection = app.project.getSelection();\n+           if (selection && selection.length > 0) {\n+               for (var i = 0; i < selection.length; i++) {\n+                   if (selection[i].type === 4) { // Type 4 = Sequence\n+                       $.writeln('[SPLICE] checkSequenceOpen: Found SELECTED sequence: ' + selection[i].name);\n+                       $.writeln('[SPLICE] checkSequenceOpen: (Not active in Timeline - user needs to double-click)');\n+                       return false; // Return false but log helpful message\n+                   }\n+               }\n+           }\n+       } catch (selErr) {\n+           $.writeln('[SPLICE] checkSequenceOpen: Selection check failed: ' + selErr.message);\n+       }\n\n        // Fallback: Try QE DOM\n        // ... existing fallback logic ...\n    } catch (e) {\n        // ... existing error handling ...\n    }\n}\n```\n\n## Regression Test\n\nAdd to test suite to prevent recurrence:\n\n```javascript\n// Test: Sequence selection timing\ntest('handles rapid sequence selection changes', async () => {\n    // Simulate rapid selection events\n    for (let i = 0; i < 5; i++) {\n        jsx.cs.dispatchEvent(new CSEvent('com.adobe.csxs.events.SelectionChanged'));\n    }\n    \n    // Wait for debounce + retries (500ms + 2*300ms = 1100ms)\n    await new Promise(resolve => setTimeout(resolve, 1200));\n    \n    // Check that final state is correct\n    expect(window.spliceState.activeSequence).not.toBeNull();\n});\n\n// Test: Selected vs Active sequence\ntest('distinguishes between selected and active sequence', async () => {\n    // Select sequence (but don't activate in Timeline)\n    mockPremiere.selectSequence('Test Sequence');\n    \n    const hasSequence = await checkSequenceOpen();\n    expect(hasSequence).toBe(false); // Should return false until activated\n    \n    // Now activate in Timeline\n    mockPremiere.activateSequence('Test Sequence');\n    \n    const hasSequenceAfter = await checkSequenceOpen();\n    expect(hasSequenceAfter).toBe(true); // Should return true after activation\n});\n```\n\n## Prevention\n\n**Guard against future timing issues:**\n1. Always use retry logic for Premiere Pro state checks (never 0 retries)\n2. Increase debounce timeouts for user-initiated events (300-500ms minimum)\n3. Never silently ignore errors in event handlers - always log for diagnostics\n4. Add status bar feedback for all state changes so users know what's happening\n\n**Red flags that caused this bug:**\n- \"Quick check, no retries\" comment on line 328 - optimization that defeated correctness\n- Empty catch block with \"just ignore\" comment on line 337 - hidden failures\n- 200ms debounce too aggressive for ExtendScript communication latency\n- No differentiation between \"sequence selected\" vs \"sequence active in Timeline\"\n\nThe root cause is **premature optimization** - the \"quick check\" without retries was added to avoid delays, but it introduced a race condition that makes sequence selection unreliable. The fix is to trust the retry logic and give Premiere Pro enough time to settle its internal state."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":52656,"cache_read_input_tokens":29104,"cache_creation":{"ephemeral_5m_input_tokens":52656,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3EVM6eKx6mST72S38pB","type":"assistant","uuid":"a5250f6c-79b8-4cf7-af87-a6ec65624152","timestamp":"2026-01-12T09:18:41.879Z"}
