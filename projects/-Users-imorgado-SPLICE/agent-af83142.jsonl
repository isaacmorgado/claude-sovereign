{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":"Verify the SPLICE backend API integration with the CEP panel.\n\n1. Read the CEP config to understand API endpoints:\n- /Users/imorgado/SPLICE/splice-cep/panel/js/config.js\n\n2. Read key backend files:\n- /Users/imorgado/SPLICE/splice-backend/server.js\n- /Users/imorgado/SPLICE/splice-backend/middleware/auth.js\n- /Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js\n\n3. Verify API endpoints used by CEP:\n- POST /auth/login - authentication\n- POST /auth/logout - logout\n- POST /auth/refresh - token refresh\n- GET /billing/credits - credit balance\n- POST /detect/* - detection endpoints\n- POST /music/* - music generation\n\n4. Verify middleware chain:\n- CSRF protection\n- JWT authentication\n- Rate limiting (with Redis fix)\n- Input validation\n\n5. Check that CEP panel properly:\n- Sends Authorization header with JWT\n- Handles token refresh\n- Shows appropriate error messages\n- Uses correct API URL (production vs dev)\n\nReturn a verification report on API integration status."},"uuid":"907fc202-9c62-48f3-957a-5aa5edd728ab","timestamp":"2026-01-11T23:55:35.904Z"}
{"parentUuid":"907fc202-9c62-48f3-957a-5aa5edd728ab","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QVFMJBCgqUvKydjpNUPbSg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016VyFxF8rLohShf6S9v4WYD","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":8106,"cache_read_input_tokens":19775,"cache_creation":{"ephemeral_5m_input_tokens":8106,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2Vcm7TVD22isLYizanC","type":"assistant","uuid":"193d964c-654f-4c65-9659-33e0bd4d869e","timestamp":"2026-01-11T23:55:39.066Z"}
{"parentUuid":"193d964c-654f-4c65-9659-33e0bd4d869e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QVFMJBCgqUvKydjpNUPbSg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KSFKNUxkd8M2gJFybcRM21","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":8106,"cache_read_input_tokens":19775,"cache_creation":{"ephemeral_5m_input_tokens":8106,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2Vcm7TVD22isLYizanC","type":"assistant","uuid":"3062e9e3-25fb-4776-bb58-779d4be2e84d","timestamp":"2026-01-11T23:55:39.421Z"}
{"parentUuid":"3062e9e3-25fb-4776-bb58-779d4be2e84d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QVFMJBCgqUvKydjpNUPbSg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FwURdu6g9pJkAnKerLBiN5","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":8106,"cache_read_input_tokens":19775,"cache_creation":{"ephemeral_5m_input_tokens":8106,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2Vcm7TVD22isLYizanC","type":"assistant","uuid":"7b9a2546-ec00-434b-967f-89a154baeb9e","timestamp":"2026-01-11T23:55:39.800Z"}
{"parentUuid":"7b9a2546-ec00-434b-967f-89a154baeb9e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QVFMJBCgqUvKydjpNUPbSg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RfvAEgS1hxHPrwPSdi2bWF","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":8106,"cache_read_input_tokens":19775,"cache_creation":{"ephemeral_5m_input_tokens":8106,"ephemeral_1h_input_tokens":0},"output_tokens":237,"service_tier":"standard"}},"requestId":"req_011CX2Vcm7TVD22isLYizanC","type":"assistant","uuid":"ea7273ab-fa10-4144-98ed-f564eb9eba42","timestamp":"2026-01-11T23:55:40.190Z"}
{"parentUuid":"ea7273ab-fa10-4144-98ed-f564eb9eba42","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FwURdu6g9pJkAnKerLBiN5","type":"tool_result","content":"     1→/**\n     2→ * JWT Authentication Middleware\n     3→ *\n     4→ * Primary authentication method: JWT Bearer tokens\n     5→ * Tokens are signed with a secret and contain the customer ID.\n     6→ *\n     7→ * Token Blacklist:\n     8→ * - Primary: Upstash Redis with automatic TTL-based expiry\n     9→ * - Fallback: In-memory Map (for development or Redis failures)\n    10→ *\n    11→ * DEPRECATION NOTICE:\n    12→ * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n    13→ * - Sunset Date: 2026-04-11\n    14→ * - Control: Set ALLOW_LEGACY_AUTH environment variable\n    15→ *   - Production default: false (disabled)\n    16→ *   - Development default: true (enabled for backward compatibility)\n    17→ * - Clients using legacy auth will receive X-Deprecation-Warning headers\n    18→ * - After sunset date, legacy auth will be completely removed\n    19→ *\n    20→ * Migration Guide:\n    21→ * 1. Call POST /auth/login with license key to obtain JWT tokens\n    22→ * 2. Use Authorization: Bearer <token> header for all authenticated requests\n    23→ * 3. Use POST /auth/refresh to refresh expired tokens\n    24→ */\n    25→\n    26→const jwt = require('jsonwebtoken');\n    27→const crypto = require('crypto');\n    28→const authLogger = require('../utils/authLogger');\n    29→const redis = require('../services/redisClient');\n    30→\n    31→// HIGH-007: Database pool for admin RBAC\n    32→let pool = null;\n    33→try {\n    34→  const { Pool } = require('pg');\n    35→  pool = new Pool({\n    36→    connectionString: process.env.DATABASE_URL,\n    37→    ssl: process.env.NODE_ENV === 'production'\n    38→      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n    39→      : false,\n    40→    max: 3, // Small pool just for auth checks\n    41→    idleTimeoutMillis: 30000,\n    42→  });\n    43→} catch (err) {\n    44→  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n    45→}\n    46→\n    47→// JWT configuration\n    48→const JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\n    49→const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\n    50→const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n    51→\n    52→// Redis key prefix for blacklisted tokens\n    53→const BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n    54→\n    55→// Check if running in production\n    56→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    57→\n    58→// =============================================================================\n    59→// Legacy Authentication Deprecation Configuration\n    60→// =============================================================================\n    61→// The x-stripe-customer-id header is deprecated and will be removed.\n    62→// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n    63→\n    64→/**\n    65→ * Legacy auth sunset date (90 days from 2026-01-11)\n    66→ * After this date, legacy auth will be completely removed\n    67→ */\n    68→const LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n    69→\n    70→/**\n    71→ * Whether to allow legacy x-stripe-customer-id header authentication\n    72→ * Defaults to false in production, true in development for backward compatibility\n    73→ */\n    74→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n    75→  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n    76→\n    77→// Log legacy auth configuration on startup\n    78→if (isProduction) {\n    79→  if (ALLOW_LEGACY_AUTH) {\n    80→    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    81→    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    82→    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n    83→  } else {\n    84→    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n    85→  }\n    86→} else {\n    87→  if (ALLOW_LEGACY_AUTH) {\n    88→    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    89→  } else {\n    90→    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n    91→  }\n    92→}\n    93→\n    94→// HIGH-001: Validate JWT_SECRET security requirements\n    95→if (isProduction) {\n    96→  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    97→    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    98→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    99→    process.exit(1);\n   100→  }\n   101→  \n   102→  if (JWT_SECRET.length < 32) {\n   103→    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n   104→    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n   105→    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n   106→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n   107→    process.exit(1);\n   108→  }\n   109→}\n   110→\n   111→/**\n   112→ * Fallback Token Blacklist (In-Memory)\n   113→ * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n   114→ */\n   115→const fallbackBlacklist = new Map();\n   116→\n   117→// Track if we're using fallback mode\n   118→let usingFallback = false;\n   119→\n   120→// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\n   121→const BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n   122→\n   123→/**\n   124→ * Clean up expired entries from the fallback blacklist\n   125→ * Only runs when using in-memory fallback\n   126→ */\n   127→function cleanupFallbackBlacklist() {\n   128→  if (!usingFallback || fallbackBlacklist.size === 0) {\n   129→    return;\n   130→  }\n   131→\n   132→  const now = Math.floor(Date.now() / 1000);\n   133→  let cleanedCount = 0;\n   134→\n   135→  for (const [jti, exp] of fallbackBlacklist.entries()) {\n   136→    if (exp <= now) {\n   137→      fallbackBlacklist.delete(jti);\n   138→      cleanedCount++;\n   139→    }\n   140→  }\n   141→\n   142→  if (cleanedCount > 0) {\n   143→    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n   144→  }\n   145→}\n   146→\n   147→// Start periodic cleanup for fallback (unref to allow process exit)\n   148→const cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\n   149→if (cleanupTimer.unref) {\n   150→  cleanupTimer.unref();\n   151→}\n   152→\n   153→/**\n   154→ * Add a token to the blacklist\n   155→ * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n   156→ * @param {string} jti - JWT ID claim\n   157→ * @param {number} exp - Token expiration timestamp (Unix seconds)\n   158→ * @param {Object} options - Additional options for logging\n   159→ * @param {string} options.userId - User ID for logging\n   160→ * @param {string} options.reason - Reason for revocation (logout, security, admin)\n   161→ * @returns {Promise<boolean>} True if successfully blacklisted\n   162→ */\n   163→async function blacklistToken(jti, exp, options = {}) {\n   164→  if (!jti) {\n   165→    console.warn('[Auth] Cannot blacklist token without jti');\n   166→    return false;\n   167→  }\n   168→\n   169→  const now = Math.floor(Date.now() / 1000);\n   170→  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n   171→\n   172→  // Try Redis first\n   173→  if (redis.isRedisAvailable()) {\n   174→    try {\n   175→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   176→      const success = await redis.set(key, exp, ttlSeconds);\n   177→\n   178→      if (success) {\n   179→        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n   180→        usingFallback = false;\n   181→        // Log token revocation with structured logging\n   182→        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   183→        return true;\n   184→      }\n   185→    } catch (err) {\n   186→      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n   187→    }\n   188→  }\n   189→\n   190→  // Fallback to in-memory\n   191→  usingFallback = true;\n   192→  fallbackBlacklist.set(jti, exp);\n   193→  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n   194→\n   195→  // Log token revocation with structured logging\n   196→  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   197→  return true;\n   198→}\n   199→\n   200→/**\n   201→ * Check if a token is blacklisted\n   202→ * Checks Redis first, then fallback in-memory store\n   203→ * @param {string} jti - JWT ID claim\n   204→ * @returns {Promise<boolean>} True if token is blacklisted\n   205→ */\n   206→async function isTokenBlacklisted(jti) {\n   207→  if (!jti) {\n   208→    return false;\n   209→  }\n   210→\n   211→  // Try Redis first\n   212→  if (redis.isRedisAvailable()) {\n   213→    try {\n   214→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   215→      const exists = await redis.exists(key);\n   216→\n   217→      if (exists) {\n   218→        return true;\n   219→      }\n   220→\n   221→      // Also check fallback in case token was blacklisted during Redis downtime\n   222→      // and Redis is now back up\n   223→      if (fallbackBlacklist.has(jti)) {\n   224→        // Migrate to Redis if token still valid\n   225→        const exp = fallbackBlacklist.get(jti);\n   226→        const now = Math.floor(Date.now() / 1000);\n   227→        if (exp > now) {\n   228→          const ttlSeconds = exp - now;\n   229→          await redis.set(key, exp, ttlSeconds);\n   230→          fallbackBlacklist.delete(jti);\n   231→          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n   232→        } else {\n   233→          // Expired, remove from fallback\n   234→          fallbackBlacklist.delete(jti);\n   235→        }\n   236→        return true;\n   237→      }\n   238→\n   239→      return false;\n   240→    } catch (err) {\n   241→      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n   242→    }\n   243→  }\n   244→\n   245→  // Fallback to in-memory check\n   246→  if (fallbackBlacklist.has(jti)) {\n   247→    const exp = fallbackBlacklist.get(jti);\n   248→    const now = Math.floor(Date.now() / 1000);\n   249→    if (exp > now) {\n   250→      return true;\n   251→    }\n   252→    // Expired, remove it\n   253→    fallbackBlacklist.delete(jti);\n   254→  }\n   255→\n   256→  return false;\n   257→}\n   258→\n   259→/**\n   260→ * Get blacklist statistics (for monitoring)\n   261→ * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n   262→ */\n   263→async function getBlacklistStats() {\n   264→  const redisAvailable = redis.isRedisAvailable();\n   265→  const redisStatus = redis.getRedisStatus();\n   266→\n   267→  return {\n   268→    storage: redisAvailable ? 'redis' : 'memory',\n   269→    redisConnected: redisStatus.connected,\n   270→    redisError: redisStatus.error,\n   271→    fallbackSize: fallbackBlacklist.size,\n   272→    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n   273→    usingFallback\n   274→  };\n   275→}\n   276→\n   277→/**\n   278→ * Generate a JWT token for a customer\n   279→ * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n   280→ * @param {Object} options - Additional options\n   281→ * @param {string} options.tier - User's subscription tier\n   282→ * @param {string} options.email - User's email (optional)\n   283→ * @returns {Object} { token, expiresIn }\n   284→ */\n   285→function generateToken(stripeCustomerId, options = {}) {\n   286→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   287→    throw new Error('Invalid Stripe customer ID');\n   288→  }\n   289→\n   290→  const payload = {\n   291→    sub: stripeCustomerId,\n   292→    type: 'access',\n   293→    tier: options.tier || 'starter',\n   294→    iat: Math.floor(Date.now() / 1000),\n   295→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   296→  };\n   297→\n   298→  if (options.email) {\n   299→    payload.email = options.email;\n   300→  }\n   301→\n   302→  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n   303→\n   304→  return {\n   305→    token,\n   306→    expiresIn: JWT_EXPIRES_IN,\n   307→    tokenType: 'Bearer'\n   308→  };\n   309→}\n   310→\n   311→/**\n   312→ * Generate a refresh token for a customer\n   313→ * @param {string} stripeCustomerId - Stripe customer ID\n   314→ * @returns {Object} { refreshToken, expiresIn }\n   315→ */\n   316→function generateRefreshToken(stripeCustomerId) {\n   317→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   318→    throw new Error('Invalid Stripe customer ID');\n   319→  }\n   320→\n   321→  const payload = {\n   322→    sub: stripeCustomerId,\n   323→    type: 'refresh',\n   324→    iat: Math.floor(Date.now() / 1000),\n   325→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   326→  };\n   327→\n   328→  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n   329→\n   330→  return {\n   331→    refreshToken,\n   332→    expiresIn: JWT_REFRESH_EXPIRES_IN\n   333→  };\n   334→}\n   335→\n   336→/**\n   337→ * Verify and decode a JWT token (async version)\n   338→ * Checks both JWT signature validity and token blacklist status via Redis\n   339→ * @param {string} token - JWT token to verify\n   340→ * @param {Object} options - Verification options\n   341→ * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n   342→ * @param {Object} options.req - Express request object for logging (optional)\n   343→ * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n   344→ */\n   345→async function verifyToken(token, options = {}) {\n   346→  const { checkBlacklist = true, req = null } = options;\n   347→\n   348→  try {\n   349→    const decoded = jwt.verify(token, JWT_SECRET);\n   350→\n   351→    // Check if token has been revoked (blacklisted) - async Redis check\n   352→    if (checkBlacklist && decoded.jti) {\n   353→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   354→      if (isBlacklisted) {\n   355→        if (req) {\n   356→          authLogger.logTokenBlacklisted(req, decoded.jti);\n   357→        }\n   358→        return null;\n   359→      }\n   360→    }\n   361→\n   362→    return decoded;\n   363→  } catch (err) {\n   364→    // Log specific error types for debugging\n   365→    if (err.name === 'TokenExpiredError') {\n   366→      if (req) {\n   367→        authLogger.logTokenExpired(req);\n   368→      }\n   369→    } else if (err.name === 'JsonWebTokenError') {\n   370→      if (req) {\n   371→        authLogger.logTokenInvalid(req, err.message);\n   372→      }\n   373→    }\n   374→    return null;\n   375→  }\n   376→}\n   377→\n   378→/**\n   379→ * Synchronous token verification (for cases where async is not possible)\n   380→ * Does NOT check blacklist - use verifyToken() for full verification\n   381→ * @param {string} token - JWT token to verify\n   382→ * @returns {Object|null} Decoded payload or null if invalid\n   383→ */\n   384→function verifyTokenSync(token) {\n   385→  try {\n   386→    return jwt.verify(token, JWT_SECRET);\n   387→  } catch {\n   388→    return null;\n   389→  }\n   390→}\n   391→\n   392→/**\n   393→ * Extract Bearer token from Authorization header\n   394→ * @param {string} authHeader - Authorization header value\n   395→ * @returns {string|null} Token or null if not found\n   396→ */\n   397→function extractBearerToken(authHeader) {\n   398→  if (!authHeader || typeof authHeader !== 'string') {\n   399→    return null;\n   400→  }\n   401→\n   402→  const parts = authHeader.split(' ');\n   403→  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n   404→    return null;\n   405→  }\n   406→\n   407→  return parts[1];\n   408→}\n   409→\n   410→/**\n   411→ * Middleware to authenticate JWT tokens\n   412→ * Sets req.stripeCustomerId if valid token found\n   413→ *\n   414→ * Authentication Methods:\n   415→ * - Authorization: Bearer <token> (PREFERRED - use this method)\n   416→ * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)\n   417→ *\n   418→ * DEPRECATION: x-stripe-customer-id header\n   419→ * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var\n   420→ * - Production: Disabled by default (returns 401)\n   421→ * - Development: Enabled by default for backward compatibility\n   422→ * - Sunset Date: 2026-04-11 (after which it will be removed entirely)\n   423→ * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers\n   424→ *\n   425→ * @param {Object} req - Express request object\n   426→ * @param {Object} res - Express response object\n   427→ * @param {Function} next - Express next function\n   428→ */\n   429→async function authenticateToken(req, res, next) {\n   430→  // First, try JWT token from Authorization header\n   431→  const authHeader = req.headers['authorization'];\n   432→  const token = extractBearerToken(authHeader);\n   433→\n   434→  if (token) {\n   435→    // First verify JWT signature without blacklist check to get specific error messages\n   436→    const decoded = verifyTokenSync(token);\n   437→\n   438→    if (!decoded || !decoded.sub) {\n   439→      // Token is invalid or expired (signature failed)\n   440→      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n   441→      return res.status(401).json({\n   442→        error: 'Invalid or expired token',\n   443→        message: 'Please log in again to continue'\n   444→      });\n   445→    }\n   446→\n   447→    // Check if token has been revoked (blacklisted) - async Redis check\n   448→    if (decoded.jti) {\n   449→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   450→      if (isBlacklisted) {\n   451→        authLogger.logTokenBlacklisted(req, decoded.jti);\n   452→        return res.status(401).json({\n   453→          error: 'Token has been revoked',\n   454→          message: 'This session has been logged out. Please log in again.'\n   455→        });\n   456→      }\n   457→    }\n   458→\n   459→    // Token is valid and not revoked\n   460→    req.stripeCustomerId = decoded.sub;\n   461→    req.tokenData = decoded;\n   462→    req.rawToken = token; // Store raw token for logout\n   463→    return next();\n   464→  }\n   465→\n   466→  // ==========================================================================\n   467→  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n   468→  // This authentication method is deprecated and will be removed after\n   469→  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n   470→  // ==========================================================================\n   471→  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   472→  if (legacyCustomerId) {\n   473→    // Check if legacy auth is allowed\n   474→    if (!ALLOW_LEGACY_AUTH) {\n   475→      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n   476→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   477→      return res.status(401).json({\n   478→        error: 'Legacy authentication disabled',\n   479→        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n   480→        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n   481→      });\n   482→    }\n   483→\n   484→    // Log deprecation warning with structured logging (once per request)\n   485→    if (!req._legacyAuthWarned) {\n   486→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   487→      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n   488→      req._legacyAuthWarned = true;\n   489→    }\n   490→\n   491→    // Validate format\n   492→    if (!legacyCustomerId.startsWith('cus_')) {\n   493→      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n   494→      return res.status(401).json({\n   495→        error: 'Invalid customer ID format',\n   496→        message: 'Customer ID must start with cus_'\n   497→      });\n   498→    }\n   499→\n   500→    // Set deprecation warning header on the response\n   501→    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n   502→    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n   503→\n   504→    req.stripeCustomerId = legacyCustomerId;\n   505→    req.isLegacyAuth = true;\n   506→    return next();\n   507→  }\n   508→\n   509→  // No authentication provided\n   510→  return res.status(401).json({\n   511→    error: 'Authentication required',\n   512→    message: 'Please provide a valid Bearer token in the Authorization header'\n   513→  });\n   514→}\n   515→\n   516→/**\n   517→ * Optional authentication middleware\n   518→ * Allows unauthenticated access but sets req.stripeCustomerId if token present\n   519→ *\n   520→ * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n   521→ */\n   522→async function optionalAuthentication(req, res, next) {\n   523→  const authHeader = req.headers['authorization'];\n   524→  const token = extractBearerToken(authHeader);\n   525→\n   526→  if (token) {\n   527→    const decoded = await verifyToken(token);\n   528→    if (decoded && decoded.sub) {\n   529→      req.stripeCustomerId = decoded.sub;\n   530→      req.tokenData = decoded;\n   531→    }\n   532→  } else {\n   533→    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n   534→    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   535→    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n   536→      // Only accept legacy auth if allowed\n   537→      if (ALLOW_LEGACY_AUTH) {\n   538→        // Log deprecation warning\n   539→        if (!req._legacyAuthWarned) {\n   540→          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   541→          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n   542→          req._legacyAuthWarned = true;\n   543→        }\n   544→\n   545→        // Set deprecation warning headers\n   546→        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n   547→        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n   548→\n   549→        req.stripeCustomerId = legacyCustomerId;\n   550→        req.isLegacyAuth = true;\n   551→      }\n   552→      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n   553→    }\n   554→  }\n   555→\n   556→  next();\n   557→}\n   558→\n   559→/**\n   560→ * HIGH-007: Database-backed admin role check middleware\n   561→ * Checks the user's role in the database instead of relying on env vars\n   562→ * Requires authenticateToken middleware to run first\n   563→ *\n   564→ * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n   565→ * @param {Object} res - Express response object\n   566→ * @param {Function} next - Express next function\n   567→ */\n   568→async function requireAdmin(req, res, next) {\n   569→  // Must be authenticated first\n   570→  if (!req.stripeCustomerId) {\n   571→    return res.status(401).json({\n   572→      error: 'Authentication required',\n   573→      message: 'Please log in to access this resource'\n   574→    });\n   575→  }\n   576→\n   577→  // Check if database pool is available\n   578→  if (!pool) {\n   579→    console.error('[Auth] Admin check failed: Database pool not available');\n   580→    return res.status(503).json({\n   581→      error: 'Service unavailable',\n   582→      message: 'Admin verification temporarily unavailable'\n   583→    });\n   584→  }\n   585→\n   586→  try {\n   587→    // Query database for user role\n   588→    const result = await pool.query(\n   589→      'SELECT role FROM users WHERE stripe_customer_id = $1',\n   590→      [req.stripeCustomerId]\n   591→    );\n   592→\n   593→    if (!result.rows[0]) {\n   594→      authLogger.logAdminAccessDenied(req, 'User not found in database');\n   595→      return res.status(403).json({\n   596→        error: 'Access denied',\n   597→        message: 'User account not found'\n   598→      });\n   599→    }\n   600→\n   601→    const userRole = result.rows[0].role;\n   602→\n   603→    if (userRole !== 'admin') {\n   604→      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n   605→      return res.status(403).json({\n   606→        error: 'Admin access required',\n   607→        message: 'This action requires administrator privileges'\n   608→      });\n   609→    }\n   610→\n   611→    // User is admin - log and proceed\n   612→    authLogger.logAdminAccess(req);\n   613→    req.isAdmin = true;\n   614→    next();\n   615→  } catch (err) {\n   616→    console.error('[Auth] Admin role check failed:', err.message);\n   617→    return res.status(500).json({\n   618→      error: 'Authorization check failed',\n   619→      message: 'Unable to verify admin privileges'\n   620→    });\n   621→  }\n   622→}\n   623→\n   624→/**\n   625→ * Mask sensitive data for logging\n   626→ * @param {string} key - License key or other sensitive string\n   627→ * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n   628→ */\n   629→function maskSensitiveData(data) {\n   630→  if (!data || typeof data !== 'string') {\n   631→    return '****';\n   632→  }\n   633→\n   634→  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n   635→  if (data.startsWith('SPLICE-')) {\n   636→    const parts = data.split('-');\n   637→    if (parts.length === 5) {\n   638→      return `${parts[0]}-${parts[1]}-****-****-****`;\n   639→    }\n   640→  }\n   641→\n   642→  // For customer IDs (cus_xxxx format)\n   643→  if (data.startsWith('cus_')) {\n   644→    if (data.length > 10) {\n   645→      return `cus_${data.slice(4, 8)}****`;\n   646→    }\n   647→    return 'cus_****';\n   648→  }\n   649→\n   650→  // For JWTs (eyJ... format)\n   651→  if (data.startsWith('eyJ')) {\n   652→    return `${data.slice(0, 10)}...****`;\n   653→  }\n   654→\n   655→  // For emails\n   656→  if (data.includes('@')) {\n   657→    const [local, domain] = data.split('@');\n   658→    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n   659→    return `${maskedLocal}@${domain}`;\n   660→  }\n   661→\n   662→  // Generic masking - show first 4 chars\n   663→  if (data.length > 8) {\n   664→    return `${data.slice(0, 4)}****`;\n   665→  }\n   666→\n   667→  return '****';\n   668→}\n   669→\n   670→module.exports = {\n   671→  generateToken,\n   672→  generateRefreshToken,\n   673→  verifyToken,\n   674→  verifyTokenSync,\n   675→  extractBearerToken,\n   676→  authenticateToken,\n   677→  optionalAuthentication,\n   678→  maskSensitiveData,\n   679→  // HIGH-007: Admin RBAC middleware\n   680→  requireAdmin,\n   681→  // Token blacklist functions\n   682→  blacklistToken,\n   683→  isTokenBlacklisted,\n   684→  getBlacklistStats,\n   685→  // Structured logging\n   686→  authLogger,\n   687→  // Constants\n   688→  JWT_SECRET,\n   689→  JWT_EXPIRES_IN,\n   690→  // Legacy auth deprecation constants\n   691→  LEGACY_AUTH_SUNSET_DATE,\n   692→  ALLOW_LEGACY_AUTH\n   693→};\n   694→\n\n</system-reminder>\n"}]},"uuid":"1993d25e-78ab-4d87-b6be-addd2e4c1978","timestamp":"2026-01-11T23:55:40.227Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","content":"/**\n * JWT Authentication Middleware\n *\n * Primary authentication method: JWT Bearer tokens\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n *\n * DEPRECATION NOTICE:\n * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n * - Sunset Date: 2026-04-11\n * - Control: Set ALLOW_LEGACY_AUTH environment variable\n *   - Production default: false (disabled)\n *   - Development default: true (enabled for backward compatibility)\n * - Clients using legacy auth will receive X-Deprecation-Warning headers\n * - After sunset date, legacy auth will be completely removed\n *\n * Migration Guide:\n * 1. Call POST /auth/login with license key to obtain JWT tokens\n * 2. Use Authorization: Bearer <token> header for all authenticated requests\n * 3. Use POST /auth/refresh to refresh expired tokens\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Authentication Methods:\n * - Authorization: Bearer <token> (PREFERRED - use this method)\n * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)\n *\n * DEPRECATION: x-stripe-customer-id header\n * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var\n * - Production: Disabled by default (returns 401)\n * - Development: Enabled by default for backward compatibility\n * - Sunset Date: 2026-04-11 (after which it will be removed entirely)\n * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers\n *\n * @param {Object} req - Express request object\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // ==========================================================================\n  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n  // This authentication method is deprecated and will be removed after\n  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n  // ==========================================================================\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Check if legacy auth is allowed\n    if (!ALLOW_LEGACY_AUTH) {\n      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      return res.status(401).json({\n        error: 'Legacy authentication disabled',\n        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n      });\n    }\n\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    // Set deprecation warning header on the response\n    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n *\n * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      // Only accept legacy auth if allowed\n      if (ALLOW_LEGACY_AUTH) {\n        // Log deprecation warning\n        if (!req._legacyAuthWarned) {\n          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n          req._legacyAuthWarned = true;\n        }\n\n        // Set deprecation warning headers\n        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n        req.stripeCustomerId = legacyCustomerId;\n        req.isLegacyAuth = true;\n      }\n      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN,\n  // Legacy auth deprecation constants\n  LEGACY_AUTH_SUNSET_DATE,\n  ALLOW_LEGACY_AUTH\n};\n","numLines":694,"startLine":1,"totalLines":694}}}
{"parentUuid":"1993d25e-78ab-4d87-b6be-addd2e4c1978","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RfvAEgS1hxHPrwPSdi2bWF","type":"tool_result","content":"     1→/**\n     2→ * Rate Limiter Middleware\n     3→ *\n     4→ * Checks if user has sufficient credits before processing.\n     5→ * Uses atomic credit reservation to prevent race conditions.\n     6→ * Returns 402 Payment Required if insufficient credits.\n     7→ *\n     8→ * SECURITY FEATURES:\n     9→ * - JWT authentication via authenticateToken middleware\n    10→ * - Redis-backed rate limiting with in-memory fallback\n    11→ * - Tiered limits: authenticated users get higher limits than anonymous\n    12→ * - Endpoint-specific limits for sensitive operations\n    13→ * - Proper 429 responses with Retry-After header\n    14→ * - Legacy x-stripe-customer-id header is DISABLED in production for security\n    15→ */\n    16→\n    17→const {\n    18→  deductUsage,\n    19→  getBalance,\n    20→  reserveCredits,\n    21→  confirmReservation,\n    22→  releaseReservation,\n    23→  customerExists,\n    24→  hasFeatureAccess\n    25→} = require('../services/usageTracking');\n    26→const { verifyToken, extractBearerToken } = require('./auth');\n    27→const redisClient = require('../services/redisClient');\n    28→\n    29→// SECURITY: Disable legacy auth in production unless explicitly enabled\n    30→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    31→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n    32→\n    33→// =============================================================================\n    34→// SECURITY: Enhanced IP-based Rate Limiting with Redis Backend\n    35→// =============================================================================\n    36→\n    37→/**\n    38→ * Rate limit configuration\n    39→ * Tiered limits: authenticated users get higher limits than anonymous\n    40→ */\n    41→const RATE_LIMITS = {\n    42→  // Global IP limits\n    43→  global: {\n    44→    anonymous: { max: 100, window: 60 },      // 100 req/min for unauthenticated\n    45→    authenticated: { max: 300, window: 60 }   // 300 req/min for authenticated users\n    46→  },\n    47→  // Endpoint-specific limits (stricter)\n    48→  endpoints: {\n    49→    '/auth/send-code': { max: 5, window: 300 },        // 5 requests per 5 minutes\n    50→    '/auth/verify-code': { max: 10, window: 300 },     // 10 requests per 5 minutes\n    51→    '/music/generate': { max: 10, window: 60 },        // 10 requests per minute\n    52→    '/analyze': { max: 30, window: 60 },               // 30 requests per minute\n    53→    'upload': { max: 20, window: 60 }                  // 20 uploads per minute\n    54→  }\n    55→};\n    56→\n    57→// In-memory fallback for when Redis is unavailable\n    58→const ipRequestCounts = new Map(); // IP -> { count, windowStart }\n    59→\n    60→// Cleanup old entries every 5 minutes to prevent memory leaks\n    61→setInterval(() => {\n    62→  const now = Date.now();\n    63→  for (const [ip, data] of ipRequestCounts.entries()) {\n    64→    if (now - data.windowStart > 120000) { // Clean up entries older than 2 minutes\n    65→      ipRequestCounts.delete(ip);\n    66→    }\n    67→  }\n    68→}, 300000);\n    69→\n    70→/**\n    71→ * SECURITY: Check rate limit using Redis with in-memory fallback\n    72→ * @param {string} key - Redis key for rate limit counter\n    73→ * @param {number} max - Maximum requests allowed\n    74→ * @param {number} windowSeconds - Time window in seconds\n    75→ * @returns {Promise<{allowed: boolean, remaining: number, resetAt: number}>}\n    76→ */\n    77→async function checkRateLimit(key, max, windowSeconds) {\n    78→  try {\n    79→    // Try Redis first (preferred for multi-instance deployments)\n    80→    // Use isRedisAvailable() function and getRedisClient() to access raw client\n    81→    if (redisClient && redisClient.isRedisAvailable()) {\n    82→      const redis = redisClient.getRedisClient();\n    83→      if (redis) {\n    84→        const current = await redis.incr(key);\n    85→\n    86→        if (current === 1) {\n    87→          // First request in window, set expiry\n    88→          await redis.expire(key, windowSeconds);\n    89→        }\n    90→\n    91→        const ttlValue = await redis.ttl(key);\n    92→        const resetAt = Date.now() + (ttlValue * 1000);\n    93→\n    94→        return {\n    95→          allowed: current <= max,\n    96→          remaining: Math.max(0, max - current),\n    97→          resetAt,\n    98→          retryAfter: ttlValue\n    99→        };\n   100→      }\n   101→    }\n   102→  } catch (redisError) {\n   103→    console.warn('[RateLimiter] Redis error, falling back to in-memory:', redisError.message);\n   104→  }\n   105→  \n   106→  // Fallback to in-memory (single-instance only)\n   107→  const now = Date.now();\n   108→  const windowMs = windowSeconds * 1000;\n   109→  const data = ipRequestCounts.get(key);\n   110→  \n   111→  if (!data || now - data.windowStart > windowMs) {\n   112→    // Start new window\n   113→    ipRequestCounts.set(key, { count: 1, windowStart: now });\n   114→    return {\n   115→      allowed: true,\n   116→      remaining: max - 1,\n   117→      resetAt: now + windowMs,\n   118→      retryAfter: windowSeconds\n   119→    };\n   120→  }\n   121→  \n   122→  data.count++;\n   123→  const allowed = data.count <= max;\n   124→  const remaining = Math.max(0, max - data.count);\n   125→  const resetAt = data.windowStart + windowMs;\n   126→  const retryAfter = Math.ceil((resetAt - now) / 1000);\n   127→  \n   128→  return {\n   129→    allowed,\n   130→    remaining,\n   131→    resetAt,\n   132→    retryAfter\n   133→  };\n   134→}\n   135→\n   136→/**\n   137→ * SECURITY: IP-based rate limiting middleware with tiered limits\n   138→ * Authenticated users get higher limits than anonymous users\n   139→ * Returns 429 with Retry-After header when limit exceeded\n   140→ */\n   141→function ipRateLimit(req, res, next) {\n   142→  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n   143→  \n   144→  // Determine if user is authenticated (check for valid JWT token)\n   145→  const authHeader = req.headers['authorization'];\n   146→  const token = extractBearerToken(authHeader);\n   147→  const isAuthenticated = !!token; // Simple check, validation happens in requireCredits\n   148→  \n   149→  // Select appropriate rate limit\n   150→  const limit = isAuthenticated\n   151→    ? RATE_LIMITS.global.authenticated\n   152→    : RATE_LIMITS.global.anonymous;\n   153→  \n   154→  const rateLimitKey = `ratelimit:global:${clientIp}`;\n   155→  \n   156→  checkRateLimit(rateLimitKey, limit.max, limit.window)\n   157→    .then(result => {\n   158→      // Add rate limit headers (industry standard)\n   159→      res.set('X-RateLimit-Limit', limit.max.toString());\n   160→      res.set('X-RateLimit-Remaining', result.remaining.toString());\n   161→      res.set('X-RateLimit-Reset', Math.floor(result.resetAt / 1000).toString());\n   162→      \n   163→      if (!result.allowed) {\n   164→        // SECURITY: Return 429 with Retry-After header\n   165→        res.set('Retry-After', result.retryAfter.toString());\n   166→        console.warn(`[SECURITY] Global rate limit exceeded for IP: ${clientIp} (${isAuthenticated ? 'authenticated' : 'anonymous'})`);\n   167→        return res.status(429).json({\n   168→          error: 'Too many requests',\n   169→          message: 'Please slow down and try again later',\n   170→          retryAfter: result.retryAfter,\n   171→          limit: limit.max,\n   172→          window: limit.window\n   173→        });\n   174→      }\n   175→      \n   176→      next();\n   177→    })\n   178→    .catch(err => {\n   179→      console.error('[RateLimiter] Error checking rate limit:', err);\n   180→      // On error, allow request but log warning\n   181→      console.warn('[RateLimiter] Rate limit check failed, allowing request');\n   182→      next();\n   183→    });\n   184→}\n   185→\n   186→/**\n   187→ * SECURITY: Endpoint-specific rate limiting\n   188→ * Stricter limits for sensitive operations like authentication and file uploads\n   189→ * @param {string} endpointKey - Key from RATE_LIMITS.endpoints\n   190→ */\n   191→function endpointRateLimit(endpointKey) {\n   192→  return async (req, res, next) => {\n   193→    const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n   194→    const limit = RATE_LIMITS.endpoints[endpointKey];\n   195→    \n   196→    if (!limit) {\n   197→      console.warn(`[RateLimiter] No rate limit configured for endpoint: ${endpointKey}`);\n   198→      return next();\n   199→    }\n   200→    \n   201→    const rateLimitKey = `ratelimit:endpoint:${endpointKey}:${clientIp}`;\n   202→    \n   203→    try {\n   204→      const result = await checkRateLimit(rateLimitKey, limit.max, limit.window);\n   205→      \n   206→      // Add rate limit headers\n   207→      res.set('X-RateLimit-Limit', limit.max.toString());\n   208→      res.set('X-RateLimit-Remaining', result.remaining.toString());\n   209→      res.set('X-RateLimit-Reset', Math.floor(result.resetAt / 1000).toString());\n   210→      \n   211→      if (!result.allowed) {\n   212→        // SECURITY: Return 429 with Retry-After header\n   213→        res.set('Retry-After', result.retryAfter.toString());\n   214→        console.warn(`[SECURITY] Endpoint rate limit exceeded for ${endpointKey} from IP: ${clientIp}`);\n   215→        return res.status(429).json({\n   216→          error: 'Too many requests',\n   217→          message: `Rate limit exceeded for this operation. Please try again in ${result.retryAfter} seconds.`,\n   218→          retryAfter: result.retryAfter,\n   219→          limit: limit.max,\n   220→          window: limit.window\n   221→        });\n   222→      }\n   223→      \n   224→      next();\n   225→    } catch (err) {\n   226→      console.error(`[RateLimiter] Error checking endpoint rate limit for ${endpointKey}:`, err);\n   227→      // On error, allow request but log warning\n   228→      console.warn('[RateLimiter] Endpoint rate limit check failed, allowing request');\n   229→      next();\n   230→    }\n   231→  };\n   232→}\n   233→\n   234→// Rate limiting for legacy auth attempts (prevent brute force)\n   235→const legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\n   236→const LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\n   237→const LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n   238→\n   239→/**\n   240→ * Check if IP is rate limited for legacy auth\n   241→ */\n   242→function isLegacyAuthRateLimited(ip) {\n   243→  const now = Date.now();\n   244→  const attempt = legacyAuthAttempts.get(ip);\n   245→\n   246→  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n   247→    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n   248→    return false;\n   249→  }\n   250→\n   251→  attempt.count++;\n   252→  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n   253→    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n   254→    return true;\n   255→  }\n   256→\n   257→  return false;\n   258→}\n   259→\n   260→// Default estimated duration for reservation (1 minute = 60 seconds)\n   261→const DEFAULT_RESERVATION_SECONDS = 60;\n   262→\n   263→/**\n   264→ * Middleware to check and atomically reserve credits before processing\n   265→ *\n   266→ * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n   267→ * Falls back to legacy x-stripe-customer-id header (deprecated)\n   268→ *\n   269→ * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n   270→ *\n   271→ * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n   272→ * where multiple concurrent requests could all pass credit check.\n   273→ */\n   274→function requireCredits(options = {}) {\n   275→  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n   276→\n   277→  return async (req, res, next) => {\n   278→    // SECURITY: Primary auth via JWT token\n   279→    const authHeader = req.headers['authorization'];\n   280→    const token = extractBearerToken(authHeader);\n   281→\n   282→    let stripeCustomerId = null;\n   283→\n   284→    if (token) {\n   285→      const decoded = await verifyToken(token);\n   286→      if (decoded && decoded.sub) {\n   287→        stripeCustomerId = decoded.sub;\n   288→        req.tokenData = decoded;\n   289→      } else {\n   290→        // Token present but invalid\n   291→        return res.status(401).json({\n   292→          error: 'Invalid or expired token',\n   293→          message: 'Please log in again to continue'\n   294→        });\n   295→      }\n   296→    } else {\n   297→      // DEPRECATED: Fallback to legacy header\n   298→      const legacyId = req.headers['x-stripe-customer-id'];\n   299→      if (legacyId) {\n   300→        // SECURITY: Block legacy auth in production unless explicitly enabled\n   301→        if (isProduction && !ALLOW_LEGACY_AUTH) {\n   302→          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n   303→          return res.status(401).json({\n   304→            error: 'Authentication method not supported',\n   305→            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n   306→          });\n   307→        }\n   308→\n   309→        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n   310→        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n   311→        if (isLegacyAuthRateLimited(clientIp)) {\n   312→          return res.status(429).json({\n   313→            error: 'Too many authentication attempts',\n   314→            message: 'Please wait before trying again'\n   315→          });\n   316→        }\n   317→\n   318→        // Validate format to prevent injection\n   319→        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n   320→          return res.status(401).json({\n   321→            error: 'Invalid customer ID format',\n   322→            message: 'Customer ID must be a valid Stripe customer ID'\n   323→          });\n   324→        }\n   325→\n   326→        // SECURITY: Verify customer exists in database before accepting\n   327→        const exists = await customerExists(legacyId);\n   328→        if (!exists) {\n   329→          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n   330→          return res.status(401).json({\n   331→            error: 'Invalid customer ID',\n   332→            message: 'Customer not found'\n   333→          });\n   334→        }\n   335→\n   336→        stripeCustomerId = legacyId;\n   337→        req.isLegacyAuth = true;\n   338→        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n   339→      }\n   340→    }\n   341→\n   342→    if (!stripeCustomerId) {\n   343→      return res.status(401).json({\n   344→        error: 'Authentication required',\n   345→        message: 'Missing Stripe customer ID'\n   346→      });\n   347→    }\n   348→\n   349→    // Store for later use\n   350→    req.stripeCustomerId = stripeCustomerId;\n   351→\n   352→    // Determine estimated duration - use request value, option value, or default\n   353→    const estSeconds = req.estimatedDuration || estimatedSeconds;\n   354→\n   355→    try {\n   356→      // Atomically reserve credits using SELECT...FOR UPDATE\n   357→      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n   358→\n   359→      if (!reservation.success) {\n   360→        // Reservation failed - not enough credits\n   361→        const balance = await getBalance(stripeCustomerId);\n   362→        return res.status(402).json({\n   363→          error: 'Insufficient credits',\n   364→          message: 'Please upgrade your plan or wait for your next billing cycle',\n   365→          balance: {\n   366→            hoursRemaining: balance.hoursRemaining,\n   367→            tier: balance.tier\n   368→          }\n   369→        });\n   370→      }\n   371→\n   372→      // Store reservation info for confirmation/release\n   373→      req.reservation = {\n   374→        id: reservation.reservationId,\n   375→        seconds: estSeconds,\n   376→        hoursReserved: reservation.hoursReserved\n   377→      };\n   378→\n   379→      // Attach helper function to confirm usage with actual duration\n   380→      // This adjusts the reservation if actual duration differs\n   381→      req.deductUsage = async (actualDurationSeconds) => {\n   382→        return await confirmReservation(\n   383→          stripeCustomerId,\n   384→          actualDurationSeconds,\n   385→          estSeconds,\n   386→          endpoint\n   387→        );\n   388→      };\n   389→\n   390→      // Attach helper function to release reservation on failure\n   391→      req.releaseReservation = async (reason = 'processing_failed') => {\n   392→        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n   393→      };\n   394→\n   395→      // Hook into response to auto-release on error responses\n   396→      const originalSend = res.send.bind(res);\n   397→      res.send = function(body) {\n   398→        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n   399→        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n   400→          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n   401→            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n   402→        }\n   403→        return originalSend(body);\n   404→      };\n   405→\n   406→      next();\n   407→    } catch (err) {\n   408→      console.error('[RateLimiter] Error reserving credits:', err);\n   409→      return res.status(500).json({\n   410→        error: 'Credit check failed',\n   411→        message: err.message\n   412→      });\n   413→    }\n   414→  };\n   415→}\n   416→\n   417→/**\n   418→ * Middleware to enforce tier-based feature access\n   419→ *\n   420→ * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n   421→ * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n   422→ *\n   423→ * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n   424→ */\n   425→function requireFeature(featureName) {\n   426→  return async (req, res, next) => {\n   427→    // Must have stripeCustomerId from requireCredits middleware\n   428→    if (!req.stripeCustomerId) {\n   429→      return res.status(401).json({\n   430→        error: 'Authentication required',\n   431→        message: 'Please log in to access this feature'\n   432→      });\n   433→    }\n   434→\n   435→    try {\n   436→      // Get user's current balance (includes tier info)\n   437→      const balance = await getBalance(req.stripeCustomerId);\n   438→\n   439→      // Check if user's tier has access to this feature\n   440→      if (!hasFeatureAccess(balance.tier, featureName)) {\n   441→        // Release any reserved credits since we're blocking the request\n   442→        if (req.releaseReservation) {\n   443→          await req.releaseReservation('feature_not_available');\n   444→        }\n   445→\n   446→        // Determine required tier for helpful error message\n   447→        const requiredTier = getRequiredTierForFeature(featureName);\n   448→\n   449→        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n   450→\n   451→        return res.status(403).json({\n   452→          error: 'Feature not available',\n   453→          message: `This feature requires a ${requiredTier} plan or higher`,\n   454→          requiredFeature: featureName,\n   455→          requiredTier: requiredTier,\n   456→          currentTier: balance.tier\n   457→        });\n   458→      }\n   459→\n   460→      // Feature access granted\n   461→      next();\n   462→    } catch (err) {\n   463→      console.error('[requireFeature] Error checking feature access:', err);\n   464→      return res.status(500).json({\n   465→        error: 'Feature access check failed',\n   466→        message: err.message\n   467→      });\n   468→    }\n   469→  };\n   470→}\n   471→\n   472→/**\n   473→ * Helper to determine required tier for a feature\n   474→ * Used for helpful error messages\n   475→ */\n   476→function getRequiredTierForFeature(featureName) {\n   477→  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n   478→  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n   479→\n   480→  if (teamOnlyFeatures.includes(featureName)) {\n   481→    return 'Team';\n   482→  } else if (proFeatures.includes(featureName)) {\n   483→    return 'Pro';\n   484→  }\n   485→  return 'Starter';\n   486→}\n   487→\n   488→/**\n   489→ * Middleware to track usage after successful response\n   490→ *\n   491→ * Call this after processing to deduct actual usage\n   492→ */\n   493→function trackUsage(endpoint = 'unknown') {\n   494→  return async (req, res, next) => {\n   495→    // Store original json method\n   496→    const originalJson = res.json.bind(res);\n   497→\n   498→    // Override json to track usage on success\n   499→    res.json = async (data) => {\n   500→      // Only deduct on successful responses\n   501→      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n   502→        try {\n   503→          const balance = await deductUsage(\n   504→            req.stripeCustomerId,\n   505→            req.audioDuration,\n   506→            endpoint\n   507→          );\n   508→          // Attach updated balance to response\n   509→          data.balance = balance;\n   510→        } catch (err) {\n   511→          console.error('[RateLimiter] Error deducting usage:', err);\n   512→        }\n   513→      }\n   514→      return originalJson(data);\n   515→    };\n   516→\n   517→    next();\n   518→  };\n   519→}\n   520→\n   521→module.exports = {\n   522→  requireCredits,\n   523→  requireFeature,\n   524→  trackUsage,\n   525→  ipRateLimit\n   526→};\n   527→\n\n</system-reminder>\n"}]},"uuid":"73e5328e-db6c-45a5-9e36-ec159afaddc1","timestamp":"2026-01-11T23:55:40.227Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js","content":"/**\n * Rate Limiter Middleware\n *\n * Checks if user has sufficient credits before processing.\n * Uses atomic credit reservation to prevent race conditions.\n * Returns 402 Payment Required if insufficient credits.\n *\n * SECURITY FEATURES:\n * - JWT authentication via authenticateToken middleware\n * - Redis-backed rate limiting with in-memory fallback\n * - Tiered limits: authenticated users get higher limits than anonymous\n * - Endpoint-specific limits for sensitive operations\n * - Proper 429 responses with Retry-After header\n * - Legacy x-stripe-customer-id header is DISABLED in production for security\n */\n\nconst {\n  deductUsage,\n  getBalance,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  customerExists,\n  hasFeatureAccess\n} = require('../services/usageTracking');\nconst { verifyToken, extractBearerToken } = require('./auth');\nconst redisClient = require('../services/redisClient');\n\n// SECURITY: Disable legacy auth in production unless explicitly enabled\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n\n// =============================================================================\n// SECURITY: Enhanced IP-based Rate Limiting with Redis Backend\n// =============================================================================\n\n/**\n * Rate limit configuration\n * Tiered limits: authenticated users get higher limits than anonymous\n */\nconst RATE_LIMITS = {\n  // Global IP limits\n  global: {\n    anonymous: { max: 100, window: 60 },      // 100 req/min for unauthenticated\n    authenticated: { max: 300, window: 60 }   // 300 req/min for authenticated users\n  },\n  // Endpoint-specific limits (stricter)\n  endpoints: {\n    '/auth/send-code': { max: 5, window: 300 },        // 5 requests per 5 minutes\n    '/auth/verify-code': { max: 10, window: 300 },     // 10 requests per 5 minutes\n    '/music/generate': { max: 10, window: 60 },        // 10 requests per minute\n    '/analyze': { max: 30, window: 60 },               // 30 requests per minute\n    'upload': { max: 20, window: 60 }                  // 20 uploads per minute\n  }\n};\n\n// In-memory fallback for when Redis is unavailable\nconst ipRequestCounts = new Map(); // IP -> { count, windowStart }\n\n// Cleanup old entries every 5 minutes to prevent memory leaks\nsetInterval(() => {\n  const now = Date.now();\n  for (const [ip, data] of ipRequestCounts.entries()) {\n    if (now - data.windowStart > 120000) { // Clean up entries older than 2 minutes\n      ipRequestCounts.delete(ip);\n    }\n  }\n}, 300000);\n\n/**\n * SECURITY: Check rate limit using Redis with in-memory fallback\n * @param {string} key - Redis key for rate limit counter\n * @param {number} max - Maximum requests allowed\n * @param {number} windowSeconds - Time window in seconds\n * @returns {Promise<{allowed: boolean, remaining: number, resetAt: number}>}\n */\nasync function checkRateLimit(key, max, windowSeconds) {\n  try {\n    // Try Redis first (preferred for multi-instance deployments)\n    // Use isRedisAvailable() function and getRedisClient() to access raw client\n    if (redisClient && redisClient.isRedisAvailable()) {\n      const redis = redisClient.getRedisClient();\n      if (redis) {\n        const current = await redis.incr(key);\n\n        if (current === 1) {\n          // First request in window, set expiry\n          await redis.expire(key, windowSeconds);\n        }\n\n        const ttlValue = await redis.ttl(key);\n        const resetAt = Date.now() + (ttlValue * 1000);\n\n        return {\n          allowed: current <= max,\n          remaining: Math.max(0, max - current),\n          resetAt,\n          retryAfter: ttlValue\n        };\n      }\n    }\n  } catch (redisError) {\n    console.warn('[RateLimiter] Redis error, falling back to in-memory:', redisError.message);\n  }\n  \n  // Fallback to in-memory (single-instance only)\n  const now = Date.now();\n  const windowMs = windowSeconds * 1000;\n  const data = ipRequestCounts.get(key);\n  \n  if (!data || now - data.windowStart > windowMs) {\n    // Start new window\n    ipRequestCounts.set(key, { count: 1, windowStart: now });\n    return {\n      allowed: true,\n      remaining: max - 1,\n      resetAt: now + windowMs,\n      retryAfter: windowSeconds\n    };\n  }\n  \n  data.count++;\n  const allowed = data.count <= max;\n  const remaining = Math.max(0, max - data.count);\n  const resetAt = data.windowStart + windowMs;\n  const retryAfter = Math.ceil((resetAt - now) / 1000);\n  \n  return {\n    allowed,\n    remaining,\n    resetAt,\n    retryAfter\n  };\n}\n\n/**\n * SECURITY: IP-based rate limiting middleware with tiered limits\n * Authenticated users get higher limits than anonymous users\n * Returns 429 with Retry-After header when limit exceeded\n */\nfunction ipRateLimit(req, res, next) {\n  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n  \n  // Determine if user is authenticated (check for valid JWT token)\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n  const isAuthenticated = !!token; // Simple check, validation happens in requireCredits\n  \n  // Select appropriate rate limit\n  const limit = isAuthenticated\n    ? RATE_LIMITS.global.authenticated\n    : RATE_LIMITS.global.anonymous;\n  \n  const rateLimitKey = `ratelimit:global:${clientIp}`;\n  \n  checkRateLimit(rateLimitKey, limit.max, limit.window)\n    .then(result => {\n      // Add rate limit headers (industry standard)\n      res.set('X-RateLimit-Limit', limit.max.toString());\n      res.set('X-RateLimit-Remaining', result.remaining.toString());\n      res.set('X-RateLimit-Reset', Math.floor(result.resetAt / 1000).toString());\n      \n      if (!result.allowed) {\n        // SECURITY: Return 429 with Retry-After header\n        res.set('Retry-After', result.retryAfter.toString());\n        console.warn(`[SECURITY] Global rate limit exceeded for IP: ${clientIp} (${isAuthenticated ? 'authenticated' : 'anonymous'})`);\n        return res.status(429).json({\n          error: 'Too many requests',\n          message: 'Please slow down and try again later',\n          retryAfter: result.retryAfter,\n          limit: limit.max,\n          window: limit.window\n        });\n      }\n      \n      next();\n    })\n    .catch(err => {\n      console.error('[RateLimiter] Error checking rate limit:', err);\n      // On error, allow request but log warning\n      console.warn('[RateLimiter] Rate limit check failed, allowing request');\n      next();\n    });\n}\n\n/**\n * SECURITY: Endpoint-specific rate limiting\n * Stricter limits for sensitive operations like authentication and file uploads\n * @param {string} endpointKey - Key from RATE_LIMITS.endpoints\n */\nfunction endpointRateLimit(endpointKey) {\n  return async (req, res, next) => {\n    const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n    const limit = RATE_LIMITS.endpoints[endpointKey];\n    \n    if (!limit) {\n      console.warn(`[RateLimiter] No rate limit configured for endpoint: ${endpointKey}`);\n      return next();\n    }\n    \n    const rateLimitKey = `ratelimit:endpoint:${endpointKey}:${clientIp}`;\n    \n    try {\n      const result = await checkRateLimit(rateLimitKey, limit.max, limit.window);\n      \n      // Add rate limit headers\n      res.set('X-RateLimit-Limit', limit.max.toString());\n      res.set('X-RateLimit-Remaining', result.remaining.toString());\n      res.set('X-RateLimit-Reset', Math.floor(result.resetAt / 1000).toString());\n      \n      if (!result.allowed) {\n        // SECURITY: Return 429 with Retry-After header\n        res.set('Retry-After', result.retryAfter.toString());\n        console.warn(`[SECURITY] Endpoint rate limit exceeded for ${endpointKey} from IP: ${clientIp}`);\n        return res.status(429).json({\n          error: 'Too many requests',\n          message: `Rate limit exceeded for this operation. Please try again in ${result.retryAfter} seconds.`,\n          retryAfter: result.retryAfter,\n          limit: limit.max,\n          window: limit.window\n        });\n      }\n      \n      next();\n    } catch (err) {\n      console.error(`[RateLimiter] Error checking endpoint rate limit for ${endpointKey}:`, err);\n      // On error, allow request but log warning\n      console.warn('[RateLimiter] Endpoint rate limit check failed, allowing request');\n      next();\n    }\n  };\n}\n\n// Rate limiting for legacy auth attempts (prevent brute force)\nconst legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\nconst LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\nconst LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n\n/**\n * Check if IP is rate limited for legacy auth\n */\nfunction isLegacyAuthRateLimited(ip) {\n  const now = Date.now();\n  const attempt = legacyAuthAttempts.get(ip);\n\n  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n    return false;\n  }\n\n  attempt.count++;\n  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n    return true;\n  }\n\n  return false;\n}\n\n// Default estimated duration for reservation (1 minute = 60 seconds)\nconst DEFAULT_RESERVATION_SECONDS = 60;\n\n/**\n * Middleware to check and atomically reserve credits before processing\n *\n * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n * Falls back to legacy x-stripe-customer-id header (deprecated)\n *\n * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n *\n * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n * where multiple concurrent requests could all pass credit check.\n */\nfunction requireCredits(options = {}) {\n  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n\n  return async (req, res, next) => {\n    // SECURITY: Primary auth via JWT token\n    const authHeader = req.headers['authorization'];\n    const token = extractBearerToken(authHeader);\n\n    let stripeCustomerId = null;\n\n    if (token) {\n      const decoded = await verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n        req.tokenData = decoded;\n      } else {\n        // Token present but invalid\n        return res.status(401).json({\n          error: 'Invalid or expired token',\n          message: 'Please log in again to continue'\n        });\n      }\n    } else {\n      // DEPRECATED: Fallback to legacy header\n      const legacyId = req.headers['x-stripe-customer-id'];\n      if (legacyId) {\n        // SECURITY: Block legacy auth in production unless explicitly enabled\n        if (isProduction && !ALLOW_LEGACY_AUTH) {\n          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n          return res.status(401).json({\n            error: 'Authentication method not supported',\n            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n          });\n        }\n\n        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n        if (isLegacyAuthRateLimited(clientIp)) {\n          return res.status(429).json({\n            error: 'Too many authentication attempts',\n            message: 'Please wait before trying again'\n          });\n        }\n\n        // Validate format to prevent injection\n        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n          return res.status(401).json({\n            error: 'Invalid customer ID format',\n            message: 'Customer ID must be a valid Stripe customer ID'\n          });\n        }\n\n        // SECURITY: Verify customer exists in database before accepting\n        const exists = await customerExists(legacyId);\n        if (!exists) {\n          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n          return res.status(401).json({\n            error: 'Invalid customer ID',\n            message: 'Customer not found'\n          });\n        }\n\n        stripeCustomerId = legacyId;\n        req.isLegacyAuth = true;\n        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n      }\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Missing Stripe customer ID'\n      });\n    }\n\n    // Store for later use\n    req.stripeCustomerId = stripeCustomerId;\n\n    // Determine estimated duration - use request value, option value, or default\n    const estSeconds = req.estimatedDuration || estimatedSeconds;\n\n    try {\n      // Atomically reserve credits using SELECT...FOR UPDATE\n      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n\n      if (!reservation.success) {\n        // Reservation failed - not enough credits\n        const balance = await getBalance(stripeCustomerId);\n        return res.status(402).json({\n          error: 'Insufficient credits',\n          message: 'Please upgrade your plan or wait for your next billing cycle',\n          balance: {\n            hoursRemaining: balance.hoursRemaining,\n            tier: balance.tier\n          }\n        });\n      }\n\n      // Store reservation info for confirmation/release\n      req.reservation = {\n        id: reservation.reservationId,\n        seconds: estSeconds,\n        hoursReserved: reservation.hoursReserved\n      };\n\n      // Attach helper function to confirm usage with actual duration\n      // This adjusts the reservation if actual duration differs\n      req.deductUsage = async (actualDurationSeconds) => {\n        return await confirmReservation(\n          stripeCustomerId,\n          actualDurationSeconds,\n          estSeconds,\n          endpoint\n        );\n      };\n\n      // Attach helper function to release reservation on failure\n      req.releaseReservation = async (reason = 'processing_failed') => {\n        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n      };\n\n      // Hook into response to auto-release on error responses\n      const originalSend = res.send.bind(res);\n      res.send = function(body) {\n        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n        }\n        return originalSend(body);\n      };\n\n      next();\n    } catch (err) {\n      console.error('[RateLimiter] Error reserving credits:', err);\n      return res.status(500).json({\n        error: 'Credit check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Middleware to enforce tier-based feature access\n *\n * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n *\n * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n */\nfunction requireFeature(featureName) {\n  return async (req, res, next) => {\n    // Must have stripeCustomerId from requireCredits middleware\n    if (!req.stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please log in to access this feature'\n      });\n    }\n\n    try {\n      // Get user's current balance (includes tier info)\n      const balance = await getBalance(req.stripeCustomerId);\n\n      // Check if user's tier has access to this feature\n      if (!hasFeatureAccess(balance.tier, featureName)) {\n        // Release any reserved credits since we're blocking the request\n        if (req.releaseReservation) {\n          await req.releaseReservation('feature_not_available');\n        }\n\n        // Determine required tier for helpful error message\n        const requiredTier = getRequiredTierForFeature(featureName);\n\n        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n\n        return res.status(403).json({\n          error: 'Feature not available',\n          message: `This feature requires a ${requiredTier} plan or higher`,\n          requiredFeature: featureName,\n          requiredTier: requiredTier,\n          currentTier: balance.tier\n        });\n      }\n\n      // Feature access granted\n      next();\n    } catch (err) {\n      console.error('[requireFeature] Error checking feature access:', err);\n      return res.status(500).json({\n        error: 'Feature access check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Helper to determine required tier for a feature\n * Used for helpful error messages\n */\nfunction getRequiredTierForFeature(featureName) {\n  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n\n  if (teamOnlyFeatures.includes(featureName)) {\n    return 'Team';\n  } else if (proFeatures.includes(featureName)) {\n    return 'Pro';\n  }\n  return 'Starter';\n}\n\n/**\n * Middleware to track usage after successful response\n *\n * Call this after processing to deduct actual usage\n */\nfunction trackUsage(endpoint = 'unknown') {\n  return async (req, res, next) => {\n    // Store original json method\n    const originalJson = res.json.bind(res);\n\n    // Override json to track usage on success\n    res.json = async (data) => {\n      // Only deduct on successful responses\n      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n        try {\n          const balance = await deductUsage(\n            req.stripeCustomerId,\n            req.audioDuration,\n            endpoint\n          );\n          // Attach updated balance to response\n          data.balance = balance;\n        } catch (err) {\n          console.error('[RateLimiter] Error deducting usage:', err);\n        }\n      }\n      return originalJson(data);\n    };\n\n    next();\n  };\n}\n\nmodule.exports = {\n  requireCredits,\n  requireFeature,\n  trackUsage,\n  ipRateLimit\n};\n","numLines":527,"startLine":1,"totalLines":527}}}
{"parentUuid":"73e5328e-db6c-45a5-9e36-ec159afaddc1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016VyFxF8rLohShf6S9v4WYD","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Panel Configuration\n     3→ * Backend URLs, paths, and utility functions\n     4→ */\n     5→\n     6→// ============================================================================\n     7→// DEBUG MODE CONFIGURATION\n     8→// ============================================================================\n     9→\n    10→/**\n    11→ * Debug mode flag - enables verbose diagnostic logging\n    12→ * Can be enabled via localStorage for troubleshooting:\n    13→ *   localStorage.setItem('spliceDebugMode', 'true');\n    14→ *\n    15→ * Default: false (production mode - minimal logging)\n    16→ */\n    17→const SPLICE_DEBUG = localStorage.getItem('spliceDebugMode') === 'true';\n    18→\n    19→/**\n    20→ * Debug logging function - only outputs when debug mode is enabled\n    21→ * Use this for diagnostic/development logging that should be silent in production\n    22→ * @param {...any} args - Arguments to log (prefixed with [SPLICE DEBUG])\n    23→ */\n    24→function debugLog(...args) {\n    25→    if (SPLICE_DEBUG) {\n    26→        console.log('[SPLICE DEBUG]', ...args);\n    27→    }\n    28→}\n    29→\n    30→/**\n    31→ * Debug fetch logging - verbose fetch request/response logging\n    32→ * @param {...any} args - Arguments to log (prefixed with [SPLICE FETCH])\n    33→ */\n    34→function debugFetch(...args) {\n    35→    if (SPLICE_DEBUG) {\n    36→        console.log('[SPLICE FETCH]', ...args);\n    37→    }\n    38→}\n    39→\n    40→// ============================================================================\n    41→// BACKEND CONFIGURATION\n    42→// ============================================================================\n    43→const SPLICE_CONFIG = {\n    44→    VERSION: '6.0.3',\n    45→    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    46→    BACKEND_DEV: 'https://127.0.0.1:3847',\n    47→    FETCH_TIMEOUT: 120000, // 2 minutes\n    48→    RETRY_ATTEMPTS: 3,\n    49→    RETRY_DELAY: 1000\n    50→};\n    51→\n    52→/**\n    53→ * Get the backend URL based on environment\n    54→ * FIXED: CEP panels always run from file://, so we default to PROD\n    55→ * Use localStorage to override for local development if needed\n    56→ */\n    57→function getBackendUrl() {\n    58→    // Priority 1: Allow override via localStorage (for local dev testing)\n    59→    const customUrl = localStorage.getItem('spliceBackendUrl');\n    60→    if (customUrl) {\n    61→        debugLog('Using custom backend URL from localStorage:', customUrl);\n    62→        return customUrl;\n    63→    }\n    64→\n    65→    // Priority 2: Default to production backend\n    66→    // (CEP panels always run from file://, so can't reliably detect dev mode)\n    67→    debugLog('Using production backend URL:', SPLICE_CONFIG.BACKEND_PROD);\n    68→    return SPLICE_CONFIG.BACKEND_PROD;\n    69→}\n    70→\n    71→// ============================================================================\n    72→// JSX BRIDGE - Communicate with Premiere Pro\n    73→// ============================================================================\n    74→const jsx = {\n    75→    cs: null,\n    76→    _initPromise: null,\n    77→    _initialized: false,\n    78→\n    79→    /**\n    80→     * Initialize the CSInterface\n    81→     * Returns a promise that resolves when ready (true/false)\n    82→     * Does NOT reject - gracefully handles missing CEP environment\n    83→     */\n    84→    init: function() {\n    85→        if (this._initPromise) return this._initPromise;\n    86→\n    87→        this._initPromise = new Promise((resolve) => {\n    88→            try {\n    89→                if (typeof CSInterface !== 'undefined') {\n    90→                    this.cs = new CSInterface();\n    91→                    // Verify we're in a real CEP environment by checking for __adobe_cep__\n    92→                    if (window.__adobe_cep__) {\n    93→                        this._initialized = true;\n    94→                        debugLog('[JSX] CSInterface initialized successfully (CEP environment detected)');\n    95→                    } else {\n    96→                        // CSInterface exists but no CEP runtime - browser/dev mode\n    97→                        this._initialized = true;\n    98→                        debugLog('[JSX] CSInterface initialized (development/browser mode)');\n    99→                    }\n   100→                } else {\n   101→                    console.warn('[JSX] CSInterface not available - panel may not function correctly');\n   102→                    this._initialized = false;\n   103→                }\n   104→            } catch (err) {\n   105→                console.error('[JSX] Failed to initialize CSInterface:', err);\n   106→                this._initialized = false;\n   107→            }\n   108→            resolve(this._initialized);\n   109→        });\n   110→\n   111→        return this._initPromise;\n   112→    },\n   113→\n   114→    /**\n   115→     * Ensure JSX is initialized before making calls\n   116→     */\n   117→    ensureInitialized: async function() {\n   118→        if (!this._initialized) {\n   119→            await this.init();\n   120→        }\n   121→        if (!this.cs) {\n   122→            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n   123→        }\n   124→    },\n   125→\n   126→    /**\n   127→     * Execute ExtendScript in Premiere Pro\n   128→     * @param {string} script - ExtendScript to execute\n   129→     * @returns {Promise<any>} - Parsed result\n   130→     */\n   131→    evalScript: async function(script) {\n   132→        await this.ensureInitialized();\n   133→\n   134→        return new Promise((resolve, reject) => {\n   135→            this.cs.evalScript(script, (result) => {\n   136→                if (result === 'undefined' || result === undefined) {\n   137→                    resolve(null);\n   138→                    return;\n   139→                }\n   140→\n   141→                // Check for EvalScript error or ExtendScript runtime errors\n   142→                if (typeof result === 'string' && (\n   143→                    result.indexOf('EvalScript error') !== -1 ||\n   144→                    result.indexOf('Error:') !== -1 ||\n   145→                    result.indexOf('TypeError:') !== -1 ||\n   146→                    result.indexOf('ReferenceError:') !== -1\n   147→                )) {\n   148→                    reject(new Error(result));\n   149→                    return;\n   150→                }\n   151→\n   152→                // Try to parse JSON\n   153→                try {\n   154→                    const parsed = JSON.parse(result);\n   155→                    if (parsed.error) {\n   156→                        reject(new Error(parsed.error));\n   157→                    } else {\n   158→                        resolve(parsed);\n   159→                    }\n   160→                } catch (e) {\n   161→                    // Return as-is if not JSON\n   162→                    resolve(result);\n   163→                }\n   164→            });\n   165→        });\n   166→    },\n   167→\n   168→    /**\n   169→     * Call a JSX function with arguments\n   170→     * @param {string} funcName - Function name\n   171→     * @param {...any} args - Arguments to pass\n   172→     * @returns {Promise<any>}\n   173→     */\n   174→    call: async function(funcName, ...args) {\n   175→        await this.ensureInitialized();\n   176→\n   177→        const escapedArgs = args.map(arg => {\n   178→            if (arg === null || arg === undefined) return 'null';\n   179→            if (typeof arg === 'string') {\n   180→                // Escape backslashes first, then other special chars\n   181→                return `'${arg\n   182→                    .replace(/\\\\/g, '\\\\\\\\')\n   183→                    .replace(/'/g, \"\\\\'\")\n   184→                    .replace(/\\r/g, '\\\\r')\n   185→                    .replace(/\\n/g, '\\\\n')\n   186→                    .replace(/\\t/g, '\\\\t')}'`;\n   187→            }\n   188→            if (typeof arg === 'object') {\n   189→                return `'${JSON.stringify(arg)\n   190→                    .replace(/\\\\/g, '\\\\\\\\')\n   191→                    .replace(/'/g, \"\\\\'\")}'`;\n   192→            }\n   193→            return String(arg);\n   194→        });\n   195→\n   196→        const script = `${funcName}(${escapedArgs.join(', ')})`;\n   197→        return this.evalScript(script);\n   198→    }\n   199→};\n   200→\n   201→// ============================================================================\n   202→// FETCH UTILITIES\n   203→// ============================================================================\n   204→\n   205→/**\n   206→ * Fetch with timeout support\n   207→ * @param {string} url - URL to fetch\n   208→ * @param {object} options - Fetch options\n   209→ * @param {number} timeout - Timeout in ms\n   210→ */\n   211→async function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n   212→    // DIAGNOSTIC: Log fetch request details (debug mode only)\n   213→    debugFetch('=== FETCH REQUEST START ===');\n   214→    debugFetch('URL:', url);\n   215→    debugFetch('Method:', options?.method || 'GET');\n   216→    debugFetch('Headers:', options?.headers);\n   217→    debugFetch('Timeout:', timeout);\n   218→    debugFetch('Is CEP environment:', typeof CSInterface !== 'undefined');\n   219→    debugFetch('=================================');\n   220→\n   221→    const controller = new AbortController();\n   222→    const timeoutId = setTimeout(() => controller.abort(), timeout);\n   223→\n   224→    try {\n   225→        const response = await fetch(url, {\n   226→            ...options,\n   227→            signal: controller.signal\n   228→        });\n   229→        clearTimeout(timeoutId);\n   230→\n   231→        // DIAGNOSTIC: Log successful response (debug mode only)\n   232→        debugFetch('=== FETCH RESPONSE SUCCESS ===');\n   233→        debugFetch('Status:', response.status);\n   234→        debugFetch('OK:', response.ok);\n   235→        debugFetch('=================================');\n   236→\n   237→        return response;\n   238→    } catch (error) {\n   239→        clearTimeout(timeoutId);\n   240→\n   241→        // DIAGNOSTIC: Log raw fetch error (debug mode only)\n   242→        debugFetch('=== FETCH ERROR CAUGHT ===');\n   243→        debugFetch('Error name:', error?.name);\n   244→        debugFetch('Error message:', error?.message);\n   245→        debugFetch('Error type:', typeof error);\n   246→        debugFetch('Error constructor:', error?.constructor?.name);\n   247→        debugFetch('Is AbortError:', error.name === 'AbortError');\n   248→        debugFetch('Is TypeError:', error.name === 'TypeError');\n   249→        debugFetch('Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\n   250→        debugFetch('=================================');\n   251→\n   252→        if (error.name === 'AbortError') {\n   253→            throw new Error(`Request timeout after ${timeout}ms`);\n   254→        }\n   255→        throw error;\n   256→    }\n   257→}\n   258→\n   259→/**\n   260→ * Parse error response from backend\n   261→ * @param {Response} response - Fetch response\n   262→ */\n   263→async function parseErrorResponse(response) {\n   264→    try {\n   265→        const data = await response.json();\n   266→        return data.error || data.message || `HTTP ${response.status}`;\n   267→    } catch {\n   268→        return `HTTP ${response.status}: ${response.statusText}`;\n   269→    }\n   270→}\n   271→\n   272→/**\n   273→ * Get auth headers for API requests\n   274→ */\n   275→function getAuthHeaders() {\n   276→    const headers = { 'Content-Type': 'application/json' };\n   277→    const settings = getSettings();\n   278→\n   279→    if (settings.customerId) {\n   280→        headers['x-stripe-customer-id'] = settings.customerId;\n   281→    }\n   282→    if (settings.licenseKey) {\n   283→        headers['x-license-key'] = settings.licenseKey;\n   284→    }\n   285→\n   286→    return headers;\n   287→}\n   288→\n   289→// ============================================================================\n   290→// SETTINGS MANAGEMENT\n   291→// ============================================================================\n   292→\n   293→const DEFAULT_SETTINGS = {\n   294→    sensitivity: 50,\n   295→    minSilenceLength: 0.5,\n   296→    sourceIsolated: false,\n   297→    enableTakesDetection: true,\n   298→    enableJCut: false,\n   299→    jcutLeadIn: 0.3,\n   300→    jcutLeadOut: 0.2,\n   301→    enableZoom: false,\n   302→    zoomFrequency: 'medium',\n   303→    zoomPreset: 'medium',\n   304→    zoomPlacement: 'sentence_start',\n   305→    enableChapters: false,\n   306→    maxChapters: 10,\n   307→    minChapterLength: 60,\n   308→    enableProfanity: false,\n   309→    profanityLanguage: 'en',\n   310→    bleepType: 'standard',\n   311→    customerId: null,\n   312→    licenseKey: null,\n   313→    expandedOptions: false,\n   314→    activePreset: 'podcast',\n   315→    rememberOptions: false\n   316→};\n   317→\n   318→// Current storage version for future migrations\n   319→const SETTINGS_STORAGE_VERSION = 1;\n   320→\n   321→// Fields that contain sensitive data and should be encrypted\n   322→const SENSITIVE_FIELDS = ['customerId', 'licenseKey'];\n   323→\n   324→// ============================================================================\n   325→// ENCRYPTION HELPERS FOR SENSITIVE DATA\n   326→// ============================================================================\n   327→\n   328→/**\n   329→ * Simple obfuscation for localStorage\n   330→ * NOTE: This is NOT cryptographically secure, but provides basic protection\n   331→ * against casual inspection of localStorage. For truly sensitive data,\n   332→ * consider server-side storage or proper encryption libraries.\n   333→ *\n   334→ * @param {any} data - Data to encode\n   335→ * @returns {string|null} Encoded string or null on error\n   336→ */\n   337→function encryptForStorage(data) {\n   338→    try {\n   339→        if (data === null || data === undefined) {\n   340→            return null;\n   341→        }\n   342→        // Double encode to add slight obfuscation layer\n   343→        const jsonStr = JSON.stringify(data);\n   344→        const encoded = encodeURIComponent(jsonStr);\n   345→        return btoa(encoded);\n   346→    } catch (e) {\n   347→        debugLog('[Config] Encryption error:', e);\n   348→        return null;\n   349→    }\n   350→}\n   351→\n   352→/**\n   353→ * Decode obfuscated data from localStorage\n   354→ *\n   355→ * @param {string} data - Encoded string\n   356→ * @returns {any|null} Decoded data or null on error\n   357→ */\n   358→function decryptFromStorage(data) {\n   359→    try {\n   360→        if (!data || typeof data !== 'string') {\n   361→            return null;\n   362→        }\n   363→        const decoded = atob(data);\n   364→        const jsonStr = decodeURIComponent(decoded);\n   365→        return JSON.parse(jsonStr);\n   366→    } catch (e) {\n   367→        // This is expected for unencrypted legacy data - don't log as warning\n   368→        return null;\n   369→    }\n   370→}\n   371→\n   372→/**\n   373→ * Check if a value appears to be encrypted (base64 encoded JSON)\n   374→ *\n   375→ * @param {any} value - Value to check\n   376→ * @returns {boolean} True if value appears to be encrypted\n   377→ */\n   378→function isEncryptedValue(value) {\n   379→    if (!value || typeof value !== 'string') {\n   380→        return false;\n   381→    }\n   382→    // Unencrypted values typically start with known patterns\n   383→    // (e.g., \"cus_\" for Stripe customer IDs, \"SPLICE-\" for license keys)\n   384→    if (value.startsWith('cus_') || value.startsWith('SPLICE-')) {\n   385→        return false;\n   386→    }\n   387→    // Check if it's a valid base64 string that decodes to valid JSON\n   388→    try {\n   389→        const decoded = atob(value);\n   390→        const jsonStr = decodeURIComponent(decoded);\n   391→        JSON.parse(jsonStr);\n   392→        return true;\n   393→    } catch {\n   394→        return false;\n   395→    }\n   396→}\n   397→\n   398→/**\n   399→ * Encrypt sensitive fields in settings object\n   400→ *\n   401→ * @param {Object} settings - Settings object with plaintext sensitive fields\n   402→ * @returns {Object} Settings with encrypted sensitive fields\n   403→ */\n   404→function encryptSensitiveFields(settings) {\n   405→    const encrypted = { ...settings };\n   406→\n   407→    for (const field of SENSITIVE_FIELDS) {\n   408→        if (encrypted[field] !== null && encrypted[field] !== undefined) {\n   409→            // Only encrypt if not already encrypted\n   410→            if (!isEncryptedValue(encrypted[field])) {\n   411→                encrypted[field] = encryptForStorage(encrypted[field]);\n   412→                debugLog(`[Config] Encrypted field: ${field}`);\n   413→            }\n   414→        }\n   415→    }\n   416→\n   417→    return encrypted;\n   418→}\n   419→\n   420→/**\n   421→ * Decrypt sensitive fields in settings object\n   422→ *\n   423→ * @param {Object} settings - Settings object with encrypted sensitive fields\n   424→ * @returns {Object} Settings with decrypted sensitive fields\n   425→ */\n   426→function decryptSensitiveFields(settings) {\n   427→    const decrypted = { ...settings };\n   428→\n   429→    for (const field of SENSITIVE_FIELDS) {\n   430→        if (decrypted[field] !== null && decrypted[field] !== undefined) {\n   431→            // Check if it looks encrypted before attempting to decrypt\n   432→            if (isEncryptedValue(decrypted[field])) {\n   433→                const decryptedValue = decryptFromStorage(decrypted[field]);\n   434→                if (decryptedValue !== null) {\n   435→                    decrypted[field] = decryptedValue;\n   436→                    debugLog(`[Config] Decrypted field: ${field}`);\n   437→                }\n   438→            }\n   439→            // If not encrypted (legacy data), keep the original value\n   440→        }\n   441→    }\n   442→\n   443→    return decrypted;\n   444→}\n   445→\n   446→/**\n   447→ * Internal save function to avoid recursion during migration\n   448→ * @private\n   449→ */\n   450→function _saveSettingsInternal(settings) {\n   451→    try {\n   452→        // Encrypt sensitive fields before storing\n   453→        const toStore = encryptSensitiveFields(settings);\n   454→\n   455→        // Add version marker for future migrations\n   456→        toStore._storageVersion = SETTINGS_STORAGE_VERSION;\n   457→\n   458→        localStorage.setItem('spliceSettings', JSON.stringify(toStore));\n   459→        return true;\n   460→    } catch (e) {\n   461→        console.warn('[Config] Error saving settings:', e);\n   462→        return false;\n   463→    }\n   464→}\n   465→\n   466→/**\n   467→ * Get settings from localStorage\n   468→ * Handles migration from unencrypted to encrypted storage format\n   469→ */\n   470→function getSettings() {\n   471→    try {\n   472→        const stored = localStorage.getItem('spliceSettings');\n   473→        if (stored) {\n   474→            const parsed = JSON.parse(stored);\n   475→\n   476→            // Decrypt sensitive fields (handles both encrypted and legacy unencrypted data)\n   477→            const decrypted = decryptSensitiveFields(parsed);\n   478→\n   479→            // Check if migration is needed (no version marker = legacy data)\n   480→            if (!parsed._storageVersion) {\n   481→                // Migrate legacy data: save with encryption and version marker\n   482→                debugLog('[Config] Migrating legacy settings to encrypted format');\n   483→                const migratedSettings = { ...DEFAULT_SETTINGS, ...decrypted };\n   484→                // Use internal save to avoid infinite recursion\n   485→                _saveSettingsInternal(migratedSettings);\n   486→            }\n   487→\n   488→            // Return merged settings without internal fields\n   489→            const result = { ...DEFAULT_SETTINGS, ...decrypted };\n   490→            delete result._storageVersion;\n   491→            return result;\n   492→        }\n   493→    } catch (e) {\n   494→        console.warn('[Config] Error loading settings:', e);\n   495→    }\n   496→    return { ...DEFAULT_SETTINGS };\n   497→}\n   498→\n   499→/**\n   500→ * Save settings to localStorage\n   501→ * Encrypts sensitive fields before storing\n   502→ */\n   503→function saveSettings(settings) {\n   504→    try {\n   505→        // Get current settings (decrypted) and merge with new settings\n   506→        const current = getSettings();\n   507→        const merged = { ...current, ...settings };\n   508→\n   509→        return _saveSettingsInternal(merged);\n   510→    } catch (e) {\n   511→        console.warn('[Config] Error saving settings:', e);\n   512→        return false;\n   513→    }\n   514→}\n   515→\n   516→/**\n   517→ * Clear specific setting\n   518→ */\n   519→function clearSetting(key) {\n   520→    const settings = getSettings();\n   521→    delete settings[key];\n   522→    _saveSettingsInternal(settings);\n   523→}\n   524→\n   525→// ============================================================================\n   526→// OFFLINE DETECTION\n   527→// ============================================================================\n   528→\n   529→let isOnlineState = true;\n   530→let offlineCheckInterval = null;\n   531→\n   532→/**\n   533→ * Check if online\n   534→ */\n   535→function isOnline() {\n   536→    return isOnlineState && navigator.onLine;\n   537→}\n   538→\n   539→/**\n   540→ * Initialize offline detection\n   541→ */\n   542→function initOfflineDetection() {\n   543→    // Browser events\n   544→    window.addEventListener('online', () => {\n   545→        isOnlineState = true;\n   546→        updateOfflineUI(true);\n   547→    });\n   548→\n   549→    window.addEventListener('offline', () => {\n   550→        isOnlineState = false;\n   551→        updateOfflineUI(false);\n   552→    });\n   553→\n   554→    // Periodic check\n   555→    offlineCheckInterval = setInterval(async () => {\n   556→        try {\n   557→            const response = await fetchWithTimeout(\n   558→                `${getBackendUrl()}/health`,\n   559→                { method: 'GET' },\n   560→                5000\n   561→            );\n   562→            isOnlineState = response.ok;\n   563→        } catch {\n   564→            isOnlineState = false;\n   565→        }\n   566→        updateOfflineUI(isOnlineState);\n   567→    }, 30000);\n   568→}\n   569→\n   570→/**\n   571→ * Update UI based on online state\n   572→ */\n   573→function updateOfflineUI(online) {\n   574→    const goBtn = document.getElementById('goBtn');\n   575→    const status = document.getElementById('status');\n   576→\n   577→    if (goBtn) {\n   578→        goBtn.disabled = !online;\n   579→    }\n   580→\n   581→    if (status) {\n   582→        if (!online) {\n   583→            status.textContent = 'Offline - Check your connection';\n   584→            status.style.color = '#dc3545';\n   585→        } else {\n   586→            // Reset status when back online\n   587→            status.textContent = 'Ready';\n   588→            status.style.color = '#888';\n   589→        }\n   590→    }\n   591→}\n   592→\n   593→// ============================================================================\n   594→// UTILITY FUNCTIONS\n   595→// ============================================================================\n   596→\n   597→/**\n   598→ * SECURITY: Escape HTML to prevent XSS attacks\n   599→ * Use this when inserting untrusted content into innerHTML\n   600→ * @param {string} str - String to escape\n   601→ * @returns {string} Escaped string safe for innerHTML\n   602→ */\n   603→function escapeHtml(str) {\n   604→    if (str === null || str === undefined) return '';\n   605→    if (typeof str !== 'string') str = String(str);\n   606→\n   607→    const escapeMap = {\n   608→        '&': '&amp;',\n   609→        '<': '&lt;',\n   610→        '>': '&gt;',\n   611→        '\"': '&quot;',\n   612→        \"'\": '&#x27;',\n   613→        '/': '&#x2F;',\n   614→        '`': '&#x60;'\n   615→    };\n   616→\n   617→    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n   618→}\n   619→\n   620→/**\n   621→ * SECURITY: Create safe HTML from template with escaped values\n   622→ * @param {TemplateStringsArray} strings - Template strings\n   623→ * @param {...any} values - Values to escape\n   624→ * @returns {string} HTML with escaped values\n   625→ */\n   626→function safeHtml(strings, ...values) {\n   627→    return strings.reduce((result, str, i) => {\n   628→        const value = values[i - 1];\n   629→        const escaped = escapeHtml(value);\n   630→        return result + escaped + str;\n   631→    });\n   632→}\n   633→\n   634→/**\n   635→ * Format time in MM:SS or HH:MM:SS\n   636→ */\n   637→function formatTime(seconds) {\n   638→    if (isNaN(seconds) || seconds < 0) return '0:00';\n   639→\n   640→    const hours = Math.floor(seconds / 3600);\n   641→    const minutes = Math.floor((seconds % 3600) / 60);\n   642→    const secs = Math.floor(seconds % 60);\n   643→\n   644→    if (hours > 0) {\n   645→        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n   646→    }\n   647→    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n   648→}\n   649→\n   650→/**\n   651→ * Set status message\n   652→ */\n   653→function setStatus(message, isError = false) {\n   654→    const status = document.getElementById('status');\n   655→    if (status) {\n   656→        status.textContent = message;\n   657→        status.style.color = isError ? '#dc3545' : '#888';\n   658→    }\n   659→}\n   660→\n   661→/**\n   662→ * Debounce function calls\n   663→ */\n   664→function debounce(func, wait) {\n   665→    let timeout;\n   666→    return function executedFunction(...args) {\n   667→        const later = () => {\n   668→            clearTimeout(timeout);\n   669→            func(...args);\n   670→        };\n   671→        clearTimeout(timeout);\n   672→        timeout = setTimeout(later, wait);\n   673→    };\n   674→}\n   675→\n   676→// ============================================================================\n   677→// PRESET PROFILES\n   678→// ============================================================================\n   679→\n   680→/**\n   681→ * Detection presets for different content types.\n   682→ * Each preset defines optimal settings for a specific use case.\n   683→ */\n   684→const PRESETS = {\n   685→    // Custom - user-defined settings (default)\n   686→    custom: {\n   687→        name: 'Custom',\n   688→        description: 'Your custom settings',\n   689→        icon: 'settings',\n   690→        settings: null // Uses current user settings\n   691→    },\n   692→\n   693→    // Podcast - longer pauses are natural, be conservative\n   694→    podcast: {\n   695→        name: 'Podcast',\n   696→        description: 'Longer natural pauses, J-Cuts enabled',\n   697→        icon: 'mic',\n   698→        settings: {\n   699→            sensitivity: 35,\n   700→            threshold: -35,\n   701→            minSilenceLength: 0.8,\n   702→            paddingStart: 0.15,\n   703→            paddingEnd: 0.15,\n   704→            enableTakesDetection: true,\n   705→            enableJCut: true,\n   706→            jCutLeadIn: 0.3,\n   707→            jCutLeadOut: 0.2\n   708→        }\n   709→    },\n   710→\n   711→    // Interview - balanced, respects speaker pauses\n   712→    interview: {\n   713→        name: 'Interview',\n   714→        description: 'Balanced cuts, J-Cuts for smooth transitions',\n   715→        icon: 'people',\n   716→        settings: {\n   717→            sensitivity: 50,\n   718→            threshold: -32,\n   719→            minSilenceLength: 0.5,\n   720→            paddingStart: 0.12,\n   721→            paddingEnd: 0.08,\n   722→            enableTakesDetection: true,\n   723→            enableJCut: true,\n   724→            jCutLeadIn: 0.25,\n   725→            jCutLeadOut: 0.15\n   726→        }\n   727→    },\n   728→\n   729→    // Reaction video - fast pacing, quick cuts\n   730→    reaction: {\n   731→        name: 'Reaction',\n   732→        description: 'Fast-paced, tight cuts for energy',\n   733→        icon: 'bolt',\n   734→        settings: {\n   735→            sensitivity: 70,\n   736→            threshold: -28,\n   737→            minSilenceLength: 0.3,\n   738→            paddingStart: 0.05,\n   739→            paddingEnd: 0.03,\n   740→            enableTakesDetection: false,\n   741→            enableJCut: false,\n   742→            jCutLeadIn: 0,\n   743→            jCutLeadOut: 0\n   744→        }\n   745→    },\n   746→\n   747→    // Tutorial/Educational - preserve thinking pauses\n   748→    tutorial: {\n   749→        name: 'Tutorial',\n   750→        description: 'Preserves teaching pace, J-Cuts enabled',\n   751→        icon: 'school',\n   752→        settings: {\n   753→            sensitivity: 30,\n   754→            threshold: -38,\n   755→            minSilenceLength: 1.0,\n   756→            paddingStart: 0.2,\n   757→            paddingEnd: 0.15,\n   758→            enableTakesDetection: true,\n   759→            enableJCut: true,\n   760→            jCutLeadIn: 0.35,\n   761→            jCutLeadOut: 0.25\n   762→        }\n   763→    },\n   764→\n   765→    // Vlog/YouTube - punchy edits, engagement-focused\n   766→    vlog: {\n   767→        name: 'Vlog',\n   768→        description: 'Punchy edits for YouTube engagement',\n   769→        icon: 'videocam',\n   770→        settings: {\n   771→            sensitivity: 65,\n   772→            threshold: -30,\n   773→            minSilenceLength: 0.35,\n   774→            paddingStart: 0.08,\n   775→            paddingEnd: 0.05,\n   776→            enableTakesDetection: true,\n   777→            enableJCut: false,\n   778→            jCutLeadIn: 0,\n   779→            jCutLeadOut: 0\n   780→        }\n   781→    }\n   782→};\n   783→\n   784→/**\n   785→ * List of built-in preset IDs\n   786→ */\n   787→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n   788→\n   789→/**\n   790→ * Get all available presets\n   791→ * @returns {Object} All preset definitions\n   792→ */\n   793→function getPresets() {\n   794→    return { ...PRESETS };\n   795→}\n   796→\n   797→/**\n   798→ * Get a specific preset by name\n   799→ * @param {string} presetName - Name of the preset\n   800→ * @returns {Object|null} Preset definition or null if not found\n   801→ */\n   802→function getPreset(presetName) {\n   803→    return PRESETS[presetName] || null;\n   804→}\n   805→\n   806→/**\n   807→ * Check if a preset is a built-in preset\n   808→ * @param {string} id - Preset ID to check\n   809→ * @returns {boolean} True if built-in, false if custom\n   810→ */\n   811→function isBuiltInPreset(id) {\n   812→    return BUILT_IN_PRESET_IDS.includes(id);\n   813→}\n   814→\n   815→/**\n   816→ * Apply a preset to current settings\n   817→ * @param {string} presetName - Name of the preset to apply\n   818→ * @returns {Object} The applied settings\n   819→ */\n   820→function applyPreset(presetName) {\n   821→    const preset = PRESETS[presetName];\n   822→\n   823→    if (!preset) {\n   824→        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n   825→        return getSettings();\n   826→    }\n   827→\n   828→    // Custom preset uses current settings\n   829→    if (presetName === 'custom' || !preset.settings) {\n   830→        saveSettings({ activePreset: 'custom' });\n   831→        return getSettings();\n   832→    }\n   833→\n   834→    // Apply preset settings\n   835→    const newSettings = {\n   836→        ...preset.settings,\n   837→        activePreset: presetName\n   838→    };\n   839→\n   840→    saveSettings(newSettings);\n   841→    debugLog(`Applied preset: ${preset.name}`);\n   842→\n   843→    return getSettings();\n   844→}\n   845→\n   846→/**\n   847→ * Get the currently active preset\n   848→ * @returns {string} Active preset name\n   849→ */\n   850→function getActivePreset() {\n   851→    const settings = getSettings();\n   852→    return settings.activePreset || 'custom';\n   853→}\n   854→\n   855→/**\n   856→ * Initialize preset selector\n   857→ */\n   858→function initPresetSelector() {\n   859→    const presetSelector = document.getElementById('presetSelector');\n   860→    const sensitivitySlider = document.getElementById('sensitivitySlider');\n   861→\n   862→    if (!presetSelector) return;\n   863→\n   864→    // Set initial value from settings\n   865→    const settings = getSettings();\n   866→    presetSelector.value = settings.activePreset || 'podcast';\n   867→\n   868→    // Handle preset change\n   869→    presetSelector.addEventListener('change', () => {\n   870→        const presetId = presetSelector.value;\n   871→        const appliedSettings = applyPreset(presetId);\n   872→\n   873→        // Update sensitivity slider to match preset\n   874→        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n   875→            sensitivitySlider.value = appliedSettings.sensitivity;\n   876→            // Update display value\n   877→            const sensitivityValue = document.getElementById('sensitivityValue');\n   878→            if (sensitivityValue) {\n   879→                sensitivityValue.textContent = appliedSettings.sensitivity;\n   880→            }\n   881→        }\n   882→\n   883→        // Update takes detection checkbox\n   884→        const enableTakesDetection = document.getElementById('enableTakesDetection');\n   885→        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n   886→            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n   887→        }\n   888→\n   889→        // Update J-Cut checkbox\n   890→        const enableJCut = document.getElementById('enableJCut');\n   891→        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n   892→            enableJCut.checked = appliedSettings.enableJCut;\n   893→            // Toggle J-Cut settings visibility\n   894→            const jcutSettings = document.getElementById('jcutSettings');\n   895→            if (jcutSettings) {\n   896→                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n   897→            }\n   898→        }\n   899→\n   900→        const preset = getPreset(presetId);\n   901→        if (preset) {\n   902→            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n   903→        }\n   904→    });\n   905→\n   906→    // Switch to custom when user manually changes sensitivity\n   907→    if (sensitivitySlider) {\n   908→        sensitivitySlider.addEventListener('change', () => {\n   909→            if (presetSelector.value !== 'custom') {\n   910→                presetSelector.value = 'custom';\n   911→                saveSettings({ activePreset: 'custom' });\n   912→            }\n   913→        });\n   914→    }\n   915→}\n   916→\n   917→// ============================================================================\n   918→// LOGIN MODAL\n   919→// ============================================================================\n   920→\n   921→/**\n   922→ * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n   923→ * Character set excludes confusing chars: 0/O, 1/I/L\n   924→ */\n   925→function isValidLicenseKeyFormat(key) {\n   926→    if (!key || typeof key !== 'string') return false;\n   927→    const normalized = key.toUpperCase().trim();\n   928→    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n   929→    return pattern.test(normalized);\n   930→}\n   931→\n   932→/**\n   933→ * Initialize login modal handlers\n   934→ */\n   935→function initLoginModal() {\n   936→    const loginModal = document.getElementById('loginModal');\n   937→    const closeLoginBtn = document.getElementById('closeLoginBtn');\n   938→    const saveLoginBtn = document.getElementById('saveLoginBtn');\n   939→    const licenseKeyInput = document.getElementById('licenseKeyInput');\n   940→    const creditBadge = document.getElementById('creditBadge');\n   941→\n   942→    // Handle credit badge click - retry on error, or show login modal\n   943→    if (creditBadge) {\n   944→        creditBadge.addEventListener('click', async () => {\n   945→            if (creditBadge.classList.contains('error')) {\n   946→                creditBadge.textContent = '...';\n   947→                if (typeof refreshCredits === 'function') {\n   948→                    await refreshCredits();\n   949→                }\n   950→                return;\n   951→            }\n   952→            showLoginModal();\n   953→        });\n   954→    }\n   955→\n   956→    // Close login modal\n   957→    if (closeLoginBtn && loginModal) {\n   958→        closeLoginBtn.addEventListener('click', () => {\n   959→            loginModal.classList.add('hidden');\n   960→        });\n   961→    }\n   962→\n   963→    // Close on backdrop click\n   964→    if (loginModal) {\n   965→        loginModal.addEventListener('click', (e) => {\n   966→            if (e.target === loginModal) {\n   967→                loginModal.classList.add('hidden');\n   968→            }\n   969→        });\n   970→    }\n   971→\n   972→    // Activate license key\n   973→    if (saveLoginBtn) {\n   974→        saveLoginBtn.addEventListener('click', async () => {\n   975→            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n   976→\n   977→            if (!licenseKey) {\n   978→                showLoginError('Please enter your license key');\n   979→                return;\n   980→            }\n   981→\n   982→            if (!isValidLicenseKeyFormat(licenseKey)) {\n   983→                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n   984→                return;\n   985→            }\n   986→\n   987→            saveLoginBtn.disabled = true;\n   988→            saveLoginBtn.textContent = 'Activating...';\n   989→\n   990→            try {\n   991→                const response = await fetchWithTimeout(`${getBackendUrl()}/license/activate`, {\n   992→                    method: 'POST',\n   993→                    headers: { 'Content-Type': 'application/json' },\n   994→                    body: JSON.stringify({ key: licenseKey })\n   995→                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n   996→\n   997→                const result = await response.json();\n   998→\n   999→                if (!result.success) {\n  1000→                    showLoginError(result.error || 'Activation failed');\n  1001→                    return;\n  1002→                }\n  1003→\n  1004→                saveSettings({ customerId: result.customerId });\n  1005→                loginModal?.classList.add('hidden');\n  1006→\n  1007→                if (typeof refreshCredits === 'function') {\n  1008→                    await refreshCredits();\n  1009→                }\n  1010→\n  1011→                setStatus(`License activated! ${result.tierName} tier`);\n  1012→            } catch (err) {\n  1013→                console.error('[SPLICE] License activation error:', err);\n  1014→\n  1015→                // DIAGNOSTIC LOGGING: Capture exact error details (debug mode only)\n  1016→                debugLog('=== CEP LICENSE ACTIVATION ERROR DIAGNOSTICS ===');\n  1017→                debugLog('Error name:', err?.name);\n  1018→                debugLog('Error message:', err?.message);\n  1019→                debugLog('Error stack:', err?.stack);\n  1020→                debugLog('Backend URL:', getBackendUrl());\n  1021→                debugLog('Fetch timeout:', SPLICE_CONFIG.FETCH_TIMEOUT);\n  1022→                debugLog('Is CEP environment:', typeof CSInterface !== 'undefined');\n  1023→                debugLog('User agent:', navigator?.userAgent);\n  1024→                debugLog('Error constructor:', err?.constructor?.name);\n  1025→                debugLog('Is TypeError:', err?.name === 'TypeError');\n  1026→                debugLog('Message contains \"Failed to fetch\":', err?.message?.includes('Failed to fetch'));\n  1027→                debugLog('Message contains \"fetch\":', err?.message?.toLowerCase()?.includes('fetch'));\n  1028→                debugLog('Message contains \"network\":', err?.message?.toLowerCase()?.includes('network'));\n  1029→                debugLog('Message contains \"CORS\":', err?.message?.toLowerCase()?.includes('cors'));\n  1030→                debugLog('Message contains \"SSL\":', err?.message?.toLowerCase()?.includes('ssl'));\n  1031→                debugLog('Message contains \"certificate\":', err?.message?.toLowerCase()?.includes('certificate'));\n  1032→                debugLog('Full error object:', JSON.stringify(err, Object.getOwnPropertyNames(err)));\n  1033→                debugLog('================================================');\n  1034→\n  1035→                // Provide detailed error message based on error type\n  1036→                let errorMessage = 'Connection error. ';\n  1037→\n  1038→                if (err.message === 'Request timed out') {\n  1039→                    errorMessage += 'Server is not responding. Check if backend is running.';\n  1040→                } else if (err.message?.includes('Failed to fetch') || err.name === 'TypeError') {\n  1041→                    errorMessage += `Cannot reach ${getBackendUrl()}. Check network/firewall.`;\n  1042→                } else if (err.message?.includes('CORS')) {\n  1043→                    errorMessage += 'CORS error. Contact support.';\n  1044→                } else if (err.message?.includes('SSL') || err.message?.includes('certificate')) {\n  1045→                    errorMessage += 'SSL certificate error. Try updating your system certificates.';\n  1046→                } else if (err.message) {\n  1047→                    errorMessage += err.message;\n  1048→                } else {\n  1049→                    errorMessage += 'Unknown error. Check console for details.';\n  1050→                }\n  1051→\n  1052→                debugLog('Final error message shown to user:', errorMessage);\n  1053→                showLoginError(errorMessage);\n  1054→            } finally {\n  1055→                saveLoginBtn.disabled = false;\n  1056→                saveLoginBtn.textContent = 'Activate';\n  1057→            }\n  1058→        });\n  1059→    }\n  1060→\n  1061→    // Email lookup\n  1062→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n  1063→    const lookupEmailInput = document.getElementById('lookupEmailInput');\n  1064→\n  1065→    if (lookupLicenseBtn) {\n  1066→        lookupLicenseBtn.addEventListener('click', async () => {\n  1067→            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n  1068→\n  1069→            if (!email) {\n  1070→                showLoginError('Please enter your email address');\n  1071→                return;\n  1072→            }\n  1073→\n  1074→            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  1075→            if (!emailRegex.test(email)) {\n  1076→                showLoginError('Please enter a valid email address');\n  1077→                return;\n  1078→            }\n  1079→\n  1080→            lookupLicenseBtn.disabled = true;\n  1081→            lookupLicenseBtn.textContent = 'Looking up...';\n  1082→\n  1083→            try {\n  1084→                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n  1085→                    method: 'POST',\n  1086→                    headers: { 'Content-Type': 'application/json' },\n  1087→                    body: JSON.stringify({ email })\n  1088→                }, 30000);\n  1089→\n  1090→                const result = await response.json();\n  1091→\n  1092→                // Note: For security, the backend does NOT return the license key directly.\n  1093→                // It sends the key via email to prevent enumeration attacks.\n  1094→                if (result.success) {\n  1095→                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n  1096→                } else {\n  1097→                    showLoginError(result.error || 'Lookup failed. Please try again.');\n  1098→                }\n  1099→            } catch (err) {\n  1100→                console.error('[SPLICE] License lookup error:', err);\n  1101→                showLoginError('Failed to look up license. Please try again.');\n  1102→            } finally {\n  1103→                lookupLicenseBtn.disabled = false;\n  1104→                lookupLicenseBtn.textContent = 'Lookup';\n  1105→            }\n  1106→        });\n  1107→    }\n  1108→\n  1109→    // Handle external URL buttons\n  1110→    // CEP panels cannot use target=\"_blank\" for security reasons.\n  1111→    // Must use CSInterface.openURLInDefaultBrowser() instead.\n  1112→    initExternalLinkButtons();\n  1113→}\n  1114→\n  1115→/**\n  1116→ * Initialize all external link buttons that need CSInterface.openURLInDefaultBrowser()\n  1117→ * CEP panels cannot use target=\"_blank\" due to security restrictions\n  1118→ */\n  1119→function initExternalLinkButtons() {\n  1120→    // Check if CSInterface is available\n  1121→    if (typeof CSInterface === 'undefined') {\n  1122→        console.warn('[SPLICE] CSInterface not available - external links disabled');\n  1123→        return;\n  1124→    }\n  1125→\n  1126→    let cs;\n  1127→    try {\n  1128→        cs = new CSInterface();\n  1129→    } catch (e) {\n  1130→        console.warn('[SPLICE] Failed to create CSInterface:', e.message);\n  1131→        return;\n  1132→    }\n  1133→\n  1134→    // Buy a License button\n  1135→    const buyLicenseBtn = document.querySelector('.btn-buy-license');\n  1136→\n  1137→    if (buyLicenseBtn) {\n  1138→        buyLicenseBtn.addEventListener('click', (e) => {\n  1139→            e.preventDefault();\n  1140→            e.stopPropagation();\n  1141→\n  1142→            // Visual feedback\n  1143→            buyLicenseBtn.textContent = 'Opening...';\n  1144→            buyLicenseBtn.style.backgroundColor = '#28a745';\n  1145→\n  1146→            try {\n  1147→                cs.openURLInDefaultBrowser('https://spliceclips.com/pricing');\n  1148→\n  1149→                // Reset button after a delay\n  1150→                setTimeout(() => {\n  1151→                    buyLicenseBtn.textContent = 'Buy License';\n  1152→                    buyLicenseBtn.style.backgroundColor = '';\n  1153→                }, 2000);\n  1154→            } catch (err) {\n  1155→                console.error('[SPLICE] Failed to open URL:', err.message);\n  1156→                buyLicenseBtn.textContent = 'Error';\n  1157→                buyLicenseBtn.style.backgroundColor = '#dc3545';\n  1158→            }\n  1159→        });\n  1160→    }\n  1161→    \n  1162→    // View Plans button (in upgrade modal)\n  1163→    const viewPlansBtn = document.querySelector('.btn-view-plans');\n  1164→    if (viewPlansBtn) {\n  1165→        viewPlansBtn.addEventListener('click', (e) => {\n  1166→            e.preventDefault();\n  1167→            e.stopPropagation();\n  1168→            const url = viewPlansBtn.dataset.url || 'https://spliceclips.com/pricing';\n  1169→            cs.openURLInDefaultBrowser(url);\n  1170→        });\n  1171→    }\n  1172→    \n  1173→    // Referral link button\n  1174→    const referralBtn = document.querySelector('.btn-referral');\n  1175→    if (referralBtn) {\n  1176→        referralBtn.addEventListener('click', (e) => {\n  1177→            e.preventDefault();\n  1178→            e.stopPropagation();\n  1179→            const url = referralBtn.dataset.url || 'https://splice.video/referrals';\n  1180→            cs.openURLInDefaultBrowser(url);\n  1181→        });\n  1182→    }\n  1183→}\n  1184→\n  1185→/**\n  1186→ * Show login modal\n  1187→ */\n  1188→function showLoginModal() {\n  1189→    const loginModal = document.getElementById('loginModal');\n  1190→    const loginError = document.getElementById('loginError');\n  1191→    if (loginError) loginError.style.display = 'none';\n  1192→    if (loginModal) loginModal.classList.remove('hidden');\n  1193→}\n  1194→\n  1195→/**\n  1196→ * Show login error message\n  1197→ */\n  1198→function showLoginError(message) {\n  1199→    const loginError = document.getElementById('loginError');\n  1200→    if (loginError) {\n  1201→        loginError.textContent = message;\n  1202→        loginError.style.display = 'block';\n  1203→    }\n  1204→}\n  1205→\n  1206→/**\n  1207→ * Check if user is logged in\n  1208→ */\n  1209→function isLoggedIn() {\n  1210→    const settings = getSettings();\n  1211→    return !!settings.customerId;\n  1212→}\n  1213→\n  1214→/**\n  1215→ * Logout - clear customer ID\n  1216→ */\n  1217→function logout() {\n  1218→    saveSettings({ customerId: null });\n  1219→    if (typeof clearCreditsCache === 'function') {\n  1220→        clearCreditsCache();\n  1221→    }\n  1222→    if (typeof updateCreditDisplay === 'function') {\n  1223→        updateCreditDisplay(null);\n  1224→    }\n  1225→    setStatus('Logged out');\n  1226→}\n  1227→\n  1228→// Initialize JSX bridge when loaded\n  1229→document.addEventListener('DOMContentLoaded', () => {\n  1230→    jsx.init();\n  1231→});\n  1232→\n  1233→// Export for modules\n  1234→window.SPLICE_CONFIG = SPLICE_CONFIG;\n  1235→window.SPLICE_DEBUG = SPLICE_DEBUG;\n  1236→window.debugLog = debugLog;\n  1237→window.debugFetch = debugFetch;\n  1238→window.getBackendUrl = getBackendUrl;\n  1239→window.fetchWithTimeout = fetchWithTimeout;\n  1240→window.parseErrorResponse = parseErrorResponse;\n  1241→window.getAuthHeaders = getAuthHeaders;\n  1242→window.getSettings = getSettings;\n  1243→window.saveSettings = saveSettings;\n  1244→window.clearSetting = clearSetting;\n  1245→window.isOnline = isOnline;\n  1246→window.initOfflineDetection = initOfflineDetection;\n  1247→window.formatTime = formatTime;\n  1248→window.setStatus = setStatus;\n  1249→window.debounce = debounce;\n  1250→window.jsx = jsx;\n  1251→window.PRESETS = PRESETS;\n  1252→window.getPresets = getPresets;\n  1253→window.getPreset = getPreset;\n  1254→window.applyPreset = applyPreset;\n  1255→window.getActivePreset = getActivePreset;\n  1256→window.isBuiltInPreset = isBuiltInPreset;\n  1257→window.initPresetSelector = initPresetSelector;\n  1258→window.initLoginModal = initLoginModal;\n  1259→window.showLoginModal = showLoginModal;\n  1260→window.isLoggedIn = isLoggedIn;\n  1261→window.logout = logout;\n  1262→window.escapeHtml = escapeHtml;\n  1263→window.safeHtml = safeHtml;\n  1264→\n\n</system-reminder>\n"}]},"uuid":"06a1c911-aacb-4cd3-89c7-4090c6f955ce","timestamp":"2026-01-11T23:55:40.388Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js","content":"/**\n * SPLICE CEP Panel Configuration\n * Backend URLs, paths, and utility functions\n */\n\n// ============================================================================\n// DEBUG MODE CONFIGURATION\n// ============================================================================\n\n/**\n * Debug mode flag - enables verbose diagnostic logging\n * Can be enabled via localStorage for troubleshooting:\n *   localStorage.setItem('spliceDebugMode', 'true');\n *\n * Default: false (production mode - minimal logging)\n */\nconst SPLICE_DEBUG = localStorage.getItem('spliceDebugMode') === 'true';\n\n/**\n * Debug logging function - only outputs when debug mode is enabled\n * Use this for diagnostic/development logging that should be silent in production\n * @param {...any} args - Arguments to log (prefixed with [SPLICE DEBUG])\n */\nfunction debugLog(...args) {\n    if (SPLICE_DEBUG) {\n        console.log('[SPLICE DEBUG]', ...args);\n    }\n}\n\n/**\n * Debug fetch logging - verbose fetch request/response logging\n * @param {...any} args - Arguments to log (prefixed with [SPLICE FETCH])\n */\nfunction debugFetch(...args) {\n    if (SPLICE_DEBUG) {\n        console.log('[SPLICE FETCH]', ...args);\n    }\n}\n\n// ============================================================================\n// BACKEND CONFIGURATION\n// ============================================================================\nconst SPLICE_CONFIG = {\n    VERSION: '6.0.3',\n    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    BACKEND_DEV: 'https://127.0.0.1:3847',\n    FETCH_TIMEOUT: 120000, // 2 minutes\n    RETRY_ATTEMPTS: 3,\n    RETRY_DELAY: 1000\n};\n\n/**\n * Get the backend URL based on environment\n * FIXED: CEP panels always run from file://, so we default to PROD\n * Use localStorage to override for local development if needed\n */\nfunction getBackendUrl() {\n    // Priority 1: Allow override via localStorage (for local dev testing)\n    const customUrl = localStorage.getItem('spliceBackendUrl');\n    if (customUrl) {\n        debugLog('Using custom backend URL from localStorage:', customUrl);\n        return customUrl;\n    }\n\n    // Priority 2: Default to production backend\n    // (CEP panels always run from file://, so can't reliably detect dev mode)\n    debugLog('Using production backend URL:', SPLICE_CONFIG.BACKEND_PROD);\n    return SPLICE_CONFIG.BACKEND_PROD;\n}\n\n// ============================================================================\n// JSX BRIDGE - Communicate with Premiere Pro\n// ============================================================================\nconst jsx = {\n    cs: null,\n    _initPromise: null,\n    _initialized: false,\n\n    /**\n     * Initialize the CSInterface\n     * Returns a promise that resolves when ready (true/false)\n     * Does NOT reject - gracefully handles missing CEP environment\n     */\n    init: function() {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = new Promise((resolve) => {\n            try {\n                if (typeof CSInterface !== 'undefined') {\n                    this.cs = new CSInterface();\n                    // Verify we're in a real CEP environment by checking for __adobe_cep__\n                    if (window.__adobe_cep__) {\n                        this._initialized = true;\n                        debugLog('[JSX] CSInterface initialized successfully (CEP environment detected)');\n                    } else {\n                        // CSInterface exists but no CEP runtime - browser/dev mode\n                        this._initialized = true;\n                        debugLog('[JSX] CSInterface initialized (development/browser mode)');\n                    }\n                } else {\n                    console.warn('[JSX] CSInterface not available - panel may not function correctly');\n                    this._initialized = false;\n                }\n            } catch (err) {\n                console.error('[JSX] Failed to initialize CSInterface:', err);\n                this._initialized = false;\n            }\n            resolve(this._initialized);\n        });\n\n        return this._initPromise;\n    },\n\n    /**\n     * Ensure JSX is initialized before making calls\n     */\n    ensureInitialized: async function() {\n        if (!this._initialized) {\n            await this.init();\n        }\n        if (!this.cs) {\n            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n        }\n    },\n\n    /**\n     * Execute ExtendScript in Premiere Pro\n     * @param {string} script - ExtendScript to execute\n     * @returns {Promise<any>} - Parsed result\n     */\n    evalScript: async function(script) {\n        await this.ensureInitialized();\n\n        return new Promise((resolve, reject) => {\n            this.cs.evalScript(script, (result) => {\n                if (result === 'undefined' || result === undefined) {\n                    resolve(null);\n                    return;\n                }\n\n                // Check for EvalScript error or ExtendScript runtime errors\n                if (typeof result === 'string' && (\n                    result.indexOf('EvalScript error') !== -1 ||\n                    result.indexOf('Error:') !== -1 ||\n                    result.indexOf('TypeError:') !== -1 ||\n                    result.indexOf('ReferenceError:') !== -1\n                )) {\n                    reject(new Error(result));\n                    return;\n                }\n\n                // Try to parse JSON\n                try {\n                    const parsed = JSON.parse(result);\n                    if (parsed.error) {\n                        reject(new Error(parsed.error));\n                    } else {\n                        resolve(parsed);\n                    }\n                } catch (e) {\n                    // Return as-is if not JSON\n                    resolve(result);\n                }\n            });\n        });\n    },\n\n    /**\n     * Call a JSX function with arguments\n     * @param {string} funcName - Function name\n     * @param {...any} args - Arguments to pass\n     * @returns {Promise<any>}\n     */\n    call: async function(funcName, ...args) {\n        await this.ensureInitialized();\n\n        const escapedArgs = args.map(arg => {\n            if (arg === null || arg === undefined) return 'null';\n            if (typeof arg === 'string') {\n                // Escape backslashes first, then other special chars\n                return `'${arg\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")\n                    .replace(/\\r/g, '\\\\r')\n                    .replace(/\\n/g, '\\\\n')\n                    .replace(/\\t/g, '\\\\t')}'`;\n            }\n            if (typeof arg === 'object') {\n                return `'${JSON.stringify(arg)\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")}'`;\n            }\n            return String(arg);\n        });\n\n        const script = `${funcName}(${escapedArgs.join(', ')})`;\n        return this.evalScript(script);\n    }\n};\n\n// ============================================================================\n// FETCH UTILITIES\n// ============================================================================\n\n/**\n * Fetch with timeout support\n * @param {string} url - URL to fetch\n * @param {object} options - Fetch options\n * @param {number} timeout - Timeout in ms\n */\nasync function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n    // DIAGNOSTIC: Log fetch request details (debug mode only)\n    debugFetch('=== FETCH REQUEST START ===');\n    debugFetch('URL:', url);\n    debugFetch('Method:', options?.method || 'GET');\n    debugFetch('Headers:', options?.headers);\n    debugFetch('Timeout:', timeout);\n    debugFetch('Is CEP environment:', typeof CSInterface !== 'undefined');\n    debugFetch('=================================');\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n        const response = await fetch(url, {\n            ...options,\n            signal: controller.signal\n        });\n        clearTimeout(timeoutId);\n\n        // DIAGNOSTIC: Log successful response (debug mode only)\n        debugFetch('=== FETCH RESPONSE SUCCESS ===');\n        debugFetch('Status:', response.status);\n        debugFetch('OK:', response.ok);\n        debugFetch('=================================');\n\n        return response;\n    } catch (error) {\n        clearTimeout(timeoutId);\n\n        // DIAGNOSTIC: Log raw fetch error (debug mode only)\n        debugFetch('=== FETCH ERROR CAUGHT ===');\n        debugFetch('Error name:', error?.name);\n        debugFetch('Error message:', error?.message);\n        debugFetch('Error type:', typeof error);\n        debugFetch('Error constructor:', error?.constructor?.name);\n        debugFetch('Is AbortError:', error.name === 'AbortError');\n        debugFetch('Is TypeError:', error.name === 'TypeError');\n        debugFetch('Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\n        debugFetch('=================================');\n\n        if (error.name === 'AbortError') {\n            throw new Error(`Request timeout after ${timeout}ms`);\n        }\n        throw error;\n    }\n}\n\n/**\n * Parse error response from backend\n * @param {Response} response - Fetch response\n */\nasync function parseErrorResponse(response) {\n    try {\n        const data = await response.json();\n        return data.error || data.message || `HTTP ${response.status}`;\n    } catch {\n        return `HTTP ${response.status}: ${response.statusText}`;\n    }\n}\n\n/**\n * Get auth headers for API requests\n */\nfunction getAuthHeaders() {\n    const headers = { 'Content-Type': 'application/json' };\n    const settings = getSettings();\n\n    if (settings.customerId) {\n        headers['x-stripe-customer-id'] = settings.customerId;\n    }\n    if (settings.licenseKey) {\n        headers['x-license-key'] = settings.licenseKey;\n    }\n\n    return headers;\n}\n\n// ============================================================================\n// SETTINGS MANAGEMENT\n// ============================================================================\n\nconst DEFAULT_SETTINGS = {\n    sensitivity: 50,\n    minSilenceLength: 0.5,\n    sourceIsolated: false,\n    enableTakesDetection: true,\n    enableJCut: false,\n    jcutLeadIn: 0.3,\n    jcutLeadOut: 0.2,\n    enableZoom: false,\n    zoomFrequency: 'medium',\n    zoomPreset: 'medium',\n    zoomPlacement: 'sentence_start',\n    enableChapters: false,\n    maxChapters: 10,\n    minChapterLength: 60,\n    enableProfanity: false,\n    profanityLanguage: 'en',\n    bleepType: 'standard',\n    customerId: null,\n    licenseKey: null,\n    expandedOptions: false,\n    activePreset: 'podcast',\n    rememberOptions: false\n};\n\n// Current storage version for future migrations\nconst SETTINGS_STORAGE_VERSION = 1;\n\n// Fields that contain sensitive data and should be encrypted\nconst SENSITIVE_FIELDS = ['customerId', 'licenseKey'];\n\n// ============================================================================\n// ENCRYPTION HELPERS FOR SENSITIVE DATA\n// ============================================================================\n\n/**\n * Simple obfuscation for localStorage\n * NOTE: This is NOT cryptographically secure, but provides basic protection\n * against casual inspection of localStorage. For truly sensitive data,\n * consider server-side storage or proper encryption libraries.\n *\n * @param {any} data - Data to encode\n * @returns {string|null} Encoded string or null on error\n */\nfunction encryptForStorage(data) {\n    try {\n        if (data === null || data === undefined) {\n            return null;\n        }\n        // Double encode to add slight obfuscation layer\n        const jsonStr = JSON.stringify(data);\n        const encoded = encodeURIComponent(jsonStr);\n        return btoa(encoded);\n    } catch (e) {\n        debugLog('[Config] Encryption error:', e);\n        return null;\n    }\n}\n\n/**\n * Decode obfuscated data from localStorage\n *\n * @param {string} data - Encoded string\n * @returns {any|null} Decoded data or null on error\n */\nfunction decryptFromStorage(data) {\n    try {\n        if (!data || typeof data !== 'string') {\n            return null;\n        }\n        const decoded = atob(data);\n        const jsonStr = decodeURIComponent(decoded);\n        return JSON.parse(jsonStr);\n    } catch (e) {\n        // This is expected for unencrypted legacy data - don't log as warning\n        return null;\n    }\n}\n\n/**\n * Check if a value appears to be encrypted (base64 encoded JSON)\n *\n * @param {any} value - Value to check\n * @returns {boolean} True if value appears to be encrypted\n */\nfunction isEncryptedValue(value) {\n    if (!value || typeof value !== 'string') {\n        return false;\n    }\n    // Unencrypted values typically start with known patterns\n    // (e.g., \"cus_\" for Stripe customer IDs, \"SPLICE-\" for license keys)\n    if (value.startsWith('cus_') || value.startsWith('SPLICE-')) {\n        return false;\n    }\n    // Check if it's a valid base64 string that decodes to valid JSON\n    try {\n        const decoded = atob(value);\n        const jsonStr = decodeURIComponent(decoded);\n        JSON.parse(jsonStr);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Encrypt sensitive fields in settings object\n *\n * @param {Object} settings - Settings object with plaintext sensitive fields\n * @returns {Object} Settings with encrypted sensitive fields\n */\nfunction encryptSensitiveFields(settings) {\n    const encrypted = { ...settings };\n\n    for (const field of SENSITIVE_FIELDS) {\n        if (encrypted[field] !== null && encrypted[field] !== undefined) {\n            // Only encrypt if not already encrypted\n            if (!isEncryptedValue(encrypted[field])) {\n                encrypted[field] = encryptForStorage(encrypted[field]);\n                debugLog(`[Config] Encrypted field: ${field}`);\n            }\n        }\n    }\n\n    return encrypted;\n}\n\n/**\n * Decrypt sensitive fields in settings object\n *\n * @param {Object} settings - Settings object with encrypted sensitive fields\n * @returns {Object} Settings with decrypted sensitive fields\n */\nfunction decryptSensitiveFields(settings) {\n    const decrypted = { ...settings };\n\n    for (const field of SENSITIVE_FIELDS) {\n        if (decrypted[field] !== null && decrypted[field] !== undefined) {\n            // Check if it looks encrypted before attempting to decrypt\n            if (isEncryptedValue(decrypted[field])) {\n                const decryptedValue = decryptFromStorage(decrypted[field]);\n                if (decryptedValue !== null) {\n                    decrypted[field] = decryptedValue;\n                    debugLog(`[Config] Decrypted field: ${field}`);\n                }\n            }\n            // If not encrypted (legacy data), keep the original value\n        }\n    }\n\n    return decrypted;\n}\n\n/**\n * Internal save function to avoid recursion during migration\n * @private\n */\nfunction _saveSettingsInternal(settings) {\n    try {\n        // Encrypt sensitive fields before storing\n        const toStore = encryptSensitiveFields(settings);\n\n        // Add version marker for future migrations\n        toStore._storageVersion = SETTINGS_STORAGE_VERSION;\n\n        localStorage.setItem('spliceSettings', JSON.stringify(toStore));\n        return true;\n    } catch (e) {\n        console.warn('[Config] Error saving settings:', e);\n        return false;\n    }\n}\n\n/**\n * Get settings from localStorage\n * Handles migration from unencrypted to encrypted storage format\n */\nfunction getSettings() {\n    try {\n        const stored = localStorage.getItem('spliceSettings');\n        if (stored) {\n            const parsed = JSON.parse(stored);\n\n            // Decrypt sensitive fields (handles both encrypted and legacy unencrypted data)\n            const decrypted = decryptSensitiveFields(parsed);\n\n            // Check if migration is needed (no version marker = legacy data)\n            if (!parsed._storageVersion) {\n                // Migrate legacy data: save with encryption and version marker\n                debugLog('[Config] Migrating legacy settings to encrypted format');\n                const migratedSettings = { ...DEFAULT_SETTINGS, ...decrypted };\n                // Use internal save to avoid infinite recursion\n                _saveSettingsInternal(migratedSettings);\n            }\n\n            // Return merged settings without internal fields\n            const result = { ...DEFAULT_SETTINGS, ...decrypted };\n            delete result._storageVersion;\n            return result;\n        }\n    } catch (e) {\n        console.warn('[Config] Error loading settings:', e);\n    }\n    return { ...DEFAULT_SETTINGS };\n}\n\n/**\n * Save settings to localStorage\n * Encrypts sensitive fields before storing\n */\nfunction saveSettings(settings) {\n    try {\n        // Get current settings (decrypted) and merge with new settings\n        const current = getSettings();\n        const merged = { ...current, ...settings };\n\n        return _saveSettingsInternal(merged);\n    } catch (e) {\n        console.warn('[Config] Error saving settings:', e);\n        return false;\n    }\n}\n\n/**\n * Clear specific setting\n */\nfunction clearSetting(key) {\n    const settings = getSettings();\n    delete settings[key];\n    _saveSettingsInternal(settings);\n}\n\n// ============================================================================\n// OFFLINE DETECTION\n// ============================================================================\n\nlet isOnlineState = true;\nlet offlineCheckInterval = null;\n\n/**\n * Check if online\n */\nfunction isOnline() {\n    return isOnlineState && navigator.onLine;\n}\n\n/**\n * Initialize offline detection\n */\nfunction initOfflineDetection() {\n    // Browser events\n    window.addEventListener('online', () => {\n        isOnlineState = true;\n        updateOfflineUI(true);\n    });\n\n    window.addEventListener('offline', () => {\n        isOnlineState = false;\n        updateOfflineUI(false);\n    });\n\n    // Periodic check\n    offlineCheckInterval = setInterval(async () => {\n        try {\n            const response = await fetchWithTimeout(\n                `${getBackendUrl()}/health`,\n                { method: 'GET' },\n                5000\n            );\n            isOnlineState = response.ok;\n        } catch {\n            isOnlineState = false;\n        }\n        updateOfflineUI(isOnlineState);\n    }, 30000);\n}\n\n/**\n * Update UI based on online state\n */\nfunction updateOfflineUI(online) {\n    const goBtn = document.getElementById('goBtn');\n    const status = document.getElementById('status');\n\n    if (goBtn) {\n        goBtn.disabled = !online;\n    }\n\n    if (status) {\n        if (!online) {\n            status.textContent = 'Offline - Check your connection';\n            status.style.color = '#dc3545';\n        } else {\n            // Reset status when back online\n            status.textContent = 'Ready';\n            status.style.color = '#888';\n        }\n    }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * SECURITY: Escape HTML to prevent XSS attacks\n * Use this when inserting untrusted content into innerHTML\n * @param {string} str - String to escape\n * @returns {string} Escaped string safe for innerHTML\n */\nfunction escapeHtml(str) {\n    if (str === null || str === undefined) return '';\n    if (typeof str !== 'string') str = String(str);\n\n    const escapeMap = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;',\n        '/': '&#x2F;',\n        '`': '&#x60;'\n    };\n\n    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n}\n\n/**\n * SECURITY: Create safe HTML from template with escaped values\n * @param {TemplateStringsArray} strings - Template strings\n * @param {...any} values - Values to escape\n * @returns {string} HTML with escaped values\n */\nfunction safeHtml(strings, ...values) {\n    return strings.reduce((result, str, i) => {\n        const value = values[i - 1];\n        const escaped = escapeHtml(value);\n        return result + escaped + str;\n    });\n}\n\n/**\n * Format time in MM:SS or HH:MM:SS\n */\nfunction formatTime(seconds) {\n    if (isNaN(seconds) || seconds < 0) return '0:00';\n\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n\n    if (hours > 0) {\n        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Set status message\n */\nfunction setStatus(message, isError = false) {\n    const status = document.getElementById('status');\n    if (status) {\n        status.textContent = message;\n        status.style.color = isError ? '#dc3545' : '#888';\n    }\n}\n\n/**\n * Debounce function calls\n */\nfunction debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n        const later = () => {\n            clearTimeout(timeout);\n            func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n\n// ============================================================================\n// PRESET PROFILES\n// ============================================================================\n\n/**\n * Detection presets for different content types.\n * Each preset defines optimal settings for a specific use case.\n */\nconst PRESETS = {\n    // Custom - user-defined settings (default)\n    custom: {\n        name: 'Custom',\n        description: 'Your custom settings',\n        icon: 'settings',\n        settings: null // Uses current user settings\n    },\n\n    // Podcast - longer pauses are natural, be conservative\n    podcast: {\n        name: 'Podcast',\n        description: 'Longer natural pauses, J-Cuts enabled',\n        icon: 'mic',\n        settings: {\n            sensitivity: 35,\n            threshold: -35,\n            minSilenceLength: 0.8,\n            paddingStart: 0.15,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.3,\n            jCutLeadOut: 0.2\n        }\n    },\n\n    // Interview - balanced, respects speaker pauses\n    interview: {\n        name: 'Interview',\n        description: 'Balanced cuts, J-Cuts for smooth transitions',\n        icon: 'people',\n        settings: {\n            sensitivity: 50,\n            threshold: -32,\n            minSilenceLength: 0.5,\n            paddingStart: 0.12,\n            paddingEnd: 0.08,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.25,\n            jCutLeadOut: 0.15\n        }\n    },\n\n    // Reaction video - fast pacing, quick cuts\n    reaction: {\n        name: 'Reaction',\n        description: 'Fast-paced, tight cuts for energy',\n        icon: 'bolt',\n        settings: {\n            sensitivity: 70,\n            threshold: -28,\n            minSilenceLength: 0.3,\n            paddingStart: 0.05,\n            paddingEnd: 0.03,\n            enableTakesDetection: false,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    },\n\n    // Tutorial/Educational - preserve thinking pauses\n    tutorial: {\n        name: 'Tutorial',\n        description: 'Preserves teaching pace, J-Cuts enabled',\n        icon: 'school',\n        settings: {\n            sensitivity: 30,\n            threshold: -38,\n            minSilenceLength: 1.0,\n            paddingStart: 0.2,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.35,\n            jCutLeadOut: 0.25\n        }\n    },\n\n    // Vlog/YouTube - punchy edits, engagement-focused\n    vlog: {\n        name: 'Vlog',\n        description: 'Punchy edits for YouTube engagement',\n        icon: 'videocam',\n        settings: {\n            sensitivity: 65,\n            threshold: -30,\n            minSilenceLength: 0.35,\n            paddingStart: 0.08,\n            paddingEnd: 0.05,\n            enableTakesDetection: true,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    }\n};\n\n/**\n * List of built-in preset IDs\n */\nconst BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n\n/**\n * Get all available presets\n * @returns {Object} All preset definitions\n */\nfunction getPresets() {\n    return { ...PRESETS };\n}\n\n/**\n * Get a specific preset by name\n * @param {string} presetName - Name of the preset\n * @returns {Object|null} Preset definition or null if not found\n */\nfunction getPreset(presetName) {\n    return PRESETS[presetName] || null;\n}\n\n/**\n * Check if a preset is a built-in preset\n * @param {string} id - Preset ID to check\n * @returns {boolean} True if built-in, false if custom\n */\nfunction isBuiltInPreset(id) {\n    return BUILT_IN_PRESET_IDS.includes(id);\n}\n\n/**\n * Apply a preset to current settings\n * @param {string} presetName - Name of the preset to apply\n * @returns {Object} The applied settings\n */\nfunction applyPreset(presetName) {\n    const preset = PRESETS[presetName];\n\n    if (!preset) {\n        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n        return getSettings();\n    }\n\n    // Custom preset uses current settings\n    if (presetName === 'custom' || !preset.settings) {\n        saveSettings({ activePreset: 'custom' });\n        return getSettings();\n    }\n\n    // Apply preset settings\n    const newSettings = {\n        ...preset.settings,\n        activePreset: presetName\n    };\n\n    saveSettings(newSettings);\n    debugLog(`Applied preset: ${preset.name}`);\n\n    return getSettings();\n}\n\n/**\n * Get the currently active preset\n * @returns {string} Active preset name\n */\nfunction getActivePreset() {\n    const settings = getSettings();\n    return settings.activePreset || 'custom';\n}\n\n/**\n * Initialize preset selector\n */\nfunction initPresetSelector() {\n    const presetSelector = document.getElementById('presetSelector');\n    const sensitivitySlider = document.getElementById('sensitivitySlider');\n\n    if (!presetSelector) return;\n\n    // Set initial value from settings\n    const settings = getSettings();\n    presetSelector.value = settings.activePreset || 'podcast';\n\n    // Handle preset change\n    presetSelector.addEventListener('change', () => {\n        const presetId = presetSelector.value;\n        const appliedSettings = applyPreset(presetId);\n\n        // Update sensitivity slider to match preset\n        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n            sensitivitySlider.value = appliedSettings.sensitivity;\n            // Update display value\n            const sensitivityValue = document.getElementById('sensitivityValue');\n            if (sensitivityValue) {\n                sensitivityValue.textContent = appliedSettings.sensitivity;\n            }\n        }\n\n        // Update takes detection checkbox\n        const enableTakesDetection = document.getElementById('enableTakesDetection');\n        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n        }\n\n        // Update J-Cut checkbox\n        const enableJCut = document.getElementById('enableJCut');\n        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n            enableJCut.checked = appliedSettings.enableJCut;\n            // Toggle J-Cut settings visibility\n            const jcutSettings = document.getElementById('jcutSettings');\n            if (jcutSettings) {\n                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n            }\n        }\n\n        const preset = getPreset(presetId);\n        if (preset) {\n            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n        }\n    });\n\n    // Switch to custom when user manually changes sensitivity\n    if (sensitivitySlider) {\n        sensitivitySlider.addEventListener('change', () => {\n            if (presetSelector.value !== 'custom') {\n                presetSelector.value = 'custom';\n                saveSettings({ activePreset: 'custom' });\n            }\n        });\n    }\n}\n\n// ============================================================================\n// LOGIN MODAL\n// ============================================================================\n\n/**\n * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n * Character set excludes confusing chars: 0/O, 1/I/L\n */\nfunction isValidLicenseKeyFormat(key) {\n    if (!key || typeof key !== 'string') return false;\n    const normalized = key.toUpperCase().trim();\n    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n    return pattern.test(normalized);\n}\n\n/**\n * Initialize login modal handlers\n */\nfunction initLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const closeLoginBtn = document.getElementById('closeLoginBtn');\n    const saveLoginBtn = document.getElementById('saveLoginBtn');\n    const licenseKeyInput = document.getElementById('licenseKeyInput');\n    const creditBadge = document.getElementById('creditBadge');\n\n    // Handle credit badge click - retry on error, or show login modal\n    if (creditBadge) {\n        creditBadge.addEventListener('click', async () => {\n            if (creditBadge.classList.contains('error')) {\n                creditBadge.textContent = '...';\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n                return;\n            }\n            showLoginModal();\n        });\n    }\n\n    // Close login modal\n    if (closeLoginBtn && loginModal) {\n        closeLoginBtn.addEventListener('click', () => {\n            loginModal.classList.add('hidden');\n        });\n    }\n\n    // Close on backdrop click\n    if (loginModal) {\n        loginModal.addEventListener('click', (e) => {\n            if (e.target === loginModal) {\n                loginModal.classList.add('hidden');\n            }\n        });\n    }\n\n    // Activate license key\n    if (saveLoginBtn) {\n        saveLoginBtn.addEventListener('click', async () => {\n            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n\n            if (!licenseKey) {\n                showLoginError('Please enter your license key');\n                return;\n            }\n\n            if (!isValidLicenseKeyFormat(licenseKey)) {\n                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n                return;\n            }\n\n            saveLoginBtn.disabled = true;\n            saveLoginBtn.textContent = 'Activating...';\n\n            try {\n                const response = await fetchWithTimeout(`${getBackendUrl()}/license/activate`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ key: licenseKey })\n                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n                const result = await response.json();\n\n                if (!result.success) {\n                    showLoginError(result.error || 'Activation failed');\n                    return;\n                }\n\n                saveSettings({ customerId: result.customerId });\n                loginModal?.classList.add('hidden');\n\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n\n                setStatus(`License activated! ${result.tierName} tier`);\n            } catch (err) {\n                console.error('[SPLICE] License activation error:', err);\n\n                // DIAGNOSTIC LOGGING: Capture exact error details (debug mode only)\n                debugLog('=== CEP LICENSE ACTIVATION ERROR DIAGNOSTICS ===');\n                debugLog('Error name:', err?.name);\n                debugLog('Error message:', err?.message);\n                debugLog('Error stack:', err?.stack);\n                debugLog('Backend URL:', getBackendUrl());\n                debugLog('Fetch timeout:', SPLICE_CONFIG.FETCH_TIMEOUT);\n                debugLog('Is CEP environment:', typeof CSInterface !== 'undefined');\n                debugLog('User agent:', navigator?.userAgent);\n                debugLog('Error constructor:', err?.constructor?.name);\n                debugLog('Is TypeError:', err?.name === 'TypeError');\n                debugLog('Message contains \"Failed to fetch\":', err?.message?.includes('Failed to fetch'));\n                debugLog('Message contains \"fetch\":', err?.message?.toLowerCase()?.includes('fetch'));\n                debugLog('Message contains \"network\":', err?.message?.toLowerCase()?.includes('network'));\n                debugLog('Message contains \"CORS\":', err?.message?.toLowerCase()?.includes('cors'));\n                debugLog('Message contains \"SSL\":', err?.message?.toLowerCase()?.includes('ssl'));\n                debugLog('Message contains \"certificate\":', err?.message?.toLowerCase()?.includes('certificate'));\n                debugLog('Full error object:', JSON.stringify(err, Object.getOwnPropertyNames(err)));\n                debugLog('================================================');\n\n                // Provide detailed error message based on error type\n                let errorMessage = 'Connection error. ';\n\n                if (err.message === 'Request timed out') {\n                    errorMessage += 'Server is not responding. Check if backend is running.';\n                } else if (err.message?.includes('Failed to fetch') || err.name === 'TypeError') {\n                    errorMessage += `Cannot reach ${getBackendUrl()}. Check network/firewall.`;\n                } else if (err.message?.includes('CORS')) {\n                    errorMessage += 'CORS error. Contact support.';\n                } else if (err.message?.includes('SSL') || err.message?.includes('certificate')) {\n                    errorMessage += 'SSL certificate error. Try updating your system certificates.';\n                } else if (err.message) {\n                    errorMessage += err.message;\n                } else {\n                    errorMessage += 'Unknown error. Check console for details.';\n                }\n\n                debugLog('Final error message shown to user:', errorMessage);\n                showLoginError(errorMessage);\n            } finally {\n                saveLoginBtn.disabled = false;\n                saveLoginBtn.textContent = 'Activate';\n            }\n        });\n    }\n\n    // Email lookup\n    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n    const lookupEmailInput = document.getElementById('lookupEmailInput');\n\n    if (lookupLicenseBtn) {\n        lookupLicenseBtn.addEventListener('click', async () => {\n            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n\n            if (!email) {\n                showLoginError('Please enter your email address');\n                return;\n            }\n\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(email)) {\n                showLoginError('Please enter a valid email address');\n                return;\n            }\n\n            lookupLicenseBtn.disabled = true;\n            lookupLicenseBtn.textContent = 'Looking up...';\n\n            try {\n                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ email })\n                }, 30000);\n\n                const result = await response.json();\n\n                // Note: For security, the backend does NOT return the license key directly.\n                // It sends the key via email to prevent enumeration attacks.\n                if (result.success) {\n                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n                } else {\n                    showLoginError(result.error || 'Lookup failed. Please try again.');\n                }\n            } catch (err) {\n                console.error('[SPLICE] License lookup error:', err);\n                showLoginError('Failed to look up license. Please try again.');\n            } finally {\n                lookupLicenseBtn.disabled = false;\n                lookupLicenseBtn.textContent = 'Lookup';\n            }\n        });\n    }\n\n    // Handle external URL buttons\n    // CEP panels cannot use target=\"_blank\" for security reasons.\n    // Must use CSInterface.openURLInDefaultBrowser() instead.\n    initExternalLinkButtons();\n}\n\n/**\n * Initialize all external link buttons that need CSInterface.openURLInDefaultBrowser()\n * CEP panels cannot use target=\"_blank\" due to security restrictions\n */\nfunction initExternalLinkButtons() {\n    // Check if CSInterface is available\n    if (typeof CSInterface === 'undefined') {\n        console.warn('[SPLICE] CSInterface not available - external links disabled');\n        return;\n    }\n\n    let cs;\n    try {\n        cs = new CSInterface();\n    } catch (e) {\n        console.warn('[SPLICE] Failed to create CSInterface:', e.message);\n        return;\n    }\n\n    // Buy a License button\n    const buyLicenseBtn = document.querySelector('.btn-buy-license');\n\n    if (buyLicenseBtn) {\n        buyLicenseBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n\n            // Visual feedback\n            buyLicenseBtn.textContent = 'Opening...';\n            buyLicenseBtn.style.backgroundColor = '#28a745';\n\n            try {\n                cs.openURLInDefaultBrowser('https://spliceclips.com/pricing');\n\n                // Reset button after a delay\n                setTimeout(() => {\n                    buyLicenseBtn.textContent = 'Buy License';\n                    buyLicenseBtn.style.backgroundColor = '';\n                }, 2000);\n            } catch (err) {\n                console.error('[SPLICE] Failed to open URL:', err.message);\n                buyLicenseBtn.textContent = 'Error';\n                buyLicenseBtn.style.backgroundColor = '#dc3545';\n            }\n        });\n    }\n    \n    // View Plans button (in upgrade modal)\n    const viewPlansBtn = document.querySelector('.btn-view-plans');\n    if (viewPlansBtn) {\n        viewPlansBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const url = viewPlansBtn.dataset.url || 'https://spliceclips.com/pricing';\n            cs.openURLInDefaultBrowser(url);\n        });\n    }\n    \n    // Referral link button\n    const referralBtn = document.querySelector('.btn-referral');\n    if (referralBtn) {\n        referralBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const url = referralBtn.dataset.url || 'https://splice.video/referrals';\n            cs.openURLInDefaultBrowser(url);\n        });\n    }\n}\n\n/**\n * Show login modal\n */\nfunction showLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const loginError = document.getElementById('loginError');\n    if (loginError) loginError.style.display = 'none';\n    if (loginModal) loginModal.classList.remove('hidden');\n}\n\n/**\n * Show login error message\n */\nfunction showLoginError(message) {\n    const loginError = document.getElementById('loginError');\n    if (loginError) {\n        loginError.textContent = message;\n        loginError.style.display = 'block';\n    }\n}\n\n/**\n * Check if user is logged in\n */\nfunction isLoggedIn() {\n    const settings = getSettings();\n    return !!settings.customerId;\n}\n\n/**\n * Logout - clear customer ID\n */\nfunction logout() {\n    saveSettings({ customerId: null });\n    if (typeof clearCreditsCache === 'function') {\n        clearCreditsCache();\n    }\n    if (typeof updateCreditDisplay === 'function') {\n        updateCreditDisplay(null);\n    }\n    setStatus('Logged out');\n}\n\n// Initialize JSX bridge when loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    jsx.init();\n});\n\n// Export for modules\nwindow.SPLICE_CONFIG = SPLICE_CONFIG;\nwindow.SPLICE_DEBUG = SPLICE_DEBUG;\nwindow.debugLog = debugLog;\nwindow.debugFetch = debugFetch;\nwindow.getBackendUrl = getBackendUrl;\nwindow.fetchWithTimeout = fetchWithTimeout;\nwindow.parseErrorResponse = parseErrorResponse;\nwindow.getAuthHeaders = getAuthHeaders;\nwindow.getSettings = getSettings;\nwindow.saveSettings = saveSettings;\nwindow.clearSetting = clearSetting;\nwindow.isOnline = isOnline;\nwindow.initOfflineDetection = initOfflineDetection;\nwindow.formatTime = formatTime;\nwindow.setStatus = setStatus;\nwindow.debounce = debounce;\nwindow.jsx = jsx;\nwindow.PRESETS = PRESETS;\nwindow.getPresets = getPresets;\nwindow.getPreset = getPreset;\nwindow.applyPreset = applyPreset;\nwindow.getActivePreset = getActivePreset;\nwindow.isBuiltInPreset = isBuiltInPreset;\nwindow.initPresetSelector = initPresetSelector;\nwindow.initLoginModal = initLoginModal;\nwindow.showLoginModal = showLoginModal;\nwindow.isLoggedIn = isLoggedIn;\nwindow.logout = logout;\nwindow.escapeHtml = escapeHtml;\nwindow.safeHtml = safeHtml;\n","numLines":1264,"startLine":1,"totalLines":1264}}}
{"parentUuid":"06a1c911-aacb-4cd3-89c7-4090c6f955ce","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KSFKNUxkd8M2gJFybcRM21","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Backend Server\n     3→ *\n     4→ * Main entry point for the SPLICE backend API.\n     5→ * Orchestrates the audio analysis pipeline.\n     6→ *\n     7→ * Slices:\n     8→ * - Slice 4: Transcription (services/transcription.js)\n     9→ * - Slice 5: Take Detection (services/takeDetection.js)\n    10→ *\n    11→ * Architecture: Modular routes (see routes/ directory)\n    12→ */\n    13→\n    14→\n    15→require('dotenv').config();\n    16→\n    17→const express = require('express');\n    18→const cors = require('cors');\n    19→const helmet = require('helmet');\n    20→const cookieParser = require('cookie-parser');\n    21→const fs = require('fs');\n    22→const https = require('https');\n    23→const http = require('http');\n    24→const path = require('path');\n    25→const crypto = require('crypto');\n    26→\n    27→// MEDIUM-005: Request ID Tracing Middleware\n    28→const { requestIdMiddleware } = require('./middleware/requestId');\n    29→\n    30→// HIGH-008: Sentry Error Monitoring Integration\n    31→let Sentry = null;\n    32→if (process.env.SENTRY_DSN) {\n    33→  try {\n    34→    Sentry = require('@sentry/node');\n    35→    console.log('[SPLICE] Sentry module loaded, will initialize after app creation');\n    36→  } catch (_err) {\n    37→    console.warn('[SPLICE] @sentry/node not installed. Run: npm install @sentry/node');\n    38→  }\n    39→}\n    40→\n    41→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\n    42→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    43→\n    44→// Import services\n    45→const usageTracking = require('./services/usageTracking');\n    46→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\n    47→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\n    48→const referralService = require('./services/referralService');\n    49→const licenseService = require('./services/licenseService');\n    50→const emailService = require('./services/emailService');\n    51→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\n    52→const { getSupportedFormats } = require('./services/captionExporter');\n    53→\n    54→// Import route modules\n    55→const healthRoutes = require('./routes/health');\n    56→const analyzeRoutes = require('./routes/analyze');\n    57→const silencesRoutes = require('./routes/silences');\n    58→const detectionRoutes = require('./routes/detection');\n    59→const exportRoutes = require('./routes/export');\n    60→const multitrackRoutes = require('./routes/multitrack');\n    61→const cutListRoutes = require('./routes/cutList');\n    62→const zoomRoutes = require('./routes/zoom');\n    63→const chaptersRoutes = require('./routes/chapters');\n    64→const youtubeRoutes = require('./routes/youtube');\n    65→const captionsRoutes = require('./routes/captions');\n    66→const textEditRoutes = require('./routes/textEdit');\n    67→const reframeRoutes = require('./routes/reframe');\n    68→const batchRoutes = require('./routes/batch');\n    69→const authRoutes = require('./routes/auth');\n    70→const billingRoutes = require('./routes/billing');\n    71→const referralRoutes = require('./routes/referral');\n    72→const licenseRoutes = require('./routes/license');\n    73→const musicRoutes = require('./routes/music');\n    74→\n    75→// Music generation worker (BullMQ background processor)\n    76→const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\n    77→\n    78→// HIGH-011: API Versioning - v1 routes\n    79→const v1Routes = require('./routes/v1');\n    80→\n    81→// Stripe for webhooks\n    82→const Stripe = require('stripe');\n    83→\n    84→// MEDIUM-008: Pin Stripe API version for stability\n    85→// This prevents breaking changes when Stripe releases new API versions\n    86→// Should match version in services/stripeUsageReporting.js\n    87→const STRIPE_API_VERSION = '2024-12-18.acacia';\n    88→\n    89→// =============================================================================\n    90→// SECURITY: Environment Variable Validation\n    91→// Validate all required environment variables at startup\n    92→// Fail fast with clear error messages if critical secrets are missing\n    93→// =============================================================================\n    94→\n    95→/**\n    96→ * Validate required environment variables\n    97→ * @returns {Object} { valid: boolean, errors: string[] }\n    98→ */\n    99→function validateEnvironmentVariables() {\n   100→  const errors = [];\n   101→  \n   102→  // CRITICAL: Core infrastructure secrets\n   103→  if (!process.env.STRIPE_SECRET_KEY) {\n   104→    errors.push('STRIPE_SECRET_KEY is required (Stripe API key for billing)');\n   105→  }\n   106→  \n   107→  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production') {\n   108→    errors.push('JWT_SECRET must be set to a secure random value (not default)');\n   109→  } else if (process.env.JWT_SECRET.length < 32) {\n   110→    // HIGH-001: Enforce minimum 32 character length for cryptographic security\n   111→    errors.push('JWT_SECRET must be at least 32 characters for cryptographic security');\n   112→  }\n   113→  \n   114→  if (!process.env.DATABASE_URL) {\n   115→    errors.push('DATABASE_URL is required (PostgreSQL connection string)');\n   116→  }\n   117→  \n   118→  if (!process.env.OPENAI_API_KEY) {\n   119→    errors.push('OPENAI_API_KEY is required (OpenAI API for transcription)');\n   120→  }\n   121→  \n   122→  // CRITICAL: Redis required for job queue and rate limiting in production\n   123→  // Support both Railway Redis (REDIS_URL) and Upstash (UPSTASH_REDIS_URL)\n   124→  // In development, will fall back to in-memory storage\n   125→  if (process.env.NODE_ENV === 'production' && !process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n   126→    errors.push('REDIS_URL or UPSTASH_REDIS_URL is required (Redis for job queue and rate limiting)');\n   127→  } else if (!process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n   128→    console.warn('[SPLICE] WARNING: Redis not configured. Using in-memory fallback (not suitable for production).');\n   129→  }\n   130→  \n   131→  // CRITICAL: Webhook secret required in production\n   132→  if (!process.env.STRIPE_WEBHOOK_SECRET) {\n   133→    errors.push('STRIPE_WEBHOOK_SECRET is required (Stripe webhook signature verification)');\n   134→  }\n   135→  \n   136→  // CONDITIONAL: Email provider validation\n   137→  const emailProvider = process.env.EMAIL_PROVIDER || 'sendgrid';\n   138→  if (emailProvider === 'sendgrid' && !process.env.SENDGRID_API_KEY) {\n   139→    errors.push('SENDGRID_API_KEY is required when EMAIL_PROVIDER=sendgrid');\n   140→  }\n   141→  \n   142→  // RECOMMENDED: R2 Storage (warn if missing, don't block)\n   143→  if (!process.env.R2_ACCOUNT_ID || !process.env.R2_ACCESS_KEY_ID || !process.env.R2_SECRET_ACCESS_KEY) {\n   144→    console.warn('[SPLICE] WARNING: R2 storage credentials not configured. Music generation uploads will fail.');\n   145→  }\n   146→  \n   147→  return {\n   148→    valid: errors.length === 0,\n   149→    errors\n   150→  };\n   151→}\n   152→\n   153→// Run validation in production\n   154→if (isProduction) {\n   155→  const validation = validateEnvironmentVariables();\n   156→  \n   157→  if (!validation.valid) {\n   158→    console.error('[SPLICE] ========================================');\n   159→    console.error('[SPLICE] CRITICAL: Missing required environment variables');\n   160→    console.error('[SPLICE] ========================================');\n   161→    validation.errors.forEach(error => {\n   162→      console.error(`[SPLICE]   ❌ ${error}`);\n   163→    });\n   164→    console.error('[SPLICE] ========================================');\n   165→    console.error('[SPLICE] Server startup aborted. Please configure all required environment variables.');\n   166→    console.error('[SPLICE] See .env.example for complete documentation.');\n   167→    process.exit(1);\n   168→  }\n   169→  \n   170→  console.log('[SPLICE] ✅ Environment validation passed');\n   171→}\n   172→\n   173→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n   174→  apiVersion: STRIPE_API_VERSION\n   175→});\n   176→\n   177→// =============================================================================\n   178→// PERF-FIX: Static Response Cache\n   179→// Cache static endpoint responses at startup to avoid repeated computation\n   180→// =============================================================================\n   181→\n   182→// Generate ETag from content\n   183→function generateETag(content) {\n   184→  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n   185→}\n   186→\n   187→// Static response cache - populated at startup\n   188→const STATIC_RESPONSE_CACHE = {\n   189→  profanityLanguages: null,\n   190→  profanityBleeps: null,\n   191→  exportFormats: null\n   192→};\n   193→\n   194→// Initialize cache at startup (called after server starts)\n   195→function initializeStaticCache() {\n   196→  // Cache profanity languages\n   197→  const languages = getSupportedLanguages();\n   198→  STATIC_RESPONSE_CACHE.profanityLanguages = {\n   199→    body: { success: true, languages },\n   200→    etag: generateETag({ languages })\n   201→  };\n   202→\n   203→  // Cache profanity bleeps\n   204→  const sounds = getAvailableBleepSounds();\n   205→  STATIC_RESPONSE_CACHE.profanityBleeps = {\n   206→    body: { success: true, sounds },\n   207→    etag: generateETag({ sounds })\n   208→  };\n   209→\n   210→  // Cache export formats\n   211→  const formats = getSupportedFormats();\n   212→  STATIC_RESPONSE_CACHE.exportFormats = {\n   213→    body: { success: true, formats },\n   214→    etag: generateETag({ formats })\n   215→  };\n   216→\n   217→  console.log('[SPLICE] Static response cache initialized');\n   218→}\n   219→\n   220→// Helper to send cached response with ETag\n   221→function sendCachedResponse(req, res, cacheKey) {\n   222→  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n   223→  if (!cached) {\n   224→    return res.status(500).json({ error: 'Cache not initialized' });\n   225→  }\n   226→\n   227→  // Check If-None-Match header for conditional GET\n   228→  const clientETag = req.headers['if-none-match'];\n   229→  if (clientETag === cached.etag) {\n   230→    return res.status(304).end(); // Not Modified\n   231→  }\n   232→\n   233→  // Send cached response with ETag and cache headers\n   234→  res.set('ETag', cached.etag);\n   235→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n   236→  res.json(cached.body);\n   237→}\n   238→\n   239→// =============================================================================\n   240→// Server Configuration\n   241→// =============================================================================\n   242→\n   243→const app = express();\n   244→const PORT = process.env.PORT || 3847;\n   245→\n   246→// HIGH-008: Initialize Sentry after app creation\n   247→if (Sentry && process.env.SENTRY_DSN) {\n   248→  Sentry.init({\n   249→    dsn: process.env.SENTRY_DSN,\n   250→    environment: process.env.NODE_ENV || 'development',\n   251→    release: process.env.npm_package_version || '6.0.3',\n   252→    tracesSampleRate: isProduction ? 0.1 : 1.0, // 10% in prod, 100% in dev\n   253→    profilesSampleRate: isProduction ? 0.1 : 0, // Profile only in production\n   254→    integrations: [\n   255→      // Automatically instrument HTTP requests\n   256→      Sentry.httpIntegration({ tracing: true }),\n   257→      // Automatically instrument Express\n   258→      Sentry.expressIntegration({ app }),\n   259→    ],\n   260→    // Filter out sensitive data\n   261→    beforeSend(event) {\n   262→      // Remove sensitive headers\n   263→      if (event.request && event.request.headers) {\n   264→        delete event.request.headers.authorization;\n   265→        delete event.request.headers['x-stripe-customer-id'];\n   266→        delete event.request.headers['stripe-signature'];\n   267→      }\n   268→      return event;\n   269→    },\n   270→  });\n   271→  \n   272→  // Add Sentry request handler as first middleware\n   273→  app.use(Sentry.Handlers.requestHandler());\n   274→  app.use(Sentry.Handlers.tracingHandler());\n   275→  \n   276→  console.log('[SPLICE] ✅ Sentry error monitoring initialized');\n   277→}\n   278→\n   279→// MEDIUM-005: Request ID Tracing Middleware\n   280→// Add early in chain to ensure all requests have correlation IDs for logging\n   281→app.use(requestIdMiddleware);\n   282→\n   283→// HTTPS certificates (generated by mkcert) - only for local development\n   284→let httpsOptions = null;\n   285→if (!isProduction) {\n   286→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n   287→  const certPath = path.join(__dirname, 'localhost+1.pem');\n   288→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n   289→    httpsOptions = {\n   290→      key: fs.readFileSync(keyPath),\n   291→      cert: fs.readFileSync(certPath)\n   292→    };\n   293→  }\n   294→}\n   295→\n   296→// =============================================================================\n   297→// Security Configuration\n   298→// =============================================================================\n   299→\n   300→// CORS whitelist - restrict origins in production\n   301→const CORS_WHITELIST = [\n   302→  'http://localhost:3000',\n   303→  'http://localhost:3847',\n   304→  'https://localhost:3847',\n   305→  'http://127.0.0.1:3000',\n   306→  'http://127.0.0.1:3847',\n   307→  'https://127.0.0.1:3847',\n   308→  'https://splice.app',\n   309→  'https://www.splice.app',\n   310→  'https://spliceclips.com',\n   311→  'https://www.spliceclips.com',\n   312→  'https://splice-api-production.up.railway.app',\n   313→  'https://splice-website.vercel.app',\n   314→  // Adobe CEP/UXP panels run from file:// or bolt://\n   315→  'file://',\n   316→  'bolt://'\n   317→];\n   318→\n   319→const corsOptions = {\n   320→  origin: function (origin, callback) {\n   321→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n   322→    if (!origin) {\n   323→      return callback(null, true);\n   324→    }\n   325→    // Check if origin is in whitelist\n   326→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n   327→      return callback(null, true);\n   328→    }\n   329→    // In development, allow all origins with warning\n   330→    if (!isProduction) {\n   331→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n   332→      return callback(null, true);\n   333→    }\n   334→    // In production, reject non-whitelisted origins\n   335→    console.error(`[CORS] Blocked request from: ${origin}`);\n   336→    return callback(new Error('Not allowed by CORS'));\n   337→  },\n   338→  credentials: true,\n   339→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n   340→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n   341→};\n   342→\n   343→app.use(cors(corsOptions));\n   344→\n   345→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n   346→// This ensures rate limiting and logging use the correct client IP\n   347→if (isProduction) {\n   348→  app.set('trust proxy', 1);\n   349→}\n   350→\n   351→// IP-based rate limiting (100 requests/minute per IP)\n   352→app.use(ipRateLimit);\n   353→\n   354→// Security headers via helmet\n   355→app.use(helmet({\n   356→  contentSecurityPolicy: {\n   357→    directives: {\n   358→      defaultSrc: [\"'self'\"],\n   359→      scriptSrc: [\"'self'\"],\n   360→      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n   361→      imgSrc: [\"'self'\", 'data:', 'https:'],\n   362→      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n   363→      fontSrc: [\"'self'\"],\n   364→      objectSrc: [\"'none'\"],\n   365→      mediaSrc: [\"'self'\"],\n   366→      frameSrc: [\"'none'\"]\n   367→    }\n   368→  },\n   369→  hsts: {\n   370→    maxAge: 31536000,\n   371→    includeSubDomains: true,\n   372→    preload: true\n   373→  },\n   374→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n   375→  noSniff: true,\n   376→  xssFilter: true,\n   377→  hidePoweredBy: true\n   378→}));\n   379→\n   380→// Helper to determine tier from price ID with logging\n   381→// Supports both monthly and annual pricing\n   382→function getTierFromPriceId(priceId) {\n   383→  // Monthly prices\n   384→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   385→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   386→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   387→\n   388→  // Annual prices (same tier, just different billing period)\n   389→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n   390→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n   391→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n   392→\n   393→  // Log unknown price ID for debugging\n   394→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   395→  return 'starter';\n   396→}\n   397→\n   398→// =============================================================================\n   399→// Stripe Webhook (must be before express.json())\n   400→// =============================================================================\n   401→\n   402→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   403→  const sig = req.headers['stripe-signature'];\n   404→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   405→\n   406→  let event;\n   407→\n   408→  try {\n   409→    if (webhookSecret) {\n   410→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   411→    } else if (isProduction) {\n   412→      // SECURITY: Reject unsigned webhooks in production\n   413→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   414→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   415→    } else {\n   416→      // For local development testing only\n   417→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   418→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   419→      event = JSON.parse(bodyString);\n   420→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   421→    }\n   422→  } catch (err) {\n   423→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   424→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   425→  }\n   426→\n   427→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   428→\n   429→  // Idempotency check - skip if already processed\n   430→  if (await usageTracking.isEventProcessed(event.id)) {\n   431→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   432→    return res.json({ received: true, skipped: true });\n   433→  }\n   434→\n   435→  try {\n   436→    switch (event.type) {\n   437→      case 'customer.subscription.created':\n   438→      case 'customer.subscription.updated': {\n   439→        const subscription = event.data.object;\n   440→        const customerId = subscription.customer;\n   441→\n   442→        // Validate customerId\n   443→        if (!customerId) {\n   444→          console.error('[SPLICE] Missing customer ID in subscription event');\n   445→          return res.status(400).json({ error: 'Missing customer ID' });\n   446→        }\n   447→\n   448→        // Get tier from price ID\n   449→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   450→        const tier = getTierFromPriceId(priceId);\n   451→\n   452→        // Update user tier and reset hours\n   453→        await usageTracking.updateTier(customerId, tier);\n   454→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   455→\n   456→        // Initialize music credits for new subscriptions\n   457→        if (event.type === 'customer.subscription.created') {\n   458→          await usageTracking.resetMusicCredits(customerId, tier);\n   459→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n   460→        }\n   461→\n   462→        // Update trial end date if present\n   463→        if (subscription.trial_end) {\n   464→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n   465→        }\n   466→\n   467→        // Generate license key for new subscriptions with retry and delivery\n   468→        if (event.type === 'customer.subscription.created') {\n   469→          let licenseResult = null;\n   470→          let retryCount = 0;\n   471→          const maxRetries = 3;\n   472→\n   473→          // Retry mechanism for license key generation\n   474→          while (retryCount < maxRetries) {\n   475→            licenseResult = await licenseService.generateLicenseKey(customerId);\n   476→            if (licenseResult.success) {\n   477→              break;\n   478→            }\n   479→            retryCount++;\n   480→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n   481→            // Wait before retry (exponential backoff)\n   482→            if (retryCount < maxRetries) {\n   483→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n   484→            }\n   485→          }\n   486→\n   487→          if (licenseResult && licenseResult.success) {\n   488→            // SECURITY: Mask license key in logs\n   489→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n   490→\n   491→            // Store license key in Stripe subscription metadata as backup\n   492→            try {\n   493→              await stripe.subscriptions.update(subscription.id, {\n   494→                metadata: {\n   495→                  license_key: licenseResult.key,\n   496→                  license_generated_at: new Date().toISOString()\n   497→                }\n   498→              });\n   499→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n   500→            } catch (stripeErr) {\n   501→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n   502→            }\n   503→\n   504→            // Get customer email and send license key\n   505→            try {\n   506→              const customer = await stripe.customers.retrieve(customerId);\n   507→              if (customer.email) {\n   508→                // SECURITY: Mask sensitive data in logs\n   509→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n   510→\n   511→                // Send license key email\n   512→                try {\n   513→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n   514→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n   515→                } catch (sendErr) {\n   516→                  // Log but don't fail - license is stored in Stripe metadata as backup\n   517→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n   518→                }\n   519→\n   520→                // Store email in database for reference\n   521→                await usageTracking.updateTier(customerId, tier, customer.email);\n   522→              } else {\n   523→                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n   524→              }\n   525→            } catch (emailErr) {\n   526→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n   527→            }\n   528→          } else {\n   529→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n   530→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n   531→            console.error(`[SPLICE] ${errorMsg}`);\n   532→            return res.status(500).json({ error: errorMsg });\n   533→          }\n   534→        }\n   535→        break;\n   536→      }\n   537→\n   538→      case 'customer.subscription.deleted': {\n   539→        const subscription = event.data.object;\n   540→        const customerId = subscription.customer;\n   541→\n   542→        // Validate customerId\n   543→        if (!customerId) {\n   544→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   545→          return res.status(400).json({ error: 'Missing customer ID' });\n   546→        }\n   547→\n   548→        // Downgrade to cancelled (0 hours)\n   549→        await usageTracking.updateTier(customerId, 'cancelled');\n   550→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   551→        break;\n   552→      }\n   553→\n   554→      case 'invoice.payment_succeeded': {\n   555→        const invoice = event.data.object;\n   556→        const customerId = invoice.customer;\n   557→        const subscriptionId = invoice.subscription;\n   558→\n   559→        // Validate customerId\n   560→        if (!customerId) {\n   561→          console.error('[SPLICE] Missing customer ID in invoice event');\n   562→          return res.status(400).json({ error: 'Missing customer ID' });\n   563→        }\n   564→\n   565→        // Reset hours on successful payment (new billing period)\n   566→        let tier = 'starter';\n   567→        if (subscriptionId) {\n   568→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   569→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   570→          tier = getTierFromPriceId(priceId);\n   571→\n   572→          await usageTracking.resetHours(customerId, tier);\n   573→          await usageTracking.resetMusicCredits(customerId, tier);\n   574→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n   575→        }\n   576→\n   577→        // Check for affiliate coupon and record commission\n   578→        const discount = invoice.discount;\n   579→        if (discount && discount.coupon) {\n   580→          const couponId = discount.coupon.id;\n   581→          // Check if this is an affiliate code (like JIMMYN)\n   582→          if (referralService.AFFILIATE_CODES[couponId]) {\n   583→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n   584→            await referralService.recordAffiliateCommission(\n   585→              couponId,\n   586→              customerId,\n   587→              amountPaid,\n   588→              tier\n   589→            );\n   590→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n   591→          }\n   592→        }\n   593→        break;\n   594→      }\n   595→\n   596→      case 'invoice.payment_failed': {\n   597→        const invoice = event.data.object;\n   598→        const customerId = invoice.customer;\n   599→        const attemptCount = invoice.attempt_count || 1;\n   600→\n   601→        // Validate customerId\n   602→        if (!customerId) {\n   603→          console.error('[SPLICE] Missing customer ID in payment_failed event');\n   604→          return res.status(400).json({ error: 'Missing customer ID' });\n   605→        }\n   606→\n   607→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n   608→\n   609→        // Stripe will retry automatically per retry settings\n   610→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n   611→        // Send warning email on final attempt\n   612→        if (attemptCount >= 3) {\n   613→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n   614→          // Send warning email to customer about impending cancellation\n   615→          try {\n   616→            const customer = await stripe.customers.retrieve(customerId);\n   617→            if (customer.email) {\n   618→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n   619→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n   620→            }\n   621→          } catch (emailErr) {\n   622→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n   623→          }\n   624→        }\n   625→        break;\n   626→      }\n   627→\n   628→      case 'customer.deleted': {\n   629→        const customer = event.data.object;\n   630→        const customerId = customer.id;\n   631→\n   632→        // Validate customerId\n   633→        if (!customerId) {\n   634→          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n   635→          return res.status(400).json({ error: 'Missing customer ID' });\n   636→        }\n   637→\n   638→        // Clean up user data - downgrade to cancelled\n   639→        await usageTracking.updateTier(customerId, 'cancelled');\n   640→        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n   641→        break;\n   642→      }\n   643→\n   644→      default:\n   645→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   646→    }\n   647→\n   648→    // Record event as processed (idempotency)\n   649→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   650→\n   651→    res.json({ received: true });\n   652→  } catch (err) {\n   653→    console.error('[SPLICE] Webhook handler error:', err);\n   654→    res.status(500).json({ error: err.message });\n   655→  }\n   656→});\n   657→\n   658→// Parse JSON body for all other routes\n   659→// SECURITY: Limit JSON body size to prevent DoS attacks\n   660→app.use(express.json({ limit: '10mb' }));\n   661→\n   662→// Parse cookies for CSRF token validation\n   663→app.use(cookieParser());\n   664→\n   665→// =============================================================================\n   666→// Route Configuration Options\n   667→// =============================================================================\n   668→\n   669→const routeOptions = {\n   670→  middleware: {\n   671→    requireCredits,\n   672→    requireFeature,\n   673→    authenticateToken\n   674→  },\n   675→  services: {\n   676→    usageTracking,\n   677→    referralService,\n   678→    licenseService,\n   679→    emailService,\n   680→    stripe\n   681→  },\n   682→  authHelpers: {\n   683→    generateToken,\n   684→    generateRefreshToken,\n   685→    verifyToken,\n   686→    maskSensitiveData,\n   687→    blacklistToken\n   688→  },\n   689→  staticCache: STATIC_RESPONSE_CACHE,\n   690→  sendCachedResponse\n   691→};\n   692→\n   693→// =============================================================================\n   694→// Mount Routes\n   695→// =============================================================================\n   696→\n   697→// Health check and system endpoints (no prefix)\n   698→app.use('/', healthRoutes(routeOptions));\n   699→\n   700→// Core analysis endpoints\n   701→app.use('/', analyzeRoutes(routeOptions));\n   702→app.use('/', silencesRoutes(routeOptions));\n   703→app.use('/', detectionRoutes(routeOptions));\n   704→\n   705→// Export endpoints\n   706→app.use('/export', exportRoutes(routeOptions));\n   707→\n   708→// Multitrack/Multicam endpoints\n   709→app.use('/multitrack', multitrackRoutes(routeOptions));\n   710→\n   711→// Cut list generation\n   712→app.use('/cut-list', cutListRoutes(routeOptions));\n   713→\n   714→// Legacy XML processing endpoint (backwards compatibility)\n   715→const { processXMLFile } = require('./services/xmlProcessor');\n   716→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n   717→  const {\n   718→    xmlPath,\n   719→    silences,\n   720→    removeGaps = true,\n   721→    outputPath = null\n   722→  } = req.body;\n   723→\n   724→  if (!xmlPath) {\n   725→    return res.status(400).json({ error: 'xmlPath is required' });\n   726→  }\n   727→\n   728→  if (!silences || !Array.isArray(silences)) {\n   729→    return res.status(400).json({ error: 'silences array is required' });\n   730→  }\n   731→\n   732→  if (!fs.existsSync(xmlPath)) {\n   733→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n   734→  }\n   735→\n   736→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n   737→\n   738→  try {\n   739→    const result = await processXMLFile(xmlPath, silences, {\n   740→      outputPath,\n   741→      removeGaps\n   742→    });\n   743→\n   744→    res.json({\n   745→      success: true,\n   746→      inputPath: xmlPath,\n   747→      outputPath: result.outputPath,\n   748→      stats: result.stats\n   749→    });\n   750→  } catch (err) {\n   751→    console.error('[SPLICE] XML processing error:', err);\n   752→    res.status(500).json({ error: err.message });\n   753→  }\n   754→});\n   755→\n   756→// Auto zoom endpoints\n   757→app.use('/zoom', zoomRoutes(routeOptions));\n   758→\n   759→// Chapter detection endpoints\n   760→app.use('/chapters', chaptersRoutes(routeOptions));\n   761→\n   762→// YouTube content generation\n   763→app.use('/youtube', youtubeRoutes(routeOptions));\n   764→\n   765→// Animated captions endpoints\n   766→app.use('/captions', captionsRoutes(routeOptions));\n   767→\n   768→// Text-based editing endpoints\n   769→app.use('/text-edit', textEditRoutes(routeOptions));\n   770→\n   771→// Social reframe endpoints\n   772→app.use('/reframe', reframeRoutes(routeOptions));\n   773→app.use('/faces', reframeRoutes.facesRouter(routeOptions));\n   774→\n   775→// Batch processing endpoints\n   776→app.use('/batch', batchRoutes(routeOptions));\n   777→\n   778→// Authentication endpoints\n   779→app.use('/auth', authRoutes(routeOptions));\n   780→\n   781→// Billing and credits endpoints\n   782→app.use('/', billingRoutes(routeOptions));\n   783→\n   784→// Referral system endpoints\n   785→app.use('/referral', referralRoutes(routeOptions));\n   786→\n   787→// License key endpoints\n   788→app.use('/license', licenseRoutes(routeOptions));\n   789→\n   790→// AI Music generation endpoints\n   791→app.use('/music', musicRoutes(routeOptions));\n   792→\n   793→// =============================================================================\n   794→// HIGH-011: API Versioning\n   795→// Mount versioned routes under /api/v1 prefix\n   796→// Maintain backwards compatibility with deprecation warnings\n   797→// =============================================================================\n   798→\n   799→// Mount v1 API routes\n   800→app.use('/api/v1', v1Routes(routeOptions));\n   801→\n   802→// Deprecation warning middleware for unversioned API calls\n   803→// This helps clients migrate to versioned endpoints\n   804→app.use('/api', (req, res, next) => {\n   805→  // Skip if already using versioned endpoint\n   806→  if (req.path.startsWith('/v1')) {\n   807→    return next();\n   808→  }\n   809→  \n   810→  // Add deprecation warning header\n   811→  res.set('X-API-Deprecation-Warning', 'Unversioned API endpoints are deprecated. Please migrate to /api/v1/');\n   812→  res.set('X-API-Version', 'unversioned');\n   813→  res.set('Deprecation', 'true');\n   814→  res.set('Sunset', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toUTCString()); // 90 days from now\n   815→  \n   816→  next();\n   817→});\n   818→\n   819→// HIGH-008: Add Sentry error handler (must be after all routes)\n   820→if (Sentry) {\n   821→  app.use(Sentry.Handlers.errorHandler({\n   822→    shouldHandleError(error) {\n   823→      // Capture all 4xx and 5xx errors\n   824→      if (error.status >= 400) {\n   825→        return true;\n   826→      }\n   827→      return true;\n   828→    },\n   829→  }));\n   830→}\n   831→\n   832→// =============================================================================\n   833→// Start Server\n   834→// =============================================================================\n   835→\n   836→// Track active server for graceful shutdown\n   837→let server = null;\n   838→\n   839→// Initialize database and start server\n   840→async function startServer() {\n   841→  try {\n   842→    await usageTracking.initDatabase();\n   843→    await referralService.initReferralTables();\n   844→    await licenseService.initLicenseTables();\n   845→    console.log('[SPLICE] Database initialized');\n   846→\n   847→    // PERF-FIX: Initialize static response cache at startup\n   848→    initializeStaticCache();\n   849→\n   850→    // Start music generation worker (BullMQ background processor)\n   851→    // Only starts if Redis is configured and Replicate API key is available\n   852→    if (process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL) {\n   853→      if (process.env.REPLICATE_API_TOKEN) {\n   854→        try {\n   855→          createMusicWorker();\n   856→          console.log('[SPLICE] ✅ Music generation worker started');\n   857→        } catch (workerErr) {\n   858→          console.error('[SPLICE] ⚠️ Failed to start music worker:', workerErr.message);\n   859→          // Don't fail server startup - music generation will be unavailable\n   860→        }\n   861→      } else {\n   862→        console.warn('[SPLICE] ⚠️ REPLICATE_API_TOKEN not set - music generation disabled');\n   863→      }\n   864→    } else {\n   865→      console.warn('[SPLICE] ⚠️ Redis not configured - music generation queue disabled');\n   866→    }\n   867→\n   868→    if (isProduction || !httpsOptions) {\n   869→      // Production: Railway provides TLS termination, use HTTP\n   870→      server = http.createServer(app).listen(PORT, () => {\n   871→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n   872→      });\n   873→    } else {\n   874→      // Development: Use HTTPS with local certificates\n   875→      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n   876→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n   877→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n   878→      });\n   879→    }\n   880→  } catch (err) {\n   881→    console.error('[SPLICE] Failed to start server:', err);\n   882→    process.exit(1);\n   883→  }\n   884→}\n   885→\n   886→// =============================================================================\n   887→// Graceful Shutdown\n   888→// =============================================================================\n   889→\n   890→async function gracefulShutdown(signal) {\n   891→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n   892→\n   893→  // Stop accepting new connections\n   894→  if (server) {\n   895→    server.close(() => {\n   896→      console.log('[SPLICE] HTTP server closed');\n   897→    });\n   898→  }\n   899→\n   900→  // Shutdown music worker (allows in-progress jobs to complete)\n   901→  try {\n   902→    await shutdownWorker();\n   903→    console.log('[SPLICE] Music worker shut down');\n   904→  } catch (err) {\n   905→    console.error('[SPLICE] Error shutting down music worker:', err.message);\n   906→  }\n   907→\n   908→  // Close database pool\n   909→  try {\n   910→    await usageTracking.closePool();\n   911→    console.log('[SPLICE] Database pool closed');\n   912→  } catch (err) {\n   913→    console.error('[SPLICE] Error closing database pool:', err.message);\n   914→  }\n   915→\n   916→  // Give ongoing requests time to complete (max 10 seconds)\n   917→  setTimeout(() => {\n   918→    console.log('[SPLICE] Graceful shutdown complete');\n   919→    process.exit(0);\n   920→  }, 10000);\n   921→}\n   922→\n   923→// Handle termination signals\n   924→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n   925→process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n   926→\n   927→// Handle uncaught exceptions\n   928→process.on('uncaughtException', (err) => {\n   929→  console.error('[SPLICE] Uncaught exception:', err);\n   930→  gracefulShutdown('uncaughtException');\n   931→});\n   932→\n   933→process.on('unhandledRejection', (reason, promise) => {\n   934→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n   935→});\n   936→\n   937→startServer();\n   938→\n\n</system-reminder>\n"}]},"uuid":"f214afad-14aa-4cf0-a007-c436de0cd1d4","timestamp":"2026-01-11T23:55:40.438Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"/**\n * SPLICE Backend Server\n *\n * Main entry point for the SPLICE backend API.\n * Orchestrates the audio analysis pipeline.\n *\n * Slices:\n * - Slice 4: Transcription (services/transcription.js)\n * - Slice 5: Take Detection (services/takeDetection.js)\n *\n * Architecture: Modular routes (see routes/ directory)\n */\n\n\nrequire('dotenv').config();\n\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst https = require('https');\nconst http = require('http');\nconst path = require('path');\nconst crypto = require('crypto');\n\n// MEDIUM-005: Request ID Tracing Middleware\nconst { requestIdMiddleware } = require('./middleware/requestId');\n\n// HIGH-008: Sentry Error Monitoring Integration\nlet Sentry = null;\nif (process.env.SENTRY_DSN) {\n  try {\n    Sentry = require('@sentry/node');\n    console.log('[SPLICE] Sentry module loaded, will initialize after app creation');\n  } catch (_err) {\n    console.warn('[SPLICE] @sentry/node not installed. Run: npm install @sentry/node');\n  }\n}\n\n// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// Import services\nconst usageTracking = require('./services/usageTracking');\nconst { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\nconst { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\nconst referralService = require('./services/referralService');\nconst licenseService = require('./services/licenseService');\nconst emailService = require('./services/emailService');\nconst { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\nconst { getSupportedFormats } = require('./services/captionExporter');\n\n// Import route modules\nconst healthRoutes = require('./routes/health');\nconst analyzeRoutes = require('./routes/analyze');\nconst silencesRoutes = require('./routes/silences');\nconst detectionRoutes = require('./routes/detection');\nconst exportRoutes = require('./routes/export');\nconst multitrackRoutes = require('./routes/multitrack');\nconst cutListRoutes = require('./routes/cutList');\nconst zoomRoutes = require('./routes/zoom');\nconst chaptersRoutes = require('./routes/chapters');\nconst youtubeRoutes = require('./routes/youtube');\nconst captionsRoutes = require('./routes/captions');\nconst textEditRoutes = require('./routes/textEdit');\nconst reframeRoutes = require('./routes/reframe');\nconst batchRoutes = require('./routes/batch');\nconst authRoutes = require('./routes/auth');\nconst billingRoutes = require('./routes/billing');\nconst referralRoutes = require('./routes/referral');\nconst licenseRoutes = require('./routes/license');\nconst musicRoutes = require('./routes/music');\n\n// Music generation worker (BullMQ background processor)\nconst { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\n\n// HIGH-011: API Versioning - v1 routes\nconst v1Routes = require('./routes/v1');\n\n// Stripe for webhooks\nconst Stripe = require('stripe');\n\n// MEDIUM-008: Pin Stripe API version for stability\n// This prevents breaking changes when Stripe releases new API versions\n// Should match version in services/stripeUsageReporting.js\nconst STRIPE_API_VERSION = '2024-12-18.acacia';\n\n// =============================================================================\n// SECURITY: Environment Variable Validation\n// Validate all required environment variables at startup\n// Fail fast with clear error messages if critical secrets are missing\n// =============================================================================\n\n/**\n * Validate required environment variables\n * @returns {Object} { valid: boolean, errors: string[] }\n */\nfunction validateEnvironmentVariables() {\n  const errors = [];\n  \n  // CRITICAL: Core infrastructure secrets\n  if (!process.env.STRIPE_SECRET_KEY) {\n    errors.push('STRIPE_SECRET_KEY is required (Stripe API key for billing)');\n  }\n  \n  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    errors.push('JWT_SECRET must be set to a secure random value (not default)');\n  } else if (process.env.JWT_SECRET.length < 32) {\n    // HIGH-001: Enforce minimum 32 character length for cryptographic security\n    errors.push('JWT_SECRET must be at least 32 characters for cryptographic security');\n  }\n  \n  if (!process.env.DATABASE_URL) {\n    errors.push('DATABASE_URL is required (PostgreSQL connection string)');\n  }\n  \n  if (!process.env.OPENAI_API_KEY) {\n    errors.push('OPENAI_API_KEY is required (OpenAI API for transcription)');\n  }\n  \n  // CRITICAL: Redis required for job queue and rate limiting in production\n  // Support both Railway Redis (REDIS_URL) and Upstash (UPSTASH_REDIS_URL)\n  // In development, will fall back to in-memory storage\n  if (process.env.NODE_ENV === 'production' && !process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n    errors.push('REDIS_URL or UPSTASH_REDIS_URL is required (Redis for job queue and rate limiting)');\n  } else if (!process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n    console.warn('[SPLICE] WARNING: Redis not configured. Using in-memory fallback (not suitable for production).');\n  }\n  \n  // CRITICAL: Webhook secret required in production\n  if (!process.env.STRIPE_WEBHOOK_SECRET) {\n    errors.push('STRIPE_WEBHOOK_SECRET is required (Stripe webhook signature verification)');\n  }\n  \n  // CONDITIONAL: Email provider validation\n  const emailProvider = process.env.EMAIL_PROVIDER || 'sendgrid';\n  if (emailProvider === 'sendgrid' && !process.env.SENDGRID_API_KEY) {\n    errors.push('SENDGRID_API_KEY is required when EMAIL_PROVIDER=sendgrid');\n  }\n  \n  // RECOMMENDED: R2 Storage (warn if missing, don't block)\n  if (!process.env.R2_ACCOUNT_ID || !process.env.R2_ACCESS_KEY_ID || !process.env.R2_SECRET_ACCESS_KEY) {\n    console.warn('[SPLICE] WARNING: R2 storage credentials not configured. Music generation uploads will fail.');\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n\n// Run validation in production\nif (isProduction) {\n  const validation = validateEnvironmentVariables();\n  \n  if (!validation.valid) {\n    console.error('[SPLICE] ========================================');\n    console.error('[SPLICE] CRITICAL: Missing required environment variables');\n    console.error('[SPLICE] ========================================');\n    validation.errors.forEach(error => {\n      console.error(`[SPLICE]   ❌ ${error}`);\n    });\n    console.error('[SPLICE] ========================================');\n    console.error('[SPLICE] Server startup aborted. Please configure all required environment variables.');\n    console.error('[SPLICE] See .env.example for complete documentation.');\n    process.exit(1);\n  }\n  \n  console.log('[SPLICE] ✅ Environment validation passed');\n}\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n  apiVersion: STRIPE_API_VERSION\n});\n\n// =============================================================================\n// PERF-FIX: Static Response Cache\n// Cache static endpoint responses at startup to avoid repeated computation\n// =============================================================================\n\n// Generate ETag from content\nfunction generateETag(content) {\n  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n}\n\n// Static response cache - populated at startup\nconst STATIC_RESPONSE_CACHE = {\n  profanityLanguages: null,\n  profanityBleeps: null,\n  exportFormats: null\n};\n\n// Initialize cache at startup (called after server starts)\nfunction initializeStaticCache() {\n  // Cache profanity languages\n  const languages = getSupportedLanguages();\n  STATIC_RESPONSE_CACHE.profanityLanguages = {\n    body: { success: true, languages },\n    etag: generateETag({ languages })\n  };\n\n  // Cache profanity bleeps\n  const sounds = getAvailableBleepSounds();\n  STATIC_RESPONSE_CACHE.profanityBleeps = {\n    body: { success: true, sounds },\n    etag: generateETag({ sounds })\n  };\n\n  // Cache export formats\n  const formats = getSupportedFormats();\n  STATIC_RESPONSE_CACHE.exportFormats = {\n    body: { success: true, formats },\n    etag: generateETag({ formats })\n  };\n\n  console.log('[SPLICE] Static response cache initialized');\n}\n\n// Helper to send cached response with ETag\nfunction sendCachedResponse(req, res, cacheKey) {\n  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n  if (!cached) {\n    return res.status(500).json({ error: 'Cache not initialized' });\n  }\n\n  // Check If-None-Match header for conditional GET\n  const clientETag = req.headers['if-none-match'];\n  if (clientETag === cached.etag) {\n    return res.status(304).end(); // Not Modified\n  }\n\n  // Send cached response with ETag and cache headers\n  res.set('ETag', cached.etag);\n  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n  res.json(cached.body);\n}\n\n// =============================================================================\n// Server Configuration\n// =============================================================================\n\nconst app = express();\nconst PORT = process.env.PORT || 3847;\n\n// HIGH-008: Initialize Sentry after app creation\nif (Sentry && process.env.SENTRY_DSN) {\n  Sentry.init({\n    dsn: process.env.SENTRY_DSN,\n    environment: process.env.NODE_ENV || 'development',\n    release: process.env.npm_package_version || '6.0.3',\n    tracesSampleRate: isProduction ? 0.1 : 1.0, // 10% in prod, 100% in dev\n    profilesSampleRate: isProduction ? 0.1 : 0, // Profile only in production\n    integrations: [\n      // Automatically instrument HTTP requests\n      Sentry.httpIntegration({ tracing: true }),\n      // Automatically instrument Express\n      Sentry.expressIntegration({ app }),\n    ],\n    // Filter out sensitive data\n    beforeSend(event) {\n      // Remove sensitive headers\n      if (event.request && event.request.headers) {\n        delete event.request.headers.authorization;\n        delete event.request.headers['x-stripe-customer-id'];\n        delete event.request.headers['stripe-signature'];\n      }\n      return event;\n    },\n  });\n  \n  // Add Sentry request handler as first middleware\n  app.use(Sentry.Handlers.requestHandler());\n  app.use(Sentry.Handlers.tracingHandler());\n  \n  console.log('[SPLICE] ✅ Sentry error monitoring initialized');\n}\n\n// MEDIUM-005: Request ID Tracing Middleware\n// Add early in chain to ensure all requests have correlation IDs for logging\napp.use(requestIdMiddleware);\n\n// HTTPS certificates (generated by mkcert) - only for local development\nlet httpsOptions = null;\nif (!isProduction) {\n  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n  const certPath = path.join(__dirname, 'localhost+1.pem');\n  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n    httpsOptions = {\n      key: fs.readFileSync(keyPath),\n      cert: fs.readFileSync(certPath)\n    };\n  }\n}\n\n// =============================================================================\n// Security Configuration\n// =============================================================================\n\n// CORS whitelist - restrict origins in production\nconst CORS_WHITELIST = [\n  'http://localhost:3000',\n  'http://localhost:3847',\n  'https://localhost:3847',\n  'http://127.0.0.1:3000',\n  'http://127.0.0.1:3847',\n  'https://127.0.0.1:3847',\n  'https://splice.app',\n  'https://www.splice.app',\n  'https://spliceclips.com',\n  'https://www.spliceclips.com',\n  'https://splice-api-production.up.railway.app',\n  'https://splice-website.vercel.app',\n  // Adobe CEP/UXP panels run from file:// or bolt://\n  'file://',\n  'bolt://'\n];\n\nconst corsOptions = {\n  origin: function (origin, callback) {\n    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n    if (!origin) {\n      return callback(null, true);\n    }\n    // Check if origin is in whitelist\n    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n      return callback(null, true);\n    }\n    // In development, allow all origins with warning\n    if (!isProduction) {\n      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n      return callback(null, true);\n    }\n    // In production, reject non-whitelisted origins\n    console.error(`[CORS] Blocked request from: ${origin}`);\n    return callback(new Error('Not allowed by CORS'));\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n};\n\napp.use(cors(corsOptions));\n\n// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n// This ensures rate limiting and logging use the correct client IP\nif (isProduction) {\n  app.set('trust proxy', 1);\n}\n\n// IP-based rate limiting (100 requests/minute per IP)\napp.use(ipRateLimit);\n\n// Security headers via helmet\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n  noSniff: true,\n  xssFilter: true,\n  hidePoweredBy: true\n}));\n\n// Helper to determine tier from price ID with logging\n// Supports both monthly and annual pricing\nfunction getTierFromPriceId(priceId) {\n  // Monthly prices\n  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n\n  // Annual prices (same tier, just different billing period)\n  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n\n  // Log unknown price ID for debugging\n  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n  return 'starter';\n}\n\n// =============================================================================\n// Stripe Webhook (must be before express.json())\n// =============================================================================\n\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n  let event;\n\n  try {\n    if (webhookSecret) {\n      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } else if (isProduction) {\n      // SECURITY: Reject unsigned webhooks in production\n      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n    } else {\n      // For local development testing only\n      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n      event = JSON.parse(bodyString);\n      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n    return res.status(400).json({ error: 'Webhook signature verification failed' });\n  }\n\n  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n\n  // Idempotency check - skip if already processed\n  if (await usageTracking.isEventProcessed(event.id)) {\n    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n    return res.json({ received: true, skipped: true });\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Get tier from price ID\n        const priceId = subscription.items?.data?.[0]?.price?.id;\n        const tier = getTierFromPriceId(priceId);\n\n        // Update user tier and reset hours\n        await usageTracking.updateTier(customerId, tier);\n        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n\n        // Initialize music credits for new subscriptions\n        if (event.type === 'customer.subscription.created') {\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Update trial end date if present\n        if (subscription.trial_end) {\n          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n        }\n\n        // Generate license key for new subscriptions with retry and delivery\n        if (event.type === 'customer.subscription.created') {\n          let licenseResult = null;\n          let retryCount = 0;\n          const maxRetries = 3;\n\n          // Retry mechanism for license key generation\n          while (retryCount < maxRetries) {\n            licenseResult = await licenseService.generateLicenseKey(customerId);\n            if (licenseResult.success) {\n              break;\n            }\n            retryCount++;\n            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n            // Wait before retry (exponential backoff)\n            if (retryCount < maxRetries) {\n              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n            }\n          }\n\n          if (licenseResult && licenseResult.success) {\n            // SECURITY: Mask license key in logs\n            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n\n            // Store license key in Stripe subscription metadata as backup\n            try {\n              await stripe.subscriptions.update(subscription.id, {\n                metadata: {\n                  license_key: licenseResult.key,\n                  license_generated_at: new Date().toISOString()\n                }\n              });\n              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n            } catch (stripeErr) {\n              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n            }\n\n            // Get customer email and send license key\n            try {\n              const customer = await stripe.customers.retrieve(customerId);\n              if (customer.email) {\n                // SECURITY: Mask sensitive data in logs\n                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n\n                // Send license key email\n                try {\n                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n                } catch (sendErr) {\n                  // Log but don't fail - license is stored in Stripe metadata as backup\n                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n                }\n\n                // Store email in database for reference\n                await usageTracking.updateTier(customerId, tier, customer.email);\n              } else {\n                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n              }\n            } catch (emailErr) {\n              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n            }\n          } else {\n            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n            console.error(`[SPLICE] ${errorMsg}`);\n            return res.status(500).json({ error: errorMsg });\n          }\n        }\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Downgrade to cancelled (0 hours)\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const subscriptionId = invoice.subscription;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in invoice event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Reset hours on successful payment (new billing period)\n        let tier = 'starter';\n        if (subscriptionId) {\n          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n          const priceId = subscription.items?.data?.[0]?.price?.id;\n          tier = getTierFromPriceId(priceId);\n\n          await usageTracking.resetHours(customerId, tier);\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Check for affiliate coupon and record commission\n        const discount = invoice.discount;\n        if (discount && discount.coupon) {\n          const couponId = discount.coupon.id;\n          // Check if this is an affiliate code (like JIMMYN)\n          if (referralService.AFFILIATE_CODES[couponId]) {\n            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n            await referralService.recordAffiliateCommission(\n              couponId,\n              customerId,\n              amountPaid,\n              tier\n            );\n            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n          }\n        }\n        break;\n      }\n\n      case 'invoice.payment_failed': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const attemptCount = invoice.attempt_count || 1;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in payment_failed event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n\n        // Stripe will retry automatically per retry settings\n        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n        // Send warning email on final attempt\n        if (attemptCount >= 3) {\n          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n          // Send warning email to customer about impending cancellation\n          try {\n            const customer = await stripe.customers.retrieve(customerId);\n            if (customer.email) {\n              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n            }\n          } catch (emailErr) {\n            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n          }\n        }\n        break;\n      }\n\n      case 'customer.deleted': {\n        const customer = event.data.object;\n        const customerId = customer.id;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Clean up user data - downgrade to cancelled\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n        break;\n      }\n\n      default:\n        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n    }\n\n    // Record event as processed (idempotency)\n    await usageTracking.recordWebhookEvent(event.id, event.type);\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error('[SPLICE] Webhook handler error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Parse JSON body for all other routes\n// SECURITY: Limit JSON body size to prevent DoS attacks\napp.use(express.json({ limit: '10mb' }));\n\n// Parse cookies for CSRF token validation\napp.use(cookieParser());\n\n// =============================================================================\n// Route Configuration Options\n// =============================================================================\n\nconst routeOptions = {\n  middleware: {\n    requireCredits,\n    requireFeature,\n    authenticateToken\n  },\n  services: {\n    usageTracking,\n    referralService,\n    licenseService,\n    emailService,\n    stripe\n  },\n  authHelpers: {\n    generateToken,\n    generateRefreshToken,\n    verifyToken,\n    maskSensitiveData,\n    blacklistToken\n  },\n  staticCache: STATIC_RESPONSE_CACHE,\n  sendCachedResponse\n};\n\n// =============================================================================\n// Mount Routes\n// =============================================================================\n\n// Health check and system endpoints (no prefix)\napp.use('/', healthRoutes(routeOptions));\n\n// Core analysis endpoints\napp.use('/', analyzeRoutes(routeOptions));\napp.use('/', silencesRoutes(routeOptions));\napp.use('/', detectionRoutes(routeOptions));\n\n// Export endpoints\napp.use('/export', exportRoutes(routeOptions));\n\n// Multitrack/Multicam endpoints\napp.use('/multitrack', multitrackRoutes(routeOptions));\n\n// Cut list generation\napp.use('/cut-list', cutListRoutes(routeOptions));\n\n// Legacy XML processing endpoint (backwards compatibility)\nconst { processXMLFile } = require('./services/xmlProcessor');\napp.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n  const {\n    xmlPath,\n    silences,\n    removeGaps = true,\n    outputPath = null\n  } = req.body;\n\n  if (!xmlPath) {\n    return res.status(400).json({ error: 'xmlPath is required' });\n  }\n\n  if (!silences || !Array.isArray(silences)) {\n    return res.status(400).json({ error: 'silences array is required' });\n  }\n\n  if (!fs.existsSync(xmlPath)) {\n    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n  }\n\n  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n\n  try {\n    const result = await processXMLFile(xmlPath, silences, {\n      outputPath,\n      removeGaps\n    });\n\n    res.json({\n      success: true,\n      inputPath: xmlPath,\n      outputPath: result.outputPath,\n      stats: result.stats\n    });\n  } catch (err) {\n    console.error('[SPLICE] XML processing error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Auto zoom endpoints\napp.use('/zoom', zoomRoutes(routeOptions));\n\n// Chapter detection endpoints\napp.use('/chapters', chaptersRoutes(routeOptions));\n\n// YouTube content generation\napp.use('/youtube', youtubeRoutes(routeOptions));\n\n// Animated captions endpoints\napp.use('/captions', captionsRoutes(routeOptions));\n\n// Text-based editing endpoints\napp.use('/text-edit', textEditRoutes(routeOptions));\n\n// Social reframe endpoints\napp.use('/reframe', reframeRoutes(routeOptions));\napp.use('/faces', reframeRoutes.facesRouter(routeOptions));\n\n// Batch processing endpoints\napp.use('/batch', batchRoutes(routeOptions));\n\n// Authentication endpoints\napp.use('/auth', authRoutes(routeOptions));\n\n// Billing and credits endpoints\napp.use('/', billingRoutes(routeOptions));\n\n// Referral system endpoints\napp.use('/referral', referralRoutes(routeOptions));\n\n// License key endpoints\napp.use('/license', licenseRoutes(routeOptions));\n\n// AI Music generation endpoints\napp.use('/music', musicRoutes(routeOptions));\n\n// =============================================================================\n// HIGH-011: API Versioning\n// Mount versioned routes under /api/v1 prefix\n// Maintain backwards compatibility with deprecation warnings\n// =============================================================================\n\n// Mount v1 API routes\napp.use('/api/v1', v1Routes(routeOptions));\n\n// Deprecation warning middleware for unversioned API calls\n// This helps clients migrate to versioned endpoints\napp.use('/api', (req, res, next) => {\n  // Skip if already using versioned endpoint\n  if (req.path.startsWith('/v1')) {\n    return next();\n  }\n  \n  // Add deprecation warning header\n  res.set('X-API-Deprecation-Warning', 'Unversioned API endpoints are deprecated. Please migrate to /api/v1/');\n  res.set('X-API-Version', 'unversioned');\n  res.set('Deprecation', 'true');\n  res.set('Sunset', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toUTCString()); // 90 days from now\n  \n  next();\n});\n\n// HIGH-008: Add Sentry error handler (must be after all routes)\nif (Sentry) {\n  app.use(Sentry.Handlers.errorHandler({\n    shouldHandleError(error) {\n      // Capture all 4xx and 5xx errors\n      if (error.status >= 400) {\n        return true;\n      }\n      return true;\n    },\n  }));\n}\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\n// Track active server for graceful shutdown\nlet server = null;\n\n// Initialize database and start server\nasync function startServer() {\n  try {\n    await usageTracking.initDatabase();\n    await referralService.initReferralTables();\n    await licenseService.initLicenseTables();\n    console.log('[SPLICE] Database initialized');\n\n    // PERF-FIX: Initialize static response cache at startup\n    initializeStaticCache();\n\n    // Start music generation worker (BullMQ background processor)\n    // Only starts if Redis is configured and Replicate API key is available\n    if (process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL) {\n      if (process.env.REPLICATE_API_TOKEN) {\n        try {\n          createMusicWorker();\n          console.log('[SPLICE] ✅ Music generation worker started');\n        } catch (workerErr) {\n          console.error('[SPLICE] ⚠️ Failed to start music worker:', workerErr.message);\n          // Don't fail server startup - music generation will be unavailable\n        }\n      } else {\n        console.warn('[SPLICE] ⚠️ REPLICATE_API_TOKEN not set - music generation disabled');\n      }\n    } else {\n      console.warn('[SPLICE] ⚠️ Redis not configured - music generation queue disabled');\n    }\n\n    if (isProduction || !httpsOptions) {\n      // Production: Railway provides TLS termination, use HTTP\n      server = http.createServer(app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n      });\n    } else {\n      // Development: Use HTTPS with local certificates\n      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n      });\n    }\n  } catch (err) {\n    console.error('[SPLICE] Failed to start server:', err);\n    process.exit(1);\n  }\n}\n\n// =============================================================================\n// Graceful Shutdown\n// =============================================================================\n\nasync function gracefulShutdown(signal) {\n  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n\n  // Stop accepting new connections\n  if (server) {\n    server.close(() => {\n      console.log('[SPLICE] HTTP server closed');\n    });\n  }\n\n  // Shutdown music worker (allows in-progress jobs to complete)\n  try {\n    await shutdownWorker();\n    console.log('[SPLICE] Music worker shut down');\n  } catch (err) {\n    console.error('[SPLICE] Error shutting down music worker:', err.message);\n  }\n\n  // Close database pool\n  try {\n    await usageTracking.closePool();\n    console.log('[SPLICE] Database pool closed');\n  } catch (err) {\n    console.error('[SPLICE] Error closing database pool:', err.message);\n  }\n\n  // Give ongoing requests time to complete (max 10 seconds)\n  setTimeout(() => {\n    console.log('[SPLICE] Graceful shutdown complete');\n    process.exit(0);\n  }, 10000);\n}\n\n// Handle termination signals\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (err) => {\n  console.error('[SPLICE] Uncaught exception:', err);\n  gracefulShutdown('uncaughtException');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n});\n\nstartServer();\n","numLines":938,"startLine":1,"totalLines":938}}}
{"parentUuid":"f214afad-14aa-4cf0-a007-c436de0cd1d4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SBXhBgnPyERGMpVFDAAmqs","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the auth routes and the CEP panel's main JavaScript file to understand the complete integration:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16132,"cache_creation_input_tokens":27780,"cache_read_input_tokens":27881,"cache_creation":{"ephemeral_5m_input_tokens":27780,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2Vd6G8oT6PDX45mS8Ge","type":"assistant","uuid":"dea1c88f-dc3a-4363-87d5-0e1a8448a643","timestamp":"2026-01-11T23:55:44.945Z"}
{"parentUuid":"dea1c88f-dc3a-4363-87d5-0e1a8448a643","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SBXhBgnPyERGMpVFDAAmqs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NrEtxSp6diqQNMNi5eijQN","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16132,"cache_creation_input_tokens":27780,"cache_read_input_tokens":27881,"cache_creation":{"ephemeral_5m_input_tokens":27780,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2Vd6G8oT6PDX45mS8Ge","type":"assistant","uuid":"14eed942-4f15-4050-97a5-82cf321a1105","timestamp":"2026-01-11T23:55:45.812Z"}
{"parentUuid":"14eed942-4f15-4050-97a5-82cf321a1105","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SBXhBgnPyERGMpVFDAAmqs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CNeDwqCkWk1sm5ksDhdU6c","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/main.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16132,"cache_creation_input_tokens":27780,"cache_read_input_tokens":27881,"cache_creation":{"ephemeral_5m_input_tokens":27780,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2Vd6G8oT6PDX45mS8Ge","type":"assistant","uuid":"4a25ddb0-de2a-47e2-9ea4-568b00c710af","timestamp":"2026-01-11T23:55:46.371Z"}
{"parentUuid":"4a25ddb0-de2a-47e2-9ea4-568b00c710af","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SBXhBgnPyERGMpVFDAAmqs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ezb9833YNACTEaC4Cuj2zN","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/billing.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":16132,"cache_creation_input_tokens":27780,"cache_read_input_tokens":27881,"cache_creation":{"ephemeral_5m_input_tokens":27780,"ephemeral_1h_input_tokens":0},"output_tokens":205,"service_tier":"standard"}},"requestId":"req_011CX2Vd6G8oT6PDX45mS8Ge","type":"assistant","uuid":"4b0625d1-7843-476e-a977-c84a4594c1aa","timestamp":"2026-01-11T23:55:46.837Z"}
{"parentUuid":"4b0625d1-7843-476e-a977-c84a4594c1aa","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NrEtxSp6diqQNMNi5eijQN","type":"tool_result","content":"     1→/**\n     2→ * Auth Routes\n     3→ *\n     4→ * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n     5→ *\n     6→ * SECURITY: Enhanced with endpoint-specific rate limiting for sensitive operations\n     7→ * HIGH-003: Added IP-based rate limiting for email verification endpoints\n     8→ * MEDIUM-004: Redis-backed verification codes for horizontal scaling\n     9→ */\n    10→\n    11→const express = require('express');\n    12→const crypto = require('crypto');\n    13→const { rateLimit } = require('express-rate-limit');\n    14→const { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\n    15→const { endpointRateLimit } = require('../middleware/rateLimiter');\n    16→const authLogger = require('../utils/authLogger');\n    17→const redis = require('../services/redisClient');\n    18→\n    19→// ============================================================================\n    20→// HIGH-003: IP-Based Rate Limiting for Email Verification\n    21→// Prevents abuse of email verification endpoints regardless of email\n    22→// ============================================================================\n    23→\n    24→/**\n    25→ * IP-based rate limiter for email verification endpoints\n    26→ * Limits: 5 requests per 15 minutes per IP address\n    27→ */\n    28→const emailVerificationLimiter = rateLimit({\n    29→  windowMs: 15 * 60 * 1000, // 15 minutes\n    30→  max: 5, // 5 requests per IP per window\n    31→  keyGenerator: (req) => {\n    32→    // Use X-Forwarded-For header in production (behind proxy)\n    33→    return req.ip || req.headers['x-forwarded-for']?.split(',')[0]?.trim() || 'unknown';\n    34→  },\n    35→  message: {\n    36→    error: 'Too many verification attempts',\n    37→    message: 'Too many verification requests from this IP. Please try again later.',\n    38→    retryAfter: 15 * 60 // 15 minutes in seconds\n    39→  },\n    40→  standardHeaders: true, // Return rate limit info in RateLimit-* headers\n    41→  legacyHeaders: false, // Disable X-RateLimit-* headers\n    42→  handler: (req, res, next, options) => {\n    43→    console.warn(`[Auth] IP rate limit exceeded for email verification: ${req.ip}`);\n    44→    res.status(429).json(options.message);\n    45→  }\n    46→});\n    47→\n    48→// ============================================================================\n    49→// Email Verification Code Storage\n    50→// MEDIUM-004: Redis-backed storage for horizontal scaling\n    51→// Fallback to in-memory storage when Redis is unavailable\n    52→// ============================================================================\n    53→\n    54→// Fallback in-memory storage (used when Redis is unavailable)\n    55→const fallbackVerificationCodes = new Map();\n    56→const fallbackLastSendTime = new Map();\n    57→\n    58→// Verification code expiry time (10 minutes = 600 seconds)\n    59→const VERIFICATION_CODE_TTL_SECONDS = 600;\n    60→const VERIFICATION_CODE_EXPIRY_MS = VERIFICATION_CODE_TTL_SECONDS * 1000;\n    61→\n    62→// Maximum verification attempts before code is invalidated\n    63→const MAX_VERIFICATION_ATTEMPTS = 5;\n    64→\n    65→// Rate limiting: minimum time between sending codes to same email (60 seconds)\n    66→const SEND_CODE_COOLDOWN_SECONDS = 60;\n    67→const SEND_CODE_COOLDOWN_MS = SEND_CODE_COOLDOWN_SECONDS * 1000;\n    68→\n    69→// Redis key prefixes\n    70→const REDIS_KEY_VERIFY = 'verify:';\n    71→const REDIS_KEY_SEND_TIME = 'verify:sendtime:';\n    72→\n    73→/**\n    74→ * Generate a 6-digit verification code\n    75→ * @returns {string} 6-digit code\n    76→ */\n    77→function generateVerificationCode() {\n    78→  // Generate cryptographically secure random 6-digit code\n    79→  const code = crypto.randomInt(100000, 999999).toString();\n    80→  return code;\n    81→}\n    82→\n    83→/**\n    84→ * Store a verification code for an email (Redis-backed with fallback)\n    85→ * @param {string} email - Email address\n    86→ * @param {string} code - Verification code\n    87→ * @returns {Promise<void>}\n    88→ */\n    89→async function storeVerificationCode(email, code) {\n    90→  const normalizedEmail = email.toLowerCase().trim();\n    91→  const data = {\n    92→    code,\n    93→    createdAt: Date.now(),\n    94→    attempts: 0\n    95→  };\n    96→\n    97→  // Try Redis first\n    98→  if (redis.isRedisAvailable()) {\n    99→    try {\n   100→      const verifyKey = `${REDIS_KEY_VERIFY}${normalizedEmail}`;\n   101→      const sendTimeKey = `${REDIS_KEY_SEND_TIME}${normalizedEmail}`;\n   102→      \n   103→      await redis.set(verifyKey, data, VERIFICATION_CODE_TTL_SECONDS);\n   104→      await redis.set(sendTimeKey, Date.now(), SEND_CODE_COOLDOWN_SECONDS * 2); // Keep send time a bit longer\n   105→      return;\n   106→    } catch (err) {\n   107→      console.warn('[Auth] Redis store failed, using fallback:', err.message);\n   108→    }\n   109→  }\n   110→\n   111→  // Fallback to in-memory storage\n   112→  fallbackVerificationCodes.set(normalizedEmail, {\n   113→    ...data,\n   114→    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS\n   115→  });\n   116→  fallbackLastSendTime.set(normalizedEmail, Date.now());\n   117→}\n   118→\n   119→/**\n   120→ * Verify a code for an email (Redis-backed with fallback)\n   121→ * @param {string} email - Email address\n   122→ * @param {string} code - Code to verify\n   123→ * @returns {Promise<{ valid: boolean, error?: string }>}\n   124→ */\n   125→async function verifyCode(email, code) {\n   126→  const normalizedEmail = email.toLowerCase().trim();\n   127→\n   128→  // Try Redis first\n   129→  if (redis.isRedisAvailable()) {\n   130→    try {\n   131→      const verifyKey = `${REDIS_KEY_VERIFY}${normalizedEmail}`;\n   132→      const stored = await redis.get(verifyKey);\n   133→\n   134→      if (!stored) {\n   135→        return { valid: false, error: 'No verification code found. Please request a new one.' };\n   136→      }\n   137→\n   138→      // Increment attempt counter\n   139→      stored.attempts = (stored.attempts || 0) + 1;\n   140→\n   141→      // Check if too many attempts\n   142→      if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n   143→        await redis.del(verifyKey);\n   144→        return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n   145→      }\n   146→\n   147→      // Check if code matches\n   148→      if (stored.code !== code) {\n   149→        // Update attempts count in Redis (keep remaining TTL)\n   150→        const ttl = await redis.ttl(verifyKey);\n   151→        if (ttl > 0) {\n   152→          await redis.set(verifyKey, stored, ttl);\n   153→        }\n   154→        return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n   155→      }\n   156→\n   157→      // Code is valid - remove it (single use)\n   158→      await redis.del(verifyKey);\n   159→      return { valid: true };\n   160→    } catch (err) {\n   161→      console.warn('[Auth] Redis verify failed, using fallback:', err.message);\n   162→    }\n   163→  }\n   164→\n   165→  // Fallback to in-memory storage\n   166→  const stored = fallbackVerificationCodes.get(normalizedEmail);\n   167→\n   168→  if (!stored) {\n   169→    return { valid: false, error: 'No verification code found. Please request a new one.' };\n   170→  }\n   171→\n   172→  // Check if expired\n   173→  if (Date.now() > stored.expires) {\n   174→    fallbackVerificationCodes.delete(normalizedEmail);\n   175→    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n   176→  }\n   177→\n   178→  // Increment attempt counter\n   179→  stored.attempts++;\n   180→\n   181→  // Check if too many attempts\n   182→  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n   183→    fallbackVerificationCodes.delete(normalizedEmail);\n   184→    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n   185→  }\n   186→\n   187→  // Check if code matches\n   188→  if (stored.code !== code) {\n   189→    fallbackVerificationCodes.set(normalizedEmail, stored);\n   190→    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n   191→  }\n   192→\n   193→  // Code is valid - remove it (single use)\n   194→  fallbackVerificationCodes.delete(normalizedEmail);\n   195→  return { valid: true };\n   196→}\n   197→\n   198→/**\n   199→ * Check if we can send a new code to an email (rate limiting, Redis-backed)\n   200→ * @param {string} email - Email address\n   201→ * @returns {Promise<{ allowed: boolean, waitSeconds?: number }>}\n   202→ */\n   203→async function canSendCode(email) {\n   204→  const normalizedEmail = email.toLowerCase().trim();\n   205→\n   206→  // Try Redis first\n   207→  if (redis.isRedisAvailable()) {\n   208→    try {\n   209→      const sendTimeKey = `${REDIS_KEY_SEND_TIME}${normalizedEmail}`;\n   210→      const lastSent = await redis.get(sendTimeKey);\n   211→\n   212→      if (!lastSent) {\n   213→        return { allowed: true };\n   214→      }\n   215→\n   216→      const elapsed = Date.now() - lastSent;\n   217→      if (elapsed < SEND_CODE_COOLDOWN_MS) {\n   218→        const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n   219→        return { allowed: false, waitSeconds };\n   220→      }\n   221→\n   222→      return { allowed: true };\n   223→    } catch (err) {\n   224→      console.warn('[Auth] Redis canSendCode failed, using fallback:', err.message);\n   225→    }\n   226→  }\n   227→\n   228→  // Fallback to in-memory storage\n   229→  const lastSent = fallbackLastSendTime.get(normalizedEmail);\n   230→\n   231→  if (!lastSent) {\n   232→    return { allowed: true };\n   233→  }\n   234→\n   235→  const elapsed = Date.now() - lastSent;\n   236→  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n   237→    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n   238→    return { allowed: false, waitSeconds };\n   239→  }\n   240→\n   241→  return { allowed: true };\n   242→}\n   243→\n   244→// Cleanup for fallback in-memory storage (only needed when Redis is unavailable)\n   245→// Redis handles expiration automatically via TTL\n   246→function cleanupFallbackStorage() {\n   247→  const now = Date.now();\n   248→  let cleanedCount = 0;\n   249→\n   250→  for (const [email, data] of fallbackVerificationCodes.entries()) {\n   251→    if (data.expires <= now) {\n   252→      fallbackVerificationCodes.delete(email);\n   253→      cleanedCount++;\n   254→    }\n   255→  }\n   256→\n   257→  // Also clean up old lastSendTime entries (older than 1 hour)\n   258→  const oneHourAgo = now - (60 * 60 * 1000);\n   259→  for (const [email, time] of fallbackLastSendTime.entries()) {\n   260→    if (time < oneHourAgo) {\n   261→      fallbackLastSendTime.delete(email);\n   262→    }\n   263→  }\n   264→\n   265→  if (cleanedCount > 0) {\n   266→    console.log(`[Auth] Fallback storage cleanup: removed ${cleanedCount} expired codes`);\n   267→  }\n   268→}\n   269→\n   270→// Start periodic cleanup for fallback storage (unref to allow process exit)\n   271→const cleanupTimer = setInterval(cleanupFallbackStorage, 5 * 60 * 1000);\n   272→if (cleanupTimer.unref) {\n   273→  cleanupTimer.unref();\n   274→}\n   275→\n   276→/**\n   277→ * Validate email format\n   278→ * @param {string} email - Email to validate\n   279→ * @returns {boolean}\n   280→ */\n   281→function isValidEmail(email) {\n   282→  if (!email || typeof email !== 'string') return false;\n   283→  // Basic email validation regex\n   284→  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n   285→  return emailRegex.test(email.trim());\n   286→}\n   287→\n   288→/**\n   289→ * Create auth routes\n   290→ * @param {Object} options - Route configuration options\n   291→ * @param {Object} options.middleware - Shared middleware (authenticateToken)\n   292→ * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n   293→ * @param {Object} options.authHelpers - Auth helper functions\n   294→ * @returns {express.Router}\n   295→ */\n   296→function createAuthRoutes(options = {}) {\n   297→  const router = express.Router();\n   298→  const { authenticateToken } = options.middleware || {};\n   299→  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n   300→  const { usageTracking, licenseService, emailService } = options.services || {};\n   301→\n   302→  /**\n   303→   * GET /csrf-token - Generate and return a CSRF token\n   304→   *\n   305→   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   306→   * The token is returned in both the response body and an HttpOnly cookie.\n   307→   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   308→   */\n   309→  router.get('/csrf-token', csrfTokenHandler);\n   310→\n   311→  /**\n   312→   * POST /login - Authenticate with license key and get JWT token\n   313→   *\n   314→   * SECURITY: This is the primary authentication endpoint.\n   315→   * Validates license key and returns a JWT token for API access.\n   316→   * NOTE: CSRF disabled - license key auth is not vulnerable to CSRF\n   317→   * (user must know the key, it's not auto-submitted like cookies)\n   318→   */\n   319→  router.post('/login', async (req, res) => {\n   320→    const { licenseKey } = req.body;\n   321→\n   322→    if (!licenseKey) {\n   323→      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n   324→      return res.status(400).json({\n   325→        error: 'License key required',\n   326→        message: 'Please provide your license key to log in'\n   327→      });\n   328→    }\n   329→\n   330→    try {\n   331→      // Validate and activate the license key\n   332→      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n   333→\n   334→      if (!licenseResult.success) {\n   335→        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n   336→        return res.status(401).json({\n   337→          error: 'Invalid license key',\n   338→          message: licenseResult.error || 'The license key is invalid or expired'\n   339→        });\n   340→      }\n   341→\n   342→      // Get user's tier and balance\n   343→      const balance = await usageTracking.getBalance(licenseResult.customerId);\n   344→\n   345→      // Generate JWT tokens\n   346→      const tokenResult = generateToken(licenseResult.customerId, {\n   347→        tier: balance.tier,\n   348→        email: licenseResult.email\n   349→      });\n   350→      const refreshResult = generateRefreshToken(licenseResult.customerId);\n   351→\n   352→      // Log successful login with structured logging\n   353→      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n   354→        email: licenseResult.email,\n   355→        tier: balance.tier\n   356→      });\n   357→\n   358→      res.json({\n   359→        success: true,\n   360→        token: tokenResult.token,\n   361→        tokenType: tokenResult.tokenType,\n   362→        expiresIn: tokenResult.expiresIn,\n   363→        refreshToken: refreshResult.refreshToken,\n   364→        customerId: licenseResult.customerId,\n   365→        tier: balance.tier,\n   366→        hoursRemaining: balance.hoursRemaining\n   367→      });\n   368→    } catch (err) {\n   369→      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n   370→      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n   371→    }\n   372→  });\n   373→\n   374→  /**\n   375→   * POST /refresh - Refresh an expired JWT token\n   376→   *\n   377→   * Uses a refresh token to get a new access token.\n   378→   * NOTE: CSRF disabled for cross-domain compatibility during beta.\n   379→   */\n   380→  router.post('/refresh', async (req, res) => {\n   381→    const { refreshToken } = req.body;\n   382→\n   383→    if (!refreshToken) {\n   384→      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n   385→      return res.status(400).json({\n   386→        error: 'Refresh token required'\n   387→      });\n   388→    }\n   389→\n   390→    try {\n   391→      const decoded = await verifyToken(refreshToken, { req });\n   392→\n   393→      if (!decoded || decoded.type !== 'refresh') {\n   394→        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n   395→        return res.status(401).json({\n   396→          error: 'Invalid refresh token',\n   397→          message: 'Please log in again'\n   398→        });\n   399→      }\n   400→\n   401→      // Get current user info\n   402→      const balance = await usageTracking.getBalance(decoded.sub);\n   403→\n   404→      // Generate new access token\n   405→      const tokenResult = generateToken(decoded.sub, {\n   406→        tier: balance.tier\n   407→      });\n   408→\n   409→      // Log successful token refresh\n   410→      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n   411→\n   412→      res.json({\n   413→        success: true,\n   414→        token: tokenResult.token,\n   415→        tokenType: tokenResult.tokenType,\n   416→        expiresIn: tokenResult.expiresIn\n   417→      });\n   418→    } catch (err) {\n   419→      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n   420→      res.status(401).json({\n   421→        error: 'Failed to refresh token',\n   422→        message: 'Please log in again'\n   423→      });\n   424→    }\n   425→  });\n   426→\n   427→  /**\n   428→   * POST /logout - Invalidate tokens by adding to blacklist\n   429→   *\n   430→   * Adds the current token's jti to the blacklist so it cannot be reused.\n   431→   * Also accepts an optional refreshToken to revoke both tokens at once.\n   432→   * CSRF protection applied to prevent forced logout attacks.\n   433→   */\n   434→  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n   435→    const { refreshToken } = req.body;\n   436→    let refreshTokenRevoked = false;\n   437→\n   438→    // Blacklist the access token using the blacklistToken function from authHelpers\n   439→    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n   440→      if (blacklistToken) {\n   441→        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n   442→          userId: req.stripeCustomerId,\n   443→          reason: 'logout'\n   444→        });\n   445→      } else {\n   446→        console.warn('[Auth] Logout: blacklistToken function not available');\n   447→      }\n   448→    } else {\n   449→      // Token doesn't have jti - log warning but continue\n   450→      // This handles tokens generated before jti was added\n   451→      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n   452→    }\n   453→\n   454→    // Optionally blacklist the refresh token too\n   455→    if (refreshToken && blacklistToken) {\n   456→      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n   457→      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n   458→      if (decoded && decoded.jti && decoded.exp) {\n   459→        await blacklistToken(decoded.jti, decoded.exp, {\n   460→          userId: req.stripeCustomerId,\n   461→          reason: 'logout_refresh'\n   462→        });\n   463→        refreshTokenRevoked = true;\n   464→      }\n   465→    }\n   466→\n   467→    // Log successful logout with structured logging\n   468→    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n   469→      jti: req.tokenData?.jti,\n   470→      refreshTokenRevoked\n   471→    });\n   472→\n   473→    res.json({\n   474→      success: true,\n   475→      message: 'Logged out successfully'\n   476→    });\n   477→  });\n   478→\n   479→  // ==========================================================================\n   480→  // Email Verification Endpoints\n   481→  // ==========================================================================\n   482→\n   483→  /**\n   484→   * POST /send-verification - Send a verification code to an email address\n   485→   *\n   486→   * Request body: { email: string }\n   487→   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   488→   *\n   489→   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   490→   * HIGH-003: Added IP-based rate limiting (5 requests per 15 minutes per IP)\n   491→   */\n   492→  router.post('/send-verification', emailVerificationLimiter, validateCsrfToken, async (req, res) => {\n   493→    const { email } = req.body;\n   494→\n   495→    // Validate email\n   496→    if (!email) {\n   497→      return res.status(400).json({\n   498→        error: 'Email required',\n   499→        message: 'Please provide an email address'\n   500→      });\n   501→    }\n   502→\n   503→    if (!isValidEmail(email)) {\n   504→      return res.status(400).json({\n   505→        error: 'Invalid email',\n   506→        message: 'Please provide a valid email address'\n   507→      });\n   508→    }\n   509→\n   510→    // Check rate limiting (async - Redis backed)\n   511→    const rateCheck = await canSendCode(email);\n   512→    if (!rateCheck.allowed) {\n   513→      return res.status(429).json({\n   514→        error: 'Too many requests',\n   515→        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n   516→        waitSeconds: rateCheck.waitSeconds\n   517→      });\n   518→    }\n   519→\n   520→    try {\n   521→      // Generate and store verification code (async - Redis backed)\n   522→      const code = generateVerificationCode();\n   523→      await storeVerificationCode(email, code);\n   524→\n   525→      // Send verification email\n   526→      if (emailService && emailService.sendEmailVerificationCode) {\n   527→        await emailService.sendEmailVerificationCode(email, code, 10);\n   528→        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n   529→      } else {\n   530→        // Fallback for development - log to console\n   531→        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n   532→      }\n   533→\n   534→      res.json({\n   535→        success: true,\n   536→        message: 'Verification code sent. Please check your email.',\n   537→        expiresInMinutes: 10\n   538→      });\n   539→    } catch (err) {\n   540→      console.error('[Auth] Send verification error:', err.message);\n   541→      res.status(500).json({\n   542→        error: 'Failed to send verification code',\n   543→        message: 'Please try again later'\n   544→      });\n   545→    }\n   546→  });\n   547→\n   548→  /**\n   549→   * POST /verify-email - Verify an email address with a code\n   550→   *\n   551→   * Request body: { email: string, code: string }\n   552→   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   553→   *\n   554→   * SECURITY: Limited attempts per code. CSRF protection applied.\n   555→   * HIGH-003: Added IP-based rate limiting (5 requests per 15 minutes per IP)\n   556→   */\n   557→  router.post('/verify-email', emailVerificationLimiter, validateCsrfToken, async (req, res) => {\n   558→    const { email, code } = req.body;\n   559→\n   560→    // Validate inputs\n   561→    if (!email) {\n   562→      return res.status(400).json({\n   563→        error: 'Email required',\n   564→        message: 'Please provide an email address'\n   565→      });\n   566→    }\n   567→\n   568→    if (!code) {\n   569→      return res.status(400).json({\n   570→        error: 'Code required',\n   571→        message: 'Please provide the verification code'\n   572→      });\n   573→    }\n   574→\n   575→    if (!isValidEmail(email)) {\n   576→      return res.status(400).json({\n   577→        error: 'Invalid email',\n   578→        message: 'Please provide a valid email address'\n   579→      });\n   580→    }\n   581→\n   582→    // Validate code format (6 digits)\n   583→    const codeStr = String(code).trim();\n   584→    if (!/^\\d{6}$/.test(codeStr)) {\n   585→      return res.status(400).json({\n   586→        error: 'Invalid code format',\n   587→        message: 'Verification code must be 6 digits'\n   588→      });\n   589→    }\n   590→\n   591→    try {\n   592→      // Verify the code (async - Redis backed)\n   593→      const result = await verifyCode(email, codeStr);\n   594→\n   595→      if (!result.valid) {\n   596→        return res.status(400).json({\n   597→          success: false,\n   598→          verified: false,\n   599→          error: 'Verification failed',\n   600→          message: result.error\n   601→        });\n   602→      }\n   603→\n   604→      // Mark email as verified in the database\n   605→      if (usageTracking && usageTracking.markEmailVerified) {\n   606→        const dbResult = await usageTracking.markEmailVerified(email);\n   607→        if (!dbResult.success) {\n   608→          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n   609→        }\n   610→      }\n   611→\n   612→      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n   613→\n   614→      // Email verified successfully\n   615→      res.json({\n   616→        success: true,\n   617→        verified: true,\n   618→        message: 'Email verified successfully'\n   619→      });\n   620→    } catch (err) {\n   621→      console.error('[Auth] Verify email error:', err.message);\n   622→      res.status(500).json({\n   623→        error: 'Verification failed',\n   624→        message: 'Please try again later'\n   625→      });\n   626→    }\n   627→  });\n   628→\n   629→  return router;\n   630→}\n   631→\n   632→module.exports = createAuthRoutes;\n   633→\n\n</system-reminder>\n"}]},"uuid":"bcdf9dea-cad3-4eab-9ed9-617e92d733c5","timestamp":"2026-01-11T23:55:46.870Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/auth.js","content":"/**\n * Auth Routes\n *\n * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n *\n * SECURITY: Enhanced with endpoint-specific rate limiting for sensitive operations\n * HIGH-003: Added IP-based rate limiting for email verification endpoints\n * MEDIUM-004: Redis-backed verification codes for horizontal scaling\n */\n\nconst express = require('express');\nconst crypto = require('crypto');\nconst { rateLimit } = require('express-rate-limit');\nconst { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\nconst { endpointRateLimit } = require('../middleware/rateLimiter');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// ============================================================================\n// HIGH-003: IP-Based Rate Limiting for Email Verification\n// Prevents abuse of email verification endpoints regardless of email\n// ============================================================================\n\n/**\n * IP-based rate limiter for email verification endpoints\n * Limits: 5 requests per 15 minutes per IP address\n */\nconst emailVerificationLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 requests per IP per window\n  keyGenerator: (req) => {\n    // Use X-Forwarded-For header in production (behind proxy)\n    return req.ip || req.headers['x-forwarded-for']?.split(',')[0]?.trim() || 'unknown';\n  },\n  message: {\n    error: 'Too many verification attempts',\n    message: 'Too many verification requests from this IP. Please try again later.',\n    retryAfter: 15 * 60 // 15 minutes in seconds\n  },\n  standardHeaders: true, // Return rate limit info in RateLimit-* headers\n  legacyHeaders: false, // Disable X-RateLimit-* headers\n  handler: (req, res, next, options) => {\n    console.warn(`[Auth] IP rate limit exceeded for email verification: ${req.ip}`);\n    res.status(429).json(options.message);\n  }\n});\n\n// ============================================================================\n// Email Verification Code Storage\n// MEDIUM-004: Redis-backed storage for horizontal scaling\n// Fallback to in-memory storage when Redis is unavailable\n// ============================================================================\n\n// Fallback in-memory storage (used when Redis is unavailable)\nconst fallbackVerificationCodes = new Map();\nconst fallbackLastSendTime = new Map();\n\n// Verification code expiry time (10 minutes = 600 seconds)\nconst VERIFICATION_CODE_TTL_SECONDS = 600;\nconst VERIFICATION_CODE_EXPIRY_MS = VERIFICATION_CODE_TTL_SECONDS * 1000;\n\n// Maximum verification attempts before code is invalidated\nconst MAX_VERIFICATION_ATTEMPTS = 5;\n\n// Rate limiting: minimum time between sending codes to same email (60 seconds)\nconst SEND_CODE_COOLDOWN_SECONDS = 60;\nconst SEND_CODE_COOLDOWN_MS = SEND_CODE_COOLDOWN_SECONDS * 1000;\n\n// Redis key prefixes\nconst REDIS_KEY_VERIFY = 'verify:';\nconst REDIS_KEY_SEND_TIME = 'verify:sendtime:';\n\n/**\n * Generate a 6-digit verification code\n * @returns {string} 6-digit code\n */\nfunction generateVerificationCode() {\n  // Generate cryptographically secure random 6-digit code\n  const code = crypto.randomInt(100000, 999999).toString();\n  return code;\n}\n\n/**\n * Store a verification code for an email (Redis-backed with fallback)\n * @param {string} email - Email address\n * @param {string} code - Verification code\n * @returns {Promise<void>}\n */\nasync function storeVerificationCode(email, code) {\n  const normalizedEmail = email.toLowerCase().trim();\n  const data = {\n    code,\n    createdAt: Date.now(),\n    attempts: 0\n  };\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const verifyKey = `${REDIS_KEY_VERIFY}${normalizedEmail}`;\n      const sendTimeKey = `${REDIS_KEY_SEND_TIME}${normalizedEmail}`;\n      \n      await redis.set(verifyKey, data, VERIFICATION_CODE_TTL_SECONDS);\n      await redis.set(sendTimeKey, Date.now(), SEND_CODE_COOLDOWN_SECONDS * 2); // Keep send time a bit longer\n      return;\n    } catch (err) {\n      console.warn('[Auth] Redis store failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory storage\n  fallbackVerificationCodes.set(normalizedEmail, {\n    ...data,\n    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS\n  });\n  fallbackLastSendTime.set(normalizedEmail, Date.now());\n}\n\n/**\n * Verify a code for an email (Redis-backed with fallback)\n * @param {string} email - Email address\n * @param {string} code - Code to verify\n * @returns {Promise<{ valid: boolean, error?: string }>}\n */\nasync function verifyCode(email, code) {\n  const normalizedEmail = email.toLowerCase().trim();\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const verifyKey = `${REDIS_KEY_VERIFY}${normalizedEmail}`;\n      const stored = await redis.get(verifyKey);\n\n      if (!stored) {\n        return { valid: false, error: 'No verification code found. Please request a new one.' };\n      }\n\n      // Increment attempt counter\n      stored.attempts = (stored.attempts || 0) + 1;\n\n      // Check if too many attempts\n      if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n        await redis.del(verifyKey);\n        return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n      }\n\n      // Check if code matches\n      if (stored.code !== code) {\n        // Update attempts count in Redis (keep remaining TTL)\n        const ttl = await redis.ttl(verifyKey);\n        if (ttl > 0) {\n          await redis.set(verifyKey, stored, ttl);\n        }\n        return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n      }\n\n      // Code is valid - remove it (single use)\n      await redis.del(verifyKey);\n      return { valid: true };\n    } catch (err) {\n      console.warn('[Auth] Redis verify failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory storage\n  const stored = fallbackVerificationCodes.get(normalizedEmail);\n\n  if (!stored) {\n    return { valid: false, error: 'No verification code found. Please request a new one.' };\n  }\n\n  // Check if expired\n  if (Date.now() > stored.expires) {\n    fallbackVerificationCodes.delete(normalizedEmail);\n    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n  }\n\n  // Increment attempt counter\n  stored.attempts++;\n\n  // Check if too many attempts\n  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n    fallbackVerificationCodes.delete(normalizedEmail);\n    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n  }\n\n  // Check if code matches\n  if (stored.code !== code) {\n    fallbackVerificationCodes.set(normalizedEmail, stored);\n    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n  }\n\n  // Code is valid - remove it (single use)\n  fallbackVerificationCodes.delete(normalizedEmail);\n  return { valid: true };\n}\n\n/**\n * Check if we can send a new code to an email (rate limiting, Redis-backed)\n * @param {string} email - Email address\n * @returns {Promise<{ allowed: boolean, waitSeconds?: number }>}\n */\nasync function canSendCode(email) {\n  const normalizedEmail = email.toLowerCase().trim();\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const sendTimeKey = `${REDIS_KEY_SEND_TIME}${normalizedEmail}`;\n      const lastSent = await redis.get(sendTimeKey);\n\n      if (!lastSent) {\n        return { allowed: true };\n      }\n\n      const elapsed = Date.now() - lastSent;\n      if (elapsed < SEND_CODE_COOLDOWN_MS) {\n        const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n        return { allowed: false, waitSeconds };\n      }\n\n      return { allowed: true };\n    } catch (err) {\n      console.warn('[Auth] Redis canSendCode failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory storage\n  const lastSent = fallbackLastSendTime.get(normalizedEmail);\n\n  if (!lastSent) {\n    return { allowed: true };\n  }\n\n  const elapsed = Date.now() - lastSent;\n  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n    return { allowed: false, waitSeconds };\n  }\n\n  return { allowed: true };\n}\n\n// Cleanup for fallback in-memory storage (only needed when Redis is unavailable)\n// Redis handles expiration automatically via TTL\nfunction cleanupFallbackStorage() {\n  const now = Date.now();\n  let cleanedCount = 0;\n\n  for (const [email, data] of fallbackVerificationCodes.entries()) {\n    if (data.expires <= now) {\n      fallbackVerificationCodes.delete(email);\n      cleanedCount++;\n    }\n  }\n\n  // Also clean up old lastSendTime entries (older than 1 hour)\n  const oneHourAgo = now - (60 * 60 * 1000);\n  for (const [email, time] of fallbackLastSendTime.entries()) {\n    if (time < oneHourAgo) {\n      fallbackLastSendTime.delete(email);\n    }\n  }\n\n  if (cleanedCount > 0) {\n    console.log(`[Auth] Fallback storage cleanup: removed ${cleanedCount} expired codes`);\n  }\n}\n\n// Start periodic cleanup for fallback storage (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackStorage, 5 * 60 * 1000);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Validate email format\n * @param {string} email - Email to validate\n * @returns {boolean}\n */\nfunction isValidEmail(email) {\n  if (!email || typeof email !== 'string') return false;\n  // Basic email validation regex\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email.trim());\n}\n\n/**\n * Create auth routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (authenticateToken)\n * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n * @param {Object} options.authHelpers - Auth helper functions\n * @returns {express.Router}\n */\nfunction createAuthRoutes(options = {}) {\n  const router = express.Router();\n  const { authenticateToken } = options.middleware || {};\n  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n  const { usageTracking, licenseService, emailService } = options.services || {};\n\n  /**\n   * GET /csrf-token - Generate and return a CSRF token\n   *\n   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   * The token is returned in both the response body and an HttpOnly cookie.\n   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   */\n  router.get('/csrf-token', csrfTokenHandler);\n\n  /**\n   * POST /login - Authenticate with license key and get JWT token\n   *\n   * SECURITY: This is the primary authentication endpoint.\n   * Validates license key and returns a JWT token for API access.\n   * NOTE: CSRF disabled - license key auth is not vulnerable to CSRF\n   * (user must know the key, it's not auto-submitted like cookies)\n   */\n  router.post('/login', async (req, res) => {\n    const { licenseKey } = req.body;\n\n    if (!licenseKey) {\n      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n      return res.status(400).json({\n        error: 'License key required',\n        message: 'Please provide your license key to log in'\n      });\n    }\n\n    try {\n      // Validate and activate the license key\n      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n\n      if (!licenseResult.success) {\n        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n        return res.status(401).json({\n          error: 'Invalid license key',\n          message: licenseResult.error || 'The license key is invalid or expired'\n        });\n      }\n\n      // Get user's tier and balance\n      const balance = await usageTracking.getBalance(licenseResult.customerId);\n\n      // Generate JWT tokens\n      const tokenResult = generateToken(licenseResult.customerId, {\n        tier: balance.tier,\n        email: licenseResult.email\n      });\n      const refreshResult = generateRefreshToken(licenseResult.customerId);\n\n      // Log successful login with structured logging\n      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n        email: licenseResult.email,\n        tier: balance.tier\n      });\n\n      res.json({\n        success: true,\n        token: tokenResult.token,\n        tokenType: tokenResult.tokenType,\n        expiresIn: tokenResult.expiresIn,\n        refreshToken: refreshResult.refreshToken,\n        customerId: licenseResult.customerId,\n        tier: balance.tier,\n        hoursRemaining: balance.hoursRemaining\n      });\n    } catch (err) {\n      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n    }\n  });\n\n  /**\n   * POST /refresh - Refresh an expired JWT token\n   *\n   * Uses a refresh token to get a new access token.\n   * NOTE: CSRF disabled for cross-domain compatibility during beta.\n   */\n  router.post('/refresh', async (req, res) => {\n    const { refreshToken } = req.body;\n\n    if (!refreshToken) {\n      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n      return res.status(400).json({\n        error: 'Refresh token required'\n      });\n    }\n\n    try {\n      const decoded = await verifyToken(refreshToken, { req });\n\n      if (!decoded || decoded.type !== 'refresh') {\n        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n        return res.status(401).json({\n          error: 'Invalid refresh token',\n          message: 'Please log in again'\n        });\n      }\n\n      // Get current user info\n      const balance = await usageTracking.getBalance(decoded.sub);\n\n      // Generate new access token\n      const tokenResult = generateToken(decoded.sub, {\n        tier: balance.tier\n      });\n\n      // Log successful token refresh\n      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n\n      res.json({\n        success: true,\n        token: tokenResult.token,\n        tokenType: tokenResult.tokenType,\n        expiresIn: tokenResult.expiresIn\n      });\n    } catch (err) {\n      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n      res.status(401).json({\n        error: 'Failed to refresh token',\n        message: 'Please log in again'\n      });\n    }\n  });\n\n  /**\n   * POST /logout - Invalidate tokens by adding to blacklist\n   *\n   * Adds the current token's jti to the blacklist so it cannot be reused.\n   * Also accepts an optional refreshToken to revoke both tokens at once.\n   * CSRF protection applied to prevent forced logout attacks.\n   */\n  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n    const { refreshToken } = req.body;\n    let refreshTokenRevoked = false;\n\n    // Blacklist the access token using the blacklistToken function from authHelpers\n    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n      if (blacklistToken) {\n        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n          userId: req.stripeCustomerId,\n          reason: 'logout'\n        });\n      } else {\n        console.warn('[Auth] Logout: blacklistToken function not available');\n      }\n    } else {\n      // Token doesn't have jti - log warning but continue\n      // This handles tokens generated before jti was added\n      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n    }\n\n    // Optionally blacklist the refresh token too\n    if (refreshToken && blacklistToken) {\n      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n      if (decoded && decoded.jti && decoded.exp) {\n        await blacklistToken(decoded.jti, decoded.exp, {\n          userId: req.stripeCustomerId,\n          reason: 'logout_refresh'\n        });\n        refreshTokenRevoked = true;\n      }\n    }\n\n    // Log successful logout with structured logging\n    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n      jti: req.tokenData?.jti,\n      refreshTokenRevoked\n    });\n\n    res.json({\n      success: true,\n      message: 'Logged out successfully'\n    });\n  });\n\n  // ==========================================================================\n  // Email Verification Endpoints\n  // ==========================================================================\n\n  /**\n   * POST /send-verification - Send a verification code to an email address\n   *\n   * Request body: { email: string }\n   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   *\n   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   * HIGH-003: Added IP-based rate limiting (5 requests per 15 minutes per IP)\n   */\n  router.post('/send-verification', emailVerificationLimiter, validateCsrfToken, async (req, res) => {\n    const { email } = req.body;\n\n    // Validate email\n    if (!email) {\n      return res.status(400).json({\n        error: 'Email required',\n        message: 'Please provide an email address'\n      });\n    }\n\n    if (!isValidEmail(email)) {\n      return res.status(400).json({\n        error: 'Invalid email',\n        message: 'Please provide a valid email address'\n      });\n    }\n\n    // Check rate limiting (async - Redis backed)\n    const rateCheck = await canSendCode(email);\n    if (!rateCheck.allowed) {\n      return res.status(429).json({\n        error: 'Too many requests',\n        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n        waitSeconds: rateCheck.waitSeconds\n      });\n    }\n\n    try {\n      // Generate and store verification code (async - Redis backed)\n      const code = generateVerificationCode();\n      await storeVerificationCode(email, code);\n\n      // Send verification email\n      if (emailService && emailService.sendEmailVerificationCode) {\n        await emailService.sendEmailVerificationCode(email, code, 10);\n        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n      } else {\n        // Fallback for development - log to console\n        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n      }\n\n      res.json({\n        success: true,\n        message: 'Verification code sent. Please check your email.',\n        expiresInMinutes: 10\n      });\n    } catch (err) {\n      console.error('[Auth] Send verification error:', err.message);\n      res.status(500).json({\n        error: 'Failed to send verification code',\n        message: 'Please try again later'\n      });\n    }\n  });\n\n  /**\n   * POST /verify-email - Verify an email address with a code\n   *\n   * Request body: { email: string, code: string }\n   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   *\n   * SECURITY: Limited attempts per code. CSRF protection applied.\n   * HIGH-003: Added IP-based rate limiting (5 requests per 15 minutes per IP)\n   */\n  router.post('/verify-email', emailVerificationLimiter, validateCsrfToken, async (req, res) => {\n    const { email, code } = req.body;\n\n    // Validate inputs\n    if (!email) {\n      return res.status(400).json({\n        error: 'Email required',\n        message: 'Please provide an email address'\n      });\n    }\n\n    if (!code) {\n      return res.status(400).json({\n        error: 'Code required',\n        message: 'Please provide the verification code'\n      });\n    }\n\n    if (!isValidEmail(email)) {\n      return res.status(400).json({\n        error: 'Invalid email',\n        message: 'Please provide a valid email address'\n      });\n    }\n\n    // Validate code format (6 digits)\n    const codeStr = String(code).trim();\n    if (!/^\\d{6}$/.test(codeStr)) {\n      return res.status(400).json({\n        error: 'Invalid code format',\n        message: 'Verification code must be 6 digits'\n      });\n    }\n\n    try {\n      // Verify the code (async - Redis backed)\n      const result = await verifyCode(email, codeStr);\n\n      if (!result.valid) {\n        return res.status(400).json({\n          success: false,\n          verified: false,\n          error: 'Verification failed',\n          message: result.error\n        });\n      }\n\n      // Mark email as verified in the database\n      if (usageTracking && usageTracking.markEmailVerified) {\n        const dbResult = await usageTracking.markEmailVerified(email);\n        if (!dbResult.success) {\n          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n        }\n      }\n\n      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n\n      // Email verified successfully\n      res.json({\n        success: true,\n        verified: true,\n        message: 'Email verified successfully'\n      });\n    } catch (err) {\n      console.error('[Auth] Verify email error:', err.message);\n      res.status(500).json({\n        error: 'Verification failed',\n        message: 'Please try again later'\n      });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createAuthRoutes;\n","numLines":633,"startLine":1,"totalLines":633}}}
{"parentUuid":"bcdf9dea-cad3-4eab-9ed9-617e92d733c5","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ezb9833YNACTEaC4Cuj2zN","type":"tool_result","content":"     1→/**\n     2→ * Billing Routes\n     3→ *\n     4→ * Credits and usage history endpoints\n     5→ */\n     6→\n     7→const express = require('express');\n     8→\n     9→/**\n    10→ * Create billing routes\n    11→ * @param {Object} options - Route configuration options\n    12→ * @param {Object} options.services - Shared services (usageTracking)\n    13→ * @param {Object} options.authHelpers - Auth helper functions (verifyToken)\n    14→ * @returns {express.Router}\n    15→ */\n    16→function createBillingRoutes(options = {}) {\n    17→  const router = express.Router();\n    18→  const { usageTracking } = options.services || {};\n    19→  const { verifyToken } = options.authHelpers || {};\n    20→\n    21→  /**\n    22→   * GET /credits - Get user's credit balance\n    23→   *\n    24→   * Supports both JWT (Authorization: Bearer) and legacy x-stripe-customer-id header\n    25→   */\n    26→  router.get('/credits', async (req, res) => {\n    27→    // Support both JWT and legacy auth\n    28→    let stripeCustomerId = null;\n    29→\n    30→    // Try JWT first\n    31→    const authHeader = req.headers['authorization'];\n    32→    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n    33→      const token = authHeader.slice(7);\n    34→      const decoded = await verifyToken(token);\n    35→      if (decoded && decoded.sub) {\n    36→        stripeCustomerId = decoded.sub;\n    37→      }\n    38→    }\n    39→\n    40→    // Fallback to legacy header\n    41→    if (!stripeCustomerId) {\n    42→      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    43→    }\n    44→\n    45→    if (!stripeCustomerId) {\n    46→      return res.status(401).json({\n    47→        error: 'Authentication required',\n    48→        message: 'Please provide a valid Bearer token or log in again'\n    49→      });\n    50→    }\n    51→\n    52→    try {\n    53→      const balance = await usageTracking.getBalance(stripeCustomerId);\n    54→      res.json({\n    55→        success: true,\n    56→        ...balance\n    57→      });\n    58→    } catch (err) {\n    59→      console.error('[SPLICE] Credits error:', err);\n    60→      res.status(500).json({ error: err.message });\n    61→    }\n    62→  });\n    63→\n    64→  /**\n    65→   * GET /usage-history - Get user's usage history\n    66→   */\n    67→  router.get('/usage-history', async (req, res) => {\n    68→    // Support both JWT and legacy auth\n    69→    let stripeCustomerId = null;\n    70→\n    71→    const authHeader = req.headers['authorization'];\n    72→    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n    73→      const token = authHeader.slice(7);\n    74→      const decoded = await verifyToken(token);\n    75→      if (decoded && decoded.sub) {\n    76→        stripeCustomerId = decoded.sub;\n    77→      }\n    78→    }\n    79→\n    80→    if (!stripeCustomerId) {\n    81→      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    82→    }\n    83→\n    84→    if (!stripeCustomerId) {\n    85→      return res.status(401).json({\n    86→        error: 'Authentication required',\n    87→        message: 'Please provide a valid Bearer token or log in again'\n    88→      });\n    89→    }\n    90→\n    91→    try {\n    92→      const history = await usageTracking.getUsageHistory(stripeCustomerId);\n    93→      res.json({\n    94→        success: true,\n    95→        history\n    96→      });\n    97→    } catch (err) {\n    98→      console.error('[SPLICE] Usage history error:', err);\n    99→      res.status(500).json({ error: err.message });\n   100→    }\n   101→  });\n   102→\n   103→  return router;\n   104→}\n   105→\n   106→module.exports = createBillingRoutes;\n   107→\n\n</system-reminder>\n"}]},"uuid":"b1d45fdd-5ca1-4740-89ed-a0f5a7086a9d","timestamp":"2026-01-11T23:55:46.870Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/billing.js","content":"/**\n * Billing Routes\n *\n * Credits and usage history endpoints\n */\n\nconst express = require('express');\n\n/**\n * Create billing routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.services - Shared services (usageTracking)\n * @param {Object} options.authHelpers - Auth helper functions (verifyToken)\n * @returns {express.Router}\n */\nfunction createBillingRoutes(options = {}) {\n  const router = express.Router();\n  const { usageTracking } = options.services || {};\n  const { verifyToken } = options.authHelpers || {};\n\n  /**\n   * GET /credits - Get user's credit balance\n   *\n   * Supports both JWT (Authorization: Bearer) and legacy x-stripe-customer-id header\n   */\n  router.get('/credits', async (req, res) => {\n    // Support both JWT and legacy auth\n    let stripeCustomerId = null;\n\n    // Try JWT first\n    const authHeader = req.headers['authorization'];\n    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n      const token = authHeader.slice(7);\n      const decoded = await verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n      }\n    }\n\n    // Fallback to legacy header\n    if (!stripeCustomerId) {\n      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please provide a valid Bearer token or log in again'\n      });\n    }\n\n    try {\n      const balance = await usageTracking.getBalance(stripeCustomerId);\n      res.json({\n        success: true,\n        ...balance\n      });\n    } catch (err) {\n      console.error('[SPLICE] Credits error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * GET /usage-history - Get user's usage history\n   */\n  router.get('/usage-history', async (req, res) => {\n    // Support both JWT and legacy auth\n    let stripeCustomerId = null;\n\n    const authHeader = req.headers['authorization'];\n    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n      const token = authHeader.slice(7);\n      const decoded = await verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n      }\n    }\n\n    if (!stripeCustomerId) {\n      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please provide a valid Bearer token or log in again'\n      });\n    }\n\n    try {\n      const history = await usageTracking.getUsageHistory(stripeCustomerId);\n      res.json({\n        success: true,\n        history\n      });\n    } catch (err) {\n      console.error('[SPLICE] Usage history error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createBillingRoutes;\n","numLines":107,"startLine":1,"totalLines":107}}}
{"parentUuid":"b1d45fdd-5ca1-4740-89ed-a0f5a7086a9d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CNeDwqCkWk1sm5ksDhdU6c","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Panel - Main Entry Point\n     3→ * v4.0.0 - CEP Migration\n     4→ */\n     5→\n     6→// ============================================================================\n     7→// CACHED DOM ELEMENTS\n     8→// ============================================================================\n     9→const ui = {};\n    10→\n    11→function cacheUIElements() {\n    12→    ui.status = document.getElementById('status');\n    13→    ui.goBtn = document.getElementById('goBtn');\n    14→    ui.optionsToggle = document.getElementById('optionsToggle');\n    15→    ui.optionsPanel = document.getElementById('optionsPanel');\n    16→\n    17→    // Sliders and options\n    18→    ui.sensitivitySlider = document.getElementById('sensitivitySlider');\n    19→    ui.sensitivityValue = document.getElementById('sensitivityValue');\n    20→    ui.sourceOriginal = document.getElementById('sourceOriginal');\n    21→    ui.sourceIsolated = document.getElementById('sourceIsolated');\n    22→\n    23→    // Feature toggles\n    24→    ui.enableTakesDetection = document.getElementById('enableTakesDetection');\n    25→    ui.enableJCut = document.getElementById('enableJCut');\n    26→    ui.jcutSettings = document.getElementById('jcutSettings');\n    27→    ui.jcutLeadIn = document.getElementById('jcutLeadIn');\n    28→    ui.jcutLeadInValue = document.getElementById('jcutLeadInValue');\n    29→    ui.jcutLeadOut = document.getElementById('jcutLeadOut');\n    30→    ui.jcutLeadOutValue = document.getElementById('jcutLeadOutValue');\n    31→\n    32→    // Zoom settings\n    33→    ui.enableZoom = document.getElementById('enableZoom');\n    34→    ui.zoomSettings = document.getElementById('zoomSettings');\n    35→    ui.zoomFrequency = document.getElementById('zoomFrequency');\n    36→    ui.zoomPreset = document.getElementById('zoomPreset');\n    37→    ui.zoomPlacement = document.getElementById('zoomPlacement');\n    38→\n    39→    // Chapter settings\n    40→    ui.enableChapters = document.getElementById('enableChapters');\n    41→    ui.chapterSettings = document.getElementById('chapterSettings');\n    42→    ui.maxChapters = document.getElementById('maxChapters');\n    43→    ui.minChapterLength = document.getElementById('minChapterLength');\n    44→\n    45→    // Profanity settings\n    46→    ui.enableProfanity = document.getElementById('enableProfanity');\n    47→    ui.profanitySettings = document.getElementById('profanitySettings');\n    48→\n    49→    // Filler word settings\n    50→    ui.enableFillerDetection = document.getElementById('enableFillerDetection');\n    51→    ui.fillerSettings = document.getElementById('fillerSettings');\n    52→\n    53→    // Progress\n    54→    ui.progressContainer = document.getElementById('progressContainer');\n    55→    ui.progressBar = document.getElementById('progressBar');\n    56→    ui.progressText = document.getElementById('progressText');\n    57→    ui.resultsEmpty = document.getElementById('resultsEmpty');\n    58→\n    59→    // Preview\n    60→    ui.combinedPreview = document.getElementById('combinedPreview');\n    61→    ui.previewList = document.getElementById('previewList');\n    62→    ui.silenceCount = document.getElementById('silenceCount');\n    63→    ui.takeCount = document.getElementById('takeCount');\n    64→    ui.selectedCount = document.getElementById('selectedCount');\n    65→    ui.selectAllSilences = document.getElementById('selectAllSilences');\n    66→    ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');\n    67→    ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');\n    68→    ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');\n    69→\n    70→    // Results\n    71→    ui.zoomResults = document.getElementById('zoomResults');\n    72→    ui.zoomList = document.getElementById('zoomList');\n    73→    ui.chapterResults = document.getElementById('chapterResults');\n    74→    ui.chapterList = document.getElementById('chapterList');\n    75→    ui.copyYouTubeBtn = document.getElementById('copyYouTubeBtn');\n    76→    ui.addChapterMarkersBtn = document.getElementById('addChapterMarkersBtn');\n    77→\n    78→    // Modals\n    79→    ui.settingsBtn = document.getElementById('settingsBtn');\n    80→    ui.settingsModal = document.getElementById('settingsModal');\n    81→    ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');\n    82→    ui.loginModal = document.getElementById('loginModal');\n    83→    ui.closeLoginBtn = document.getElementById('closeLoginBtn');\n    84→    ui.licenseKeyInput = document.getElementById('licenseKeyInput');\n    85→    ui.saveLoginBtn = document.getElementById('saveLoginBtn');\n    86→\n    87→    // Credit badge\n    88→    ui.creditBadge = document.getElementById('creditBadge');\n    89→\n    90→    // Preset selector\n    91→    ui.presetSelector = document.getElementById('presetSelector');\n    92→}\n    93→\n    94→// ============================================================================\n    95→// STATE MANAGEMENT\n    96→// ============================================================================\n    97→let previewSilences = [];\n    98→let previewTakes = [];\n    99→let currentChapters = [];\n   100→let currentZooms = [];\n   101→let currentProfanity = [];\n   102→let selectedSilenceIndices = new Set();\n   103→let isOperationInProgress = false;\n   104→let lastDetectionResult = null;\n   105→let currentAudioPath = null;\n   106→let currentSequenceInfo = null;\n   107→let currentTranscript = null;\n   108→\n   109→// Global state for captions/reframe modules\n   110→window.spliceState = {\n   111→    lastTranscript: null,\n   112→    currentVideoPath: null,\n   113→    activeSequence: null,\n   114→    audioPath: null\n   115→};\n   116→\n   117→// Also expose transcript globally for music module\n   118→window.currentTranscript = null;\n   119→\n   120→// ============================================================================\n   121→// INITIALIZATION\n   122→// ============================================================================\n   123→document.addEventListener('DOMContentLoaded', async () => {\n   124→    // Premium Loading Experience\n   125→    setTimeout(() => {\n   126→        const loader = document.getElementById('loading-overlay');\n   127→        if (loader) loader.classList.add('hidden');\n   128→    }, 800); // Small delay for smooth perception\n   129→    debugLog('Initializing CEP panel...');\n   130→\n   131→    // Debug: Show init started\n   132→    const statusEl = document.getElementById('status');\n   133→    if (statusEl) statusEl.textContent = 'Initializing...';\n   134→\n   135→    // Cache DOM elements\n   136→    cacheUIElements();\n   137→\n   138→    // Load settings\n   139→    loadSettingsToUI();\n   140→\n   141→    // Initialize UI handlers\n   142→    initOptionsToggle();\n   143→    initSliders();\n   144→    initFeatureToggles();\n   145→    initPresetSelector();\n   146→    initGoButton();\n   147→    initPreviewHandlers();\n   148→    initModals();\n   149→    initLoginModal();\n   150→    initCredits();\n   151→    initHelpButton();\n   152→\n   153→    // Initialize offline detection\n   154→    if (typeof initOfflineDetection === 'function') {\n   155→        initOfflineDetection();\n   156→    }\n   157→\n   158→    // Initialize multitrack UI\n   159→    if (typeof initMultitrackUI === 'function') {\n   160→        initMultitrackUI();\n   161→    }\n   162→\n   163→    // Initialize animated captions UI\n   164→    if (typeof initAnimatedCaptions === 'function') {\n   165→        initAnimatedCaptions();\n   166→    }\n   167→\n   168→    // Initialize text editor UI\n   169→    if (typeof initTextEditor === 'function') {\n   170→        initTextEditor();\n   171→    }\n   172→\n   173→    // Initialize text editor section toggle\n   174→    initTextEditorToggle();\n   175→\n   176→    // Initialize social reframe UI\n   177→    if (typeof initSocialReframe === 'function') {\n   178→        initSocialReframe();\n   179→    }\n   180→\n   181→    // Initialize social reframe section toggle\n   182→    initSocialReframeToggle();\n   183→\n   184→    // Initialize music UI\n   185→    if (typeof initMusicModule === 'function') {\n   186→        initMusicModule();\n   187→    }\n   188→\n   189→    // Initialize music section toggle\n   190→    initMusicToggle();\n   191→\n   192→    // Initialize JSX bridge first, then check connection\n   193→    // This ensures jsx.init() completes before checkJSXConnection() uses it\n   194→    await jsx.init();\n   195→    await checkJSXConnection();\n   196→\n   197→    // Initialize sequence event listeners for real-time state updates\n   198→    initSequenceEventListeners();\n   199→\n   200→    setStatus('Ready');\n   201→    debugLog('CEP panel initialized');\n   202→});\n   203→\n   204→// ============================================================================\n   205→// SEQUENCE EVENT LISTENERS\n   206→// ============================================================================\n   207→/**\n   208→ * Initialize event listeners for sequence state changes\n   209→ * This provides real-time updates when sequences are activated/deactivated\n   210→ */\n   211→function initSequenceEventListeners() {\n   212→    if (!jsx.cs) {\n   213→        console.warn('[SPLICE] Cannot init sequence listeners - CSInterface not available');\n   214→        return;\n   215→    }\n   216→\n   217→    try {\n   218→        // Listen for sequence activation events\n   219→        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceActivated', async (event) => {\n   220→            debugLog('Sequence activated event received');\n   221→            try {\n   222→                const seqInfo = await jsx.call('getActiveSequence');\n   223→                if (seqInfo && !seqInfo.error) {\n   224→                    window.spliceState.activeSequence = seqInfo;\n   225→                    setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));\n   226→                    debugLog('Active sequence updated:', seqInfo.name);\n   227→                }\n   228→            } catch (e) {\n   229→                console.warn('[SPLICE] Failed to get sequence info on activation:', e.message);\n   230→            }\n   231→        });\n   232→\n   233→        // Listen for sequence close/deactivation\n   234→        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceDeactivated', () => {\n   235→            debugLog('Sequence deactivated event');\n   236→            window.spliceState.activeSequence = null;\n   237→            setStatus('No sequence open', true);\n   238→        });\n   239→\n   240→        // Listen for project item selection changes (includes sequences)\n   241→        jsx.cs.addEventListener('com.adobe.csxs.events.SelectionChanged', async () => {\n   242→            // Debounce rapid selection changes\n   243→            if (window._selectionChangeTimeout) {\n   244→                clearTimeout(window._selectionChangeTimeout);\n   245→            }\n   246→            window._selectionChangeTimeout = setTimeout(async () => {\n   247→                try {\n   248→                    const hasSequence = await checkSequenceOpen(0, 0); // Quick check, no retries\n   249→                    if (hasSequence && !window.spliceState.activeSequence) {\n   250→                        const seqInfo = await jsx.call('getActiveSequence');\n   251→                        if (seqInfo && !seqInfo.error) {\n   252→                            window.spliceState.activeSequence = seqInfo;\n   253→                            debugLog('Sequence detected via selection change:', seqInfo.name);\n   254→                        }\n   255→                    }\n   256→                } catch (e) {\n   257→                    // Ignore errors during selection change - it's just for proactive updates\n   258→                }\n   259→            }, 200);\n   260→        });\n   261→\n   262→        debugLog('Sequence event listeners initialized');\n   263→    } catch (e) {\n   264→        console.error('[SPLICE] Failed to init sequence event listeners:', e.message);\n   265→    }\n   266→}\n   267→\n   268→// ============================================================================\n   269→// JSX CONNECTION CHECK\n   270→// ============================================================================\n   271→async function checkJSXConnection() {\n   272→    try {\n   273→        const result = await jsx.call('getVersion');\n   274→        debugLog('JSX connection OK, version:', result);\n   275→        return true;\n   276→    } catch (e) {\n   277→        console.warn('[SPLICE] JSX connection failed:', e.message);\n   278→        setStatus('Premiere Pro connection failed', true);\n   279→        return false;\n   280→    }\n   281→}\n   282→\n   283→/**\n   284→ * Check if a sequence is currently open in the Timeline\n   285→ * Enhanced with logging and retry logic\n   286→ * @param {number} retries - Number of retry attempts (default: 2)\n   287→ * @param {number} delayMs - Delay between retries in ms (default: 300)\n   288→ * @returns {Promise<boolean>} true if sequence is open\n   289→ */\n   290→async function checkSequenceOpen(retries = 2, delayMs = 300) {\n   291→    for (let attempt = 0; attempt <= retries; attempt++) {\n   292→        try {\n   293→            const result = await jsx.call('checkSequenceOpen');\n   294→            debugLog('checkSequenceOpen attempt', attempt + 1, 'result:', result, 'type:', typeof result);\n   295→\n   296→            if (result === true || result === 'true') {\n   297→                return true;\n   298→            }\n   299→\n   300→            // If false, wait and retry (sequence might be loading)\n   301→            if (attempt < retries) {\n   302→                debugLog('checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');\n   303→                await new Promise(r => setTimeout(r, delayMs));\n   304→            }\n   305→        } catch (error) {\n   306→            console.error('[SPLICE] checkSequenceOpen attempt', attempt + 1, 'failed:', error.message);\n   307→\n   308→            // On last attempt, return false but log the actual error\n   309→            if (attempt === retries) {\n   310→                console.error('[SPLICE] checkSequenceOpen: All attempts failed. Last error:', error.message);\n   311→                // Store error for diagnostics\n   312→                window.spliceState.lastSequenceCheckError = error.message;\n   313→                return false;\n   314→            }\n   315→\n   316→            // Wait before retry\n   317→            await new Promise(r => setTimeout(r, delayMs));\n   318→        }\n   319→    }\n   320→    return false;\n   321→}\n   322→\n   323→// ============================================================================\n   324→// OPTIONS TOGGLE\n   325→// ============================================================================\n   326→function initOptionsToggle() {\n   327→    debugLog('initOptionsToggle - toggle:', !!ui.optionsToggle, 'panel:', !!ui.optionsPanel);\n   328→    if (ui.optionsToggle && ui.optionsPanel) {\n   329→        ui.optionsToggle.addEventListener('click', () => {\n   330→            debugLog('Options toggle clicked');\n   331→            // Check current state BEFORE toggling\n   332→            const wasCollapsed = ui.optionsPanel.classList.contains('collapsed');\n   333→            ui.optionsPanel.classList.toggle('collapsed');\n   334→            // If it was collapsed, it's now expanded (show 'expanded' class)\n   335→            ui.optionsToggle.classList.toggle('expanded', wasCollapsed);\n   336→            saveSettings({ expandedOptions: wasCollapsed });\n   337→        });\n   338→\n   339→        // Restore state\n   340→        const settings = getSettings();\n   341→        if (!settings.expandedOptions) {\n   342→            ui.optionsPanel.classList.add('collapsed');\n   343→            ui.optionsToggle.classList.remove('expanded');\n   344→        } else {\n   345→            ui.optionsToggle.classList.add('expanded');\n   346→            ui.optionsPanel.classList.remove('collapsed');\n   347→        }\n   348→    }\n   349→}\n   350→\n   351→// ============================================================================\n   352→// TEXT EDITOR TOGGLE\n   353→// ============================================================================\n   354→function initTextEditorToggle() {\n   355→    const toggle = document.getElementById('textEditorToggle');\n   356→    const panel = document.getElementById('text-editor-panel');\n   357→    debugLog('initTextEditorToggle - toggle:', !!toggle, 'panel:', !!panel);\n   358→\n   359→    if (toggle && panel) {\n   360→        toggle.addEventListener('click', (e) => {\n   361→            e.preventDefault();\n   362→            e.stopPropagation();\n   363→            debugLog('Text Editor toggle clicked');\n   364→            setStatus('Text Editor: ' + (panel.classList.contains('collapsed') ? 'Opening' : 'Closing'));\n   365→            // Check state BEFORE toggling\n   366→            const wasCollapsed = panel.classList.contains('collapsed');\n   367→            panel.classList.toggle('collapsed');\n   368→            const icon = toggle.querySelector('.toggle-icon');\n   369→            debugLog('wasCollapsed:', wasCollapsed, 'icon:', !!icon);\n   370→            if (icon) {\n   371→                // If it was collapsed, it's now expanded (show -)\n   372→                icon.textContent = wasCollapsed ? '-' : '+';\n   373→            }\n   374→        });\n   375→    } else {\n   376→        console.error('[SPLICE] Text Editor toggle elements not found!');\n   377→    }\n   378→}\n   379→\n   380→// ============================================================================\n   381→// SOCIAL REFRAME TOGGLE\n   382→// ============================================================================\n   383→function initSocialReframeToggle() {\n   384→    const toggle = document.getElementById('socialReframeToggle');\n   385→    const panel = document.getElementById('social-reframe-panel');\n   386→    debugLog('initSocialReframeToggle - toggle:', !!toggle, 'panel:', !!panel);\n   387→\n   388→    if (toggle && panel) {\n   389→        toggle.addEventListener('click', () => {\n   390→            debugLog('Social Reframe toggle clicked');\n   391→            // Check state BEFORE toggling\n   392→            const wasCollapsed = panel.classList.contains('collapsed');\n   393→            panel.classList.toggle('collapsed');\n   394→            const icon = toggle.querySelector('.toggle-icon');\n   395→            if (icon) {\n   396→                // If it was collapsed, it's now expanded (show -)\n   397→                icon.textContent = wasCollapsed ? '-' : '+';\n   398→            }\n   399→        });\n   400→    } else {\n   401→        console.error('[SPLICE] Social Reframe toggle elements not found!');\n   402→    }\n   403→}\n   404→\n   405→// ============================================================================\n   406→// MUSIC TOGGLE\n   407→// ============================================================================\n   408→function initMusicToggle() {\n   409→    const toggle = document.getElementById('musicToggle');\n   410→    const panel = document.getElementById('music-panel');\n   411→    debugLog('initMusicToggle - toggle:', !!toggle, 'panel:', !!panel);\n   412→\n   413→    if (toggle && panel) {\n   414→        toggle.addEventListener('click', () => {\n   415→            debugLog('Music toggle clicked');\n   416→            // Check state BEFORE toggling\n   417→            const wasCollapsed = panel.classList.contains('collapsed');\n   418→            panel.classList.toggle('collapsed');\n   419→            const icon = toggle.querySelector('.toggle-icon');\n   420→            if (icon) {\n   421→                // If it was collapsed, it's now expanded (show -)\n   422→                icon.textContent = wasCollapsed ? '-' : '+';\n   423→            }\n   424→        });\n   425→    } else {\n   426→        console.error('[SPLICE] Music toggle elements not found!');\n   427→    }\n   428→}\n   429→\n   430→// ============================================================================\n   431→// SLIDERS\n   432→// ============================================================================\n   433→function initSliders() {\n   434→    // Sensitivity slider\n   435→    if (ui.sensitivitySlider && ui.sensitivityValue) {\n   436→        ui.sensitivitySlider.addEventListener('input', () => {\n   437→            ui.sensitivityValue.textContent = ui.sensitivitySlider.value;\n   438→            saveSettings({ sensitivity: parseInt(ui.sensitivitySlider.value) });\n   439→        });\n   440→    }\n   441→\n   442→    // J-Cut sliders\n   443→    if (ui.jcutLeadIn && ui.jcutLeadInValue) {\n   444→        ui.jcutLeadIn.addEventListener('input', () => {\n   445→            const val = (ui.jcutLeadIn.value / 100).toFixed(2);\n   446→            ui.jcutLeadInValue.textContent = val + 's';\n   447→            saveSettings({ jcutLeadIn: parseFloat(val) });\n   448→        });\n   449→    }\n   450→\n   451→    if (ui.jcutLeadOut && ui.jcutLeadOutValue) {\n   452→        ui.jcutLeadOut.addEventListener('input', () => {\n   453→            const val = (ui.jcutLeadOut.value / 100).toFixed(2);\n   454→            ui.jcutLeadOutValue.textContent = val + 's';\n   455→            saveSettings({ jcutLeadOut: parseFloat(val) });\n   456→        });\n   457→    }\n   458→}\n   459→\n   460→// ============================================================================\n   461→// FEATURE TOGGLES\n   462→// ============================================================================\n   463→function initFeatureToggles() {\n   464→    // J-Cut toggle\n   465→    if (ui.enableJCut && ui.jcutSettings) {\n   466→        ui.enableJCut.addEventListener('change', () => {\n   467→            ui.jcutSettings.classList.toggle('collapsed', !ui.enableJCut.checked);\n   468→            saveSettings({ enableJCut: ui.enableJCut.checked });\n   469→        });\n   470→    }\n   471→\n   472→    // Zoom toggle\n   473→    if (ui.enableZoom && ui.zoomSettings) {\n   474→        ui.enableZoom.addEventListener('change', () => {\n   475→            ui.zoomSettings.classList.toggle('collapsed', !ui.enableZoom.checked);\n   476→            saveSettings({ enableZoom: ui.enableZoom.checked });\n   477→        });\n   478→    }\n   479→\n   480→    // Chapters toggle\n   481→    if (ui.enableChapters && ui.chapterSettings) {\n   482→        ui.enableChapters.addEventListener('change', () => {\n   483→            ui.chapterSettings.classList.toggle('collapsed', !ui.enableChapters.checked);\n   484→            saveSettings({ enableChapters: ui.enableChapters.checked });\n   485→        });\n   486→    }\n   487→\n   488→    // Takes detection toggle\n   489→    if (ui.enableTakesDetection) {\n   490→        ui.enableTakesDetection.addEventListener('change', () => {\n   491→            saveSettings({ enableTakesDetection: ui.enableTakesDetection.checked });\n   492→        });\n   493→    }\n   494→\n   495→    // Profanity detection toggle\n   496→    if (ui.enableProfanity && ui.profanitySettings) {\n   497→        ui.enableProfanity.addEventListener('change', () => {\n   498→            ui.profanitySettings.classList.toggle('collapsed', !ui.enableProfanity.checked);\n   499→            saveSettings({ enableProfanity: ui.enableProfanity.checked });\n   500→        });\n   501→    }\n   502→\n   503→    // Filler word detection toggle\n   504→    if (ui.enableFillerDetection && ui.fillerSettings) {\n   505→        ui.enableFillerDetection.addEventListener('change', () => {\n   506→            ui.fillerSettings.classList.toggle('collapsed', !ui.enableFillerDetection.checked);\n   507→            saveSettings({ enableFillerDetection: ui.enableFillerDetection.checked });\n   508→        });\n   509→    }\n   510→}\n   511→\n   512→// ============================================================================\n   513→// PRESET SELECTOR\n   514→// ============================================================================\n   515→// PRESETS is defined in config.js\n   516→\n   517→function initPresetSelector() {\n   518→    if (!ui.presetSelector) return;\n   519→\n   520→    ui.presetSelector.addEventListener('change', () => {\n   521→        const presetId = ui.presetSelector.value;\n   522→        applyPreset(presetId);\n   523→    });\n   524→\n   525→    // Load current preset\n   526→    const settings = getSettings();\n   527→    if (settings.activePreset) {\n   528→        ui.presetSelector.value = settings.activePreset;\n   529→    }\n   530→}\n   531→\n   532→function applyPreset(presetId) {\n   533→    const preset = PRESETS[presetId];\n   534→    if (!preset) return;\n   535→\n   536→    // Custom preset - keep current settings\n   537→    if (presetId === 'custom' || !preset.settings) {\n   538→        saveSettings({ activePreset: 'custom' });\n   539→        setStatus('Using custom settings');\n   540→        return;\n   541→    }\n   542→\n   543→    const settings = preset.settings;\n   544→\n   545→    // Apply to UI\n   546→    if (ui.sensitivitySlider && settings.sensitivity !== undefined) {\n   547→        ui.sensitivitySlider.value = settings.sensitivity;\n   548→        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n   549→    }\n   550→\n   551→    if (ui.enableJCut) {\n   552→        ui.enableJCut.checked = settings.enableJCut || false;\n   553→        if (ui.jcutSettings) {\n   554→            ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n   555→        }\n   556→    }\n   557→\n   558→    if (settings.jCutLeadIn !== undefined && ui.jcutLeadIn) {\n   559→        ui.jcutLeadIn.value = Math.round(settings.jCutLeadIn * 100);\n   560→        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jCutLeadIn + 's';\n   561→    }\n   562→\n   563→    if (settings.jCutLeadOut !== undefined && ui.jcutLeadOut) {\n   564→        ui.jcutLeadOut.value = Math.round(settings.jCutLeadOut * 100);\n   565→        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jCutLeadOut + 's';\n   566→    }\n   567→\n   568→    // Save merged settings\n   569→    saveSettings({\n   570→        activePreset: presetId,\n   571→        sensitivity: settings.sensitivity,\n   572→        threshold: settings.threshold,\n   573→        minSilenceLength: settings.minSilenceLength,\n   574→        paddingStart: settings.paddingStart,\n   575→        paddingEnd: settings.paddingEnd,\n   576→        enableTakesDetection: settings.enableTakesDetection,\n   577→        enableJCut: settings.enableJCut || false,\n   578→        jcutLeadIn: settings.jCutLeadIn || 0.3,\n   579→        jcutLeadOut: settings.jCutLeadOut || 0.2\n   580→    });\n   581→\n   582→    setStatus(`Applied ${preset.name} preset`);\n   583→}\n   584→\n   585→// ============================================================================\n   586→// LOAD SETTINGS TO UI\n   587→// ============================================================================\n   588→function loadSettingsToUI() {\n   589→    const settings = getSettings();\n   590→\n   591→    if (ui.sensitivitySlider) {\n   592→        ui.sensitivitySlider.value = settings.sensitivity;\n   593→        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n   594→    }\n   595→\n   596→    if (ui.enableTakesDetection) ui.enableTakesDetection.checked = settings.enableTakesDetection;\n   597→    if (ui.enableJCut) ui.enableJCut.checked = settings.enableJCut;\n   598→    if (ui.enableZoom) ui.enableZoom.checked = settings.enableZoom;\n   599→    if (ui.enableChapters) ui.enableChapters.checked = settings.enableChapters;\n   600→\n   601→    if (ui.jcutSettings) ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n   602→    if (ui.zoomSettings) ui.zoomSettings.classList.toggle('collapsed', !settings.enableZoom);\n   603→    if (ui.chapterSettings) ui.chapterSettings.classList.toggle('collapsed', !settings.enableChapters);\n   604→\n   605→    if (ui.jcutLeadIn) {\n   606→        ui.jcutLeadIn.value = Math.round(settings.jcutLeadIn * 100);\n   607→        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jcutLeadIn + 's';\n   608→    }\n   609→    if (ui.jcutLeadOut) {\n   610→        ui.jcutLeadOut.value = Math.round(settings.jcutLeadOut * 100);\n   611→        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jcutLeadOut + 's';\n   612→    }\n   613→\n   614→    if (ui.presetSelector && settings.activePreset) {\n   615→        ui.presetSelector.value = settings.activePreset;\n   616→    }\n   617→}\n   618→\n   619→// ============================================================================\n   620→// GO BUTTON - MAIN WORKFLOW\n   621→// ============================================================================\n   622→function initGoButton() {\n   623→    if (!ui.goBtn) return;\n   624→\n   625→    ui.goBtn.addEventListener('click', async () => {\n   626→        if (isOperationInProgress) return;\n   627→        await runDetection();\n   628→    });\n   629→}\n   630→\n   631→async function runDetection() {\n   632→    if (isOperationInProgress) return;\n   633→\n   634→    // Check sequence with enhanced error messaging\n   635→    const hasSequence = await checkSequenceOpen();\n   636→    if (!hasSequence) {\n   637→        // Check if there was a communication error vs just no sequence\n   638→        const lastError = window.spliceState.lastSequenceCheckError;\n   639→        if (lastError && (lastError.includes('CEP') || lastError.includes('communication') || lastError.includes('evalScript'))) {\n   640→            setStatus('Premiere Pro connection issue - try reopening panel', true);\n   641→            console.error('[SPLICE] runDetection: JSX communication failure:', lastError);\n   642→        } else {\n   643→            setStatus('Please open a sequence in the Timeline first', true);\n   644→            debugLog('runDetection: No active sequence in Timeline');\n   645→        }\n   646→        // Clear the error for next check\n   647→        window.spliceState.lastSequenceCheckError = null;\n   648→        return;\n   649→    }\n   650→\n   651→    // Check online\n   652→    if (!isOnline()) {\n   653→        setStatus('Offline - Check your connection', true);\n   654→        return;\n   655→    }\n   656→\n   657→    isOperationInProgress = true;\n   658→    ui.goBtn.disabled = true;\n   659→    showProgress('Detecting silences...');\n   660→\n   661→    try {\n   662→        const settings = getSettings();\n   663→\n   664→        // Get sequence info\n   665→        const seqInfo = await jsx.call('getActiveSequence');\n   666→        debugLog('Sequence info:', seqInfo);\n   667→\n   668→        // Store sequence info for later use\n   669→        currentSequenceInfo = seqInfo;\n   670→        window.spliceState.activeSequence = seqInfo;\n   671→        if (seqInfo && seqInfo.videoPath) {\n   672→            window.spliceState.currentVideoPath = seqInfo.videoPath;\n   673→        }\n   674→\n   675→        // Export audio via JSX for silence detection\n   676→        updateProgress(10, 'Exporting audio...');\n   677→\n   678→        let audioFilePath = null;\n   679→        try {\n   680→            // Get sequence info for audio export\n   681→            const exportResult = await jsx.call('exportSequenceAudioForAnalysis');\n   682→            if (exportResult && exportResult.success && exportResult.outputPath) {\n   683→                audioFilePath = exportResult.outputPath;\n   684→                debugLog('Audio exported to:', audioFilePath);\n   685→            } else if (exportResult && exportResult.error) {\n   686→                throw new Error(exportResult.error);\n   687→            }\n   688→        } catch (exportError) {\n   689→            console.warn('[SPLICE] Audio export failed, trying fallback:', exportError.message);\n   690→            // Try to get audio from first clip in timeline\n   691→            try {\n   692→                const clipInfo = await jsx.call('getFirstClipAudioPath');\n   693→                if (clipInfo && clipInfo.path) {\n   694→                    audioFilePath = clipInfo.path;\n   695→                    debugLog('Using clip audio path:', audioFilePath);\n   696→                }\n   697→            } catch (clipError) {\n   698→                console.warn('[SPLICE] Fallback audio path failed:', clipError.message);\n   699→            }\n   700→        }\n   701→\n   702→        if (!audioFilePath) {\n   703→            throw new Error('Could not export or locate audio file. Please ensure sequence has audio tracks.');\n   704→        }\n   705→\n   706→        // Store audio path globally for other modules\n   707→        currentAudioPath = audioFilePath;\n   708→        window.spliceState.audioPath = audioFilePath;\n   709→\n   710→        // Call backend for silence detection with audio file path\n   711→        updateProgress(30, 'Detecting silences...');\n   712→        const silenceResponse = await fetchWithTimeout(\n   713→            `${getBackendUrl()}/silences-rms`,\n   714→            {\n   715→                method: 'POST',\n   716→                headers: getAuthHeaders(),\n   717→                body: JSON.stringify({\n   718→                    wavPath: audioFilePath,\n   719→                    sensitivity: settings.sensitivity,\n   720→                    minSilenceLength: settings.minSilenceLength || 0.5\n   721→                })\n   722→            }\n   723→        );\n   724→\n   725→        if (!silenceResponse.ok) {\n   726→            throw new Error(await parseErrorResponse(silenceResponse));\n   727→        }\n   728→\n   729→        const silenceData = await silenceResponse.json();\n   730→        previewSilences = silenceData.silences || [];\n   731→\n   732→        // Detect takes if enabled\n   733→        if (settings.enableTakesDetection) {\n   734→            updateProgress(60, 'Detecting takes...');\n   735→            try {\n   736→                const analyzeResponse = await fetchWithTimeout(\n   737→                    `${getBackendUrl()}/analyze`,\n   738→                    {\n   739→                        method: 'POST',\n   740→                        headers: getAuthHeaders(),\n   741→                        body: JSON.stringify({\n   742→                            wavPath: audioFilePath,\n   743→                            detectTakes: true\n   744→                        })\n   745→                    }\n   746→                );\n   747→\n   748→                if (analyzeResponse.ok) {\n   749→                    const analyzeData = await analyzeResponse.json();\n   750→                    previewTakes = analyzeData.takes || [];\n   751→\n   752→                    // Store transcript for captions/music modules\n   753→                    if (analyzeData.transcript) {\n   754→                        currentTranscript = analyzeData.transcript;\n   755→                        window.currentTranscript = analyzeData.transcript;\n   756→                        window.spliceState.lastTranscript = analyzeData.transcript;\n   757→                    }\n   758→                } else {\n   759→                    // Handle specific error codes\n   760→                    const errorMsg = await parseErrorResponse(analyzeResponse);\n   761→                    if (analyzeResponse.status === 402) {\n   762→                        console.warn('[SPLICE] Takes detection skipped: insufficient credits');\n   763→                        setStatus('Takes detection skipped: insufficient credits', true);\n   764→                    } else if (analyzeResponse.status === 401) {\n   765→                        console.warn('[SPLICE] Takes detection skipped: authentication required');\n   766→                    } else {\n   767→                        console.warn('[SPLICE] Takes detection failed:', errorMsg);\n   768→                    }\n   769→                }\n   770→            } catch (e) {\n   771→                console.warn('[SPLICE] Takes detection failed:', e.message);\n   772→            }\n   773→        }\n   774→\n   775→        // Detect profanity if enabled\n   776→        if (settings.enableProfanity) {\n   777→            updateProgress(65, 'Detecting profanity...');\n   778→            try {\n   779→                const profanityResponse = await fetchWithTimeout(\n   780→                    `${getBackendUrl()}/profanity`,\n   781→                    {\n   782→                        method: 'POST',\n   783→                        headers: getAuthHeaders(),\n   784→                        body: JSON.stringify({\n   785→                            wavPath: audioFilePath,\n   786→                            language: settings.profanityLanguage || 'en',\n   787→                            bleepType: settings.bleepType || 'standard'\n   788→                        })\n   789→                    }\n   790→                );\n   791→\n   792→                if (profanityResponse.ok) {\n   793→                    const profanityData = await profanityResponse.json();\n   794→                    currentProfanity = profanityData.instances || [];\n   795→                    if (currentProfanity.length > 0) {\n   796→                        debugLog(`Found ${currentProfanity.length} profanity instances`);\n   797→                    }\n   798→                } else {\n   799→                    console.warn('[SPLICE] Profanity detection failed:', await parseErrorResponse(profanityResponse));\n   800→                }\n   801→            } catch (e) {\n   802→                console.warn('[SPLICE] Profanity detection failed:', e.message);\n   803→            }\n   804→        }\n   805→\n   806→        // Detect chapters if enabled\n   807→        if (settings.enableChapters) {\n   808→            updateProgress(80, 'Detecting chapters...');\n   809→            try {\n   810→                const chapterResponse = await fetchWithTimeout(\n   811→                    `${getBackendUrl()}/chapters`,\n   812→                    {\n   813→                        method: 'POST',\n   814→                        headers: getAuthHeaders(),\n   815→                        body: JSON.stringify({\n   816→                            wavPath: audioFilePath,\n   817→                            transcript: currentTranscript,\n   818→                            maxChapters: settings.maxChapters || 10,\n   819→                            minChapterLength: settings.minChapterLength || 60\n   820→                        })\n   821→                    }\n   822→                );\n   823→\n   824→                if (chapterResponse.ok) {\n   825→                    const chapterData = await chapterResponse.json();\n   826→                    currentChapters = chapterData.chapters || [];\n   827→                } else {\n   828→                    const errorMsg = await parseErrorResponse(chapterResponse);\n   829→                    console.warn('[SPLICE] Chapter detection failed:', errorMsg);\n   830→                    // Don't block workflow, just notify user\n   831→                    setStatus('Chapter detection skipped: ' + errorMsg, true);\n   832→                }\n   833→            } catch (e) {\n   834→                console.warn('[SPLICE] Chapter detection failed:', e);\n   835→                setStatus('Chapter detection failed - continuing without chapters', true);\n   836→            }\n   837→        }\n   838→\n   839→        // Detect zoom points if enabled\n   840→        if (settings.enableZoom) {\n   841→            updateProgress(90, 'Detecting zoom points...');\n   842→            try {\n   843→                const zoomResponse = await fetchWithTimeout(\n   844→                    `${getBackendUrl()}/zoom`,\n   845→                    {\n   846→                        method: 'POST',\n   847→                        headers: getAuthHeaders(),\n   848→                        body: JSON.stringify({\n   849→                            wavPath: audioFilePath,\n   850→                            transcript: currentTranscript,\n   851→                            frequency: settings.zoomFrequency || 'medium',\n   852→                            preset: settings.zoomPreset || 'medium',\n   853→                            placement: settings.zoomPlacement || 'sentence_start'\n   854→                        })\n   855→                    }\n   856→                );\n   857→\n   858→                if (zoomResponse.ok) {\n   859→                    const zoomData = await zoomResponse.json();\n   860→                    currentZooms = zoomData.zoomPoints || [];\n   861→                } else {\n   862→                    const errorMsg = await parseErrorResponse(zoomResponse);\n   863→                    console.warn('[SPLICE] Zoom detection failed:', errorMsg);\n   864→                    setStatus('Zoom detection skipped: ' + errorMsg, true);\n   865→                }\n   866→            } catch (e) {\n   867→                console.warn('[SPLICE] Zoom detection failed:', e);\n   868→                setStatus('Zoom detection failed - continuing without zoom points', true);\n   869→            }\n   870→        }\n   871→\n   872→        // Store results\n   873→        lastDetectionResult = {\n   874→            silences: previewSilences,\n   875→            takes: previewTakes,\n   876→            chapters: currentChapters,\n   877→            zooms: currentZooms\n   878→        };\n   879→\n   880→        // Show preview\n   881→        hideProgress();\n   882→        showCombinedPreview();\n   883→        setStatus(`Found ${previewSilences.length} silences, ${previewTakes.length} takes`);\n   884→\n   885→    } catch (error) {\n   886→        console.error('[SPLICE] Detection error:', error);\n   887→        setStatus('Detection failed: ' + error.message, true);\n   888→        hideProgress();\n   889→    } finally {\n   890→        isOperationInProgress = false;\n   891→        ui.goBtn.disabled = false;\n   892→    }\n   893→}\n   894→\n   895→// ============================================================================\n   896→// PROGRESS UI\n   897→// ============================================================================\n   898→function showProgress(message) {\n   899→    if (ui.progressContainer) ui.progressContainer.classList.remove('hidden');\n   900→    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n   901→    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n   902→    updateProgress(0, message);\n   903→}\n   904→\n   905→function updateProgress(percent, message) {\n   906→    if (ui.progressBar) ui.progressBar.style.width = percent + '%';\n   907→    if (ui.progressText) ui.progressText.textContent = message || '';\n   908→}\n   909→\n   910→function hideProgress() {\n   911→    if (ui.progressContainer) ui.progressContainer.classList.add('hidden');\n   912→}\n   913→\n   914→// ============================================================================\n   915→// COMBINED PREVIEW\n   916→// ============================================================================\n   917→function showCombinedPreview() {\n   918→    if (!ui.combinedPreview) return;\n   919→\n   920→    ui.combinedPreview.classList.remove('hidden');\n   921→    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n   922→\n   923→    // Update counts\n   924→    if (ui.silenceCount) ui.silenceCount.textContent = previewSilences.length;\n   925→    if (ui.takeCount) ui.takeCount.textContent = previewTakes.length;\n   926→\n   927→    // Select all by default\n   928→    selectedSilenceIndices.clear();\n   929→    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n   930→    updateSelectedCount();\n   931→\n   932→    // Render preview list\n   933→    renderPreviewList();\n   934→\n   935→    // Show chapter results if available\n   936→    if (currentChapters.length > 0 && ui.chapterResults) {\n   937→        ui.chapterResults.classList.remove('hidden');\n   938→        renderChapterList();\n   939→    }\n   940→\n   941→    // Show zoom results if available\n   942→    if (currentZooms.length > 0 && ui.zoomResults) {\n   943→        ui.zoomResults.classList.remove('hidden');\n   944→    }\n   945→}\n   946→\n   947→function renderPreviewList() {\n   948→    if (!ui.previewList) return;\n   949→\n   950→    const html = [];\n   951→\n   952→    // Render silences\n   953→    previewSilences.forEach((silence, i) => {\n   954→        const isSelected = selectedSilenceIndices.has(i);\n   955→        const duration = silence.end - silence.start;\n   956→        html.push(`\n   957→            <div class=\"preview-item ${isSelected ? '' : 'excluded'}\" data-index=\"${i}\" data-type=\"silence\">\n   958→                <input type=\"checkbox\" class=\"preview-item-check\" ${isSelected ? 'checked' : ''}>\n   959→                <div class=\"preview-item-info\">\n   960→                    <div class=\"preview-item-time\">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>\n   961→                    <div class=\"preview-item-duration\">${duration.toFixed(2)}s silence</div>\n   962→                </div>\n   963→            </div>\n   964→        `);\n   965→    });\n   966→\n   967→    // Render takes\n   968→    previewTakes.forEach((take, i) => {\n   969→        // SECURITY: Escape take label to prevent XSS\n   970→        const safeLabel = escapeHtml(take.label || 'Take ' + (take.takeNumber || i + 1));\n   971→        html.push(`\n   972→            <div class=\"preview-item take-item\" data-index=\"${i}\" data-type=\"take\">\n   973→                <div class=\"preview-item-icon\">🎬</div>\n   974→                <div class=\"preview-item-info\">\n   975→                    <div class=\"preview-item-time\">${formatTime(take.start)} - ${formatTime(take.end)}</div>\n   976→                    <div class=\"preview-item-label\">${safeLabel}</div>\n   977→                </div>\n   978→            </div>\n   979→        `);\n   980→    });\n   981→\n   982→    ui.previewList.innerHTML = html.join('');\n   983→\n   984→    // Add click handlers\n   985→    ui.previewList.querySelectorAll('.preview-item').forEach(item => {\n   986→        item.addEventListener('click', (e) => {\n   987→            const index = parseInt(item.dataset.index);\n   988→            const type = item.dataset.type;\n   989→\n   990→            if (e.target.classList.contains('preview-item-check')) {\n   991→                // Checkbox clicked\n   992→                toggleSilenceSelection(index);\n   993→            } else {\n   994→                // Item clicked - seek to time\n   995→                const data = type === 'silence' ? previewSilences[index] : previewTakes[index];\n   996→                seekToTime(data.start);\n   997→            }\n   998→        });\n   999→    });\n  1000→}\n  1001→\n  1002→function toggleSilenceSelection(index) {\n  1003→    if (selectedSilenceIndices.has(index)) {\n  1004→        selectedSilenceIndices.delete(index);\n  1005→    } else {\n  1006→        selectedSilenceIndices.add(index);\n  1007→    }\n  1008→    updateSelectedCount();\n  1009→    renderPreviewList();\n  1010→}\n  1011→\n  1012→function updateSelectedCount() {\n  1013→    if (ui.selectedCount) {\n  1014→        ui.selectedCount.textContent = selectedSilenceIndices.size;\n  1015→    }\n  1016→    if (ui.selectAllSilences) {\n  1017→        ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length;\n  1018→    }\n  1019→}\n  1020→\n  1021→async function seekToTime(seconds) {\n  1022→    try {\n  1023→        // Check if there's an active sequence before seeking\n  1024→        if (!app?.project?.activeSequence) {\n  1025→            debugLog('No active sequence to seek in');\n  1026→            return;\n  1027→        }\n  1028→        // Use JSX to set playhead position\n  1029→        // Note: setPlayerPosition expects ticks as a string without quotes around the number value\n  1030→        const ticks = Math.round(seconds * 254016000000);\n  1031→        await jsx.evalScript(`app.project.activeSequence.setPlayerPosition(${ticks})`);\n  1032→    } catch (e) {\n  1033→        console.warn('[SPLICE] Seek failed:', e);\n  1034→    }\n  1035→}\n  1036→\n  1037→// ============================================================================\n  1038→// CHAPTER LIST\n  1039→// ============================================================================\n  1040→function renderChapterList() {\n  1041→    if (!ui.chapterList) return;\n  1042→\n  1043→    const html = currentChapters.map((chapter, i) => {\n  1044→        // SECURITY: Escape chapter title to prevent XSS\n  1045→        const safeTitle = escapeHtml(chapter.title);\n  1046→        return `\n  1047→            <div class=\"chapter-item\" data-index=\"${i}\">\n  1048→                <div class=\"chapter-time\">${formatTime(chapter.startTime)}</div>\n  1049→                <div class=\"chapter-title\">${safeTitle}</div>\n  1050→            </div>\n  1051→        `;\n  1052→    }).join('');\n  1053→\n  1054→    ui.chapterList.innerHTML = html;\n  1055→\n  1056→    // Add click handlers\n  1057→    ui.chapterList.querySelectorAll('.chapter-item').forEach(item => {\n  1058→        item.addEventListener('click', () => {\n  1059→            const index = parseInt(item.dataset.index);\n  1060→            seekToTime(currentChapters[index].startTime);\n  1061→        });\n  1062→    });\n  1063→}\n  1064→\n  1065→// ============================================================================\n  1066→// PREVIEW HANDLERS\n  1067→// ============================================================================\n  1068→function initPreviewHandlers() {\n  1069→    // Select all checkbox\n  1070→    if (ui.selectAllSilences) {\n  1071→        ui.selectAllSilences.addEventListener('change', () => {\n  1072→            if (ui.selectAllSilences.checked) {\n  1073→                previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n  1074→            } else {\n  1075→                selectedSilenceIndices.clear();\n  1076→            }\n  1077→            updateSelectedCount();\n  1078→            renderPreviewList();\n  1079→        });\n  1080→    }\n  1081→\n  1082→    // Apply button\n  1083→    if (ui.applyPreviewBtn) {\n  1084→        ui.applyPreviewBtn.addEventListener('click', applyPreviewAndMarkers);\n  1085→    }\n  1086→\n  1087→    // Cancel button\n  1088→    if (ui.cancelPreviewBtn) {\n  1089→        ui.cancelPreviewBtn.addEventListener('click', hidePreview);\n  1090→    }\n  1091→\n  1092→    // Build sequence button\n  1093→    if (ui.buildSequenceBtn) {\n  1094→        ui.buildSequenceBtn.addEventListener('click', buildSequence);\n  1095→    }\n  1096→\n  1097→    // Copy YouTube timestamps\n  1098→    if (ui.copyYouTubeBtn) {\n  1099→        ui.copyYouTubeBtn.addEventListener('click', copyYouTubeTimestamps);\n  1100→    }\n  1101→\n  1102→    // Add chapter markers\n  1103→    if (ui.addChapterMarkersBtn) {\n  1104→        ui.addChapterMarkersBtn.addEventListener('click', addChapterMarkers);\n  1105→    }\n  1106→\n  1107→    // Apply zoom markers\n  1108→    const applyZoomsBtn = document.getElementById('applyZoomsBtn');\n  1109→    if (applyZoomsBtn) {\n  1110→        applyZoomsBtn.addEventListener('click', applyZoomMarkers);\n  1111→    }\n  1112→}\n  1113→\n  1114→async function applyPreviewAndMarkers() {\n  1115→    if (isOperationInProgress) return;\n  1116→\n  1117→    isOperationInProgress = true;\n  1118→    setStatus('Adding markers...');\n  1119→\n  1120→    try {\n  1121→        // Add silence markers\n  1122→        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n  1123→        for (const silence of selectedSilences) {\n  1124→            await jsx.call('createMarker', silence.start, 'SPLICE: Silence', silence.end - silence.start, null, 1);\n  1125→        }\n  1126→\n  1127→        // Add take markers\n  1128→        for (const take of previewTakes) {\n  1129→            await jsx.call('createMarker', take.start, take.label || `Take ${take.takeNumber}`, take.end - take.start, null, 5);\n  1130→        }\n  1131→\n  1132→        setStatus(`Added ${selectedSilences.length + previewTakes.length} markers`);\n  1133→    } catch (error) {\n  1134→        setStatus('Failed to add markers: ' + error.message, true);\n  1135→    } finally {\n  1136→        isOperationInProgress = false;\n  1137→    }\n  1138→}\n  1139→\n  1140→function hidePreview() {\n  1141→    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n  1142→    if (ui.chapterResults) ui.chapterResults.classList.add('hidden');\n  1143→    if (ui.zoomResults) ui.zoomResults.classList.add('hidden');\n  1144→    if (ui.resultsEmpty) ui.resultsEmpty.classList.remove('hidden');\n  1145→    previewSilences = [];\n  1146→    previewTakes = [];\n  1147→    selectedSilenceIndices.clear();\n  1148→}\n  1149→\n  1150→async function buildSequence() {\n  1151→    if (isOperationInProgress) return;\n  1152→\n  1153→    isOperationInProgress = true;\n  1154→    setStatus('Building sequence...');\n  1155→\n  1156→    try {\n  1157→        const settings = getSettings();\n  1158→\n  1159→        // Ensure we have sequence info\n  1160→        if (!currentSequenceInfo) {\n  1161→            currentSequenceInfo = await jsx.call('getActiveSequence');\n  1162→        }\n  1163→\n  1164→        // Create cut list from selected silences\n  1165→        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n  1166→\n  1167→        // Calculate total duration from sequence info or last silence\n  1168→        let duration = 0;\n  1169→        if (currentSequenceInfo && currentSequenceInfo.duration) {\n  1170→            duration = currentSequenceInfo.duration;\n  1171→        } else if (previewSilences.length > 0) {\n  1172→            const lastSilence = previewSilences[previewSilences.length - 1];\n  1173→            duration = lastSilence.end + 10; // Add buffer\n  1174→        }\n  1175→\n  1176→        // Call backend to generate cut list\n  1177→        const cutListResponse = await fetchWithTimeout(\n  1178→            `${getBackendUrl()}/cut-list`,\n  1179→            {\n  1180→                method: 'POST',\n  1181→                headers: getAuthHeaders(),\n  1182→                body: JSON.stringify({\n  1183→                    sourceName: currentSequenceInfo?.name || 'Untitled Sequence',\n  1184→                    sourcePath: currentSequenceInfo?.treePath || currentSequenceInfo?.name || 'Untitled',\n  1185→                    duration: duration,\n  1186→                    silences: selectedSilences,\n  1187→                    takes: previewTakes,\n  1188→                    enableTakes: settings.enableTakesDetection,\n  1189→                    jCutOffset: settings.enableJCut ? settings.jcutLeadIn : 0,\n  1190→                    lCutOffset: settings.enableJCut ? settings.jcutLeadOut : 0\n  1191→                })\n  1192→            }\n  1193→        );\n  1194→\n  1195→        if (!cutListResponse.ok) {\n  1196→            throw new Error(await parseErrorResponse(cutListResponse));\n  1197→        }\n  1198→\n  1199→        const cutList = await cutListResponse.json();\n  1200→\n  1201→        // Build sequence via JSX\n  1202→        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));\n  1203→\n  1204→        if (result && result.success) {\n  1205→            setStatus(`Built sequence: ${result.sequenceName}`);\n  1206→            hidePreview();\n  1207→        } else {\n  1208→            throw new Error(result?.error || 'Build failed');\n  1209→        }\n  1210→    } catch (error) {\n  1211→        setStatus('Build failed: ' + error.message, true);\n  1212→    } finally {\n  1213→        isOperationInProgress = false;\n  1214→    }\n  1215→}\n  1216→\n  1217→function copyYouTubeTimestamps() {\n  1218→    if (currentChapters.length === 0) return;\n  1219→\n  1220→    const timestamps = currentChapters.map(ch =>\n  1221→        `${formatTime(ch.startTime)} ${ch.title}`\n  1222→    ).join('\\n');\n  1223→\n  1224→    navigator.clipboard.writeText(timestamps).then(() => {\n  1225→        setStatus('Copied YouTube timestamps');\n  1226→    }).catch(() => {\n  1227→        setStatus('Failed to copy', true);\n  1228→    });\n  1229→}\n  1230→\n  1231→async function addChapterMarkers() {\n  1232→    if (isOperationInProgress || currentChapters.length === 0) return;\n  1233→\n  1234→    isOperationInProgress = true;\n  1235→    setStatus('Adding chapter markers...');\n  1236→\n  1237→    try {\n  1238→        for (const chapter of currentChapters) {\n  1239→            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);\n  1240→        }\n  1241→        setStatus(`Added ${currentChapters.length} chapter markers`);\n  1242→    } catch (error) {\n  1243→        setStatus('Failed to add markers: ' + error.message, true);\n  1244→    } finally {\n  1245→        isOperationInProgress = false;\n  1246→    }\n  1247→}\n  1248→\n  1249→/**\n  1250→ * Apply zoom point markers to the timeline\n  1251→ */\n  1252→async function applyZoomMarkers() {\n  1253→    if (isOperationInProgress || currentZooms.length === 0) return;\n  1254→\n  1255→    isOperationInProgress = true;\n  1256→    setStatus('Adding zoom markers...');\n  1257→\n  1258→    try {\n  1259→        for (const zoom of currentZooms) {\n  1260→            // Create a marker for each zoom point with zoom intensity info\n  1261→            const comment = `Zoom ${zoom.intensity || 'medium'} - ${zoom.reason || 'emphasis'}`;\n  1262→            await jsx.call('createMarker', zoom.time, 'SPLICE: Zoom', 0.5, comment, 3);\n  1263→        }\n  1264→        setStatus(`Added ${currentZooms.length} zoom markers`);\n  1265→    } catch (error) {\n  1266→        setStatus('Failed to add zoom markers: ' + error.message, true);\n  1267→    } finally {\n  1268→        isOperationInProgress = false;\n  1269→    }\n  1270→}\n  1271→\n  1272→// ============================================================================\n  1273→// MODALS\n  1274→// ============================================================================\n  1275→function initModals() {\n  1276→    // Settings modal\n  1277→    if (ui.settingsBtn && ui.settingsModal) {\n  1278→        ui.settingsBtn.addEventListener('click', () => {\n  1279→            ui.settingsModal.classList.remove('hidden');\n  1280→            // Sync remember options checkbox with current settings\n  1281→            const rememberOptions = document.getElementById('rememberOptions');\n  1282→            if (rememberOptions) {\n  1283→                rememberOptions.checked = getSettings().rememberOptions;\n  1284→            }\n  1285→        });\n  1286→    }\n  1287→\n  1288→    if (ui.closeSettingsBtn && ui.settingsModal) {\n  1289→        ui.closeSettingsBtn.addEventListener('click', () => {\n  1290→            ui.settingsModal.classList.add('hidden');\n  1291→        });\n  1292→    }\n  1293→\n  1294→    // Remember options checkbox\n  1295→    const rememberOptions = document.getElementById('rememberOptions');\n  1296→    if (rememberOptions) {\n  1297→        rememberOptions.addEventListener('change', () => {\n  1298→            saveSettings({ rememberOptions: rememberOptions.checked });\n  1299→            if (rememberOptions.checked) {\n  1300→                setStatus('Options will be remembered');\n  1301→            } else {\n  1302→                setStatus('Options will reset to defaults');\n  1303→            }\n  1304→        });\n  1305→    }\n  1306→\n  1307→    // Credit badge click handler (handles login, retry, and refresh)\n  1308→    if (ui.creditBadge) {\n  1309→        ui.creditBadge.addEventListener('click', () => {\n  1310→            // Use the centralized handler from credits.js\n  1311→            if (typeof handleCreditBadgeClick === 'function') {\n  1312→                handleCreditBadgeClick();\n  1313→            } else {\n  1314→                // Fallback if credits.js not loaded yet\n  1315→                const settings = getSettings();\n  1316→                if (!settings.customerId) {\n  1317→                    showLoginModal();\n  1318→                }\n  1319→            }\n  1320→        });\n  1321→    }\n  1322→\n  1323→    if (ui.closeLoginBtn && ui.loginModal) {\n  1324→        ui.closeLoginBtn.addEventListener('click', () => {\n  1325→            ui.loginModal.classList.add('hidden');\n  1326→        });\n  1327→    }\n  1328→\n  1329→    // Note: saveLoginBtn handler is registered in initLoginModal() (config.js)\n  1330→    // to avoid duplicate event listeners\n  1331→\n  1332→    // License lookup button\n  1333→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n  1334→    if (lookupLicenseBtn) {\n  1335→        lookupLicenseBtn.addEventListener('click', lookupLicense);\n  1336→    }\n  1337→\n  1338→    // Close modals on backdrop click\n  1339→    document.querySelectorAll('.modal').forEach(modal => {\n  1340→        modal.addEventListener('click', (e) => {\n  1341→            if (e.target === modal) {\n  1342→                modal.classList.add('hidden');\n  1343→            }\n  1344→        });\n  1345→    });\n  1346→}\n  1347→\n  1348→function showLoginModal() {\n  1349→    if (ui.loginModal) ui.loginModal.classList.remove('hidden');\n  1350→}\n  1351→\n  1352→/**\n  1353→ * Show upgrade modal when user tries to access a gated feature\n  1354→ * @param {string} featureName - Display name of the feature\n  1355→ * @param {string} requiredTier - Required tier (Pro, Team)\n  1356→ */\n  1357→function showUpgradeModal(featureName, requiredTier = 'Pro') {\n  1358→    const modal = document.getElementById('upgradeModal');\n  1359→    const featureText = document.getElementById('upgradeFeatureName');\n  1360→    const tierText = document.getElementById('upgradeRequiredTier');\n  1361→\n  1362→    if (featureText) {\n  1363→        featureText.textContent = featureName;\n  1364→    }\n  1365→    if (tierText) {\n  1366→        tierText.textContent = requiredTier;\n  1367→    }\n  1368→    if (modal) {\n  1369→        modal.classList.remove('hidden');\n  1370→    }\n  1371→}\n  1372→\n  1373→/**\n  1374→ * Close the upgrade modal\n  1375→ */\n  1376→function closeUpgradeModal() {\n  1377→    const modal = document.getElementById('upgradeModal');\n  1378→    if (modal) {\n  1379→        modal.classList.add('hidden');\n  1380→    }\n  1381→}\n  1382→\n  1383→// Expose showUpgradeModal and closeUpgradeModal globally for feature modules\n  1384→window.showUpgradeModal = showUpgradeModal;\n  1385→window.closeUpgradeModal = closeUpgradeModal;\n  1386→\n  1387→async function activateLicense() {\n  1388→    if (!ui.licenseKeyInput) return;\n  1389→\n  1390→    const licenseKey = ui.licenseKeyInput.value.trim();\n  1391→    if (!licenseKey) {\n  1392→        setStatus('Please enter a license key', true);\n  1393→        return;\n  1394→    }\n  1395→\n  1396→    try {\n  1397→        const response = await fetchWithTimeout(\n  1398→            `${getBackendUrl()}/license/activate`,\n  1399→            {\n  1400→                method: 'POST',\n  1401→                headers: { 'Content-Type': 'application/json' },\n  1402→                body: JSON.stringify({ key: licenseKey })\n  1403→            }\n  1404→        );\n  1405→\n  1406→        if (!response.ok) {\n  1407→            throw new Error(await parseErrorResponse(response));\n  1408→        }\n  1409→\n  1410→        const data = await response.json();\n  1411→        saveSettings({\n  1412→            customerId: data.customerId,\n  1413→            licenseKey: licenseKey\n  1414→        });\n  1415→\n  1416→        if (ui.loginModal) ui.loginModal.classList.add('hidden');\n  1417→        setStatus('License activated');\n  1418→        updateCredits();\n  1419→    } catch (error) {\n  1420→        setStatus('Activation failed: ' + error.message, true);\n  1421→    }\n  1422→}\n  1423→\n  1424→/**\n  1425→ * Look up license key by email address\n  1426→ */\n  1427→async function lookupLicense() {\n  1428→    const lookupEmailInput = document.getElementById('lookupEmailInput');\n  1429→    const licenseKeyInput = document.getElementById('licenseKeyInput');\n  1430→\n  1431→    if (!lookupEmailInput) return;\n  1432→\n  1433→    const email = lookupEmailInput.value.trim().toLowerCase();\n  1434→    if (!email) {\n  1435→        setStatus('Please enter your email address', true);\n  1436→        return;\n  1437→    }\n  1438→\n  1439→    // Basic email validation\n  1440→    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  1441→    if (!emailRegex.test(email)) {\n  1442→        setStatus('Please enter a valid email address', true);\n  1443→        return;\n  1444→    }\n  1445→\n  1446→    const lookupBtn = document.getElementById('lookupLicenseBtn');\n  1447→    if (lookupBtn) {\n  1448→        lookupBtn.disabled = true;\n  1449→        lookupBtn.textContent = 'Looking up...';\n  1450→    }\n  1451→\n  1452→    try {\n  1453→        const response = await fetchWithTimeout(\n  1454→            `${getBackendUrl()}/license/lookup`,\n  1455→            {\n  1456→                method: 'POST',\n  1457→                headers: { 'Content-Type': 'application/json' },\n  1458→                body: JSON.stringify({ email })\n  1459→            },\n  1460→            30000\n  1461→        );\n  1462→\n  1463→        const result = await response.json();\n  1464→\n  1465→        // Note: For security, the backend does NOT return the license key directly.\n  1466→        // It sends the key via email to prevent enumeration attacks.\n  1467→        if (result.success) {\n  1468→            setStatus(result.message || 'If a license exists, it has been sent to your email.');\n  1469→        } else {\n  1470→            setStatus(result.error || 'Lookup failed. Please try again.', true);\n  1471→        }\n  1472→    } catch (error) {\n  1473→        setStatus('Lookup failed: ' + error.message, true);\n  1474→    } finally {\n  1475→        if (lookupBtn) {\n  1476→            lookupBtn.disabled = false;\n  1477→            lookupBtn.textContent = 'Lookup';\n  1478→        }\n  1479→    }\n  1480→}\n  1481→\n  1482→// ============================================================================\n  1483→// CREDITS\n  1484→// ============================================================================\n  1485→function initCredits() {\n  1486→    updateCredits();\n  1487→}\n  1488→\n  1489→async function updateCredits() {\n  1490→    if (!ui.creditBadge) return;\n  1491→\n  1492→    const settings = getSettings();\n  1493→    if (!settings.customerId) {\n  1494→        ui.creditBadge.className = 'credit-badge login';\n  1495→        ui.creditBadge.textContent = 'Login';\n  1496→        ui.creditBadge.style.display = 'flex';\n  1497→        return;\n  1498→    }\n  1499→\n  1500→    try {\n  1501→        const response = await fetchWithTimeout(\n  1502→            `${getBackendUrl()}/credits`,\n  1503→            {\n  1504→                method: 'GET',\n  1505→                headers: getAuthHeaders()\n  1506→            }\n  1507→        );\n  1508→\n  1509→        if (response.ok) {\n  1510→            const data = await response.json();\n  1511→            // Backend returns hoursRemaining (not remainingMinutes)\n  1512→            const hours = (data.hoursRemaining || 0).toFixed(1);\n  1513→            ui.creditBadge.textContent = `${hours}h`;\n  1514→            // Low warning when less than 1 hour remaining\n  1515→            ui.creditBadge.className = data.hoursRemaining < 1 ? 'credit-badge low' : 'credit-badge ok';\n  1516→            ui.creditBadge.style.display = 'flex';\n  1517→        } else {\n  1518→            ui.creditBadge.className = 'credit-badge error';\n  1519→            ui.creditBadge.textContent = 'Error';\n  1520→            ui.creditBadge.style.display = 'flex';\n  1521→        }\n  1522→    } catch {\n  1523→        ui.creditBadge.className = 'credit-badge error';\n  1524→        ui.creditBadge.textContent = 'Offline';\n  1525→        ui.creditBadge.style.display = 'flex';\n  1526→    }\n  1527→}\n  1528→\n  1529→// ============================================================================\n  1530→// HELP BUTTON\n  1531→// ============================================================================\n  1532→function initHelpButton() {\n  1533→    const helpBtn = document.getElementById('helpBtn');\n  1534→    if (helpBtn) {\n  1535→        helpBtn.addEventListener('click', () => {\n  1536→            setStatus('Silence: removes quiet gaps | Takes: detects repeated content | Chapters: AI topic segmentation');\n  1537→        });\n  1538→    }\n  1539→}\n  1540→\n  1541→// Export for debugging\n  1542→window.spliceDebug = {\n  1543→    getState: () => ({\n  1544→        silences: previewSilences,\n  1545→        takes: previewTakes,\n  1546→        chapters: currentChapters,\n  1547→        zooms: currentZooms,\n  1548→        selected: Array.from(selectedSilenceIndices)\n  1549→    }),\n  1550→    jsx,\n  1551→    runDetection\n  1552→};\n  1553→\n\n</system-reminder>\n"}]},"uuid":"6cd4152d-ff5e-4454-b4bb-7f38e9ebf91a","timestamp":"2026-01-11T23:55:46.996Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/main.js","content":"/**\n * SPLICE CEP Panel - Main Entry Point\n * v4.0.0 - CEP Migration\n */\n\n// ============================================================================\n// CACHED DOM ELEMENTS\n// ============================================================================\nconst ui = {};\n\nfunction cacheUIElements() {\n    ui.status = document.getElementById('status');\n    ui.goBtn = document.getElementById('goBtn');\n    ui.optionsToggle = document.getElementById('optionsToggle');\n    ui.optionsPanel = document.getElementById('optionsPanel');\n\n    // Sliders and options\n    ui.sensitivitySlider = document.getElementById('sensitivitySlider');\n    ui.sensitivityValue = document.getElementById('sensitivityValue');\n    ui.sourceOriginal = document.getElementById('sourceOriginal');\n    ui.sourceIsolated = document.getElementById('sourceIsolated');\n\n    // Feature toggles\n    ui.enableTakesDetection = document.getElementById('enableTakesDetection');\n    ui.enableJCut = document.getElementById('enableJCut');\n    ui.jcutSettings = document.getElementById('jcutSettings');\n    ui.jcutLeadIn = document.getElementById('jcutLeadIn');\n    ui.jcutLeadInValue = document.getElementById('jcutLeadInValue');\n    ui.jcutLeadOut = document.getElementById('jcutLeadOut');\n    ui.jcutLeadOutValue = document.getElementById('jcutLeadOutValue');\n\n    // Zoom settings\n    ui.enableZoom = document.getElementById('enableZoom');\n    ui.zoomSettings = document.getElementById('zoomSettings');\n    ui.zoomFrequency = document.getElementById('zoomFrequency');\n    ui.zoomPreset = document.getElementById('zoomPreset');\n    ui.zoomPlacement = document.getElementById('zoomPlacement');\n\n    // Chapter settings\n    ui.enableChapters = document.getElementById('enableChapters');\n    ui.chapterSettings = document.getElementById('chapterSettings');\n    ui.maxChapters = document.getElementById('maxChapters');\n    ui.minChapterLength = document.getElementById('minChapterLength');\n\n    // Profanity settings\n    ui.enableProfanity = document.getElementById('enableProfanity');\n    ui.profanitySettings = document.getElementById('profanitySettings');\n\n    // Filler word settings\n    ui.enableFillerDetection = document.getElementById('enableFillerDetection');\n    ui.fillerSettings = document.getElementById('fillerSettings');\n\n    // Progress\n    ui.progressContainer = document.getElementById('progressContainer');\n    ui.progressBar = document.getElementById('progressBar');\n    ui.progressText = document.getElementById('progressText');\n    ui.resultsEmpty = document.getElementById('resultsEmpty');\n\n    // Preview\n    ui.combinedPreview = document.getElementById('combinedPreview');\n    ui.previewList = document.getElementById('previewList');\n    ui.silenceCount = document.getElementById('silenceCount');\n    ui.takeCount = document.getElementById('takeCount');\n    ui.selectedCount = document.getElementById('selectedCount');\n    ui.selectAllSilences = document.getElementById('selectAllSilences');\n    ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');\n    ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');\n    ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');\n\n    // Results\n    ui.zoomResults = document.getElementById('zoomResults');\n    ui.zoomList = document.getElementById('zoomList');\n    ui.chapterResults = document.getElementById('chapterResults');\n    ui.chapterList = document.getElementById('chapterList');\n    ui.copyYouTubeBtn = document.getElementById('copyYouTubeBtn');\n    ui.addChapterMarkersBtn = document.getElementById('addChapterMarkersBtn');\n\n    // Modals\n    ui.settingsBtn = document.getElementById('settingsBtn');\n    ui.settingsModal = document.getElementById('settingsModal');\n    ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');\n    ui.loginModal = document.getElementById('loginModal');\n    ui.closeLoginBtn = document.getElementById('closeLoginBtn');\n    ui.licenseKeyInput = document.getElementById('licenseKeyInput');\n    ui.saveLoginBtn = document.getElementById('saveLoginBtn');\n\n    // Credit badge\n    ui.creditBadge = document.getElementById('creditBadge');\n\n    // Preset selector\n    ui.presetSelector = document.getElementById('presetSelector');\n}\n\n// ============================================================================\n// STATE MANAGEMENT\n// ============================================================================\nlet previewSilences = [];\nlet previewTakes = [];\nlet currentChapters = [];\nlet currentZooms = [];\nlet currentProfanity = [];\nlet selectedSilenceIndices = new Set();\nlet isOperationInProgress = false;\nlet lastDetectionResult = null;\nlet currentAudioPath = null;\nlet currentSequenceInfo = null;\nlet currentTranscript = null;\n\n// Global state for captions/reframe modules\nwindow.spliceState = {\n    lastTranscript: null,\n    currentVideoPath: null,\n    activeSequence: null,\n    audioPath: null\n};\n\n// Also expose transcript globally for music module\nwindow.currentTranscript = null;\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\ndocument.addEventListener('DOMContentLoaded', async () => {\n    // Premium Loading Experience\n    setTimeout(() => {\n        const loader = document.getElementById('loading-overlay');\n        if (loader) loader.classList.add('hidden');\n    }, 800); // Small delay for smooth perception\n    debugLog('Initializing CEP panel...');\n\n    // Debug: Show init started\n    const statusEl = document.getElementById('status');\n    if (statusEl) statusEl.textContent = 'Initializing...';\n\n    // Cache DOM elements\n    cacheUIElements();\n\n    // Load settings\n    loadSettingsToUI();\n\n    // Initialize UI handlers\n    initOptionsToggle();\n    initSliders();\n    initFeatureToggles();\n    initPresetSelector();\n    initGoButton();\n    initPreviewHandlers();\n    initModals();\n    initLoginModal();\n    initCredits();\n    initHelpButton();\n\n    // Initialize offline detection\n    if (typeof initOfflineDetection === 'function') {\n        initOfflineDetection();\n    }\n\n    // Initialize multitrack UI\n    if (typeof initMultitrackUI === 'function') {\n        initMultitrackUI();\n    }\n\n    // Initialize animated captions UI\n    if (typeof initAnimatedCaptions === 'function') {\n        initAnimatedCaptions();\n    }\n\n    // Initialize text editor UI\n    if (typeof initTextEditor === 'function') {\n        initTextEditor();\n    }\n\n    // Initialize text editor section toggle\n    initTextEditorToggle();\n\n    // Initialize social reframe UI\n    if (typeof initSocialReframe === 'function') {\n        initSocialReframe();\n    }\n\n    // Initialize social reframe section toggle\n    initSocialReframeToggle();\n\n    // Initialize music UI\n    if (typeof initMusicModule === 'function') {\n        initMusicModule();\n    }\n\n    // Initialize music section toggle\n    initMusicToggle();\n\n    // Initialize JSX bridge first, then check connection\n    // This ensures jsx.init() completes before checkJSXConnection() uses it\n    await jsx.init();\n    await checkJSXConnection();\n\n    // Initialize sequence event listeners for real-time state updates\n    initSequenceEventListeners();\n\n    setStatus('Ready');\n    debugLog('CEP panel initialized');\n});\n\n// ============================================================================\n// SEQUENCE EVENT LISTENERS\n// ============================================================================\n/**\n * Initialize event listeners for sequence state changes\n * This provides real-time updates when sequences are activated/deactivated\n */\nfunction initSequenceEventListeners() {\n    if (!jsx.cs) {\n        console.warn('[SPLICE] Cannot init sequence listeners - CSInterface not available');\n        return;\n    }\n\n    try {\n        // Listen for sequence activation events\n        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceActivated', async (event) => {\n            debugLog('Sequence activated event received');\n            try {\n                const seqInfo = await jsx.call('getActiveSequence');\n                if (seqInfo && !seqInfo.error) {\n                    window.spliceState.activeSequence = seqInfo;\n                    setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));\n                    debugLog('Active sequence updated:', seqInfo.name);\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Failed to get sequence info on activation:', e.message);\n            }\n        });\n\n        // Listen for sequence close/deactivation\n        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceDeactivated', () => {\n            debugLog('Sequence deactivated event');\n            window.spliceState.activeSequence = null;\n            setStatus('No sequence open', true);\n        });\n\n        // Listen for project item selection changes (includes sequences)\n        jsx.cs.addEventListener('com.adobe.csxs.events.SelectionChanged', async () => {\n            // Debounce rapid selection changes\n            if (window._selectionChangeTimeout) {\n                clearTimeout(window._selectionChangeTimeout);\n            }\n            window._selectionChangeTimeout = setTimeout(async () => {\n                try {\n                    const hasSequence = await checkSequenceOpen(0, 0); // Quick check, no retries\n                    if (hasSequence && !window.spliceState.activeSequence) {\n                        const seqInfo = await jsx.call('getActiveSequence');\n                        if (seqInfo && !seqInfo.error) {\n                            window.spliceState.activeSequence = seqInfo;\n                            debugLog('Sequence detected via selection change:', seqInfo.name);\n                        }\n                    }\n                } catch (e) {\n                    // Ignore errors during selection change - it's just for proactive updates\n                }\n            }, 200);\n        });\n\n        debugLog('Sequence event listeners initialized');\n    } catch (e) {\n        console.error('[SPLICE] Failed to init sequence event listeners:', e.message);\n    }\n}\n\n// ============================================================================\n// JSX CONNECTION CHECK\n// ============================================================================\nasync function checkJSXConnection() {\n    try {\n        const result = await jsx.call('getVersion');\n        debugLog('JSX connection OK, version:', result);\n        return true;\n    } catch (e) {\n        console.warn('[SPLICE] JSX connection failed:', e.message);\n        setStatus('Premiere Pro connection failed', true);\n        return false;\n    }\n}\n\n/**\n * Check if a sequence is currently open in the Timeline\n * Enhanced with logging and retry logic\n * @param {number} retries - Number of retry attempts (default: 2)\n * @param {number} delayMs - Delay between retries in ms (default: 300)\n * @returns {Promise<boolean>} true if sequence is open\n */\nasync function checkSequenceOpen(retries = 2, delayMs = 300) {\n    for (let attempt = 0; attempt <= retries; attempt++) {\n        try {\n            const result = await jsx.call('checkSequenceOpen');\n            debugLog('checkSequenceOpen attempt', attempt + 1, 'result:', result, 'type:', typeof result);\n\n            if (result === true || result === 'true') {\n                return true;\n            }\n\n            // If false, wait and retry (sequence might be loading)\n            if (attempt < retries) {\n                debugLog('checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');\n                await new Promise(r => setTimeout(r, delayMs));\n            }\n        } catch (error) {\n            console.error('[SPLICE] checkSequenceOpen attempt', attempt + 1, 'failed:', error.message);\n\n            // On last attempt, return false but log the actual error\n            if (attempt === retries) {\n                console.error('[SPLICE] checkSequenceOpen: All attempts failed. Last error:', error.message);\n                // Store error for diagnostics\n                window.spliceState.lastSequenceCheckError = error.message;\n                return false;\n            }\n\n            // Wait before retry\n            await new Promise(r => setTimeout(r, delayMs));\n        }\n    }\n    return false;\n}\n\n// ============================================================================\n// OPTIONS TOGGLE\n// ============================================================================\nfunction initOptionsToggle() {\n    debugLog('initOptionsToggle - toggle:', !!ui.optionsToggle, 'panel:', !!ui.optionsPanel);\n    if (ui.optionsToggle && ui.optionsPanel) {\n        ui.optionsToggle.addEventListener('click', () => {\n            debugLog('Options toggle clicked');\n            // Check current state BEFORE toggling\n            const wasCollapsed = ui.optionsPanel.classList.contains('collapsed');\n            ui.optionsPanel.classList.toggle('collapsed');\n            // If it was collapsed, it's now expanded (show 'expanded' class)\n            ui.optionsToggle.classList.toggle('expanded', wasCollapsed);\n            saveSettings({ expandedOptions: wasCollapsed });\n        });\n\n        // Restore state\n        const settings = getSettings();\n        if (!settings.expandedOptions) {\n            ui.optionsPanel.classList.add('collapsed');\n            ui.optionsToggle.classList.remove('expanded');\n        } else {\n            ui.optionsToggle.classList.add('expanded');\n            ui.optionsPanel.classList.remove('collapsed');\n        }\n    }\n}\n\n// ============================================================================\n// TEXT EDITOR TOGGLE\n// ============================================================================\nfunction initTextEditorToggle() {\n    const toggle = document.getElementById('textEditorToggle');\n    const panel = document.getElementById('text-editor-panel');\n    debugLog('initTextEditorToggle - toggle:', !!toggle, 'panel:', !!panel);\n\n    if (toggle && panel) {\n        toggle.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            debugLog('Text Editor toggle clicked');\n            setStatus('Text Editor: ' + (panel.classList.contains('collapsed') ? 'Opening' : 'Closing'));\n            // Check state BEFORE toggling\n            const wasCollapsed = panel.classList.contains('collapsed');\n            panel.classList.toggle('collapsed');\n            const icon = toggle.querySelector('.toggle-icon');\n            debugLog('wasCollapsed:', wasCollapsed, 'icon:', !!icon);\n            if (icon) {\n                // If it was collapsed, it's now expanded (show -)\n                icon.textContent = wasCollapsed ? '-' : '+';\n            }\n        });\n    } else {\n        console.error('[SPLICE] Text Editor toggle elements not found!');\n    }\n}\n\n// ============================================================================\n// SOCIAL REFRAME TOGGLE\n// ============================================================================\nfunction initSocialReframeToggle() {\n    const toggle = document.getElementById('socialReframeToggle');\n    const panel = document.getElementById('social-reframe-panel');\n    debugLog('initSocialReframeToggle - toggle:', !!toggle, 'panel:', !!panel);\n\n    if (toggle && panel) {\n        toggle.addEventListener('click', () => {\n            debugLog('Social Reframe toggle clicked');\n            // Check state BEFORE toggling\n            const wasCollapsed = panel.classList.contains('collapsed');\n            panel.classList.toggle('collapsed');\n            const icon = toggle.querySelector('.toggle-icon');\n            if (icon) {\n                // If it was collapsed, it's now expanded (show -)\n                icon.textContent = wasCollapsed ? '-' : '+';\n            }\n        });\n    } else {\n        console.error('[SPLICE] Social Reframe toggle elements not found!');\n    }\n}\n\n// ============================================================================\n// MUSIC TOGGLE\n// ============================================================================\nfunction initMusicToggle() {\n    const toggle = document.getElementById('musicToggle');\n    const panel = document.getElementById('music-panel');\n    debugLog('initMusicToggle - toggle:', !!toggle, 'panel:', !!panel);\n\n    if (toggle && panel) {\n        toggle.addEventListener('click', () => {\n            debugLog('Music toggle clicked');\n            // Check state BEFORE toggling\n            const wasCollapsed = panel.classList.contains('collapsed');\n            panel.classList.toggle('collapsed');\n            const icon = toggle.querySelector('.toggle-icon');\n            if (icon) {\n                // If it was collapsed, it's now expanded (show -)\n                icon.textContent = wasCollapsed ? '-' : '+';\n            }\n        });\n    } else {\n        console.error('[SPLICE] Music toggle elements not found!');\n    }\n}\n\n// ============================================================================\n// SLIDERS\n// ============================================================================\nfunction initSliders() {\n    // Sensitivity slider\n    if (ui.sensitivitySlider && ui.sensitivityValue) {\n        ui.sensitivitySlider.addEventListener('input', () => {\n            ui.sensitivityValue.textContent = ui.sensitivitySlider.value;\n            saveSettings({ sensitivity: parseInt(ui.sensitivitySlider.value) });\n        });\n    }\n\n    // J-Cut sliders\n    if (ui.jcutLeadIn && ui.jcutLeadInValue) {\n        ui.jcutLeadIn.addEventListener('input', () => {\n            const val = (ui.jcutLeadIn.value / 100).toFixed(2);\n            ui.jcutLeadInValue.textContent = val + 's';\n            saveSettings({ jcutLeadIn: parseFloat(val) });\n        });\n    }\n\n    if (ui.jcutLeadOut && ui.jcutLeadOutValue) {\n        ui.jcutLeadOut.addEventListener('input', () => {\n            const val = (ui.jcutLeadOut.value / 100).toFixed(2);\n            ui.jcutLeadOutValue.textContent = val + 's';\n            saveSettings({ jcutLeadOut: parseFloat(val) });\n        });\n    }\n}\n\n// ============================================================================\n// FEATURE TOGGLES\n// ============================================================================\nfunction initFeatureToggles() {\n    // J-Cut toggle\n    if (ui.enableJCut && ui.jcutSettings) {\n        ui.enableJCut.addEventListener('change', () => {\n            ui.jcutSettings.classList.toggle('collapsed', !ui.enableJCut.checked);\n            saveSettings({ enableJCut: ui.enableJCut.checked });\n        });\n    }\n\n    // Zoom toggle\n    if (ui.enableZoom && ui.zoomSettings) {\n        ui.enableZoom.addEventListener('change', () => {\n            ui.zoomSettings.classList.toggle('collapsed', !ui.enableZoom.checked);\n            saveSettings({ enableZoom: ui.enableZoom.checked });\n        });\n    }\n\n    // Chapters toggle\n    if (ui.enableChapters && ui.chapterSettings) {\n        ui.enableChapters.addEventListener('change', () => {\n            ui.chapterSettings.classList.toggle('collapsed', !ui.enableChapters.checked);\n            saveSettings({ enableChapters: ui.enableChapters.checked });\n        });\n    }\n\n    // Takes detection toggle\n    if (ui.enableTakesDetection) {\n        ui.enableTakesDetection.addEventListener('change', () => {\n            saveSettings({ enableTakesDetection: ui.enableTakesDetection.checked });\n        });\n    }\n\n    // Profanity detection toggle\n    if (ui.enableProfanity && ui.profanitySettings) {\n        ui.enableProfanity.addEventListener('change', () => {\n            ui.profanitySettings.classList.toggle('collapsed', !ui.enableProfanity.checked);\n            saveSettings({ enableProfanity: ui.enableProfanity.checked });\n        });\n    }\n\n    // Filler word detection toggle\n    if (ui.enableFillerDetection && ui.fillerSettings) {\n        ui.enableFillerDetection.addEventListener('change', () => {\n            ui.fillerSettings.classList.toggle('collapsed', !ui.enableFillerDetection.checked);\n            saveSettings({ enableFillerDetection: ui.enableFillerDetection.checked });\n        });\n    }\n}\n\n// ============================================================================\n// PRESET SELECTOR\n// ============================================================================\n// PRESETS is defined in config.js\n\nfunction initPresetSelector() {\n    if (!ui.presetSelector) return;\n\n    ui.presetSelector.addEventListener('change', () => {\n        const presetId = ui.presetSelector.value;\n        applyPreset(presetId);\n    });\n\n    // Load current preset\n    const settings = getSettings();\n    if (settings.activePreset) {\n        ui.presetSelector.value = settings.activePreset;\n    }\n}\n\nfunction applyPreset(presetId) {\n    const preset = PRESETS[presetId];\n    if (!preset) return;\n\n    // Custom preset - keep current settings\n    if (presetId === 'custom' || !preset.settings) {\n        saveSettings({ activePreset: 'custom' });\n        setStatus('Using custom settings');\n        return;\n    }\n\n    const settings = preset.settings;\n\n    // Apply to UI\n    if (ui.sensitivitySlider && settings.sensitivity !== undefined) {\n        ui.sensitivitySlider.value = settings.sensitivity;\n        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n    }\n\n    if (ui.enableJCut) {\n        ui.enableJCut.checked = settings.enableJCut || false;\n        if (ui.jcutSettings) {\n            ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n        }\n    }\n\n    if (settings.jCutLeadIn !== undefined && ui.jcutLeadIn) {\n        ui.jcutLeadIn.value = Math.round(settings.jCutLeadIn * 100);\n        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jCutLeadIn + 's';\n    }\n\n    if (settings.jCutLeadOut !== undefined && ui.jcutLeadOut) {\n        ui.jcutLeadOut.value = Math.round(settings.jCutLeadOut * 100);\n        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jCutLeadOut + 's';\n    }\n\n    // Save merged settings\n    saveSettings({\n        activePreset: presetId,\n        sensitivity: settings.sensitivity,\n        threshold: settings.threshold,\n        minSilenceLength: settings.minSilenceLength,\n        paddingStart: settings.paddingStart,\n        paddingEnd: settings.paddingEnd,\n        enableTakesDetection: settings.enableTakesDetection,\n        enableJCut: settings.enableJCut || false,\n        jcutLeadIn: settings.jCutLeadIn || 0.3,\n        jcutLeadOut: settings.jCutLeadOut || 0.2\n    });\n\n    setStatus(`Applied ${preset.name} preset`);\n}\n\n// ============================================================================\n// LOAD SETTINGS TO UI\n// ============================================================================\nfunction loadSettingsToUI() {\n    const settings = getSettings();\n\n    if (ui.sensitivitySlider) {\n        ui.sensitivitySlider.value = settings.sensitivity;\n        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n    }\n\n    if (ui.enableTakesDetection) ui.enableTakesDetection.checked = settings.enableTakesDetection;\n    if (ui.enableJCut) ui.enableJCut.checked = settings.enableJCut;\n    if (ui.enableZoom) ui.enableZoom.checked = settings.enableZoom;\n    if (ui.enableChapters) ui.enableChapters.checked = settings.enableChapters;\n\n    if (ui.jcutSettings) ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n    if (ui.zoomSettings) ui.zoomSettings.classList.toggle('collapsed', !settings.enableZoom);\n    if (ui.chapterSettings) ui.chapterSettings.classList.toggle('collapsed', !settings.enableChapters);\n\n    if (ui.jcutLeadIn) {\n        ui.jcutLeadIn.value = Math.round(settings.jcutLeadIn * 100);\n        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jcutLeadIn + 's';\n    }\n    if (ui.jcutLeadOut) {\n        ui.jcutLeadOut.value = Math.round(settings.jcutLeadOut * 100);\n        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jcutLeadOut + 's';\n    }\n\n    if (ui.presetSelector && settings.activePreset) {\n        ui.presetSelector.value = settings.activePreset;\n    }\n}\n\n// ============================================================================\n// GO BUTTON - MAIN WORKFLOW\n// ============================================================================\nfunction initGoButton() {\n    if (!ui.goBtn) return;\n\n    ui.goBtn.addEventListener('click', async () => {\n        if (isOperationInProgress) return;\n        await runDetection();\n    });\n}\n\nasync function runDetection() {\n    if (isOperationInProgress) return;\n\n    // Check sequence with enhanced error messaging\n    const hasSequence = await checkSequenceOpen();\n    if (!hasSequence) {\n        // Check if there was a communication error vs just no sequence\n        const lastError = window.spliceState.lastSequenceCheckError;\n        if (lastError && (lastError.includes('CEP') || lastError.includes('communication') || lastError.includes('evalScript'))) {\n            setStatus('Premiere Pro connection issue - try reopening panel', true);\n            console.error('[SPLICE] runDetection: JSX communication failure:', lastError);\n        } else {\n            setStatus('Please open a sequence in the Timeline first', true);\n            debugLog('runDetection: No active sequence in Timeline');\n        }\n        // Clear the error for next check\n        window.spliceState.lastSequenceCheckError = null;\n        return;\n    }\n\n    // Check online\n    if (!isOnline()) {\n        setStatus('Offline - Check your connection', true);\n        return;\n    }\n\n    isOperationInProgress = true;\n    ui.goBtn.disabled = true;\n    showProgress('Detecting silences...');\n\n    try {\n        const settings = getSettings();\n\n        // Get sequence info\n        const seqInfo = await jsx.call('getActiveSequence');\n        debugLog('Sequence info:', seqInfo);\n\n        // Store sequence info for later use\n        currentSequenceInfo = seqInfo;\n        window.spliceState.activeSequence = seqInfo;\n        if (seqInfo && seqInfo.videoPath) {\n            window.spliceState.currentVideoPath = seqInfo.videoPath;\n        }\n\n        // Export audio via JSX for silence detection\n        updateProgress(10, 'Exporting audio...');\n\n        let audioFilePath = null;\n        try {\n            // Get sequence info for audio export\n            const exportResult = await jsx.call('exportSequenceAudioForAnalysis');\n            if (exportResult && exportResult.success && exportResult.outputPath) {\n                audioFilePath = exportResult.outputPath;\n                debugLog('Audio exported to:', audioFilePath);\n            } else if (exportResult && exportResult.error) {\n                throw new Error(exportResult.error);\n            }\n        } catch (exportError) {\n            console.warn('[SPLICE] Audio export failed, trying fallback:', exportError.message);\n            // Try to get audio from first clip in timeline\n            try {\n                const clipInfo = await jsx.call('getFirstClipAudioPath');\n                if (clipInfo && clipInfo.path) {\n                    audioFilePath = clipInfo.path;\n                    debugLog('Using clip audio path:', audioFilePath);\n                }\n            } catch (clipError) {\n                console.warn('[SPLICE] Fallback audio path failed:', clipError.message);\n            }\n        }\n\n        if (!audioFilePath) {\n            throw new Error('Could not export or locate audio file. Please ensure sequence has audio tracks.');\n        }\n\n        // Store audio path globally for other modules\n        currentAudioPath = audioFilePath;\n        window.spliceState.audioPath = audioFilePath;\n\n        // Call backend for silence detection with audio file path\n        updateProgress(30, 'Detecting silences...');\n        const silenceResponse = await fetchWithTimeout(\n            `${getBackendUrl()}/silences-rms`,\n            {\n                method: 'POST',\n                headers: getAuthHeaders(),\n                body: JSON.stringify({\n                    wavPath: audioFilePath,\n                    sensitivity: settings.sensitivity,\n                    minSilenceLength: settings.minSilenceLength || 0.5\n                })\n            }\n        );\n\n        if (!silenceResponse.ok) {\n            throw new Error(await parseErrorResponse(silenceResponse));\n        }\n\n        const silenceData = await silenceResponse.json();\n        previewSilences = silenceData.silences || [];\n\n        // Detect takes if enabled\n        if (settings.enableTakesDetection) {\n            updateProgress(60, 'Detecting takes...');\n            try {\n                const analyzeResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/analyze`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            detectTakes: true\n                        })\n                    }\n                );\n\n                if (analyzeResponse.ok) {\n                    const analyzeData = await analyzeResponse.json();\n                    previewTakes = analyzeData.takes || [];\n\n                    // Store transcript for captions/music modules\n                    if (analyzeData.transcript) {\n                        currentTranscript = analyzeData.transcript;\n                        window.currentTranscript = analyzeData.transcript;\n                        window.spliceState.lastTranscript = analyzeData.transcript;\n                    }\n                } else {\n                    // Handle specific error codes\n                    const errorMsg = await parseErrorResponse(analyzeResponse);\n                    if (analyzeResponse.status === 402) {\n                        console.warn('[SPLICE] Takes detection skipped: insufficient credits');\n                        setStatus('Takes detection skipped: insufficient credits', true);\n                    } else if (analyzeResponse.status === 401) {\n                        console.warn('[SPLICE] Takes detection skipped: authentication required');\n                    } else {\n                        console.warn('[SPLICE] Takes detection failed:', errorMsg);\n                    }\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Takes detection failed:', e.message);\n            }\n        }\n\n        // Detect profanity if enabled\n        if (settings.enableProfanity) {\n            updateProgress(65, 'Detecting profanity...');\n            try {\n                const profanityResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/profanity`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            language: settings.profanityLanguage || 'en',\n                            bleepType: settings.bleepType || 'standard'\n                        })\n                    }\n                );\n\n                if (profanityResponse.ok) {\n                    const profanityData = await profanityResponse.json();\n                    currentProfanity = profanityData.instances || [];\n                    if (currentProfanity.length > 0) {\n                        debugLog(`Found ${currentProfanity.length} profanity instances`);\n                    }\n                } else {\n                    console.warn('[SPLICE] Profanity detection failed:', await parseErrorResponse(profanityResponse));\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Profanity detection failed:', e.message);\n            }\n        }\n\n        // Detect chapters if enabled\n        if (settings.enableChapters) {\n            updateProgress(80, 'Detecting chapters...');\n            try {\n                const chapterResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/chapters`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            transcript: currentTranscript,\n                            maxChapters: settings.maxChapters || 10,\n                            minChapterLength: settings.minChapterLength || 60\n                        })\n                    }\n                );\n\n                if (chapterResponse.ok) {\n                    const chapterData = await chapterResponse.json();\n                    currentChapters = chapterData.chapters || [];\n                } else {\n                    const errorMsg = await parseErrorResponse(chapterResponse);\n                    console.warn('[SPLICE] Chapter detection failed:', errorMsg);\n                    // Don't block workflow, just notify user\n                    setStatus('Chapter detection skipped: ' + errorMsg, true);\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Chapter detection failed:', e);\n                setStatus('Chapter detection failed - continuing without chapters', true);\n            }\n        }\n\n        // Detect zoom points if enabled\n        if (settings.enableZoom) {\n            updateProgress(90, 'Detecting zoom points...');\n            try {\n                const zoomResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/zoom`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            transcript: currentTranscript,\n                            frequency: settings.zoomFrequency || 'medium',\n                            preset: settings.zoomPreset || 'medium',\n                            placement: settings.zoomPlacement || 'sentence_start'\n                        })\n                    }\n                );\n\n                if (zoomResponse.ok) {\n                    const zoomData = await zoomResponse.json();\n                    currentZooms = zoomData.zoomPoints || [];\n                } else {\n                    const errorMsg = await parseErrorResponse(zoomResponse);\n                    console.warn('[SPLICE] Zoom detection failed:', errorMsg);\n                    setStatus('Zoom detection skipped: ' + errorMsg, true);\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Zoom detection failed:', e);\n                setStatus('Zoom detection failed - continuing without zoom points', true);\n            }\n        }\n\n        // Store results\n        lastDetectionResult = {\n            silences: previewSilences,\n            takes: previewTakes,\n            chapters: currentChapters,\n            zooms: currentZooms\n        };\n\n        // Show preview\n        hideProgress();\n        showCombinedPreview();\n        setStatus(`Found ${previewSilences.length} silences, ${previewTakes.length} takes`);\n\n    } catch (error) {\n        console.error('[SPLICE] Detection error:', error);\n        setStatus('Detection failed: ' + error.message, true);\n        hideProgress();\n    } finally {\n        isOperationInProgress = false;\n        ui.goBtn.disabled = false;\n    }\n}\n\n// ============================================================================\n// PROGRESS UI\n// ============================================================================\nfunction showProgress(message) {\n    if (ui.progressContainer) ui.progressContainer.classList.remove('hidden');\n    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n    updateProgress(0, message);\n}\n\nfunction updateProgress(percent, message) {\n    if (ui.progressBar) ui.progressBar.style.width = percent + '%';\n    if (ui.progressText) ui.progressText.textContent = message || '';\n}\n\nfunction hideProgress() {\n    if (ui.progressContainer) ui.progressContainer.classList.add('hidden');\n}\n\n// ============================================================================\n// COMBINED PREVIEW\n// ============================================================================\nfunction showCombinedPreview() {\n    if (!ui.combinedPreview) return;\n\n    ui.combinedPreview.classList.remove('hidden');\n    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n\n    // Update counts\n    if (ui.silenceCount) ui.silenceCount.textContent = previewSilences.length;\n    if (ui.takeCount) ui.takeCount.textContent = previewTakes.length;\n\n    // Select all by default\n    selectedSilenceIndices.clear();\n    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n    updateSelectedCount();\n\n    // Render preview list\n    renderPreviewList();\n\n    // Show chapter results if available\n    if (currentChapters.length > 0 && ui.chapterResults) {\n        ui.chapterResults.classList.remove('hidden');\n        renderChapterList();\n    }\n\n    // Show zoom results if available\n    if (currentZooms.length > 0 && ui.zoomResults) {\n        ui.zoomResults.classList.remove('hidden');\n    }\n}\n\nfunction renderPreviewList() {\n    if (!ui.previewList) return;\n\n    const html = [];\n\n    // Render silences\n    previewSilences.forEach((silence, i) => {\n        const isSelected = selectedSilenceIndices.has(i);\n        const duration = silence.end - silence.start;\n        html.push(`\n            <div class=\"preview-item ${isSelected ? '' : 'excluded'}\" data-index=\"${i}\" data-type=\"silence\">\n                <input type=\"checkbox\" class=\"preview-item-check\" ${isSelected ? 'checked' : ''}>\n                <div class=\"preview-item-info\">\n                    <div class=\"preview-item-time\">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>\n                    <div class=\"preview-item-duration\">${duration.toFixed(2)}s silence</div>\n                </div>\n            </div>\n        `);\n    });\n\n    // Render takes\n    previewTakes.forEach((take, i) => {\n        // SECURITY: Escape take label to prevent XSS\n        const safeLabel = escapeHtml(take.label || 'Take ' + (take.takeNumber || i + 1));\n        html.push(`\n            <div class=\"preview-item take-item\" data-index=\"${i}\" data-type=\"take\">\n                <div class=\"preview-item-icon\">🎬</div>\n                <div class=\"preview-item-info\">\n                    <div class=\"preview-item-time\">${formatTime(take.start)} - ${formatTime(take.end)}</div>\n                    <div class=\"preview-item-label\">${safeLabel}</div>\n                </div>\n            </div>\n        `);\n    });\n\n    ui.previewList.innerHTML = html.join('');\n\n    // Add click handlers\n    ui.previewList.querySelectorAll('.preview-item').forEach(item => {\n        item.addEventListener('click', (e) => {\n            const index = parseInt(item.dataset.index);\n            const type = item.dataset.type;\n\n            if (e.target.classList.contains('preview-item-check')) {\n                // Checkbox clicked\n                toggleSilenceSelection(index);\n            } else {\n                // Item clicked - seek to time\n                const data = type === 'silence' ? previewSilences[index] : previewTakes[index];\n                seekToTime(data.start);\n            }\n        });\n    });\n}\n\nfunction toggleSilenceSelection(index) {\n    if (selectedSilenceIndices.has(index)) {\n        selectedSilenceIndices.delete(index);\n    } else {\n        selectedSilenceIndices.add(index);\n    }\n    updateSelectedCount();\n    renderPreviewList();\n}\n\nfunction updateSelectedCount() {\n    if (ui.selectedCount) {\n        ui.selectedCount.textContent = selectedSilenceIndices.size;\n    }\n    if (ui.selectAllSilences) {\n        ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length;\n    }\n}\n\nasync function seekToTime(seconds) {\n    try {\n        // Check if there's an active sequence before seeking\n        if (!app?.project?.activeSequence) {\n            debugLog('No active sequence to seek in');\n            return;\n        }\n        // Use JSX to set playhead position\n        // Note: setPlayerPosition expects ticks as a string without quotes around the number value\n        const ticks = Math.round(seconds * 254016000000);\n        await jsx.evalScript(`app.project.activeSequence.setPlayerPosition(${ticks})`);\n    } catch (e) {\n        console.warn('[SPLICE] Seek failed:', e);\n    }\n}\n\n// ============================================================================\n// CHAPTER LIST\n// ============================================================================\nfunction renderChapterList() {\n    if (!ui.chapterList) return;\n\n    const html = currentChapters.map((chapter, i) => {\n        // SECURITY: Escape chapter title to prevent XSS\n        const safeTitle = escapeHtml(chapter.title);\n        return `\n            <div class=\"chapter-item\" data-index=\"${i}\">\n                <div class=\"chapter-time\">${formatTime(chapter.startTime)}</div>\n                <div class=\"chapter-title\">${safeTitle}</div>\n            </div>\n        `;\n    }).join('');\n\n    ui.chapterList.innerHTML = html;\n\n    // Add click handlers\n    ui.chapterList.querySelectorAll('.chapter-item').forEach(item => {\n        item.addEventListener('click', () => {\n            const index = parseInt(item.dataset.index);\n            seekToTime(currentChapters[index].startTime);\n        });\n    });\n}\n\n// ============================================================================\n// PREVIEW HANDLERS\n// ============================================================================\nfunction initPreviewHandlers() {\n    // Select all checkbox\n    if (ui.selectAllSilences) {\n        ui.selectAllSilences.addEventListener('change', () => {\n            if (ui.selectAllSilences.checked) {\n                previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n            } else {\n                selectedSilenceIndices.clear();\n            }\n            updateSelectedCount();\n            renderPreviewList();\n        });\n    }\n\n    // Apply button\n    if (ui.applyPreviewBtn) {\n        ui.applyPreviewBtn.addEventListener('click', applyPreviewAndMarkers);\n    }\n\n    // Cancel button\n    if (ui.cancelPreviewBtn) {\n        ui.cancelPreviewBtn.addEventListener('click', hidePreview);\n    }\n\n    // Build sequence button\n    if (ui.buildSequenceBtn) {\n        ui.buildSequenceBtn.addEventListener('click', buildSequence);\n    }\n\n    // Copy YouTube timestamps\n    if (ui.copyYouTubeBtn) {\n        ui.copyYouTubeBtn.addEventListener('click', copyYouTubeTimestamps);\n    }\n\n    // Add chapter markers\n    if (ui.addChapterMarkersBtn) {\n        ui.addChapterMarkersBtn.addEventListener('click', addChapterMarkers);\n    }\n\n    // Apply zoom markers\n    const applyZoomsBtn = document.getElementById('applyZoomsBtn');\n    if (applyZoomsBtn) {\n        applyZoomsBtn.addEventListener('click', applyZoomMarkers);\n    }\n}\n\nasync function applyPreviewAndMarkers() {\n    if (isOperationInProgress) return;\n\n    isOperationInProgress = true;\n    setStatus('Adding markers...');\n\n    try {\n        // Add silence markers\n        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n        for (const silence of selectedSilences) {\n            await jsx.call('createMarker', silence.start, 'SPLICE: Silence', silence.end - silence.start, null, 1);\n        }\n\n        // Add take markers\n        for (const take of previewTakes) {\n            await jsx.call('createMarker', take.start, take.label || `Take ${take.takeNumber}`, take.end - take.start, null, 5);\n        }\n\n        setStatus(`Added ${selectedSilences.length + previewTakes.length} markers`);\n    } catch (error) {\n        setStatus('Failed to add markers: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\nfunction hidePreview() {\n    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n    if (ui.chapterResults) ui.chapterResults.classList.add('hidden');\n    if (ui.zoomResults) ui.zoomResults.classList.add('hidden');\n    if (ui.resultsEmpty) ui.resultsEmpty.classList.remove('hidden');\n    previewSilences = [];\n    previewTakes = [];\n    selectedSilenceIndices.clear();\n}\n\nasync function buildSequence() {\n    if (isOperationInProgress) return;\n\n    isOperationInProgress = true;\n    setStatus('Building sequence...');\n\n    try {\n        const settings = getSettings();\n\n        // Ensure we have sequence info\n        if (!currentSequenceInfo) {\n            currentSequenceInfo = await jsx.call('getActiveSequence');\n        }\n\n        // Create cut list from selected silences\n        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n\n        // Calculate total duration from sequence info or last silence\n        let duration = 0;\n        if (currentSequenceInfo && currentSequenceInfo.duration) {\n            duration = currentSequenceInfo.duration;\n        } else if (previewSilences.length > 0) {\n            const lastSilence = previewSilences[previewSilences.length - 1];\n            duration = lastSilence.end + 10; // Add buffer\n        }\n\n        // Call backend to generate cut list\n        const cutListResponse = await fetchWithTimeout(\n            `${getBackendUrl()}/cut-list`,\n            {\n                method: 'POST',\n                headers: getAuthHeaders(),\n                body: JSON.stringify({\n                    sourceName: currentSequenceInfo?.name || 'Untitled Sequence',\n                    sourcePath: currentSequenceInfo?.treePath || currentSequenceInfo?.name || 'Untitled',\n                    duration: duration,\n                    silences: selectedSilences,\n                    takes: previewTakes,\n                    enableTakes: settings.enableTakesDetection,\n                    jCutOffset: settings.enableJCut ? settings.jcutLeadIn : 0,\n                    lCutOffset: settings.enableJCut ? settings.jcutLeadOut : 0\n                })\n            }\n        );\n\n        if (!cutListResponse.ok) {\n            throw new Error(await parseErrorResponse(cutListResponse));\n        }\n\n        const cutList = await cutListResponse.json();\n\n        // Build sequence via JSX\n        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));\n\n        if (result && result.success) {\n            setStatus(`Built sequence: ${result.sequenceName}`);\n            hidePreview();\n        } else {\n            throw new Error(result?.error || 'Build failed');\n        }\n    } catch (error) {\n        setStatus('Build failed: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\nfunction copyYouTubeTimestamps() {\n    if (currentChapters.length === 0) return;\n\n    const timestamps = currentChapters.map(ch =>\n        `${formatTime(ch.startTime)} ${ch.title}`\n    ).join('\\n');\n\n    navigator.clipboard.writeText(timestamps).then(() => {\n        setStatus('Copied YouTube timestamps');\n    }).catch(() => {\n        setStatus('Failed to copy', true);\n    });\n}\n\nasync function addChapterMarkers() {\n    if (isOperationInProgress || currentChapters.length === 0) return;\n\n    isOperationInProgress = true;\n    setStatus('Adding chapter markers...');\n\n    try {\n        for (const chapter of currentChapters) {\n            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);\n        }\n        setStatus(`Added ${currentChapters.length} chapter markers`);\n    } catch (error) {\n        setStatus('Failed to add markers: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\n/**\n * Apply zoom point markers to the timeline\n */\nasync function applyZoomMarkers() {\n    if (isOperationInProgress || currentZooms.length === 0) return;\n\n    isOperationInProgress = true;\n    setStatus('Adding zoom markers...');\n\n    try {\n        for (const zoom of currentZooms) {\n            // Create a marker for each zoom point with zoom intensity info\n            const comment = `Zoom ${zoom.intensity || 'medium'} - ${zoom.reason || 'emphasis'}`;\n            await jsx.call('createMarker', zoom.time, 'SPLICE: Zoom', 0.5, comment, 3);\n        }\n        setStatus(`Added ${currentZooms.length} zoom markers`);\n    } catch (error) {\n        setStatus('Failed to add zoom markers: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\n// ============================================================================\n// MODALS\n// ============================================================================\nfunction initModals() {\n    // Settings modal\n    if (ui.settingsBtn && ui.settingsModal) {\n        ui.settingsBtn.addEventListener('click', () => {\n            ui.settingsModal.classList.remove('hidden');\n            // Sync remember options checkbox with current settings\n            const rememberOptions = document.getElementById('rememberOptions');\n            if (rememberOptions) {\n                rememberOptions.checked = getSettings().rememberOptions;\n            }\n        });\n    }\n\n    if (ui.closeSettingsBtn && ui.settingsModal) {\n        ui.closeSettingsBtn.addEventListener('click', () => {\n            ui.settingsModal.classList.add('hidden');\n        });\n    }\n\n    // Remember options checkbox\n    const rememberOptions = document.getElementById('rememberOptions');\n    if (rememberOptions) {\n        rememberOptions.addEventListener('change', () => {\n            saveSettings({ rememberOptions: rememberOptions.checked });\n            if (rememberOptions.checked) {\n                setStatus('Options will be remembered');\n            } else {\n                setStatus('Options will reset to defaults');\n            }\n        });\n    }\n\n    // Credit badge click handler (handles login, retry, and refresh)\n    if (ui.creditBadge) {\n        ui.creditBadge.addEventListener('click', () => {\n            // Use the centralized handler from credits.js\n            if (typeof handleCreditBadgeClick === 'function') {\n                handleCreditBadgeClick();\n            } else {\n                // Fallback if credits.js not loaded yet\n                const settings = getSettings();\n                if (!settings.customerId) {\n                    showLoginModal();\n                }\n            }\n        });\n    }\n\n    if (ui.closeLoginBtn && ui.loginModal) {\n        ui.closeLoginBtn.addEventListener('click', () => {\n            ui.loginModal.classList.add('hidden');\n        });\n    }\n\n    // Note: saveLoginBtn handler is registered in initLoginModal() (config.js)\n    // to avoid duplicate event listeners\n\n    // License lookup button\n    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n    if (lookupLicenseBtn) {\n        lookupLicenseBtn.addEventListener('click', lookupLicense);\n    }\n\n    // Close modals on backdrop click\n    document.querySelectorAll('.modal').forEach(modal => {\n        modal.addEventListener('click', (e) => {\n            if (e.target === modal) {\n                modal.classList.add('hidden');\n            }\n        });\n    });\n}\n\nfunction showLoginModal() {\n    if (ui.loginModal) ui.loginModal.classList.remove('hidden');\n}\n\n/**\n * Show upgrade modal when user tries to access a gated feature\n * @param {string} featureName - Display name of the feature\n * @param {string} requiredTier - Required tier (Pro, Team)\n */\nfunction showUpgradeModal(featureName, requiredTier = 'Pro') {\n    const modal = document.getElementById('upgradeModal');\n    const featureText = document.getElementById('upgradeFeatureName');\n    const tierText = document.getElementById('upgradeRequiredTier');\n\n    if (featureText) {\n        featureText.textContent = featureName;\n    }\n    if (tierText) {\n        tierText.textContent = requiredTier;\n    }\n    if (modal) {\n        modal.classList.remove('hidden');\n    }\n}\n\n/**\n * Close the upgrade modal\n */\nfunction closeUpgradeModal() {\n    const modal = document.getElementById('upgradeModal');\n    if (modal) {\n        modal.classList.add('hidden');\n    }\n}\n\n// Expose showUpgradeModal and closeUpgradeModal globally for feature modules\nwindow.showUpgradeModal = showUpgradeModal;\nwindow.closeUpgradeModal = closeUpgradeModal;\n\nasync function activateLicense() {\n    if (!ui.licenseKeyInput) return;\n\n    const licenseKey = ui.licenseKeyInput.value.trim();\n    if (!licenseKey) {\n        setStatus('Please enter a license key', true);\n        return;\n    }\n\n    try {\n        const response = await fetchWithTimeout(\n            `${getBackendUrl()}/license/activate`,\n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ key: licenseKey })\n            }\n        );\n\n        if (!response.ok) {\n            throw new Error(await parseErrorResponse(response));\n        }\n\n        const data = await response.json();\n        saveSettings({\n            customerId: data.customerId,\n            licenseKey: licenseKey\n        });\n\n        if (ui.loginModal) ui.loginModal.classList.add('hidden');\n        setStatus('License activated');\n        updateCredits();\n    } catch (error) {\n        setStatus('Activation failed: ' + error.message, true);\n    }\n}\n\n/**\n * Look up license key by email address\n */\nasync function lookupLicense() {\n    const lookupEmailInput = document.getElementById('lookupEmailInput');\n    const licenseKeyInput = document.getElementById('licenseKeyInput');\n\n    if (!lookupEmailInput) return;\n\n    const email = lookupEmailInput.value.trim().toLowerCase();\n    if (!email) {\n        setStatus('Please enter your email address', true);\n        return;\n    }\n\n    // Basic email validation\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n        setStatus('Please enter a valid email address', true);\n        return;\n    }\n\n    const lookupBtn = document.getElementById('lookupLicenseBtn');\n    if (lookupBtn) {\n        lookupBtn.disabled = true;\n        lookupBtn.textContent = 'Looking up...';\n    }\n\n    try {\n        const response = await fetchWithTimeout(\n            `${getBackendUrl()}/license/lookup`,\n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ email })\n            },\n            30000\n        );\n\n        const result = await response.json();\n\n        // Note: For security, the backend does NOT return the license key directly.\n        // It sends the key via email to prevent enumeration attacks.\n        if (result.success) {\n            setStatus(result.message || 'If a license exists, it has been sent to your email.');\n        } else {\n            setStatus(result.error || 'Lookup failed. Please try again.', true);\n        }\n    } catch (error) {\n        setStatus('Lookup failed: ' + error.message, true);\n    } finally {\n        if (lookupBtn) {\n            lookupBtn.disabled = false;\n            lookupBtn.textContent = 'Lookup';\n        }\n    }\n}\n\n// ============================================================================\n// CREDITS\n// ============================================================================\nfunction initCredits() {\n    updateCredits();\n}\n\nasync function updateCredits() {\n    if (!ui.creditBadge) return;\n\n    const settings = getSettings();\n    if (!settings.customerId) {\n        ui.creditBadge.className = 'credit-badge login';\n        ui.creditBadge.textContent = 'Login';\n        ui.creditBadge.style.display = 'flex';\n        return;\n    }\n\n    try {\n        const response = await fetchWithTimeout(\n            `${getBackendUrl()}/credits`,\n            {\n                method: 'GET',\n                headers: getAuthHeaders()\n            }\n        );\n\n        if (response.ok) {\n            const data = await response.json();\n            // Backend returns hoursRemaining (not remainingMinutes)\n            const hours = (data.hoursRemaining || 0).toFixed(1);\n            ui.creditBadge.textContent = `${hours}h`;\n            // Low warning when less than 1 hour remaining\n            ui.creditBadge.className = data.hoursRemaining < 1 ? 'credit-badge low' : 'credit-badge ok';\n            ui.creditBadge.style.display = 'flex';\n        } else {\n            ui.creditBadge.className = 'credit-badge error';\n            ui.creditBadge.textContent = 'Error';\n            ui.creditBadge.style.display = 'flex';\n        }\n    } catch {\n        ui.creditBadge.className = 'credit-badge error';\n        ui.creditBadge.textContent = 'Offline';\n        ui.creditBadge.style.display = 'flex';\n    }\n}\n\n// ============================================================================\n// HELP BUTTON\n// ============================================================================\nfunction initHelpButton() {\n    const helpBtn = document.getElementById('helpBtn');\n    if (helpBtn) {\n        helpBtn.addEventListener('click', () => {\n            setStatus('Silence: removes quiet gaps | Takes: detects repeated content | Chapters: AI topic segmentation');\n        });\n    }\n}\n\n// Export for debugging\nwindow.spliceDebug = {\n    getState: () => ({\n        silences: previewSilences,\n        takes: previewTakes,\n        chapters: currentChapters,\n        zooms: currentZooms,\n        selected: Array.from(selectedSilenceIndices)\n    }),\n    jsx,\n    runDetection\n};\n","numLines":1553,"startLine":1,"totalLines":1553}}}
{"parentUuid":"6cd4152d-ff5e-4454-b4bb-7f38e9ebf91a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Jdt4c3f3JnM9WYDY8KmK82","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also check the CSRF middleware and the credits.js file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1217,"cache_creation_input_tokens":44798,"cache_read_input_tokens":55661,"cache_creation":{"ephemeral_5m_input_tokens":44798,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2VdaTHSbsfs1RLCKzLW","type":"assistant","uuid":"d9a72f95-78a9-4c8d-af5f-a6e57b995f42","timestamp":"2026-01-11T23:55:51.410Z"}
{"parentUuid":"d9a72f95-78a9-4c8d-af5f-a6e57b995f42","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Jdt4c3f3JnM9WYDY8KmK82","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FEQxumsYQdnLgPmCnNtrUH","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1217,"cache_creation_input_tokens":44798,"cache_read_input_tokens":55661,"cache_creation":{"ephemeral_5m_input_tokens":44798,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2VdaTHSbsfs1RLCKzLW","type":"assistant","uuid":"34b5614c-d731-457b-9d70-9f6e16cad6fe","timestamp":"2026-01-11T23:55:52.012Z"}
{"parentUuid":"34b5614c-d731-457b-9d70-9f6e16cad6fe","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Jdt4c3f3JnM9WYDY8KmK82","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011c6YD5FpTFevDgMH87kh12","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1217,"cache_creation_input_tokens":44798,"cache_read_input_tokens":55661,"cache_creation":{"ephemeral_5m_input_tokens":44798,"ephemeral_1h_input_tokens":0},"output_tokens":145,"service_tier":"standard"}},"requestId":"req_011CX2VdaTHSbsfs1RLCKzLW","type":"assistant","uuid":"7e9204ba-84f9-4033-93d8-a22a17c13516","timestamp":"2026-01-11T23:55:52.532Z"}
{"parentUuid":"7e9204ba-84f9-4033-93d8-a22a17c13516","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FEQxumsYQdnLgPmCnNtrUH","type":"tool_result","content":"     1→/**\n     2→ * CSRF Protection Middleware\n     3→ *\n     4→ * Implements double-submit cookie pattern for CSRF protection.\n     5→ * Works with stateless JWT authentication.\n     6→ *\n     7→ * How it works:\n     8→ * 1. Client requests a CSRF token via GET /auth/csrf-token\n     9→ * 2. Server generates a cryptographically random token\n    10→ * 3. Server sends token in both:\n    11→ *    - Response body (for JavaScript to read)\n    12→ *    - HttpOnly cookie (for automatic submission)\n    13→ * 4. Client includes token in X-CSRF-Token header on state-changing requests\n    14→ * 5. Server validates header token matches cookie token\n    15→ */\n    16→\n    17→const crypto = require('crypto');\n    18→\n    19→// CSRF Configuration\n    20→const CSRF_TOKEN_LENGTH = 32; // 256 bits\n    21→const CSRF_COOKIE_NAME = 'splice_csrf';\n    22→const CSRF_HEADER_NAME = 'x-csrf-token';\n    23→const CSRF_TOKEN_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n    24→\n    25→// Check if running in production\n    26→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    27→\n    28→/**\n    29→ * Generate a cryptographically secure CSRF token\n    30→ * @returns {string} Hex-encoded random token\n    31→ */\n    32→function generateCsrfToken() {\n    33→  return crypto.randomBytes(CSRF_TOKEN_LENGTH).toString('hex');\n    34→}\n    35→\n    36→/**\n    37→ * Constant-time comparison to prevent timing attacks\n    38→ * @param {string} a - First string\n    39→ * @param {string} b - Second string\n    40→ * @returns {boolean} True if strings are equal\n    41→ */\n    42→function safeCompare(a, b) {\n    43→  if (!a || !b || typeof a !== 'string' || typeof b !== 'string') {\n    44→    return false;\n    45→  }\n    46→\n    47→  // Use crypto.timingSafeEqual for constant-time comparison\n    48→  const bufA = Buffer.from(a);\n    49→  const bufB = Buffer.from(b);\n    50→\n    51→  if (bufA.length !== bufB.length) {\n    52→    return false;\n    53→  }\n    54→\n    55→  return crypto.timingSafeEqual(bufA, bufB);\n    56→}\n    57→\n    58→/**\n    59→ * Get cookie options for CSRF token\n    60→ * @returns {Object} Cookie configuration\n    61→ */\n    62→function getCsrfCookieOptions() {\n    63→  return {\n    64→    httpOnly: true,\n    65→    secure: isProduction, // Only secure in production (HTTPS)\n    66→    sameSite: 'strict', // Strict same-site policy for CSRF protection\n    67→    maxAge: CSRF_TOKEN_EXPIRY,\n    68→    path: '/',\n    69→    // Domain is omitted to default to the current domain\n    70→  };\n    71→}\n    72→\n    73→/**\n    74→ * Handler to generate and return a CSRF token\n    75→ * Should be mounted as GET /auth/csrf-token\n    76→ *\n    77→ * @param {Request} req - Express request\n    78→ * @param {Response} res - Express response\n    79→ */\n    80→function csrfTokenHandler(req, res) {\n    81→  const token = generateCsrfToken();\n    82→\n    83→  // Set the token in an HttpOnly cookie\n    84→  res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n    85→\n    86→  // Also return token in response body for JavaScript to use\n    87→  // The client will send this in the X-CSRF-Token header\n    88→  res.json({\n    89→    success: true,\n    90→    csrfToken: token,\n    91→    expiresIn: CSRF_TOKEN_EXPIRY / 1000 // seconds\n    92→  });\n    93→\n    94→  console.log('[CSRF] Token generated for request');\n    95→}\n    96→\n    97→/**\n    98→ * Middleware to validate CSRF token on state-changing requests\n    99→ * Checks that the X-CSRF-Token header matches the cookie value\n   100→ *\n   101→ * @param {Request} req - Express request\n   102→ * @param {Response} res - Express response\n   103→ * @param {Function} next - Next middleware\n   104→ */\n   105→function validateCsrfToken(req, res, next) {\n   106→  // Skip CSRF validation for safe methods (GET, HEAD, OPTIONS)\n   107→  const safeMethods = ['GET', 'HEAD', 'OPTIONS'];\n   108→  if (safeMethods.includes(req.method)) {\n   109→    return next();\n   110→  }\n   111→\n   112→  // Get token from header\n   113→  const headerToken = req.headers[CSRF_HEADER_NAME];\n   114→\n   115→  // Get token from cookie\n   116→  const cookieToken = req.cookies?.[CSRF_COOKIE_NAME];\n   117→\n   118→  // Validate both tokens exist\n   119→  if (!headerToken) {\n   120→    console.warn('[CSRF] Missing CSRF token in header');\n   121→    return res.status(403).json({\n   122→      error: 'CSRF token missing',\n   123→      message: 'Please refresh the page and try again'\n   124→    });\n   125→  }\n   126→\n   127→  if (!cookieToken) {\n   128→    console.warn('[CSRF] Missing CSRF cookie');\n   129→    return res.status(403).json({\n   130→      error: 'CSRF validation failed',\n   131→      message: 'Session expired. Please refresh the page and try again'\n   132→    });\n   133→  }\n   134→\n   135→  // Use constant-time comparison to prevent timing attacks\n   136→  if (!safeCompare(headerToken, cookieToken)) {\n   137→    console.warn('[CSRF] Token mismatch - possible CSRF attack');\n   138→    return res.status(403).json({\n   139→      error: 'CSRF validation failed',\n   140→      message: 'Security validation failed. Please refresh the page and try again'\n   141→    });\n   142→  }\n   143→\n   144→  // Token is valid\n   145→  next();\n   146→}\n   147→\n   148→/**\n   149→ * Conditional CSRF validation middleware\n   150→ * Skips validation for certain routes (e.g., webhooks, public endpoints)\n   151→ *\n   152→ * @param {Object} options - Configuration options\n   153→ * @param {string[]} options.skipRoutes - Array of route patterns to skip\n   154→ * @returns {Function} Middleware function\n   155→ */\n   156→function csrfProtection(options = {}) {\n   157→  const { skipRoutes = [] } = options;\n   158→\n   159→  // Default routes to skip CSRF validation\n   160→  const defaultSkipRoutes = [\n   161→    '/webhooks/', // Stripe webhooks use their own signature verification\n   162→    '/health', // Health checks are public\n   163→    '/api-info', // API info is public\n   164→  ];\n   165→\n   166→  const allSkipRoutes = [...defaultSkipRoutes, ...skipRoutes];\n   167→\n   168→  return (req, res, next) => {\n   169→    // Check if this route should skip CSRF validation\n   170→    const shouldSkip = allSkipRoutes.some(route => req.path.startsWith(route));\n   171→\n   172→    if (shouldSkip) {\n   173→      return next();\n   174→    }\n   175→\n   176→    // Apply CSRF validation\n   177→    return validateCsrfToken(req, res, next);\n   178→  };\n   179→}\n   180→\n   181→/**\n   182→ * Middleware to ensure CSRF cookie exists\n   183→ * Sets a new cookie if one doesn't exist\n   184→ * Useful for ensuring cookie is set before any form is shown\n   185→ *\n   186→ * @param {Request} req - Express request\n   187→ * @param {Response} res - Express response\n   188→ * @param {Function} next - Next middleware\n   189→ */\n   190→function ensureCsrfCookie(req, res, next) {\n   191→  // Check if cookie already exists\n   192→  if (!req.cookies?.[CSRF_COOKIE_NAME]) {\n   193→    const token = generateCsrfToken();\n   194→    res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n   195→  }\n   196→  next();\n   197→}\n   198→\n   199→module.exports = {\n   200→  generateCsrfToken,\n   201→  csrfTokenHandler,\n   202→  validateCsrfToken,\n   203→  csrfProtection,\n   204→  ensureCsrfCookie,\n   205→  // Constants for external use\n   206→  CSRF_COOKIE_NAME,\n   207→  CSRF_HEADER_NAME,\n   208→  CSRF_TOKEN_EXPIRY\n   209→};\n   210→\n\n</system-reminder>\n"}]},"uuid":"072ec280-4252-4dbe-8161-7264f5bda14d","timestamp":"2026-01-11T23:55:52.564Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js","content":"/**\n * CSRF Protection Middleware\n *\n * Implements double-submit cookie pattern for CSRF protection.\n * Works with stateless JWT authentication.\n *\n * How it works:\n * 1. Client requests a CSRF token via GET /auth/csrf-token\n * 2. Server generates a cryptographically random token\n * 3. Server sends token in both:\n *    - Response body (for JavaScript to read)\n *    - HttpOnly cookie (for automatic submission)\n * 4. Client includes token in X-CSRF-Token header on state-changing requests\n * 5. Server validates header token matches cookie token\n */\n\nconst crypto = require('crypto');\n\n// CSRF Configuration\nconst CSRF_TOKEN_LENGTH = 32; // 256 bits\nconst CSRF_COOKIE_NAME = 'splice_csrf';\nconst CSRF_HEADER_NAME = 'x-csrf-token';\nconst CSRF_TOKEN_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n/**\n * Generate a cryptographically secure CSRF token\n * @returns {string} Hex-encoded random token\n */\nfunction generateCsrfToken() {\n  return crypto.randomBytes(CSRF_TOKEN_LENGTH).toString('hex');\n}\n\n/**\n * Constant-time comparison to prevent timing attacks\n * @param {string} a - First string\n * @param {string} b - Second string\n * @returns {boolean} True if strings are equal\n */\nfunction safeCompare(a, b) {\n  if (!a || !b || typeof a !== 'string' || typeof b !== 'string') {\n    return false;\n  }\n\n  // Use crypto.timingSafeEqual for constant-time comparison\n  const bufA = Buffer.from(a);\n  const bufB = Buffer.from(b);\n\n  if (bufA.length !== bufB.length) {\n    return false;\n  }\n\n  return crypto.timingSafeEqual(bufA, bufB);\n}\n\n/**\n * Get cookie options for CSRF token\n * @returns {Object} Cookie configuration\n */\nfunction getCsrfCookieOptions() {\n  return {\n    httpOnly: true,\n    secure: isProduction, // Only secure in production (HTTPS)\n    sameSite: 'strict', // Strict same-site policy for CSRF protection\n    maxAge: CSRF_TOKEN_EXPIRY,\n    path: '/',\n    // Domain is omitted to default to the current domain\n  };\n}\n\n/**\n * Handler to generate and return a CSRF token\n * Should be mounted as GET /auth/csrf-token\n *\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n */\nfunction csrfTokenHandler(req, res) {\n  const token = generateCsrfToken();\n\n  // Set the token in an HttpOnly cookie\n  res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n\n  // Also return token in response body for JavaScript to use\n  // The client will send this in the X-CSRF-Token header\n  res.json({\n    success: true,\n    csrfToken: token,\n    expiresIn: CSRF_TOKEN_EXPIRY / 1000 // seconds\n  });\n\n  console.log('[CSRF] Token generated for request');\n}\n\n/**\n * Middleware to validate CSRF token on state-changing requests\n * Checks that the X-CSRF-Token header matches the cookie value\n *\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n * @param {Function} next - Next middleware\n */\nfunction validateCsrfToken(req, res, next) {\n  // Skip CSRF validation for safe methods (GET, HEAD, OPTIONS)\n  const safeMethods = ['GET', 'HEAD', 'OPTIONS'];\n  if (safeMethods.includes(req.method)) {\n    return next();\n  }\n\n  // Get token from header\n  const headerToken = req.headers[CSRF_HEADER_NAME];\n\n  // Get token from cookie\n  const cookieToken = req.cookies?.[CSRF_COOKIE_NAME];\n\n  // Validate both tokens exist\n  if (!headerToken) {\n    console.warn('[CSRF] Missing CSRF token in header');\n    return res.status(403).json({\n      error: 'CSRF token missing',\n      message: 'Please refresh the page and try again'\n    });\n  }\n\n  if (!cookieToken) {\n    console.warn('[CSRF] Missing CSRF cookie');\n    return res.status(403).json({\n      error: 'CSRF validation failed',\n      message: 'Session expired. Please refresh the page and try again'\n    });\n  }\n\n  // Use constant-time comparison to prevent timing attacks\n  if (!safeCompare(headerToken, cookieToken)) {\n    console.warn('[CSRF] Token mismatch - possible CSRF attack');\n    return res.status(403).json({\n      error: 'CSRF validation failed',\n      message: 'Security validation failed. Please refresh the page and try again'\n    });\n  }\n\n  // Token is valid\n  next();\n}\n\n/**\n * Conditional CSRF validation middleware\n * Skips validation for certain routes (e.g., webhooks, public endpoints)\n *\n * @param {Object} options - Configuration options\n * @param {string[]} options.skipRoutes - Array of route patterns to skip\n * @returns {Function} Middleware function\n */\nfunction csrfProtection(options = {}) {\n  const { skipRoutes = [] } = options;\n\n  // Default routes to skip CSRF validation\n  const defaultSkipRoutes = [\n    '/webhooks/', // Stripe webhooks use their own signature verification\n    '/health', // Health checks are public\n    '/api-info', // API info is public\n  ];\n\n  const allSkipRoutes = [...defaultSkipRoutes, ...skipRoutes];\n\n  return (req, res, next) => {\n    // Check if this route should skip CSRF validation\n    const shouldSkip = allSkipRoutes.some(route => req.path.startsWith(route));\n\n    if (shouldSkip) {\n      return next();\n    }\n\n    // Apply CSRF validation\n    return validateCsrfToken(req, res, next);\n  };\n}\n\n/**\n * Middleware to ensure CSRF cookie exists\n * Sets a new cookie if one doesn't exist\n * Useful for ensuring cookie is set before any form is shown\n *\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n * @param {Function} next - Next middleware\n */\nfunction ensureCsrfCookie(req, res, next) {\n  // Check if cookie already exists\n  if (!req.cookies?.[CSRF_COOKIE_NAME]) {\n    const token = generateCsrfToken();\n    res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n  }\n  next();\n}\n\nmodule.exports = {\n  generateCsrfToken,\n  csrfTokenHandler,\n  validateCsrfToken,\n  csrfProtection,\n  ensureCsrfCookie,\n  // Constants for external use\n  CSRF_COOKIE_NAME,\n  CSRF_HEADER_NAME,\n  CSRF_TOKEN_EXPIRY\n};\n","numLines":210,"startLine":1,"totalLines":210}}}
{"parentUuid":"072ec280-4252-4dbe-8161-7264f5bda14d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011c6YD5FpTFevDgMH87kh12","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Credits Display Module\n     3→ *\n     4→ * Fetches and displays user's remaining hours from the billing backend.\n     5→ * Port of UXP credits.js for CEP compatibility.\n     6→ */\n     7→\n     8→// Track fetch error state for retry UI\n     9→let lastCreditsError = null;\n    10→let creditsRetryCount = 0;\n    11→const MAX_CREDITS_RETRIES = 3;\n    12→\n    13→// Store current credits globally for access checks\n    14→let currentCredits = null;\n    15→\n    16→// Store interval reference for cleanup\n    17→let creditsRefreshInterval = null;\n    18→\n    19→/**\n    20→ * Fetch user's credit balance from backend\n    21→ * @returns {Promise<Object | null>} Credit data including isolation hours, or error object\n    22→ */\n    23→async function fetchCredits() {\n    24→    const settings = getSettings();\n    25→    const customerId = settings.customerId;\n    26→\n    27→    if (!customerId) {\n    28→        console.log('[SPLICE] No customerId configured - credits display disabled');\n    29→        lastCreditsError = null;\n    30→        return null;\n    31→    }\n    32→\n    33→    try {\n    34→        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    35→            method: 'GET',\n    36→            headers: {\n    37→                'x-stripe-customer-id': customerId\n    38→            }\n    39→        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n    40→\n    41→        if (!response.ok) {\n    42→            const errorMsg = await parseErrorResponse(response);\n    43→            console.error('[SPLICE] Credits fetch failed:', errorMsg);\n    44→            lastCreditsError = errorMsg;\n    45→            return { _error: true, message: errorMsg };\n    46→        }\n    47→\n    48→        const data = await response.json();\n    49→        lastCreditsError = null;\n    50→        creditsRetryCount = 0;\n    51→        return {\n    52→            hoursRemaining: data.hoursRemaining || 0,\n    53→            hoursTotal: data.hoursTotal || 0,\n    54→            tierName: data.tierName || 'Free',\n    55→            tier: data.tier || 'starter',\n    56→            // Isolation hours\n    57→            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n    58→            isolationHoursTotal: data.isolationHoursTotal || 0,\n    59→            hasIsolationAccess: data.hasIsolationAccess || false,\n    60→            isolationOverageRate: data.isolationOverageRate || 0.08,\n    61→            // Feature access\n    62→            featureAccess: data.featureAccess || [],\n    63→            // Trial info\n    64→            trialDaysRemaining: data.trialDaysRemaining || null,\n    65→            isOnTrial: data.isOnTrial || false\n    66→        };\n    67→    } catch (err) {\n    68→        console.error('[SPLICE] Credits fetch error:', err);\n    69→        lastCreditsError = err.message || 'Connection failed';\n    70→        return { _error: true, message: lastCreditsError };\n    71→    }\n    72→}\n    73→\n    74→/**\n    75→ * Clear the credits cache (call on logout)\n    76→ */\n    77→function clearCreditsCache() {\n    78→    currentCredits = null;\n    79→    lastCreditsError = null;\n    80→    creditsRetryCount = 0;\n    81→    console.log('[SPLICE] Credits cache cleared');\n    82→}\n    83→\n    84→/**\n    85→ * Update the credit display in the UI\n    86→ * @param {Object|null} credits - Credit data, error object, or null if unavailable\n    87→ */\n    88→function updateCreditDisplay(credits) {\n    89→    const creditBadge = document.getElementById('creditBadge');\n    90→    if (!creditBadge) return;\n    91→\n    92→    // Handle no customer ID configured\n    93→    if (!credits) {\n    94→        currentCredits = null;\n    95→        creditBadge.style.display = 'flex';\n    96→        creditBadge.textContent = 'Login';\n    97→        creditBadge.title = 'Click to enter license key';\n    98→        creditBadge.classList.remove('ok', 'low');\n    99→        creditBadge.classList.add('login');\n   100→        return;\n   101→    }\n   102→\n   103→    // Handle error state - show error badge with retry\n   104→    if (credits._error) {\n   105→        currentCredits = null;\n   106→        creditBadge.style.display = 'flex';\n   107→        creditBadge.textContent = 'Retry';\n   108→        creditBadge.title = `Error: ${credits.message}\\nClick to retry`;\n   109→        creditBadge.classList.remove('ok', 'low', 'login');\n   110→        creditBadge.classList.add('error');\n   111→        return;\n   112→    }\n   113→\n   114→    // Normal credit display\n   115→    currentCredits = credits;\n   116→    creditBadge.style.display = 'flex';\n   117→\n   118→    // Show referral promo when logged in\n   119→    const referralPromo = document.getElementById('referralPromo');\n   120→    if (referralPromo) {\n   121→        referralPromo.classList.remove('hidden');\n   122→    }\n   123→\n   124→    // Show trial status if on trial\n   125→    if (credits.isOnTrial && credits.trialDaysRemaining) {\n   126→        creditBadge.textContent = `Trial: ${credits.trialDaysRemaining}d`;\n   127→        creditBadge.classList.remove('error', 'login', 'ok', 'low');\n   128→        creditBadge.classList.add('trial');\n   129→    } else {\n   130→        creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n   131→        creditBadge.classList.remove('error', 'login', 'trial');\n   132→    }\n   133→\n   134→    // Build tooltip with isolation info if available\n   135→    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n   136→    if (credits.isOnTrial && credits.trialDaysRemaining) {\n   137→        tooltip = `Trial: ${credits.trialDaysRemaining} days remaining\\n` + tooltip;\n   138→    }\n   139→    if (credits.hasIsolationAccess) {\n   140→        tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n   141→    }\n   142→    creditBadge.title = tooltip;\n   143→\n   144→    // Color based on remaining hours\n   145→    if (credits.hoursRemaining <= 1) {\n   146→        creditBadge.classList.add('low');\n   147→        creditBadge.classList.remove('ok');\n   148→    } else {\n   149→        creditBadge.classList.add('ok');\n   150→        creditBadge.classList.remove('low');\n   151→    }\n   152→\n   153→    // Update isolation checkbox state based on tier access\n   154→    updateIsolationCheckboxState(credits);\n   155→}\n   156→\n   157→/**\n   158→ * Update the isolation checkbox based on tier access\n   159→ */\n   160→function updateIsolationCheckboxState(credits) {\n   161→    const isolatedCheckbox = document.getElementById('sourceIsolated');\n   162→    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n   163→\n   164→    if (!isolatedCheckbox) return;\n   165→\n   166→    if (!credits || !credits.hasIsolationAccess) {\n   167→        // Disable isolation for non-Pro/Team users\n   168→        isolatedCheckbox.disabled = true;\n   169→        isolatedCheckbox.checked = false;\n   170→        if (tierBadge) {\n   171→            tierBadge.textContent = 'Pro+';\n   172→            tierBadge.style.opacity = '1';\n   173→        }\n   174→    } else {\n   175→        // Enable isolation for Pro/Team users\n   176→        isolatedCheckbox.disabled = false;\n   177→        if (tierBadge) {\n   178→            // Show remaining isolation time\n   179→            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n   180→            tierBadge.textContent = `${minsRemaining} min`;\n   181→            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n   182→        }\n   183→    }\n   184→}\n   185→\n   186→/**\n   187→ * Check if user can use isolation and get cost estimate\n   188→ * @param {number} estimatedMinutes - Estimated audio duration in minutes\n   189→ * @returns {Object} Access info with allowed, message, overageCost\n   190→ */\n   191→function checkIsolationAccess(estimatedMinutes = 0) {\n   192→    if (!currentCredits) {\n   193→        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n   194→    }\n   195→\n   196→    if (!currentCredits.hasIsolationAccess) {\n   197→        return {\n   198→            allowed: false,\n   199→            message: 'Vocal isolation requires Pro or Team tier',\n   200→            upgradeRequired: true,\n   201→            overageCost: 0\n   202→        };\n   203→    }\n   204→\n   205→    const estimatedHours = estimatedMinutes / 60;\n   206→    const remaining = currentCredits.isolationHoursRemaining;\n   207→\n   208→    if (remaining >= estimatedHours) {\n   209→        return {\n   210→            allowed: true,\n   211→            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   212→            overageCost: 0\n   213→        };\n   214→    }\n   215→\n   216→    // Calculate overage\n   217→    const overageMinutes = estimatedMinutes - (remaining * 60);\n   218→    const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n   219→\n   220→    return {\n   221→        allowed: true,\n   222→        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n   223→        overageCost,\n   224→        overageMinutes\n   225→    };\n   226→}\n   227→\n   228→/**\n   229→ * Get current credits (for access checks)\n   230→ */\n   231→function getCurrentCredits() {\n   232→    return currentCredits;\n   233→}\n   234→\n   235→/**\n   236→ * Check if user has access to a specific feature based on their tier\n   237→ * @param {string} featureName - The feature to check (e.g., 'social_reframe', 'text_editing', 'multitrack')\n   238→ * @returns {boolean} - True if user has access\n   239→ */\n   240→function hasFeatureAccess(featureName) {\n   241→    if (!currentCredits || !currentCredits.featureAccess) {\n   242→        return false; // Not logged in = no premium features\n   243→    }\n   244→    return currentCredits.featureAccess.includes(featureName);\n   245→}\n   246→\n   247→/**\n   248→ * Get the required tier for a feature\n   249→ * @param {string} featureName - The feature name\n   250→ * @returns {string} - Required tier name\n   251→ */\n   252→function getRequiredTier(featureName) {\n   253→    const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n   254→    const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n   255→\n   256→    if (teamOnlyFeatures.includes(featureName)) {\n   257→        return 'Team';\n   258→    } else if (proFeatures.includes(featureName)) {\n   259→        return 'Pro';\n   260→    }\n   261→    return 'Starter';\n   262→}\n   263→\n   264→/**\n   265→ * Initialize credits display\n   266→ * Fetches credits on load and sets up periodic refresh\n   267→ */\n   268→async function initCredits() {\n   269→    // Clear any existing interval to prevent duplicates\n   270→    if (creditsRefreshInterval) {\n   271→        clearInterval(creditsRefreshInterval);\n   272→    }\n   273→\n   274→    // Initial fetch\n   275→    const credits = await fetchCredits();\n   276→    updateCreditDisplay(credits);\n   277→\n   278→    // Refresh credits every 5 minutes\n   279→    creditsRefreshInterval = setInterval(async () => {\n   280→        const refreshedCredits = await fetchCredits();\n   281→        updateCreditDisplay(refreshedCredits);\n   282→    }, 5 * 60 * 1000);\n   283→}\n   284→\n   285→/**\n   286→ * Cleanup credits module - call on plugin unload\n   287→ */\n   288→function cleanupCredits() {\n   289→    if (creditsRefreshInterval) {\n   290→        clearInterval(creditsRefreshInterval);\n   291→        creditsRefreshInterval = null;\n   292→    }\n   293→}\n   294→\n   295→/**\n   296→ * Manually refresh credits (e.g., after a processing operation)\n   297→ */\n   298→async function refreshCredits() {\n   299→    const credits = await fetchCredits();\n   300→    updateCreditDisplay(credits);\n   301→    return credits;\n   302→}\n   303→\n   304→/**\n   305→ * Retry fetching credits with exponential backoff\n   306→ * Called when user clicks the \"Retry\" badge\n   307→ */\n   308→async function retryFetchCredits() {\n   309→    if (creditsRetryCount >= MAX_CREDITS_RETRIES) {\n   310→        console.warn('[SPLICE] Max retry attempts reached for credits fetch');\n   311→        updateCreditDisplay({\n   312→            _error: true,\n   313→            message: 'Max retries exceeded. Check your connection and try again later.'\n   314→        });\n   315→        creditsRetryCount = 0; // Reset for next attempt\n   316→        return null;\n   317→    }\n   318→\n   319→    creditsRetryCount++;\n   320→    console.log(`[SPLICE] Retrying credits fetch (attempt ${creditsRetryCount}/${MAX_CREDITS_RETRIES})`);\n   321→\n   322→    // Exponential backoff: 1s, 2s, 4s\n   323→    const delay = Math.pow(2, creditsRetryCount - 1) * 1000;\n   324→\n   325→    // Show retrying state\n   326→    const creditBadge = document.getElementById('creditBadge');\n   327→    if (creditBadge) {\n   328→        creditBadge.textContent = `Retry ${creditsRetryCount}...`;\n   329→        creditBadge.classList.add('retrying');\n   330→    }\n   331→\n   332→    await new Promise(resolve => setTimeout(resolve, delay));\n   333→\n   334→    const credits = await fetchCredits();\n   335→\n   336→    if (creditBadge) {\n   337→        creditBadge.classList.remove('retrying');\n   338→    }\n   339→\n   340→    updateCreditDisplay(credits);\n   341→    return credits;\n   342→}\n   343→\n   344→/**\n   345→ * Handle click on credit badge\n   346→ * - If error state: retry fetching\n   347→ * - If login state: open login modal\n   348→ * - Otherwise: refresh credits\n   349→ */\n   350→function handleCreditBadgeClick() {\n   351→    const creditBadge = document.getElementById('creditBadge');\n   352→    if (!creditBadge) return;\n   353→\n   354→    if (creditBadge.classList.contains('error')) {\n   355→        retryFetchCredits();\n   356→    } else if (creditBadge.classList.contains('login')) {\n   357→        // Open login modal (handled in main.js)\n   358→        const loginModal = document.getElementById('loginModal');\n   359→        if (loginModal) {\n   360→            loginModal.classList.remove('hidden');\n   361→        }\n   362→    } else {\n   363→        // Normal state - just refresh\n   364→        refreshCredits();\n   365→    }\n   366→}\n   367→\n   368→// Export for window access\n   369→window.fetchCredits = fetchCredits;\n   370→window.clearCreditsCache = clearCreditsCache;\n   371→window.updateCreditDisplay = updateCreditDisplay;\n   372→window.checkIsolationAccess = checkIsolationAccess;\n   373→window.getCurrentCredits = getCurrentCredits;\n   374→window.hasFeatureAccess = hasFeatureAccess;\n   375→window.getRequiredTier = getRequiredTier;\n   376→window.initCredits = initCredits;\n   377→window.cleanupCredits = cleanupCredits;\n   378→window.refreshCredits = refreshCredits;\n   379→window.retryFetchCredits = retryFetchCredits;\n   380→window.handleCreditBadgeClick = handleCreditBadgeClick;\n   381→\n   382→\n\n</system-reminder>\n"}]},"uuid":"34dcb55a-ba50-4bd0-9e4a-17905ff3e288","timestamp":"2026-01-11T23:55:52.564Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js","content":"/**\n * SPLICE CEP Credits Display Module\n *\n * Fetches and displays user's remaining hours from the billing backend.\n * Port of UXP credits.js for CEP compatibility.\n */\n\n// Track fetch error state for retry UI\nlet lastCreditsError = null;\nlet creditsRetryCount = 0;\nconst MAX_CREDITS_RETRIES = 3;\n\n// Store current credits globally for access checks\nlet currentCredits = null;\n\n// Store interval reference for cleanup\nlet creditsRefreshInterval = null;\n\n/**\n * Fetch user's credit balance from backend\n * @returns {Promise<Object | null>} Credit data including isolation hours, or error object\n */\nasync function fetchCredits() {\n    const settings = getSettings();\n    const customerId = settings.customerId;\n\n    if (!customerId) {\n        console.log('[SPLICE] No customerId configured - credits display disabled');\n        lastCreditsError = null;\n        return null;\n    }\n\n    try {\n        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n            method: 'GET',\n            headers: {\n                'x-stripe-customer-id': customerId\n            }\n        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n        if (!response.ok) {\n            const errorMsg = await parseErrorResponse(response);\n            console.error('[SPLICE] Credits fetch failed:', errorMsg);\n            lastCreditsError = errorMsg;\n            return { _error: true, message: errorMsg };\n        }\n\n        const data = await response.json();\n        lastCreditsError = null;\n        creditsRetryCount = 0;\n        return {\n            hoursRemaining: data.hoursRemaining || 0,\n            hoursTotal: data.hoursTotal || 0,\n            tierName: data.tierName || 'Free',\n            tier: data.tier || 'starter',\n            // Isolation hours\n            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n            isolationHoursTotal: data.isolationHoursTotal || 0,\n            hasIsolationAccess: data.hasIsolationAccess || false,\n            isolationOverageRate: data.isolationOverageRate || 0.08,\n            // Feature access\n            featureAccess: data.featureAccess || [],\n            // Trial info\n            trialDaysRemaining: data.trialDaysRemaining || null,\n            isOnTrial: data.isOnTrial || false\n        };\n    } catch (err) {\n        console.error('[SPLICE] Credits fetch error:', err);\n        lastCreditsError = err.message || 'Connection failed';\n        return { _error: true, message: lastCreditsError };\n    }\n}\n\n/**\n * Clear the credits cache (call on logout)\n */\nfunction clearCreditsCache() {\n    currentCredits = null;\n    lastCreditsError = null;\n    creditsRetryCount = 0;\n    console.log('[SPLICE] Credits cache cleared');\n}\n\n/**\n * Update the credit display in the UI\n * @param {Object|null} credits - Credit data, error object, or null if unavailable\n */\nfunction updateCreditDisplay(credits) {\n    const creditBadge = document.getElementById('creditBadge');\n    if (!creditBadge) return;\n\n    // Handle no customer ID configured\n    if (!credits) {\n        currentCredits = null;\n        creditBadge.style.display = 'flex';\n        creditBadge.textContent = 'Login';\n        creditBadge.title = 'Click to enter license key';\n        creditBadge.classList.remove('ok', 'low');\n        creditBadge.classList.add('login');\n        return;\n    }\n\n    // Handle error state - show error badge with retry\n    if (credits._error) {\n        currentCredits = null;\n        creditBadge.style.display = 'flex';\n        creditBadge.textContent = 'Retry';\n        creditBadge.title = `Error: ${credits.message}\\nClick to retry`;\n        creditBadge.classList.remove('ok', 'low', 'login');\n        creditBadge.classList.add('error');\n        return;\n    }\n\n    // Normal credit display\n    currentCredits = credits;\n    creditBadge.style.display = 'flex';\n\n    // Show referral promo when logged in\n    const referralPromo = document.getElementById('referralPromo');\n    if (referralPromo) {\n        referralPromo.classList.remove('hidden');\n    }\n\n    // Show trial status if on trial\n    if (credits.isOnTrial && credits.trialDaysRemaining) {\n        creditBadge.textContent = `Trial: ${credits.trialDaysRemaining}d`;\n        creditBadge.classList.remove('error', 'login', 'ok', 'low');\n        creditBadge.classList.add('trial');\n    } else {\n        creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n        creditBadge.classList.remove('error', 'login', 'trial');\n    }\n\n    // Build tooltip with isolation info if available\n    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n    if (credits.isOnTrial && credits.trialDaysRemaining) {\n        tooltip = `Trial: ${credits.trialDaysRemaining} days remaining\\n` + tooltip;\n    }\n    if (credits.hasIsolationAccess) {\n        tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n    }\n    creditBadge.title = tooltip;\n\n    // Color based on remaining hours\n    if (credits.hoursRemaining <= 1) {\n        creditBadge.classList.add('low');\n        creditBadge.classList.remove('ok');\n    } else {\n        creditBadge.classList.add('ok');\n        creditBadge.classList.remove('low');\n    }\n\n    // Update isolation checkbox state based on tier access\n    updateIsolationCheckboxState(credits);\n}\n\n/**\n * Update the isolation checkbox based on tier access\n */\nfunction updateIsolationCheckboxState(credits) {\n    const isolatedCheckbox = document.getElementById('sourceIsolated');\n    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n\n    if (!isolatedCheckbox) return;\n\n    if (!credits || !credits.hasIsolationAccess) {\n        // Disable isolation for non-Pro/Team users\n        isolatedCheckbox.disabled = true;\n        isolatedCheckbox.checked = false;\n        if (tierBadge) {\n            tierBadge.textContent = 'Pro+';\n            tierBadge.style.opacity = '1';\n        }\n    } else {\n        // Enable isolation for Pro/Team users\n        isolatedCheckbox.disabled = false;\n        if (tierBadge) {\n            // Show remaining isolation time\n            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n            tierBadge.textContent = `${minsRemaining} min`;\n            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n        }\n    }\n}\n\n/**\n * Check if user can use isolation and get cost estimate\n * @param {number} estimatedMinutes - Estimated audio duration in minutes\n * @returns {Object} Access info with allowed, message, overageCost\n */\nfunction checkIsolationAccess(estimatedMinutes = 0) {\n    if (!currentCredits) {\n        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n    }\n\n    if (!currentCredits.hasIsolationAccess) {\n        return {\n            allowed: false,\n            message: 'Vocal isolation requires Pro or Team tier',\n            upgradeRequired: true,\n            overageCost: 0\n        };\n    }\n\n    const estimatedHours = estimatedMinutes / 60;\n    const remaining = currentCredits.isolationHoursRemaining;\n\n    if (remaining >= estimatedHours) {\n        return {\n            allowed: true,\n            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n            overageCost: 0\n        };\n    }\n\n    // Calculate overage\n    const overageMinutes = estimatedMinutes - (remaining * 60);\n    const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n\n    return {\n        allowed: true,\n        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n        overageCost,\n        overageMinutes\n    };\n}\n\n/**\n * Get current credits (for access checks)\n */\nfunction getCurrentCredits() {\n    return currentCredits;\n}\n\n/**\n * Check if user has access to a specific feature based on their tier\n * @param {string} featureName - The feature to check (e.g., 'social_reframe', 'text_editing', 'multitrack')\n * @returns {boolean} - True if user has access\n */\nfunction hasFeatureAccess(featureName) {\n    if (!currentCredits || !currentCredits.featureAccess) {\n        return false; // Not logged in = no premium features\n    }\n    return currentCredits.featureAccess.includes(featureName);\n}\n\n/**\n * Get the required tier for a feature\n * @param {string} featureName - The feature name\n * @returns {string} - Required tier name\n */\nfunction getRequiredTier(featureName) {\n    const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n    const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n\n    if (teamOnlyFeatures.includes(featureName)) {\n        return 'Team';\n    } else if (proFeatures.includes(featureName)) {\n        return 'Pro';\n    }\n    return 'Starter';\n}\n\n/**\n * Initialize credits display\n * Fetches credits on load and sets up periodic refresh\n */\nasync function initCredits() {\n    // Clear any existing interval to prevent duplicates\n    if (creditsRefreshInterval) {\n        clearInterval(creditsRefreshInterval);\n    }\n\n    // Initial fetch\n    const credits = await fetchCredits();\n    updateCreditDisplay(credits);\n\n    // Refresh credits every 5 minutes\n    creditsRefreshInterval = setInterval(async () => {\n        const refreshedCredits = await fetchCredits();\n        updateCreditDisplay(refreshedCredits);\n    }, 5 * 60 * 1000);\n}\n\n/**\n * Cleanup credits module - call on plugin unload\n */\nfunction cleanupCredits() {\n    if (creditsRefreshInterval) {\n        clearInterval(creditsRefreshInterval);\n        creditsRefreshInterval = null;\n    }\n}\n\n/**\n * Manually refresh credits (e.g., after a processing operation)\n */\nasync function refreshCredits() {\n    const credits = await fetchCredits();\n    updateCreditDisplay(credits);\n    return credits;\n}\n\n/**\n * Retry fetching credits with exponential backoff\n * Called when user clicks the \"Retry\" badge\n */\nasync function retryFetchCredits() {\n    if (creditsRetryCount >= MAX_CREDITS_RETRIES) {\n        console.warn('[SPLICE] Max retry attempts reached for credits fetch');\n        updateCreditDisplay({\n            _error: true,\n            message: 'Max retries exceeded. Check your connection and try again later.'\n        });\n        creditsRetryCount = 0; // Reset for next attempt\n        return null;\n    }\n\n    creditsRetryCount++;\n    console.log(`[SPLICE] Retrying credits fetch (attempt ${creditsRetryCount}/${MAX_CREDITS_RETRIES})`);\n\n    // Exponential backoff: 1s, 2s, 4s\n    const delay = Math.pow(2, creditsRetryCount - 1) * 1000;\n\n    // Show retrying state\n    const creditBadge = document.getElementById('creditBadge');\n    if (creditBadge) {\n        creditBadge.textContent = `Retry ${creditsRetryCount}...`;\n        creditBadge.classList.add('retrying');\n    }\n\n    await new Promise(resolve => setTimeout(resolve, delay));\n\n    const credits = await fetchCredits();\n\n    if (creditBadge) {\n        creditBadge.classList.remove('retrying');\n    }\n\n    updateCreditDisplay(credits);\n    return credits;\n}\n\n/**\n * Handle click on credit badge\n * - If error state: retry fetching\n * - If login state: open login modal\n * - Otherwise: refresh credits\n */\nfunction handleCreditBadgeClick() {\n    const creditBadge = document.getElementById('creditBadge');\n    if (!creditBadge) return;\n\n    if (creditBadge.classList.contains('error')) {\n        retryFetchCredits();\n    } else if (creditBadge.classList.contains('login')) {\n        // Open login modal (handled in main.js)\n        const loginModal = document.getElementById('loginModal');\n        if (loginModal) {\n            loginModal.classList.remove('hidden');\n        }\n    } else {\n        // Normal state - just refresh\n        refreshCredits();\n    }\n}\n\n// Export for window access\nwindow.fetchCredits = fetchCredits;\nwindow.clearCreditsCache = clearCreditsCache;\nwindow.updateCreditDisplay = updateCreditDisplay;\nwindow.checkIsolationAccess = checkIsolationAccess;\nwindow.getCurrentCredits = getCurrentCredits;\nwindow.hasFeatureAccess = hasFeatureAccess;\nwindow.getRequiredTier = getRequiredTier;\nwindow.initCredits = initCredits;\nwindow.cleanupCredits = cleanupCredits;\nwindow.refreshCredits = refreshCredits;\nwindow.retryFetchCredits = retryFetchCredits;\nwindow.handleCreditBadgeClick = handleCreditBadgeClick;\n\n","numLines":382,"startLine":1,"totalLines":382}}}
{"parentUuid":"34dcb55a-ba50-4bd0-9e4a-17905ff3e288","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"af83142","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Cg6jpciyYxRWu5UqD2vj7c","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a comprehensive understanding of the integration. Let me compile the verification report.\n\n---\n\n# SPLICE Backend API Integration Verification Report\n\n## Overall Verdict: PASS WITH ISSUES\n\nThe CEP panel and backend API integration is largely functional with proper authentication flows, but there are some issues and inconsistencies that should be addressed.\n\n---\n\n## Requirements Checklist\n\n### API Endpoints Verification\n\n| Endpoint | Backend Status | CEP Usage Status | Verdict |\n|----------|---------------|------------------|---------|\n| POST /auth/login | Implemented | Not used directly | Warning - CEP uses /license/activate instead |\n| POST /auth/logout | Implemented with CSRF | Not implemented in CEP | Not Met |\n| POST /auth/refresh | Implemented | Not implemented in CEP | Not Met |\n| GET /auth/csrf-token | Implemented | Not used in CEP | Warning |\n| GET /credits | Implemented | Used | Met |\n| POST /silences-rms | Implemented | Used | Met |\n| POST /analyze | Implemented | Used | Met |\n| POST /profanity | Implemented | Used | Met |\n| POST /chapters | Implemented | Used | Met |\n| POST /zoom | Implemented | Used | Met |\n| POST /cut-list | Implemented | Used | Met |\n| POST /license/activate | Implemented | Used | Met |\n| POST /license/lookup | Implemented | Used | Met |\n\n### Middleware Chain Verification\n\n| Middleware | Status | Notes |\n|------------|--------|-------|\n| CSRF protection | Implemented | Double-submit cookie pattern, but CEP does not use it |\n| JWT authentication | Implemented | Full implementation with blacklist support |\n| Rate limiting | Implemented | IP-based + tiered limits, Redis-backed with fallback |\n| Input validation | Partially Implemented | Varies by endpoint |\n\n### CEP Panel Authentication Verification\n\n| Feature | Status | Notes |\n|---------|--------|-------|\n| Sends Authorization header with JWT | Not Met | Uses legacy x-stripe-customer-id header |\n| Handles token refresh | Not Met | No refresh token logic implemented |\n| Shows appropriate error messages | Met | Error handling in place |\n| Uses correct API URL (prod vs dev) | Met | Proper URL configuration with localStorage override |\n\n---\n\n## Detailed Findings\n\n### Issue 1: CEP Uses Legacy Authentication (CRITICAL)\n\n**Location:** `/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js` (lines 33-39) and `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js` (lines 275-287)\n\n**Finding:** The CEP panel uses the legacy `x-stripe-customer-id` header instead of JWT Bearer tokens.\n\n```javascript\n// credits.js line 33-39\nconst response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    method: 'GET',\n    headers: {\n        'x-stripe-customer-id': customerId  // LEGACY - should use JWT\n    }\n}, SPLICE_CONFIG.FETCH_TIMEOUT);\n```\n\n**Impact:** \n- The legacy auth is marked as DEPRECATED with sunset date 2026-04-11\n- Legacy auth is DISABLED by default in production (`ALLOW_LEGACY_AUTH` defaults to false)\n- This will cause authentication failures for CEP users in production\n\n**Backend Evidence (auth.js lines 74-92):**\n```javascript\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n}\n```\n\n**Priority:** Critical\n\n**Recommendation:**\n1. Update CEP panel to use JWT Bearer tokens obtained from `/auth/login` endpoint\n2. Store tokens securely in localStorage (the panel already has encryption helpers)\n3. Implement token refresh logic using `/auth/refresh` endpoint\n4. Add proper token expiration handling\n\n---\n\n### Issue 2: Missing Token Refresh Implementation (HIGH)\n\n**Location:** `/Users/imorgado/SPLICE/splice-cep/panel/js/main.js` and `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js`\n\n**Finding:** The CEP panel has no mechanism to refresh expired JWT tokens. If JWT authentication is implemented, tokens will expire (24h default) with no graceful refresh.\n\n**Backend Support (auth.js lines 380-425):**\n```javascript\n// POST /auth/refresh endpoint is fully implemented\nrouter.post('/refresh', async (req, res) => {\n    const { refreshToken } = req.body;\n    // ... validates refresh token and returns new access token\n});\n```\n\n**Priority:** High\n\n**Recommendation:**\n1. Store refresh token along with access token after login\n2. Implement automatic token refresh before access token expires\n3. Add 401 response handler that attempts token refresh before showing error\n\n---\n\n### Issue 3: CSRF Protection Not Used by CEP (MEDIUM)\n\n**Location:** `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js`\n\n**Finding:** The backend implements CSRF protection for state-changing endpoints, but CEP panel does not fetch or send CSRF tokens.\n\n**Backend Evidence (auth.js lines 434, 492, 557):**\n```javascript\n// Logout requires CSRF\nrouter.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {...});\n\n// Email verification requires CSRF  \nrouter.post('/send-verification', emailVerificationLimiter, validateCsrfToken, async (req, res) => {...});\nrouter.post('/verify-email', emailVerificationLimiter, validateCsrfToken, async (req, res) => {...});\n```\n\n**Note:** The `/auth/login` endpoint intentionally does NOT require CSRF (correct design - license key auth is not vulnerable to CSRF).\n\n**Priority:** Medium\n\n**Recommendation:**\n1. For CEP panel, CSRF may not be necessary due to the plugin's sandboxed environment\n2. However, if logout functionality is added, CSRF token handling should be implemented\n3. Document this design decision\n\n---\n\n### Issue 4: getAuthHeaders() Returns Wrong Headers (HIGH)\n\n**Location:** `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js` (lines 275-287)\n\n**Finding:** The `getAuthHeaders()` function returns legacy headers instead of JWT:\n\n```javascript\nfunction getAuthHeaders() {\n    const headers = { 'Content-Type': 'application/json' };\n    const settings = getSettings();\n\n    if (settings.customerId) {\n        headers['x-stripe-customer-id'] = settings.customerId;  // LEGACY\n    }\n    if (settings.licenseKey) {\n        headers['x-license-key'] = settings.licenseKey;  // Not used by backend\n    }\n\n    return headers;\n}\n```\n\n**Expected Implementation:**\n```javascript\nfunction getAuthHeaders() {\n    const headers = { 'Content-Type': 'application/json' };\n    const settings = getSettings();\n\n    if (settings.accessToken) {\n        headers['Authorization'] = `Bearer ${settings.accessToken}`;\n    }\n\n    return headers;\n}\n```\n\n**Priority:** High\n\n**Recommendation:**\n1. Modify `getAuthHeaders()` to send JWT Bearer token\n2. Store access token in settings after successful login\n3. Keep license key for re-authentication purposes only\n\n---\n\n### Issue 5: License Activation vs Login Flow Mismatch (MEDIUM)\n\n**Location:** `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js` (lines 991-1058)\n\n**Finding:** CEP uses `/license/activate` for authentication, while backend has a proper `/auth/login` endpoint that returns JWT tokens.\n\n**CEP Implementation (config.js):**\n```javascript\nconst response = await fetchWithTimeout(`${getBackendUrl()}/license/activate`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ key: licenseKey })\n}, SPLICE_CONFIG.FETCH_TIMEOUT);\n\nconst result = await response.json();\nif (result.success) {\n    saveSettings({ customerId: result.customerId });  // Only stores customerId\n}\n```\n\n**Backend /auth/login Response (auth.js lines 346-367):**\n```javascript\nres.json({\n    success: true,\n    token: tokenResult.token,         // JWT access token - NOT USED BY CEP\n    tokenType: tokenResult.tokenType,\n    expiresIn: tokenResult.expiresIn,\n    refreshToken: refreshResult.refreshToken,  // Refresh token - NOT USED BY CEP\n    customerId: licenseResult.customerId,\n    tier: balance.tier,\n    hoursRemaining: balance.hoursRemaining\n});\n```\n\n**Priority:** Medium\n\n**Recommendation:**\n1. Update CEP to use `/auth/login` instead of `/license/activate`\n2. Store both access token and refresh token from response\n3. Alternatively, update `/license/activate` to also return JWT tokens\n\n---\n\n### Positive Findings\n\n1. **Correct Production URL Configuration** - Met\n   - CEP correctly defaults to production URL: `https://splice-api-production.up.railway.app`\n   - Supports localStorage override for development\n\n2. **Proper Error Handling** - Met\n   - `parseErrorResponse()` function handles various error formats\n   - `fetchWithTimeout()` provides timeout protection (2 minutes)\n   - Detailed error messages with connection diagnostics in debug mode\n\n3. **CORS Configuration** - Met\n   - Backend allows `file://` and `bolt://` origins for CEP/UXP panels\n   - Proper credentials handling enabled\n\n4. **Sensitive Data Encryption** - Met\n   - CEP encrypts customerId and licenseKey in localStorage\n   - Uses base64 encoding with JSON wrapping\n\n5. **Offline Detection** - Met\n   - Periodic health check every 30 seconds\n   - Proper UI state management for offline scenarios\n\n6. **Rate Limiting** - Met\n   - Backend implements tiered rate limits\n   - 100 req/min for anonymous, 300 req/min for authenticated\n   - Redis-backed with in-memory fallback\n\n---\n\n## Recommendations Summary\n\n| Priority | Issue | Fix |\n|----------|-------|-----|\n| Critical | CEP uses legacy auth header | Migrate to JWT Bearer tokens |\n| High | Missing token refresh | Implement refresh token logic |\n| High | getAuthHeaders() returns wrong headers | Return Authorization header with JWT |\n| Medium | CSRF not implemented | Add CSRF for logout/verification if needed |\n| Medium | Uses /license/activate instead of /auth/login | Switch to /auth/login for JWT tokens |\n\n---\n\n## Files Requiring Updates\n\n1. **`/Users/imorgado/SPLICE/splice-cep/panel/js/config.js`**\n   - Update `getAuthHeaders()` to return JWT Bearer token\n   - Update login flow to use `/auth/login` and store JWT tokens\n   - Add token refresh logic\n\n2. **`/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js`**\n   - Update `fetchCredits()` to use JWT authentication\n   - Add 401 handling with token refresh attempt\n\n3. **`/Users/imorgado/SPLICE/splice-cep/panel/js/main.js`**\n   - Update all API calls to use JWT Bearer tokens (already uses `getAuthHeaders()`)\n   - Add token expiration checking\n\n---\n\n## Conclusion\n\nThe SPLICE backend API is well-implemented with proper JWT authentication, token blacklisting, CSRF protection, and rate limiting. However, the CEP panel is still using the deprecated legacy authentication method (`x-stripe-customer-id` header), which is disabled by default in production. This is a **critical issue** that will cause authentication failures for CEP users.\n\nThe CEP panel needs to be updated to:\n1. Use the `/auth/login` endpoint to obtain JWT tokens\n2. Store and send JWT Bearer tokens in the Authorization header\n3. Implement token refresh logic for seamless session management"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":8920,"cache_read_input_tokens":100459,"cache_creation":{"ephemeral_5m_input_tokens":8920,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2VdzRvmkHYnxvYpJgsz","type":"assistant","uuid":"67834f2b-3fbe-4212-86de-54d8aa658718","timestamp":"2026-01-11T23:56:43.944Z"}
