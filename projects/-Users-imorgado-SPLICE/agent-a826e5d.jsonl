{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","type":"user","message":{"role":"user","content":"Analyze SPLICE for multi-user concurrency issues:\n\n1. Review usageTracking.js (especially deductUsage:321-358)\n   - Is usage deduction atomic?\n   - Could two concurrent requests both pass credit check then both deduct?\n   - Is there proper database transaction isolation?\n\n2. Check for race conditions in:\n   - License key activation (two devices activating same key)\n   - Credit balance reads vs writes\n   - Batch job status updates\n   - Cache operations\n\n3. Check isolation between users:\n   - Can customer A see customer B's data?\n   - Are all DB queries properly filtered by customer_id?\n   - Are batch jobs isolated?\n\n4. Check for credit leakage:\n   - Can requests complete without usage being deducted?\n   - What if deduction fails after processing?\n\nReport: List each potential race condition with severity (CRITICAL/HIGH/MEDIUM), code location, and recommended fix."},"uuid":"df7f7d64-c899-479f-8854-2825e36b03ae","timestamp":"2025-12-25T23:26:26.036Z"}
{"parentUuid":"df7f7d64-c899-479f-8854-2825e36b03ae","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYEsTLZVeQ8SvwpEz3StEX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017VfJPqS3F754di8Ce98bxT","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":17312,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":17312,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWUGeEJDn16idmGGwxKrW","type":"assistant","uuid":"7cf8577f-f3d7-44c5-a7a9-8bf1f64122fc","timestamp":"2025-12-25T23:26:30.523Z"}
{"parentUuid":"7cf8577f-f3d7-44c5-a7a9-8bf1f64122fc","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYEsTLZVeQ8SvwpEz3StEX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DpuFvrzGYzp6ouJgr6f8gs","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/licenseService.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":17312,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":17312,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWUGeEJDn16idmGGwxKrW","type":"assistant","uuid":"29bce4e8-14e0-4b70-9bea-a7e8db79856b","timestamp":"2025-12-25T23:26:31.050Z"}
{"parentUuid":"29bce4e8-14e0-4b70-9bea-a7e8db79856b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KYEsTLZVeQ8SvwpEz3StEX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011GkbcETFhkiVrSsgLFJXWC","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":17312,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":17312,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWUGeEJDn16idmGGwxKrW","type":"assistant","uuid":"81cc4bad-28ca-45c7-99af-7e22fa6258fc","timestamp":"2025-12-25T23:26:31.595Z"}
{"parentUuid":"81cc4bad-28ca-45c7-99af-7e22fa6258fc","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017VfJPqS3F754di8Ce98bxT","type":"tool_result","content":"     1→/**\n     2→ * Usage Tracking Service\n     3→ *\n     4→ * Tracks user credit balances and usage for billing.\n     5→ * Uses PostgreSQL for persistence.\n     6→ */\n     7→\n     8→const { Pool } = require('pg');\n     9→\n    10→// PostgreSQL connection pool with proper limits\n    11→const pool = new Pool({\n    12→  connectionString: process.env.DATABASE_URL,\n    13→  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    14→  // PERFORMANCE: Set connection pool limits\n    15→  max: 20,                    // Maximum number of clients in the pool\n    16→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n    17→  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n    18→});\n    19→\n    20→// Hours per tier (regular processing)\n    21→const TIER_HOURS = {\n    22→  starter: 15,\n    23→  pro: 50,\n    24→  team: 150,\n    25→  cancelled: 0\n    26→};\n    27→\n    28→// Isolation minutes per tier (sized to maintain 80% margins)\n    29→const TIER_ISOLATION_MINUTES = {\n    30→  starter: 0,     // No isolation access\n    31→  pro: 45,        // 45 minutes included\n    32→  team: 180,      // 3 hours included\n    33→  cancelled: 0\n    34→};\n    35→\n    36→// Convert to hours for database storage\n    37→const TIER_ISOLATION_HOURS = {\n    38→  starter: 0,\n    39→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n    40→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n    41→  cancelled: 0\n    42→};\n    43→\n    44→// Overage rate for isolation beyond included minutes\n    45→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n    46→\n    47→/**\n    48→ * Initialize database tables\n    49→ */\n    50→async function initDatabase() {\n    51→  const client = await pool.connect();\n    52→  try {\n    53→    await client.query(`\n    54→      CREATE TABLE IF NOT EXISTS users (\n    55→        id SERIAL PRIMARY KEY,\n    56→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n    57→        email VARCHAR(255),\n    58→        tier VARCHAR(50) DEFAULT 'starter',\n    59→        hours_remaining DECIMAL(10,4) DEFAULT 15,\n    60→        hours_total DECIMAL(10,4) DEFAULT 15,\n    61→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n    62→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n    63→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    64→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    65→      )\n    66→    `);\n    67→\n    68→    // Add isolation columns if they don't exist (for existing databases)\n    69→    await client.query(`\n    70→      DO $$\n    71→      BEGIN\n    72→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n    73→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n    74→        END IF;\n    75→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n    76→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n    77→        END IF;\n    78→      END $$;\n    79→    `);\n    80→\n    81→    await client.query(`\n    82→      CREATE TABLE IF NOT EXISTS usage_log (\n    83→        id SERIAL PRIMARY KEY,\n    84→        user_id INTEGER REFERENCES users(id),\n    85→        stripe_customer_id VARCHAR(255),\n    86→        audio_duration_seconds DECIMAL(10,2),\n    87→        hours_used DECIMAL(10,6),\n    88→        endpoint VARCHAR(100),\n    89→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    90→      )\n    91→    `);\n    92→\n    93→    await client.query(`\n    94→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    95→    `);\n    96→\n    97→    await client.query(`\n    98→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    99→    `);\n   100→\n   101→    // PERFORMANCE: Add composite index for efficient customer usage history queries\n   102→    await client.query(`\n   103→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n   104→      ON usage_log(stripe_customer_id, created_at DESC)\n   105→    `);\n   106→\n   107→    // Webhook events table for idempotency\n   108→    await client.query(`\n   109→      CREATE TABLE IF NOT EXISTS webhook_events (\n   110→        id SERIAL PRIMARY KEY,\n   111→        event_id VARCHAR(255) UNIQUE NOT NULL,\n   112→        event_type VARCHAR(100),\n   113→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   114→      )\n   115→    `);\n   116→\n   117→    await client.query(`\n   118→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n   119→    `);\n   120→\n   121→    console.log('[UsageTracking] Database initialized');\n   122→  } finally {\n   123→    client.release();\n   124→  }\n   125→}\n   126→\n   127→/**\n   128→ * Get or create a user by Stripe customer ID\n   129→ */\n   130→async function getOrCreateUser(stripeCustomerId, email = null) {\n   131→  const client = await pool.connect();\n   132→  try {\n   133→    // Try to find existing user\n   134→    let result = await client.query(\n   135→      'SELECT * FROM users WHERE stripe_customer_id = $1',\n   136→      [stripeCustomerId]\n   137→    );\n   138→\n   139→    if (result.rows.length > 0) {\n   140→      return result.rows[0];\n   141→    }\n   142→\n   143→    // Create new user with starter tier (no isolation hours)\n   144→    result = await client.query(\n   145→      `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   146→       VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   147→       RETURNING *`,\n   148→      [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n   149→    );\n   150→\n   151→    return result.rows[0];\n   152→  } finally {\n   153→    client.release();\n   154→  }\n   155→}\n   156→\n   157→/**\n   158→ * Get user's current credit balance\n   159→ */\n   160→async function getBalance(stripeCustomerId) {\n   161→  const user = await getOrCreateUser(stripeCustomerId);\n   162→  const hoursTotal = parseFloat(user.hours_total);\n   163→  const hoursRemaining = parseFloat(user.hours_remaining);\n   164→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   165→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   166→\n   167→  // Tier display names\n   168→  const tierNames = {\n   169→    starter: 'Starter',\n   170→    pro: 'Pro',\n   171→    team: 'Team',\n   172→    cancelled: 'Cancelled'\n   173→  };\n   174→\n   175→  return {\n   176→    hoursRemaining,\n   177→    hoursTotal,\n   178→    isolationHoursRemaining,\n   179→    isolationHoursTotal,\n   180→    tier: user.tier,\n   181→    tierName: tierNames[user.tier] || user.tier,\n   182→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   183→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   184→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   185→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   186→  };\n   187→}\n   188→\n   189→/**\n   190→ * Check if user has enough credits for estimated duration\n   191→ */\n   192→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n   193→  const balance = await getBalance(stripeCustomerId);\n   194→  const estimatedHours = estimatedSeconds / 3600;\n   195→  return balance.hoursRemaining >= estimatedHours;\n   196→}\n   197→\n   198→/**\n   199→ * Check if user can use vocal isolation\n   200→ * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n   201→ */\n   202→async function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n   203→  const balance = await getBalance(stripeCustomerId);\n   204→\n   205→  // Starter tier has no isolation access\n   206→  if (!balance.hasIsolationAccess) {\n   207→    return {\n   208→      allowed: false,\n   209→      reason: 'upgrade_required',\n   210→      message: 'Vocal isolation requires Pro or Team tier',\n   211→      hasIncludedHours: false,\n   212→      overageRequired: false,\n   213→      overageCost: 0\n   214→    };\n   215→  }\n   216→\n   217→  const estimatedHours = estimatedMinutes / 60;\n   218→  const remainingIncluded = balance.isolationHoursRemaining;\n   219→\n   220→  // Check if within included hours\n   221→  if (remainingIncluded >= estimatedHours) {\n   222→    return {\n   223→      allowed: true,\n   224→      reason: 'included',\n   225→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   226→      hasIncludedHours: true,\n   227→      overageRequired: false,\n   228→      overageCost: 0,\n   229→      isolationHoursRemaining: remainingIncluded - estimatedHours\n   230→    };\n   231→  }\n   232→\n   233→  // Calculate overage\n   234→  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n   235→  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   236→\n   237→  return {\n   238→    allowed: true,\n   239→    reason: 'overage',\n   240→    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n   241→    hasIncludedHours: remainingIncluded > 0,\n   242→    overageRequired: true,\n   243→    overageMinutes,\n   244→    overageCost,\n   245→    isolationHoursRemaining: 0\n   246→  };\n   247→}\n   248→\n   249→/**\n   250→ * Deduct isolation usage from user's balance\n   251→ * Returns overage cost if beyond included hours\n   252→ */\n   253→async function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n   254→  const durationMinutes = audioDurationSeconds / 60;\n   255→  const durationHours = audioDurationSeconds / 3600;\n   256→\n   257→  const client = await pool.connect();\n   258→  try {\n   259→    // Get user\n   260→    const userResult = await client.query(\n   261→      'SELECT * FROM users WHERE stripe_customer_id = $1',\n   262→      [stripeCustomerId]\n   263→    );\n   264→\n   265→    if (userResult.rows.length === 0) {\n   266→      throw new Error('User not found');\n   267→    }\n   268→\n   269→    const user = userResult.rows[0];\n   270→    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n   271→\n   272→    let overageCost = 0;\n   273→    let hoursFromIncluded = 0;\n   274→    let overageMinutes = 0;\n   275→\n   276→    if (remainingIncluded >= durationHours) {\n   277→      // Fully covered by included hours\n   278→      hoursFromIncluded = durationHours;\n   279→    } else {\n   280→      // Partial or full overage\n   281→      hoursFromIncluded = remainingIncluded;\n   282→      overageMinutes = durationMinutes - (remainingIncluded * 60);\n   283→      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   284→    }\n   285→\n   286→    // Update isolation balance\n   287→    await client.query(\n   288→      `UPDATE users\n   289→       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n   290→           updated_at = CURRENT_TIMESTAMP\n   291→       WHERE stripe_customer_id = $2`,\n   292→      [durationHours, stripeCustomerId]\n   293→    );\n   294→\n   295→    // Log usage (mark as isolation)\n   296→    await client.query(\n   297→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   298→       VALUES ($1, $2, $3, $4, $5)`,\n   299→      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n   300→    );\n   301→\n   302→    // Return updated balance and overage info\n   303→    const newBalance = await getBalance(stripeCustomerId);\n   304→    return {\n   305→      ...newBalance,\n   306→      isolationUsed: {\n   307→        durationMinutes,\n   308→        hoursFromIncluded,\n   309→        overageMinutes,\n   310→        overageCost\n   311→      }\n   312→    };\n   313→  } finally {\n   314→    client.release();\n   315→  }\n   316→}\n   317→\n   318→/**\n   319→ * Deduct usage from user's balance\n   320→ */\n   321→async function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n   322→  const hoursUsed = audioDurationSeconds / 3600;\n   323→\n   324→  const client = await pool.connect();\n   325→  try {\n   326→    // Get user\n   327→    const userResult = await client.query(\n   328→      'SELECT * FROM users WHERE stripe_customer_id = $1',\n   329→      [stripeCustomerId]\n   330→    );\n   331→\n   332→    if (userResult.rows.length === 0) {\n   333→      throw new Error('User not found');\n   334→    }\n   335→\n   336→    const user = userResult.rows[0];\n   337→\n   338→    // Update balance\n   339→    await client.query(\n   340→      `UPDATE users\n   341→       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   342→           updated_at = CURRENT_TIMESTAMP\n   343→       WHERE stripe_customer_id = $2`,\n   344→      [hoursUsed, stripeCustomerId]\n   345→    );\n   346→\n   347→    // Log usage\n   348→    await client.query(\n   349→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   350→       VALUES ($1, $2, $3, $4, $5)`,\n   351→      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n   352→    );\n   353→\n   354→    // Return updated balance\n   355→    return await getBalance(stripeCustomerId);\n   356→  } finally {\n   357→    client.release();\n   358→  }\n   359→}\n   360→\n   361→/**\n   362→ * Reset user's hours for new billing period\n   363→ */\n   364→async function resetHours(stripeCustomerId, tier) {\n   365→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   366→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   367→\n   368→  await pool.query(\n   369→    `UPDATE users\n   370→     SET hours_remaining = $1, hours_total = $1,\n   371→         isolation_hours_remaining = $2, isolation_hours_total = $2,\n   372→         tier = $3, updated_at = CURRENT_TIMESTAMP\n   373→     WHERE stripe_customer_id = $4`,\n   374→    [hours, isolationHours, tier, stripeCustomerId]\n   375→  );\n   376→\n   377→  return await getBalance(stripeCustomerId);\n   378→}\n   379→\n   380→/**\n   381→ * Update user's tier (from Stripe webhook)\n   382→ */\n   383→async function updateTier(stripeCustomerId, tier, email = null) {\n   384→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   385→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   386→\n   387→  const client = await pool.connect();\n   388→  try {\n   389→    // Check if user exists\n   390→    const result = await client.query(\n   391→      'SELECT * FROM users WHERE stripe_customer_id = $1',\n   392→      [stripeCustomerId]\n   393→    );\n   394→\n   395→    if (result.rows.length === 0) {\n   396→      // Create new user with this tier\n   397→      await client.query(\n   398→        `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   399→         VALUES ($1, $2, $3, $4, $4, $5, $5)`,\n   400→        [stripeCustomerId, email, tier, hours, isolationHours]\n   401→      );\n   402→    } else {\n   403→      // Update existing user\n   404→      await client.query(\n   405→        `UPDATE users\n   406→         SET tier = $1, hours_remaining = $2, hours_total = $2,\n   407→             isolation_hours_remaining = $3, isolation_hours_total = $3,\n   408→             updated_at = CURRENT_TIMESTAMP\n   409→         WHERE stripe_customer_id = $4`,\n   410→        [tier, hours, isolationHours, stripeCustomerId]\n   411→      );\n   412→    }\n   413→\n   414→    return await getBalance(stripeCustomerId);\n   415→  } finally {\n   416→    client.release();\n   417→  }\n   418→}\n   419→\n   420→/**\n   421→ * Get usage history for a user\n   422→ */\n   423→async function getUsageHistory(stripeCustomerId, limit = 50) {\n   424→  const result = await pool.query(\n   425→    `SELECT * FROM usage_log\n   426→     WHERE stripe_customer_id = $1\n   427→     ORDER BY created_at DESC\n   428→     LIMIT $2`,\n   429→    [stripeCustomerId, limit]\n   430→  );\n   431→  return result.rows;\n   432→}\n   433→\n   434→/**\n   435→ * Check if webhook event has already been processed (idempotency)\n   436→ */\n   437→async function isEventProcessed(eventId) {\n   438→  const result = await pool.query(\n   439→    'SELECT id FROM webhook_events WHERE event_id = $1',\n   440→    [eventId]\n   441→  );\n   442→  return result.rows.length > 0;\n   443→}\n   444→\n   445→/**\n   446→ * Record a processed webhook event\n   447→ */\n   448→async function recordWebhookEvent(eventId, eventType) {\n   449→  try {\n   450→    await pool.query(\n   451→      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n   452→      [eventId, eventType]\n   453→    );\n   454→  } catch (err) {\n   455→    // Ignore duplicate key errors (race condition safety)\n   456→    if (err.code !== '23505') throw err;\n   457→  }\n   458→}\n   459→\n   460→module.exports = {\n   461→  initDatabase,\n   462→  getOrCreateUser,\n   463→  getBalance,\n   464→  hasCredits,\n   465→  checkIsolationAccess,\n   466→  deductUsage,\n   467→  deductIsolationUsage,\n   468→  resetHours,\n   469→  updateTier,\n   470→  getUsageHistory,\n   471→  isEventProcessed,\n   472→  recordWebhookEvent,\n   473→  TIER_HOURS,\n   474→  TIER_ISOLATION_MINUTES,\n   475→  TIER_ISOLATION_HOURS,\n   476→  ISOLATION_OVERAGE_RATE\n   477→};\n   478→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"79e85eda-1c07-4717-bd25-310744369159","timestamp":"2025-12-25T23:26:31.688Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"/**\n * Usage Tracking Service\n *\n * Tracks user credit balances and usage for billing.\n * Uses PostgreSQL for persistence.\n */\n\nconst { Pool } = require('pg');\n\n// PostgreSQL connection pool with proper limits\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n  // PERFORMANCE: Set connection pool limits\n  max: 20,                    // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n});\n\n// Hours per tier (regular processing)\nconst TIER_HOURS = {\n  starter: 15,\n  pro: 50,\n  team: 150,\n  cancelled: 0\n};\n\n// Isolation minutes per tier (sized to maintain 80% margins)\nconst TIER_ISOLATION_MINUTES = {\n  starter: 0,     // No isolation access\n  pro: 45,        // 45 minutes included\n  team: 180,      // 3 hours included\n  cancelled: 0\n};\n\n// Convert to hours for database storage\nconst TIER_ISOLATION_HOURS = {\n  starter: 0,\n  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n  cancelled: 0\n};\n\n// Overage rate for isolation beyond included minutes\nconst ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n\n/**\n * Initialize database tables\n */\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n        email VARCHAR(255),\n        tier VARCHAR(50) DEFAULT 'starter',\n        hours_remaining DECIMAL(10,4) DEFAULT 15,\n        hours_total DECIMAL(10,4) DEFAULT 15,\n        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Add isolation columns if they don't exist (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n        END IF;\n      END $$;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS usage_log (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        stripe_customer_id VARCHAR(255),\n        audio_duration_seconds DECIMAL(10,2),\n        hours_used DECIMAL(10,6),\n        endpoint VARCHAR(100),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    `);\n\n    // PERFORMANCE: Add composite index for efficient customer usage history queries\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n      ON usage_log(stripe_customer_id, created_at DESC)\n    `);\n\n    // Webhook events table for idempotency\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id SERIAL PRIMARY KEY,\n        event_id VARCHAR(255) UNIQUE NOT NULL,\n        event_type VARCHAR(100),\n        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n    `);\n\n    console.log('[UsageTracking] Database initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get or create a user by Stripe customer ID\n */\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  const client = await pool.connect();\n  try {\n    // Try to find existing user\n    let result = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length > 0) {\n      return result.rows[0];\n    }\n\n    // Create new user with starter tier (no isolation hours)\n    result = await client.query(\n      `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n       VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n       RETURNING *`,\n      [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n    );\n\n    return result.rows[0];\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get user's current credit balance\n */\nasync function getBalance(stripeCustomerId) {\n  const user = await getOrCreateUser(stripeCustomerId);\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  // Tier display names\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Check if user has enough credits for estimated duration\n */\nasync function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n  const balance = await getBalance(stripeCustomerId);\n  const estimatedHours = estimatedSeconds / 3600;\n  return balance.hoursRemaining >= estimatedHours;\n}\n\n/**\n * Check if user can use vocal isolation\n * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n */\nasync function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n  const balance = await getBalance(stripeCustomerId);\n\n  // Starter tier has no isolation access\n  if (!balance.hasIsolationAccess) {\n    return {\n      allowed: false,\n      reason: 'upgrade_required',\n      message: 'Vocal isolation requires Pro or Team tier',\n      hasIncludedHours: false,\n      overageRequired: false,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remainingIncluded = balance.isolationHoursRemaining;\n\n  // Check if within included hours\n  if (remainingIncluded >= estimatedHours) {\n    return {\n      allowed: true,\n      reason: 'included',\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      hasIncludedHours: true,\n      overageRequired: false,\n      overageCost: 0,\n      isolationHoursRemaining: remainingIncluded - estimatedHours\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n\n  return {\n    allowed: true,\n    reason: 'overage',\n    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n    hasIncludedHours: remainingIncluded > 0,\n    overageRequired: true,\n    overageMinutes,\n    overageCost,\n    isolationHoursRemaining: 0\n  };\n}\n\n/**\n * Deduct isolation usage from user's balance\n * Returns overage cost if beyond included hours\n */\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n  const durationMinutes = audioDurationSeconds / 60;\n  const durationHours = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    // Get user\n    const userResult = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n\n    let overageCost = 0;\n    let hoursFromIncluded = 0;\n    let overageMinutes = 0;\n\n    if (remainingIncluded >= durationHours) {\n      // Fully covered by included hours\n      hoursFromIncluded = durationHours;\n    } else {\n      // Partial or full overage\n      hoursFromIncluded = remainingIncluded;\n      overageMinutes = durationMinutes - (remainingIncluded * 60);\n      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n    }\n\n    // Update isolation balance\n    await client.query(\n      `UPDATE users\n       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [durationHours, stripeCustomerId]\n    );\n\n    // Log usage (mark as isolation)\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n\n    // Return updated balance and overage info\n    const newBalance = await getBalance(stripeCustomerId);\n    return {\n      ...newBalance,\n      isolationUsed: {\n        durationMinutes,\n        hoursFromIncluded,\n        overageMinutes,\n        overageCost\n      }\n    };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct usage from user's balance\n */\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    // Get user\n    const userResult = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n\n    // Update balance\n    await client.query(\n      `UPDATE users\n       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [hoursUsed, stripeCustomerId]\n    );\n\n    // Log usage\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n    );\n\n    // Return updated balance\n    return await getBalance(stripeCustomerId);\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset user's hours for new billing period\n */\nasync function resetHours(stripeCustomerId, tier) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  await pool.query(\n    `UPDATE users\n     SET hours_remaining = $1, hours_total = $1,\n         isolation_hours_remaining = $2, isolation_hours_total = $2,\n         tier = $3, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $4`,\n    [hours, isolationHours, tier, stripeCustomerId]\n  );\n\n  return await getBalance(stripeCustomerId);\n}\n\n/**\n * Update user's tier (from Stripe webhook)\n */\nasync function updateTier(stripeCustomerId, tier, email = null) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  const client = await pool.connect();\n  try {\n    // Check if user exists\n    const result = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      // Create new user with this tier\n      await client.query(\n        `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n         VALUES ($1, $2, $3, $4, $4, $5, $5)`,\n        [stripeCustomerId, email, tier, hours, isolationHours]\n      );\n    } else {\n      // Update existing user\n      await client.query(\n        `UPDATE users\n         SET tier = $1, hours_remaining = $2, hours_total = $2,\n             isolation_hours_remaining = $3, isolation_hours_total = $3,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $4`,\n        [tier, hours, isolationHours, stripeCustomerId]\n      );\n    }\n\n    return await getBalance(stripeCustomerId);\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get usage history for a user\n */\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Check if webhook event has already been processed (idempotency)\n */\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n\n/**\n * Record a processed webhook event\n */\nasync function recordWebhookEvent(eventId, eventType) {\n  try {\n    await pool.query(\n      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n      [eventId, eventType]\n    );\n  } catch (err) {\n    // Ignore duplicate key errors (race condition safety)\n    if (err.code !== '23505') throw err;\n  }\n}\n\nmodule.exports = {\n  initDatabase,\n  getOrCreateUser,\n  getBalance,\n  hasCredits,\n  checkIsolationAccess,\n  deductUsage,\n  deductIsolationUsage,\n  resetHours,\n  updateTier,\n  getUsageHistory,\n  isEventProcessed,\n  recordWebhookEvent,\n  TIER_HOURS,\n  TIER_ISOLATION_MINUTES,\n  TIER_ISOLATION_HOURS,\n  ISOLATION_OVERAGE_RATE\n};\n","numLines":478,"startLine":1,"totalLines":478}}}
{"parentUuid":"79e85eda-1c07-4717-bd25-310744369159","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DpuFvrzGYzp6ouJgr6f8gs","type":"tool_result","content":"     1→/**\n     2→ * License Key Service\n     3→ *\n     4→ * Generates and validates license keys for user authentication.\n     5→ * License keys are generated when a user purchases a subscription via Stripe.\n     6→ * Format: SPLICE-XXXX-XXXX-XXXX (alphanumeric, no confusing characters)\n     7→ */\n     8→\n     9→const { Pool } = require('pg');\n    10→const crypto = require('crypto');\n    11→\n    12→// Use the same pool configuration as other services\n    13→const pool = new Pool({\n    14→  connectionString: process.env.DATABASE_URL,\n    15→  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    16→  max: 20,\n    17→  idleTimeoutMillis: 30000,\n    18→  connectionTimeoutMillis: 5000\n    19→});\n    20→\n    21→// Characters for key generation (no confusing chars: 0/O, 1/I/L)\n    22→const KEY_CHARS = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';\n    23→\n    24→/**\n    25→ * Initialize license_keys table\n    26→ */\n    27→async function initLicenseTables() {\n    28→  const client = await pool.connect();\n    29→  try {\n    30→    await client.query(`\n    31→      CREATE TABLE IF NOT EXISTS license_keys (\n    32→        id SERIAL PRIMARY KEY,\n    33→        key VARCHAR(21) UNIQUE NOT NULL,\n    34→        stripe_customer_id VARCHAR(255) NOT NULL,\n    35→        created_at TIMESTAMP DEFAULT NOW(),\n    36→        activated_at TIMESTAMP,\n    37→        is_active BOOLEAN DEFAULT TRUE\n    38→      )\n    39→    `);\n    40→\n    41→    // Migrate existing column if needed (for existing databases)\n    42→    await client.query(`\n    43→      DO $$\n    44→      BEGIN\n    45→        IF EXISTS (\n    46→          SELECT 1 FROM information_schema.columns\n    47→          WHERE table_name = 'license_keys'\n    48→          AND column_name = 'key'\n    49→          AND character_maximum_length = 19\n    50→        ) THEN\n    51→          ALTER TABLE license_keys ALTER COLUMN key TYPE VARCHAR(21);\n    52→        END IF;\n    53→      END $$;\n    54→    `);\n    55→\n    56→    // Add indexes for efficient lookups\n    57→    await client.query(`\n    58→      CREATE INDEX IF NOT EXISTS idx_license_keys_key\n    59→      ON license_keys(key)\n    60→    `);\n    61→\n    62→    await client.query(`\n    63→      CREATE INDEX IF NOT EXISTS idx_license_keys_customer\n    64→      ON license_keys(stripe_customer_id)\n    65→    `);\n    66→\n    67→    console.log('[License] Database tables initialized');\n    68→  } finally {\n    69→    client.release();\n    70→  }\n    71→}\n    72→\n    73→/**\n    74→ * Generate a random 4-character segment\n    75→ * @returns {string} 4 uppercase alphanumeric characters\n    76→ */\n    77→function generateSegment() {\n    78→  let segment = '';\n    79→  for (let i = 0; i < 4; i++) {\n    80→    segment += KEY_CHARS.charAt(crypto.randomInt(KEY_CHARS.length));\n    81→  }\n    82→  return segment;\n    83→}\n    84→\n    85→/**\n    86→ * Generate a license key in format SPLICE-XXXX-XXXX-XXXX\n    87→ * @returns {string} License key\n    88→ */\n    89→function generateKeyString() {\n    90→  return `SPLICE-${generateSegment()}-${generateSegment()}-${generateSegment()}`;\n    91→}\n    92→\n    93→/**\n    94→ * Validate license key format\n    95→ * @param {string} key - License key to validate\n    96→ * @returns {boolean} True if format is valid\n    97→ */\n    98→function isValidKeyFormat(key) {\n    99→  if (!key || typeof key !== 'string') return false;\n   100→\n   101→  // Normalize: uppercase and trim\n   102→  const normalized = key.toUpperCase().trim();\n   103→\n   104→  // Must match SPLICE-XXXX-XXXX-XXXX pattern\n   105→  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;\n   106→  return pattern.test(normalized);\n   107→}\n   108→\n   109→/**\n   110→ * Normalize a license key (uppercase, trim)\n   111→ * @param {string} key - License key\n   112→ * @returns {string} Normalized key\n   113→ */\n   114→function normalizeKey(key) {\n   115→  return (key || '').toUpperCase().trim();\n   116→}\n   117→\n   118→/**\n   119→ * Generate a new license key for a Stripe customer\n   120→ *\n   121→ * @param {string} stripeCustomerId - Stripe customer ID\n   122→ * @returns {Promise<{success: boolean, key?: string, error?: string}>}\n   123→ */\n   124→async function generateLicenseKey(stripeCustomerId) {\n   125→  if (!stripeCustomerId) {\n   126→    return { success: false, error: 'Customer ID is required' };\n   127→  }\n   128→\n   129→  const client = await pool.connect();\n   130→  try {\n   131→    // Check if customer already has a key\n   132→    const existing = await client.query(\n   133→      'SELECT key FROM license_keys WHERE stripe_customer_id = $1',\n   134→      [stripeCustomerId]\n   135→    );\n   136→\n   137→    if (existing.rows.length > 0) {\n   138→      return {\n   139→        success: true,\n   140→        key: existing.rows[0].key,\n   141→        existing: true\n   142→      };\n   143→    }\n   144→\n   145→    // Generate unique key with retry logic\n   146→    let key;\n   147→    let attempts = 0;\n   148→    const maxAttempts = 10;\n   149→\n   150→    while (attempts < maxAttempts) {\n   151→      key = generateKeyString();\n   152→      try {\n   153→        await client.query(\n   154→          `INSERT INTO license_keys (key, stripe_customer_id)\n   155→           VALUES ($1, $2)`,\n   156→          [key, stripeCustomerId]\n   157→        );\n   158→        break;\n   159→      } catch (err) {\n   160→        if (err.code === '23505') { // Unique violation\n   161→          attempts++;\n   162→          continue;\n   163→        }\n   164→        throw err;\n   165→      }\n   166→    }\n   167→\n   168→    if (attempts >= maxAttempts) {\n   169→      return { success: false, error: 'Failed to generate unique license key' };\n   170→    }\n   171→\n   172→    console.log(`[License] Generated key for customer ${stripeCustomerId}: ${key}`);\n   173→    return { success: true, key };\n   174→  } finally {\n   175→    client.release();\n   176→  }\n   177→}\n   178→\n   179→/**\n   180→ * Activate a license key\n   181→ *\n   182→ * @param {string} key - License key to activate\n   183→ * @returns {Promise<{success: boolean, customerId?: string, error?: string}>}\n   184→ */\n   185→async function activateLicenseKey(key) {\n   186→  if (!key) {\n   187→    return { success: false, error: 'License key is required' };\n   188→  }\n   189→\n   190→  const normalized = normalizeKey(key);\n   191→\n   192→  if (!isValidKeyFormat(normalized)) {\n   193→    return { success: false, error: 'Invalid license key format. Expected: SPLICE-XXXX-XXXX-XXXX' };\n   194→  }\n   195→\n   196→  const client = await pool.connect();\n   197→  try {\n   198→    // Look up the key\n   199→    const result = await client.query(\n   200→      'SELECT * FROM license_keys WHERE key = $1',\n   201→      [normalized]\n   202→    );\n   203→\n   204→    if (result.rows.length === 0) {\n   205→      return { success: false, error: 'License key not found' };\n   206→    }\n   207→\n   208→    const license = result.rows[0];\n   209→\n   210→    if (!license.is_active) {\n   211→      return { success: false, error: 'License key has been deactivated' };\n   212→    }\n   213→\n   214→    // Update activated_at if not already set\n   215→    if (!license.activated_at) {\n   216→      await client.query(\n   217→        'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n   218→        [license.id]\n   219→      );\n   220→    }\n   221→\n   222→    return {\n   223→      success: true,\n   224→      customerId: license.stripe_customer_id\n   225→    };\n   226→  } finally {\n   227→    client.release();\n   228→  }\n   229→}\n   230→\n   231→/**\n   232→ * Get license key for a customer\n   233→ *\n   234→ * @param {string} stripeCustomerId - Stripe customer ID\n   235→ * @returns {Promise<{success: boolean, key?: string, activated?: boolean, error?: string}>}\n   236→ */\n   237→async function getLicenseByCustomerId(stripeCustomerId) {\n   238→  if (!stripeCustomerId) {\n   239→    return { success: false, error: 'Customer ID is required' };\n   240→  }\n   241→\n   242→  const result = await pool.query(\n   243→    'SELECT * FROM license_keys WHERE stripe_customer_id = $1',\n   244→    [stripeCustomerId]\n   245→  );\n   246→\n   247→  if (result.rows.length === 0) {\n   248→    return { success: false, error: 'No license key found for this customer' };\n   249→  }\n   250→\n   251→  const license = result.rows[0];\n   252→  return {\n   253→    success: true,\n   254→    key: license.key,\n   255→    activated: !!license.activated_at,\n   256→    isActive: license.is_active,\n   257→    createdAt: license.created_at,\n   258→    activatedAt: license.activated_at\n   259→  };\n   260→}\n   261→\n   262→/**\n   263→ * Deactivate a license key\n   264→ *\n   265→ * @param {string} key - License key to deactivate\n   266→ * @returns {Promise<{success: boolean, error?: string}>}\n   267→ */\n   268→async function deactivateLicenseKey(key) {\n   269→  if (!key) {\n   270→    return { success: false, error: 'License key is required' };\n   271→  }\n   272→\n   273→  const normalized = normalizeKey(key);\n   274→\n   275→  const result = await pool.query(\n   276→    'UPDATE license_keys SET is_active = FALSE WHERE key = $1 RETURNING id',\n   277→    [normalized]\n   278→  );\n   279→\n   280→  if (result.rowCount === 0) {\n   281→    return { success: false, error: 'License key not found' };\n   282→  }\n   283→\n   284→  console.log(`[License] Deactivated key: ${normalized}`);\n   285→  return { success: true };\n   286→}\n   287→\n   288→/**\n   289→ * Reactivate a license key\n   290→ *\n   291→ * @param {string} key - License key to reactivate\n   292→ * @returns {Promise<{success: boolean, error?: string}>}\n   293→ */\n   294→async function reactivateLicenseKey(key) {\n   295→  if (!key) {\n   296→    return { success: false, error: 'License key is required' };\n   297→  }\n   298→\n   299→  const normalized = normalizeKey(key);\n   300→\n   301→  const result = await pool.query(\n   302→    'UPDATE license_keys SET is_active = TRUE WHERE key = $1 RETURNING id',\n   303→    [normalized]\n   304→  );\n   305→\n   306→  if (result.rowCount === 0) {\n   307→    return { success: false, error: 'License key not found' };\n   308→  }\n   309→\n   310→  console.log(`[License] Reactivated key: ${normalized}`);\n   311→  return { success: true };\n   312→}\n   313→\n   314→module.exports = {\n   315→  initLicenseTables,\n   316→  generateLicenseKey,\n   317→  activateLicenseKey,\n   318→  getLicenseByCustomerId,\n   319→  deactivateLicenseKey,\n   320→  reactivateLicenseKey,\n   321→  isValidKeyFormat,\n   322→  normalizeKey,\n   323→  // Exposed for testing\n   324→  generateKeyString\n   325→};\n   326→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1b8ce235-0f82-46e5-81fb-4d8e83875d65","timestamp":"2025-12-25T23:26:31.689Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/licenseService.js","content":"/**\n * License Key Service\n *\n * Generates and validates license keys for user authentication.\n * License keys are generated when a user purchases a subscription via Stripe.\n * Format: SPLICE-XXXX-XXXX-XXXX (alphanumeric, no confusing characters)\n */\n\nconst { Pool } = require('pg');\nconst crypto = require('crypto');\n\n// Use the same pool configuration as other services\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 5000\n});\n\n// Characters for key generation (no confusing chars: 0/O, 1/I/L)\nconst KEY_CHARS = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';\n\n/**\n * Initialize license_keys table\n */\nasync function initLicenseTables() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS license_keys (\n        id SERIAL PRIMARY KEY,\n        key VARCHAR(21) UNIQUE NOT NULL,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW(),\n        activated_at TIMESTAMP,\n        is_active BOOLEAN DEFAULT TRUE\n      )\n    `);\n\n    // Migrate existing column if needed (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF EXISTS (\n          SELECT 1 FROM information_schema.columns\n          WHERE table_name = 'license_keys'\n          AND column_name = 'key'\n          AND character_maximum_length = 19\n        ) THEN\n          ALTER TABLE license_keys ALTER COLUMN key TYPE VARCHAR(21);\n        END IF;\n      END $$;\n    `);\n\n    // Add indexes for efficient lookups\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_license_keys_key\n      ON license_keys(key)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_license_keys_customer\n      ON license_keys(stripe_customer_id)\n    `);\n\n    console.log('[License] Database tables initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Generate a random 4-character segment\n * @returns {string} 4 uppercase alphanumeric characters\n */\nfunction generateSegment() {\n  let segment = '';\n  for (let i = 0; i < 4; i++) {\n    segment += KEY_CHARS.charAt(crypto.randomInt(KEY_CHARS.length));\n  }\n  return segment;\n}\n\n/**\n * Generate a license key in format SPLICE-XXXX-XXXX-XXXX\n * @returns {string} License key\n */\nfunction generateKeyString() {\n  return `SPLICE-${generateSegment()}-${generateSegment()}-${generateSegment()}`;\n}\n\n/**\n * Validate license key format\n * @param {string} key - License key to validate\n * @returns {boolean} True if format is valid\n */\nfunction isValidKeyFormat(key) {\n  if (!key || typeof key !== 'string') return false;\n\n  // Normalize: uppercase and trim\n  const normalized = key.toUpperCase().trim();\n\n  // Must match SPLICE-XXXX-XXXX-XXXX pattern\n  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;\n  return pattern.test(normalized);\n}\n\n/**\n * Normalize a license key (uppercase, trim)\n * @param {string} key - License key\n * @returns {string} Normalized key\n */\nfunction normalizeKey(key) {\n  return (key || '').toUpperCase().trim();\n}\n\n/**\n * Generate a new license key for a Stripe customer\n *\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, key?: string, error?: string}>}\n */\nasync function generateLicenseKey(stripeCustomerId) {\n  if (!stripeCustomerId) {\n    return { success: false, error: 'Customer ID is required' };\n  }\n\n  const client = await pool.connect();\n  try {\n    // Check if customer already has a key\n    const existing = await client.query(\n      'SELECT key FROM license_keys WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (existing.rows.length > 0) {\n      return {\n        success: true,\n        key: existing.rows[0].key,\n        existing: true\n      };\n    }\n\n    // Generate unique key with retry logic\n    let key;\n    let attempts = 0;\n    const maxAttempts = 10;\n\n    while (attempts < maxAttempts) {\n      key = generateKeyString();\n      try {\n        await client.query(\n          `INSERT INTO license_keys (key, stripe_customer_id)\n           VALUES ($1, $2)`,\n          [key, stripeCustomerId]\n        );\n        break;\n      } catch (err) {\n        if (err.code === '23505') { // Unique violation\n          attempts++;\n          continue;\n        }\n        throw err;\n      }\n    }\n\n    if (attempts >= maxAttempts) {\n      return { success: false, error: 'Failed to generate unique license key' };\n    }\n\n    console.log(`[License] Generated key for customer ${stripeCustomerId}: ${key}`);\n    return { success: true, key };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Activate a license key\n *\n * @param {string} key - License key to activate\n * @returns {Promise<{success: boolean, customerId?: string, error?: string}>}\n */\nasync function activateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  if (!isValidKeyFormat(normalized)) {\n    return { success: false, error: 'Invalid license key format. Expected: SPLICE-XXXX-XXXX-XXXX' };\n  }\n\n  const client = await pool.connect();\n  try {\n    // Look up the key\n    const result = await client.query(\n      'SELECT * FROM license_keys WHERE key = $1',\n      [normalized]\n    );\n\n    if (result.rows.length === 0) {\n      return { success: false, error: 'License key not found' };\n    }\n\n    const license = result.rows[0];\n\n    if (!license.is_active) {\n      return { success: false, error: 'License key has been deactivated' };\n    }\n\n    // Update activated_at if not already set\n    if (!license.activated_at) {\n      await client.query(\n        'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n        [license.id]\n      );\n    }\n\n    return {\n      success: true,\n      customerId: license.stripe_customer_id\n    };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get license key for a customer\n *\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, key?: string, activated?: boolean, error?: string}>}\n */\nasync function getLicenseByCustomerId(stripeCustomerId) {\n  if (!stripeCustomerId) {\n    return { success: false, error: 'Customer ID is required' };\n  }\n\n  const result = await pool.query(\n    'SELECT * FROM license_keys WHERE stripe_customer_id = $1',\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { success: false, error: 'No license key found for this customer' };\n  }\n\n  const license = result.rows[0];\n  return {\n    success: true,\n    key: license.key,\n    activated: !!license.activated_at,\n    isActive: license.is_active,\n    createdAt: license.created_at,\n    activatedAt: license.activated_at\n  };\n}\n\n/**\n * Deactivate a license key\n *\n * @param {string} key - License key to deactivate\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function deactivateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  const result = await pool.query(\n    'UPDATE license_keys SET is_active = FALSE WHERE key = $1 RETURNING id',\n    [normalized]\n  );\n\n  if (result.rowCount === 0) {\n    return { success: false, error: 'License key not found' };\n  }\n\n  console.log(`[License] Deactivated key: ${normalized}`);\n  return { success: true };\n}\n\n/**\n * Reactivate a license key\n *\n * @param {string} key - License key to reactivate\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function reactivateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  const result = await pool.query(\n    'UPDATE license_keys SET is_active = TRUE WHERE key = $1 RETURNING id',\n    [normalized]\n  );\n\n  if (result.rowCount === 0) {\n    return { success: false, error: 'License key not found' };\n  }\n\n  console.log(`[License] Reactivated key: ${normalized}`);\n  return { success: true };\n}\n\nmodule.exports = {\n  initLicenseTables,\n  generateLicenseKey,\n  activateLicenseKey,\n  getLicenseByCustomerId,\n  deactivateLicenseKey,\n  reactivateLicenseKey,\n  isValidKeyFormat,\n  normalizeKey,\n  // Exposed for testing\n  generateKeyString\n};\n","numLines":326,"startLine":1,"totalLines":326}}}
{"parentUuid":"1b8ce235-0f82-46e5-81fb-4d8e83875d65","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011GkbcETFhkiVrSsgLFJXWC","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Backend Server\n     3→ *\n     4→ * Main entry point for the SPLICE backend API.\n     5→ * Orchestrates the audio analysis pipeline.\n     6→ *\n     7→ * Slices:\n     8→ * - Slice 4: Transcription (services/transcription.js)\n     9→ * - Slice 5: Take Detection (services/takeDetection.js)\n    10→ */\n    11→\n    12→require('dotenv').config();\n    13→\n    14→const express = require('express');\n    15→const cors = require('cors');\n    16→const fs = require('fs');\n    17→const https = require('https');\n    18→const http = require('http');\n    19→const path = require('path');\n    20→\n    21→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\n    22→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    23→\n    24→// Import slice services\n    25→const { transcribeAudio, transcribeWithWords } = require('./services/transcription');\n    26→const { detectTakes } = require('./services/takeDetection');\n    27→const { detectSilences } = require('./services/silenceDetection');\n    28→const { detectAudioSilences, isFFprobeInstalled, getAudioDuration } = require('./services/ffprobeSilence');\n    29→const { detectSilencesRMS, sensitivityToParams } = require('./services/rmsSilenceDetection');\n    30→const {\n    31→  detectProfanity,\n    32→  getProfanityList,\n    33→  getSupportedLanguages,\n    34→  getAvailableBleepSounds,\n    35→  parseWordList\n    36→} = require('./services/profanityDetection');\n    37→const {\n    38→  detectRepetitionsBasic,\n    39→  detectRepetitionsAdvanced,\n    40→  detectStutters,\n    41→  detectAllRepetitions\n    42→} = require('./services/repetitionDetection');\n    43→const {\n    44→  analyzeMultitrack,\n    45→  autoBalanceMultitrack\n    46→} = require('./services/multitrackAnalysis');\n    47→const {\n    48→  toSRT,\n    49→  toVTT,\n    50→  toPlainText,\n    51→  toJSON,\n    52→  exportToFile,\n    53→  getSupportedFormats\n    54→} = require('./services/captionExporter');\n    55→const { processXMLFile } = require('./services/xmlProcessor');\n    56→const { isolateVocals, isReplicateConfigured } = require('./services/vocalIsolation');\n    57→const { generateCutList, generateTakesCutList, validateCutList } = require('./services/cutListGenerator');\n    58→\n    59→// Usage tracking and billing\n    60→const usageTracking = require('./services/usageTracking');\n    61→// Rate limiter for usage-based endpoints\n    62→const { requireCredits } = require('./middleware/rateLimiter');\n    63→// Referral system\n    64→const referralService = require('./services/referralService');\n    65→// License key system\n    66→const licenseService = require('./services/licenseService');\n    67→\n    68→// Maximum file size for audio processing (500MB)\n    69→const MAX_FILE_SIZE_BYTES = 500 * 1024 * 1024;\n    70→\n    71→/**\n    72→ * Validate file size to prevent OOM crashes\n    73→ * @param {string} filePath - Path to file\n    74→ * @returns {Promise<{valid: boolean, size?: number, error?: string}>}\n    75→ */\n    76→async function validateFileSize(filePath) {\n    77→  try {\n    78→    const stats = await require('fs').promises.stat(filePath);\n    79→    if (stats.size > MAX_FILE_SIZE_BYTES) {\n    80→      return {\n    81→        valid: false,\n    82→        size: stats.size,\n    83→        error: `File too large (${(stats.size / 1024 / 1024).toFixed(1)}MB). Maximum allowed: ${MAX_FILE_SIZE_BYTES / 1024 / 1024}MB`\n    84→      };\n    85→    }\n    86→    return { valid: true, size: stats.size };\n    87→  } catch (err) {\n    88→    return { valid: false, error: `Cannot access file: ${err.message}` };\n    89→  }\n    90→}\n    91→\n    92→// Stripe for webhooks\n    93→const Stripe = require('stripe');\n    94→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n    95→\n    96→// =============================================================================\n    97→// Server Configuration\n    98→// =============================================================================\n    99→\n   100→const app = express();\n   101→const PORT = process.env.PORT || 3847;\n   102→\n   103→// HTTPS certificates (generated by mkcert) - only for local development\n   104→let httpsOptions = null;\n   105→if (!isProduction) {\n   106→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n   107→  const certPath = path.join(__dirname, 'localhost+1.pem');\n   108→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n   109→    httpsOptions = {\n   110→      key: fs.readFileSync(keyPath),\n   111→      cert: fs.readFileSync(certPath)\n   112→    };\n   113→  }\n   114→}\n   115→\n   116→app.use(cors());\n   117→\n   118→// Helper to determine tier from price ID with logging\n   119→function getTierFromPriceId(priceId) {\n   120→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   121→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   122→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   123→\n   124→  // Log unknown price ID for debugging\n   125→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   126→  return 'starter';\n   127→}\n   128→\n   129→// Stripe webhook needs raw body - must be before express.json()\n   130→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   131→  const sig = req.headers['stripe-signature'];\n   132→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   133→\n   134→  let event;\n   135→\n   136→  try {\n   137→    if (webhookSecret) {\n   138→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   139→    } else if (isProduction) {\n   140→      // SECURITY: Reject unsigned webhooks in production\n   141→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   142→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   143→    } else {\n   144→      // For local development testing only\n   145→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   146→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   147→      event = JSON.parse(bodyString);\n   148→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   149→    }\n   150→  } catch (err) {\n   151→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   152→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   153→  }\n   154→\n   155→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   156→\n   157→  // Idempotency check - skip if already processed\n   158→  if (await usageTracking.isEventProcessed(event.id)) {\n   159→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   160→    return res.json({ received: true, skipped: true });\n   161→  }\n   162→\n   163→  try {\n   164→    switch (event.type) {\n   165→      case 'customer.subscription.created':\n   166→      case 'customer.subscription.updated': {\n   167→        const subscription = event.data.object;\n   168→        const customerId = subscription.customer;\n   169→\n   170→        // Validate customerId\n   171→        if (!customerId) {\n   172→          console.error('[SPLICE] Missing customer ID in subscription event');\n   173→          return res.status(400).json({ error: 'Missing customer ID' });\n   174→        }\n   175→\n   176→        // Get tier from price ID\n   177→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   178→        const tier = getTierFromPriceId(priceId);\n   179→\n   180→        // Update user tier and reset hours\n   181→        await usageTracking.updateTier(customerId, tier);\n   182→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   183→\n   184→        // Generate license key for new subscriptions\n   185→        if (event.type === 'customer.subscription.created') {\n   186→          const licenseResult = await licenseService.generateLicenseKey(customerId);\n   187→          if (licenseResult.success) {\n   188→            console.log(`[SPLICE] Generated license key for ${customerId}: ${licenseResult.key}`);\n   189→          } else {\n   190→            console.error(`[SPLICE] Failed to generate license key: ${licenseResult.error}`);\n   191→          }\n   192→        }\n   193→        break;\n   194→      }\n   195→\n   196→      case 'customer.subscription.deleted': {\n   197→        const subscription = event.data.object;\n   198→        const customerId = subscription.customer;\n   199→\n   200→        // Validate customerId\n   201→        if (!customerId) {\n   202→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   203→          return res.status(400).json({ error: 'Missing customer ID' });\n   204→        }\n   205→\n   206→        // Downgrade to cancelled (0 hours)\n   207→        await usageTracking.updateTier(customerId, 'cancelled');\n   208→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   209→        break;\n   210→      }\n   211→\n   212→      case 'invoice.payment_succeeded': {\n   213→        const invoice = event.data.object;\n   214→        const customerId = invoice.customer;\n   215→        const subscriptionId = invoice.subscription;\n   216→\n   217→        // Validate customerId\n   218→        if (!customerId) {\n   219→          console.error('[SPLICE] Missing customer ID in invoice event');\n   220→          return res.status(400).json({ error: 'Missing customer ID' });\n   221→        }\n   222→\n   223→        // Reset hours on successful payment (new billing period)\n   224→        if (subscriptionId) {\n   225→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   226→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   227→          const tier = getTierFromPriceId(priceId);\n   228→\n   229→          await usageTracking.resetHours(customerId, tier);\n   230→          console.log(`[SPLICE] Reset hours for customer ${customerId} (tier: ${tier})`);\n   231→        }\n   232→        break;\n   233→      }\n   234→\n   235→      default:\n   236→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   237→    }\n   238→\n   239→    // Record event as processed (idempotency)\n   240→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   241→\n   242→    res.json({ received: true });\n   243→  } catch (err) {\n   244→    console.error('[SPLICE] Webhook handler error:', err);\n   245→    res.status(500).json({ error: err.message });\n   246→  }\n   247→});\n   248→\n   249→app.use(express.json());\n   250→\n   251→// =============================================================================\n   252→// Routes\n   253→// =============================================================================\n   254→\n   255→/**\n   256→ * GET / - API information\n   257→ */\n   258→app.get('/', (req, res) => {\n   259→  res.json({\n   260→    service: 'splice-backend',\n   261→    version: '0.3.0',\n   262→    endpoints: {\n   263→      'GET /': 'This info',\n   264→      'GET /health': 'Health check',\n   265→      'GET /ffprobe-check': 'Check if FFprobe is installed',\n   266→      'GET /replicate-check': 'Check if Replicate API is configured',\n   267→      'POST /analyze': 'Analyze WAV file { wavPath }',\n   268→      'POST /silences': 'Detect silences via Whisper gaps { wavPath, threshold: 0.5 }',\n   269→      'POST /silences-audio': 'Detect silences via FFprobe { wavPath, threshold: -30, minDuration: 0.5, padding: 0.1 }',\n   270→      'POST /silences-rms': 'Detect silences via RMS analysis { wavPath, threshold: -30, minSilenceLength: 0.5, paddingStart: 0.1, paddingEnd: 0.05, autoThreshold: false, sensitivity: 50 }',\n   271→      'POST /profanity': 'Detect profanity in transcript { wavPath, language: \"en\", customBlocklist: [], customAllowlist: [] }',\n   272→      'GET /profanity/languages': 'Get supported languages for profanity detection',\n   273→      'GET /profanity/bleeps': 'Get available bleep sounds',\n   274→      'POST /repetitions': 'Detect phrase repetitions and stutters { wavPath, phraseSize: 5, tolerance: 0.7, useOpenAI: false }',\n   275→      'POST /fillers': 'Detect filler words (um, uh, like, etc.) { wavPath, customFillers: [] }',\n   276→      'POST /stutters': 'Detect single-word stutters only { wavPath, minRepeats: 2 }',\n   277→      'POST /export/captions': 'Export transcript to caption format { wavPath, format: srt|vtt|txt|json, outputPath? }',\n   278→      'GET /export/formats': 'Get supported caption export formats',\n   279→      'POST /multitrack': 'Analyze multiple audio tracks for multicam { audioPaths: [], speakerNames: [], videoTrackMapping: {} }',\n   280→      'POST /multitrack/auto-balance': 'Auto-balance speaker screentime { audioPaths: [], speakerNames: [] }',\n   281→      'POST /process-xml': 'Process FCP XML { xmlPath, silences, removeGaps: true }',\n   282→      'POST /cut-list': 'Generate JSON cut list for DOM building (v3.5) { sourceName, sourcePath, duration, silences, takes?, settings? }',\n   283→      'POST /cut-list/takes': 'Generate cut list keeping only takes { sourceName, sourcePath, duration, takes, settings? }',\n   284→      'POST /isolate-vocals': 'Isolate vocals from audio { audioPath }',\n   285→      'POST /batch/silences': 'Batch process multiple files for silence detection { files: [], options: {} }',\n   286→      'GET /batch/status/:jobId': 'Get batch job status',\n   287→      'GET /batch/results/:jobId': 'Get full batch job results',\n   288→      'GET /batch/jobs': 'List all batch jobs',\n   289→      'DELETE /batch/:jobId': 'Delete a batch job',\n   290→      'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',\n   291→      'GET /usage-history': 'Get usage history (requires x-stripe-customer-id header)',\n   292→      'POST /webhooks/stripe': 'Stripe webhook endpoint',\n   293→      'GET /referral/code': 'Get or create referral code for user',\n   294→      'POST /referral/validate': 'Validate a referral code',\n   295→      'POST /referral/apply': 'Apply referral code at signup',\n   296→      'GET /referral/stats': 'Get referral statistics for user',\n   297→      'POST /license/activate': 'Activate license key { key: \"SPLICE-XXXX-XXXX-XXXX\" }',\n   298→      'GET /license/key': 'Get license key for customer (requires x-stripe-customer-id)'\n   299→    }\n   300→  });\n   301→});\n   302→\n   303→/**\n   304→ * GET /health - Health check\n   305→ */\n   306→app.get('/health', (req, res) => {\n   307→  res.json({ status: 'ok', service: 'splice-backend' });\n   308→});\n   309→\n   310→/**\n   311→ * POST /analyze - Main analysis endpoint\n   312→ *\n   313→ * Pipeline:\n   314→ * 1. Validate input (wavPath)\n   315→ * 2. Slice 4: Transcribe audio with Groq Whisper\n   316→ * 3. Slice 5: Detect takes with GPT-4o-mini\n   317→ * 4. Return combined results\n   318→ */\n   319→app.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n   320→  const { wavPath } = req.body;\n   321→\n   322→  // Validate input\n   323→  if (!wavPath) {\n   324→    return res.status(400).json({ error: 'wavPath is required' });\n   325→  }\n   326→\n   327→  if (!fs.existsSync(wavPath)) {\n   328→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   329→  }\n   330→\n   331→  console.log(`[SPLICE] Analyzing: ${wavPath}`);\n   332→\n   333→  try {\n   334→    // Slice 4 - GPT-4o-mini transcription\n   335→    const transcript = await transcribeAudio(wavPath);\n   336→\n   337→    // Slice 5 - GPT-4o-mini take detection\n   338→    const takes = await detectTakes(transcript);\n   339→\n   340→    // Deduct usage based on audio duration\n   341→    const audioDuration = transcript.duration || 0;\n   342→    let balance = null;\n   343→    if (audioDuration > 0 && req.deductUsage) {\n   344→      balance = await req.deductUsage(audioDuration);\n   345→    }\n   346→\n   347→    res.json({\n   348→      success: true,\n   349→      wavPath,\n   350→      transcript,\n   351→      takes,\n   352→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   353→    });\n   354→  } catch (err) {\n   355→    console.error('[SPLICE] Error:', err);\n   356→    res.status(500).json({ error: err.message });\n   357→  }\n   358→});\n   359→\n   360→/**\n   361→ * POST /silences - Detect silent gaps in audio\n   362→ *\n   363→ * Pipeline:\n   364→ * 1. Transcribe audio with Whisper (reuses transcription)\n   365→ * 2. Analyze gaps between segments\n   366→ * 3. Return silence regions\n   367→ */\n   368→app.post('/silences', requireCredits({ endpoint: 'silences' }), async (req, res) => {\n   369→  const { wavPath, threshold = 0.5 } = req.body;\n   370→\n   371→  if (!wavPath) {\n   372→    return res.status(400).json({ error: 'wavPath is required' });\n   373→  }\n   374→\n   375→  if (!fs.existsSync(wavPath)) {\n   376→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   377→  }\n   378→\n   379→  console.log(`[SPLICE] Detecting silences: ${wavPath} (threshold: ${threshold}s)`);\n   380→\n   381→  try {\n   382→    const transcript = await transcribeAudio(wavPath);\n   383→    const silences = detectSilences(transcript.segments, threshold);\n   384→\n   385→    // Deduct usage based on audio duration\n   386→    const audioDuration = transcript.duration || 0;\n   387→    let balance = null;\n   388→    if (audioDuration > 0 && req.deductUsage) {\n   389→      balance = await req.deductUsage(audioDuration);\n   390→    }\n   391→\n   392→    res.json({\n   393→      success: true,\n   394→      wavPath,\n   395→      threshold,\n   396→      silences,\n   397→      count: silences.length,\n   398→      totalSilenceDuration: silences.reduce((sum, s) => sum + s.duration, 0).toFixed(2),\n   399→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   400→    });\n   401→  } catch (err) {\n   402→    console.error('[SPLICE] Silence detection error:', err);\n   403→    res.status(500).json({ error: err.message });\n   404→  }\n   405→});\n   406→\n   407→/**\n   408→ * POST /silences-audio - Detect silences using FFprobe audio analysis\n   409→ *\n   410→ * Uses actual audio levels (dB threshold) instead of transcript gaps.\n   411→ * More accurate for detecting silence vs background noise.\n   412→ */\n   413→app.post('/silences-audio', requireCredits({ endpoint: 'silences-audio' }), async (req, res) => {\n   414→  const {\n   415→    wavPath,\n   416→    threshold = -30,\n   417→    minDuration = 0.5,\n   418→    padding = 0.1\n   419→  } = req.body;\n   420→\n   421→  if (!wavPath) {\n   422→    return res.status(400).json({ error: 'wavPath is required' });\n   423→  }\n   424→\n   425→  if (!fs.existsSync(wavPath)) {\n   426→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   427→  }\n   428→\n   429→  // Check FFprobe availability\n   430→  const ffprobeAvailable = await isFFprobeInstalled();\n   431→  if (!ffprobeAvailable) {\n   432→    return res.status(500).json({\n   433→      error: 'FFprobe not installed. Run: brew install ffmpeg'\n   434→    });\n   435→  }\n   436→\n   437→  console.log(`[SPLICE] FFprobe silence detection: ${wavPath} (threshold: ${threshold}dB, min: ${minDuration}s)`);\n   438→\n   439→  try {\n   440→    const silences = await detectAudioSilences(wavPath, {\n   441→      threshold,\n   442→      minDuration,\n   443→      padding\n   444→    });\n   445→\n   446→    const totalDuration = silences.reduce((sum, s) => sum + s.duration, 0);\n   447→\n   448→    // Deduct usage based on audio duration\n   449→    let balance = null;\n   450→    try {\n   451→      const audioDuration = await getAudioDuration(wavPath);\n   452→      if (audioDuration > 0 && req.deductUsage) {\n   453→        balance = await req.deductUsage(audioDuration);\n   454→      }\n   455→    } catch (durErr) {\n   456→      console.warn('[SPLICE] Could not get audio duration for billing:', durErr.message);\n   457→    }\n   458→\n   459→    res.json({\n   460→      success: true,\n   461→      wavPath,\n   462→      threshold,\n   463→      minDuration,\n   464→      padding,\n   465→      silences,\n   466→      count: silences.length,\n   467→      totalSilenceDuration: totalDuration.toFixed(2),\n   468→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   469→    });\n   470→  } catch (err) {\n   471→    console.error('[SPLICE] FFprobe silence detection error:', err);\n   472→    res.status(500).json({ error: err.message });\n   473→  }\n   474→});\n   475→\n   476→/**\n   477→ * POST /silences-rms - Detect silences using RMS audio analysis\n   478→ *\n   479→ * Advanced silence detection with:\n   480→ * - RMS (Root Mean Square) audio level analysis\n   481→ * - Auto-threshold detection from audio histogram\n   482→ * - Configurable padding (before/after cuts)\n   483→ * - Sensitivity slider mapping (0-100)\n   484→ *\n   485→ * Options:\n   486→ * - threshold: dBFS threshold (-60 to -20, default: -30)\n   487→ * - minSilenceLength: Minimum silence duration in seconds (default: 0.5)\n   488→ * - seekStep: Analysis window step in seconds (default: 0.05)\n   489→ * - paddingStart: Buffer before silence in seconds (default: 0.1)\n   490→ * - paddingEnd: Buffer after silence in seconds (default: 0.05)\n   491→ * - autoThreshold: Auto-detect optimal threshold (default: false)\n   492→ * - sensitivity: UI sensitivity 0-100 (overrides other params if provided)\n   493→ */\n   494→app.post('/silences-rms', requireCredits({ endpoint: 'silences-rms' }), async (req, res) => {\n   495→  const { wavPath, sensitivity, ...manualOptions } = req.body;\n   496→\n   497→  if (!wavPath) {\n   498→    return res.status(400).json({ error: 'wavPath is required' });\n   499→  }\n   500→\n   501→  if (!fs.existsSync(wavPath)) {\n   502→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   503→  }\n   504→\n   505→  // Validate file size to prevent OOM\n   506→  const sizeCheck = await validateFileSize(wavPath);\n   507→  if (!sizeCheck.valid) {\n   508→    return res.status(413).json({ error: sizeCheck.error });\n   509→  }\n   510→\n   511→  // Check FFprobe availability (needed for audio extraction)\n   512→  const ffprobeAvailable = await isFFprobeInstalled();\n   513→  if (!ffprobeAvailable) {\n   514→    return res.status(500).json({\n   515→      error: 'FFprobe not installed. Run: brew install ffmpeg'\n   516→    });\n   517→  }\n   518→\n   519→  // Build options - use sensitivity if provided, otherwise use manual options\n   520→  let options = {};\n   521→  if (typeof sensitivity === 'number') {\n   522→    options = sensitivityToParams(sensitivity);\n   523→    console.log(`[SPLICE] RMS detection with sensitivity ${sensitivity}`);\n   524→  } else {\n   525→    options = {\n   526→      threshold: manualOptions.threshold ?? -30,\n   527→      minSilenceLength: manualOptions.minSilenceLength ?? 0.5,\n   528→      seekStep: manualOptions.seekStep ?? 0.05,\n   529→      paddingStart: manualOptions.paddingStart ?? 0.1,\n   530→      paddingEnd: manualOptions.paddingEnd ?? 0.05,\n   531→      autoThreshold: manualOptions.autoThreshold ?? false,\n   532→      mergeDistance: manualOptions.mergeDistance ?? 0.2\n   533→    };\n   534→  }\n   535→\n   536→  console.log(`[SPLICE] RMS silence detection: ${wavPath}`);\n   537→\n   538→  try {\n   539→    const result = await detectSilencesRMS(wavPath, options);\n   540→\n   541→    // Deduct usage based on audio duration\n   542→    const audioDuration = result.metadata?.audioDuration || 0;\n   543→    let balance = null;\n   544→    if (audioDuration > 0 && req.deductUsage) {\n   545→      balance = await req.deductUsage(audioDuration);\n   546→    }\n   547→\n   548→    res.json({\n   549→      success: true,\n   550→      wavPath,\n   551→      ...result,\n   552→      count: result.silences.length,\n   553→      totalSilenceDuration: result.metadata.totalSilenceDuration.toFixed(2),\n   554→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   555→    });\n   556→  } catch (err) {\n   557→    console.error('[SPLICE] RMS silence detection error:', err);\n   558→    res.status(500).json({ error: err.message });\n   559→  }\n   560→});\n   561→\n   562→// =============================================================================\n   563→// Profanity Detection Routes\n   564→// =============================================================================\n   565→\n   566→/**\n   567→ * POST /profanity - Detect profanity in audio/transcript\n   568→ *\n   569→ * Transcribes audio (if needed) and detects profanity words.\n   570→ * Returns word-level and segment-level results for muting/bleeping.\n   571→ *\n   572→ * Options:\n   573→ * - wavPath: Path to audio file (required)\n   574→ * - transcript: Pre-existing transcript (optional, skips transcription)\n   575→ * - language: Language code (en, es, fr, de) - default: en\n   576→ * - customBlocklist: Array or comma-separated string of additional words to censor\n   577→ * - customAllowlist: Array or comma-separated string of words to allow\n   578→ * - frameRate: Frame rate for boundary alignment (default: 30)\n   579→ */\n   580→app.post('/profanity', requireCredits({ endpoint: 'profanity' }), async (req, res) => {\n   581→  const {\n   582→    wavPath,\n   583→    transcript: providedTranscript,\n   584→    language = 'en',\n   585→    customBlocklist = [],\n   586→    customAllowlist = [],\n   587→    frameRate = 30\n   588→  } = req.body;\n   589→\n   590→  if (!wavPath && !providedTranscript) {\n   591→    return res.status(400).json({ error: 'wavPath or transcript is required' });\n   592→  }\n   593→\n   594→  if (wavPath && !fs.existsSync(wavPath)) {\n   595→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   596→  }\n   597→\n   598→  console.log(`[SPLICE] Profanity detection: ${wavPath || 'provided transcript'} (language: ${language})`);\n   599→\n   600→  try {\n   601→    // Get or create transcript with word-level timestamps\n   602→    let transcript = providedTranscript;\n   603→    if (!transcript && wavPath) {\n   604→      // Use transcribeWithWords for word-level timestamps required by profanity detection\n   605→      transcript = await transcribeWithWords(wavPath);\n   606→    }\n   607→\n   608→    // Validate transcript has words\n   609→    if (!transcript || !transcript.words || transcript.words.length === 0) {\n   610→      return res.status(400).json({\n   611→        error: 'Transcript must contain word-level timing data',\n   612→        hint: 'Ensure transcription returns words array with start/end times'\n   613→      });\n   614→    }\n   615→\n   616→    // Parse custom lists\n   617→    const blocklist = parseWordList(customBlocklist);\n   618→    const allowlist = parseWordList(customAllowlist);\n   619→\n   620→    // Detect profanity\n   621→    const result = detectProfanity(transcript, {\n   622→      language,\n   623→      customBlocklist: blocklist,\n   624→      customAllowlist: allowlist,\n   625→      frameRate\n   626→    });\n   627→\n   628→    // Deduct usage based on audio duration\n   629→    const audioDuration = transcript.duration || 0;\n   630→    let balance = null;\n   631→    if (audioDuration > 0 && req.deductUsage) {\n   632→      balance = await req.deductUsage(audioDuration);\n   633→    }\n   634→\n   635→    res.json({\n   636→      success: true,\n   637→      wavPath,\n   638→      ...result,\n   639→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   640→    });\n   641→  } catch (err) {\n   642→    console.error('[SPLICE] Profanity detection error:', err);\n   643→    res.status(500).json({ error: err.message });\n   644→  }\n   645→});\n   646→\n   647→/**\n   648→ * GET /profanity/languages - Get supported languages\n   649→ */\n   650→app.get('/profanity/languages', (req, res) => {\n   651→  res.json({\n   652→    success: true,\n   653→    languages: getSupportedLanguages()\n   654→  });\n   655→});\n   656→\n   657→/**\n   658→ * GET /profanity/bleeps - Get available bleep sounds\n   659→ */\n   660→app.get('/profanity/bleeps', (req, res) => {\n   661→  res.json({\n   662→    success: true,\n   663→    sounds: getAvailableBleepSounds()\n   664→  });\n   665→});\n   666→\n   667→/**\n   668→ * GET /profanity/list/:language - Get default profanity list for a language\n   669→ */\n   670→app.get('/profanity/list/:language', (req, res) => {\n   671→  const { language } = req.params;\n   672→  const list = getProfanityList(language);\n   673→\n   674→  res.json({\n   675→    success: true,\n   676→    language,\n   677→    wordCount: list.length,\n   678→    // Return first 50 words as sample (full list is large)\n   679→    sample: list.slice(0, 50),\n   680→    note: 'Full list available but truncated for response size'\n   681→  });\n   682→});\n   683→\n   684→// =============================================================================\n   685→// Repetition/Stutter Detection Routes\n   686→// =============================================================================\n   687→\n   688→/**\n   689→ * POST /repetitions - Detect phrase repetitions and stutters\n   690→ *\n   691→ * Analyzes transcript for repeated phrases and stutters.\n   692→ * Returns segments that can be removed to clean up the edit.\n   693→ *\n   694→ * Options:\n   695→ * - wavPath: Path to audio file (required unless transcript provided)\n   696→ * - transcript: Pre-existing transcript (optional)\n   697→ * - phraseSize: Words per comparison window (default: 5)\n   698→ * - tolerance: Similarity threshold 0-1 (default: 0.7)\n   699→ * - searchRadius: Words to search ahead (default: 100)\n   700→ * - useOpenAI: Use OpenAI for boundary refinement (default: false)\n   701→ * - includeStutters: Also detect single-word stutters (default: true)\n   702→ */\n   703→app.post('/repetitions', requireCredits({ endpoint: 'repetitions' }), async (req, res) => {\n   704→  const {\n   705→    wavPath,\n   706→    transcript: providedTranscript,\n   707→    phraseSize = 5,\n   708→    tolerance = 0.7,\n   709→    searchRadius = 100,\n   710→    useOpenAI = false,\n   711→    includeStutters = true\n   712→  } = req.body;\n   713→\n   714→  if (!wavPath && !providedTranscript) {\n   715→    return res.status(400).json({ error: 'wavPath or transcript is required' });\n   716→  }\n   717→\n   718→  if (wavPath && !fs.existsSync(wavPath)) {\n   719→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   720→  }\n   721→\n   722→  console.log(`[SPLICE] Repetition detection: ${wavPath || 'provided transcript'}`);\n   723→\n   724→  try {\n   725→    // Get or create transcript with word-level timestamps\n   726→    let transcript = providedTranscript;\n   727→    if (!transcript && wavPath) {\n   728→      // Use transcribeWithWords for word-level timestamps required by repetition detection\n   729→      transcript = await transcribeWithWords(wavPath);\n   730→    }\n   731→\n   732→    // Validate transcript has words\n   733→    if (!transcript || !transcript.words || transcript.words.length === 0) {\n   734→      return res.status(400).json({\n   735→        error: 'Transcript must contain word-level timing data'\n   736→      });\n   737→    }\n   738→\n   739→    // Detect all repetitions (phrases + stutters)\n   740→    const result = await detectAllRepetitions(transcript, {\n   741→      phraseSize,\n   742→      tolerance,\n   743→      searchRadius,\n   744→      useOpenAI\n   745→    });\n   746→\n   747→    // Optionally filter out stutters\n   748→    if (!includeStutters) {\n   749→      result.stutters = [];\n   750→      result.removalSegments = result.removalSegments.filter(s => s.type !== 'stutter');\n   751→    }\n   752→\n   753→    // Deduct usage based on audio duration\n   754→    const audioDuration = transcript.duration || 0;\n   755→    let balance = null;\n   756→    if (audioDuration > 0 && req.deductUsage) {\n   757→      balance = await req.deductUsage(audioDuration);\n   758→    }\n   759→\n   760→    res.json({\n   761→      success: true,\n   762→      wavPath,\n   763→      ...result,\n   764→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   765→    });\n   766→  } catch (err) {\n   767→    console.error('[SPLICE] Repetition detection error:', err);\n   768→    res.status(500).json({ error: err.message });\n   769→  }\n   770→});\n   771→\n   772→/**\n   773→ * POST /fillers - Detect filler words (um, uh, like, etc.)\n   774→ *\n   775→ * Transcribes audio and identifies filler words with timestamps.\n   776→ * Returns segments that can be cut or reviewed for removal.\n   777→ *\n   778→ * Options:\n   779→ * - wavPath: Path to audio file (required unless transcript provided)\n   780→ * - transcript: Pre-existing transcript with word-level timing (optional)\n   781→ * - customFillers: Additional filler words to detect (optional)\n   782→ */\n   783→app.post('/fillers', requireCredits({ endpoint: 'fillers' }), async (req, res) => {\n   784→  const {\n   785→    wavPath,\n   786→    transcript: providedTranscript,\n   787→    customFillers = []\n   788→  } = req.body;\n   789→\n   790→  if (!wavPath && !providedTranscript) {\n   791→    return res.status(400).json({ error: 'wavPath or transcript is required' });\n   792→  }\n   793→\n   794→  if (wavPath && !fs.existsSync(wavPath)) {\n   795→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   796→  }\n   797→\n   798→  console.log(`[SPLICE] Filler word detection: ${wavPath || 'provided transcript'}`);\n   799→\n   800→  try {\n   801→    // Get or create transcript with word-level timestamps\n   802→    let transcript = providedTranscript;\n   803→    if (!transcript && wavPath) {\n   804→      transcript = await transcribeWithWords(wavPath);\n   805→    }\n   806→\n   807→    // Validate transcript has words\n   808→    if (!transcript || !transcript.words || transcript.words.length === 0) {\n   809→      return res.status(400).json({\n   810→        error: 'Transcript must contain word-level timing data'\n   811→      });\n   812→    }\n   813→\n   814→    // Default filler words (common in English speech)\n   815→    const defaultFillers = [\n   816→      'um', 'uh', 'ah', 'er', 'eh',           // Hesitation sounds\n   817→      'like', 'so', 'well', 'right',           // Discourse markers\n   818→      'you know', 'i mean', 'basically',       // Filler phrases\n   819→      'actually', 'literally', 'honestly',     // Overused qualifiers\n   820→      'kind of', 'sort of', 'you see'          // Hedging phrases\n   821→    ];\n   822→\n   823→    // Combine default + custom fillers (lowercase for matching)\n   824→    const fillerSet = new Set([\n   825→      ...defaultFillers,\n   826→      ...customFillers.map(f => f.toLowerCase().trim())\n   827→    ]);\n   828→\n   829→    // Detect filler words\n   830→    const fillers = [];\n   831→    const words = transcript.words;\n   832→\n   833→    for (let i = 0; i < words.length; i++) {\n   834→      const word = words[i];\n   835→      const normalizedWord = word.word.toLowerCase().replace(/[.,!?;:'\"]/g, '').trim();\n   836→\n   837→      // Check single-word fillers\n   838→      if (fillerSet.has(normalizedWord)) {\n   839→        fillers.push({\n   840→          word: word.word,\n   841→          normalizedWord,\n   842→          start: word.start,\n   843→          end: word.end,\n   844→          duration: word.end - word.start,\n   845→          index: i,\n   846→          type: 'filler'\n   847→        });\n   848→        continue;\n   849→      }\n   850→\n   851→      // Check two-word phrases (e.g., \"you know\", \"kind of\")\n   852→      if (i < words.length - 1) {\n   853→        const nextWord = words[i + 1];\n   854→        const twoWordPhrase = `${normalizedWord} ${nextWord.word.toLowerCase().replace(/[.,!?;:'\"]/g, '').trim()}`;\n   855→        if (fillerSet.has(twoWordPhrase)) {\n   856→          fillers.push({\n   857→            word: `${word.word} ${nextWord.word}`,\n   858→            normalizedWord: twoWordPhrase,\n   859→            start: word.start,\n   860→            end: nextWord.end,\n   861→            duration: nextWord.end - word.start,\n   862→            index: i,\n   863→            type: 'filler_phrase'\n   864→          });\n   865→          // Skip next word since it's part of this phrase\n   866→          i++;\n   867→        }\n   868→      }\n   869→    }\n   870→\n   871→    // Calculate total filler time\n   872→    const totalFillerDuration = fillers.reduce((sum, f) => sum + f.duration, 0);\n   873→    const audioDuration = transcript.duration || (words.length > 0 ? words[words.length - 1].end : 0);\n   874→    const fillerPercentage = audioDuration > 0 ? (totalFillerDuration / audioDuration) * 100 : 0;\n   875→\n   876→    // Deduct usage based on audio duration\n   877→    let balance = null;\n   878→    if (audioDuration > 0 && req.deductUsage) {\n   879→      balance = await req.deductUsage(audioDuration);\n   880→    }\n   881→\n   882→    res.json({\n   883→      success: true,\n   884→      wavPath,\n   885→      fillers,\n   886→      metadata: {\n   887→        totalWords: words.length,\n   888→        fillerCount: fillers.length,\n   889→        totalFillerDuration: parseFloat(totalFillerDuration.toFixed(3)),\n   890→        audioDuration: parseFloat(audioDuration.toFixed(3)),\n   891→        fillerPercentage: parseFloat(fillerPercentage.toFixed(2)),\n   892→        fillersPerMinute: audioDuration > 0 ? parseFloat((fillers.length / (audioDuration / 60)).toFixed(2)) : 0\n   893→      },\n   894→      removalSegments: fillers.map(f => ({\n   895→        start: f.start,\n   896→        end: f.end,\n   897→        duration: f.duration,\n   898→        reason: `Filler: \"${f.word}\"`,\n   899→        type: f.type\n   900→      })),\n   901→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   902→    });\n   903→  } catch (err) {\n   904→    console.error('[SPLICE] Filler detection error:', err);\n   905→    res.status(500).json({ error: err.message });\n   906→  }\n   907→});\n   908→\n   909→/**\n   910→ * POST /stutters - Detect single-word stutters only\n   911→ *\n   912→ * Focused detection for word-level stutters (e.g., \"I I I think\").\n   913→ * Faster than full repetition detection.\n   914→ */\n   915→app.post('/stutters', requireCredits({ endpoint: 'stutters' }), async (req, res) => {\n   916→  const {\n   917→    wavPath,\n   918→    transcript: providedTranscript,\n   919→    options = {},\n   920→    // Support both top-level and nested options for flexibility\n   921→    minRepeats = options.minRepeats ?? 2,\n   922→    maxGapMs = options.maxGapMs ?? 500,\n   923→    ignoreFillers = options.ignoreFillers ?? true,\n   924→    minWordLength = options.minWordLength ?? 1\n   925→  } = req.body;\n   926→\n   927→  if (!wavPath && !providedTranscript) {\n   928→    return res.status(400).json({ error: 'wavPath or transcript is required' });\n   929→  }\n   930→\n   931→  if (wavPath && !fs.existsSync(wavPath)) {\n   932→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n   933→  }\n   934→\n   935→  console.log(`[SPLICE] Stutter detection: ${wavPath || 'provided transcript'}`);\n   936→\n   937→  try {\n   938→    // Get or create transcript with word-level timestamps\n   939→    let transcript = providedTranscript;\n   940→    if (!transcript && wavPath) {\n   941→      // Use transcribeWithWords for word-level timestamps required by stutter detection\n   942→      transcript = await transcribeWithWords(wavPath);\n   943→    }\n   944→\n   945→    // Validate transcript exists and has words array\n   946→    if (!transcript || !transcript.words) {\n   947→      return res.status(400).json({\n   948→        error: 'Transcript must contain word-level timing data'\n   949→      });\n   950→    }\n   951→\n   952→    // Empty transcript returns empty result (not an error)\n   953→    if (transcript.words.length === 0) {\n   954→      return res.json({\n   955→        success: true,\n   956→        stutters: [],\n   957→        metadata: { type: 'stutters', totalWords: 0, stutterCount: 0, totalRepeatedWords: 0 }\n   958→      });\n   959→    }\n   960→\n   961→    // Detect stutters only\n   962→    const result = detectStutters(transcript, {\n   963→      minRepeats,\n   964→      maxGapMs,\n   965→      ignoreFillers,\n   966→      minWordLength\n   967→    });\n   968→\n   969→    // Deduct usage based on audio duration\n   970→    const audioDuration = transcript.duration || 0;\n   971→    let balance = null;\n   972→    if (audioDuration > 0 && req.deductUsage) {\n   973→      balance = await req.deductUsage(audioDuration);\n   974→    }\n   975→\n   976→    res.json({\n   977→      success: true,\n   978→      wavPath,\n   979→      ...result,\n   980→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   981→    });\n   982→  } catch (err) {\n   983→    console.error('[SPLICE] Stutter detection error:', err);\n   984→    res.status(500).json({ error: err.message });\n   985→  }\n   986→});\n   987→\n   988→// =============================================================================\n   989→// Caption Export Routes\n   990→// =============================================================================\n   991→\n   992→/**\n   993→ * POST /export/captions - Export transcript to caption format (SRT, VTT, etc.)\n   994→ *\n   995→ * Converts a transcript to the specified caption format.\n   996→ * Can optionally save to file.\n   997→ *\n   998→ * Options:\n   999→ * - wavPath: Path to audio file (to transcribe first)\n  1000→ * - transcript: Pre-existing transcript with word-level timing\n  1001→ * - format: Export format (srt, vtt, txt, json) - default: srt\n  1002→ * - outputPath: Optional file path to save to\n  1003→ * - maxWordsPerCaption: Max words per caption (default: 8)\n  1004→ * - maxDuration: Max duration per caption in seconds (default: 5)\n  1005→ */\n  1006→app.post('/export/captions', requireCredits({ endpoint: 'export-captions' }), async (req, res) => {\n  1007→  const {\n  1008→    wavPath,\n  1009→    transcript: providedTranscript,\n  1010→    format = 'srt',\n  1011→    outputPath = null,\n  1012→    maxWordsPerCaption = 8,\n  1013→    maxDuration = 5\n  1014→  } = req.body;\n  1015→\n  1016→  if (!wavPath && !providedTranscript) {\n  1017→    return res.status(400).json({ error: 'wavPath or transcript is required' });\n  1018→  }\n  1019→\n  1020→  if (wavPath && !fs.existsSync(wavPath)) {\n  1021→    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  1022→  }\n  1023→\n  1024→  console.log(`[SPLICE] Caption export: ${wavPath || 'provided transcript'} -> ${format}`);\n  1025→\n  1026→  try {\n  1027→    // Get or create transcript with word-level timestamps\n  1028→    let transcript = providedTranscript;\n  1029→    if (!transcript && wavPath) {\n  1030→      transcript = await transcribeWithWords(wavPath);\n  1031→    }\n  1032→\n  1033→    const exportOptions = { maxWordsPerCaption, maxDuration };\n  1034→\n  1035→    // Generate caption content based on format\n  1036→    let content;\n  1037→    let mimeType;\n  1038→\n  1039→    switch (format.toLowerCase()) {\n  1040→      case 'srt':\n  1041→        content = toSRT(transcript, exportOptions);\n  1042→        mimeType = 'application/x-subrip';\n  1043→        break;\n  1044→      case 'vtt':\n  1045→      case 'webvtt':\n  1046→        content = toVTT(transcript, exportOptions);\n  1047→        mimeType = 'text/vtt';\n  1048→        break;\n  1049→      case 'txt':\n  1050→      case 'text':\n  1051→        content = toPlainText(transcript, { ...exportOptions, includeTimestamps: true });\n  1052→        mimeType = 'text/plain';\n  1053→        break;\n  1054→      case 'json':\n  1055→        content = toJSON(transcript);\n  1056→        mimeType = 'application/json';\n  1057→        break;\n  1058→      default:\n  1059→        return res.status(400).json({\n  1060→          error: `Unsupported format: ${format}`,\n  1061→          supportedFormats: getSupportedFormats()\n  1062→        });\n  1063→    }\n  1064→\n  1065→    // Save to file if outputPath provided\n  1066→    let savedPath = null;\n  1067→    if (outputPath) {\n  1068→      const result = await exportToFile(transcript, outputPath, format, exportOptions);\n  1069→      savedPath = result.path;\n  1070→      console.log(`[SPLICE] Saved captions to: ${savedPath}`);\n  1071→    }\n  1072→\n  1073→    // Deduct usage based on audio duration\n  1074→    const audioDuration = transcript.duration || 0;\n  1075→    let balance = null;\n  1076→    if (audioDuration > 0 && req.deductUsage) {\n  1077→      balance = await req.deductUsage(audioDuration);\n  1078→    }\n  1079→\n  1080→    res.json({\n  1081→      success: true,\n  1082→      format,\n  1083→      content,\n  1084→      mimeType,\n  1085→      savedPath,\n  1086→      wordCount: transcript.words?.length || 0,\n  1087→      duration: transcript.duration || 0,\n  1088→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n  1089→    });\n  1090→  } catch (err) {\n  1091→    console.error('[SPLICE] Caption export error:', err);\n  1092→    res.status(500).json({ error: err.message });\n  1093→  }\n  1094→});\n  1095→\n  1096→/**\n  1097→ * GET /export/formats - Get supported export formats\n  1098→ */\n  1099→app.get('/export/formats', (req, res) => {\n  1100→  res.json({\n  1101→    success: true,\n  1102→    formats: getSupportedFormats()\n  1103→  });\n  1104→});\n  1105→\n  1106→// =============================================================================\n  1107→// Multitrack/Multicam Analysis Routes\n  1108→// =============================================================================\n  1109→\n  1110→/**\n  1111→ * POST /multitrack - Analyze multiple audio tracks for multicam editing\n  1112→ *\n  1113→ * Analyzes audio levels across multiple tracks to determine optimal\n  1114→ * video angle selection based on who is speaking.\n  1115→ *\n  1116→ * Options:\n  1117→ * - audioPaths: Array of paths to audio files (one per speaker) - required\n  1118→ * - speakerNames: Array of speaker names (optional)\n  1119→ * - videoTrackMapping: Object mapping speaker index to video track { 0: 0, 1: 1 }\n  1120→ * - minShotDuration: Minimum seconds before next cut (default: 2.0)\n  1121→ * - switchingFrequency: How often to allow cuts 0-100 (default: 50)\n  1122→ * - wideShotEnabled: Enable wide shot detection (default: true)\n  1123→ * - wideShotPercentage: Target % of wide shots (default: 20)\n  1124→ * - wideShotTracks: Video track indices for wide shots\n  1125→ * - cutawayEnabled: Enable cutaway insertion (default: false)\n  1126→ * - cutawayTracks: Video track indices for cutaways\n  1127→ * - speakerBoosts: Per-speaker dB adjustments { \"Speaker 1\": 5 }\n  1128→ */\n  1129→app.post('/multitrack', requireCredits({ endpoint: 'multitrack' }), async (req, res) => {\n  1130→  const {\n  1131→    audioPaths,\n  1132→    speakerNames,\n  1133→    videoTrackMapping = {},\n  1134→    minShotDuration = 2.0,\n  1135→    switchingFrequency = 50,\n  1136→    wideShotEnabled = true,\n  1137→    wideShotPercentage = 20,\n  1138→    wideShotTracks = [],\n  1139→    cutawayEnabled = false,\n  1140→    cutawayTracks = [],\n  1141→    speakerBoosts = {},\n  1142→    frameRate = 30\n  1143→  } = req.body;\n  1144→\n  1145→  // Validate audioPaths\n  1146→  if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length === 0) {\n  1147→    return res.status(400).json({ error: 'audioPaths array is required (at least 1 path)' });\n  1148→  }\n  1149→\n  1150→  // Validate all files exist\n  1151→  for (const audioPath of audioPaths) {\n  1152→    if (!fs.existsSync(audioPath)) {\n  1153→      return res.status(404).json({ error: `File not found: ${audioPath}` });\n  1154→    }\n  1155→  }\n  1156→\n  1157→  // Check FFprobe availability\n  1158→  const ffprobeAvailable = await isFFprobeInstalled();\n  1159→  if (!ffprobeAvailable) {\n  1160→    return res.status(500).json({\n  1161→      error: 'FFprobe not installed. Run: brew install ffmpeg'\n  1162→    });\n  1163→  }\n  1164→\n  1165→  console.log(`[SPLICE] Multitrack analysis: ${audioPaths.length} track(s)`);\n  1166→\n  1167→  try {\n  1168→    const result = await analyzeMultitrack(audioPaths, {\n  1169→      speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n  1170→      videoTrackMapping,\n  1171→      minShotDuration,\n  1172→      switchingFrequency,\n  1173→      wideShotEnabled,\n  1174→      wideShotPercentage,\n  1175→      wideShotTracks,\n  1176→      cutawayEnabled,\n  1177→      cutawayTracks,\n  1178→      speakerBoosts,\n  1179→      frameRate\n  1180→    });\n  1181→\n  1182→    // Deduct usage based on total duration (use longest track)\n  1183→    const audioDuration = result.metadata?.totalDuration || 0;\n  1184→    let balance = null;\n  1185→    if (audioDuration > 0 && req.deductUsage) {\n  1186→      balance = await req.deductUsage(audioDuration);\n  1187→    }\n  1188→\n  1189→    res.json({\n  1190→      success: true,\n  1191→      ...result,\n  1192→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n  1193→    });\n  1194→  } catch (err) {\n  1195→    console.error('[SPLICE] Multitrack analysis error:', err);\n  1196→    res.status(500).json({ error: err.message });\n  1197→  }\n  1198→});\n  1199→\n  1200→/**\n  1201→ * POST /multitrack/auto-balance - Auto-balance speaker screentime\n  1202→ *\n  1203→ * Automatically adjusts speaker boosts to achieve equal screentime distribution.\n  1204→ * Runs multiple iterations to find optimal parameters.\n  1205→ */\n  1206→app.post('/multitrack/auto-balance', requireCredits({ endpoint: 'multitrack-auto-balance' }), async (req, res) => {\n  1207→  const {\n  1208→    audioPaths,\n  1209→    speakerNames,\n  1210→    videoTrackMapping = {},\n  1211→    minShotDuration = 2.0,\n  1212→    switchingFrequency = 50,\n  1213→    wideShotEnabled = false, // Disable wide shots for balance calc\n  1214→    frameRate = 30\n  1215→  } = req.body;\n  1216→\n  1217→  // Validate audioPaths\n  1218→  if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length < 2) {\n  1219→    return res.status(400).json({ error: 'audioPaths array requires at least 2 tracks for balancing' });\n  1220→  }\n  1221→\n  1222→  // Validate all files exist\n  1223→  for (const audioPath of audioPaths) {\n  1224→    if (!fs.existsSync(audioPath)) {\n  1225→      return res.status(404).json({ error: `File not found: ${audioPath}` });\n  1226→    }\n  1227→  }\n  1228→\n  1229→  // Check FFprobe availability\n  1230→  const ffprobeAvailable = await isFFprobeInstalled();\n  1231→  if (!ffprobeAvailable) {\n  1232→    return res.status(500).json({\n  1233→      error: 'FFprobe not installed. Run: brew install ffmpeg'\n  1234→    });\n  1235→  }\n  1236→\n  1237→  console.log(`[SPLICE] Auto-balancing multitrack: ${audioPaths.length} track(s)`);\n  1238→\n  1239→  try {\n  1240→    const result = await autoBalanceMultitrack(audioPaths, {\n  1241→      speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n  1242→      videoTrackMapping,\n  1243→      minShotDuration,\n  1244→      switchingFrequency,\n  1245→      wideShotEnabled,\n  1246→      frameRate\n  1247→    });\n  1248→\n  1249→    // Deduct usage based on total duration\n  1250→    const audioDuration = result.metadata?.totalDuration || 0;\n  1251→    let balance = null;\n  1252→    if (audioDuration > 0 && req.deductUsage) {\n  1253→      balance = await req.deductUsage(audioDuration);\n  1254→    }\n  1255→\n  1256→    res.json({\n  1257→      success: true,\n  1258→      ...result,\n  1259→      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n  1260→    });\n  1261→  } catch (err) {\n  1262→    console.error('[SPLICE] Auto-balance error:', err);\n  1263→    res.status(500).json({ error: err.message });\n  1264→  }\n  1265→});\n  1266→\n  1267→/**\n  1268→ * POST /process-xml - Process FCP XML to split clips at silences\n  1269→ *\n  1270→ * Takes an FCP XML file and silence timestamps, splits clips\n  1271→ * at silence boundaries, and optionally removes gaps.\n  1272→ */\n  1273→app.post('/process-xml', async (req, res) => {\n  1274→  const {\n  1275→    xmlPath,\n  1276→    silences,\n  1277→    removeGaps = true,\n  1278→    outputPath = null\n  1279→  } = req.body;\n  1280→\n  1281→  if (!xmlPath) {\n  1282→    return res.status(400).json({ error: 'xmlPath is required' });\n  1283→  }\n  1284→\n  1285→  if (!silences || !Array.isArray(silences)) {\n  1286→    return res.status(400).json({ error: 'silences array is required' });\n  1287→  }\n  1288→\n  1289→  if (!fs.existsSync(xmlPath)) {\n  1290→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n  1291→  }\n  1292→\n  1293→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n  1294→\n  1295→  try {\n  1296→    const result = await processXMLFile(xmlPath, silences, {\n  1297→      outputPath,\n  1298→      removeGaps\n  1299→    });\n  1300→\n  1301→    res.json({\n  1302→      success: true,\n  1303→      inputPath: xmlPath,\n  1304→      outputPath: result.outputPath,\n  1305→      stats: result.stats\n  1306→    });\n  1307→  } catch (err) {\n  1308→    console.error('[SPLICE] XML processing error:', err);\n  1309→    res.status(500).json({ error: err.message });\n  1310→  }\n  1311→});\n  1312→\n  1313→/**\n  1314→ * POST /cut-list - Generate a JSON cut list for direct DOM building (v3.5)\n  1315→ *\n  1316→ * Takes silences and optionally takes, returns a cut list that the\n  1317→ * plugin can use to build sequences directly via UXP APIs.\n  1318→ *\n  1319→ * Body:\n  1320→ * - sourceName: Name of the source clip\n  1321→ * - sourcePath: Full path to the source file\n  1322→ * - duration: Total duration in seconds\n  1323→ * - silences: Array of silence segments [{start, end, duration}]\n  1324→ * - takes: (optional) Array of detected takes\n  1325→ * - settings: (optional) Generation settings\n  1326→ */\n  1327→app.post('/cut-list', async (req, res) => {\n  1328→  const {\n  1329→    sourceName,\n  1330→    sourcePath,\n  1331→    duration,\n  1332→    silences,\n  1333→    takes = [],\n  1334→    settings = {}\n  1335→  } = req.body;\n  1336→\n  1337→  // Validate required fields\n  1338→  if (!sourceName && !sourcePath) {\n  1339→    return res.status(400).json({ error: 'sourceName or sourcePath is required' });\n  1340→  }\n  1341→\n  1342→  if (typeof duration !== 'number' || duration <= 0) {\n  1343→    return res.status(400).json({ error: 'duration must be a positive number' });\n  1344→  }\n  1345→\n  1346→  if (!silences || !Array.isArray(silences)) {\n  1347→    return res.status(400).json({ error: 'silences array is required' });\n  1348→  }\n  1349→\n  1350→  console.log(`[SPLICE] Generating cut list for ${sourceName || sourcePath} (${silences.length} silences)`);\n  1351→\n  1352→  try {\n  1353→    const cutList = generateCutList({\n  1354→      sourceName: sourceName || path.basename(sourcePath),\n  1355→      sourcePath,\n  1356→      duration,\n  1357→      silences,\n  1358→      takes,\n  1359→      settings\n  1360→    });\n  1361→\n  1362→    // Validate the generated cut list\n  1363→    const validation = validateCutList(cutList);\n  1364→    if (!validation.valid) {\n  1365→      return res.status(500).json({\n  1366→        error: 'Generated cut list is invalid',\n  1367→        validationErrors: validation.errors\n  1368→      });\n  1369→    }\n  1370→\n  1371→    res.json({\n  1372→      success: true,\n  1373→      cutList\n  1374→    });\n  1375→  } catch (err) {\n  1376→    console.error('[SPLICE] Cut list generation error:', err);\n  1377→    res.status(500).json({ error: err.message });\n  1378→  }\n  1379→});\n  1380→\n  1381→/**\n  1382→ * POST /cut-list/takes - Generate a cut list that keeps only takes\n  1383→ *\n  1384→ * Alternative endpoint for \"keep best takes only\" workflow.\n  1385→ */\n  1386→app.post('/cut-list/takes', async (req, res) => {\n  1387→  const {\n  1388→    sourceName,\n  1389→    sourcePath,\n  1390→    duration,\n  1391→    takes,\n  1392→    settings = {}\n  1393→  } = req.body;\n  1394→\n  1395→  // Validate required fields\n  1396→  if (!sourceName && !sourcePath) {\n  1397→    return res.status(400).json({ error: 'sourceName or sourcePath is required' });\n  1398→  }\n  1399→\n  1400→  if (typeof duration !== 'number' || duration <= 0) {\n  1401→    return res.status(400).json({ error: 'duration must be a positive number' });\n  1402→  }\n  1403→\n  1404→  if (!takes || !Array.isArray(takes) || takes.length === 0) {\n  1405→    return res.status(400).json({ error: 'takes array is required and must not be empty' });\n  1406→  }\n  1407→\n  1408→  console.log(`[SPLICE] Generating takes cut list for ${sourceName || sourcePath} (${takes.length} takes)`);\n  1409→\n  1410→  try {\n  1411→    const cutList = generateTakesCutList({\n  1412→      sourceName: sourceName || path.basename(sourcePath),\n  1413→      sourcePath,\n  1414→      duration,\n  1415→      takes,\n  1416→      settings\n  1417→    });\n  1418→\n  1419→    res.json({\n  1420→      success: true,\n  1421→      cutList\n  1422→    });\n  1423→  } catch (err) {\n  1424→    console.error('[SPLICE] Takes cut list generation error:', err);\n  1425→    res.status(500).json({ error: err.message });\n  1426→  }\n  1427→});\n  1428→\n  1429→/**\n  1430→ * GET /ffprobe-check - Check if FFprobe is installed\n  1431→ */\n  1432→app.get('/ffprobe-check', async (req, res) => {\n  1433→  const installed = await isFFprobeInstalled();\n  1434→  res.json({\n  1435→    installed,\n  1436→    message: installed\n  1437→      ? 'FFprobe is available'\n  1438→      : 'FFprobe not found. Install with: brew install ffmpeg'\n  1439→  });\n  1440→});\n  1441→\n  1442→/**\n  1443→ * GET /replicate-check - Check if Replicate API is configured\n  1444→ */\n  1445→app.get('/replicate-check', async (req, res) => {\n  1446→  const configured = isReplicateConfigured();\n  1447→  res.json({\n  1448→    configured,\n  1449→    message: configured\n  1450→      ? 'Replicate API is configured'\n  1451→      : 'REPLICATE_API_TOKEN not set. Add to .env file.'\n  1452→  });\n  1453→});\n  1454→\n  1455→/**\n  1456→ * POST /isolate-vocals - Isolate vocals from audio using Demucs\n  1457→ *\n  1458→ * Uses Replicate's Demucs model to separate vocals from background audio.\n  1459→ * Cost: ~$0.015/min of audio\n  1460→ *\n  1461→ * Tier access:\n  1462→ * - Starter: No access (upgrade required)\n  1463→ * - Pro: 2 hours included, then $0.08/min overage\n  1464→ * - Team: 5 hours included, then $0.08/min overage\n  1465→ */\n  1466→app.post('/isolate-vocals', requireCredits({ endpoint: 'isolate-vocals' }), async (req, res) => {\n  1467→  const { audioPath, stem = 'vocals', outputDir = null } = req.body;\n  1468→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  1469→\n  1470→  if (!audioPath) {\n  1471→    return res.status(400).json({ error: 'audioPath is required' });\n  1472→  }\n  1473→\n  1474→  if (!fs.existsSync(audioPath)) {\n  1475→    return res.status(404).json({ error: `File not found: ${audioPath}` });\n  1476→  }\n  1477→\n  1478→  // Check Replicate configuration\n  1479→  if (!isReplicateConfigured()) {\n  1480→    return res.status(500).json({\n  1481→      error: 'Replicate API not configured. Set REPLICATE_API_TOKEN in .env'\n  1482→    });\n  1483→  }\n  1484→\n  1485→  // Get audio duration for billing\n  1486→  let audioDurationSeconds = 0;\n  1487→  try {\n  1488→    audioDurationSeconds = await getAudioDuration(audioPath);\n  1489→  } catch (err) {\n  1490→    console.warn('[SPLICE] Could not get audio duration:', err.message);\n  1491→  }\n  1492→\n  1493→  const audioDurationMinutes = audioDurationSeconds / 60;\n  1494→\n  1495→  // Check isolation access if customer ID provided\n  1496→  if (stripeCustomerId) {\n  1497→    const accessCheck = await usageTracking.checkIsolationAccess(stripeCustomerId, audioDurationMinutes);\n  1498→\n  1499→    if (!accessCheck.allowed) {\n  1500→      return res.status(403).json({\n  1501→        error: accessCheck.message,\n  1502→        reason: accessCheck.reason,\n  1503→        upgradeRequired: accessCheck.reason === 'upgrade_required'\n  1504→      });\n  1505→    }\n  1506→\n  1507→    console.log(`[SPLICE] Isolation access: ${accessCheck.message}`);\n  1508→  }\n  1509→\n  1510→  console.log(`[SPLICE] Isolating vocals: ${audioPath} (${audioDurationMinutes.toFixed(1)} min)`);\n  1511→\n  1512→  try {\n  1513→    const result = await isolateVocals(audioPath, {\n  1514→      stem,\n  1515→      outputDir: outputDir || undefined\n  1516→    });\n  1517→\n  1518→    // Deduct isolation usage if customer ID provided\n  1519→    let usageInfo = null;\n  1520→    if (stripeCustomerId) {\n  1521→      usageInfo = await usageTracking.deductIsolationUsage(\n  1522→        stripeCustomerId,\n  1523→        audioDurationSeconds,\n  1524→        'isolate-vocals'\n  1525→      );\n  1526→      console.log(`[SPLICE] Isolation usage deducted: ${audioDurationMinutes.toFixed(1)} min`);\n  1527→      if (usageInfo.isolationUsed?.overageCost > 0) {\n  1528→        console.log(`[SPLICE] Overage cost: $${usageInfo.isolationUsed.overageCost.toFixed(2)}`);\n  1529→      }\n  1530→    }\n  1531→\n  1532→    res.json({\n  1533→      success: true,\n  1534→      inputPath: audioPath,\n  1535→      outputPath: result.outputPath,\n  1536→      stem: result.stem,\n  1537→      processingTime: result.processingTime,\n  1538→      availableStems: result.allStems,\n  1539→      audioDurationMinutes,\n  1540→      usage: usageInfo ? {\n  1541→        isolationHoursRemaining: usageInfo.isolationHoursRemaining,\n  1542→        overageCost: usageInfo.isolationUsed?.overageCost || 0\n  1543→      } : null\n  1544→    });\n  1545→  } catch (err) {\n  1546→    console.error('[SPLICE] Vocal isolation error:', err);\n  1547→    res.status(500).json({ error: err.message });\n  1548→  }\n  1549→});\n  1550→\n  1551→// =============================================================================\n  1552→// Batch Processing Routes\n  1553→// =============================================================================\n  1554→\n  1555→// In-memory job queue for batch processing\n  1556→const batchJobs = new Map();\n  1557→\n  1558→// Batch job limits to prevent memory leak\n  1559→const MAX_BATCH_JOBS = 10000;\n  1560→const BATCH_JOB_MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24 hours\n  1561→\n  1562→/**\n  1563→ * Generate a unique job ID\n  1564→ */\n  1565→function generateJobId() {\n  1566→  return `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  1567→}\n  1568→\n  1569→/**\n  1570→ * Clean up old batch jobs to prevent memory leak\n  1571→ * Removes jobs older than 24 hours\n  1572→ */\n  1573→function cleanupOldBatchJobs() {\n  1574→  const now = Date.now();\n  1575→  let removedCount = 0;\n  1576→\n  1577→  for (const [jobId, job] of batchJobs.entries()) {\n  1578→    const createdAt = new Date(job.createdAt).getTime();\n  1579→    if (now - createdAt > BATCH_JOB_MAX_AGE_MS) {\n  1580→      batchJobs.delete(jobId);\n  1581→      removedCount++;\n  1582→    }\n  1583→  }\n  1584→\n  1585→  if (removedCount > 0) {\n  1586→    console.log(`[SPLICE] Cleaned up ${removedCount} old batch job(s)`);\n  1587→  }\n  1588→}\n  1589→\n  1590→/**\n  1591→ * Enforce max job limit by removing oldest completed jobs\n  1592→ */\n  1593→function enforceJobLimit() {\n  1594→  if (batchJobs.size < MAX_BATCH_JOBS) return;\n  1595→\n  1596→  // Get completed jobs sorted by creation date (oldest first)\n  1597→  const completedJobs = Array.from(batchJobs.entries())\n  1598→    .filter(([_, job]) => job.status !== 'processing')\n  1599→    .sort((a, b) => new Date(a[1].createdAt) - new Date(b[1].createdAt));\n  1600→\n  1601→  // Remove oldest completed jobs until under limit\n  1602→  const toRemove = batchJobs.size - MAX_BATCH_JOBS + 1;\n  1603→  for (let i = 0; i < Math.min(toRemove, completedJobs.length); i++) {\n  1604→    batchJobs.delete(completedJobs[i][0]);\n  1605→  }\n  1606→\n  1607→  console.log(`[SPLICE] Enforced job limit, removed ${Math.min(toRemove, completedJobs.length)} job(s)`);\n  1608→}\n  1609→\n  1610→// Run cleanup every hour\n  1611→setInterval(cleanupOldBatchJobs, 60 * 60 * 1000);\n  1612→\n  1613→/**\n  1614→ * POST /batch/silences - Process multiple files for silence detection\n  1615→ *\n  1616→ * Creates a batch job that processes multiple audio files.\n  1617→ * Returns a job ID for tracking progress.\n  1618→ *\n  1619→ * Body:\n  1620→ * - files: Array of file paths to process\n  1621→ * - options: Detection options (sensitivity, threshold, etc.)\n  1622→ */\n  1623→app.post('/batch/silences', requireCredits({ endpoint: 'batch-silences' }), async (req, res) => {\n  1624→  const { files, options = {} } = req.body;\n  1625→\n  1626→  if (!files || !Array.isArray(files) || files.length === 0) {\n  1627→    return res.status(400).json({ error: 'files array is required' });\n  1628→  }\n  1629→\n  1630→  // Validate all files exist\n  1631→  const missingFiles = files.filter(f => !fs.existsSync(f));\n  1632→  if (missingFiles.length > 0) {\n  1633→    return res.status(404).json({\n  1634→      error: 'Some files not found',\n  1635→      missingFiles\n  1636→    });\n  1637→  }\n  1638→\n  1639→  // Enforce job limit before creating new job\n  1640→  enforceJobLimit();\n  1641→\n  1642→  const jobId = generateJobId();\n  1643→\n  1644→  // Initialize job with customer ID for usage tracking\n  1645→  const job = {\n  1646→    id: jobId,\n  1647→    type: 'silences',\n  1648→    status: 'processing',\n  1649→    createdAt: new Date().toISOString(),\n  1650→    stripeCustomerId: req.stripeCustomerId,  // Store for usage deduction\n  1651→    files: files.map(f => ({\n  1652→      path: f,\n  1653→      status: 'pending',\n  1654→      result: null,\n  1655→      error: null\n  1656→    })),\n  1657→    options,\n  1658→    progress: {\n  1659→      total: files.length,\n  1660→      completed: 0,\n  1661→      failed: 0,\n  1662→      percentage: 0\n  1663→    },\n  1664→    results: [],\n  1665→    errors: [],\n  1666→    totalUsageDeducted: 0  // Track total seconds deducted\n  1667→  };\n  1668→\n  1669→  batchJobs.set(jobId, job);\n  1670→  console.log(`[SPLICE] Batch job ${jobId} created with ${files.length} files`);\n  1671→\n  1672→  // Start processing in background\n  1673→  processBatchJob(jobId);\n  1674→\n  1675→  res.json({\n  1676→    success: true,\n  1677→    jobId,\n  1678→    message: `Batch job created with ${files.length} files`,\n  1679→    statusUrl: `/batch/status/${jobId}`\n  1680→  });\n  1681→});\n  1682→\n  1683→/**\n  1684→ * Process a batch job (runs in background)\n  1685→ */\n  1686→async function processBatchJob(jobId) {\n  1687→  const job = batchJobs.get(jobId);\n  1688→  if (!job) return;\n  1689→\n  1690→  const { sensitivity, ...manualOptions } = job.options;\n  1691→\n  1692→  // Build detection options\n  1693→  let detectionOptions = {};\n  1694→  if (typeof sensitivity === 'number') {\n  1695→    detectionOptions = sensitivityToParams(sensitivity);\n  1696→  } else {\n  1697→    detectionOptions = {\n  1698→      threshold: manualOptions.threshold ?? -30,\n  1699→      minSilenceLength: manualOptions.minSilenceLength ?? 0.5,\n  1700→      paddingStart: manualOptions.paddingStart ?? 0.1,\n  1701→      paddingEnd: manualOptions.paddingEnd ?? 0.05,\n  1702→      autoThreshold: manualOptions.autoThreshold ?? false\n  1703→    };\n  1704→  }\n  1705→\n  1706→  // Process files sequentially to avoid overwhelming the system\n  1707→  for (let i = 0; i < job.files.length; i++) {\n  1708→    const fileEntry = job.files[i];\n  1709→    fileEntry.status = 'processing';\n  1710→\n  1711→    try {\n  1712→      const result = await detectSilencesRMS(fileEntry.path, detectionOptions);\n  1713→\n  1714→      fileEntry.status = 'completed';\n  1715→      fileEntry.result = {\n  1716→        silences: result.silences,\n  1717→        count: result.silences.length,\n  1718→        totalSilenceDuration: result.metadata.totalSilenceDuration,\n  1719→        audioDuration: result.metadata.audioDuration\n  1720→      };\n  1721→\n  1722→      job.results.push({\n  1723→        file: fileEntry.path,\n  1724→        ...fileEntry.result\n  1725→      });\n  1726→\n  1727→      // Deduct usage for this file\n  1728→      const audioDuration = result.metadata?.audioDuration || 0;\n  1729→      if (audioDuration > 0 && job.stripeCustomerId) {\n  1730→        try {\n  1731→          await usageTracking.deductUsage(job.stripeCustomerId, audioDuration, 'batch-silences');\n  1732→          job.totalUsageDeducted += audioDuration;\n  1733→        } catch (usageErr) {\n  1734→          console.warn(`[SPLICE] Batch ${jobId}: Usage deduction failed:`, usageErr.message);\n  1735→        }\n  1736→      }\n  1737→\n  1738→      job.progress.completed++;\n  1739→      console.log(`[SPLICE] Batch ${jobId}: ${i + 1}/${job.files.length} completed`);\n  1740→    } catch (err) {\n  1741→      fileEntry.status = 'failed';\n  1742→      fileEntry.error = err.message;\n  1743→\n  1744→      job.errors.push({\n  1745→        file: fileEntry.path,\n  1746→        error: err.message\n  1747→      });\n  1748→\n  1749→      job.progress.failed++;\n  1750→      console.error(`[SPLICE] Batch ${jobId}: ${fileEntry.path} failed:`, err.message);\n  1751→    }\n  1752→\n  1753→    // Update progress\n  1754→    job.progress.percentage = Math.round(\n  1755→      ((job.progress.completed + job.progress.failed) / job.progress.total) * 100\n  1756→    );\n  1757→  }\n  1758→\n  1759→  // Mark job as complete\n  1760→  job.status = job.progress.failed === job.progress.total ? 'failed' :\n  1761→               job.progress.failed > 0 ? 'completed_with_errors' : 'completed';\n  1762→  job.completedAt = new Date().toISOString();\n  1763→\n  1764→  console.log(`[SPLICE] Batch job ${jobId} ${job.status}`);\n  1765→}\n  1766→\n  1767→/**\n  1768→ * GET /batch/status/:jobId - Get batch job status and results\n  1769→ */\n  1770→app.get('/batch/status/:jobId', (req, res) => {\n  1771→  const { jobId } = req.params;\n  1772→  const job = batchJobs.get(jobId);\n  1773→\n  1774→  if (!job) {\n  1775→    return res.status(404).json({ error: 'Job not found' });\n  1776→  }\n  1777→\n  1778→  res.json({\n  1779→    success: true,\n  1780→    job: {\n  1781→      id: job.id,\n  1782→      type: job.type,\n  1783→      status: job.status,\n  1784→      createdAt: job.createdAt,\n  1785→      completedAt: job.completedAt,\n  1786→      progress: job.progress,\n  1787→      files: job.files.map(f => ({\n  1788→        path: f.path,\n  1789→        status: f.status,\n  1790→        silenceCount: f.result?.count,\n  1791→        error: f.error\n  1792→      }))\n  1793→    }\n  1794→  });\n  1795→});\n  1796→\n  1797→/**\n  1798→ * GET /batch/results/:jobId - Get full results for a completed batch job\n  1799→ */\n  1800→app.get('/batch/results/:jobId', (req, res) => {\n  1801→  const { jobId } = req.params;\n  1802→  const job = batchJobs.get(jobId);\n  1803→\n  1804→  if (!job) {\n  1805→    return res.status(404).json({ error: 'Job not found' });\n  1806→  }\n  1807→\n  1808→  if (job.status === 'processing') {\n  1809→    return res.status(202).json({\n  1810→      success: false,\n  1811→      message: 'Job still processing',\n  1812→      progress: job.progress\n  1813→    });\n  1814→  }\n  1815→\n  1816→  res.json({\n  1817→    success: true,\n  1818→    jobId: job.id,\n  1819→    status: job.status,\n  1820→    progress: job.progress,\n  1821→    results: job.results,\n  1822→    errors: job.errors,\n  1823→    summary: {\n  1824→      totalFiles: job.progress.total,\n  1825→      successful: job.progress.completed,\n  1826→      failed: job.progress.failed,\n  1827→      totalSilences: job.results.reduce((sum, r) => sum + (r.count || 0), 0),\n  1828→      totalSilenceDuration: job.results.reduce((sum, r) => sum + (r.totalSilenceDuration || 0), 0)\n  1829→    }\n  1830→  });\n  1831→});\n  1832→\n  1833→/**\n  1834→ * DELETE /batch/:jobId - Cancel or delete a batch job\n  1835→ */\n  1836→app.delete('/batch/:jobId', (req, res) => {\n  1837→  const { jobId } = req.params;\n  1838→  const job = batchJobs.get(jobId);\n  1839→\n  1840→  if (!job) {\n  1841→    return res.status(404).json({ error: 'Job not found' });\n  1842→  }\n  1843→\n  1844→  // Note: This doesn't actually cancel in-progress processing\n  1845→  // but prevents the job from being queried\n  1846→  batchJobs.delete(jobId);\n  1847→\n  1848→  res.json({\n  1849→    success: true,\n  1850→    message: `Job ${jobId} deleted`\n  1851→  });\n  1852→});\n  1853→\n  1854→/**\n  1855→ * GET /batch/jobs - List all batch jobs\n  1856→ */\n  1857→app.get('/batch/jobs', (req, res) => {\n  1858→  const jobs = Array.from(batchJobs.values()).map(job => ({\n  1859→    id: job.id,\n  1860→    type: job.type,\n  1861→    status: job.status,\n  1862→    createdAt: job.createdAt,\n  1863→    completedAt: job.completedAt,\n  1864→    progress: job.progress\n  1865→  }));\n  1866→\n  1867→  // Sort by creation date (newest first)\n  1868→  jobs.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n  1869→\n  1870→  res.json({\n  1871→    success: true,\n  1872→    count: jobs.length,\n  1873→    jobs\n  1874→  });\n  1875→});\n  1876→\n  1877→// =============================================================================\n  1878→// Billing & Credits Routes\n  1879→// =============================================================================\n  1880→\n  1881→/**\n  1882→ * GET /credits - Get user's credit balance\n  1883→ *\n  1884→ * Requires x-stripe-customer-id header\n  1885→ */\n  1886→app.get('/credits', async (req, res) => {\n  1887→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  1888→\n  1889→  if (!stripeCustomerId) {\n  1890→    return res.status(401).json({\n  1891→      error: 'Authentication required',\n  1892→      message: 'Missing x-stripe-customer-id header'\n  1893→    });\n  1894→  }\n  1895→\n  1896→  try {\n  1897→    const balance = await usageTracking.getBalance(stripeCustomerId);\n  1898→    res.json({\n  1899→      success: true,\n  1900→      ...balance\n  1901→    });\n  1902→  } catch (err) {\n  1903→    console.error('[SPLICE] Credits error:', err);\n  1904→    res.status(500).json({ error: err.message });\n  1905→  }\n  1906→});\n  1907→\n  1908→/**\n  1909→ * GET /usage-history - Get user's usage history\n  1910→ */\n  1911→app.get('/usage-history', async (req, res) => {\n  1912→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  1913→\n  1914→  if (!stripeCustomerId) {\n  1915→    return res.status(401).json({\n  1916→      error: 'Authentication required',\n  1917→      message: 'Missing x-stripe-customer-id header'\n  1918→    });\n  1919→  }\n  1920→\n  1921→  try {\n  1922→    const history = await usageTracking.getUsageHistory(stripeCustomerId);\n  1923→    res.json({\n  1924→      success: true,\n  1925→      history\n  1926→    });\n  1927→  } catch (err) {\n  1928→    console.error('[SPLICE] Usage history error:', err);\n  1929→    res.status(500).json({ error: err.message });\n  1930→  }\n  1931→});\n  1932→\n  1933→// =============================================================================\n  1934→// Referral System Endpoints\n  1935→// =============================================================================\n  1936→\n  1937→/**\n  1938→ * GET /referral/code - Get or create referral code for user\n  1939→ *\n  1940→ * Requires x-stripe-customer-id header\n  1941→ */\n  1942→app.get('/referral/code', async (req, res) => {\n  1943→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  1944→\n  1945→  if (!stripeCustomerId) {\n  1946→    return res.status(401).json({\n  1947→      error: 'Authentication required',\n  1948→      message: 'Missing x-stripe-customer-id header'\n  1949→    });\n  1950→  }\n  1951→\n  1952→  try {\n  1953→    const codeInfo = await referralService.getOrCreateCode(stripeCustomerId);\n  1954→    res.json({\n  1955→      success: true,\n  1956→      ...codeInfo\n  1957→    });\n  1958→  } catch (err) {\n  1959→    console.error('[SPLICE] Referral code error:', err);\n  1960→    res.status(500).json({ error: err.message });\n  1961→  }\n  1962→});\n  1963→\n  1964→/**\n  1965→ * POST /referral/validate - Validate a referral code\n  1966→ *\n  1967→ * Body: { code: string, customerId?: string }\n  1968→ */\n  1969→app.post('/referral/validate', async (req, res) => {\n  1970→  const { code, customerId } = req.body;\n  1971→\n  1972→  if (!code) {\n  1973→    return res.status(400).json({\n  1974→      error: 'Missing code',\n  1975→      message: 'Referral code is required'\n  1976→    });\n  1977→  }\n  1978→\n  1979→  try {\n  1980→    const result = await referralService.validateCode(code, customerId);\n  1981→    res.json({\n  1982→      success: true,\n  1983→      ...result\n  1984→    });\n  1985→  } catch (err) {\n  1986→    console.error('[SPLICE] Referral validate error:', err);\n  1987→    res.status(500).json({ error: err.message });\n  1988→  }\n  1989→});\n  1990→\n  1991→/**\n  1992→ * POST /referral/apply - Apply referral code at signup\n  1993→ *\n  1994→ * Body: { code: string, customerId: string }\n  1995→ */\n  1996→app.post('/referral/apply', async (req, res) => {\n  1997→  const { code, customerId } = req.body;\n  1998→\n  1999→  if (!code || !customerId) {\n  2000→    return res.status(400).json({\n  2001→      error: 'Missing required fields',\n  2002→      message: 'Both code and customerId are required'\n  2003→    });\n  2004→  }\n  2005→\n  2006→  try {\n  2007→    const result = await referralService.applyCode(code, customerId, stripe);\n  2008→    res.json({\n  2009→      success: true,\n  2010→      ...result\n  2011→    });\n  2012→  } catch (err) {\n  2013→    console.error('[SPLICE] Referral apply error:', err);\n  2014→    // Return user-friendly errors for validation failures\n  2015→    if (err.message.includes('Cannot use your own') ||\n  2016→        err.message.includes('already used') ||\n  2017→        err.message.includes('not found') ||\n  2018→        err.message.includes('no longer active')) {\n  2019→      return res.status(400).json({ error: err.message });\n  2020→    }\n  2021→    res.status(500).json({ error: err.message });\n  2022→  }\n  2023→});\n  2024→\n  2025→/**\n  2026→ * GET /referral/stats - Get referral statistics for user\n  2027→ *\n  2028→ * Requires x-stripe-customer-id header\n  2029→ */\n  2030→app.get('/referral/stats', async (req, res) => {\n  2031→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  2032→\n  2033→  if (!stripeCustomerId) {\n  2034→    return res.status(401).json({\n  2035→      error: 'Authentication required',\n  2036→      message: 'Missing x-stripe-customer-id header'\n  2037→    });\n  2038→  }\n  2039→\n  2040→  try {\n  2041→    const stats = await referralService.getStats(stripeCustomerId);\n  2042→    res.json({\n  2043→      success: true,\n  2044→      ...stats\n  2045→    });\n  2046→  } catch (err) {\n  2047→    console.error('[SPLICE] Referral stats error:', err);\n  2048→    res.status(500).json({ error: err.message });\n  2049→  }\n  2050→});\n  2051→\n  2052→// =============================================================================\n  2053→// License Key Endpoints\n  2054→// =============================================================================\n  2055→\n  2056→/**\n  2057→ * POST /license/activate - Activate a license key\n  2058→ *\n  2059→ * Body: { key: \"SPLICE-XXXX-XXXX-XXXX\" }\n  2060→ * Returns: { success, customerId, tier, hoursRemaining }\n  2061→ */\n  2062→app.post('/license/activate', async (req, res) => {\n  2063→  const { key } = req.body;\n  2064→\n  2065→  if (!key) {\n  2066→    return res.status(400).json({\n  2067→      error: 'Missing license key',\n  2068→      message: 'License key is required'\n  2069→    });\n  2070→  }\n  2071→\n  2072→  // Validate format\n  2073→  if (!licenseService.isValidKeyFormat(key)) {\n  2074→    return res.status(400).json({\n  2075→      error: 'Invalid license key format',\n  2076→      message: 'License key should be in format: SPLICE-XXXX-XXXX-XXXX'\n  2077→    });\n  2078→  }\n  2079→\n  2080→  try {\n  2081→    // Activate the key\n  2082→    const result = await licenseService.activateLicenseKey(key);\n  2083→\n  2084→    if (!result.success) {\n  2085→      return res.status(400).json({\n  2086→        success: false,\n  2087→        error: result.error\n  2088→      });\n  2089→    }\n  2090→\n  2091→    // Get the customer's balance and tier info\n  2092→    const balance = await usageTracking.getBalance(result.customerId);\n  2093→\n  2094→    res.json({\n  2095→      success: true,\n  2096→      customerId: result.customerId,\n  2097→      tier: balance.tier,\n  2098→      tierName: balance.tierName,\n  2099→      hoursRemaining: balance.hoursRemaining,\n  2100→      hoursTotal: balance.hoursTotal\n  2101→    });\n  2102→  } catch (err) {\n  2103→    console.error('[SPLICE] License activation error:', err);\n  2104→    res.status(500).json({ error: err.message });\n  2105→  }\n  2106→});\n  2107→\n  2108→/**\n  2109→ * GET /license/key - Get license key for a customer (for display/resend)\n  2110→ *\n  2111→ * Requires x-stripe-customer-id header\n  2112→ */\n  2113→app.get('/license/key', async (req, res) => {\n  2114→  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  2115→\n  2116→  if (!stripeCustomerId) {\n  2117→    return res.status(401).json({\n  2118→      error: 'Authentication required',\n  2119→      message: 'Missing x-stripe-customer-id header'\n  2120→    });\n  2121→  }\n  2122→\n  2123→  try {\n  2124→    const result = await licenseService.getLicenseByCustomerId(stripeCustomerId);\n  2125→\n  2126→    if (!result.success) {\n  2127→      return res.status(404).json({\n  2128→        success: false,\n  2129→        error: result.error\n  2130→      });\n  2131→    }\n  2132→\n  2133→    res.json({\n  2134→      success: true,\n  2135→      key: result.key,\n  2136→      activated: result.activated,\n  2137→      createdAt: result.createdAt\n  2138→    });\n  2139→  } catch (err) {\n  2140→    console.error('[SPLICE] License lookup error:', err);\n  2141→    res.status(500).json({ error: err.message });\n  2142→  }\n  2143→});\n  2144→\n  2145→// =============================================================================\n  2146→// Start Server\n  2147→// =============================================================================\n  2148→\n  2149→// Initialize database and start server\n  2150→async function startServer() {\n  2151→  try {\n  2152→    await usageTracking.initDatabase();\n  2153→    await referralService.initReferralTables();\n  2154→    await licenseService.initLicenseTables();\n  2155→    console.log('[SPLICE] Database initialized');\n  2156→\n  2157→    if (isProduction || !httpsOptions) {\n  2158→      // Production: Railway provides TLS termination, use HTTP\n  2159→      http.createServer(app).listen(PORT, () => {\n  2160→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n  2161→      });\n  2162→    } else {\n  2163→      // Development: Use HTTPS with local certificates\n  2164→      https.createServer(httpsOptions, app).listen(PORT, () => {\n  2165→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n  2166→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n  2167→      });\n  2168→    }\n  2169→  } catch (err) {\n  2170→    console.error('[SPLICE] Failed to start server:', err);\n  2171→    process.exit(1);\n  2172→  }\n  2173→}\n  2174→\n  2175→startServer();\n  2176→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d3c31432-cb34-4aa1-8c73-9f4e23b64b03","timestamp":"2025-12-25T23:26:31.935Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"/**\n * SPLICE Backend Server\n *\n * Main entry point for the SPLICE backend API.\n * Orchestrates the audio analysis pipeline.\n *\n * Slices:\n * - Slice 4: Transcription (services/transcription.js)\n * - Slice 5: Take Detection (services/takeDetection.js)\n */\n\nrequire('dotenv').config();\n\nconst express = require('express');\nconst cors = require('cors');\nconst fs = require('fs');\nconst https = require('https');\nconst http = require('http');\nconst path = require('path');\n\n// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// Import slice services\nconst { transcribeAudio, transcribeWithWords } = require('./services/transcription');\nconst { detectTakes } = require('./services/takeDetection');\nconst { detectSilences } = require('./services/silenceDetection');\nconst { detectAudioSilences, isFFprobeInstalled, getAudioDuration } = require('./services/ffprobeSilence');\nconst { detectSilencesRMS, sensitivityToParams } = require('./services/rmsSilenceDetection');\nconst {\n  detectProfanity,\n  getProfanityList,\n  getSupportedLanguages,\n  getAvailableBleepSounds,\n  parseWordList\n} = require('./services/profanityDetection');\nconst {\n  detectRepetitionsBasic,\n  detectRepetitionsAdvanced,\n  detectStutters,\n  detectAllRepetitions\n} = require('./services/repetitionDetection');\nconst {\n  analyzeMultitrack,\n  autoBalanceMultitrack\n} = require('./services/multitrackAnalysis');\nconst {\n  toSRT,\n  toVTT,\n  toPlainText,\n  toJSON,\n  exportToFile,\n  getSupportedFormats\n} = require('./services/captionExporter');\nconst { processXMLFile } = require('./services/xmlProcessor');\nconst { isolateVocals, isReplicateConfigured } = require('./services/vocalIsolation');\nconst { generateCutList, generateTakesCutList, validateCutList } = require('./services/cutListGenerator');\n\n// Usage tracking and billing\nconst usageTracking = require('./services/usageTracking');\n// Rate limiter for usage-based endpoints\nconst { requireCredits } = require('./middleware/rateLimiter');\n// Referral system\nconst referralService = require('./services/referralService');\n// License key system\nconst licenseService = require('./services/licenseService');\n\n// Maximum file size for audio processing (500MB)\nconst MAX_FILE_SIZE_BYTES = 500 * 1024 * 1024;\n\n/**\n * Validate file size to prevent OOM crashes\n * @param {string} filePath - Path to file\n * @returns {Promise<{valid: boolean, size?: number, error?: string}>}\n */\nasync function validateFileSize(filePath) {\n  try {\n    const stats = await require('fs').promises.stat(filePath);\n    if (stats.size > MAX_FILE_SIZE_BYTES) {\n      return {\n        valid: false,\n        size: stats.size,\n        error: `File too large (${(stats.size / 1024 / 1024).toFixed(1)}MB). Maximum allowed: ${MAX_FILE_SIZE_BYTES / 1024 / 1024}MB`\n      };\n    }\n    return { valid: true, size: stats.size };\n  } catch (err) {\n    return { valid: false, error: `Cannot access file: ${err.message}` };\n  }\n}\n\n// Stripe for webhooks\nconst Stripe = require('stripe');\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n\n// =============================================================================\n// Server Configuration\n// =============================================================================\n\nconst app = express();\nconst PORT = process.env.PORT || 3847;\n\n// HTTPS certificates (generated by mkcert) - only for local development\nlet httpsOptions = null;\nif (!isProduction) {\n  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n  const certPath = path.join(__dirname, 'localhost+1.pem');\n  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n    httpsOptions = {\n      key: fs.readFileSync(keyPath),\n      cert: fs.readFileSync(certPath)\n    };\n  }\n}\n\napp.use(cors());\n\n// Helper to determine tier from price ID with logging\nfunction getTierFromPriceId(priceId) {\n  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n\n  // Log unknown price ID for debugging\n  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n  return 'starter';\n}\n\n// Stripe webhook needs raw body - must be before express.json()\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n  let event;\n\n  try {\n    if (webhookSecret) {\n      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } else if (isProduction) {\n      // SECURITY: Reject unsigned webhooks in production\n      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n    } else {\n      // For local development testing only\n      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n      event = JSON.parse(bodyString);\n      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n    return res.status(400).json({ error: 'Webhook signature verification failed' });\n  }\n\n  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n\n  // Idempotency check - skip if already processed\n  if (await usageTracking.isEventProcessed(event.id)) {\n    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n    return res.json({ received: true, skipped: true });\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Get tier from price ID\n        const priceId = subscription.items?.data?.[0]?.price?.id;\n        const tier = getTierFromPriceId(priceId);\n\n        // Update user tier and reset hours\n        await usageTracking.updateTier(customerId, tier);\n        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n\n        // Generate license key for new subscriptions\n        if (event.type === 'customer.subscription.created') {\n          const licenseResult = await licenseService.generateLicenseKey(customerId);\n          if (licenseResult.success) {\n            console.log(`[SPLICE] Generated license key for ${customerId}: ${licenseResult.key}`);\n          } else {\n            console.error(`[SPLICE] Failed to generate license key: ${licenseResult.error}`);\n          }\n        }\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Downgrade to cancelled (0 hours)\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const subscriptionId = invoice.subscription;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in invoice event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Reset hours on successful payment (new billing period)\n        if (subscriptionId) {\n          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n          const priceId = subscription.items?.data?.[0]?.price?.id;\n          const tier = getTierFromPriceId(priceId);\n\n          await usageTracking.resetHours(customerId, tier);\n          console.log(`[SPLICE] Reset hours for customer ${customerId} (tier: ${tier})`);\n        }\n        break;\n      }\n\n      default:\n        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n    }\n\n    // Record event as processed (idempotency)\n    await usageTracking.recordWebhookEvent(event.id, event.type);\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error('[SPLICE] Webhook handler error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.use(express.json());\n\n// =============================================================================\n// Routes\n// =============================================================================\n\n/**\n * GET / - API information\n */\napp.get('/', (req, res) => {\n  res.json({\n    service: 'splice-backend',\n    version: '0.3.0',\n    endpoints: {\n      'GET /': 'This info',\n      'GET /health': 'Health check',\n      'GET /ffprobe-check': 'Check if FFprobe is installed',\n      'GET /replicate-check': 'Check if Replicate API is configured',\n      'POST /analyze': 'Analyze WAV file { wavPath }',\n      'POST /silences': 'Detect silences via Whisper gaps { wavPath, threshold: 0.5 }',\n      'POST /silences-audio': 'Detect silences via FFprobe { wavPath, threshold: -30, minDuration: 0.5, padding: 0.1 }',\n      'POST /silences-rms': 'Detect silences via RMS analysis { wavPath, threshold: -30, minSilenceLength: 0.5, paddingStart: 0.1, paddingEnd: 0.05, autoThreshold: false, sensitivity: 50 }',\n      'POST /profanity': 'Detect profanity in transcript { wavPath, language: \"en\", customBlocklist: [], customAllowlist: [] }',\n      'GET /profanity/languages': 'Get supported languages for profanity detection',\n      'GET /profanity/bleeps': 'Get available bleep sounds',\n      'POST /repetitions': 'Detect phrase repetitions and stutters { wavPath, phraseSize: 5, tolerance: 0.7, useOpenAI: false }',\n      'POST /fillers': 'Detect filler words (um, uh, like, etc.) { wavPath, customFillers: [] }',\n      'POST /stutters': 'Detect single-word stutters only { wavPath, minRepeats: 2 }',\n      'POST /export/captions': 'Export transcript to caption format { wavPath, format: srt|vtt|txt|json, outputPath? }',\n      'GET /export/formats': 'Get supported caption export formats',\n      'POST /multitrack': 'Analyze multiple audio tracks for multicam { audioPaths: [], speakerNames: [], videoTrackMapping: {} }',\n      'POST /multitrack/auto-balance': 'Auto-balance speaker screentime { audioPaths: [], speakerNames: [] }',\n      'POST /process-xml': 'Process FCP XML { xmlPath, silences, removeGaps: true }',\n      'POST /cut-list': 'Generate JSON cut list for DOM building (v3.5) { sourceName, sourcePath, duration, silences, takes?, settings? }',\n      'POST /cut-list/takes': 'Generate cut list keeping only takes { sourceName, sourcePath, duration, takes, settings? }',\n      'POST /isolate-vocals': 'Isolate vocals from audio { audioPath }',\n      'POST /batch/silences': 'Batch process multiple files for silence detection { files: [], options: {} }',\n      'GET /batch/status/:jobId': 'Get batch job status',\n      'GET /batch/results/:jobId': 'Get full batch job results',\n      'GET /batch/jobs': 'List all batch jobs',\n      'DELETE /batch/:jobId': 'Delete a batch job',\n      'GET /credits': 'Get user credit balance (requires x-stripe-customer-id header)',\n      'GET /usage-history': 'Get usage history (requires x-stripe-customer-id header)',\n      'POST /webhooks/stripe': 'Stripe webhook endpoint',\n      'GET /referral/code': 'Get or create referral code for user',\n      'POST /referral/validate': 'Validate a referral code',\n      'POST /referral/apply': 'Apply referral code at signup',\n      'GET /referral/stats': 'Get referral statistics for user',\n      'POST /license/activate': 'Activate license key { key: \"SPLICE-XXXX-XXXX-XXXX\" }',\n      'GET /license/key': 'Get license key for customer (requires x-stripe-customer-id)'\n    }\n  });\n});\n\n/**\n * GET /health - Health check\n */\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok', service: 'splice-backend' });\n});\n\n/**\n * POST /analyze - Main analysis endpoint\n *\n * Pipeline:\n * 1. Validate input (wavPath)\n * 2. Slice 4: Transcribe audio with Groq Whisper\n * 3. Slice 5: Detect takes with GPT-4o-mini\n * 4. Return combined results\n */\napp.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n  const { wavPath } = req.body;\n\n  // Validate input\n  if (!wavPath) {\n    return res.status(400).json({ error: 'wavPath is required' });\n  }\n\n  if (!fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  console.log(`[SPLICE] Analyzing: ${wavPath}`);\n\n  try {\n    // Slice 4 - GPT-4o-mini transcription\n    const transcript = await transcribeAudio(wavPath);\n\n    // Slice 5 - GPT-4o-mini take detection\n    const takes = await detectTakes(transcript);\n\n    // Deduct usage based on audio duration\n    const audioDuration = transcript.duration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      transcript,\n      takes,\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /silences - Detect silent gaps in audio\n *\n * Pipeline:\n * 1. Transcribe audio with Whisper (reuses transcription)\n * 2. Analyze gaps between segments\n * 3. Return silence regions\n */\napp.post('/silences', requireCredits({ endpoint: 'silences' }), async (req, res) => {\n  const { wavPath, threshold = 0.5 } = req.body;\n\n  if (!wavPath) {\n    return res.status(400).json({ error: 'wavPath is required' });\n  }\n\n  if (!fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  console.log(`[SPLICE] Detecting silences: ${wavPath} (threshold: ${threshold}s)`);\n\n  try {\n    const transcript = await transcribeAudio(wavPath);\n    const silences = detectSilences(transcript.segments, threshold);\n\n    // Deduct usage based on audio duration\n    const audioDuration = transcript.duration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      threshold,\n      silences,\n      count: silences.length,\n      totalSilenceDuration: silences.reduce((sum, s) => sum + s.duration, 0).toFixed(2),\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Silence detection error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /silences-audio - Detect silences using FFprobe audio analysis\n *\n * Uses actual audio levels (dB threshold) instead of transcript gaps.\n * More accurate for detecting silence vs background noise.\n */\napp.post('/silences-audio', requireCredits({ endpoint: 'silences-audio' }), async (req, res) => {\n  const {\n    wavPath,\n    threshold = -30,\n    minDuration = 0.5,\n    padding = 0.1\n  } = req.body;\n\n  if (!wavPath) {\n    return res.status(400).json({ error: 'wavPath is required' });\n  }\n\n  if (!fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  // Check FFprobe availability\n  const ffprobeAvailable = await isFFprobeInstalled();\n  if (!ffprobeAvailable) {\n    return res.status(500).json({\n      error: 'FFprobe not installed. Run: brew install ffmpeg'\n    });\n  }\n\n  console.log(`[SPLICE] FFprobe silence detection: ${wavPath} (threshold: ${threshold}dB, min: ${minDuration}s)`);\n\n  try {\n    const silences = await detectAudioSilences(wavPath, {\n      threshold,\n      minDuration,\n      padding\n    });\n\n    const totalDuration = silences.reduce((sum, s) => sum + s.duration, 0);\n\n    // Deduct usage based on audio duration\n    let balance = null;\n    try {\n      const audioDuration = await getAudioDuration(wavPath);\n      if (audioDuration > 0 && req.deductUsage) {\n        balance = await req.deductUsage(audioDuration);\n      }\n    } catch (durErr) {\n      console.warn('[SPLICE] Could not get audio duration for billing:', durErr.message);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      threshold,\n      minDuration,\n      padding,\n      silences,\n      count: silences.length,\n      totalSilenceDuration: totalDuration.toFixed(2),\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] FFprobe silence detection error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /silences-rms - Detect silences using RMS audio analysis\n *\n * Advanced silence detection with:\n * - RMS (Root Mean Square) audio level analysis\n * - Auto-threshold detection from audio histogram\n * - Configurable padding (before/after cuts)\n * - Sensitivity slider mapping (0-100)\n *\n * Options:\n * - threshold: dBFS threshold (-60 to -20, default: -30)\n * - minSilenceLength: Minimum silence duration in seconds (default: 0.5)\n * - seekStep: Analysis window step in seconds (default: 0.05)\n * - paddingStart: Buffer before silence in seconds (default: 0.1)\n * - paddingEnd: Buffer after silence in seconds (default: 0.05)\n * - autoThreshold: Auto-detect optimal threshold (default: false)\n * - sensitivity: UI sensitivity 0-100 (overrides other params if provided)\n */\napp.post('/silences-rms', requireCredits({ endpoint: 'silences-rms' }), async (req, res) => {\n  const { wavPath, sensitivity, ...manualOptions } = req.body;\n\n  if (!wavPath) {\n    return res.status(400).json({ error: 'wavPath is required' });\n  }\n\n  if (!fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  // Validate file size to prevent OOM\n  const sizeCheck = await validateFileSize(wavPath);\n  if (!sizeCheck.valid) {\n    return res.status(413).json({ error: sizeCheck.error });\n  }\n\n  // Check FFprobe availability (needed for audio extraction)\n  const ffprobeAvailable = await isFFprobeInstalled();\n  if (!ffprobeAvailable) {\n    return res.status(500).json({\n      error: 'FFprobe not installed. Run: brew install ffmpeg'\n    });\n  }\n\n  // Build options - use sensitivity if provided, otherwise use manual options\n  let options = {};\n  if (typeof sensitivity === 'number') {\n    options = sensitivityToParams(sensitivity);\n    console.log(`[SPLICE] RMS detection with sensitivity ${sensitivity}`);\n  } else {\n    options = {\n      threshold: manualOptions.threshold ?? -30,\n      minSilenceLength: manualOptions.minSilenceLength ?? 0.5,\n      seekStep: manualOptions.seekStep ?? 0.05,\n      paddingStart: manualOptions.paddingStart ?? 0.1,\n      paddingEnd: manualOptions.paddingEnd ?? 0.05,\n      autoThreshold: manualOptions.autoThreshold ?? false,\n      mergeDistance: manualOptions.mergeDistance ?? 0.2\n    };\n  }\n\n  console.log(`[SPLICE] RMS silence detection: ${wavPath}`);\n\n  try {\n    const result = await detectSilencesRMS(wavPath, options);\n\n    // Deduct usage based on audio duration\n    const audioDuration = result.metadata?.audioDuration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      ...result,\n      count: result.silences.length,\n      totalSilenceDuration: result.metadata.totalSilenceDuration.toFixed(2),\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] RMS silence detection error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// =============================================================================\n// Profanity Detection Routes\n// =============================================================================\n\n/**\n * POST /profanity - Detect profanity in audio/transcript\n *\n * Transcribes audio (if needed) and detects profanity words.\n * Returns word-level and segment-level results for muting/bleeping.\n *\n * Options:\n * - wavPath: Path to audio file (required)\n * - transcript: Pre-existing transcript (optional, skips transcription)\n * - language: Language code (en, es, fr, de) - default: en\n * - customBlocklist: Array or comma-separated string of additional words to censor\n * - customAllowlist: Array or comma-separated string of words to allow\n * - frameRate: Frame rate for boundary alignment (default: 30)\n */\napp.post('/profanity', requireCredits({ endpoint: 'profanity' }), async (req, res) => {\n  const {\n    wavPath,\n    transcript: providedTranscript,\n    language = 'en',\n    customBlocklist = [],\n    customAllowlist = [],\n    frameRate = 30\n  } = req.body;\n\n  if (!wavPath && !providedTranscript) {\n    return res.status(400).json({ error: 'wavPath or transcript is required' });\n  }\n\n  if (wavPath && !fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  console.log(`[SPLICE] Profanity detection: ${wavPath || 'provided transcript'} (language: ${language})`);\n\n  try {\n    // Get or create transcript with word-level timestamps\n    let transcript = providedTranscript;\n    if (!transcript && wavPath) {\n      // Use transcribeWithWords for word-level timestamps required by profanity detection\n      transcript = await transcribeWithWords(wavPath);\n    }\n\n    // Validate transcript has words\n    if (!transcript || !transcript.words || transcript.words.length === 0) {\n      return res.status(400).json({\n        error: 'Transcript must contain word-level timing data',\n        hint: 'Ensure transcription returns words array with start/end times'\n      });\n    }\n\n    // Parse custom lists\n    const blocklist = parseWordList(customBlocklist);\n    const allowlist = parseWordList(customAllowlist);\n\n    // Detect profanity\n    const result = detectProfanity(transcript, {\n      language,\n      customBlocklist: blocklist,\n      customAllowlist: allowlist,\n      frameRate\n    });\n\n    // Deduct usage based on audio duration\n    const audioDuration = transcript.duration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      ...result,\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Profanity detection error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * GET /profanity/languages - Get supported languages\n */\napp.get('/profanity/languages', (req, res) => {\n  res.json({\n    success: true,\n    languages: getSupportedLanguages()\n  });\n});\n\n/**\n * GET /profanity/bleeps - Get available bleep sounds\n */\napp.get('/profanity/bleeps', (req, res) => {\n  res.json({\n    success: true,\n    sounds: getAvailableBleepSounds()\n  });\n});\n\n/**\n * GET /profanity/list/:language - Get default profanity list for a language\n */\napp.get('/profanity/list/:language', (req, res) => {\n  const { language } = req.params;\n  const list = getProfanityList(language);\n\n  res.json({\n    success: true,\n    language,\n    wordCount: list.length,\n    // Return first 50 words as sample (full list is large)\n    sample: list.slice(0, 50),\n    note: 'Full list available but truncated for response size'\n  });\n});\n\n// =============================================================================\n// Repetition/Stutter Detection Routes\n// =============================================================================\n\n/**\n * POST /repetitions - Detect phrase repetitions and stutters\n *\n * Analyzes transcript for repeated phrases and stutters.\n * Returns segments that can be removed to clean up the edit.\n *\n * Options:\n * - wavPath: Path to audio file (required unless transcript provided)\n * - transcript: Pre-existing transcript (optional)\n * - phraseSize: Words per comparison window (default: 5)\n * - tolerance: Similarity threshold 0-1 (default: 0.7)\n * - searchRadius: Words to search ahead (default: 100)\n * - useOpenAI: Use OpenAI for boundary refinement (default: false)\n * - includeStutters: Also detect single-word stutters (default: true)\n */\napp.post('/repetitions', requireCredits({ endpoint: 'repetitions' }), async (req, res) => {\n  const {\n    wavPath,\n    transcript: providedTranscript,\n    phraseSize = 5,\n    tolerance = 0.7,\n    searchRadius = 100,\n    useOpenAI = false,\n    includeStutters = true\n  } = req.body;\n\n  if (!wavPath && !providedTranscript) {\n    return res.status(400).json({ error: 'wavPath or transcript is required' });\n  }\n\n  if (wavPath && !fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  console.log(`[SPLICE] Repetition detection: ${wavPath || 'provided transcript'}`);\n\n  try {\n    // Get or create transcript with word-level timestamps\n    let transcript = providedTranscript;\n    if (!transcript && wavPath) {\n      // Use transcribeWithWords for word-level timestamps required by repetition detection\n      transcript = await transcribeWithWords(wavPath);\n    }\n\n    // Validate transcript has words\n    if (!transcript || !transcript.words || transcript.words.length === 0) {\n      return res.status(400).json({\n        error: 'Transcript must contain word-level timing data'\n      });\n    }\n\n    // Detect all repetitions (phrases + stutters)\n    const result = await detectAllRepetitions(transcript, {\n      phraseSize,\n      tolerance,\n      searchRadius,\n      useOpenAI\n    });\n\n    // Optionally filter out stutters\n    if (!includeStutters) {\n      result.stutters = [];\n      result.removalSegments = result.removalSegments.filter(s => s.type !== 'stutter');\n    }\n\n    // Deduct usage based on audio duration\n    const audioDuration = transcript.duration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      ...result,\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Repetition detection error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /fillers - Detect filler words (um, uh, like, etc.)\n *\n * Transcribes audio and identifies filler words with timestamps.\n * Returns segments that can be cut or reviewed for removal.\n *\n * Options:\n * - wavPath: Path to audio file (required unless transcript provided)\n * - transcript: Pre-existing transcript with word-level timing (optional)\n * - customFillers: Additional filler words to detect (optional)\n */\napp.post('/fillers', requireCredits({ endpoint: 'fillers' }), async (req, res) => {\n  const {\n    wavPath,\n    transcript: providedTranscript,\n    customFillers = []\n  } = req.body;\n\n  if (!wavPath && !providedTranscript) {\n    return res.status(400).json({ error: 'wavPath or transcript is required' });\n  }\n\n  if (wavPath && !fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  console.log(`[SPLICE] Filler word detection: ${wavPath || 'provided transcript'}`);\n\n  try {\n    // Get or create transcript with word-level timestamps\n    let transcript = providedTranscript;\n    if (!transcript && wavPath) {\n      transcript = await transcribeWithWords(wavPath);\n    }\n\n    // Validate transcript has words\n    if (!transcript || !transcript.words || transcript.words.length === 0) {\n      return res.status(400).json({\n        error: 'Transcript must contain word-level timing data'\n      });\n    }\n\n    // Default filler words (common in English speech)\n    const defaultFillers = [\n      'um', 'uh', 'ah', 'er', 'eh',           // Hesitation sounds\n      'like', 'so', 'well', 'right',           // Discourse markers\n      'you know', 'i mean', 'basically',       // Filler phrases\n      'actually', 'literally', 'honestly',     // Overused qualifiers\n      'kind of', 'sort of', 'you see'          // Hedging phrases\n    ];\n\n    // Combine default + custom fillers (lowercase for matching)\n    const fillerSet = new Set([\n      ...defaultFillers,\n      ...customFillers.map(f => f.toLowerCase().trim())\n    ]);\n\n    // Detect filler words\n    const fillers = [];\n    const words = transcript.words;\n\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i];\n      const normalizedWord = word.word.toLowerCase().replace(/[.,!?;:'\"]/g, '').trim();\n\n      // Check single-word fillers\n      if (fillerSet.has(normalizedWord)) {\n        fillers.push({\n          word: word.word,\n          normalizedWord,\n          start: word.start,\n          end: word.end,\n          duration: word.end - word.start,\n          index: i,\n          type: 'filler'\n        });\n        continue;\n      }\n\n      // Check two-word phrases (e.g., \"you know\", \"kind of\")\n      if (i < words.length - 1) {\n        const nextWord = words[i + 1];\n        const twoWordPhrase = `${normalizedWord} ${nextWord.word.toLowerCase().replace(/[.,!?;:'\"]/g, '').trim()}`;\n        if (fillerSet.has(twoWordPhrase)) {\n          fillers.push({\n            word: `${word.word} ${nextWord.word}`,\n            normalizedWord: twoWordPhrase,\n            start: word.start,\n            end: nextWord.end,\n            duration: nextWord.end - word.start,\n            index: i,\n            type: 'filler_phrase'\n          });\n          // Skip next word since it's part of this phrase\n          i++;\n        }\n      }\n    }\n\n    // Calculate total filler time\n    const totalFillerDuration = fillers.reduce((sum, f) => sum + f.duration, 0);\n    const audioDuration = transcript.duration || (words.length > 0 ? words[words.length - 1].end : 0);\n    const fillerPercentage = audioDuration > 0 ? (totalFillerDuration / audioDuration) * 100 : 0;\n\n    // Deduct usage based on audio duration\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      fillers,\n      metadata: {\n        totalWords: words.length,\n        fillerCount: fillers.length,\n        totalFillerDuration: parseFloat(totalFillerDuration.toFixed(3)),\n        audioDuration: parseFloat(audioDuration.toFixed(3)),\n        fillerPercentage: parseFloat(fillerPercentage.toFixed(2)),\n        fillersPerMinute: audioDuration > 0 ? parseFloat((fillers.length / (audioDuration / 60)).toFixed(2)) : 0\n      },\n      removalSegments: fillers.map(f => ({\n        start: f.start,\n        end: f.end,\n        duration: f.duration,\n        reason: `Filler: \"${f.word}\"`,\n        type: f.type\n      })),\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Filler detection error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /stutters - Detect single-word stutters only\n *\n * Focused detection for word-level stutters (e.g., \"I I I think\").\n * Faster than full repetition detection.\n */\napp.post('/stutters', requireCredits({ endpoint: 'stutters' }), async (req, res) => {\n  const {\n    wavPath,\n    transcript: providedTranscript,\n    options = {},\n    // Support both top-level and nested options for flexibility\n    minRepeats = options.minRepeats ?? 2,\n    maxGapMs = options.maxGapMs ?? 500,\n    ignoreFillers = options.ignoreFillers ?? true,\n    minWordLength = options.minWordLength ?? 1\n  } = req.body;\n\n  if (!wavPath && !providedTranscript) {\n    return res.status(400).json({ error: 'wavPath or transcript is required' });\n  }\n\n  if (wavPath && !fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  console.log(`[SPLICE] Stutter detection: ${wavPath || 'provided transcript'}`);\n\n  try {\n    // Get or create transcript with word-level timestamps\n    let transcript = providedTranscript;\n    if (!transcript && wavPath) {\n      // Use transcribeWithWords for word-level timestamps required by stutter detection\n      transcript = await transcribeWithWords(wavPath);\n    }\n\n    // Validate transcript exists and has words array\n    if (!transcript || !transcript.words) {\n      return res.status(400).json({\n        error: 'Transcript must contain word-level timing data'\n      });\n    }\n\n    // Empty transcript returns empty result (not an error)\n    if (transcript.words.length === 0) {\n      return res.json({\n        success: true,\n        stutters: [],\n        metadata: { type: 'stutters', totalWords: 0, stutterCount: 0, totalRepeatedWords: 0 }\n      });\n    }\n\n    // Detect stutters only\n    const result = detectStutters(transcript, {\n      minRepeats,\n      maxGapMs,\n      ignoreFillers,\n      minWordLength\n    });\n\n    // Deduct usage based on audio duration\n    const audioDuration = transcript.duration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      wavPath,\n      ...result,\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Stutter detection error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// =============================================================================\n// Caption Export Routes\n// =============================================================================\n\n/**\n * POST /export/captions - Export transcript to caption format (SRT, VTT, etc.)\n *\n * Converts a transcript to the specified caption format.\n * Can optionally save to file.\n *\n * Options:\n * - wavPath: Path to audio file (to transcribe first)\n * - transcript: Pre-existing transcript with word-level timing\n * - format: Export format (srt, vtt, txt, json) - default: srt\n * - outputPath: Optional file path to save to\n * - maxWordsPerCaption: Max words per caption (default: 8)\n * - maxDuration: Max duration per caption in seconds (default: 5)\n */\napp.post('/export/captions', requireCredits({ endpoint: 'export-captions' }), async (req, res) => {\n  const {\n    wavPath,\n    transcript: providedTranscript,\n    format = 'srt',\n    outputPath = null,\n    maxWordsPerCaption = 8,\n    maxDuration = 5\n  } = req.body;\n\n  if (!wavPath && !providedTranscript) {\n    return res.status(400).json({ error: 'wavPath or transcript is required' });\n  }\n\n  if (wavPath && !fs.existsSync(wavPath)) {\n    return res.status(404).json({ error: `File not found: ${wavPath}` });\n  }\n\n  console.log(`[SPLICE] Caption export: ${wavPath || 'provided transcript'} -> ${format}`);\n\n  try {\n    // Get or create transcript with word-level timestamps\n    let transcript = providedTranscript;\n    if (!transcript && wavPath) {\n      transcript = await transcribeWithWords(wavPath);\n    }\n\n    const exportOptions = { maxWordsPerCaption, maxDuration };\n\n    // Generate caption content based on format\n    let content;\n    let mimeType;\n\n    switch (format.toLowerCase()) {\n      case 'srt':\n        content = toSRT(transcript, exportOptions);\n        mimeType = 'application/x-subrip';\n        break;\n      case 'vtt':\n      case 'webvtt':\n        content = toVTT(transcript, exportOptions);\n        mimeType = 'text/vtt';\n        break;\n      case 'txt':\n      case 'text':\n        content = toPlainText(transcript, { ...exportOptions, includeTimestamps: true });\n        mimeType = 'text/plain';\n        break;\n      case 'json':\n        content = toJSON(transcript);\n        mimeType = 'application/json';\n        break;\n      default:\n        return res.status(400).json({\n          error: `Unsupported format: ${format}`,\n          supportedFormats: getSupportedFormats()\n        });\n    }\n\n    // Save to file if outputPath provided\n    let savedPath = null;\n    if (outputPath) {\n      const result = await exportToFile(transcript, outputPath, format, exportOptions);\n      savedPath = result.path;\n      console.log(`[SPLICE] Saved captions to: ${savedPath}`);\n    }\n\n    // Deduct usage based on audio duration\n    const audioDuration = transcript.duration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      format,\n      content,\n      mimeType,\n      savedPath,\n      wordCount: transcript.words?.length || 0,\n      duration: transcript.duration || 0,\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Caption export error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * GET /export/formats - Get supported export formats\n */\napp.get('/export/formats', (req, res) => {\n  res.json({\n    success: true,\n    formats: getSupportedFormats()\n  });\n});\n\n// =============================================================================\n// Multitrack/Multicam Analysis Routes\n// =============================================================================\n\n/**\n * POST /multitrack - Analyze multiple audio tracks for multicam editing\n *\n * Analyzes audio levels across multiple tracks to determine optimal\n * video angle selection based on who is speaking.\n *\n * Options:\n * - audioPaths: Array of paths to audio files (one per speaker) - required\n * - speakerNames: Array of speaker names (optional)\n * - videoTrackMapping: Object mapping speaker index to video track { 0: 0, 1: 1 }\n * - minShotDuration: Minimum seconds before next cut (default: 2.0)\n * - switchingFrequency: How often to allow cuts 0-100 (default: 50)\n * - wideShotEnabled: Enable wide shot detection (default: true)\n * - wideShotPercentage: Target % of wide shots (default: 20)\n * - wideShotTracks: Video track indices for wide shots\n * - cutawayEnabled: Enable cutaway insertion (default: false)\n * - cutawayTracks: Video track indices for cutaways\n * - speakerBoosts: Per-speaker dB adjustments { \"Speaker 1\": 5 }\n */\napp.post('/multitrack', requireCredits({ endpoint: 'multitrack' }), async (req, res) => {\n  const {\n    audioPaths,\n    speakerNames,\n    videoTrackMapping = {},\n    minShotDuration = 2.0,\n    switchingFrequency = 50,\n    wideShotEnabled = true,\n    wideShotPercentage = 20,\n    wideShotTracks = [],\n    cutawayEnabled = false,\n    cutawayTracks = [],\n    speakerBoosts = {},\n    frameRate = 30\n  } = req.body;\n\n  // Validate audioPaths\n  if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length === 0) {\n    return res.status(400).json({ error: 'audioPaths array is required (at least 1 path)' });\n  }\n\n  // Validate all files exist\n  for (const audioPath of audioPaths) {\n    if (!fs.existsSync(audioPath)) {\n      return res.status(404).json({ error: `File not found: ${audioPath}` });\n    }\n  }\n\n  // Check FFprobe availability\n  const ffprobeAvailable = await isFFprobeInstalled();\n  if (!ffprobeAvailable) {\n    return res.status(500).json({\n      error: 'FFprobe not installed. Run: brew install ffmpeg'\n    });\n  }\n\n  console.log(`[SPLICE] Multitrack analysis: ${audioPaths.length} track(s)`);\n\n  try {\n    const result = await analyzeMultitrack(audioPaths, {\n      speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n      videoTrackMapping,\n      minShotDuration,\n      switchingFrequency,\n      wideShotEnabled,\n      wideShotPercentage,\n      wideShotTracks,\n      cutawayEnabled,\n      cutawayTracks,\n      speakerBoosts,\n      frameRate\n    });\n\n    // Deduct usage based on total duration (use longest track)\n    const audioDuration = result.metadata?.totalDuration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      ...result,\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Multitrack analysis error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /multitrack/auto-balance - Auto-balance speaker screentime\n *\n * Automatically adjusts speaker boosts to achieve equal screentime distribution.\n * Runs multiple iterations to find optimal parameters.\n */\napp.post('/multitrack/auto-balance', requireCredits({ endpoint: 'multitrack-auto-balance' }), async (req, res) => {\n  const {\n    audioPaths,\n    speakerNames,\n    videoTrackMapping = {},\n    minShotDuration = 2.0,\n    switchingFrequency = 50,\n    wideShotEnabled = false, // Disable wide shots for balance calc\n    frameRate = 30\n  } = req.body;\n\n  // Validate audioPaths\n  if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length < 2) {\n    return res.status(400).json({ error: 'audioPaths array requires at least 2 tracks for balancing' });\n  }\n\n  // Validate all files exist\n  for (const audioPath of audioPaths) {\n    if (!fs.existsSync(audioPath)) {\n      return res.status(404).json({ error: `File not found: ${audioPath}` });\n    }\n  }\n\n  // Check FFprobe availability\n  const ffprobeAvailable = await isFFprobeInstalled();\n  if (!ffprobeAvailable) {\n    return res.status(500).json({\n      error: 'FFprobe not installed. Run: brew install ffmpeg'\n    });\n  }\n\n  console.log(`[SPLICE] Auto-balancing multitrack: ${audioPaths.length} track(s)`);\n\n  try {\n    const result = await autoBalanceMultitrack(audioPaths, {\n      speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n      videoTrackMapping,\n      minShotDuration,\n      switchingFrequency,\n      wideShotEnabled,\n      frameRate\n    });\n\n    // Deduct usage based on total duration\n    const audioDuration = result.metadata?.totalDuration || 0;\n    let balance = null;\n    if (audioDuration > 0 && req.deductUsage) {\n      balance = await req.deductUsage(audioDuration);\n    }\n\n    res.json({\n      success: true,\n      ...result,\n      balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n    });\n  } catch (err) {\n    console.error('[SPLICE] Auto-balance error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /process-xml - Process FCP XML to split clips at silences\n *\n * Takes an FCP XML file and silence timestamps, splits clips\n * at silence boundaries, and optionally removes gaps.\n */\napp.post('/process-xml', async (req, res) => {\n  const {\n    xmlPath,\n    silences,\n    removeGaps = true,\n    outputPath = null\n  } = req.body;\n\n  if (!xmlPath) {\n    return res.status(400).json({ error: 'xmlPath is required' });\n  }\n\n  if (!silences || !Array.isArray(silences)) {\n    return res.status(400).json({ error: 'silences array is required' });\n  }\n\n  if (!fs.existsSync(xmlPath)) {\n    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n  }\n\n  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n\n  try {\n    const result = await processXMLFile(xmlPath, silences, {\n      outputPath,\n      removeGaps\n    });\n\n    res.json({\n      success: true,\n      inputPath: xmlPath,\n      outputPath: result.outputPath,\n      stats: result.stats\n    });\n  } catch (err) {\n    console.error('[SPLICE] XML processing error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /cut-list - Generate a JSON cut list for direct DOM building (v3.5)\n *\n * Takes silences and optionally takes, returns a cut list that the\n * plugin can use to build sequences directly via UXP APIs.\n *\n * Body:\n * - sourceName: Name of the source clip\n * - sourcePath: Full path to the source file\n * - duration: Total duration in seconds\n * - silences: Array of silence segments [{start, end, duration}]\n * - takes: (optional) Array of detected takes\n * - settings: (optional) Generation settings\n */\napp.post('/cut-list', async (req, res) => {\n  const {\n    sourceName,\n    sourcePath,\n    duration,\n    silences,\n    takes = [],\n    settings = {}\n  } = req.body;\n\n  // Validate required fields\n  if (!sourceName && !sourcePath) {\n    return res.status(400).json({ error: 'sourceName or sourcePath is required' });\n  }\n\n  if (typeof duration !== 'number' || duration <= 0) {\n    return res.status(400).json({ error: 'duration must be a positive number' });\n  }\n\n  if (!silences || !Array.isArray(silences)) {\n    return res.status(400).json({ error: 'silences array is required' });\n  }\n\n  console.log(`[SPLICE] Generating cut list for ${sourceName || sourcePath} (${silences.length} silences)`);\n\n  try {\n    const cutList = generateCutList({\n      sourceName: sourceName || path.basename(sourcePath),\n      sourcePath,\n      duration,\n      silences,\n      takes,\n      settings\n    });\n\n    // Validate the generated cut list\n    const validation = validateCutList(cutList);\n    if (!validation.valid) {\n      return res.status(500).json({\n        error: 'Generated cut list is invalid',\n        validationErrors: validation.errors\n      });\n    }\n\n    res.json({\n      success: true,\n      cutList\n    });\n  } catch (err) {\n    console.error('[SPLICE] Cut list generation error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /cut-list/takes - Generate a cut list that keeps only takes\n *\n * Alternative endpoint for \"keep best takes only\" workflow.\n */\napp.post('/cut-list/takes', async (req, res) => {\n  const {\n    sourceName,\n    sourcePath,\n    duration,\n    takes,\n    settings = {}\n  } = req.body;\n\n  // Validate required fields\n  if (!sourceName && !sourcePath) {\n    return res.status(400).json({ error: 'sourceName or sourcePath is required' });\n  }\n\n  if (typeof duration !== 'number' || duration <= 0) {\n    return res.status(400).json({ error: 'duration must be a positive number' });\n  }\n\n  if (!takes || !Array.isArray(takes) || takes.length === 0) {\n    return res.status(400).json({ error: 'takes array is required and must not be empty' });\n  }\n\n  console.log(`[SPLICE] Generating takes cut list for ${sourceName || sourcePath} (${takes.length} takes)`);\n\n  try {\n    const cutList = generateTakesCutList({\n      sourceName: sourceName || path.basename(sourcePath),\n      sourcePath,\n      duration,\n      takes,\n      settings\n    });\n\n    res.json({\n      success: true,\n      cutList\n    });\n  } catch (err) {\n    console.error('[SPLICE] Takes cut list generation error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * GET /ffprobe-check - Check if FFprobe is installed\n */\napp.get('/ffprobe-check', async (req, res) => {\n  const installed = await isFFprobeInstalled();\n  res.json({\n    installed,\n    message: installed\n      ? 'FFprobe is available'\n      : 'FFprobe not found. Install with: brew install ffmpeg'\n  });\n});\n\n/**\n * GET /replicate-check - Check if Replicate API is configured\n */\napp.get('/replicate-check', async (req, res) => {\n  const configured = isReplicateConfigured();\n  res.json({\n    configured,\n    message: configured\n      ? 'Replicate API is configured'\n      : 'REPLICATE_API_TOKEN not set. Add to .env file.'\n  });\n});\n\n/**\n * POST /isolate-vocals - Isolate vocals from audio using Demucs\n *\n * Uses Replicate's Demucs model to separate vocals from background audio.\n * Cost: ~$0.015/min of audio\n *\n * Tier access:\n * - Starter: No access (upgrade required)\n * - Pro: 2 hours included, then $0.08/min overage\n * - Team: 5 hours included, then $0.08/min overage\n */\napp.post('/isolate-vocals', requireCredits({ endpoint: 'isolate-vocals' }), async (req, res) => {\n  const { audioPath, stem = 'vocals', outputDir = null } = req.body;\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!audioPath) {\n    return res.status(400).json({ error: 'audioPath is required' });\n  }\n\n  if (!fs.existsSync(audioPath)) {\n    return res.status(404).json({ error: `File not found: ${audioPath}` });\n  }\n\n  // Check Replicate configuration\n  if (!isReplicateConfigured()) {\n    return res.status(500).json({\n      error: 'Replicate API not configured. Set REPLICATE_API_TOKEN in .env'\n    });\n  }\n\n  // Get audio duration for billing\n  let audioDurationSeconds = 0;\n  try {\n    audioDurationSeconds = await getAudioDuration(audioPath);\n  } catch (err) {\n    console.warn('[SPLICE] Could not get audio duration:', err.message);\n  }\n\n  const audioDurationMinutes = audioDurationSeconds / 60;\n\n  // Check isolation access if customer ID provided\n  if (stripeCustomerId) {\n    const accessCheck = await usageTracking.checkIsolationAccess(stripeCustomerId, audioDurationMinutes);\n\n    if (!accessCheck.allowed) {\n      return res.status(403).json({\n        error: accessCheck.message,\n        reason: accessCheck.reason,\n        upgradeRequired: accessCheck.reason === 'upgrade_required'\n      });\n    }\n\n    console.log(`[SPLICE] Isolation access: ${accessCheck.message}`);\n  }\n\n  console.log(`[SPLICE] Isolating vocals: ${audioPath} (${audioDurationMinutes.toFixed(1)} min)`);\n\n  try {\n    const result = await isolateVocals(audioPath, {\n      stem,\n      outputDir: outputDir || undefined\n    });\n\n    // Deduct isolation usage if customer ID provided\n    let usageInfo = null;\n    if (stripeCustomerId) {\n      usageInfo = await usageTracking.deductIsolationUsage(\n        stripeCustomerId,\n        audioDurationSeconds,\n        'isolate-vocals'\n      );\n      console.log(`[SPLICE] Isolation usage deducted: ${audioDurationMinutes.toFixed(1)} min`);\n      if (usageInfo.isolationUsed?.overageCost > 0) {\n        console.log(`[SPLICE] Overage cost: $${usageInfo.isolationUsed.overageCost.toFixed(2)}`);\n      }\n    }\n\n    res.json({\n      success: true,\n      inputPath: audioPath,\n      outputPath: result.outputPath,\n      stem: result.stem,\n      processingTime: result.processingTime,\n      availableStems: result.allStems,\n      audioDurationMinutes,\n      usage: usageInfo ? {\n        isolationHoursRemaining: usageInfo.isolationHoursRemaining,\n        overageCost: usageInfo.isolationUsed?.overageCost || 0\n      } : null\n    });\n  } catch (err) {\n    console.error('[SPLICE] Vocal isolation error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// =============================================================================\n// Batch Processing Routes\n// =============================================================================\n\n// In-memory job queue for batch processing\nconst batchJobs = new Map();\n\n// Batch job limits to prevent memory leak\nconst MAX_BATCH_JOBS = 10000;\nconst BATCH_JOB_MAX_AGE_MS = 24 * 60 * 60 * 1000; // 24 hours\n\n/**\n * Generate a unique job ID\n */\nfunction generateJobId() {\n  return `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Clean up old batch jobs to prevent memory leak\n * Removes jobs older than 24 hours\n */\nfunction cleanupOldBatchJobs() {\n  const now = Date.now();\n  let removedCount = 0;\n\n  for (const [jobId, job] of batchJobs.entries()) {\n    const createdAt = new Date(job.createdAt).getTime();\n    if (now - createdAt > BATCH_JOB_MAX_AGE_MS) {\n      batchJobs.delete(jobId);\n      removedCount++;\n    }\n  }\n\n  if (removedCount > 0) {\n    console.log(`[SPLICE] Cleaned up ${removedCount} old batch job(s)`);\n  }\n}\n\n/**\n * Enforce max job limit by removing oldest completed jobs\n */\nfunction enforceJobLimit() {\n  if (batchJobs.size < MAX_BATCH_JOBS) return;\n\n  // Get completed jobs sorted by creation date (oldest first)\n  const completedJobs = Array.from(batchJobs.entries())\n    .filter(([_, job]) => job.status !== 'processing')\n    .sort((a, b) => new Date(a[1].createdAt) - new Date(b[1].createdAt));\n\n  // Remove oldest completed jobs until under limit\n  const toRemove = batchJobs.size - MAX_BATCH_JOBS + 1;\n  for (let i = 0; i < Math.min(toRemove, completedJobs.length); i++) {\n    batchJobs.delete(completedJobs[i][0]);\n  }\n\n  console.log(`[SPLICE] Enforced job limit, removed ${Math.min(toRemove, completedJobs.length)} job(s)`);\n}\n\n// Run cleanup every hour\nsetInterval(cleanupOldBatchJobs, 60 * 60 * 1000);\n\n/**\n * POST /batch/silences - Process multiple files for silence detection\n *\n * Creates a batch job that processes multiple audio files.\n * Returns a job ID for tracking progress.\n *\n * Body:\n * - files: Array of file paths to process\n * - options: Detection options (sensitivity, threshold, etc.)\n */\napp.post('/batch/silences', requireCredits({ endpoint: 'batch-silences' }), async (req, res) => {\n  const { files, options = {} } = req.body;\n\n  if (!files || !Array.isArray(files) || files.length === 0) {\n    return res.status(400).json({ error: 'files array is required' });\n  }\n\n  // Validate all files exist\n  const missingFiles = files.filter(f => !fs.existsSync(f));\n  if (missingFiles.length > 0) {\n    return res.status(404).json({\n      error: 'Some files not found',\n      missingFiles\n    });\n  }\n\n  // Enforce job limit before creating new job\n  enforceJobLimit();\n\n  const jobId = generateJobId();\n\n  // Initialize job with customer ID for usage tracking\n  const job = {\n    id: jobId,\n    type: 'silences',\n    status: 'processing',\n    createdAt: new Date().toISOString(),\n    stripeCustomerId: req.stripeCustomerId,  // Store for usage deduction\n    files: files.map(f => ({\n      path: f,\n      status: 'pending',\n      result: null,\n      error: null\n    })),\n    options,\n    progress: {\n      total: files.length,\n      completed: 0,\n      failed: 0,\n      percentage: 0\n    },\n    results: [],\n    errors: [],\n    totalUsageDeducted: 0  // Track total seconds deducted\n  };\n\n  batchJobs.set(jobId, job);\n  console.log(`[SPLICE] Batch job ${jobId} created with ${files.length} files`);\n\n  // Start processing in background\n  processBatchJob(jobId);\n\n  res.json({\n    success: true,\n    jobId,\n    message: `Batch job created with ${files.length} files`,\n    statusUrl: `/batch/status/${jobId}`\n  });\n});\n\n/**\n * Process a batch job (runs in background)\n */\nasync function processBatchJob(jobId) {\n  const job = batchJobs.get(jobId);\n  if (!job) return;\n\n  const { sensitivity, ...manualOptions } = job.options;\n\n  // Build detection options\n  let detectionOptions = {};\n  if (typeof sensitivity === 'number') {\n    detectionOptions = sensitivityToParams(sensitivity);\n  } else {\n    detectionOptions = {\n      threshold: manualOptions.threshold ?? -30,\n      minSilenceLength: manualOptions.minSilenceLength ?? 0.5,\n      paddingStart: manualOptions.paddingStart ?? 0.1,\n      paddingEnd: manualOptions.paddingEnd ?? 0.05,\n      autoThreshold: manualOptions.autoThreshold ?? false\n    };\n  }\n\n  // Process files sequentially to avoid overwhelming the system\n  for (let i = 0; i < job.files.length; i++) {\n    const fileEntry = job.files[i];\n    fileEntry.status = 'processing';\n\n    try {\n      const result = await detectSilencesRMS(fileEntry.path, detectionOptions);\n\n      fileEntry.status = 'completed';\n      fileEntry.result = {\n        silences: result.silences,\n        count: result.silences.length,\n        totalSilenceDuration: result.metadata.totalSilenceDuration,\n        audioDuration: result.metadata.audioDuration\n      };\n\n      job.results.push({\n        file: fileEntry.path,\n        ...fileEntry.result\n      });\n\n      // Deduct usage for this file\n      const audioDuration = result.metadata?.audioDuration || 0;\n      if (audioDuration > 0 && job.stripeCustomerId) {\n        try {\n          await usageTracking.deductUsage(job.stripeCustomerId, audioDuration, 'batch-silences');\n          job.totalUsageDeducted += audioDuration;\n        } catch (usageErr) {\n          console.warn(`[SPLICE] Batch ${jobId}: Usage deduction failed:`, usageErr.message);\n        }\n      }\n\n      job.progress.completed++;\n      console.log(`[SPLICE] Batch ${jobId}: ${i + 1}/${job.files.length} completed`);\n    } catch (err) {\n      fileEntry.status = 'failed';\n      fileEntry.error = err.message;\n\n      job.errors.push({\n        file: fileEntry.path,\n        error: err.message\n      });\n\n      job.progress.failed++;\n      console.error(`[SPLICE] Batch ${jobId}: ${fileEntry.path} failed:`, err.message);\n    }\n\n    // Update progress\n    job.progress.percentage = Math.round(\n      ((job.progress.completed + job.progress.failed) / job.progress.total) * 100\n    );\n  }\n\n  // Mark job as complete\n  job.status = job.progress.failed === job.progress.total ? 'failed' :\n               job.progress.failed > 0 ? 'completed_with_errors' : 'completed';\n  job.completedAt = new Date().toISOString();\n\n  console.log(`[SPLICE] Batch job ${jobId} ${job.status}`);\n}\n\n/**\n * GET /batch/status/:jobId - Get batch job status and results\n */\napp.get('/batch/status/:jobId', (req, res) => {\n  const { jobId } = req.params;\n  const job = batchJobs.get(jobId);\n\n  if (!job) {\n    return res.status(404).json({ error: 'Job not found' });\n  }\n\n  res.json({\n    success: true,\n    job: {\n      id: job.id,\n      type: job.type,\n      status: job.status,\n      createdAt: job.createdAt,\n      completedAt: job.completedAt,\n      progress: job.progress,\n      files: job.files.map(f => ({\n        path: f.path,\n        status: f.status,\n        silenceCount: f.result?.count,\n        error: f.error\n      }))\n    }\n  });\n});\n\n/**\n * GET /batch/results/:jobId - Get full results for a completed batch job\n */\napp.get('/batch/results/:jobId', (req, res) => {\n  const { jobId } = req.params;\n  const job = batchJobs.get(jobId);\n\n  if (!job) {\n    return res.status(404).json({ error: 'Job not found' });\n  }\n\n  if (job.status === 'processing') {\n    return res.status(202).json({\n      success: false,\n      message: 'Job still processing',\n      progress: job.progress\n    });\n  }\n\n  res.json({\n    success: true,\n    jobId: job.id,\n    status: job.status,\n    progress: job.progress,\n    results: job.results,\n    errors: job.errors,\n    summary: {\n      totalFiles: job.progress.total,\n      successful: job.progress.completed,\n      failed: job.progress.failed,\n      totalSilences: job.results.reduce((sum, r) => sum + (r.count || 0), 0),\n      totalSilenceDuration: job.results.reduce((sum, r) => sum + (r.totalSilenceDuration || 0), 0)\n    }\n  });\n});\n\n/**\n * DELETE /batch/:jobId - Cancel or delete a batch job\n */\napp.delete('/batch/:jobId', (req, res) => {\n  const { jobId } = req.params;\n  const job = batchJobs.get(jobId);\n\n  if (!job) {\n    return res.status(404).json({ error: 'Job not found' });\n  }\n\n  // Note: This doesn't actually cancel in-progress processing\n  // but prevents the job from being queried\n  batchJobs.delete(jobId);\n\n  res.json({\n    success: true,\n    message: `Job ${jobId} deleted`\n  });\n});\n\n/**\n * GET /batch/jobs - List all batch jobs\n */\napp.get('/batch/jobs', (req, res) => {\n  const jobs = Array.from(batchJobs.values()).map(job => ({\n    id: job.id,\n    type: job.type,\n    status: job.status,\n    createdAt: job.createdAt,\n    completedAt: job.completedAt,\n    progress: job.progress\n  }));\n\n  // Sort by creation date (newest first)\n  jobs.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n\n  res.json({\n    success: true,\n    count: jobs.length,\n    jobs\n  });\n});\n\n// =============================================================================\n// Billing & Credits Routes\n// =============================================================================\n\n/**\n * GET /credits - Get user's credit balance\n *\n * Requires x-stripe-customer-id header\n */\napp.get('/credits', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const balance = await usageTracking.getBalance(stripeCustomerId);\n    res.json({\n      success: true,\n      ...balance\n    });\n  } catch (err) {\n    console.error('[SPLICE] Credits error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * GET /usage-history - Get user's usage history\n */\napp.get('/usage-history', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const history = await usageTracking.getUsageHistory(stripeCustomerId);\n    res.json({\n      success: true,\n      history\n    });\n  } catch (err) {\n    console.error('[SPLICE] Usage history error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// =============================================================================\n// Referral System Endpoints\n// =============================================================================\n\n/**\n * GET /referral/code - Get or create referral code for user\n *\n * Requires x-stripe-customer-id header\n */\napp.get('/referral/code', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const codeInfo = await referralService.getOrCreateCode(stripeCustomerId);\n    res.json({\n      success: true,\n      ...codeInfo\n    });\n  } catch (err) {\n    console.error('[SPLICE] Referral code error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /referral/validate - Validate a referral code\n *\n * Body: { code: string, customerId?: string }\n */\napp.post('/referral/validate', async (req, res) => {\n  const { code, customerId } = req.body;\n\n  if (!code) {\n    return res.status(400).json({\n      error: 'Missing code',\n      message: 'Referral code is required'\n    });\n  }\n\n  try {\n    const result = await referralService.validateCode(code, customerId);\n    res.json({\n      success: true,\n      ...result\n    });\n  } catch (err) {\n    console.error('[SPLICE] Referral validate error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * POST /referral/apply - Apply referral code at signup\n *\n * Body: { code: string, customerId: string }\n */\napp.post('/referral/apply', async (req, res) => {\n  const { code, customerId } = req.body;\n\n  if (!code || !customerId) {\n    return res.status(400).json({\n      error: 'Missing required fields',\n      message: 'Both code and customerId are required'\n    });\n  }\n\n  try {\n    const result = await referralService.applyCode(code, customerId, stripe);\n    res.json({\n      success: true,\n      ...result\n    });\n  } catch (err) {\n    console.error('[SPLICE] Referral apply error:', err);\n    // Return user-friendly errors for validation failures\n    if (err.message.includes('Cannot use your own') ||\n        err.message.includes('already used') ||\n        err.message.includes('not found') ||\n        err.message.includes('no longer active')) {\n      return res.status(400).json({ error: err.message });\n    }\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * GET /referral/stats - Get referral statistics for user\n *\n * Requires x-stripe-customer-id header\n */\napp.get('/referral/stats', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const stats = await referralService.getStats(stripeCustomerId);\n    res.json({\n      success: true,\n      ...stats\n    });\n  } catch (err) {\n    console.error('[SPLICE] Referral stats error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// =============================================================================\n// License Key Endpoints\n// =============================================================================\n\n/**\n * POST /license/activate - Activate a license key\n *\n * Body: { key: \"SPLICE-XXXX-XXXX-XXXX\" }\n * Returns: { success, customerId, tier, hoursRemaining }\n */\napp.post('/license/activate', async (req, res) => {\n  const { key } = req.body;\n\n  if (!key) {\n    return res.status(400).json({\n      error: 'Missing license key',\n      message: 'License key is required'\n    });\n  }\n\n  // Validate format\n  if (!licenseService.isValidKeyFormat(key)) {\n    return res.status(400).json({\n      error: 'Invalid license key format',\n      message: 'License key should be in format: SPLICE-XXXX-XXXX-XXXX'\n    });\n  }\n\n  try {\n    // Activate the key\n    const result = await licenseService.activateLicenseKey(key);\n\n    if (!result.success) {\n      return res.status(400).json({\n        success: false,\n        error: result.error\n      });\n    }\n\n    // Get the customer's balance and tier info\n    const balance = await usageTracking.getBalance(result.customerId);\n\n    res.json({\n      success: true,\n      customerId: result.customerId,\n      tier: balance.tier,\n      tierName: balance.tierName,\n      hoursRemaining: balance.hoursRemaining,\n      hoursTotal: balance.hoursTotal\n    });\n  } catch (err) {\n    console.error('[SPLICE] License activation error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n/**\n * GET /license/key - Get license key for a customer (for display/resend)\n *\n * Requires x-stripe-customer-id header\n */\napp.get('/license/key', async (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n\n  if (!stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Missing x-stripe-customer-id header'\n    });\n  }\n\n  try {\n    const result = await licenseService.getLicenseByCustomerId(stripeCustomerId);\n\n    if (!result.success) {\n      return res.status(404).json({\n        success: false,\n        error: result.error\n      });\n    }\n\n    res.json({\n      success: true,\n      key: result.key,\n      activated: result.activated,\n      createdAt: result.createdAt\n    });\n  } catch (err) {\n    console.error('[SPLICE] License lookup error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\n// Initialize database and start server\nasync function startServer() {\n  try {\n    await usageTracking.initDatabase();\n    await referralService.initReferralTables();\n    await licenseService.initLicenseTables();\n    console.log('[SPLICE] Database initialized');\n\n    if (isProduction || !httpsOptions) {\n      // Production: Railway provides TLS termination, use HTTP\n      http.createServer(app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n      });\n    } else {\n      // Development: Use HTTPS with local certificates\n      https.createServer(httpsOptions, app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n      });\n    }\n  } catch (err) {\n    console.error('[SPLICE] Failed to start server:', err);\n    process.exit(1);\n  }\n}\n\nstartServer();\n","numLines":2176,"startLine":1,"totalLines":2176}}}
{"parentUuid":"d3c31432-cb34-4aa1-8c73-9f4e23b64b03","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HminyfESh1qFM5uGAeTj6v","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also check the rate limiter middleware and referral service to get a complete picture of the concurrency vulnerabilities:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":39034,"cache_read_input_tokens":17312,"cache_creation":{"ephemeral_5m_input_tokens":39034,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWUGeeNpJoHhsumTkV8ys","type":"assistant","uuid":"e256b8b2-3e05-4900-977b-edda1308a3bd","timestamp":"2025-12-25T23:26:35.136Z"}
{"parentUuid":"e256b8b2-3e05-4900-977b-edda1308a3bd","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HminyfESh1qFM5uGAeTj6v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EtH6ErfMpexUdwH1ovSPJ3","name":"Glob","input":{"pattern":"**/middleware/*.js","path":"/Users/imorgado/SPLICE"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":39034,"cache_read_input_tokens":17312,"cache_creation":{"ephemeral_5m_input_tokens":39034,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWUGeeNpJoHhsumTkV8ys","type":"assistant","uuid":"c96da6ab-39b5-404d-a85f-a007fd400468","timestamp":"2025-12-25T23:26:36.173Z"}
{"parentUuid":"c96da6ab-39b5-404d-a85f-a007fd400468","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HminyfESh1qFM5uGAeTj6v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FBPapDS71misf8xgnUp2ga","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/referralService.js"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":39034,"cache_read_input_tokens":17312,"cache_creation":{"ephemeral_5m_input_tokens":39034,"ephemeral_1h_input_tokens":0},"output_tokens":164,"service_tier":"standard"}},"requestId":"req_011CWUGeeNpJoHhsumTkV8ys","type":"assistant","uuid":"e5ebfbb4-581d-4b37-96ae-cd7d18d635b1","timestamp":"2025-12-25T23:26:36.916Z"}
{"parentUuid":"e5ebfbb4-581d-4b37-96ae-cd7d18d635b1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FBPapDS71misf8xgnUp2ga","type":"tool_result","content":"     1→/**\n     2→ * Referral Code Service\n     3→ *\n     4→ * Manages referral codes for user acquisition and rewards.\n     5→ * Each user gets a unique referral code that gives:\n     6→ * - Referee: 10% discount on first purchase\n     7→ * - Referrer: 1 hour credit bonus when code is used\n     8→ */\n     9→\n    10→const { Pool } = require('pg');\n    11→const crypto = require('crypto');\n    12→\n    13→// Use the same pool configuration as usageTracking\n    14→const pool = new Pool({\n    15→  connectionString: process.env.DATABASE_URL,\n    16→  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    17→  max: 20,\n    18→  idleTimeoutMillis: 30000,\n    19→  connectionTimeoutMillis: 5000\n    20→});\n    21→\n    22→// Default referral rewards\n    23→const DEFAULT_REFEREE_DISCOUNT = 10;    // 10% discount for new users\n    24→const DEFAULT_REFERRER_CREDIT = 1.0;    // 1 hour credit for referrer\n    25→\n    26→/**\n    27→ * Initialize referral tables\n    28→ */\n    29→async function initReferralTables() {\n    30→  const client = await pool.connect();\n    31→  try {\n    32→    // Create referral_codes table\n    33→    await client.query(`\n    34→      CREATE TABLE IF NOT EXISTS referral_codes (\n    35→        id SERIAL PRIMARY KEY,\n    36→        code VARCHAR(12) UNIQUE NOT NULL,\n    37→        owner_customer_id VARCHAR(255) NOT NULL,\n    38→        referee_discount_percent INTEGER DEFAULT ${DEFAULT_REFEREE_DISCOUNT},\n    39→        referrer_credit_hours DECIMAL(10,2) DEFAULT ${DEFAULT_REFERRER_CREDIT},\n    40→        times_used INTEGER DEFAULT 0,\n    41→        is_active BOOLEAN DEFAULT TRUE,\n    42→        created_at TIMESTAMP DEFAULT NOW()\n    43→      )\n    44→    `);\n    45→\n    46→    // Create referral_uses table to track who used which code\n    47→    await client.query(`\n    48→      CREATE TABLE IF NOT EXISTS referral_uses (\n    49→        id SERIAL PRIMARY KEY,\n    50→        code_id INTEGER REFERENCES referral_codes(id),\n    51→        referee_customer_id VARCHAR(255) NOT NULL,\n    52→        used_at TIMESTAMP DEFAULT NOW(),\n    53→        credit_awarded BOOLEAN DEFAULT FALSE,\n    54→        stripe_coupon_id VARCHAR(255)\n    55→      )\n    56→    `);\n    57→\n    58→    // Add indexes for efficient lookups\n    59→    await client.query(`\n    60→      CREATE INDEX IF NOT EXISTS idx_referral_codes_owner\n    61→      ON referral_codes(owner_customer_id)\n    62→    `);\n    63→\n    64→    await client.query(`\n    65→      CREATE INDEX IF NOT EXISTS idx_referral_codes_code\n    66→      ON referral_codes(code)\n    67→    `);\n    68→\n    69→    await client.query(`\n    70→      CREATE INDEX IF NOT EXISTS idx_referral_uses_code\n    71→      ON referral_uses(code_id)\n    72→    `);\n    73→\n    74→    await client.query(`\n    75→      CREATE INDEX IF NOT EXISTS idx_referral_uses_referee\n    76→      ON referral_uses(referee_customer_id)\n    77→    `);\n    78→\n    79→    console.log('[Referral] Database tables initialized');\n    80→  } finally {\n    81→    client.release();\n    82→  }\n    83→}\n    84→\n    85→/**\n    86→ * Generate a unique referral code\n    87→ * Format: SPLICE-XXXX (8 random alphanumeric chars)\n    88→ */\n    89→function generateCode() {\n    90→  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Exclude confusing chars\n    91→  let code = 'SPLICE-';\n    92→  for (let i = 0; i < 6; i++) {\n    93→    code += chars.charAt(crypto.randomInt(chars.length));\n    94→  }\n    95→  return code;\n    96→}\n    97→\n    98→/**\n    99→ * Get or create referral code for a customer\n   100→ *\n   101→ * @param {string} customerId - Stripe customer ID\n   102→ * @returns {Promise<Object>} Referral code info\n   103→ */\n   104→async function getOrCreateCode(customerId) {\n   105→  if (!customerId) {\n   106→    throw new Error('Customer ID is required');\n   107→  }\n   108→\n   109→  const client = await pool.connect();\n   110→  try {\n   111→    // Check for existing code\n   112→    let result = await client.query(\n   113→      'SELECT * FROM referral_codes WHERE owner_customer_id = $1',\n   114→      [customerId]\n   115→    );\n   116→\n   117→    if (result.rows.length > 0) {\n   118→      return {\n   119→        code: result.rows[0].code,\n   120→        discountPercent: result.rows[0].referee_discount_percent,\n   121→        creditHours: parseFloat(result.rows[0].referrer_credit_hours),\n   122→        timesUsed: result.rows[0].times_used,\n   123→        isActive: result.rows[0].is_active,\n   124→        createdAt: result.rows[0].created_at\n   125→      };\n   126→    }\n   127→\n   128→    // Generate unique code with retry logic\n   129→    let code;\n   130→    let attempts = 0;\n   131→    const maxAttempts = 10;\n   132→\n   133→    while (attempts < maxAttempts) {\n   134→      code = generateCode();\n   135→      try {\n   136→        result = await client.query(\n   137→          `INSERT INTO referral_codes (code, owner_customer_id)\n   138→           VALUES ($1, $2)\n   139→           RETURNING *`,\n   140→          [code, customerId]\n   141→        );\n   142→        break;\n   143→      } catch (err) {\n   144→        if (err.code === '23505') { // Unique violation\n   145→          attempts++;\n   146→          continue;\n   147→        }\n   148→        throw err;\n   149→      }\n   150→    }\n   151→\n   152→    if (attempts >= maxAttempts) {\n   153→      throw new Error('Failed to generate unique referral code');\n   154→    }\n   155→\n   156→    return {\n   157→      code: result.rows[0].code,\n   158→      discountPercent: result.rows[0].referee_discount_percent,\n   159→      creditHours: parseFloat(result.rows[0].referrer_credit_hours),\n   160→      timesUsed: 0,\n   161→      isActive: true,\n   162→      createdAt: result.rows[0].created_at\n   163→    };\n   164→  } finally {\n   165→    client.release();\n   166→  }\n   167→}\n   168→\n   169→/**\n   170→ * Validate a referral code\n   171→ *\n   172→ * @param {string} code - Referral code to validate\n   173→ * @param {string} refereeCustomerId - The customer trying to use the code (optional)\n   174→ * @returns {Promise<Object>} Validation result\n   175→ */\n   176→async function validateCode(code, refereeCustomerId = null) {\n   177→  if (!code || typeof code !== 'string') {\n   178→    return {\n   179→      valid: false,\n   180→      error: 'Invalid code format'\n   181→    };\n   182→  }\n   183→\n   184→  // Normalize code\n   185→  const normalizedCode = code.toUpperCase().trim();\n   186→\n   187→  const client = await pool.connect();\n   188→  try {\n   189→    const result = await client.query(\n   190→      'SELECT * FROM referral_codes WHERE code = $1',\n   191→      [normalizedCode]\n   192→    );\n   193→\n   194→    if (result.rows.length === 0) {\n   195→      return {\n   196→        valid: false,\n   197→        error: 'Code not found'\n   198→      };\n   199→    }\n   200→\n   201→    const codeRow = result.rows[0];\n   202→\n   203→    // Check if code is active\n   204→    if (!codeRow.is_active) {\n   205→      return {\n   206→        valid: false,\n   207→        error: 'Code is no longer active'\n   208→      };\n   209→    }\n   210→\n   211→    // Check if user is trying to use their own code\n   212→    if (refereeCustomerId && codeRow.owner_customer_id === refereeCustomerId) {\n   213→      return {\n   214→        valid: false,\n   215→        error: 'Cannot use your own referral code'\n   216→      };\n   217→    }\n   218→\n   219→    // Check if referee has already used a code\n   220→    if (refereeCustomerId) {\n   221→      const usageCheck = await client.query(\n   222→        'SELECT id FROM referral_uses WHERE referee_customer_id = $1',\n   223→        [refereeCustomerId]\n   224→      );\n   225→      if (usageCheck.rows.length > 0) {\n   226→        return {\n   227→          valid: false,\n   228→          error: 'You have already used a referral code'\n   229→        };\n   230→      }\n   231→    }\n   232→\n   233→    return {\n   234→      valid: true,\n   235→      code: codeRow.code,\n   236→      discountPercent: codeRow.referee_discount_percent,\n   237→      ownerCustomerId: codeRow.owner_customer_id\n   238→    };\n   239→  } finally {\n   240→    client.release();\n   241→  }\n   242→}\n   243→\n   244→/**\n   245→ * Apply a referral code for a new signup\n   246→ *\n   247→ * @param {string} code - Referral code\n   248→ * @param {string} refereeCustomerId - New customer's Stripe ID\n   249→ * @param {Object} stripe - Stripe instance for creating coupons (optional)\n   250→ * @returns {Promise<Object>} Application result with coupon info\n   251→ */\n   252→async function applyCode(code, refereeCustomerId, stripe = null) {\n   253→  if (!code || !refereeCustomerId) {\n   254→    throw new Error('Code and referee customer ID are required');\n   255→  }\n   256→\n   257→  // Validate the code first\n   258→  const validation = await validateCode(code, refereeCustomerId);\n   259→  if (!validation.valid) {\n   260→    throw new Error(validation.error);\n   261→  }\n   262→\n   263→  const client = await pool.connect();\n   264→  try {\n   265→    await client.query('BEGIN');\n   266→\n   267→    // Get the code details\n   268→    const codeResult = await client.query(\n   269→      'SELECT * FROM referral_codes WHERE code = $1',\n   270→      [validation.code]\n   271→    );\n   272→    const codeRow = codeResult.rows[0];\n   273→\n   274→    // Create Stripe coupon if Stripe instance provided\n   275→    let stripeCouponId = null;\n   276→    if (stripe) {\n   277→      try {\n   278→        const coupon = await stripe.coupons.create({\n   279→          percent_off: codeRow.referee_discount_percent,\n   280→          duration: 'once',\n   281→          metadata: {\n   282→            referral_code: codeRow.code,\n   283→            referrer: codeRow.owner_customer_id\n   284→          }\n   285→        });\n   286→        stripeCouponId = coupon.id;\n   287→      } catch (err) {\n   288→        console.warn(`[Referral] Failed to create Stripe coupon: ${err.message}`);\n   289→        // Continue without coupon - user still gets tracking\n   290→      }\n   291→    }\n   292→\n   293→    // Record the usage\n   294→    await client.query(\n   295→      `INSERT INTO referral_uses (code_id, referee_customer_id, stripe_coupon_id)\n   296→       VALUES ($1, $2, $3)`,\n   297→      [codeRow.id, refereeCustomerId, stripeCouponId]\n   298→    );\n   299→\n   300→    // Increment usage count\n   301→    await client.query(\n   302→      'UPDATE referral_codes SET times_used = times_used + 1 WHERE id = $1',\n   303→      [codeRow.id]\n   304→    );\n   305→\n   306→    await client.query('COMMIT');\n   307→\n   308→    return {\n   309→      success: true,\n   310→      discountPercent: codeRow.referee_discount_percent,\n   311→      stripeCouponId,\n   312→      referrerCustomerId: codeRow.owner_customer_id,\n   313→      creditHoursToAward: parseFloat(codeRow.referrer_credit_hours)\n   314→    };\n   315→  } catch (err) {\n   316→    await client.query('ROLLBACK');\n   317→    throw err;\n   318→  } finally {\n   319→    client.release();\n   320→  }\n   321→}\n   322→\n   323→/**\n   324→ * Award credit to referrer when a referred user completes first payment\n   325→ *\n   326→ * @param {string} refereeCustomerId - The new customer who was referred\n   327→ * @param {Object} usageTracking - Usage tracking service for adding credits\n   328→ * @returns {Promise<Object>} Award result\n   329→ */\n   330→async function awardReferrerCredit(refereeCustomerId, usageTracking) {\n   331→  const client = await pool.connect();\n   332→  try {\n   333→    // Find the referral use record\n   334→    const useResult = await client.query(\n   335→      `SELECT ru.*, rc.owner_customer_id, rc.referrer_credit_hours\n   336→       FROM referral_uses ru\n   337→       JOIN referral_codes rc ON ru.code_id = rc.id\n   338→       WHERE ru.referee_customer_id = $1 AND ru.credit_awarded = FALSE`,\n   339→      [refereeCustomerId]\n   340→    );\n   341→\n   342→    if (useResult.rows.length === 0) {\n   343→      return { awarded: false, reason: 'No pending referral credit' };\n   344→    }\n   345→\n   346→    const useRow = useResult.rows[0];\n   347→    const creditHours = parseFloat(useRow.referrer_credit_hours);\n   348→\n   349→    // Add credit to referrer's balance\n   350→    if (usageTracking) {\n   351→      const referrerBalance = await usageTracking.getBalance(useRow.owner_customer_id);\n   352→\n   353→      // Add bonus hours to existing balance\n   354→      await pool.query(\n   355→        `UPDATE users\n   356→         SET hours_remaining = hours_remaining + $1,\n   357→             hours_total = hours_total + $1,\n   358→             updated_at = CURRENT_TIMESTAMP\n   359→         WHERE stripe_customer_id = $2`,\n   360→        [creditHours, useRow.owner_customer_id]\n   361→      );\n   362→    }\n   363→\n   364→    // Mark as awarded\n   365→    await client.query(\n   366→      'UPDATE referral_uses SET credit_awarded = TRUE WHERE id = $1',\n   367→      [useRow.id]\n   368→    );\n   369→\n   370→    return {\n   371→      awarded: true,\n   372→      referrerCustomerId: useRow.owner_customer_id,\n   373→      creditHours\n   374→    };\n   375→  } finally {\n   376→    client.release();\n   377→  }\n   378→}\n   379→\n   380→/**\n   381→ * Get referral statistics for a customer\n   382→ *\n   383→ * @param {string} customerId - Stripe customer ID\n   384→ * @returns {Promise<Object>} Referral statistics\n   385→ */\n   386→async function getStats(customerId) {\n   387→  if (!customerId) {\n   388→    throw new Error('Customer ID is required');\n   389→  }\n   390→\n   391→  const client = await pool.connect();\n   392→  try {\n   393→    // Get the customer's referral code\n   394→    const codeResult = await client.query(\n   395→      'SELECT * FROM referral_codes WHERE owner_customer_id = $1',\n   396→      [customerId]\n   397→    );\n   398→\n   399→    if (codeResult.rows.length === 0) {\n   400→      return {\n   401→        hasCode: false,\n   402→        code: null,\n   403→        stats: null\n   404→      };\n   405→    }\n   406→\n   407→    const codeRow = codeResult.rows[0];\n   408→\n   409→    // Get usage details\n   410→    const usesResult = await client.query(\n   411→      `SELECT ru.*, ru.credit_awarded\n   412→       FROM referral_uses ru\n   413→       WHERE ru.code_id = $1\n   414→       ORDER BY ru.used_at DESC`,\n   415→      [codeRow.id]\n   416→    );\n   417→\n   418→    const uses = usesResult.rows;\n   419→    const totalUses = uses.length;\n   420→    const creditsAwarded = uses.filter(u => u.credit_awarded).length;\n   421→    const pendingCredits = totalUses - creditsAwarded;\n   422→\n   423→    return {\n   424→      hasCode: true,\n   425→      code: codeRow.code,\n   426→      stats: {\n   427→        totalReferrals: totalUses,\n   428→        successfulReferrals: creditsAwarded,\n   429→        pendingReferrals: pendingCredits,\n   430→        totalCreditsEarned: creditsAwarded * parseFloat(codeRow.referrer_credit_hours),\n   431→        discountPercent: codeRow.referee_discount_percent,\n   432→        creditHoursPerReferral: parseFloat(codeRow.referrer_credit_hours),\n   433→        isActive: codeRow.is_active,\n   434→        recentReferrals: uses.slice(0, 10).map(u => ({\n   435→          usedAt: u.used_at,\n   436→          creditAwarded: u.credit_awarded\n   437→        }))\n   438→      }\n   439→    };\n   440→  } finally {\n   441→    client.release();\n   442→  }\n   443→}\n   444→\n   445→/**\n   446→ * Check if a customer has used a referral code\n   447→ *\n   448→ * @param {string} customerId - Stripe customer ID\n   449→ * @returns {Promise<boolean>}\n   450→ */\n   451→async function hasUsedReferralCode(customerId) {\n   452→  const result = await pool.query(\n   453→    'SELECT id FROM referral_uses WHERE referee_customer_id = $1',\n   454→    [customerId]\n   455→  );\n   456→  return result.rows.length > 0;\n   457→}\n   458→\n   459→module.exports = {\n   460→  initReferralTables,\n   461→  getOrCreateCode,\n   462→  validateCode,\n   463→  applyCode,\n   464→  awardReferrerCredit,\n   465→  getStats,\n   466→  hasUsedReferralCode,\n   467→  generateCode,\n   468→  DEFAULT_REFEREE_DISCOUNT,\n   469→  DEFAULT_REFERRER_CREDIT\n   470→};\n   471→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4ead9253-2c4a-4462-a3ea-e13cd6ad8317","timestamp":"2025-12-25T23:26:36.980Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/referralService.js","content":"/**\n * Referral Code Service\n *\n * Manages referral codes for user acquisition and rewards.\n * Each user gets a unique referral code that gives:\n * - Referee: 10% discount on first purchase\n * - Referrer: 1 hour credit bonus when code is used\n */\n\nconst { Pool } = require('pg');\nconst crypto = require('crypto');\n\n// Use the same pool configuration as usageTracking\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 5000\n});\n\n// Default referral rewards\nconst DEFAULT_REFEREE_DISCOUNT = 10;    // 10% discount for new users\nconst DEFAULT_REFERRER_CREDIT = 1.0;    // 1 hour credit for referrer\n\n/**\n * Initialize referral tables\n */\nasync function initReferralTables() {\n  const client = await pool.connect();\n  try {\n    // Create referral_codes table\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS referral_codes (\n        id SERIAL PRIMARY KEY,\n        code VARCHAR(12) UNIQUE NOT NULL,\n        owner_customer_id VARCHAR(255) NOT NULL,\n        referee_discount_percent INTEGER DEFAULT ${DEFAULT_REFEREE_DISCOUNT},\n        referrer_credit_hours DECIMAL(10,2) DEFAULT ${DEFAULT_REFERRER_CREDIT},\n        times_used INTEGER DEFAULT 0,\n        is_active BOOLEAN DEFAULT TRUE,\n        created_at TIMESTAMP DEFAULT NOW()\n      )\n    `);\n\n    // Create referral_uses table to track who used which code\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS referral_uses (\n        id SERIAL PRIMARY KEY,\n        code_id INTEGER REFERENCES referral_codes(id),\n        referee_customer_id VARCHAR(255) NOT NULL,\n        used_at TIMESTAMP DEFAULT NOW(),\n        credit_awarded BOOLEAN DEFAULT FALSE,\n        stripe_coupon_id VARCHAR(255)\n      )\n    `);\n\n    // Add indexes for efficient lookups\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_referral_codes_owner\n      ON referral_codes(owner_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_referral_codes_code\n      ON referral_codes(code)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_referral_uses_code\n      ON referral_uses(code_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_referral_uses_referee\n      ON referral_uses(referee_customer_id)\n    `);\n\n    console.log('[Referral] Database tables initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Generate a unique referral code\n * Format: SPLICE-XXXX (8 random alphanumeric chars)\n */\nfunction generateCode() {\n  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Exclude confusing chars\n  let code = 'SPLICE-';\n  for (let i = 0; i < 6; i++) {\n    code += chars.charAt(crypto.randomInt(chars.length));\n  }\n  return code;\n}\n\n/**\n * Get or create referral code for a customer\n *\n * @param {string} customerId - Stripe customer ID\n * @returns {Promise<Object>} Referral code info\n */\nasync function getOrCreateCode(customerId) {\n  if (!customerId) {\n    throw new Error('Customer ID is required');\n  }\n\n  const client = await pool.connect();\n  try {\n    // Check for existing code\n    let result = await client.query(\n      'SELECT * FROM referral_codes WHERE owner_customer_id = $1',\n      [customerId]\n    );\n\n    if (result.rows.length > 0) {\n      return {\n        code: result.rows[0].code,\n        discountPercent: result.rows[0].referee_discount_percent,\n        creditHours: parseFloat(result.rows[0].referrer_credit_hours),\n        timesUsed: result.rows[0].times_used,\n        isActive: result.rows[0].is_active,\n        createdAt: result.rows[0].created_at\n      };\n    }\n\n    // Generate unique code with retry logic\n    let code;\n    let attempts = 0;\n    const maxAttempts = 10;\n\n    while (attempts < maxAttempts) {\n      code = generateCode();\n      try {\n        result = await client.query(\n          `INSERT INTO referral_codes (code, owner_customer_id)\n           VALUES ($1, $2)\n           RETURNING *`,\n          [code, customerId]\n        );\n        break;\n      } catch (err) {\n        if (err.code === '23505') { // Unique violation\n          attempts++;\n          continue;\n        }\n        throw err;\n      }\n    }\n\n    if (attempts >= maxAttempts) {\n      throw new Error('Failed to generate unique referral code');\n    }\n\n    return {\n      code: result.rows[0].code,\n      discountPercent: result.rows[0].referee_discount_percent,\n      creditHours: parseFloat(result.rows[0].referrer_credit_hours),\n      timesUsed: 0,\n      isActive: true,\n      createdAt: result.rows[0].created_at\n    };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Validate a referral code\n *\n * @param {string} code - Referral code to validate\n * @param {string} refereeCustomerId - The customer trying to use the code (optional)\n * @returns {Promise<Object>} Validation result\n */\nasync function validateCode(code, refereeCustomerId = null) {\n  if (!code || typeof code !== 'string') {\n    return {\n      valid: false,\n      error: 'Invalid code format'\n    };\n  }\n\n  // Normalize code\n  const normalizedCode = code.toUpperCase().trim();\n\n  const client = await pool.connect();\n  try {\n    const result = await client.query(\n      'SELECT * FROM referral_codes WHERE code = $1',\n      [normalizedCode]\n    );\n\n    if (result.rows.length === 0) {\n      return {\n        valid: false,\n        error: 'Code not found'\n      };\n    }\n\n    const codeRow = result.rows[0];\n\n    // Check if code is active\n    if (!codeRow.is_active) {\n      return {\n        valid: false,\n        error: 'Code is no longer active'\n      };\n    }\n\n    // Check if user is trying to use their own code\n    if (refereeCustomerId && codeRow.owner_customer_id === refereeCustomerId) {\n      return {\n        valid: false,\n        error: 'Cannot use your own referral code'\n      };\n    }\n\n    // Check if referee has already used a code\n    if (refereeCustomerId) {\n      const usageCheck = await client.query(\n        'SELECT id FROM referral_uses WHERE referee_customer_id = $1',\n        [refereeCustomerId]\n      );\n      if (usageCheck.rows.length > 0) {\n        return {\n          valid: false,\n          error: 'You have already used a referral code'\n        };\n      }\n    }\n\n    return {\n      valid: true,\n      code: codeRow.code,\n      discountPercent: codeRow.referee_discount_percent,\n      ownerCustomerId: codeRow.owner_customer_id\n    };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Apply a referral code for a new signup\n *\n * @param {string} code - Referral code\n * @param {string} refereeCustomerId - New customer's Stripe ID\n * @param {Object} stripe - Stripe instance for creating coupons (optional)\n * @returns {Promise<Object>} Application result with coupon info\n */\nasync function applyCode(code, refereeCustomerId, stripe = null) {\n  if (!code || !refereeCustomerId) {\n    throw new Error('Code and referee customer ID are required');\n  }\n\n  // Validate the code first\n  const validation = await validateCode(code, refereeCustomerId);\n  if (!validation.valid) {\n    throw new Error(validation.error);\n  }\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Get the code details\n    const codeResult = await client.query(\n      'SELECT * FROM referral_codes WHERE code = $1',\n      [validation.code]\n    );\n    const codeRow = codeResult.rows[0];\n\n    // Create Stripe coupon if Stripe instance provided\n    let stripeCouponId = null;\n    if (stripe) {\n      try {\n        const coupon = await stripe.coupons.create({\n          percent_off: codeRow.referee_discount_percent,\n          duration: 'once',\n          metadata: {\n            referral_code: codeRow.code,\n            referrer: codeRow.owner_customer_id\n          }\n        });\n        stripeCouponId = coupon.id;\n      } catch (err) {\n        console.warn(`[Referral] Failed to create Stripe coupon: ${err.message}`);\n        // Continue without coupon - user still gets tracking\n      }\n    }\n\n    // Record the usage\n    await client.query(\n      `INSERT INTO referral_uses (code_id, referee_customer_id, stripe_coupon_id)\n       VALUES ($1, $2, $3)`,\n      [codeRow.id, refereeCustomerId, stripeCouponId]\n    );\n\n    // Increment usage count\n    await client.query(\n      'UPDATE referral_codes SET times_used = times_used + 1 WHERE id = $1',\n      [codeRow.id]\n    );\n\n    await client.query('COMMIT');\n\n    return {\n      success: true,\n      discountPercent: codeRow.referee_discount_percent,\n      stripeCouponId,\n      referrerCustomerId: codeRow.owner_customer_id,\n      creditHoursToAward: parseFloat(codeRow.referrer_credit_hours)\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Award credit to referrer when a referred user completes first payment\n *\n * @param {string} refereeCustomerId - The new customer who was referred\n * @param {Object} usageTracking - Usage tracking service for adding credits\n * @returns {Promise<Object>} Award result\n */\nasync function awardReferrerCredit(refereeCustomerId, usageTracking) {\n  const client = await pool.connect();\n  try {\n    // Find the referral use record\n    const useResult = await client.query(\n      `SELECT ru.*, rc.owner_customer_id, rc.referrer_credit_hours\n       FROM referral_uses ru\n       JOIN referral_codes rc ON ru.code_id = rc.id\n       WHERE ru.referee_customer_id = $1 AND ru.credit_awarded = FALSE`,\n      [refereeCustomerId]\n    );\n\n    if (useResult.rows.length === 0) {\n      return { awarded: false, reason: 'No pending referral credit' };\n    }\n\n    const useRow = useResult.rows[0];\n    const creditHours = parseFloat(useRow.referrer_credit_hours);\n\n    // Add credit to referrer's balance\n    if (usageTracking) {\n      const referrerBalance = await usageTracking.getBalance(useRow.owner_customer_id);\n\n      // Add bonus hours to existing balance\n      await pool.query(\n        `UPDATE users\n         SET hours_remaining = hours_remaining + $1,\n             hours_total = hours_total + $1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2`,\n        [creditHours, useRow.owner_customer_id]\n      );\n    }\n\n    // Mark as awarded\n    await client.query(\n      'UPDATE referral_uses SET credit_awarded = TRUE WHERE id = $1',\n      [useRow.id]\n    );\n\n    return {\n      awarded: true,\n      referrerCustomerId: useRow.owner_customer_id,\n      creditHours\n    };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get referral statistics for a customer\n *\n * @param {string} customerId - Stripe customer ID\n * @returns {Promise<Object>} Referral statistics\n */\nasync function getStats(customerId) {\n  if (!customerId) {\n    throw new Error('Customer ID is required');\n  }\n\n  const client = await pool.connect();\n  try {\n    // Get the customer's referral code\n    const codeResult = await client.query(\n      'SELECT * FROM referral_codes WHERE owner_customer_id = $1',\n      [customerId]\n    );\n\n    if (codeResult.rows.length === 0) {\n      return {\n        hasCode: false,\n        code: null,\n        stats: null\n      };\n    }\n\n    const codeRow = codeResult.rows[0];\n\n    // Get usage details\n    const usesResult = await client.query(\n      `SELECT ru.*, ru.credit_awarded\n       FROM referral_uses ru\n       WHERE ru.code_id = $1\n       ORDER BY ru.used_at DESC`,\n      [codeRow.id]\n    );\n\n    const uses = usesResult.rows;\n    const totalUses = uses.length;\n    const creditsAwarded = uses.filter(u => u.credit_awarded).length;\n    const pendingCredits = totalUses - creditsAwarded;\n\n    return {\n      hasCode: true,\n      code: codeRow.code,\n      stats: {\n        totalReferrals: totalUses,\n        successfulReferrals: creditsAwarded,\n        pendingReferrals: pendingCredits,\n        totalCreditsEarned: creditsAwarded * parseFloat(codeRow.referrer_credit_hours),\n        discountPercent: codeRow.referee_discount_percent,\n        creditHoursPerReferral: parseFloat(codeRow.referrer_credit_hours),\n        isActive: codeRow.is_active,\n        recentReferrals: uses.slice(0, 10).map(u => ({\n          usedAt: u.used_at,\n          creditAwarded: u.credit_awarded\n        }))\n      }\n    };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if a customer has used a referral code\n *\n * @param {string} customerId - Stripe customer ID\n * @returns {Promise<boolean>}\n */\nasync function hasUsedReferralCode(customerId) {\n  const result = await pool.query(\n    'SELECT id FROM referral_uses WHERE referee_customer_id = $1',\n    [customerId]\n  );\n  return result.rows.length > 0;\n}\n\nmodule.exports = {\n  initReferralTables,\n  getOrCreateCode,\n  validateCode,\n  applyCode,\n  awardReferrerCredit,\n  getStats,\n  hasUsedReferralCode,\n  generateCode,\n  DEFAULT_REFEREE_DISCOUNT,\n  DEFAULT_REFERRER_CREDIT\n};\n","numLines":471,"startLine":1,"totalLines":471}}}
{"parentUuid":"4ead9253-2c4a-4462-a3ea-e13cd6ad8317","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EtH6ErfMpexUdwH1ovSPJ3","type":"tool_result","content":"/Users/imorgado/SPLICE/splice-backend/node_modules/express/lib/middleware/init.js\n/Users/imorgado/SPLICE/splice-backend/node_modules/express/lib/middleware/query.js\n/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js"}]},"uuid":"3f7d5769-9ad4-4da6-a2f1-3c2b666664b5","timestamp":"2025-12-25T23:26:37.429Z","toolUseResult":{"filenames":["/Users/imorgado/SPLICE/splice-backend/node_modules/express/lib/middleware/init.js","/Users/imorgado/SPLICE/splice-backend/node_modules/express/lib/middleware/query.js","/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js"],"durationMs":463,"numFiles":3,"truncated":false}}
{"parentUuid":"3f7d5769-9ad4-4da6-a2f1-3c2b666664b5","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Q1EJQXyAovP3ahpE6yEqzn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013QkVZ1wHGdi1Pf6bFoPPpT","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5524,"cache_creation_input_tokens":272,"cache_read_input_tokens":56346,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWUGf6XveeULnxmT3JkZd","type":"assistant","uuid":"e648b0ee-43e4-47f9-a970-3ea86107cfa7","timestamp":"2025-12-25T23:26:41.794Z"}
{"parentUuid":"e648b0ee-43e4-47f9-a970-3ea86107cfa7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013QkVZ1wHGdi1Pf6bFoPPpT","type":"tool_result","content":"     1→/**\n     2→ * Rate Limiter Middleware\n     3→ *\n     4→ * Checks if user has sufficient credits before processing.\n     5→ * Returns 402 Payment Required if insufficient credits.\n     6→ */\n     7→\n     8→const { hasCredits, deductUsage, getBalance } = require('../services/usageTracking');\n     9→\n    10→/**\n    11→ * Middleware to check credits before processing\n    12→ *\n    13→ * Expects req.stripeCustomerId to be set by auth middleware\n    14→ * Optionally uses req.estimatedDuration (in seconds) for pre-check\n    15→ */\n    16→function requireCredits(options = {}) {\n    17→  const { endpoint = 'unknown' } = options;\n    18→\n    19→  return async (req, res, next) => {\n    20→    const stripeCustomerId = req.stripeCustomerId || req.headers['x-stripe-customer-id'];\n    21→\n    22→    if (!stripeCustomerId) {\n    23→      return res.status(401).json({\n    24→        error: 'Authentication required',\n    25→        message: 'Missing Stripe customer ID'\n    26→      });\n    27→    }\n    28→\n    29→    // Store for later use\n    30→    req.stripeCustomerId = stripeCustomerId;\n    31→\n    32→    try {\n    33→      // Check if user has any credits\n    34→      const hasCreds = await hasCredits(stripeCustomerId, req.estimatedDuration || 0);\n    35→\n    36→      if (!hasCreds) {\n    37→        const balance = await getBalance(stripeCustomerId);\n    38→        return res.status(402).json({\n    39→          error: 'Insufficient credits',\n    40→          message: 'Please upgrade your plan or wait for your next billing cycle',\n    41→          balance: {\n    42→            hoursRemaining: balance.hoursRemaining,\n    43→            tier: balance.tier\n    44→          }\n    45→        });\n    46→      }\n    47→\n    48→      // Attach helper function to deduct after processing\n    49→      req.deductUsage = async (audioDurationSeconds) => {\n    50→        return await deductUsage(stripeCustomerId, audioDurationSeconds, endpoint);\n    51→      };\n    52→\n    53→      next();\n    54→    } catch (err) {\n    55→      console.error('[RateLimiter] Error checking credits:', err);\n    56→      return res.status(500).json({\n    57→        error: 'Credit check failed',\n    58→        message: err.message\n    59→      });\n    60→    }\n    61→  };\n    62→}\n    63→\n    64→/**\n    65→ * Middleware to track usage after successful response\n    66→ *\n    67→ * Call this after processing to deduct actual usage\n    68→ */\n    69→function trackUsage(endpoint = 'unknown') {\n    70→  return async (req, res, next) => {\n    71→    // Store original json method\n    72→    const originalJson = res.json.bind(res);\n    73→\n    74→    // Override json to track usage on success\n    75→    res.json = async (data) => {\n    76→      // Only deduct on successful responses\n    77→      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n    78→        try {\n    79→          const balance = await deductUsage(\n    80→            req.stripeCustomerId,\n    81→            req.audioDuration,\n    82→            endpoint\n    83→          );\n    84→          // Attach updated balance to response\n    85→          data.balance = balance;\n    86→        } catch (err) {\n    87→          console.error('[RateLimiter] Error deducting usage:', err);\n    88→        }\n    89→      }\n    90→      return originalJson(data);\n    91→    };\n    92→\n    93→    next();\n    94→  };\n    95→}\n    96→\n    97→module.exports = {\n    98→  requireCredits,\n    99→  trackUsage\n   100→};\n   101→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"434abedc-a82c-492f-9a63-47e45f8364eb","timestamp":"2025-12-25T23:26:41.848Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js","content":"/**\n * Rate Limiter Middleware\n *\n * Checks if user has sufficient credits before processing.\n * Returns 402 Payment Required if insufficient credits.\n */\n\nconst { hasCredits, deductUsage, getBalance } = require('../services/usageTracking');\n\n/**\n * Middleware to check credits before processing\n *\n * Expects req.stripeCustomerId to be set by auth middleware\n * Optionally uses req.estimatedDuration (in seconds) for pre-check\n */\nfunction requireCredits(options = {}) {\n  const { endpoint = 'unknown' } = options;\n\n  return async (req, res, next) => {\n    const stripeCustomerId = req.stripeCustomerId || req.headers['x-stripe-customer-id'];\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Missing Stripe customer ID'\n      });\n    }\n\n    // Store for later use\n    req.stripeCustomerId = stripeCustomerId;\n\n    try {\n      // Check if user has any credits\n      const hasCreds = await hasCredits(stripeCustomerId, req.estimatedDuration || 0);\n\n      if (!hasCreds) {\n        const balance = await getBalance(stripeCustomerId);\n        return res.status(402).json({\n          error: 'Insufficient credits',\n          message: 'Please upgrade your plan or wait for your next billing cycle',\n          balance: {\n            hoursRemaining: balance.hoursRemaining,\n            tier: balance.tier\n          }\n        });\n      }\n\n      // Attach helper function to deduct after processing\n      req.deductUsage = async (audioDurationSeconds) => {\n        return await deductUsage(stripeCustomerId, audioDurationSeconds, endpoint);\n      };\n\n      next();\n    } catch (err) {\n      console.error('[RateLimiter] Error checking credits:', err);\n      return res.status(500).json({\n        error: 'Credit check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Middleware to track usage after successful response\n *\n * Call this after processing to deduct actual usage\n */\nfunction trackUsage(endpoint = 'unknown') {\n  return async (req, res, next) => {\n    // Store original json method\n    const originalJson = res.json.bind(res);\n\n    // Override json to track usage on success\n    res.json = async (data) => {\n      // Only deduct on successful responses\n      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n        try {\n          const balance = await deductUsage(\n            req.stripeCustomerId,\n            req.audioDuration,\n            endpoint\n          );\n          // Attach updated balance to response\n          data.balance = balance;\n        } catch (err) {\n          console.error('[RateLimiter] Error deducting usage:', err);\n        }\n      }\n      return originalJson(data);\n    };\n\n    next();\n  };\n}\n\nmodule.exports = {\n  requireCredits,\n  trackUsage\n};\n","numLines":101,"startLine":1,"totalLines":101}}}
{"parentUuid":"434abedc-a82c-492f-9a63-47e45f8364eb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"8b7a714a-1a8e-4fc6-8df9-75fdb2eae3d0","version":"2.0.76","gitBranch":"main","agentId":"a826e5d","slug":"enchanted-puzzling-tarjan","message":{"model":"claude-opus-4-5-20251101","id":"msg_014HHo342h3K5qLirCUAP5gs","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have enough information to provide a comprehensive security analysis. Let me compile my findings:\n\n---\n\n# SPLICE Multi-User Concurrency Security Analysis\n\n## Executive Summary\n\n| Severity | Count | Description |\n|----------|-------|-------------|\n| **CRITICAL** | 2 | Race conditions allowing double-spend and credit bypass |\n| **HIGH** | 3 | Non-atomic operations, isolation leaks, license key race |\n| **MEDIUM** | 3 | Batch job data leakage, referral abuse, cache issues |\n| **LOW** | 2 | Minor isolation concerns |\n\n---\n\n## Critical Findings\n\n### [VULN-001] Credit Check vs Deduction Race Condition (TOCTOU)\n\n**Severity:** CRITICAL  \n**CVSS:** 9.1  \n**Location:** `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js:32-50` and `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js:321-358`\n\n**Vulnerable Pattern:**\n\n```javascript\n// rateLimiter.js:32-50\n// Step 1: CHECK credits (time T1)\nconst hasCreds = await hasCredits(stripeCustomerId, req.estimatedDuration || 0);\nif (!hasCreds) { /* reject */ }\n\n// ... request processing happens here (potentially long) ...\n\n// Step 2: DEDUCT credits (time T2) - called AFTER processing\nreq.deductUsage = async (audioDurationSeconds) => {\n  return await deductUsage(stripeCustomerId, audioDurationSeconds, endpoint);\n};\n```\n\n```javascript\n// usageTracking.js:321-358 - deductUsage is NOT atomic\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n  const client = await pool.connect();\n  try {\n    // Step A: SELECT (non-locking read)\n    const userResult = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n    \n    // Step B: UPDATE (separate statement, no transaction)\n    await client.query(\n      `UPDATE users SET hours_remaining = GREATEST(0, hours_remaining - $1)...`,\n      [hoursUsed, stripeCustomerId]\n    );\n    // ...\n  }\n}\n```\n\n**Attack Scenario:**\n1. User has 0.5 hours remaining\n2. User sends two concurrent requests for 1-hour audio files\n3. Both requests pass `hasCredits()` check (both see 0.5 hours)\n4. Both requests process (expensive AI/API calls)\n5. Both requests call `deductUsage()` \n6. Result: User gets 2 hours of processing for 0.5 hours of credit (or negative balance clamped to 0)\n\n**Impact:** \n- Unlimited free processing through concurrent requests\n- Financial loss to service provider\n- API cost exploitation (OpenAI/Replicate charges incurred without payment)\n\n**Proof of Concept:**\n```bash\n# Send 10 concurrent requests with almost-exhausted credits\nfor i in {1..10}; do\n  curl -X POST https://splice-api-production.up.railway.app/silences-rms \\\n    -H \"x-stripe-customer-id: cus_xxx\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"wavPath\":\"/path/to/large/file.wav\"}' &\ndone\nwait\n```\n\n**Remediation:**\nUse `SELECT ... FOR UPDATE` with transaction and reserve credits BEFORE processing:\n\n```javascript\nasync function reserveAndDeductUsage(stripeCustomerId, estimatedSeconds) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    // Lock row and check balance atomically\n    const result = await client.query(\n      `SELECT hours_remaining FROM users \n       WHERE stripe_customer_id = $1 \n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n    \n    const hoursNeeded = estimatedSeconds / 3600;\n    if (result.rows[0].hours_remaining < hoursNeeded) {\n      await client.query('ROLLBACK');\n      throw new Error('Insufficient credits');\n    }\n    \n    // Reserve immediately\n    await client.query(\n      `UPDATE users SET hours_remaining = hours_remaining - $1 WHERE stripe_customer_id = $2`,\n      [hoursNeeded, stripeCustomerId]\n    );\n    \n    await client.query('COMMIT');\n    return { reserved: hoursNeeded };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n```\n\n---\n\n### [VULN-002] Deduction Failure After Processing = Free Service\n\n**Severity:** CRITICAL  \n**CVSS:** 8.7  \n**Location:** `/Users/imorgado/SPLICE/splice-backend/server.js` - All endpoint handlers (lines 319-358, 368-405, etc.)\n\n**Vulnerable Pattern:**\n\n```javascript\n// server.js:319-358 - /analyze endpoint\napp.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n  // ... processing happens ...\n  const transcript = await transcribeAudio(wavPath);  // EXPENSIVE: OpenAI API call\n  const takes = await detectTakes(transcript);        // EXPENSIVE: GPT-4o-mini call\n  \n  // Deduct usage AFTER processing\n  const audioDuration = transcript.duration || 0;\n  let balance = null;\n  if (audioDuration > 0 && req.deductUsage) {\n    balance = await req.deductUsage(audioDuration);  // What if this fails?\n  }\n  \n  res.json({ success: true, ... });  // User gets results even if deduction failed\n});\n```\n\n**Attack Scenario:**\n1. User makes request that passes credit check\n2. Expensive processing completes (OpenAI charges incurred)\n3. Database becomes temporarily unavailable OR user's row is locked\n4. `deductUsage()` throws an error\n5. Response is still sent with `success: true`\n6. User receives full service, credits never deducted\n\n**Impact:**\n- Silent credit leakage on any database hiccup\n- No audit trail of failed deductions\n- Service provided without billing\n\n**Remediation:**\nImplement pre-authorization pattern:\n\n```javascript\napp.post('/analyze', requireCredits({ endpoint: 'analyze' }), async (req, res) => {\n  let reservationId = null;\n  try {\n    // Estimate and RESERVE credits upfront\n    const estimatedHours = await estimateAudioDuration(wavPath) / 3600;\n    reservationId = await usageTracking.reserveCredits(req.stripeCustomerId, estimatedHours);\n    \n    // Process\n    const transcript = await transcribeAudio(wavPath);\n    \n    // Confirm reservation with actual usage\n    await usageTracking.confirmReservation(reservationId, transcript.duration / 3600);\n    \n    res.json({ success: true, ... });\n  } catch (err) {\n    // Release reservation on failure\n    if (reservationId) {\n      await usageTracking.releaseReservation(reservationId);\n    }\n    res.status(500).json({ error: err.message });\n  }\n});\n```\n\n---\n\n## High Severity Findings\n\n### [VULN-003] License Key Activation Race Condition\n\n**Severity:** HIGH  \n**CVSS:** 7.5  \n**Location:** `/Users/imorgado/SPLICE/splice-backend/services/licenseService.js:185-229`\n\n**Vulnerable Code:**\n\n```javascript\nasync function activateLicenseKey(key) {\n  const client = await pool.connect();\n  try {\n    // Step 1: Read license (no lock)\n    const result = await client.query(\n      'SELECT * FROM license_keys WHERE key = $1',\n      [normalized]\n    );\n    \n    // Step 2: Check if activated (in application code)\n    if (!license.activated_at) {\n      // Step 3: Update (separate statement)\n      await client.query(\n        'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n        [license.id]\n      );\n    }\n    \n    return { success: true, customerId: license.stripe_customer_id };\n  }\n}\n```\n\n**Attack Scenario:**\n1. User purchases subscription, receives license key\n2. User activates key on Device A\n3. User shares key with friends\n4. Friends activate on Devices B, C, D simultaneously\n5. All activation attempts see `activated_at = NULL`\n6. All succeed and get `customerId` for the same account\n\n**Impact:**\n- License key sharing enables unlimited device activations\n- Multiple users can share one subscription\n- No device limit enforcement\n\n**Remediation:**\n\n```javascript\nasync function activateLicenseKey(key) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    // Lock the row\n    const result = await client.query(\n      'SELECT * FROM license_keys WHERE key = $1 FOR UPDATE',\n      [normalized]\n    );\n    \n    if (!license.activated_at) {\n      await client.query(\n        'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n        [license.id]\n      );\n    }\n    \n    await client.query('COMMIT');\n    return { success: true, customerId: license.stripe_customer_id };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  }\n}\n```\n\nAlso consider adding a `device_activations` table to track per-device activations with limits.\n\n---\n\n### [VULN-004] Non-Atomic Isolation Hours Deduction\n\n**Severity:** HIGH  \n**CVSS:** 7.3  \n**Location:** `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js:253-316`\n\n**Vulnerable Code:**\n\n```javascript\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint) {\n  const client = await pool.connect();\n  try {\n    // Step 1: Read (no lock, no transaction)\n    const userResult = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n    \n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n    \n    // ... overage calculation based on stale read ...\n    \n    // Step 2: Update (separate statement)\n    await client.query(\n      `UPDATE users SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1)...`,\n      [durationHours, stripeCustomerId]\n    );\n    \n    // Step 3: Insert log (another separate statement)\n    await client.query(\n      `INSERT INTO usage_log ...`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n  }\n}\n```\n\n**Issues:**\n1. No transaction wrapping SELECT + UPDATE + INSERT\n2. Overage calculation uses stale data\n3. Concurrent requests can both undercount overage charges\n\n**Impact:** \n- Users can avoid overage charges through concurrent requests\n- Financial loss on vocal isolation feature\n\n---\n\n### [VULN-005] getOrCreateUser Race Condition\n\n**Severity:** HIGH  \n**CVSS:** 7.0  \n**Location:** `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js:130-155`\n\n**Vulnerable Code:**\n\n```javascript\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  const client = await pool.connect();\n  try {\n    // Step 1: Check if exists\n    let result = await client.query(\n      'SELECT * FROM users WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length > 0) {\n      return result.rows[0];\n    }\n\n    // Step 2: Create new user (separate operation)\n    result = await client.query(\n      `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, ...)\n       VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n       RETURNING *`,\n      [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n    );\n  }\n}\n```\n\n**Attack Scenario:**\n1. Two concurrent requests for new customer `cus_xxx`\n2. Both check: `SELECT * FROM users WHERE stripe_customer_id = 'cus_xxx'` -> 0 rows\n3. Both try to INSERT\n4. One fails with unique constraint violation (23505)\n5. Error propagates up, request fails\n\n**Note:** While this won't cause duplicate users (due to UNIQUE constraint), it does cause unnecessary failures and poor UX.\n\n**Remediation:**\nUse `INSERT ... ON CONFLICT`:\n\n```javascript\nconst result = await client.query(\n  `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, ...)\n   VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   ON CONFLICT (stripe_customer_id) DO UPDATE SET updated_at = NOW()\n   RETURNING *`,\n  [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n);\n```\n\n---\n\n## Medium Severity Findings\n\n### [VULN-006] Batch Jobs Cross-Customer Visibility\n\n**Severity:** MEDIUM  \n**CVSS:** 5.3  \n**Location:** `/Users/imorgado/SPLICE/splice-backend/server.js:1770-1875`\n\n**Vulnerable Code:**\n\n```javascript\n// server.js:1770-1795 - GET /batch/status/:jobId\napp.get('/batch/status/:jobId', (req, res) => {\n  const { jobId } = req.params;\n  const job = batchJobs.get(jobId);  // NO customer ID check!\n  \n  if (!job) {\n    return res.status(404).json({ error: 'Job not found' });\n  }\n  \n  res.json({ success: true, job: { ... } });  // Returns any job by ID\n});\n\n// server.js:1857-1875 - GET /batch/jobs - Lists ALL jobs\napp.get('/batch/jobs', (req, res) => {\n  const jobs = Array.from(batchJobs.values()).map(job => ({ ... }));\n  // NO filtering by customer!\n  res.json({ success: true, jobs });\n});\n```\n\n**Attack Scenario:**\n1. Attacker creates a batch job, notes job ID format: `batch_1703500000000_abc123def`\n2. Attacker enumerates job IDs: `batch_1703500000001_*`, `batch_1703500000002_*`\n3. Attacker can view any customer's batch job status and file paths\n4. File paths may reveal sensitive information about other users' projects\n\n**Impact:**\n- Exposure of other users' file paths and project structure\n- Potential PII in file names\n- Information disclosure\n\n**Remediation:**\n\n```javascript\napp.get('/batch/status/:jobId', (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  const job = batchJobs.get(jobId);\n  \n  if (!job || job.stripeCustomerId !== stripeCustomerId) {\n    return res.status(404).json({ error: 'Job not found' });\n  }\n  // ...\n});\n\napp.get('/batch/jobs', (req, res) => {\n  const stripeCustomerId = req.headers['x-stripe-customer-id'];\n  const jobs = Array.from(batchJobs.values())\n    .filter(job => job.stripeCustomerId === stripeCustomerId)\n    .map(job => ({ ... }));\n  // ...\n});\n```\n\n---\n\n### [VULN-007] Referral Code Apply Race Condition\n\n**Severity:** MEDIUM  \n**CVSS:** 5.0  \n**Location:** `/Users/imorgado/SPLICE/splice-backend/services/referralService.js:252-321`\n\n**Vulnerable Code:**\n\n```javascript\nasync function applyCode(code, refereeCustomerId, stripe = null) {\n  // Validate first (reads database)\n  const validation = await validateCode(code, refereeCustomerId);\n  if (!validation.valid) {\n    throw new Error(validation.error);\n  }\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    \n    // Re-read the code (but validation already passed!)\n    const codeResult = await client.query(\n      'SELECT * FROM referral_codes WHERE code = $1',\n      [validation.code]\n    );\n    \n    // ... apply code ...\n    \n    await client.query('COMMIT');\n  }\n}\n```\n\n**Issue:** `validateCode()` and `applyCode()` are not atomic. Between validation and application:\n- Same user could apply the code twice from different sessions\n- Although INSERT will fail on duplicate `referee_customer_id`, the Stripe coupon may already be created\n\n**Impact:**\n- Potential duplicate Stripe coupons\n- Race condition window exists\n\n---\n\n### [VULN-008] Webhook Event Idempotency Check Race\n\n**Severity:** MEDIUM  \n**CVSS:** 4.5  \n**Location:** `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js:437-458` and `server.js:157-161`\n\n**Vulnerable Code:**\n\n```javascript\n// server.js:157-161\nif (await usageTracking.isEventProcessed(event.id)) {\n  console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n  return res.json({ received: true, skipped: true });\n}\n\n// ... process event ...\n\n// Record AFTER processing\nawait usageTracking.recordWebhookEvent(event.id, event.type);\n```\n\n```javascript\n// usageTracking.js:437-443\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n```\n\n**Issue:** Stripe may retry webhooks quickly. Two identical webhook requests could both pass `isEventProcessed()` check before either records the event.\n\n**Impact:**\n- Double processing of subscription events\n- Credits may be reset twice\n- Duplicate license key generation attempts\n\n**Remediation:**\nUse INSERT with ON CONFLICT as lock:\n\n```javascript\nasync function tryProcessEvent(eventId, eventType, processor) {\n  const client = await pool.connect();\n  try {\n    // Atomic check-and-lock\n    const result = await client.query(\n      `INSERT INTO webhook_events (event_id, event_type, status)\n       VALUES ($1, $2, 'processing')\n       ON CONFLICT (event_id) DO NOTHING\n       RETURNING id`,\n      [eventId, eventType]\n    );\n    \n    if (result.rows.length === 0) {\n      return { skipped: true };  // Already processing/processed\n    }\n    \n    try {\n      await processor();\n      await client.query(\n        `UPDATE webhook_events SET status = 'completed', processed_at = NOW() WHERE event_id = $1`,\n        [eventId]\n      );\n    } catch (err) {\n      await client.query(\n        `UPDATE webhook_events SET status = 'failed', error = $2 WHERE event_id = $1`,\n        [eventId, err.message]\n      );\n      throw err;\n    }\n  } finally {\n    client.release();\n  }\n}\n```\n\n---\n\n## Low Severity Findings\n\n### [VULN-009] Database Query Customer ID Filtering - Generally Good\n\n**Severity:** LOW (Informational)  \n**Location:** All database queries\n\n**Finding:** Customer isolation is generally well-implemented. All queries use `stripe_customer_id` for filtering:\n- `usageTracking.js:160-187` - getBalance uses customer ID\n- `usageTracking.js:327-329` - deductUsage uses customer ID\n- `referralService.js:112-115` - getOrCreateCode uses customer ID\n\n**One Exception:**\n\n```javascript\n// usageTracking.js:424-431\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n```\n\nThis is correctly filtered.\n\n---\n\n### [VULN-010] In-Memory Batch Job Storage\n\n**Severity:** LOW  \n**Location:** `/Users/imorgado/SPLICE/splice-backend/server.js:1556`\n\n**Issue:** Batch jobs stored in memory (`const batchJobs = new Map();`) will be lost on server restart.\n\n**Impact:**\n- Batch job results lost on deploy/restart\n- No persistence across server instances (if scaled horizontally)\n- Jobs in progress will be orphaned\n\n**Remediation:** Consider using Redis or PostgreSQL for batch job storage in production.\n\n---\n\n## Summary of Required Fixes by Priority\n\n### Immediate (Critical - Deploy Blockers)\n\n1. **Implement atomic credit reservation** - Reserve credits BEFORE expensive processing\n2. **Wrap deductUsage in transaction with row locking** - Use `FOR UPDATE`\n3. **Add compensation logic** for failed deductions (queue for retry or alert)\n\n### Short-Term (High - This Sprint)\n\n4. **Add row locking to license activation** - Prevent multi-device race\n5. **Wrap isolation deduction in transaction**\n6. **Fix getOrCreateUser** - Use `ON CONFLICT`\n\n### Medium-Term (Medium - Next Sprint)\n\n7. **Filter batch jobs by customer ID** in all endpoints\n8. **Make referral code application fully atomic**\n9. **Improve webhook idempotency** with INSERT-as-lock pattern\n\n### Nice-to-Have (Low)\n\n10. **Move batch jobs to persistent storage** (Redis/PostgreSQL)\n11. **Add device tracking for license keys**\n\n---\n\n## Architectural Recommendations\n\n1. **Implement Reservation Pattern:**\n   - Reserve credits before processing\n   - Confirm or release after completion\n   - Add `credit_reservations` table\n\n2. **Use Database Transactions Consistently:**\n   - Every multi-step operation should be in a transaction\n   - Use `SELECT ... FOR UPDATE` for balance modifications\n\n3. **Add Request Idempotency Keys:**\n   - Client sends `Idempotency-Key` header\n   - Server deduplicates based on key\n   - Prevents duplicate processing from retries\n\n4. **Implement Credit Ledger:**\n   - Replace simple balance column with ledger entries\n   - Every credit change is an immutable entry\n   - Balance = SUM(ledger entries)\n   - Enables audit trail and reconciliation"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":6890,"cache_read_input_tokens":56618,"cache_creation":{"ephemeral_5m_input_tokens":6890,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWUGfRXvjfYm4MGs7Qjbb","type":"assistant","uuid":"5b62650d-7a5a-4982-92e0-0cc38f58c4e5","timestamp":"2025-12-25T23:28:27.819Z"}
