     1→     1→/**
     2→     2→ * SPLICE CEP Panel - Main Entry Point
     3→     3→ * v4.0.0 - CEP Migration
     4→     4→ */
     5→     5→
     6→     6→// ============================================================================
     7→     7→// CACHED DOM ELEMENTS
     8→     8→// ============================================================================
     9→     9→const ui = {};
    10→    10→
    11→    11→function cacheUIElements() {
    12→    12→    ui.status = document.getElementById('status');
    13→    13→    ui.goBtn = document.getElementById('goBtn');
    14→    14→    ui.optionsToggle = document.getElementById('optionsToggle');
    15→    15→    ui.optionsPanel = document.getElementById('optionsPanel');
    16→    16→
    17→    17→    // Sliders and options
    18→    18→    ui.sensitivitySlider = document.getElementById('sensitivitySlider');
    19→    19→    ui.sensitivityValue = document.getElementById('sensitivityValue');
    20→    20→    ui.sourceOriginal = document.getElementById('sourceOriginal');
    21→    21→    ui.sourceIsolated = document.getElementById('sourceIsolated');
    22→    22→
    23→    23→    // Feature toggles
    24→    24→    ui.enableTakesDetection = document.getElementById('enableTakesDetection');
    25→    25→    ui.enableJCut = document.getElementById('enableJCut');
    26→    26→    ui.jcutSettings = document.getElementById('jcutSettings');
    27→    27→    ui.jcutLeadIn = document.getElementById('jcutLeadIn');
    28→    28→    ui.jcutLeadInValue = document.getElementById('jcutLeadInValue');
    29→    29→    ui.jcutLeadOut = document.getElementById('jcutLeadOut');
    30→    30→    ui.jcutLeadOutValue = document.getElementById('jcutLeadOutValue');
    31→    31→
    32→    32→    // Zoom settings
    33→    33→    ui.enableZoom = document.getElementById('enableZoom');
    34→    34→    ui.zoomSettings = document.getElementById('zoomSettings');
    35→    35→    ui.zoomFrequency = document.getElementById('zoomFrequency');
    36→    36→    ui.zoomPreset = document.getElementById('zoomPreset');
    37→    37→    ui.zoomPlacement = document.getElementById('zoomPlacement');
    38→    38→
    39→    39→    // Chapter settings
    40→    40→    ui.enableChapters = document.getElementById('enableChapters');
    41→    41→    ui.chapterSettings = document.getElementById('chapterSettings');
    42→    42→    ui.maxChapters = document.getElementById('maxChapters');
    43→    43→    ui.minChapterLength = document.getElementById('minChapterLength');
    44→    44→
    45→    45→    // Profanity settings
    46→    46→    ui.enableProfanity = document.getElementById('enableProfanity');
    47→    47→    ui.profanitySettings = document.getElementById('profanitySettings');
    48→    48→
    49→    49→    // Filler word settings
    50→    50→    ui.enableFillerDetection = document.getElementById('enableFillerDetection');
    51→    51→    ui.fillerSettings = document.getElementById('fillerSettings');
    52→    52→
    53→    53→    // Progress
    54→    54→    ui.progressContainer = document.getElementById('progressContainer');
    55→    55→    ui.progressBar = document.getElementById('progressBar');
    56→    56→    ui.progressText = document.getElementById('progressText');
    57→    57→    ui.resultsEmpty = document.getElementById('resultsEmpty');
    58→    58→
    59→    59→    // Preview
    60→    60→    ui.combinedPreview = document.getElementById('combinedPreview');
    61→    61→    ui.previewList = document.getElementById('previewList');
    62→    62→    ui.silenceCount = document.getElementById('silenceCount');
    63→    63→    ui.takeCount = document.getElementById('takeCount');
    64→    64→    ui.selectedCount = document.getElementById('selectedCount');
    65→    65→    ui.selectAllSilences = document.getElementById('selectAllSilences');
    66→    66→    ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');
    67→    67→    ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');
    68→    68→    ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');
    69→    69→
    70→    70→    // Results
    71→    71→    ui.zoomResults = document.getElementById('zoomResults');
    72→    72→    ui.zoomList = document.getElementById('zoomList');
    73→    73→    ui.chapterResults = document.getElementById('chapterResults');
    74→    74→    ui.chapterList = document.getElementById('chapterList');
    75→    75→    ui.copyYouTubeBtn = document.getElementById('copyYouTubeBtn');
    76→    76→    ui.addChapterMarkersBtn = document.getElementById('addChapterMarkersBtn');
    77→    77→
    78→    78→    // Modals
    79→    79→    ui.settingsBtn = document.getElementById('settingsBtn');
    80→    80→    ui.settingsModal = document.getElementById('settingsModal');
    81→    81→    ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');
    82→    82→    ui.loginModal = document.getElementById('loginModal');
    83→    83→    ui.closeLoginBtn = document.getElementById('closeLoginBtn');
    84→    84→    ui.licenseKeyInput = document.getElementById('licenseKeyInput');
    85→    85→    ui.saveLoginBtn = document.getElementById('saveLoginBtn');
    86→    86→
    87→    87→    // Credit badge
    88→    88→    ui.creditBadge = document.getElementById('creditBadge');
    89→    89→
    90→    90→    // Preset selector
    91→    91→    ui.presetSelector = document.getElementById('presetSelector');
    92→    92→}
    93→    93→
    94→    94→// ============================================================================
    95→    95→// STATE MANAGEMENT
    96→    96→// ============================================================================
    97→    97→let previewSilences = [];
    98→    98→let previewTakes = [];
    99→    99→let currentChapters = [];
   100→   100→let currentZooms = [];
   101→   101→let currentProfanity = [];
   102→   102→let selectedSilenceIndices = new Set();
   103→   103→let isOperationInProgress = false;
   104→   104→let lastDetectionResult = null;
   105→   105→let currentAudioPath = null;
   106→   106→let currentSequenceInfo = null;
   107→   107→let currentTranscript = null;
   108→   108→
   109→   109→// Global state for captions/reframe modules
   110→   110→window.spliceState = {
   111→   111→    lastTranscript: null,
   112→   112→    currentVideoPath: null,
   113→   113→    activeSequence: null,
   114→   114→    audioPath: null
   115→   115→};
   116→   116→
   117→   117→// Also expose transcript globally for music module
   118→   118→window.currentTranscript = null;
   119→   119→
   120→   120→// ============================================================================
   121→   121→// INITIALIZATION
   122→   122→// ============================================================================
   123→   123→document.addEventListener('DOMContentLoaded', async () => {
   124→   124→    // Premium Loading Experience
   125→   125→    setTimeout(() => {
   126→   126→        const loader = document.getElementById('loading-overlay');
   127→   127→        if (loader) loader.classList.add('hidden');
   128→   128→    }, 800); // Small delay for smooth perception
   129→   129→    console.log('[SPLICE] Initializing CEP panel...');
   130→   130→
   131→   131→    // Debug: Show init started
   132→   132→    const statusEl = document.getElementById('status');
   133→   133→    if (statusEl) statusEl.textContent = 'Initializing...';
   134→   134→
   135→   135→    // Cache DOM elements
   136→   136→    cacheUIElements();
   137→   137→
   138→   138→    // Load settings
   139→   139→    loadSettingsToUI();
   140→   140→
   141→   141→    // Initialize UI handlers
   142→   142→    initOptionsToggle();
   143→   143→    initSliders();
   144→   144→    initFeatureToggles();
   145→   145→    initPresetSelector();
   146→   146→    initGoButton();
   147→   147→    initPreviewHandlers();
   148→   148→    initModals();
   149→   149→    initLoginModal();
   150→   150→    initCredits();
   151→   151→    initHelpButton();
   152→   152→
   153→   153→    // Initialize offline detection
   154→   154→    if (typeof initOfflineDetection === 'function') {
   155→   155→        initOfflineDetection();
   156→   156→    }
   157→   157→
   158→   158→    // Initialize multitrack UI
   159→   159→    if (typeof initMultitrackUI === 'function') {
   160→   160→        initMultitrackUI();
   161→   161→    }
   162→   162→
   163→   163→    // Initialize animated captions UI
   164→   164→    if (typeof initAnimatedCaptions === 'function') {
   165→   165→        initAnimatedCaptions();
   166→   166→    }
   167→   167→
   168→   168→    // Initialize text editor UI
   169→   169→    if (typeof initTextEditor === 'function') {
   170→   170→        initTextEditor();
   171→   171→    }
   172→   172→
   173→   173→    // Initialize text editor section toggle
   174→   174→    initTextEditorToggle();
   175→   175→
   176→   176→    // Initialize social reframe UI
   177→   177→    if (typeof initSocialReframe === 'function') {
   178→   178→        initSocialReframe();
   179→   179→    }
   180→   180→
   181→   181→    // Initialize social reframe section toggle
   182→   182→    initSocialReframeToggle();
   183→   183→
   184→   184→    // Initialize music UI
   185→   185→    if (typeof initMusicModule === 'function') {
   186→   186→        initMusicModule();
   187→   187→    }
   188→   188→
   189→   189→    // Initialize music section toggle
   190→   190→    initMusicToggle();
   191→   191→
   192→   192→    // Initialize JSX bridge first, then check connection
   193→   193→    // This ensures jsx.init() completes before checkJSXConnection() uses it
   194→   194→    await jsx.init();
   195→   195→    await checkJSXConnection();
   196→   196→
   197→   197→    // Initialize sequence event listeners for real-time state updates
   198→   198→    initSequenceEventListeners();
   199→   199→
   200→   200→    setStatus('Ready');
   201→   201→    console.log('[SPLICE] CEP panel initialized');
   202→   202→});
   203→   203→
   204→   204→// ============================================================================
   205→   205→// SEQUENCE EVENT LISTENERS
   206→   206→// ============================================================================
   207→   207→/**
   208→   208→ * Initialize event listeners for sequence state changes
   209→   209→ * This provides real-time updates when sequences are activated/deactivated
   210→   210→ */
   211→   211→function initSequenceEventListeners() {
   212→   212→    if (!jsx.cs) {
   213→   213→        console.warn('[SPLICE] Cannot init sequence listeners - CSInterface not available');
   214→   214→        return;
   215→   215→    }
   216→   216→
   217→   217→    try {
   218→   218→        // Listen for sequence activation events
   219→   219→        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceActivated', async (event) => {
   220→   220→            console.log('[SPLICE] Sequence activated event received');
   221→   221→            try {
   222→   222→                const seqInfo = await jsx.call('getActiveSequence');
   223→   223→                if (seqInfo && !seqInfo.error) {
   224→   224→                    window.spliceState.activeSequence = seqInfo;
   225→   225→                    setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));
   226→   226→                    console.log('[SPLICE] Active sequence updated:', seqInfo.name);
   227→   227→                }
   228→   228→            } catch (e) {
   229→   229→                console.warn('[SPLICE] Failed to get sequence info on activation:', e.message);
   230→   230→            }
   231→   231→        });
   232→   232→
   233→   233→        // Listen for sequence close/deactivation
   234→   234→        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceDeactivated', () => {
   235→   235→            console.log('[SPLICE] Sequence deactivated event');
   236→   236→            window.spliceState.activeSequence = null;
   237→   237→            setStatus('No sequence open', true);
   238→   238→        });
   239→   239→
   240→   240→        // Listen for project item selection changes (includes sequences)
   241→   241→        jsx.cs.addEventListener('com.adobe.csxs.events.SelectionChanged', async () => {
   242→   242→            // Debounce rapid selection changes
   243→   243→            if (window._selectionChangeTimeout) {
   244→   244→                clearTimeout(window._selectionChangeTimeout);
   245→   245→            }
   246→   246→            window._selectionChangeTimeout = setTimeout(async () => {
   247→   247→                try {
   248→   248→                    const hasSequence = await checkSequenceOpen(0, 0); // Quick check, no retries
   249→   249→                    if (hasSequence && !window.spliceState.activeSequence) {
   250→   250→                        const seqInfo = await jsx.call('getActiveSequence');
   251→   251→                        if (seqInfo && !seqInfo.error) {
   252→   252→                            window.spliceState.activeSequence = seqInfo;
   253→   253→                            console.log('[SPLICE] Sequence detected via selection change:', seqInfo.name);
   254→   254→                        }
   255→   255→                    }
   256→   256→                } catch (e) {
   257→   257→                    // Ignore errors during selection change - it's just for proactive updates
   258→   258→                }
   259→   259→            }, 200);
   260→   260→        });
   261→   261→
   262→   262→        console.log('[SPLICE] Sequence event listeners initialized');
   263→   263→    } catch (e) {
   264→   264→        console.error('[SPLICE] Failed to init sequence event listeners:', e.message);
   265→   265→    }
   266→   266→}
   267→   267→
   268→   268→// ============================================================================
   269→   269→// JSX CONNECTION CHECK
   270→   270→// ============================================================================
   271→   271→async function checkJSXConnection() {
   272→   272→    try {
   273→   273→        const result = await jsx.call('getVersion');
   274→   274→        console.log('[SPLICE] JSX connection OK, version:', result);
   275→   275→        return true;
   276→   276→    } catch (e) {
   277→   277→        console.warn('[SPLICE] JSX connection failed:', e.message);
   278→   278→        setStatus('Premiere Pro connection failed', true);
   279→   279→        return false;
   280→   280→    }
   281→   281→}
   282→   282→
   283→   283→/**
   284→   284→ * Check if a sequence is currently open in the Timeline
   285→   285→ * Enhanced with logging and retry logic
   286→   286→ * @param {number} retries - Number of retry attempts (default: 2)
   287→   287→ * @param {number} delayMs - Delay between retries in ms (default: 300)
   288→   288→ * @returns {Promise<boolean>} true if sequence is open
   289→   289→ */
   290→   290→async function checkSequenceOpen(retries = 2, delayMs = 300) {
   291→   291→    for (let attempt = 0; attempt <= retries; attempt++) {
   292→   292→        try {
   293→   293→            const result = await jsx.call('checkSequenceOpen');
   294→   294→            console.log('[SPLICE] checkSequenceOpen attempt', attempt + 1, 'result:', result, 'type:', typeof result);
   295→   295→
   296→   296→            if (result === true || result === 'true') {
   297→   297→                return true;
   298→   298→            }
   299→   299→
   300→   300→            // If false, wait and retry (sequence might be loading)
   301→   301→            if (attempt < retries) {
   302→   302→                console.log('[SPLICE] checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');
   303→   303→                await new Promise(r => setTimeout(r, delayMs));
   304→   304→            }
   305→   305→        } catch (error) {
   306→   306→            console.error('[SPLICE] checkSequenceOpen attempt', attempt + 1, 'failed:', error.message);
   307→   307→
   308→   308→            // On last attempt, return false but log the actual error
   309→   309→            if (attempt === retries) {
   310→   310→                console.error('[SPLICE] checkSequenceOpen: All attempts failed. Last error:', error.message);
   311→   311→                // Store error for diagnostics
   312→   312→                window.spliceState.lastSequenceCheckError = error.message;
   313→   313→                return false;
   314→   314→            }
   315→   315→
   316→   316→            // Wait before retry
   317→   317→            await new Promise(r => setTimeout(r, delayMs));
   318→   318→        }
   319→   319→    }
   320→   320→    return false;
   321→   321→}
   322→   322→
   323→   323→// ============================================================================
   324→   324→// OPTIONS TOGGLE
   325→   325→// ============================================================================
   326→   326→function initOptionsToggle() {
   327→   327→    console.log('[SPLICE] initOptionsToggle - toggle:', !!ui.optionsToggle, 'panel:', !!ui.optionsPanel);
   328→   328→    if (ui.optionsToggle && ui.optionsPanel) {
   329→   329→        ui.optionsToggle.addEventListener('click', () => {
   330→   330→            console.log('[SPLICE] Options toggle clicked');
   331→   331→            // Check current state BEFORE toggling
   332→   332→            const wasCollapsed = ui.optionsPanel.classList.contains('collapsed');
   333→   333→            ui.optionsPanel.classList.toggle('collapsed');
   334→   334→            // If it was collapsed, it's now expanded (show 'expanded' class)
   335→   335→            ui.optionsToggle.classList.toggle('expanded', wasCollapsed);
   336→   336→            saveSettings({ expandedOptions: wasCollapsed });
   337→   337→        });
   338→   338→
   339→   339→        // Restore state
   340→   340→        const settings = getSettings();
   341→   341→        if (!settings.expandedOptions) {
   342→   342→            ui.optionsPanel.classList.add('collapsed');
   343→   343→            ui.optionsToggle.classList.remove('expanded');
   344→   344→        } else {
   345→   345→            ui.optionsToggle.classList.add('expanded');
   346→   346→            ui.optionsPanel.classList.remove('collapsed');
   347→   347→        }
   348→   348→    }
   349→   349→}
   350→   350→
   351→   351→// ============================================================================
   352→   352→// TEXT EDITOR TOGGLE
   353→   353→// ============================================================================
   354→   354→function initTextEditorToggle() {
   355→   355→    const toggle = document.getElementById('textEditorToggle');
   356→   356→    const panel = document.getElementById('text-editor-panel');
   357→   357→    console.log('[SPLICE] initTextEditorToggle - toggle:', !!toggle, 'panel:', !!panel);
   358→   358→
   359→   359→    if (toggle && panel) {
   360→   360→        toggle.addEventListener('click', (e) => {
   361→   361→            e.preventDefault();
   362→   362→            e.stopPropagation();
   363→   363→            console.log('[SPLICE] Text Editor toggle clicked');
   364→   364→            setStatus('Text Editor: ' + (panel.classList.contains('collapsed') ? 'Opening' : 'Closing'));
   365→   365→            // Check state BEFORE toggling
   366→   366→            const wasCollapsed = panel.classList.contains('collapsed');
   367→   367→            panel.classList.toggle('collapsed');
   368→   368→            const icon = toggle.querySelector('.toggle-icon');
   369→   369→            console.log('[SPLICE] wasCollapsed:', wasCollapsed, 'icon:', !!icon);
   370→   370→            if (icon) {
   371→   371→                // If it was collapsed, it's now expanded (show -)
   372→   372→                icon.textContent = wasCollapsed ? '-' : '+';
   373→   373→            }
   374→   374→        });
   375→   375→    } else {
   376→   376→        console.error('[SPLICE] Text Editor toggle elements not found!');
   377→   377→    }
   378→   378→}
   379→   379→
   380→   380→// ============================================================================
   381→   381→// SOCIAL REFRAME TOGGLE
   382→   382→// ============================================================================
   383→   383→function initSocialReframeToggle() {
   384→   384→    const toggle = document.getElementById('socialReframeToggle');
   385→   385→    const panel = document.getElementById('social-reframe-panel');
   386→   386→    console.log('[SPLICE] initSocialReframeToggle - toggle:', !!toggle, 'panel:', !!panel);
   387→   387→
   388→   388→    if (toggle && panel) {
   389→   389→        toggle.addEventListener('click', () => {
   390→   390→            console.log('[SPLICE] Social Reframe toggle clicked');
   391→   391→            // Check state BEFORE toggling
   392→   392→            const wasCollapsed = panel.classList.contains('collapsed');
   393→   393→            panel.classList.toggle('collapsed');
   394→   394→            const icon = toggle.querySelector('.toggle-icon');
   395→   395→            if (icon) {
   396→   396→                // If it was collapsed, it's now expanded (show -)
   397→   397→                icon.textContent = wasCollapsed ? '-' : '+';
   398→   398→            }
   399→   399→        });
   400→   400→    } else {
   401→   401→        console.error('[SPLICE] Social Reframe toggle elements not found!');
   402→   402→    }
   403→   403→}
   404→   404→
   405→   405→// ============================================================================
   406→   406→// MUSIC TOGGLE
   407→   407→// ============================================================================
   408→   408→function initMusicToggle() {
   409→   409→    const toggle = document.getElementById('musicToggle');
   410→   410→    const panel = document.getElementById('music-panel');
   411→   411→    console.log('[SPLICE] initMusicToggle - toggle:', !!toggle, 'panel:', !!panel);
   412→   412→
   413→   413→    if (toggle && panel) {
   414→   414→        toggle.addEventListener('click', () => {
   415→   415→            console.log('[SPLICE] Music toggle clicked');
   416→   416→            // Check state BEFORE toggling
   417→   417→            const wasCollapsed = panel.classList.contains('collapsed');
   418→   418→            panel.classList.toggle('collapsed');
   419→   419→            const icon = toggle.querySelector('.toggle-icon');
   420→   420→            if (icon) {
   421→   421→                // If it was collapsed, it's now expanded (show -)
   422→   422→                icon.textContent = wasCollapsed ? '-' : '+';
   423→   423→            }
   424→   424→        });
   425→   425→    } else {
   426→   426→        console.error('[SPLICE] Music toggle elements not found!');
   427→   427→    }
   428→   428→}
   429→   429→
   430→   430→// ============================================================================
   431→   431→// SLIDERS
   432→   432→// ============================================================================
   433→   433→function initSliders() {
   434→   434→    // Sensitivity slider
   435→   435→    if (ui.sensitivitySlider && ui.sensitivityValue) {
   436→   436→        ui.sensitivitySlider.addEventListener('input', () => {
   437→   437→            ui.sensitivityValue.textContent = ui.sensitivitySlider.value;
   438→   438→            saveSettings({ sensitivity: parseInt(ui.sensitivitySlider.value) });
   439→   439→        });
   440→   440→    }
   441→   441→
   442→   442→    // J-Cut sliders
   443→   443→    if (ui.jcutLeadIn && ui.jcutLeadInValue) {
   444→   444→        ui.jcutLeadIn.addEventListener('input', () => {
   445→   445→            const val = (ui.jcutLeadIn.value / 100).toFixed(2);
   446→   446→            ui.jcutLeadInValue.textContent = val + 's';
   447→   447→            saveSettings({ jcutLeadIn: parseFloat(val) });
   448→   448→        });
   449→   449→    }
   450→   450→
   451→   451→    if (ui.jcutLeadOut && ui.jcutLeadOutValue) {
   452→   452→        ui.jcutLeadOut.addEventListener('input', () => {
   453→   453→            const val = (ui.jcutLeadOut.value / 100).toFixed(2);
   454→   454→            ui.jcutLeadOutValue.textContent = val + 's';
   455→   455→            saveSettings({ jcutLeadOut: parseFloat(val) });
   456→   456→        });
   457→   457→    }
   458→   458→}
   459→   459→
   460→   460→// ============================================================================
   461→   461→// FEATURE TOGGLES
   462→   462→// ============================================================================
   463→   463→function initFeatureToggles() {
   464→   464→    // J-Cut toggle
   465→   465→    if (ui.enableJCut && ui.jcutSettings) {
   466→   466→        ui.enableJCut.addEventListener('change', () => {
   467→   467→            ui.jcutSettings.classList.toggle('collapsed', !ui.enableJCut.checked);
   468→   468→            saveSettings({ enableJCut: ui.enableJCut.checked });
   469→   469→        });
   470→   470→    }
   471→   471→
   472→   472→    // Zoom toggle
   473→   473→    if (ui.enableZoom && ui.zoomSettings) {
   474→   474→        ui.enableZoom.addEventListener('change', () => {
   475→   475→            ui.zoomSettings.classList.toggle('collapsed', !ui.enableZoom.checked);
   476→   476→            saveSettings({ enableZoom: ui.enableZoom.checked });
   477→   477→        });
   478→   478→    }
   479→   479→
   480→   480→    // Chapters toggle
   481→   481→    if (ui.enableChapters && ui.chapterSettings) {
   482→   482→        ui.enableChapters.addEventListener('change', () => {
   483→   483→            ui.chapterSettings.classList.toggle('collapsed', !ui.enableChapters.checked);
   484→   484→            saveSettings({ enableChapters: ui.enableChapters.checked });
   485→   485→        });
   486→   486→    }
   487→   487→
   488→   488→    // Takes detection toggle
   489→   489→    if (ui.enableTakesDetection) {
   490→   490→        ui.enableTakesDetection.addEventListener('change', () => {
   491→   491→            saveSettings({ enableTakesDetection: ui.enableTakesDetection.checked });
   492→   492→        });
   493→   493→    }
   494→   494→
   495→   495→    // Profanity detection toggle
   496→   496→    if (ui.enableProfanity && ui.profanitySettings) {
   497→   497→        ui.enableProfanity.addEventListener('change', () => {
   498→   498→            ui.profanitySettings.classList.toggle('collapsed', !ui.enableProfanity.checked);
   499→   499→            saveSettings({ enableProfanity: ui.enableProfanity.checked });
   500→   500→        });
   501→   501→    }
   502→   502→
   503→   503→    // Filler word detection toggle
   504→   504→    if (ui.enableFillerDetection && ui.fillerSettings) {
   505→   505→        ui.enableFillerDetection.addEventListener('change', () => {
   506→   506→            ui.fillerSettings.classList.toggle('collapsed', !ui.enableFillerDetection.checked);
   507→   507→            saveSettings({ enableFillerDetection: ui.enableFillerDetection.checked });
   508→   508→        });
   509→   509→    }
   510→   510→}
   511→   511→
   512→   512→// ============================================================================
   513→   513→// PRESET SELECTOR
   514→   514→// ============================================================================
   515→   515→// PRESETS is defined in config.js
   516→   516→
   517→   517→function initPresetSelector() {
   518→   518→    if (!ui.presetSelector) return;
   519→   519→
   520→   520→    ui.presetSelector.addEventListener('change', () => {
   521→   521→        const presetId = ui.presetSelector.value;
   522→   522→        applyPreset(presetId);
   523→   523→    });
   524→   524→
   525→   525→    // Load current preset
   526→   526→    const settings = getSettings();
   527→   527→    if (settings.activePreset) {
   528→   528→        ui.presetSelector.value = settings.activePreset;
   529→   529→    }
   530→   530→}
   531→   531→
   532→   532→function applyPreset(presetId) {
   533→   533→    const preset = PRESETS[presetId];
   534→   534→    if (!preset) return;
   535→   535→
   536→   536→    // Custom preset - keep current settings
   537→   537→    if (presetId === 'custom' || !preset.settings) {
   538→   538→        saveSettings({ activePreset: 'custom' });
   539→   539→        setStatus('Using custom settings');
   540→   540→        return;
   541→   541→    }
   542→   542→
   543→   543→    const settings = preset.settings;
   544→   544→
   545→   545→    // Apply to UI
   546→   546→    if (ui.sensitivitySlider && settings.sensitivity !== undefined) {
   547→   547→        ui.sensitivitySlider.value = settings.sensitivity;
   548→   548→        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;
   549→   549→    }
   550→   550→
   551→   551→    if (ui.enableJCut) {
   552→   552→        ui.enableJCut.checked = settings.enableJCut || false;
   553→   553→        if (ui.jcutSettings) {
   554→   554→            ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);
   555→   555→        }
   556→   556→    }
   557→   557→
   558→   558→    if (settings.jCutLeadIn !== undefined && ui.jcutLeadIn) {
   559→   559→        ui.jcutLeadIn.value = Math.round(settings.jCutLeadIn * 100);
   560→   560→        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jCutLeadIn + 's';
   561→   561→    }
   562→   562→
   563→   563→    if (settings.jCutLeadOut !== undefined && ui.jcutLeadOut) {
   564→   564→        ui.jcutLeadOut.value = Math.round(settings.jCutLeadOut * 100);
   565→   565→        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jCutLeadOut + 's';
   566→   566→    }
   567→   567→
   568→   568→    // Save merged settings
   569→   569→    saveSettings({
   570→   570→        activePreset: presetId,
   571→   571→        sensitivity: settings.sensitivity,
   572→   572→        threshold: settings.threshold,
   573→   573→        minSilenceLength: settings.minSilenceLength,
   574→   574→        paddingStart: settings.paddingStart,
   575→   575→        paddingEnd: settings.paddingEnd,
   576→   576→        enableTakesDetection: settings.enableTakesDetection,
   577→   577→        enableJCut: settings.enableJCut || false,
   578→   578→        jcutLeadIn: settings.jCutLeadIn || 0.3,
   579→   579→        jcutLeadOut: settings.jCutLeadOut || 0.2
   580→   580→    });
   581→   581→
   582→   582→    setStatus(`Applied ${preset.name} preset`);
   583→   583→}
   584→   584→
   585→   585→// ============================================================================
   586→   586→// LOAD SETTINGS TO UI
   587→   587→// ============================================================================
   588→   588→function loadSettingsToUI() {
   589→   589→    const settings = getSettings();
   590→   590→
   591→   591→    if (ui.sensitivitySlider) {
   592→   592→        ui.sensitivitySlider.value = settings.sensitivity;
   593→   593→        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;
   594→   594→    }
   595→   595→
   596→   596→    if (ui.enableTakesDetection) ui.enableTakesDetection.checked = settings.enableTakesDetection;
   597→   597→    if (ui.enableJCut) ui.enableJCut.checked = settings.enableJCut;
   598→   598→    if (ui.enableZoom) ui.enableZoom.checked = settings.enableZoom;
   599→   599→    if (ui.enableChapters) ui.enableChapters.checked = settings.enableChapters;
   600→   600→
   601→   601→    if (ui.jcutSettings) ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);
   602→   602→    if (ui.zoomSettings) ui.zoomSettings.classList.toggle('collapsed', !settings.enableZoom);
   603→   603→    if (ui.chapterSettings) ui.chapterSettings.classList.toggle('collapsed', !settings.enableChapters);
   604→   604→
   605→   605→    if (ui.jcutLeadIn) {
   606→   606→        ui.jcutLeadIn.value = Math.round(settings.jcutLeadIn * 100);
   607→   607→        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jcutLeadIn + 's';
   608→   608→    }
   609→   609→    if (ui.jcutLeadOut) {
   610→   610→        ui.jcutLeadOut.value = Math.round(settings.jcutLeadOut * 100);
   611→   611→        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jcutLeadOut + 's';
   612→   612→    }
   613→   613→
   614→   614→    if (ui.presetSelector && settings.activePreset) {
   615→   615→        ui.presetSelector.value = settings.activePreset;
   616→   616→    }
   617→   617→}
   618→   618→
   619→   619→// ============================================================================
   620→   620→// GO BUTTON - MAIN WORKFLOW
   621→   621→// ============================================================================
   622→   622→function initGoButton() {
   623→   623→    if (!ui.goBtn) return;
   624→   624→
   625→   625→    ui.goBtn.addEventListener('click', async () => {
   626→   626→        if (isOperationInProgress) return;
   627→   627→        await runDetection();
   628→   628→    });
   629→   629→}
   630→   630→
   631→   631→async function runDetection() {
   632→   632→    if (isOperationInProgress) return;
   633→   633→
   634→   634→    // Check sequence with enhanced error messaging
   635→   635→    const hasSequence = await checkSequenceOpen();
   636→   636→    if (!hasSequence) {
   637→   637→        // Check if there was a communication error vs just no sequence
   638→   638→        const lastError = window.spliceState.lastSequenceCheckError;
   639→   639→        if (lastError && (lastError.includes('CEP') || lastError.includes('communication') || lastError.includes('evalScript'))) {
   640→   640→            setStatus('Premiere Pro connection issue - try reopening panel', true);
   641→   641→            console.error('[SPLICE] runDetection: JSX communication failure:', lastError);
   642→   642→        } else {
   643→   643→            setStatus('Please open a sequence in the Timeline first', true);
   644→   644→            console.log('[SPLICE] runDetection: No active sequence in Timeline');
   645→   645→        }
   646→   646→        // Clear the error for next check
   647→   647→        window.spliceState.lastSequenceCheckError = null;
   648→   648→        return;
   649→   649→    }
   650→   650→
   651→   651→    // Check online
   652→   652→    if (!isOnline()) {
   653→   653→        setStatus('Offline - Check your connection', true);
   654→   654→        return;
   655→   655→    }
   656→   656→
   657→   657→    isOperationInProgress = true;
   658→   658→    ui.goBtn.disabled = true;
   659→   659→    showProgress('Detecting silences...');
   660→   660→
   661→   661→    try {
   662→   662→        const settings = getSettings();
   663→   663→
   664→   664→        // Get sequence info
   665→   665→        const seqInfo = await jsx.call('getActiveSequence');
   666→   666→        console.log('[SPLICE] Sequence info:', seqInfo);
   667→   667→
   668→   668→        // Store sequence info for later use
   669→   669→        currentSequenceInfo = seqInfo;
   670→   670→        window.spliceState.activeSequence = seqInfo;
   671→   671→        if (seqInfo && seqInfo.videoPath) {
   672→   672→            window.spliceState.currentVideoPath = seqInfo.videoPath;
   673→   673→        }
   674→   674→
   675→   675→        // Export audio via JSX for silence detection
   676→   676→        updateProgress(10, 'Exporting audio...');
   677→   677→
   678→   678→        let audioFilePath = null;
   679→   679→        try {
   680→   680→            // Get sequence info for audio export
   681→   681→            const exportResult = await jsx.call('exportSequenceAudioForAnalysis');
   682→   682→            if (exportResult && exportResult.success && exportResult.outputPath) {
   683→   683→                audioFilePath = exportResult.outputPath;
   684→   684→                console.log('[SPLICE] Audio exported to:', audioFilePath);
   685→   685→            } else if (exportResult && exportResult.error) {
   686→   686→                throw new Error(exportResult.error);
   687→   687→            }
   688→   688→        } catch (exportError) {
   689→   689→            console.warn('[SPLICE] Audio export failed, trying fallback:', exportError.message);
   690→   690→            // Try to get audio from first clip in timeline
   691→   691→            try {
   692→   692→                const clipInfo = await jsx.call('getFirstClipAudioPath');
   693→   693→                if (clipInfo && clipInfo.path) {
   694→   694→                    audioFilePath = clipInfo.path;
   695→   695→                    console.log('[SPLICE] Using clip audio path:', audioFilePath);
   696→   696→                }
   697→   697→            } catch (clipError) {
   698→   698→                console.warn('[SPLICE] Fallback audio path failed:', clipError.message);
   699→   699→            }
   700→   700→        }
   701→   701→
   702→   702→        if (!audioFilePath) {
   703→   703→            throw new Error('Could not export or locate audio file. Please ensure sequence has audio tracks.');
   704→   704→        }
   705→   705→
   706→   706→        // Store audio path globally for other modules
   707→   707→        currentAudioPath = audioFilePath;
   708→   708→        window.spliceState.audioPath = audioFilePath;
   709→   709→
   710→   710→        // Call backend for silence detection with audio file path
   711→   711→        updateProgress(30, 'Detecting silences...');
   712→   712→        const silenceResponse = await fetchWithTimeout(
   713→   713→            `${getBackendUrl()}/silences-rms`,
   714→   714→            {
   715→   715→                method: 'POST',
   716→   716→                headers: getAuthHeaders(),
   717→   717→                body: JSON.stringify({
   718→   718→                    wavPath: audioFilePath,
   719→   719→                    sensitivity: settings.sensitivity,
   720→   720→                    minSilenceLength: settings.minSilenceLength || 0.5
   721→   721→                })
   722→   722→            }
   723→   723→        );
   724→   724→
   725→   725→        if (!silenceResponse.ok) {
   726→   726→            throw new Error(await parseErrorResponse(silenceResponse));
   727→   727→        }
   728→   728→
   729→   729→        const silenceData = await silenceResponse.json();
   730→   730→        previewSilences = silenceData.silences || [];
   731→   731→
   732→   732→        // Detect takes if enabled
   733→   733→        if (settings.enableTakesDetection) {
   734→   734→            updateProgress(60, 'Detecting takes...');
   735→   735→            try {
   736→   736→                const analyzeResponse = await fetchWithTimeout(
   737→   737→                    `${getBackendUrl()}/analyze`,
   738→   738→                    {
   739→   739→                        method: 'POST',
   740→   740→                        headers: getAuthHeaders(),
   741→   741→                        body: JSON.stringify({
   742→   742→                            wavPath: audioFilePath,
   743→   743→                            detectTakes: true
   744→   744→                        })
   745→   745→                    }
   746→   746→                );
   747→   747→
   748→   748→                if (analyzeResponse.ok) {
   749→   749→                    const analyzeData = await analyzeResponse.json();
   750→   750→                    previewTakes = analyzeData.takes || [];
   751→   751→
   752→   752→                    // Store transcript for captions/music modules
   753→   753→                    if (analyzeData.transcript) {
   754→   754→                        currentTranscript = analyzeData.transcript;
   755→   755→                        window.currentTranscript = analyzeData.transcript;
   756→   756→                        window.spliceState.lastTranscript = analyzeData.transcript;
   757→   757→                    }
   758→   758→                } else {
   759→   759→                    // Handle specific error codes
   760→   760→                    const errorMsg = await parseErrorResponse(analyzeResponse);
   761→   761→                    if (analyzeResponse.status === 402) {
   762→   762→                        console.warn('[SPLICE] Takes detection skipped: insufficient credits');
   763→   763→                        setStatus('Takes detection skipped: insufficient credits', true);
   764→   764→                    } else if (analyzeResponse.status === 401) {
   765→   765→                        console.warn('[SPLICE] Takes detection skipped: authentication required');
   766→   766→                    } else {
   767→   767→                        console.warn('[SPLICE] Takes detection failed:', errorMsg);
   768→   768→                    }
   769→   769→                }
   770→   770→            } catch (e) {
   771→   771→                console.warn('[SPLICE] Takes detection failed:', e.message);
   772→   772→            }
   773→   773→        }
   774→   774→
   775→   775→        // Detect profanity if enabled
   776→   776→        if (settings.enableProfanity) {
   777→   777→            updateProgress(65, 'Detecting profanity...');
   778→   778→            try {
   779→   779→                const profanityResponse = await fetchWithTimeout(
   780→   780→                    `${getBackendUrl()}/profanity`,
   781→   781→                    {
   782→   782→                        method: 'POST',
   783→   783→                        headers: getAuthHeaders(),
   784→   784→                        body: JSON.stringify({
   785→   785→                            wavPath: audioFilePath,
   786→   786→                            language: settings.profanityLanguage || 'en',
   787→   787→                            bleepType: settings.bleepType || 'standard'
   788→   788→                        })
   789→   789→                    }
   790→   790→                );
   791→   791→
   792→   792→                if (profanityResponse.ok) {
   793→   793→                    const profanityData = await profanityResponse.json();
   794→   794→                    currentProfanity = profanityData.instances || [];
   795→   795→                    if (currentProfanity.length > 0) {
   796→   796→                        console.log(`[SPLICE] Found ${currentProfanity.length} profanity instances`);
   797→   797→                    }
   798→   798→                } else {
   799→   799→                    console.warn('[SPLICE] Profanity detection failed:', await parseErrorResponse(profanityResponse));
   800→   800→                }
   801→   801→            } catch (e) {
   802→   802→                console.warn('[SPLICE] Profanity detection failed:', e.message);
   803→   803→            }
   804→   804→        }
   805→   805→
   806→   806→        // Detect chapters if enabled
   807→   807→        if (settings.enableChapters) {
   808→   808→            updateProgress(80, 'Detecting chapters...');
   809→   809→            try {
   810→   810→                const chapterResponse = await fetchWithTimeout(
   811→   811→                    `${getBackendUrl()}/chapters`,
   812→   812→                    {
   813→   813→                        method: 'POST',
   814→   814→                        headers: getAuthHeaders(),
   815→   815→                        body: JSON.stringify({
   816→   816→                            wavPath: audioFilePath,
   817→   817→                            transcript: currentTranscript,
   818→   818→                            maxChapters: settings.maxChapters || 10,
   819→   819→                            minChapterLength: settings.minChapterLength || 60
   820→   820→                        })
   821→   821→                    }
   822→   822→                );
   823→   823→
   824→   824→                if (chapterResponse.ok) {
   825→   825→                    const chapterData = await chapterResponse.json();
   826→   826→                    currentChapters = chapterData.chapters || [];
   827→   827→                }
   828→   828→            } catch (e) {
   829→   829→                console.warn('[SPLICE] Chapter detection failed:', e);
   830→   830→            }
   831→   831→        }
   832→   832→
   833→   833→        // Detect zoom points if enabled
   834→   834→        if (settings.enableZoom) {
   835→   835→            updateProgress(90, 'Detecting zoom points...');
   836→   836→            try {
   837→   837→                const zoomResponse = await fetchWithTimeout(
   838→   838→                    `${getBackendUrl()}/zoom`,
   839→   839→                    {
   840→   840→                        method: 'POST',
   841→   841→                        headers: getAuthHeaders(),
   842→   842→                        body: JSON.stringify({
   843→   843→                            wavPath: audioFilePath,
   844→   844→                            transcript: currentTranscript,
   845→   845→                            frequency: settings.zoomFrequency || 'medium',
   846→   846→                            preset: settings.zoomPreset || 'medium',
   847→   847→                            placement: settings.zoomPlacement || 'sentence_start'
   848→   848→                        })
   849→   849→                    }
   850→   850→                );
   851→   851→
   852→   852→                if (zoomResponse.ok) {
   853→   853→                    const zoomData = await zoomResponse.json();
   854→   854→                    currentZooms = zoomData.zoomPoints || [];
   855→   855→                }
   856→   856→            } catch (e) {
   857→   857→                console.warn('[SPLICE] Zoom detection failed:', e);
   858→   858→            }
   859→   859→        }
   860→   860→
   861→   861→        // Store results
   862→   862→        lastDetectionResult = {
   863→   863→            silences: previewSilences,
   864→   864→            takes: previewTakes,
   865→   865→            chapters: currentChapters,
   866→   866→            zooms: currentZooms
   867→   867→        };
   868→   868→
   869→   869→        // Show preview
   870→   870→        hideProgress();
   871→   871→        showCombinedPreview();
   872→   872→        setStatus(`Found ${previewSilences.length} silences, ${previewTakes.length} takes`);
   873→   873→
   874→   874→    } catch (error) {
   875→   875→        console.error('[SPLICE] Detection error:', error);
   876→   876→        setStatus('Detection failed: ' + error.message, true);
   877→   877→        hideProgress();
   878→   878→    } finally {
   879→   879→        isOperationInProgress = false;
   880→   880→        ui.goBtn.disabled = false;
   881→   881→    }
   882→   882→}
   883→   883→
   884→   884→// ============================================================================
   885→   885→// PROGRESS UI
   886→   886→// ============================================================================
   887→   887→function showProgress(message) {
   888→   888→    if (ui.progressContainer) ui.progressContainer.classList.remove('hidden');
   889→   889→    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');
   890→   890→    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');
   891→   891→    updateProgress(0, message);
   892→   892→}
   893→   893→
   894→   894→function updateProgress(percent, message) {
   895→   895→    if (ui.progressBar) ui.progressBar.style.width = percent + '%';
   896→   896→    if (ui.progressText) ui.progressText.textContent = message || '';
   897→   897→}
   898→   898→
   899→   899→function hideProgress() {
   900→   900→    if (ui.progressContainer) ui.progressContainer.classList.add('hidden');
   901→   901→}
   902→   902→
   903→   903→// ============================================================================
   904→   904→// COMBINED PREVIEW
   905→   905→// ============================================================================
   906→   906→function showCombinedPreview() {
   907→   907→    if (!ui.combinedPreview) return;
   908→   908→
   909→   909→    ui.combinedPreview.classList.remove('hidden');
   910→   910→    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');
   911→   911→
   912→   912→    // Update counts
   913→   913→    if (ui.silenceCount) ui.silenceCount.textContent = previewSilences.length;
   914→   914→    if (ui.takeCount) ui.takeCount.textContent = previewTakes.length;
   915→   915→
   916→   916→    // Select all by default
   917→   917→    selectedSilenceIndices.clear();
   918→   918→    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));
   919→   919→    updateSelectedCount();
   920→   920→
   921→   921→    // Render preview list
   922→   922→    renderPreviewList();
   923→   923→
   924→   924→    // Show chapter results if available
   925→   925→    if (currentChapters.length > 0 && ui.chapterResults) {
   926→   926→        ui.chapterResults.classList.remove('hidden');
   927→   927→        renderChapterList();
   928→   928→    }
   929→   929→
   930→   930→    // Show zoom results if available
   931→   931→    if (currentZooms.length > 0 && ui.zoomResults) {
   932→   932→        ui.zoomResults.classList.remove('hidden');
   933→   933→    }
   934→   934→}
   935→   935→
   936→   936→function renderPreviewList() {
   937→   937→    if (!ui.previewList) return;
   938→   938→
   939→   939→    const html = [];
   940→   940→
   941→   941→    // Render silences
   942→   942→    previewSilences.forEach((silence, i) => {
   943→   943→        const isSelected = selectedSilenceIndices.has(i);
   944→   944→        const duration = silence.end - silence.start;
   945→   945→        html.push(`
   946→   946→            <div class="preview-item ${isSelected ? '' : 'excluded'}" data-index="${i}" data-type="silence">
   947→   947→                <input type="checkbox" class="preview-item-check" ${isSelected ? 'checked' : ''}>
   948→   948→                <div class="preview-item-info">
   949→   949→                    <div class="preview-item-time">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>
   950→   950→                    <div class="preview-item-duration">${duration.toFixed(2)}s silence</div>
   951→   951→                </div>
   952→   952→            </div>
   953→   953→        `);
   954→   954→    });
   955→   955→
   956→   956→    // Render takes
   957→   957→    previewTakes.forEach((take, i) => {
   958→   958→        // SECURITY: Escape take label to prevent XSS
   959→   959→        const safeLabel = escapeHtml(take.label || 'Take ' + (take.takeNumber || i + 1));
   960→   960→        html.push(`
   961→   961→            <div class="preview-item take-item" data-index="${i}" data-type="take">
   962→   962→                <div class="preview-item-icon">🎬</div>
   963→   963→                <div class="preview-item-info">
   964→   964→                    <div class="preview-item-time">${formatTime(take.start)} - ${formatTime(take.end)}</div>
   965→   965→                    <div class="preview-item-label">${safeLabel}</div>
   966→   966→                </div>
   967→   967→            </div>
   968→   968→        `);
   969→   969→    });
   970→   970→
   971→   971→    ui.previewList.innerHTML = html.join('');
   972→   972→
   973→   973→    // Add click handlers
   974→   974→    ui.previewList.querySelectorAll('.preview-item').forEach(item => {
   975→   975→        item.addEventListener('click', (e) => {
   976→   976→            const index = parseInt(item.dataset.index);
   977→   977→            const type = item.dataset.type;
   978→   978→
   979→   979→            if (e.target.classList.contains('preview-item-check')) {
   980→   980→                // Checkbox clicked
   981→   981→                toggleSilenceSelection(index);
   982→   982→            } else {
   983→   983→                // Item clicked - seek to time
   984→   984→                const data = type === 'silence' ? previewSilences[index] : previewTakes[index];
   985→   985→                seekToTime(data.start);
   986→   986→            }
   987→   987→        });
   988→   988→    });
   989→   989→}
   990→   990→
   991→   991→function toggleSilenceSelection(index) {
   992→   992→    if (selectedSilenceIndices.has(index)) {
   993→   993→        selectedSilenceIndices.delete(index);
   994→   994→    } else {
   995→   995→        selectedSilenceIndices.add(index);
   996→   996→    }
   997→   997→    updateSelectedCount();
   998→   998→    renderPreviewList();
   999→   999→}
  1000→  1000→
  1001→  1001→function updateSelectedCount() {
  1002→  1002→    if (ui.selectedCount) {
  1003→  1003→        ui.selectedCount.textContent = selectedSilenceIndices.size;
  1004→  1004→    }
  1005→  1005→    if (ui.selectAllSilences) {
  1006→  1006→        ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length;
  1007→  1007→    }
  1008→  1008→}
  1009→  1009→
  1010→  1010→async function seekToTime(seconds) {
  1011→  1011→    try {
  1012→  1012→        // Check if there's an active sequence before seeking
  1013→  1013→        if (!app?.project?.activeSequence) {
  1014→  1014→            console.warn('[SPLICE] No active sequence to seek in');
  1015→  1015→            return;
  1016→  1016→        }
  1017→  1017→        // Use JSX to set playhead position
  1018→  1018→        // Note: setPlayerPosition expects ticks as a string without quotes around the number value
  1019→  1019→        const ticks = Math.round(seconds * 254016000000);
  1020→  1020→        await jsx.evalScript(`app.project.activeSequence.setPlayerPosition(${ticks})`);
  1021→  1021→    } catch (e) {
  1022→  1022→        console.warn('[SPLICE] Seek failed:', e);
  1023→  1023→    }
  1024→  1024→}
  1025→  1025→
  1026→  1026→// ============================================================================
  1027→  1027→// CHAPTER LIST
  1028→  1028→// ============================================================================
  1029→  1029→function renderChapterList() {
  1030→  1030→    if (!ui.chapterList) return;
  1031→  1031→
  1032→  1032→    const html = currentChapters.map((chapter, i) => {
  1033→  1033→        // SECURITY: Escape chapter title to prevent XSS
  1034→  1034→        const safeTitle = escapeHtml(chapter.title);
  1035→  1035→        return `
  1036→  1036→            <div class="chapter-item" data-index="${i}">
  1037→  1037→                <div class="chapter-time">${formatTime(chapter.startTime)}</div>
  1038→  1038→                <div class="chapter-title">${safeTitle}</div>
  1039→  1039→            </div>
  1040→  1040→        `;
  1041→  1041→    }).join('');
  1042→  1042→
  1043→  1043→    ui.chapterList.innerHTML = html;
  1044→  1044→
  1045→  1045→    // Add click handlers
  1046→  1046→    ui.chapterList.querySelectorAll('.chapter-item').forEach(item => {
  1047→  1047→        item.addEventListener('click', () => {
  1048→  1048→            const index = parseInt(item.dataset.index);
  1049→  1049→            seekToTime(currentChapters[index].startTime);
  1050→  1050→        });
  1051→  1051→    });
  1052→  1052→}
  1053→  1053→
  1054→  1054→// ============================================================================
  1055→  1055→// PREVIEW HANDLERS
  1056→  1056→// ============================================================================
  1057→  1057→function initPreviewHandlers() {
  1058→  1058→    // Select all checkbox
  1059→  1059→    if (ui.selectAllSilences) {
  1060→  1060→        ui.selectAllSilences.addEventListener('change', () => {
  1061→  1061→            if (ui.selectAllSilences.checked) {
  1062→  1062→                previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));
  1063→  1063→            } else {
  1064→  1064→                selectedSilenceIndices.clear();
  1065→  1065→            }
  1066→  1066→            updateSelectedCount();
  1067→  1067→            renderPreviewList();
  1068→  1068→        });
  1069→  1069→    }
  1070→  1070→
  1071→  1071→    // Apply button
  1072→  1072→    if (ui.applyPreviewBtn) {
  1073→  1073→        ui.applyPreviewBtn.addEventListener('click', applyPreviewAndMarkers);
  1074→  1074→    }
  1075→  1075→
  1076→  1076→    // Cancel button
  1077→  1077→    if (ui.cancelPreviewBtn) {
  1078→  1078→        ui.cancelPreviewBtn.addEventListener('click', hidePreview);
  1079→  1079→    }
  1080→  1080→
  1081→  1081→    // Build sequence button
  1082→  1082→    if (ui.buildSequenceBtn) {
  1083→  1083→        ui.buildSequenceBtn.addEventListener('click', buildSequence);
  1084→  1084→    }
  1085→  1085→
  1086→  1086→    // Copy YouTube timestamps
  1087→  1087→    if (ui.copyYouTubeBtn) {
  1088→  1088→        ui.copyYouTubeBtn.addEventListener('click', copyYouTubeTimestamps);
  1089→  1089→    }
  1090→  1090→
  1091→  1091→    // Add chapter markers
  1092→  1092→    if (ui.addChapterMarkersBtn) {
  1093→  1093→        ui.addChapterMarkersBtn.addEventListener('click', addChapterMarkers);
  1094→  1094→    }
  1095→  1095→
  1096→  1096→    // Apply zoom markers
  1097→  1097→    const applyZoomsBtn = document.getElementById('applyZoomsBtn');
  1098→  1098→    if (applyZoomsBtn) {
  1099→  1099→        applyZoomsBtn.addEventListener('click', applyZoomMarkers);
  1100→  1100→    }
  1101→  1101→}
  1102→  1102→
  1103→  1103→async function applyPreviewAndMarkers() {
  1104→  1104→    if (isOperationInProgress) return;
  1105→  1105→
  1106→  1106→    isOperationInProgress = true;
  1107→  1107→    setStatus('Adding markers...');
  1108→  1108→
  1109→  1109→    try {
  1110→  1110→        // Add silence markers
  1111→  1111→        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));
  1112→  1112→        for (const silence of selectedSilences) {
  1113→  1113→            await jsx.call('createMarker', silence.start, 'SPLICE: Silence', silence.end - silence.start, null, 1);
  1114→  1114→        }
  1115→  1115→
  1116→  1116→        // Add take markers
  1117→  1117→        for (const take of previewTakes) {
  1118→  1118→            await jsx.call('createMarker', take.start, take.label || `Take ${take.takeNumber}`, take.end - take.start, null, 5);
  1119→  1119→        }
  1120→  1120→
  1121→  1121→        setStatus(`Added ${selectedSilences.length + previewTakes.length} markers`);
  1122→  1122→    } catch (error) {
  1123→  1123→        setStatus('Failed to add markers: ' + error.message, true);
  1124→  1124→    } finally {
  1125→  1125→        isOperationInProgress = false;
  1126→  1126→    }
  1127→  1127→}
  1128→  1128→
  1129→  1129→function hidePreview() {
  1130→  1130→    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');
  1131→  1131→    if (ui.chapterResults) ui.chapterResults.classList.add('hidden');
  1132→  1132→    if (ui.zoomResults) ui.zoomResults.classList.add('hidden');
  1133→  1133→    if (ui.resultsEmpty) ui.resultsEmpty.classList.remove('hidden');
  1134→  1134→    previewSilences = [];
  1135→  1135→    previewTakes = [];
  1136→  1136→    selectedSilenceIndices.clear();
  1137→  1137→}
  1138→  1138→
  1139→  1139→async function buildSequence() {
  1140→  1140→    if (isOperationInProgress) return;
  1141→  1141→
  1142→  1142→    isOperationInProgress = true;
  1143→  1143→    setStatus('Building sequence...');
  1144→  1144→
  1145→  1145→    try {
  1146→  1146→        const settings = getSettings();
  1147→  1147→
  1148→  1148→        // Ensure we have sequence info
  1149→  1149→        if (!currentSequenceInfo) {
  1150→  1150→            currentSequenceInfo = await jsx.call('getActiveSequence');
  1151→  1151→        }
  1152→  1152→
  1153→  1153→        // Create cut list from selected silences
  1154→  1154→        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));
  1155→  1155→
  1156→  1156→        // Calculate total duration from sequence info or last silence
  1157→  1157→        let duration = 0;
  1158→  1158→        if (currentSequenceInfo && currentSequenceInfo.duration) {
  1159→  1159→            duration = currentSequenceInfo.duration;
  1160→  1160→        } else if (previewSilences.length > 0) {
  1161→  1161→            const lastSilence = previewSilences[previewSilences.length - 1];
  1162→  1162→            duration = lastSilence.end + 10; // Add buffer
  1163→  1163→        }
  1164→  1164→
  1165→  1165→        // Call backend to generate cut list
  1166→  1166→        const cutListResponse = await fetchWithTimeout(
  1167→  1167→            `${getBackendUrl()}/cut-list`,
  1168→  1168→            {
  1169→  1169→                method: 'POST',
  1170→  1170→                headers: getAuthHeaders(),
  1171→  1171→                body: JSON.stringify({
  1172→  1172→                    sourceName: currentSequenceInfo?.name || 'Untitled Sequence',
  1173→  1173→                    sourcePath: currentSequenceInfo?.treePath || currentSequenceInfo?.name || 'Untitled',
  1174→  1174→                    duration: duration,
  1175→  1175→                    silences: selectedSilences,
  1176→  1176→                    takes: previewTakes,
  1177→  1177→                    enableTakes: settings.enableTakesDetection,
  1178→  1178→                    jCutOffset: settings.enableJCut ? settings.jcutLeadIn : 0,
  1179→  1179→                    lCutOffset: settings.enableJCut ? settings.jcutLeadOut : 0
  1180→  1180→                })
  1181→  1181→            }
  1182→  1182→        );
  1183→  1183→
  1184→  1184→        if (!cutListResponse.ok) {
  1185→  1185→            throw new Error(await parseErrorResponse(cutListResponse));
  1186→  1186→        }
  1187→  1187→
  1188→  1188→        const cutList = await cutListResponse.json();
  1189→  1189→
  1190→  1190→        // Build sequence via JSX
  1191→  1191→        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));
  1192→  1192→
  1193→  1193→        if (result && result.success) {
  1194→  1194→            setStatus(`Built sequence: ${result.sequenceName}`);
  1195→  1195→            hidePreview();
  1196→  1196→        } else {
  1197→  1197→            throw new Error(result?.error || 'Build failed');
  1198→  1198→        }
  1199→  1199→    } catch (error) {
  1200→  1200→        setStatus('Build failed: ' + error.message, true);
  1201→  1201→    } finally {
  1202→  1202→        isOperationInProgress = false;
  1203→  1203→    }
  1204→  1204→}
  1205→  1205→
  1206→  1206→function copyYouTubeTimestamps() {
  1207→  1207→    if (currentChapters.length === 0) return;
  1208→  1208→
  1209→  1209→    const timestamps = currentChapters.map(ch =>
  1210→  1210→        `${formatTime(ch.startTime)} ${ch.title}`
  1211→  1211→    ).join('\n');
  1212→  1212→
  1213→  1213→    navigator.clipboard.writeText(timestamps).then(() => {
  1214→  1214→        setStatus('Copied YouTube timestamps');
  1215→  1215→    }).catch(() => {
  1216→  1216→        setStatus('Failed to copy', true);
  1217→  1217→    });
  1218→  1218→}
  1219→  1219→
  1220→  1220→async function addChapterMarkers() {
  1221→  1221→    if (isOperationInProgress || currentChapters.length === 0) return;
  1222→  1222→
  1223→  1223→    isOperationInProgress = true;
  1224→  1224→    setStatus('Adding chapter markers...');
  1225→  1225→
  1226→  1226→    try {
  1227→  1227→        for (const chapter of currentChapters) {
  1228→  1228→            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);
  1229→  1229→        }
  1230→  1230→        setStatus(`Added ${currentChapters.length} chapter markers`);
  1231→  1231→    } catch (error) {
  1232→  1232→        setStatus('Failed to add markers: ' + error.message, true);
  1233→  1233→    } finally {
  1234→  1234→        isOperationInProgress = false;
  1235→  1235→    }
  1236→  1236→}
  1237→  1237→
  1238→  1238→/**
  1239→  1239→ * Apply zoom point markers to the timeline
  1240→  1240→ */
  1241→  1241→async function applyZoomMarkers() {
  1242→  1242→    if (isOperationInProgress || currentZooms.length === 0) return;
  1243→  1243→
  1244→  1244→    isOperationInProgress = true;
  1245→  1245→    setStatus('Adding zoom markers...');
  1246→  1246→
  1247→  1247→    try {
  1248→  1248→        for (const zoom of currentZooms) {
  1249→  1249→            // Create a marker for each zoom point with zoom intensity info
  1250→  1250→            const comment = `Zoom ${zoom.intensity || 'medium'} - ${zoom.reason || 'emphasis'}`;
  1251→  1251→            await jsx.call('createMarker', zoom.time, 'SPLICE: Zoom', 0.5, comment, 3);
  1252→  1252→        }
  1253→  1253→        setStatus(`Added ${currentZooms.length} zoom markers`);
  1254→  1254→    } catch (error) {
  1255→  1255→        setStatus('Failed to add zoom markers: ' + error.message, true);
  1256→  1256→    } finally {
  1257→  1257→        isOperationInProgress = false;
  1258→  1258→    }
  1259→  1259→}
  1260→  1260→
  1261→  1261→// ============================================================================
  1262→  1262→// MODALS
  1263→  1263→// ============================================================================
  1264→  1264→function initModals() {
  1265→  1265→    // Settings modal
  1266→  1266→    if (ui.settingsBtn && ui.settingsModal) {
  1267→  1267→        ui.settingsBtn.addEventListener('click', () => {
  1268→  1268→            ui.settingsModal.classList.remove('hidden');
  1269→  1269→            // Sync remember options checkbox with current settings
  1270→  1270→            const rememberOptions = document.getElementById('rememberOptions');
  1271→  1271→            if (rememberOptions) {
  1272→  1272→                rememberOptions.checked = getSettings().rememberOptions;
  1273→  1273→            }
  1274→  1274→        });
  1275→  1275→    }
  1276→  1276→
  1277→  1277→    if (ui.closeSettingsBtn && ui.settingsModal) {
  1278→  1278→        ui.closeSettingsBtn.addEventListener('click', () => {
  1279→  1279→            ui.settingsModal.classList.add('hidden');
  1280→  1280→        });
  1281→  1281→    }
  1282→  1282→
  1283→  1283→    // Remember options checkbox
  1284→  1284→    const rememberOptions = document.getElementById('rememberOptions');
  1285→  1285→    if (rememberOptions) {
  1286→  1286→        rememberOptions.addEventListener('change', () => {
  1287→  1287→            saveSettings({ rememberOptions: rememberOptions.checked });
  1288→  1288→            if (rememberOptions.checked) {
  1289→  1289→                setStatus('Options will be remembered');
  1290→  1290→            } else {
  1291→  1291→                setStatus('Options will reset to defaults');
  1292→  1292→            }
  1293→  1293→        });
  1294→  1294→    }
  1295→  1295→
  1296→  1296→    // Credit badge click handler (handles login, retry, and refresh)
  1297→  1297→    if (ui.creditBadge) {
  1298→  1298→        ui.creditBadge.addEventListener('click', () => {
  1299→  1299→            // Use the centralized handler from credits.js
  1300→  1300→            if (typeof handleCreditBadgeClick === 'function') {
  1301→  1301→                handleCreditBadgeClick();
  1302→  1302→            } else {
  1303→  1303→                // Fallback if credits.js not loaded yet
  1304→  1304→                const settings = getSettings();
  1305→  1305→                if (!settings.customerId) {
  1306→  1306→                    showLoginModal();
  1307→  1307→                }
  1308→  1308→            }
  1309→  1309→        });
  1310→  1310→    }
  1311→  1311→
  1312→  1312→    if (ui.closeLoginBtn && ui.loginModal) {
  1313→  1313→        ui.closeLoginBtn.addEventListener('click', () => {
  1314→  1314→            ui.loginModal.classList.add('hidden');
  1315→  1315→        });
  1316→  1316→    }
  1317→  1317→
  1318→  1318→    if (ui.saveLoginBtn) {
  1319→  1319→        ui.saveLoginBtn.addEventListener('click', activateLicense);
  1320→  1320→    }
  1321→  1321→
  1322→  1322→    // License lookup button
  1323→  1323→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');
  1324→  1324→    if (lookupLicenseBtn) {
  1325→  1325→        lookupLicenseBtn.addEventListener('click', lookupLicense);
  1326→  1326→    }
  1327→  1327→
  1328→  1328→    // Close modals on backdrop click
  1329→  1329→    document.querySelectorAll('.modal').forEach(modal => {
  1330→  1330→        modal.addEventListener('click', (e) => {
  1331→  1331→            if (e.target === modal) {
  1332→  1332→                modal.classList.add('hidden');
  1333→  1333→            }
  1334→  1334→        });
  1335→  1335→    });
  1336→  1336→}
  1337→  1337→
  1338→  1338→function showLoginModal() {
  1339→  1339→    if (ui.loginModal) ui.loginModal.classList.remove('hidden');
  1340→  1340→}
  1341→  1341→
  1342→  1342→/**
  1343→  1343→ * Show upgrade modal when user tries to access a gated feature
  1344→  1344→ * @param {string} featureName - Display name of the feature
  1345→  1345→ * @param {string} requiredTier - Required tier (Pro, Team)
  1346→  1346→ */
  1347→  1347→function showUpgradeModal(featureName, requiredTier = 'Pro') {
  1348→  1348→    const modal = document.getElementById('upgradeModal');
  1349→  1349→    const featureText = document.getElementById('upgradeFeatureName');
  1350→  1350→    const tierText = document.getElementById('upgradeRequiredTier');
  1351→  1351→
  1352→  1352→    if (featureText) {
  1353→  1353→        featureText.textContent = featureName;
  1354→  1354→    }
  1355→  1355→    if (tierText) {
  1356→  1356→        tierText.textContent = requiredTier;
  1357→  1357→    }
  1358→  1358→    if (modal) {
  1359→  1359→        modal.classList.remove('hidden');
  1360→  1360→    }
  1361→  1361→}
  1362→  1362→
  1363→  1363→/**
  1364→  1364→ * Close the upgrade modal
  1365→  1365→ */
  1366→  1366→function closeUpgradeModal() {
  1367→  1367→    const modal = document.getElementById('upgradeModal');
  1368→  1368→    if (modal) {
  1369→  1369→        modal.classList.add('hidden');
  1370→  1370→    }
  1371→  1371→}
  1372→  1372→
  1373→  1373→// Expose showUpgradeModal and closeUpgradeModal globally for feature modules
  1374→  1374→window.showUpgradeModal = showUpgradeModal;
  1375→  1375→window.closeUpgradeModal = closeUpgradeModal;
  1376→  1376→
  1377→  1377→async function activateLicense() {
  1378→  1378→    if (!ui.licenseKeyInput) return;
  1379→  1379→
  1380→  1380→    const licenseKey = ui.licenseKeyInput.value.trim();
  1381→  1381→    if (!licenseKey) {
  1382→  1382→        setStatus('Please enter a license key', true);
  1383→  1383→        return;
  1384→  1384→    }
  1385→  1385→
  1386→  1386→    try {
  1387→  1387→        const response = await fetchWithTimeout(
  1388→  1388→            `${getBackendUrl()}/license/activate`,
  1389→  1389→            {
  1390→  1390→                method: 'POST',
  1391→  1391→                headers: { 'Content-Type': 'application/json' },
  1392→  1392→                body: JSON.stringify({ key: licenseKey })
  1393→  1393→            }
  1394→  1394→        );
  1395→  1395→
  1396→  1396→        if (!response.ok) {
  1397→  1397→            throw new Error(await parseErrorResponse(response));
  1398→  1398→        }
  1399→  1399→
  1400→  1400→        const data = await response.json();
  1401→  1401→        saveSettings({
  1402→  1402→            customerId: data.customerId,
  1403→  1403→            licenseKey: licenseKey
  1404→  1404→        });
  1405→  1405→
  1406→  1406→        if (ui.loginModal) ui.loginModal.classList.add('hidden');
  1407→  1407→        setStatus('License activated');
  1408→  1408→        updateCredits();
  1409→  1409→    } catch (error) {
  1410→  1410→        setStatus('Activation failed: ' + error.message, true);
  1411→  1411→    }
  1412→  1412→}
  1413→  1413→
  1414→  1414→/**
  1415→  1415→ * Look up license key by email address
  1416→  1416→ */
  1417→  1417→async function lookupLicense() {
  1418→  1418→    const lookupEmailInput = document.getElementById('lookupEmailInput');
  1419→  1419→    const licenseKeyInput = document.getElementById('licenseKeyInput');
  1420→  1420→
  1421→  1421→    if (!lookupEmailInput) return;
  1422→  1422→
  1423→  1423→    const email = lookupEmailInput.value.trim().toLowerCase();
  1424→  1424→    if (!email) {
  1425→  1425→        setStatus('Please enter your email address', true);
  1426→  1426→        return;
  1427→  1427→    }
  1428→  1428→
  1429→  1429→    // Basic email validation
  1430→  1430→    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  1431→  1431→    if (!emailRegex.test(email)) {
  1432→  1432→        setStatus('Please enter a valid email address', true);
  1433→  1433→        return;
  1434→  1434→    }
  1435→  1435→
  1436→  1436→    const lookupBtn = document.getElementById('lookupLicenseBtn');
  1437→  1437→    if (lookupBtn) {
  1438→  1438→        lookupBtn.disabled = true;
  1439→  1439→        lookupBtn.textContent = 'Looking up...';
  1440→  1440→    }
  1441→  1441→
  1442→  1442→    try {
  1443→  1443→        const response = await fetchWithTimeout(
  1444→  1444→            `${getBackendUrl()}/license/lookup`,
  1445→  1445→            {
  1446→  1446→                method: 'POST',
  1447→  1447→                headers: { 'Content-Type': 'application/json' },
  1448→  1448→                body: JSON.stringify({ email })
  1449→  1449→            },
  1450→  1450→            30000
  1451→  1451→        );
  1452→  1452→
  1453→  1453→        const result = await response.json();
  1454→  1454→
  1455→  1455→        // Note: For security, the backend does NOT return the license key directly.
  1456→  1456→        // It sends the key via email to prevent enumeration attacks.
  1457→  1457→        if (result.success) {
  1458→  1458→            setStatus(result.message || 'If a license exists, it has been sent to your email.');
  1459→  1459→        } else {
  1460→  1460→            setStatus(result.error || 'Lookup failed. Please try again.', true);
  1461→  1461→        }
  1462→  1462→    } catch (error) {
  1463→  1463→        setStatus('Lookup failed: ' + error.message, true);
  1464→  1464→    } finally {
  1465→  1465→        if (lookupBtn) {
  1466→  1466→            lookupBtn.disabled = false;
  1467→  1467→            lookupBtn.textContent = 'Lookup';
  1468→  1468→        }
  1469→  1469→    }
  1470→  1470→}
  1471→  1471→
  1472→  1472→// ============================================================================
  1473→  1473→// CREDITS
  1474→  1474→// ============================================================================
  1475→  1475→function initCredits() {
  1476→  1476→    updateCredits();
  1477→  1477→}
  1478→  1478→
  1479→  1479→async function updateCredits() {
  1480→  1480→    if (!ui.creditBadge) return;
  1481→  1481→
  1482→  1482→    const settings = getSettings();
  1483→  1483→    if (!settings.customerId) {
  1484→  1484→        ui.creditBadge.className = 'credit-badge login';
  1485→  1485→        ui.creditBadge.textContent = 'Login';
  1486→  1486→        ui.creditBadge.style.display = 'flex';
  1487→  1487→        return;
  1488→  1488→    }
  1489→  1489→
  1490→  1490→    try {
  1491→  1491→        const response = await fetchWithTimeout(
  1492→  1492→            `${getBackendUrl()}/credits`,
  1493→  1493→            {
  1494→  1494→                method: 'GET',
  1495→  1495→                headers: getAuthHeaders()
  1496→  1496→            }
  1497→  1497→        );
  1498→  1498→
  1499→  1499→        if (response.ok) {
  1500→  1500→            const data = await response.json();
  1501→  1501→            // Backend returns hoursRemaining (not remainingMinutes)
  1502→  1502→            const hours = (data.hoursRemaining || 0).toFixed(1);
  1503→  1503→            ui.creditBadge.textContent = `${hours}h`;
  1504→  1504→            // Low warning when less than 1 hour remaining
  1505→  1505→            ui.creditBadge.className = data.hoursRemaining < 1 ? 'credit-badge low' : 'credit-badge ok';
  1506→  1506→            ui.creditBadge.style.display = 'flex';
  1507→  1507→        } else {
  1508→  1508→            ui.creditBadge.className = 'credit-badge error';
  1509→  1509→            ui.creditBadge.textContent = 'Error';
  1510→  1510→            ui.creditBadge.style.display = 'flex';
  1511→  1511→        }
  1512→  1512→    } catch {
  1513→  1513→        ui.creditBadge.className = 'credit-badge error';
  1514→  1514→        ui.creditBadge.textContent = 'Offline';
  1515→  1515→        ui.creditBadge.style.display = 'flex';
  1516→  1516→    }
  1517→  1517→}
  1518→  1518→
  1519→  1519→// ============================================================================
  1520→  1520→// HELP BUTTON
  1521→  1521→// ============================================================================
  1522→  1522→function initHelpButton() {
  1523→  1523→    const helpBtn = document.getElementById('helpBtn');
  1524→  1524→    if (helpBtn) {
  1525→  1525→        helpBtn.addEventListener('click', () => {
  1526→  1526→            setStatus('Silence: removes quiet gaps | Takes: detects repeated content | Chapters: AI topic segmentation');
  1527→  1527→        });
  1528→  1528→    }
  1529→  1529→}
  1530→  1530→
  1531→  1531→// Export for debugging
  1532→  1532→window.spliceDebug = {
  1533→  1533→    getState: () => ({
  1534→  1534→        silences: previewSilences,
  1535→  1535→        takes: previewTakes,
  1536→  1536→        chapters: currentChapters,
  1537→  1537→        zooms: currentZooms,
  1538→  1538→        selected: Array.from(selectedSilenceIndices)
  1539→  1539→    }),
  1540→  1540→    jsx,
  1541→  1541→    runDetection
  1542→  1542→};
  1543→  1543→
  1544→
  1545→</system-reminder>
  1546→

</system-reminder>
