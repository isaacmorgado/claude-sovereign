     1→/**
     2→ * SPLICE Backend Server
     3→ *
     4→ * Main entry point for the SPLICE backend API.
     5→ * Orchestrates the audio analysis pipeline.
     6→ *
     7→ * Slices:
     8→ * - Slice 4: Transcription (services/transcription.js)
     9→ * - Slice 5: Take Detection (services/takeDetection.js)
    10→ *
    11→ * Architecture: Modular routes (see routes/ directory)
    12→ */
    13→
    14→
    15→require('dotenv').config();
    16→
    17→const express = require('express');
    18→const cors = require('cors');
    19→const helmet = require('helmet');
    20→const cookieParser = require('cookie-parser');
    21→const fs = require('fs');
    22→const https = require('https');
    23→const http = require('http');
    24→const path = require('path');
    25→const crypto = require('crypto');
    26→
    27→// MEDIUM-005: Request ID Tracing Middleware
    28→const { requestIdMiddleware } = require('./middleware/requestId');
    29→
    30→// HIGH-008: Sentry Error Monitoring Integration
    31→let Sentry = null;
    32→if (process.env.SENTRY_DSN) {
    33→  try {
    34→    Sentry = require('@sentry/node');
    35→    console.log('[SPLICE] Sentry module loaded, will initialize after app creation');
    36→  } catch (_err) {
    37→    console.warn('[SPLICE] @sentry/node not installed. Run: npm install @sentry/node');
    38→  }
    39→}
    40→
    41→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)
    42→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;
    43→
    44→// Import services
    45→const usageTracking = require('./services/usageTracking');
    46→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');
    47→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');
    48→const referralService = require('./services/referralService');
    49→const licenseService = require('./services/licenseService');
    50→const emailService = require('./services/emailService');
    51→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');
    52→const { getSupportedFormats } = require('./services/captionExporter');
    53→
    54→// Import route modules
    55→const healthRoutes = require('./routes/health');
    56→const analyzeRoutes = require('./routes/analyze');
    57→const silencesRoutes = require('./routes/silences');
    58→const detectionRoutes = require('./routes/detection');
    59→const exportRoutes = require('./routes/export');
    60→const multitrackRoutes = require('./routes/multitrack');
    61→const cutListRoutes = require('./routes/cutList');
    62→const zoomRoutes = require('./routes/zoom');
    63→const chaptersRoutes = require('./routes/chapters');
    64→const youtubeRoutes = require('./routes/youtube');
    65→const captionsRoutes = require('./routes/captions');
    66→const textEditRoutes = require('./routes/textEdit');
    67→const reframeRoutes = require('./routes/reframe');
    68→const batchRoutes = require('./routes/batch');
    69→const authRoutes = require('./routes/auth');
    70→const billingRoutes = require('./routes/billing');
    71→const referralRoutes = require('./routes/referral');
    72→const licenseRoutes = require('./routes/license');
    73→const musicRoutes = require('./routes/music');
    74→
    75→// Music generation worker (BullMQ background processor)
    76→const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');
    77→
    78→// HIGH-011: API Versioning - v1 routes
    79→const v1Routes = require('./routes/v1');
    80→
    81→// Stripe for webhooks
    82→const Stripe = require('stripe');
    83→
    84→// MEDIUM-008: Pin Stripe API version for stability
    85→// This prevents breaking changes when Stripe releases new API versions
    86→// Should match version in services/stripeUsageReporting.js
    87→const STRIPE_API_VERSION = '2024-12-18.acacia';
    88→
    89→// =============================================================================
    90→// SECURITY: Environment Variable Validation
    91→// Validate all required environment variables at startup
    92→// Fail fast with clear error messages if critical secrets are missing
    93→// =============================================================================
    94→
    95→/**
    96→ * Validate required environment variables
    97→ * @returns {Object} { valid: boolean, errors: string[] }
    98→ */
    99→function validateEnvironmentVariables() {
   100→  const errors = [];
   101→  
   102→  // CRITICAL: Core infrastructure secrets
   103→  if (!process.env.STRIPE_SECRET_KEY) {
   104→    errors.push('STRIPE_SECRET_KEY is required (Stripe API key for billing)');
   105→  }
   106→  
   107→  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production') {
   108→    errors.push('JWT_SECRET must be set to a secure random value (not default)');
   109→  } else if (process.env.JWT_SECRET.length < 32) {
   110→    // HIGH-001: Enforce minimum 32 character length for cryptographic security
   111→    errors.push('JWT_SECRET must be at least 32 characters for cryptographic security');
   112→  }
   113→  
   114→  if (!process.env.DATABASE_URL) {
   115→    errors.push('DATABASE_URL is required (PostgreSQL connection string)');
   116→  }
   117→  
   118→  if (!process.env.OPENAI_API_KEY) {
   119→    errors.push('OPENAI_API_KEY is required (OpenAI API for transcription)');
   120→  }
   121→  
   122→  // CRITICAL: Redis required for job queue and rate limiting in production
   123→  // Support both Railway Redis (REDIS_URL) and Upstash (UPSTASH_REDIS_URL)
   124→  // In development, will fall back to in-memory storage
   125→  if (process.env.NODE_ENV === 'production' && !process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {
   126→    errors.push('REDIS_URL or UPSTASH_REDIS_URL is required (Redis for job queue and rate limiting)');
   127→  } else if (!process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {
   128→    console.warn('[SPLICE] WARNING: Redis not configured. Using in-memory fallback (not suitable for production).');
   129→  }
   130→  
   131→  // CRITICAL: Webhook secret required in production
   132→  if (!process.env.STRIPE_WEBHOOK_SECRET) {
   133→    errors.push('STRIPE_WEBHOOK_SECRET is required (Stripe webhook signature verification)');
   134→  }
   135→  
   136→  // CONDITIONAL: Email provider validation
   137→  const emailProvider = process.env.EMAIL_PROVIDER || 'sendgrid';
   138→  if (emailProvider === 'sendgrid' && !process.env.SENDGRID_API_KEY) {
   139→    errors.push('SENDGRID_API_KEY is required when EMAIL_PROVIDER=sendgrid');
   140→  }
   141→  
   142→  // RECOMMENDED: R2 Storage (warn if missing, don't block)
   143→  if (!process.env.R2_ACCOUNT_ID || !process.env.R2_ACCESS_KEY_ID || !process.env.R2_SECRET_ACCESS_KEY) {
   144→    console.warn('[SPLICE] WARNING: R2 storage credentials not configured. Music generation uploads will fail.');
   145→  }
   146→  
   147→  return {
   148→    valid: errors.length === 0,
   149→    errors
   150→  };
   151→}
   152→
   153→// Run validation in production
   154→if (isProduction) {
   155→  const validation = validateEnvironmentVariables();
   156→  
   157→  if (!validation.valid) {
   158→    console.error('[SPLICE] ========================================');
   159→    console.error('[SPLICE] CRITICAL: Missing required environment variables');
   160→    console.error('[SPLICE] ========================================');
   161→    validation.errors.forEach(error => {
   162→      console.error(`[SPLICE]   ❌ ${error}`);
   163→    });
   164→    console.error('[SPLICE] ========================================');
   165→    console.error('[SPLICE] Server startup aborted. Please configure all required environment variables.');
   166→    console.error('[SPLICE] See .env.example for complete documentation.');
   167→    process.exit(1);
   168→  }
   169→  
   170→  console.log('[SPLICE] ✅ Environment validation passed');
   171→}
   172→
   173→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
   174→  apiVersion: STRIPE_API_VERSION
   175→});
   176→
   177→// =============================================================================
   178→// PERF-FIX: Static Response Cache
   179→// Cache static endpoint responses at startup to avoid repeated computation
   180→// =============================================================================
   181→
   182→// Generate ETag from content
   183→function generateETag(content) {
   184→  return `"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}"`;
   185→}
   186→
   187→// Static response cache - populated at startup
   188→const STATIC_RESPONSE_CACHE = {
   189→  profanityLanguages: null,
   190→  profanityBleeps: null,
   191→  exportFormats: null
   192→};
   193→
   194→// Initialize cache at startup (called after server starts)
   195→function initializeStaticCache() {
   196→  // Cache profanity languages
   197→  const languages = getSupportedLanguages();
   198→  STATIC_RESPONSE_CACHE.profanityLanguages = {
   199→    body: { success: true, languages },
   200→    etag: generateETag({ languages })
   201→  };
   202→
   203→  // Cache profanity bleeps
   204→  const sounds = getAvailableBleepSounds();
   205→  STATIC_RESPONSE_CACHE.profanityBleeps = {
   206→    body: { success: true, sounds },
   207→    etag: generateETag({ sounds })
   208→  };
   209→
   210→  // Cache export formats
   211→  const formats = getSupportedFormats();
   212→  STATIC_RESPONSE_CACHE.exportFormats = {
   213→    body: { success: true, formats },
   214→    etag: generateETag({ formats })
   215→  };
   216→
   217→  console.log('[SPLICE] Static response cache initialized');
   218→}
   219→
   220→// Helper to send cached response with ETag
   221→function sendCachedResponse(req, res, cacheKey) {
   222→  const cached = STATIC_RESPONSE_CACHE[cacheKey];
   223→  if (!cached) {
   224→    return res.status(500).json({ error: 'Cache not initialized' });
   225→  }
   226→
   227→  // Check If-None-Match header for conditional GET
   228→  const clientETag = req.headers['if-none-match'];
   229→  if (clientETag === cached.etag) {
   230→    return res.status(304).end(); // Not Modified
   231→  }
   232→
   233→  // Send cached response with ETag and cache headers
   234→  res.set('ETag', cached.etag);
   235→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours
   236→  res.json(cached.body);
   237→}
   238→
   239→// =============================================================================
   240→// Server Configuration
   241→// =============================================================================
   242→
   243→const app = express();
   244→const PORT = process.env.PORT || 3847;
   245→
   246→// HIGH-008: Initialize Sentry after app creation
   247→if (Sentry && process.env.SENTRY_DSN) {
   248→  Sentry.init({
   249→    dsn: process.env.SENTRY_DSN,
   250→    environment: process.env.NODE_ENV || 'development',
   251→    release: process.env.npm_package_version || '6.0.3',
   252→    tracesSampleRate: isProduction ? 0.1 : 1.0, // 10% in prod, 100% in dev
   253→    profilesSampleRate: isProduction ? 0.1 : 0, // Profile only in production
   254→    integrations: [
   255→      // Automatically instrument HTTP requests
   256→      Sentry.httpIntegration({ tracing: true }),
   257→      // Automatically instrument Express
   258→      Sentry.expressIntegration({ app }),
   259→    ],
   260→    // Filter out sensitive data
   261→    beforeSend(event) {
   262→      // Remove sensitive headers
   263→      if (event.request && event.request.headers) {
   264→        delete event.request.headers.authorization;
   265→        delete event.request.headers['x-stripe-customer-id'];
   266→        delete event.request.headers['stripe-signature'];
   267→      }
   268→      return event;
   269→    },
   270→  });
   271→  
   272→  // Add Sentry request handler as first middleware
   273→  app.use(Sentry.Handlers.requestHandler());
   274→  app.use(Sentry.Handlers.tracingHandler());
   275→  
   276→  console.log('[SPLICE] ✅ Sentry error monitoring initialized');
   277→}
   278→
   279→// MEDIUM-005: Request ID Tracing Middleware
   280→// Add early in chain to ensure all requests have correlation IDs for logging
   281→app.use(requestIdMiddleware);
   282→
   283→// HTTPS certificates (generated by mkcert) - only for local development
   284→let httpsOptions = null;
   285→if (!isProduction) {
   286→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');
   287→  const certPath = path.join(__dirname, 'localhost+1.pem');
   288→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
   289→    httpsOptions = {
   290→      key: fs.readFileSync(keyPath),
   291→      cert: fs.readFileSync(certPath)
   292→    };
   293→  }
   294→}
   295→
   296→// =============================================================================
   297→// Security Configuration
   298→// =============================================================================
   299→
   300→// CORS whitelist - restrict origins in production
   301→const CORS_WHITELIST = [
   302→  'http://localhost:3000',
   303→  'http://localhost:3847',
   304→  'https://localhost:3847',
   305→  'http://127.0.0.1:3000',
   306→  'http://127.0.0.1:3847',
   307→  'https://127.0.0.1:3847',
   308→  'https://splice.app',
   309→  'https://www.splice.app',
   310→  'https://spliceclips.com',
   311→  'https://www.spliceclips.com',
   312→  'https://splice-api-production.up.railway.app',
   313→  'https://splice-website.vercel.app',
   314→  // Adobe CEP/UXP panels run from file:// or bolt://
   315→  'file://',
   316→  'bolt://'
   317→];
   318→
   319→const corsOptions = {
   320→  origin: function (origin, callback) {
   321→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)
   322→    if (!origin) {
   323→      return callback(null, true);
   324→    }
   325→    // Check if origin is in whitelist
   326→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {
   327→      return callback(null, true);
   328→    }
   329→    // In development, allow all origins with warning
   330→    if (!isProduction) {
   331→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);
   332→      return callback(null, true);
   333→    }
   334→    // In production, reject non-whitelisted origins
   335→    console.error(`[CORS] Blocked request from: ${origin}`);
   336→    return callback(new Error('Not allowed by CORS'));
   337→  },
   338→  credentials: true,
   339→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
   340→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']
   341→};
   342→
   343→app.use(cors(corsOptions));
   344→
   345→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers
   346→// This ensures rate limiting and logging use the correct client IP
   347→if (isProduction) {
   348→  app.set('trust proxy', 1);
   349→}
   350→
   351→// IP-based rate limiting (100 requests/minute per IP)
   352→app.use(ipRateLimit);
   353→
   354→// Security headers via helmet
   355→app.use(helmet({
   356→  contentSecurityPolicy: {
   357→    directives: {
   358→      defaultSrc: ["'self'"],
   359→      scriptSrc: ["'self'"],
   360→      styleSrc: ["'self'", "'unsafe-inline'"],
   361→      imgSrc: ["'self'", 'data:', 'https:'],
   362→      connectSrc: ["'self'", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],
   363→      fontSrc: ["'self'"],
   364→      objectSrc: ["'none'"],
   365→      mediaSrc: ["'self'"],
   366→      frameSrc: ["'none'"]
   367→    }
   368→  },
   369→  hsts: {
   370→    maxAge: 31536000,
   371→    includeSubDomains: true,
   372→    preload: true
   373→  },
   374→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
   375→  noSniff: true,
   376→  xssFilter: true,
   377→  hidePoweredBy: true
   378→}));
   379→
   380→// Helper to determine tier from price ID with logging
   381→// Supports both monthly and annual pricing
   382→function getTierFromPriceId(priceId) {
   383→  // Monthly prices
   384→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';
   385→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';
   386→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';
   387→
   388→  // Annual prices (same tier, just different billing period)
   389→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';
   390→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';
   391→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';
   392→
   393→  // Log unknown price ID for debugging
   394→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);
   395→  return 'starter';
   396→}
   397→
   398→// =============================================================================
   399→// Stripe Webhook (must be before express.json())
   400→// =============================================================================
   401→
   402→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
   403→  const sig = req.headers['stripe-signature'];
   404→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
   405→
   406→  let event;
   407→
   408→  try {
   409→    if (webhookSecret) {
   410→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
   411→    } else if (isProduction) {
   412→      // SECURITY: Reject unsigned webhooks in production
   413→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');
   414→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });
   415→    } else {
   416→      // For local development testing only
   417→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse
   418→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');
   419→      event = JSON.parse(bodyString);
   420→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');
   421→    }
   422→  } catch (err) {
   423→    console.error('[SPLICE] Webhook signature verification failed:', err.message);
   424→    return res.status(400).json({ error: 'Webhook signature verification failed' });
   425→  }
   426→
   427→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);
   428→
   429→  // Idempotency check - skip if already processed
   430→  if (await usageTracking.isEventProcessed(event.id)) {
   431→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);
   432→    return res.json({ received: true, skipped: true });
   433→  }
   434→
   435→  try {
   436→    switch (event.type) {
   437→      case 'customer.subscription.created':
   438→      case 'customer.subscription.updated': {
   439→        const subscription = event.data.object;
   440→        const customerId = subscription.customer;
   441→
   442→        // Validate customerId
   443→        if (!customerId) {
   444→          console.error('[SPLICE] Missing customer ID in subscription event');
   445→          return res.status(400).json({ error: 'Missing customer ID' });
   446→        }
   447→
   448→        // Get tier from price ID
   449→        const priceId = subscription.items?.data?.[0]?.price?.id;
   450→        const tier = getTierFromPriceId(priceId);
   451→
   452→        // Update user tier and reset hours
   453→        await usageTracking.updateTier(customerId, tier);
   454→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);
   455→
   456→        // Initialize music credits for new subscriptions
   457→        if (event.type === 'customer.subscription.created') {
   458→          await usageTracking.resetMusicCredits(customerId, tier);
   459→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);
   460→        }
   461→
   462→        // Update trial end date if present
   463→        if (subscription.trial_end) {
   464→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);
   465→        }
   466→
   467→        // Generate license key for new subscriptions with retry and delivery
   468→        if (event.type === 'customer.subscription.created') {
   469→          let licenseResult = null;
   470→          let retryCount = 0;
   471→          const maxRetries = 3;
   472→
   473→          // Retry mechanism for license key generation
   474→          while (retryCount < maxRetries) {
   475→            licenseResult = await licenseService.generateLicenseKey(customerId);
   476→            if (licenseResult.success) {
   477→              break;
   478→            }
   479→            retryCount++;
   480→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);
   481→            // Wait before retry (exponential backoff)
   482→            if (retryCount < maxRetries) {
   483→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
   484→            }
   485→          }
   486→
   487→          if (licenseResult && licenseResult.success) {
   488→            // SECURITY: Mask license key in logs
   489→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);
   490→
   491→            // Store license key in Stripe subscription metadata as backup
   492→            try {
   493→              await stripe.subscriptions.update(subscription.id, {
   494→                metadata: {
   495→                  license_key: licenseResult.key,
   496→                  license_generated_at: new Date().toISOString()
   497→                }
   498→              });
   499→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);
   500→            } catch (stripeErr) {
   501→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);
   502→            }
   503→
   504→            // Get customer email and send license key
   505→            try {
   506→              const customer = await stripe.customers.retrieve(customerId);
   507→              if (customer.email) {
   508→                // SECURITY: Mask sensitive data in logs
   509→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);
   510→
   511→                // Send license key email
   512→                try {
   513→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);
   514→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);
   515→                } catch (sendErr) {
   516→                  // Log but don't fail - license is stored in Stripe metadata as backup
   517→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);
   518→                }
   519→
   520→                // Store email in database for reference
   521→                await usageTracking.updateTier(customerId, tier, customer.email);
   522→              } else {
   523→                console.warn(`[SPLICE] No email found for customer ${customerId}`);
   524→              }
   525→            } catch (emailErr) {
   526→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);
   527→            }
   528→          } else {
   529→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry
   530→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;
   531→            console.error(`[SPLICE] ${errorMsg}`);
   532→            return res.status(500).json({ error: errorMsg });
   533→          }
   534→        }
   535→        break;
   536→      }
   537→
   538→      case 'customer.subscription.deleted': {
   539→        const subscription = event.data.object;
   540→        const customerId = subscription.customer;
   541→
   542→        // Validate customerId
   543→        if (!customerId) {
   544→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');
   545→          return res.status(400).json({ error: 'Missing customer ID' });
   546→        }
   547→
   548→        // Downgrade to cancelled (0 hours)
   549→        await usageTracking.updateTier(customerId, 'cancelled');
   550→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);
   551→        break;
   552→      }
   553→
   554→      case 'invoice.payment_succeeded': {
   555→        const invoice = event.data.object;
   556→        const customerId = invoice.customer;
   557→        const subscriptionId = invoice.subscription;
   558→
   559→        // Validate customerId
   560→        if (!customerId) {
   561→          console.error('[SPLICE] Missing customer ID in invoice event');
   562→          return res.status(400).json({ error: 'Missing customer ID' });
   563→        }
   564→
   565→        // Reset hours on successful payment (new billing period)
   566→        let tier = 'starter';
   567→        if (subscriptionId) {
   568→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);
   569→          const priceId = subscription.items?.data?.[0]?.price?.id;
   570→          tier = getTierFromPriceId(priceId);
   571→
   572→          await usageTracking.resetHours(customerId, tier);
   573→          await usageTracking.resetMusicCredits(customerId, tier);
   574→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);
   575→        }
   576→
   577→        // Check for affiliate coupon and record commission
   578→        const discount = invoice.discount;
   579→        if (discount && discount.coupon) {
   580→          const couponId = discount.coupon.id;
   581→          // Check if this is an affiliate code (like JIMMYN)
   582→          if (referralService.AFFILIATE_CODES[couponId]) {
   583→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars
   584→            await referralService.recordAffiliateCommission(
   585→              couponId,
   586→              customerId,
   587→              amountPaid,
   588→              tier
   589→            );
   590→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);
   591→          }
   592→        }
   593→        break;
   594→      }
   595→
   596→      case 'invoice.payment_failed': {
   597→        const invoice = event.data.object;
   598→        const customerId = invoice.customer;
   599→        const attemptCount = invoice.attempt_count || 1;
   600→
   601→        // Validate customerId
   602→        if (!customerId) {
   603→          console.error('[SPLICE] Missing customer ID in payment_failed event');
   604→          return res.status(400).json({ error: 'Missing customer ID' });
   605→        }
   606→
   607→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);
   608→
   609→        // Stripe will retry automatically per retry settings
   610→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted
   611→        // Send warning email on final attempt
   612→        if (attemptCount >= 3) {
   613→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);
   614→          // Send warning email to customer about impending cancellation
   615→          try {
   616→            const customer = await stripe.customers.retrieve(customerId);
   617→            if (customer.email) {
   618→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);
   619→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);
   620→            }
   621→          } catch (emailErr) {
   622→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);
   623→          }
   624→        }
   625→        break;
   626→      }
   627→
   628→      case 'customer.deleted': {
   629→        const customer = event.data.object;
   630→        const customerId = customer.id;
   631→
   632→        // Validate customerId
   633→        if (!customerId) {
   634→          console.error('[SPLICE] Missing customer ID in customer.deleted event');
   635→          return res.status(400).json({ error: 'Missing customer ID' });
   636→        }
   637→
   638→        // Clean up user data - downgrade to cancelled
   639→        await usageTracking.updateTier(customerId, 'cancelled');
   640→        console.log(`[SPLICE] Customer deleted: ${customerId}`);
   641→        break;
   642→      }
   643→
   644→      default:
   645→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);
   646→    }
   647→
   648→    // Record event as processed (idempotency)
   649→    await usageTracking.recordWebhookEvent(event.id, event.type);
   650→
   651→    res.json({ received: true });
   652→  } catch (err) {
   653→    console.error('[SPLICE] Webhook handler error:', err);
   654→    res.status(500).json({ error: err.message });
   655→  }
   656→});
   657→
   658→// Parse JSON body for all other routes
   659→// SECURITY: Limit JSON body size to prevent DoS attacks
   660→app.use(express.json({ limit: '10mb' }));
   661→
   662→// Parse cookies for CSRF token validation
   663→app.use(cookieParser());
   664→
   665→// =============================================================================
   666→// Route Configuration Options
   667→// =============================================================================
   668→
   669→const routeOptions = {
   670→  middleware: {
   671→    requireCredits,
   672→    requireFeature,
   673→    authenticateToken
   674→  },
   675→  services: {
   676→    usageTracking,
   677→    referralService,
   678→    licenseService,
   679→    emailService,
   680→    stripe
   681→  },
   682→  authHelpers: {
   683→    generateToken,
   684→    generateRefreshToken,
   685→    verifyToken,
   686→    maskSensitiveData,
   687→    blacklistToken
   688→  },
   689→  staticCache: STATIC_RESPONSE_CACHE,
   690→  sendCachedResponse
   691→};
   692→
   693→// =============================================================================
   694→// Mount Routes
   695→// =============================================================================
   696→
   697→// Health check and system endpoints (no prefix)
   698→app.use('/', healthRoutes(routeOptions));
   699→
   700→// Core analysis endpoints
   701→app.use('/', analyzeRoutes(routeOptions));
   702→app.use('/', silencesRoutes(routeOptions));
   703→app.use('/', detectionRoutes(routeOptions));
   704→
   705→// Export endpoints
   706→app.use('/export', exportRoutes(routeOptions));
   707→
   708→// Multitrack/Multicam endpoints
   709→app.use('/multitrack', multitrackRoutes(routeOptions));
   710→
   711→// Cut list generation
   712→app.use('/cut-list', cutListRoutes(routeOptions));
   713→
   714→// Legacy XML processing endpoint (backwards compatibility)
   715→const { processXMLFile } = require('./services/xmlProcessor');
   716→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {
   717→  const {
   718→    xmlPath,
   719→    silences,
   720→    removeGaps = true,
   721→    outputPath = null
   722→  } = req.body;
   723→
   724→  if (!xmlPath) {
   725→    return res.status(400).json({ error: 'xmlPath is required' });
   726→  }
   727→
   728→  if (!silences || !Array.isArray(silences)) {
   729→    return res.status(400).json({ error: 'silences array is required' });
   730→  }
   731→
   732→  if (!fs.existsSync(xmlPath)) {
   733→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });
   734→  }
   735→
   736→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);
   737→
   738→  try {
   739→    const result = await processXMLFile(xmlPath, silences, {
   740→      outputPath,
   741→      removeGaps
   742→    });
   743→
   744→    res.json({
   745→      success: true,
   746→      inputPath: xmlPath,
   747→      outputPath: result.outputPath,
   748→      stats: result.stats
   749→    });
   750→  } catch (err) {
   751→    console.error('[SPLICE] XML processing error:', err);
   752→    res.status(500).json({ error: err.message });
   753→  }
   754→});
   755→
   756→// Auto zoom endpoints
   757→app.use('/zoom', zoomRoutes(routeOptions));
   758→
   759→// Chapter detection endpoints
   760→app.use('/chapters', chaptersRoutes(routeOptions));
   761→
   762→// YouTube content generation
   763→app.use('/youtube', youtubeRoutes(routeOptions));
   764→
   765→// Animated captions endpoints
   766→app.use('/captions', captionsRoutes(routeOptions));
   767→
   768→// Text-based editing endpoints
   769→app.use('/text-edit', textEditRoutes(routeOptions));
   770→
   771→// Social reframe endpoints
   772→app.use('/reframe', reframeRoutes(routeOptions));
   773→app.use('/faces', reframeRoutes.facesRouter(routeOptions));
   774→
   775→// Batch processing endpoints
   776→app.use('/batch', batchRoutes(routeOptions));
   777→
   778→// Authentication endpoints
   779→app.use('/auth', authRoutes(routeOptions));
   780→
   781→// Billing and credits endpoints
   782→app.use('/', billingRoutes(routeOptions));
   783→
   784→// Referral system endpoints
   785→app.use('/referral', referralRoutes(routeOptions));
   786→
   787→// License key endpoints
   788→app.use('/license', licenseRoutes(routeOptions));
   789→
   790→// AI Music generation endpoints
   791→app.use('/music', musicRoutes(routeOptions));
   792→
   793→// =============================================================================
   794→// HIGH-011: API Versioning
   795→// Mount versioned routes under /api/v1 prefix
   796→// Maintain backwards compatibility with deprecation warnings
   797→// =============================================================================
   798→
   799→// Mount v1 API routes
   800→app.use('/api/v1', v1Routes(routeOptions));
   801→
   802→// Deprecation warning middleware for unversioned API calls
   803→// This helps clients migrate to versioned endpoints
   804→app.use('/api', (req, res, next) => {
   805→  // Skip if already using versioned endpoint
   806→  if (req.path.startsWith('/v1')) {
   807→    return next();
   808→  }
   809→  
   810→  // Add deprecation warning header
   811→  res.set('X-API-Deprecation-Warning', 'Unversioned API endpoints are deprecated. Please migrate to /api/v1/');
   812→  res.set('X-API-Version', 'unversioned');
   813→  res.set('Deprecation', 'true');
   814→  res.set('Sunset', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toUTCString()); // 90 days from now
   815→  
   816→  next();
   817→});
   818→
   819→// HIGH-008: Add Sentry error handler (must be after all routes)
   820→if (Sentry) {
   821→  app.use(Sentry.Handlers.errorHandler({
   822→    shouldHandleError(error) {
   823→      // Capture all 4xx and 5xx errors
   824→      if (error.status >= 400) {
   825→        return true;
   826→      }
   827→      return true;
   828→    },
   829→  }));
   830→}
   831→
   832→// =============================================================================
   833→// Start Server
   834→// =============================================================================
   835→
   836→// Track active server for graceful shutdown
   837→let server = null;
   838→
   839→// Initialize database and start server
   840→async function startServer() {
   841→  try {
   842→    await usageTracking.initDatabase();
   843→    await referralService.initReferralTables();
   844→    await licenseService.initLicenseTables();
   845→    console.log('[SPLICE] Database initialized');
   846→
   847→    // PERF-FIX: Initialize static response cache at startup
   848→    initializeStaticCache();
   849→
   850→    // Start music generation worker (BullMQ background processor)
   851→    // Only starts if Redis is configured and Replicate API key is available
   852→    if (process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL) {
   853→      if (process.env.REPLICATE_API_TOKEN) {
   854→        try {
   855→          createMusicWorker();
   856→          console.log('[SPLICE] ✅ Music generation worker started');
   857→        } catch (workerErr) {
   858→          console.error('[SPLICE] ⚠️ Failed to start music worker:', workerErr.message);
   859→          // Don't fail server startup - music generation will be unavailable
   860→        }
   861→      } else {
   862→        console.warn('[SPLICE] ⚠️ REPLICATE_API_TOKEN not set - music generation disabled');
   863→      }
   864→    } else {
   865→      console.warn('[SPLICE] ⚠️ Redis not configured - music generation queue disabled');
   866→    }
   867→
   868→    if (isProduction || !httpsOptions) {
   869→      // Production: Railway provides TLS termination, use HTTP
   870→      server = http.createServer(app).listen(PORT, () => {
   871→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);
   872→      });
   873→    } else {
   874→      // Development: Use HTTPS with local certificates
   875→      server = https.createServer(httpsOptions, app).listen(PORT, () => {
   876→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);
   877→        console.log(`[SPLICE] POST /analyze with { "wavPath": "/path/to/audio.wav" }`);
   878→      });
   879→    }
   880→  } catch (err) {
   881→    console.error('[SPLICE] Failed to start server:', err);
   882→    process.exit(1);
   883→  }
   884→}
   885→
   886→// =============================================================================
   887→// Graceful Shutdown
   888→// =============================================================================
   889→
   890→async function gracefulShutdown(signal) {
   891→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);
   892→
   893→  // Stop accepting new connections
   894→  if (server) {
   895→    server.close(() => {
   896→      console.log('[SPLICE] HTTP server closed');
   897→    });
   898→  }
   899→
   900→  // Shutdown music worker (allows in-progress jobs to complete)
   901→  try {
   902→    await shutdownWorker();
   903→    console.log('[SPLICE] Music worker shut down');
   904→  } catch (err) {
   905→    console.error('[SPLICE] Error shutting down music worker:', err.message);
   906→  }
   907→
   908→  // Close database pool
   909→  try {
   910→    await usageTracking.closePool();
   911→    console.log('[SPLICE] Database pool closed');
   912→  } catch (err) {
   913→    console.error('[SPLICE] Error closing database pool:', err.message);
   914→  }
   915→
   916→  // Give ongoing requests time to complete (max 10 seconds)
   917→  setTimeout(() => {
   918→    console.log('[SPLICE] Graceful shutdown complete');
   919→    process.exit(0);
   920→  }, 10000);
   921→}
   922→
   923→// Handle termination signals
   924→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
   925→process.on('SIGINT', () => gracefulShutdown('SIGINT'));
   926→
   927→// Handle uncaught exceptions
   928→process.on('uncaughtException', (err) => {
   929→  console.error('[SPLICE] Uncaught exception:', err);
   930→  gracefulShutdown('uncaughtException');
   931→});
   932→
   933→process.on('unhandledRejection', (reason, promise) => {
   934→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);
   935→});
   936→
   937→startServer();
   938→

</system-reminder>
