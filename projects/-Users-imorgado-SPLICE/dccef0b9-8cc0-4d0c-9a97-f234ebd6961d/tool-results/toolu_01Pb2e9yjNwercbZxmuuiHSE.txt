     1→/**
     2→ * Input Validation Middleware
     3→ *
     4→ * Provides type validation and sanitization for API request parameters
     5→ * to prevent type confusion attacks and ensure data integrity.
     6→ *
     7→ * SECURITY ENHANCEMENTS:
     8→ * - Email validation with RFC-compliant regex
     9→ * - File upload validation (type, size, extension whitelist)
    10→ * - Input sanitization to prevent injection attacks
    11→ * - Request body size enforcement
    12→ * - Path traversal prevention
    13→ */
    14→
    15→/**
    16→ * Validate that a value is a non-empty string
    17→ * @param {any} value - Value to validate
    18→ * @param {string} fieldName - Name of the field for error messages
    19→ * @returns {{valid: boolean, value?: string, error?: string}}
    20→ */
    21→function validateString(value, fieldName, options = {}) {
    22→  const { maxLength = 10000, allowEmpty = false } = options;
    23→
    24→  if (value === null || value === undefined) {
    25→    return { valid: false, error: `${fieldName} is required` };
    26→  }
    27→
    28→  if (typeof value !== 'string') {
    29→    return { valid: false, error: `${fieldName} must be a string` };
    30→  }
    31→
    32→  if (!allowEmpty && value.trim() === '') {
    33→    return { valid: false, error: `${fieldName} cannot be empty` };
    34→  }
    35→
    36→  if (value.length > maxLength) {
    37→    return { valid: false, error: `${fieldName} exceeds maximum length of ${maxLength}` };
    38→  }
    39→
    40→  return { valid: true, value: value.trim() };
    41→}
    42→
    43→/**
    44→ * Validate that a value is a number within range
    45→ * @param {any} value - Value to validate
    46→ * @param {string} fieldName - Name of the field for error messages
    47→ * @param {Object} options - Validation options
    48→ * @returns {{valid: boolean, value?: number, error?: string}}
    49→ */
    50→function validateNumber(value, fieldName, options = {}) {
    51→  const { min = -Infinity, max = Infinity, allowNegative = true } = options;
    52→
    53→  if (value === null || value === undefined) {
    54→    return { valid: false, error: `${fieldName} is required` };
    55→  }
    56→
    57→  const num = typeof value === 'string' ? parseFloat(value) : value;
    58→
    59→  if (typeof num !== 'number' || isNaN(num)) {
    60→    return { valid: false, error: `${fieldName} must be a valid number` };
    61→  }
    62→
    63→  if (!allowNegative && num < 0) {
    64→    return { valid: false, error: `${fieldName} cannot be negative` };
    65→  }
    66→
    67→  if (num < min || num > max) {
    68→    return { valid: false, error: `${fieldName} must be between ${min} and ${max}` };
    69→  }
    70→
    71→  return { valid: true, value: num };
    72→}
    73→
    74→/**
    75→ * Validate that a value is a boolean
    76→ * @param {any} value - Value to validate
    77→ * @param {string} fieldName - Name of the field for error messages
    78→ * @returns {{valid: boolean, value?: boolean, error?: string}}
    79→ */
    80→function validateBoolean(value, fieldName) {
    81→  if (value === null || value === undefined) {
    82→    return { valid: true, value: false }; // Default to false
    83→  }
    84→
    85→  if (typeof value === 'boolean') {
    86→    return { valid: true, value };
    87→  }
    88→
    89→  if (value === 'true' || value === '1') {
    90→    return { valid: true, value: true };
    91→  }
    92→
    93→  if (value === 'false' || value === '0') {
    94→    return { valid: true, value: false };
    95→  }
    96→
    97→  return { valid: false, error: `${fieldName} must be a boolean` };
    98→}
    99→
   100→/**
   101→ * Validate that a value is an array
   102→ * @param {any} value - Value to validate
   103→ * @param {string} fieldName - Name of the field for error messages
   104→ * @param {Object} options - Validation options
   105→ * @returns {{valid: boolean, value?: Array, error?: string}}
   106→ */
   107→function validateArray(value, fieldName, options = {}) {
   108→  const { maxItems = 10000, minItems = 0 } = options;
   109→
   110→  if (value === null || value === undefined) {
   111→    if (minItems > 0) {
   112→      return { valid: false, error: `${fieldName} is required` };
   113→    }
   114→    return { valid: true, value: [] };
   115→  }
   116→
   117→  if (!Array.isArray(value)) {
   118→    return { valid: false, error: `${fieldName} must be an array` };
   119→  }
   120→
   121→  if (value.length < minItems) {
   122→    return { valid: false, error: `${fieldName} must have at least ${minItems} items` };
   123→  }
   124→
   125→  if (value.length > maxItems) {
   126→    return { valid: false, error: `${fieldName} exceeds maximum of ${maxItems} items` };
   127→  }
   128→
   129→  return { valid: true, value };
   130→}
   131→
   132→/**
   133→ * Validate that a value is one of a set of allowed values
   134→ * @param {any} value - Value to validate
   135→ * @param {string} fieldName - Name of the field for error messages
   136→ * @param {Array} allowedValues - Array of allowed values
   137→ * @returns {{valid: boolean, value?: any, error?: string}}
   138→ */
   139→function validateEnum(value, fieldName, allowedValues) {
   140→  if (value === null || value === undefined) {
   141→    return { valid: false, error: `${fieldName} is required` };
   142→  }
   143→
   144→  if (!allowedValues.includes(value)) {
   145→    return { valid: false, error: `${fieldName} must be one of: ${allowedValues.join(', ')}` };
   146→  }
   147→
   148→  return { valid: true, value };
   149→}
   150→
   151→/**
   152→ * Create a validation middleware for a specific endpoint
   153→ * @param {Object} schema - Validation schema
   154→ * @returns {Function} Express middleware
   155→ */
   156→function createValidator(schema) {
   157→  return (req, res, next) => {
   158→    const errors = [];
   159→    const validated = {};
   160→
   161→    for (const [field, rules] of Object.entries(schema)) {
   162→      const value = req.body[field];
   163→      let result;
   164→
   165→      switch (rules.type) {
   166→        case 'string':
   167→          result = validateString(value, field, rules);
   168→          break;
   169→        case 'number':
   170→          result = validateNumber(value, field, rules);
   171→          break;
   172→        case 'boolean':
   173→          result = validateBoolean(value, field);
   174→          break;
   175→        case 'array':
   176→          result = validateArray(value, field, rules);
   177→          break;
   178→        case 'enum':
   179→          result = validateEnum(value, field, rules.values);
   180→          break;
   181→        default:
   182→          result = { valid: true, value };
   183→      }
   184→
   185→      if (!result.valid) {
   186→        if (!rules.optional) {
   187→          errors.push(result.error);
   188→        }
   189→      } else {
   190→        validated[field] = result.value;
   191→      }
   192→    }
   193→
   194→    if (errors.length > 0) {
   195→      return res.status(400).json({
   196→        error: 'Validation failed',
   197→        details: errors
   198→      });
   199→    }
   200→
   201→    // Attach validated data to request
   202→    req.validatedBody = validated;
   203→    next();
   204→  };
   205→}
   206→
   207→/**
   208→ * Common validation schemas for endpoints
   209→ */
   210→const validationSchemas = {
   211→  analyze: {
   212→    wavPath: { type: 'string', maxLength: 1000 },
   213→    detectTakes: { type: 'boolean', optional: true }
   214→  },
   215→  silences: {
   216→    wavPath: { type: 'string', maxLength: 1000 },
   217→    sensitivity: { type: 'number', min: 0, max: 100, optional: true },
   218→    minSilenceLength: { type: 'number', min: 0.1, max: 60, optional: true }
   219→  },
   220→  cutList: {
   221→    sourceName: { type: 'string', maxLength: 500, optional: true },
   222→    sourcePath: { type: 'string', maxLength: 1000, optional: true },
   223→    duration: { type: 'number', min: 0, max: 86400 },
   224→    silences: { type: 'array', maxItems: 10000 }
   225→  },
   226→  chapters: {
   227→    wavPath: { type: 'string', maxLength: 1000 },
   228→    transcript: { type: 'string', maxLength: 1000000, optional: true }
   229→  },
   230→  musicGenerate: {
   231→    mood: { type: 'string', maxLength: 100 },
   232→    duration: { type: 'number', min: 15, max: 600 },
   233→    instruments: { type: 'array', maxItems: 20, optional: true }
   234→  }
   235→};
   236→
   237→module.exports = {
   238→  validateString,
   239→  validateNumber,
   240→  validateBoolean,
   241→  validateArray,
   242→  validateEnum,
   243→  createValidator,
   244→  validationSchemas
   245→};
   246→

</system-reminder>
