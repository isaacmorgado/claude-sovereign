{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":"Investigate the music queue and worker system in splice-backend. Look at:\n1. /Users/imorgado/SPLICE/splice-backend/services/musicQueue.js\n2. /Users/imorgado/SPLICE/splice-backend/workers/ - find music worker\n3. Check BullMQ configuration\n4. Look for Redis connection issues\n5. Check if workers are properly starting\n\nReport any issues with the queue/worker system."},"uuid":"769eb329-81ed-4b25-bd8b-578707eafd32","timestamp":"2026-01-12T01:30:30.219Z"}
{"parentUuid":"769eb329-81ed-4b25-bd8b-578707eafd32","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01M1XCiKYh8nmJAxWMkixYJr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EYFA1X3Aa2aYbRmNZE2Hbm","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/musicQueue.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":27998,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27998,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2crWgzUGNVZJp99Cxtw","type":"assistant","uuid":"fdcb510d-9740-4be1-b3f7-da0145dcef89","timestamp":"2026-01-12T01:30:34.333Z"}
{"parentUuid":"fdcb510d-9740-4be1-b3f7-da0145dcef89","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01M1XCiKYh8nmJAxWMkixYJr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WTQh8ULhmf4faZQCsqfmmH","name":"Glob","input":{"pattern":"**/splice-backend/workers/**/*.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":27998,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27998,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2crWgzUGNVZJp99Cxtw","type":"assistant","uuid":"e760a511-f456-4a8b-b24b-83395b48dfbc","timestamp":"2026-01-12T01:30:34.737Z"}
{"parentUuid":"e760a511-f456-4a8b-b24b-83395b48dfbc","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01M1XCiKYh8nmJAxWMkixYJr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HcnmeRk9DbvtqAS8h3Su2r","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/redisClient.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":27998,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27998,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2crWgzUGNVZJp99Cxtw","type":"assistant","uuid":"b810bc14-a52f-4355-8596-72f82301a29e","timestamp":"2026-01-12T01:30:35.118Z"}
{"parentUuid":"b810bc14-a52f-4355-8596-72f82301a29e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HcnmeRk9DbvtqAS8h3Su2r","type":"tool_result","content":"     1→/**\n     2→ * Shared Redis Client Service\n     3→ * Supports both Upstash REST API and standard Redis (ioredis)\n     4→ * - Uses @upstash/redis when UPSTASH_REDIS_REST_URL is configured\n     5→ * - Uses ioredis when UPSTASH_REDIS_URL is configured (Railway, standard Redis)\n     6→ * - Provides unified API for caching and storage operations\n     7→ */\n     8→\n     9→const { Redis: UpstashRedis } = require('@upstash/redis');\n    10→const IORedis = require('ioredis');\n    11→\n    12→// Singleton instances\n    13→let client = null;\n    14→let clientType = 'none'; // 'upstash-rest', 'ioredis', or 'none'\n    15→let isConnected = false;\n    16→let connectionError = null;\n    17→\n    18→/**\n    19→ * Initialize Redis client based on available environment variables\n    20→ * Priority: Upstash REST > Standard Redis URL\n    21→ * @returns {Object|null} Redis client or null if not configured\n    22→ */\n    23→function initializeClient() {\n    24→  if (client) {\n    25→    return client;\n    26→  }\n    27→\n    28→  // Try Upstash REST first (for Upstash-specific deployments)\n    29→  const restUrl = process.env.UPSTASH_REDIS_REST_URL;\n    30→  const restToken = process.env.UPSTASH_REDIS_REST_TOKEN;\n    31→\n    32→  if (restUrl && restToken) {\n    33→    try {\n    34→      client = new UpstashRedis({\n    35→        url: restUrl,\n    36→        token: restToken,\n    37→        automaticDeserialization: true,\n    38→      });\n    39→      clientType = 'upstash-rest';\n    40→      isConnected = true;\n    41→      console.log('[Redis] Upstash REST client initialized');\n    42→      return client;\n    43→    } catch (err) {\n    44→      console.error('[Redis] Failed to initialize Upstash REST client:', err.message);\n    45→      connectionError = err;\n    46→    }\n    47→  }\n    48→\n    49→  // Try standard Redis URL (Railway, Docker, local Redis)\n    50→  const redisUrl = process.env.UPSTASH_REDIS_URL || process.env.REDIS_URL;\n    51→\n    52→  if (redisUrl) {\n    53→    try {\n    54→      client = new IORedis(redisUrl, {\n    55→        maxRetriesPerRequest: 3,\n    56→        retryDelayOnFailover: 100,\n    57→        lazyConnect: false,\n    58→        enableReadyCheck: true,\n    59→        connectTimeout: 10000,\n    60→      });\n    61→\n    62→      client.on('connect', () => {\n    63→        isConnected = true;\n    64→        connectionError = null;\n    65→        console.log('[Redis] ioredis client connected');\n    66→      });\n    67→\n    68→      client.on('error', (err) => {\n    69→        console.error('[Redis] ioredis error:', err.message);\n    70→        connectionError = err;\n    71→        // Don't set isConnected to false on transient errors\n    72→      });\n    73→\n    74→      client.on('close', () => {\n    75→        console.log('[Redis] ioredis connection closed');\n    76→      });\n    77→\n    78→      clientType = 'ioredis';\n    79→      isConnected = true; // Optimistically set, will be updated by events\n    80→      console.log('[Redis] ioredis client initialized with URL');\n    81→      return client;\n    82→    } catch (err) {\n    83→      console.error('[Redis] Failed to initialize ioredis client:', err.message);\n    84→      connectionError = err;\n    85→    }\n    86→  }\n    87→\n    88→  console.warn('[Redis] No Redis configuration found - Redis features disabled');\n    89→  console.warn('[Redis] Set UPSTASH_REDIS_URL for standard Redis or UPSTASH_REDIS_REST_URL + UPSTASH_REDIS_REST_TOKEN for Upstash REST');\n    90→  connectionError = new Error('Redis not configured');\n    91→  return null;\n    92→}\n    93→\n    94→/**\n    95→ * Get the Redis client (lazy initialization)\n    96→ * @returns {Object|null} Redis client or null if not configured\n    97→ */\n    98→function getRedisClient() {\n    99→  return initializeClient();\n   100→}\n   101→\n   102→/**\n   103→ * Check if Redis is available and connected\n   104→ * @returns {boolean} True if Redis is available\n   105→ */\n   106→function isRedisAvailable() {\n   107→  const redis = getRedisClient();\n   108→  return redis !== null && isConnected;\n   109→}\n   110→\n   111→/**\n   112→ * Get Redis connection status\n   113→ * @returns {Object} { connected, error, type }\n   114→ */\n   115→function getRedisStatus() {\n   116→  getRedisClient(); // Ensure initialization attempted\n   117→  return {\n   118→    connected: isConnected && client !== null,\n   119→    error: connectionError ? connectionError.message : null,\n   120→    type: clientType\n   121→  };\n   122→}\n   123→\n   124→/**\n   125→ * Ping Redis to check connectivity\n   126→ * @returns {Promise<boolean>} True if ping successful\n   127→ */\n   128→async function pingRedis() {\n   129→  const redis = getRedisClient();\n   130→  if (!redis) {\n   131→    return false;\n   132→  }\n   133→\n   134→  try {\n   135→    const result = await redis.ping();\n   136→    const success = result === 'PONG' || result === 'pong';\n   137→    if (success) {\n   138→      isConnected = true;\n   139→      connectionError = null;\n   140→    }\n   141→    return success;\n   142→  } catch (err) {\n   143→    console.error('[Redis] Ping failed:', err.message);\n   144→    isConnected = false;\n   145→    connectionError = err;\n   146→    return false;\n   147→  }\n   148→}\n   149→\n   150→/**\n   151→ * Set a value with optional TTL\n   152→ * @param {string} key - Redis key\n   153→ * @param {any} value - Value to store (will be JSON serialized for ioredis)\n   154→ * @param {number} ttlSeconds - Optional TTL in seconds\n   155→ * @returns {Promise<boolean>} True if successful\n   156→ */\n   157→async function set(key, value, ttlSeconds = null) {\n   158→  const redis = getRedisClient();\n   159→  if (!redis) {\n   160→    return false;\n   161→  }\n   162→\n   163→  try {\n   164→    // Serialize value for ioredis (Upstash REST handles this automatically)\n   165→    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;\n   166→\n   167→    if (clientType === 'upstash-rest') {\n   168→      if (ttlSeconds) {\n   169→        await redis.set(key, value, { ex: ttlSeconds });\n   170→      } else {\n   171→        await redis.set(key, value);\n   172→      }\n   173→    } else {\n   174→      // ioredis syntax\n   175→      if (ttlSeconds) {\n   176→        await redis.set(key, serializedValue, 'EX', ttlSeconds);\n   177→      } else {\n   178→        await redis.set(key, serializedValue);\n   179→      }\n   180→    }\n   181→    return true;\n   182→  } catch (err) {\n   183→    console.error('[Redis] SET failed:', err.message);\n   184→    return false;\n   185→  }\n   186→}\n   187→\n   188→/**\n   189→ * Get a value\n   190→ * @param {string} key - Redis key\n   191→ * @returns {Promise<any|null>} Value or null if not found\n   192→ */\n   193→async function get(key) {\n   194→  const redis = getRedisClient();\n   195→  if (!redis) {\n   196→    return null;\n   197→  }\n   198→\n   199→  try {\n   200→    const result = await redis.get(key);\n   201→    if (result === null) {\n   202→      return null;\n   203→    }\n   204→    // Parse JSON for ioredis (Upstash REST handles this automatically)\n   205→    if (clientType === 'ioredis' && typeof result === 'string') {\n   206→      try {\n   207→        return JSON.parse(result);\n   208→      } catch {\n   209→        return result; // Return as-is if not JSON\n   210→      }\n   211→    }\n   212→    return result;\n   213→  } catch (err) {\n   214→    console.error('[Redis] GET failed:', err.message);\n   215→    return null;\n   216→  }\n   217→}\n   218→\n   219→/**\n   220→ * Check if a key exists\n   221→ * @param {string} key - Redis key\n   222→ * @returns {Promise<boolean>} True if key exists\n   223→ */\n   224→async function exists(key) {\n   225→  const redis = getRedisClient();\n   226→  if (!redis) {\n   227→    return false;\n   228→  }\n   229→\n   230→  try {\n   231→    const result = await redis.exists(key);\n   232→    return result === 1 || result === true;\n   233→  } catch (err) {\n   234→    console.error('[Redis] EXISTS failed:', err.message);\n   235→    return false;\n   236→  }\n   237→}\n   238→\n   239→/**\n   240→ * Delete a key\n   241→ * @param {string} key - Redis key\n   242→ * @returns {Promise<boolean>} True if deleted\n   243→ */\n   244→async function del(key) {\n   245→  const redis = getRedisClient();\n   246→  if (!redis) {\n   247→    return false;\n   248→  }\n   249→\n   250→  try {\n   251→    await redis.del(key);\n   252→    return true;\n   253→  } catch (err) {\n   254→    console.error('[Redis] DEL failed:', err.message);\n   255→    return false;\n   256→  }\n   257→}\n   258→\n   259→/**\n   260→ * Set a value only if it doesn't exist (SETNX)\n   261→ * @param {string} key - Redis key\n   262→ * @param {any} value - Value to store\n   263→ * @param {number} ttlSeconds - Optional TTL in seconds\n   264→ * @returns {Promise<boolean>} True if set (key didn't exist)\n   265→ */\n   266→async function setNX(key, value, ttlSeconds = null) {\n   267→  const redis = getRedisClient();\n   268→  if (!redis) {\n   269→    return false;\n   270→  }\n   271→\n   272→  try {\n   273→    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;\n   274→\n   275→    if (clientType === 'upstash-rest') {\n   276→      const options = { nx: true };\n   277→      if (ttlSeconds) {\n   278→        options.ex = ttlSeconds;\n   279→      }\n   280→      const result = await redis.set(key, value, options);\n   281→      return result === 'OK';\n   282→    } else {\n   283→      // ioredis: Use SET with NX option\n   284→      const args = [key, serializedValue, 'NX'];\n   285→      if (ttlSeconds) {\n   286→        args.push('EX', ttlSeconds);\n   287→      }\n   288→      const result = await redis.set(...args);\n   289→      return result === 'OK';\n   290→    }\n   291→  } catch (err) {\n   292→    console.error('[Redis] SETNX failed:', err.message);\n   293→    return false;\n   294→  }\n   295→}\n   296→\n   297→/**\n   298→ * Get TTL of a key\n   299→ * @param {string} key - Redis key\n   300→ * @returns {Promise<number>} TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n   301→ */\n   302→async function ttl(key) {\n   303→  const redis = getRedisClient();\n   304→  if (!redis) {\n   305→    return -2;\n   306→  }\n   307→\n   308→  try {\n   309→    return await redis.ttl(key);\n   310→  } catch (err) {\n   311→    console.error('[Redis] TTL failed:', err.message);\n   312→    return -2;\n   313→  }\n   314→}\n   315→\n   316→/**\n   317→ * Gracefully close the Redis connection\n   318→ * @returns {Promise<void>}\n   319→ */\n   320→async function close() {\n   321→  if (client && clientType === 'ioredis') {\n   322→    try {\n   323→      await client.quit();\n   324→      console.log('[Redis] ioredis connection closed gracefully');\n   325→    } catch (err) {\n   326→      console.error('[Redis] Error closing connection:', err.message);\n   327→    }\n   328→  }\n   329→  client = null;\n   330→  clientType = 'none';\n   331→  isConnected = false;\n   332→}\n   333→\n   334→module.exports = {\n   335→  getRedisClient,\n   336→  isRedisAvailable,\n   337→  getRedisStatus,\n   338→  pingRedis,\n   339→  close,\n   340→  // Convenience methods\n   341→  set,\n   342→  get,\n   343→  exists,\n   344→  del,\n   345→  setNX,\n   346→  ttl\n   347→};\n   348→\n\n</system-reminder>\n"}]},"uuid":"6107b4ad-6263-44ec-a7ae-d81f3e0cccaa","timestamp":"2026-01-12T01:30:35.177Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/redisClient.js","content":"/**\n * Shared Redis Client Service\n * Supports both Upstash REST API and standard Redis (ioredis)\n * - Uses @upstash/redis when UPSTASH_REDIS_REST_URL is configured\n * - Uses ioredis when UPSTASH_REDIS_URL is configured (Railway, standard Redis)\n * - Provides unified API for caching and storage operations\n */\n\nconst { Redis: UpstashRedis } = require('@upstash/redis');\nconst IORedis = require('ioredis');\n\n// Singleton instances\nlet client = null;\nlet clientType = 'none'; // 'upstash-rest', 'ioredis', or 'none'\nlet isConnected = false;\nlet connectionError = null;\n\n/**\n * Initialize Redis client based on available environment variables\n * Priority: Upstash REST > Standard Redis URL\n * @returns {Object|null} Redis client or null if not configured\n */\nfunction initializeClient() {\n  if (client) {\n    return client;\n  }\n\n  // Try Upstash REST first (for Upstash-specific deployments)\n  const restUrl = process.env.UPSTASH_REDIS_REST_URL;\n  const restToken = process.env.UPSTASH_REDIS_REST_TOKEN;\n\n  if (restUrl && restToken) {\n    try {\n      client = new UpstashRedis({\n        url: restUrl,\n        token: restToken,\n        automaticDeserialization: true,\n      });\n      clientType = 'upstash-rest';\n      isConnected = true;\n      console.log('[Redis] Upstash REST client initialized');\n      return client;\n    } catch (err) {\n      console.error('[Redis] Failed to initialize Upstash REST client:', err.message);\n      connectionError = err;\n    }\n  }\n\n  // Try standard Redis URL (Railway, Docker, local Redis)\n  const redisUrl = process.env.UPSTASH_REDIS_URL || process.env.REDIS_URL;\n\n  if (redisUrl) {\n    try {\n      client = new IORedis(redisUrl, {\n        maxRetriesPerRequest: 3,\n        retryDelayOnFailover: 100,\n        lazyConnect: false,\n        enableReadyCheck: true,\n        connectTimeout: 10000,\n      });\n\n      client.on('connect', () => {\n        isConnected = true;\n        connectionError = null;\n        console.log('[Redis] ioredis client connected');\n      });\n\n      client.on('error', (err) => {\n        console.error('[Redis] ioredis error:', err.message);\n        connectionError = err;\n        // Don't set isConnected to false on transient errors\n      });\n\n      client.on('close', () => {\n        console.log('[Redis] ioredis connection closed');\n      });\n\n      clientType = 'ioredis';\n      isConnected = true; // Optimistically set, will be updated by events\n      console.log('[Redis] ioredis client initialized with URL');\n      return client;\n    } catch (err) {\n      console.error('[Redis] Failed to initialize ioredis client:', err.message);\n      connectionError = err;\n    }\n  }\n\n  console.warn('[Redis] No Redis configuration found - Redis features disabled');\n  console.warn('[Redis] Set UPSTASH_REDIS_URL for standard Redis or UPSTASH_REDIS_REST_URL + UPSTASH_REDIS_REST_TOKEN for Upstash REST');\n  connectionError = new Error('Redis not configured');\n  return null;\n}\n\n/**\n * Get the Redis client (lazy initialization)\n * @returns {Object|null} Redis client or null if not configured\n */\nfunction getRedisClient() {\n  return initializeClient();\n}\n\n/**\n * Check if Redis is available and connected\n * @returns {boolean} True if Redis is available\n */\nfunction isRedisAvailable() {\n  const redis = getRedisClient();\n  return redis !== null && isConnected;\n}\n\n/**\n * Get Redis connection status\n * @returns {Object} { connected, error, type }\n */\nfunction getRedisStatus() {\n  getRedisClient(); // Ensure initialization attempted\n  return {\n    connected: isConnected && client !== null,\n    error: connectionError ? connectionError.message : null,\n    type: clientType\n  };\n}\n\n/**\n * Ping Redis to check connectivity\n * @returns {Promise<boolean>} True if ping successful\n */\nasync function pingRedis() {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    const result = await redis.ping();\n    const success = result === 'PONG' || result === 'pong';\n    if (success) {\n      isConnected = true;\n      connectionError = null;\n    }\n    return success;\n  } catch (err) {\n    console.error('[Redis] Ping failed:', err.message);\n    isConnected = false;\n    connectionError = err;\n    return false;\n  }\n}\n\n/**\n * Set a value with optional TTL\n * @param {string} key - Redis key\n * @param {any} value - Value to store (will be JSON serialized for ioredis)\n * @param {number} ttlSeconds - Optional TTL in seconds\n * @returns {Promise<boolean>} True if successful\n */\nasync function set(key, value, ttlSeconds = null) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    // Serialize value for ioredis (Upstash REST handles this automatically)\n    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;\n\n    if (clientType === 'upstash-rest') {\n      if (ttlSeconds) {\n        await redis.set(key, value, { ex: ttlSeconds });\n      } else {\n        await redis.set(key, value);\n      }\n    } else {\n      // ioredis syntax\n      if (ttlSeconds) {\n        await redis.set(key, serializedValue, 'EX', ttlSeconds);\n      } else {\n        await redis.set(key, serializedValue);\n      }\n    }\n    return true;\n  } catch (err) {\n    console.error('[Redis] SET failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get a value\n * @param {string} key - Redis key\n * @returns {Promise<any|null>} Value or null if not found\n */\nasync function get(key) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return null;\n  }\n\n  try {\n    const result = await redis.get(key);\n    if (result === null) {\n      return null;\n    }\n    // Parse JSON for ioredis (Upstash REST handles this automatically)\n    if (clientType === 'ioredis' && typeof result === 'string') {\n      try {\n        return JSON.parse(result);\n      } catch {\n        return result; // Return as-is if not JSON\n      }\n    }\n    return result;\n  } catch (err) {\n    console.error('[Redis] GET failed:', err.message);\n    return null;\n  }\n}\n\n/**\n * Check if a key exists\n * @param {string} key - Redis key\n * @returns {Promise<boolean>} True if key exists\n */\nasync function exists(key) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    const result = await redis.exists(key);\n    return result === 1 || result === true;\n  } catch (err) {\n    console.error('[Redis] EXISTS failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Delete a key\n * @param {string} key - Redis key\n * @returns {Promise<boolean>} True if deleted\n */\nasync function del(key) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    await redis.del(key);\n    return true;\n  } catch (err) {\n    console.error('[Redis] DEL failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Set a value only if it doesn't exist (SETNX)\n * @param {string} key - Redis key\n * @param {any} value - Value to store\n * @param {number} ttlSeconds - Optional TTL in seconds\n * @returns {Promise<boolean>} True if set (key didn't exist)\n */\nasync function setNX(key, value, ttlSeconds = null) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;\n\n    if (clientType === 'upstash-rest') {\n      const options = { nx: true };\n      if (ttlSeconds) {\n        options.ex = ttlSeconds;\n      }\n      const result = await redis.set(key, value, options);\n      return result === 'OK';\n    } else {\n      // ioredis: Use SET with NX option\n      const args = [key, serializedValue, 'NX'];\n      if (ttlSeconds) {\n        args.push('EX', ttlSeconds);\n      }\n      const result = await redis.set(...args);\n      return result === 'OK';\n    }\n  } catch (err) {\n    console.error('[Redis] SETNX failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get TTL of a key\n * @param {string} key - Redis key\n * @returns {Promise<number>} TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n */\nasync function ttl(key) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return -2;\n  }\n\n  try {\n    return await redis.ttl(key);\n  } catch (err) {\n    console.error('[Redis] TTL failed:', err.message);\n    return -2;\n  }\n}\n\n/**\n * Gracefully close the Redis connection\n * @returns {Promise<void>}\n */\nasync function close() {\n  if (client && clientType === 'ioredis') {\n    try {\n      await client.quit();\n      console.log('[Redis] ioredis connection closed gracefully');\n    } catch (err) {\n      console.error('[Redis] Error closing connection:', err.message);\n    }\n  }\n  client = null;\n  clientType = 'none';\n  isConnected = false;\n}\n\nmodule.exports = {\n  getRedisClient,\n  isRedisAvailable,\n  getRedisStatus,\n  pingRedis,\n  close,\n  // Convenience methods\n  set,\n  get,\n  exists,\n  del,\n  setNX,\n  ttl\n};\n","numLines":348,"startLine":1,"totalLines":348}}}
{"parentUuid":"6107b4ad-6263-44ec-a7ae-d81f3e0cccaa","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WTQh8ULhmf4faZQCsqfmmH","type":"tool_result","content":"/Users/imorgado/SPLICE/splice-backend/workers/musicWorker.js"}]},"uuid":"522561f7-697d-4ef0-91e9-26209d68ea34","timestamp":"2026-01-12T01:30:35.321Z","toolUseResult":{"filenames":["/Users/imorgado/SPLICE/splice-backend/workers/musicWorker.js"],"durationMs":153,"numFiles":1,"truncated":false}}
{"parentUuid":"522561f7-697d-4ef0-91e9-26209d68ea34","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EYFA1X3Aa2aYbRmNZE2Hbm","type":"tool_result","content":"     1→/**\n     2→ * Music Generation Job Queue Service\n     3→ * Uses BullMQ with Upstash Redis for reliable background processing\n     4→ *\n     5→ * HIGH-006: Added Dead Letter Queue (DLQ) for permanently failed jobs\n     6→ */\n     7→\n     8→const { Queue } = require('bullmq');\n     9→\n    10→// Redis connection (lazy initialization)\n    11→let redisConnection = null;\n    12→let musicQueue = null;\n    13→let musicWorker = null;\n    14→let deadLetterQueue = null;\n    15→\n    16→// ============================================================================\n    17→// HIGH-006: Dead Letter Queue Configuration\n    18→// Jobs that fail after all retry attempts are moved here for inspection/recovery\n    19→// ============================================================================\n    20→\n    21→const DLQ_CONFIG = {\n    22→  queueName: 'music-generation-dlq',\n    23→  // Keep failed jobs in DLQ for 30 days\n    24→  retentionDays: 30,\n    25→  // Maximum DLQ jobs to keep\n    26→  maxJobs: 10000\n    27→};\n    28→\n    29→// Job statuses\n    30→const JOB_STATUS = {\n    31→  PENDING: 'pending',\n    32→  EXTRACTING: 'extracting',\n    33→  IDENTIFYING: 'identifying',\n    34→  GENERATING: 'generating',\n    35→  UPLOADING: 'uploading',\n    36→  COMPLETED: 'completed',\n    37→  FAILED: 'failed',\n    38→  // Variations-specific statuses\n    39→  GENERATING_VARIATIONS: 'generating_variations',\n    40→  SELECTING: 'selecting',  // Waiting for user to select a variation\n    41→  // Scene-aware specific statuses\n    42→  ANALYZING: 'analyzing'  // Analyzing transcript for scene context\n    43→};\n    44→\n    45→// Progress percentages for each step\n    46→const PROGRESS_MAP = {\n    47→  [JOB_STATUS.PENDING]: 0,\n    48→  [JOB_STATUS.EXTRACTING]: 10,\n    49→  [JOB_STATUS.IDENTIFYING]: 30,\n    50→  [JOB_STATUS.GENERATING]: 60,\n    51→  [JOB_STATUS.UPLOADING]: 90,\n    52→  [JOB_STATUS.COMPLETED]: 100,\n    53→  // Variations progress\n    54→  [JOB_STATUS.GENERATING_VARIATIONS]: 50,\n    55→  [JOB_STATUS.SELECTING]: 95,\n    56→  // Scene-aware progress\n    57→  [JOB_STATUS.ANALYZING]: 15\n    58→};\n    59→\n    60→/**\n    61→ * Initialize Redis connection\n    62→ * Supports both Railway Redis (REDIS_URL) and Upstash Redis (UPSTASH_REDIS_URL)\n    63→ * @returns {Object} IORedis connection options\n    64→ */\n    65→function getRedisConnection() {\n    66→  if (!redisConnection) {\n    67→    // Support both Railway Redis URL and Upstash Redis URL\n    68→    const redisUrl = process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL;\n    69→\n    70→    if (!redisUrl) {\n    71→      throw new Error('Missing REDIS_URL or UPSTASH_REDIS_URL environment variable');\n    72→    }\n    73→\n    74→    // Parse Redis URL\n    75→    const url = new URL(redisUrl);\n    76→\n    77→    redisConnection = {\n    78→      host: url.hostname,\n    79→      port: parseInt(url.port) || 6379,\n    80→      password: url.password,\n    81→      username: url.username || undefined,\n    82→      tls: url.protocol === 'rediss:' ? {} : undefined,\n    83→      maxRetriesPerRequest: null // Required for BullMQ workers\n    84→    };\n    85→    \n    86→    console.log(`[Queue] Redis connection configured for ${url.hostname}:${url.port} (${url.protocol === 'rediss:' ? 'TLS' : 'plain'})`);\n    87→  }\n    88→  return redisConnection;\n    89→}\n    90→\n    91→// ============================================================================\n    92→// HIGH-006: Dead Letter Queue Functions\n    93→// ============================================================================\n    94→\n    95→/**\n    96→ * Get or create the dead letter queue for permanently failed jobs\n    97→ * @returns {Queue} BullMQ Queue instance for DLQ\n    98→ */\n    99→function getDeadLetterQueue() {\n   100→  if (!deadLetterQueue) {\n   101→    deadLetterQueue = new Queue(DLQ_CONFIG.queueName, {\n   102→      connection: getRedisConnection(),\n   103→      defaultJobOptions: {\n   104→        // DLQ jobs don't retry - they're already failed\n   105→        attempts: 1,\n   106→        // Keep for inspection/debugging\n   107→        removeOnComplete: {\n   108→          age: DLQ_CONFIG.retentionDays * 24 * 3600,\n   109→          count: DLQ_CONFIG.maxJobs\n   110→        },\n   111→        removeOnFail: false // Never auto-remove failed DLQ entries\n   112→      }\n   113→    });\n   114→    console.log('[Queue] Dead Letter Queue initialized');\n   115→  }\n   116→  return deadLetterQueue;\n   117→}\n   118→\n   119→/**\n   120→ * Move a permanently failed job to the Dead Letter Queue\n   121→ * Called by the worker when a job exhausts all retry attempts\n   122→ * @param {Object} job - The failed BullMQ job\n   123→ * @param {Error|string} error - The error that caused the failure\n   124→ * @returns {Promise<{dlqJobId: string}>}\n   125→ */\n   126→async function moveToDeadLetterQueue(job, error) {\n   127→  const dlq = getDeadLetterQueue();\n   128→  \n   129→  const dlqJobId = `dlq_${job.id}_${Date.now()}`;\n   130→  \n   131→  const dlqData = {\n   132→    // Original job metadata\n   133→    originalJobId: job.id,\n   134→    originalQueue: 'music-generation',\n   135→    \n   136→    // Copy of original job data\n   137→    originalData: job.data,\n   138→    \n   139→    // Failure information\n   140→    error: typeof error === 'string' ? error : error?.message || 'Unknown error',\n   141→    errorStack: error?.stack || null,\n   142→    failedAt: new Date().toISOString(),\n   143→    attemptsMade: job.attemptsMade || 0,\n   144→    \n   145→    // Job history for debugging\n   146→    processedAt: job.processedOn ? new Date(job.processedOn).toISOString() : null,\n   147→    createdAt: job.data?.createdAt || null,\n   148→    \n   149→    // Recovery flags\n   150→    canRetry: !isUnrecoverableError(error),\n   151→    recovered: false,\n   152→    recoveredAt: null,\n   153→    recoveryNotes: null\n   154→  };\n   155→  \n   156→  await dlq.add('failed-job', dlqData, {\n   157→    jobId: dlqJobId\n   158→  });\n   159→  \n   160→  console.log(`[DLQ] Job ${job.id} moved to dead letter queue as ${dlqJobId}`);\n   161→  console.log(`[DLQ] Reason: ${dlqData.error}`);\n   162→  \n   163→  return { dlqJobId };\n   164→}\n   165→\n   166→/**\n   167→ * Check if an error indicates an unrecoverable failure\n   168→ * @param {Error|string} error - The error to check\n   169→ * @returns {boolean}\n   170→ */\n   171→function isUnrecoverableError(error) {\n   172→  const message = typeof error === 'string' ? error : error?.message || '';\n   173→  \n   174→  const unrecoverablePatterns = [\n   175→    /quota exceeded/i,\n   176→    /invalid api key/i,\n   177→    /authentication failed/i,\n   178→    /insufficient credits/i,\n   179→    /account suspended/i,\n   180→    /content policy violation/i,\n   181→    /customer not found/i,\n   182→    /invalid customer/i\n   183→  ];\n   184→  \n   185→  return unrecoverablePatterns.some(pattern => pattern.test(message));\n   186→}\n   187→\n   188→/**\n   189→ * Get jobs from the Dead Letter Queue with pagination\n   190→ * @param {Object} options - Query options\n   191→ * @param {number} options.limit - Max jobs to return (default 50)\n   192→ * @param {number} options.offset - Offset for pagination (default 0)\n   193→ * @param {boolean} options.includeRecovered - Include already recovered jobs (default false)\n   194→ * @returns {Promise<{jobs: Object[], total: number}>}\n   195→ */\n   196→async function getDeadLetterJobs(options = {}) {\n   197→  const dlq = getDeadLetterQueue();\n   198→  const limit = options.limit || 50;\n   199→  const offset = options.offset || 0;\n   200→  const includeRecovered = options.includeRecovered || false;\n   201→  \n   202→  // Get waiting and completed jobs from DLQ\n   203→  const [waiting, completed] = await Promise.all([\n   204→    dlq.getWaiting(0, 1000),\n   205→    dlq.getCompleted(0, 1000)\n   206→  ]);\n   207→  \n   208→  // Combine and filter\n   209→  let allJobs = [...waiting, ...completed];\n   210→  \n   211→  if (!includeRecovered) {\n   212→    allJobs = allJobs.filter(job => !job.data.recovered);\n   213→  }\n   214→  \n   215→  // Sort by failedAt descending (newest first)\n   216→  allJobs.sort((a, b) => {\n   217→    const aDate = new Date(a.data.failedAt || 0);\n   218→    const bDate = new Date(b.data.failedAt || 0);\n   219→    return bDate - aDate;\n   220→  });\n   221→  \n   222→  const total = allJobs.length;\n   223→  const paginatedJobs = allJobs.slice(offset, offset + limit);\n   224→  \n   225→  return {\n   226→    jobs: paginatedJobs.map(job => ({\n   227→      dlqJobId: job.id,\n   228→      originalJobId: job.data.originalJobId,\n   229→      customerId: job.data.originalData?.customerId,\n   230→      error: job.data.error,\n   231→      failedAt: job.data.failedAt,\n   232→      attemptsMade: job.data.attemptsMade,\n   233→      canRetry: job.data.canRetry,\n   234→      recovered: job.data.recovered,\n   235→      recoveredAt: job.data.recoveredAt,\n   236→      // Include original job context\n   237→      mood: job.data.originalData?.mood,\n   238→      duration: job.data.originalData?.duration,\n   239→      isSceneAware: job.data.originalData?.isSceneAware\n   240→    })),\n   241→    total,\n   242→    limit,\n   243→    offset\n   244→  };\n   245→}\n   246→\n   247→/**\n   248→ * Recover a job from the Dead Letter Queue by re-queueing it\n   249→ * @param {string} dlqJobId - Dead Letter Queue job ID\n   250→ * @param {Object} options - Recovery options\n   251→ * @param {string} options.notes - Recovery notes for audit trail\n   252→ * @returns {Promise<{success: boolean, newJobId: string}>}\n   253→ */\n   254→async function recoverFromDeadLetterQueue(dlqJobId, options = {}) {\n   255→  const dlq = getDeadLetterQueue();\n   256→  const mainQueue = getMusicQueue();\n   257→  \n   258→  const dlqJob = await dlq.getJob(dlqJobId);\n   259→  \n   260→  if (!dlqJob) {\n   261→    throw new Error(`DLQ job ${dlqJobId} not found`);\n   262→  }\n   263→  \n   264→  if (dlqJob.data.recovered) {\n   265→    throw new Error(`DLQ job ${dlqJobId} has already been recovered`);\n   266→  }\n   267→  \n   268→  if (!dlqJob.data.canRetry) {\n   269→    throw new Error(`DLQ job ${dlqJobId} is marked as unrecoverable`);\n   270→  }\n   271→  \n   272→  // Generate new job ID for the recovered job\n   273→  const newJobId = `recovered_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n   274→  \n   275→  // Re-queue with original data\n   276→  await mainQueue.add('generate', {\n   277→    ...dlqJob.data.originalData,\n   278→    jobId: newJobId,\n   279→    recoveredFrom: dlqJobId,\n   280→    step: JOB_STATUS.PENDING,\n   281→    createdAt: new Date().toISOString()\n   282→  }, {\n   283→    jobId: newJobId,\n   284→    priority: 0\n   285→  });\n   286→  \n   287→  // Mark DLQ job as recovered\n   288→  await dlqJob.updateData({\n   289→    ...dlqJob.data,\n   290→    recovered: true,\n   291→    recoveredAt: new Date().toISOString(),\n   292→    recoveryNotes: options.notes || null,\n   293→    newJobId\n   294→  });\n   295→  \n   296→  console.log(`[DLQ] Job ${dlqJobId} recovered as ${newJobId}`);\n   297→  \n   298→  return { success: true, newJobId };\n   299→}\n   300→\n   301→/**\n   302→ * Get Dead Letter Queue statistics\n   303→ * @returns {Promise<Object>} DLQ stats\n   304→ */\n   305→async function getDeadLetterQueueStats() {\n   306→  const dlq = getDeadLetterQueue();\n   307→  \n   308→  const [waiting, completed] = await Promise.all([\n   309→    dlq.getWaiting(0, 10000),\n   310→    dlq.getCompleted(0, 10000)\n   311→  ]);\n   312→  \n   313→  const allJobs = [...waiting, ...completed];\n   314→  \n   315→  const stats = {\n   316→    total: allJobs.length,\n   317→    recoverable: 0,\n   318→    unrecoverable: 0,\n   319→    recovered: 0,\n   320→    pending: 0,\n   321→    oldestFailure: null,\n   322→    newestFailure: null,\n   323→    byError: {}\n   324→  };\n   325→  \n   326→  for (const job of allJobs) {\n   327→    if (job.data.recovered) {\n   328→      stats.recovered++;\n   329→    } else if (job.data.canRetry) {\n   330→      stats.recoverable++;\n   331→      stats.pending++;\n   332→    } else {\n   333→      stats.unrecoverable++;\n   334→      stats.pending++;\n   335→    }\n   336→    \n   337→    // Track error types\n   338→    const errorKey = job.data.error?.substring(0, 50) || 'Unknown';\n   339→    stats.byError[errorKey] = (stats.byError[errorKey] || 0) + 1;\n   340→    \n   341→    // Track oldest/newest\n   342→    const failedAt = new Date(job.data.failedAt);\n   343→    if (!stats.oldestFailure || failedAt < new Date(stats.oldestFailure)) {\n   344→      stats.oldestFailure = job.data.failedAt;\n   345→    }\n   346→    if (!stats.newestFailure || failedAt > new Date(stats.newestFailure)) {\n   347→      stats.newestFailure = job.data.failedAt;\n   348→    }\n   349→  }\n   350→  \n   351→  return stats;\n   352→}\n   353→\n   354→/**\n   355→ * Get or create the music generation queue\n   356→ * @returns {Queue} BullMQ Queue instance\n   357→ */\n   358→function getMusicQueue() {\n   359→  if (!musicQueue) {\n   360→    musicQueue = new Queue('music-generation', {\n   361→      connection: getRedisConnection(),\n   362→      defaultJobOptions: {\n   363→        attempts: 3,\n   364→        backoff: {\n   365→          type: 'exponential',\n   366→          delay: 5000 // Start with 5s, then 10s, then 20s\n   367→        },\n   368→        removeOnComplete: {\n   369→          age: 24 * 3600, // Keep completed jobs for 24 hours\n   370→          count: 1000 // Keep max 1000 completed jobs\n   371→        },\n   372→        removeOnFail: {\n   373→          age: 7 * 24 * 3600 // Keep failed jobs for 7 days\n   374→        }\n   375→      }\n   376→    });\n   377→  }\n   378→  return musicQueue;\n   379→}\n   380→\n   381→/**\n   382→ * Generate a unique job ID\n   383→ * @param {string} customerId - Stripe customer ID\n   384→ * @returns {string} Unique job ID\n   385→ */\n   386→function generateJobId(_customerId) {\n   387→  const timestamp = Date.now();\n   388→  const random = Math.random().toString(36).substring(2, 8);\n   389→  return `music_${timestamp}_${random}`;\n   390→}\n   391→\n   392→/**\n   393→ * Add a new music generation job to the queue\n   394→ * @param {Object} jobData - Job data\n   395→ * @param {string} jobData.customerId - Stripe customer ID\n   396→ * @param {string} jobData.youtubeUrl - YouTube URL for reference song (optional)\n   397→ * @param {string} jobData.prompt - Text prompt for music generation\n   398→ * @param {number} jobData.duration - Duration in seconds (30-180)\n   399→ * @param {string} jobData.mood - Mood setting\n   400→ * @param {string[]} jobData.instruments - Preferred instruments\n   401→ * @param {boolean} jobData.isSceneAware - Whether to use scene analysis\n   402→ * @param {Object[]} jobData.segments - Transcript segments for scene analysis\n   403→ * @returns {Promise<{jobId: string, status: string}>}\n   404→ */\n   405→async function addMusicJob(jobData) {\n   406→  const queue = getMusicQueue();\n   407→\n   408→  // Validate required fields\n   409→  if (!jobData.customerId) {\n   410→    throw new Error('customerId is required');\n   411→  }\n   412→\n   413→  // For scene-aware jobs, segments are required\n   414→  if (jobData.isSceneAware && (!jobData.segments || jobData.segments.length === 0)) {\n   415→    throw new Error('Transcript segments are required for scene-aware music');\n   416→  }\n   417→\n   418→  // Generate unique job ID\n   419→  const jobId = jobData.isSceneAware\n   420→    ? `scene_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`\n   421→    : generateJobId(jobData.customerId);\n   422→\n   423→  // Prepare job data with defaults\n   424→  const data = {\n   425→    jobId,\n   426→    customerId: jobData.customerId,\n   427→    youtubeUrl: jobData.youtubeUrl || null,\n   428→    prompt: jobData.prompt || '',\n   429→    duration: Math.min(Math.max(jobData.duration || 60, 30), 180), // Clamp 30-180\n   430→    mood: jobData.mood || 'neutral',\n   431→    instruments: jobData.instruments || [],\n   432→    step: JOB_STATUS.PENDING,\n   433→    createdAt: new Date().toISOString(),\n   434→    // Reference song metadata (populated during identification)\n   435→    referenceSong: jobData.referenceSong || null,\n   436→    // Generated music info (populated after generation)\n   437→    musicResult: null,\n   438→    // Scene-aware specific data\n   439→    isSceneAware: !!jobData.isSceneAware,\n   440→    segments: jobData.isSceneAware ? jobData.segments : null,\n   441→    sceneContext: null  // Populated during scene analysis\n   442→  };\n   443→\n   444→  // Add to queue\n   445→  await queue.add('generate', data, {\n   446→    jobId,\n   447→    priority: 0 // Normal priority\n   448→  });\n   449→\n   450→  return {\n   451→    jobId,\n   452→    status: JOB_STATUS.PENDING,\n   453→    isSceneAware: data.isSceneAware,\n   454→    estimatedTime: data.isSceneAware ? '4-6 minutes' : '3-5 minutes'\n   455→  };\n   456→}\n   457→\n   458→/**\n   459→ * Get job status by job ID\n   460→ * @param {string} jobId - Job ID\n   461→ * @returns {Promise<Object|null>} Job status or null if not found\n   462→ */\n   463→async function getJobStatus(jobId) {\n   464→  const queue = getMusicQueue();\n   465→\n   466→  const job = await queue.getJob(jobId);\n   467→\n   468→  if (!job) {\n   469→    return null;\n   470→  }\n   471→\n   472→  const state = await job.getState();\n   473→  const progress = job.progress || 0;\n   474→\n   475→  return {\n   476→    jobId: job.id,\n   477→    status: job.data.step || state,\n   478→    progress,\n   479→    isSceneAware: job.data.isSceneAware || false,\n   480→    data: {\n   481→      customerId: job.data.customerId,\n   482→      youtubeUrl: job.data.youtubeUrl,\n   483→      prompt: job.data.prompt,\n   484→      duration: job.data.duration,\n   485→      mood: job.data.mood,\n   486→      instruments: job.data.instruments,\n   487→      referenceSong: job.data.referenceSong,\n   488→      musicResult: job.data.musicResult,\n   489→      // Scene-aware context (if applicable)\n   490→      sceneContext: job.data.sceneContext || null\n   491→    },\n   492→    createdAt: job.data.createdAt,\n   493→    processedAt: job.processedOn ? new Date(job.processedOn).toISOString() : null,\n   494→    completedAt: job.finishedOn ? new Date(job.finishedOn).toISOString() : null,\n   495→    failedReason: job.failedReason || null,\n   496→    attemptsMade: job.attemptsMade || 0\n   497→  };\n   498→}\n   499→\n   500→/**\n   501→ * Get all jobs for a customer\n   502→ * @param {string} customerId - Stripe customer ID\n   503→ * @param {Object} options - Pagination options\n   504→ * @param {number} options.limit - Max jobs to return (default 50)\n   505→ * @param {number} options.offset - Offset for pagination (default 0)\n   506→ * @returns {Promise<Object[]>} Array of job statuses\n   507→ */\n   508→async function getCustomerJobs(customerId, options = {}) {\n   509→  const queue = getMusicQueue();\n   510→  const limit = options.limit || 50;\n   511→  const offset = options.offset || 0;\n   512→\n   513→  // Get all job types\n   514→  const [completed, active, waiting, delayed, failed] = await Promise.all([\n   515→    queue.getCompleted(0, 1000),\n   516→    queue.getActive(),\n   517→    queue.getWaiting(),\n   518→    queue.getDelayed(),\n   519→    queue.getFailed(0, 100)\n   520→  ]);\n   521→\n   522→  // Combine and filter by customer\n   523→  const allJobs = [...completed, ...active, ...waiting, ...delayed, ...failed];\n   524→  const customerJobs = allJobs\n   525→    .filter(job => job.data.customerId === customerId)\n   526→    .sort((a, b) => new Date(b.data.createdAt) - new Date(a.data.createdAt));\n   527→\n   528→  // Apply pagination\n   529→  const paginatedJobs = customerJobs.slice(offset, offset + limit);\n   530→\n   531→  // Format results\n   532→  return Promise.all(paginatedJobs.map(async job => {\n   533→    const state = await job.getState();\n   534→    return {\n   535→      jobId: job.id,\n   536→      status: job.data.step || state,\n   537→      progress: job.progress || 0,\n   538→      title: job.data.musicResult?.title || `Generated Music - ${job.data.mood}`,\n   539→      duration: job.data.duration,\n   540→      mood: job.data.mood,\n   541→      createdAt: job.data.createdAt,\n   542→      completedAt: job.finishedOn ? new Date(job.finishedOn).toISOString() : null,\n   543→      failedReason: job.failedReason || null\n   544→    };\n   545→  }));\n   546→}\n   547→\n   548→/**\n   549→ * Cancel a pending job\n   550→ * @param {string} jobId - Job ID\n   551→ * @returns {Promise<{success: boolean}>}\n   552→ */\n   553→async function cancelJob(jobId) {\n   554→  const queue = getMusicQueue();\n   555→\n   556→  const job = await queue.getJob(jobId);\n   557→\n   558→  if (!job) {\n   559→    throw new Error(`Job ${jobId} not found`);\n   560→  }\n   561→\n   562→  const state = await job.getState();\n   563→\n   564→  if (state === 'active') {\n   565→    throw new Error('Cannot cancel job that is already processing');\n   566→  }\n   567→\n   568→  if (state === 'completed' || state === 'failed') {\n   569→    throw new Error(`Cannot cancel job that is already ${state}`);\n   570→  }\n   571→\n   572→  await job.remove();\n   573→\n   574→  return { success: true };\n   575→}\n   576→\n   577→/**\n   578→ * Retry a failed job\n   579→ * @param {string} jobId - Job ID\n   580→ * @returns {Promise<{success: boolean}>}\n   581→ */\n   582→async function retryJob(jobId) {\n   583→  const queue = getMusicQueue();\n   584→\n   585→  const job = await queue.getJob(jobId);\n   586→\n   587→  if (!job) {\n   588→    throw new Error(`Job ${jobId} not found`);\n   589→  }\n   590→\n   591→  const state = await job.getState();\n   592→\n   593→  if (state !== 'failed') {\n   594→    throw new Error(`Can only retry failed jobs, current state: ${state}`);\n   595→  }\n   596→\n   597→  await job.retry();\n   598→\n   599→  return { success: true };\n   600→}\n   601→\n   602→/**\n   603→ * Update job data (used internally by worker)\n   604→ * @param {string} jobId - Job ID\n   605→ * @param {Object} updates - Data updates\n   606→ * @returns {Promise<void>}\n   607→ */\n   608→async function updateJobData(jobId, updates) {\n   609→  const queue = getMusicQueue();\n   610→\n   611→  const job = await queue.getJob(jobId);\n   612→\n   613→  if (!job) {\n   614→    throw new Error(`Job ${jobId} not found`);\n   615→  }\n   616→\n   617→  await job.updateData({\n   618→    ...job.data,\n   619→    ...updates\n   620→  });\n   621→}\n   622→\n   623→/**\n   624→ * Get queue statistics\n   625→ * @returns {Promise<Object>} Queue stats\n   626→ */\n   627→async function getQueueStats() {\n   628→  const queue = getMusicQueue();\n   629→\n   630→  const [waiting, active, completed, failed, delayed] = await Promise.all([\n   631→    queue.getWaitingCount(),\n   632→    queue.getActiveCount(),\n   633→    queue.getCompletedCount(),\n   634→    queue.getFailedCount(),\n   635→    queue.getDelayedCount()\n   636→  ]);\n   637→\n   638→  return {\n   639→    waiting,\n   640→    active,\n   641→    completed,\n   642→    failed,\n   643→    delayed,\n   644→    total: waiting + active + completed + failed + delayed\n   645→  };\n   646→}\n   647→\n   648→/**\n   649→ * Close queue connections (for graceful shutdown)\n   650→ */\n   651→async function closeQueue() {\n   652→  if (musicQueue) {\n   653→    await musicQueue.close();\n   654→    musicQueue = null;\n   655→  }\n   656→  if (musicWorker) {\n   657→    await musicWorker.close();\n   658→    musicWorker = null;\n   659→  }\n   660→}\n   661→\n   662→/**\n   663→ * Add a new variations job to the queue\n   664→ * Generates 3 variations in parallel for user selection\n   665→ * @param {Object} jobData - Job data\n   666→ * @param {string} jobData.customerId - Stripe customer ID\n   667→ * @param {string} jobData.prompt - Text prompt for music generation\n   668→ * @param {number} jobData.duration - Duration in seconds (30-180)\n   669→ * @param {string} jobData.mood - Mood setting\n   670→ * @param {string[]} jobData.instruments - Preferred instruments\n   671→ * @param {Object} jobData.referenceSong - Reference song info (optional)\n   672→ * @returns {Promise<{jobId: string, status: string}>}\n   673→ */\n   674→async function addVariationsJob(jobData) {\n   675→  const queue = getMusicQueue();\n   676→\n   677→  // Validate required fields\n   678→  if (!jobData.customerId) {\n   679→    throw new Error('customerId is required');\n   680→  }\n   681→\n   682→  // Generate unique job ID with variations prefix\n   683→  const jobId = `variations_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n   684→\n   685→  // Prepare job data with defaults\n   686→  const data = {\n   687→    jobId,\n   688→    customerId: jobData.customerId,\n   689→    isVariations: true,  // Flag to identify this as a variations job\n   690→    prompt: jobData.prompt || '',\n   691→    duration: Math.min(Math.max(jobData.duration || 60, 30), 180),\n   692→    mood: jobData.mood || 'neutral',\n   693→    instruments: jobData.instruments || [],\n   694→    referenceSong: jobData.referenceSong || null,\n   695→    step: JOB_STATUS.PENDING,\n   696→    createdAt: new Date().toISOString(),\n   697→    // Variations-specific data\n   698→    variations: [],  // Will be populated during generation\n   699→    variationProgress: [0, 0, 0],  // Progress for each variation\n   700→    selectedVariation: null,  // Index of user-selected variation\n   701→    // Generated music info (populated after selection)\n   702→    musicResult: null\n   703→  };\n   704→\n   705→  // Add to queue with higher priority than regular jobs\n   706→  await queue.add('generate-variations', data, {\n   707→    jobId,\n   708→    priority: 1  // Higher priority than regular jobs\n   709→  });\n   710→\n   711→  return {\n   712→    jobId,\n   713→    status: JOB_STATUS.PENDING,\n   714→    isVariations: true,\n   715→    estimatedTime: '5-8 minutes'  // Longer due to 3 parallel generations\n   716→  };\n   717→}\n   718→\n   719→/**\n   720→ * Get variations job status with detailed progress\n   721→ * @param {string} jobId - Job ID\n   722→ * @returns {Promise<Object|null>} Job status with variations info\n   723→ */\n   724→async function getVariationsJobStatus(jobId) {\n   725→  const queue = getMusicQueue();\n   726→\n   727→  const job = await queue.getJob(jobId);\n   728→\n   729→  if (!job) {\n   730→    return null;\n   731→  }\n   732→\n   733→  const state = await job.getState();\n   734→\n   735→  return {\n   736→    jobId: job.id,\n   737→    isVariations: true,\n   738→    status: job.data.step || state,\n   739→    progress: job.progress || 0,\n   740→    variationProgress: job.data.variationProgress || [0, 0, 0],\n   741→    variations: (job.data.variations || []).map(v => ({\n   742→      variationIndex: v.variationIndex,\n   743→      variationName: v.variationName,\n   744→      promptDescription: v.promptDescription,\n   745→      status: v.failed ? 'failed' : 'completed',\n   746→      error: v.error || null,\n   747→      previewUrl: v.previewUrl || null,\n   748→      duration: v.duration || null\n   749→    })),\n   750→    selectedVariation: job.data.selectedVariation,\n   751→    data: {\n   752→      customerId: job.data.customerId,\n   753→      prompt: job.data.prompt,\n   754→      duration: job.data.duration,\n   755→      mood: job.data.mood,\n   756→      instruments: job.data.instruments,\n   757→      musicResult: job.data.musicResult\n   758→    },\n   759→    createdAt: job.data.createdAt,\n   760→    processedAt: job.processedOn ? new Date(job.processedOn).toISOString() : null,\n   761→    completedAt: job.finishedOn ? new Date(job.finishedOn).toISOString() : null,\n   762→    failedReason: job.failedReason || null,\n   763→    attemptsMade: job.attemptsMade || 0\n   764→  };\n   765→}\n   766→\n   767→/**\n   768→ * Select a variation from a completed variations job\n   769→ * @param {string} jobId - Job ID\n   770→ * @param {number} variationIndex - Index of variation to select (0-2)\n   771→ * @param {string} customerId - Customer ID for ownership verification\n   772→ * @returns {Promise<Object>} Selected variation info\n   773→ */\n   774→async function selectVariation(jobId, variationIndex, customerId) {\n   775→  const queue = getMusicQueue();\n   776→\n   777→  const job = await queue.getJob(jobId);\n   778→\n   779→  if (!job) {\n   780→    throw new Error(`Job ${jobId} not found`);\n   781→  }\n   782→\n   783→  // Verify ownership\n   784→  if (job.data.customerId !== customerId) {\n   785→    throw new Error('Not authorized to access this job');\n   786→  }\n   787→\n   788→  // Check if variations are ready\n   789→  if (!job.data.variations || job.data.variations.length === 0) {\n   790→    throw new Error('Variations not yet generated');\n   791→  }\n   792→\n   793→  // Validate variation index\n   794→  if (variationIndex < 0 || variationIndex >= job.data.variations.length) {\n   795→    throw new Error(`Invalid variation index: ${variationIndex}`);\n   796→  }\n   797→\n   798→  // Check if selected variation failed\n   799→  const selectedVar = job.data.variations[variationIndex];\n   800→  if (selectedVar.failed) {\n   801→    throw new Error(`Selected variation failed: ${selectedVar.error}`);\n   802→  }\n   803→\n   804→  // Update job with selection\n   805→  await job.updateData({\n   806→    ...job.data,\n   807→    selectedVariation: variationIndex,\n   808→    step: JOB_STATUS.COMPLETED,\n   809→    musicResult: {\n   810→      title: selectedVar.title,\n   811→      taskId: selectedVar.taskId,\n   812→      duration: selectedVar.duration,\n   813→      audioUrl: selectedVar.audioUrl,\n   814→      previewUrl: selectedVar.previewUrl,\n   815→      variationName: selectedVar.variationName,\n   816→      variationIndex: selectedVar.variationIndex\n   817→    }\n   818→  });\n   819→\n   820→  return {\n   821→    success: true,\n   822→    selectedVariation: variationIndex,\n   823→    variationName: selectedVar.variationName,\n   824→    musicResult: {\n   825→      title: selectedVar.title,\n   826→      duration: selectedVar.duration,\n   827→      audioUrl: selectedVar.audioUrl,\n   828→      previewUrl: selectedVar.previewUrl\n   829→    }\n   830→  };\n   831→}\n   832→\n   833→/**\n   834→ * Update variation progress (used internally during generation)\n   835→ * @param {string} jobId - Job ID\n   836→ * @param {number} variationIndex - Variation index (0-2)\n   837→ * @param {number} progress - Progress percentage (0-100)\n   838→ * @param {string} status - Current status\n   839→ */\n   840→async function updateVariationProgress(jobId, variationIndex, progress, status) {\n   841→  const queue = getMusicQueue();\n   842→\n   843→  const job = await queue.getJob(jobId);\n   844→\n   845→  if (!job) {\n   846→    throw new Error(`Job ${jobId} not found`);\n   847→  }\n   848→\n   849→  const variationProgress = job.data.variationProgress || [0, 0, 0];\n   850→  variationProgress[variationIndex] = progress;\n   851→\n   852→  // Calculate overall progress (average of all variations)\n   853→  const overallProgress = Math.floor(\n   854→    variationProgress.reduce((a, b) => a + b, 0) / 3\n   855→  );\n   856→\n   857→  await job.updateData({\n   858→    ...job.data,\n   859→    variationProgress,\n   860→    step: status === 'completed' ? JOB_STATUS.SELECTING : JOB_STATUS.GENERATING_VARIATIONS\n   861→  });\n   862→\n   863→  await job.updateProgress(overallProgress);\n   864→}\n   865→\n   866→/**\n   867→ * Store generated variations in job data\n   868→ * @param {string} jobId - Job ID\n   869→ * @param {Object[]} variations - Array of variation results\n   870→ */\n   871→async function storeVariations(jobId, variations) {\n   872→  const queue = getMusicQueue();\n   873→\n   874→  const job = await queue.getJob(jobId);\n   875→\n   876→  if (!job) {\n   877→    throw new Error(`Job ${jobId} not found`);\n   878→  }\n   879→\n   880→  const successCount = variations.filter(v => !v.failed).length;\n   881→\n   882→  await job.updateData({\n   883→    ...job.data,\n   884→    variations,\n   885→    step: successCount > 0 ? JOB_STATUS.SELECTING : JOB_STATUS.FAILED\n   886→  });\n   887→\n   888→  await job.updateProgress(successCount > 0 ? 95 : 100);\n   889→}\n   890→\n   891→module.exports = {\n   892→  JOB_STATUS,\n   893→  PROGRESS_MAP,\n   894→  getMusicQueue,\n   895→  getRedisConnection,\n   896→  generateJobId,\n   897→  addMusicJob,\n   898→  getJobStatus,\n   899→  getCustomerJobs,\n   900→  cancelJob,\n   901→  retryJob,\n   902→  updateJobData,\n   903→  getQueueStats,\n   904→  closeQueue,\n   905→  // Variations-specific exports\n   906→  addVariationsJob,\n   907→  getVariationsJobStatus,\n   908→  selectVariation,\n   909→  updateVariationProgress,\n   910→  storeVariations,\n   911→  // HIGH-006: Dead Letter Queue exports\n   912→  getDeadLetterQueue,\n   913→  moveToDeadLetterQueue,\n   914→  getDeadLetterJobs,\n   915→  recoverFromDeadLetterQueue,\n   916→  getDeadLetterQueueStats,\n   917→  isUnrecoverableError,\n   918→  DLQ_CONFIG\n   919→};\n   920→\n\n</system-reminder>\n"}]},"uuid":"ad3aacab-5131-4bb7-b283-0c9483952902","timestamp":"2026-01-12T01:30:35.373Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/musicQueue.js","content":"/**\n * Music Generation Job Queue Service\n * Uses BullMQ with Upstash Redis for reliable background processing\n *\n * HIGH-006: Added Dead Letter Queue (DLQ) for permanently failed jobs\n */\n\nconst { Queue } = require('bullmq');\n\n// Redis connection (lazy initialization)\nlet redisConnection = null;\nlet musicQueue = null;\nlet musicWorker = null;\nlet deadLetterQueue = null;\n\n// ============================================================================\n// HIGH-006: Dead Letter Queue Configuration\n// Jobs that fail after all retry attempts are moved here for inspection/recovery\n// ============================================================================\n\nconst DLQ_CONFIG = {\n  queueName: 'music-generation-dlq',\n  // Keep failed jobs in DLQ for 30 days\n  retentionDays: 30,\n  // Maximum DLQ jobs to keep\n  maxJobs: 10000\n};\n\n// Job statuses\nconst JOB_STATUS = {\n  PENDING: 'pending',\n  EXTRACTING: 'extracting',\n  IDENTIFYING: 'identifying',\n  GENERATING: 'generating',\n  UPLOADING: 'uploading',\n  COMPLETED: 'completed',\n  FAILED: 'failed',\n  // Variations-specific statuses\n  GENERATING_VARIATIONS: 'generating_variations',\n  SELECTING: 'selecting',  // Waiting for user to select a variation\n  // Scene-aware specific statuses\n  ANALYZING: 'analyzing'  // Analyzing transcript for scene context\n};\n\n// Progress percentages for each step\nconst PROGRESS_MAP = {\n  [JOB_STATUS.PENDING]: 0,\n  [JOB_STATUS.EXTRACTING]: 10,\n  [JOB_STATUS.IDENTIFYING]: 30,\n  [JOB_STATUS.GENERATING]: 60,\n  [JOB_STATUS.UPLOADING]: 90,\n  [JOB_STATUS.COMPLETED]: 100,\n  // Variations progress\n  [JOB_STATUS.GENERATING_VARIATIONS]: 50,\n  [JOB_STATUS.SELECTING]: 95,\n  // Scene-aware progress\n  [JOB_STATUS.ANALYZING]: 15\n};\n\n/**\n * Initialize Redis connection\n * Supports both Railway Redis (REDIS_URL) and Upstash Redis (UPSTASH_REDIS_URL)\n * @returns {Object} IORedis connection options\n */\nfunction getRedisConnection() {\n  if (!redisConnection) {\n    // Support both Railway Redis URL and Upstash Redis URL\n    const redisUrl = process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL;\n\n    if (!redisUrl) {\n      throw new Error('Missing REDIS_URL or UPSTASH_REDIS_URL environment variable');\n    }\n\n    // Parse Redis URL\n    const url = new URL(redisUrl);\n\n    redisConnection = {\n      host: url.hostname,\n      port: parseInt(url.port) || 6379,\n      password: url.password,\n      username: url.username || undefined,\n      tls: url.protocol === 'rediss:' ? {} : undefined,\n      maxRetriesPerRequest: null // Required for BullMQ workers\n    };\n    \n    console.log(`[Queue] Redis connection configured for ${url.hostname}:${url.port} (${url.protocol === 'rediss:' ? 'TLS' : 'plain'})`);\n  }\n  return redisConnection;\n}\n\n// ============================================================================\n// HIGH-006: Dead Letter Queue Functions\n// ============================================================================\n\n/**\n * Get or create the dead letter queue for permanently failed jobs\n * @returns {Queue} BullMQ Queue instance for DLQ\n */\nfunction getDeadLetterQueue() {\n  if (!deadLetterQueue) {\n    deadLetterQueue = new Queue(DLQ_CONFIG.queueName, {\n      connection: getRedisConnection(),\n      defaultJobOptions: {\n        // DLQ jobs don't retry - they're already failed\n        attempts: 1,\n        // Keep for inspection/debugging\n        removeOnComplete: {\n          age: DLQ_CONFIG.retentionDays * 24 * 3600,\n          count: DLQ_CONFIG.maxJobs\n        },\n        removeOnFail: false // Never auto-remove failed DLQ entries\n      }\n    });\n    console.log('[Queue] Dead Letter Queue initialized');\n  }\n  return deadLetterQueue;\n}\n\n/**\n * Move a permanently failed job to the Dead Letter Queue\n * Called by the worker when a job exhausts all retry attempts\n * @param {Object} job - The failed BullMQ job\n * @param {Error|string} error - The error that caused the failure\n * @returns {Promise<{dlqJobId: string}>}\n */\nasync function moveToDeadLetterQueue(job, error) {\n  const dlq = getDeadLetterQueue();\n  \n  const dlqJobId = `dlq_${job.id}_${Date.now()}`;\n  \n  const dlqData = {\n    // Original job metadata\n    originalJobId: job.id,\n    originalQueue: 'music-generation',\n    \n    // Copy of original job data\n    originalData: job.data,\n    \n    // Failure information\n    error: typeof error === 'string' ? error : error?.message || 'Unknown error',\n    errorStack: error?.stack || null,\n    failedAt: new Date().toISOString(),\n    attemptsMade: job.attemptsMade || 0,\n    \n    // Job history for debugging\n    processedAt: job.processedOn ? new Date(job.processedOn).toISOString() : null,\n    createdAt: job.data?.createdAt || null,\n    \n    // Recovery flags\n    canRetry: !isUnrecoverableError(error),\n    recovered: false,\n    recoveredAt: null,\n    recoveryNotes: null\n  };\n  \n  await dlq.add('failed-job', dlqData, {\n    jobId: dlqJobId\n  });\n  \n  console.log(`[DLQ] Job ${job.id} moved to dead letter queue as ${dlqJobId}`);\n  console.log(`[DLQ] Reason: ${dlqData.error}`);\n  \n  return { dlqJobId };\n}\n\n/**\n * Check if an error indicates an unrecoverable failure\n * @param {Error|string} error - The error to check\n * @returns {boolean}\n */\nfunction isUnrecoverableError(error) {\n  const message = typeof error === 'string' ? error : error?.message || '';\n  \n  const unrecoverablePatterns = [\n    /quota exceeded/i,\n    /invalid api key/i,\n    /authentication failed/i,\n    /insufficient credits/i,\n    /account suspended/i,\n    /content policy violation/i,\n    /customer not found/i,\n    /invalid customer/i\n  ];\n  \n  return unrecoverablePatterns.some(pattern => pattern.test(message));\n}\n\n/**\n * Get jobs from the Dead Letter Queue with pagination\n * @param {Object} options - Query options\n * @param {number} options.limit - Max jobs to return (default 50)\n * @param {number} options.offset - Offset for pagination (default 0)\n * @param {boolean} options.includeRecovered - Include already recovered jobs (default false)\n * @returns {Promise<{jobs: Object[], total: number}>}\n */\nasync function getDeadLetterJobs(options = {}) {\n  const dlq = getDeadLetterQueue();\n  const limit = options.limit || 50;\n  const offset = options.offset || 0;\n  const includeRecovered = options.includeRecovered || false;\n  \n  // Get waiting and completed jobs from DLQ\n  const [waiting, completed] = await Promise.all([\n    dlq.getWaiting(0, 1000),\n    dlq.getCompleted(0, 1000)\n  ]);\n  \n  // Combine and filter\n  let allJobs = [...waiting, ...completed];\n  \n  if (!includeRecovered) {\n    allJobs = allJobs.filter(job => !job.data.recovered);\n  }\n  \n  // Sort by failedAt descending (newest first)\n  allJobs.sort((a, b) => {\n    const aDate = new Date(a.data.failedAt || 0);\n    const bDate = new Date(b.data.failedAt || 0);\n    return bDate - aDate;\n  });\n  \n  const total = allJobs.length;\n  const paginatedJobs = allJobs.slice(offset, offset + limit);\n  \n  return {\n    jobs: paginatedJobs.map(job => ({\n      dlqJobId: job.id,\n      originalJobId: job.data.originalJobId,\n      customerId: job.data.originalData?.customerId,\n      error: job.data.error,\n      failedAt: job.data.failedAt,\n      attemptsMade: job.data.attemptsMade,\n      canRetry: job.data.canRetry,\n      recovered: job.data.recovered,\n      recoveredAt: job.data.recoveredAt,\n      // Include original job context\n      mood: job.data.originalData?.mood,\n      duration: job.data.originalData?.duration,\n      isSceneAware: job.data.originalData?.isSceneAware\n    })),\n    total,\n    limit,\n    offset\n  };\n}\n\n/**\n * Recover a job from the Dead Letter Queue by re-queueing it\n * @param {string} dlqJobId - Dead Letter Queue job ID\n * @param {Object} options - Recovery options\n * @param {string} options.notes - Recovery notes for audit trail\n * @returns {Promise<{success: boolean, newJobId: string}>}\n */\nasync function recoverFromDeadLetterQueue(dlqJobId, options = {}) {\n  const dlq = getDeadLetterQueue();\n  const mainQueue = getMusicQueue();\n  \n  const dlqJob = await dlq.getJob(dlqJobId);\n  \n  if (!dlqJob) {\n    throw new Error(`DLQ job ${dlqJobId} not found`);\n  }\n  \n  if (dlqJob.data.recovered) {\n    throw new Error(`DLQ job ${dlqJobId} has already been recovered`);\n  }\n  \n  if (!dlqJob.data.canRetry) {\n    throw new Error(`DLQ job ${dlqJobId} is marked as unrecoverable`);\n  }\n  \n  // Generate new job ID for the recovered job\n  const newJobId = `recovered_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n  \n  // Re-queue with original data\n  await mainQueue.add('generate', {\n    ...dlqJob.data.originalData,\n    jobId: newJobId,\n    recoveredFrom: dlqJobId,\n    step: JOB_STATUS.PENDING,\n    createdAt: new Date().toISOString()\n  }, {\n    jobId: newJobId,\n    priority: 0\n  });\n  \n  // Mark DLQ job as recovered\n  await dlqJob.updateData({\n    ...dlqJob.data,\n    recovered: true,\n    recoveredAt: new Date().toISOString(),\n    recoveryNotes: options.notes || null,\n    newJobId\n  });\n  \n  console.log(`[DLQ] Job ${dlqJobId} recovered as ${newJobId}`);\n  \n  return { success: true, newJobId };\n}\n\n/**\n * Get Dead Letter Queue statistics\n * @returns {Promise<Object>} DLQ stats\n */\nasync function getDeadLetterQueueStats() {\n  const dlq = getDeadLetterQueue();\n  \n  const [waiting, completed] = await Promise.all([\n    dlq.getWaiting(0, 10000),\n    dlq.getCompleted(0, 10000)\n  ]);\n  \n  const allJobs = [...waiting, ...completed];\n  \n  const stats = {\n    total: allJobs.length,\n    recoverable: 0,\n    unrecoverable: 0,\n    recovered: 0,\n    pending: 0,\n    oldestFailure: null,\n    newestFailure: null,\n    byError: {}\n  };\n  \n  for (const job of allJobs) {\n    if (job.data.recovered) {\n      stats.recovered++;\n    } else if (job.data.canRetry) {\n      stats.recoverable++;\n      stats.pending++;\n    } else {\n      stats.unrecoverable++;\n      stats.pending++;\n    }\n    \n    // Track error types\n    const errorKey = job.data.error?.substring(0, 50) || 'Unknown';\n    stats.byError[errorKey] = (stats.byError[errorKey] || 0) + 1;\n    \n    // Track oldest/newest\n    const failedAt = new Date(job.data.failedAt);\n    if (!stats.oldestFailure || failedAt < new Date(stats.oldestFailure)) {\n      stats.oldestFailure = job.data.failedAt;\n    }\n    if (!stats.newestFailure || failedAt > new Date(stats.newestFailure)) {\n      stats.newestFailure = job.data.failedAt;\n    }\n  }\n  \n  return stats;\n}\n\n/**\n * Get or create the music generation queue\n * @returns {Queue} BullMQ Queue instance\n */\nfunction getMusicQueue() {\n  if (!musicQueue) {\n    musicQueue = new Queue('music-generation', {\n      connection: getRedisConnection(),\n      defaultJobOptions: {\n        attempts: 3,\n        backoff: {\n          type: 'exponential',\n          delay: 5000 // Start with 5s, then 10s, then 20s\n        },\n        removeOnComplete: {\n          age: 24 * 3600, // Keep completed jobs for 24 hours\n          count: 1000 // Keep max 1000 completed jobs\n        },\n        removeOnFail: {\n          age: 7 * 24 * 3600 // Keep failed jobs for 7 days\n        }\n      }\n    });\n  }\n  return musicQueue;\n}\n\n/**\n * Generate a unique job ID\n * @param {string} customerId - Stripe customer ID\n * @returns {string} Unique job ID\n */\nfunction generateJobId(_customerId) {\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 8);\n  return `music_${timestamp}_${random}`;\n}\n\n/**\n * Add a new music generation job to the queue\n * @param {Object} jobData - Job data\n * @param {string} jobData.customerId - Stripe customer ID\n * @param {string} jobData.youtubeUrl - YouTube URL for reference song (optional)\n * @param {string} jobData.prompt - Text prompt for music generation\n * @param {number} jobData.duration - Duration in seconds (30-180)\n * @param {string} jobData.mood - Mood setting\n * @param {string[]} jobData.instruments - Preferred instruments\n * @param {boolean} jobData.isSceneAware - Whether to use scene analysis\n * @param {Object[]} jobData.segments - Transcript segments for scene analysis\n * @returns {Promise<{jobId: string, status: string}>}\n */\nasync function addMusicJob(jobData) {\n  const queue = getMusicQueue();\n\n  // Validate required fields\n  if (!jobData.customerId) {\n    throw new Error('customerId is required');\n  }\n\n  // For scene-aware jobs, segments are required\n  if (jobData.isSceneAware && (!jobData.segments || jobData.segments.length === 0)) {\n    throw new Error('Transcript segments are required for scene-aware music');\n  }\n\n  // Generate unique job ID\n  const jobId = jobData.isSceneAware\n    ? `scene_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`\n    : generateJobId(jobData.customerId);\n\n  // Prepare job data with defaults\n  const data = {\n    jobId,\n    customerId: jobData.customerId,\n    youtubeUrl: jobData.youtubeUrl || null,\n    prompt: jobData.prompt || '',\n    duration: Math.min(Math.max(jobData.duration || 60, 30), 180), // Clamp 30-180\n    mood: jobData.mood || 'neutral',\n    instruments: jobData.instruments || [],\n    step: JOB_STATUS.PENDING,\n    createdAt: new Date().toISOString(),\n    // Reference song metadata (populated during identification)\n    referenceSong: jobData.referenceSong || null,\n    // Generated music info (populated after generation)\n    musicResult: null,\n    // Scene-aware specific data\n    isSceneAware: !!jobData.isSceneAware,\n    segments: jobData.isSceneAware ? jobData.segments : null,\n    sceneContext: null  // Populated during scene analysis\n  };\n\n  // Add to queue\n  await queue.add('generate', data, {\n    jobId,\n    priority: 0 // Normal priority\n  });\n\n  return {\n    jobId,\n    status: JOB_STATUS.PENDING,\n    isSceneAware: data.isSceneAware,\n    estimatedTime: data.isSceneAware ? '4-6 minutes' : '3-5 minutes'\n  };\n}\n\n/**\n * Get job status by job ID\n * @param {string} jobId - Job ID\n * @returns {Promise<Object|null>} Job status or null if not found\n */\nasync function getJobStatus(jobId) {\n  const queue = getMusicQueue();\n\n  const job = await queue.getJob(jobId);\n\n  if (!job) {\n    return null;\n  }\n\n  const state = await job.getState();\n  const progress = job.progress || 0;\n\n  return {\n    jobId: job.id,\n    status: job.data.step || state,\n    progress,\n    isSceneAware: job.data.isSceneAware || false,\n    data: {\n      customerId: job.data.customerId,\n      youtubeUrl: job.data.youtubeUrl,\n      prompt: job.data.prompt,\n      duration: job.data.duration,\n      mood: job.data.mood,\n      instruments: job.data.instruments,\n      referenceSong: job.data.referenceSong,\n      musicResult: job.data.musicResult,\n      // Scene-aware context (if applicable)\n      sceneContext: job.data.sceneContext || null\n    },\n    createdAt: job.data.createdAt,\n    processedAt: job.processedOn ? new Date(job.processedOn).toISOString() : null,\n    completedAt: job.finishedOn ? new Date(job.finishedOn).toISOString() : null,\n    failedReason: job.failedReason || null,\n    attemptsMade: job.attemptsMade || 0\n  };\n}\n\n/**\n * Get all jobs for a customer\n * @param {string} customerId - Stripe customer ID\n * @param {Object} options - Pagination options\n * @param {number} options.limit - Max jobs to return (default 50)\n * @param {number} options.offset - Offset for pagination (default 0)\n * @returns {Promise<Object[]>} Array of job statuses\n */\nasync function getCustomerJobs(customerId, options = {}) {\n  const queue = getMusicQueue();\n  const limit = options.limit || 50;\n  const offset = options.offset || 0;\n\n  // Get all job types\n  const [completed, active, waiting, delayed, failed] = await Promise.all([\n    queue.getCompleted(0, 1000),\n    queue.getActive(),\n    queue.getWaiting(),\n    queue.getDelayed(),\n    queue.getFailed(0, 100)\n  ]);\n\n  // Combine and filter by customer\n  const allJobs = [...completed, ...active, ...waiting, ...delayed, ...failed];\n  const customerJobs = allJobs\n    .filter(job => job.data.customerId === customerId)\n    .sort((a, b) => new Date(b.data.createdAt) - new Date(a.data.createdAt));\n\n  // Apply pagination\n  const paginatedJobs = customerJobs.slice(offset, offset + limit);\n\n  // Format results\n  return Promise.all(paginatedJobs.map(async job => {\n    const state = await job.getState();\n    return {\n      jobId: job.id,\n      status: job.data.step || state,\n      progress: job.progress || 0,\n      title: job.data.musicResult?.title || `Generated Music - ${job.data.mood}`,\n      duration: job.data.duration,\n      mood: job.data.mood,\n      createdAt: job.data.createdAt,\n      completedAt: job.finishedOn ? new Date(job.finishedOn).toISOString() : null,\n      failedReason: job.failedReason || null\n    };\n  }));\n}\n\n/**\n * Cancel a pending job\n * @param {string} jobId - Job ID\n * @returns {Promise<{success: boolean}>}\n */\nasync function cancelJob(jobId) {\n  const queue = getMusicQueue();\n\n  const job = await queue.getJob(jobId);\n\n  if (!job) {\n    throw new Error(`Job ${jobId} not found`);\n  }\n\n  const state = await job.getState();\n\n  if (state === 'active') {\n    throw new Error('Cannot cancel job that is already processing');\n  }\n\n  if (state === 'completed' || state === 'failed') {\n    throw new Error(`Cannot cancel job that is already ${state}`);\n  }\n\n  await job.remove();\n\n  return { success: true };\n}\n\n/**\n * Retry a failed job\n * @param {string} jobId - Job ID\n * @returns {Promise<{success: boolean}>}\n */\nasync function retryJob(jobId) {\n  const queue = getMusicQueue();\n\n  const job = await queue.getJob(jobId);\n\n  if (!job) {\n    throw new Error(`Job ${jobId} not found`);\n  }\n\n  const state = await job.getState();\n\n  if (state !== 'failed') {\n    throw new Error(`Can only retry failed jobs, current state: ${state}`);\n  }\n\n  await job.retry();\n\n  return { success: true };\n}\n\n/**\n * Update job data (used internally by worker)\n * @param {string} jobId - Job ID\n * @param {Object} updates - Data updates\n * @returns {Promise<void>}\n */\nasync function updateJobData(jobId, updates) {\n  const queue = getMusicQueue();\n\n  const job = await queue.getJob(jobId);\n\n  if (!job) {\n    throw new Error(`Job ${jobId} not found`);\n  }\n\n  await job.updateData({\n    ...job.data,\n    ...updates\n  });\n}\n\n/**\n * Get queue statistics\n * @returns {Promise<Object>} Queue stats\n */\nasync function getQueueStats() {\n  const queue = getMusicQueue();\n\n  const [waiting, active, completed, failed, delayed] = await Promise.all([\n    queue.getWaitingCount(),\n    queue.getActiveCount(),\n    queue.getCompletedCount(),\n    queue.getFailedCount(),\n    queue.getDelayedCount()\n  ]);\n\n  return {\n    waiting,\n    active,\n    completed,\n    failed,\n    delayed,\n    total: waiting + active + completed + failed + delayed\n  };\n}\n\n/**\n * Close queue connections (for graceful shutdown)\n */\nasync function closeQueue() {\n  if (musicQueue) {\n    await musicQueue.close();\n    musicQueue = null;\n  }\n  if (musicWorker) {\n    await musicWorker.close();\n    musicWorker = null;\n  }\n}\n\n/**\n * Add a new variations job to the queue\n * Generates 3 variations in parallel for user selection\n * @param {Object} jobData - Job data\n * @param {string} jobData.customerId - Stripe customer ID\n * @param {string} jobData.prompt - Text prompt for music generation\n * @param {number} jobData.duration - Duration in seconds (30-180)\n * @param {string} jobData.mood - Mood setting\n * @param {string[]} jobData.instruments - Preferred instruments\n * @param {Object} jobData.referenceSong - Reference song info (optional)\n * @returns {Promise<{jobId: string, status: string}>}\n */\nasync function addVariationsJob(jobData) {\n  const queue = getMusicQueue();\n\n  // Validate required fields\n  if (!jobData.customerId) {\n    throw new Error('customerId is required');\n  }\n\n  // Generate unique job ID with variations prefix\n  const jobId = `variations_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n\n  // Prepare job data with defaults\n  const data = {\n    jobId,\n    customerId: jobData.customerId,\n    isVariations: true,  // Flag to identify this as a variations job\n    prompt: jobData.prompt || '',\n    duration: Math.min(Math.max(jobData.duration || 60, 30), 180),\n    mood: jobData.mood || 'neutral',\n    instruments: jobData.instruments || [],\n    referenceSong: jobData.referenceSong || null,\n    step: JOB_STATUS.PENDING,\n    createdAt: new Date().toISOString(),\n    // Variations-specific data\n    variations: [],  // Will be populated during generation\n    variationProgress: [0, 0, 0],  // Progress for each variation\n    selectedVariation: null,  // Index of user-selected variation\n    // Generated music info (populated after selection)\n    musicResult: null\n  };\n\n  // Add to queue with higher priority than regular jobs\n  await queue.add('generate-variations', data, {\n    jobId,\n    priority: 1  // Higher priority than regular jobs\n  });\n\n  return {\n    jobId,\n    status: JOB_STATUS.PENDING,\n    isVariations: true,\n    estimatedTime: '5-8 minutes'  // Longer due to 3 parallel generations\n  };\n}\n\n/**\n * Get variations job status with detailed progress\n * @param {string} jobId - Job ID\n * @returns {Promise<Object|null>} Job status with variations info\n */\nasync function getVariationsJobStatus(jobId) {\n  const queue = getMusicQueue();\n\n  const job = await queue.getJob(jobId);\n\n  if (!job) {\n    return null;\n  }\n\n  const state = await job.getState();\n\n  return {\n    jobId: job.id,\n    isVariations: true,\n    status: job.data.step || state,\n    progress: job.progress || 0,\n    variationProgress: job.data.variationProgress || [0, 0, 0],\n    variations: (job.data.variations || []).map(v => ({\n      variationIndex: v.variationIndex,\n      variationName: v.variationName,\n      promptDescription: v.promptDescription,\n      status: v.failed ? 'failed' : 'completed',\n      error: v.error || null,\n      previewUrl: v.previewUrl || null,\n      duration: v.duration || null\n    })),\n    selectedVariation: job.data.selectedVariation,\n    data: {\n      customerId: job.data.customerId,\n      prompt: job.data.prompt,\n      duration: job.data.duration,\n      mood: job.data.mood,\n      instruments: job.data.instruments,\n      musicResult: job.data.musicResult\n    },\n    createdAt: job.data.createdAt,\n    processedAt: job.processedOn ? new Date(job.processedOn).toISOString() : null,\n    completedAt: job.finishedOn ? new Date(job.finishedOn).toISOString() : null,\n    failedReason: job.failedReason || null,\n    attemptsMade: job.attemptsMade || 0\n  };\n}\n\n/**\n * Select a variation from a completed variations job\n * @param {string} jobId - Job ID\n * @param {number} variationIndex - Index of variation to select (0-2)\n * @param {string} customerId - Customer ID for ownership verification\n * @returns {Promise<Object>} Selected variation info\n */\nasync function selectVariation(jobId, variationIndex, customerId) {\n  const queue = getMusicQueue();\n\n  const job = await queue.getJob(jobId);\n\n  if (!job) {\n    throw new Error(`Job ${jobId} not found`);\n  }\n\n  // Verify ownership\n  if (job.data.customerId !== customerId) {\n    throw new Error('Not authorized to access this job');\n  }\n\n  // Check if variations are ready\n  if (!job.data.variations || job.data.variations.length === 0) {\n    throw new Error('Variations not yet generated');\n  }\n\n  // Validate variation index\n  if (variationIndex < 0 || variationIndex >= job.data.variations.length) {\n    throw new Error(`Invalid variation index: ${variationIndex}`);\n  }\n\n  // Check if selected variation failed\n  const selectedVar = job.data.variations[variationIndex];\n  if (selectedVar.failed) {\n    throw new Error(`Selected variation failed: ${selectedVar.error}`);\n  }\n\n  // Update job with selection\n  await job.updateData({\n    ...job.data,\n    selectedVariation: variationIndex,\n    step: JOB_STATUS.COMPLETED,\n    musicResult: {\n      title: selectedVar.title,\n      taskId: selectedVar.taskId,\n      duration: selectedVar.duration,\n      audioUrl: selectedVar.audioUrl,\n      previewUrl: selectedVar.previewUrl,\n      variationName: selectedVar.variationName,\n      variationIndex: selectedVar.variationIndex\n    }\n  });\n\n  return {\n    success: true,\n    selectedVariation: variationIndex,\n    variationName: selectedVar.variationName,\n    musicResult: {\n      title: selectedVar.title,\n      duration: selectedVar.duration,\n      audioUrl: selectedVar.audioUrl,\n      previewUrl: selectedVar.previewUrl\n    }\n  };\n}\n\n/**\n * Update variation progress (used internally during generation)\n * @param {string} jobId - Job ID\n * @param {number} variationIndex - Variation index (0-2)\n * @param {number} progress - Progress percentage (0-100)\n * @param {string} status - Current status\n */\nasync function updateVariationProgress(jobId, variationIndex, progress, status) {\n  const queue = getMusicQueue();\n\n  const job = await queue.getJob(jobId);\n\n  if (!job) {\n    throw new Error(`Job ${jobId} not found`);\n  }\n\n  const variationProgress = job.data.variationProgress || [0, 0, 0];\n  variationProgress[variationIndex] = progress;\n\n  // Calculate overall progress (average of all variations)\n  const overallProgress = Math.floor(\n    variationProgress.reduce((a, b) => a + b, 0) / 3\n  );\n\n  await job.updateData({\n    ...job.data,\n    variationProgress,\n    step: status === 'completed' ? JOB_STATUS.SELECTING : JOB_STATUS.GENERATING_VARIATIONS\n  });\n\n  await job.updateProgress(overallProgress);\n}\n\n/**\n * Store generated variations in job data\n * @param {string} jobId - Job ID\n * @param {Object[]} variations - Array of variation results\n */\nasync function storeVariations(jobId, variations) {\n  const queue = getMusicQueue();\n\n  const job = await queue.getJob(jobId);\n\n  if (!job) {\n    throw new Error(`Job ${jobId} not found`);\n  }\n\n  const successCount = variations.filter(v => !v.failed).length;\n\n  await job.updateData({\n    ...job.data,\n    variations,\n    step: successCount > 0 ? JOB_STATUS.SELECTING : JOB_STATUS.FAILED\n  });\n\n  await job.updateProgress(successCount > 0 ? 95 : 100);\n}\n\nmodule.exports = {\n  JOB_STATUS,\n  PROGRESS_MAP,\n  getMusicQueue,\n  getRedisConnection,\n  generateJobId,\n  addMusicJob,\n  getJobStatus,\n  getCustomerJobs,\n  cancelJob,\n  retryJob,\n  updateJobData,\n  getQueueStats,\n  closeQueue,\n  // Variations-specific exports\n  addVariationsJob,\n  getVariationsJobStatus,\n  selectVariation,\n  updateVariationProgress,\n  storeVariations,\n  // HIGH-006: Dead Letter Queue exports\n  getDeadLetterQueue,\n  moveToDeadLetterQueue,\n  getDeadLetterJobs,\n  recoverFromDeadLetterQueue,\n  getDeadLetterQueueStats,\n  isUnrecoverableError,\n  DLQ_CONFIG\n};\n","numLines":920,"startLine":1,"totalLines":920}}}
{"parentUuid":"ad3aacab-5131-4bb7-b283-0c9483952902","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_012sNK1ZMZNEfbZBjQyriUDt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BuVY72B1yU1i9yonWf35qg","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/workers/musicWorker.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3959,"cache_creation_input_tokens":11531,"cache_read_input_tokens":27998,"cache_creation":{"ephemeral_5m_input_tokens":11531,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CX2crtY9XiyKs6qcVzEvq","type":"assistant","uuid":"6cf43eb7-4d49-458d-80f0-bf3168b677a9","timestamp":"2026-01-12T01:30:38.646Z"}
{"parentUuid":"6cf43eb7-4d49-458d-80f0-bf3168b677a9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_012sNK1ZMZNEfbZBjQyriUDt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ME1LNhBT3EArzQRqGfhYx6","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3959,"cache_creation_input_tokens":11531,"cache_read_input_tokens":27998,"cache_creation":{"ephemeral_5m_input_tokens":11531,"ephemeral_1h_input_tokens":0},"output_tokens":125,"service_tier":"standard"}},"requestId":"req_011CX2crtY9XiyKs6qcVzEvq","type":"assistant","uuid":"766083b5-6ef0-402c-b0b1-a0cd5bab12f3","timestamp":"2026-01-12T01:30:39.072Z"}
{"parentUuid":"766083b5-6ef0-402c-b0b1-a0cd5bab12f3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BuVY72B1yU1i9yonWf35qg","type":"tool_result","content":"     1→/**\n     2→ * Music Generation Background Worker\n     3→ * Processes music generation jobs from the BullMQ queue\n     4→ *\n     5→ * HIGH-006: Integrated with Dead Letter Queue for permanently failed jobs\n     6→ */\n     7→\n     8→const { Worker, UnrecoverableError } = require('bullmq');\n     9→const {\n    10→  getRedisConnection,\n    11→  JOB_STATUS,\n    12→  PROGRESS_MAP,\n    13→  moveToDeadLetterQueue // HIGH-006: Import DLQ function\n    14→} = require('../services/musicQueue');\n    15→\n    16→// Lazy import services (will be implemented in later phases)\n    17→let songIdentification = null;\n    18→let musicGeneration = null;\n    19→let r2Storage = null;\n    20→let sceneAnalysis = null;\n    21→\n    22→/**\n    23→ * Initialize worker dependencies\n    24→ */\n    25→async function initDependencies() {\n    26→  try {\n    27→    r2Storage = require('../services/r2Storage');\n    28→  } catch (e) {\n    29→    console.warn('r2Storage not available:', e.message);\n    30→  }\n    31→\n    32→  try {\n    33→    songIdentification = require('../services/songIdentification');\n    34→  } catch (e) {\n    35→    console.warn('songIdentification not available:', e.message);\n    36→  }\n    37→\n    38→  try {\n    39→    musicGeneration = require('../services/musicGeneration');\n    40→  } catch (e) {\n    41→    console.warn('musicGeneration not available:', e.message);\n    42→  }\n    43→\n    44→  try {\n    45→    sceneAnalysis = require('../services/sceneAnalysis');\n    46→  } catch (e) {\n    47→    console.warn('sceneAnalysis not available:', e.message);\n    48→  }\n    49→}\n    50→\n    51→/**\n    52→ * Update job step and progress\n    53→ */\n    54→async function updateJobStep(job, step) {\n    55→  await job.updateData({\n    56→    ...job.data,\n    57→    step\n    58→  });\n    59→  await job.updateProgress(PROGRESS_MAP[step] || 0);\n    60→  console.log(`[Job ${job.id}] Step: ${step} (${PROGRESS_MAP[step]}%)`);\n    61→}\n    62→\n    63→/**\n    64→ * Update database record\n    65→ */\n    66→async function updateDatabaseRecord(jobId, updates) {\n    67→  // This will be connected to the actual database in Phase 4\n    68→  console.log(`[DB Update] Job ${jobId}:`, JSON.stringify(updates).substring(0, 100));\n    69→}\n    70→\n    71→/**\n    72→ * Process a music generation job\n    73→ * @param {Object} job - BullMQ job\n    74→ * @returns {Promise<Object>} Job result\n    75→ */\n    76→async function processJob(job) {\n    77→  const startTime = Date.now();\n    78→  console.log(`[Job ${job.id}] Starting music generation`);\n    79→  console.log(`[Job ${job.id}] Data:`, JSON.stringify({\n    80→    customerId: job.data.customerId,\n    81→    youtubeUrl: job.data.youtubeUrl?.substring(0, 50),\n    82→    prompt: job.data.prompt?.substring(0, 50),\n    83→    duration: job.data.duration,\n    84→    mood: job.data.mood\n    85→  }));\n    86→\n    87→  try {\n    88→    // Scene-aware path: Analyze transcript first\n    89→    let sceneContext = null;\n    90→    if (job.data.isSceneAware && job.data.segments) {\n    91→      await updateJobStep(job, JOB_STATUS.ANALYZING);\n    92→\n    93→      if (!sceneAnalysis) {\n    94→        console.log(`[Job ${job.id}] Skipping scene analysis (service not available)`);\n    95→      } else {\n    96→        console.log(`[Job ${job.id}] Analyzing ${job.data.segments.length} transcript segments...`);\n    97→        sceneContext = await sceneAnalysis.analyzeScenes(job.data.segments);\n    98→        await job.updateData({\n    99→          ...job.data,\n   100→          sceneContext: {\n   101→            dominantMood: sceneContext.dominantMood,\n   102→            averageEnergy: sceneContext.averageEnergy,\n   103→            sceneCount: sceneContext.scenes.length,\n   104→            summary: sceneAnalysis.getSceneContextSummary(sceneContext)\n   105→          }\n   106→        });\n   107→\n   108→        console.log(`[Job ${job.id}] Scene analysis: ${sceneContext.dominantMood} mood, ${sceneContext.averageEnergy}% energy`);\n   109→      }\n   110→    }\n   111→\n   112→    // Step 1: Extract audio fingerprint (if YouTube URL provided)\n   113→    if (job.data.youtubeUrl) {\n   114→      await updateJobStep(job, JOB_STATUS.EXTRACTING);\n   115→\n   116→      if (!songIdentification) {\n   117→        console.log(`[Job ${job.id}] Skipping extraction (service not available)`);\n   118→      } else {\n   119→        // Extract 15-second audio fingerprint\n   120→        const audioPath = await songIdentification.extractAudioFingerprint(job.data.youtubeUrl);\n   121→        await job.updateData({\n   122→          ...job.data,\n   123→          audioPath\n   124→        });\n   125→      }\n   126→    }\n   127→\n   128→    // Step 2: Identify reference song\n   129→    if (job.data.youtubeUrl) {\n   130→      await updateJobStep(job, JOB_STATUS.IDENTIFYING);\n   131→\n   132→      if (!songIdentification) {\n   133→        console.log(`[Job ${job.id}] Skipping identification (service not available)`);\n   134→      } else {\n   135→        const identification = await songIdentification.identifySong(job.data.audioPath);\n   136→        await job.updateData({\n   137→          ...job.data,\n   138→          referenceSong: identification\n   139→        });\n   140→\n   141→        // Update database with reference info\n   142→        await updateDatabaseRecord(job.id, {\n   143→          reference_song_title: identification?.title,\n   144→          reference_artist: identification?.artist,\n   145→          reference_bpm: identification?.bpm,\n   146→          reference_key: identification?.key,\n   147→          reference_mood: identification?.mood,\n   148→          reference_confidence: identification?.confidence\n   149→        });\n   150→      }\n   151→    }\n   152→\n   153→    // Step 3: Generate music via Mureka API\n   154→    await updateJobStep(job, JOB_STATUS.GENERATING);\n   155→\n   156→    let musicResult;\n   157→    if (!musicGeneration) {\n   158→      console.log(`[Job ${job.id}] Skipping generation (service not available)`);\n   159→      // Placeholder result for testing\n   160→      musicResult = {\n   161→        title: `Generated ${job.data.mood} Music`,\n   162→        duration: job.data.duration,\n   163→        audioBuffer: Buffer.from('placeholder'),\n   164→        previewBuffer: Buffer.from('placeholder')\n   165→      };\n   166→    } else if (job.data.isSceneAware && sceneContext) {\n   167→      // Use scene-aware generation\n   168→      console.log(`[Job ${job.id}] Using scene-aware generation`);\n   169→      musicResult = await musicGeneration.generateSceneAwareMusic(\n   170→        job.data.segments,\n   171→        {\n   172→          prompt: job.data.prompt,\n   173→          duration: job.data.duration,\n   174→          mood: job.data.mood,\n   175→          instruments: job.data.instruments,\n   176→          referenceSong: job.data.referenceSong\n   177→        }\n   178→      );\n   179→    } else {\n   180→      // Build generation prompt from reference + user input\n   181→      const prompt = buildGenerationPrompt(job.data);\n   182→      musicResult = await musicGeneration.generateMusic({\n   183→        prompt,\n   184→        duration: job.data.duration,\n   185→        mood: job.data.mood,\n   186→        instruments: job.data.instruments,\n   187→        referenceSong: job.data.referenceSong\n   188→      });\n   189→    }\n   190→\n   191→    await job.updateData({\n   192→      ...job.data,\n   193→      musicResult: {\n   194→        title: musicResult.title,\n   195→        duration: musicResult.duration\n   196→      }\n   197→    });\n   198→\n   199→    // Step 4: Upload to R2\n   200→    await updateJobStep(job, JOB_STATUS.UPLOADING);\n   201→\n   202→    if (!r2Storage) {\n   203→      console.log(`[Job ${job.id}] Skipping upload (service not available)`);\n   204→    } else {\n   205→      // Upload master WAV\n   206→      const masterKey = r2Storage.generateStorageKey(\n   207→        job.data.customerId,\n   208→        job.id,\n   209→        'master.wav'\n   210→      );\n   211→      await r2Storage.uploadMusic(musicResult.audioBuffer, masterKey);\n   212→\n   213→      // Upload preview MP3\n   214→      const previewKey = r2Storage.generateStorageKey(\n   215→        job.data.customerId,\n   216→        job.id,\n   217→        'preview.mp3'\n   218→      );\n   219→      await r2Storage.uploadMusic(musicResult.previewBuffer, previewKey);\n   220→\n   221→      // Upload metadata\n   222→      const metadataKey = r2Storage.generateStorageKey(\n   223→        job.data.customerId,\n   224→        job.id,\n   225→        'metadata.json'\n   226→      );\n   227→      await r2Storage.uploadMetadata(metadataKey, {\n   228→        title: musicResult.title,\n   229→        duration: musicResult.duration,\n   230→        mood: job.data.mood,\n   231→        instruments: job.data.instruments,\n   232→        referenceSong: job.data.referenceSong,\n   233→        isSceneAware: job.data.isSceneAware || false,\n   234→        sceneContext: job.data.sceneContext || null,\n   235→        createdAt: new Date().toISOString()\n   236→      });\n   237→\n   238→      // Update database with storage info\n   239→      await updateDatabaseRecord(job.id, {\n   240→        r2_key: masterKey,\n   241→        r2_preview_key: previewKey,\n   242→        file_size_bytes: musicResult.audioBuffer.length,\n   243→        audio_duration_seconds: musicResult.duration,\n   244→        title: musicResult.title\n   245→      });\n   246→    }\n   247→\n   248→    // Step 5: Complete\n   249→    await updateJobStep(job, JOB_STATUS.COMPLETED);\n   250→\n   251→    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\n   252→    console.log(`[Job ${job.id}] Completed in ${elapsed}s`);\n   253→\n   254→    // Update database with completion\n   255→    await updateDatabaseRecord(job.id, {\n   256→      status: 'completed',\n   257→      completed_at: new Date().toISOString()\n   258→    });\n   259→\n   260→    return {\n   261→      success: true,\n   262→      jobId: job.id,\n   263→      title: musicResult.title,\n   264→      duration: musicResult.duration,\n   265→      elapsed: parseFloat(elapsed)\n   266→    };\n   267→\n   268→  } catch (error) {\n   269→    console.error(`[Job ${job.id}] Error:`, error.message);\n   270→\n   271→    // Check for unrecoverable errors\n   272→    if (isUnrecoverableError(error)) {\n   273→      // Update database with failure\n   274→      await updateDatabaseRecord(job.id, {\n   275→        status: 'failed',\n   276→        error_message: error.message\n   277→      });\n   278→\n   279→      throw new UnrecoverableError(error.message);\n   280→    }\n   281→\n   282→    // Update step to indicate failure point\n   283→    await job.updateData({\n   284→      ...job.data,\n   285→      lastError: error.message,\n   286→      lastErrorStep: job.data.step\n   287→    });\n   288→\n   289→    throw error; // Will trigger retry\n   290→  }\n   291→}\n   292→\n   293→/**\n   294→ * Build generation prompt from job data\n   295→ */\n   296→function buildGenerationPrompt(data) {\n   297→  const parts = [];\n   298→\n   299→  // Add user prompt if provided\n   300→  if (data.prompt) {\n   301→    parts.push(data.prompt);\n   302→  }\n   303→\n   304→  // Add reference song style\n   305→  if (data.referenceSong) {\n   306→    parts.push(`Style similar to \"${data.referenceSong.title}\" by ${data.referenceSong.artist}`);\n   307→    if (data.referenceSong.bpm) {\n   308→      parts.push(`Tempo: around ${data.referenceSong.bpm} BPM`);\n   309→    }\n   310→    if (data.referenceSong.key) {\n   311→      parts.push(`Key: ${data.referenceSong.key}`);\n   312→    }\n   313→  }\n   314→\n   315→  // Add mood\n   316→  if (data.mood) {\n   317→    parts.push(`Mood: ${data.mood}`);\n   318→  }\n   319→\n   320→  // Add instruments\n   321→  if (data.instruments && data.instruments.length > 0) {\n   322→    parts.push(`Instruments: ${data.instruments.join(', ')}`);\n   323→  }\n   324→\n   325→  // Add duration\n   326→  parts.push(`Duration: ${data.duration} seconds`);\n   327→\n   328→  // Add generic quality markers\n   329→  parts.push('Instrumental only, no vocals');\n   330→  parts.push('Suitable for video background music');\n   331→\n   332→  return parts.join('. ');\n   333→}\n   334→\n   335→/**\n   336→ * Check if error is unrecoverable\n   337→ */\n   338→function isUnrecoverableError(error) {\n   339→  const unrecoverablePatterns = [\n   340→    /quota exceeded/i,\n   341→    /invalid api key/i,\n   342→    /authentication failed/i,\n   343→    /insufficient credits/i,\n   344→    /account suspended/i,\n   345→    /content policy violation/i\n   346→  ];\n   347→\n   348→  return unrecoverablePatterns.some(pattern => pattern.test(error.message));\n   349→}\n   350→\n   351→/**\n   352→ * Create and start the music worker\n   353→ */\n   354→function createMusicWorker(options = {}) {\n   355→  const worker = new Worker(\n   356→    'music-generation',\n   357→    async (job) => {\n   358→      await initDependencies();\n   359→      return processJob(job);\n   360→    },\n   361→    {\n   362→      connection: getRedisConnection(),\n   363→      concurrency: options.concurrency || 3,\n   364→      settings: {\n   365→        backoffStrategy: (attemptsMade) => {\n   366→          // Exponential backoff: 5s, 10s, 20s\n   367→          return Math.min(5000 * Math.pow(2, attemptsMade - 1), 300000);\n   368→        }\n   369→      }\n   370→    }\n   371→  );\n   372→\n   373→  // Event handlers\n   374→  worker.on('completed', (job, result) => {\n   375→    console.log(`[Worker] Job ${job.id} completed:`, result?.title || 'Unknown');\n   376→  });\n   377→\n   378→  // HIGH-006: Move permanently failed jobs to Dead Letter Queue\n   379→  worker.on('failed', async (job, error) => {\n   380→    console.error(`[Worker] Job ${job?.id} failed after ${job?.attemptsMade} attempts:`, error.message);\n   381→    \n   382→    // Check if this job has exhausted all retries\n   383→    if (job && job.attemptsMade >= (job.opts?.attempts || 3)) {\n   384→      try {\n   385→        // Move to dead letter queue for inspection and potential recovery\n   386→        const { dlqJobId } = await moveToDeadLetterQueue(job, error);\n   387→        console.log(`[Worker] Job ${job.id} moved to DLQ as ${dlqJobId}`);\n   388→      } catch (dlqError) {\n   389→        console.error(`[Worker] Failed to move job ${job.id} to DLQ:`, dlqError.message);\n   390→      }\n   391→    }\n   392→  });\n   393→\n   394→  worker.on('progress', (job, progress) => {\n   395→    console.log(`[Worker] Job ${job.id} progress: ${progress}%`);\n   396→  });\n   397→\n   398→  worker.on('error', (error) => {\n   399→    console.error('[Worker] Error:', error.message);\n   400→  });\n   401→\n   402→  worker.on('stalled', (jobId) => {\n   403→    console.warn(`[Worker] Job ${jobId} stalled`);\n   404→  });\n   405→\n   406→  console.log('[Worker] Music generation worker started');\n   407→  console.log(`[Worker] Concurrency: ${options.concurrency || 3}`);\n   408→\n   409→  return worker;\n   410→}\n   411→\n   412→/**\n   413→ * Graceful shutdown\n   414→ */\n   415→async function shutdownWorker(worker) {\n   416→  console.log('[Worker] Shutting down...');\n   417→  await worker.close();\n   418→  console.log('[Worker] Shutdown complete');\n   419→}\n   420→\n   421→// Export for use in server.js or standalone\n   422→module.exports = {\n   423→  createMusicWorker,\n   424→  shutdownWorker,\n   425→  processJob,\n   426→  buildGenerationPrompt,\n   427→  isUnrecoverableError\n   428→};\n   429→\n   430→// Run standalone if executed directly\n   431→if (require.main === module) {\n   432→  const worker = createMusicWorker();\n   433→\n   434→  process.on('SIGTERM', async () => {\n   435→    await shutdownWorker(worker);\n   436→    process.exit(0);\n   437→  });\n   438→\n   439→  process.on('SIGINT', async () => {\n   440→    await shutdownWorker(worker);\n   441→    process.exit(0);\n   442→  });\n   443→}\n   444→\n\n</system-reminder>\n"}]},"uuid":"6948095e-7030-4793-adc3-5437cfb18a9b","timestamp":"2026-01-12T01:30:39.108Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/workers/musicWorker.js","content":"/**\n * Music Generation Background Worker\n * Processes music generation jobs from the BullMQ queue\n *\n * HIGH-006: Integrated with Dead Letter Queue for permanently failed jobs\n */\n\nconst { Worker, UnrecoverableError } = require('bullmq');\nconst {\n  getRedisConnection,\n  JOB_STATUS,\n  PROGRESS_MAP,\n  moveToDeadLetterQueue // HIGH-006: Import DLQ function\n} = require('../services/musicQueue');\n\n// Lazy import services (will be implemented in later phases)\nlet songIdentification = null;\nlet musicGeneration = null;\nlet r2Storage = null;\nlet sceneAnalysis = null;\n\n/**\n * Initialize worker dependencies\n */\nasync function initDependencies() {\n  try {\n    r2Storage = require('../services/r2Storage');\n  } catch (e) {\n    console.warn('r2Storage not available:', e.message);\n  }\n\n  try {\n    songIdentification = require('../services/songIdentification');\n  } catch (e) {\n    console.warn('songIdentification not available:', e.message);\n  }\n\n  try {\n    musicGeneration = require('../services/musicGeneration');\n  } catch (e) {\n    console.warn('musicGeneration not available:', e.message);\n  }\n\n  try {\n    sceneAnalysis = require('../services/sceneAnalysis');\n  } catch (e) {\n    console.warn('sceneAnalysis not available:', e.message);\n  }\n}\n\n/**\n * Update job step and progress\n */\nasync function updateJobStep(job, step) {\n  await job.updateData({\n    ...job.data,\n    step\n  });\n  await job.updateProgress(PROGRESS_MAP[step] || 0);\n  console.log(`[Job ${job.id}] Step: ${step} (${PROGRESS_MAP[step]}%)`);\n}\n\n/**\n * Update database record\n */\nasync function updateDatabaseRecord(jobId, updates) {\n  // This will be connected to the actual database in Phase 4\n  console.log(`[DB Update] Job ${jobId}:`, JSON.stringify(updates).substring(0, 100));\n}\n\n/**\n * Process a music generation job\n * @param {Object} job - BullMQ job\n * @returns {Promise<Object>} Job result\n */\nasync function processJob(job) {\n  const startTime = Date.now();\n  console.log(`[Job ${job.id}] Starting music generation`);\n  console.log(`[Job ${job.id}] Data:`, JSON.stringify({\n    customerId: job.data.customerId,\n    youtubeUrl: job.data.youtubeUrl?.substring(0, 50),\n    prompt: job.data.prompt?.substring(0, 50),\n    duration: job.data.duration,\n    mood: job.data.mood\n  }));\n\n  try {\n    // Scene-aware path: Analyze transcript first\n    let sceneContext = null;\n    if (job.data.isSceneAware && job.data.segments) {\n      await updateJobStep(job, JOB_STATUS.ANALYZING);\n\n      if (!sceneAnalysis) {\n        console.log(`[Job ${job.id}] Skipping scene analysis (service not available)`);\n      } else {\n        console.log(`[Job ${job.id}] Analyzing ${job.data.segments.length} transcript segments...`);\n        sceneContext = await sceneAnalysis.analyzeScenes(job.data.segments);\n        await job.updateData({\n          ...job.data,\n          sceneContext: {\n            dominantMood: sceneContext.dominantMood,\n            averageEnergy: sceneContext.averageEnergy,\n            sceneCount: sceneContext.scenes.length,\n            summary: sceneAnalysis.getSceneContextSummary(sceneContext)\n          }\n        });\n\n        console.log(`[Job ${job.id}] Scene analysis: ${sceneContext.dominantMood} mood, ${sceneContext.averageEnergy}% energy`);\n      }\n    }\n\n    // Step 1: Extract audio fingerprint (if YouTube URL provided)\n    if (job.data.youtubeUrl) {\n      await updateJobStep(job, JOB_STATUS.EXTRACTING);\n\n      if (!songIdentification) {\n        console.log(`[Job ${job.id}] Skipping extraction (service not available)`);\n      } else {\n        // Extract 15-second audio fingerprint\n        const audioPath = await songIdentification.extractAudioFingerprint(job.data.youtubeUrl);\n        await job.updateData({\n          ...job.data,\n          audioPath\n        });\n      }\n    }\n\n    // Step 2: Identify reference song\n    if (job.data.youtubeUrl) {\n      await updateJobStep(job, JOB_STATUS.IDENTIFYING);\n\n      if (!songIdentification) {\n        console.log(`[Job ${job.id}] Skipping identification (service not available)`);\n      } else {\n        const identification = await songIdentification.identifySong(job.data.audioPath);\n        await job.updateData({\n          ...job.data,\n          referenceSong: identification\n        });\n\n        // Update database with reference info\n        await updateDatabaseRecord(job.id, {\n          reference_song_title: identification?.title,\n          reference_artist: identification?.artist,\n          reference_bpm: identification?.bpm,\n          reference_key: identification?.key,\n          reference_mood: identification?.mood,\n          reference_confidence: identification?.confidence\n        });\n      }\n    }\n\n    // Step 3: Generate music via Mureka API\n    await updateJobStep(job, JOB_STATUS.GENERATING);\n\n    let musicResult;\n    if (!musicGeneration) {\n      console.log(`[Job ${job.id}] Skipping generation (service not available)`);\n      // Placeholder result for testing\n      musicResult = {\n        title: `Generated ${job.data.mood} Music`,\n        duration: job.data.duration,\n        audioBuffer: Buffer.from('placeholder'),\n        previewBuffer: Buffer.from('placeholder')\n      };\n    } else if (job.data.isSceneAware && sceneContext) {\n      // Use scene-aware generation\n      console.log(`[Job ${job.id}] Using scene-aware generation`);\n      musicResult = await musicGeneration.generateSceneAwareMusic(\n        job.data.segments,\n        {\n          prompt: job.data.prompt,\n          duration: job.data.duration,\n          mood: job.data.mood,\n          instruments: job.data.instruments,\n          referenceSong: job.data.referenceSong\n        }\n      );\n    } else {\n      // Build generation prompt from reference + user input\n      const prompt = buildGenerationPrompt(job.data);\n      musicResult = await musicGeneration.generateMusic({\n        prompt,\n        duration: job.data.duration,\n        mood: job.data.mood,\n        instruments: job.data.instruments,\n        referenceSong: job.data.referenceSong\n      });\n    }\n\n    await job.updateData({\n      ...job.data,\n      musicResult: {\n        title: musicResult.title,\n        duration: musicResult.duration\n      }\n    });\n\n    // Step 4: Upload to R2\n    await updateJobStep(job, JOB_STATUS.UPLOADING);\n\n    if (!r2Storage) {\n      console.log(`[Job ${job.id}] Skipping upload (service not available)`);\n    } else {\n      // Upload master WAV\n      const masterKey = r2Storage.generateStorageKey(\n        job.data.customerId,\n        job.id,\n        'master.wav'\n      );\n      await r2Storage.uploadMusic(musicResult.audioBuffer, masterKey);\n\n      // Upload preview MP3\n      const previewKey = r2Storage.generateStorageKey(\n        job.data.customerId,\n        job.id,\n        'preview.mp3'\n      );\n      await r2Storage.uploadMusic(musicResult.previewBuffer, previewKey);\n\n      // Upload metadata\n      const metadataKey = r2Storage.generateStorageKey(\n        job.data.customerId,\n        job.id,\n        'metadata.json'\n      );\n      await r2Storage.uploadMetadata(metadataKey, {\n        title: musicResult.title,\n        duration: musicResult.duration,\n        mood: job.data.mood,\n        instruments: job.data.instruments,\n        referenceSong: job.data.referenceSong,\n        isSceneAware: job.data.isSceneAware || false,\n        sceneContext: job.data.sceneContext || null,\n        createdAt: new Date().toISOString()\n      });\n\n      // Update database with storage info\n      await updateDatabaseRecord(job.id, {\n        r2_key: masterKey,\n        r2_preview_key: previewKey,\n        file_size_bytes: musicResult.audioBuffer.length,\n        audio_duration_seconds: musicResult.duration,\n        title: musicResult.title\n      });\n    }\n\n    // Step 5: Complete\n    await updateJobStep(job, JOB_STATUS.COMPLETED);\n\n    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);\n    console.log(`[Job ${job.id}] Completed in ${elapsed}s`);\n\n    // Update database with completion\n    await updateDatabaseRecord(job.id, {\n      status: 'completed',\n      completed_at: new Date().toISOString()\n    });\n\n    return {\n      success: true,\n      jobId: job.id,\n      title: musicResult.title,\n      duration: musicResult.duration,\n      elapsed: parseFloat(elapsed)\n    };\n\n  } catch (error) {\n    console.error(`[Job ${job.id}] Error:`, error.message);\n\n    // Check for unrecoverable errors\n    if (isUnrecoverableError(error)) {\n      // Update database with failure\n      await updateDatabaseRecord(job.id, {\n        status: 'failed',\n        error_message: error.message\n      });\n\n      throw new UnrecoverableError(error.message);\n    }\n\n    // Update step to indicate failure point\n    await job.updateData({\n      ...job.data,\n      lastError: error.message,\n      lastErrorStep: job.data.step\n    });\n\n    throw error; // Will trigger retry\n  }\n}\n\n/**\n * Build generation prompt from job data\n */\nfunction buildGenerationPrompt(data) {\n  const parts = [];\n\n  // Add user prompt if provided\n  if (data.prompt) {\n    parts.push(data.prompt);\n  }\n\n  // Add reference song style\n  if (data.referenceSong) {\n    parts.push(`Style similar to \"${data.referenceSong.title}\" by ${data.referenceSong.artist}`);\n    if (data.referenceSong.bpm) {\n      parts.push(`Tempo: around ${data.referenceSong.bpm} BPM`);\n    }\n    if (data.referenceSong.key) {\n      parts.push(`Key: ${data.referenceSong.key}`);\n    }\n  }\n\n  // Add mood\n  if (data.mood) {\n    parts.push(`Mood: ${data.mood}`);\n  }\n\n  // Add instruments\n  if (data.instruments && data.instruments.length > 0) {\n    parts.push(`Instruments: ${data.instruments.join(', ')}`);\n  }\n\n  // Add duration\n  parts.push(`Duration: ${data.duration} seconds`);\n\n  // Add generic quality markers\n  parts.push('Instrumental only, no vocals');\n  parts.push('Suitable for video background music');\n\n  return parts.join('. ');\n}\n\n/**\n * Check if error is unrecoverable\n */\nfunction isUnrecoverableError(error) {\n  const unrecoverablePatterns = [\n    /quota exceeded/i,\n    /invalid api key/i,\n    /authentication failed/i,\n    /insufficient credits/i,\n    /account suspended/i,\n    /content policy violation/i\n  ];\n\n  return unrecoverablePatterns.some(pattern => pattern.test(error.message));\n}\n\n/**\n * Create and start the music worker\n */\nfunction createMusicWorker(options = {}) {\n  const worker = new Worker(\n    'music-generation',\n    async (job) => {\n      await initDependencies();\n      return processJob(job);\n    },\n    {\n      connection: getRedisConnection(),\n      concurrency: options.concurrency || 3,\n      settings: {\n        backoffStrategy: (attemptsMade) => {\n          // Exponential backoff: 5s, 10s, 20s\n          return Math.min(5000 * Math.pow(2, attemptsMade - 1), 300000);\n        }\n      }\n    }\n  );\n\n  // Event handlers\n  worker.on('completed', (job, result) => {\n    console.log(`[Worker] Job ${job.id} completed:`, result?.title || 'Unknown');\n  });\n\n  // HIGH-006: Move permanently failed jobs to Dead Letter Queue\n  worker.on('failed', async (job, error) => {\n    console.error(`[Worker] Job ${job?.id} failed after ${job?.attemptsMade} attempts:`, error.message);\n    \n    // Check if this job has exhausted all retries\n    if (job && job.attemptsMade >= (job.opts?.attempts || 3)) {\n      try {\n        // Move to dead letter queue for inspection and potential recovery\n        const { dlqJobId } = await moveToDeadLetterQueue(job, error);\n        console.log(`[Worker] Job ${job.id} moved to DLQ as ${dlqJobId}`);\n      } catch (dlqError) {\n        console.error(`[Worker] Failed to move job ${job.id} to DLQ:`, dlqError.message);\n      }\n    }\n  });\n\n  worker.on('progress', (job, progress) => {\n    console.log(`[Worker] Job ${job.id} progress: ${progress}%`);\n  });\n\n  worker.on('error', (error) => {\n    console.error('[Worker] Error:', error.message);\n  });\n\n  worker.on('stalled', (jobId) => {\n    console.warn(`[Worker] Job ${jobId} stalled`);\n  });\n\n  console.log('[Worker] Music generation worker started');\n  console.log(`[Worker] Concurrency: ${options.concurrency || 3}`);\n\n  return worker;\n}\n\n/**\n * Graceful shutdown\n */\nasync function shutdownWorker(worker) {\n  console.log('[Worker] Shutting down...');\n  await worker.close();\n  console.log('[Worker] Shutdown complete');\n}\n\n// Export for use in server.js or standalone\nmodule.exports = {\n  createMusicWorker,\n  shutdownWorker,\n  processJob,\n  buildGenerationPrompt,\n  isUnrecoverableError\n};\n\n// Run standalone if executed directly\nif (require.main === module) {\n  const worker = createMusicWorker();\n\n  process.on('SIGTERM', async () => {\n    await shutdownWorker(worker);\n    process.exit(0);\n  });\n\n  process.on('SIGINT', async () => {\n    await shutdownWorker(worker);\n    process.exit(0);\n  });\n}\n","numLines":444,"startLine":1,"totalLines":444}}}
{"parentUuid":"6948095e-7030-4793-adc3-5437cfb18a9b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ME1LNhBT3EArzQRqGfhYx6","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Backend Server\n     3→ *\n     4→ * Main entry point for the SPLICE backend API.\n     5→ * Orchestrates the audio analysis pipeline.\n     6→ *\n     7→ * Slices:\n     8→ * - Slice 4: Transcription (services/transcription.js)\n     9→ * - Slice 5: Take Detection (services/takeDetection.js)\n    10→ *\n    11→ * Architecture: Modular routes (see routes/ directory)\n    12→ */\n    13→\n    14→\n    15→require('dotenv').config();\n    16→\n    17→const express = require('express');\n    18→const cors = require('cors');\n    19→const helmet = require('helmet');\n    20→const cookieParser = require('cookie-parser');\n    21→const fs = require('fs');\n    22→const https = require('https');\n    23→const http = require('http');\n    24→const path = require('path');\n    25→const crypto = require('crypto');\n    26→\n    27→// MEDIUM-005: Request ID Tracing Middleware\n    28→const { requestIdMiddleware } = require('./middleware/requestId');\n    29→\n    30→// HIGH-008: Sentry Error Monitoring Integration\n    31→let Sentry = null;\n    32→if (process.env.SENTRY_DSN) {\n    33→  try {\n    34→    Sentry = require('@sentry/node');\n    35→    console.log('[SPLICE] Sentry module loaded, will initialize after app creation');\n    36→  } catch (_err) {\n    37→    console.warn('[SPLICE] @sentry/node not installed. Run: npm install @sentry/node');\n    38→  }\n    39→}\n    40→\n    41→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\n    42→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    43→\n    44→// Import services\n    45→const usageTracking = require('./services/usageTracking');\n    46→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\n    47→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\n    48→const referralService = require('./services/referralService');\n    49→const licenseService = require('./services/licenseService');\n    50→const emailService = require('./services/emailService');\n    51→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\n    52→const { getSupportedFormats } = require('./services/captionExporter');\n    53→\n    54→// Import route modules\n    55→const healthRoutes = require('./routes/health');\n    56→const analyzeRoutes = require('./routes/analyze');\n    57→const silencesRoutes = require('./routes/silences');\n    58→const detectionRoutes = require('./routes/detection');\n    59→const exportRoutes = require('./routes/export');\n    60→const multitrackRoutes = require('./routes/multitrack');\n    61→const cutListRoutes = require('./routes/cutList');\n    62→const zoomRoutes = require('./routes/zoom');\n    63→const chaptersRoutes = require('./routes/chapters');\n    64→const youtubeRoutes = require('./routes/youtube');\n    65→const captionsRoutes = require('./routes/captions');\n    66→const textEditRoutes = require('./routes/textEdit');\n    67→const reframeRoutes = require('./routes/reframe');\n    68→const batchRoutes = require('./routes/batch');\n    69→const authRoutes = require('./routes/auth');\n    70→const billingRoutes = require('./routes/billing');\n    71→const referralRoutes = require('./routes/referral');\n    72→const licenseRoutes = require('./routes/license');\n    73→const musicRoutes = require('./routes/music');\n    74→\n    75→// Music generation worker (BullMQ background processor)\n    76→const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\n    77→\n    78→// HIGH-011: API Versioning - v1 routes\n    79→const v1Routes = require('./routes/v1');\n    80→\n    81→// Stripe for webhooks\n    82→const Stripe = require('stripe');\n    83→\n    84→// MEDIUM-008: Pin Stripe API version for stability\n    85→// This prevents breaking changes when Stripe releases new API versions\n    86→// Should match version in services/stripeUsageReporting.js\n    87→const STRIPE_API_VERSION = '2024-12-18.acacia';\n    88→\n    89→// =============================================================================\n    90→// SECURITY: Environment Variable Validation\n    91→// Validate all required environment variables at startup\n    92→// Fail fast with clear error messages if critical secrets are missing\n    93→// =============================================================================\n    94→\n    95→/**\n    96→ * Validate required environment variables\n    97→ * @returns {Object} { valid: boolean, errors: string[] }\n    98→ */\n    99→function validateEnvironmentVariables() {\n   100→  const errors = [];\n   101→  \n   102→  // CRITICAL: Core infrastructure secrets\n   103→  if (!process.env.STRIPE_SECRET_KEY) {\n   104→    errors.push('STRIPE_SECRET_KEY is required (Stripe API key for billing)');\n   105→  }\n   106→  \n   107→  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production') {\n   108→    errors.push('JWT_SECRET must be set to a secure random value (not default)');\n   109→  } else if (process.env.JWT_SECRET.length < 32) {\n   110→    // HIGH-001: Enforce minimum 32 character length for cryptographic security\n   111→    errors.push('JWT_SECRET must be at least 32 characters for cryptographic security');\n   112→  }\n   113→  \n   114→  if (!process.env.DATABASE_URL) {\n   115→    errors.push('DATABASE_URL is required (PostgreSQL connection string)');\n   116→  }\n   117→  \n   118→  if (!process.env.OPENAI_API_KEY) {\n   119→    errors.push('OPENAI_API_KEY is required (OpenAI API for transcription)');\n   120→  }\n   121→  \n   122→  // CRITICAL: Redis required for job queue and rate limiting in production\n   123→  // Support both Railway Redis (REDIS_URL) and Upstash (UPSTASH_REDIS_URL)\n   124→  // In development, will fall back to in-memory storage\n   125→  if (process.env.NODE_ENV === 'production' && !process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n   126→    errors.push('REDIS_URL or UPSTASH_REDIS_URL is required (Redis for job queue and rate limiting)');\n   127→  } else if (!process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n   128→    console.warn('[SPLICE] WARNING: Redis not configured. Using in-memory fallback (not suitable for production).');\n   129→  }\n   130→  \n   131→  // CRITICAL: Webhook secret required in production\n   132→  if (!process.env.STRIPE_WEBHOOK_SECRET) {\n   133→    errors.push('STRIPE_WEBHOOK_SECRET is required (Stripe webhook signature verification)');\n   134→  }\n   135→  \n   136→  // CONDITIONAL: Email provider validation\n   137→  const emailProvider = process.env.EMAIL_PROVIDER || 'sendgrid';\n   138→  if (emailProvider === 'sendgrid' && !process.env.SENDGRID_API_KEY) {\n   139→    errors.push('SENDGRID_API_KEY is required when EMAIL_PROVIDER=sendgrid');\n   140→  }\n   141→  \n   142→  // RECOMMENDED: R2 Storage (warn if missing, don't block)\n   143→  if (!process.env.R2_ACCOUNT_ID || !process.env.R2_ACCESS_KEY_ID || !process.env.R2_SECRET_ACCESS_KEY) {\n   144→    console.warn('[SPLICE] WARNING: R2 storage credentials not configured. Music generation uploads will fail.');\n   145→  }\n   146→  \n   147→  return {\n   148→    valid: errors.length === 0,\n   149→    errors\n   150→  };\n   151→}\n   152→\n   153→// Run validation in production\n   154→if (isProduction) {\n   155→  const validation = validateEnvironmentVariables();\n   156→  \n   157→  if (!validation.valid) {\n   158→    console.error('[SPLICE] ========================================');\n   159→    console.error('[SPLICE] CRITICAL: Missing required environment variables');\n   160→    console.error('[SPLICE] ========================================');\n   161→    validation.errors.forEach(error => {\n   162→      console.error(`[SPLICE]   ❌ ${error}`);\n   163→    });\n   164→    console.error('[SPLICE] ========================================');\n   165→    console.error('[SPLICE] Server startup aborted. Please configure all required environment variables.');\n   166→    console.error('[SPLICE] See .env.example for complete documentation.');\n   167→    process.exit(1);\n   168→  }\n   169→  \n   170→  console.log('[SPLICE] ✅ Environment validation passed');\n   171→}\n   172→\n   173→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n   174→  apiVersion: STRIPE_API_VERSION\n   175→});\n   176→\n   177→// =============================================================================\n   178→// PERF-FIX: Static Response Cache\n   179→// Cache static endpoint responses at startup to avoid repeated computation\n   180→// =============================================================================\n   181→\n   182→// Generate ETag from content\n   183→function generateETag(content) {\n   184→  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n   185→}\n   186→\n   187→// Static response cache - populated at startup\n   188→const STATIC_RESPONSE_CACHE = {\n   189→  profanityLanguages: null,\n   190→  profanityBleeps: null,\n   191→  exportFormats: null\n   192→};\n   193→\n   194→// Initialize cache at startup (called after server starts)\n   195→function initializeStaticCache() {\n   196→  // Cache profanity languages\n   197→  const languages = getSupportedLanguages();\n   198→  STATIC_RESPONSE_CACHE.profanityLanguages = {\n   199→    body: { success: true, languages },\n   200→    etag: generateETag({ languages })\n   201→  };\n   202→\n   203→  // Cache profanity bleeps\n   204→  const sounds = getAvailableBleepSounds();\n   205→  STATIC_RESPONSE_CACHE.profanityBleeps = {\n   206→    body: { success: true, sounds },\n   207→    etag: generateETag({ sounds })\n   208→  };\n   209→\n   210→  // Cache export formats\n   211→  const formats = getSupportedFormats();\n   212→  STATIC_RESPONSE_CACHE.exportFormats = {\n   213→    body: { success: true, formats },\n   214→    etag: generateETag({ formats })\n   215→  };\n   216→\n   217→  console.log('[SPLICE] Static response cache initialized');\n   218→}\n   219→\n   220→// Helper to send cached response with ETag\n   221→function sendCachedResponse(req, res, cacheKey) {\n   222→  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n   223→  if (!cached) {\n   224→    return res.status(500).json({ error: 'Cache not initialized' });\n   225→  }\n   226→\n   227→  // Check If-None-Match header for conditional GET\n   228→  const clientETag = req.headers['if-none-match'];\n   229→  if (clientETag === cached.etag) {\n   230→    return res.status(304).end(); // Not Modified\n   231→  }\n   232→\n   233→  // Send cached response with ETag and cache headers\n   234→  res.set('ETag', cached.etag);\n   235→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n   236→  res.json(cached.body);\n   237→}\n   238→\n   239→// =============================================================================\n   240→// Server Configuration\n   241→// =============================================================================\n   242→\n   243→const app = express();\n   244→const PORT = process.env.PORT || 3847;\n   245→\n   246→// HIGH-008: Initialize Sentry after app creation\n   247→if (Sentry && process.env.SENTRY_DSN) {\n   248→  Sentry.init({\n   249→    dsn: process.env.SENTRY_DSN,\n   250→    environment: process.env.NODE_ENV || 'development',\n   251→    release: process.env.npm_package_version || '6.0.3',\n   252→    tracesSampleRate: isProduction ? 0.1 : 1.0, // 10% in prod, 100% in dev\n   253→    profilesSampleRate: isProduction ? 0.1 : 0, // Profile only in production\n   254→    integrations: [\n   255→      // Automatically instrument HTTP requests\n   256→      Sentry.httpIntegration({ tracing: true }),\n   257→      // Automatically instrument Express\n   258→      Sentry.expressIntegration({ app }),\n   259→    ],\n   260→    // Filter out sensitive data\n   261→    beforeSend(event) {\n   262→      // Remove sensitive headers\n   263→      if (event.request && event.request.headers) {\n   264→        delete event.request.headers.authorization;\n   265→        delete event.request.headers['x-stripe-customer-id'];\n   266→        delete event.request.headers['stripe-signature'];\n   267→      }\n   268→      return event;\n   269→    },\n   270→  });\n   271→  \n   272→  // Add Sentry request handler as first middleware\n   273→  app.use(Sentry.Handlers.requestHandler());\n   274→  app.use(Sentry.Handlers.tracingHandler());\n   275→  \n   276→  console.log('[SPLICE] ✅ Sentry error monitoring initialized');\n   277→}\n   278→\n   279→// MEDIUM-005: Request ID Tracing Middleware\n   280→// Add early in chain to ensure all requests have correlation IDs for logging\n   281→app.use(requestIdMiddleware);\n   282→\n   283→// HTTPS certificates (generated by mkcert) - only for local development\n   284→let httpsOptions = null;\n   285→if (!isProduction) {\n   286→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n   287→  const certPath = path.join(__dirname, 'localhost+1.pem');\n   288→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n   289→    httpsOptions = {\n   290→      key: fs.readFileSync(keyPath),\n   291→      cert: fs.readFileSync(certPath)\n   292→    };\n   293→  }\n   294→}\n   295→\n   296→// =============================================================================\n   297→// Security Configuration\n   298→// =============================================================================\n   299→\n   300→// CORS whitelist - restrict origins in production\n   301→const CORS_WHITELIST = [\n   302→  'http://localhost:3000',\n   303→  'http://localhost:3847',\n   304→  'https://localhost:3847',\n   305→  'http://127.0.0.1:3000',\n   306→  'http://127.0.0.1:3847',\n   307→  'https://127.0.0.1:3847',\n   308→  'https://splice.app',\n   309→  'https://www.splice.app',\n   310→  'https://spliceclips.com',\n   311→  'https://www.spliceclips.com',\n   312→  'https://splice-api-production.up.railway.app',\n   313→  'https://splice-website.vercel.app',\n   314→  // Adobe CEP/UXP panels run from file:// or bolt://\n   315→  'file://',\n   316→  'bolt://'\n   317→];\n   318→\n   319→const corsOptions = {\n   320→  origin: function (origin, callback) {\n   321→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n   322→    if (!origin) {\n   323→      return callback(null, true);\n   324→    }\n   325→    // Check if origin is in whitelist\n   326→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n   327→      return callback(null, true);\n   328→    }\n   329→    // In development, allow all origins with warning\n   330→    if (!isProduction) {\n   331→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n   332→      return callback(null, true);\n   333→    }\n   334→    // In production, reject non-whitelisted origins\n   335→    console.error(`[CORS] Blocked request from: ${origin}`);\n   336→    return callback(new Error('Not allowed by CORS'));\n   337→  },\n   338→  credentials: true,\n   339→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n   340→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n   341→};\n   342→\n   343→app.use(cors(corsOptions));\n   344→\n   345→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n   346→// This ensures rate limiting and logging use the correct client IP\n   347→if (isProduction) {\n   348→  app.set('trust proxy', 1);\n   349→}\n   350→\n   351→// IP-based rate limiting (100 requests/minute per IP)\n   352→app.use(ipRateLimit);\n   353→\n   354→// Security headers via helmet\n   355→app.use(helmet({\n   356→  contentSecurityPolicy: {\n   357→    directives: {\n   358→      defaultSrc: [\"'self'\"],\n   359→      scriptSrc: [\"'self'\"],\n   360→      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n   361→      imgSrc: [\"'self'\", 'data:', 'https:'],\n   362→      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n   363→      fontSrc: [\"'self'\"],\n   364→      objectSrc: [\"'none'\"],\n   365→      mediaSrc: [\"'self'\"],\n   366→      frameSrc: [\"'none'\"]\n   367→    }\n   368→  },\n   369→  hsts: {\n   370→    maxAge: 31536000,\n   371→    includeSubDomains: true,\n   372→    preload: true\n   373→  },\n   374→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n   375→  noSniff: true,\n   376→  xssFilter: true,\n   377→  hidePoweredBy: true\n   378→}));\n   379→\n   380→// Helper to determine tier from price ID with logging\n   381→// Supports both monthly and annual pricing\n   382→function getTierFromPriceId(priceId) {\n   383→  // Monthly prices\n   384→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   385→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   386→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   387→\n   388→  // Annual prices (same tier, just different billing period)\n   389→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n   390→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n   391→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n   392→\n   393→  // Log unknown price ID for debugging\n   394→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   395→  return 'starter';\n   396→}\n   397→\n   398→// =============================================================================\n   399→// Stripe Webhook (must be before express.json())\n   400→// =============================================================================\n   401→\n   402→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   403→  const sig = req.headers['stripe-signature'];\n   404→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   405→\n   406→  let event;\n   407→\n   408→  try {\n   409→    if (webhookSecret) {\n   410→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   411→    } else if (isProduction) {\n   412→      // SECURITY: Reject unsigned webhooks in production\n   413→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   414→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   415→    } else {\n   416→      // For local development testing only\n   417→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   418→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   419→      event = JSON.parse(bodyString);\n   420→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   421→    }\n   422→  } catch (err) {\n   423→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   424→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   425→  }\n   426→\n   427→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   428→\n   429→  // Idempotency check - skip if already processed\n   430→  if (await usageTracking.isEventProcessed(event.id)) {\n   431→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   432→    return res.json({ received: true, skipped: true });\n   433→  }\n   434→\n   435→  try {\n   436→    switch (event.type) {\n   437→      case 'customer.subscription.created':\n   438→      case 'customer.subscription.updated': {\n   439→        const subscription = event.data.object;\n   440→        const customerId = subscription.customer;\n   441→\n   442→        // Validate customerId\n   443→        if (!customerId) {\n   444→          console.error('[SPLICE] Missing customer ID in subscription event');\n   445→          return res.status(400).json({ error: 'Missing customer ID' });\n   446→        }\n   447→\n   448→        // Get tier from price ID\n   449→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   450→        const tier = getTierFromPriceId(priceId);\n   451→\n   452→        // Update user tier and reset hours\n   453→        await usageTracking.updateTier(customerId, tier);\n   454→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   455→\n   456→        // Initialize music credits for new subscriptions\n   457→        if (event.type === 'customer.subscription.created') {\n   458→          await usageTracking.resetMusicCredits(customerId, tier);\n   459→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n   460→        }\n   461→\n   462→        // Update trial end date if present\n   463→        if (subscription.trial_end) {\n   464→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n   465→        }\n   466→\n   467→        // Generate license key for new subscriptions with retry and delivery\n   468→        if (event.type === 'customer.subscription.created') {\n   469→          let licenseResult = null;\n   470→          let retryCount = 0;\n   471→          const maxRetries = 3;\n   472→\n   473→          // Retry mechanism for license key generation\n   474→          while (retryCount < maxRetries) {\n   475→            licenseResult = await licenseService.generateLicenseKey(customerId);\n   476→            if (licenseResult.success) {\n   477→              break;\n   478→            }\n   479→            retryCount++;\n   480→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n   481→            // Wait before retry (exponential backoff)\n   482→            if (retryCount < maxRetries) {\n   483→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n   484→            }\n   485→          }\n   486→\n   487→          if (licenseResult && licenseResult.success) {\n   488→            // SECURITY: Mask license key in logs\n   489→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n   490→\n   491→            // Store license key in Stripe subscription metadata as backup\n   492→            try {\n   493→              await stripe.subscriptions.update(subscription.id, {\n   494→                metadata: {\n   495→                  license_key: licenseResult.key,\n   496→                  license_generated_at: new Date().toISOString()\n   497→                }\n   498→              });\n   499→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n   500→            } catch (stripeErr) {\n   501→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n   502→            }\n   503→\n   504→            // Get customer email and send license key\n   505→            try {\n   506→              const customer = await stripe.customers.retrieve(customerId);\n   507→              if (customer.email) {\n   508→                // SECURITY: Mask sensitive data in logs\n   509→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n   510→\n   511→                // Send license key email\n   512→                try {\n   513→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n   514→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n   515→                } catch (sendErr) {\n   516→                  // Log but don't fail - license is stored in Stripe metadata as backup\n   517→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n   518→                }\n   519→\n   520→                // Store email in database for reference\n   521→                await usageTracking.updateTier(customerId, tier, customer.email);\n   522→              } else {\n   523→                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n   524→              }\n   525→            } catch (emailErr) {\n   526→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n   527→            }\n   528→          } else {\n   529→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n   530→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n   531→            console.error(`[SPLICE] ${errorMsg}`);\n   532→            return res.status(500).json({ error: errorMsg });\n   533→          }\n   534→        }\n   535→        break;\n   536→      }\n   537→\n   538→      case 'customer.subscription.deleted': {\n   539→        const subscription = event.data.object;\n   540→        const customerId = subscription.customer;\n   541→\n   542→        // Validate customerId\n   543→        if (!customerId) {\n   544→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   545→          return res.status(400).json({ error: 'Missing customer ID' });\n   546→        }\n   547→\n   548→        // Downgrade to cancelled (0 hours)\n   549→        await usageTracking.updateTier(customerId, 'cancelled');\n   550→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   551→        break;\n   552→      }\n   553→\n   554→      case 'invoice.payment_succeeded': {\n   555→        const invoice = event.data.object;\n   556→        const customerId = invoice.customer;\n   557→        const subscriptionId = invoice.subscription;\n   558→\n   559→        // Validate customerId\n   560→        if (!customerId) {\n   561→          console.error('[SPLICE] Missing customer ID in invoice event');\n   562→          return res.status(400).json({ error: 'Missing customer ID' });\n   563→        }\n   564→\n   565→        // Reset hours on successful payment (new billing period)\n   566→        let tier = 'starter';\n   567→        if (subscriptionId) {\n   568→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   569→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   570→          tier = getTierFromPriceId(priceId);\n   571→\n   572→          await usageTracking.resetHours(customerId, tier);\n   573→          await usageTracking.resetMusicCredits(customerId, tier);\n   574→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n   575→        }\n   576→\n   577→        // Check for affiliate coupon and record commission\n   578→        const discount = invoice.discount;\n   579→        if (discount && discount.coupon) {\n   580→          const couponId = discount.coupon.id;\n   581→          // Check if this is an affiliate code (like JIMMYN)\n   582→          if (referralService.AFFILIATE_CODES[couponId]) {\n   583→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n   584→            await referralService.recordAffiliateCommission(\n   585→              couponId,\n   586→              customerId,\n   587→              amountPaid,\n   588→              tier\n   589→            );\n   590→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n   591→          }\n   592→        }\n   593→        break;\n   594→      }\n   595→\n   596→      case 'invoice.payment_failed': {\n   597→        const invoice = event.data.object;\n   598→        const customerId = invoice.customer;\n   599→        const attemptCount = invoice.attempt_count || 1;\n   600→\n   601→        // Validate customerId\n   602→        if (!customerId) {\n   603→          console.error('[SPLICE] Missing customer ID in payment_failed event');\n   604→          return res.status(400).json({ error: 'Missing customer ID' });\n   605→        }\n   606→\n   607→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n   608→\n   609→        // Stripe will retry automatically per retry settings\n   610→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n   611→        // Send warning email on final attempt\n   612→        if (attemptCount >= 3) {\n   613→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n   614→          // Send warning email to customer about impending cancellation\n   615→          try {\n   616→            const customer = await stripe.customers.retrieve(customerId);\n   617→            if (customer.email) {\n   618→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n   619→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n   620→            }\n   621→          } catch (emailErr) {\n   622→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n   623→          }\n   624→        }\n   625→        break;\n   626→      }\n   627→\n   628→      case 'customer.deleted': {\n   629→        const customer = event.data.object;\n   630→        const customerId = customer.id;\n   631→\n   632→        // Validate customerId\n   633→        if (!customerId) {\n   634→          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n   635→          return res.status(400).json({ error: 'Missing customer ID' });\n   636→        }\n   637→\n   638→        // Clean up user data - downgrade to cancelled\n   639→        await usageTracking.updateTier(customerId, 'cancelled');\n   640→        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n   641→        break;\n   642→      }\n   643→\n   644→      default:\n   645→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   646→    }\n   647→\n   648→    // Record event as processed (idempotency)\n   649→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   650→\n   651→    res.json({ received: true });\n   652→  } catch (err) {\n   653→    console.error('[SPLICE] Webhook handler error:', err);\n   654→    res.status(500).json({ error: err.message });\n   655→  }\n   656→});\n   657→\n   658→// Parse JSON body for all other routes\n   659→// SECURITY: Limit JSON body size to prevent DoS attacks\n   660→app.use(express.json({ limit: '10mb' }));\n   661→\n   662→// Parse cookies for CSRF token validation\n   663→app.use(cookieParser());\n   664→\n   665→// =============================================================================\n   666→// Route Configuration Options\n   667→// =============================================================================\n   668→\n   669→const routeOptions = {\n   670→  middleware: {\n   671→    requireCredits,\n   672→    requireFeature,\n   673→    authenticateToken\n   674→  },\n   675→  services: {\n   676→    usageTracking,\n   677→    referralService,\n   678→    licenseService,\n   679→    emailService,\n   680→    stripe\n   681→  },\n   682→  authHelpers: {\n   683→    generateToken,\n   684→    generateRefreshToken,\n   685→    verifyToken,\n   686→    maskSensitiveData,\n   687→    blacklistToken\n   688→  },\n   689→  staticCache: STATIC_RESPONSE_CACHE,\n   690→  sendCachedResponse\n   691→};\n   692→\n   693→// =============================================================================\n   694→// Mount Routes\n   695→// =============================================================================\n   696→\n   697→// Health check and system endpoints (no prefix)\n   698→app.use('/', healthRoutes(routeOptions));\n   699→\n   700→// Core analysis endpoints\n   701→app.use('/', analyzeRoutes(routeOptions));\n   702→app.use('/', silencesRoutes(routeOptions));\n   703→app.use('/', detectionRoutes(routeOptions));\n   704→\n   705→// Export endpoints\n   706→app.use('/export', exportRoutes(routeOptions));\n   707→\n   708→// Multitrack/Multicam endpoints\n   709→app.use('/multitrack', multitrackRoutes(routeOptions));\n   710→\n   711→// Cut list generation\n   712→app.use('/cut-list', cutListRoutes(routeOptions));\n   713→\n   714→// Legacy XML processing endpoint (backwards compatibility)\n   715→const { processXMLFile } = require('./services/xmlProcessor');\n   716→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n   717→  const {\n   718→    xmlPath,\n   719→    silences,\n   720→    removeGaps = true,\n   721→    outputPath = null\n   722→  } = req.body;\n   723→\n   724→  if (!xmlPath) {\n   725→    return res.status(400).json({ error: 'xmlPath is required' });\n   726→  }\n   727→\n   728→  if (!silences || !Array.isArray(silences)) {\n   729→    return res.status(400).json({ error: 'silences array is required' });\n   730→  }\n   731→\n   732→  if (!fs.existsSync(xmlPath)) {\n   733→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n   734→  }\n   735→\n   736→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n   737→\n   738→  try {\n   739→    const result = await processXMLFile(xmlPath, silences, {\n   740→      outputPath,\n   741→      removeGaps\n   742→    });\n   743→\n   744→    res.json({\n   745→      success: true,\n   746→      inputPath: xmlPath,\n   747→      outputPath: result.outputPath,\n   748→      stats: result.stats\n   749→    });\n   750→  } catch (err) {\n   751→    console.error('[SPLICE] XML processing error:', err);\n   752→    res.status(500).json({ error: err.message });\n   753→  }\n   754→});\n   755→\n   756→// Auto zoom endpoints\n   757→app.use('/zoom', zoomRoutes(routeOptions));\n   758→\n   759→// Chapter detection endpoints\n   760→app.use('/chapters', chaptersRoutes(routeOptions));\n   761→\n   762→// YouTube content generation\n   763→app.use('/youtube', youtubeRoutes(routeOptions));\n   764→\n   765→// Animated captions endpoints\n   766→app.use('/captions', captionsRoutes(routeOptions));\n   767→\n   768→// Text-based editing endpoints\n   769→app.use('/text-edit', textEditRoutes(routeOptions));\n   770→\n   771→// Social reframe endpoints\n   772→app.use('/reframe', reframeRoutes(routeOptions));\n   773→app.use('/faces', reframeRoutes.facesRouter(routeOptions));\n   774→\n   775→// Batch processing endpoints\n   776→app.use('/batch', batchRoutes(routeOptions));\n   777→\n   778→// Authentication endpoints\n   779→app.use('/auth', authRoutes(routeOptions));\n   780→\n   781→// Billing and credits endpoints\n   782→app.use('/', billingRoutes(routeOptions));\n   783→\n   784→// Referral system endpoints\n   785→app.use('/referral', referralRoutes(routeOptions));\n   786→\n   787→// License key endpoints\n   788→app.use('/license', licenseRoutes(routeOptions));\n   789→\n   790→// AI Music generation endpoints\n   791→app.use('/music', musicRoutes(routeOptions));\n   792→\n   793→// =============================================================================\n   794→// HIGH-011: API Versioning\n   795→// Mount versioned routes under /api/v1 prefix\n   796→// Maintain backwards compatibility with deprecation warnings\n   797→// =============================================================================\n   798→\n   799→// Mount v1 API routes\n   800→app.use('/api/v1', v1Routes(routeOptions));\n   801→\n   802→// Deprecation warning middleware for unversioned API calls\n   803→// This helps clients migrate to versioned endpoints\n   804→app.use('/api', (req, res, next) => {\n   805→  // Skip if already using versioned endpoint\n   806→  if (req.path.startsWith('/v1')) {\n   807→    return next();\n   808→  }\n   809→  \n   810→  // Add deprecation warning header\n   811→  res.set('X-API-Deprecation-Warning', 'Unversioned API endpoints are deprecated. Please migrate to /api/v1/');\n   812→  res.set('X-API-Version', 'unversioned');\n   813→  res.set('Deprecation', 'true');\n   814→  res.set('Sunset', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toUTCString()); // 90 days from now\n   815→  \n   816→  next();\n   817→});\n   818→\n   819→// HIGH-008: Add Sentry error handler (must be after all routes)\n   820→if (Sentry) {\n   821→  app.use(Sentry.Handlers.errorHandler({\n   822→    shouldHandleError(error) {\n   823→      // Capture all 4xx and 5xx errors\n   824→      if (error.status >= 400) {\n   825→        return true;\n   826→      }\n   827→      return true;\n   828→    },\n   829→  }));\n   830→}\n   831→\n   832→// =============================================================================\n   833→// Start Server\n   834→// =============================================================================\n   835→\n   836→// Track active server for graceful shutdown\n   837→let server = null;\n   838→\n   839→// Initialize database and start server\n   840→async function startServer() {\n   841→  try {\n   842→    await usageTracking.initDatabase();\n   843→    await referralService.initReferralTables();\n   844→    await licenseService.initLicenseTables();\n   845→    console.log('[SPLICE] Database initialized');\n   846→\n   847→    // PERF-FIX: Initialize static response cache at startup\n   848→    initializeStaticCache();\n   849→\n   850→    // Start music generation worker (BullMQ background processor)\n   851→    // Only starts if Redis is configured and Replicate API key is available\n   852→    if (process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL) {\n   853→      if (process.env.REPLICATE_API_TOKEN) {\n   854→        try {\n   855→          createMusicWorker();\n   856→          console.log('[SPLICE] ✅ Music generation worker started');\n   857→        } catch (workerErr) {\n   858→          console.error('[SPLICE] ⚠️ Failed to start music worker:', workerErr.message);\n   859→          // Don't fail server startup - music generation will be unavailable\n   860→        }\n   861→      } else {\n   862→        console.warn('[SPLICE] ⚠️ REPLICATE_API_TOKEN not set - music generation disabled');\n   863→      }\n   864→    } else {\n   865→      console.warn('[SPLICE] ⚠️ Redis not configured - music generation queue disabled');\n   866→    }\n   867→\n   868→    if (isProduction || !httpsOptions) {\n   869→      // Production: Railway provides TLS termination, use HTTP\n   870→      server = http.createServer(app).listen(PORT, () => {\n   871→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n   872→      });\n   873→    } else {\n   874→      // Development: Use HTTPS with local certificates\n   875→      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n   876→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n   877→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n   878→      });\n   879→    }\n   880→  } catch (err) {\n   881→    console.error('[SPLICE] Failed to start server:', err);\n   882→    process.exit(1);\n   883→  }\n   884→}\n   885→\n   886→// =============================================================================\n   887→// Graceful Shutdown\n   888→// =============================================================================\n   889→\n   890→async function gracefulShutdown(signal) {\n   891→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n   892→\n   893→  // Stop accepting new connections\n   894→  if (server) {\n   895→    server.close(() => {\n   896→      console.log('[SPLICE] HTTP server closed');\n   897→    });\n   898→  }\n   899→\n   900→  // Shutdown music worker (allows in-progress jobs to complete)\n   901→  try {\n   902→    await shutdownWorker();\n   903→    console.log('[SPLICE] Music worker shut down');\n   904→  } catch (err) {\n   905→    console.error('[SPLICE] Error shutting down music worker:', err.message);\n   906→  }\n   907→\n   908→  // Close database pool\n   909→  try {\n   910→    await usageTracking.closePool();\n   911→    console.log('[SPLICE] Database pool closed');\n   912→  } catch (err) {\n   913→    console.error('[SPLICE] Error closing database pool:', err.message);\n   914→  }\n   915→\n   916→  // Give ongoing requests time to complete (max 10 seconds)\n   917→  setTimeout(() => {\n   918→    console.log('[SPLICE] Graceful shutdown complete');\n   919→    process.exit(0);\n   920→  }, 10000);\n   921→}\n   922→\n   923→// Handle termination signals\n   924→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n   925→process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n   926→\n   927→// Handle uncaught exceptions\n   928→process.on('uncaughtException', (err) => {\n   929→  console.error('[SPLICE] Uncaught exception:', err);\n   930→  gracefulShutdown('uncaughtException');\n   931→});\n   932→\n   933→process.on('unhandledRejection', (reason, promise) => {\n   934→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n   935→});\n   936→\n   937→startServer();\n   938→\n\n</system-reminder>\n"}]},"uuid":"69e324a5-a9aa-43ea-85dc-475afd4942f0","timestamp":"2026-01-12T01:30:39.286Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"/**\n * SPLICE Backend Server\n *\n * Main entry point for the SPLICE backend API.\n * Orchestrates the audio analysis pipeline.\n *\n * Slices:\n * - Slice 4: Transcription (services/transcription.js)\n * - Slice 5: Take Detection (services/takeDetection.js)\n *\n * Architecture: Modular routes (see routes/ directory)\n */\n\n\nrequire('dotenv').config();\n\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst https = require('https');\nconst http = require('http');\nconst path = require('path');\nconst crypto = require('crypto');\n\n// MEDIUM-005: Request ID Tracing Middleware\nconst { requestIdMiddleware } = require('./middleware/requestId');\n\n// HIGH-008: Sentry Error Monitoring Integration\nlet Sentry = null;\nif (process.env.SENTRY_DSN) {\n  try {\n    Sentry = require('@sentry/node');\n    console.log('[SPLICE] Sentry module loaded, will initialize after app creation');\n  } catch (_err) {\n    console.warn('[SPLICE] @sentry/node not installed. Run: npm install @sentry/node');\n  }\n}\n\n// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// Import services\nconst usageTracking = require('./services/usageTracking');\nconst { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\nconst { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\nconst referralService = require('./services/referralService');\nconst licenseService = require('./services/licenseService');\nconst emailService = require('./services/emailService');\nconst { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\nconst { getSupportedFormats } = require('./services/captionExporter');\n\n// Import route modules\nconst healthRoutes = require('./routes/health');\nconst analyzeRoutes = require('./routes/analyze');\nconst silencesRoutes = require('./routes/silences');\nconst detectionRoutes = require('./routes/detection');\nconst exportRoutes = require('./routes/export');\nconst multitrackRoutes = require('./routes/multitrack');\nconst cutListRoutes = require('./routes/cutList');\nconst zoomRoutes = require('./routes/zoom');\nconst chaptersRoutes = require('./routes/chapters');\nconst youtubeRoutes = require('./routes/youtube');\nconst captionsRoutes = require('./routes/captions');\nconst textEditRoutes = require('./routes/textEdit');\nconst reframeRoutes = require('./routes/reframe');\nconst batchRoutes = require('./routes/batch');\nconst authRoutes = require('./routes/auth');\nconst billingRoutes = require('./routes/billing');\nconst referralRoutes = require('./routes/referral');\nconst licenseRoutes = require('./routes/license');\nconst musicRoutes = require('./routes/music');\n\n// Music generation worker (BullMQ background processor)\nconst { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\n\n// HIGH-011: API Versioning - v1 routes\nconst v1Routes = require('./routes/v1');\n\n// Stripe for webhooks\nconst Stripe = require('stripe');\n\n// MEDIUM-008: Pin Stripe API version for stability\n// This prevents breaking changes when Stripe releases new API versions\n// Should match version in services/stripeUsageReporting.js\nconst STRIPE_API_VERSION = '2024-12-18.acacia';\n\n// =============================================================================\n// SECURITY: Environment Variable Validation\n// Validate all required environment variables at startup\n// Fail fast with clear error messages if critical secrets are missing\n// =============================================================================\n\n/**\n * Validate required environment variables\n * @returns {Object} { valid: boolean, errors: string[] }\n */\nfunction validateEnvironmentVariables() {\n  const errors = [];\n  \n  // CRITICAL: Core infrastructure secrets\n  if (!process.env.STRIPE_SECRET_KEY) {\n    errors.push('STRIPE_SECRET_KEY is required (Stripe API key for billing)');\n  }\n  \n  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    errors.push('JWT_SECRET must be set to a secure random value (not default)');\n  } else if (process.env.JWT_SECRET.length < 32) {\n    // HIGH-001: Enforce minimum 32 character length for cryptographic security\n    errors.push('JWT_SECRET must be at least 32 characters for cryptographic security');\n  }\n  \n  if (!process.env.DATABASE_URL) {\n    errors.push('DATABASE_URL is required (PostgreSQL connection string)');\n  }\n  \n  if (!process.env.OPENAI_API_KEY) {\n    errors.push('OPENAI_API_KEY is required (OpenAI API for transcription)');\n  }\n  \n  // CRITICAL: Redis required for job queue and rate limiting in production\n  // Support both Railway Redis (REDIS_URL) and Upstash (UPSTASH_REDIS_URL)\n  // In development, will fall back to in-memory storage\n  if (process.env.NODE_ENV === 'production' && !process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n    errors.push('REDIS_URL or UPSTASH_REDIS_URL is required (Redis for job queue and rate limiting)');\n  } else if (!process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n    console.warn('[SPLICE] WARNING: Redis not configured. Using in-memory fallback (not suitable for production).');\n  }\n  \n  // CRITICAL: Webhook secret required in production\n  if (!process.env.STRIPE_WEBHOOK_SECRET) {\n    errors.push('STRIPE_WEBHOOK_SECRET is required (Stripe webhook signature verification)');\n  }\n  \n  // CONDITIONAL: Email provider validation\n  const emailProvider = process.env.EMAIL_PROVIDER || 'sendgrid';\n  if (emailProvider === 'sendgrid' && !process.env.SENDGRID_API_KEY) {\n    errors.push('SENDGRID_API_KEY is required when EMAIL_PROVIDER=sendgrid');\n  }\n  \n  // RECOMMENDED: R2 Storage (warn if missing, don't block)\n  if (!process.env.R2_ACCOUNT_ID || !process.env.R2_ACCESS_KEY_ID || !process.env.R2_SECRET_ACCESS_KEY) {\n    console.warn('[SPLICE] WARNING: R2 storage credentials not configured. Music generation uploads will fail.');\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n\n// Run validation in production\nif (isProduction) {\n  const validation = validateEnvironmentVariables();\n  \n  if (!validation.valid) {\n    console.error('[SPLICE] ========================================');\n    console.error('[SPLICE] CRITICAL: Missing required environment variables');\n    console.error('[SPLICE] ========================================');\n    validation.errors.forEach(error => {\n      console.error(`[SPLICE]   ❌ ${error}`);\n    });\n    console.error('[SPLICE] ========================================');\n    console.error('[SPLICE] Server startup aborted. Please configure all required environment variables.');\n    console.error('[SPLICE] See .env.example for complete documentation.');\n    process.exit(1);\n  }\n  \n  console.log('[SPLICE] ✅ Environment validation passed');\n}\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n  apiVersion: STRIPE_API_VERSION\n});\n\n// =============================================================================\n// PERF-FIX: Static Response Cache\n// Cache static endpoint responses at startup to avoid repeated computation\n// =============================================================================\n\n// Generate ETag from content\nfunction generateETag(content) {\n  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n}\n\n// Static response cache - populated at startup\nconst STATIC_RESPONSE_CACHE = {\n  profanityLanguages: null,\n  profanityBleeps: null,\n  exportFormats: null\n};\n\n// Initialize cache at startup (called after server starts)\nfunction initializeStaticCache() {\n  // Cache profanity languages\n  const languages = getSupportedLanguages();\n  STATIC_RESPONSE_CACHE.profanityLanguages = {\n    body: { success: true, languages },\n    etag: generateETag({ languages })\n  };\n\n  // Cache profanity bleeps\n  const sounds = getAvailableBleepSounds();\n  STATIC_RESPONSE_CACHE.profanityBleeps = {\n    body: { success: true, sounds },\n    etag: generateETag({ sounds })\n  };\n\n  // Cache export formats\n  const formats = getSupportedFormats();\n  STATIC_RESPONSE_CACHE.exportFormats = {\n    body: { success: true, formats },\n    etag: generateETag({ formats })\n  };\n\n  console.log('[SPLICE] Static response cache initialized');\n}\n\n// Helper to send cached response with ETag\nfunction sendCachedResponse(req, res, cacheKey) {\n  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n  if (!cached) {\n    return res.status(500).json({ error: 'Cache not initialized' });\n  }\n\n  // Check If-None-Match header for conditional GET\n  const clientETag = req.headers['if-none-match'];\n  if (clientETag === cached.etag) {\n    return res.status(304).end(); // Not Modified\n  }\n\n  // Send cached response with ETag and cache headers\n  res.set('ETag', cached.etag);\n  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n  res.json(cached.body);\n}\n\n// =============================================================================\n// Server Configuration\n// =============================================================================\n\nconst app = express();\nconst PORT = process.env.PORT || 3847;\n\n// HIGH-008: Initialize Sentry after app creation\nif (Sentry && process.env.SENTRY_DSN) {\n  Sentry.init({\n    dsn: process.env.SENTRY_DSN,\n    environment: process.env.NODE_ENV || 'development',\n    release: process.env.npm_package_version || '6.0.3',\n    tracesSampleRate: isProduction ? 0.1 : 1.0, // 10% in prod, 100% in dev\n    profilesSampleRate: isProduction ? 0.1 : 0, // Profile only in production\n    integrations: [\n      // Automatically instrument HTTP requests\n      Sentry.httpIntegration({ tracing: true }),\n      // Automatically instrument Express\n      Sentry.expressIntegration({ app }),\n    ],\n    // Filter out sensitive data\n    beforeSend(event) {\n      // Remove sensitive headers\n      if (event.request && event.request.headers) {\n        delete event.request.headers.authorization;\n        delete event.request.headers['x-stripe-customer-id'];\n        delete event.request.headers['stripe-signature'];\n      }\n      return event;\n    },\n  });\n  \n  // Add Sentry request handler as first middleware\n  app.use(Sentry.Handlers.requestHandler());\n  app.use(Sentry.Handlers.tracingHandler());\n  \n  console.log('[SPLICE] ✅ Sentry error monitoring initialized');\n}\n\n// MEDIUM-005: Request ID Tracing Middleware\n// Add early in chain to ensure all requests have correlation IDs for logging\napp.use(requestIdMiddleware);\n\n// HTTPS certificates (generated by mkcert) - only for local development\nlet httpsOptions = null;\nif (!isProduction) {\n  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n  const certPath = path.join(__dirname, 'localhost+1.pem');\n  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n    httpsOptions = {\n      key: fs.readFileSync(keyPath),\n      cert: fs.readFileSync(certPath)\n    };\n  }\n}\n\n// =============================================================================\n// Security Configuration\n// =============================================================================\n\n// CORS whitelist - restrict origins in production\nconst CORS_WHITELIST = [\n  'http://localhost:3000',\n  'http://localhost:3847',\n  'https://localhost:3847',\n  'http://127.0.0.1:3000',\n  'http://127.0.0.1:3847',\n  'https://127.0.0.1:3847',\n  'https://splice.app',\n  'https://www.splice.app',\n  'https://spliceclips.com',\n  'https://www.spliceclips.com',\n  'https://splice-api-production.up.railway.app',\n  'https://splice-website.vercel.app',\n  // Adobe CEP/UXP panels run from file:// or bolt://\n  'file://',\n  'bolt://'\n];\n\nconst corsOptions = {\n  origin: function (origin, callback) {\n    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n    if (!origin) {\n      return callback(null, true);\n    }\n    // Check if origin is in whitelist\n    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n      return callback(null, true);\n    }\n    // In development, allow all origins with warning\n    if (!isProduction) {\n      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n      return callback(null, true);\n    }\n    // In production, reject non-whitelisted origins\n    console.error(`[CORS] Blocked request from: ${origin}`);\n    return callback(new Error('Not allowed by CORS'));\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n};\n\napp.use(cors(corsOptions));\n\n// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n// This ensures rate limiting and logging use the correct client IP\nif (isProduction) {\n  app.set('trust proxy', 1);\n}\n\n// IP-based rate limiting (100 requests/minute per IP)\napp.use(ipRateLimit);\n\n// Security headers via helmet\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n  noSniff: true,\n  xssFilter: true,\n  hidePoweredBy: true\n}));\n\n// Helper to determine tier from price ID with logging\n// Supports both monthly and annual pricing\nfunction getTierFromPriceId(priceId) {\n  // Monthly prices\n  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n\n  // Annual prices (same tier, just different billing period)\n  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n\n  // Log unknown price ID for debugging\n  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n  return 'starter';\n}\n\n// =============================================================================\n// Stripe Webhook (must be before express.json())\n// =============================================================================\n\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n  let event;\n\n  try {\n    if (webhookSecret) {\n      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } else if (isProduction) {\n      // SECURITY: Reject unsigned webhooks in production\n      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n    } else {\n      // For local development testing only\n      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n      event = JSON.parse(bodyString);\n      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n    return res.status(400).json({ error: 'Webhook signature verification failed' });\n  }\n\n  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n\n  // Idempotency check - skip if already processed\n  if (await usageTracking.isEventProcessed(event.id)) {\n    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n    return res.json({ received: true, skipped: true });\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Get tier from price ID\n        const priceId = subscription.items?.data?.[0]?.price?.id;\n        const tier = getTierFromPriceId(priceId);\n\n        // Update user tier and reset hours\n        await usageTracking.updateTier(customerId, tier);\n        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n\n        // Initialize music credits for new subscriptions\n        if (event.type === 'customer.subscription.created') {\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Update trial end date if present\n        if (subscription.trial_end) {\n          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n        }\n\n        // Generate license key for new subscriptions with retry and delivery\n        if (event.type === 'customer.subscription.created') {\n          let licenseResult = null;\n          let retryCount = 0;\n          const maxRetries = 3;\n\n          // Retry mechanism for license key generation\n          while (retryCount < maxRetries) {\n            licenseResult = await licenseService.generateLicenseKey(customerId);\n            if (licenseResult.success) {\n              break;\n            }\n            retryCount++;\n            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n            // Wait before retry (exponential backoff)\n            if (retryCount < maxRetries) {\n              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n            }\n          }\n\n          if (licenseResult && licenseResult.success) {\n            // SECURITY: Mask license key in logs\n            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n\n            // Store license key in Stripe subscription metadata as backup\n            try {\n              await stripe.subscriptions.update(subscription.id, {\n                metadata: {\n                  license_key: licenseResult.key,\n                  license_generated_at: new Date().toISOString()\n                }\n              });\n              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n            } catch (stripeErr) {\n              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n            }\n\n            // Get customer email and send license key\n            try {\n              const customer = await stripe.customers.retrieve(customerId);\n              if (customer.email) {\n                // SECURITY: Mask sensitive data in logs\n                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n\n                // Send license key email\n                try {\n                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n                } catch (sendErr) {\n                  // Log but don't fail - license is stored in Stripe metadata as backup\n                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n                }\n\n                // Store email in database for reference\n                await usageTracking.updateTier(customerId, tier, customer.email);\n              } else {\n                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n              }\n            } catch (emailErr) {\n              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n            }\n          } else {\n            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n            console.error(`[SPLICE] ${errorMsg}`);\n            return res.status(500).json({ error: errorMsg });\n          }\n        }\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Downgrade to cancelled (0 hours)\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const subscriptionId = invoice.subscription;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in invoice event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Reset hours on successful payment (new billing period)\n        let tier = 'starter';\n        if (subscriptionId) {\n          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n          const priceId = subscription.items?.data?.[0]?.price?.id;\n          tier = getTierFromPriceId(priceId);\n\n          await usageTracking.resetHours(customerId, tier);\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Check for affiliate coupon and record commission\n        const discount = invoice.discount;\n        if (discount && discount.coupon) {\n          const couponId = discount.coupon.id;\n          // Check if this is an affiliate code (like JIMMYN)\n          if (referralService.AFFILIATE_CODES[couponId]) {\n            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n            await referralService.recordAffiliateCommission(\n              couponId,\n              customerId,\n              amountPaid,\n              tier\n            );\n            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n          }\n        }\n        break;\n      }\n\n      case 'invoice.payment_failed': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const attemptCount = invoice.attempt_count || 1;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in payment_failed event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n\n        // Stripe will retry automatically per retry settings\n        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n        // Send warning email on final attempt\n        if (attemptCount >= 3) {\n          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n          // Send warning email to customer about impending cancellation\n          try {\n            const customer = await stripe.customers.retrieve(customerId);\n            if (customer.email) {\n              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n            }\n          } catch (emailErr) {\n            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n          }\n        }\n        break;\n      }\n\n      case 'customer.deleted': {\n        const customer = event.data.object;\n        const customerId = customer.id;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Clean up user data - downgrade to cancelled\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n        break;\n      }\n\n      default:\n        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n    }\n\n    // Record event as processed (idempotency)\n    await usageTracking.recordWebhookEvent(event.id, event.type);\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error('[SPLICE] Webhook handler error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Parse JSON body for all other routes\n// SECURITY: Limit JSON body size to prevent DoS attacks\napp.use(express.json({ limit: '10mb' }));\n\n// Parse cookies for CSRF token validation\napp.use(cookieParser());\n\n// =============================================================================\n// Route Configuration Options\n// =============================================================================\n\nconst routeOptions = {\n  middleware: {\n    requireCredits,\n    requireFeature,\n    authenticateToken\n  },\n  services: {\n    usageTracking,\n    referralService,\n    licenseService,\n    emailService,\n    stripe\n  },\n  authHelpers: {\n    generateToken,\n    generateRefreshToken,\n    verifyToken,\n    maskSensitiveData,\n    blacklistToken\n  },\n  staticCache: STATIC_RESPONSE_CACHE,\n  sendCachedResponse\n};\n\n// =============================================================================\n// Mount Routes\n// =============================================================================\n\n// Health check and system endpoints (no prefix)\napp.use('/', healthRoutes(routeOptions));\n\n// Core analysis endpoints\napp.use('/', analyzeRoutes(routeOptions));\napp.use('/', silencesRoutes(routeOptions));\napp.use('/', detectionRoutes(routeOptions));\n\n// Export endpoints\napp.use('/export', exportRoutes(routeOptions));\n\n// Multitrack/Multicam endpoints\napp.use('/multitrack', multitrackRoutes(routeOptions));\n\n// Cut list generation\napp.use('/cut-list', cutListRoutes(routeOptions));\n\n// Legacy XML processing endpoint (backwards compatibility)\nconst { processXMLFile } = require('./services/xmlProcessor');\napp.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n  const {\n    xmlPath,\n    silences,\n    removeGaps = true,\n    outputPath = null\n  } = req.body;\n\n  if (!xmlPath) {\n    return res.status(400).json({ error: 'xmlPath is required' });\n  }\n\n  if (!silences || !Array.isArray(silences)) {\n    return res.status(400).json({ error: 'silences array is required' });\n  }\n\n  if (!fs.existsSync(xmlPath)) {\n    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n  }\n\n  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n\n  try {\n    const result = await processXMLFile(xmlPath, silences, {\n      outputPath,\n      removeGaps\n    });\n\n    res.json({\n      success: true,\n      inputPath: xmlPath,\n      outputPath: result.outputPath,\n      stats: result.stats\n    });\n  } catch (err) {\n    console.error('[SPLICE] XML processing error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Auto zoom endpoints\napp.use('/zoom', zoomRoutes(routeOptions));\n\n// Chapter detection endpoints\napp.use('/chapters', chaptersRoutes(routeOptions));\n\n// YouTube content generation\napp.use('/youtube', youtubeRoutes(routeOptions));\n\n// Animated captions endpoints\napp.use('/captions', captionsRoutes(routeOptions));\n\n// Text-based editing endpoints\napp.use('/text-edit', textEditRoutes(routeOptions));\n\n// Social reframe endpoints\napp.use('/reframe', reframeRoutes(routeOptions));\napp.use('/faces', reframeRoutes.facesRouter(routeOptions));\n\n// Batch processing endpoints\napp.use('/batch', batchRoutes(routeOptions));\n\n// Authentication endpoints\napp.use('/auth', authRoutes(routeOptions));\n\n// Billing and credits endpoints\napp.use('/', billingRoutes(routeOptions));\n\n// Referral system endpoints\napp.use('/referral', referralRoutes(routeOptions));\n\n// License key endpoints\napp.use('/license', licenseRoutes(routeOptions));\n\n// AI Music generation endpoints\napp.use('/music', musicRoutes(routeOptions));\n\n// =============================================================================\n// HIGH-011: API Versioning\n// Mount versioned routes under /api/v1 prefix\n// Maintain backwards compatibility with deprecation warnings\n// =============================================================================\n\n// Mount v1 API routes\napp.use('/api/v1', v1Routes(routeOptions));\n\n// Deprecation warning middleware for unversioned API calls\n// This helps clients migrate to versioned endpoints\napp.use('/api', (req, res, next) => {\n  // Skip if already using versioned endpoint\n  if (req.path.startsWith('/v1')) {\n    return next();\n  }\n  \n  // Add deprecation warning header\n  res.set('X-API-Deprecation-Warning', 'Unversioned API endpoints are deprecated. Please migrate to /api/v1/');\n  res.set('X-API-Version', 'unversioned');\n  res.set('Deprecation', 'true');\n  res.set('Sunset', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toUTCString()); // 90 days from now\n  \n  next();\n});\n\n// HIGH-008: Add Sentry error handler (must be after all routes)\nif (Sentry) {\n  app.use(Sentry.Handlers.errorHandler({\n    shouldHandleError(error) {\n      // Capture all 4xx and 5xx errors\n      if (error.status >= 400) {\n        return true;\n      }\n      return true;\n    },\n  }));\n}\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\n// Track active server for graceful shutdown\nlet server = null;\n\n// Initialize database and start server\nasync function startServer() {\n  try {\n    await usageTracking.initDatabase();\n    await referralService.initReferralTables();\n    await licenseService.initLicenseTables();\n    console.log('[SPLICE] Database initialized');\n\n    // PERF-FIX: Initialize static response cache at startup\n    initializeStaticCache();\n\n    // Start music generation worker (BullMQ background processor)\n    // Only starts if Redis is configured and Replicate API key is available\n    if (process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL) {\n      if (process.env.REPLICATE_API_TOKEN) {\n        try {\n          createMusicWorker();\n          console.log('[SPLICE] ✅ Music generation worker started');\n        } catch (workerErr) {\n          console.error('[SPLICE] ⚠️ Failed to start music worker:', workerErr.message);\n          // Don't fail server startup - music generation will be unavailable\n        }\n      } else {\n        console.warn('[SPLICE] ⚠️ REPLICATE_API_TOKEN not set - music generation disabled');\n      }\n    } else {\n      console.warn('[SPLICE] ⚠️ Redis not configured - music generation queue disabled');\n    }\n\n    if (isProduction || !httpsOptions) {\n      // Production: Railway provides TLS termination, use HTTP\n      server = http.createServer(app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n      });\n    } else {\n      // Development: Use HTTPS with local certificates\n      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n      });\n    }\n  } catch (err) {\n    console.error('[SPLICE] Failed to start server:', err);\n    process.exit(1);\n  }\n}\n\n// =============================================================================\n// Graceful Shutdown\n// =============================================================================\n\nasync function gracefulShutdown(signal) {\n  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n\n  // Stop accepting new connections\n  if (server) {\n    server.close(() => {\n      console.log('[SPLICE] HTTP server closed');\n    });\n  }\n\n  // Shutdown music worker (allows in-progress jobs to complete)\n  try {\n    await shutdownWorker();\n    console.log('[SPLICE] Music worker shut down');\n  } catch (err) {\n    console.error('[SPLICE] Error shutting down music worker:', err.message);\n  }\n\n  // Close database pool\n  try {\n    await usageTracking.closePool();\n    console.log('[SPLICE] Database pool closed');\n  } catch (err) {\n    console.error('[SPLICE] Error closing database pool:', err.message);\n  }\n\n  // Give ongoing requests time to complete (max 10 seconds)\n  setTimeout(() => {\n    console.log('[SPLICE] Graceful shutdown complete');\n    process.exit(0);\n  }, 10000);\n}\n\n// Handle termination signals\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (err) => {\n  console.error('[SPLICE] Uncaught exception:', err);\n  gracefulShutdown('uncaughtException');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n});\n\nstartServer();\n","numLines":938,"startLine":1,"totalLines":938}}}
{"parentUuid":"69e324a5-a9aa-43ea-85dc-475afd4942f0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FTmTp8bEYU32vyyhhjXtg9","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check for any additional queue-related services and look at the music routes to understand the full picture:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":21809,"cache_read_input_tokens":39529,"cache_creation":{"ephemeral_5m_input_tokens":21809,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2csBPQvTVjmDELgkPQF","type":"assistant","uuid":"8d52e1ed-ee6b-45be-95c9-ac3872147403","timestamp":"2026-01-12T01:30:43.191Z"}
{"parentUuid":"8d52e1ed-ee6b-45be-95c9-ac3872147403","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FTmTp8bEYU32vyyhhjXtg9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015rx1qNoMqDpn4qZGpnrwwU","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/music.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":21809,"cache_read_input_tokens":39529,"cache_creation":{"ephemeral_5m_input_tokens":21809,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2csBPQvTVjmDELgkPQF","type":"assistant","uuid":"8000c850-6726-4d4d-a88f-df185cd8d1d6","timestamp":"2026-01-12T01:30:44.129Z"}
{"parentUuid":"8000c850-6726-4d4d-a88f-df185cd8d1d6","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FTmTp8bEYU32vyyhhjXtg9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01L4QYjAitJwjsMwDCU6VCct","name":"Grep","input":{"pattern":"getRedisConnection|getMusicQueue|createMusicWorker","path":"/Users/imorgado/SPLICE/splice-backend","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":21809,"cache_read_input_tokens":39529,"cache_creation":{"ephemeral_5m_input_tokens":21809,"ephemeral_1h_input_tokens":0},"output_tokens":209,"service_tier":"standard"}},"requestId":"req_011CX2csBPQvTVjmDELgkPQF","type":"assistant","uuid":"ffa1440c-f24a-4a7c-b233-e6e4b2ee0c9d","timestamp":"2026-01-12T01:30:45.264Z"}
{"parentUuid":"ffa1440c-f24a-4a7c-b233-e6e4b2ee0c9d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L4QYjAitJwjsMwDCU6VCct","type":"tool_result","content":"splice-backend/workers/musicWorker.js:10:  getRedisConnection,\nsplice-backend/workers/musicWorker.js:354:function createMusicWorker(options = {}) {\nsplice-backend/workers/musicWorker.js:362:      connection: getRedisConnection(),\nsplice-backend/workers/musicWorker.js:423:  createMusicWorker,\nsplice-backend/workers/musicWorker.js:432:  const worker = createMusicWorker();\nsplice-backend/services/musicQueue.js:65:function getRedisConnection() {\nsplice-backend/services/musicQueue.js:102:      connection: getRedisConnection(),\nsplice-backend/services/musicQueue.js:256:  const mainQueue = getMusicQueue();\nsplice-backend/services/musicQueue.js:358:function getMusicQueue() {\nsplice-backend/services/musicQueue.js:361:      connection: getRedisConnection(),\nsplice-backend/services/musicQueue.js:406:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:464:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:509:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:554:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:583:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:609:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:628:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:675:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:725:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:775:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:841:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:872:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:894:  getMusicQueue,\nsplice-backend/services/musicQueue.js:895:  getRedisConnection,\nsplice-backend/server.js:76:const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\nsplice-backend/server.js:855:          createMusicWorker();\nsplice-backend/tests/music-phase0-e2e.test.js:209:  assert(musicWorkerCode.includes('getRedisConnection'), 'Should use getRedisConnection');\nsplice-backend/tests/music-phase0-e2e.test.js:214:test('musicWorker exports createMusicWorker function', () => {\nsplice-backend/tests/music-phase0-e2e.test.js:215:  assert(musicWorkerCode.includes('function createMusicWorker'), 'Should have createMusicWorker');"}]},"uuid":"bc09b2cb-9e4e-4973-bda0-0fc78da147da","timestamp":"2026-01-12T01:30:45.308Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"splice-backend/workers/musicWorker.js:10:  getRedisConnection,\nsplice-backend/workers/musicWorker.js:354:function createMusicWorker(options = {}) {\nsplice-backend/workers/musicWorker.js:362:      connection: getRedisConnection(),\nsplice-backend/workers/musicWorker.js:423:  createMusicWorker,\nsplice-backend/workers/musicWorker.js:432:  const worker = createMusicWorker();\nsplice-backend/services/musicQueue.js:65:function getRedisConnection() {\nsplice-backend/services/musicQueue.js:102:      connection: getRedisConnection(),\nsplice-backend/services/musicQueue.js:256:  const mainQueue = getMusicQueue();\nsplice-backend/services/musicQueue.js:358:function getMusicQueue() {\nsplice-backend/services/musicQueue.js:361:      connection: getRedisConnection(),\nsplice-backend/services/musicQueue.js:406:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:464:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:509:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:554:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:583:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:609:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:628:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:675:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:725:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:775:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:841:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:872:  const queue = getMusicQueue();\nsplice-backend/services/musicQueue.js:894:  getMusicQueue,\nsplice-backend/services/musicQueue.js:895:  getRedisConnection,\nsplice-backend/server.js:76:const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\nsplice-backend/server.js:855:          createMusicWorker();\nsplice-backend/tests/music-phase0-e2e.test.js:209:  assert(musicWorkerCode.includes('getRedisConnection'), 'Should use getRedisConnection');\nsplice-backend/tests/music-phase0-e2e.test.js:214:test('musicWorker exports createMusicWorker function', () => {\nsplice-backend/tests/music-phase0-e2e.test.js:215:  assert(musicWorkerCode.includes('function createMusicWorker'), 'Should have createMusicWorker');","numLines":29}}
{"parentUuid":"bc09b2cb-9e4e-4973-bda0-0fc78da147da","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015rx1qNoMqDpn4qZGpnrwwU","type":"tool_result","content":"     1→/**\n     2→ * Music Routes\n     3→ *\n     4→ * AI Music generation endpoints (Phase 8)\n     5→ */\n     6→\n     7→const express = require('express');\n     8→\n     9→// Lazy-load music services to prevent startup failures if deps missing\n    10→let musicQueue, songIdentification, musicGeneration, r2Storage, musicAlignment, musicTimeline;\n    11→let musicServicesLoaded = false;\n    12→let musicGenerationLoaded = false;\n    13→\n    14→/**\n    15→ * Load only musicGeneration service (no Redis dependency)\n    16→ * Used by /moods and /instruments endpoints\n    17→ */\n    18→function loadMusicGenerationOnly() {\n    19→  if (!musicGenerationLoaded) {\n    20→    try {\n    21→      musicGeneration = require('../services/musicGeneration');\n    22→      musicGenerationLoaded = true;\n    23→    } catch (err) {\n    24→      console.warn('[SPLICE] Music generation service not available:', err.message);\n    25→    }\n    26→  }\n    27→}\n    28→\n    29→/**\n    30→ * Load all music services including Redis-dependent ones\n    31→ * Used by endpoints that need queue functionality\n    32→ */\n    33→function loadMusicServices() {\n    34→  if (!musicServicesLoaded) {\n    35→    try {\n    36→      // Load musicGeneration first (no Redis dependency)\n    37→      loadMusicGenerationOnly();\n    38→\n    39→      // Load Redis-dependent services with timeout protection\n    40→      songIdentification = require('../services/songIdentification');\n    41→      r2Storage = require('../services/r2Storage');\n    42→      musicAlignment = require('../services/musicAlignment');\n    43→      musicTimeline = require('../services/musicTimeline');\n    44→\n    45→      // Load musicQueue last (Redis-dependent, may throw)\n    46→      try {\n    47→        musicQueue = require('../services/musicQueue');\n    48→      } catch (queueErr) {\n    49→        console.warn('[SPLICE] Music queue not available (Redis not configured):', queueErr.message);\n    50→        // Continue without queue - some endpoints will return 503\n    51→      }\n    52→\n    53→      musicServicesLoaded = true;\n    54→    } catch (err) {\n    55→      console.warn('[SPLICE] Music services not available:', err.message);\n    56→    }\n    57→  }\n    58→}\n    59→\n    60→/**\n    61→ * Create music routes\n    62→ * @param {Object} options - Route configuration options\n    63→ * @param {Object} options.middleware - Shared middleware (requireCredits)\n    64→ * @param {Object} options.services - Shared services (usageTracking)\n    65→ * @returns {express.Router}\n    66→ */\n    67→function createMusicRoutes(options = {}) {\n    68→  const router = express.Router();\n    69→  const { requireCredits } = options.middleware || {};\n    70→  const { usageTracking } = options.services || {};\n    71→\n    72→  // Note: Services are now loaded lazily on first route access\n    73→  // This prevents Redis dependency from blocking startup\n    74→\n    75→  /**\n    76→   * POST /identify - Identify song from YouTube URL\n    77→   */\n    78→  router.post('/identify', requireCredits, async (req, res) => {\n    79→    const { youtubeUrl } = req.body;\n    80→\n    81→    if (!youtubeUrl) {\n    82→      return res.status(400).json({ error: 'youtubeUrl is required' });\n    83→    }\n    84→\n    85→    if (!songIdentification) {\n    86→      return res.status(503).json({ error: 'Song identification service not available' });\n    87→    }\n    88→\n    89→    try {\n    90→      // Validate URL\n    91→      const validation = songIdentification.validateYouTubeUrl(youtubeUrl);\n    92→      if (!validation.valid) {\n    93→        return res.status(400).json({ error: validation.error });\n    94→      }\n    95→\n    96→      // Check dependencies\n    97→      const deps = await songIdentification.checkDependencies();\n    98→      if (!deps.ytdlp) {\n    99→        return res.status(503).json({ error: 'yt-dlp is not installed on server' });\n   100→      }\n   101→      if (!deps.ffmpeg) {\n   102→        return res.status(503).json({ error: 'FFmpeg is not installed on server' });\n   103→      }\n   104→\n   105→      // Check ACRCloud credentials\n   106→      if (!songIdentification.hasACRCloudCredentials()) {\n   107→        return res.status(503).json({ error: 'ACRCloud credentials not configured' });\n   108→      }\n   109→\n   110→      // Identify song\n   111→      const result = await songIdentification.identifyFromYouTube(youtubeUrl);\n   112→\n   113→      res.json(result);\n   114→\n   115→    } catch (err) {\n   116→      console.error('[SPLICE] Song identification error:', err.message);\n   117→      res.status(500).json({ error: err.message || 'Song identification failed' });\n   118→    }\n   119→  });\n   120→\n   121→  /**\n   122→   * POST /generate - Start music generation job\n   123→   */\n   124→  router.post('/generate', requireCredits, async (req, res) => {\n   125→    const { youtubeUrl, prompt, duration, mood, instruments, referenceSong } = req.body;\n   126→    const customerId = req.stripeCustomerId;\n   127→\n   128→    if (!customerId) {\n   129→      return res.status(401).json({ error: 'Authentication required' });\n   130→    }\n   131→\n   132→    if (!musicQueue) {\n   133→      return res.status(503).json({ error: 'Music generation service not available' });\n   134→    }\n   135→\n   136→    try {\n   137→      // Validate options if musicGeneration is available\n   138→      if (musicGeneration) {\n   139→        const validation = musicGeneration.validateOptions({ duration, mood, instruments });\n   140→        if (!validation.valid) {\n   141→          return res.status(400).json({ error: validation.errors.join(', ') });\n   142→        }\n   143→      }\n   144→\n   145→      // Add job to queue\n   146→      const result = await musicQueue.addMusicJob({\n   147→        customerId,\n   148→        youtubeUrl,\n   149→        prompt,\n   150→        duration: duration || 60,\n   151→        mood: mood || 'neutral',\n   152→        instruments: instruments || [],\n   153→        referenceSong\n   154→      });\n   155→\n   156→      res.json({\n   157→        success: true,\n   158→        jobId: result.jobId,\n   159→        status: result.status,\n   160→        estimatedTime: result.estimatedTime,\n   161→        statusUrl: `/music/status/${result.jobId}`\n   162→      });\n   163→\n   164→    } catch (err) {\n   165→      console.error('[SPLICE] Music generation error:', err.message);\n   166→      res.status(500).json({ error: err.message || 'Failed to start music generation' });\n   167→    }\n   168→  });\n   169→\n   170→  /**\n   171→   * POST /generate-variations - Generate 3 song variations for user selection\n   172→   */\n   173→  router.post('/generate-variations', requireCredits, async (req, res) => {\n   174→    const { prompt, duration, mood, instruments, referenceSong } = req.body;\n   175→    const customerId = req.stripeCustomerId;\n   176→\n   177→    if (!customerId) {\n   178→      return res.status(401).json({ error: 'Authentication required' });\n   179→    }\n   180→\n   181→    if (!musicQueue) {\n   182→      return res.status(503).json({ error: 'Music generation service not available' });\n   183→    }\n   184→\n   185→    try {\n   186→      // Validate options if musicGeneration is available\n   187→      if (musicGeneration) {\n   188→        const validation = musicGeneration.validateOptions({ duration, mood, instruments });\n   189→        if (!validation.valid) {\n   190→          return res.status(400).json({ error: validation.errors.join(', ') });\n   191→        }\n   192→      }\n   193→\n   194→      // Check for variations credits (2.5 credits = 3 music credits equivalent)\n   195→      const hasCredits = await usageTracking.checkVariationsCredits(customerId);\n   196→      if (!hasCredits.canGenerate) {\n   197→        return res.status(402).json({\n   198→          error: 'Insufficient credits for variations',\n   199→          creditsRequired: 2.5,\n   200→          creditsAvailable: hasCredits.creditsAvailable\n   201→        });\n   202→      }\n   203→\n   204→      // Add variations job to queue\n   205→      const result = await musicQueue.addVariationsJob({\n   206→        customerId,\n   207→        prompt,\n   208→        duration: duration || 60,\n   209→        mood: mood || 'neutral',\n   210→        instruments: instruments || [],\n   211→        referenceSong\n   212→      });\n   213→\n   214→      res.json({\n   215→        success: true,\n   216→        jobId: result.jobId,\n   217→        status: result.status,\n   218→        isVariations: true,\n   219→        estimatedTime: result.estimatedTime,\n   220→        statusUrl: `/music/variations/status/${result.jobId}`\n   221→      });\n   222→\n   223→    } catch (err) {\n   224→      console.error('[SPLICE] Music variations error:', err.message);\n   225→      res.status(500).json({ error: err.message || 'Failed to start variations generation' });\n   226→    }\n   227→  });\n   228→\n   229→  /**\n   230→   * POST /generate-scene-aware - Generate music with transcript analysis\n   231→   */\n   232→  router.post('/generate-scene-aware', requireCredits, async (req, res) => {\n   233→    const { segments, prompt, duration, mood, instruments, referenceSong } = req.body;\n   234→    const customerId = req.stripeCustomerId;\n   235→\n   236→    if (!customerId) {\n   237→      return res.status(401).json({ error: 'Authentication required' });\n   238→    }\n   239→\n   240→    if (!musicQueue) {\n   241→      return res.status(503).json({ error: 'Music generation service not available' });\n   242→    }\n   243→\n   244→    // Validate segments\n   245→    if (!segments || !Array.isArray(segments) || segments.length === 0) {\n   246→      return res.status(400).json({ error: 'Transcript segments are required' });\n   247→    }\n   248→\n   249→    try {\n   250→      // Validate scene-aware options\n   251→      if (musicGeneration) {\n   252→        const validation = musicGeneration.validateSceneAwareOptions(segments, { duration, mood, instruments });\n   253→        if (!validation.valid) {\n   254→          return res.status(400).json({ error: validation.errors.join(', ') });\n   255→        }\n   256→      }\n   257→\n   258→      // Check for scene-aware credits (1.5 credits)\n   259→      const hasCredits = await usageTracking.checkSceneAwareCredits(customerId);\n   260→      if (!hasCredits.canGenerate) {\n   261→        return res.status(402).json({\n   262→          error: 'Insufficient credits for scene-aware music',\n   263→          creditsRequired: 1.5,\n   264→          creditsAvailable: hasCredits.creditsAvailable\n   265→        });\n   266→      }\n   267→\n   268→      // Add scene-aware job to queue with scene analysis flag\n   269→      const result = await musicQueue.addMusicJob({\n   270→        customerId,\n   271→        prompt,\n   272→        duration: duration || 60,\n   273→        mood: mood || 'neutral',\n   274→        instruments: instruments || [],\n   275→        referenceSong,\n   276→        isSceneAware: true,\n   277→        segments\n   278→      });\n   279→\n   280→      res.json({\n   281→        success: true,\n   282→        jobId: result.jobId,\n   283→        status: result.status,\n   284→        isSceneAware: true,\n   285→        estimatedTime: result.estimatedTime,\n   286→        statusUrl: `/music/status/${result.jobId}`\n   287→      });\n   288→\n   289→    } catch (err) {\n   290→      console.error('[SPLICE] Scene-aware music error:', err.message);\n   291→      res.status(500).json({ error: err.message || 'Failed to start scene-aware music generation' });\n   292→    }\n   293→  });\n   294→\n   295→  /**\n   296→   * GET /variations/status/:jobId - Get variations job status with detailed progress\n   297→   */\n   298→  router.get('/variations/status/:jobId', requireCredits, async (req, res) => {\n   299→    const { jobId } = req.params;\n   300→    const customerId = req.stripeCustomerId;\n   301→\n   302→    if (!musicQueue) {\n   303→      return res.status(503).json({ error: 'Music generation service not available' });\n   304→    }\n   305→\n   306→    try {\n   307→      const status = await musicQueue.getVariationsJobStatus(jobId);\n   308→\n   309→      if (!status) {\n   310→        return res.status(404).json({ error: 'Job not found' });\n   311→      }\n   312→\n   313→      // Verify ownership\n   314→      if (status.data.customerId !== customerId) {\n   315→        return res.status(403).json({ error: 'Not authorized to access this job' });\n   316→      }\n   317→\n   318→      res.json(status);\n   319→\n   320→    } catch (err) {\n   321→      console.error('[SPLICE] Variations status error:', err.message);\n   322→      res.status(500).json({ error: err.message || 'Failed to get job status' });\n   323→    }\n   324→  });\n   325→\n   326→  /**\n   327→   * POST /variations/:jobId/select - Select a variation to finalize\n   328→   */\n   329→  router.post('/variations/:jobId/select', requireCredits, async (req, res) => {\n   330→    const { jobId } = req.params;\n   331→    const { variationIndex } = req.body;\n   332→    const customerId = req.stripeCustomerId;\n   333→\n   334→    if (!musicQueue) {\n   335→      return res.status(503).json({ error: 'Music generation service not available' });\n   336→    }\n   337→\n   338→    if (variationIndex === undefined || variationIndex === null) {\n   339→      return res.status(400).json({ error: 'variationIndex is required' });\n   340→    }\n   341→\n   342→    const index = parseInt(variationIndex);\n   343→    if (isNaN(index) || index < 0 || index > 2) {\n   344→      return res.status(400).json({ error: 'variationIndex must be 0, 1, or 2' });\n   345→    }\n   346→\n   347→    try {\n   348→      // Select the variation\n   349→      const result = await musicQueue.selectVariation(jobId, index, customerId);\n   350→\n   351→      // Deduct variations credits (2.5 credits)\n   352→      await usageTracking.deductVariationsCredit(customerId);\n   353→\n   354→      res.json({\n   355→        success: true,\n   356→        ...result\n   357→      });\n   358→\n   359→    } catch (err) {\n   360→      console.error('[SPLICE] Variation selection error:', err.message);\n   361→      res.status(500).json({ error: err.message || 'Failed to select variation' });\n   362→    }\n   363→  });\n   364→\n   365→  /**\n   366→   * GET /status/:jobId - Get job status\n   367→   */\n   368→  router.get('/status/:jobId', requireCredits, async (req, res) => {\n   369→    const { jobId } = req.params;\n   370→    const customerId = req.stripeCustomerId;\n   371→\n   372→    if (!musicQueue) {\n   373→      return res.status(503).json({ error: 'Music generation service not available' });\n   374→    }\n   375→\n   376→    try {\n   377→      const status = await musicQueue.getJobStatus(jobId);\n   378→\n   379→      if (!status) {\n   380→        return res.status(404).json({ error: 'Job not found' });\n   381→      }\n   382→\n   383→      // Verify ownership\n   384→      if (status.data.customerId !== customerId) {\n   385→        return res.status(403).json({ error: 'Access denied' });\n   386→      }\n   387→\n   388→      res.json(status);\n   389→\n   390→    } catch (err) {\n   391→      console.error('[SPLICE] Job status error:', err.message);\n   392→      res.status(500).json({ error: err.message || 'Failed to get job status' });\n   393→    }\n   394→  });\n   395→\n   396→  /**\n   397→   * GET /library - Get user's music library\n   398→   */\n   399→  router.get('/library', requireCredits, async (req, res) => {\n   400→    const customerId = req.stripeCustomerId;\n   401→\n   402→    if (!customerId) {\n   403→      return res.status(401).json({ error: 'Authentication required' });\n   404→    }\n   405→\n   406→    if (!musicQueue) {\n   407→      return res.status(503).json({ error: 'Music generation service not available' });\n   408→    }\n   409→\n   410→    try {\n   411→      const jobs = await musicQueue.getCustomerJobs(customerId, {\n   412→        limit: parseInt(req.query.limit) || 50,\n   413→        offset: parseInt(req.query.offset) || 0\n   414→      });\n   415→\n   416→      // Filter to only completed jobs for library\n   417→      const library = jobs.filter(j => j.status === 'completed');\n   418→\n   419→      res.json(library);\n   420→\n   421→    } catch (err) {\n   422→      console.error('[SPLICE] Music library error:', err.message);\n   423→      res.status(500).json({ error: err.message || 'Failed to load music library' });\n   424→    }\n   425→  });\n   426→\n   427→  /**\n   428→   * GET /credits - Get music credits balance\n   429→   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   430→   */\n   431→  router.get('/credits', requireCredits, async (req, res) => {\n   432→    const customerId = req.stripeCustomerId;\n   433→\n   434→    if (!customerId) {\n   435→      return res.status(401).json({ error: 'Authentication required' });\n   436→    }\n   437→\n   438→    try {\n   439→      // Get credits from database using usageTracking\n   440→      const credits = await usageTracking.getMusicCredits(customerId);\n   441→\n   442→      res.json(credits);\n   443→\n   444→    } catch (err) {\n   445→      console.error('[SPLICE] Music credits error:', err.message);\n   446→      res.status(500).json({ error: err.message || 'Failed to get credits' });\n   447→    }\n   448→  });\n   449→\n   450→  /**\n   451→   * GET /moods - Get available mood presets\n   452→   * Note: Uses lightweight loader (no Redis dependency)\n   453→   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   454→   */\n   455→  router.get('/moods', (req, res) => {\n   456→    loadMusicGenerationOnly();\n   457→    if (!musicGeneration) {\n   458→      return res.status(503).json({ error: 'Music service not available' });\n   459→    }\n   460→\n   461→    res.json(musicGeneration.getAvailableMoods());\n   462→  });\n   463→\n   464→  /**\n   465→   * GET /instruments - Get available instrument presets\n   466→   * Note: Uses lightweight loader (no Redis dependency)\n   467→   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   468→   */\n   469→  router.get('/instruments', (req, res) => {\n   470→    loadMusicGenerationOnly();\n   471→    if (!musicGeneration) {\n   472→      return res.status(503).json({ error: 'Music service not available' });\n   473→    }\n   474→\n   475→    res.json(musicGeneration.getAvailableInstruments());\n   476→  });\n   477→\n   478→  /**\n   479→   * GET /queue-stats - Get queue statistics (admin only)\n   480→   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   481→   * SECURITY: Restricted to admin customers only\n   482→   */\n   483→  router.get('/queue-stats', requireCredits, async (req, res) => {\n   484→    // SECURITY: Check for admin access\n   485→    // Only allow specific admin customer IDs (configured via env var)\n   486→    const adminCustomerIds = (process.env.ADMIN_CUSTOMER_IDS || '').split(',').filter(Boolean);\n   487→    const customerId = req.stripeCustomerId;\n   488→\n   489→    if (!customerId || (adminCustomerIds.length > 0 && !adminCustomerIds.includes(customerId))) {\n   490→      return res.status(403).json({ error: 'Admin access required' });\n   491→    }\n   492→\n   493→    loadMusicServices();\n   494→    if (!musicQueue) {\n   495→      return res.status(503).json({ error: 'Music service not available' });\n   496→    }\n   497→\n   498→    try {\n   499→      const stats = await musicQueue.getQueueStats();\n   500→      res.json(stats);\n   501→    } catch (err) {\n   502→      console.error('[SPLICE] Queue stats error:', err.message);\n   503→      res.status(500).json({ error: err.message || 'Failed to get queue stats' });\n   504→    }\n   505→  });\n   506→\n   507→  /**\n   508→   * GET /alignment-options - Get alignment configuration options\n   509→   * Note: Loads alignment service on demand (no Redis dependency)\n   510→   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   511→   */\n   512→  router.get('/alignment-options', (req, res) => {\n   513→    // Load alignment service on demand if not already loaded\n   514→    if (!musicAlignment) {\n   515→      try {\n   516→        musicAlignment = require('../services/musicAlignment');\n   517→      } catch (err) {\n   518→        console.warn('[SPLICE] Music alignment service not available:', err.message);\n   519→        return res.status(503).json({ error: 'Music alignment service not available' });\n   520→      }\n   521→    }\n   522→\n   523→    res.json({\n   524→      fadeDuration: {\n   525→        default: musicAlignment.DEFAULT_FADE_DURATION,\n   526→        min: musicAlignment.MIN_FADE_DURATION,\n   527→        max: musicAlignment.MAX_FADE_DURATION\n   528→      },\n   529→      searchWindow: {\n   530→        default: musicAlignment.BEAT_SEARCH_WINDOW,\n   531→        min: 0.5,\n   532→        max: 10\n   533→      },\n   534→      minAudioDuration: musicAlignment.MIN_AUDIO_DURATION\n   535→    });\n   536→  });\n   537→\n   538→  /**\n   539→   * GET /timeline-options - Get timeline generation options and presets\n   540→   * Note: Loads timeline service on demand (no Redis dependency)\n   541→   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   542→   */\n   543→  router.get('/timeline-options', (req, res) => {\n   544→    // Load timeline service on demand if not already loaded\n   545→    if (!musicTimeline) {\n   546→      try {\n   547→        musicTimeline = require('../services/musicTimeline');\n   548→      } catch (err) {\n   549→        console.warn('[SPLICE] Music timeline service not available:', err.message);\n   550→        return res.status(503).json({ error: 'Music timeline service not available' });\n   551→      }\n   552→    }\n   553→\n   554→    res.json(musicTimeline.getTimelinePresets());\n   555→  });\n   556→\n   557→  /**\n   558→   * POST /timeline-estimate - Estimate timeline generation time\n   559→   * Note: Loads timeline service on demand (no Redis dependency)\n   560→   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   561→   */\n   562→  router.post('/timeline-estimate', (req, res) => {\n   563→    const { transcript, maxChapters, minChapterLength } = req.body;\n   564→\n   565→    // Load timeline service on demand if not already loaded\n   566→    if (!musicTimeline) {\n   567→      try {\n   568→        musicTimeline = require('../services/musicTimeline');\n   569→      } catch (err) {\n   570→        console.warn('[SPLICE] Music timeline service not available:', err.message);\n   571→        return res.status(503).json({ error: 'Music timeline service not available' });\n   572→      }\n   573→    }\n   574→\n   575→    if (!transcript || !transcript.duration) {\n   576→      return res.status(400).json({ error: 'transcript with duration is required' });\n   577→    }\n   578→\n   579→    const estimate = musicTimeline.estimateGenerationTime(transcript, {\n   580→      maxChapters,\n   581→      minChapterLength\n   582→    });\n   583→\n   584→    res.json(estimate);\n   585→  });\n   586→\n   587→  /**\n   588→   * GET /:jobId - Get music with signed download URL\n   589→   * IMPORTANT: This is a catch-all route - must be defined AFTER all specific routes\n   590→   */\n   591→  router.get('/:jobId', requireCredits, async (req, res) => {\n   592→    const { jobId } = req.params;\n   593→    const customerId = req.stripeCustomerId;\n   594→\n   595→    if (!musicQueue || !r2Storage) {\n   596→      return res.status(503).json({ error: 'Music service not available' });\n   597→    }\n   598→\n   599→    try {\n   600→      const status = await musicQueue.getJobStatus(jobId);\n   601→\n   602→      if (!status) {\n   603→        return res.status(404).json({ error: 'Music not found' });\n   604→      }\n   605→\n   606→      // Verify ownership\n   607→      if (status.data.customerId !== customerId) {\n   608→        return res.status(403).json({ error: 'Access denied' });\n   609→      }\n   610→\n   611→      if (status.status !== 'completed') {\n   612→        return res.status(400).json({ error: 'Music generation not complete' });\n   613→      }\n   614→\n   615→      // Generate signed download URLs\n   616→      const masterKey = r2Storage.generateStorageKey(customerId, jobId, 'master.wav');\n   617→      const previewKey = r2Storage.generateStorageKey(customerId, jobId, 'preview.mp3');\n   618→\n   619→      const [downloadUrl, previewUrl] = await Promise.all([\n   620→        r2Storage.getSignedDownloadUrl(masterKey, 3600), // 1 hour\n   621→        r2Storage.getSignedDownloadUrl(previewKey, 3600).catch(() => null)\n   622→      ]);\n   623→\n   624→      res.json({\n   625→        success: true,\n   626→        music: {\n   627→          jobId,\n   628→          title: status.data.musicResult?.title || 'Generated Music',\n   629→          duration: status.data.duration,\n   630→          mood: status.data.mood,\n   631→          downloadUrl,\n   632→          previewUrl,\n   633→          createdAt: status.createdAt,\n   634→          completedAt: status.completedAt\n   635→        }\n   636→      });\n   637→\n   638→    } catch (err) {\n   639→      console.error('[SPLICE] Get music error:', err.message);\n   640→      res.status(500).json({ error: err.message || 'Failed to get music' });\n   641→    }\n   642→  });\n   643→\n   644→  /**\n   645→   * DELETE /:jobId - Delete music from library\n   646→   */\n   647→  router.delete('/:jobId', requireCredits, async (req, res) => {\n   648→    const { jobId } = req.params;\n   649→    const customerId = req.stripeCustomerId;\n   650→\n   651→    if (!musicQueue || !r2Storage) {\n   652→      return res.status(503).json({ error: 'Music service not available' });\n   653→    }\n   654→\n   655→    try {\n   656→      const status = await musicQueue.getJobStatus(jobId);\n   657→\n   658→      if (!status) {\n   659→        return res.status(404).json({ error: 'Music not found' });\n   660→      }\n   661→\n   662→      // Verify ownership\n   663→      if (status.data.customerId !== customerId) {\n   664→        return res.status(403).json({ error: 'Access denied' });\n   665→      }\n   666→\n   667→      // Delete from R2\n   668→      await r2Storage.deleteJobFiles(customerId, jobId);\n   669→\n   670→      // Note: Job record stays in Redis for history\n   671→      // Could optionally call musicQueue.cancelJob if we want to remove it\n   672→\n   673→      res.json({ success: true, message: 'Music deleted' });\n   674→\n   675→    } catch (err) {\n   676→      console.error('[SPLICE] Delete music error:', err.message);\n   677→      res.status(500).json({ error: err.message || 'Failed to delete music' });\n   678→    }\n   679→  });\n   680→\n   681→  /**\n   682→   * POST /align - Align music to video duration with beat-matching\n   683→   */\n   684→  router.post('/align', requireCredits, async (req, res) => {\n   685→    const { jobId, targetDuration, fadeDuration, beatAlign = true, searchWindow } = req.body;\n   686→    const customerId = req.stripeCustomerId;\n   687→\n   688→    if (!jobId) {\n   689→      return res.status(400).json({ error: 'jobId is required' });\n   690→    }\n   691→\n   692→    if (!targetDuration || typeof targetDuration !== 'number') {\n   693→      return res.status(400).json({ error: 'targetDuration (number in seconds) is required' });\n   694→    }\n   695→\n   696→    if (!musicAlignment || !musicQueue || !r2Storage) {\n   697→      return res.status(503).json({ error: 'Music alignment service not available' });\n   698→    }\n   699→\n   700→    try {\n   701→      // Validate options\n   702→      const validation = musicAlignment.validateAlignmentOptions({\n   703→        targetDuration,\n   704→        fadeDuration,\n   705→        searchWindow\n   706→      });\n   707→      if (!validation.valid) {\n   708→        return res.status(400).json({ error: validation.errors.join(', ') });\n   709→      }\n   710→\n   711→      // Get job and verify ownership\n   712→      const job = await musicQueue.getJobStatus(jobId);\n   713→      if (!job) {\n   714→        return res.status(404).json({ error: 'Job not found' });\n   715→      }\n   716→      if (job.data.customerId !== customerId) {\n   717→        return res.status(403).json({ error: 'Access denied' });\n   718→      }\n   719→      if (job.status !== 'completed') {\n   720→        return res.status(400).json({ error: 'Job must be completed before alignment' });\n   721→      }\n   722→\n   723→      // Download the master audio from R2\n   724→      const masterKey = r2Storage.generateStorageKey(customerId, jobId, 'master.wav');\n   725→      const audioBuffer = await r2Storage.downloadFile(masterKey);\n   726→\n   727→      // Perform alignment with beat detection\n   728→      const result = await musicAlignment.trimToLength(audioBuffer, targetDuration, {\n   729→        fadeDuration: fadeDuration || musicAlignment.DEFAULT_FADE_DURATION,\n   730→        beatAlign,\n   731→        searchWindow: searchWindow || musicAlignment.BEAT_SEARCH_WINDOW\n   732→      });\n   733→\n   734→      // Generate aligned file key\n   735→      const alignedKey = r2Storage.generateStorageKey(customerId, jobId, `aligned_${Math.round(targetDuration)}s.wav`);\n   736→\n   737→      // Upload aligned audio to R2\n   738→      await r2Storage.uploadBuffer(alignedKey, result.buffer, 'audio/wav');\n   739→\n   740→      // Get signed URL for download\n   741→      const downloadUrl = await r2Storage.getSignedDownloadUrl(alignedKey, 3600);\n   742→\n   743→      res.json({\n   744→        success: true,\n   745→        jobId,\n   746→        targetDuration,\n   747→        actualDuration: result.cutTime,\n   748→        wasAligned: result.wasAligned,\n   749→        beatCount: result.beats.length,\n   750→        downloadUrl,\n   751→        alignedKey\n   752→      });\n   753→\n   754→    } catch (err) {\n   755→      console.error('[SPLICE] Music align error:', err.message);\n   756→      res.status(500).json({ error: err.message || 'Failed to align music' });\n   757→    }\n   758→  });\n   759→\n   760→  /**\n   761→   * POST /analyze-beats - Analyze beats in audio without trimming\n   762→   */\n   763→  router.post('/analyze-beats', requireCredits, async (req, res) => {\n   764→    const { jobId } = req.body;\n   765→    const customerId = req.stripeCustomerId;\n   766→\n   767→    if (!jobId) {\n   768→      return res.status(400).json({ error: 'jobId is required' });\n   769→    }\n   770→\n   771→    if (!musicAlignment || !musicQueue || !r2Storage) {\n   772→      return res.status(503).json({ error: 'Music alignment service not available' });\n   773→    }\n   774→\n   775→    try {\n   776→      // Get job and verify ownership\n   777→      const job = await musicQueue.getJobStatus(jobId);\n   778→      if (!job) {\n   779→        return res.status(404).json({ error: 'Job not found' });\n   780→      }\n   781→      if (job.data.customerId !== customerId) {\n   782→        return res.status(403).json({ error: 'Access denied' });\n   783→      }\n   784→      if (job.status !== 'completed') {\n   785→        return res.status(400).json({ error: 'Job must be completed before analysis' });\n   786→      }\n   787→\n   788→      // Download the master audio from R2\n   789→      const masterKey = r2Storage.generateStorageKey(customerId, jobId, 'master.wav');\n   790→      const audioBuffer = await r2Storage.downloadFile(masterKey);\n   791→\n   792→      // Analyze beats\n   793→      const analysis = await musicAlignment.analyzeBeats(audioBuffer);\n   794→\n   795→      res.json({\n   796→        success: true,\n   797→        jobId,\n   798→        duration: analysis.duration,\n   799→        beatCount: analysis.beatCount,\n   800→        bpm: analysis.bpm,\n   801→        beats: analysis.beats\n   802→      });\n   803→\n   804→    } catch (err) {\n   805→      console.error('[SPLICE] Beat analysis error:', err.message);\n   806→      res.status(500).json({ error: err.message || 'Failed to analyze beats' });\n   807→    }\n   808→  });\n   809→\n   810→  /**\n   811→   * POST /generate-timeline - Generate per-chapter mood-matched music\n   812→   * Billing: 3 credits per timeline job (multiple generations + assembly)\n   813→   */\n   814→  router.post('/generate-timeline', requireCredits, async (req, res) => {\n   815→    const { transcript, maxChapters, minChapterLength, crossfadeDuration, instruments, prompt } = req.body;\n   816→    const customerId = req.stripeCustomerId;\n   817→\n   818→    if (!customerId) {\n   819→      return res.status(401).json({ error: 'Authentication required' });\n   820→    }\n   821→\n   822→    loadMusicServices();\n   823→    if (!musicTimeline) {\n   824→      return res.status(503).json({ error: 'Music timeline service not available' });\n   825→    }\n   826→\n   827→    if (!musicGeneration || !musicGeneration.hasMurekaCredentials()) {\n   828→      return res.status(503).json({ error: 'Music generation service not configured' });\n   829→    }\n   830→\n   831→    // Validate transcript\n   832→    if (!transcript) {\n   833→      return res.status(400).json({ error: 'transcript is required' });\n   834→    }\n   835→\n   836→    // Validate options\n   837→    const validation = musicTimeline.validateTimelineOptions(transcript, {\n   838→      maxChapters,\n   839→      minChapterLength,\n   840→      crossfadeDuration\n   841→    });\n   842→\n   843→    if (!validation.valid) {\n   844→      return res.status(400).json({ error: validation.errors.join(', ') });\n   845→    }\n   846→\n   847→    try {\n   848→      // Check music credits (timeline costs 3 credits due to multiple generations)\n   849→      const creditCost = 3;\n   850→\n   851→      // Estimate generation time\n   852→      const estimate = musicTimeline.estimateGenerationTime(transcript, {\n   853→        maxChapters: maxChapters || 10,\n   854→        minChapterLength: minChapterLength || 60\n   855→      });\n   856→\n   857→      console.log(`[SPLICE Timeline] Starting generation for ${customerId} - est. ${estimate.estimatedChapters} chapters`);\n   858→\n   859→      // Generate timeline music\n   860→      const result = await musicTimeline.generateTimelineMusic(transcript, {\n   861→        maxChapters: maxChapters || 10,\n   862→        minChapterLength: minChapterLength || 60,\n   863→        crossfadeDuration: crossfadeDuration || 2.0,\n   864→        instruments: instruments || [],\n   865→        prompt: prompt || ''\n   866→      });\n   867→\n   868→      // Upload to R2 if available\n   869→      let r2Key = null;\n   870→      let signedUrl = null;\n   871→\n   872→      if (r2Storage && result.audioBuffer) {\n   873→        const jobId = `timeline_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n   874→        r2Key = `${customerId}/${jobId}/timeline.wav`;\n   875→\n   876→        // Note: uploadMusic signature is (buffer, key, metadata)\n   877→        await r2Storage.uploadMusic(result.audioBuffer, r2Key, {\n   878→          customerId,\n   879→          jobId,\n   880→          type: 'timeline',\n   881→          chapterCount: String(result.chapters.length)\n   882→        });\n   883→\n   884→        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n   885→      }\n   886→\n   887→      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)\n   888→      for (let i = 0; i < creditCost; i++) {\n   889→        await usageTracking.deductMusicCredit(customerId);\n   890→      }\n   891→\n   892→      res.json({\n   893→        success: true,\n   894→        duration: result.duration,\n   895→        chapters: result.chapters,\n   896→        metadata: result.metadata,\n   897→        audioUrl: signedUrl,\n   898→        r2Key,\n   899→        creditCost,\n   900→        estimate\n   901→      });\n   902→\n   903→    } catch (err) {\n   904→      console.error('[SPLICE Timeline] Generation error:', err.message);\n   905→      res.status(500).json({ error: err.message || 'Timeline generation failed' });\n   906→    }\n   907→  });\n   908→\n   909→  return router;\n   910→}\n   911→\n   912→module.exports = createMusicRoutes;\n   913→\n\n</system-reminder>\n"}]},"uuid":"1d89a5c9-c3e8-417a-8c56-a1b577892351","timestamp":"2026-01-12T01:30:45.420Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/music.js","content":"/**\n * Music Routes\n *\n * AI Music generation endpoints (Phase 8)\n */\n\nconst express = require('express');\n\n// Lazy-load music services to prevent startup failures if deps missing\nlet musicQueue, songIdentification, musicGeneration, r2Storage, musicAlignment, musicTimeline;\nlet musicServicesLoaded = false;\nlet musicGenerationLoaded = false;\n\n/**\n * Load only musicGeneration service (no Redis dependency)\n * Used by /moods and /instruments endpoints\n */\nfunction loadMusicGenerationOnly() {\n  if (!musicGenerationLoaded) {\n    try {\n      musicGeneration = require('../services/musicGeneration');\n      musicGenerationLoaded = true;\n    } catch (err) {\n      console.warn('[SPLICE] Music generation service not available:', err.message);\n    }\n  }\n}\n\n/**\n * Load all music services including Redis-dependent ones\n * Used by endpoints that need queue functionality\n */\nfunction loadMusicServices() {\n  if (!musicServicesLoaded) {\n    try {\n      // Load musicGeneration first (no Redis dependency)\n      loadMusicGenerationOnly();\n\n      // Load Redis-dependent services with timeout protection\n      songIdentification = require('../services/songIdentification');\n      r2Storage = require('../services/r2Storage');\n      musicAlignment = require('../services/musicAlignment');\n      musicTimeline = require('../services/musicTimeline');\n\n      // Load musicQueue last (Redis-dependent, may throw)\n      try {\n        musicQueue = require('../services/musicQueue');\n      } catch (queueErr) {\n        console.warn('[SPLICE] Music queue not available (Redis not configured):', queueErr.message);\n        // Continue without queue - some endpoints will return 503\n      }\n\n      musicServicesLoaded = true;\n    } catch (err) {\n      console.warn('[SPLICE] Music services not available:', err.message);\n    }\n  }\n}\n\n/**\n * Create music routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (requireCredits)\n * @param {Object} options.services - Shared services (usageTracking)\n * @returns {express.Router}\n */\nfunction createMusicRoutes(options = {}) {\n  const router = express.Router();\n  const { requireCredits } = options.middleware || {};\n  const { usageTracking } = options.services || {};\n\n  // Note: Services are now loaded lazily on first route access\n  // This prevents Redis dependency from blocking startup\n\n  /**\n   * POST /identify - Identify song from YouTube URL\n   */\n  router.post('/identify', requireCredits, async (req, res) => {\n    const { youtubeUrl } = req.body;\n\n    if (!youtubeUrl) {\n      return res.status(400).json({ error: 'youtubeUrl is required' });\n    }\n\n    if (!songIdentification) {\n      return res.status(503).json({ error: 'Song identification service not available' });\n    }\n\n    try {\n      // Validate URL\n      const validation = songIdentification.validateYouTubeUrl(youtubeUrl);\n      if (!validation.valid) {\n        return res.status(400).json({ error: validation.error });\n      }\n\n      // Check dependencies\n      const deps = await songIdentification.checkDependencies();\n      if (!deps.ytdlp) {\n        return res.status(503).json({ error: 'yt-dlp is not installed on server' });\n      }\n      if (!deps.ffmpeg) {\n        return res.status(503).json({ error: 'FFmpeg is not installed on server' });\n      }\n\n      // Check ACRCloud credentials\n      if (!songIdentification.hasACRCloudCredentials()) {\n        return res.status(503).json({ error: 'ACRCloud credentials not configured' });\n      }\n\n      // Identify song\n      const result = await songIdentification.identifyFromYouTube(youtubeUrl);\n\n      res.json(result);\n\n    } catch (err) {\n      console.error('[SPLICE] Song identification error:', err.message);\n      res.status(500).json({ error: err.message || 'Song identification failed' });\n    }\n  });\n\n  /**\n   * POST /generate - Start music generation job\n   */\n  router.post('/generate', requireCredits, async (req, res) => {\n    const { youtubeUrl, prompt, duration, mood, instruments, referenceSong } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      // Validate options if musicGeneration is available\n      if (musicGeneration) {\n        const validation = musicGeneration.validateOptions({ duration, mood, instruments });\n        if (!validation.valid) {\n          return res.status(400).json({ error: validation.errors.join(', ') });\n        }\n      }\n\n      // Add job to queue\n      const result = await musicQueue.addMusicJob({\n        customerId,\n        youtubeUrl,\n        prompt,\n        duration: duration || 60,\n        mood: mood || 'neutral',\n        instruments: instruments || [],\n        referenceSong\n      });\n\n      res.json({\n        success: true,\n        jobId: result.jobId,\n        status: result.status,\n        estimatedTime: result.estimatedTime,\n        statusUrl: `/music/status/${result.jobId}`\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Music generation error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to start music generation' });\n    }\n  });\n\n  /**\n   * POST /generate-variations - Generate 3 song variations for user selection\n   */\n  router.post('/generate-variations', requireCredits, async (req, res) => {\n    const { prompt, duration, mood, instruments, referenceSong } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      // Validate options if musicGeneration is available\n      if (musicGeneration) {\n        const validation = musicGeneration.validateOptions({ duration, mood, instruments });\n        if (!validation.valid) {\n          return res.status(400).json({ error: validation.errors.join(', ') });\n        }\n      }\n\n      // Check for variations credits (2.5 credits = 3 music credits equivalent)\n      const hasCredits = await usageTracking.checkVariationsCredits(customerId);\n      if (!hasCredits.canGenerate) {\n        return res.status(402).json({\n          error: 'Insufficient credits for variations',\n          creditsRequired: 2.5,\n          creditsAvailable: hasCredits.creditsAvailable\n        });\n      }\n\n      // Add variations job to queue\n      const result = await musicQueue.addVariationsJob({\n        customerId,\n        prompt,\n        duration: duration || 60,\n        mood: mood || 'neutral',\n        instruments: instruments || [],\n        referenceSong\n      });\n\n      res.json({\n        success: true,\n        jobId: result.jobId,\n        status: result.status,\n        isVariations: true,\n        estimatedTime: result.estimatedTime,\n        statusUrl: `/music/variations/status/${result.jobId}`\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Music variations error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to start variations generation' });\n    }\n  });\n\n  /**\n   * POST /generate-scene-aware - Generate music with transcript analysis\n   */\n  router.post('/generate-scene-aware', requireCredits, async (req, res) => {\n    const { segments, prompt, duration, mood, instruments, referenceSong } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    // Validate segments\n    if (!segments || !Array.isArray(segments) || segments.length === 0) {\n      return res.status(400).json({ error: 'Transcript segments are required' });\n    }\n\n    try {\n      // Validate scene-aware options\n      if (musicGeneration) {\n        const validation = musicGeneration.validateSceneAwareOptions(segments, { duration, mood, instruments });\n        if (!validation.valid) {\n          return res.status(400).json({ error: validation.errors.join(', ') });\n        }\n      }\n\n      // Check for scene-aware credits (1.5 credits)\n      const hasCredits = await usageTracking.checkSceneAwareCredits(customerId);\n      if (!hasCredits.canGenerate) {\n        return res.status(402).json({\n          error: 'Insufficient credits for scene-aware music',\n          creditsRequired: 1.5,\n          creditsAvailable: hasCredits.creditsAvailable\n        });\n      }\n\n      // Add scene-aware job to queue with scene analysis flag\n      const result = await musicQueue.addMusicJob({\n        customerId,\n        prompt,\n        duration: duration || 60,\n        mood: mood || 'neutral',\n        instruments: instruments || [],\n        referenceSong,\n        isSceneAware: true,\n        segments\n      });\n\n      res.json({\n        success: true,\n        jobId: result.jobId,\n        status: result.status,\n        isSceneAware: true,\n        estimatedTime: result.estimatedTime,\n        statusUrl: `/music/status/${result.jobId}`\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Scene-aware music error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to start scene-aware music generation' });\n    }\n  });\n\n  /**\n   * GET /variations/status/:jobId - Get variations job status with detailed progress\n   */\n  router.get('/variations/status/:jobId', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      const status = await musicQueue.getVariationsJobStatus(jobId);\n\n      if (!status) {\n        return res.status(404).json({ error: 'Job not found' });\n      }\n\n      // Verify ownership\n      if (status.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Not authorized to access this job' });\n      }\n\n      res.json(status);\n\n    } catch (err) {\n      console.error('[SPLICE] Variations status error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get job status' });\n    }\n  });\n\n  /**\n   * POST /variations/:jobId/select - Select a variation to finalize\n   */\n  router.post('/variations/:jobId/select', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const { variationIndex } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    if (variationIndex === undefined || variationIndex === null) {\n      return res.status(400).json({ error: 'variationIndex is required' });\n    }\n\n    const index = parseInt(variationIndex);\n    if (isNaN(index) || index < 0 || index > 2) {\n      return res.status(400).json({ error: 'variationIndex must be 0, 1, or 2' });\n    }\n\n    try {\n      // Select the variation\n      const result = await musicQueue.selectVariation(jobId, index, customerId);\n\n      // Deduct variations credits (2.5 credits)\n      await usageTracking.deductVariationsCredit(customerId);\n\n      res.json({\n        success: true,\n        ...result\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Variation selection error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to select variation' });\n    }\n  });\n\n  /**\n   * GET /status/:jobId - Get job status\n   */\n  router.get('/status/:jobId', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      const status = await musicQueue.getJobStatus(jobId);\n\n      if (!status) {\n        return res.status(404).json({ error: 'Job not found' });\n      }\n\n      // Verify ownership\n      if (status.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n\n      res.json(status);\n\n    } catch (err) {\n      console.error('[SPLICE] Job status error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get job status' });\n    }\n  });\n\n  /**\n   * GET /library - Get user's music library\n   */\n  router.get('/library', requireCredits, async (req, res) => {\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music generation service not available' });\n    }\n\n    try {\n      const jobs = await musicQueue.getCustomerJobs(customerId, {\n        limit: parseInt(req.query.limit) || 50,\n        offset: parseInt(req.query.offset) || 0\n      });\n\n      // Filter to only completed jobs for library\n      const library = jobs.filter(j => j.status === 'completed');\n\n      res.json(library);\n\n    } catch (err) {\n      console.error('[SPLICE] Music library error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to load music library' });\n    }\n  });\n\n  /**\n   * GET /credits - Get music credits balance\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/credits', requireCredits, async (req, res) => {\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    try {\n      // Get credits from database using usageTracking\n      const credits = await usageTracking.getMusicCredits(customerId);\n\n      res.json(credits);\n\n    } catch (err) {\n      console.error('[SPLICE] Music credits error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get credits' });\n    }\n  });\n\n  /**\n   * GET /moods - Get available mood presets\n   * Note: Uses lightweight loader (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/moods', (req, res) => {\n    loadMusicGenerationOnly();\n    if (!musicGeneration) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    res.json(musicGeneration.getAvailableMoods());\n  });\n\n  /**\n   * GET /instruments - Get available instrument presets\n   * Note: Uses lightweight loader (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/instruments', (req, res) => {\n    loadMusicGenerationOnly();\n    if (!musicGeneration) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    res.json(musicGeneration.getAvailableInstruments());\n  });\n\n  /**\n   * GET /queue-stats - Get queue statistics (admin only)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   * SECURITY: Restricted to admin customers only\n   */\n  router.get('/queue-stats', requireCredits, async (req, res) => {\n    // SECURITY: Check for admin access\n    // Only allow specific admin customer IDs (configured via env var)\n    const adminCustomerIds = (process.env.ADMIN_CUSTOMER_IDS || '').split(',').filter(Boolean);\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId || (adminCustomerIds.length > 0 && !adminCustomerIds.includes(customerId))) {\n      return res.status(403).json({ error: 'Admin access required' });\n    }\n\n    loadMusicServices();\n    if (!musicQueue) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    try {\n      const stats = await musicQueue.getQueueStats();\n      res.json(stats);\n    } catch (err) {\n      console.error('[SPLICE] Queue stats error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get queue stats' });\n    }\n  });\n\n  /**\n   * GET /alignment-options - Get alignment configuration options\n   * Note: Loads alignment service on demand (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/alignment-options', (req, res) => {\n    // Load alignment service on demand if not already loaded\n    if (!musicAlignment) {\n      try {\n        musicAlignment = require('../services/musicAlignment');\n      } catch (err) {\n        console.warn('[SPLICE] Music alignment service not available:', err.message);\n        return res.status(503).json({ error: 'Music alignment service not available' });\n      }\n    }\n\n    res.json({\n      fadeDuration: {\n        default: musicAlignment.DEFAULT_FADE_DURATION,\n        min: musicAlignment.MIN_FADE_DURATION,\n        max: musicAlignment.MAX_FADE_DURATION\n      },\n      searchWindow: {\n        default: musicAlignment.BEAT_SEARCH_WINDOW,\n        min: 0.5,\n        max: 10\n      },\n      minAudioDuration: musicAlignment.MIN_AUDIO_DURATION\n    });\n  });\n\n  /**\n   * GET /timeline-options - Get timeline generation options and presets\n   * Note: Loads timeline service on demand (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.get('/timeline-options', (req, res) => {\n    // Load timeline service on demand if not already loaded\n    if (!musicTimeline) {\n      try {\n        musicTimeline = require('../services/musicTimeline');\n      } catch (err) {\n        console.warn('[SPLICE] Music timeline service not available:', err.message);\n        return res.status(503).json({ error: 'Music timeline service not available' });\n      }\n    }\n\n    res.json(musicTimeline.getTimelinePresets());\n  });\n\n  /**\n   * POST /timeline-estimate - Estimate timeline generation time\n   * Note: Loads timeline service on demand (no Redis dependency)\n   * IMPORTANT: Must be defined BEFORE /:jobId catch-all route\n   */\n  router.post('/timeline-estimate', (req, res) => {\n    const { transcript, maxChapters, minChapterLength } = req.body;\n\n    // Load timeline service on demand if not already loaded\n    if (!musicTimeline) {\n      try {\n        musicTimeline = require('../services/musicTimeline');\n      } catch (err) {\n        console.warn('[SPLICE] Music timeline service not available:', err.message);\n        return res.status(503).json({ error: 'Music timeline service not available' });\n      }\n    }\n\n    if (!transcript || !transcript.duration) {\n      return res.status(400).json({ error: 'transcript with duration is required' });\n    }\n\n    const estimate = musicTimeline.estimateGenerationTime(transcript, {\n      maxChapters,\n      minChapterLength\n    });\n\n    res.json(estimate);\n  });\n\n  /**\n   * GET /:jobId - Get music with signed download URL\n   * IMPORTANT: This is a catch-all route - must be defined AFTER all specific routes\n   */\n  router.get('/:jobId', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue || !r2Storage) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    try {\n      const status = await musicQueue.getJobStatus(jobId);\n\n      if (!status) {\n        return res.status(404).json({ error: 'Music not found' });\n      }\n\n      // Verify ownership\n      if (status.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n\n      if (status.status !== 'completed') {\n        return res.status(400).json({ error: 'Music generation not complete' });\n      }\n\n      // Generate signed download URLs\n      const masterKey = r2Storage.generateStorageKey(customerId, jobId, 'master.wav');\n      const previewKey = r2Storage.generateStorageKey(customerId, jobId, 'preview.mp3');\n\n      const [downloadUrl, previewUrl] = await Promise.all([\n        r2Storage.getSignedDownloadUrl(masterKey, 3600), // 1 hour\n        r2Storage.getSignedDownloadUrl(previewKey, 3600).catch(() => null)\n      ]);\n\n      res.json({\n        success: true,\n        music: {\n          jobId,\n          title: status.data.musicResult?.title || 'Generated Music',\n          duration: status.data.duration,\n          mood: status.data.mood,\n          downloadUrl,\n          previewUrl,\n          createdAt: status.createdAt,\n          completedAt: status.completedAt\n        }\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Get music error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to get music' });\n    }\n  });\n\n  /**\n   * DELETE /:jobId - Delete music from library\n   */\n  router.delete('/:jobId', requireCredits, async (req, res) => {\n    const { jobId } = req.params;\n    const customerId = req.stripeCustomerId;\n\n    if (!musicQueue || !r2Storage) {\n      return res.status(503).json({ error: 'Music service not available' });\n    }\n\n    try {\n      const status = await musicQueue.getJobStatus(jobId);\n\n      if (!status) {\n        return res.status(404).json({ error: 'Music not found' });\n      }\n\n      // Verify ownership\n      if (status.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n\n      // Delete from R2\n      await r2Storage.deleteJobFiles(customerId, jobId);\n\n      // Note: Job record stays in Redis for history\n      // Could optionally call musicQueue.cancelJob if we want to remove it\n\n      res.json({ success: true, message: 'Music deleted' });\n\n    } catch (err) {\n      console.error('[SPLICE] Delete music error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to delete music' });\n    }\n  });\n\n  /**\n   * POST /align - Align music to video duration with beat-matching\n   */\n  router.post('/align', requireCredits, async (req, res) => {\n    const { jobId, targetDuration, fadeDuration, beatAlign = true, searchWindow } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!jobId) {\n      return res.status(400).json({ error: 'jobId is required' });\n    }\n\n    if (!targetDuration || typeof targetDuration !== 'number') {\n      return res.status(400).json({ error: 'targetDuration (number in seconds) is required' });\n    }\n\n    if (!musicAlignment || !musicQueue || !r2Storage) {\n      return res.status(503).json({ error: 'Music alignment service not available' });\n    }\n\n    try {\n      // Validate options\n      const validation = musicAlignment.validateAlignmentOptions({\n        targetDuration,\n        fadeDuration,\n        searchWindow\n      });\n      if (!validation.valid) {\n        return res.status(400).json({ error: validation.errors.join(', ') });\n      }\n\n      // Get job and verify ownership\n      const job = await musicQueue.getJobStatus(jobId);\n      if (!job) {\n        return res.status(404).json({ error: 'Job not found' });\n      }\n      if (job.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n      if (job.status !== 'completed') {\n        return res.status(400).json({ error: 'Job must be completed before alignment' });\n      }\n\n      // Download the master audio from R2\n      const masterKey = r2Storage.generateStorageKey(customerId, jobId, 'master.wav');\n      const audioBuffer = await r2Storage.downloadFile(masterKey);\n\n      // Perform alignment with beat detection\n      const result = await musicAlignment.trimToLength(audioBuffer, targetDuration, {\n        fadeDuration: fadeDuration || musicAlignment.DEFAULT_FADE_DURATION,\n        beatAlign,\n        searchWindow: searchWindow || musicAlignment.BEAT_SEARCH_WINDOW\n      });\n\n      // Generate aligned file key\n      const alignedKey = r2Storage.generateStorageKey(customerId, jobId, `aligned_${Math.round(targetDuration)}s.wav`);\n\n      // Upload aligned audio to R2\n      await r2Storage.uploadBuffer(alignedKey, result.buffer, 'audio/wav');\n\n      // Get signed URL for download\n      const downloadUrl = await r2Storage.getSignedDownloadUrl(alignedKey, 3600);\n\n      res.json({\n        success: true,\n        jobId,\n        targetDuration,\n        actualDuration: result.cutTime,\n        wasAligned: result.wasAligned,\n        beatCount: result.beats.length,\n        downloadUrl,\n        alignedKey\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Music align error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to align music' });\n    }\n  });\n\n  /**\n   * POST /analyze-beats - Analyze beats in audio without trimming\n   */\n  router.post('/analyze-beats', requireCredits, async (req, res) => {\n    const { jobId } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!jobId) {\n      return res.status(400).json({ error: 'jobId is required' });\n    }\n\n    if (!musicAlignment || !musicQueue || !r2Storage) {\n      return res.status(503).json({ error: 'Music alignment service not available' });\n    }\n\n    try {\n      // Get job and verify ownership\n      const job = await musicQueue.getJobStatus(jobId);\n      if (!job) {\n        return res.status(404).json({ error: 'Job not found' });\n      }\n      if (job.data.customerId !== customerId) {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n      if (job.status !== 'completed') {\n        return res.status(400).json({ error: 'Job must be completed before analysis' });\n      }\n\n      // Download the master audio from R2\n      const masterKey = r2Storage.generateStorageKey(customerId, jobId, 'master.wav');\n      const audioBuffer = await r2Storage.downloadFile(masterKey);\n\n      // Analyze beats\n      const analysis = await musicAlignment.analyzeBeats(audioBuffer);\n\n      res.json({\n        success: true,\n        jobId,\n        duration: analysis.duration,\n        beatCount: analysis.beatCount,\n        bpm: analysis.bpm,\n        beats: analysis.beats\n      });\n\n    } catch (err) {\n      console.error('[SPLICE] Beat analysis error:', err.message);\n      res.status(500).json({ error: err.message || 'Failed to analyze beats' });\n    }\n  });\n\n  /**\n   * POST /generate-timeline - Generate per-chapter mood-matched music\n   * Billing: 3 credits per timeline job (multiple generations + assembly)\n   */\n  router.post('/generate-timeline', requireCredits, async (req, res) => {\n    const { transcript, maxChapters, minChapterLength, crossfadeDuration, instruments, prompt } = req.body;\n    const customerId = req.stripeCustomerId;\n\n    if (!customerId) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n\n    loadMusicServices();\n    if (!musicTimeline) {\n      return res.status(503).json({ error: 'Music timeline service not available' });\n    }\n\n    if (!musicGeneration || !musicGeneration.hasMurekaCredentials()) {\n      return res.status(503).json({ error: 'Music generation service not configured' });\n    }\n\n    // Validate transcript\n    if (!transcript) {\n      return res.status(400).json({ error: 'transcript is required' });\n    }\n\n    // Validate options\n    const validation = musicTimeline.validateTimelineOptions(transcript, {\n      maxChapters,\n      minChapterLength,\n      crossfadeDuration\n    });\n\n    if (!validation.valid) {\n      return res.status(400).json({ error: validation.errors.join(', ') });\n    }\n\n    try {\n      // Check music credits (timeline costs 3 credits due to multiple generations)\n      const creditCost = 3;\n\n      // Estimate generation time\n      const estimate = musicTimeline.estimateGenerationTime(transcript, {\n        maxChapters: maxChapters || 10,\n        minChapterLength: minChapterLength || 60\n      });\n\n      console.log(`[SPLICE Timeline] Starting generation for ${customerId} - est. ${estimate.estimatedChapters} chapters`);\n\n      // Generate timeline music\n      const result = await musicTimeline.generateTimelineMusic(transcript, {\n        maxChapters: maxChapters || 10,\n        minChapterLength: minChapterLength || 60,\n        crossfadeDuration: crossfadeDuration || 2.0,\n        instruments: instruments || [],\n        prompt: prompt || ''\n      });\n\n      // Upload to R2 if available\n      let r2Key = null;\n      let signedUrl = null;\n\n      if (r2Storage && result.audioBuffer) {\n        const jobId = `timeline_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;\n        r2Key = `${customerId}/${jobId}/timeline.wav`;\n\n        // Note: uploadMusic signature is (buffer, key, metadata)\n        await r2Storage.uploadMusic(result.audioBuffer, r2Key, {\n          customerId,\n          jobId,\n          type: 'timeline',\n          chapterCount: String(result.chapters.length)\n        });\n\n        signedUrl = await r2Storage.getSignedDownloadUrl(r2Key, 3600);\n      }\n\n      // Deduct timeline credits (3 credits for timeline = 3 individual song credits)\n      for (let i = 0; i < creditCost; i++) {\n        await usageTracking.deductMusicCredit(customerId);\n      }\n\n      res.json({\n        success: true,\n        duration: result.duration,\n        chapters: result.chapters,\n        metadata: result.metadata,\n        audioUrl: signedUrl,\n        r2Key,\n        creditCost,\n        estimate\n      });\n\n    } catch (err) {\n      console.error('[SPLICE Timeline] Generation error:', err.message);\n      res.status(500).json({ error: err.message || 'Timeline generation failed' });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createMusicRoutes;\n","numLines":913,"startLine":1,"totalLines":913}}}
{"parentUuid":"1d89a5c9-c3e8-417a-8c56-a1b577892351","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Y3h86fsqk5s2TLEexXx7Mg","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also check for potential issues with how the worker is started and stopped, and look at the `shutdownWorker` function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":742,"cache_creation_input_tokens":11578,"cache_read_input_tokens":61338,"cache_creation":{"ephemeral_5m_input_tokens":11578,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX2csey6xZGtAmAVVzcqd","type":"assistant","uuid":"421e24bf-b87f-43df-9ab3-3dd9c59b0425","timestamp":"2026-01-12T01:30:50.294Z"}
{"parentUuid":"421e24bf-b87f-43df-9ab3-3dd9c59b0425","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Y3h86fsqk5s2TLEexXx7Mg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012bss9S782odjbfNJHD6GSJ","name":"Grep","input":{"pattern":"shutdownWorker|closeQueue","path":"/Users/imorgado/SPLICE/splice-backend","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":742,"cache_creation_input_tokens":11578,"cache_read_input_tokens":61338,"cache_creation":{"ephemeral_5m_input_tokens":11578,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX2csey6xZGtAmAVVzcqd","type":"assistant","uuid":"7c1c4200-798a-4671-bb16-e2a7cfb24083","timestamp":"2026-01-12T01:30:51.616Z"}
{"parentUuid":"7c1c4200-798a-4671-bb16-e2a7cfb24083","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012bss9S782odjbfNJHD6GSJ","type":"tool_result","content":"splice-backend/workers/musicWorker.js:415:async function shutdownWorker(worker) {\nsplice-backend/workers/musicWorker.js:424:  shutdownWorker,\nsplice-backend/workers/musicWorker.js:435:    await shutdownWorker(worker);\nsplice-backend/workers/musicWorker.js:440:    await shutdownWorker(worker);\nsplice-backend/server.js:76:const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\nsplice-backend/server.js:902:    await shutdownWorker();\nsplice-backend/services/musicQueue.js:651:async function closeQueue() {\nsplice-backend/services/musicQueue.js:904:  closeQueue,\nsplice-backend/tests/music-phase0-e2e.test.js:156:test('musicQueue exports closeQueue function', () => {\nsplice-backend/tests/music-phase0-e2e.test.js:157:  assert(musicQueueCode.includes('async function closeQueue'), 'Should have closeQueue function');\nsplice-backend/tests/music-phase0-e2e.test.js:218:test('musicWorker exports shutdownWorker function', () => {\nsplice-backend/tests/music-phase0-e2e.test.js:219:  assert(musicWorkerCode.includes('async function shutdownWorker'), 'Should have shutdownWorker');"}]},"uuid":"1b64383c-396f-4988-ad50-0dd24bb44557","timestamp":"2026-01-12T01:30:51.666Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"splice-backend/workers/musicWorker.js:415:async function shutdownWorker(worker) {\nsplice-backend/workers/musicWorker.js:424:  shutdownWorker,\nsplice-backend/workers/musicWorker.js:435:    await shutdownWorker(worker);\nsplice-backend/workers/musicWorker.js:440:    await shutdownWorker(worker);\nsplice-backend/server.js:76:const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\nsplice-backend/server.js:902:    await shutdownWorker();\nsplice-backend/services/musicQueue.js:651:async function closeQueue() {\nsplice-backend/services/musicQueue.js:904:  closeQueue,\nsplice-backend/tests/music-phase0-e2e.test.js:156:test('musicQueue exports closeQueue function', () => {\nsplice-backend/tests/music-phase0-e2e.test.js:157:  assert(musicQueueCode.includes('async function closeQueue'), 'Should have closeQueue function');\nsplice-backend/tests/music-phase0-e2e.test.js:218:test('musicWorker exports shutdownWorker function', () => {\nsplice-backend/tests/music-phase0-e2e.test.js:219:  assert(musicWorkerCode.includes('async function shutdownWorker'), 'Should have shutdownWorker');","numLines":12}}
{"parentUuid":"1b64383c-396f-4988-ad50-0dd24bb44557","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a6a3dce","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_011u5o2MWeb6VMUeSaiJUfgN","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a complete picture. Let me compile my analysis report on the music queue and worker system.\n\n## Bug Summary\n\nThe music queue and worker system has several issues, including a **critical bug** in the graceful shutdown logic and potential Redis connection inconsistencies.\n\n---\n\n## Root Cause Analysis\n\n### Issue 1: CRITICAL - Graceful Shutdown Bug\n\n**File**: `/Users/imorgado/SPLICE/splice-backend/server.js:902`\n\nThe `shutdownWorker()` function is called without passing the worker instance:\n\n```javascript\n// server.js line 902\nawait shutdownWorker();  // BUG: No worker argument passed!\n```\n\nBut the function signature in `musicWorker.js` requires the worker as an argument:\n\n```javascript\n// musicWorker.js line 415\nasync function shutdownWorker(worker) {\n  console.log('[Worker] Shutting down...');\n  await worker.close();  // Will throw: Cannot read property 'close' of undefined\n  console.log('[Worker] Shutdown complete');\n}\n```\n\n**Impact**: When the server receives SIGTERM/SIGINT, the graceful shutdown will fail with a TypeError, potentially leaving jobs in an inconsistent state.\n\n---\n\n### Issue 2: Worker Instance Not Tracked\n\n**File**: `/Users/imorgado/SPLICE/splice-backend/server.js:855`\n\nThe worker is created but not stored for later shutdown:\n\n```javascript\n// server.js lines 854-856\ntry {\n  createMusicWorker();  // Returns the worker but it's discarded!\n  console.log('[SPLICE] Music generation worker started');\n}\n```\n\nThe created worker instance is never assigned to a variable that can be used during shutdown.\n\n---\n\n### Issue 3: Duplicate Redis Connection Implementations\n\n**Root Cause Location**: Two separate Redis connection systems exist that may behave inconsistently:\n\n1. **`/Users/imorgado/SPLICE/splice-backend/services/redisClient.js`** - Used for general Redis operations (token blacklist, caching)\n   - Supports Upstash REST API and ioredis\n   - Priority: REST API first, then standard URL\n\n2. **`/Users/imorgado/SPLICE/splice-backend/services/musicQueue.js:65`** - Used by BullMQ\n   - Only supports ioredis (standard Redis URL)\n   - Priority: `REDIS_URL` first, then `UPSTASH_REDIS_URL`\n\n**Potential Issue**: If `UPSTASH_REDIS_REST_URL` is configured (but not a standard Redis URL), the general Redis client works but BullMQ will fail to connect.\n\n---\n\n### Issue 4: Missing Worker Instance Reference in Module Scope\n\n**File**: `/Users/imorgado/SPLICE/splice-backend/services/musicQueue.js`\n\nThe `musicWorker` variable is declared but never used:\n\n```javascript\n// musicQueue.js lines 10-14\nlet redisConnection = null;\nlet musicQueue = null;\nlet musicWorker = null;      // Declared but never assigned\nlet deadLetterQueue = null;\n```\n\nThe `closeQueue()` function checks for `musicWorker`:\n\n```javascript\n// musicQueue.js lines 656-660\nif (musicWorker) {\n  await musicWorker.close();\n  musicWorker = null;\n}\n```\n\nBut since `musicWorker` is never assigned, this code path is dead.\n\n---\n\n## Trace Path\n\n1. Server starts and calls `createMusicWorker()` (server.js:855)\n2. Worker instance is created but NOT stored (server.js:855 - return value discarded)\n3. Server receives SIGTERM signal (server.js:924)\n4. `gracefulShutdown()` is called (server.js:890)\n5. `shutdownWorker()` is called with NO arguments (server.js:902)\n6. **ERROR**: `worker.close()` fails because `worker` is `undefined`\n\n---\n\n## Fix\n\n### Fix 1: Track Worker Instance and Pass to Shutdown\n\n```javascript\n// server.js - Around line 837, add:\nlet musicWorkerInstance = null;\n\n// server.js - Around line 855, change to:\ntry {\n  musicWorkerInstance = createMusicWorker();\n  console.log('[SPLICE] Music generation worker started');\n}\n\n// server.js - Around line 902, change to:\ntry {\n  if (musicWorkerInstance) {\n    await shutdownWorker(musicWorkerInstance);\n  }\n  console.log('[SPLICE] Music worker shut down');\n}\n```\n\n### Fix 2: Add Defensive Check in shutdownWorker\n\n```javascript\n// musicWorker.js line 415\nasync function shutdownWorker(worker) {\n  if (!worker) {\n    console.log('[Worker] No worker instance to shut down');\n    return;\n  }\n  console.log('[Worker] Shutting down...');\n  await worker.close();\n  console.log('[Worker] Shutdown complete');\n}\n```\n\n---\n\n## Additional Issues Found\n\n### Issue 5: BullMQ `maxRetriesPerRequest` Setting\n\n**File**: `/Users/imorgado/SPLICE/splice-backend/services/musicQueue.js:83`\n\nThe setting is correct (`maxRetriesPerRequest: null`), which is required for BullMQ workers. However, the `redisClient.js` uses a different value:\n\n```javascript\n// redisClient.js line 55\nmaxRetriesPerRequest: 3,  // This is fine for general Redis\n```\n\nThis is correct - BullMQ requires `null` while general operations can have retries.\n\n---\n\n### Issue 6: Lazy Loading Creates Race Conditions\n\n**File**: `/Users/imorgado/SPLICE/splice-backend/routes/music.js:33-57`\n\nServices are loaded lazily but there's no synchronization:\n\n```javascript\nfunction loadMusicServices() {\n  if (!musicServicesLoaded) {\n    // Multiple concurrent requests could enter here\n    try {\n      musicQueue = require('../services/musicQueue');\n    }\n    // ...\n  }\n}\n```\n\nThis could cause issues if multiple requests arrive simultaneously during initial load.\n\n---\n\n## Regression Test\n\n```javascript\n// Test: Graceful shutdown should work correctly\ntest('graceful shutdown closes worker properly', async () => {\n  const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\n  \n  // Create worker\n  const worker = createMusicWorker({ concurrency: 1 });\n  expect(worker).toBeDefined();\n  \n  // Shutdown should not throw\n  await expect(shutdownWorker(worker)).resolves.not.toThrow();\n  \n  // Calling shutdown without worker should not throw\n  await expect(shutdownWorker(null)).resolves.not.toThrow();\n  await expect(shutdownWorker(undefined)).resolves.not.toThrow();\n});\n```\n\n---\n\n## Prevention\n\n1. **TypeScript/JSDoc**: Add type annotations to catch missing arguments:\n   ```javascript\n   /**\n    * @param {Worker} worker - The BullMQ worker instance (required)\n    */\n   async function shutdownWorker(worker) {\n   ```\n\n2. **Module-level Worker Tracking**: Store worker instance in module scope so it can be accessed during shutdown without passing references.\n\n3. **Integration Tests**: Add tests that simulate SIGTERM during operation to ensure graceful shutdown works.\n\n4. **Code Review Checklist**: When adding background workers, verify:\n   - Worker instance is stored for later cleanup\n   - Shutdown function receives correct arguments\n   - Redis connection configuration is consistent across services"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1253,"cache_read_input_tokens":72916,"cache_creation":{"ephemeral_5m_input_tokens":1253,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2ct6KbRimv8BRrw38Z7","type":"assistant","uuid":"a98a1a21-9559-4057-a40a-f6a994164e38","timestamp":"2026-01-12T01:31:22.951Z"}
