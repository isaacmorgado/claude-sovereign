{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":"Search the SPLICE backend for potential unhandled promise rejections related to the Redis/auth changes.\n\nLook for:\n\n1. Async functions called without await AND without .catch():\n   - `blacklistToken(` without await\n   - `isTokenBlacklisted(` without await\n   - `verifyToken(` without await (verifyTokenSync is okay)\n   - `redis.set(`, `redis.get(`, `redis.exists(`, `redis.del(` without await\n\n2. Missing try/catch blocks around Redis operations\n\n3. Express route handlers that are async but might not handle errors properly\n\n4. Any .then() chains without .catch()\n\nSearch in:\n- `splice-backend/middleware/auth.js`\n- `splice-backend/routes/auth.js`\n- `splice-backend/services/redisClient.js`\n- Any other files that import from these\n\nReport any unhandled promise issues found."},"uuid":"3c6e6c7d-96d9-4d82-a7f5-d27d8b3136e9","timestamp":"2025-12-30T01:03:51.711Z"}
{"parentUuid":"3c6e6c7d-96d9-4d82-a7f5-d27d8b3136e9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HmR4VYPfPE5UrV5XkViD5s","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Be3Ln46X6MQQaG3wNnR3eb","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20585,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20585,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbyJnDM2zsJuKVhSrAXq","type":"assistant","uuid":"ded6dac7-e373-47ff-8c7f-76dd9fddd962","timestamp":"2025-12-30T01:03:57.557Z"}
{"parentUuid":"ded6dac7-e373-47ff-8c7f-76dd9fddd962","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HmR4VYPfPE5UrV5XkViD5s","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SMu1dXPZCtdMFTDG45vDmm","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20585,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20585,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbyJnDM2zsJuKVhSrAXq","type":"assistant","uuid":"f001cb4b-742b-4dc9-a43a-792c758de4e9","timestamp":"2025-12-30T01:03:57.907Z"}
{"parentUuid":"f001cb4b-742b-4dc9-a43a-792c758de4e9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HmR4VYPfPE5UrV5XkViD5s","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KM1nsF1gnDYE7HEGQZbQGa","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/redisClient.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20585,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20585,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbyJnDM2zsJuKVhSrAXq","type":"assistant","uuid":"187ca915-957c-403a-8cd3-73603aaea56d","timestamp":"2025-12-30T01:03:58.300Z"}
{"parentUuid":"187ca915-957c-403a-8cd3-73603aaea56d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Be3Ln46X6MQQaG3wNnR3eb","type":"tool_result","content":"     1→/**\n     2→ * JWT Authentication Middleware\n     3→ *\n     4→ * Replaces insecure x-stripe-customer-id header with JWT tokens.\n     5→ * Tokens are signed with a secret and contain the customer ID.\n     6→ *\n     7→ * Token Blacklist:\n     8→ * - Primary: Upstash Redis with automatic TTL-based expiry\n     9→ * - Fallback: In-memory Map (for development or Redis failures)\n    10→ */\n    11→\n    12→const jwt = require('jsonwebtoken');\n    13→const crypto = require('crypto');\n    14→const authLogger = require('../utils/authLogger');\n    15→const redis = require('../services/redisClient');\n    16→\n    17→// JWT configuration\n    18→const JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\n    19→const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\n    20→const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n    21→\n    22→// Redis key prefix for blacklisted tokens\n    23→const BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n    24→\n    25→// Check if running in production\n    26→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    27→\n    28→// Warn if using default secret in production\n    29→if (isProduction && JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    30→  console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    31→  console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    32→  process.exit(1);\n    33→}\n    34→\n    35→/**\n    36→ * Fallback Token Blacklist (In-Memory)\n    37→ * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n    38→ */\n    39→const fallbackBlacklist = new Map();\n    40→\n    41→// Track if we're using fallback mode\n    42→let usingFallback = false;\n    43→\n    44→// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\n    45→const BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n    46→\n    47→/**\n    48→ * Clean up expired entries from the fallback blacklist\n    49→ * Only runs when using in-memory fallback\n    50→ */\n    51→function cleanupFallbackBlacklist() {\n    52→  if (!usingFallback || fallbackBlacklist.size === 0) {\n    53→    return;\n    54→  }\n    55→\n    56→  const now = Math.floor(Date.now() / 1000);\n    57→  let cleanedCount = 0;\n    58→\n    59→  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    60→    if (exp <= now) {\n    61→      fallbackBlacklist.delete(jti);\n    62→      cleanedCount++;\n    63→    }\n    64→  }\n    65→\n    66→  if (cleanedCount > 0) {\n    67→    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n    68→  }\n    69→}\n    70→\n    71→// Start periodic cleanup for fallback (unref to allow process exit)\n    72→const cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\n    73→if (cleanupTimer.unref) {\n    74→  cleanupTimer.unref();\n    75→}\n    76→\n    77→/**\n    78→ * Add a token to the blacklist\n    79→ * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n    80→ * @param {string} jti - JWT ID claim\n    81→ * @param {number} exp - Token expiration timestamp (Unix seconds)\n    82→ * @param {Object} options - Additional options for logging\n    83→ * @param {string} options.userId - User ID for logging\n    84→ * @param {string} options.reason - Reason for revocation (logout, security, admin)\n    85→ * @returns {Promise<boolean>} True if successfully blacklisted\n    86→ */\n    87→async function blacklistToken(jti, exp, options = {}) {\n    88→  if (!jti) {\n    89→    console.warn('[Auth] Cannot blacklist token without jti');\n    90→    return false;\n    91→  }\n    92→\n    93→  const now = Math.floor(Date.now() / 1000);\n    94→  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n    95→\n    96→  // Try Redis first\n    97→  if (redis.isRedisAvailable()) {\n    98→    try {\n    99→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   100→      const success = await redis.set(key, exp, ttlSeconds);\n   101→\n   102→      if (success) {\n   103→        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n   104→        usingFallback = false;\n   105→        // Log token revocation with structured logging\n   106→        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   107→        return true;\n   108→      }\n   109→    } catch (err) {\n   110→      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n   111→    }\n   112→  }\n   113→\n   114→  // Fallback to in-memory\n   115→  usingFallback = true;\n   116→  fallbackBlacklist.set(jti, exp);\n   117→  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n   118→\n   119→  // Log token revocation with structured logging\n   120→  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   121→  return true;\n   122→}\n   123→\n   124→/**\n   125→ * Check if a token is blacklisted\n   126→ * Checks Redis first, then fallback in-memory store\n   127→ * @param {string} jti - JWT ID claim\n   128→ * @returns {Promise<boolean>} True if token is blacklisted\n   129→ */\n   130→async function isTokenBlacklisted(jti) {\n   131→  if (!jti) {\n   132→    return false;\n   133→  }\n   134→\n   135→  // Try Redis first\n   136→  if (redis.isRedisAvailable()) {\n   137→    try {\n   138→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   139→      const exists = await redis.exists(key);\n   140→\n   141→      if (exists) {\n   142→        return true;\n   143→      }\n   144→\n   145→      // Also check fallback in case token was blacklisted during Redis downtime\n   146→      // and Redis is now back up\n   147→      if (fallbackBlacklist.has(jti)) {\n   148→        // Migrate to Redis if token still valid\n   149→        const exp = fallbackBlacklist.get(jti);\n   150→        const now = Math.floor(Date.now() / 1000);\n   151→        if (exp > now) {\n   152→          const ttlSeconds = exp - now;\n   153→          await redis.set(key, exp, ttlSeconds);\n   154→          fallbackBlacklist.delete(jti);\n   155→          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n   156→        } else {\n   157→          // Expired, remove from fallback\n   158→          fallbackBlacklist.delete(jti);\n   159→        }\n   160→        return true;\n   161→      }\n   162→\n   163→      return false;\n   164→    } catch (err) {\n   165→      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n   166→    }\n   167→  }\n   168→\n   169→  // Fallback to in-memory check\n   170→  if (fallbackBlacklist.has(jti)) {\n   171→    const exp = fallbackBlacklist.get(jti);\n   172→    const now = Math.floor(Date.now() / 1000);\n   173→    if (exp > now) {\n   174→      return true;\n   175→    }\n   176→    // Expired, remove it\n   177→    fallbackBlacklist.delete(jti);\n   178→  }\n   179→\n   180→  return false;\n   181→}\n   182→\n   183→/**\n   184→ * Get blacklist statistics (for monitoring)\n   185→ * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n   186→ */\n   187→async function getBlacklistStats() {\n   188→  const redisAvailable = redis.isRedisAvailable();\n   189→  const redisStatus = redis.getRedisStatus();\n   190→\n   191→  return {\n   192→    storage: redisAvailable ? 'redis' : 'memory',\n   193→    redisConnected: redisStatus.connected,\n   194→    redisError: redisStatus.error,\n   195→    fallbackSize: fallbackBlacklist.size,\n   196→    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n   197→    usingFallback\n   198→  };\n   199→}\n   200→\n   201→/**\n   202→ * Generate a JWT token for a customer\n   203→ * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n   204→ * @param {Object} options - Additional options\n   205→ * @param {string} options.tier - User's subscription tier\n   206→ * @param {string} options.email - User's email (optional)\n   207→ * @returns {Object} { token, expiresIn }\n   208→ */\n   209→function generateToken(stripeCustomerId, options = {}) {\n   210→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   211→    throw new Error('Invalid Stripe customer ID');\n   212→  }\n   213→\n   214→  const payload = {\n   215→    sub: stripeCustomerId,\n   216→    type: 'access',\n   217→    tier: options.tier || 'starter',\n   218→    iat: Math.floor(Date.now() / 1000),\n   219→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   220→  };\n   221→\n   222→  if (options.email) {\n   223→    payload.email = options.email;\n   224→  }\n   225→\n   226→  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n   227→\n   228→  return {\n   229→    token,\n   230→    expiresIn: JWT_EXPIRES_IN,\n   231→    tokenType: 'Bearer'\n   232→  };\n   233→}\n   234→\n   235→/**\n   236→ * Generate a refresh token for a customer\n   237→ * @param {string} stripeCustomerId - Stripe customer ID\n   238→ * @returns {Object} { refreshToken, expiresIn }\n   239→ */\n   240→function generateRefreshToken(stripeCustomerId) {\n   241→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   242→    throw new Error('Invalid Stripe customer ID');\n   243→  }\n   244→\n   245→  const payload = {\n   246→    sub: stripeCustomerId,\n   247→    type: 'refresh',\n   248→    iat: Math.floor(Date.now() / 1000),\n   249→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   250→  };\n   251→\n   252→  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n   253→\n   254→  return {\n   255→    refreshToken,\n   256→    expiresIn: JWT_REFRESH_EXPIRES_IN\n   257→  };\n   258→}\n   259→\n   260→/**\n   261→ * Verify and decode a JWT token (async version)\n   262→ * Checks both JWT signature validity and token blacklist status via Redis\n   263→ * @param {string} token - JWT token to verify\n   264→ * @param {Object} options - Verification options\n   265→ * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n   266→ * @param {Object} options.req - Express request object for logging (optional)\n   267→ * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n   268→ */\n   269→async function verifyToken(token, options = {}) {\n   270→  const { checkBlacklist = true, req = null } = options;\n   271→\n   272→  try {\n   273→    const decoded = jwt.verify(token, JWT_SECRET);\n   274→\n   275→    // Check if token has been revoked (blacklisted) - async Redis check\n   276→    if (checkBlacklist && decoded.jti) {\n   277→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   278→      if (isBlacklisted) {\n   279→        if (req) {\n   280→          authLogger.logTokenBlacklisted(req, decoded.jti);\n   281→        }\n   282→        return null;\n   283→      }\n   284→    }\n   285→\n   286→    return decoded;\n   287→  } catch (err) {\n   288→    // Log specific error types for debugging\n   289→    if (err.name === 'TokenExpiredError') {\n   290→      if (req) {\n   291→        authLogger.logTokenExpired(req);\n   292→      }\n   293→    } else if (err.name === 'JsonWebTokenError') {\n   294→      if (req) {\n   295→        authLogger.logTokenInvalid(req, err.message);\n   296→      }\n   297→    }\n   298→    return null;\n   299→  }\n   300→}\n   301→\n   302→/**\n   303→ * Synchronous token verification (for cases where async is not possible)\n   304→ * Does NOT check blacklist - use verifyToken() for full verification\n   305→ * @param {string} token - JWT token to verify\n   306→ * @returns {Object|null} Decoded payload or null if invalid\n   307→ */\n   308→function verifyTokenSync(token) {\n   309→  try {\n   310→    return jwt.verify(token, JWT_SECRET);\n   311→  } catch {\n   312→    return null;\n   313→  }\n   314→}\n   315→\n   316→/**\n   317→ * Extract Bearer token from Authorization header\n   318→ * @param {string} authHeader - Authorization header value\n   319→ * @returns {string|null} Token or null if not found\n   320→ */\n   321→function extractBearerToken(authHeader) {\n   322→  if (!authHeader || typeof authHeader !== 'string') {\n   323→    return null;\n   324→  }\n   325→\n   326→  const parts = authHeader.split(' ');\n   327→  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n   328→    return null;\n   329→  }\n   330→\n   331→  return parts[1];\n   332→}\n   333→\n   334→/**\n   335→ * Middleware to authenticate JWT tokens\n   336→ * Sets req.stripeCustomerId if valid token found\n   337→ *\n   338→ * Supports both:\n   339→ * - Authorization: Bearer <token> (preferred)\n   340→ * - x-stripe-customer-id header (legacy, will be deprecated)\n   341→ */\n   342→async function authenticateToken(req, res, next) {\n   343→  // First, try JWT token from Authorization header\n   344→  const authHeader = req.headers['authorization'];\n   345→  const token = extractBearerToken(authHeader);\n   346→\n   347→  if (token) {\n   348→    // First verify JWT signature without blacklist check to get specific error messages\n   349→    const decoded = verifyTokenSync(token);\n   350→\n   351→    if (!decoded || !decoded.sub) {\n   352→      // Token is invalid or expired (signature failed)\n   353→      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n   354→      return res.status(401).json({\n   355→        error: 'Invalid or expired token',\n   356→        message: 'Please log in again to continue'\n   357→      });\n   358→    }\n   359→\n   360→    // Check if token has been revoked (blacklisted) - async Redis check\n   361→    if (decoded.jti) {\n   362→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   363→      if (isBlacklisted) {\n   364→        authLogger.logTokenBlacklisted(req, decoded.jti);\n   365→        return res.status(401).json({\n   366→          error: 'Token has been revoked',\n   367→          message: 'This session has been logged out. Please log in again.'\n   368→        });\n   369→      }\n   370→    }\n   371→\n   372→    // Token is valid and not revoked\n   373→    req.stripeCustomerId = decoded.sub;\n   374→    req.tokenData = decoded;\n   375→    req.rawToken = token; // Store raw token for logout\n   376→    return next();\n   377→  }\n   378→\n   379→  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n   380→  // This will be deprecated in future versions\n   381→  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   382→  if (legacyCustomerId) {\n   383→    // Log deprecation warning with structured logging (once per request)\n   384→    if (!req._legacyAuthWarned) {\n   385→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   386→      req._legacyAuthWarned = true;\n   387→    }\n   388→\n   389→    // Validate format\n   390→    if (!legacyCustomerId.startsWith('cus_')) {\n   391→      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n   392→      return res.status(401).json({\n   393→        error: 'Invalid customer ID format',\n   394→        message: 'Customer ID must start with cus_'\n   395→      });\n   396→    }\n   397→\n   398→    req.stripeCustomerId = legacyCustomerId;\n   399→    req.isLegacyAuth = true;\n   400→    return next();\n   401→  }\n   402→\n   403→  // No authentication provided\n   404→  return res.status(401).json({\n   405→    error: 'Authentication required',\n   406→    message: 'Please provide a valid Bearer token in the Authorization header'\n   407→  });\n   408→}\n   409→\n   410→/**\n   411→ * Optional authentication middleware\n   412→ * Allows unauthenticated access but sets req.stripeCustomerId if token present\n   413→ */\n   414→async function optionalAuthentication(req, res, next) {\n   415→  const authHeader = req.headers['authorization'];\n   416→  const token = extractBearerToken(authHeader);\n   417→\n   418→  if (token) {\n   419→    const decoded = await verifyToken(token);\n   420→    if (decoded && decoded.sub) {\n   421→      req.stripeCustomerId = decoded.sub;\n   422→      req.tokenData = decoded;\n   423→    }\n   424→  } else {\n   425→    // Check legacy header\n   426→    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   427→    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n   428→      req.stripeCustomerId = legacyCustomerId;\n   429→      req.isLegacyAuth = true;\n   430→    }\n   431→  }\n   432→\n   433→  next();\n   434→}\n   435→\n   436→/**\n   437→ * Mask sensitive data for logging\n   438→ * @param {string} key - License key or other sensitive string\n   439→ * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n   440→ */\n   441→function maskSensitiveData(data) {\n   442→  if (!data || typeof data !== 'string') {\n   443→    return '****';\n   444→  }\n   445→\n   446→  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n   447→  if (data.startsWith('SPLICE-')) {\n   448→    const parts = data.split('-');\n   449→    if (parts.length === 5) {\n   450→      return `${parts[0]}-${parts[1]}-****-****-****`;\n   451→    }\n   452→  }\n   453→\n   454→  // For customer IDs (cus_xxxx format)\n   455→  if (data.startsWith('cus_')) {\n   456→    if (data.length > 10) {\n   457→      return `cus_${data.slice(4, 8)}****`;\n   458→    }\n   459→    return 'cus_****';\n   460→  }\n   461→\n   462→  // For JWTs (eyJ... format)\n   463→  if (data.startsWith('eyJ')) {\n   464→    return `${data.slice(0, 10)}...****`;\n   465→  }\n   466→\n   467→  // For emails\n   468→  if (data.includes('@')) {\n   469→    const [local, domain] = data.split('@');\n   470→    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n   471→    return `${maskedLocal}@${domain}`;\n   472→  }\n   473→\n   474→  // Generic masking - show first 4 chars\n   475→  if (data.length > 8) {\n   476→    return `${data.slice(0, 4)}****`;\n   477→  }\n   478→\n   479→  return '****';\n   480→}\n   481→\n   482→module.exports = {\n   483→  generateToken,\n   484→  generateRefreshToken,\n   485→  verifyToken,\n   486→  verifyTokenSync,\n   487→  extractBearerToken,\n   488→  authenticateToken,\n   489→  optionalAuthentication,\n   490→  maskSensitiveData,\n   491→  // Token blacklist functions\n   492→  blacklistToken,\n   493→  isTokenBlacklisted,\n   494→  getBlacklistStats,\n   495→  // Structured logging\n   496→  authLogger,\n   497→  // Constants\n   498→  JWT_SECRET,\n   499→  JWT_EXPIRES_IN\n   500→};\n   501→\n\n</system-reminder>\n"}]},"uuid":"047bbaa7-6fb8-425d-9f2a-dcefacc41326","timestamp":"2025-12-30T01:03:58.369Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","content":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// Warn if using default secret in production\nif (isProduction && JWT_SECRET === 'splice-dev-secret-change-in-production') {\n  console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n  console.error('[SECURITY] Exiting process to prevent insecure operation.');\n  process.exit(1);\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n  // This will be deprecated in future versions\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // Check legacy header\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      req.stripeCustomerId = legacyCustomerId;\n      req.isLegacyAuth = true;\n    }\n  }\n\n  next();\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};\n","numLines":501,"startLine":1,"totalLines":501}}}
{"parentUuid":"047bbaa7-6fb8-425d-9f2a-dcefacc41326","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SMu1dXPZCtdMFTDG45vDmm","type":"tool_result","content":"     1→/**\n     2→ * Auth Routes\n     3→ *\n     4→ * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n     5→ */\n     6→\n     7→const express = require('express');\n     8→const crypto = require('crypto');\n     9→const { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\n    10→const authLogger = require('../utils/authLogger');\n    11→\n    12→// ============================================================================\n    13→// Email Verification Code Storage\n    14→// In-memory store for verification codes. Maps email -> { code, expires, attempts }\n    15→// Can be upgraded to Redis for distributed deployments.\n    16→// ============================================================================\n    17→\n    18→const verificationCodes = new Map();\n    19→\n    20→// Verification code expiry time (10 minutes)\n    21→const VERIFICATION_CODE_EXPIRY_MS = 10 * 60 * 1000;\n    22→\n    23→// Maximum verification attempts before code is invalidated\n    24→const MAX_VERIFICATION_ATTEMPTS = 5;\n    25→\n    26→// Rate limiting: minimum time between sending codes to same email (60 seconds)\n    27→const SEND_CODE_COOLDOWN_MS = 60 * 1000;\n    28→\n    29→// Track last send time per email for rate limiting\n    30→const lastSendTime = new Map();\n    31→\n    32→// Cleanup interval for expired codes (every 5 minutes)\n    33→const CLEANUP_INTERVAL_MS = 5 * 60 * 1000;\n    34→\n    35→/**\n    36→ * Generate a 6-digit verification code\n    37→ * @returns {string} 6-digit code\n    38→ */\n    39→function generateVerificationCode() {\n    40→  // Generate cryptographically secure random 6-digit code\n    41→  const code = crypto.randomInt(100000, 999999).toString();\n    42→  return code;\n    43→}\n    44→\n    45→/**\n    46→ * Store a verification code for an email\n    47→ * @param {string} email - Email address\n    48→ * @param {string} code - Verification code\n    49→ */\n    50→function storeVerificationCode(email, code) {\n    51→  const normalizedEmail = email.toLowerCase().trim();\n    52→  verificationCodes.set(normalizedEmail, {\n    53→    code,\n    54→    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS,\n    55→    attempts: 0,\n    56→    createdAt: Date.now()\n    57→  });\n    58→  lastSendTime.set(normalizedEmail, Date.now());\n    59→}\n    60→\n    61→/**\n    62→ * Verify a code for an email\n    63→ * @param {string} email - Email address\n    64→ * @param {string} code - Code to verify\n    65→ * @returns {{ valid: boolean, error?: string }}\n    66→ */\n    67→function verifyCode(email, code) {\n    68→  const normalizedEmail = email.toLowerCase().trim();\n    69→  const stored = verificationCodes.get(normalizedEmail);\n    70→\n    71→  if (!stored) {\n    72→    return { valid: false, error: 'No verification code found. Please request a new one.' };\n    73→  }\n    74→\n    75→  // Check if expired\n    76→  if (Date.now() > stored.expires) {\n    77→    verificationCodes.delete(normalizedEmail);\n    78→    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n    79→  }\n    80→\n    81→  // Increment attempt counter\n    82→  stored.attempts++;\n    83→\n    84→  // Check if too many attempts\n    85→  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n    86→    verificationCodes.delete(normalizedEmail);\n    87→    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n    88→  }\n    89→\n    90→  // Check if code matches\n    91→  if (stored.code !== code) {\n    92→    verificationCodes.set(normalizedEmail, stored);\n    93→    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n    94→  }\n    95→\n    96→  // Code is valid - remove it (single use)\n    97→  verificationCodes.delete(normalizedEmail);\n    98→  return { valid: true };\n    99→}\n   100→\n   101→/**\n   102→ * Check if we can send a new code to an email (rate limiting)\n   103→ * @param {string} email - Email address\n   104→ * @returns {{ allowed: boolean, waitSeconds?: number }}\n   105→ */\n   106→function canSendCode(email) {\n   107→  const normalizedEmail = email.toLowerCase().trim();\n   108→  const lastSent = lastSendTime.get(normalizedEmail);\n   109→\n   110→  if (!lastSent) {\n   111→    return { allowed: true };\n   112→  }\n   113→\n   114→  const elapsed = Date.now() - lastSent;\n   115→  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n   116→    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n   117→    return { allowed: false, waitSeconds };\n   118→  }\n   119→\n   120→  return { allowed: true };\n   121→}\n   122→\n   123→/**\n   124→ * Clean up expired verification codes\n   125→ */\n   126→function cleanupVerificationCodes() {\n   127→  const now = Date.now();\n   128→  let cleanedCount = 0;\n   129→\n   130→  for (const [email, data] of verificationCodes.entries()) {\n   131→    if (data.expires <= now) {\n   132→      verificationCodes.delete(email);\n   133→      cleanedCount++;\n   134→    }\n   135→  }\n   136→\n   137→  // Also clean up old lastSendTime entries (older than 1 hour)\n   138→  const oneHourAgo = now - (60 * 60 * 1000);\n   139→  for (const [email, time] of lastSendTime.entries()) {\n   140→    if (time < oneHourAgo) {\n   141→      lastSendTime.delete(email);\n   142→    }\n   143→  }\n   144→\n   145→  if (cleanedCount > 0) {\n   146→    console.log(`[Auth] Verification code cleanup: removed ${cleanedCount} expired codes`);\n   147→  }\n   148→}\n   149→\n   150→// Start periodic cleanup (unref to allow process exit)\n   151→const cleanupTimer = setInterval(cleanupVerificationCodes, CLEANUP_INTERVAL_MS);\n   152→if (cleanupTimer.unref) {\n   153→  cleanupTimer.unref();\n   154→}\n   155→\n   156→/**\n   157→ * Validate email format\n   158→ * @param {string} email - Email to validate\n   159→ * @returns {boolean}\n   160→ */\n   161→function isValidEmail(email) {\n   162→  if (!email || typeof email !== 'string') return false;\n   163→  // Basic email validation regex\n   164→  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n   165→  return emailRegex.test(email.trim());\n   166→}\n   167→\n   168→/**\n   169→ * Create auth routes\n   170→ * @param {Object} options - Route configuration options\n   171→ * @param {Object} options.middleware - Shared middleware (authenticateToken)\n   172→ * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n   173→ * @param {Object} options.authHelpers - Auth helper functions\n   174→ * @returns {express.Router}\n   175→ */\n   176→function createAuthRoutes(options = {}) {\n   177→  const router = express.Router();\n   178→  const { authenticateToken } = options.middleware || {};\n   179→  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n   180→  const { usageTracking, licenseService, emailService } = options.services || {};\n   181→\n   182→  /**\n   183→   * GET /csrf-token - Generate and return a CSRF token\n   184→   *\n   185→   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   186→   * The token is returned in both the response body and an HttpOnly cookie.\n   187→   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   188→   */\n   189→  router.get('/csrf-token', csrfTokenHandler);\n   190→\n   191→  /**\n   192→   * POST /login - Authenticate with license key and get JWT token\n   193→   *\n   194→   * SECURITY: This is the primary authentication endpoint.\n   195→   * Validates license key and returns a JWT token for API access.\n   196→   * CSRF protection applied to prevent cross-site login attacks.\n   197→   */\n   198→  router.post('/login', validateCsrfToken, async (req, res) => {\n   199→    const { licenseKey } = req.body;\n   200→\n   201→    if (!licenseKey) {\n   202→      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n   203→      return res.status(400).json({\n   204→        error: 'License key required',\n   205→        message: 'Please provide your license key to log in'\n   206→      });\n   207→    }\n   208→\n   209→    try {\n   210→      // Validate and activate the license key\n   211→      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n   212→\n   213→      if (!licenseResult.success) {\n   214→        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n   215→        return res.status(401).json({\n   216→          error: 'Invalid license key',\n   217→          message: licenseResult.error || 'The license key is invalid or expired'\n   218→        });\n   219→      }\n   220→\n   221→      // Get user's tier and balance\n   222→      const balance = await usageTracking.getBalance(licenseResult.customerId);\n   223→\n   224→      // Generate JWT tokens\n   225→      const tokenResult = generateToken(licenseResult.customerId, {\n   226→        tier: balance.tier,\n   227→        email: licenseResult.email\n   228→      });\n   229→      const refreshResult = generateRefreshToken(licenseResult.customerId);\n   230→\n   231→      // Log successful login with structured logging\n   232→      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n   233→        email: licenseResult.email,\n   234→        tier: balance.tier\n   235→      });\n   236→\n   237→      res.json({\n   238→        success: true,\n   239→        token: tokenResult.token,\n   240→        tokenType: tokenResult.tokenType,\n   241→        expiresIn: tokenResult.expiresIn,\n   242→        refreshToken: refreshResult.refreshToken,\n   243→        customerId: licenseResult.customerId,\n   244→        tier: balance.tier,\n   245→        hoursRemaining: balance.hoursRemaining\n   246→      });\n   247→    } catch (err) {\n   248→      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n   249→      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n   250→    }\n   251→  });\n   252→\n   253→  /**\n   254→   * POST /refresh - Refresh an expired JWT token\n   255→   *\n   256→   * Uses a refresh token to get a new access token.\n   257→   * CSRF protection applied to prevent token theft via cross-site requests.\n   258→   */\n   259→  router.post('/refresh', validateCsrfToken, async (req, res) => {\n   260→    const { refreshToken } = req.body;\n   261→\n   262→    if (!refreshToken) {\n   263→      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n   264→      return res.status(400).json({\n   265→        error: 'Refresh token required'\n   266→      });\n   267→    }\n   268→\n   269→    try {\n   270→      const decoded = await verifyToken(refreshToken, { req });\n   271→\n   272→      if (!decoded || decoded.type !== 'refresh') {\n   273→        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n   274→        return res.status(401).json({\n   275→          error: 'Invalid refresh token',\n   276→          message: 'Please log in again'\n   277→        });\n   278→      }\n   279→\n   280→      // Get current user info\n   281→      const balance = await usageTracking.getBalance(decoded.sub);\n   282→\n   283→      // Generate new access token\n   284→      const tokenResult = generateToken(decoded.sub, {\n   285→        tier: balance.tier\n   286→      });\n   287→\n   288→      // Log successful token refresh\n   289→      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n   290→\n   291→      res.json({\n   292→        success: true,\n   293→        token: tokenResult.token,\n   294→        tokenType: tokenResult.tokenType,\n   295→        expiresIn: tokenResult.expiresIn\n   296→      });\n   297→    } catch (err) {\n   298→      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n   299→      res.status(401).json({\n   300→        error: 'Failed to refresh token',\n   301→        message: 'Please log in again'\n   302→      });\n   303→    }\n   304→  });\n   305→\n   306→  /**\n   307→   * POST /logout - Invalidate tokens by adding to blacklist\n   308→   *\n   309→   * Adds the current token's jti to the blacklist so it cannot be reused.\n   310→   * Also accepts an optional refreshToken to revoke both tokens at once.\n   311→   * CSRF protection applied to prevent forced logout attacks.\n   312→   */\n   313→  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n   314→    const { refreshToken } = req.body;\n   315→    let refreshTokenRevoked = false;\n   316→\n   317→    // Blacklist the access token using the blacklistToken function from authHelpers\n   318→    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n   319→      if (blacklistToken) {\n   320→        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n   321→          userId: req.stripeCustomerId,\n   322→          reason: 'logout'\n   323→        });\n   324→      } else {\n   325→        console.warn('[Auth] Logout: blacklistToken function not available');\n   326→      }\n   327→    } else {\n   328→      // Token doesn't have jti - log warning but continue\n   329→      // This handles tokens generated before jti was added\n   330→      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n   331→    }\n   332→\n   333→    // Optionally blacklist the refresh token too\n   334→    if (refreshToken && blacklistToken) {\n   335→      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n   336→      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n   337→      if (decoded && decoded.jti && decoded.exp) {\n   338→        await blacklistToken(decoded.jti, decoded.exp, {\n   339→          userId: req.stripeCustomerId,\n   340→          reason: 'logout_refresh'\n   341→        });\n   342→        refreshTokenRevoked = true;\n   343→      }\n   344→    }\n   345→\n   346→    // Log successful logout with structured logging\n   347→    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n   348→      jti: req.tokenData?.jti,\n   349→      refreshTokenRevoked\n   350→    });\n   351→\n   352→    res.json({\n   353→      success: true,\n   354→      message: 'Logged out successfully'\n   355→    });\n   356→  });\n   357→\n   358→  // ==========================================================================\n   359→  // Email Verification Endpoints\n   360→  // ==========================================================================\n   361→\n   362→  /**\n   363→   * POST /send-verification - Send a verification code to an email address\n   364→   *\n   365→   * Request body: { email: string }\n   366→   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   367→   *\n   368→   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   369→   */\n   370→  router.post('/send-verification', validateCsrfToken, async (req, res) => {\n   371→    const { email } = req.body;\n   372→\n   373→    // Validate email\n   374→    if (!email) {\n   375→      return res.status(400).json({\n   376→        error: 'Email required',\n   377→        message: 'Please provide an email address'\n   378→      });\n   379→    }\n   380→\n   381→    if (!isValidEmail(email)) {\n   382→      return res.status(400).json({\n   383→        error: 'Invalid email',\n   384→        message: 'Please provide a valid email address'\n   385→      });\n   386→    }\n   387→\n   388→    // Check rate limiting\n   389→    const rateCheck = canSendCode(email);\n   390→    if (!rateCheck.allowed) {\n   391→      return res.status(429).json({\n   392→        error: 'Too many requests',\n   393→        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n   394→        waitSeconds: rateCheck.waitSeconds\n   395→      });\n   396→    }\n   397→\n   398→    try {\n   399→      // Generate and store verification code\n   400→      const code = generateVerificationCode();\n   401→      storeVerificationCode(email, code);\n   402→\n   403→      // Send verification email\n   404→      if (emailService && emailService.sendEmailVerificationCode) {\n   405→        await emailService.sendEmailVerificationCode(email, code, 10);\n   406→        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n   407→      } else {\n   408→        // Fallback for development - log to console\n   409→        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n   410→      }\n   411→\n   412→      res.json({\n   413→        success: true,\n   414→        message: 'Verification code sent. Please check your email.',\n   415→        expiresInMinutes: 10\n   416→      });\n   417→    } catch (err) {\n   418→      console.error('[Auth] Send verification error:', err.message);\n   419→      res.status(500).json({\n   420→        error: 'Failed to send verification code',\n   421→        message: 'Please try again later'\n   422→      });\n   423→    }\n   424→  });\n   425→\n   426→  /**\n   427→   * POST /verify-email - Verify an email address with a code\n   428→   *\n   429→   * Request body: { email: string, code: string }\n   430→   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   431→   *\n   432→   * SECURITY: Limited attempts per code. CSRF protection applied.\n   433→   */\n   434→  router.post('/verify-email', validateCsrfToken, async (req, res) => {\n   435→    const { email, code } = req.body;\n   436→\n   437→    // Validate inputs\n   438→    if (!email) {\n   439→      return res.status(400).json({\n   440→        error: 'Email required',\n   441→        message: 'Please provide an email address'\n   442→      });\n   443→    }\n   444→\n   445→    if (!code) {\n   446→      return res.status(400).json({\n   447→        error: 'Code required',\n   448→        message: 'Please provide the verification code'\n   449→      });\n   450→    }\n   451→\n   452→    if (!isValidEmail(email)) {\n   453→      return res.status(400).json({\n   454→        error: 'Invalid email',\n   455→        message: 'Please provide a valid email address'\n   456→      });\n   457→    }\n   458→\n   459→    // Validate code format (6 digits)\n   460→    const codeStr = String(code).trim();\n   461→    if (!/^\\d{6}$/.test(codeStr)) {\n   462→      return res.status(400).json({\n   463→        error: 'Invalid code format',\n   464→        message: 'Verification code must be 6 digits'\n   465→      });\n   466→    }\n   467→\n   468→    try {\n   469→      // Verify the code\n   470→      const result = verifyCode(email, codeStr);\n   471→\n   472→      if (!result.valid) {\n   473→        return res.status(400).json({\n   474→          success: false,\n   475→          verified: false,\n   476→          error: 'Verification failed',\n   477→          message: result.error\n   478→        });\n   479→      }\n   480→\n   481→      // Mark email as verified in the database\n   482→      if (usageTracking && usageTracking.markEmailVerified) {\n   483→        const dbResult = await usageTracking.markEmailVerified(email);\n   484→        if (!dbResult.success) {\n   485→          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n   486→        }\n   487→      }\n   488→\n   489→      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n   490→\n   491→      // Email verified successfully\n   492→      res.json({\n   493→        success: true,\n   494→        verified: true,\n   495→        message: 'Email verified successfully'\n   496→      });\n   497→    } catch (err) {\n   498→      console.error('[Auth] Verify email error:', err.message);\n   499→      res.status(500).json({\n   500→        error: 'Verification failed',\n   501→        message: 'Please try again later'\n   502→      });\n   503→    }\n   504→  });\n   505→\n   506→  return router;\n   507→}\n   508→\n   509→module.exports = createAuthRoutes;\n   510→\n\n</system-reminder>\n"}]},"uuid":"52c9a74f-f9ec-4049-8e90-2068244358a3","timestamp":"2025-12-30T01:03:58.370Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/auth.js","content":"/**\n * Auth Routes\n *\n * Authentication endpoints (login, refresh, logout, csrf-token, email verification)\n */\n\nconst express = require('express');\nconst crypto = require('crypto');\nconst { csrfTokenHandler, validateCsrfToken } = require('../middleware/csrf');\nconst authLogger = require('../utils/authLogger');\n\n// ============================================================================\n// Email Verification Code Storage\n// In-memory store for verification codes. Maps email -> { code, expires, attempts }\n// Can be upgraded to Redis for distributed deployments.\n// ============================================================================\n\nconst verificationCodes = new Map();\n\n// Verification code expiry time (10 minutes)\nconst VERIFICATION_CODE_EXPIRY_MS = 10 * 60 * 1000;\n\n// Maximum verification attempts before code is invalidated\nconst MAX_VERIFICATION_ATTEMPTS = 5;\n\n// Rate limiting: minimum time between sending codes to same email (60 seconds)\nconst SEND_CODE_COOLDOWN_MS = 60 * 1000;\n\n// Track last send time per email for rate limiting\nconst lastSendTime = new Map();\n\n// Cleanup interval for expired codes (every 5 minutes)\nconst CLEANUP_INTERVAL_MS = 5 * 60 * 1000;\n\n/**\n * Generate a 6-digit verification code\n * @returns {string} 6-digit code\n */\nfunction generateVerificationCode() {\n  // Generate cryptographically secure random 6-digit code\n  const code = crypto.randomInt(100000, 999999).toString();\n  return code;\n}\n\n/**\n * Store a verification code for an email\n * @param {string} email - Email address\n * @param {string} code - Verification code\n */\nfunction storeVerificationCode(email, code) {\n  const normalizedEmail = email.toLowerCase().trim();\n  verificationCodes.set(normalizedEmail, {\n    code,\n    expires: Date.now() + VERIFICATION_CODE_EXPIRY_MS,\n    attempts: 0,\n    createdAt: Date.now()\n  });\n  lastSendTime.set(normalizedEmail, Date.now());\n}\n\n/**\n * Verify a code for an email\n * @param {string} email - Email address\n * @param {string} code - Code to verify\n * @returns {{ valid: boolean, error?: string }}\n */\nfunction verifyCode(email, code) {\n  const normalizedEmail = email.toLowerCase().trim();\n  const stored = verificationCodes.get(normalizedEmail);\n\n  if (!stored) {\n    return { valid: false, error: 'No verification code found. Please request a new one.' };\n  }\n\n  // Check if expired\n  if (Date.now() > stored.expires) {\n    verificationCodes.delete(normalizedEmail);\n    return { valid: false, error: 'Verification code has expired. Please request a new one.' };\n  }\n\n  // Increment attempt counter\n  stored.attempts++;\n\n  // Check if too many attempts\n  if (stored.attempts > MAX_VERIFICATION_ATTEMPTS) {\n    verificationCodes.delete(normalizedEmail);\n    return { valid: false, error: 'Too many failed attempts. Please request a new code.' };\n  }\n\n  // Check if code matches\n  if (stored.code !== code) {\n    verificationCodes.set(normalizedEmail, stored);\n    return { valid: false, error: `Invalid verification code. ${MAX_VERIFICATION_ATTEMPTS - stored.attempts} attempts remaining.` };\n  }\n\n  // Code is valid - remove it (single use)\n  verificationCodes.delete(normalizedEmail);\n  return { valid: true };\n}\n\n/**\n * Check if we can send a new code to an email (rate limiting)\n * @param {string} email - Email address\n * @returns {{ allowed: boolean, waitSeconds?: number }}\n */\nfunction canSendCode(email) {\n  const normalizedEmail = email.toLowerCase().trim();\n  const lastSent = lastSendTime.get(normalizedEmail);\n\n  if (!lastSent) {\n    return { allowed: true };\n  }\n\n  const elapsed = Date.now() - lastSent;\n  if (elapsed < SEND_CODE_COOLDOWN_MS) {\n    const waitSeconds = Math.ceil((SEND_CODE_COOLDOWN_MS - elapsed) / 1000);\n    return { allowed: false, waitSeconds };\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Clean up expired verification codes\n */\nfunction cleanupVerificationCodes() {\n  const now = Date.now();\n  let cleanedCount = 0;\n\n  for (const [email, data] of verificationCodes.entries()) {\n    if (data.expires <= now) {\n      verificationCodes.delete(email);\n      cleanedCount++;\n    }\n  }\n\n  // Also clean up old lastSendTime entries (older than 1 hour)\n  const oneHourAgo = now - (60 * 60 * 1000);\n  for (const [email, time] of lastSendTime.entries()) {\n    if (time < oneHourAgo) {\n      lastSendTime.delete(email);\n    }\n  }\n\n  if (cleanedCount > 0) {\n    console.log(`[Auth] Verification code cleanup: removed ${cleanedCount} expired codes`);\n  }\n}\n\n// Start periodic cleanup (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupVerificationCodes, CLEANUP_INTERVAL_MS);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Validate email format\n * @param {string} email - Email to validate\n * @returns {boolean}\n */\nfunction isValidEmail(email) {\n  if (!email || typeof email !== 'string') return false;\n  // Basic email validation regex\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email.trim());\n}\n\n/**\n * Create auth routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (authenticateToken)\n * @param {Object} options.services - Shared services (usageTracking, licenseService, emailService)\n * @param {Object} options.authHelpers - Auth helper functions\n * @returns {express.Router}\n */\nfunction createAuthRoutes(options = {}) {\n  const router = express.Router();\n  const { authenticateToken } = options.middleware || {};\n  const { generateToken, generateRefreshToken, verifyToken, maskSensitiveData, blacklistToken } = options.authHelpers || {};\n  const { usageTracking, licenseService, emailService } = options.services || {};\n\n  /**\n   * GET /csrf-token - Generate and return a CSRF token\n   *\n   * SECURITY: This endpoint provides CSRF tokens for state-changing requests.\n   * The token is returned in both the response body and an HttpOnly cookie.\n   * Clients must include the token in the X-CSRF-Token header for POST/PUT/DELETE requests.\n   */\n  router.get('/csrf-token', csrfTokenHandler);\n\n  /**\n   * POST /login - Authenticate with license key and get JWT token\n   *\n   * SECURITY: This is the primary authentication endpoint.\n   * Validates license key and returns a JWT token for API access.\n   * CSRF protection applied to prevent cross-site login attacks.\n   */\n  router.post('/login', validateCsrfToken, async (req, res) => {\n    const { licenseKey } = req.body;\n\n    if (!licenseKey) {\n      authLogger.logLoginFailed(req, 'missing_license_key', { licenseKey: null });\n      return res.status(400).json({\n        error: 'License key required',\n        message: 'Please provide your license key to log in'\n      });\n    }\n\n    try {\n      // Validate and activate the license key\n      const licenseResult = await licenseService.activateLicenseKey(licenseKey);\n\n      if (!licenseResult.success) {\n        authLogger.logLoginFailed(req, licenseResult.error || 'invalid_license_key', { licenseKey });\n        return res.status(401).json({\n          error: 'Invalid license key',\n          message: licenseResult.error || 'The license key is invalid or expired'\n        });\n      }\n\n      // Get user's tier and balance\n      const balance = await usageTracking.getBalance(licenseResult.customerId);\n\n      // Generate JWT tokens\n      const tokenResult = generateToken(licenseResult.customerId, {\n        tier: balance.tier,\n        email: licenseResult.email\n      });\n      const refreshResult = generateRefreshToken(licenseResult.customerId);\n\n      // Log successful login with structured logging\n      authLogger.logLoginSuccess(req, licenseResult.customerId, {\n        email: licenseResult.email,\n        tier: balance.tier\n      });\n\n      res.json({\n        success: true,\n        token: tokenResult.token,\n        tokenType: tokenResult.tokenType,\n        expiresIn: tokenResult.expiresIn,\n        refreshToken: refreshResult.refreshToken,\n        customerId: licenseResult.customerId,\n        tier: balance.tier,\n        hoursRemaining: balance.hoursRemaining\n      });\n    } catch (err) {\n      authLogger.logLoginFailed(req, `server_error: ${err.message}`, { licenseKey });\n      res.status(500).json({ error: 'Authentication failed. Please try again.' });\n    }\n  });\n\n  /**\n   * POST /refresh - Refresh an expired JWT token\n   *\n   * Uses a refresh token to get a new access token.\n   * CSRF protection applied to prevent token theft via cross-site requests.\n   */\n  router.post('/refresh', validateCsrfToken, async (req, res) => {\n    const { refreshToken } = req.body;\n\n    if (!refreshToken) {\n      authLogger.logTokenRefreshFailed(req, 'missing_refresh_token');\n      return res.status(400).json({\n        error: 'Refresh token required'\n      });\n    }\n\n    try {\n      const decoded = await verifyToken(refreshToken, { req });\n\n      if (!decoded || decoded.type !== 'refresh') {\n        authLogger.logTokenRefreshFailed(req, 'invalid_or_wrong_token_type');\n        return res.status(401).json({\n          error: 'Invalid refresh token',\n          message: 'Please log in again'\n        });\n      }\n\n      // Get current user info\n      const balance = await usageTracking.getBalance(decoded.sub);\n\n      // Generate new access token\n      const tokenResult = generateToken(decoded.sub, {\n        tier: balance.tier\n      });\n\n      // Log successful token refresh\n      authLogger.logTokenRefreshSuccess(req, decoded.sub);\n\n      res.json({\n        success: true,\n        token: tokenResult.token,\n        tokenType: tokenResult.tokenType,\n        expiresIn: tokenResult.expiresIn\n      });\n    } catch (err) {\n      authLogger.logTokenRefreshFailed(req, `server_error: ${err.message}`);\n      res.status(401).json({\n        error: 'Failed to refresh token',\n        message: 'Please log in again'\n      });\n    }\n  });\n\n  /**\n   * POST /logout - Invalidate tokens by adding to blacklist\n   *\n   * Adds the current token's jti to the blacklist so it cannot be reused.\n   * Also accepts an optional refreshToken to revoke both tokens at once.\n   * CSRF protection applied to prevent forced logout attacks.\n   */\n  router.post('/logout', validateCsrfToken, authenticateToken, async (req, res) => {\n    const { refreshToken } = req.body;\n    let refreshTokenRevoked = false;\n\n    // Blacklist the access token using the blacklistToken function from authHelpers\n    if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n      if (blacklistToken) {\n        await blacklistToken(req.tokenData.jti, req.tokenData.exp, {\n          userId: req.stripeCustomerId,\n          reason: 'logout'\n        });\n      } else {\n        console.warn('[Auth] Logout: blacklistToken function not available');\n      }\n    } else {\n      // Token doesn't have jti - log warning but continue\n      // This handles tokens generated before jti was added\n      console.warn('[Auth] Logout: token missing jti or exp, cannot blacklist access token');\n    }\n\n    // Optionally blacklist the refresh token too\n    if (refreshToken && blacklistToken) {\n      // Use checkBlacklist: false to allow decoding already-blacklisted refresh tokens\n      const decoded = await verifyToken(refreshToken, { checkBlacklist: false });\n      if (decoded && decoded.jti && decoded.exp) {\n        await blacklistToken(decoded.jti, decoded.exp, {\n          userId: req.stripeCustomerId,\n          reason: 'logout_refresh'\n        });\n        refreshTokenRevoked = true;\n      }\n    }\n\n    // Log successful logout with structured logging\n    authLogger.logLogoutSuccess(req, req.stripeCustomerId, {\n      jti: req.tokenData?.jti,\n      refreshTokenRevoked\n    });\n\n    res.json({\n      success: true,\n      message: 'Logged out successfully'\n    });\n  });\n\n  // ==========================================================================\n  // Email Verification Endpoints\n  // ==========================================================================\n\n  /**\n   * POST /send-verification - Send a verification code to an email address\n   *\n   * Request body: { email: string }\n   * Response: { success: boolean, message: string, expiresInMinutes?: number }\n   *\n   * SECURITY: Rate limited to prevent abuse. CSRF protection applied.\n   */\n  router.post('/send-verification', validateCsrfToken, async (req, res) => {\n    const { email } = req.body;\n\n    // Validate email\n    if (!email) {\n      return res.status(400).json({\n        error: 'Email required',\n        message: 'Please provide an email address'\n      });\n    }\n\n    if (!isValidEmail(email)) {\n      return res.status(400).json({\n        error: 'Invalid email',\n        message: 'Please provide a valid email address'\n      });\n    }\n\n    // Check rate limiting\n    const rateCheck = canSendCode(email);\n    if (!rateCheck.allowed) {\n      return res.status(429).json({\n        error: 'Too many requests',\n        message: `Please wait ${rateCheck.waitSeconds} seconds before requesting a new code`,\n        waitSeconds: rateCheck.waitSeconds\n      });\n    }\n\n    try {\n      // Generate and store verification code\n      const code = generateVerificationCode();\n      storeVerificationCode(email, code);\n\n      // Send verification email\n      if (emailService && emailService.sendEmailVerificationCode) {\n        await emailService.sendEmailVerificationCode(email, code, 10);\n        console.log(`[Auth] Verification code sent to ${maskSensitiveData(email)}`);\n      } else {\n        // Fallback for development - log to console\n        console.log(`[Auth] Verification code for ${email}: ${code} (emailService not configured)`);\n      }\n\n      res.json({\n        success: true,\n        message: 'Verification code sent. Please check your email.',\n        expiresInMinutes: 10\n      });\n    } catch (err) {\n      console.error('[Auth] Send verification error:', err.message);\n      res.status(500).json({\n        error: 'Failed to send verification code',\n        message: 'Please try again later'\n      });\n    }\n  });\n\n  /**\n   * POST /verify-email - Verify an email address with a code\n   *\n   * Request body: { email: string, code: string }\n   * Response: { success: boolean, verified: boolean, message?: string, error?: string }\n   *\n   * SECURITY: Limited attempts per code. CSRF protection applied.\n   */\n  router.post('/verify-email', validateCsrfToken, async (req, res) => {\n    const { email, code } = req.body;\n\n    // Validate inputs\n    if (!email) {\n      return res.status(400).json({\n        error: 'Email required',\n        message: 'Please provide an email address'\n      });\n    }\n\n    if (!code) {\n      return res.status(400).json({\n        error: 'Code required',\n        message: 'Please provide the verification code'\n      });\n    }\n\n    if (!isValidEmail(email)) {\n      return res.status(400).json({\n        error: 'Invalid email',\n        message: 'Please provide a valid email address'\n      });\n    }\n\n    // Validate code format (6 digits)\n    const codeStr = String(code).trim();\n    if (!/^\\d{6}$/.test(codeStr)) {\n      return res.status(400).json({\n        error: 'Invalid code format',\n        message: 'Verification code must be 6 digits'\n      });\n    }\n\n    try {\n      // Verify the code\n      const result = verifyCode(email, codeStr);\n\n      if (!result.valid) {\n        return res.status(400).json({\n          success: false,\n          verified: false,\n          error: 'Verification failed',\n          message: result.error\n        });\n      }\n\n      // Mark email as verified in the database\n      if (usageTracking && usageTracking.markEmailVerified) {\n        const dbResult = await usageTracking.markEmailVerified(email);\n        if (!dbResult.success) {\n          console.warn(`[Auth] Failed to persist email verification: ${dbResult.error}`);\n        }\n      }\n\n      console.log(`[Auth] Email verified: ${maskSensitiveData(email)}`);\n\n      // Email verified successfully\n      res.json({\n        success: true,\n        verified: true,\n        message: 'Email verified successfully'\n      });\n    } catch (err) {\n      console.error('[Auth] Verify email error:', err.message);\n      res.status(500).json({\n        error: 'Verification failed',\n        message: 'Please try again later'\n      });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createAuthRoutes;\n","numLines":510,"startLine":1,"totalLines":510}}}
{"parentUuid":"52c9a74f-f9ec-4049-8e90-2068244358a3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KM1nsF1gnDYE7HEGQZbQGa","type":"tool_result","content":"     1→/**\n     2→ * Shared Redis Client Service\n     3→ * Uses Upstash Redis for distributed caching and storage\n     4→ * Provides both REST-based (@upstash/redis) and ioredis connections\n     5→ */\n     6→\n     7→const { Redis } = require('@upstash/redis');\n     8→\n     9→// Singleton instances\n    10→let restClient = null;\n    11→let isConnected = false;\n    12→let connectionError = null;\n    13→\n    14→/**\n    15→ * Get the Upstash REST Redis client (recommended for most operations)\n    16→ * This client works well in serverless environments\n    17→ * @returns {Redis|null} Redis client or null if not configured\n    18→ */\n    19→function getRedisClient() {\n    20→  if (restClient) {\n    21→    return restClient;\n    22→  }\n    23→\n    24→  const url = process.env.UPSTASH_REDIS_REST_URL;\n    25→  const token = process.env.UPSTASH_REDIS_REST_TOKEN;\n    26→\n    27→  if (!url || !token) {\n    28→    console.warn('[Redis] Missing UPSTASH_REDIS_REST_URL or UPSTASH_REDIS_REST_TOKEN - Redis features disabled');\n    29→    connectionError = new Error('Redis not configured');\n    30→    return null;\n    31→  }\n    32→\n    33→  try {\n    34→    restClient = new Redis({\n    35→      url,\n    36→      token,\n    37→      automaticDeserialization: true,\n    38→    });\n    39→    isConnected = true;\n    40→    console.log('[Redis] Upstash REST client initialized');\n    41→    return restClient;\n    42→  } catch (err) {\n    43→    console.error('[Redis] Failed to initialize Upstash REST client:', err.message);\n    44→    connectionError = err;\n    45→    return null;\n    46→  }\n    47→}\n    48→\n    49→/**\n    50→ * Check if Redis is available and connected\n    51→ * @returns {boolean} True if Redis is available\n    52→ */\n    53→function isRedisAvailable() {\n    54→  if (restClient && isConnected) {\n    55→    return true;\n    56→  }\n    57→  // Try to initialize if not yet attempted\n    58→  const client = getRedisClient();\n    59→  return client !== null;\n    60→}\n    61→\n    62→/**\n    63→ * Get Redis connection status\n    64→ * @returns {Object} { connected, error }\n    65→ */\n    66→function getRedisStatus() {\n    67→  return {\n    68→    connected: isConnected && restClient !== null,\n    69→    error: connectionError ? connectionError.message : null,\n    70→    type: restClient ? 'upstash-rest' : 'none'\n    71→  };\n    72→}\n    73→\n    74→/**\n    75→ * Ping Redis to check connectivity\n    76→ * @returns {Promise<boolean>} True if ping successful\n    77→ */\n    78→async function pingRedis() {\n    79→  const client = getRedisClient();\n    80→  if (!client) {\n    81→    return false;\n    82→  }\n    83→\n    84→  try {\n    85→    const result = await client.ping();\n    86→    return result === 'PONG';\n    87→  } catch (err) {\n    88→    console.error('[Redis] Ping failed:', err.message);\n    89→    isConnected = false;\n    90→    connectionError = err;\n    91→    return false;\n    92→  }\n    93→}\n    94→\n    95→/**\n    96→ * Set a value with optional TTL\n    97→ * @param {string} key - Redis key\n    98→ * @param {any} value - Value to store (will be JSON serialized)\n    99→ * @param {number} ttlSeconds - Optional TTL in seconds\n   100→ * @returns {Promise<boolean>} True if successful\n   101→ */\n   102→async function set(key, value, ttlSeconds = null) {\n   103→  const client = getRedisClient();\n   104→  if (!client) {\n   105→    return false;\n   106→  }\n   107→\n   108→  try {\n   109→    if (ttlSeconds) {\n   110→      await client.set(key, value, { ex: ttlSeconds });\n   111→    } else {\n   112→      await client.set(key, value);\n   113→    }\n   114→    return true;\n   115→  } catch (err) {\n   116→    console.error('[Redis] SET failed:', err.message);\n   117→    return false;\n   118→  }\n   119→}\n   120→\n   121→/**\n   122→ * Get a value\n   123→ * @param {string} key - Redis key\n   124→ * @returns {Promise<any|null>} Value or null if not found\n   125→ */\n   126→async function get(key) {\n   127→  const client = getRedisClient();\n   128→  if (!client) {\n   129→    return null;\n   130→  }\n   131→\n   132→  try {\n   133→    return await client.get(key);\n   134→  } catch (err) {\n   135→    console.error('[Redis] GET failed:', err.message);\n   136→    return null;\n   137→  }\n   138→}\n   139→\n   140→/**\n   141→ * Check if a key exists\n   142→ * @param {string} key - Redis key\n   143→ * @returns {Promise<boolean>} True if key exists\n   144→ */\n   145→async function exists(key) {\n   146→  const client = getRedisClient();\n   147→  if (!client) {\n   148→    return false;\n   149→  }\n   150→\n   151→  try {\n   152→    const result = await client.exists(key);\n   153→    return result === 1;\n   154→  } catch (err) {\n   155→    console.error('[Redis] EXISTS failed:', err.message);\n   156→    return false;\n   157→  }\n   158→}\n   159→\n   160→/**\n   161→ * Delete a key\n   162→ * @param {string} key - Redis key\n   163→ * @returns {Promise<boolean>} True if deleted\n   164→ */\n   165→async function del(key) {\n   166→  const client = getRedisClient();\n   167→  if (!client) {\n   168→    return false;\n   169→  }\n   170→\n   171→  try {\n   172→    await client.del(key);\n   173→    return true;\n   174→  } catch (err) {\n   175→    console.error('[Redis] DEL failed:', err.message);\n   176→    return false;\n   177→  }\n   178→}\n   179→\n   180→/**\n   181→ * Set a value only if it doesn't exist (SETNX)\n   182→ * @param {string} key - Redis key\n   183→ * @param {any} value - Value to store\n   184→ * @param {number} ttlSeconds - Optional TTL in seconds\n   185→ * @returns {Promise<boolean>} True if set (key didn't exist)\n   186→ */\n   187→async function setNX(key, value, ttlSeconds = null) {\n   188→  const client = getRedisClient();\n   189→  if (!client) {\n   190→    return false;\n   191→  }\n   192→\n   193→  try {\n   194→    const options = { nx: true };\n   195→    if (ttlSeconds) {\n   196→      options.ex = ttlSeconds;\n   197→    }\n   198→    const result = await client.set(key, value, options);\n   199→    return result === 'OK';\n   200→  } catch (err) {\n   201→    console.error('[Redis] SETNX failed:', err.message);\n   202→    return false;\n   203→  }\n   204→}\n   205→\n   206→/**\n   207→ * Get TTL of a key\n   208→ * @param {string} key - Redis key\n   209→ * @returns {Promise<number>} TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n   210→ */\n   211→async function ttl(key) {\n   212→  const client = getRedisClient();\n   213→  if (!client) {\n   214→    return -2;\n   215→  }\n   216→\n   217→  try {\n   218→    return await client.ttl(key);\n   219→  } catch (err) {\n   220→    console.error('[Redis] TTL failed:', err.message);\n   221→    return -2;\n   222→  }\n   223→}\n   224→\n   225→module.exports = {\n   226→  getRedisClient,\n   227→  isRedisAvailable,\n   228→  getRedisStatus,\n   229→  pingRedis,\n   230→  // Convenience methods\n   231→  set,\n   232→  get,\n   233→  exists,\n   234→  del,\n   235→  setNX,\n   236→  ttl\n   237→};\n   238→\n\n</system-reminder>\n"}]},"uuid":"7a738513-58e2-4ee7-b3e2-dd527664695d","timestamp":"2025-12-30T01:03:58.370Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/redisClient.js","content":"/**\n * Shared Redis Client Service\n * Uses Upstash Redis for distributed caching and storage\n * Provides both REST-based (@upstash/redis) and ioredis connections\n */\n\nconst { Redis } = require('@upstash/redis');\n\n// Singleton instances\nlet restClient = null;\nlet isConnected = false;\nlet connectionError = null;\n\n/**\n * Get the Upstash REST Redis client (recommended for most operations)\n * This client works well in serverless environments\n * @returns {Redis|null} Redis client or null if not configured\n */\nfunction getRedisClient() {\n  if (restClient) {\n    return restClient;\n  }\n\n  const url = process.env.UPSTASH_REDIS_REST_URL;\n  const token = process.env.UPSTASH_REDIS_REST_TOKEN;\n\n  if (!url || !token) {\n    console.warn('[Redis] Missing UPSTASH_REDIS_REST_URL or UPSTASH_REDIS_REST_TOKEN - Redis features disabled');\n    connectionError = new Error('Redis not configured');\n    return null;\n  }\n\n  try {\n    restClient = new Redis({\n      url,\n      token,\n      automaticDeserialization: true,\n    });\n    isConnected = true;\n    console.log('[Redis] Upstash REST client initialized');\n    return restClient;\n  } catch (err) {\n    console.error('[Redis] Failed to initialize Upstash REST client:', err.message);\n    connectionError = err;\n    return null;\n  }\n}\n\n/**\n * Check if Redis is available and connected\n * @returns {boolean} True if Redis is available\n */\nfunction isRedisAvailable() {\n  if (restClient && isConnected) {\n    return true;\n  }\n  // Try to initialize if not yet attempted\n  const client = getRedisClient();\n  return client !== null;\n}\n\n/**\n * Get Redis connection status\n * @returns {Object} { connected, error }\n */\nfunction getRedisStatus() {\n  return {\n    connected: isConnected && restClient !== null,\n    error: connectionError ? connectionError.message : null,\n    type: restClient ? 'upstash-rest' : 'none'\n  };\n}\n\n/**\n * Ping Redis to check connectivity\n * @returns {Promise<boolean>} True if ping successful\n */\nasync function pingRedis() {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    const result = await client.ping();\n    return result === 'PONG';\n  } catch (err) {\n    console.error('[Redis] Ping failed:', err.message);\n    isConnected = false;\n    connectionError = err;\n    return false;\n  }\n}\n\n/**\n * Set a value with optional TTL\n * @param {string} key - Redis key\n * @param {any} value - Value to store (will be JSON serialized)\n * @param {number} ttlSeconds - Optional TTL in seconds\n * @returns {Promise<boolean>} True if successful\n */\nasync function set(key, value, ttlSeconds = null) {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    if (ttlSeconds) {\n      await client.set(key, value, { ex: ttlSeconds });\n    } else {\n      await client.set(key, value);\n    }\n    return true;\n  } catch (err) {\n    console.error('[Redis] SET failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get a value\n * @param {string} key - Redis key\n * @returns {Promise<any|null>} Value or null if not found\n */\nasync function get(key) {\n  const client = getRedisClient();\n  if (!client) {\n    return null;\n  }\n\n  try {\n    return await client.get(key);\n  } catch (err) {\n    console.error('[Redis] GET failed:', err.message);\n    return null;\n  }\n}\n\n/**\n * Check if a key exists\n * @param {string} key - Redis key\n * @returns {Promise<boolean>} True if key exists\n */\nasync function exists(key) {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    const result = await client.exists(key);\n    return result === 1;\n  } catch (err) {\n    console.error('[Redis] EXISTS failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Delete a key\n * @param {string} key - Redis key\n * @returns {Promise<boolean>} True if deleted\n */\nasync function del(key) {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    await client.del(key);\n    return true;\n  } catch (err) {\n    console.error('[Redis] DEL failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Set a value only if it doesn't exist (SETNX)\n * @param {string} key - Redis key\n * @param {any} value - Value to store\n * @param {number} ttlSeconds - Optional TTL in seconds\n * @returns {Promise<boolean>} True if set (key didn't exist)\n */\nasync function setNX(key, value, ttlSeconds = null) {\n  const client = getRedisClient();\n  if (!client) {\n    return false;\n  }\n\n  try {\n    const options = { nx: true };\n    if (ttlSeconds) {\n      options.ex = ttlSeconds;\n    }\n    const result = await client.set(key, value, options);\n    return result === 'OK';\n  } catch (err) {\n    console.error('[Redis] SETNX failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get TTL of a key\n * @param {string} key - Redis key\n * @returns {Promise<number>} TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n */\nasync function ttl(key) {\n  const client = getRedisClient();\n  if (!client) {\n    return -2;\n  }\n\n  try {\n    return await client.ttl(key);\n  } catch (err) {\n    console.error('[Redis] TTL failed:', err.message);\n    return -2;\n  }\n}\n\nmodule.exports = {\n  getRedisClient,\n  isRedisAvailable,\n  getRedisStatus,\n  pingRedis,\n  // Convenience methods\n  set,\n  get,\n  exists,\n  del,\n  setNX,\n  ttl\n};\n","numLines":238,"startLine":1,"totalLines":238}}}
{"parentUuid":"7a738513-58e2-4ee7-b3e2-dd527664695d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BNaSQFmkYTkD5m5xW4EcUX","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me search for any files that import from these modules to check for unhandled promise issues:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15260,"cache_read_input_tokens":20585,"cache_creation":{"ephemeral_5m_input_tokens":15260,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWbyKGJJ7srFwhMc67PST","type":"assistant","uuid":"2916b3d2-dc17-416a-9f9e-688babcb3424","timestamp":"2025-12-30T01:04:04.996Z"}
{"parentUuid":"2916b3d2-dc17-416a-9f9e-688babcb3424","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BNaSQFmkYTkD5m5xW4EcUX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RUeJs3isBqfvwmUEhZBVRZ","name":"Grep","input":{"pattern":"require.*auth\\.js|from.*auth\\.js|require.*redisClient|from.*redisClient|blacklistToken|isTokenBlacklisted|verifyToken","path":"/Users/imorgado/SPLICE/splice-backend","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15260,"cache_read_input_tokens":20585,"cache_creation":{"ephemeral_5m_input_tokens":15260,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWbyKGJJ7srFwhMc67PST","type":"assistant","uuid":"cfeda866-241d-4343-8ec6-2f6715202fb4","timestamp":"2025-12-30T01:04:07.034Z"}
{"parentUuid":"cfeda866-241d-4343-8ec6-2f6715202fb4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BNaSQFmkYTkD5m5xW4EcUX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XfXFEu7g27Veuf5JFhXAnn","name":"Grep","input":{"pattern":"\\.then\\s*\\([^)]*\\)(?!\\s*\\.catch)","path":"/Users/imorgado/SPLICE/splice-backend","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":15260,"cache_read_input_tokens":20585,"cache_creation":{"ephemeral_5m_input_tokens":15260,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWbyKGJJ7srFwhMc67PST","type":"assistant","uuid":"4e5cb732-70ec-46cc-b981-1b60e73e8c5d","timestamp":"2025-12-30T01:04:08.381Z"}
{"parentUuid":"4e5cb732-70ec-46cc-b981-1b60e73e8c5d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XfXFEu7g27Veuf5JFhXAnn","type":"tool_result","content":"No matches found"}]},"uuid":"f7a17b52-d3a8-450f-923f-df1181316380","timestamp":"2025-12-30T01:04:08.511Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"f7a17b52-d3a8-450f-923f-df1181316380","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RUeJs3isBqfvwmUEhZBVRZ","type":"tool_result","content":"Found 7 files\nsplice-backend/routes/auth.js\nsplice-backend/middleware/auth.js\nsplice-backend/server.js\nsplice-backend/tests/auth.test.js\nsplice-backend/middleware/rateLimiter.js\nsplice-backend/tests/security.test.js\nsplice-backend/routes/billing.js"}]},"uuid":"820d991d-8f3a-407c-9875-5842a39fd04d","timestamp":"2025-12-30T01:04:08.516Z","toolUseResult":{"mode":"files_with_matches","filenames":["splice-backend/routes/auth.js","splice-backend/middleware/auth.js","splice-backend/server.js","splice-backend/tests/auth.test.js","splice-backend/middleware/rateLimiter.js","splice-backend/tests/security.test.js","splice-backend/routes/billing.js"],"numFiles":7}}
{"parentUuid":"820d991d-8f3a-407c-9875-5842a39fd04d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HwneCd4JRnTwx4m9H6BpMQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019vPupHbe9YhWUGzp2RBxTx","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":33,"cache_creation_input_tokens":392,"cache_read_input_tokens":35845,"cache_creation":{"ephemeral_5m_input_tokens":392,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CWbyL1gzTLXwC4LquNdDA","type":"assistant","uuid":"2e3ad44e-db61-4ccd-b6c5-e8079ce2349c","timestamp":"2025-12-30T01:04:14.406Z"}
{"parentUuid":"2e3ad44e-db61-4ccd-b6c5-e8079ce2349c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HwneCd4JRnTwx4m9H6BpMQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016Qo6aeG9rkpL4XQb5R1YzV","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":33,"cache_creation_input_tokens":392,"cache_read_input_tokens":35845,"cache_creation":{"ephemeral_5m_input_tokens":392,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CWbyL1gzTLXwC4LquNdDA","type":"assistant","uuid":"ddf68f09-829c-48b7-80c0-37d92324b97f","timestamp":"2025-12-30T01:04:14.768Z"}
{"parentUuid":"ddf68f09-829c-48b7-80c0-37d92324b97f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HwneCd4JRnTwx4m9H6BpMQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01N7CWv17gr4WLrGg46m1X7q","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/billing.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":33,"cache_creation_input_tokens":392,"cache_read_input_tokens":35845,"cache_creation":{"ephemeral_5m_input_tokens":392,"ephemeral_1h_input_tokens":0},"output_tokens":180,"service_tier":"standard"}},"requestId":"req_011CWbyL1gzTLXwC4LquNdDA","type":"assistant","uuid":"f83b30a5-84a8-448b-9c7d-1a2db9c261f1","timestamp":"2025-12-30T01:04:15.109Z"}
{"parentUuid":"f83b30a5-84a8-448b-9c7d-1a2db9c261f1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016Qo6aeG9rkpL4XQb5R1YzV","type":"tool_result","content":"     1→/**\n     2→ * Rate Limiter Middleware\n     3→ *\n     4→ * Checks if user has sufficient credits before processing.\n     5→ * Uses atomic credit reservation to prevent race conditions.\n     6→ * Returns 402 Payment Required if insufficient credits.\n     7→ *\n     8→ * SECURITY: Uses JWT authentication via authenticateToken middleware.\n     9→ * Legacy x-stripe-customer-id header is DISABLED in production for security.\n    10→ */\n    11→\n    12→const {\n    13→  deductUsage,\n    14→  getBalance,\n    15→  reserveCredits,\n    16→  confirmReservation,\n    17→  releaseReservation,\n    18→  customerExists,\n    19→  hasFeatureAccess\n    20→} = require('../services/usageTracking');\n    21→const { verifyToken, extractBearerToken } = require('./auth');\n    22→\n    23→// SECURITY: Disable legacy auth in production unless explicitly enabled\n    24→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    25→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n    26→\n    27→// =============================================================================\n    28→// IP-based Rate Limiting\n    29→// =============================================================================\n    30→\n    31→// General rate limiting per IP\n    32→const ipRequestCounts = new Map(); // IP -> { count, windowStart }\n    33→const IP_RATE_LIMIT_WINDOW_MS = 60000; // 1 minute window\n    34→const IP_RATE_LIMIT_MAX_REQUESTS = 100; // 100 requests per minute per IP\n    35→\n    36→// Cleanup old entries every 5 minutes to prevent memory leaks\n    37→setInterval(() => {\n    38→  const now = Date.now();\n    39→  for (const [ip, data] of ipRequestCounts.entries()) {\n    40→    if (now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS * 2) {\n    41→      ipRequestCounts.delete(ip);\n    42→    }\n    43→  }\n    44→}, 300000);\n    45→\n    46→/**\n    47→ * Check if IP is rate limited\n    48→ * @param {string} ip - Client IP address\n    49→ * @returns {boolean} True if rate limited\n    50→ */\n    51→function isIpRateLimited(ip) {\n    52→  const now = Date.now();\n    53→  const data = ipRequestCounts.get(ip);\n    54→\n    55→  if (!data || now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS) {\n    56→    // Start new window\n    57→    ipRequestCounts.set(ip, { count: 1, windowStart: now });\n    58→    return false;\n    59→  }\n    60→\n    61→  data.count++;\n    62→  if (data.count > IP_RATE_LIMIT_MAX_REQUESTS) {\n    63→    return true;\n    64→  }\n    65→\n    66→  return false;\n    67→}\n    68→\n    69→/**\n    70→ * IP-based rate limiting middleware\n    71→ * Limits requests per IP to prevent abuse\n    72→ */\n    73→function ipRateLimit(req, res, next) {\n    74→  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n    75→\n    76→  if (isIpRateLimited(clientIp)) {\n    77→    console.warn(`[SECURITY] IP rate limit exceeded for: ${clientIp}`);\n    78→    return res.status(429).json({\n    79→      error: 'Too many requests',\n    80→      message: 'Please slow down and try again later',\n    81→      retryAfter: 60\n    82→    });\n    83→  }\n    84→\n    85→  next();\n    86→}\n    87→\n    88→// Rate limiting for legacy auth attempts (prevent brute force)\n    89→const legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\n    90→const LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\n    91→const LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n    92→\n    93→/**\n    94→ * Check if IP is rate limited for legacy auth\n    95→ */\n    96→function isLegacyAuthRateLimited(ip) {\n    97→  const now = Date.now();\n    98→  const attempt = legacyAuthAttempts.get(ip);\n    99→\n   100→  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n   101→    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n   102→    return false;\n   103→  }\n   104→\n   105→  attempt.count++;\n   106→  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n   107→    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n   108→    return true;\n   109→  }\n   110→\n   111→  return false;\n   112→}\n   113→\n   114→// Default estimated duration for reservation (1 minute = 60 seconds)\n   115→const DEFAULT_RESERVATION_SECONDS = 60;\n   116→\n   117→/**\n   118→ * Middleware to check and atomically reserve credits before processing\n   119→ *\n   120→ * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n   121→ * Falls back to legacy x-stripe-customer-id header (deprecated)\n   122→ *\n   123→ * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n   124→ *\n   125→ * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n   126→ * where multiple concurrent requests could all pass credit check.\n   127→ */\n   128→function requireCredits(options = {}) {\n   129→  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n   130→\n   131→  return async (req, res, next) => {\n   132→    // SECURITY: Primary auth via JWT token\n   133→    const authHeader = req.headers['authorization'];\n   134→    const token = extractBearerToken(authHeader);\n   135→\n   136→    let stripeCustomerId = null;\n   137→\n   138→    if (token) {\n   139→      const decoded = verifyToken(token);\n   140→      if (decoded && decoded.sub) {\n   141→        stripeCustomerId = decoded.sub;\n   142→        req.tokenData = decoded;\n   143→      } else {\n   144→        // Token present but invalid\n   145→        return res.status(401).json({\n   146→          error: 'Invalid or expired token',\n   147→          message: 'Please log in again to continue'\n   148→        });\n   149→      }\n   150→    } else {\n   151→      // DEPRECATED: Fallback to legacy header\n   152→      const legacyId = req.headers['x-stripe-customer-id'];\n   153→      if (legacyId) {\n   154→        // SECURITY: Block legacy auth in production unless explicitly enabled\n   155→        if (isProduction && !ALLOW_LEGACY_AUTH) {\n   156→          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n   157→          return res.status(401).json({\n   158→            error: 'Authentication method not supported',\n   159→            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n   160→          });\n   161→        }\n   162→\n   163→        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n   164→        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n   165→        if (isLegacyAuthRateLimited(clientIp)) {\n   166→          return res.status(429).json({\n   167→            error: 'Too many authentication attempts',\n   168→            message: 'Please wait before trying again'\n   169→          });\n   170→        }\n   171→\n   172→        // Validate format to prevent injection\n   173→        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n   174→          return res.status(401).json({\n   175→            error: 'Invalid customer ID format',\n   176→            message: 'Customer ID must be a valid Stripe customer ID'\n   177→          });\n   178→        }\n   179→\n   180→        // SECURITY: Verify customer exists in database before accepting\n   181→        const exists = await customerExists(legacyId);\n   182→        if (!exists) {\n   183→          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n   184→          return res.status(401).json({\n   185→            error: 'Invalid customer ID',\n   186→            message: 'Customer not found'\n   187→          });\n   188→        }\n   189→\n   190→        stripeCustomerId = legacyId;\n   191→        req.isLegacyAuth = true;\n   192→        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n   193→      }\n   194→    }\n   195→\n   196→    if (!stripeCustomerId) {\n   197→      return res.status(401).json({\n   198→        error: 'Authentication required',\n   199→        message: 'Missing Stripe customer ID'\n   200→      });\n   201→    }\n   202→\n   203→    // Store for later use\n   204→    req.stripeCustomerId = stripeCustomerId;\n   205→\n   206→    // Determine estimated duration - use request value, option value, or default\n   207→    const estSeconds = req.estimatedDuration || estimatedSeconds;\n   208→\n   209→    try {\n   210→      // Atomically reserve credits using SELECT...FOR UPDATE\n   211→      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n   212→\n   213→      if (!reservation.success) {\n   214→        // Reservation failed - not enough credits\n   215→        const balance = await getBalance(stripeCustomerId);\n   216→        return res.status(402).json({\n   217→          error: 'Insufficient credits',\n   218→          message: 'Please upgrade your plan or wait for your next billing cycle',\n   219→          balance: {\n   220→            hoursRemaining: balance.hoursRemaining,\n   221→            tier: balance.tier\n   222→          }\n   223→        });\n   224→      }\n   225→\n   226→      // Store reservation info for confirmation/release\n   227→      req.reservation = {\n   228→        id: reservation.reservationId,\n   229→        seconds: estSeconds,\n   230→        hoursReserved: reservation.hoursReserved\n   231→      };\n   232→\n   233→      // Attach helper function to confirm usage with actual duration\n   234→      // This adjusts the reservation if actual duration differs\n   235→      req.deductUsage = async (actualDurationSeconds) => {\n   236→        return await confirmReservation(\n   237→          stripeCustomerId,\n   238→          actualDurationSeconds,\n   239→          estSeconds,\n   240→          endpoint\n   241→        );\n   242→      };\n   243→\n   244→      // Attach helper function to release reservation on failure\n   245→      req.releaseReservation = async (reason = 'processing_failed') => {\n   246→        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n   247→      };\n   248→\n   249→      // Hook into response to auto-release on error responses\n   250→      const originalSend = res.send.bind(res);\n   251→      res.send = function(body) {\n   252→        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n   253→        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n   254→          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n   255→            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n   256→        }\n   257→        return originalSend(body);\n   258→      };\n   259→\n   260→      next();\n   261→    } catch (err) {\n   262→      console.error('[RateLimiter] Error reserving credits:', err);\n   263→      return res.status(500).json({\n   264→        error: 'Credit check failed',\n   265→        message: err.message\n   266→      });\n   267→    }\n   268→  };\n   269→}\n   270→\n   271→/**\n   272→ * Middleware to enforce tier-based feature access\n   273→ *\n   274→ * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n   275→ * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n   276→ *\n   277→ * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n   278→ */\n   279→function requireFeature(featureName) {\n   280→  return async (req, res, next) => {\n   281→    // Must have stripeCustomerId from requireCredits middleware\n   282→    if (!req.stripeCustomerId) {\n   283→      return res.status(401).json({\n   284→        error: 'Authentication required',\n   285→        message: 'Please log in to access this feature'\n   286→      });\n   287→    }\n   288→\n   289→    try {\n   290→      // Get user's current balance (includes tier info)\n   291→      const balance = await getBalance(req.stripeCustomerId);\n   292→\n   293→      // Check if user's tier has access to this feature\n   294→      if (!hasFeatureAccess(balance.tier, featureName)) {\n   295→        // Release any reserved credits since we're blocking the request\n   296→        if (req.releaseReservation) {\n   297→          await req.releaseReservation('feature_not_available');\n   298→        }\n   299→\n   300→        // Determine required tier for helpful error message\n   301→        const requiredTier = getRequiredTierForFeature(featureName);\n   302→\n   303→        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n   304→\n   305→        return res.status(403).json({\n   306→          error: 'Feature not available',\n   307→          message: `This feature requires a ${requiredTier} plan or higher`,\n   308→          requiredFeature: featureName,\n   309→          requiredTier: requiredTier,\n   310→          currentTier: balance.tier\n   311→        });\n   312→      }\n   313→\n   314→      // Feature access granted\n   315→      next();\n   316→    } catch (err) {\n   317→      console.error('[requireFeature] Error checking feature access:', err);\n   318→      return res.status(500).json({\n   319→        error: 'Feature access check failed',\n   320→        message: err.message\n   321→      });\n   322→    }\n   323→  };\n   324→}\n   325→\n   326→/**\n   327→ * Helper to determine required tier for a feature\n   328→ * Used for helpful error messages\n   329→ */\n   330→function getRequiredTierForFeature(featureName) {\n   331→  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n   332→  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n   333→\n   334→  if (teamOnlyFeatures.includes(featureName)) {\n   335→    return 'Team';\n   336→  } else if (proFeatures.includes(featureName)) {\n   337→    return 'Pro';\n   338→  }\n   339→  return 'Starter';\n   340→}\n   341→\n   342→/**\n   343→ * Middleware to track usage after successful response\n   344→ *\n   345→ * Call this after processing to deduct actual usage\n   346→ */\n   347→function trackUsage(endpoint = 'unknown') {\n   348→  return async (req, res, next) => {\n   349→    // Store original json method\n   350→    const originalJson = res.json.bind(res);\n   351→\n   352→    // Override json to track usage on success\n   353→    res.json = async (data) => {\n   354→      // Only deduct on successful responses\n   355→      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n   356→        try {\n   357→          const balance = await deductUsage(\n   358→            req.stripeCustomerId,\n   359→            req.audioDuration,\n   360→            endpoint\n   361→          );\n   362→          // Attach updated balance to response\n   363→          data.balance = balance;\n   364→        } catch (err) {\n   365→          console.error('[RateLimiter] Error deducting usage:', err);\n   366→        }\n   367→      }\n   368→      return originalJson(data);\n   369→    };\n   370→\n   371→    next();\n   372→  };\n   373→}\n   374→\n   375→module.exports = {\n   376→  requireCredits,\n   377→  requireFeature,\n   378→  trackUsage,\n   379→  ipRateLimit\n   380→};\n   381→\n\n</system-reminder>\n"}]},"uuid":"e9f68343-8d70-44ca-8add-37a8b6cd3b71","timestamp":"2025-12-30T01:04:15.139Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js","content":"/**\n * Rate Limiter Middleware\n *\n * Checks if user has sufficient credits before processing.\n * Uses atomic credit reservation to prevent race conditions.\n * Returns 402 Payment Required if insufficient credits.\n *\n * SECURITY: Uses JWT authentication via authenticateToken middleware.\n * Legacy x-stripe-customer-id header is DISABLED in production for security.\n */\n\nconst {\n  deductUsage,\n  getBalance,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  customerExists,\n  hasFeatureAccess\n} = require('../services/usageTracking');\nconst { verifyToken, extractBearerToken } = require('./auth');\n\n// SECURITY: Disable legacy auth in production unless explicitly enabled\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n\n// =============================================================================\n// IP-based Rate Limiting\n// =============================================================================\n\n// General rate limiting per IP\nconst ipRequestCounts = new Map(); // IP -> { count, windowStart }\nconst IP_RATE_LIMIT_WINDOW_MS = 60000; // 1 minute window\nconst IP_RATE_LIMIT_MAX_REQUESTS = 100; // 100 requests per minute per IP\n\n// Cleanup old entries every 5 minutes to prevent memory leaks\nsetInterval(() => {\n  const now = Date.now();\n  for (const [ip, data] of ipRequestCounts.entries()) {\n    if (now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS * 2) {\n      ipRequestCounts.delete(ip);\n    }\n  }\n}, 300000);\n\n/**\n * Check if IP is rate limited\n * @param {string} ip - Client IP address\n * @returns {boolean} True if rate limited\n */\nfunction isIpRateLimited(ip) {\n  const now = Date.now();\n  const data = ipRequestCounts.get(ip);\n\n  if (!data || now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS) {\n    // Start new window\n    ipRequestCounts.set(ip, { count: 1, windowStart: now });\n    return false;\n  }\n\n  data.count++;\n  if (data.count > IP_RATE_LIMIT_MAX_REQUESTS) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * IP-based rate limiting middleware\n * Limits requests per IP to prevent abuse\n */\nfunction ipRateLimit(req, res, next) {\n  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n\n  if (isIpRateLimited(clientIp)) {\n    console.warn(`[SECURITY] IP rate limit exceeded for: ${clientIp}`);\n    return res.status(429).json({\n      error: 'Too many requests',\n      message: 'Please slow down and try again later',\n      retryAfter: 60\n    });\n  }\n\n  next();\n}\n\n// Rate limiting for legacy auth attempts (prevent brute force)\nconst legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\nconst LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\nconst LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n\n/**\n * Check if IP is rate limited for legacy auth\n */\nfunction isLegacyAuthRateLimited(ip) {\n  const now = Date.now();\n  const attempt = legacyAuthAttempts.get(ip);\n\n  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n    return false;\n  }\n\n  attempt.count++;\n  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n    return true;\n  }\n\n  return false;\n}\n\n// Default estimated duration for reservation (1 minute = 60 seconds)\nconst DEFAULT_RESERVATION_SECONDS = 60;\n\n/**\n * Middleware to check and atomically reserve credits before processing\n *\n * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n * Falls back to legacy x-stripe-customer-id header (deprecated)\n *\n * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n *\n * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n * where multiple concurrent requests could all pass credit check.\n */\nfunction requireCredits(options = {}) {\n  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n\n  return async (req, res, next) => {\n    // SECURITY: Primary auth via JWT token\n    const authHeader = req.headers['authorization'];\n    const token = extractBearerToken(authHeader);\n\n    let stripeCustomerId = null;\n\n    if (token) {\n      const decoded = verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n        req.tokenData = decoded;\n      } else {\n        // Token present but invalid\n        return res.status(401).json({\n          error: 'Invalid or expired token',\n          message: 'Please log in again to continue'\n        });\n      }\n    } else {\n      // DEPRECATED: Fallback to legacy header\n      const legacyId = req.headers['x-stripe-customer-id'];\n      if (legacyId) {\n        // SECURITY: Block legacy auth in production unless explicitly enabled\n        if (isProduction && !ALLOW_LEGACY_AUTH) {\n          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n          return res.status(401).json({\n            error: 'Authentication method not supported',\n            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n          });\n        }\n\n        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n        if (isLegacyAuthRateLimited(clientIp)) {\n          return res.status(429).json({\n            error: 'Too many authentication attempts',\n            message: 'Please wait before trying again'\n          });\n        }\n\n        // Validate format to prevent injection\n        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n          return res.status(401).json({\n            error: 'Invalid customer ID format',\n            message: 'Customer ID must be a valid Stripe customer ID'\n          });\n        }\n\n        // SECURITY: Verify customer exists in database before accepting\n        const exists = await customerExists(legacyId);\n        if (!exists) {\n          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n          return res.status(401).json({\n            error: 'Invalid customer ID',\n            message: 'Customer not found'\n          });\n        }\n\n        stripeCustomerId = legacyId;\n        req.isLegacyAuth = true;\n        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n      }\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Missing Stripe customer ID'\n      });\n    }\n\n    // Store for later use\n    req.stripeCustomerId = stripeCustomerId;\n\n    // Determine estimated duration - use request value, option value, or default\n    const estSeconds = req.estimatedDuration || estimatedSeconds;\n\n    try {\n      // Atomically reserve credits using SELECT...FOR UPDATE\n      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n\n      if (!reservation.success) {\n        // Reservation failed - not enough credits\n        const balance = await getBalance(stripeCustomerId);\n        return res.status(402).json({\n          error: 'Insufficient credits',\n          message: 'Please upgrade your plan or wait for your next billing cycle',\n          balance: {\n            hoursRemaining: balance.hoursRemaining,\n            tier: balance.tier\n          }\n        });\n      }\n\n      // Store reservation info for confirmation/release\n      req.reservation = {\n        id: reservation.reservationId,\n        seconds: estSeconds,\n        hoursReserved: reservation.hoursReserved\n      };\n\n      // Attach helper function to confirm usage with actual duration\n      // This adjusts the reservation if actual duration differs\n      req.deductUsage = async (actualDurationSeconds) => {\n        return await confirmReservation(\n          stripeCustomerId,\n          actualDurationSeconds,\n          estSeconds,\n          endpoint\n        );\n      };\n\n      // Attach helper function to release reservation on failure\n      req.releaseReservation = async (reason = 'processing_failed') => {\n        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n      };\n\n      // Hook into response to auto-release on error responses\n      const originalSend = res.send.bind(res);\n      res.send = function(body) {\n        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n        }\n        return originalSend(body);\n      };\n\n      next();\n    } catch (err) {\n      console.error('[RateLimiter] Error reserving credits:', err);\n      return res.status(500).json({\n        error: 'Credit check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Middleware to enforce tier-based feature access\n *\n * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n *\n * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n */\nfunction requireFeature(featureName) {\n  return async (req, res, next) => {\n    // Must have stripeCustomerId from requireCredits middleware\n    if (!req.stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please log in to access this feature'\n      });\n    }\n\n    try {\n      // Get user's current balance (includes tier info)\n      const balance = await getBalance(req.stripeCustomerId);\n\n      // Check if user's tier has access to this feature\n      if (!hasFeatureAccess(balance.tier, featureName)) {\n        // Release any reserved credits since we're blocking the request\n        if (req.releaseReservation) {\n          await req.releaseReservation('feature_not_available');\n        }\n\n        // Determine required tier for helpful error message\n        const requiredTier = getRequiredTierForFeature(featureName);\n\n        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n\n        return res.status(403).json({\n          error: 'Feature not available',\n          message: `This feature requires a ${requiredTier} plan or higher`,\n          requiredFeature: featureName,\n          requiredTier: requiredTier,\n          currentTier: balance.tier\n        });\n      }\n\n      // Feature access granted\n      next();\n    } catch (err) {\n      console.error('[requireFeature] Error checking feature access:', err);\n      return res.status(500).json({\n        error: 'Feature access check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Helper to determine required tier for a feature\n * Used for helpful error messages\n */\nfunction getRequiredTierForFeature(featureName) {\n  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n\n  if (teamOnlyFeatures.includes(featureName)) {\n    return 'Team';\n  } else if (proFeatures.includes(featureName)) {\n    return 'Pro';\n  }\n  return 'Starter';\n}\n\n/**\n * Middleware to track usage after successful response\n *\n * Call this after processing to deduct actual usage\n */\nfunction trackUsage(endpoint = 'unknown') {\n  return async (req, res, next) => {\n    // Store original json method\n    const originalJson = res.json.bind(res);\n\n    // Override json to track usage on success\n    res.json = async (data) => {\n      // Only deduct on successful responses\n      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n        try {\n          const balance = await deductUsage(\n            req.stripeCustomerId,\n            req.audioDuration,\n            endpoint\n          );\n          // Attach updated balance to response\n          data.balance = balance;\n        } catch (err) {\n          console.error('[RateLimiter] Error deducting usage:', err);\n        }\n      }\n      return originalJson(data);\n    };\n\n    next();\n  };\n}\n\nmodule.exports = {\n  requireCredits,\n  requireFeature,\n  trackUsage,\n  ipRateLimit\n};\n","numLines":381,"startLine":1,"totalLines":381}}}
{"parentUuid":"e9f68343-8d70-44ca-8add-37a8b6cd3b71","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01N7CWv17gr4WLrGg46m1X7q","type":"tool_result","content":"     1→/**\n     2→ * Billing Routes\n     3→ *\n     4→ * Credits and usage history endpoints\n     5→ */\n     6→\n     7→const express = require('express');\n     8→\n     9→/**\n    10→ * Create billing routes\n    11→ * @param {Object} options - Route configuration options\n    12→ * @param {Object} options.services - Shared services (usageTracking)\n    13→ * @param {Object} options.authHelpers - Auth helper functions (verifyToken)\n    14→ * @returns {express.Router}\n    15→ */\n    16→function createBillingRoutes(options = {}) {\n    17→  const router = express.Router();\n    18→  const { usageTracking } = options.services || {};\n    19→  const { verifyToken } = options.authHelpers || {};\n    20→\n    21→  /**\n    22→   * GET /credits - Get user's credit balance\n    23→   *\n    24→   * Supports both JWT (Authorization: Bearer) and legacy x-stripe-customer-id header\n    25→   */\n    26→  router.get('/credits', async (req, res) => {\n    27→    // Support both JWT and legacy auth\n    28→    let stripeCustomerId = null;\n    29→\n    30→    // Try JWT first\n    31→    const authHeader = req.headers['authorization'];\n    32→    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n    33→      const token = authHeader.slice(7);\n    34→      const decoded = verifyToken(token);\n    35→      if (decoded && decoded.sub) {\n    36→        stripeCustomerId = decoded.sub;\n    37→      }\n    38→    }\n    39→\n    40→    // Fallback to legacy header\n    41→    if (!stripeCustomerId) {\n    42→      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    43→    }\n    44→\n    45→    if (!stripeCustomerId) {\n    46→      return res.status(401).json({\n    47→        error: 'Authentication required',\n    48→        message: 'Please provide a valid Bearer token or log in again'\n    49→      });\n    50→    }\n    51→\n    52→    try {\n    53→      const balance = await usageTracking.getBalance(stripeCustomerId);\n    54→      res.json({\n    55→        success: true,\n    56→        ...balance\n    57→      });\n    58→    } catch (err) {\n    59→      console.error('[SPLICE] Credits error:', err);\n    60→      res.status(500).json({ error: err.message });\n    61→    }\n    62→  });\n    63→\n    64→  /**\n    65→   * GET /usage-history - Get user's usage history\n    66→   */\n    67→  router.get('/usage-history', async (req, res) => {\n    68→    // Support both JWT and legacy auth\n    69→    let stripeCustomerId = null;\n    70→\n    71→    const authHeader = req.headers['authorization'];\n    72→    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n    73→      const token = authHeader.slice(7);\n    74→      const decoded = verifyToken(token);\n    75→      if (decoded && decoded.sub) {\n    76→        stripeCustomerId = decoded.sub;\n    77→      }\n    78→    }\n    79→\n    80→    if (!stripeCustomerId) {\n    81→      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    82→    }\n    83→\n    84→    if (!stripeCustomerId) {\n    85→      return res.status(401).json({\n    86→        error: 'Authentication required',\n    87→        message: 'Please provide a valid Bearer token or log in again'\n    88→      });\n    89→    }\n    90→\n    91→    try {\n    92→      const history = await usageTracking.getUsageHistory(stripeCustomerId);\n    93→      res.json({\n    94→        success: true,\n    95→        history\n    96→      });\n    97→    } catch (err) {\n    98→      console.error('[SPLICE] Usage history error:', err);\n    99→      res.status(500).json({ error: err.message });\n   100→    }\n   101→  });\n   102→\n   103→  return router;\n   104→}\n   105→\n   106→module.exports = createBillingRoutes;\n   107→\n\n</system-reminder>\n"}]},"uuid":"4f01929f-6b55-48cd-ac8d-0257888a3cef","timestamp":"2025-12-30T01:04:15.139Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/billing.js","content":"/**\n * Billing Routes\n *\n * Credits and usage history endpoints\n */\n\nconst express = require('express');\n\n/**\n * Create billing routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.services - Shared services (usageTracking)\n * @param {Object} options.authHelpers - Auth helper functions (verifyToken)\n * @returns {express.Router}\n */\nfunction createBillingRoutes(options = {}) {\n  const router = express.Router();\n  const { usageTracking } = options.services || {};\n  const { verifyToken } = options.authHelpers || {};\n\n  /**\n   * GET /credits - Get user's credit balance\n   *\n   * Supports both JWT (Authorization: Bearer) and legacy x-stripe-customer-id header\n   */\n  router.get('/credits', async (req, res) => {\n    // Support both JWT and legacy auth\n    let stripeCustomerId = null;\n\n    // Try JWT first\n    const authHeader = req.headers['authorization'];\n    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n      const token = authHeader.slice(7);\n      const decoded = verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n      }\n    }\n\n    // Fallback to legacy header\n    if (!stripeCustomerId) {\n      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please provide a valid Bearer token or log in again'\n      });\n    }\n\n    try {\n      const balance = await usageTracking.getBalance(stripeCustomerId);\n      res.json({\n        success: true,\n        ...balance\n      });\n    } catch (err) {\n      console.error('[SPLICE] Credits error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * GET /usage-history - Get user's usage history\n   */\n  router.get('/usage-history', async (req, res) => {\n    // Support both JWT and legacy auth\n    let stripeCustomerId = null;\n\n    const authHeader = req.headers['authorization'];\n    if (authHeader && authHeader.startsWith('Bearer ') && verifyToken) {\n      const token = authHeader.slice(7);\n      const decoded = verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n      }\n    }\n\n    if (!stripeCustomerId) {\n      stripeCustomerId = req.headers['x-stripe-customer-id'];\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please provide a valid Bearer token or log in again'\n      });\n    }\n\n    try {\n      const history = await usageTracking.getUsageHistory(stripeCustomerId);\n      res.json({\n        success: true,\n        history\n      });\n    } catch (err) {\n      console.error('[SPLICE] Usage history error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createBillingRoutes;\n","numLines":107,"startLine":1,"totalLines":107}}}
{"parentUuid":"4f01929f-6b55-48cd-ac8d-0257888a3cef","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019vPupHbe9YhWUGzp2RBxTx","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Backend Server\n     3→ *\n     4→ * Main entry point for the SPLICE backend API.\n     5→ * Orchestrates the audio analysis pipeline.\n     6→ *\n     7→ * Slices:\n     8→ * - Slice 4: Transcription (services/transcription.js)\n     9→ * - Slice 5: Take Detection (services/takeDetection.js)\n    10→ *\n    11→ * Architecture: Modular routes (see routes/ directory)\n    12→ */\n    13→\n    14→\n    15→require('dotenv').config();\n    16→\n    17→const express = require('express');\n    18→const cors = require('cors');\n    19→const helmet = require('helmet');\n    20→const cookieParser = require('cookie-parser');\n    21→const fs = require('fs');\n    22→const https = require('https');\n    23→const http = require('http');\n    24→const path = require('path');\n    25→const crypto = require('crypto');\n    26→\n    27→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\n    28→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    29→\n    30→// Import services\n    31→const usageTracking = require('./services/usageTracking');\n    32→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\n    33→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\n    34→const referralService = require('./services/referralService');\n    35→const licenseService = require('./services/licenseService');\n    36→const emailService = require('./services/emailService');\n    37→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\n    38→const { getSupportedFormats } = require('./services/captionExporter');\n    39→\n    40→// Import route modules\n    41→const healthRoutes = require('./routes/health');\n    42→const analyzeRoutes = require('./routes/analyze');\n    43→const silencesRoutes = require('./routes/silences');\n    44→const detectionRoutes = require('./routes/detection');\n    45→const exportRoutes = require('./routes/export');\n    46→const multitrackRoutes = require('./routes/multitrack');\n    47→const cutListRoutes = require('./routes/cutList');\n    48→const zoomRoutes = require('./routes/zoom');\n    49→const chaptersRoutes = require('./routes/chapters');\n    50→const youtubeRoutes = require('./routes/youtube');\n    51→const captionsRoutes = require('./routes/captions');\n    52→const textEditRoutes = require('./routes/textEdit');\n    53→const reframeRoutes = require('./routes/reframe');\n    54→const batchRoutes = require('./routes/batch');\n    55→const authRoutes = require('./routes/auth');\n    56→const billingRoutes = require('./routes/billing');\n    57→const referralRoutes = require('./routes/referral');\n    58→const licenseRoutes = require('./routes/license');\n    59→const musicRoutes = require('./routes/music');\n    60→\n    61→// Stripe for webhooks\n    62→const Stripe = require('stripe');\n    63→\n    64→// Validate STRIPE_SECRET_KEY in production - exit if missing\n    65→if (isProduction && !process.env.STRIPE_SECRET_KEY) {\n    66→  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');\n    67→  process.exit(1);\n    68→}\n    69→\n    70→// Validate JWT_SECRET in production - exit if using default\n    71→if (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {\n    72→  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');\n    73→  process.exit(1);\n    74→}\n    75→\n    76→// Validate DATABASE_URL in production\n    77→if (isProduction && !process.env.DATABASE_URL) {\n    78→  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');\n    79→  process.exit(1);\n    80→}\n    81→\n    82→// Validate OPENAI_API_KEY in production\n    83→if (isProduction && !process.env.OPENAI_API_KEY) {\n    84→  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');\n    85→  process.exit(1);\n    86→}\n    87→\n    88→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n    89→\n    90→// =============================================================================\n    91→// PERF-FIX: Static Response Cache\n    92→// Cache static endpoint responses at startup to avoid repeated computation\n    93→// =============================================================================\n    94→\n    95→// Generate ETag from content\n    96→function generateETag(content) {\n    97→  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n    98→}\n    99→\n   100→// Static response cache - populated at startup\n   101→const STATIC_RESPONSE_CACHE = {\n   102→  profanityLanguages: null,\n   103→  profanityBleeps: null,\n   104→  exportFormats: null\n   105→};\n   106→\n   107→// Initialize cache at startup (called after server starts)\n   108→function initializeStaticCache() {\n   109→  // Cache profanity languages\n   110→  const languages = getSupportedLanguages();\n   111→  STATIC_RESPONSE_CACHE.profanityLanguages = {\n   112→    body: { success: true, languages },\n   113→    etag: generateETag({ languages })\n   114→  };\n   115→\n   116→  // Cache profanity bleeps\n   117→  const sounds = getAvailableBleepSounds();\n   118→  STATIC_RESPONSE_CACHE.profanityBleeps = {\n   119→    body: { success: true, sounds },\n   120→    etag: generateETag({ sounds })\n   121→  };\n   122→\n   123→  // Cache export formats\n   124→  const formats = getSupportedFormats();\n   125→  STATIC_RESPONSE_CACHE.exportFormats = {\n   126→    body: { success: true, formats },\n   127→    etag: generateETag({ formats })\n   128→  };\n   129→\n   130→  console.log('[SPLICE] Static response cache initialized');\n   131→}\n   132→\n   133→// Helper to send cached response with ETag\n   134→function sendCachedResponse(req, res, cacheKey) {\n   135→  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n   136→  if (!cached) {\n   137→    return res.status(500).json({ error: 'Cache not initialized' });\n   138→  }\n   139→\n   140→  // Check If-None-Match header for conditional GET\n   141→  const clientETag = req.headers['if-none-match'];\n   142→  if (clientETag === cached.etag) {\n   143→    return res.status(304).end(); // Not Modified\n   144→  }\n   145→\n   146→  // Send cached response with ETag and cache headers\n   147→  res.set('ETag', cached.etag);\n   148→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n   149→  res.json(cached.body);\n   150→}\n   151→\n   152→// =============================================================================\n   153→// Server Configuration\n   154→// =============================================================================\n   155→\n   156→const app = express();\n   157→const PORT = process.env.PORT || 3847;\n   158→\n   159→// HTTPS certificates (generated by mkcert) - only for local development\n   160→let httpsOptions = null;\n   161→if (!isProduction) {\n   162→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n   163→  const certPath = path.join(__dirname, 'localhost+1.pem');\n   164→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n   165→    httpsOptions = {\n   166→      key: fs.readFileSync(keyPath),\n   167→      cert: fs.readFileSync(certPath)\n   168→    };\n   169→  }\n   170→}\n   171→\n   172→// =============================================================================\n   173→// Security Configuration\n   174→// =============================================================================\n   175→\n   176→// CORS whitelist - restrict origins in production\n   177→const CORS_WHITELIST = [\n   178→  'http://localhost:3000',\n   179→  'http://localhost:3847',\n   180→  'https://localhost:3847',\n   181→  'http://127.0.0.1:3000',\n   182→  'http://127.0.0.1:3847',\n   183→  'https://127.0.0.1:3847',\n   184→  'https://splice.app',\n   185→  'https://www.splice.app',\n   186→  'https://splice-api-production.up.railway.app',\n   187→  'https://splice-website.vercel.app',\n   188→  // Adobe CEP/UXP panels run from file:// or bolt://\n   189→  'file://',\n   190→  'bolt://'\n   191→];\n   192→\n   193→const corsOptions = {\n   194→  origin: function (origin, callback) {\n   195→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n   196→    if (!origin) {\n   197→      return callback(null, true);\n   198→    }\n   199→    // Check if origin is in whitelist\n   200→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n   201→      return callback(null, true);\n   202→    }\n   203→    // In development, allow all origins with warning\n   204→    if (!isProduction) {\n   205→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n   206→      return callback(null, true);\n   207→    }\n   208→    // In production, reject non-whitelisted origins\n   209→    console.error(`[CORS] Blocked request from: ${origin}`);\n   210→    return callback(new Error('Not allowed by CORS'));\n   211→  },\n   212→  credentials: true,\n   213→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n   214→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n   215→};\n   216→\n   217→app.use(cors(corsOptions));\n   218→\n   219→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n   220→// This ensures rate limiting and logging use the correct client IP\n   221→if (isProduction) {\n   222→  app.set('trust proxy', 1);\n   223→}\n   224→\n   225→// IP-based rate limiting (100 requests/minute per IP)\n   226→app.use(ipRateLimit);\n   227→\n   228→// Security headers via helmet\n   229→app.use(helmet({\n   230→  contentSecurityPolicy: {\n   231→    directives: {\n   232→      defaultSrc: [\"'self'\"],\n   233→      scriptSrc: [\"'self'\"],\n   234→      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n   235→      imgSrc: [\"'self'\", 'data:', 'https:'],\n   236→      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n   237→      fontSrc: [\"'self'\"],\n   238→      objectSrc: [\"'none'\"],\n   239→      mediaSrc: [\"'self'\"],\n   240→      frameSrc: [\"'none'\"]\n   241→    }\n   242→  },\n   243→  hsts: {\n   244→    maxAge: 31536000,\n   245→    includeSubDomains: true,\n   246→    preload: true\n   247→  },\n   248→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n   249→  noSniff: true,\n   250→  xssFilter: true,\n   251→  hidePoweredBy: true\n   252→}));\n   253→\n   254→// Helper to determine tier from price ID with logging\n   255→// Supports both monthly and annual pricing\n   256→function getTierFromPriceId(priceId) {\n   257→  // Monthly prices\n   258→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   259→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   260→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   261→\n   262→  // Annual prices (same tier, just different billing period)\n   263→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n   264→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n   265→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n   266→\n   267→  // Log unknown price ID for debugging\n   268→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   269→  return 'starter';\n   270→}\n   271→\n   272→// =============================================================================\n   273→// Stripe Webhook (must be before express.json())\n   274→// =============================================================================\n   275→\n   276→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   277→  const sig = req.headers['stripe-signature'];\n   278→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   279→\n   280→  let event;\n   281→\n   282→  try {\n   283→    if (webhookSecret) {\n   284→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   285→    } else if (isProduction) {\n   286→      // SECURITY: Reject unsigned webhooks in production\n   287→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   288→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   289→    } else {\n   290→      // For local development testing only\n   291→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   292→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   293→      event = JSON.parse(bodyString);\n   294→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   295→    }\n   296→  } catch (err) {\n   297→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   298→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   299→  }\n   300→\n   301→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   302→\n   303→  // Idempotency check - skip if already processed\n   304→  if (await usageTracking.isEventProcessed(event.id)) {\n   305→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   306→    return res.json({ received: true, skipped: true });\n   307→  }\n   308→\n   309→  try {\n   310→    switch (event.type) {\n   311→      case 'customer.subscription.created':\n   312→      case 'customer.subscription.updated': {\n   313→        const subscription = event.data.object;\n   314→        const customerId = subscription.customer;\n   315→\n   316→        // Validate customerId\n   317→        if (!customerId) {\n   318→          console.error('[SPLICE] Missing customer ID in subscription event');\n   319→          return res.status(400).json({ error: 'Missing customer ID' });\n   320→        }\n   321→\n   322→        // Get tier from price ID\n   323→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   324→        const tier = getTierFromPriceId(priceId);\n   325→\n   326→        // Update user tier and reset hours\n   327→        await usageTracking.updateTier(customerId, tier);\n   328→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   329→\n   330→        // Initialize music credits for new subscriptions\n   331→        if (event.type === 'customer.subscription.created') {\n   332→          await usageTracking.resetMusicCredits(customerId, tier);\n   333→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n   334→        }\n   335→\n   336→        // Update trial end date if present\n   337→        if (subscription.trial_end) {\n   338→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n   339→        }\n   340→\n   341→        // Generate license key for new subscriptions with retry and delivery\n   342→        if (event.type === 'customer.subscription.created') {\n   343→          let licenseResult = null;\n   344→          let retryCount = 0;\n   345→          const maxRetries = 3;\n   346→\n   347→          // Retry mechanism for license key generation\n   348→          while (retryCount < maxRetries) {\n   349→            licenseResult = await licenseService.generateLicenseKey(customerId);\n   350→            if (licenseResult.success) {\n   351→              break;\n   352→            }\n   353→            retryCount++;\n   354→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n   355→            // Wait before retry (exponential backoff)\n   356→            if (retryCount < maxRetries) {\n   357→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n   358→            }\n   359→          }\n   360→\n   361→          if (licenseResult && licenseResult.success) {\n   362→            // SECURITY: Mask license key in logs\n   363→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n   364→\n   365→            // Store license key in Stripe subscription metadata as backup\n   366→            try {\n   367→              await stripe.subscriptions.update(subscription.id, {\n   368→                metadata: {\n   369→                  license_key: licenseResult.key,\n   370→                  license_generated_at: new Date().toISOString()\n   371→                }\n   372→              });\n   373→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n   374→            } catch (stripeErr) {\n   375→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n   376→            }\n   377→\n   378→            // Get customer email and send license key\n   379→            try {\n   380→              const customer = await stripe.customers.retrieve(customerId);\n   381→              if (customer.email) {\n   382→                // SECURITY: Mask sensitive data in logs\n   383→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n   384→\n   385→                // Send license key email\n   386→                try {\n   387→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n   388→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n   389→                } catch (sendErr) {\n   390→                  // Log but don't fail - license is stored in Stripe metadata as backup\n   391→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n   392→                }\n   393→\n   394→                // Store email in database for reference\n   395→                await usageTracking.updateTier(customerId, tier, customer.email);\n   396→              } else {\n   397→                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n   398→              }\n   399→            } catch (emailErr) {\n   400→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n   401→            }\n   402→          } else {\n   403→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n   404→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n   405→            console.error(`[SPLICE] ${errorMsg}`);\n   406→            return res.status(500).json({ error: errorMsg });\n   407→          }\n   408→        }\n   409→        break;\n   410→      }\n   411→\n   412→      case 'customer.subscription.deleted': {\n   413→        const subscription = event.data.object;\n   414→        const customerId = subscription.customer;\n   415→\n   416→        // Validate customerId\n   417→        if (!customerId) {\n   418→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   419→          return res.status(400).json({ error: 'Missing customer ID' });\n   420→        }\n   421→\n   422→        // Downgrade to cancelled (0 hours)\n   423→        await usageTracking.updateTier(customerId, 'cancelled');\n   424→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   425→        break;\n   426→      }\n   427→\n   428→      case 'invoice.payment_succeeded': {\n   429→        const invoice = event.data.object;\n   430→        const customerId = invoice.customer;\n   431→        const subscriptionId = invoice.subscription;\n   432→\n   433→        // Validate customerId\n   434→        if (!customerId) {\n   435→          console.error('[SPLICE] Missing customer ID in invoice event');\n   436→          return res.status(400).json({ error: 'Missing customer ID' });\n   437→        }\n   438→\n   439→        // Reset hours on successful payment (new billing period)\n   440→        let tier = 'starter';\n   441→        if (subscriptionId) {\n   442→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   443→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   444→          tier = getTierFromPriceId(priceId);\n   445→\n   446→          await usageTracking.resetHours(customerId, tier);\n   447→          await usageTracking.resetMusicCredits(customerId, tier);\n   448→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n   449→        }\n   450→\n   451→        // Check for affiliate coupon and record commission\n   452→        const discount = invoice.discount;\n   453→        if (discount && discount.coupon) {\n   454→          const couponId = discount.coupon.id;\n   455→          // Check if this is an affiliate code (like JIMMYN)\n   456→          if (referralService.AFFILIATE_CODES[couponId]) {\n   457→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n   458→            await referralService.recordAffiliateCommission(\n   459→              couponId,\n   460→              customerId,\n   461→              amountPaid,\n   462→              tier\n   463→            );\n   464→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n   465→          }\n   466→        }\n   467→        break;\n   468→      }\n   469→\n   470→      case 'invoice.payment_failed': {\n   471→        const invoice = event.data.object;\n   472→        const customerId = invoice.customer;\n   473→        const attemptCount = invoice.attempt_count || 1;\n   474→\n   475→        // Validate customerId\n   476→        if (!customerId) {\n   477→          console.error('[SPLICE] Missing customer ID in payment_failed event');\n   478→          return res.status(400).json({ error: 'Missing customer ID' });\n   479→        }\n   480→\n   481→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n   482→\n   483→        // Stripe will retry automatically per retry settings\n   484→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n   485→        // Send warning email on final attempt\n   486→        if (attemptCount >= 3) {\n   487→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n   488→          // Send warning email to customer about impending cancellation\n   489→          try {\n   490→            const customer = await stripe.customers.retrieve(customerId);\n   491→            if (customer.email) {\n   492→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n   493→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n   494→            }\n   495→          } catch (emailErr) {\n   496→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n   497→          }\n   498→        }\n   499→        break;\n   500→      }\n   501→\n   502→      case 'customer.deleted': {\n   503→        const customer = event.data.object;\n   504→        const customerId = customer.id;\n   505→\n   506→        // Validate customerId\n   507→        if (!customerId) {\n   508→          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n   509→          return res.status(400).json({ error: 'Missing customer ID' });\n   510→        }\n   511→\n   512→        // Clean up user data - downgrade to cancelled\n   513→        await usageTracking.updateTier(customerId, 'cancelled');\n   514→        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n   515→        break;\n   516→      }\n   517→\n   518→      default:\n   519→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   520→    }\n   521→\n   522→    // Record event as processed (idempotency)\n   523→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   524→\n   525→    res.json({ received: true });\n   526→  } catch (err) {\n   527→    console.error('[SPLICE] Webhook handler error:', err);\n   528→    res.status(500).json({ error: err.message });\n   529→  }\n   530→});\n   531→\n   532→// Parse JSON body for all other routes\n   533→// SECURITY: Limit JSON body size to prevent DoS attacks\n   534→app.use(express.json({ limit: '10mb' }));\n   535→\n   536→// Parse cookies for CSRF token validation\n   537→app.use(cookieParser());\n   538→\n   539→// =============================================================================\n   540→// Route Configuration Options\n   541→// =============================================================================\n   542→\n   543→const routeOptions = {\n   544→  middleware: {\n   545→    requireCredits,\n   546→    requireFeature,\n   547→    authenticateToken\n   548→  },\n   549→  services: {\n   550→    usageTracking,\n   551→    referralService,\n   552→    licenseService,\n   553→    emailService,\n   554→    stripe\n   555→  },\n   556→  authHelpers: {\n   557→    generateToken,\n   558→    generateRefreshToken,\n   559→    verifyToken,\n   560→    maskSensitiveData,\n   561→    blacklistToken\n   562→  },\n   563→  staticCache: STATIC_RESPONSE_CACHE,\n   564→  sendCachedResponse\n   565→};\n   566→\n   567→// =============================================================================\n   568→// Mount Routes\n   569→// =============================================================================\n   570→\n   571→// Health check and system endpoints (no prefix)\n   572→app.use('/', healthRoutes(routeOptions));\n   573→\n   574→// Core analysis endpoints\n   575→app.use('/', analyzeRoutes(routeOptions));\n   576→app.use('/', silencesRoutes(routeOptions));\n   577→app.use('/', detectionRoutes(routeOptions));\n   578→\n   579→// Export endpoints\n   580→app.use('/export', exportRoutes(routeOptions));\n   581→\n   582→// Multitrack/Multicam endpoints\n   583→app.use('/multitrack', multitrackRoutes(routeOptions));\n   584→\n   585→// Cut list generation\n   586→app.use('/cut-list', cutListRoutes(routeOptions));\n   587→\n   588→// Legacy XML processing endpoint (backwards compatibility)\n   589→const { processXMLFile } = require('./services/xmlProcessor');\n   590→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n   591→  const {\n   592→    xmlPath,\n   593→    silences,\n   594→    removeGaps = true,\n   595→    outputPath = null\n   596→  } = req.body;\n   597→\n   598→  if (!xmlPath) {\n   599→    return res.status(400).json({ error: 'xmlPath is required' });\n   600→  }\n   601→\n   602→  if (!silences || !Array.isArray(silences)) {\n   603→    return res.status(400).json({ error: 'silences array is required' });\n   604→  }\n   605→\n   606→  if (!fs.existsSync(xmlPath)) {\n   607→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n   608→  }\n   609→\n   610→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n   611→\n   612→  try {\n   613→    const result = await processXMLFile(xmlPath, silences, {\n   614→      outputPath,\n   615→      removeGaps\n   616→    });\n   617→\n   618→    res.json({\n   619→      success: true,\n   620→      inputPath: xmlPath,\n   621→      outputPath: result.outputPath,\n   622→      stats: result.stats\n   623→    });\n   624→  } catch (err) {\n   625→    console.error('[SPLICE] XML processing error:', err);\n   626→    res.status(500).json({ error: err.message });\n   627→  }\n   628→});\n   629→\n   630→// Auto zoom endpoints\n   631→app.use('/zoom', zoomRoutes(routeOptions));\n   632→\n   633→// Chapter detection endpoints\n   634→app.use('/chapters', chaptersRoutes(routeOptions));\n   635→\n   636→// YouTube content generation\n   637→app.use('/youtube', youtubeRoutes(routeOptions));\n   638→\n   639→// Animated captions endpoints\n   640→app.use('/captions', captionsRoutes(routeOptions));\n   641→\n   642→// Text-based editing endpoints\n   643→app.use('/text-edit', textEditRoutes(routeOptions));\n   644→\n   645→// Social reframe endpoints\n   646→app.use('/reframe', reframeRoutes(routeOptions));\n   647→app.use('/faces', reframeRoutes.facesRouter(routeOptions));\n   648→\n   649→// Batch processing endpoints\n   650→app.use('/batch', batchRoutes(routeOptions));\n   651→\n   652→// Authentication endpoints\n   653→app.use('/auth', authRoutes(routeOptions));\n   654→\n   655→// Billing and credits endpoints\n   656→app.use('/', billingRoutes(routeOptions));\n   657→\n   658→// Referral system endpoints\n   659→app.use('/referral', referralRoutes(routeOptions));\n   660→\n   661→// License key endpoints\n   662→app.use('/license', licenseRoutes(routeOptions));\n   663→\n   664→// AI Music generation endpoints\n   665→app.use('/music', musicRoutes(routeOptions));\n   666→\n   667→// =============================================================================\n   668→// Start Server\n   669→// =============================================================================\n   670→\n   671→// Track active server for graceful shutdown\n   672→let server = null;\n   673→\n   674→// Initialize database and start server\n   675→async function startServer() {\n   676→  try {\n   677→    await usageTracking.initDatabase();\n   678→    await referralService.initReferralTables();\n   679→    await licenseService.initLicenseTables();\n   680→    console.log('[SPLICE] Database initialized');\n   681→\n   682→    // PERF-FIX: Initialize static response cache at startup\n   683→    initializeStaticCache();\n   684→\n   685→    if (isProduction || !httpsOptions) {\n   686→      // Production: Railway provides TLS termination, use HTTP\n   687→      server = http.createServer(app).listen(PORT, () => {\n   688→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n   689→      });\n   690→    } else {\n   691→      // Development: Use HTTPS with local certificates\n   692→      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n   693→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n   694→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n   695→      });\n   696→    }\n   697→  } catch (err) {\n   698→    console.error('[SPLICE] Failed to start server:', err);\n   699→    process.exit(1);\n   700→  }\n   701→}\n   702→\n   703→// =============================================================================\n   704→// Graceful Shutdown\n   705→// =============================================================================\n   706→\n   707→async function gracefulShutdown(signal) {\n   708→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n   709→\n   710→  // Stop accepting new connections\n   711→  if (server) {\n   712→    server.close(() => {\n   713→      console.log('[SPLICE] HTTP server closed');\n   714→    });\n   715→  }\n   716→\n   717→  // Close database pool\n   718→  try {\n   719→    await usageTracking.closePool();\n   720→    console.log('[SPLICE] Database pool closed');\n   721→  } catch (err) {\n   722→    console.error('[SPLICE] Error closing database pool:', err.message);\n   723→  }\n   724→\n   725→  // Give ongoing requests time to complete (max 10 seconds)\n   726→  setTimeout(() => {\n   727→    console.log('[SPLICE] Graceful shutdown complete');\n   728→    process.exit(0);\n   729→  }, 10000);\n   730→}\n   731→\n   732→// Handle termination signals\n   733→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n   734→process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n   735→\n   736→// Handle uncaught exceptions\n   737→process.on('uncaughtException', (err) => {\n   738→  console.error('[SPLICE] Uncaught exception:', err);\n   739→  gracefulShutdown('uncaughtException');\n   740→});\n   741→\n   742→process.on('unhandledRejection', (reason, promise) => {\n   743→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n   744→});\n   745→\n   746→startServer();\n   747→\n\n</system-reminder>\n"}]},"uuid":"edac6c4a-78a3-43f3-afa4-332cfb1c967d","timestamp":"2025-12-30T01:04:15.266Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"/**\n * SPLICE Backend Server\n *\n * Main entry point for the SPLICE backend API.\n * Orchestrates the audio analysis pipeline.\n *\n * Slices:\n * - Slice 4: Transcription (services/transcription.js)\n * - Slice 5: Take Detection (services/takeDetection.js)\n *\n * Architecture: Modular routes (see routes/ directory)\n */\n\n\nrequire('dotenv').config();\n\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst https = require('https');\nconst http = require('http');\nconst path = require('path');\nconst crypto = require('crypto');\n\n// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// Import services\nconst usageTracking = require('./services/usageTracking');\nconst { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\nconst { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\nconst referralService = require('./services/referralService');\nconst licenseService = require('./services/licenseService');\nconst emailService = require('./services/emailService');\nconst { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\nconst { getSupportedFormats } = require('./services/captionExporter');\n\n// Import route modules\nconst healthRoutes = require('./routes/health');\nconst analyzeRoutes = require('./routes/analyze');\nconst silencesRoutes = require('./routes/silences');\nconst detectionRoutes = require('./routes/detection');\nconst exportRoutes = require('./routes/export');\nconst multitrackRoutes = require('./routes/multitrack');\nconst cutListRoutes = require('./routes/cutList');\nconst zoomRoutes = require('./routes/zoom');\nconst chaptersRoutes = require('./routes/chapters');\nconst youtubeRoutes = require('./routes/youtube');\nconst captionsRoutes = require('./routes/captions');\nconst textEditRoutes = require('./routes/textEdit');\nconst reframeRoutes = require('./routes/reframe');\nconst batchRoutes = require('./routes/batch');\nconst authRoutes = require('./routes/auth');\nconst billingRoutes = require('./routes/billing');\nconst referralRoutes = require('./routes/referral');\nconst licenseRoutes = require('./routes/license');\nconst musicRoutes = require('./routes/music');\n\n// Stripe for webhooks\nconst Stripe = require('stripe');\n\n// Validate STRIPE_SECRET_KEY in production - exit if missing\nif (isProduction && !process.env.STRIPE_SECRET_KEY) {\n  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');\n  process.exit(1);\n}\n\n// Validate JWT_SECRET in production - exit if using default\nif (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {\n  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');\n  process.exit(1);\n}\n\n// Validate DATABASE_URL in production\nif (isProduction && !process.env.DATABASE_URL) {\n  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');\n  process.exit(1);\n}\n\n// Validate OPENAI_API_KEY in production\nif (isProduction && !process.env.OPENAI_API_KEY) {\n  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');\n  process.exit(1);\n}\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n\n// =============================================================================\n// PERF-FIX: Static Response Cache\n// Cache static endpoint responses at startup to avoid repeated computation\n// =============================================================================\n\n// Generate ETag from content\nfunction generateETag(content) {\n  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n}\n\n// Static response cache - populated at startup\nconst STATIC_RESPONSE_CACHE = {\n  profanityLanguages: null,\n  profanityBleeps: null,\n  exportFormats: null\n};\n\n// Initialize cache at startup (called after server starts)\nfunction initializeStaticCache() {\n  // Cache profanity languages\n  const languages = getSupportedLanguages();\n  STATIC_RESPONSE_CACHE.profanityLanguages = {\n    body: { success: true, languages },\n    etag: generateETag({ languages })\n  };\n\n  // Cache profanity bleeps\n  const sounds = getAvailableBleepSounds();\n  STATIC_RESPONSE_CACHE.profanityBleeps = {\n    body: { success: true, sounds },\n    etag: generateETag({ sounds })\n  };\n\n  // Cache export formats\n  const formats = getSupportedFormats();\n  STATIC_RESPONSE_CACHE.exportFormats = {\n    body: { success: true, formats },\n    etag: generateETag({ formats })\n  };\n\n  console.log('[SPLICE] Static response cache initialized');\n}\n\n// Helper to send cached response with ETag\nfunction sendCachedResponse(req, res, cacheKey) {\n  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n  if (!cached) {\n    return res.status(500).json({ error: 'Cache not initialized' });\n  }\n\n  // Check If-None-Match header for conditional GET\n  const clientETag = req.headers['if-none-match'];\n  if (clientETag === cached.etag) {\n    return res.status(304).end(); // Not Modified\n  }\n\n  // Send cached response with ETag and cache headers\n  res.set('ETag', cached.etag);\n  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n  res.json(cached.body);\n}\n\n// =============================================================================\n// Server Configuration\n// =============================================================================\n\nconst app = express();\nconst PORT = process.env.PORT || 3847;\n\n// HTTPS certificates (generated by mkcert) - only for local development\nlet httpsOptions = null;\nif (!isProduction) {\n  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n  const certPath = path.join(__dirname, 'localhost+1.pem');\n  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n    httpsOptions = {\n      key: fs.readFileSync(keyPath),\n      cert: fs.readFileSync(certPath)\n    };\n  }\n}\n\n// =============================================================================\n// Security Configuration\n// =============================================================================\n\n// CORS whitelist - restrict origins in production\nconst CORS_WHITELIST = [\n  'http://localhost:3000',\n  'http://localhost:3847',\n  'https://localhost:3847',\n  'http://127.0.0.1:3000',\n  'http://127.0.0.1:3847',\n  'https://127.0.0.1:3847',\n  'https://splice.app',\n  'https://www.splice.app',\n  'https://splice-api-production.up.railway.app',\n  'https://splice-website.vercel.app',\n  // Adobe CEP/UXP panels run from file:// or bolt://\n  'file://',\n  'bolt://'\n];\n\nconst corsOptions = {\n  origin: function (origin, callback) {\n    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n    if (!origin) {\n      return callback(null, true);\n    }\n    // Check if origin is in whitelist\n    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n      return callback(null, true);\n    }\n    // In development, allow all origins with warning\n    if (!isProduction) {\n      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n      return callback(null, true);\n    }\n    // In production, reject non-whitelisted origins\n    console.error(`[CORS] Blocked request from: ${origin}`);\n    return callback(new Error('Not allowed by CORS'));\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n};\n\napp.use(cors(corsOptions));\n\n// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n// This ensures rate limiting and logging use the correct client IP\nif (isProduction) {\n  app.set('trust proxy', 1);\n}\n\n// IP-based rate limiting (100 requests/minute per IP)\napp.use(ipRateLimit);\n\n// Security headers via helmet\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n  noSniff: true,\n  xssFilter: true,\n  hidePoweredBy: true\n}));\n\n// Helper to determine tier from price ID with logging\n// Supports both monthly and annual pricing\nfunction getTierFromPriceId(priceId) {\n  // Monthly prices\n  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n\n  // Annual prices (same tier, just different billing period)\n  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n\n  // Log unknown price ID for debugging\n  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n  return 'starter';\n}\n\n// =============================================================================\n// Stripe Webhook (must be before express.json())\n// =============================================================================\n\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n  let event;\n\n  try {\n    if (webhookSecret) {\n      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } else if (isProduction) {\n      // SECURITY: Reject unsigned webhooks in production\n      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n    } else {\n      // For local development testing only\n      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n      event = JSON.parse(bodyString);\n      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n    return res.status(400).json({ error: 'Webhook signature verification failed' });\n  }\n\n  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n\n  // Idempotency check - skip if already processed\n  if (await usageTracking.isEventProcessed(event.id)) {\n    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n    return res.json({ received: true, skipped: true });\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Get tier from price ID\n        const priceId = subscription.items?.data?.[0]?.price?.id;\n        const tier = getTierFromPriceId(priceId);\n\n        // Update user tier and reset hours\n        await usageTracking.updateTier(customerId, tier);\n        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n\n        // Initialize music credits for new subscriptions\n        if (event.type === 'customer.subscription.created') {\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Update trial end date if present\n        if (subscription.trial_end) {\n          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n        }\n\n        // Generate license key for new subscriptions with retry and delivery\n        if (event.type === 'customer.subscription.created') {\n          let licenseResult = null;\n          let retryCount = 0;\n          const maxRetries = 3;\n\n          // Retry mechanism for license key generation\n          while (retryCount < maxRetries) {\n            licenseResult = await licenseService.generateLicenseKey(customerId);\n            if (licenseResult.success) {\n              break;\n            }\n            retryCount++;\n            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n            // Wait before retry (exponential backoff)\n            if (retryCount < maxRetries) {\n              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n            }\n          }\n\n          if (licenseResult && licenseResult.success) {\n            // SECURITY: Mask license key in logs\n            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n\n            // Store license key in Stripe subscription metadata as backup\n            try {\n              await stripe.subscriptions.update(subscription.id, {\n                metadata: {\n                  license_key: licenseResult.key,\n                  license_generated_at: new Date().toISOString()\n                }\n              });\n              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n            } catch (stripeErr) {\n              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n            }\n\n            // Get customer email and send license key\n            try {\n              const customer = await stripe.customers.retrieve(customerId);\n              if (customer.email) {\n                // SECURITY: Mask sensitive data in logs\n                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n\n                // Send license key email\n                try {\n                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n                } catch (sendErr) {\n                  // Log but don't fail - license is stored in Stripe metadata as backup\n                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n                }\n\n                // Store email in database for reference\n                await usageTracking.updateTier(customerId, tier, customer.email);\n              } else {\n                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n              }\n            } catch (emailErr) {\n              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n            }\n          } else {\n            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n            console.error(`[SPLICE] ${errorMsg}`);\n            return res.status(500).json({ error: errorMsg });\n          }\n        }\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Downgrade to cancelled (0 hours)\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const subscriptionId = invoice.subscription;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in invoice event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Reset hours on successful payment (new billing period)\n        let tier = 'starter';\n        if (subscriptionId) {\n          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n          const priceId = subscription.items?.data?.[0]?.price?.id;\n          tier = getTierFromPriceId(priceId);\n\n          await usageTracking.resetHours(customerId, tier);\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Check for affiliate coupon and record commission\n        const discount = invoice.discount;\n        if (discount && discount.coupon) {\n          const couponId = discount.coupon.id;\n          // Check if this is an affiliate code (like JIMMYN)\n          if (referralService.AFFILIATE_CODES[couponId]) {\n            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n            await referralService.recordAffiliateCommission(\n              couponId,\n              customerId,\n              amountPaid,\n              tier\n            );\n            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n          }\n        }\n        break;\n      }\n\n      case 'invoice.payment_failed': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const attemptCount = invoice.attempt_count || 1;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in payment_failed event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n\n        // Stripe will retry automatically per retry settings\n        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n        // Send warning email on final attempt\n        if (attemptCount >= 3) {\n          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n          // Send warning email to customer about impending cancellation\n          try {\n            const customer = await stripe.customers.retrieve(customerId);\n            if (customer.email) {\n              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n            }\n          } catch (emailErr) {\n            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n          }\n        }\n        break;\n      }\n\n      case 'customer.deleted': {\n        const customer = event.data.object;\n        const customerId = customer.id;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Clean up user data - downgrade to cancelled\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n        break;\n      }\n\n      default:\n        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n    }\n\n    // Record event as processed (idempotency)\n    await usageTracking.recordWebhookEvent(event.id, event.type);\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error('[SPLICE] Webhook handler error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Parse JSON body for all other routes\n// SECURITY: Limit JSON body size to prevent DoS attacks\napp.use(express.json({ limit: '10mb' }));\n\n// Parse cookies for CSRF token validation\napp.use(cookieParser());\n\n// =============================================================================\n// Route Configuration Options\n// =============================================================================\n\nconst routeOptions = {\n  middleware: {\n    requireCredits,\n    requireFeature,\n    authenticateToken\n  },\n  services: {\n    usageTracking,\n    referralService,\n    licenseService,\n    emailService,\n    stripe\n  },\n  authHelpers: {\n    generateToken,\n    generateRefreshToken,\n    verifyToken,\n    maskSensitiveData,\n    blacklistToken\n  },\n  staticCache: STATIC_RESPONSE_CACHE,\n  sendCachedResponse\n};\n\n// =============================================================================\n// Mount Routes\n// =============================================================================\n\n// Health check and system endpoints (no prefix)\napp.use('/', healthRoutes(routeOptions));\n\n// Core analysis endpoints\napp.use('/', analyzeRoutes(routeOptions));\napp.use('/', silencesRoutes(routeOptions));\napp.use('/', detectionRoutes(routeOptions));\n\n// Export endpoints\napp.use('/export', exportRoutes(routeOptions));\n\n// Multitrack/Multicam endpoints\napp.use('/multitrack', multitrackRoutes(routeOptions));\n\n// Cut list generation\napp.use('/cut-list', cutListRoutes(routeOptions));\n\n// Legacy XML processing endpoint (backwards compatibility)\nconst { processXMLFile } = require('./services/xmlProcessor');\napp.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n  const {\n    xmlPath,\n    silences,\n    removeGaps = true,\n    outputPath = null\n  } = req.body;\n\n  if (!xmlPath) {\n    return res.status(400).json({ error: 'xmlPath is required' });\n  }\n\n  if (!silences || !Array.isArray(silences)) {\n    return res.status(400).json({ error: 'silences array is required' });\n  }\n\n  if (!fs.existsSync(xmlPath)) {\n    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n  }\n\n  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n\n  try {\n    const result = await processXMLFile(xmlPath, silences, {\n      outputPath,\n      removeGaps\n    });\n\n    res.json({\n      success: true,\n      inputPath: xmlPath,\n      outputPath: result.outputPath,\n      stats: result.stats\n    });\n  } catch (err) {\n    console.error('[SPLICE] XML processing error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Auto zoom endpoints\napp.use('/zoom', zoomRoutes(routeOptions));\n\n// Chapter detection endpoints\napp.use('/chapters', chaptersRoutes(routeOptions));\n\n// YouTube content generation\napp.use('/youtube', youtubeRoutes(routeOptions));\n\n// Animated captions endpoints\napp.use('/captions', captionsRoutes(routeOptions));\n\n// Text-based editing endpoints\napp.use('/text-edit', textEditRoutes(routeOptions));\n\n// Social reframe endpoints\napp.use('/reframe', reframeRoutes(routeOptions));\napp.use('/faces', reframeRoutes.facesRouter(routeOptions));\n\n// Batch processing endpoints\napp.use('/batch', batchRoutes(routeOptions));\n\n// Authentication endpoints\napp.use('/auth', authRoutes(routeOptions));\n\n// Billing and credits endpoints\napp.use('/', billingRoutes(routeOptions));\n\n// Referral system endpoints\napp.use('/referral', referralRoutes(routeOptions));\n\n// License key endpoints\napp.use('/license', licenseRoutes(routeOptions));\n\n// AI Music generation endpoints\napp.use('/music', musicRoutes(routeOptions));\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\n// Track active server for graceful shutdown\nlet server = null;\n\n// Initialize database and start server\nasync function startServer() {\n  try {\n    await usageTracking.initDatabase();\n    await referralService.initReferralTables();\n    await licenseService.initLicenseTables();\n    console.log('[SPLICE] Database initialized');\n\n    // PERF-FIX: Initialize static response cache at startup\n    initializeStaticCache();\n\n    if (isProduction || !httpsOptions) {\n      // Production: Railway provides TLS termination, use HTTP\n      server = http.createServer(app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n      });\n    } else {\n      // Development: Use HTTPS with local certificates\n      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n      });\n    }\n  } catch (err) {\n    console.error('[SPLICE] Failed to start server:', err);\n    process.exit(1);\n  }\n}\n\n// =============================================================================\n// Graceful Shutdown\n// =============================================================================\n\nasync function gracefulShutdown(signal) {\n  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n\n  // Stop accepting new connections\n  if (server) {\n    server.close(() => {\n      console.log('[SPLICE] HTTP server closed');\n    });\n  }\n\n  // Close database pool\n  try {\n    await usageTracking.closePool();\n    console.log('[SPLICE] Database pool closed');\n  } catch (err) {\n    console.error('[SPLICE] Error closing database pool:', err.message);\n  }\n\n  // Give ongoing requests time to complete (max 10 seconds)\n  setTimeout(() => {\n    console.log('[SPLICE] Graceful shutdown complete');\n    process.exit(0);\n  }, 10000);\n}\n\n// Handle termination signals\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (err) => {\n  console.error('[SPLICE] Uncaught exception:', err);\n  gracefulShutdown('uncaughtException');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n});\n\nstartServer();\n","numLines":747,"startLine":1,"totalLines":747}}}
{"parentUuid":"edac6c4a-78a3-43f3-afa4-332cfb1c967d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01M54PJbnLEz8HRkxBtUwxrn","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the test files as well:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5981,"cache_creation_input_tokens":10028,"cache_read_input_tokens":36237,"cache_creation":{"ephemeral_5m_input_tokens":10028,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWbyLWYaDJYNL9gVDzhnD","type":"assistant","uuid":"dbd77ddf-cacd-4026-9d85-8de1ab9bc4a3","timestamp":"2025-12-30T01:04:21.155Z"}
{"parentUuid":"dbd77ddf-cacd-4026-9d85-8de1ab9bc4a3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01M54PJbnLEz8HRkxBtUwxrn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HiLuAgsPRgBDMgasnJAkK1","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/tests/auth.test.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5981,"cache_creation_input_tokens":10028,"cache_read_input_tokens":36237,"cache_creation":{"ephemeral_5m_input_tokens":10028,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWbyLWYaDJYNL9gVDzhnD","type":"assistant","uuid":"72c66e65-7f4e-4030-8ca3-bc47cd4ba838","timestamp":"2025-12-30T01:04:21.901Z"}
{"parentUuid":"72c66e65-7f4e-4030-8ca3-bc47cd4ba838","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01M54PJbnLEz8HRkxBtUwxrn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SZeGrmc9fE7aRaaMfwkWsv","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/tests/security.test.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5981,"cache_creation_input_tokens":10028,"cache_read_input_tokens":36237,"cache_creation":{"ephemeral_5m_input_tokens":10028,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWbyLWYaDJYNL9gVDzhnD","type":"assistant","uuid":"8138d0c8-0aa9-40d9-ac65-331067a3e6f5","timestamp":"2025-12-30T01:04:22.280Z"}
{"parentUuid":"8138d0c8-0aa9-40d9-ac65-331067a3e6f5","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SZeGrmc9fE7aRaaMfwkWsv","type":"tool_result","content":"     1→/**\n     2→ * Security Tests - Comprehensive security vulnerability verification\n     3→ *\n     4→ * Tests for:\n     5→ * 1. JWT Authentication - Token generation, validation, expiration\n     6→ * 2. License Key Security - Masked logs, email-only delivery\n     7→ * 3. CORS Whitelist - Origin validation\n     8→ * 4. Security Headers - Helmet configuration\n     9→ * 5. Rate Limiter Auth - JWT vs legacy header handling\n    10→ */\n    11→\n    12→// const assert = require('assert'); // Not currently used\n    13→const fs = require('fs');\n    14→const path = require('path');\n    15→\n    16→// =============================================================================\n    17→// Test Framework\n    18→// =============================================================================\n    19→\n    20→let passCount = 0;\n    21→let failCount = 0;\n    22→\n    23→function test(name, fn) {\n    24→  try {\n    25→    fn();\n    26→    passCount++;\n    27→    console.log(`  \\u2713 ${name}`);\n    28→  } catch (err) {\n    29→    failCount++;\n    30→    console.log(`  \\u2717 ${name}`);\n    31→    console.log(`    Error: ${err.message}`);\n    32→  }\n    33→}\n    34→\n    35→// eslint-disable-next-line no-unused-vars\n    36→function _assertEqual(actual, expected, message = '') {\n    37→  if (actual !== expected) {\n    38→    throw new Error(`${message}: Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);\n    39→  }\n    40→}\n    41→\n    42→function assertTrue(condition, message = '') {\n    43→  if (!condition) {\n    44→    throw new Error(`${message}: Expected true, got false`);\n    45→  }\n    46→}\n    47→\n    48→// eslint-disable-next-line no-unused-vars\n    49→function _assertFalse(condition, message = '') {\n    50→  if (condition) {\n    51→    throw new Error(`${message}: Expected false, got true`);\n    52→  }\n    53→}\n    54→\n    55→function assertIncludes(str, substr, message = '') {\n    56→  if (!str || !str.includes(substr)) {\n    57→    throw new Error(`${message}: String does not include \"${substr}\"`);\n    58→  }\n    59→}\n    60→\n    61→// eslint-disable-next-line no-unused-vars\n    62→function _assertNotIncludes(str, substr, message = '') {\n    63→  if (str && str.includes(substr)) {\n    64→    throw new Error(`${message}: String should not include \"${substr}\"`);\n    65→  }\n    66→}\n    67→\n    68→// =============================================================================\n    69→// Load Source Files\n    70→// =============================================================================\n    71→\n    72→let authSource = '';\n    73→let rateLimiterSource = '';\n    74→let serverSource = '';\n    75→let authRoutesSource = '';\n    76→let billingRoutesSource = '';\n    77→let licenseRoutesSource = '';\n    78→\n    79→try {\n    80→  authSource = fs.readFileSync(path.join(__dirname, '../middleware/auth.js'), 'utf8');\n    81→  rateLimiterSource = fs.readFileSync(path.join(__dirname, '../middleware/rateLimiter.js'), 'utf8');\n    82→  serverSource = fs.readFileSync(path.join(__dirname, '../server.js'), 'utf8');\n    83→  authRoutesSource = fs.readFileSync(path.join(__dirname, '../routes/auth.js'), 'utf8');\n    84→  billingRoutesSource = fs.readFileSync(path.join(__dirname, '../routes/billing.js'), 'utf8');\n    85→  licenseRoutesSource = fs.readFileSync(path.join(__dirname, '../routes/license.js'), 'utf8');\n    86→} catch (err) {\n    87→  console.error('Failed to read source files:', err.message);\n    88→  process.exit(1);\n    89→}\n    90→\n    91→// =============================================================================\n    92→// Test Suite 1: JWT Authentication Middleware\n    93→// =============================================================================\n    94→\n    95→console.log('\\n=== Security Tests ===\\n');\n    96→console.log('1. JWT Authentication Middleware');\n    97→\n    98→test('should export generateToken function', () => {\n    99→  assertIncludes(authSource, 'function generateToken', 'Missing generateToken');\n   100→  assertIncludes(authSource, \"module.exports\", 'Missing exports');\n   101→  assertIncludes(authSource, \"generateToken\", 'generateToken not exported');\n   102→});\n   103→\n   104→test('should export generateRefreshToken function', () => {\n   105→  assertIncludes(authSource, 'function generateRefreshToken', 'Missing generateRefreshToken');\n   106→  assertIncludes(authSource, \"generateRefreshToken\", 'generateRefreshToken not exported');\n   107→});\n   108→\n   109→test('should export verifyToken function', () => {\n   110→  assertIncludes(authSource, 'function verifyToken', 'Missing verifyToken');\n   111→  assertIncludes(authSource, \"verifyToken\", 'verifyToken not exported');\n   112→});\n   113→\n   114→test('should export authenticateToken middleware', () => {\n   115→  assertIncludes(authSource, 'function authenticateToken', 'Missing authenticateToken');\n   116→  assertIncludes(authSource, \"authenticateToken\", 'authenticateToken not exported');\n   117→});\n   118→\n   119→test('should use jsonwebtoken library', () => {\n   120→  assertIncludes(authSource, \"require('jsonwebtoken')\", 'Not using jsonwebtoken');\n   121→});\n   122→\n   123→test('should have JWT_SECRET configuration', () => {\n   124→  assertIncludes(authSource, 'JWT_SECRET', 'Missing JWT_SECRET');\n   125→  assertIncludes(authSource, 'process.env.JWT_SECRET', 'JWT_SECRET not from env');\n   126→});\n   127→\n   128→test('should have JWT expiration configuration', () => {\n   129→  assertIncludes(authSource, 'JWT_EXPIRES_IN', 'Missing JWT_EXPIRES_IN');\n   130→  assertIncludes(authSource, 'expiresIn', 'Missing expiresIn in sign');\n   131→});\n   132→\n   133→test('should validate Stripe customer ID format in generateToken', () => {\n   134→  assertIncludes(authSource, \"startsWith('cus_')\", 'Missing cus_ validation');\n   135→});\n   136→\n   137→test('should handle TokenExpiredError', () => {\n   138→  assertIncludes(authSource, 'TokenExpiredError', 'Missing TokenExpiredError handling');\n   139→});\n   140→\n   141→test('should handle JsonWebTokenError', () => {\n   142→  assertIncludes(authSource, 'JsonWebTokenError', 'Missing JsonWebTokenError handling');\n   143→});\n   144→\n   145→test('should extract Bearer token from Authorization header', () => {\n   146→  assertIncludes(authSource, 'function extractBearerToken', 'Missing extractBearerToken');\n   147→  assertIncludes(authSource, \"toLowerCase() !== 'bearer'\", 'Missing Bearer validation');\n   148→});\n   149→\n   150→test('should warn about default JWT secret in production', () => {\n   151→  assertIncludes(authSource, 'CRITICAL: JWT_SECRET not set in production', 'Missing production warning');\n   152→});\n   153→\n   154→test('should support legacy x-stripe-customer-id header (deprecated)', () => {\n   155→  assertIncludes(authSource, 'x-stripe-customer-id', 'Missing legacy header support');\n   156→  assertIncludes(authSource, 'DEPRECATED', 'Missing deprecation warning');\n   157→});\n   158→\n   159→test('should export maskSensitiveData function', () => {\n   160→  assertIncludes(authSource, 'function maskSensitiveData', 'Missing maskSensitiveData');\n   161→  assertIncludes(authSource, \"maskSensitiveData\", 'maskSensitiveData not exported');\n   162→});\n   163→\n   164→test('should mask SPLICE license keys properly', () => {\n   165→  assertIncludes(authSource, \"startsWith('SPLICE-')\", 'Missing SPLICE key detection');\n   166→  assertIncludes(authSource, '****', 'Missing masking pattern');\n   167→});\n   168→\n   169→test('should mask customer IDs properly', () => {\n   170→  assertIncludes(authSource, \"startsWith('cus_')\", 'Missing cus_ detection');\n   171→});\n   172→\n   173→test('should mask emails properly', () => {\n   174→  assertIncludes(authSource, \"includes('@')\", 'Missing email detection');\n   175→});\n   176→\n   177→// =============================================================================\n   178→// Test Suite 2: Rate Limiter JWT Integration\n   179→// =============================================================================\n   180→\n   181→console.log('\\n2. Rate Limiter JWT Integration');\n   182→\n   183→test('should import auth middleware in rateLimiter', () => {\n   184→  assertIncludes(rateLimiterSource, \"require('./auth')\", 'Not importing auth middleware');\n   185→});\n   186→\n   187→test('should import verifyToken in rateLimiter', () => {\n   188→  assertIncludes(rateLimiterSource, 'verifyToken', 'Not using verifyToken');\n   189→});\n   190→\n   191→test('should import extractBearerToken in rateLimiter', () => {\n   192→  assertIncludes(rateLimiterSource, 'extractBearerToken', 'Not using extractBearerToken');\n   193→});\n   194→\n   195→test('should check Authorization header first', () => {\n   196→  assertIncludes(rateLimiterSource, \"headers['authorization']\", 'Not checking Authorization header');\n   197→});\n   198→\n   199→test('should validate legacy customer ID format with regex', () => {\n   200→  assertIncludes(rateLimiterSource, \"match(/^cus_[a-zA-Z0-9]\", 'Missing customer ID format validation');\n   201→});\n   202→\n   203→test('should log deprecation warning for legacy auth', () => {\n   204→  assertIncludes(rateLimiterSource, 'DEPRECATED', 'Missing deprecation warning');\n   205→});\n   206→\n   207→test('should set isLegacyAuth flag for legacy header', () => {\n   208→  assertIncludes(rateLimiterSource, 'req.isLegacyAuth = true', 'Missing isLegacyAuth flag');\n   209→});\n   210→\n   211→test('should return 401 for invalid JWT token', () => {\n   212→  assertIncludes(rateLimiterSource, 'Invalid or expired token', 'Missing invalid token error');\n   213→});\n   214→\n   215→// =============================================================================\n   216→// Test Suite 3: CORS Whitelist\n   217→// =============================================================================\n   218→\n   219→console.log('\\n3. CORS Whitelist');\n   220→\n   221→test('should define CORS_WHITELIST array', () => {\n   222→  assertIncludes(serverSource, 'CORS_WHITELIST', 'Missing CORS_WHITELIST');\n   223→});\n   224→\n   225→test('should include localhost in whitelist', () => {\n   226→  assertIncludes(serverSource, \"'http://localhost:3847'\", 'Missing localhost');\n   227→  assertIncludes(serverSource, \"'https://localhost:3847'\", 'Missing https localhost');\n   228→});\n   229→\n   230→test('should include 127.0.0.1 in whitelist', () => {\n   231→  assertIncludes(serverSource, \"'http://127.0.0.1:3847'\", 'Missing 127.0.0.1');\n   232→  assertIncludes(serverSource, \"'https://127.0.0.1:3847'\", 'Missing https 127.0.0.1');\n   233→});\n   234→\n   235→test('should include production domains in whitelist', () => {\n   236→  assertIncludes(serverSource, \"'https://splice.app'\", 'Missing splice.app');\n   237→  assertIncludes(serverSource, \"'https://splice-api-production.up.railway.app'\", 'Missing Railway domain');\n   238→});\n   239→\n   240→test('should include Adobe plugin protocols', () => {\n   241→  assertIncludes(serverSource, \"'file://'\", 'Missing file:// protocol');\n   242→  assertIncludes(serverSource, \"'bolt://'\", 'Missing bolt:// protocol');\n   243→});\n   244→\n   245→test('should have custom CORS origin function', () => {\n   246→  assertIncludes(serverSource, 'origin: function (origin, callback)', 'Missing custom origin function');\n   247→});\n   248→\n   249→test('should allow requests with no origin', () => {\n   250→  assertIncludes(serverSource, 'if (!origin)', 'Missing no-origin check');\n   251→  assertIncludes(serverSource, 'callback(null, true)', 'Missing allow callback');\n   252→});\n   253→\n   254→test('should reject non-whitelisted origins in production', () => {\n   255→  assertIncludes(serverSource, \"callback(new Error('Not allowed by CORS'))\", 'Missing CORS rejection');\n   256→});\n   257→\n   258→test('should log blocked CORS requests', () => {\n   259→  assertIncludes(serverSource, '[CORS] Blocked request', 'Missing CORS block logging');\n   260→});\n   261→\n   262→test('should allow non-whitelisted origins in dev with warning', () => {\n   263→  assertIncludes(serverSource, '[CORS] Non-whitelisted origin in dev', 'Missing dev warning');\n   264→});\n   265→\n   266→test('should include Authorization header in allowed headers', () => {\n   267→  assertIncludes(serverSource, \"'Authorization'\", 'Missing Authorization in allowedHeaders');\n   268→});\n   269→\n   270→// =============================================================================\n   271→// Test Suite 4: Helmet Security Headers\n   272→// =============================================================================\n   273→\n   274→console.log('\\n4. Helmet Security Headers');\n   275→\n   276→test('should require helmet', () => {\n   277→  assertIncludes(serverSource, \"require('helmet')\", 'Not requiring helmet');\n   278→});\n   279→\n   280→test('should use helmet middleware', () => {\n   281→  assertIncludes(serverSource, 'app.use(helmet', 'Not using helmet middleware');\n   282→});\n   283→\n   284→test('should configure Content-Security-Policy', () => {\n   285→  assertIncludes(serverSource, 'contentSecurityPolicy', 'Missing CSP configuration');\n   286→  assertIncludes(serverSource, 'defaultSrc', 'Missing defaultSrc directive');\n   287→  assertIncludes(serverSource, 'scriptSrc', 'Missing scriptSrc directive');\n   288→});\n   289→\n   290→test('should configure HSTS', () => {\n   291→  assertIncludes(serverSource, 'hsts:', 'Missing HSTS configuration');\n   292→  assertIncludes(serverSource, 'maxAge:', 'Missing HSTS maxAge');\n   293→  assertIncludes(serverSource, 'includeSubDomains', 'Missing includeSubDomains');\n   294→});\n   295→\n   296→test('should configure referrer policy', () => {\n   297→  assertIncludes(serverSource, 'referrerPolicy', 'Missing referrer policy');\n   298→  assertIncludes(serverSource, 'strict-origin-when-cross-origin', 'Missing referrer policy value');\n   299→});\n   300→\n   301→test('should enable noSniff', () => {\n   302→  assertIncludes(serverSource, 'noSniff: true', 'Missing noSniff');\n   303→});\n   304→\n   305→test('should enable xssFilter', () => {\n   306→  assertIncludes(serverSource, 'xssFilter: true', 'Missing xssFilter');\n   307→});\n   308→\n   309→test('should hide X-Powered-By', () => {\n   310→  assertIncludes(serverSource, 'hidePoweredBy: true', 'Missing hidePoweredBy');\n   311→});\n   312→\n   313→test('should allow API connections in CSP', () => {\n   314→  assertIncludes(serverSource, 'connectSrc', 'Missing connectSrc');\n   315→  assertIncludes(serverSource, \"'https://api.stripe.com'\", 'Missing Stripe in CSP');\n   316→  assertIncludes(serverSource, \"'https://api.openai.com'\", 'Missing OpenAI in CSP');\n   317→});\n   318→\n   319→// =============================================================================\n   320→// Test Suite 5: License Key Security\n   321→// =============================================================================\n   322→\n   323→console.log('\\n5. License Key Security');\n   324→\n   325→test('should mask license keys in webhook logs', () => {\n   326→  assertIncludes(serverSource, 'maskSensitiveData(licenseResult.key)', 'Missing masked license key in logs');\n   327→});\n   328→\n   329→test('should mask customer IDs in logs', () => {\n   330→  // Check license routes for masking customer IDs\n   331→  assertIncludes(licenseRoutesSource, 'maskSensitiveData', 'Missing maskSensitiveData usage');\n   332→});\n   333→\n   334→test('should mask emails in logs', () => {\n   335→  // Check license routes for masking emails\n   336→  assertIncludes(licenseRoutesSource, 'maskSensitiveData(email)', 'Missing masked email in license routes');\n   337→});\n   338→\n   339→test('should NOT return license key in lookup response', () => {\n   340→  // The secure lookup should send via email, not return in response\n   341→  assertIncludes(licenseRoutesSource, 'emailSent: true', 'Missing emailSent flag');\n   342→  assertIncludes(licenseRoutesSource, 'sent to your email address', 'Missing email delivery message');\n   343→});\n   344→\n   345→test('should prevent email enumeration in lookup', () => {\n   346→  // Check license routes for enumeration protection\n   347→  assertIncludes(licenseRoutesSource, \"Don't reveal if email exists\", 'Missing enumeration protection comment');\n   348→  assertIncludes(licenseRoutesSource, 'If an account exists with this email', 'Missing generic message');\n   349→});\n   350→\n   351→test('should log license lookup attempts (masked)', () => {\n   352→  assertIncludes(licenseRoutesSource, 'License lookup attempt for unknown email', 'Missing lookup logging');\n   353→});\n   354→\n   355→// =============================================================================\n   356→// Test Suite 6: Authentication Endpoints\n   357→// =============================================================================\n   358→\n   359→console.log('\\n6. Authentication Endpoints');\n   360→\n   361→test('should have POST /login endpoint in auth routes', () => {\n   362→  assertIncludes(authRoutesSource, \"router.post('/login'\", 'Missing /login endpoint in auth routes');\n   363→});\n   364→\n   365→test('should validate license key in login', () => {\n   366→  assertIncludes(authRoutesSource, 'licenseService.activateLicense', 'Missing license activation in login');\n   367→});\n   368→\n   369→test('should return JWT token on successful login', () => {\n   370→  assertIncludes(authRoutesSource, 'generateToken(licenseResult.customerId', 'Missing token generation');\n   371→  assertIncludes(authRoutesSource, \"token: tokenResult.token\", 'Missing token in response');\n   372→});\n   373→\n   374→test('should return refresh token on login', () => {\n   375→  assertIncludes(authRoutesSource, 'generateRefreshToken(licenseResult.customerId', 'Missing refresh token');\n   376→  assertIncludes(authRoutesSource, 'refreshToken: refreshResult.refreshToken', 'Missing refresh token in response');\n   377→});\n   378→\n   379→test('should have POST /refresh endpoint in auth routes', () => {\n   380→  assertIncludes(authRoutesSource, \"router.post('/refresh'\", 'Missing /refresh endpoint in auth routes');\n   381→});\n   382→\n   383→test('should validate refresh token type', () => {\n   384→  assertIncludes(authRoutesSource, \"decoded.type !== 'refresh'\", 'Missing refresh token type check');\n   385→});\n   386→\n   387→test('should have POST /logout endpoint in auth routes', () => {\n   388→  assertIncludes(authRoutesSource, \"router.post('/logout'\", 'Missing /logout endpoint in auth routes');\n   389→});\n   390→\n   391→test('should use authenticateToken middleware on logout', () => {\n   392→  assertIncludes(authRoutesSource, \"'/logout', authenticateToken\", 'Missing auth middleware on logout');\n   393→});\n   394→\n   395→// =============================================================================\n   396→// Test Suite 7: Credits Endpoint JWT Support\n   397→// =============================================================================\n   398→\n   399→console.log('\\n7. Credits Endpoint JWT Support');\n   400→\n   401→test('should support JWT in /credits endpoint', () => {\n   402→  // Check billing routes for authorization header check\n   403→  assertTrue(\n   404→    billingRoutesSource.includes(\"headers['authorization']\") || billingRoutesSource.includes('headers[\"authorization\"]'),\n   405→    'Missing JWT check in billing routes'\n   406→  );\n   407→});\n   408→\n   409→test('should support JWT in /usage-history endpoint', () => {\n   410→  // Check billing routes for authorization header in usage-history\n   411→  const usageHistorySection = billingRoutesSource.substring(\n   412→    billingRoutesSource.indexOf(\"router.get('/usage-history'\"),\n   413→    billingRoutesSource.length\n   414→  );\n   415→  assertTrue(\n   416→    usageHistorySection.includes(\"headers['authorization']\") || usageHistorySection.includes('headers[\"authorization\"]'),\n   417→    'Missing JWT check in /usage-history'\n   418→  );\n   419→});\n   420→\n   421→test('should fallback to legacy header in credits endpoints', () => {\n   422→  // Check billing routes for legacy header fallback\n   423→  assertIncludes(billingRoutesSource, \"x-stripe-customer-id\", 'Missing legacy header fallback');\n   424→});\n   425→\n   426→// =============================================================================\n   427→// Test Suite 8: Server Security Hardening\n   428→// =============================================================================\n   429→\n   430→console.log('\\n8. Server Security Hardening');\n   431→\n   432→test('should check for production environment', () => {\n   433→  assertIncludes(serverSource, 'isProduction', 'Missing production check');\n   434→  assertIncludes(serverSource, \"process.env.NODE_ENV === 'production'\", 'Missing NODE_ENV check');\n   435→});\n   436→\n   437→test('should warn about unsigned webhooks in production', () => {\n   438→  assertIncludes(serverSource, 'CRITICAL: STRIPE_WEBHOOK_SECRET not set in production', 'Missing webhook secret warning');\n   439→});\n   440→\n   441→test('should reject unsigned webhooks in production', () => {\n   442→  assertIncludes(serverSource, \"if (isProduction)\", 'Missing production check for webhooks');\n   443→  assertIncludes(serverSource, \"Webhook configuration error\", 'Missing webhook error');\n   444→});\n   445→\n   446→// =============================================================================\n   447→// Summary\n   448→// =============================================================================\n   449→\n   450→console.log('\\n=== Security Test Summary ===');\n   451→console.log(`  Passed: ${passCount}`);\n   452→console.log(`  Failed: ${failCount}`);\n   453→console.log(`  Total: ${passCount + failCount}`);\n   454→\n   455→if (failCount > 0) {\n   456→  console.log('\\n\\u274C Some security tests failed');\n   457→  process.exit(1);\n   458→} else {\n   459→  console.log('\\n\\u2713 All security tests passed');\n   460→  process.exit(0);\n   461→}\n   462→\n\n</system-reminder>\n"}]},"uuid":"4e127274-63ed-4ef2-8ec2-8f079568f423","timestamp":"2025-12-30T01:04:22.317Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/tests/security.test.js","content":"/**\n * Security Tests - Comprehensive security vulnerability verification\n *\n * Tests for:\n * 1. JWT Authentication - Token generation, validation, expiration\n * 2. License Key Security - Masked logs, email-only delivery\n * 3. CORS Whitelist - Origin validation\n * 4. Security Headers - Helmet configuration\n * 5. Rate Limiter Auth - JWT vs legacy header handling\n */\n\n// const assert = require('assert'); // Not currently used\nconst fs = require('fs');\nconst path = require('path');\n\n// =============================================================================\n// Test Framework\n// =============================================================================\n\nlet passCount = 0;\nlet failCount = 0;\n\nfunction test(name, fn) {\n  try {\n    fn();\n    passCount++;\n    console.log(`  \\u2713 ${name}`);\n  } catch (err) {\n    failCount++;\n    console.log(`  \\u2717 ${name}`);\n    console.log(`    Error: ${err.message}`);\n  }\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction _assertEqual(actual, expected, message = '') {\n  if (actual !== expected) {\n    throw new Error(`${message}: Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);\n  }\n}\n\nfunction assertTrue(condition, message = '') {\n  if (!condition) {\n    throw new Error(`${message}: Expected true, got false`);\n  }\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction _assertFalse(condition, message = '') {\n  if (condition) {\n    throw new Error(`${message}: Expected false, got true`);\n  }\n}\n\nfunction assertIncludes(str, substr, message = '') {\n  if (!str || !str.includes(substr)) {\n    throw new Error(`${message}: String does not include \"${substr}\"`);\n  }\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction _assertNotIncludes(str, substr, message = '') {\n  if (str && str.includes(substr)) {\n    throw new Error(`${message}: String should not include \"${substr}\"`);\n  }\n}\n\n// =============================================================================\n// Load Source Files\n// =============================================================================\n\nlet authSource = '';\nlet rateLimiterSource = '';\nlet serverSource = '';\nlet authRoutesSource = '';\nlet billingRoutesSource = '';\nlet licenseRoutesSource = '';\n\ntry {\n  authSource = fs.readFileSync(path.join(__dirname, '../middleware/auth.js'), 'utf8');\n  rateLimiterSource = fs.readFileSync(path.join(__dirname, '../middleware/rateLimiter.js'), 'utf8');\n  serverSource = fs.readFileSync(path.join(__dirname, '../server.js'), 'utf8');\n  authRoutesSource = fs.readFileSync(path.join(__dirname, '../routes/auth.js'), 'utf8');\n  billingRoutesSource = fs.readFileSync(path.join(__dirname, '../routes/billing.js'), 'utf8');\n  licenseRoutesSource = fs.readFileSync(path.join(__dirname, '../routes/license.js'), 'utf8');\n} catch (err) {\n  console.error('Failed to read source files:', err.message);\n  process.exit(1);\n}\n\n// =============================================================================\n// Test Suite 1: JWT Authentication Middleware\n// =============================================================================\n\nconsole.log('\\n=== Security Tests ===\\n');\nconsole.log('1. JWT Authentication Middleware');\n\ntest('should export generateToken function', () => {\n  assertIncludes(authSource, 'function generateToken', 'Missing generateToken');\n  assertIncludes(authSource, \"module.exports\", 'Missing exports');\n  assertIncludes(authSource, \"generateToken\", 'generateToken not exported');\n});\n\ntest('should export generateRefreshToken function', () => {\n  assertIncludes(authSource, 'function generateRefreshToken', 'Missing generateRefreshToken');\n  assertIncludes(authSource, \"generateRefreshToken\", 'generateRefreshToken not exported');\n});\n\ntest('should export verifyToken function', () => {\n  assertIncludes(authSource, 'function verifyToken', 'Missing verifyToken');\n  assertIncludes(authSource, \"verifyToken\", 'verifyToken not exported');\n});\n\ntest('should export authenticateToken middleware', () => {\n  assertIncludes(authSource, 'function authenticateToken', 'Missing authenticateToken');\n  assertIncludes(authSource, \"authenticateToken\", 'authenticateToken not exported');\n});\n\ntest('should use jsonwebtoken library', () => {\n  assertIncludes(authSource, \"require('jsonwebtoken')\", 'Not using jsonwebtoken');\n});\n\ntest('should have JWT_SECRET configuration', () => {\n  assertIncludes(authSource, 'JWT_SECRET', 'Missing JWT_SECRET');\n  assertIncludes(authSource, 'process.env.JWT_SECRET', 'JWT_SECRET not from env');\n});\n\ntest('should have JWT expiration configuration', () => {\n  assertIncludes(authSource, 'JWT_EXPIRES_IN', 'Missing JWT_EXPIRES_IN');\n  assertIncludes(authSource, 'expiresIn', 'Missing expiresIn in sign');\n});\n\ntest('should validate Stripe customer ID format in generateToken', () => {\n  assertIncludes(authSource, \"startsWith('cus_')\", 'Missing cus_ validation');\n});\n\ntest('should handle TokenExpiredError', () => {\n  assertIncludes(authSource, 'TokenExpiredError', 'Missing TokenExpiredError handling');\n});\n\ntest('should handle JsonWebTokenError', () => {\n  assertIncludes(authSource, 'JsonWebTokenError', 'Missing JsonWebTokenError handling');\n});\n\ntest('should extract Bearer token from Authorization header', () => {\n  assertIncludes(authSource, 'function extractBearerToken', 'Missing extractBearerToken');\n  assertIncludes(authSource, \"toLowerCase() !== 'bearer'\", 'Missing Bearer validation');\n});\n\ntest('should warn about default JWT secret in production', () => {\n  assertIncludes(authSource, 'CRITICAL: JWT_SECRET not set in production', 'Missing production warning');\n});\n\ntest('should support legacy x-stripe-customer-id header (deprecated)', () => {\n  assertIncludes(authSource, 'x-stripe-customer-id', 'Missing legacy header support');\n  assertIncludes(authSource, 'DEPRECATED', 'Missing deprecation warning');\n});\n\ntest('should export maskSensitiveData function', () => {\n  assertIncludes(authSource, 'function maskSensitiveData', 'Missing maskSensitiveData');\n  assertIncludes(authSource, \"maskSensitiveData\", 'maskSensitiveData not exported');\n});\n\ntest('should mask SPLICE license keys properly', () => {\n  assertIncludes(authSource, \"startsWith('SPLICE-')\", 'Missing SPLICE key detection');\n  assertIncludes(authSource, '****', 'Missing masking pattern');\n});\n\ntest('should mask customer IDs properly', () => {\n  assertIncludes(authSource, \"startsWith('cus_')\", 'Missing cus_ detection');\n});\n\ntest('should mask emails properly', () => {\n  assertIncludes(authSource, \"includes('@')\", 'Missing email detection');\n});\n\n// =============================================================================\n// Test Suite 2: Rate Limiter JWT Integration\n// =============================================================================\n\nconsole.log('\\n2. Rate Limiter JWT Integration');\n\ntest('should import auth middleware in rateLimiter', () => {\n  assertIncludes(rateLimiterSource, \"require('./auth')\", 'Not importing auth middleware');\n});\n\ntest('should import verifyToken in rateLimiter', () => {\n  assertIncludes(rateLimiterSource, 'verifyToken', 'Not using verifyToken');\n});\n\ntest('should import extractBearerToken in rateLimiter', () => {\n  assertIncludes(rateLimiterSource, 'extractBearerToken', 'Not using extractBearerToken');\n});\n\ntest('should check Authorization header first', () => {\n  assertIncludes(rateLimiterSource, \"headers['authorization']\", 'Not checking Authorization header');\n});\n\ntest('should validate legacy customer ID format with regex', () => {\n  assertIncludes(rateLimiterSource, \"match(/^cus_[a-zA-Z0-9]\", 'Missing customer ID format validation');\n});\n\ntest('should log deprecation warning for legacy auth', () => {\n  assertIncludes(rateLimiterSource, 'DEPRECATED', 'Missing deprecation warning');\n});\n\ntest('should set isLegacyAuth flag for legacy header', () => {\n  assertIncludes(rateLimiterSource, 'req.isLegacyAuth = true', 'Missing isLegacyAuth flag');\n});\n\ntest('should return 401 for invalid JWT token', () => {\n  assertIncludes(rateLimiterSource, 'Invalid or expired token', 'Missing invalid token error');\n});\n\n// =============================================================================\n// Test Suite 3: CORS Whitelist\n// =============================================================================\n\nconsole.log('\\n3. CORS Whitelist');\n\ntest('should define CORS_WHITELIST array', () => {\n  assertIncludes(serverSource, 'CORS_WHITELIST', 'Missing CORS_WHITELIST');\n});\n\ntest('should include localhost in whitelist', () => {\n  assertIncludes(serverSource, \"'http://localhost:3847'\", 'Missing localhost');\n  assertIncludes(serverSource, \"'https://localhost:3847'\", 'Missing https localhost');\n});\n\ntest('should include 127.0.0.1 in whitelist', () => {\n  assertIncludes(serverSource, \"'http://127.0.0.1:3847'\", 'Missing 127.0.0.1');\n  assertIncludes(serverSource, \"'https://127.0.0.1:3847'\", 'Missing https 127.0.0.1');\n});\n\ntest('should include production domains in whitelist', () => {\n  assertIncludes(serverSource, \"'https://splice.app'\", 'Missing splice.app');\n  assertIncludes(serverSource, \"'https://splice-api-production.up.railway.app'\", 'Missing Railway domain');\n});\n\ntest('should include Adobe plugin protocols', () => {\n  assertIncludes(serverSource, \"'file://'\", 'Missing file:// protocol');\n  assertIncludes(serverSource, \"'bolt://'\", 'Missing bolt:// protocol');\n});\n\ntest('should have custom CORS origin function', () => {\n  assertIncludes(serverSource, 'origin: function (origin, callback)', 'Missing custom origin function');\n});\n\ntest('should allow requests with no origin', () => {\n  assertIncludes(serverSource, 'if (!origin)', 'Missing no-origin check');\n  assertIncludes(serverSource, 'callback(null, true)', 'Missing allow callback');\n});\n\ntest('should reject non-whitelisted origins in production', () => {\n  assertIncludes(serverSource, \"callback(new Error('Not allowed by CORS'))\", 'Missing CORS rejection');\n});\n\ntest('should log blocked CORS requests', () => {\n  assertIncludes(serverSource, '[CORS] Blocked request', 'Missing CORS block logging');\n});\n\ntest('should allow non-whitelisted origins in dev with warning', () => {\n  assertIncludes(serverSource, '[CORS] Non-whitelisted origin in dev', 'Missing dev warning');\n});\n\ntest('should include Authorization header in allowed headers', () => {\n  assertIncludes(serverSource, \"'Authorization'\", 'Missing Authorization in allowedHeaders');\n});\n\n// =============================================================================\n// Test Suite 4: Helmet Security Headers\n// =============================================================================\n\nconsole.log('\\n4. Helmet Security Headers');\n\ntest('should require helmet', () => {\n  assertIncludes(serverSource, \"require('helmet')\", 'Not requiring helmet');\n});\n\ntest('should use helmet middleware', () => {\n  assertIncludes(serverSource, 'app.use(helmet', 'Not using helmet middleware');\n});\n\ntest('should configure Content-Security-Policy', () => {\n  assertIncludes(serverSource, 'contentSecurityPolicy', 'Missing CSP configuration');\n  assertIncludes(serverSource, 'defaultSrc', 'Missing defaultSrc directive');\n  assertIncludes(serverSource, 'scriptSrc', 'Missing scriptSrc directive');\n});\n\ntest('should configure HSTS', () => {\n  assertIncludes(serverSource, 'hsts:', 'Missing HSTS configuration');\n  assertIncludes(serverSource, 'maxAge:', 'Missing HSTS maxAge');\n  assertIncludes(serverSource, 'includeSubDomains', 'Missing includeSubDomains');\n});\n\ntest('should configure referrer policy', () => {\n  assertIncludes(serverSource, 'referrerPolicy', 'Missing referrer policy');\n  assertIncludes(serverSource, 'strict-origin-when-cross-origin', 'Missing referrer policy value');\n});\n\ntest('should enable noSniff', () => {\n  assertIncludes(serverSource, 'noSniff: true', 'Missing noSniff');\n});\n\ntest('should enable xssFilter', () => {\n  assertIncludes(serverSource, 'xssFilter: true', 'Missing xssFilter');\n});\n\ntest('should hide X-Powered-By', () => {\n  assertIncludes(serverSource, 'hidePoweredBy: true', 'Missing hidePoweredBy');\n});\n\ntest('should allow API connections in CSP', () => {\n  assertIncludes(serverSource, 'connectSrc', 'Missing connectSrc');\n  assertIncludes(serverSource, \"'https://api.stripe.com'\", 'Missing Stripe in CSP');\n  assertIncludes(serverSource, \"'https://api.openai.com'\", 'Missing OpenAI in CSP');\n});\n\n// =============================================================================\n// Test Suite 5: License Key Security\n// =============================================================================\n\nconsole.log('\\n5. License Key Security');\n\ntest('should mask license keys in webhook logs', () => {\n  assertIncludes(serverSource, 'maskSensitiveData(licenseResult.key)', 'Missing masked license key in logs');\n});\n\ntest('should mask customer IDs in logs', () => {\n  // Check license routes for masking customer IDs\n  assertIncludes(licenseRoutesSource, 'maskSensitiveData', 'Missing maskSensitiveData usage');\n});\n\ntest('should mask emails in logs', () => {\n  // Check license routes for masking emails\n  assertIncludes(licenseRoutesSource, 'maskSensitiveData(email)', 'Missing masked email in license routes');\n});\n\ntest('should NOT return license key in lookup response', () => {\n  // The secure lookup should send via email, not return in response\n  assertIncludes(licenseRoutesSource, 'emailSent: true', 'Missing emailSent flag');\n  assertIncludes(licenseRoutesSource, 'sent to your email address', 'Missing email delivery message');\n});\n\ntest('should prevent email enumeration in lookup', () => {\n  // Check license routes for enumeration protection\n  assertIncludes(licenseRoutesSource, \"Don't reveal if email exists\", 'Missing enumeration protection comment');\n  assertIncludes(licenseRoutesSource, 'If an account exists with this email', 'Missing generic message');\n});\n\ntest('should log license lookup attempts (masked)', () => {\n  assertIncludes(licenseRoutesSource, 'License lookup attempt for unknown email', 'Missing lookup logging');\n});\n\n// =============================================================================\n// Test Suite 6: Authentication Endpoints\n// =============================================================================\n\nconsole.log('\\n6. Authentication Endpoints');\n\ntest('should have POST /login endpoint in auth routes', () => {\n  assertIncludes(authRoutesSource, \"router.post('/login'\", 'Missing /login endpoint in auth routes');\n});\n\ntest('should validate license key in login', () => {\n  assertIncludes(authRoutesSource, 'licenseService.activateLicense', 'Missing license activation in login');\n});\n\ntest('should return JWT token on successful login', () => {\n  assertIncludes(authRoutesSource, 'generateToken(licenseResult.customerId', 'Missing token generation');\n  assertIncludes(authRoutesSource, \"token: tokenResult.token\", 'Missing token in response');\n});\n\ntest('should return refresh token on login', () => {\n  assertIncludes(authRoutesSource, 'generateRefreshToken(licenseResult.customerId', 'Missing refresh token');\n  assertIncludes(authRoutesSource, 'refreshToken: refreshResult.refreshToken', 'Missing refresh token in response');\n});\n\ntest('should have POST /refresh endpoint in auth routes', () => {\n  assertIncludes(authRoutesSource, \"router.post('/refresh'\", 'Missing /refresh endpoint in auth routes');\n});\n\ntest('should validate refresh token type', () => {\n  assertIncludes(authRoutesSource, \"decoded.type !== 'refresh'\", 'Missing refresh token type check');\n});\n\ntest('should have POST /logout endpoint in auth routes', () => {\n  assertIncludes(authRoutesSource, \"router.post('/logout'\", 'Missing /logout endpoint in auth routes');\n});\n\ntest('should use authenticateToken middleware on logout', () => {\n  assertIncludes(authRoutesSource, \"'/logout', authenticateToken\", 'Missing auth middleware on logout');\n});\n\n// =============================================================================\n// Test Suite 7: Credits Endpoint JWT Support\n// =============================================================================\n\nconsole.log('\\n7. Credits Endpoint JWT Support');\n\ntest('should support JWT in /credits endpoint', () => {\n  // Check billing routes for authorization header check\n  assertTrue(\n    billingRoutesSource.includes(\"headers['authorization']\") || billingRoutesSource.includes('headers[\"authorization\"]'),\n    'Missing JWT check in billing routes'\n  );\n});\n\ntest('should support JWT in /usage-history endpoint', () => {\n  // Check billing routes for authorization header in usage-history\n  const usageHistorySection = billingRoutesSource.substring(\n    billingRoutesSource.indexOf(\"router.get('/usage-history'\"),\n    billingRoutesSource.length\n  );\n  assertTrue(\n    usageHistorySection.includes(\"headers['authorization']\") || usageHistorySection.includes('headers[\"authorization\"]'),\n    'Missing JWT check in /usage-history'\n  );\n});\n\ntest('should fallback to legacy header in credits endpoints', () => {\n  // Check billing routes for legacy header fallback\n  assertIncludes(billingRoutesSource, \"x-stripe-customer-id\", 'Missing legacy header fallback');\n});\n\n// =============================================================================\n// Test Suite 8: Server Security Hardening\n// =============================================================================\n\nconsole.log('\\n8. Server Security Hardening');\n\ntest('should check for production environment', () => {\n  assertIncludes(serverSource, 'isProduction', 'Missing production check');\n  assertIncludes(serverSource, \"process.env.NODE_ENV === 'production'\", 'Missing NODE_ENV check');\n});\n\ntest('should warn about unsigned webhooks in production', () => {\n  assertIncludes(serverSource, 'CRITICAL: STRIPE_WEBHOOK_SECRET not set in production', 'Missing webhook secret warning');\n});\n\ntest('should reject unsigned webhooks in production', () => {\n  assertIncludes(serverSource, \"if (isProduction)\", 'Missing production check for webhooks');\n  assertIncludes(serverSource, \"Webhook configuration error\", 'Missing webhook error');\n});\n\n// =============================================================================\n// Summary\n// =============================================================================\n\nconsole.log('\\n=== Security Test Summary ===');\nconsole.log(`  Passed: ${passCount}`);\nconsole.log(`  Failed: ${failCount}`);\nconsole.log(`  Total: ${passCount + failCount}`);\n\nif (failCount > 0) {\n  console.log('\\n\\u274C Some security tests failed');\n  process.exit(1);\n} else {\n  console.log('\\n\\u2713 All security tests passed');\n  process.exit(0);\n}\n","numLines":462,"startLine":1,"totalLines":462}}}
{"parentUuid":"4e127274-63ed-4ef2-8ec2-8f079568f423","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HiLuAgsPRgBDMgasnJAkK1","type":"tool_result","content":"     1→/**\n     2→ * E2E Authentication Tests\n     3→ *\n     4→ * Tests for authentication endpoints:\n     5→ * - POST /auth/login - successful login returns tokens\n     6→ * - POST /auth/login - invalid credentials returns 401\n     7→ * - POST /auth/refresh - valid refresh token returns new tokens\n     8→ * - POST /auth/refresh - invalid refresh token returns 401\n     9→ * - POST /auth/logout - blacklists token\n    10→ * - Protected route access with valid token\n    11→ * - Protected route rejection with blacklisted token\n    12→ * - Protected route rejection with expired token\n    13→ */\n    14→\n    15→const assert = require('assert');\n    16→const crypto = require('crypto');\n    17→\n    18→// =============================================================================\n    19→// Test Framework\n    20→// =============================================================================\n    21→\n    22→let passCount = 0;\n    23→let failCount = 0;\n    24→\n    25→function test(name, fn) {\n    26→  try {\n    27→    const result = fn();\n    28→    // Handle async tests\n    29→    if (result && typeof result.then === 'function') {\n    30→      return result\n    31→        .then(() => {\n    32→          passCount++;\n    33→          console.log(`  \\u2713 ${name}`);\n    34→        })\n    35→        .catch((err) => {\n    36→          failCount++;\n    37→          console.log(`  \\u2717 ${name}`);\n    38→          console.log(`    Error: ${err.message}`);\n    39→        });\n    40→    }\n    41→    passCount++;\n    42→    console.log(`  \\u2713 ${name}`);\n    43→  } catch (err) {\n    44→    failCount++;\n    45→    console.log(`  \\u2717 ${name}`);\n    46→    console.log(`    Error: ${err.message}`);\n    47→  }\n    48→}\n    49→\n    50→function assertEqual(actual, expected, message = '') {\n    51→  if (actual !== expected) {\n    52→    throw new Error(`${message}: Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);\n    53→  }\n    54→}\n    55→\n    56→function assertTrue(condition, message = '') {\n    57→  if (!condition) {\n    58→    throw new Error(`${message}: Expected true, got false`);\n    59→  }\n    60→}\n    61→\n    62→function assertFalse(condition, message = '') {\n    63→  if (condition) {\n    64→    throw new Error(`${message}: Expected false, got true`);\n    65→  }\n    66→}\n    67→\n    68→function assertIncludes(str, substr, message = '') {\n    69→  if (!str || !str.includes(substr)) {\n    70→    throw new Error(`${message}: String does not include \"${substr}\"`);\n    71→  }\n    72→}\n    73→\n    74→// =============================================================================\n    75→// Mock Services and Middleware\n    76→// =============================================================================\n    77→\n    78→// In-memory token blacklist (mimics auth.js)\n    79→const tokenBlacklist = new Map();\n    80→\n    81→function blacklistToken(jti, exp) {\n    82→  if (!jti) return false;\n    83→  tokenBlacklist.set(jti, exp);\n    84→  return true;\n    85→}\n    86→\n    87→function isTokenBlacklisted(jti) {\n    88→  if (!jti) return false;\n    89→  return tokenBlacklist.has(jti);\n    90→}\n    91→\n    92→// Mock JWT functions (simplified versions for testing)\n    93→const JWT_SECRET = 'test-secret-for-auth-tests';\n    94→const JWT_EXPIRES_IN = '24h';\n    95→const JWT_REFRESH_EXPIRES_IN = '7d';\n    96→\n    97→function generateToken(stripeCustomerId, options = {}) {\n    98→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    99→    throw new Error('Invalid Stripe customer ID');\n   100→  }\n   101→\n   102→  const now = Math.floor(Date.now() / 1000);\n   103→  const jti = crypto.randomUUID();\n   104→  const payload = {\n   105→    sub: stripeCustomerId,\n   106→    type: 'access',\n   107→    tier: options.tier || 'starter',\n   108→    iat: now,\n   109→    exp: now + 86400, // 24 hours\n   110→    jti\n   111→  };\n   112→\n   113→  if (options.email) {\n   114→    payload.email = options.email;\n   115→  }\n   116→\n   117→  // Simplified token encoding (base64 JSON for testing)\n   118→  const token = Buffer.from(JSON.stringify(payload)).toString('base64');\n   119→\n   120→  return {\n   121→    token,\n   122→    expiresIn: JWT_EXPIRES_IN,\n   123→    tokenType: 'Bearer',\n   124→    payload // Include for testing\n   125→  };\n   126→}\n   127→\n   128→function generateRefreshToken(stripeCustomerId) {\n   129→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   130→    throw new Error('Invalid Stripe customer ID');\n   131→  }\n   132→\n   133→  const now = Math.floor(Date.now() / 1000);\n   134→  const jti = crypto.randomUUID();\n   135→  const payload = {\n   136→    sub: stripeCustomerId,\n   137→    type: 'refresh',\n   138→    iat: now,\n   139→    exp: now + 604800, // 7 days\n   140→    jti\n   141→  };\n   142→\n   143→  const refreshToken = Buffer.from(JSON.stringify(payload)).toString('base64');\n   144→\n   145→  return {\n   146→    refreshToken,\n   147→    expiresIn: JWT_REFRESH_EXPIRES_IN,\n   148→    payload // Include for testing\n   149→  };\n   150→}\n   151→\n   152→function verifyToken(token, options = {}) {\n   153→  const { checkBlacklist = true } = options;\n   154→\n   155→  try {\n   156→    const payload = JSON.parse(Buffer.from(token, 'base64').toString());\n   157→\n   158→    // Check expiration\n   159→    const now = Math.floor(Date.now() / 1000);\n   160→    if (payload.exp && payload.exp < now) {\n   161→      return null; // Token expired\n   162→    }\n   163→\n   164→    // Check blacklist\n   165→    if (checkBlacklist && payload.jti) {\n   166→      if (isTokenBlacklisted(payload.jti)) {\n   167→        return null;\n   168→      }\n   169→    }\n   170→\n   171→    return payload;\n   172→  } catch {\n   173→    return null;\n   174→  }\n   175→}\n   176→\n   177→function generateExpiredToken(stripeCustomerId) {\n   178→  const now = Math.floor(Date.now() / 1000);\n   179→  const jti = crypto.randomUUID();\n   180→  const payload = {\n   181→    sub: stripeCustomerId,\n   182→    type: 'access',\n   183→    tier: 'starter',\n   184→    iat: now - 86400, // 24 hours ago\n   185→    exp: now - 3600, // Expired 1 hour ago\n   186→    jti\n   187→  };\n   188→\n   189→  return Buffer.from(JSON.stringify(payload)).toString('base64');\n   190→}\n   191→\n   192→function extractBearerToken(authHeader) {\n   193→  if (!authHeader || typeof authHeader !== 'string') {\n   194→    return null;\n   195→  }\n   196→\n   197→  const parts = authHeader.split(' ');\n   198→  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n   199→    return null;\n   200→  }\n   201→\n   202→  return parts[1];\n   203→}\n   204→\n   205→// Mock license service\n   206→const mockLicenseKeys = new Map();\n   207→mockLicenseKeys.set('SPLICE-TEST-VALD-KEY1', {\n   208→  customerId: 'cus_testuser123456',\n   209→  email: 'test@example.com',\n   210→  isActive: true\n   211→});\n   212→mockLicenseKeys.set('SPLICE-DEAC-TIVE-KEY2', {\n   213→  customerId: 'cus_deactivated123',\n   214→  email: 'deactivated@example.com',\n   215→  isActive: false\n   216→});\n   217→\n   218→const mockLicenseService = {\n   219→  async activateLicenseKey(key) {\n   220→    const normalizedKey = (key || '').toUpperCase().trim();\n   221→    const license = mockLicenseKeys.get(normalizedKey);\n   222→\n   223→    if (!license) {\n   224→      return { success: false, error: 'License key not found' };\n   225→    }\n   226→\n   227→    if (!license.isActive) {\n   228→      return { success: false, error: 'License key has been deactivated' };\n   229→    }\n   230→\n   231→    return {\n   232→      success: true,\n   233→      customerId: license.customerId,\n   234→      email: license.email\n   235→    };\n   236→  }\n   237→};\n   238→\n   239→// Mock usage tracking service\n   240→const mockUsageTracking = {\n   241→  async getBalance(customerId) {\n   242→    return {\n   243→      tier: 'pro',\n   244→      hoursRemaining: 10.5,\n   245→      musicCredits: 50\n   246→    };\n   247→  }\n   248→};\n   249→\n   250→// =============================================================================\n   251→// Simulated HTTP Request/Response\n   252→// =============================================================================\n   253→\n   254→class MockRequest {\n   255→  constructor(options = {}) {\n   256→    this.body = options.body || {};\n   257→    this.headers = options.headers || {};\n   258→    this.params = options.params || {};\n   259→    this.query = options.query || {};\n   260→    this.stripeCustomerId = null;\n   261→    this.tokenData = null;\n   262→    this.rawToken = null;\n   263→    this.isLegacyAuth = false;\n   264→  }\n   265→}\n   266→\n   267→class MockResponse {\n   268→  constructor() {\n   269→    this.statusCode = 200;\n   270→    this.data = null;\n   271→    this._ended = false;\n   272→  }\n   273→\n   274→  status(code) {\n   275→    this.statusCode = code;\n   276→    return this;\n   277→  }\n   278→\n   279→  json(data) {\n   280→    this.data = data;\n   281→    this._ended = true;\n   282→    return this;\n   283→  }\n   284→\n   285→  end() {\n   286→    this._ended = true;\n   287→    return this;\n   288→  }\n   289→}\n   290→\n   291→// =============================================================================\n   292→// Simulated Route Handlers (mimicking routes/auth.js)\n   293→// =============================================================================\n   294→\n   295→async function handleLogin(req, res) {\n   296→  const { licenseKey } = req.body;\n   297→\n   298→  if (!licenseKey) {\n   299→    return res.status(400).json({\n   300→      error: 'License key required',\n   301→      message: 'Please provide your license key to log in'\n   302→    });\n   303→  }\n   304→\n   305→  try {\n   306→    const licenseResult = await mockLicenseService.activateLicenseKey(licenseKey);\n   307→\n   308→    if (!licenseResult.success) {\n   309→      return res.status(401).json({\n   310→        error: 'Invalid license key',\n   311→        message: licenseResult.error || 'The license key is invalid or expired'\n   312→      });\n   313→    }\n   314→\n   315→    const balance = await mockUsageTracking.getBalance(licenseResult.customerId);\n   316→\n   317→    const tokenResult = generateToken(licenseResult.customerId, {\n   318→      tier: balance.tier,\n   319→      email: licenseResult.email\n   320→    });\n   321→    const refreshResult = generateRefreshToken(licenseResult.customerId);\n   322→\n   323→    res.json({\n   324→      success: true,\n   325→      token: tokenResult.token,\n   326→      tokenType: tokenResult.tokenType,\n   327→      expiresIn: tokenResult.expiresIn,\n   328→      refreshToken: refreshResult.refreshToken,\n   329→      customerId: licenseResult.customerId,\n   330→      tier: balance.tier,\n   331→      hoursRemaining: balance.hoursRemaining\n   332→    });\n   333→  } catch (err) {\n   334→    res.status(500).json({ error: 'Authentication failed. Please try again.' });\n   335→  }\n   336→}\n   337→\n   338→async function handleRefresh(req, res) {\n   339→  const { refreshToken } = req.body;\n   340→\n   341→  if (!refreshToken) {\n   342→    return res.status(400).json({\n   343→      error: 'Refresh token required'\n   344→    });\n   345→  }\n   346→\n   347→  try {\n   348→    const decoded = verifyToken(refreshToken);\n   349→\n   350→    if (!decoded || decoded.type !== 'refresh') {\n   351→      return res.status(401).json({\n   352→        error: 'Invalid refresh token',\n   353→        message: 'Please log in again'\n   354→      });\n   355→    }\n   356→\n   357→    const balance = await mockUsageTracking.getBalance(decoded.sub);\n   358→\n   359→    const tokenResult = generateToken(decoded.sub, {\n   360→      tier: balance.tier\n   361→    });\n   362→\n   363→    res.json({\n   364→      success: true,\n   365→      token: tokenResult.token,\n   366→      tokenType: tokenResult.tokenType,\n   367→      expiresIn: tokenResult.expiresIn\n   368→    });\n   369→  } catch (err) {\n   370→    res.status(401).json({\n   371→      error: 'Failed to refresh token',\n   372→      message: 'Please log in again'\n   373→    });\n   374→  }\n   375→}\n   376→\n   377→function handleLogout(req, res) {\n   378→  const { refreshToken } = req.body;\n   379→\n   380→  // Blacklist the access token\n   381→  if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n   382→    blacklistToken(req.tokenData.jti, req.tokenData.exp);\n   383→  }\n   384→\n   385→  // Optionally blacklist the refresh token too\n   386→  if (refreshToken) {\n   387→    const decoded = verifyToken(refreshToken, { checkBlacklist: false });\n   388→    if (decoded && decoded.jti && decoded.exp) {\n   389→      blacklistToken(decoded.jti, decoded.exp);\n   390→    }\n   391→  }\n   392→\n   393→  res.json({\n   394→    success: true,\n   395→    message: 'Logged out successfully'\n   396→  });\n   397→}\n   398→\n   399→// Middleware to authenticate JWT tokens\n   400→function authenticateToken(req, res, next) {\n   401→  const authHeader = req.headers['authorization'];\n   402→  const token = extractBearerToken(authHeader);\n   403→\n   404→  if (token) {\n   405→    // First verify without blacklist check for specific error messages\n   406→    const decoded = verifyToken(token, { checkBlacklist: false });\n   407→\n   408→    if (!decoded || !decoded.sub) {\n   409→      return res.status(401).json({\n   410→        error: 'Invalid or expired token',\n   411→        message: 'Please log in again to continue'\n   412→      });\n   413→    }\n   414→\n   415→    // Check if token has been revoked (blacklisted)\n   416→    if (decoded.jti && isTokenBlacklisted(decoded.jti)) {\n   417→      return res.status(401).json({\n   418→        error: 'Token has been revoked',\n   419→        message: 'This session has been logged out. Please log in again.'\n   420→      });\n   421→    }\n   422→\n   423→    // Token is valid and not revoked\n   424→    req.stripeCustomerId = decoded.sub;\n   425→    req.tokenData = decoded;\n   426→    req.rawToken = token;\n   427→    return next();\n   428→  }\n   429→\n   430→  // Fallback: Legacy x-stripe-customer-id header\n   431→  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   432→  if (legacyCustomerId) {\n   433→    if (!legacyCustomerId.startsWith('cus_')) {\n   434→      return res.status(401).json({\n   435→        error: 'Invalid customer ID format',\n   436→        message: 'Customer ID must start with cus_'\n   437→      });\n   438→    }\n   439→\n   440→    req.stripeCustomerId = legacyCustomerId;\n   441→    req.isLegacyAuth = true;\n   442→    return next();\n   443→  }\n   444→\n   445→  // No authentication provided\n   446→  return res.status(401).json({\n   447→    error: 'Authentication required',\n   448→    message: 'Please provide a valid Bearer token in the Authorization header'\n   449→  });\n   450→}\n   451→\n   452→// Protected route handler for testing\n   453→function handleProtectedRoute(req, res) {\n   454→  res.json({\n   455→    success: true,\n   456→    customerId: req.stripeCustomerId,\n   457→    tier: req.tokenData?.tier || 'unknown'\n   458→  });\n   459→}\n   460→\n   461→// =============================================================================\n   462→// Test Suite\n   463→// =============================================================================\n   464→\n   465→async function runTests() {\n   466→  console.log('\\n=== Authentication E2E Tests ===\\n');\n   467→\n   468→  // =========================================================================\n   469→  // Test Suite 1: POST /auth/login\n   470→  // =========================================================================\n   471→  console.log('1. POST /auth/login - Login Tests');\n   472→\n   473→  await test('login with valid license key returns tokens', async () => {\n   474→    const req = new MockRequest({\n   475→      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n   476→    });\n   477→    const res = new MockResponse();\n   478→\n   479→    await handleLogin(req, res);\n   480→\n   481→    assertEqual(res.statusCode, 200, 'Status code');\n   482→    assertTrue(res.data.success, 'Success flag');\n   483→    assertTrue(res.data.token && res.data.token.length > 0, 'Token present');\n   484→    assertTrue(res.data.refreshToken && res.data.refreshToken.length > 0, 'Refresh token present');\n   485→    assertEqual(res.data.tokenType, 'Bearer', 'Token type');\n   486→    assertEqual(res.data.customerId, 'cus_testuser123456', 'Customer ID');\n   487→    assertEqual(res.data.tier, 'pro', 'Tier');\n   488→  });\n   489→\n   490→  await test('login with invalid license key returns 401', async () => {\n   491→    const req = new MockRequest({\n   492→      body: { licenseKey: 'SPLICE-INVA-LIDK-EY00' }\n   493→    });\n   494→    const res = new MockResponse();\n   495→\n   496→    await handleLogin(req, res);\n   497→\n   498→    assertEqual(res.statusCode, 401, 'Status code');\n   499→    assertEqual(res.data.error, 'Invalid license key', 'Error message');\n   500→  });\n   501→\n   502→  await test('login with deactivated license key returns 401', async () => {\n   503→    const req = new MockRequest({\n   504→      body: { licenseKey: 'SPLICE-DEAC-TIVE-KEY2' }\n   505→    });\n   506→    const res = new MockResponse();\n   507→\n   508→    await handleLogin(req, res);\n   509→\n   510→    assertEqual(res.statusCode, 401, 'Status code');\n   511→    assertIncludes(res.data.message, 'deactivated', 'Error mentions deactivation');\n   512→  });\n   513→\n   514→  await test('login without license key returns 400', async () => {\n   515→    const req = new MockRequest({\n   516→      body: {}\n   517→    });\n   518→    const res = new MockResponse();\n   519→\n   520→    await handleLogin(req, res);\n   521→\n   522→    assertEqual(res.statusCode, 400, 'Status code');\n   523→    assertEqual(res.data.error, 'License key required', 'Error message');\n   524→  });\n   525→\n   526→  // =========================================================================\n   527→  // Test Suite 2: POST /auth/refresh\n   528→  // =========================================================================\n   529→  console.log('\\n2. POST /auth/refresh - Token Refresh Tests');\n   530→\n   531→  await test('refresh with valid refresh token returns new tokens', async () => {\n   532→    // First get a valid refresh token\n   533→    const loginReq = new MockRequest({\n   534→      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n   535→    });\n   536→    const loginRes = new MockResponse();\n   537→    await handleLogin(loginReq, loginRes);\n   538→\n   539→    const refreshToken = loginRes.data.refreshToken;\n   540→\n   541→    // Now try to refresh\n   542→    const req = new MockRequest({\n   543→      body: { refreshToken }\n   544→    });\n   545→    const res = new MockResponse();\n   546→\n   547→    await handleRefresh(req, res);\n   548→\n   549→    assertEqual(res.statusCode, 200, 'Status code');\n   550→    assertTrue(res.data.success, 'Success flag');\n   551→    assertTrue(res.data.token && res.data.token.length > 0, 'New token present');\n   552→    assertEqual(res.data.tokenType, 'Bearer', 'Token type');\n   553→  });\n   554→\n   555→  await test('refresh with invalid refresh token returns 401', async () => {\n   556→    const req = new MockRequest({\n   557→      body: { refreshToken: 'invalid-token' }\n   558→    });\n   559→    const res = new MockResponse();\n   560→\n   561→    await handleRefresh(req, res);\n   562→\n   563→    assertEqual(res.statusCode, 401, 'Status code');\n   564→    assertEqual(res.data.error, 'Invalid refresh token', 'Error message');\n   565→  });\n   566→\n   567→  await test('refresh with access token (wrong type) returns 401', async () => {\n   568→    // Get an access token (not refresh token)\n   569→    const loginReq = new MockRequest({\n   570→      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n   571→    });\n   572→    const loginRes = new MockResponse();\n   573→    await handleLogin(loginReq, loginRes);\n   574→\n   575→    const accessToken = loginRes.data.token; // Access token, not refresh\n   576→\n   577→    const req = new MockRequest({\n   578→      body: { refreshToken: accessToken }\n   579→    });\n   580→    const res = new MockResponse();\n   581→\n   582→    await handleRefresh(req, res);\n   583→\n   584→    assertEqual(res.statusCode, 401, 'Status code');\n   585→    assertEqual(res.data.error, 'Invalid refresh token', 'Error message');\n   586→  });\n   587→\n   588→  await test('refresh without token returns 400', async () => {\n   589→    const req = new MockRequest({\n   590→      body: {}\n   591→    });\n   592→    const res = new MockResponse();\n   593→\n   594→    await handleRefresh(req, res);\n   595→\n   596→    assertEqual(res.statusCode, 400, 'Status code');\n   597→    assertEqual(res.data.error, 'Refresh token required', 'Error message');\n   598→  });\n   599→\n   600→  // =========================================================================\n   601→  // Test Suite 3: POST /auth/logout\n   602→  // =========================================================================\n   603→  console.log('\\n3. POST /auth/logout - Logout Tests');\n   604→\n   605→  await test('logout blacklists current token', async () => {\n   606→    // Login to get tokens\n   607→    const loginReq = new MockRequest({\n   608→      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n   609→    });\n   610→    const loginRes = new MockResponse();\n   611→    await handleLogin(loginReq, loginRes);\n   612→\n   613→    const accessToken = loginRes.data.token;\n   614→    const decoded = verifyToken(accessToken);\n   615→\n   616→    // Simulate authenticated request for logout\n   617→    const req = new MockRequest({\n   618→      body: {},\n   619→      headers: { authorization: `Bearer ${accessToken}` }\n   620→    });\n   621→    req.tokenData = decoded;\n   622→    req.stripeCustomerId = decoded.sub;\n   623→\n   624→    const res = new MockResponse();\n   625→    handleLogout(req, res);\n   626→\n   627→    assertEqual(res.statusCode, 200, 'Status code');\n   628→    assertTrue(res.data.success, 'Success flag');\n   629→\n   630→    // Verify token is blacklisted\n   631→    assertTrue(isTokenBlacklisted(decoded.jti), 'Token should be blacklisted');\n   632→  });\n   633→\n   634→  await test('logout also blacklists provided refresh token', async () => {\n   635→    // Clear blacklist for this test\n   636→    tokenBlacklist.clear();\n   637→\n   638→    // Login to get tokens\n   639→    const loginReq = new MockRequest({\n   640→      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n   641→    });\n   642→    const loginRes = new MockResponse();\n   643→    await handleLogin(loginReq, loginRes);\n   644→\n   645→    const accessToken = loginRes.data.token;\n   646→    const refreshToken = loginRes.data.refreshToken;\n   647→    const accessDecoded = verifyToken(accessToken);\n   648→    const refreshDecoded = verifyToken(refreshToken);\n   649→\n   650→    // Logout with refresh token\n   651→    const req = new MockRequest({\n   652→      body: { refreshToken },\n   653→      headers: { authorization: `Bearer ${accessToken}` }\n   654→    });\n   655→    req.tokenData = accessDecoded;\n   656→    req.stripeCustomerId = accessDecoded.sub;\n   657→\n   658→    const res = new MockResponse();\n   659→    handleLogout(req, res);\n   660→\n   661→    assertEqual(res.statusCode, 200, 'Status code');\n   662→    assertTrue(isTokenBlacklisted(accessDecoded.jti), 'Access token should be blacklisted');\n   663→    assertTrue(isTokenBlacklisted(refreshDecoded.jti), 'Refresh token should be blacklisted');\n   664→  });\n   665→\n   666→  // =========================================================================\n   667→  // Test Suite 4: Protected Route Access\n   668→  // =========================================================================\n   669→  console.log('\\n4. Protected Route Access Tests');\n   670→\n   671→  await test('protected route access with valid token succeeds', async () => {\n   672→    // Clear blacklist\n   673→    tokenBlacklist.clear();\n   674→\n   675→    // Login to get token\n   676→    const loginReq = new MockRequest({\n   677→      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n   678→    });\n   679→    const loginRes = new MockResponse();\n   680→    await handleLogin(loginReq, loginRes);\n   681→\n   682→    const accessToken = loginRes.data.token;\n   683→\n   684→    // Try to access protected route\n   685→    const req = new MockRequest({\n   686→      headers: { authorization: `Bearer ${accessToken}` }\n   687→    });\n   688→    const res = new MockResponse();\n   689→\n   690→    let nextCalled = false;\n   691→    authenticateToken(req, res, () => {\n   692→      nextCalled = true;\n   693→    });\n   694→\n   695→    assertTrue(nextCalled, 'next() should be called');\n   696→    assertEqual(req.stripeCustomerId, 'cus_testuser123456', 'Customer ID set');\n   697→    assertTrue(req.tokenData !== null, 'Token data set');\n   698→  });\n   699→\n   700→  await test('protected route rejection with blacklisted token', async () => {\n   701→    // Login to get token\n   702→    const loginReq = new MockRequest({\n   703→      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n   704→    });\n   705→    const loginRes = new MockResponse();\n   706→    await handleLogin(loginReq, loginRes);\n   707→\n   708→    const accessToken = loginRes.data.token;\n   709→    const decoded = verifyToken(accessToken);\n   710→\n   711→    // Blacklist the token\n   712→    blacklistToken(decoded.jti, decoded.exp);\n   713→\n   714→    // Try to access protected route with blacklisted token\n   715→    const req = new MockRequest({\n   716→      headers: { authorization: `Bearer ${accessToken}` }\n   717→    });\n   718→    const res = new MockResponse();\n   719→\n   720→    let nextCalled = false;\n   721→    authenticateToken(req, res, () => {\n   722→      nextCalled = true;\n   723→    });\n   724→\n   725→    assertFalse(nextCalled, 'next() should NOT be called');\n   726→    assertEqual(res.statusCode, 401, 'Status code');\n   727→    assertEqual(res.data.error, 'Token has been revoked', 'Error message');\n   728→  });\n   729→\n   730→  await test('protected route rejection with expired token', async () => {\n   731→    const expiredToken = generateExpiredToken('cus_testuser123456');\n   732→\n   733→    const req = new MockRequest({\n   734→      headers: { authorization: `Bearer ${expiredToken}` }\n   735→    });\n   736→    const res = new MockResponse();\n   737→\n   738→    let nextCalled = false;\n   739→    authenticateToken(req, res, () => {\n   740→      nextCalled = true;\n   741→    });\n   742→\n   743→    assertFalse(nextCalled, 'next() should NOT be called');\n   744→    assertEqual(res.statusCode, 401, 'Status code');\n   745→    assertEqual(res.data.error, 'Invalid or expired token', 'Error message');\n   746→  });\n   747→\n   748→  await test('protected route rejection with invalid token', async () => {\n   749→    const req = new MockRequest({\n   750→      headers: { authorization: 'Bearer invalid-malformed-token' }\n   751→    });\n   752→    const res = new MockResponse();\n   753→\n   754→    let nextCalled = false;\n   755→    authenticateToken(req, res, () => {\n   756→      nextCalled = true;\n   757→    });\n   758→\n   759→    assertFalse(nextCalled, 'next() should NOT be called');\n   760→    assertEqual(res.statusCode, 401, 'Status code');\n   761→    assertEqual(res.data.error, 'Invalid or expired token', 'Error message');\n   762→  });\n   763→\n   764→  await test('protected route rejection without any authentication', async () => {\n   765→    const req = new MockRequest({\n   766→      headers: {}\n   767→    });\n   768→    const res = new MockResponse();\n   769→\n   770→    let nextCalled = false;\n   771→    authenticateToken(req, res, () => {\n   772→      nextCalled = true;\n   773→    });\n   774→\n   775→    assertFalse(nextCalled, 'next() should NOT be called');\n   776→    assertEqual(res.statusCode, 401, 'Status code');\n   777→    assertEqual(res.data.error, 'Authentication required', 'Error message');\n   778→  });\n   779→\n   780→  // =========================================================================\n   781→  // Test Suite 5: Legacy Auth Header Support\n   782→  // =========================================================================\n   783→  console.log('\\n5. Legacy Auth Header Support Tests');\n   784→\n   785→  await test('legacy x-stripe-customer-id header is accepted', async () => {\n   786→    const req = new MockRequest({\n   787→      headers: { 'x-stripe-customer-id': 'cus_legacyuser123456' }\n   788→    });\n   789→    const res = new MockResponse();\n   790→\n   791→    let nextCalled = false;\n   792→    authenticateToken(req, res, () => {\n   793→      nextCalled = true;\n   794→    });\n   795→\n   796→    assertTrue(nextCalled, 'next() should be called');\n   797→    assertEqual(req.stripeCustomerId, 'cus_legacyuser123456', 'Customer ID set');\n   798→    assertTrue(req.isLegacyAuth, 'Legacy auth flag set');\n   799→  });\n   800→\n   801→  await test('invalid legacy customer ID format rejected', async () => {\n   802→    const req = new MockRequest({\n   803→      headers: { 'x-stripe-customer-id': 'invalid_customer_id' }\n   804→    });\n   805→    const res = new MockResponse();\n   806→\n   807→    let nextCalled = false;\n   808→    authenticateToken(req, res, () => {\n   809→      nextCalled = true;\n   810→    });\n   811→\n   812→    assertFalse(nextCalled, 'next() should NOT be called');\n   813→    assertEqual(res.statusCode, 401, 'Status code');\n   814→    assertEqual(res.data.error, 'Invalid customer ID format', 'Error message');\n   815→  });\n   816→\n   817→  // =========================================================================\n   818→  // Test Suite 6: Token Generation Edge Cases\n   819→  // =========================================================================\n   820→  console.log('\\n6. Token Generation Edge Cases');\n   821→\n   822→  test('generateToken requires valid Stripe customer ID', () => {\n   823→    let threw = false;\n   824→    try {\n   825→      generateToken('invalid_id');\n   826→    } catch (e) {\n   827→      threw = true;\n   828→      assertIncludes(e.message, 'Invalid Stripe customer ID', 'Error message');\n   829→    }\n   830→    assertTrue(threw, 'Should throw for invalid customer ID');\n   831→  });\n   832→\n   833→  test('generateToken requires customer ID starting with cus_', () => {\n   834→    let threw = false;\n   835→    try {\n   836→      generateToken('usr_someuser');\n   837→    } catch (e) {\n   838→      threw = true;\n   839→    }\n   840→    assertTrue(threw, 'Should throw for non-cus_ prefix');\n   841→  });\n   842→\n   843→  test('generateRefreshToken requires valid Stripe customer ID', () => {\n   844→    let threw = false;\n   845→    try {\n   846→      generateRefreshToken(null);\n   847→    } catch (e) {\n   848→      threw = true;\n   849→    }\n   850→    assertTrue(threw, 'Should throw for null customer ID');\n   851→  });\n   852→\n   853→  test('generated tokens have unique jti', () => {\n   854→    const token1 = generateToken('cus_testuser123456');\n   855→    const token2 = generateToken('cus_testuser123456');\n   856→\n   857→    const payload1 = verifyToken(token1.token);\n   858→    const payload2 = verifyToken(token2.token);\n   859→\n   860→    assertTrue(payload1.jti !== payload2.jti, 'JTIs should be unique');\n   861→  });\n   862→\n   863→  // =========================================================================\n   864→  // Test Suite 7: Bearer Token Extraction\n   865→  // =========================================================================\n   866→  console.log('\\n7. Bearer Token Extraction Tests');\n   867→\n   868→  test('extractBearerToken handles valid Bearer header', () => {\n   869→    const token = extractBearerToken('Bearer abc123');\n   870→    assertEqual(token, 'abc123', 'Token extracted');\n   871→  });\n   872→\n   873→  test('extractBearerToken handles lowercase bearer', () => {\n   874→    const token = extractBearerToken('bearer abc123');\n   875→    assertEqual(token, 'abc123', 'Token extracted');\n   876→  });\n   877→\n   878→  test('extractBearerToken returns null for non-Bearer auth', () => {\n   879→    const token = extractBearerToken('Basic abc123');\n   880→    assertEqual(token, null, 'Should return null');\n   881→  });\n   882→\n   883→  test('extractBearerToken returns null for malformed header', () => {\n   884→    const token = extractBearerToken('Bearer');\n   885→    assertEqual(token, null, 'Should return null');\n   886→  });\n   887→\n   888→  test('extractBearerToken returns null for null header', () => {\n   889→    const token = extractBearerToken(null);\n   890→    assertEqual(token, null, 'Should return null');\n   891→  });\n   892→\n   893→  test('extractBearerToken returns null for undefined header', () => {\n   894→    const token = extractBearerToken(undefined);\n   895→    assertEqual(token, null, 'Should return null');\n   896→  });\n   897→\n   898→  // =========================================================================\n   899→  // Test Suite 8: Full Login-Use-Logout Flow\n   900→  // =========================================================================\n   901→  console.log('\\n8. Full Login-Use-Logout Flow');\n   902→\n   903→  await test('complete auth lifecycle works correctly', async () => {\n   904→    // Clear blacklist for clean test\n   905→    tokenBlacklist.clear();\n   906→\n   907→    // Step 1: Login\n   908→    const loginReq = new MockRequest({\n   909→      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n   910→    });\n   911→    const loginRes = new MockResponse();\n   912→    await handleLogin(loginReq, loginRes);\n   913→\n   914→    assertEqual(loginRes.statusCode, 200, 'Login succeeds');\n   915→    const { token: accessToken, refreshToken } = loginRes.data;\n   916→\n   917→    // Step 2: Access protected resource\n   918→    const protectedReq = new MockRequest({\n   919→      headers: { authorization: `Bearer ${accessToken}` }\n   920→    });\n   921→    const protectedRes = new MockResponse();\n   922→\n   923→    let protectedNextCalled = false;\n   924→    authenticateToken(protectedReq, protectedRes, () => {\n   925→      protectedNextCalled = true;\n   926→      handleProtectedRoute(protectedReq, protectedRes);\n   927→    });\n   928→\n   929→    assertTrue(protectedNextCalled, 'Protected route accessible');\n   930→    assertEqual(protectedRes.data.success, true, 'Protected route returns success');\n   931→\n   932→    // Step 3: Refresh token\n   933→    const refreshReq = new MockRequest({\n   934→      body: { refreshToken }\n   935→    });\n   936→    const refreshRes = new MockResponse();\n   937→    await handleRefresh(refreshReq, refreshRes);\n   938→\n   939→    assertEqual(refreshRes.statusCode, 200, 'Refresh succeeds');\n   940→    const newAccessToken = refreshRes.data.token;\n   941→\n   942→    // Step 4: Access with new token\n   943→    const newProtectedReq = new MockRequest({\n   944→      headers: { authorization: `Bearer ${newAccessToken}` }\n   945→    });\n   946→    const newProtectedRes = new MockResponse();\n   947→\n   948→    let newProtectedNextCalled = false;\n   949→    authenticateToken(newProtectedReq, newProtectedRes, () => {\n   950→      newProtectedNextCalled = true;\n   951→    });\n   952→\n   953→    assertTrue(newProtectedNextCalled, 'New token works');\n   954→\n   955→    // Step 5: Logout\n   956→    const decoded = verifyToken(newAccessToken);\n   957→    const logoutReq = new MockRequest({\n   958→      body: { refreshToken },\n   959→      headers: { authorization: `Bearer ${newAccessToken}` }\n   960→    });\n   961→    logoutReq.tokenData = decoded;\n   962→    logoutReq.stripeCustomerId = decoded.sub;\n   963→\n   964→    const logoutRes = new MockResponse();\n   965→    handleLogout(logoutReq, logoutRes);\n   966→\n   967→    assertEqual(logoutRes.statusCode, 200, 'Logout succeeds');\n   968→\n   969→    // Step 6: Verify tokens are invalidated\n   970→    const postLogoutReq = new MockRequest({\n   971→      headers: { authorization: `Bearer ${newAccessToken}` }\n   972→    });\n   973→    const postLogoutRes = new MockResponse();\n   974→\n   975→    let postLogoutNextCalled = false;\n   976→    authenticateToken(postLogoutReq, postLogoutRes, () => {\n   977→      postLogoutNextCalled = true;\n   978→    });\n   979→\n   980→    assertFalse(postLogoutNextCalled, 'Token should be blacklisted after logout');\n   981→    assertEqual(postLogoutRes.statusCode, 401, 'Returns 401 after logout');\n   982→\n   983→    // Step 7: Refresh token should also be invalid\n   984→    const postLogoutRefreshReq = new MockRequest({\n   985→      body: { refreshToken }\n   986→    });\n   987→    const postLogoutRefreshRes = new MockResponse();\n   988→    await handleRefresh(postLogoutRefreshReq, postLogoutRefreshRes);\n   989→\n   990→    assertEqual(postLogoutRefreshRes.statusCode, 401, 'Refresh fails after logout');\n   991→  });\n   992→\n   993→  // =========================================================================\n   994→  // Summary\n   995→  // =========================================================================\n   996→  console.log('\\n=== Authentication Test Summary ===');\n   997→  console.log(`  Passed: ${passCount}`);\n   998→  console.log(`  Failed: ${failCount}`);\n   999→  console.log(`  Total: ${passCount + failCount}`);\n  1000→\n  1001→  if (failCount > 0) {\n  1002→    console.log('\\n\\u274C Some authentication tests failed');\n  1003→    process.exit(1);\n  1004→  } else {\n  1005→    console.log('\\n\\u2713 All authentication tests passed');\n  1006→    process.exit(0);\n  1007→  }\n  1008→}\n  1009→\n  1010→// Run tests\n  1011→runTests().catch(err => {\n  1012→  console.error('Test runner error:', err);\n  1013→  process.exit(1);\n  1014→});\n  1015→\n\n</system-reminder>\n"}]},"uuid":"915cd187-6f5c-4920-bc8d-52c524795f7a","timestamp":"2025-12-30T01:04:22.518Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/tests/auth.test.js","content":"/**\n * E2E Authentication Tests\n *\n * Tests for authentication endpoints:\n * - POST /auth/login - successful login returns tokens\n * - POST /auth/login - invalid credentials returns 401\n * - POST /auth/refresh - valid refresh token returns new tokens\n * - POST /auth/refresh - invalid refresh token returns 401\n * - POST /auth/logout - blacklists token\n * - Protected route access with valid token\n * - Protected route rejection with blacklisted token\n * - Protected route rejection with expired token\n */\n\nconst assert = require('assert');\nconst crypto = require('crypto');\n\n// =============================================================================\n// Test Framework\n// =============================================================================\n\nlet passCount = 0;\nlet failCount = 0;\n\nfunction test(name, fn) {\n  try {\n    const result = fn();\n    // Handle async tests\n    if (result && typeof result.then === 'function') {\n      return result\n        .then(() => {\n          passCount++;\n          console.log(`  \\u2713 ${name}`);\n        })\n        .catch((err) => {\n          failCount++;\n          console.log(`  \\u2717 ${name}`);\n          console.log(`    Error: ${err.message}`);\n        });\n    }\n    passCount++;\n    console.log(`  \\u2713 ${name}`);\n  } catch (err) {\n    failCount++;\n    console.log(`  \\u2717 ${name}`);\n    console.log(`    Error: ${err.message}`);\n  }\n}\n\nfunction assertEqual(actual, expected, message = '') {\n  if (actual !== expected) {\n    throw new Error(`${message}: Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);\n  }\n}\n\nfunction assertTrue(condition, message = '') {\n  if (!condition) {\n    throw new Error(`${message}: Expected true, got false`);\n  }\n}\n\nfunction assertFalse(condition, message = '') {\n  if (condition) {\n    throw new Error(`${message}: Expected false, got true`);\n  }\n}\n\nfunction assertIncludes(str, substr, message = '') {\n  if (!str || !str.includes(substr)) {\n    throw new Error(`${message}: String does not include \"${substr}\"`);\n  }\n}\n\n// =============================================================================\n// Mock Services and Middleware\n// =============================================================================\n\n// In-memory token blacklist (mimics auth.js)\nconst tokenBlacklist = new Map();\n\nfunction blacklistToken(jti, exp) {\n  if (!jti) return false;\n  tokenBlacklist.set(jti, exp);\n  return true;\n}\n\nfunction isTokenBlacklisted(jti) {\n  if (!jti) return false;\n  return tokenBlacklist.has(jti);\n}\n\n// Mock JWT functions (simplified versions for testing)\nconst JWT_SECRET = 'test-secret-for-auth-tests';\nconst JWT_EXPIRES_IN = '24h';\nconst JWT_REFRESH_EXPIRES_IN = '7d';\n\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const jti = crypto.randomUUID();\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: now,\n    exp: now + 86400, // 24 hours\n    jti\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  // Simplified token encoding (base64 JSON for testing)\n  const token = Buffer.from(JSON.stringify(payload)).toString('base64');\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer',\n    payload // Include for testing\n  };\n}\n\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const jti = crypto.randomUUID();\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: now,\n    exp: now + 604800, // 7 days\n    jti\n  };\n\n  const refreshToken = Buffer.from(JSON.stringify(payload)).toString('base64');\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN,\n    payload // Include for testing\n  };\n}\n\nfunction verifyToken(token, options = {}) {\n  const { checkBlacklist = true } = options;\n\n  try {\n    const payload = JSON.parse(Buffer.from(token, 'base64').toString());\n\n    // Check expiration\n    const now = Math.floor(Date.now() / 1000);\n    if (payload.exp && payload.exp < now) {\n      return null; // Token expired\n    }\n\n    // Check blacklist\n    if (checkBlacklist && payload.jti) {\n      if (isTokenBlacklisted(payload.jti)) {\n        return null;\n      }\n    }\n\n    return payload;\n  } catch {\n    return null;\n  }\n}\n\nfunction generateExpiredToken(stripeCustomerId) {\n  const now = Math.floor(Date.now() / 1000);\n  const jti = crypto.randomUUID();\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: 'starter',\n    iat: now - 86400, // 24 hours ago\n    exp: now - 3600, // Expired 1 hour ago\n    jti\n  };\n\n  return Buffer.from(JSON.stringify(payload)).toString('base64');\n}\n\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n// Mock license service\nconst mockLicenseKeys = new Map();\nmockLicenseKeys.set('SPLICE-TEST-VALD-KEY1', {\n  customerId: 'cus_testuser123456',\n  email: 'test@example.com',\n  isActive: true\n});\nmockLicenseKeys.set('SPLICE-DEAC-TIVE-KEY2', {\n  customerId: 'cus_deactivated123',\n  email: 'deactivated@example.com',\n  isActive: false\n});\n\nconst mockLicenseService = {\n  async activateLicenseKey(key) {\n    const normalizedKey = (key || '').toUpperCase().trim();\n    const license = mockLicenseKeys.get(normalizedKey);\n\n    if (!license) {\n      return { success: false, error: 'License key not found' };\n    }\n\n    if (!license.isActive) {\n      return { success: false, error: 'License key has been deactivated' };\n    }\n\n    return {\n      success: true,\n      customerId: license.customerId,\n      email: license.email\n    };\n  }\n};\n\n// Mock usage tracking service\nconst mockUsageTracking = {\n  async getBalance(customerId) {\n    return {\n      tier: 'pro',\n      hoursRemaining: 10.5,\n      musicCredits: 50\n    };\n  }\n};\n\n// =============================================================================\n// Simulated HTTP Request/Response\n// =============================================================================\n\nclass MockRequest {\n  constructor(options = {}) {\n    this.body = options.body || {};\n    this.headers = options.headers || {};\n    this.params = options.params || {};\n    this.query = options.query || {};\n    this.stripeCustomerId = null;\n    this.tokenData = null;\n    this.rawToken = null;\n    this.isLegacyAuth = false;\n  }\n}\n\nclass MockResponse {\n  constructor() {\n    this.statusCode = 200;\n    this.data = null;\n    this._ended = false;\n  }\n\n  status(code) {\n    this.statusCode = code;\n    return this;\n  }\n\n  json(data) {\n    this.data = data;\n    this._ended = true;\n    return this;\n  }\n\n  end() {\n    this._ended = true;\n    return this;\n  }\n}\n\n// =============================================================================\n// Simulated Route Handlers (mimicking routes/auth.js)\n// =============================================================================\n\nasync function handleLogin(req, res) {\n  const { licenseKey } = req.body;\n\n  if (!licenseKey) {\n    return res.status(400).json({\n      error: 'License key required',\n      message: 'Please provide your license key to log in'\n    });\n  }\n\n  try {\n    const licenseResult = await mockLicenseService.activateLicenseKey(licenseKey);\n\n    if (!licenseResult.success) {\n      return res.status(401).json({\n        error: 'Invalid license key',\n        message: licenseResult.error || 'The license key is invalid or expired'\n      });\n    }\n\n    const balance = await mockUsageTracking.getBalance(licenseResult.customerId);\n\n    const tokenResult = generateToken(licenseResult.customerId, {\n      tier: balance.tier,\n      email: licenseResult.email\n    });\n    const refreshResult = generateRefreshToken(licenseResult.customerId);\n\n    res.json({\n      success: true,\n      token: tokenResult.token,\n      tokenType: tokenResult.tokenType,\n      expiresIn: tokenResult.expiresIn,\n      refreshToken: refreshResult.refreshToken,\n      customerId: licenseResult.customerId,\n      tier: balance.tier,\n      hoursRemaining: balance.hoursRemaining\n    });\n  } catch (err) {\n    res.status(500).json({ error: 'Authentication failed. Please try again.' });\n  }\n}\n\nasync function handleRefresh(req, res) {\n  const { refreshToken } = req.body;\n\n  if (!refreshToken) {\n    return res.status(400).json({\n      error: 'Refresh token required'\n    });\n  }\n\n  try {\n    const decoded = verifyToken(refreshToken);\n\n    if (!decoded || decoded.type !== 'refresh') {\n      return res.status(401).json({\n        error: 'Invalid refresh token',\n        message: 'Please log in again'\n      });\n    }\n\n    const balance = await mockUsageTracking.getBalance(decoded.sub);\n\n    const tokenResult = generateToken(decoded.sub, {\n      tier: balance.tier\n    });\n\n    res.json({\n      success: true,\n      token: tokenResult.token,\n      tokenType: tokenResult.tokenType,\n      expiresIn: tokenResult.expiresIn\n    });\n  } catch (err) {\n    res.status(401).json({\n      error: 'Failed to refresh token',\n      message: 'Please log in again'\n    });\n  }\n}\n\nfunction handleLogout(req, res) {\n  const { refreshToken } = req.body;\n\n  // Blacklist the access token\n  if (req.tokenData && req.tokenData.jti && req.tokenData.exp) {\n    blacklistToken(req.tokenData.jti, req.tokenData.exp);\n  }\n\n  // Optionally blacklist the refresh token too\n  if (refreshToken) {\n    const decoded = verifyToken(refreshToken, { checkBlacklist: false });\n    if (decoded && decoded.jti && decoded.exp) {\n      blacklistToken(decoded.jti, decoded.exp);\n    }\n  }\n\n  res.json({\n    success: true,\n    message: 'Logged out successfully'\n  });\n}\n\n// Middleware to authenticate JWT tokens\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify without blacklist check for specific error messages\n    const decoded = verifyToken(token, { checkBlacklist: false });\n\n    if (!decoded || !decoded.sub) {\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted)\n    if (decoded.jti && isTokenBlacklisted(decoded.jti)) {\n      return res.status(401).json({\n        error: 'Token has been revoked',\n        message: 'This session has been logged out. Please log in again.'\n      });\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token;\n    return next();\n  }\n\n  // Fallback: Legacy x-stripe-customer-id header\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    if (!legacyCustomerId.startsWith('cus_')) {\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n// Protected route handler for testing\nfunction handleProtectedRoute(req, res) {\n  res.json({\n    success: true,\n    customerId: req.stripeCustomerId,\n    tier: req.tokenData?.tier || 'unknown'\n  });\n}\n\n// =============================================================================\n// Test Suite\n// =============================================================================\n\nasync function runTests() {\n  console.log('\\n=== Authentication E2E Tests ===\\n');\n\n  // =========================================================================\n  // Test Suite 1: POST /auth/login\n  // =========================================================================\n  console.log('1. POST /auth/login - Login Tests');\n\n  await test('login with valid license key returns tokens', async () => {\n    const req = new MockRequest({\n      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n    });\n    const res = new MockResponse();\n\n    await handleLogin(req, res);\n\n    assertEqual(res.statusCode, 200, 'Status code');\n    assertTrue(res.data.success, 'Success flag');\n    assertTrue(res.data.token && res.data.token.length > 0, 'Token present');\n    assertTrue(res.data.refreshToken && res.data.refreshToken.length > 0, 'Refresh token present');\n    assertEqual(res.data.tokenType, 'Bearer', 'Token type');\n    assertEqual(res.data.customerId, 'cus_testuser123456', 'Customer ID');\n    assertEqual(res.data.tier, 'pro', 'Tier');\n  });\n\n  await test('login with invalid license key returns 401', async () => {\n    const req = new MockRequest({\n      body: { licenseKey: 'SPLICE-INVA-LIDK-EY00' }\n    });\n    const res = new MockResponse();\n\n    await handleLogin(req, res);\n\n    assertEqual(res.statusCode, 401, 'Status code');\n    assertEqual(res.data.error, 'Invalid license key', 'Error message');\n  });\n\n  await test('login with deactivated license key returns 401', async () => {\n    const req = new MockRequest({\n      body: { licenseKey: 'SPLICE-DEAC-TIVE-KEY2' }\n    });\n    const res = new MockResponse();\n\n    await handleLogin(req, res);\n\n    assertEqual(res.statusCode, 401, 'Status code');\n    assertIncludes(res.data.message, 'deactivated', 'Error mentions deactivation');\n  });\n\n  await test('login without license key returns 400', async () => {\n    const req = new MockRequest({\n      body: {}\n    });\n    const res = new MockResponse();\n\n    await handleLogin(req, res);\n\n    assertEqual(res.statusCode, 400, 'Status code');\n    assertEqual(res.data.error, 'License key required', 'Error message');\n  });\n\n  // =========================================================================\n  // Test Suite 2: POST /auth/refresh\n  // =========================================================================\n  console.log('\\n2. POST /auth/refresh - Token Refresh Tests');\n\n  await test('refresh with valid refresh token returns new tokens', async () => {\n    // First get a valid refresh token\n    const loginReq = new MockRequest({\n      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n    });\n    const loginRes = new MockResponse();\n    await handleLogin(loginReq, loginRes);\n\n    const refreshToken = loginRes.data.refreshToken;\n\n    // Now try to refresh\n    const req = new MockRequest({\n      body: { refreshToken }\n    });\n    const res = new MockResponse();\n\n    await handleRefresh(req, res);\n\n    assertEqual(res.statusCode, 200, 'Status code');\n    assertTrue(res.data.success, 'Success flag');\n    assertTrue(res.data.token && res.data.token.length > 0, 'New token present');\n    assertEqual(res.data.tokenType, 'Bearer', 'Token type');\n  });\n\n  await test('refresh with invalid refresh token returns 401', async () => {\n    const req = new MockRequest({\n      body: { refreshToken: 'invalid-token' }\n    });\n    const res = new MockResponse();\n\n    await handleRefresh(req, res);\n\n    assertEqual(res.statusCode, 401, 'Status code');\n    assertEqual(res.data.error, 'Invalid refresh token', 'Error message');\n  });\n\n  await test('refresh with access token (wrong type) returns 401', async () => {\n    // Get an access token (not refresh token)\n    const loginReq = new MockRequest({\n      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n    });\n    const loginRes = new MockResponse();\n    await handleLogin(loginReq, loginRes);\n\n    const accessToken = loginRes.data.token; // Access token, not refresh\n\n    const req = new MockRequest({\n      body: { refreshToken: accessToken }\n    });\n    const res = new MockResponse();\n\n    await handleRefresh(req, res);\n\n    assertEqual(res.statusCode, 401, 'Status code');\n    assertEqual(res.data.error, 'Invalid refresh token', 'Error message');\n  });\n\n  await test('refresh without token returns 400', async () => {\n    const req = new MockRequest({\n      body: {}\n    });\n    const res = new MockResponse();\n\n    await handleRefresh(req, res);\n\n    assertEqual(res.statusCode, 400, 'Status code');\n    assertEqual(res.data.error, 'Refresh token required', 'Error message');\n  });\n\n  // =========================================================================\n  // Test Suite 3: POST /auth/logout\n  // =========================================================================\n  console.log('\\n3. POST /auth/logout - Logout Tests');\n\n  await test('logout blacklists current token', async () => {\n    // Login to get tokens\n    const loginReq = new MockRequest({\n      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n    });\n    const loginRes = new MockResponse();\n    await handleLogin(loginReq, loginRes);\n\n    const accessToken = loginRes.data.token;\n    const decoded = verifyToken(accessToken);\n\n    // Simulate authenticated request for logout\n    const req = new MockRequest({\n      body: {},\n      headers: { authorization: `Bearer ${accessToken}` }\n    });\n    req.tokenData = decoded;\n    req.stripeCustomerId = decoded.sub;\n\n    const res = new MockResponse();\n    handleLogout(req, res);\n\n    assertEqual(res.statusCode, 200, 'Status code');\n    assertTrue(res.data.success, 'Success flag');\n\n    // Verify token is blacklisted\n    assertTrue(isTokenBlacklisted(decoded.jti), 'Token should be blacklisted');\n  });\n\n  await test('logout also blacklists provided refresh token', async () => {\n    // Clear blacklist for this test\n    tokenBlacklist.clear();\n\n    // Login to get tokens\n    const loginReq = new MockRequest({\n      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n    });\n    const loginRes = new MockResponse();\n    await handleLogin(loginReq, loginRes);\n\n    const accessToken = loginRes.data.token;\n    const refreshToken = loginRes.data.refreshToken;\n    const accessDecoded = verifyToken(accessToken);\n    const refreshDecoded = verifyToken(refreshToken);\n\n    // Logout with refresh token\n    const req = new MockRequest({\n      body: { refreshToken },\n      headers: { authorization: `Bearer ${accessToken}` }\n    });\n    req.tokenData = accessDecoded;\n    req.stripeCustomerId = accessDecoded.sub;\n\n    const res = new MockResponse();\n    handleLogout(req, res);\n\n    assertEqual(res.statusCode, 200, 'Status code');\n    assertTrue(isTokenBlacklisted(accessDecoded.jti), 'Access token should be blacklisted');\n    assertTrue(isTokenBlacklisted(refreshDecoded.jti), 'Refresh token should be blacklisted');\n  });\n\n  // =========================================================================\n  // Test Suite 4: Protected Route Access\n  // =========================================================================\n  console.log('\\n4. Protected Route Access Tests');\n\n  await test('protected route access with valid token succeeds', async () => {\n    // Clear blacklist\n    tokenBlacklist.clear();\n\n    // Login to get token\n    const loginReq = new MockRequest({\n      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n    });\n    const loginRes = new MockResponse();\n    await handleLogin(loginReq, loginRes);\n\n    const accessToken = loginRes.data.token;\n\n    // Try to access protected route\n    const req = new MockRequest({\n      headers: { authorization: `Bearer ${accessToken}` }\n    });\n    const res = new MockResponse();\n\n    let nextCalled = false;\n    authenticateToken(req, res, () => {\n      nextCalled = true;\n    });\n\n    assertTrue(nextCalled, 'next() should be called');\n    assertEqual(req.stripeCustomerId, 'cus_testuser123456', 'Customer ID set');\n    assertTrue(req.tokenData !== null, 'Token data set');\n  });\n\n  await test('protected route rejection with blacklisted token', async () => {\n    // Login to get token\n    const loginReq = new MockRequest({\n      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n    });\n    const loginRes = new MockResponse();\n    await handleLogin(loginReq, loginRes);\n\n    const accessToken = loginRes.data.token;\n    const decoded = verifyToken(accessToken);\n\n    // Blacklist the token\n    blacklistToken(decoded.jti, decoded.exp);\n\n    // Try to access protected route with blacklisted token\n    const req = new MockRequest({\n      headers: { authorization: `Bearer ${accessToken}` }\n    });\n    const res = new MockResponse();\n\n    let nextCalled = false;\n    authenticateToken(req, res, () => {\n      nextCalled = true;\n    });\n\n    assertFalse(nextCalled, 'next() should NOT be called');\n    assertEqual(res.statusCode, 401, 'Status code');\n    assertEqual(res.data.error, 'Token has been revoked', 'Error message');\n  });\n\n  await test('protected route rejection with expired token', async () => {\n    const expiredToken = generateExpiredToken('cus_testuser123456');\n\n    const req = new MockRequest({\n      headers: { authorization: `Bearer ${expiredToken}` }\n    });\n    const res = new MockResponse();\n\n    let nextCalled = false;\n    authenticateToken(req, res, () => {\n      nextCalled = true;\n    });\n\n    assertFalse(nextCalled, 'next() should NOT be called');\n    assertEqual(res.statusCode, 401, 'Status code');\n    assertEqual(res.data.error, 'Invalid or expired token', 'Error message');\n  });\n\n  await test('protected route rejection with invalid token', async () => {\n    const req = new MockRequest({\n      headers: { authorization: 'Bearer invalid-malformed-token' }\n    });\n    const res = new MockResponse();\n\n    let nextCalled = false;\n    authenticateToken(req, res, () => {\n      nextCalled = true;\n    });\n\n    assertFalse(nextCalled, 'next() should NOT be called');\n    assertEqual(res.statusCode, 401, 'Status code');\n    assertEqual(res.data.error, 'Invalid or expired token', 'Error message');\n  });\n\n  await test('protected route rejection without any authentication', async () => {\n    const req = new MockRequest({\n      headers: {}\n    });\n    const res = new MockResponse();\n\n    let nextCalled = false;\n    authenticateToken(req, res, () => {\n      nextCalled = true;\n    });\n\n    assertFalse(nextCalled, 'next() should NOT be called');\n    assertEqual(res.statusCode, 401, 'Status code');\n    assertEqual(res.data.error, 'Authentication required', 'Error message');\n  });\n\n  // =========================================================================\n  // Test Suite 5: Legacy Auth Header Support\n  // =========================================================================\n  console.log('\\n5. Legacy Auth Header Support Tests');\n\n  await test('legacy x-stripe-customer-id header is accepted', async () => {\n    const req = new MockRequest({\n      headers: { 'x-stripe-customer-id': 'cus_legacyuser123456' }\n    });\n    const res = new MockResponse();\n\n    let nextCalled = false;\n    authenticateToken(req, res, () => {\n      nextCalled = true;\n    });\n\n    assertTrue(nextCalled, 'next() should be called');\n    assertEqual(req.stripeCustomerId, 'cus_legacyuser123456', 'Customer ID set');\n    assertTrue(req.isLegacyAuth, 'Legacy auth flag set');\n  });\n\n  await test('invalid legacy customer ID format rejected', async () => {\n    const req = new MockRequest({\n      headers: { 'x-stripe-customer-id': 'invalid_customer_id' }\n    });\n    const res = new MockResponse();\n\n    let nextCalled = false;\n    authenticateToken(req, res, () => {\n      nextCalled = true;\n    });\n\n    assertFalse(nextCalled, 'next() should NOT be called');\n    assertEqual(res.statusCode, 401, 'Status code');\n    assertEqual(res.data.error, 'Invalid customer ID format', 'Error message');\n  });\n\n  // =========================================================================\n  // Test Suite 6: Token Generation Edge Cases\n  // =========================================================================\n  console.log('\\n6. Token Generation Edge Cases');\n\n  test('generateToken requires valid Stripe customer ID', () => {\n    let threw = false;\n    try {\n      generateToken('invalid_id');\n    } catch (e) {\n      threw = true;\n      assertIncludes(e.message, 'Invalid Stripe customer ID', 'Error message');\n    }\n    assertTrue(threw, 'Should throw for invalid customer ID');\n  });\n\n  test('generateToken requires customer ID starting with cus_', () => {\n    let threw = false;\n    try {\n      generateToken('usr_someuser');\n    } catch (e) {\n      threw = true;\n    }\n    assertTrue(threw, 'Should throw for non-cus_ prefix');\n  });\n\n  test('generateRefreshToken requires valid Stripe customer ID', () => {\n    let threw = false;\n    try {\n      generateRefreshToken(null);\n    } catch (e) {\n      threw = true;\n    }\n    assertTrue(threw, 'Should throw for null customer ID');\n  });\n\n  test('generated tokens have unique jti', () => {\n    const token1 = generateToken('cus_testuser123456');\n    const token2 = generateToken('cus_testuser123456');\n\n    const payload1 = verifyToken(token1.token);\n    const payload2 = verifyToken(token2.token);\n\n    assertTrue(payload1.jti !== payload2.jti, 'JTIs should be unique');\n  });\n\n  // =========================================================================\n  // Test Suite 7: Bearer Token Extraction\n  // =========================================================================\n  console.log('\\n7. Bearer Token Extraction Tests');\n\n  test('extractBearerToken handles valid Bearer header', () => {\n    const token = extractBearerToken('Bearer abc123');\n    assertEqual(token, 'abc123', 'Token extracted');\n  });\n\n  test('extractBearerToken handles lowercase bearer', () => {\n    const token = extractBearerToken('bearer abc123');\n    assertEqual(token, 'abc123', 'Token extracted');\n  });\n\n  test('extractBearerToken returns null for non-Bearer auth', () => {\n    const token = extractBearerToken('Basic abc123');\n    assertEqual(token, null, 'Should return null');\n  });\n\n  test('extractBearerToken returns null for malformed header', () => {\n    const token = extractBearerToken('Bearer');\n    assertEqual(token, null, 'Should return null');\n  });\n\n  test('extractBearerToken returns null for null header', () => {\n    const token = extractBearerToken(null);\n    assertEqual(token, null, 'Should return null');\n  });\n\n  test('extractBearerToken returns null for undefined header', () => {\n    const token = extractBearerToken(undefined);\n    assertEqual(token, null, 'Should return null');\n  });\n\n  // =========================================================================\n  // Test Suite 8: Full Login-Use-Logout Flow\n  // =========================================================================\n  console.log('\\n8. Full Login-Use-Logout Flow');\n\n  await test('complete auth lifecycle works correctly', async () => {\n    // Clear blacklist for clean test\n    tokenBlacklist.clear();\n\n    // Step 1: Login\n    const loginReq = new MockRequest({\n      body: { licenseKey: 'SPLICE-TEST-VALD-KEY1' }\n    });\n    const loginRes = new MockResponse();\n    await handleLogin(loginReq, loginRes);\n\n    assertEqual(loginRes.statusCode, 200, 'Login succeeds');\n    const { token: accessToken, refreshToken } = loginRes.data;\n\n    // Step 2: Access protected resource\n    const protectedReq = new MockRequest({\n      headers: { authorization: `Bearer ${accessToken}` }\n    });\n    const protectedRes = new MockResponse();\n\n    let protectedNextCalled = false;\n    authenticateToken(protectedReq, protectedRes, () => {\n      protectedNextCalled = true;\n      handleProtectedRoute(protectedReq, protectedRes);\n    });\n\n    assertTrue(protectedNextCalled, 'Protected route accessible');\n    assertEqual(protectedRes.data.success, true, 'Protected route returns success');\n\n    // Step 3: Refresh token\n    const refreshReq = new MockRequest({\n      body: { refreshToken }\n    });\n    const refreshRes = new MockResponse();\n    await handleRefresh(refreshReq, refreshRes);\n\n    assertEqual(refreshRes.statusCode, 200, 'Refresh succeeds');\n    const newAccessToken = refreshRes.data.token;\n\n    // Step 4: Access with new token\n    const newProtectedReq = new MockRequest({\n      headers: { authorization: `Bearer ${newAccessToken}` }\n    });\n    const newProtectedRes = new MockResponse();\n\n    let newProtectedNextCalled = false;\n    authenticateToken(newProtectedReq, newProtectedRes, () => {\n      newProtectedNextCalled = true;\n    });\n\n    assertTrue(newProtectedNextCalled, 'New token works');\n\n    // Step 5: Logout\n    const decoded = verifyToken(newAccessToken);\n    const logoutReq = new MockRequest({\n      body: { refreshToken },\n      headers: { authorization: `Bearer ${newAccessToken}` }\n    });\n    logoutReq.tokenData = decoded;\n    logoutReq.stripeCustomerId = decoded.sub;\n\n    const logoutRes = new MockResponse();\n    handleLogout(logoutReq, logoutRes);\n\n    assertEqual(logoutRes.statusCode, 200, 'Logout succeeds');\n\n    // Step 6: Verify tokens are invalidated\n    const postLogoutReq = new MockRequest({\n      headers: { authorization: `Bearer ${newAccessToken}` }\n    });\n    const postLogoutRes = new MockResponse();\n\n    let postLogoutNextCalled = false;\n    authenticateToken(postLogoutReq, postLogoutRes, () => {\n      postLogoutNextCalled = true;\n    });\n\n    assertFalse(postLogoutNextCalled, 'Token should be blacklisted after logout');\n    assertEqual(postLogoutRes.statusCode, 401, 'Returns 401 after logout');\n\n    // Step 7: Refresh token should also be invalid\n    const postLogoutRefreshReq = new MockRequest({\n      body: { refreshToken }\n    });\n    const postLogoutRefreshRes = new MockResponse();\n    await handleRefresh(postLogoutRefreshReq, postLogoutRefreshRes);\n\n    assertEqual(postLogoutRefreshRes.statusCode, 401, 'Refresh fails after logout');\n  });\n\n  // =========================================================================\n  // Summary\n  // =========================================================================\n  console.log('\\n=== Authentication Test Summary ===');\n  console.log(`  Passed: ${passCount}`);\n  console.log(`  Failed: ${failCount}`);\n  console.log(`  Total: ${passCount + failCount}`);\n\n  if (failCount > 0) {\n    console.log('\\n\\u274C Some authentication tests failed');\n    process.exit(1);\n  } else {\n    console.log('\\n\\u2713 All authentication tests passed');\n    process.exit(0);\n  }\n}\n\n// Run tests\nrunTests().catch(err => {\n  console.error('Test runner error:', err);\n  process.exit(1);\n});\n","numLines":1015,"startLine":1,"totalLines":1015}}}
{"parentUuid":"915cd187-6f5c-4920-bc8d-52c524795f7a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"aad7df5","slug":"federated-bubbling-octopus","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GghAkF24gxrhKX46U2nXJh","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a comprehensive view of all the files. Let me compile my QA validation report for unhandled promise rejection issues.\n\n---\n\n## QA Validation Report: Unhandled Promise Rejections in SPLICE Backend\n\n### Overall Verdict: **PASS WITH ISSUES**\n\n---\n\n### Requirements Checklist\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Check `blacklistToken(` calls without await | :warning: Partially Met | 1 issue found |\n| Check `isTokenBlacklisted(` calls without await | :white_check_mark: Met | All properly awaited |\n| Check `verifyToken(` calls without await | :x: Not Met | 2 issues found |\n| Check `redis.set/get/exists/del` calls without await | :white_check_mark: Met | All wrapped in try/catch |\n| Check missing try/catch around Redis ops | :white_check_mark: Met | All Redis operations have try/catch |\n| Check async Express routes without error handling | :white_check_mark: Met | All have try/catch |\n| Check `.then()` chains without `.catch()` | :white_check_mark: Met | No unhandled .then() chains |\n\n---\n\n### Detailed Findings\n\n#### **CRITICAL - Priority: High**\n\n**1. `verifyToken` called synchronously in rateLimiter.js (line 139)**\n\nFile: `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js`\n\n```javascript\n// Line 139\nconst decoded = verifyToken(token);\n```\n\n**Problem:** `verifyToken` is an async function that checks the Redis blacklist, but it is called without `await`. This means:\n- The blacklist check is NOT performed (promise returned, not awaited)\n- A blacklisted token could bypass the rate limiter and access protected resources\n- This is a **security vulnerability**\n\n**Recommendation:** Change to `await verifyToken(token)` and ensure the middleware is properly marked as async (which it already is).\n\n---\n\n**2. `verifyToken` called synchronously in billing.js (lines 34 and 74)**\n\nFile: `/Users/imorgado/SPLICE/splice-backend/routes/billing.js`\n\n```javascript\n// Line 34\nconst decoded = verifyToken(token);\nif (decoded && decoded.sub) {\n\n// Line 74\nconst decoded = verifyToken(token);\nif (decoded && decoded.sub) {\n```\n\n**Problem:** Same issue - `verifyToken` is async but called without await. The route handlers are already async, so adding await is straightforward.\n\n**Impact:** \n- Blacklist check is skipped\n- Revoked tokens could still access `/credits` and `/usage-history` endpoints\n- Security vulnerability, though lower severity (read-only endpoints)\n\n**Recommendation:** Change both occurrences to `await verifyToken(token)`.\n\n---\n\n#### **MEDIUM - Priority: Medium**\n\n**3. `releaseReservation` called without await in rateLimiter.js (line 254)**\n\nFile: `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js`\n\n```javascript\n// Lines 253-256\nif (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n  releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n    .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n}\n```\n\n**Status:** Actually properly handled - the `.catch()` is present, so this is **not an unhandled rejection**.\n\n---\n\n#### **LOW - Priority: Low**\n\n**4. No `.then()` chains without `.catch()` found**\n\nGrep search confirmed no unhandled `.then()` chains exist in the codebase.\n\n---\n\n### Redis Operations Analysis\n\nAll Redis operations in `/Users/imorgado/SPLICE/splice-backend/services/redisClient.js` are properly wrapped:\n\n| Function | Has try/catch | Returns safely on error |\n|----------|---------------|------------------------|\n| `set()` | :white_check_mark: | Returns `false` |\n| `get()` | :white_check_mark: | Returns `null` |\n| `exists()` | :white_check_mark: | Returns `false` |\n| `del()` | :white_check_mark: | Returns `false` |\n| `setNX()` | :white_check_mark: | Returns `false` |\n| `ttl()` | :white_check_mark: | Returns `-2` |\n| `pingRedis()` | :white_check_mark: | Returns `false` |\n\nAll callers in `auth.js` that use these functions are properly awaited and wrapped in try/catch blocks.\n\n---\n\n### Express Route Handler Analysis\n\nAll async route handlers in `routes/auth.js` have proper try/catch blocks:\n- `/login` - :white_check_mark: Has try/catch\n- `/refresh` - :white_check_mark: Has try/catch\n- `/logout` - :white_check_mark: Has try/catch (and `blacklistToken` is awaited)\n- `/send-verification` - :white_check_mark: Has try/catch\n- `/verify-email` - :white_check_mark: Has try/catch\n\n---\n\n### Recommendations for Fixes\n\n**Fix 1: rateLimiter.js line 139**\n```javascript\n// Change from:\nconst decoded = verifyToken(token);\n\n// To:\nconst decoded = await verifyToken(token);\n```\n\n**Fix 2: billing.js line 34**\n```javascript\n// Change from:\nconst decoded = verifyToken(token);\n\n// To:\nconst decoded = await verifyToken(token);\n```\n\n**Fix 3: billing.js line 74**\n```javascript\n// Change from:\nconst decoded = verifyToken(token);\n\n// To:\nconst decoded = await verifyToken(token);\n```\n\n---\n\n### Summary\n\n| Severity | Count | Action Required |\n|----------|-------|-----------------|\n| Critical (Security) | 1 | Fix `rateLimiter.js` - blacklist bypass |\n| High | 2 | Fix `billing.js` - blacklist bypass on read endpoints |\n| Medium | 0 | None |\n| Low | 0 | None |\n\n**Total Issues Found:** 3 missing `await` calls on async `verifyToken` function\n\n**Security Impact:** These issues allow blacklisted (revoked) tokens to continue accessing protected endpoints until the JWT expires naturally. This undermines the logout functionality."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6545,"cache_creation_input_tokens":18233,"cache_read_input_tokens":46265,"cache_creation":{"ephemeral_5m_input_tokens":18233,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWbyM3ZdfuobxRePsv3S6","type":"assistant","uuid":"8b55d18e-8ba8-4f99-9700-f84d13193e17","timestamp":"2025-12-30T01:04:54.018Z"}
