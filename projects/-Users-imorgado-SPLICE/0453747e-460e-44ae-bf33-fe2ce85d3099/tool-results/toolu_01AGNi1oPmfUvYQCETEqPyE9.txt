     1→/**
     2→ * Rate Limiter Middleware
     3→ *
     4→ * Checks if user has sufficient credits before processing.
     5→ * Uses atomic credit reservation to prevent race conditions.
     6→ * Returns 402 Payment Required if insufficient credits.
     7→ *
     8→ * SECURITY: Uses JWT authentication via authenticateToken middleware.
     9→ * Legacy x-stripe-customer-id header is DISABLED in production for security.
    10→ */
    11→
    12→const {
    13→  deductUsage,
    14→  getBalance,
    15→  reserveCredits,
    16→  confirmReservation,
    17→  releaseReservation,
    18→  customerExists
    19→} = require('../services/usageTracking');
    20→const { verifyToken, extractBearerToken } = require('./auth');
    21→
    22→// SECURITY: Disable legacy auth in production unless explicitly enabled
    23→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;
    24→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';
    25→
    26→// =============================================================================
    27→// IP-based Rate Limiting
    28→// =============================================================================
    29→
    30→// General rate limiting per IP
    31→const ipRequestCounts = new Map(); // IP -> { count, windowStart }
    32→const IP_RATE_LIMIT_WINDOW_MS = 60000; // 1 minute window
    33→const IP_RATE_LIMIT_MAX_REQUESTS = 100; // 100 requests per minute per IP
    34→
    35→// Cleanup old entries every 5 minutes to prevent memory leaks
    36→setInterval(() => {
    37→  const now = Date.now();
    38→  for (const [ip, data] of ipRequestCounts.entries()) {
    39→    if (now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS * 2) {
    40→      ipRequestCounts.delete(ip);
    41→    }
    42→  }
    43→}, 300000);
    44→
    45→/**
    46→ * Check if IP is rate limited
    47→ * @param {string} ip - Client IP address
    48→ * @returns {boolean} True if rate limited
    49→ */
    50→function isIpRateLimited(ip) {
    51→  const now = Date.now();
    52→  const data = ipRequestCounts.get(ip);
    53→
    54→  if (!data || now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS) {
    55→    // Start new window
    56→    ipRequestCounts.set(ip, { count: 1, windowStart: now });
    57→    return false;
    58→  }
    59→
    60→  data.count++;
    61→  if (data.count > IP_RATE_LIMIT_MAX_REQUESTS) {
    62→    return true;
    63→  }
    64→
    65→  return false;
    66→}
    67→
    68→/**
    69→ * IP-based rate limiting middleware
    70→ * Limits requests per IP to prevent abuse
    71→ */
    72→function ipRateLimit(req, res, next) {
    73→  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';
    74→
    75→  if (isIpRateLimited(clientIp)) {
    76→    console.warn(`[SECURITY] IP rate limit exceeded for: ${clientIp}`);
    77→    return res.status(429).json({
    78→      error: 'Too many requests',
    79→      message: 'Please slow down and try again later',
    80→      retryAfter: 60
    81→    });
    82→  }
    83→
    84→  next();
    85→}
    86→
    87→// Rate limiting for legacy auth attempts (prevent brute force)
    88→const legacyAuthAttempts = new Map(); // IP -> { count, timestamp }
    89→const LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute
    90→const LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute
    91→
    92→/**
    93→ * Check if IP is rate limited for legacy auth
    94→ */
    95→function isLegacyAuthRateLimited(ip) {
    96→  const now = Date.now();
    97→  const attempt = legacyAuthAttempts.get(ip);
    98→
    99→  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {
   100→    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });
   101→    return false;
   102→  }
   103→
   104→  attempt.count++;
   105→  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {
   106→    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);
   107→    return true;
   108→  }
   109→
   110→  return false;
   111→}
   112→
   113→// Default estimated duration for reservation (1 minute = 60 seconds)
   114→const DEFAULT_RESERVATION_SECONDS = 60;
   115→
   116→/**
   117→ * Middleware to check and atomically reserve credits before processing
   118→ *
   119→ * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)
   120→ * Falls back to legacy x-stripe-customer-id header (deprecated)
   121→ *
   122→ * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s
   123→ *
   124→ * This middleware uses SELECT...FOR UPDATE to prevent race conditions
   125→ * where multiple concurrent requests could all pass credit check.
   126→ */
   127→function requireCredits(options = {}) {
   128→  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;
   129→
   130→  return async (req, res, next) => {
   131→    // SECURITY: Primary auth via JWT token
   132→    const authHeader = req.headers['authorization'];
   133→    const token = extractBearerToken(authHeader);
   134→
   135→    let stripeCustomerId = null;
   136→
   137→    if (token) {
   138→      const decoded = verifyToken(token);
   139→      if (decoded && decoded.sub) {
   140→        stripeCustomerId = decoded.sub;
   141→        req.tokenData = decoded;
   142→      } else {
   143→        // Token present but invalid
   144→        return res.status(401).json({
   145→          error: 'Invalid or expired token',
   146→          message: 'Please log in again to continue'
   147→        });
   148→      }
   149→    } else {
   150→      // DEPRECATED: Fallback to legacy header
   151→      const legacyId = req.headers['x-stripe-customer-id'];
   152→      if (legacyId) {
   153→        // SECURITY: Block legacy auth in production unless explicitly enabled
   154→        if (isProduction && !ALLOW_LEGACY_AUTH) {
   155→          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);
   156→          return res.status(401).json({
   157→            error: 'Authentication method not supported',
   158→            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'
   159→          });
   160→        }
   161→
   162→        // SECURITY: Rate limit legacy auth attempts to prevent brute force
   163→        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';
   164→        if (isLegacyAuthRateLimited(clientIp)) {
   165→          return res.status(429).json({
   166→            error: 'Too many authentication attempts',
   167→            message: 'Please wait before trying again'
   168→          });
   169→        }
   170→
   171→        // Validate format to prevent injection
   172→        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {
   173→          return res.status(401).json({
   174→            error: 'Invalid customer ID format',
   175→            message: 'Customer ID must be a valid Stripe customer ID'
   176→          });
   177→        }
   178→
   179→        // SECURITY: Verify customer exists in database before accepting
   180→        const exists = await customerExists(legacyId);
   181→        if (!exists) {
   182→          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);
   183→          return res.status(401).json({
   184→            error: 'Invalid customer ID',
   185→            message: 'Customer not found'
   186→          });
   187→        }
   188→
   189→        stripeCustomerId = legacyId;
   190→        req.isLegacyAuth = true;
   191→        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);
   192→      }
   193→    }
   194→
   195→    if (!stripeCustomerId) {
   196→      return res.status(401).json({
   197→        error: 'Authentication required',
   198→        message: 'Missing Stripe customer ID'
   199→      });
   200→    }
   201→
   202→    // Store for later use
   203→    req.stripeCustomerId = stripeCustomerId;
   204→
   205→    // Determine estimated duration - use request value, option value, or default
   206→    const estSeconds = req.estimatedDuration || estimatedSeconds;
   207→
   208→    try {
   209→      // Atomically reserve credits using SELECT...FOR UPDATE
   210→      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);
   211→
   212→      if (!reservation.success) {
   213→        // Reservation failed - not enough credits
   214→        const balance = await getBalance(stripeCustomerId);
   215→        return res.status(402).json({
   216→          error: 'Insufficient credits',
   217→          message: 'Please upgrade your plan or wait for your next billing cycle',
   218→          balance: {
   219→            hoursRemaining: balance.hoursRemaining,
   220→            tier: balance.tier
   221→          }
   222→        });
   223→      }
   224→
   225→      // Store reservation info for confirmation/release
   226→      req.reservation = {
   227→        id: reservation.reservationId,
   228→        seconds: estSeconds,
   229→        hoursReserved: reservation.hoursReserved
   230→      };
   231→
   232→      // Attach helper function to confirm usage with actual duration
   233→      // This adjusts the reservation if actual duration differs
   234→      req.deductUsage = async (actualDurationSeconds) => {
   235→        return await confirmReservation(
   236→          stripeCustomerId,
   237→          actualDurationSeconds,
   238→          estSeconds,
   239→          endpoint
   240→        );
   241→      };
   242→
   243→      // Attach helper function to release reservation on failure
   244→      req.releaseReservation = async (reason = 'processing_failed') => {
   245→        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);
   246→      };
   247→
   248→      // Hook into response to auto-release on error responses
   249→      const originalSend = res.send.bind(res);
   250→      res.send = function(body) {
   251→        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation
   252→        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {
   253→          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)
   254→            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));
   255→        }
   256→        return originalSend(body);
   257→      };
   258→
   259→      next();
   260→    } catch (err) {
   261→      console.error('[RateLimiter] Error reserving credits:', err);
   262→      return res.status(500).json({
   263→        error: 'Credit check failed',
   264→        message: err.message
   265→      });
   266→    }
   267→  };
   268→}
   269→
   270→/**
   271→ * Middleware to track usage after successful response
   272→ *
   273→ * Call this after processing to deduct actual usage
   274→ */
   275→function trackUsage(endpoint = 'unknown') {
   276→  return async (req, res, next) => {
   277→    // Store original json method
   278→    const originalJson = res.json.bind(res);
   279→
   280→    // Override json to track usage on success
   281→    res.json = async (data) => {
   282→      // Only deduct on successful responses
   283→      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {
   284→        try {
   285→          const balance = await deductUsage(
   286→            req.stripeCustomerId,
   287→            req.audioDuration,
   288→            endpoint
   289→          );
   290→          // Attach updated balance to response
   291→          data.balance = balance;
   292→        } catch (err) {
   293→          console.error('[RateLimiter] Error deducting usage:', err);
   294→        }
   295→      }
   296→      return originalJson(data);
   297→    };
   298→
   299→    next();
   300→  };
   301→}
   302→
   303→module.exports = {
   304→  requireCredits,
   305→  trackUsage,
   306→  ipRateLimit
   307→};
   308→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
