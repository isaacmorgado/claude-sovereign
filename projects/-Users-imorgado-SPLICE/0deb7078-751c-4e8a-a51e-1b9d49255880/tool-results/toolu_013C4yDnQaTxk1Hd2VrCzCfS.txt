     1→/**
     2→ * SPLICE Text Editor Plugin Module
     3→ *
     4→ * Provides UI for text-based video editing.
     5→ * Edit video by editing the transcript text.
     6→ * Delete text to delete video, reorder paragraphs to reorder video.
     7→ */
     8→
     9→// ============================================================================
    10→// STATE
    11→// ============================================================================
    12→
    13→const textEditorState = {
    14→  originalTranscript: null,
    15→  editableTranscript: null,
    16→  currentText: '',
    17→  undoStack: [],
    18→  redoStack: [],
    19→  searchResults: [],
    20→  currentSearchIndex: -1,
    21→  isDirty: false,
    22→  isProcessing: false,
    23→  previewChanges: null
    24→};
    25→
    26→// ============================================================================
    27→// INITIALIZATION
    28→// ============================================================================
    29→
    30→/**
    31→ * Initialize text editor module
    32→ */
    33→async function initTextEditor() {
    34→  console.log('[SPLICE] Initializing text editor module');
    35→
    36→  // Setup event listeners
    37→  setupTextEditorListeners();
    38→
    39→  // Setup keyboard shortcuts
    40→  setupKeyboardShortcuts();
    41→
    42→  console.log('[SPLICE] Text editor module initialized');
    43→}
    44→
    45→/**
    46→ * Setup event listeners for text editor
    47→ */
    48→function setupTextEditorListeners() {
    49→  // Text area input
    50→  document.addEventListener('input', (e) => {
    51→    if (e.target.id === 'text-editor-content') {
    52→      handleTextChange(e.target.value);
    53→    }
    54→  });
    55→
    56→  // Button clicks
    57→  document.addEventListener('click', (e) => {
    58→    // Apply edits
    59→    if (e.target.id === 'apply-text-edits-btn') {
    60→      applyTextEdits();
    61→    }
    62→
    63→    // Preview edits
    64→    if (e.target.id === 'preview-text-edits-btn') {
    65→      previewTextEdits();
    66→    }
    67→
    68→    // Undo/Redo
    69→    if (e.target.id === 'text-editor-undo-btn') {
    70→      undoTextEdit();
    71→    }
    72→    if (e.target.id === 'text-editor-redo-btn') {
    73→      redoTextEdit();
    74→    }
    75→
    76→    // Search
    77→    if (e.target.id === 'text-search-btn') {
    78→      searchInTranscript();
    79→    }
    80→    if (e.target.id === 'text-search-next-btn') {
    81→      navigateSearchResult(1);
    82→    }
    83→    if (e.target.id === 'text-search-prev-btn') {
    84→      navigateSearchResult(-1);
    85→    }
    86→
    87→    // Replace
    88→    if (e.target.id === 'text-replace-btn') {
    89→      replaceInTranscript();
    90→    }
    91→    if (e.target.id === 'text-replace-all-btn') {
    92→      replaceAllInTranscript();
    93→    }
    94→
    95→    // Reset
    96→    if (e.target.id === 'text-editor-reset-btn') {
    97→      resetToOriginal();
    98→    }
    99→
   100→    // Build sequence
   101→    if (e.target.id === 'text-editor-build-btn') {
   102→      buildSequenceFromEdits();
   103→    }
   104→  });
   105→
   106→  // Search input enter key
   107→  document.addEventListener('keypress', (e) => {
   108→    if (e.target.id === 'text-search-input' && e.key === 'Enter') {
   109→      e.preventDefault();
   110→      searchInTranscript();
   111→    }
   112→  });
   113→}
   114→
   115→/**
   116→ * Setup keyboard shortcuts
   117→ */
   118→function setupKeyboardShortcuts() {
   119→  document.addEventListener('keydown', (e) => {
   120→    // Only handle if text editor is focused
   121→    const editorContent = document.getElementById('text-editor-content');
   122→    if (!editorContent || document.activeElement !== editorContent) return;
   123→
   124→    // Ctrl/Cmd + Z = Undo
   125→    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
   126→      e.preventDefault();
   127→      undoTextEdit();
   128→    }
   129→
   130→    // Ctrl/Cmd + Shift + Z or Ctrl/Cmd + Y = Redo
   131→    if ((e.ctrlKey || e.metaKey) && (e.key === 'Z' || e.key === 'y')) {
   132→      e.preventDefault();
   133→      redoTextEdit();
   134→    }
   135→
   136→    // Ctrl/Cmd + F = Focus search
   137→    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
   138→      e.preventDefault();
   139→      const searchInput = document.getElementById('text-search-input');
   140→      if (searchInput) searchInput.focus();
   141→    }
   142→  });
   143→}
   144→
   145→// ============================================================================
   146→// TRANSCRIPT LOADING
   147→// ============================================================================
   148→
   149→/**
   150→ * Load transcript into text editor
   151→ * @param {Object} transcript - Transcript from main module
   152→ */
   153→async function loadTranscriptIntoEditor(transcript) {
   154→  if (!transcript) {
   155→    showTextEditorStatus('No transcript available', 'error');
   156→    return;
   157→  }
   158→
   159→  textEditorState.isProcessing = true;
   160→  updateProcessingState(true);
   161→  showTextEditorStatus('Preparing editable transcript...', 'info');
   162→
   163→  try {
   164→    const { getBackendUrl, fetchWithTimeout, getAuthHeaders } = window.spliceConfig || {};
   165→    const backendUrl = getBackendUrl ? getBackendUrl() : 'https://127.0.0.1:3847';
   166→    const headers = getAuthHeaders ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   167→
   168→    const response = await (fetchWithTimeout || fetch)(`${backendUrl}/text-edit/prepare`, {
   169→      method: 'POST',
   170→      headers,
   171→      body: JSON.stringify({ transcript })
   172→    });
   173→
   174→    if (!response.ok) {
   175→      const err = await response.json();
   176→      throw new Error(err.error || 'Failed to prepare transcript');
   177→    }
   178→
   179→    const data = await response.json();
   180→
   181→    // Store original and editable transcripts
   182→    textEditorState.originalTranscript = transcript;
   183→    textEditorState.editableTranscript = data.editableTranscript;
   184→    textEditorState.currentText = data.editableTranscript.plainText;
   185→    textEditorState.isDirty = false;
   186→    textEditorState.undoStack = [];
   187→    textEditorState.redoStack = [];
   188→
   189→    // Render editor
   190→    renderTextEditor();
   191→
   192→    showTextEditorStatus(`Loaded ${data.editableTranscript.totalWords} words`, 'success');
   193→
   194→  } catch (err) {
   195→    console.error('[SPLICE] Text editor load error:', err);
   196→    showTextEditorStatus(err.message, 'error');
   197→  } finally {
   198→    textEditorState.isProcessing = false;
   199→    updateProcessingState(false);
   200→  }
   201→}
   202→
   203→// ============================================================================
   204→// TEXT EDITING
   205→// ============================================================================
   206→
   207→/**
   208→ * Handle text changes in editor
   209→ */
   210→function handleTextChange(newText) {
   211→  // Save current state to undo stack
   212→  if (textEditorState.currentText !== newText) {
   213→    textEditorState.undoStack.push(textEditorState.currentText);
   214→    textEditorState.redoStack = []; // Clear redo stack on new edit
   215→
   216→    // Limit undo stack size
   217→    if (textEditorState.undoStack.length > 50) {
   218→      textEditorState.undoStack.shift();
   219→    }
   220→  }
   221→
   222→  textEditorState.currentText = newText;
   223→  textEditorState.isDirty = true;
   224→  textEditorState.previewChanges = null; // Clear preview
   225→
   226→  updateEditorStatus();
   227→}
   228→
   229→/**
   230→ * Undo last text edit
   231→ */
   232→function undoTextEdit() {
   233→  if (textEditorState.undoStack.length === 0) {
   234→    showTextEditorStatus('Nothing to undo', 'info');
   235→    return;
   236→  }
   237→
   238→  // Save current to redo stack
   239→  textEditorState.redoStack.push(textEditorState.currentText);
   240→
   241→  // Restore from undo stack
   242→  textEditorState.currentText = textEditorState.undoStack.pop();
   243→
   244→  // Update editor content
   245→  const editor = document.getElementById('text-editor-content');
   246→  if (editor) {
   247→    editor.value = textEditorState.currentText;
   248→  }
   249→
   250→  updateEditorStatus();
   251→  showTextEditorStatus('Undo applied', 'info');
   252→}
   253→
   254→/**
   255→ * Redo last undone edit
   256→ */
   257→function redoTextEdit() {
   258→  if (textEditorState.redoStack.length === 0) {
   259→    showTextEditorStatus('Nothing to redo', 'info');
   260→    return;
   261→  }
   262→
   263→  // Save current to undo stack
   264→  textEditorState.undoStack.push(textEditorState.currentText);
   265→
   266→  // Restore from redo stack
   267→  textEditorState.currentText = textEditorState.redoStack.pop();
   268→
   269→  // Update editor content
   270→  const editor = document.getElementById('text-editor-content');
   271→  if (editor) {
   272→    editor.value = textEditorState.currentText;
   273→  }
   274→
   275→  updateEditorStatus();
   276→  showTextEditorStatus('Redo applied', 'info');
   277→}
   278→
   279→/**
   280→ * Reset to original transcript
   281→ */
   282→function resetToOriginal() {
   283→  if (!textEditorState.editableTranscript) return;
   284→
   285→  // Save current to undo
   286→  if (textEditorState.isDirty) {
   287→    textEditorState.undoStack.push(textEditorState.currentText);
   288→  }
   289→
   290→  textEditorState.currentText = textEditorState.editableTranscript.plainText;
   291→  textEditorState.isDirty = false;
   292→  textEditorState.previewChanges = null;
   293→
   294→  const editor = document.getElementById('text-editor-content');
   295→  if (editor) {
   296→    editor.value = textEditorState.currentText;
   297→  }
   298→
   299→  updateEditorStatus();
   300→  showTextEditorStatus('Reset to original', 'success');
   301→}
   302→
   303→// ============================================================================
   304→// PREVIEW AND APPLY
   305→// ============================================================================
   306→
   307→/**
   308→ * Preview text edits without applying
   309→ */
   310→async function previewTextEdits() {
   311→  if (!textEditorState.editableTranscript || !textEditorState.isDirty) {
   312→    showTextEditorStatus('No changes to preview', 'info');
   313→    return;
   314→  }
   315→
   316→  textEditorState.isProcessing = true;
   317→  updateProcessingState(true);
   318→  showTextEditorStatus('Generating preview...', 'info');
   319→
   320→  try {
   321→    const { getBackendUrl, fetchWithTimeout, getAuthHeaders } = window.spliceConfig || {};
   322→    const backendUrl = getBackendUrl ? getBackendUrl() : 'https://127.0.0.1:3847';
   323→    const headers = getAuthHeaders ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   324→
   325→    const response = await (fetchWithTimeout || fetch)(`${backendUrl}/text-edit/preview`, {
   326→      method: 'POST',
   327→      headers,
   328→      body: JSON.stringify({
   329→        transcript: textEditorState.editableTranscript,
   330→        editedText: textEditorState.currentText
   331→      })
   332→    });
   333→
   334→    if (!response.ok) {
   335→      const err = await response.json();
   336→      throw new Error(err.error || 'Preview failed');
   337→    }
   338→
   339→    const data = await response.json();
   340→    textEditorState.previewChanges = data;
   341→
   342→    renderPreview(data);
   343→    showTextEditorStatus(`Preview: ${data.changes.length} changes`, 'success');
   344→
   345→  } catch (err) {
   346→    console.error('[SPLICE] Text edit preview error:', err);
   347→    showTextEditorStatus(err.message, 'error');
   348→  } finally {
   349→    textEditorState.isProcessing = false;
   350→    updateProcessingState(false);
   351→  }
   352→}
   353→
   354→/**
   355→ * Render preview of changes
   356→ */
   357→function renderPreview(preview) {
   358→  const container = document.getElementById('text-editor-preview');
   359→  if (!container) return;
   360→
   361→  if (!preview.changes || preview.changes.length === 0) {
   362→    container.innerHTML = '<div class="preview-empty">No changes detected</div>';
   363→    return;
   364→  }
   365→
   366→  const html = `
   367→    <div class="preview-summary">
   368→      <span class="preview-stat">${preview.summary.deletions} deletions</span>
   369→      <span class="preview-stat">${preview.summary.reorderings} reorders</span>
   370→      <span class="preview-stat">${preview.impact.percentageRemoved}% removed</span>
   371→    </div>
   372→    <div class="preview-changes">
   373→      ${preview.changes.map(change => `
   374→        <div class="preview-change preview-change-${change.type}">
   375→          <span class="change-type">${change.type}</span>
   376→          <span class="change-desc">${change.description}</span>
   377→          <span class="change-time">${change.timeRange}</span>
   378→        </div>
   379→      `).join('')}
   380→    </div>
   381→  `;
   382→
   383→  container.innerHTML = html;
   384→}
   385→
   386→/**
   387→ * Apply text edits and generate cut list
   388→ */
   389→async function applyTextEdits() {
   390→  if (!textEditorState.editableTranscript || !textEditorState.isDirty) {
   391→    showTextEditorStatus('No changes to apply', 'info');
   392→    return;
   393→  }
   394→
   395→  textEditorState.isProcessing = true;
   396→  updateProcessingState(true);
   397→  showTextEditorStatus('Applying edits...', 'info');
   398→
   399→  try {
   400→    const { getBackendUrl, fetchWithTimeout, getAuthHeaders } = window.spliceConfig || {};
   401→    const backendUrl = getBackendUrl ? getBackendUrl() : 'https://127.0.0.1:3847';
   402→    const headers = getAuthHeaders ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   403→
   404→    // Apply edits
   405→    const applyResponse = await (fetchWithTimeout || fetch)(`${backendUrl}/text-edit/apply`, {
   406→      method: 'POST',
   407→      headers,
   408→      body: JSON.stringify({
   409→        transcript: textEditorState.editableTranscript,
   410→        editedText: textEditorState.currentText
   411→      })
   412→    });
   413→
   414→    if (!applyResponse.ok) {
   415→      const err = await applyResponse.json();
   416→      throw new Error(err.error || 'Apply failed');
   417→    }
   418→
   419→    const applyData = await applyResponse.json();
   420→
   421→    // Generate cut list from operations
   422→    const cutListResponse = await (fetchWithTimeout || fetch)(`${backendUrl}/text-edit/cut-list`, {
   423→      method: 'POST',
   424→      headers,
   425→      body: JSON.stringify({
   426→        operations: applyData.operations,
   427→        sourceInfo: {
   428→          sourceName: textEditorState.originalTranscript?.source?.name || 'source',
   429→          duration: textEditorState.editableTranscript.duration
   430→        }
   431→      })
   432→    });
   433→
   434→    if (!cutListResponse.ok) {
   435→      const err = await cutListResponse.json();
   436→      throw new Error(err.error || 'Cut list generation failed');
   437→    }
   438→
   439→    const cutListData = await cutListResponse.json();
   440→
   441→    // Store cut list for building
   442→    textEditorState.lastCutList = cutListData.cutList;
   443→
   444→    // Update state
   445→    textEditorState.isDirty = false;
   446→
   447→    showTextEditorStatus(
   448→      `Applied ${applyData.stats.deletions} cuts, ${cutListData.summary.segmentCount} segments`,
   449→      'success'
   450→    );
   451→
   452→    // Show build button
   453→    updateBuildButtonState(true);
   454→
   455→  } catch (err) {
   456→    console.error('[SPLICE] Text edit apply error:', err);
   457→    showTextEditorStatus(err.message, 'error');
   458→  } finally {
   459→    textEditorState.isProcessing = false;
   460→    updateProcessingState(false);
   461→  }
   462→}
   463→
   464→/**
   465→ * Build sequence from applied edits
   466→ */
   467→async function buildSequenceFromEdits() {
   468→  if (!textEditorState.lastCutList) {
   469→    showTextEditorStatus('No edits to build. Apply edits first.', 'error');
   470→    return;
   471→  }
   472→
   473→  showTextEditorStatus('Building sequence...', 'info');
   474→
   475→  try {
   476→    // Use builder to create sequence
   477→    if (window.spliceBuilder?.buildSequence) {
   478→      await window.spliceBuilder.buildSequence(textEditorState.lastCutList);
   479→      showTextEditorStatus('Sequence built successfully', 'success');
   480→    } else {
   481→      showTextEditorStatus('Builder not available', 'error');
   482→    }
   483→  } catch (err) {
   484→    console.error('[SPLICE] Build sequence error:', err);
   485→    showTextEditorStatus(err.message, 'error');
   486→  }
   487→}
   488→
   489→// ============================================================================
   490→// SEARCH AND REPLACE
   491→// ============================================================================
   492→
   493→/**
   494→ * Search in transcript
   495→ */
   496→async function searchInTranscript() {
   497→  const searchInput = document.getElementById('text-search-input');
   498→  const searchText = searchInput?.value?.trim();
   499→
   500→  if (!searchText) {
   501→    showTextEditorStatus('Enter search text', 'info');
   502→    return;
   503→  }
   504→
   505→  if (!textEditorState.editableTranscript) {
   506→    showTextEditorStatus('No transcript loaded', 'error');
   507→    return;
   508→  }
   509→
   510→  try {
   511→    const { getBackendUrl, fetchWithTimeout, getAuthHeaders } = window.spliceConfig || {};
   512→    const backendUrl = getBackendUrl ? getBackendUrl() : 'https://127.0.0.1:3847';
   513→    const headers = getAuthHeaders ? getAuthHeaders() : { 'Content-Type': 'application/json' };
   514→
   515→    const response = await (fetchWithTimeout || fetch)(`${backendUrl}/text-edit/search`, {
   516→      method: 'POST',
   517→      headers,
   518→      body: JSON.stringify({
   519→        transcript: textEditorState.editableTranscript,
   520→        searchText
   521→      })
   522→    });
   523→
   524→    if (!response.ok) {
   525→      const err = await response.json();
   526→      throw new Error(err.error || 'Search failed');
   527→    }
   528→
   529→    const data = await response.json();
   530→    textEditorState.searchResults = data.matches || [];
   531→    textEditorState.currentSearchIndex = data.matches.length > 0 ? 0 : -1;
   532→
   533→    highlightSearchResults();
   534→    showTextEditorStatus(`Found ${data.totalMatches} matches`, 'success');
   535→
   536→  } catch (err) {
   537→    console.error('[SPLICE] Search error:', err);
   538→    showTextEditorStatus(err.message, 'error');
   539→  }
   540→}
   541→
   542→/**
   543→ * Navigate search results
   544→ */
   545→function navigateSearchResult(direction) {
   546→  if (textEditorState.searchResults.length === 0) {
   547→    showTextEditorStatus('No search results', 'info');
   548→    return;
   549→  }
   550→
   551→  textEditorState.currentSearchIndex += direction;
   552→
   553→  // Wrap around
   554→  if (textEditorState.currentSearchIndex >= textEditorState.searchResults.length) {
   555→    textEditorState.currentSearchIndex = 0;
   556→  } else if (textEditorState.currentSearchIndex < 0) {
   557→    textEditorState.currentSearchIndex = textEditorState.searchResults.length - 1;
   558→  }
   559→
   560→  highlightCurrentResult();
   561→  updateSearchResultsDisplay();
   562→}
   563→
   564→/**
   565→ * Highlight search results in editor
   566→ */
   567→function highlightSearchResults() {
   568→  // For simplicity, just update counter - full highlighting would need contenteditable
   569→  updateSearchResultsDisplay();
   570→
   571→  if (textEditorState.currentSearchIndex >= 0) {
   572→    highlightCurrentResult();
   573→  }
   574→}
   575→
   576→/**
   577→ * Highlight current search result
   578→ */
   579→function highlightCurrentResult() {
   580→  const result = textEditorState.searchResults[textEditorState.currentSearchIndex];
   581→  if (!result) return;
   582→
   583→  // Scroll to result position in textarea
   584→  const editor = document.getElementById('text-editor-content');
   585→  if (editor) {
   586→    // Simple approach: find text position and scroll
   587→    const text = editor.value;
   588→    const searchPos = text.toLowerCase().indexOf(result.text.toLowerCase());
   589→    if (searchPos >= 0) {
   590→      editor.setSelectionRange(searchPos, searchPos + result.text.length);
   591→      editor.focus();
   592→    }
   593→  }
   594→
   595→  // Show time info
   596→  showTextEditorStatus(
   597→    `Match ${textEditorState.currentSearchIndex + 1}/${textEditorState.searchResults.length} at ${formatTime(result.start)}`,
   598→    'info'
   599→  );
   600→}
   601→
   602→/**
   603→ * Update search results display
   604→ */
   605→function updateSearchResultsDisplay() {
   606→  const display = document.getElementById('text-search-results');
   607→  if (display) {
   608→    const current = textEditorState.currentSearchIndex + 1;
   609→    const total = textEditorState.searchResults.length;
   610→    display.textContent = total > 0 ? `${current}/${total}` : '0/0';
   611→  }
   612→}
   613→
   614→/**
   615→ * Replace in transcript
   616→ */
   617→async function replaceInTranscript() {
   618→  const searchText = document.getElementById('text-search-input')?.value?.trim();
   619→  const replaceText = document.getElementById('text-replace-input')?.value || '';
   620→
   621→  if (!searchText) {
   622→    showTextEditorStatus('Enter search text', 'info');
   623→    return;
   624→  }
   625→
   626→  // Replace in current text
   627→  const newText = textEditorState.currentText.replace(
   628→    new RegExp(escapeRegex(searchText), 'i'),
   629→    replaceText
   630→  );
   631→
   632→  if (newText !== textEditorState.currentText) {
   633→    handleTextChange(newText);
   634→    const editor = document.getElementById('text-editor-content');
   635→    if (editor) editor.value = newText;
   636→    showTextEditorStatus('Replaced 1 occurrence', 'success');
   637→  } else {
   638→    showTextEditorStatus('No match found', 'info');
   639→  }
   640→}
   641→
   642→/**
   643→ * Replace all occurrences in transcript
   644→ */
   645→async function replaceAllInTranscript() {
   646→  const searchText = document.getElementById('text-search-input')?.value?.trim();
   647→  const replaceText = document.getElementById('text-replace-input')?.value || '';
   648→
   649→  if (!searchText) {
   650→    showTextEditorStatus('Enter search text', 'info');
   651→    return;
   652→  }
   653→
   654→  const regex = new RegExp(escapeRegex(searchText), 'gi');
   655→  const matches = textEditorState.currentText.match(regex);
   656→  const count = matches ? matches.length : 0;
   657→
   658→  if (count > 0) {
   659→    const newText = textEditorState.currentText.replace(regex, replaceText);
   660→    handleTextChange(newText);
   661→    const editor = document.getElementById('text-editor-content');
   662→    if (editor) editor.value = newText;
   663→    showTextEditorStatus(`Replaced ${count} occurrences`, 'success');
   664→  } else {
   665→    showTextEditorStatus('No matches found', 'info');
   666→  }
   667→}
   668→
   669→/**
   670→ * Escape special regex characters
   671→ */
   672→function escapeRegex(string) {
   673→  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
   674→}
   675→
   676→// ============================================================================
   677→// UI RENDERING
   678→// ============================================================================
   679→
   680→/**
   681→ * Render text editor content
   682→ */
   683→function renderTextEditor() {
   684→  const container = document.getElementById('text-editor-content');
   685→  if (!container) return;
   686→
   687→  container.value = textEditorState.currentText;
   688→  updateEditorStatus();
   689→}
   690→
   691→/**
   692→ * Update editor status display
   693→ */
   694→function updateEditorStatus() {
   695→  const wordCount = document.getElementById('text-editor-word-count');
   696→  const dirtyIndicator = document.getElementById('text-editor-dirty');
   697→  const undoBtn = document.getElementById('text-editor-undo-btn');
   698→  const redoBtn = document.getElementById('text-editor-redo-btn');
   699→
   700→  if (wordCount) {
   701→    const words = textEditorState.currentText.split(/\s+/).filter(w => w.length > 0);
   702→    wordCount.textContent = `${words.length} words`;
   703→  }
   704→
   705→  if (dirtyIndicator) {
   706→    dirtyIndicator.style.display = textEditorState.isDirty ? 'inline' : 'none';
   707→  }
   708→
   709→  if (undoBtn) {
   710→    undoBtn.disabled = textEditorState.undoStack.length === 0;
   711→  }
   712→
   713→  if (redoBtn) {
   714→    redoBtn.disabled = textEditorState.redoStack.length === 0;
   715→  }
   716→}
   717→
   718→/**
   719→ * Update processing state UI
   720→ */
   721→function updateProcessingState(isProcessing) {
   722→  const buttons = document.querySelectorAll('#text-editor-panel button');
   723→  buttons.forEach(btn => {
   724→    if (!btn.classList.contains('always-enabled')) {
   725→      btn.disabled = isProcessing;
   726→    }
   727→  });
   728→
   729→  const editor = document.getElementById('text-editor-content');
   730→  if (editor) {
   731→    editor.disabled = isProcessing;
   732→  }
   733→}
   734→
   735→/**
   736→ * Update build button state
   737→ */
   738→function updateBuildButtonState(enabled) {
   739→  const btn = document.getElementById('text-editor-build-btn');
   740→  if (btn) {
   741→    btn.disabled = !enabled;
   742→    btn.classList.toggle('ready', enabled);
   743→  }
   744→}
   745→
   746→/**
   747→ * Show status message
   748→ */
   749→function showTextEditorStatus(message, type = 'info') {
   750→  const statusEl = document.getElementById('text-editor-status');
   751→  if (!statusEl) return;
   752→
   753→  statusEl.textContent = message;
   754→  statusEl.className = `text-editor-status text-editor-status-${type}`;
   755→
   756→  if (type !== 'error') {
   757→    setTimeout(() => {
   758→      statusEl.textContent = '';
   759→      statusEl.className = 'text-editor-status';
   760→    }, 5000);
   761→  }
   762→}
   763→
   764→/**
   765→ * Format time for display
   766→ */
   767→function formatTime(seconds) {
   768→  const mins = Math.floor(seconds / 60);
   769→  const secs = Math.floor(seconds % 60);
   770→  return `${mins}:${secs.toString().padStart(2, '0')}`;
   771→}
   772→
   773→// ============================================================================
   774→// EXPORTS
   775→// ============================================================================
   776→
   777→// Export for global access
   778→window.spliceTextEditor = {
   779→  init: initTextEditor,
   780→  loadTranscript: loadTranscriptIntoEditor,
   781→  applyEdits: applyTextEdits,
   782→  previewEdits: previewTextEdits,
   783→  undo: undoTextEdit,
   784→  redo: redoTextEdit,
   785→  reset: resetToOriginal,
   786→  search: searchInTranscript,
   787→  buildSequence: buildSequenceFromEdits,
   788→  getState: () => textEditorState
   789→};
   790→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
