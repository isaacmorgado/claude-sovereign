{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":"Explore the SPLICE codebase to determine if CSRF protection is already implemented on these two frontend API routes:\n\n1. `/Users/imorgado/SPLICE/splice-website/src/app/api/auth/logout/route.ts`\n   - Check if it uses `csrfGuard` or forwards X-CSRF-Token header to backend\n   - Compare to how `/Users/imorgado/SPLICE/splice-website/src/app/api/contact/route.ts` implements CSRF\n\n2. `/Users/imorgado/SPLICE/splice-website/src/app/api/auth/refresh/route.ts`\n   - Check if it forwards the X-CSRF-Token header to the backend\n   - Check if `csrfGuard` is called\n\nAlso check:\n- `/Users/imorgado/SPLICE/splice-website/src/lib/csrf-server.ts` - what does `csrfGuard` do?\n- `/Users/imorgado/SPLICE/splice-website/src/context/AuthContext.tsx` - how does logout/refresh handle CSRF?\n\nReport whether CSRF is already implemented or missing for these endpoints."},"uuid":"e3c8af5c-d435-4fd7-bc86-e149853dee45","timestamp":"2025-12-30T02:19:47.661Z"}
{"parentUuid":"e3c8af5c-d435-4fd7-bc86-e149853dee45","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DnMp3AKhikg2CYzL3s5gGh","type":"message","role":"assistant","content":[{"type":"text","text":"I'll explore the SPLICE codebase to check CSRF protection on those API routes. Let me start by reading the relevant files."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20583,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20583,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWc56cTawP3jKovQyQz4R","type":"assistant","uuid":"e51156a4-4fc5-46db-ab83-5fe363ab0d8b","timestamp":"2025-12-30T02:19:49.467Z"}
{"parentUuid":"e51156a4-4fc5-46db-ab83-5fe363ab0d8b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DnMp3AKhikg2CYzL3s5gGh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011v4PDx6JemuckAdmLiPrZC","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/logout/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20583,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20583,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWc56cTawP3jKovQyQz4R","type":"assistant","uuid":"dcf41fba-38ae-4a7e-a5c7-d334d82c1015","timestamp":"2025-12-30T02:19:49.881Z"}
{"parentUuid":"dcf41fba-38ae-4a7e-a5c7-d334d82c1015","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DnMp3AKhikg2CYzL3s5gGh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QMkRd3U2cLuEYrAbYcSta1","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/refresh/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20583,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20583,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWc56cTawP3jKovQyQz4R","type":"assistant","uuid":"511fab82-0671-4c5a-bddd-9ddce9f70c4a","timestamp":"2025-12-30T02:19:49.983Z"}
{"parentUuid":"511fab82-0671-4c5a-bddd-9ddce9f70c4a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DnMp3AKhikg2CYzL3s5gGh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LQShMH1v6BaHsi9ngQnw5H","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/lib/csrf-server.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20583,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20583,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWc56cTawP3jKovQyQz4R","type":"assistant","uuid":"703211b1-5ded-4c10-a30d-5d199a545e3f","timestamp":"2025-12-30T02:19:50.308Z"}
{"parentUuid":"703211b1-5ded-4c10-a30d-5d199a545e3f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DnMp3AKhikg2CYzL3s5gGh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XmHUQpMcbN9QXECvDoT9tS","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/contact/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20583,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20583,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWc56cTawP3jKovQyQz4R","type":"assistant","uuid":"6f391ced-964e-47cc-bba9-0f7d90be8376","timestamp":"2025-12-30T02:19:50.493Z"}
{"parentUuid":"6f391ced-964e-47cc-bba9-0f7d90be8376","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01DnMp3AKhikg2CYzL3s5gGh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01F9En76zTbE2pD6mWxAqJvL","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/context/AuthContext.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20583,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20583,"ephemeral_1h_input_tokens":0},"output_tokens":345,"service_tier":"standard"}},"requestId":"req_011CWc56cTawP3jKovQyQz4R","type":"assistant","uuid":"fee3fcc3-8d64-47b7-8800-dd3327047c51","timestamp":"2025-12-30T02:19:50.642Z"}
{"parentUuid":"fee3fcc3-8d64-47b7-8800-dd3327047c51","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011v4PDx6JemuckAdmLiPrZC","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import { cookies } from \"next/headers\";\n     3→\n     4→// Backend API URL for authentication\n     5→const BACKEND_API_URL =\n     6→  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n     7→\n     8→const isProduction = process.env.NODE_ENV === \"production\";\n     9→\n    10→export async function POST(_request: NextRequest) {\n    11→  try {\n    12→    const cookieStore = await cookies();\n    13→    const token = cookieStore.get(\"splice_token\")?.value;\n    14→    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n    15→\n    16→    // If we have tokens, notify the backend to blacklist them\n    17→    if (token) {\n    18→      try {\n    19→        await fetch(`${BACKEND_API_URL}/auth/logout`, {\n    20→          method: \"POST\",\n    21→          headers: {\n    22→            \"Content-Type\": \"application/json\",\n    23→            Authorization: `Bearer ${token}`,\n    24→          },\n    25→          body: JSON.stringify({ refreshToken }),\n    26→        });\n    27→      } catch (backendError) {\n    28→        // Log but don't fail - we still want to clear cookies\n    29→        console.error(\"[Auth] Backend logout error:\", backendError);\n    30→      }\n    31→    }\n    32→\n    33→    // Create response\n    34→    const response = NextResponse.json({\n    35→      success: true,\n    36→      message: \"Logged out successfully\",\n    37→    });\n    38→\n    39→    // Clear all auth cookies by setting them with maxAge: 0\n    40→    response.cookies.set(\"splice_token\", \"\", {\n    41→      httpOnly: true,\n    42→      secure: isProduction,\n    43→      sameSite: \"strict\",\n    44→      path: \"/\",\n    45→      maxAge: 0,\n    46→    });\n    47→\n    48→    response.cookies.set(\"splice_refresh_token\", \"\", {\n    49→      httpOnly: true,\n    50→      secure: isProduction,\n    51→      sameSite: \"strict\",\n    52→      path: \"/\",\n    53→      maxAge: 0,\n    54→    });\n    55→\n    56→    response.cookies.set(\"splice_auth_status\", \"\", {\n    57→      httpOnly: false,\n    58→      secure: isProduction,\n    59→      sameSite: \"strict\",\n    60→      path: \"/\",\n    61→      maxAge: 0,\n    62→    });\n    63→\n    64→    response.cookies.set(\"splice_user\", \"\", {\n    65→      httpOnly: false,\n    66→      secure: isProduction,\n    67→      sameSite: \"strict\",\n    68→      path: \"/\",\n    69→      maxAge: 0,\n    70→    });\n    71→\n    72→    return response;\n    73→  } catch (error) {\n    74→    console.error(\"[Auth] Logout error:\", error);\n    75→\n    76→    // Even on error, try to clear cookies\n    77→    const response = NextResponse.json(\n    78→      {\n    79→        success: true,\n    80→        message: \"Logged out locally\",\n    81→      },\n    82→      { status: 200 }\n    83→    );\n    84→\n    85→    // Clear cookies anyway\n    86→    response.cookies.set(\"splice_token\", \"\", { maxAge: 0, path: \"/\" });\n    87→    response.cookies.set(\"splice_refresh_token\", \"\", { maxAge: 0, path: \"/\" });\n    88→    response.cookies.set(\"splice_auth_status\", \"\", { maxAge: 0, path: \"/\" });\n    89→    response.cookies.set(\"splice_user\", \"\", { maxAge: 0, path: \"/\" });\n    90→\n    91→    return response;\n    92→  }\n    93→}\n    94→\n\n</system-reminder>\n"}]},"uuid":"cf170bf8-49f3-4cd9-8931-1a9a66d900ca","timestamp":"2025-12-30T02:19:50.687Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/logout/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport { cookies } from \"next/headers\";\n\n// Backend API URL for authentication\nconst BACKEND_API_URL =\n  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n\nconst isProduction = process.env.NODE_ENV === \"production\";\n\nexport async function POST(_request: NextRequest) {\n  try {\n    const cookieStore = await cookies();\n    const token = cookieStore.get(\"splice_token\")?.value;\n    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n\n    // If we have tokens, notify the backend to blacklist them\n    if (token) {\n      try {\n        await fetch(`${BACKEND_API_URL}/auth/logout`, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${token}`,\n          },\n          body: JSON.stringify({ refreshToken }),\n        });\n      } catch (backendError) {\n        // Log but don't fail - we still want to clear cookies\n        console.error(\"[Auth] Backend logout error:\", backendError);\n      }\n    }\n\n    // Create response\n    const response = NextResponse.json({\n      success: true,\n      message: \"Logged out successfully\",\n    });\n\n    // Clear all auth cookies by setting them with maxAge: 0\n    response.cookies.set(\"splice_token\", \"\", {\n      httpOnly: true,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n\n    response.cookies.set(\"splice_refresh_token\", \"\", {\n      httpOnly: true,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n\n    response.cookies.set(\"splice_auth_status\", \"\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n\n    response.cookies.set(\"splice_user\", \"\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: 0,\n    });\n\n    return response;\n  } catch (error) {\n    console.error(\"[Auth] Logout error:\", error);\n\n    // Even on error, try to clear cookies\n    const response = NextResponse.json(\n      {\n        success: true,\n        message: \"Logged out locally\",\n      },\n      { status: 200 }\n    );\n\n    // Clear cookies anyway\n    response.cookies.set(\"splice_token\", \"\", { maxAge: 0, path: \"/\" });\n    response.cookies.set(\"splice_refresh_token\", \"\", { maxAge: 0, path: \"/\" });\n    response.cookies.set(\"splice_auth_status\", \"\", { maxAge: 0, path: \"/\" });\n    response.cookies.set(\"splice_user\", \"\", { maxAge: 0, path: \"/\" });\n\n    return response;\n  }\n}\n","numLines":94,"startLine":1,"totalLines":94}}}
{"parentUuid":"cf170bf8-49f3-4cd9-8931-1a9a66d900ca","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QMkRd3U2cLuEYrAbYcSta1","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import { cookies } from \"next/headers\";\n     3→\n     4→// Backend API URL for authentication\n     5→const BACKEND_API_URL =\n     6→  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n     7→\n     8→const isProduction = process.env.NODE_ENV === \"production\";\n     9→const ACCESS_TOKEN_MAX_AGE = 60 * 60; // 1 hour in seconds\n    10→\n    11→export async function POST(_request: NextRequest) {\n    12→  try {\n    13→    const cookieStore = await cookies();\n    14→    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n    15→\n    16→    if (!refreshToken) {\n    17→      return NextResponse.json(\n    18→        { error: \"Refresh token is required\", success: false },\n    19→        { status: 400 }\n    20→      );\n    21→    }\n    22→\n    23→    // Forward the refresh request to the backend\n    24→    const response = await fetch(`${BACKEND_API_URL}/auth/refresh`, {\n    25→      method: \"POST\",\n    26→      headers: {\n    27→        \"Content-Type\": \"application/json\",\n    28→      },\n    29→      body: JSON.stringify({ refreshToken }),\n    30→    });\n    31→\n    32→    const data = await response.json();\n    33→\n    34→    if (!response.ok || !data.success) {\n    35→      // Clear auth cookies on refresh failure\n    36→      const errorResponse = NextResponse.json(\n    37→        {\n    38→          error: data.error || \"Token refresh failed\",\n    39→          message: data.message || \"Please log in again\",\n    40→          success: false,\n    41→        },\n    42→        { status: response.status }\n    43→      );\n    44→\n    45→      // Clear cookies\n    46→      errorResponse.cookies.set(\"splice_token\", \"\", {\n    47→        httpOnly: true,\n    48→        secure: isProduction,\n    49→        sameSite: \"strict\",\n    50→        path: \"/\",\n    51→        maxAge: 0,\n    52→      });\n    53→      errorResponse.cookies.set(\"splice_auth_status\", \"\", {\n    54→        httpOnly: false,\n    55→        secure: isProduction,\n    56→        sameSite: \"strict\",\n    57→        path: \"/\",\n    58→        maxAge: 0,\n    59→      });\n    60→      errorResponse.cookies.set(\"splice_user\", \"\", {\n    61→        httpOnly: false,\n    62→        secure: isProduction,\n    63→        sameSite: \"strict\",\n    64→        path: \"/\",\n    65→        maxAge: 0,\n    66→      });\n    67→\n    68→      return errorResponse;\n    69→    }\n    70→\n    71→    // Create response with success\n    72→    const jsonResponse = NextResponse.json({\n    73→      success: true,\n    74→      tokenType: data.tokenType,\n    75→      expiresIn: data.expiresIn,\n    76→    });\n    77→\n    78→    // Update the access token cookie\n    79→    jsonResponse.cookies.set(\"splice_token\", data.token, {\n    80→      httpOnly: true,\n    81→      secure: isProduction,\n    82→      sameSite: \"strict\",\n    83→      path: \"/\",\n    84→      maxAge: ACCESS_TOKEN_MAX_AGE,\n    85→    });\n    86→\n    87→    // Update auth status cookie\n    88→    jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n    89→      httpOnly: false,\n    90→      secure: isProduction,\n    91→      sameSite: \"strict\",\n    92→      path: \"/\",\n    93→      maxAge: ACCESS_TOKEN_MAX_AGE,\n    94→    });\n    95→\n    96→    return jsonResponse;\n    97→  } catch (error) {\n    98→    console.error(\"[Auth] Refresh error:\", error);\n    99→    return NextResponse.json(\n   100→      {\n   101→        error: \"Token refresh failed\",\n   102→        message: \"Unable to refresh authentication. Please log in again.\",\n   103→        success: false,\n   104→      },\n   105→      { status: 500 }\n   106→    );\n   107→  }\n   108→}\n   109→\n\n</system-reminder>\n"}]},"uuid":"8ad9af56-c781-4129-9c6b-5c26c66fde91","timestamp":"2025-12-30T02:19:50.687Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/refresh/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport { cookies } from \"next/headers\";\n\n// Backend API URL for authentication\nconst BACKEND_API_URL =\n  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst ACCESS_TOKEN_MAX_AGE = 60 * 60; // 1 hour in seconds\n\nexport async function POST(_request: NextRequest) {\n  try {\n    const cookieStore = await cookies();\n    const refreshToken = cookieStore.get(\"splice_refresh_token\")?.value;\n\n    if (!refreshToken) {\n      return NextResponse.json(\n        { error: \"Refresh token is required\", success: false },\n        { status: 400 }\n      );\n    }\n\n    // Forward the refresh request to the backend\n    const response = await fetch(`${BACKEND_API_URL}/auth/refresh`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ refreshToken }),\n    });\n\n    const data = await response.json();\n\n    if (!response.ok || !data.success) {\n      // Clear auth cookies on refresh failure\n      const errorResponse = NextResponse.json(\n        {\n          error: data.error || \"Token refresh failed\",\n          message: data.message || \"Please log in again\",\n          success: false,\n        },\n        { status: response.status }\n      );\n\n      // Clear cookies\n      errorResponse.cookies.set(\"splice_token\", \"\", {\n        httpOnly: true,\n        secure: isProduction,\n        sameSite: \"strict\",\n        path: \"/\",\n        maxAge: 0,\n      });\n      errorResponse.cookies.set(\"splice_auth_status\", \"\", {\n        httpOnly: false,\n        secure: isProduction,\n        sameSite: \"strict\",\n        path: \"/\",\n        maxAge: 0,\n      });\n      errorResponse.cookies.set(\"splice_user\", \"\", {\n        httpOnly: false,\n        secure: isProduction,\n        sameSite: \"strict\",\n        path: \"/\",\n        maxAge: 0,\n      });\n\n      return errorResponse;\n    }\n\n    // Create response with success\n    const jsonResponse = NextResponse.json({\n      success: true,\n      tokenType: data.tokenType,\n      expiresIn: data.expiresIn,\n    });\n\n    // Update the access token cookie\n    jsonResponse.cookies.set(\"splice_token\", data.token, {\n      httpOnly: true,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: ACCESS_TOKEN_MAX_AGE,\n    });\n\n    // Update auth status cookie\n    jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\",\n      path: \"/\",\n      maxAge: ACCESS_TOKEN_MAX_AGE,\n    });\n\n    return jsonResponse;\n  } catch (error) {\n    console.error(\"[Auth] Refresh error:\", error);\n    return NextResponse.json(\n      {\n        error: \"Token refresh failed\",\n        message: \"Unable to refresh authentication. Please log in again.\",\n        success: false,\n      },\n      { status: 500 }\n    );\n  }\n}\n","numLines":109,"startLine":1,"totalLines":109}}}
{"parentUuid":"8ad9af56-c781-4129-9c6b-5c26c66fde91","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LQShMH1v6BaHsi9ngQnw5H","type":"tool_result","content":"     1→/**\n     2→ * CSRF Protection Utilities for Next.js API Routes (Server-side)\n     3→ *\n     4→ * Validates CSRF tokens in incoming requests.\n     5→ * Works with the double-submit cookie pattern.\n     6→ */\n     7→\n     8→import { NextRequest, NextResponse } from \"next/server\";\n     9→import { cookies } from \"next/headers\";\n    10→\n    11→// Constants (must match client-side)\n    12→const CSRF_COOKIE_NAME = \"splice_csrf\";\n    13→const CSRF_HEADER_NAME = \"x-csrf-token\";\n    14→\n    15→/**\n    16→ * Constant-time string comparison to prevent timing attacks\n    17→ */\n    18→function safeCompare(a: string, b: string): boolean {\n    19→  if (a.length !== b.length) {\n    20→    return false;\n    21→  }\n    22→\n    23→  let result = 0;\n    24→  for (let i = 0; i < a.length; i++) {\n    25→    result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n    26→  }\n    27→  return result === 0;\n    28→}\n    29→\n    30→/**\n    31→ * Validate CSRF token from request\n    32→ * Compares the token in the header with the token in the cookie\n    33→ *\n    34→ * @param request - Next.js request object\n    35→ * @returns { valid: boolean, error?: string }\n    36→ */\n    37→export async function validateCsrfToken(\n    38→  request: NextRequest\n    39→): Promise<{ valid: boolean; error?: string }> {\n    40→  // Get token from header\n    41→  const headerToken = request.headers.get(CSRF_HEADER_NAME);\n    42→\n    43→  if (!headerToken) {\n    44→    return {\n    45→      valid: false,\n    46→      error: \"CSRF token missing from request header\",\n    47→    };\n    48→  }\n    49→\n    50→  // Get token from cookie\n    51→  const cookieStore = await cookies();\n    52→  const cookieToken = cookieStore.get(CSRF_COOKIE_NAME)?.value;\n    53→\n    54→  if (!cookieToken) {\n    55→    return {\n    56→      valid: false,\n    57→      error: \"CSRF cookie not found. Please refresh the page.\",\n    58→    };\n    59→  }\n    60→\n    61→  // Compare tokens using constant-time comparison\n    62→  if (!safeCompare(headerToken, cookieToken)) {\n    63→    return {\n    64→      valid: false,\n    65→      error: \"CSRF token validation failed. Please refresh the page.\",\n    66→    };\n    67→  }\n    68→\n    69→  return { valid: true };\n    70→}\n    71→\n    72→/**\n    73→ * CSRF validation wrapper for API route handlers\n    74→ * Returns an error response if CSRF validation fails\n    75→ *\n    76→ * @param request - Next.js request object\n    77→ * @returns NextResponse if validation fails, null if valid\n    78→ */\n    79→export async function csrfGuard(\n    80→  request: NextRequest\n    81→): Promise<NextResponse | null> {\n    82→  // Skip CSRF validation for safe methods\n    83→  if ([\"GET\", \"HEAD\", \"OPTIONS\"].includes(request.method)) {\n    84→    return null;\n    85→  }\n    86→\n    87→  const result = await validateCsrfToken(request);\n    88→\n    89→  if (!result.valid) {\n    90→    console.warn(\"[CSRF] Validation failed:\", result.error);\n    91→    return NextResponse.json(\n    92→      {\n    93→        error: \"CSRF validation failed\",\n    94→        message: result.error || \"Please refresh the page and try again\",\n    95→      },\n    96→      { status: 403 }\n    97→    );\n    98→  }\n    99→\n   100→  return null;\n   101→}\n   102→\n   103→/**\n   104→ * Higher-order function to wrap API handlers with CSRF protection\n   105→ *\n   106→ * @example\n   107→ * ```typescript\n   108→ * export const POST = withCsrfProtection(async (request) => {\n   109→ *   // Your handler code here\n   110→ *   return NextResponse.json({ success: true });\n   111→ * });\n   112→ * ```\n   113→ */\n   114→export function withCsrfProtection(\n   115→  handler: (request: NextRequest) => Promise<NextResponse>\n   116→): (request: NextRequest) => Promise<NextResponse> {\n   117→  return async (request: NextRequest): Promise<NextResponse> => {\n   118→    const csrfError = await csrfGuard(request);\n   119→    if (csrfError) {\n   120→      return csrfError;\n   121→    }\n   122→    return handler(request);\n   123→  };\n   124→}\n   125→\n   126→export { CSRF_COOKIE_NAME, CSRF_HEADER_NAME };\n   127→\n\n</system-reminder>\n"}]},"uuid":"28ea26a7-6380-45e4-8b1b-e5d47b3913b0","timestamp":"2025-12-30T02:19:50.687Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/lib/csrf-server.ts","content":"/**\n * CSRF Protection Utilities for Next.js API Routes (Server-side)\n *\n * Validates CSRF tokens in incoming requests.\n * Works with the double-submit cookie pattern.\n */\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { cookies } from \"next/headers\";\n\n// Constants (must match client-side)\nconst CSRF_COOKIE_NAME = \"splice_csrf\";\nconst CSRF_HEADER_NAME = \"x-csrf-token\";\n\n/**\n * Constant-time string comparison to prevent timing attacks\n */\nfunction safeCompare(a: string, b: string): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n  }\n  return result === 0;\n}\n\n/**\n * Validate CSRF token from request\n * Compares the token in the header with the token in the cookie\n *\n * @param request - Next.js request object\n * @returns { valid: boolean, error?: string }\n */\nexport async function validateCsrfToken(\n  request: NextRequest\n): Promise<{ valid: boolean; error?: string }> {\n  // Get token from header\n  const headerToken = request.headers.get(CSRF_HEADER_NAME);\n\n  if (!headerToken) {\n    return {\n      valid: false,\n      error: \"CSRF token missing from request header\",\n    };\n  }\n\n  // Get token from cookie\n  const cookieStore = await cookies();\n  const cookieToken = cookieStore.get(CSRF_COOKIE_NAME)?.value;\n\n  if (!cookieToken) {\n    return {\n      valid: false,\n      error: \"CSRF cookie not found. Please refresh the page.\",\n    };\n  }\n\n  // Compare tokens using constant-time comparison\n  if (!safeCompare(headerToken, cookieToken)) {\n    return {\n      valid: false,\n      error: \"CSRF token validation failed. Please refresh the page.\",\n    };\n  }\n\n  return { valid: true };\n}\n\n/**\n * CSRF validation wrapper for API route handlers\n * Returns an error response if CSRF validation fails\n *\n * @param request - Next.js request object\n * @returns NextResponse if validation fails, null if valid\n */\nexport async function csrfGuard(\n  request: NextRequest\n): Promise<NextResponse | null> {\n  // Skip CSRF validation for safe methods\n  if ([\"GET\", \"HEAD\", \"OPTIONS\"].includes(request.method)) {\n    return null;\n  }\n\n  const result = await validateCsrfToken(request);\n\n  if (!result.valid) {\n    console.warn(\"[CSRF] Validation failed:\", result.error);\n    return NextResponse.json(\n      {\n        error: \"CSRF validation failed\",\n        message: result.error || \"Please refresh the page and try again\",\n      },\n      { status: 403 }\n    );\n  }\n\n  return null;\n}\n\n/**\n * Higher-order function to wrap API handlers with CSRF protection\n *\n * @example\n * ```typescript\n * export const POST = withCsrfProtection(async (request) => {\n *   // Your handler code here\n *   return NextResponse.json({ success: true });\n * });\n * ```\n */\nexport function withCsrfProtection(\n  handler: (request: NextRequest) => Promise<NextResponse>\n): (request: NextRequest) => Promise<NextResponse> {\n  return async (request: NextRequest): Promise<NextResponse> => {\n    const csrfError = await csrfGuard(request);\n    if (csrfError) {\n      return csrfError;\n    }\n    return handler(request);\n  };\n}\n\nexport { CSRF_COOKIE_NAME, CSRF_HEADER_NAME };\n","numLines":127,"startLine":1,"totalLines":127}}}
{"parentUuid":"28ea26a7-6380-45e4-8b1b-e5d47b3913b0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XmHUQpMcbN9QXECvDoT9tS","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import { csrfGuard } from \"@/lib/csrf-server\";\n     3→\n     4→// Force Node.js runtime for better compatibility\n     5→export const runtime = \"nodejs\";\n     6→export const maxDuration = 30;\n     7→\n     8→// =============================================================================\n     9→// IP-based Rate Limiting\n    10→// =============================================================================\n    11→\n    12→// Rate limit configuration: 5 requests per hour per IP\n    13→const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; // 1 hour in milliseconds\n    14→const RATE_LIMIT_MAX_REQUESTS = 5;\n    15→\n    16→// In-memory store for rate limiting\n    17→// Key: IP address, Value: { count: number, windowStart: number }\n    18→const rateLimitStore = new Map<string, { count: number; windowStart: number }>();\n    19→\n    20→// Cleanup old entries every 10 minutes to prevent memory leaks\n    21→if (typeof setInterval !== \"undefined\") {\n    22→  setInterval(() => {\n    23→    const now = Date.now();\n    24→    const ipsToDelete: string[] = [];\n    25→    rateLimitStore.forEach((data, ip) => {\n    26→      // Mark entries older than 2x the window (2 hours) for deletion\n    27→      if (now - data.windowStart > RATE_LIMIT_WINDOW_MS * 2) {\n    28→        ipsToDelete.push(ip);\n    29→      }\n    30→    });\n    31→    ipsToDelete.forEach((ip) => rateLimitStore.delete(ip));\n    32→  }, 10 * 60 * 1000); // Every 10 minutes\n    33→}\n    34→\n    35→/**\n    36→ * Get client IP address from request headers\n    37→ * Handles various proxy configurations (Vercel, Cloudflare, nginx, etc.)\n    38→ */\n    39→function getClientIp(request: NextRequest): string {\n    40→  // x-forwarded-for can contain multiple IPs; the first one is the client\n    41→  const forwardedFor = request.headers.get(\"x-forwarded-for\");\n    42→  if (forwardedFor) {\n    43→    const firstIp = forwardedFor.split(\",\")[0].trim();\n    44→    if (firstIp) return firstIp;\n    45→  }\n    46→\n    47→  // x-real-ip is set by some proxies (nginx, etc.)\n    48→  const realIp = request.headers.get(\"x-real-ip\");\n    49→  if (realIp) return realIp.trim();\n    50→\n    51→  // Vercel-specific header\n    52→  const vercelForwardedFor = request.headers.get(\"x-vercel-forwarded-for\");\n    53→  if (vercelForwardedFor) {\n    54→    const firstIp = vercelForwardedFor.split(\",\")[0].trim();\n    55→    if (firstIp) return firstIp;\n    56→  }\n    57→\n    58→  // Fallback - this shouldn't happen in production behind a proxy\n    59→  return \"unknown\";\n    60→}\n    61→\n    62→/**\n    63→ * Check if an IP is rate limited\n    64→ * Returns: { limited: boolean, retryAfter?: number }\n    65→ */\n    66→function checkRateLimit(ip: string): { limited: boolean; retryAfter?: number } {\n    67→  const now = Date.now();\n    68→  const data = rateLimitStore.get(ip);\n    69→\n    70→  // No previous requests or window expired - start fresh\n    71→  if (!data || now - data.windowStart > RATE_LIMIT_WINDOW_MS) {\n    72→    rateLimitStore.set(ip, { count: 1, windowStart: now });\n    73→    return { limited: false };\n    74→  }\n    75→\n    76→  // Increment count\n    77→  data.count++;\n    78→\n    79→  // Check if over limit\n    80→  if (data.count > RATE_LIMIT_MAX_REQUESTS) {\n    81→    // Calculate seconds until window resets\n    82→    const retryAfterMs = RATE_LIMIT_WINDOW_MS - (now - data.windowStart);\n    83→    const retryAfterSeconds = Math.ceil(retryAfterMs / 1000);\n    84→    return { limited: true, retryAfter: retryAfterSeconds };\n    85→  }\n    86→\n    87→  return { limited: false };\n    88→}\n    89→\n    90→// Email configuration\n    91→const EMAIL_CONFIG = {\n    92→  from: process.env.EMAIL_FROM || \"SPLICE <noreply@splice.video>\",\n    93→  salesEmail: \"sales@splice.app\",\n    94→  sendgridApiKey: process.env.SENDGRID_API_KEY,\n    95→};\n    96→\n    97→// Request body interface\n    98→interface ContactFormData {\n    99→  name: string;\n   100→  email: string;\n   101→  company?: string;\n   102→  teamSize?: string;\n   103→  message: string;\n   104→}\n   105→\n   106→// Validation helper\n   107→function validateEmail(email: string): boolean {\n   108→  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n   109→  return emailRegex.test(email);\n   110→}\n   111→\n   112→// Escape HTML to prevent XSS in email content\n   113→function escapeHtml(str: string): string {\n   114→  if (str === null || str === undefined) return \"\";\n   115→  const escapeMap: Record<string, string> = {\n   116→    \"&\": \"&amp;\",\n   117→    \"<\": \"&lt;\",\n   118→    \">\": \"&gt;\",\n   119→    '\"': \"&quot;\",\n   120→    \"'\": \"&#x27;\",\n   121→  };\n   122→  return str.replace(/[&<>\"']/g, (char) => escapeMap[char]);\n   123→}\n   124→\n   125→// Generate email HTML template\n   126→function generateEmailHtml(data: ContactFormData): string {\n   127→  return `\n   128→<!DOCTYPE html>\n   129→<html lang=\"en\">\n   130→<head>\n   131→  <meta charset=\"UTF-8\">\n   132→  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n   133→  <title>New Contact Form Submission</title>\n   134→  <style>\n   135→    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; margin: 0; padding: 0; }\n   136→    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; background: white; }\n   137→    .header { text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 2px solid #00D4FF; }\n   138→    .logo { font-size: 28px; font-weight: bold; color: #00D4FF; }\n   139→    .badge { display: inline-block; background: #00D4FF; color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; margin-top: 10px; }\n   140→    .content { padding: 20px 0; }\n   141→    .field { margin-bottom: 20px; }\n   142→    .field-label { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: #6b7280; margin-bottom: 5px; }\n   143→    .field-value { font-size: 16px; color: #1e293b; background: #f8fafc; padding: 12px 16px; border-radius: 8px; border-left: 3px solid #00D4FF; }\n   144→    .message-box { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; padding: 20px; margin-top: 20px; }\n   145→    .message-box h3 { color: #166534; margin-top: 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }\n   146→    .message-content { color: #15803d; white-space: pre-wrap; }\n   147→    .footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 14px; }\n   148→    .reply-button { display: inline-block; background: #00D4FF; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; margin-top: 20px; font-weight: 500; }\n   149→  </style>\n   150→</head>\n   151→<body>\n   152→  <div class=\"container\">\n   153→    <div class=\"header\">\n   154→      <div class=\"logo\">SPLICE</div>\n   155→      <div class=\"badge\">New Contact Form Submission</div>\n   156→    </div>\n   157→\n   158→    <div class=\"content\">\n   159→      <div class=\"field\">\n   160→        <div class=\"field-label\">Name</div>\n   161→        <div class=\"field-value\">${escapeHtml(data.name)}</div>\n   162→      </div>\n   163→\n   164→      <div class=\"field\">\n   165→        <div class=\"field-label\">Email</div>\n   166→        <div class=\"field-value\"><a href=\"mailto:${escapeHtml(data.email)}\" style=\"color: #00A8CC;\">${escapeHtml(data.email)}</a></div>\n   167→      </div>\n   168→\n   169→      ${\n   170→        data.company\n   171→          ? `\n   172→      <div class=\"field\">\n   173→        <div class=\"field-label\">Company</div>\n   174→        <div class=\"field-value\">${escapeHtml(data.company)}</div>\n   175→      </div>\n   176→      `\n   177→          : \"\"\n   178→      }\n   179→\n   180→      ${\n   181→        data.teamSize\n   182→          ? `\n   183→      <div class=\"field\">\n   184→        <div class=\"field-label\">Team Size</div>\n   185→        <div class=\"field-value\">${escapeHtml(data.teamSize)}</div>\n   186→      </div>\n   187→      `\n   188→          : \"\"\n   189→      }\n   190→\n   191→      <div class=\"message-box\">\n   192→        <h3>Message</h3>\n   193→        <div class=\"message-content\">${escapeHtml(data.message)}</div>\n   194→      </div>\n   195→\n   196→      <div style=\"text-align: center;\">\n   197→        <a href=\"mailto:${escapeHtml(data.email)}?subject=Re: SPLICE Contact Form\" class=\"reply-button\">Reply to ${escapeHtml(data.name)}</a>\n   198→      </div>\n   199→    </div>\n   200→\n   201→    <div class=\"footer\">\n   202→      <p>This message was sent from the SPLICE website contact form.</p>\n   203→      <p style=\"font-size: 12px;\">&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n   204→    </div>\n   205→  </div>\n   206→</body>\n   207→</html>\n   208→  `;\n   209→}\n   210→\n   211→// Generate plain text email\n   212→function generateEmailText(data: ContactFormData): string {\n   213→  return `\n   214→New Contact Form Submission - SPLICE\n   215→=====================================\n   216→\n   217→Name: ${data.name}\n   218→Email: ${data.email}\n   219→${data.company ? `Company: ${data.company}` : \"\"}\n   220→${data.teamSize ? `Team Size: ${data.teamSize}` : \"\"}\n   221→\n   222→Message:\n   223→---------\n   224→${data.message}\n   225→\n   226→---\n   227→This message was sent from the SPLICE website contact form.\n   228→  `.trim();\n   229→}\n   230→\n   231→// Send email via SendGrid\n   232→async function sendEmailNotification(data: ContactFormData): Promise<void> {\n   233→  if (!EMAIL_CONFIG.sendgridApiKey) {\n   234→    console.warn(\"[Contact API] SENDGRID_API_KEY not configured, logging email to console\");\n   235→    console.log(\"[Contact API] Would send email to:\", EMAIL_CONFIG.salesEmail);\n   236→    console.log(\"[Contact API] From:\", data.name, `<${data.email}>`);\n   237→    console.log(\"[Contact API] Message:\", data.message);\n   238→    return;\n   239→  }\n   240→\n   241→  const response = await fetch(\"https://api.sendgrid.com/v3/mail/send\", {\n   242→    method: \"POST\",\n   243→    headers: {\n   244→      Authorization: `Bearer ${EMAIL_CONFIG.sendgridApiKey}`,\n   245→      \"Content-Type\": \"application/json\",\n   246→    },\n   247→    body: JSON.stringify({\n   248→      personalizations: [\n   249→        {\n   250→          to: [{ email: EMAIL_CONFIG.salesEmail }],\n   251→        },\n   252→      ],\n   253→      from: {\n   254→        email: EMAIL_CONFIG.from.match(/<(.+)>/)?.[1] || \"noreply@splice.video\",\n   255→        name: \"SPLICE Contact Form\",\n   256→      },\n   257→      reply_to: {\n   258→        email: data.email,\n   259→        name: data.name,\n   260→      },\n   261→      subject: `[SPLICE Contact] New inquiry from ${data.name}${data.company ? ` (${data.company})` : \"\"}`,\n   262→      content: [\n   263→        { type: \"text/plain\", value: generateEmailText(data) },\n   264→        { type: \"text/html\", value: generateEmailHtml(data) },\n   265→      ],\n   266→    }),\n   267→  });\n   268→\n   269→  if (!response.ok) {\n   270→    const errorText = await response.text();\n   271→    console.error(\"[Contact API] SendGrid error:\", response.status, errorText);\n   272→    throw new Error(`Failed to send email: ${response.status}`);\n   273→  }\n   274→\n   275→  console.log(\"[Contact API] Email sent successfully to\", EMAIL_CONFIG.salesEmail);\n   276→}\n   277→\n   278→export async function POST(request: NextRequest) {\n   279→  // CSRF validation first\n   280→  const csrfError = await csrfGuard(request);\n   281→  if (csrfError) {\n   282→    console.warn(\"[Contact API] CSRF validation failed\");\n   283→    return csrfError;\n   284→  }\n   285→\n   286→  // Check rate limit\n   287→  const clientIp = getClientIp(request);\n   288→  const rateLimitResult = checkRateLimit(clientIp);\n   289→\n   290→  if (rateLimitResult.limited) {\n   291→    console.warn(\n   292→      `[Contact API] Rate limit exceeded for IP: ${clientIp}`\n   293→    );\n   294→\n   295→    const retryAfter = rateLimitResult.retryAfter || 3600;\n   296→    const retryMinutes = Math.ceil(retryAfter / 60);\n   297→\n   298→    return NextResponse.json(\n   299→      {\n   300→        error: \"Too many requests\",\n   301→        message: `You have exceeded the maximum number of contact form submissions. Please try again in ${retryMinutes} minute${retryMinutes === 1 ? \"\" : \"s\"}.`,\n   302→        retryAfter: retryAfter,\n   303→      },\n   304→      {\n   305→        status: 429,\n   306→        headers: {\n   307→          \"Retry-After\": String(retryAfter),\n   308→        },\n   309→      }\n   310→    );\n   311→  }\n   312→\n   313→  try {\n   314→    // Parse request body\n   315→    let body: ContactFormData;\n   316→    try {\n   317→      body = await request.json();\n   318→    } catch {\n   319→      return NextResponse.json(\n   320→        { error: \"Invalid JSON in request body\" },\n   321→        { status: 400 }\n   322→      );\n   323→    }\n   324→\n   325→    const { name, email, company, teamSize, message } = body;\n   326→\n   327→    // Validate required fields\n   328→    const errors: string[] = [];\n   329→\n   330→    if (!name || typeof name !== \"string\" || name.trim().length === 0) {\n   331→      errors.push(\"Name is required\");\n   332→    }\n   333→\n   334→    if (!email || typeof email !== \"string\" || email.trim().length === 0) {\n   335→      errors.push(\"Email is required\");\n   336→    } else if (!validateEmail(email.trim())) {\n   337→      errors.push(\"Invalid email format\");\n   338→    }\n   339→\n   340→    if (!message || typeof message !== \"string\" || message.trim().length === 0) {\n   341→      errors.push(\"Message is required\");\n   342→    }\n   343→\n   344→    if (errors.length > 0) {\n   345→      return NextResponse.json(\n   346→        { error: \"Validation failed\", details: errors },\n   347→        { status: 400 }\n   348→      );\n   349→    }\n   350→\n   351→    // Sanitize and prepare data\n   352→    const sanitizedData: ContactFormData = {\n   353→      name: name.trim(),\n   354→      email: email.trim().toLowerCase(),\n   355→      company: company?.trim() || undefined,\n   356→      teamSize: teamSize?.trim() || undefined,\n   357→      message: message.trim(),\n   358→    };\n   359→\n   360→    // Send email notification\n   361→    await sendEmailNotification(sanitizedData);\n   362→\n   363→    // Return success response\n   364→    return NextResponse.json({\n   365→      success: true,\n   366→      message: \"Your message has been sent successfully. We will get back to you soon!\",\n   367→    });\n   368→  } catch (error) {\n   369→    console.error(\"[Contact API] Error processing contact form:\", error);\n   370→\n   371→    return NextResponse.json(\n   372→      {\n   373→        error: \"Failed to process your request. Please try again later.\",\n   374→        details: error instanceof Error ? error.message : \"Unknown error\",\n   375→      },\n   376→      { status: 500 }\n   377→    );\n   378→  }\n   379→}\n   380→\n\n</system-reminder>\n"}]},"uuid":"7b9d5f08-8305-4254-a973-e6673cd5aafe","timestamp":"2025-12-30T02:19:50.688Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/contact/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport { csrfGuard } from \"@/lib/csrf-server\";\n\n// Force Node.js runtime for better compatibility\nexport const runtime = \"nodejs\";\nexport const maxDuration = 30;\n\n// =============================================================================\n// IP-based Rate Limiting\n// =============================================================================\n\n// Rate limit configuration: 5 requests per hour per IP\nconst RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; // 1 hour in milliseconds\nconst RATE_LIMIT_MAX_REQUESTS = 5;\n\n// In-memory store for rate limiting\n// Key: IP address, Value: { count: number, windowStart: number }\nconst rateLimitStore = new Map<string, { count: number; windowStart: number }>();\n\n// Cleanup old entries every 10 minutes to prevent memory leaks\nif (typeof setInterval !== \"undefined\") {\n  setInterval(() => {\n    const now = Date.now();\n    const ipsToDelete: string[] = [];\n    rateLimitStore.forEach((data, ip) => {\n      // Mark entries older than 2x the window (2 hours) for deletion\n      if (now - data.windowStart > RATE_LIMIT_WINDOW_MS * 2) {\n        ipsToDelete.push(ip);\n      }\n    });\n    ipsToDelete.forEach((ip) => rateLimitStore.delete(ip));\n  }, 10 * 60 * 1000); // Every 10 minutes\n}\n\n/**\n * Get client IP address from request headers\n * Handles various proxy configurations (Vercel, Cloudflare, nginx, etc.)\n */\nfunction getClientIp(request: NextRequest): string {\n  // x-forwarded-for can contain multiple IPs; the first one is the client\n  const forwardedFor = request.headers.get(\"x-forwarded-for\");\n  if (forwardedFor) {\n    const firstIp = forwardedFor.split(\",\")[0].trim();\n    if (firstIp) return firstIp;\n  }\n\n  // x-real-ip is set by some proxies (nginx, etc.)\n  const realIp = request.headers.get(\"x-real-ip\");\n  if (realIp) return realIp.trim();\n\n  // Vercel-specific header\n  const vercelForwardedFor = request.headers.get(\"x-vercel-forwarded-for\");\n  if (vercelForwardedFor) {\n    const firstIp = vercelForwardedFor.split(\",\")[0].trim();\n    if (firstIp) return firstIp;\n  }\n\n  // Fallback - this shouldn't happen in production behind a proxy\n  return \"unknown\";\n}\n\n/**\n * Check if an IP is rate limited\n * Returns: { limited: boolean, retryAfter?: number }\n */\nfunction checkRateLimit(ip: string): { limited: boolean; retryAfter?: number } {\n  const now = Date.now();\n  const data = rateLimitStore.get(ip);\n\n  // No previous requests or window expired - start fresh\n  if (!data || now - data.windowStart > RATE_LIMIT_WINDOW_MS) {\n    rateLimitStore.set(ip, { count: 1, windowStart: now });\n    return { limited: false };\n  }\n\n  // Increment count\n  data.count++;\n\n  // Check if over limit\n  if (data.count > RATE_LIMIT_MAX_REQUESTS) {\n    // Calculate seconds until window resets\n    const retryAfterMs = RATE_LIMIT_WINDOW_MS - (now - data.windowStart);\n    const retryAfterSeconds = Math.ceil(retryAfterMs / 1000);\n    return { limited: true, retryAfter: retryAfterSeconds };\n  }\n\n  return { limited: false };\n}\n\n// Email configuration\nconst EMAIL_CONFIG = {\n  from: process.env.EMAIL_FROM || \"SPLICE <noreply@splice.video>\",\n  salesEmail: \"sales@splice.app\",\n  sendgridApiKey: process.env.SENDGRID_API_KEY,\n};\n\n// Request body interface\ninterface ContactFormData {\n  name: string;\n  email: string;\n  company?: string;\n  teamSize?: string;\n  message: string;\n}\n\n// Validation helper\nfunction validateEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n// Escape HTML to prevent XSS in email content\nfunction escapeHtml(str: string): string {\n  if (str === null || str === undefined) return \"\";\n  const escapeMap: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n  };\n  return str.replace(/[&<>\"']/g, (char) => escapeMap[char]);\n}\n\n// Generate email HTML template\nfunction generateEmailHtml(data: ContactFormData): string {\n  return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>New Contact Form Submission</title>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; margin: 0; padding: 0; }\n    .container { max-width: 600px; margin: 0 auto; padding: 40px 20px; background: white; }\n    .header { text-align: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 2px solid #00D4FF; }\n    .logo { font-size: 28px; font-weight: bold; color: #00D4FF; }\n    .badge { display: inline-block; background: #00D4FF; color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; margin-top: 10px; }\n    .content { padding: 20px 0; }\n    .field { margin-bottom: 20px; }\n    .field-label { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: #6b7280; margin-bottom: 5px; }\n    .field-value { font-size: 16px; color: #1e293b; background: #f8fafc; padding: 12px 16px; border-radius: 8px; border-left: 3px solid #00D4FF; }\n    .message-box { background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; padding: 20px; margin-top: 20px; }\n    .message-box h3 { color: #166534; margin-top: 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }\n    .message-content { color: #15803d; white-space: pre-wrap; }\n    .footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 14px; }\n    .reply-button { display: inline-block; background: #00D4FF; color: white; padding: 12px 24px; border-radius: 6px; text-decoration: none; margin-top: 20px; font-weight: 500; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <div class=\"logo\">SPLICE</div>\n      <div class=\"badge\">New Contact Form Submission</div>\n    </div>\n\n    <div class=\"content\">\n      <div class=\"field\">\n        <div class=\"field-label\">Name</div>\n        <div class=\"field-value\">${escapeHtml(data.name)}</div>\n      </div>\n\n      <div class=\"field\">\n        <div class=\"field-label\">Email</div>\n        <div class=\"field-value\"><a href=\"mailto:${escapeHtml(data.email)}\" style=\"color: #00A8CC;\">${escapeHtml(data.email)}</a></div>\n      </div>\n\n      ${\n        data.company\n          ? `\n      <div class=\"field\">\n        <div class=\"field-label\">Company</div>\n        <div class=\"field-value\">${escapeHtml(data.company)}</div>\n      </div>\n      `\n          : \"\"\n      }\n\n      ${\n        data.teamSize\n          ? `\n      <div class=\"field\">\n        <div class=\"field-label\">Team Size</div>\n        <div class=\"field-value\">${escapeHtml(data.teamSize)}</div>\n      </div>\n      `\n          : \"\"\n      }\n\n      <div class=\"message-box\">\n        <h3>Message</h3>\n        <div class=\"message-content\">${escapeHtml(data.message)}</div>\n      </div>\n\n      <div style=\"text-align: center;\">\n        <a href=\"mailto:${escapeHtml(data.email)}?subject=Re: SPLICE Contact Form\" class=\"reply-button\">Reply to ${escapeHtml(data.name)}</a>\n      </div>\n    </div>\n\n    <div class=\"footer\">\n      <p>This message was sent from the SPLICE website contact form.</p>\n      <p style=\"font-size: 12px;\">&copy; ${new Date().getFullYear()} SPLICE. All rights reserved.</p>\n    </div>\n  </div>\n</body>\n</html>\n  `;\n}\n\n// Generate plain text email\nfunction generateEmailText(data: ContactFormData): string {\n  return `\nNew Contact Form Submission - SPLICE\n=====================================\n\nName: ${data.name}\nEmail: ${data.email}\n${data.company ? `Company: ${data.company}` : \"\"}\n${data.teamSize ? `Team Size: ${data.teamSize}` : \"\"}\n\nMessage:\n---------\n${data.message}\n\n---\nThis message was sent from the SPLICE website contact form.\n  `.trim();\n}\n\n// Send email via SendGrid\nasync function sendEmailNotification(data: ContactFormData): Promise<void> {\n  if (!EMAIL_CONFIG.sendgridApiKey) {\n    console.warn(\"[Contact API] SENDGRID_API_KEY not configured, logging email to console\");\n    console.log(\"[Contact API] Would send email to:\", EMAIL_CONFIG.salesEmail);\n    console.log(\"[Contact API] From:\", data.name, `<${data.email}>`);\n    console.log(\"[Contact API] Message:\", data.message);\n    return;\n  }\n\n  const response = await fetch(\"https://api.sendgrid.com/v3/mail/send\", {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${EMAIL_CONFIG.sendgridApiKey}`,\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      personalizations: [\n        {\n          to: [{ email: EMAIL_CONFIG.salesEmail }],\n        },\n      ],\n      from: {\n        email: EMAIL_CONFIG.from.match(/<(.+)>/)?.[1] || \"noreply@splice.video\",\n        name: \"SPLICE Contact Form\",\n      },\n      reply_to: {\n        email: data.email,\n        name: data.name,\n      },\n      subject: `[SPLICE Contact] New inquiry from ${data.name}${data.company ? ` (${data.company})` : \"\"}`,\n      content: [\n        { type: \"text/plain\", value: generateEmailText(data) },\n        { type: \"text/html\", value: generateEmailHtml(data) },\n      ],\n    }),\n  });\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    console.error(\"[Contact API] SendGrid error:\", response.status, errorText);\n    throw new Error(`Failed to send email: ${response.status}`);\n  }\n\n  console.log(\"[Contact API] Email sent successfully to\", EMAIL_CONFIG.salesEmail);\n}\n\nexport async function POST(request: NextRequest) {\n  // CSRF validation first\n  const csrfError = await csrfGuard(request);\n  if (csrfError) {\n    console.warn(\"[Contact API] CSRF validation failed\");\n    return csrfError;\n  }\n\n  // Check rate limit\n  const clientIp = getClientIp(request);\n  const rateLimitResult = checkRateLimit(clientIp);\n\n  if (rateLimitResult.limited) {\n    console.warn(\n      `[Contact API] Rate limit exceeded for IP: ${clientIp}`\n    );\n\n    const retryAfter = rateLimitResult.retryAfter || 3600;\n    const retryMinutes = Math.ceil(retryAfter / 60);\n\n    return NextResponse.json(\n      {\n        error: \"Too many requests\",\n        message: `You have exceeded the maximum number of contact form submissions. Please try again in ${retryMinutes} minute${retryMinutes === 1 ? \"\" : \"s\"}.`,\n        retryAfter: retryAfter,\n      },\n      {\n        status: 429,\n        headers: {\n          \"Retry-After\": String(retryAfter),\n        },\n      }\n    );\n  }\n\n  try {\n    // Parse request body\n    let body: ContactFormData;\n    try {\n      body = await request.json();\n    } catch {\n      return NextResponse.json(\n        { error: \"Invalid JSON in request body\" },\n        { status: 400 }\n      );\n    }\n\n    const { name, email, company, teamSize, message } = body;\n\n    // Validate required fields\n    const errors: string[] = [];\n\n    if (!name || typeof name !== \"string\" || name.trim().length === 0) {\n      errors.push(\"Name is required\");\n    }\n\n    if (!email || typeof email !== \"string\" || email.trim().length === 0) {\n      errors.push(\"Email is required\");\n    } else if (!validateEmail(email.trim())) {\n      errors.push(\"Invalid email format\");\n    }\n\n    if (!message || typeof message !== \"string\" || message.trim().length === 0) {\n      errors.push(\"Message is required\");\n    }\n\n    if (errors.length > 0) {\n      return NextResponse.json(\n        { error: \"Validation failed\", details: errors },\n        { status: 400 }\n      );\n    }\n\n    // Sanitize and prepare data\n    const sanitizedData: ContactFormData = {\n      name: name.trim(),\n      email: email.trim().toLowerCase(),\n      company: company?.trim() || undefined,\n      teamSize: teamSize?.trim() || undefined,\n      message: message.trim(),\n    };\n\n    // Send email notification\n    await sendEmailNotification(sanitizedData);\n\n    // Return success response\n    return NextResponse.json({\n      success: true,\n      message: \"Your message has been sent successfully. We will get back to you soon!\",\n    });\n  } catch (error) {\n    console.error(\"[Contact API] Error processing contact form:\", error);\n\n    return NextResponse.json(\n      {\n        error: \"Failed to process your request. Please try again later.\",\n        details: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n","numLines":380,"startLine":1,"totalLines":380}}}
{"parentUuid":"7b9d5f08-8305-4254-a973-e6673cd5aafe","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01F9En76zTbE2pD6mWxAqJvL","type":"tool_result","content":"     1→\"use client\";\n     2→\n     3→import React, {\n     4→  createContext,\n     5→  useContext,\n     6→  useState,\n     7→  useEffect,\n     8→  useCallback,\n     9→  useRef,\n    10→  ReactNode,\n    11→} from \"react\";\n    12→import { getCsrfToken, clearCsrfToken, CSRF_HEADER_NAME } from \"@/lib/csrf\";\n    13→\n    14→// Constants for token refresh timing\n    15→const MIN_REFRESH_INTERVAL_MS = 60 * 1000; // Minimum 1 minute between refresh attempts\n    16→const AUTH_CHECK_INTERVAL_MS = 60 * 1000; // Check auth status every minute\n    17→\n    18→// Cookie name for checking auth status (non-HttpOnly cookie set by API)\n    19→const AUTH_STATUS_COOKIE = \"splice_auth_status\";\n    20→const USER_DATA_COOKIE = \"splice_user\";\n    21→\n    22→// Types\n    23→interface UserData {\n    24→  customerId: string;\n    25→  tier: string;\n    26→  hoursRemaining: number;\n    27→  musicCredits?: number;\n    28→  variationsCredits?: number;\n    29→  sceneAwareCredits?: number;\n    30→}\n    31→\n    32→interface AuthState {\n    33→  isAuthenticated: boolean;\n    34→  isLoading: boolean;\n    35→  user: UserData | null;\n    36→}\n    37→\n    38→interface LoginResult {\n    39→  success: boolean;\n    40→  error?: string;\n    41→  message?: string;\n    42→}\n    43→\n    44→interface AuthContextType extends AuthState {\n    45→  login: (licenseKey: string) => Promise<LoginResult>;\n    46→  logout: () => Promise<void>;\n    47→  refreshAuth: () => Promise<boolean>;\n    48→  checkAuth: () => Promise<boolean>;\n    49→}\n    50→\n    51→interface MeResponse {\n    52→  authenticated: boolean;\n    53→  user?: UserData;\n    54→  error?: string;\n    55→  message?: string;\n    56→}\n    57→\n    58→// Create context with undefined default\n    59→const AuthContext = createContext<AuthContextType | undefined>(undefined);\n    60→\n    61→/**\n    62→ * Get cookie value by name\n    63→ */\n    64→function getCookie(name: string): string | null {\n    65→  if (typeof document === \"undefined\") return null;\n    66→\n    67→  const value = `; ${document.cookie}`;\n    68→  const parts = value.split(`; ${name}=`);\n    69→  if (parts.length === 2) {\n    70→    return parts.pop()?.split(\";\").shift() || null;\n    71→  }\n    72→  return null;\n    73→}\n    74→\n    75→/**\n    76→ * Check if auth status cookie exists\n    77→ */\n    78→function hasAuthStatusCookie(): boolean {\n    79→  return getCookie(AUTH_STATUS_COOKIE) === \"authenticated\";\n    80→}\n    81→\n    82→/**\n    83→ * Get user data from cookie\n    84→ */\n    85→function getUserDataFromCookie(): UserData | null {\n    86→  const userCookie = getCookie(USER_DATA_COOKIE);\n    87→  if (!userCookie) return null;\n    88→\n    89→  try {\n    90→    return JSON.parse(decodeURIComponent(userCookie));\n    91→  } catch {\n    92→    return null;\n    93→  }\n    94→}\n    95→\n    96→/**\n    97→ * AuthProvider component\n    98→ * Uses HttpOnly cookies for secure token storage\n    99→ */\n   100→export function AuthProvider({ children }: { children: ReactNode }) {\n   101→  const [authState, setAuthState] = useState<AuthState>({\n   102→    isAuthenticated: false,\n   103→    isLoading: true,\n   104→    user: null,\n   105→  });\n   106→\n   107→  // Refs for managing refresh timer\n   108→  const checkIntervalRef = useRef<NodeJS.Timeout | null>(null);\n   109→  const lastCheckAttemptRef = useRef<number>(0);\n   110→  const isCheckingRef = useRef<boolean>(false);\n   111→\n   112→  /**\n   113→   * Clear all timers\n   114→   */\n   115→  const clearTimers = useCallback(() => {\n   116→    if (checkIntervalRef.current) {\n   117→      clearInterval(checkIntervalRef.current);\n   118→      checkIntervalRef.current = null;\n   119→    }\n   120→  }, []);\n   121→\n   122→  /**\n   123→   * Check authentication status with the server\n   124→   * This verifies the HttpOnly cookie is valid and refreshes if needed\n   125→   */\n   126→  const checkAuth = useCallback(async (): Promise<boolean> => {\n   127→    // Prevent concurrent check attempts\n   128→    if (isCheckingRef.current) {\n   129→      console.log(\"[AuthContext] Auth check already in progress, skipping\");\n   130→      return authState.isAuthenticated;\n   131→    }\n   132→\n   133→    // Rate limit check attempts\n   134→    const now = Date.now();\n   135→    if (now - lastCheckAttemptRef.current < MIN_REFRESH_INTERVAL_MS) {\n   136→      console.log(\"[AuthContext] Auth check rate limited\");\n   137→      return authState.isAuthenticated;\n   138→    }\n   139→\n   140→    isCheckingRef.current = true;\n   141→    lastCheckAttemptRef.current = now;\n   142→\n   143→    try {\n   144→      const response = await fetch(\"/api/auth/me\", {\n   145→        method: \"GET\",\n   146→        credentials: \"include\", // Important for cookie handling\n   147→      });\n   148→\n   149→      const data: MeResponse = await response.json();\n   150→\n   151→      if (data.authenticated && data.user) {\n   152→        setAuthState({\n   153→          isAuthenticated: true,\n   154→          isLoading: false,\n   155→          user: data.user,\n   156→        });\n   157→        return true;\n   158→      } else {\n   159→        setAuthState({\n   160→          isAuthenticated: false,\n   161→          isLoading: false,\n   162→          user: null,\n   163→        });\n   164→        return false;\n   165→      }\n   166→    } catch (error) {\n   167→      console.error(\"[AuthContext] Auth check error:\", error);\n   168→      return false;\n   169→    } finally {\n   170→      isCheckingRef.current = false;\n   171→    }\n   172→  }, [authState.isAuthenticated]);\n   173→\n   174→  /**\n   175→   * Refresh authentication (alias for checkAuth)\n   176→   * The /api/auth/me endpoint handles token refresh internally\n   177→   */\n   178→  const refreshAuth = useCallback(async (): Promise<boolean> => {\n   179→    return checkAuth();\n   180→  }, [checkAuth]);\n   181→\n   182→  /**\n   183→   * Handle user login\n   184→   * Includes CSRF token for protection against cross-site login attacks\n   185→   */\n   186→  const login = useCallback(async (licenseKey: string): Promise<LoginResult> => {\n   187→    try {\n   188→      // Get CSRF token before making login request\n   189→      const csrfToken = await getCsrfToken();\n   190→\n   191→      const response = await fetch(\"/api/auth/login\", {\n   192→        method: \"POST\",\n   193→        headers: {\n   194→          \"Content-Type\": \"application/json\",\n   195→          [CSRF_HEADER_NAME]: csrfToken,\n   196→        },\n   197→        credentials: \"include\", // Important for cookie handling\n   198→        body: JSON.stringify({ licenseKey }),\n   199→      });\n   200→\n   201→      const data = await response.json();\n   202→\n   203→      if (!response.ok || !data.success) {\n   204→        return {\n   205→          success: false,\n   206→          error: data.error,\n   207→          message: data.message || data.error || \"Authentication failed\",\n   208→        };\n   209→      }\n   210→\n   211→      // Update state with user data from response\n   212→      // Tokens are stored in HttpOnly cookies automatically\n   213→      setAuthState({\n   214→        isAuthenticated: true,\n   215→        isLoading: false,\n   216→        user: {\n   217→          customerId: data.customerId,\n   218→          tier: data.tier,\n   219→          hoursRemaining: data.hoursRemaining,\n   220→        },\n   221→      });\n   222→\n   223→      console.log(\"[AuthContext] Login successful\");\n   224→\n   225→      return { success: true };\n   226→    } catch (error) {\n   227→      console.error(\"[AuthContext] Login error:\", error);\n   228→      return {\n   229→        success: false,\n   230→        error: \"Login failed\",\n   231→        message: \"Unable to connect to the server. Please try again.\",\n   232→      };\n   233→    }\n   234→  }, []);\n   235→\n   236→  /**\n   237→   * Handle user logout\n   238→   * Includes CSRF token for protection against forced logout attacks\n   239→   */\n   240→  const logout = useCallback(async () => {\n   241→    // Clear timers first\n   242→    clearTimers();\n   243→\n   244→    try {\n   245→      // Get CSRF token before making logout request\n   246→      const csrfToken = await getCsrfToken();\n   247→\n   248→      await fetch(\"/api/auth/logout\", {\n   249→        method: \"POST\",\n   250→        headers: {\n   251→          [CSRF_HEADER_NAME]: csrfToken,\n   252→        },\n   253→        credentials: \"include\", // Important for cookie handling\n   254→      });\n   255→    } catch (error) {\n   256→      // Ignore logout errors - we'll clear local state anyway\n   257→      console.warn(\"[AuthContext] Logout API call failed:\", error);\n   258→    }\n   259→\n   260→    // Clear CSRF token cache on logout\n   261→    clearCsrfToken();\n   262→\n   263→    // Clear state\n   264→    setAuthState({\n   265→      isAuthenticated: false,\n   266→      isLoading: false,\n   267→      user: null,\n   268→    });\n   269→\n   270→    console.log(\"[AuthContext] Logged out\");\n   271→  }, [clearTimers]);\n   272→\n   273→  /**\n   274→   * Initialize auth state on mount\n   275→   */\n   276→  useEffect(() => {\n   277→    const initAuth = async () => {\n   278→      // Quick check using non-HttpOnly cookie first\n   279→      if (hasAuthStatusCookie()) {\n   280→        // Cookie exists, try to get user data from cookie for immediate UI\n   281→        const userData = getUserDataFromCookie();\n   282→        if (userData) {\n   283→          setAuthState({\n   284→            isAuthenticated: true,\n   285→            isLoading: false,\n   286→            user: userData,\n   287→          });\n   288→        }\n   289→\n   290→        // Then verify with server (this will update if needed)\n   291→        await checkAuth();\n   292→      } else {\n   293→        // No auth cookie, definitely not authenticated\n   294→        setAuthState({\n   295→          isAuthenticated: false,\n   296→          isLoading: false,\n   297→          user: null,\n   298→        });\n   299→      }\n   300→    };\n   301→\n   302→    initAuth();\n   303→\n   304→    // Set up periodic check for auth validity (handles cookie expiry, etc.)\n   305→    checkIntervalRef.current = setInterval(() => {\n   306→      // Only check if we think we're authenticated\n   307→      if (hasAuthStatusCookie()) {\n   308→        checkAuth();\n   309→      } else if (authState.isAuthenticated) {\n   310→        // Cookie was cleared externally\n   311→        setAuthState({\n   312→          isAuthenticated: false,\n   313→          isLoading: false,\n   314→          user: null,\n   315→        });\n   316→      }\n   317→    }, AUTH_CHECK_INTERVAL_MS);\n   318→\n   319→    // Cleanup on unmount\n   320→    return () => {\n   321→      clearTimers();\n   322→    };\n   323→  }, [checkAuth, clearTimers, authState.isAuthenticated]);\n   324→\n   325→  // Handle visibility change (tab focus)\n   326→  useEffect(() => {\n   327→    const handleVisibilityChange = () => {\n   328→      if (document.visibilityState === \"visible\") {\n   329→        // When tab becomes visible, verify auth status\n   330→        if (hasAuthStatusCookie()) {\n   331→          checkAuth();\n   332→        } else if (authState.isAuthenticated) {\n   333→          // Cookie was cleared while tab was hidden\n   334→          setAuthState({\n   335→            isAuthenticated: false,\n   336→            isLoading: false,\n   337→            user: null,\n   338→          });\n   339→        }\n   340→      }\n   341→    };\n   342→\n   343→    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n   344→\n   345→    return () => {\n   346→      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n   347→    };\n   348→  }, [checkAuth, authState.isAuthenticated]);\n   349→\n   350→  const contextValue: AuthContextType = {\n   351→    ...authState,\n   352→    login,\n   353→    logout,\n   354→    refreshAuth,\n   355→    checkAuth,\n   356→  };\n   357→\n   358→  return (\n   359→    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>\n   360→  );\n   361→}\n   362→\n   363→/**\n   364→ * Hook to use auth context\n   365→ */\n   366→export function useAuth(): AuthContextType {\n   367→  const context = useContext(AuthContext);\n   368→  if (context === undefined) {\n   369→    throw new Error(\"useAuth must be used within an AuthProvider\");\n   370→  }\n   371→  return context;\n   372→}\n   373→\n   374→/**\n   375→ * Hook to check if user is authenticated\n   376→ * Simplified version that just returns auth status\n   377→ */\n   378→export function useIsAuthenticated(): {\n   379→  isAuthenticated: boolean;\n   380→  isLoading: boolean;\n   381→  user: UserData | null;\n   382→} {\n   383→  const { isAuthenticated, isLoading, user } = useAuth();\n   384→  return { isAuthenticated, isLoading, user };\n   385→}\n   386→\n   387→export default AuthContext;\n   388→\n\n</system-reminder>\n"}]},"uuid":"e8a03a8a-bb98-4606-b316-21c8b58eeed7","timestamp":"2025-12-30T02:19:50.688Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/context/AuthContext.tsx","content":"\"use client\";\n\nimport React, {\n  createContext,\n  useContext,\n  useState,\n  useEffect,\n  useCallback,\n  useRef,\n  ReactNode,\n} from \"react\";\nimport { getCsrfToken, clearCsrfToken, CSRF_HEADER_NAME } from \"@/lib/csrf\";\n\n// Constants for token refresh timing\nconst MIN_REFRESH_INTERVAL_MS = 60 * 1000; // Minimum 1 minute between refresh attempts\nconst AUTH_CHECK_INTERVAL_MS = 60 * 1000; // Check auth status every minute\n\n// Cookie name for checking auth status (non-HttpOnly cookie set by API)\nconst AUTH_STATUS_COOKIE = \"splice_auth_status\";\nconst USER_DATA_COOKIE = \"splice_user\";\n\n// Types\ninterface UserData {\n  customerId: string;\n  tier: string;\n  hoursRemaining: number;\n  musicCredits?: number;\n  variationsCredits?: number;\n  sceneAwareCredits?: number;\n}\n\ninterface AuthState {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  user: UserData | null;\n}\n\ninterface LoginResult {\n  success: boolean;\n  error?: string;\n  message?: string;\n}\n\ninterface AuthContextType extends AuthState {\n  login: (licenseKey: string) => Promise<LoginResult>;\n  logout: () => Promise<void>;\n  refreshAuth: () => Promise<boolean>;\n  checkAuth: () => Promise<boolean>;\n}\n\ninterface MeResponse {\n  authenticated: boolean;\n  user?: UserData;\n  error?: string;\n  message?: string;\n}\n\n// Create context with undefined default\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n/**\n * Get cookie value by name\n */\nfunction getCookie(name: string): string | null {\n  if (typeof document === \"undefined\") return null;\n\n  const value = `; ${document.cookie}`;\n  const parts = value.split(`; ${name}=`);\n  if (parts.length === 2) {\n    return parts.pop()?.split(\";\").shift() || null;\n  }\n  return null;\n}\n\n/**\n * Check if auth status cookie exists\n */\nfunction hasAuthStatusCookie(): boolean {\n  return getCookie(AUTH_STATUS_COOKIE) === \"authenticated\";\n}\n\n/**\n * Get user data from cookie\n */\nfunction getUserDataFromCookie(): UserData | null {\n  const userCookie = getCookie(USER_DATA_COOKIE);\n  if (!userCookie) return null;\n\n  try {\n    return JSON.parse(decodeURIComponent(userCookie));\n  } catch {\n    return null;\n  }\n}\n\n/**\n * AuthProvider component\n * Uses HttpOnly cookies for secure token storage\n */\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [authState, setAuthState] = useState<AuthState>({\n    isAuthenticated: false,\n    isLoading: true,\n    user: null,\n  });\n\n  // Refs for managing refresh timer\n  const checkIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const lastCheckAttemptRef = useRef<number>(0);\n  const isCheckingRef = useRef<boolean>(false);\n\n  /**\n   * Clear all timers\n   */\n  const clearTimers = useCallback(() => {\n    if (checkIntervalRef.current) {\n      clearInterval(checkIntervalRef.current);\n      checkIntervalRef.current = null;\n    }\n  }, []);\n\n  /**\n   * Check authentication status with the server\n   * This verifies the HttpOnly cookie is valid and refreshes if needed\n   */\n  const checkAuth = useCallback(async (): Promise<boolean> => {\n    // Prevent concurrent check attempts\n    if (isCheckingRef.current) {\n      console.log(\"[AuthContext] Auth check already in progress, skipping\");\n      return authState.isAuthenticated;\n    }\n\n    // Rate limit check attempts\n    const now = Date.now();\n    if (now - lastCheckAttemptRef.current < MIN_REFRESH_INTERVAL_MS) {\n      console.log(\"[AuthContext] Auth check rate limited\");\n      return authState.isAuthenticated;\n    }\n\n    isCheckingRef.current = true;\n    lastCheckAttemptRef.current = now;\n\n    try {\n      const response = await fetch(\"/api/auth/me\", {\n        method: \"GET\",\n        credentials: \"include\", // Important for cookie handling\n      });\n\n      const data: MeResponse = await response.json();\n\n      if (data.authenticated && data.user) {\n        setAuthState({\n          isAuthenticated: true,\n          isLoading: false,\n          user: data.user,\n        });\n        return true;\n      } else {\n        setAuthState({\n          isAuthenticated: false,\n          isLoading: false,\n          user: null,\n        });\n        return false;\n      }\n    } catch (error) {\n      console.error(\"[AuthContext] Auth check error:\", error);\n      return false;\n    } finally {\n      isCheckingRef.current = false;\n    }\n  }, [authState.isAuthenticated]);\n\n  /**\n   * Refresh authentication (alias for checkAuth)\n   * The /api/auth/me endpoint handles token refresh internally\n   */\n  const refreshAuth = useCallback(async (): Promise<boolean> => {\n    return checkAuth();\n  }, [checkAuth]);\n\n  /**\n   * Handle user login\n   * Includes CSRF token for protection against cross-site login attacks\n   */\n  const login = useCallback(async (licenseKey: string): Promise<LoginResult> => {\n    try {\n      // Get CSRF token before making login request\n      const csrfToken = await getCsrfToken();\n\n      const response = await fetch(\"/api/auth/login\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          [CSRF_HEADER_NAME]: csrfToken,\n        },\n        credentials: \"include\", // Important for cookie handling\n        body: JSON.stringify({ licenseKey }),\n      });\n\n      const data = await response.json();\n\n      if (!response.ok || !data.success) {\n        return {\n          success: false,\n          error: data.error,\n          message: data.message || data.error || \"Authentication failed\",\n        };\n      }\n\n      // Update state with user data from response\n      // Tokens are stored in HttpOnly cookies automatically\n      setAuthState({\n        isAuthenticated: true,\n        isLoading: false,\n        user: {\n          customerId: data.customerId,\n          tier: data.tier,\n          hoursRemaining: data.hoursRemaining,\n        },\n      });\n\n      console.log(\"[AuthContext] Login successful\");\n\n      return { success: true };\n    } catch (error) {\n      console.error(\"[AuthContext] Login error:\", error);\n      return {\n        success: false,\n        error: \"Login failed\",\n        message: \"Unable to connect to the server. Please try again.\",\n      };\n    }\n  }, []);\n\n  /**\n   * Handle user logout\n   * Includes CSRF token for protection against forced logout attacks\n   */\n  const logout = useCallback(async () => {\n    // Clear timers first\n    clearTimers();\n\n    try {\n      // Get CSRF token before making logout request\n      const csrfToken = await getCsrfToken();\n\n      await fetch(\"/api/auth/logout\", {\n        method: \"POST\",\n        headers: {\n          [CSRF_HEADER_NAME]: csrfToken,\n        },\n        credentials: \"include\", // Important for cookie handling\n      });\n    } catch (error) {\n      // Ignore logout errors - we'll clear local state anyway\n      console.warn(\"[AuthContext] Logout API call failed:\", error);\n    }\n\n    // Clear CSRF token cache on logout\n    clearCsrfToken();\n\n    // Clear state\n    setAuthState({\n      isAuthenticated: false,\n      isLoading: false,\n      user: null,\n    });\n\n    console.log(\"[AuthContext] Logged out\");\n  }, [clearTimers]);\n\n  /**\n   * Initialize auth state on mount\n   */\n  useEffect(() => {\n    const initAuth = async () => {\n      // Quick check using non-HttpOnly cookie first\n      if (hasAuthStatusCookie()) {\n        // Cookie exists, try to get user data from cookie for immediate UI\n        const userData = getUserDataFromCookie();\n        if (userData) {\n          setAuthState({\n            isAuthenticated: true,\n            isLoading: false,\n            user: userData,\n          });\n        }\n\n        // Then verify with server (this will update if needed)\n        await checkAuth();\n      } else {\n        // No auth cookie, definitely not authenticated\n        setAuthState({\n          isAuthenticated: false,\n          isLoading: false,\n          user: null,\n        });\n      }\n    };\n\n    initAuth();\n\n    // Set up periodic check for auth validity (handles cookie expiry, etc.)\n    checkIntervalRef.current = setInterval(() => {\n      // Only check if we think we're authenticated\n      if (hasAuthStatusCookie()) {\n        checkAuth();\n      } else if (authState.isAuthenticated) {\n        // Cookie was cleared externally\n        setAuthState({\n          isAuthenticated: false,\n          isLoading: false,\n          user: null,\n        });\n      }\n    }, AUTH_CHECK_INTERVAL_MS);\n\n    // Cleanup on unmount\n    return () => {\n      clearTimers();\n    };\n  }, [checkAuth, clearTimers, authState.isAuthenticated]);\n\n  // Handle visibility change (tab focus)\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === \"visible\") {\n        // When tab becomes visible, verify auth status\n        if (hasAuthStatusCookie()) {\n          checkAuth();\n        } else if (authState.isAuthenticated) {\n          // Cookie was cleared while tab was hidden\n          setAuthState({\n            isAuthenticated: false,\n            isLoading: false,\n            user: null,\n          });\n        }\n      }\n    };\n\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n\n    return () => {\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n    };\n  }, [checkAuth, authState.isAuthenticated]);\n\n  const contextValue: AuthContextType = {\n    ...authState,\n    login,\n    logout,\n    refreshAuth,\n    checkAuth,\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>\n  );\n}\n\n/**\n * Hook to use auth context\n */\nexport function useAuth(): AuthContextType {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error(\"useAuth must be used within an AuthProvider\");\n  }\n  return context;\n}\n\n/**\n * Hook to check if user is authenticated\n * Simplified version that just returns auth status\n */\nexport function useIsAuthenticated(): {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  user: UserData | null;\n} {\n  const { isAuthenticated, isLoading, user } = useAuth();\n  return { isAuthenticated, isLoading, user };\n}\n\nexport default AuthContext;\n","numLines":388,"startLine":1,"totalLines":388}}}
{"parentUuid":"e8a03a8a-bb98-4606-b316-21c8b58eeed7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017Yw46p5XmrVqXr1gvHa6KW","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check if there's a login API route to see how it compares:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13307,"cache_read_input_tokens":20583,"cache_creation":{"ephemeral_5m_input_tokens":13307,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc56qYduCD4y8bVjk2T7","type":"assistant","uuid":"5cc974bc-1f69-407f-b868-afbf8a5cab05","timestamp":"2025-12-30T02:19:53.163Z"}
{"parentUuid":"5cc974bc-1f69-407f-b868-afbf8a5cab05","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017Yw46p5XmrVqXr1gvHa6KW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019ybYBQTnyQKvThk9S62FAj","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/login/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13307,"cache_read_input_tokens":20583,"cache_creation":{"ephemeral_5m_input_tokens":13307,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc56qYduCD4y8bVjk2T7","type":"assistant","uuid":"9b165158-c676-4249-8b45-896d29725475","timestamp":"2025-12-30T02:19:53.606Z"}
{"parentUuid":"9b165158-c676-4249-8b45-896d29725475","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_017Yw46p5XmrVqXr1gvHa6KW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MbuMbWRG1kVoFJDiCqxZqT","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-website/src/app/api/checkout/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13307,"cache_read_input_tokens":20583,"cache_creation":{"ephemeral_5m_input_tokens":13307,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc56qYduCD4y8bVjk2T7","type":"assistant","uuid":"98c3b2f2-0bad-4e7e-93e6-68e3e384e328","timestamp":"2025-12-30T02:19:53.815Z"}
{"parentUuid":"98c3b2f2-0bad-4e7e-93e6-68e3e384e328","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019ybYBQTnyQKvThk9S62FAj","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import { CSRF_HEADER_NAME } from \"@/lib/csrf-server\";\n     3→\n     4→// Backend API URL for authentication\n     5→const BACKEND_API_URL =\n     6→  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n     7→\n     8→// Cookie configuration\n     9→const isProduction = process.env.NODE_ENV === \"production\";\n    10→const COOKIE_OPTIONS = {\n    11→  httpOnly: true,\n    12→  secure: isProduction, // Only secure in production (allows localhost in dev)\n    13→  sameSite: \"strict\" as const,\n    14→  path: \"/\",\n    15→};\n    16→\n    17→// Token expiry times\n    18→const ACCESS_TOKEN_MAX_AGE = 60 * 60; // 1 hour in seconds\n    19→const REFRESH_TOKEN_MAX_AGE = 7 * 24 * 60 * 60; // 7 days in seconds\n    20→\n    21→export async function POST(request: NextRequest) {\n    22→  try {\n    23→    const body = await request.json();\n    24→    const { licenseKey } = body;\n    25→\n    26→    if (!licenseKey) {\n    27→      return NextResponse.json(\n    28→        { error: \"License key is required\" },\n    29→        { status: 400 }\n    30→      );\n    31→    }\n    32→\n    33→    // Get CSRF token from request to forward to backend\n    34→    const csrfToken = request.headers.get(CSRF_HEADER_NAME);\n    35→    const backendHeaders: Record<string, string> = {\n    36→      \"Content-Type\": \"application/json\",\n    37→    };\n    38→    if (csrfToken) {\n    39→      backendHeaders[CSRF_HEADER_NAME] = csrfToken;\n    40→    }\n    41→\n    42→    // Get CSRF cookie to forward to backend\n    43→    const csrfCookie = request.cookies.get(\"splice_csrf\")?.value;\n    44→    if (csrfCookie) {\n    45→      backendHeaders[\"Cookie\"] = `splice_csrf=${csrfCookie}`;\n    46→    }\n    47→\n    48→    // Forward the login request to the backend\n    49→    const response = await fetch(`${BACKEND_API_URL}/auth/login`, {\n    50→      method: \"POST\",\n    51→      headers: backendHeaders,\n    52→      body: JSON.stringify({ licenseKey }),\n    53→    });\n    54→\n    55→    const data = await response.json();\n    56→\n    57→    if (!response.ok) {\n    58→      return NextResponse.json(\n    59→        {\n    60→          error: data.error || \"Authentication failed\",\n    61→          message: data.message || \"Please check your license key and try again\",\n    62→        },\n    63→        { status: response.status }\n    64→      );\n    65→    }\n    66→\n    67→    // Create the response with user data (excluding tokens)\n    68→    const jsonResponse = NextResponse.json({\n    69→      success: true,\n    70→      customerId: data.customerId,\n    71→      tier: data.tier,\n    72→      hoursRemaining: data.hoursRemaining,\n    73→    });\n    74→\n    75→    // Set HttpOnly cookies for tokens\n    76→    jsonResponse.cookies.set(\"splice_token\", data.token, {\n    77→      ...COOKIE_OPTIONS,\n    78→      maxAge: ACCESS_TOKEN_MAX_AGE,\n    79→    });\n    80→\n    81→    jsonResponse.cookies.set(\"splice_refresh_token\", data.refreshToken, {\n    82→      ...COOKIE_OPTIONS,\n    83→      maxAge: REFRESH_TOKEN_MAX_AGE,\n    84→    });\n    85→\n    86→    // Set a non-HttpOnly cookie for client-side auth state check\n    87→    // This doesn't contain sensitive data, just indicates logged-in status\n    88→    jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n    89→      httpOnly: false,\n    90→      secure: isProduction,\n    91→      sameSite: \"strict\" as const,\n    92→      path: \"/\",\n    93→      maxAge: ACCESS_TOKEN_MAX_AGE,\n    94→    });\n    95→\n    96→    // Store user metadata in a separate cookie for client access\n    97→    jsonResponse.cookies.set(\n    98→      \"splice_user\",\n    99→      JSON.stringify({\n   100→        customerId: data.customerId,\n   101→        tier: data.tier,\n   102→        hoursRemaining: data.hoursRemaining,\n   103→      }),\n   104→      {\n   105→        httpOnly: false,\n   106→        secure: isProduction,\n   107→        sameSite: \"strict\" as const,\n   108→        path: \"/\",\n   109→        maxAge: ACCESS_TOKEN_MAX_AGE,\n   110→      }\n   111→    );\n   112→\n   113→    return jsonResponse;\n   114→  } catch (error) {\n   115→    console.error(\"[Auth] Login error:\", error);\n   116→    return NextResponse.json(\n   117→      {\n   118→        error: \"Authentication failed\",\n   119→        message: \"Unable to connect to the authentication server. Please try again later.\",\n   120→      },\n   121→      { status: 500 }\n   122→    );\n   123→  }\n   124→}\n   125→\n\n</system-reminder>\n"}]},"uuid":"7bd16b76-17ad-4ed5-bdc1-b41b4a9682f4","timestamp":"2025-12-30T02:19:53.855Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/auth/login/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport { CSRF_HEADER_NAME } from \"@/lib/csrf-server\";\n\n// Backend API URL for authentication\nconst BACKEND_API_URL =\n  process.env.BACKEND_API_URL || \"https://splice-api-production.up.railway.app\";\n\n// Cookie configuration\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst COOKIE_OPTIONS = {\n  httpOnly: true,\n  secure: isProduction, // Only secure in production (allows localhost in dev)\n  sameSite: \"strict\" as const,\n  path: \"/\",\n};\n\n// Token expiry times\nconst ACCESS_TOKEN_MAX_AGE = 60 * 60; // 1 hour in seconds\nconst REFRESH_TOKEN_MAX_AGE = 7 * 24 * 60 * 60; // 7 days in seconds\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { licenseKey } = body;\n\n    if (!licenseKey) {\n      return NextResponse.json(\n        { error: \"License key is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Get CSRF token from request to forward to backend\n    const csrfToken = request.headers.get(CSRF_HEADER_NAME);\n    const backendHeaders: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n    };\n    if (csrfToken) {\n      backendHeaders[CSRF_HEADER_NAME] = csrfToken;\n    }\n\n    // Get CSRF cookie to forward to backend\n    const csrfCookie = request.cookies.get(\"splice_csrf\")?.value;\n    if (csrfCookie) {\n      backendHeaders[\"Cookie\"] = `splice_csrf=${csrfCookie}`;\n    }\n\n    // Forward the login request to the backend\n    const response = await fetch(`${BACKEND_API_URL}/auth/login`, {\n      method: \"POST\",\n      headers: backendHeaders,\n      body: JSON.stringify({ licenseKey }),\n    });\n\n    const data = await response.json();\n\n    if (!response.ok) {\n      return NextResponse.json(\n        {\n          error: data.error || \"Authentication failed\",\n          message: data.message || \"Please check your license key and try again\",\n        },\n        { status: response.status }\n      );\n    }\n\n    // Create the response with user data (excluding tokens)\n    const jsonResponse = NextResponse.json({\n      success: true,\n      customerId: data.customerId,\n      tier: data.tier,\n      hoursRemaining: data.hoursRemaining,\n    });\n\n    // Set HttpOnly cookies for tokens\n    jsonResponse.cookies.set(\"splice_token\", data.token, {\n      ...COOKIE_OPTIONS,\n      maxAge: ACCESS_TOKEN_MAX_AGE,\n    });\n\n    jsonResponse.cookies.set(\"splice_refresh_token\", data.refreshToken, {\n      ...COOKIE_OPTIONS,\n      maxAge: REFRESH_TOKEN_MAX_AGE,\n    });\n\n    // Set a non-HttpOnly cookie for client-side auth state check\n    // This doesn't contain sensitive data, just indicates logged-in status\n    jsonResponse.cookies.set(\"splice_auth_status\", \"authenticated\", {\n      httpOnly: false,\n      secure: isProduction,\n      sameSite: \"strict\" as const,\n      path: \"/\",\n      maxAge: ACCESS_TOKEN_MAX_AGE,\n    });\n\n    // Store user metadata in a separate cookie for client access\n    jsonResponse.cookies.set(\n      \"splice_user\",\n      JSON.stringify({\n        customerId: data.customerId,\n        tier: data.tier,\n        hoursRemaining: data.hoursRemaining,\n      }),\n      {\n        httpOnly: false,\n        secure: isProduction,\n        sameSite: \"strict\" as const,\n        path: \"/\",\n        maxAge: ACCESS_TOKEN_MAX_AGE,\n      }\n    );\n\n    return jsonResponse;\n  } catch (error) {\n    console.error(\"[Auth] Login error:\", error);\n    return NextResponse.json(\n      {\n        error: \"Authentication failed\",\n        message: \"Unable to connect to the authentication server. Please try again later.\",\n      },\n      { status: 500 }\n    );\n  }\n}\n","numLines":125,"startLine":1,"totalLines":125}}}
{"parentUuid":"7bd16b76-17ad-4ed5-bdc1-b41b4a9682f4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MbuMbWRG1kVoFJDiCqxZqT","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from \"next/server\";\n     2→import Stripe from \"stripe\";\n     3→import { csrfGuard } from \"@/lib/csrf-server\";\n     4→\n     5→// Force Node.js runtime (not Edge) for better Stripe compatibility\n     6→export const runtime = \"nodejs\";\n     7→export const maxDuration = 30;\n     8→\n     9→// Lazy initialization to avoid errors during build\n    10→let stripe: Stripe | null = null;\n    11→function getStripe(): Stripe {\n    12→  if (!stripe) {\n    13→    if (!process.env.STRIPE_SECRET_KEY) {\n    14→      throw new Error(\"STRIPE_SECRET_KEY is not configured\");\n    15→    }\n    16→    stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n    17→      timeout: 10000,\n    18→      maxNetworkRetries: 2,\n    19→    });\n    20→  }\n    21→  return stripe;\n    22→}\n    23→\n    24→// Get price IDs at runtime to ensure env vars are loaded\n    25→function getPriceIds() {\n    26→  return {\n    27→    monthly: {\n    28→      starter: process.env.STRIPE_PRICE_STARTER || \"\",\n    29→      pro: process.env.STRIPE_PRICE_PRO || \"\",\n    30→      team: process.env.STRIPE_PRICE_TEAM || \"\",\n    31→    },\n    32→    annual: {\n    33→      starter: process.env.STRIPE_PRICE_STARTER_ANNUAL || \"\",\n    34→      pro: process.env.STRIPE_PRICE_PRO_ANNUAL || \"\",\n    35→      team: process.env.STRIPE_PRICE_TEAM_ANNUAL || \"\",\n    36→    },\n    37→  };\n    38→}\n    39→\n    40→export async function POST(request: NextRequest) {\n    41→  // CSRF validation\n    42→  const csrfError = await csrfGuard(request);\n    43→  if (csrfError) {\n    44→    console.warn(\"[Checkout] CSRF validation failed\");\n    45→    return csrfError;\n    46→  }\n    47→\n    48→  try {\n    49→    const body = await request.json();\n    50→    const { plan, email, successUrl, cancelUrl, billing = \"monthly\" } = body;\n    51→\n    52→    // Get price IDs at runtime\n    53→    const allPrices = getPriceIds();\n    54→    const priceIds = billing === \"annual\" ? allPrices.annual : allPrices.monthly;\n    55→\n    56→    if (!plan || !priceIds[plan as keyof typeof priceIds]) {\n    57→      return NextResponse.json(\n    58→        { error: \"Invalid plan selected\" },\n    59→        { status: 400 }\n    60→      );\n    61→    }\n    62→\n    63→    const priceId = priceIds[plan as keyof typeof priceIds];\n    64→\n    65→    if (!priceId) {\n    66→      return NextResponse.json(\n    67→        { error: \"Price ID not configured for this plan\" },\n    68→        { status: 500 }\n    69→      );\n    70→    }\n    71→\n    72→    // Create Stripe checkout session using raw fetch (workaround for Vercel SDK connectivity issues)\n    73→    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || \"https://splice-website.vercel.app\";\n    74→    const successUrlFinal = successUrl || `${baseUrl}/checkout/success`;\n    75→    const cancelUrlFinal = cancelUrl || `${baseUrl}/pricing`;\n    76→\n    77→    const params = new URLSearchParams();\n    78→    params.append(\"mode\", \"subscription\");\n    79→    params.append(\"payment_method_types[0]\", \"card\");\n    80→    params.append(\"line_items[0][price]\", priceId);\n    81→    params.append(\"line_items[0][quantity]\", \"1\");\n    82→    if (email) params.append(\"customer_email\", email);\n    83→    params.append(\"success_url\", successUrlFinal);\n    84→    params.append(\"cancel_url\", cancelUrlFinal);\n    85→    params.append(\"subscription_data[trial_period_days]\", \"14\");\n    86→    params.append(\"subscription_data[metadata][plan]\", plan);\n    87→    params.append(\"subscription_data[metadata][billing]\", billing);\n    88→    params.append(\"metadata[plan]\", plan);\n    89→    params.append(\"metadata[billing]\", billing);\n    90→    params.append(\"allow_promotion_codes\", \"true\");\n    91→    params.append(\"billing_address_collection\", \"required\");\n    92→\n    93→    const response = await fetch(\"https://api.stripe.com/v1/checkout/sessions\", {\n    94→      method: \"POST\",\n    95→      headers: {\n    96→        \"Authorization\": `Bearer ${process.env.STRIPE_SECRET_KEY}`,\n    97→        \"Content-Type\": \"application/x-www-form-urlencoded\",\n    98→      },\n    99→      body: params,\n   100→    });\n   101→\n   102→    if (!response.ok) {\n   103→      const errorData = await response.json();\n   104→      console.error(\"[Checkout] Stripe API error:\", errorData);\n   105→      throw new Error(errorData.error?.message || \"Stripe API error\");\n   106→    }\n   107→\n   108→    const session = await response.json();\n   109→\n   110→    return NextResponse.json({\n   111→      sessionId: session.id,\n   112→      url: session.url,\n   113→    });\n   114→  } catch (error) {\n   115→    console.error(\"[Checkout] Error:\", error instanceof Error ? error.message : error);\n   116→    return NextResponse.json(\n   117→      {\n   118→        error:\n   119→          error instanceof Error ? error.message : \"Failed to create checkout session\",\n   120→      },\n   121→      { status: 500 }\n   122→    );\n   123→  }\n   124→}\n   125→\n   126→export async function GET(request: NextRequest) {\n   127→  const searchParams = request.nextUrl.searchParams;\n   128→  const sessionId = searchParams.get(\"session_id\");\n   129→\n   130→  if (!sessionId) {\n   131→    return NextResponse.json(\n   132→      { error: \"Session ID is required\" },\n   133→      { status: 400 }\n   134→    );\n   135→  }\n   136→\n   137→  try {\n   138→    const session = await getStripe().checkout.sessions.retrieve(sessionId, {\n   139→      expand: [\"subscription\", \"customer\"],\n   140→    });\n   141→\n   142→    return NextResponse.json({\n   143→      status: session.status,\n   144→      customerEmail: session.customer_details?.email,\n   145→      plan: session.metadata?.plan,\n   146→      subscriptionId:\n   147→        typeof session.subscription === \"string\"\n   148→          ? session.subscription\n   149→          : session.subscription?.id,\n   150→    });\n   151→  } catch (error) {\n   152→    console.error(\"Session retrieval error:\", error);\n   153→    return NextResponse.json(\n   154→      {\n   155→        error:\n   156→          error instanceof Error\n   157→            ? error.message\n   158→            : \"Failed to retrieve session\",\n   159→      },\n   160→      { status: 500 }\n   161→    );\n   162→  }\n   163→}\n   164→\n\n</system-reminder>\n"}]},"uuid":"c736e6fd-d24d-4ae4-ba33-b73f81285ce5","timestamp":"2025-12-30T02:19:53.856Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-website/src/app/api/checkout/route.ts","content":"import { NextRequest, NextResponse } from \"next/server\";\nimport Stripe from \"stripe\";\nimport { csrfGuard } from \"@/lib/csrf-server\";\n\n// Force Node.js runtime (not Edge) for better Stripe compatibility\nexport const runtime = \"nodejs\";\nexport const maxDuration = 30;\n\n// Lazy initialization to avoid errors during build\nlet stripe: Stripe | null = null;\nfunction getStripe(): Stripe {\n  if (!stripe) {\n    if (!process.env.STRIPE_SECRET_KEY) {\n      throw new Error(\"STRIPE_SECRET_KEY is not configured\");\n    }\n    stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n      timeout: 10000,\n      maxNetworkRetries: 2,\n    });\n  }\n  return stripe;\n}\n\n// Get price IDs at runtime to ensure env vars are loaded\nfunction getPriceIds() {\n  return {\n    monthly: {\n      starter: process.env.STRIPE_PRICE_STARTER || \"\",\n      pro: process.env.STRIPE_PRICE_PRO || \"\",\n      team: process.env.STRIPE_PRICE_TEAM || \"\",\n    },\n    annual: {\n      starter: process.env.STRIPE_PRICE_STARTER_ANNUAL || \"\",\n      pro: process.env.STRIPE_PRICE_PRO_ANNUAL || \"\",\n      team: process.env.STRIPE_PRICE_TEAM_ANNUAL || \"\",\n    },\n  };\n}\n\nexport async function POST(request: NextRequest) {\n  // CSRF validation\n  const csrfError = await csrfGuard(request);\n  if (csrfError) {\n    console.warn(\"[Checkout] CSRF validation failed\");\n    return csrfError;\n  }\n\n  try {\n    const body = await request.json();\n    const { plan, email, successUrl, cancelUrl, billing = \"monthly\" } = body;\n\n    // Get price IDs at runtime\n    const allPrices = getPriceIds();\n    const priceIds = billing === \"annual\" ? allPrices.annual : allPrices.monthly;\n\n    if (!plan || !priceIds[plan as keyof typeof priceIds]) {\n      return NextResponse.json(\n        { error: \"Invalid plan selected\" },\n        { status: 400 }\n      );\n    }\n\n    const priceId = priceIds[plan as keyof typeof priceIds];\n\n    if (!priceId) {\n      return NextResponse.json(\n        { error: \"Price ID not configured for this plan\" },\n        { status: 500 }\n      );\n    }\n\n    // Create Stripe checkout session using raw fetch (workaround for Vercel SDK connectivity issues)\n    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || \"https://splice-website.vercel.app\";\n    const successUrlFinal = successUrl || `${baseUrl}/checkout/success`;\n    const cancelUrlFinal = cancelUrl || `${baseUrl}/pricing`;\n\n    const params = new URLSearchParams();\n    params.append(\"mode\", \"subscription\");\n    params.append(\"payment_method_types[0]\", \"card\");\n    params.append(\"line_items[0][price]\", priceId);\n    params.append(\"line_items[0][quantity]\", \"1\");\n    if (email) params.append(\"customer_email\", email);\n    params.append(\"success_url\", successUrlFinal);\n    params.append(\"cancel_url\", cancelUrlFinal);\n    params.append(\"subscription_data[trial_period_days]\", \"14\");\n    params.append(\"subscription_data[metadata][plan]\", plan);\n    params.append(\"subscription_data[metadata][billing]\", billing);\n    params.append(\"metadata[plan]\", plan);\n    params.append(\"metadata[billing]\", billing);\n    params.append(\"allow_promotion_codes\", \"true\");\n    params.append(\"billing_address_collection\", \"required\");\n\n    const response = await fetch(\"https://api.stripe.com/v1/checkout/sessions\", {\n      method: \"POST\",\n      headers: {\n        \"Authorization\": `Bearer ${process.env.STRIPE_SECRET_KEY}`,\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n      body: params,\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      console.error(\"[Checkout] Stripe API error:\", errorData);\n      throw new Error(errorData.error?.message || \"Stripe API error\");\n    }\n\n    const session = await response.json();\n\n    return NextResponse.json({\n      sessionId: session.id,\n      url: session.url,\n    });\n  } catch (error) {\n    console.error(\"[Checkout] Error:\", error instanceof Error ? error.message : error);\n    return NextResponse.json(\n      {\n        error:\n          error instanceof Error ? error.message : \"Failed to create checkout session\",\n      },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const sessionId = searchParams.get(\"session_id\");\n\n  if (!sessionId) {\n    return NextResponse.json(\n      { error: \"Session ID is required\" },\n      { status: 400 }\n    );\n  }\n\n  try {\n    const session = await getStripe().checkout.sessions.retrieve(sessionId, {\n      expand: [\"subscription\", \"customer\"],\n    });\n\n    return NextResponse.json({\n      status: session.status,\n      customerEmail: session.customer_details?.email,\n      plan: session.metadata?.plan,\n      subscriptionId:\n        typeof session.subscription === \"string\"\n          ? session.subscription\n          : session.subscription?.id,\n    });\n  } catch (error) {\n    console.error(\"Session retrieval error:\", error);\n    return NextResponse.json(\n      {\n        error:\n          error instanceof Error\n            ? error.message\n            : \"Failed to retrieve session\",\n      },\n      { status: 500 }\n    );\n  }\n}\n","numLines":164,"startLine":1,"totalLines":164}}}
{"parentUuid":"c736e6fd-d24d-4ae4-ba33-b73f81285ce5","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"4c7927f9-7798-44a0-91df-62c31e2c57cc","version":"2.0.76","gitBranch":"main","agentId":"ac2b20e","slug":"federated-bubbling-octopus","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0139q1A5LXUTh345Ad7WLCXh","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! I now have all the information needed. Let me create a comprehensive report.\n\n## CSRF Protection Status Report\n\nBased on my exploration of the SPLICE codebase, here's what I found:\n\n### Summary\n**CSRF Protection is MISSING from both `/logout` and `/refresh` endpoints**, but the infrastructure exists and is properly implemented in other routes.\n\n---\n\n### Detailed Findings\n\n#### 1. `/api/auth/logout/route.ts` - MISSING CSRF PROTECTION\n\n**Status:** ❌ No CSRF protection\n\nThe logout endpoint does NOT:\n- Call `csrfGuard()` function\n- Validate X-CSRF-Token header\n- Check CSRF cookie\n\n**What it does:** Only forwards the request to the backend `/auth/logout` endpoint with the bearer token.\n\n**What it SHOULD do:** Like the contact form and checkout routes, it should validate CSRF before processing.\n\n---\n\n#### 2. `/api/auth/refresh/route.ts` - MISSING CSRF PROTECTION\n\n**Status:** ❌ No CSRF protection\n\nThe refresh endpoint does NOT:\n- Call `csrfGuard()` function  \n- Validate X-CSRF-Token header\n- Check CSRF cookie\n\n**What it does:** Directly forwards the refresh token to the backend without CSRF validation.\n\n**What it SHOULD do:** Validate CSRF tokens before allowing token refresh.\n\n---\n\n#### 3. How CSRF IS Properly Implemented (Reference Examples)\n\n**Contact Form** (`/api/contact/route.ts`, lines 278-284):\n```typescript\nexport async function POST(request: NextRequest) {\n  // CSRF validation first\n  const csrfError = await csrfGuard(request);\n  if (csrfError) {\n    console.warn(\"[Contact API] CSRF validation failed\");\n    return csrfError;\n  }\n  // ... rest of handler\n}\n```\n\n**Checkout** (`/api/checkout/route.ts`, lines 40-46):\n```typescript\nexport async function POST(request: NextRequest) {\n  // CSRF validation\n  const csrfError = await csrfGuard(request);\n  if (csrfError) {\n    console.warn(\"[Checkout] CSRF validation failed\");\n    return csrfError;\n  }\n  // ... rest of handler\n}\n```\n\n**Login** (`/api/auth/login/route.ts`, lines 33-46):\n```typescript\n// Get CSRF token from request to forward to backend\nconst csrfToken = request.headers.get(CSRF_HEADER_NAME);\nconst backendHeaders: Record<string, string> = {\n  \"Content-Type\": \"application/json\",\n};\nif (csrfToken) {\n  backendHeaders[CSRF_HEADER_NAME] = csrfToken;\n}\n\n// Get CSRF cookie to forward to backend\nconst csrfCookie = request.cookies.get(\"splice_csrf\")?.value;\nif (csrfCookie) {\n  backendHeaders[\"Cookie\"] = `splice_csrf=${csrfCookie}`;\n}\n```\n\n---\n\n#### 4. Frontend Integration (`AuthContext.tsx`)\n\n**Logout implementation** (lines 240-271):\n```typescript\nconst logout = useCallback(async () => {\n  clearTimers();\n\n  try {\n    // Get CSRF token before making logout request\n    const csrfToken = await getCsrfToken();\n\n    await fetch(\"/api/auth/logout\", {\n      method: \"POST\",\n      headers: {\n        [CSRF_HEADER_NAME]: csrfToken,  // Client sends CSRF token\n      },\n      credentials: \"include\",\n    });\n  } catch (error) {\n    console.warn(\"[AuthContext] Logout API call failed:\", error);\n  }\n\n  clearCsrfToken();\n  // ... rest of logout logic\n}, [clearTimers]);\n```\n\n**The problem:** The frontend is sending the CSRF token in the `x-csrf-token` header, but the logout API route is NOT validating it.\n\n---\n\n#### 5. CSRF Protection Infrastructure\n\n**`csrf-server.ts`** provides two key functions:\n\n1. **`csrfGuard()`** (lines 79-101): Higher-order function that:\n   - Skips validation for GET/HEAD/OPTIONS requests\n   - Extracts CSRF token from `x-csrf-token` header\n   - Compares it against the `splice_csrf` cookie (double-submit pattern)\n   - Returns 403 error if validation fails\n   - Returns null if validation passes\n\n2. **`validateCsrfToken()`** (lines 37-70): Lower-level function that does the actual comparison using constant-time string comparison to prevent timing attacks.\n\n---\n\n### Recommendations\n\nTo fix CSRF protection on logout and refresh endpoints:\n\n**For `/api/auth/logout/route.ts`:**\nAdd at the start of the POST handler:\n```typescript\nimport { csrfGuard } from \"@/lib/csrf-server\";\n\nexport async function POST(request: NextRequest) {\n  const csrfError = await csrfGuard(request);\n  if (csrfError) {\n    console.warn(\"[Auth] Logout CSRF validation failed\");\n    return csrfError;\n  }\n  // ... rest of existing code\n}\n```\n\n**For `/api/auth/refresh/route.ts`:**\nAdd at the start of the POST handler:\n```typescript\nimport { csrfGuard } from \"@/lib/csrf-server\";\n\nexport async function POST(request: NextRequest) {\n  const csrfError = await csrfGuard(request);\n  if (csrfError) {\n    console.warn(\"[Auth] Refresh CSRF validation failed\");\n    return csrfError;\n  }\n  // ... rest of existing code\n}\n```\n\nBoth endpoints follow the same pattern as contact form and checkout, ensuring consistent CSRF protection across all state-changing operations."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3852,"cache_read_input_tokens":33890,"cache_creation":{"ephemeral_5m_input_tokens":3852,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWc574sKh4qDSGXVeMXdK","type":"assistant","uuid":"d634b8bd-62be-48ab-be01-c1e2902007b8","timestamp":"2025-12-30T02:20:05.271Z"}
