{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":"Verify all middleware in the SPLICE backend is properly configured for production.\n\nCheck /Users/imorgado/SPLICE/splice-backend/middleware/:\n\n1. **Authentication Middleware** (auth.js):\n   - JWT token verification\n   - Token blacklist checking (Redis + fallback)\n   - Proper error responses for invalid/expired tokens\n   - optionalAuthentication for public routes\n\n2. **CSRF Middleware** (csrf.js):\n   - Double-submit cookie pattern implementation\n   - Token generation\n   - Token validation with constant-time comparison\n   - Proper cookie settings (httpOnly, secure, sameSite)\n\n3. **Rate Limiter** (rateLimiter.js):\n   - Per-user rate limiting\n   - Proper Redis integration\n   - Fallback when Redis unavailable\n   - Reservation system for long operations\n\nAlso check server.js for:\n- Middleware order (important!)\n- CORS configuration for CEP panel\n- Body parser limits\n- Security headers\n- Health check endpoint\n\nVerify the middleware works together correctly and won't cause issues in production. Report any misconfigurations or security concerns."},"uuid":"1a6467da-c216-4b38-aefa-13b6258ee572","timestamp":"2026-01-11T23:38:57.927Z"}
{"parentUuid":"1a6467da-c216-4b38-aefa-13b6258ee572","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A3L3999yozLornMUckR98S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015uAKHbyAkFhRvsggzprSQ5","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":8092,"cache_read_input_tokens":19775,"cache_creation":{"ephemeral_5m_input_tokens":8092,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UMCeYhoKfxYjyjhLjM","type":"assistant","uuid":"656be657-4a31-4cc2-b25c-d6946c88df54","timestamp":"2026-01-11T23:39:01.629Z"}
{"parentUuid":"656be657-4a31-4cc2-b25c-d6946c88df54","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A3L3999yozLornMUckR98S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013P6YxdCtLxDGkvJ6eJJCUW","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":8092,"cache_read_input_tokens":19775,"cache_creation":{"ephemeral_5m_input_tokens":8092,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UMCeYhoKfxYjyjhLjM","type":"assistant","uuid":"72f39306-3d8e-4b69-b12b-a9ef93be539d","timestamp":"2026-01-11T23:39:01.982Z"}
{"parentUuid":"72f39306-3d8e-4b69-b12b-a9ef93be539d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A3L3999yozLornMUckR98S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012NQohVSZuAhMtthFDyZ8kB","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":8092,"cache_read_input_tokens":19775,"cache_creation":{"ephemeral_5m_input_tokens":8092,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UMCeYhoKfxYjyjhLjM","type":"assistant","uuid":"bcf67b64-167b-4786-9968-27a7926f145e","timestamp":"2026-01-11T23:39:02.348Z"}
{"parentUuid":"bcf67b64-167b-4786-9968-27a7926f145e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A3L3999yozLornMUckR98S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Tux7o8cKQ95tMFL8xCUMpV","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":8092,"cache_read_input_tokens":19775,"cache_creation":{"ephemeral_5m_input_tokens":8092,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UMCeYhoKfxYjyjhLjM","type":"assistant","uuid":"73acf375-38e7-48ba-8aec-6818ae9b9765","timestamp":"2026-01-11T23:39:02.774Z"}
{"parentUuid":"73acf375-38e7-48ba-8aec-6818ae9b9765","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015uAKHbyAkFhRvsggzprSQ5","type":"tool_result","content":"     1→/**\n     2→ * JWT Authentication Middleware\n     3→ *\n     4→ * Replaces insecure x-stripe-customer-id header with JWT tokens.\n     5→ * Tokens are signed with a secret and contain the customer ID.\n     6→ *\n     7→ * Token Blacklist:\n     8→ * - Primary: Upstash Redis with automatic TTL-based expiry\n     9→ * - Fallback: In-memory Map (for development or Redis failures)\n    10→ */\n    11→\n    12→const jwt = require('jsonwebtoken');\n    13→const crypto = require('crypto');\n    14→const authLogger = require('../utils/authLogger');\n    15→const redis = require('../services/redisClient');\n    16→\n    17→// HIGH-007: Database pool for admin RBAC\n    18→let pool = null;\n    19→try {\n    20→  const { Pool } = require('pg');\n    21→  pool = new Pool({\n    22→    connectionString: process.env.DATABASE_URL,\n    23→    ssl: process.env.NODE_ENV === 'production'\n    24→      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n    25→      : false,\n    26→    max: 3, // Small pool just for auth checks\n    27→    idleTimeoutMillis: 30000,\n    28→  });\n    29→} catch (err) {\n    30→  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n    31→}\n    32→\n    33→// JWT configuration\n    34→const JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\n    35→const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\n    36→const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n    37→\n    38→// Redis key prefix for blacklisted tokens\n    39→const BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n    40→\n    41→// Check if running in production\n    42→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    43→\n    44→// HIGH-001: Validate JWT_SECRET security requirements\n    45→if (isProduction) {\n    46→  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    47→    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    48→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    49→    process.exit(1);\n    50→  }\n    51→  \n    52→  if (JWT_SECRET.length < 32) {\n    53→    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    54→    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    55→    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    56→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    57→    process.exit(1);\n    58→  }\n    59→}\n    60→\n    61→/**\n    62→ * Fallback Token Blacklist (In-Memory)\n    63→ * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n    64→ */\n    65→const fallbackBlacklist = new Map();\n    66→\n    67→// Track if we're using fallback mode\n    68→let usingFallback = false;\n    69→\n    70→// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\n    71→const BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n    72→\n    73→/**\n    74→ * Clean up expired entries from the fallback blacklist\n    75→ * Only runs when using in-memory fallback\n    76→ */\n    77→function cleanupFallbackBlacklist() {\n    78→  if (!usingFallback || fallbackBlacklist.size === 0) {\n    79→    return;\n    80→  }\n    81→\n    82→  const now = Math.floor(Date.now() / 1000);\n    83→  let cleanedCount = 0;\n    84→\n    85→  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    86→    if (exp <= now) {\n    87→      fallbackBlacklist.delete(jti);\n    88→      cleanedCount++;\n    89→    }\n    90→  }\n    91→\n    92→  if (cleanedCount > 0) {\n    93→    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n    94→  }\n    95→}\n    96→\n    97→// Start periodic cleanup for fallback (unref to allow process exit)\n    98→const cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\n    99→if (cleanupTimer.unref) {\n   100→  cleanupTimer.unref();\n   101→}\n   102→\n   103→/**\n   104→ * Add a token to the blacklist\n   105→ * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n   106→ * @param {string} jti - JWT ID claim\n   107→ * @param {number} exp - Token expiration timestamp (Unix seconds)\n   108→ * @param {Object} options - Additional options for logging\n   109→ * @param {string} options.userId - User ID for logging\n   110→ * @param {string} options.reason - Reason for revocation (logout, security, admin)\n   111→ * @returns {Promise<boolean>} True if successfully blacklisted\n   112→ */\n   113→async function blacklistToken(jti, exp, options = {}) {\n   114→  if (!jti) {\n   115→    console.warn('[Auth] Cannot blacklist token without jti');\n   116→    return false;\n   117→  }\n   118→\n   119→  const now = Math.floor(Date.now() / 1000);\n   120→  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n   121→\n   122→  // Try Redis first\n   123→  if (redis.isRedisAvailable()) {\n   124→    try {\n   125→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   126→      const success = await redis.set(key, exp, ttlSeconds);\n   127→\n   128→      if (success) {\n   129→        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n   130→        usingFallback = false;\n   131→        // Log token revocation with structured logging\n   132→        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   133→        return true;\n   134→      }\n   135→    } catch (err) {\n   136→      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n   137→    }\n   138→  }\n   139→\n   140→  // Fallback to in-memory\n   141→  usingFallback = true;\n   142→  fallbackBlacklist.set(jti, exp);\n   143→  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n   144→\n   145→  // Log token revocation with structured logging\n   146→  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   147→  return true;\n   148→}\n   149→\n   150→/**\n   151→ * Check if a token is blacklisted\n   152→ * Checks Redis first, then fallback in-memory store\n   153→ * @param {string} jti - JWT ID claim\n   154→ * @returns {Promise<boolean>} True if token is blacklisted\n   155→ */\n   156→async function isTokenBlacklisted(jti) {\n   157→  if (!jti) {\n   158→    return false;\n   159→  }\n   160→\n   161→  // Try Redis first\n   162→  if (redis.isRedisAvailable()) {\n   163→    try {\n   164→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   165→      const exists = await redis.exists(key);\n   166→\n   167→      if (exists) {\n   168→        return true;\n   169→      }\n   170→\n   171→      // Also check fallback in case token was blacklisted during Redis downtime\n   172→      // and Redis is now back up\n   173→      if (fallbackBlacklist.has(jti)) {\n   174→        // Migrate to Redis if token still valid\n   175→        const exp = fallbackBlacklist.get(jti);\n   176→        const now = Math.floor(Date.now() / 1000);\n   177→        if (exp > now) {\n   178→          const ttlSeconds = exp - now;\n   179→          await redis.set(key, exp, ttlSeconds);\n   180→          fallbackBlacklist.delete(jti);\n   181→          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n   182→        } else {\n   183→          // Expired, remove from fallback\n   184→          fallbackBlacklist.delete(jti);\n   185→        }\n   186→        return true;\n   187→      }\n   188→\n   189→      return false;\n   190→    } catch (err) {\n   191→      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n   192→    }\n   193→  }\n   194→\n   195→  // Fallback to in-memory check\n   196→  if (fallbackBlacklist.has(jti)) {\n   197→    const exp = fallbackBlacklist.get(jti);\n   198→    const now = Math.floor(Date.now() / 1000);\n   199→    if (exp > now) {\n   200→      return true;\n   201→    }\n   202→    // Expired, remove it\n   203→    fallbackBlacklist.delete(jti);\n   204→  }\n   205→\n   206→  return false;\n   207→}\n   208→\n   209→/**\n   210→ * Get blacklist statistics (for monitoring)\n   211→ * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n   212→ */\n   213→async function getBlacklistStats() {\n   214→  const redisAvailable = redis.isRedisAvailable();\n   215→  const redisStatus = redis.getRedisStatus();\n   216→\n   217→  return {\n   218→    storage: redisAvailable ? 'redis' : 'memory',\n   219→    redisConnected: redisStatus.connected,\n   220→    redisError: redisStatus.error,\n   221→    fallbackSize: fallbackBlacklist.size,\n   222→    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n   223→    usingFallback\n   224→  };\n   225→}\n   226→\n   227→/**\n   228→ * Generate a JWT token for a customer\n   229→ * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n   230→ * @param {Object} options - Additional options\n   231→ * @param {string} options.tier - User's subscription tier\n   232→ * @param {string} options.email - User's email (optional)\n   233→ * @returns {Object} { token, expiresIn }\n   234→ */\n   235→function generateToken(stripeCustomerId, options = {}) {\n   236→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   237→    throw new Error('Invalid Stripe customer ID');\n   238→  }\n   239→\n   240→  const payload = {\n   241→    sub: stripeCustomerId,\n   242→    type: 'access',\n   243→    tier: options.tier || 'starter',\n   244→    iat: Math.floor(Date.now() / 1000),\n   245→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   246→  };\n   247→\n   248→  if (options.email) {\n   249→    payload.email = options.email;\n   250→  }\n   251→\n   252→  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n   253→\n   254→  return {\n   255→    token,\n   256→    expiresIn: JWT_EXPIRES_IN,\n   257→    tokenType: 'Bearer'\n   258→  };\n   259→}\n   260→\n   261→/**\n   262→ * Generate a refresh token for a customer\n   263→ * @param {string} stripeCustomerId - Stripe customer ID\n   264→ * @returns {Object} { refreshToken, expiresIn }\n   265→ */\n   266→function generateRefreshToken(stripeCustomerId) {\n   267→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   268→    throw new Error('Invalid Stripe customer ID');\n   269→  }\n   270→\n   271→  const payload = {\n   272→    sub: stripeCustomerId,\n   273→    type: 'refresh',\n   274→    iat: Math.floor(Date.now() / 1000),\n   275→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   276→  };\n   277→\n   278→  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n   279→\n   280→  return {\n   281→    refreshToken,\n   282→    expiresIn: JWT_REFRESH_EXPIRES_IN\n   283→  };\n   284→}\n   285→\n   286→/**\n   287→ * Verify and decode a JWT token (async version)\n   288→ * Checks both JWT signature validity and token blacklist status via Redis\n   289→ * @param {string} token - JWT token to verify\n   290→ * @param {Object} options - Verification options\n   291→ * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n   292→ * @param {Object} options.req - Express request object for logging (optional)\n   293→ * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n   294→ */\n   295→async function verifyToken(token, options = {}) {\n   296→  const { checkBlacklist = true, req = null } = options;\n   297→\n   298→  try {\n   299→    const decoded = jwt.verify(token, JWT_SECRET);\n   300→\n   301→    // Check if token has been revoked (blacklisted) - async Redis check\n   302→    if (checkBlacklist && decoded.jti) {\n   303→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   304→      if (isBlacklisted) {\n   305→        if (req) {\n   306→          authLogger.logTokenBlacklisted(req, decoded.jti);\n   307→        }\n   308→        return null;\n   309→      }\n   310→    }\n   311→\n   312→    return decoded;\n   313→  } catch (err) {\n   314→    // Log specific error types for debugging\n   315→    if (err.name === 'TokenExpiredError') {\n   316→      if (req) {\n   317→        authLogger.logTokenExpired(req);\n   318→      }\n   319→    } else if (err.name === 'JsonWebTokenError') {\n   320→      if (req) {\n   321→        authLogger.logTokenInvalid(req, err.message);\n   322→      }\n   323→    }\n   324→    return null;\n   325→  }\n   326→}\n   327→\n   328→/**\n   329→ * Synchronous token verification (for cases where async is not possible)\n   330→ * Does NOT check blacklist - use verifyToken() for full verification\n   331→ * @param {string} token - JWT token to verify\n   332→ * @returns {Object|null} Decoded payload or null if invalid\n   333→ */\n   334→function verifyTokenSync(token) {\n   335→  try {\n   336→    return jwt.verify(token, JWT_SECRET);\n   337→  } catch {\n   338→    return null;\n   339→  }\n   340→}\n   341→\n   342→/**\n   343→ * Extract Bearer token from Authorization header\n   344→ * @param {string} authHeader - Authorization header value\n   345→ * @returns {string|null} Token or null if not found\n   346→ */\n   347→function extractBearerToken(authHeader) {\n   348→  if (!authHeader || typeof authHeader !== 'string') {\n   349→    return null;\n   350→  }\n   351→\n   352→  const parts = authHeader.split(' ');\n   353→  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n   354→    return null;\n   355→  }\n   356→\n   357→  return parts[1];\n   358→}\n   359→\n   360→/**\n   361→ * Middleware to authenticate JWT tokens\n   362→ * Sets req.stripeCustomerId if valid token found\n   363→ *\n   364→ * Supports both:\n   365→ * - Authorization: Bearer <token> (preferred)\n   366→ * - x-stripe-customer-id header (legacy, will be deprecated)\n   367→ */\n   368→async function authenticateToken(req, res, next) {\n   369→  // First, try JWT token from Authorization header\n   370→  const authHeader = req.headers['authorization'];\n   371→  const token = extractBearerToken(authHeader);\n   372→\n   373→  if (token) {\n   374→    // First verify JWT signature without blacklist check to get specific error messages\n   375→    const decoded = verifyTokenSync(token);\n   376→\n   377→    if (!decoded || !decoded.sub) {\n   378→      // Token is invalid or expired (signature failed)\n   379→      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n   380→      return res.status(401).json({\n   381→        error: 'Invalid or expired token',\n   382→        message: 'Please log in again to continue'\n   383→      });\n   384→    }\n   385→\n   386→    // Check if token has been revoked (blacklisted) - async Redis check\n   387→    if (decoded.jti) {\n   388→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   389→      if (isBlacklisted) {\n   390→        authLogger.logTokenBlacklisted(req, decoded.jti);\n   391→        return res.status(401).json({\n   392→          error: 'Token has been revoked',\n   393→          message: 'This session has been logged out. Please log in again.'\n   394→        });\n   395→      }\n   396→    }\n   397→\n   398→    // Token is valid and not revoked\n   399→    req.stripeCustomerId = decoded.sub;\n   400→    req.tokenData = decoded;\n   401→    req.rawToken = token; // Store raw token for logout\n   402→    return next();\n   403→  }\n   404→\n   405→  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n   406→  // This will be deprecated in future versions\n   407→  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   408→  if (legacyCustomerId) {\n   409→    // Log deprecation warning with structured logging (once per request)\n   410→    if (!req._legacyAuthWarned) {\n   411→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   412→      req._legacyAuthWarned = true;\n   413→    }\n   414→\n   415→    // Validate format\n   416→    if (!legacyCustomerId.startsWith('cus_')) {\n   417→      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n   418→      return res.status(401).json({\n   419→        error: 'Invalid customer ID format',\n   420→        message: 'Customer ID must start with cus_'\n   421→      });\n   422→    }\n   423→\n   424→    req.stripeCustomerId = legacyCustomerId;\n   425→    req.isLegacyAuth = true;\n   426→    return next();\n   427→  }\n   428→\n   429→  // No authentication provided\n   430→  return res.status(401).json({\n   431→    error: 'Authentication required',\n   432→    message: 'Please provide a valid Bearer token in the Authorization header'\n   433→  });\n   434→}\n   435→\n   436→/**\n   437→ * Optional authentication middleware\n   438→ * Allows unauthenticated access but sets req.stripeCustomerId if token present\n   439→ */\n   440→async function optionalAuthentication(req, res, next) {\n   441→  const authHeader = req.headers['authorization'];\n   442→  const token = extractBearerToken(authHeader);\n   443→\n   444→  if (token) {\n   445→    const decoded = await verifyToken(token);\n   446→    if (decoded && decoded.sub) {\n   447→      req.stripeCustomerId = decoded.sub;\n   448→      req.tokenData = decoded;\n   449→    }\n   450→  } else {\n   451→    // Check legacy header\n   452→    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   453→    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n   454→      req.stripeCustomerId = legacyCustomerId;\n   455→      req.isLegacyAuth = true;\n   456→    }\n   457→  }\n   458→\n   459→  next();\n   460→}\n   461→\n   462→/**\n   463→ * HIGH-007: Database-backed admin role check middleware\n   464→ * Checks the user's role in the database instead of relying on env vars\n   465→ * Requires authenticateToken middleware to run first\n   466→ *\n   467→ * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n   468→ * @param {Object} res - Express response object\n   469→ * @param {Function} next - Express next function\n   470→ */\n   471→async function requireAdmin(req, res, next) {\n   472→  // Must be authenticated first\n   473→  if (!req.stripeCustomerId) {\n   474→    return res.status(401).json({\n   475→      error: 'Authentication required',\n   476→      message: 'Please log in to access this resource'\n   477→    });\n   478→  }\n   479→\n   480→  // Check if database pool is available\n   481→  if (!pool) {\n   482→    console.error('[Auth] Admin check failed: Database pool not available');\n   483→    return res.status(503).json({\n   484→      error: 'Service unavailable',\n   485→      message: 'Admin verification temporarily unavailable'\n   486→    });\n   487→  }\n   488→\n   489→  try {\n   490→    // Query database for user role\n   491→    const result = await pool.query(\n   492→      'SELECT role FROM users WHERE stripe_customer_id = $1',\n   493→      [req.stripeCustomerId]\n   494→    );\n   495→\n   496→    if (!result.rows[0]) {\n   497→      authLogger.logAdminAccessDenied(req, 'User not found in database');\n   498→      return res.status(403).json({\n   499→        error: 'Access denied',\n   500→        message: 'User account not found'\n   501→      });\n   502→    }\n   503→\n   504→    const userRole = result.rows[0].role;\n   505→\n   506→    if (userRole !== 'admin') {\n   507→      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n   508→      return res.status(403).json({\n   509→        error: 'Admin access required',\n   510→        message: 'This action requires administrator privileges'\n   511→      });\n   512→    }\n   513→\n   514→    // User is admin - log and proceed\n   515→    authLogger.logAdminAccess(req);\n   516→    req.isAdmin = true;\n   517→    next();\n   518→  } catch (err) {\n   519→    console.error('[Auth] Admin role check failed:', err.message);\n   520→    return res.status(500).json({\n   521→      error: 'Authorization check failed',\n   522→      message: 'Unable to verify admin privileges'\n   523→    });\n   524→  }\n   525→}\n   526→\n   527→/**\n   528→ * Mask sensitive data for logging\n   529→ * @param {string} key - License key or other sensitive string\n   530→ * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n   531→ */\n   532→function maskSensitiveData(data) {\n   533→  if (!data || typeof data !== 'string') {\n   534→    return '****';\n   535→  }\n   536→\n   537→  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n   538→  if (data.startsWith('SPLICE-')) {\n   539→    const parts = data.split('-');\n   540→    if (parts.length === 5) {\n   541→      return `${parts[0]}-${parts[1]}-****-****-****`;\n   542→    }\n   543→  }\n   544→\n   545→  // For customer IDs (cus_xxxx format)\n   546→  if (data.startsWith('cus_')) {\n   547→    if (data.length > 10) {\n   548→      return `cus_${data.slice(4, 8)}****`;\n   549→    }\n   550→    return 'cus_****';\n   551→  }\n   552→\n   553→  // For JWTs (eyJ... format)\n   554→  if (data.startsWith('eyJ')) {\n   555→    return `${data.slice(0, 10)}...****`;\n   556→  }\n   557→\n   558→  // For emails\n   559→  if (data.includes('@')) {\n   560→    const [local, domain] = data.split('@');\n   561→    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n   562→    return `${maskedLocal}@${domain}`;\n   563→  }\n   564→\n   565→  // Generic masking - show first 4 chars\n   566→  if (data.length > 8) {\n   567→    return `${data.slice(0, 4)}****`;\n   568→  }\n   569→\n   570→  return '****';\n   571→}\n   572→\n   573→module.exports = {\n   574→  generateToken,\n   575→  generateRefreshToken,\n   576→  verifyToken,\n   577→  verifyTokenSync,\n   578→  extractBearerToken,\n   579→  authenticateToken,\n   580→  optionalAuthentication,\n   581→  maskSensitiveData,\n   582→  // HIGH-007: Admin RBAC middleware\n   583→  requireAdmin,\n   584→  // Token blacklist functions\n   585→  blacklistToken,\n   586→  isTokenBlacklisted,\n   587→  getBlacklistStats,\n   588→  // Structured logging\n   589→  authLogger,\n   590→  // Constants\n   591→  JWT_SECRET,\n   592→  JWT_EXPIRES_IN\n   593→};\n   594→\n\n</system-reminder>\n"}]},"uuid":"96cc5399-eb67-44b8-80bf-23a6fab15de7","timestamp":"2026-01-11T23:39:02.814Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","content":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n  // This will be deprecated in future versions\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // Check legacy header\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      req.stripeCustomerId = legacyCustomerId;\n      req.isLegacyAuth = true;\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};\n","numLines":594,"startLine":1,"totalLines":594}}}
{"parentUuid":"96cc5399-eb67-44b8-80bf-23a6fab15de7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013P6YxdCtLxDGkvJ6eJJCUW","type":"tool_result","content":"     1→/**\n     2→ * CSRF Protection Middleware\n     3→ *\n     4→ * Implements double-submit cookie pattern for CSRF protection.\n     5→ * Works with stateless JWT authentication.\n     6→ *\n     7→ * How it works:\n     8→ * 1. Client requests a CSRF token via GET /auth/csrf-token\n     9→ * 2. Server generates a cryptographically random token\n    10→ * 3. Server sends token in both:\n    11→ *    - Response body (for JavaScript to read)\n    12→ *    - HttpOnly cookie (for automatic submission)\n    13→ * 4. Client includes token in X-CSRF-Token header on state-changing requests\n    14→ * 5. Server validates header token matches cookie token\n    15→ */\n    16→\n    17→const crypto = require('crypto');\n    18→\n    19→// CSRF Configuration\n    20→const CSRF_TOKEN_LENGTH = 32; // 256 bits\n    21→const CSRF_COOKIE_NAME = 'splice_csrf';\n    22→const CSRF_HEADER_NAME = 'x-csrf-token';\n    23→const CSRF_TOKEN_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n    24→\n    25→// Check if running in production\n    26→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    27→\n    28→/**\n    29→ * Generate a cryptographically secure CSRF token\n    30→ * @returns {string} Hex-encoded random token\n    31→ */\n    32→function generateCsrfToken() {\n    33→  return crypto.randomBytes(CSRF_TOKEN_LENGTH).toString('hex');\n    34→}\n    35→\n    36→/**\n    37→ * Constant-time comparison to prevent timing attacks\n    38→ * @param {string} a - First string\n    39→ * @param {string} b - Second string\n    40→ * @returns {boolean} True if strings are equal\n    41→ */\n    42→function safeCompare(a, b) {\n    43→  if (!a || !b || typeof a !== 'string' || typeof b !== 'string') {\n    44→    return false;\n    45→  }\n    46→\n    47→  // Use crypto.timingSafeEqual for constant-time comparison\n    48→  const bufA = Buffer.from(a);\n    49→  const bufB = Buffer.from(b);\n    50→\n    51→  if (bufA.length !== bufB.length) {\n    52→    return false;\n    53→  }\n    54→\n    55→  return crypto.timingSafeEqual(bufA, bufB);\n    56→}\n    57→\n    58→/**\n    59→ * Get cookie options for CSRF token\n    60→ * @returns {Object} Cookie configuration\n    61→ */\n    62→function getCsrfCookieOptions() {\n    63→  return {\n    64→    httpOnly: true,\n    65→    secure: isProduction, // Only secure in production (HTTPS)\n    66→    sameSite: 'strict', // Strict same-site policy for CSRF protection\n    67→    maxAge: CSRF_TOKEN_EXPIRY,\n    68→    path: '/',\n    69→    // Domain is omitted to default to the current domain\n    70→  };\n    71→}\n    72→\n    73→/**\n    74→ * Handler to generate and return a CSRF token\n    75→ * Should be mounted as GET /auth/csrf-token\n    76→ *\n    77→ * @param {Request} req - Express request\n    78→ * @param {Response} res - Express response\n    79→ */\n    80→function csrfTokenHandler(req, res) {\n    81→  const token = generateCsrfToken();\n    82→\n    83→  // Set the token in an HttpOnly cookie\n    84→  res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n    85→\n    86→  // Also return token in response body for JavaScript to use\n    87→  // The client will send this in the X-CSRF-Token header\n    88→  res.json({\n    89→    success: true,\n    90→    csrfToken: token,\n    91→    expiresIn: CSRF_TOKEN_EXPIRY / 1000 // seconds\n    92→  });\n    93→\n    94→  console.log('[CSRF] Token generated for request');\n    95→}\n    96→\n    97→/**\n    98→ * Middleware to validate CSRF token on state-changing requests\n    99→ * Checks that the X-CSRF-Token header matches the cookie value\n   100→ *\n   101→ * @param {Request} req - Express request\n   102→ * @param {Response} res - Express response\n   103→ * @param {Function} next - Next middleware\n   104→ */\n   105→function validateCsrfToken(req, res, next) {\n   106→  // Skip CSRF validation for safe methods (GET, HEAD, OPTIONS)\n   107→  const safeMethods = ['GET', 'HEAD', 'OPTIONS'];\n   108→  if (safeMethods.includes(req.method)) {\n   109→    return next();\n   110→  }\n   111→\n   112→  // Get token from header\n   113→  const headerToken = req.headers[CSRF_HEADER_NAME];\n   114→\n   115→  // Get token from cookie\n   116→  const cookieToken = req.cookies?.[CSRF_COOKIE_NAME];\n   117→\n   118→  // Validate both tokens exist\n   119→  if (!headerToken) {\n   120→    console.warn('[CSRF] Missing CSRF token in header');\n   121→    return res.status(403).json({\n   122→      error: 'CSRF token missing',\n   123→      message: 'Please refresh the page and try again'\n   124→    });\n   125→  }\n   126→\n   127→  if (!cookieToken) {\n   128→    console.warn('[CSRF] Missing CSRF cookie');\n   129→    return res.status(403).json({\n   130→      error: 'CSRF validation failed',\n   131→      message: 'Session expired. Please refresh the page and try again'\n   132→    });\n   133→  }\n   134→\n   135→  // Use constant-time comparison to prevent timing attacks\n   136→  if (!safeCompare(headerToken, cookieToken)) {\n   137→    console.warn('[CSRF] Token mismatch - possible CSRF attack');\n   138→    return res.status(403).json({\n   139→      error: 'CSRF validation failed',\n   140→      message: 'Security validation failed. Please refresh the page and try again'\n   141→    });\n   142→  }\n   143→\n   144→  // Token is valid\n   145→  next();\n   146→}\n   147→\n   148→/**\n   149→ * Conditional CSRF validation middleware\n   150→ * Skips validation for certain routes (e.g., webhooks, public endpoints)\n   151→ *\n   152→ * @param {Object} options - Configuration options\n   153→ * @param {string[]} options.skipRoutes - Array of route patterns to skip\n   154→ * @returns {Function} Middleware function\n   155→ */\n   156→function csrfProtection(options = {}) {\n   157→  const { skipRoutes = [] } = options;\n   158→\n   159→  // Default routes to skip CSRF validation\n   160→  const defaultSkipRoutes = [\n   161→    '/webhooks/', // Stripe webhooks use their own signature verification\n   162→    '/health', // Health checks are public\n   163→    '/api-info', // API info is public\n   164→  ];\n   165→\n   166→  const allSkipRoutes = [...defaultSkipRoutes, ...skipRoutes];\n   167→\n   168→  return (req, res, next) => {\n   169→    // Check if this route should skip CSRF validation\n   170→    const shouldSkip = allSkipRoutes.some(route => req.path.startsWith(route));\n   171→\n   172→    if (shouldSkip) {\n   173→      return next();\n   174→    }\n   175→\n   176→    // Apply CSRF validation\n   177→    return validateCsrfToken(req, res, next);\n   178→  };\n   179→}\n   180→\n   181→/**\n   182→ * Middleware to ensure CSRF cookie exists\n   183→ * Sets a new cookie if one doesn't exist\n   184→ * Useful for ensuring cookie is set before any form is shown\n   185→ *\n   186→ * @param {Request} req - Express request\n   187→ * @param {Response} res - Express response\n   188→ * @param {Function} next - Next middleware\n   189→ */\n   190→function ensureCsrfCookie(req, res, next) {\n   191→  // Check if cookie already exists\n   192→  if (!req.cookies?.[CSRF_COOKIE_NAME]) {\n   193→    const token = generateCsrfToken();\n   194→    res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n   195→  }\n   196→  next();\n   197→}\n   198→\n   199→module.exports = {\n   200→  generateCsrfToken,\n   201→  csrfTokenHandler,\n   202→  validateCsrfToken,\n   203→  csrfProtection,\n   204→  ensureCsrfCookie,\n   205→  // Constants for external use\n   206→  CSRF_COOKIE_NAME,\n   207→  CSRF_HEADER_NAME,\n   208→  CSRF_TOKEN_EXPIRY\n   209→};\n   210→\n\n</system-reminder>\n"}]},"uuid":"221728e4-72cd-4dfa-9bab-7d79b86c92fc","timestamp":"2026-01-11T23:39:02.814Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js","content":"/**\n * CSRF Protection Middleware\n *\n * Implements double-submit cookie pattern for CSRF protection.\n * Works with stateless JWT authentication.\n *\n * How it works:\n * 1. Client requests a CSRF token via GET /auth/csrf-token\n * 2. Server generates a cryptographically random token\n * 3. Server sends token in both:\n *    - Response body (for JavaScript to read)\n *    - HttpOnly cookie (for automatic submission)\n * 4. Client includes token in X-CSRF-Token header on state-changing requests\n * 5. Server validates header token matches cookie token\n */\n\nconst crypto = require('crypto');\n\n// CSRF Configuration\nconst CSRF_TOKEN_LENGTH = 32; // 256 bits\nconst CSRF_COOKIE_NAME = 'splice_csrf';\nconst CSRF_HEADER_NAME = 'x-csrf-token';\nconst CSRF_TOKEN_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n/**\n * Generate a cryptographically secure CSRF token\n * @returns {string} Hex-encoded random token\n */\nfunction generateCsrfToken() {\n  return crypto.randomBytes(CSRF_TOKEN_LENGTH).toString('hex');\n}\n\n/**\n * Constant-time comparison to prevent timing attacks\n * @param {string} a - First string\n * @param {string} b - Second string\n * @returns {boolean} True if strings are equal\n */\nfunction safeCompare(a, b) {\n  if (!a || !b || typeof a !== 'string' || typeof b !== 'string') {\n    return false;\n  }\n\n  // Use crypto.timingSafeEqual for constant-time comparison\n  const bufA = Buffer.from(a);\n  const bufB = Buffer.from(b);\n\n  if (bufA.length !== bufB.length) {\n    return false;\n  }\n\n  return crypto.timingSafeEqual(bufA, bufB);\n}\n\n/**\n * Get cookie options for CSRF token\n * @returns {Object} Cookie configuration\n */\nfunction getCsrfCookieOptions() {\n  return {\n    httpOnly: true,\n    secure: isProduction, // Only secure in production (HTTPS)\n    sameSite: 'strict', // Strict same-site policy for CSRF protection\n    maxAge: CSRF_TOKEN_EXPIRY,\n    path: '/',\n    // Domain is omitted to default to the current domain\n  };\n}\n\n/**\n * Handler to generate and return a CSRF token\n * Should be mounted as GET /auth/csrf-token\n *\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n */\nfunction csrfTokenHandler(req, res) {\n  const token = generateCsrfToken();\n\n  // Set the token in an HttpOnly cookie\n  res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n\n  // Also return token in response body for JavaScript to use\n  // The client will send this in the X-CSRF-Token header\n  res.json({\n    success: true,\n    csrfToken: token,\n    expiresIn: CSRF_TOKEN_EXPIRY / 1000 // seconds\n  });\n\n  console.log('[CSRF] Token generated for request');\n}\n\n/**\n * Middleware to validate CSRF token on state-changing requests\n * Checks that the X-CSRF-Token header matches the cookie value\n *\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n * @param {Function} next - Next middleware\n */\nfunction validateCsrfToken(req, res, next) {\n  // Skip CSRF validation for safe methods (GET, HEAD, OPTIONS)\n  const safeMethods = ['GET', 'HEAD', 'OPTIONS'];\n  if (safeMethods.includes(req.method)) {\n    return next();\n  }\n\n  // Get token from header\n  const headerToken = req.headers[CSRF_HEADER_NAME];\n\n  // Get token from cookie\n  const cookieToken = req.cookies?.[CSRF_COOKIE_NAME];\n\n  // Validate both tokens exist\n  if (!headerToken) {\n    console.warn('[CSRF] Missing CSRF token in header');\n    return res.status(403).json({\n      error: 'CSRF token missing',\n      message: 'Please refresh the page and try again'\n    });\n  }\n\n  if (!cookieToken) {\n    console.warn('[CSRF] Missing CSRF cookie');\n    return res.status(403).json({\n      error: 'CSRF validation failed',\n      message: 'Session expired. Please refresh the page and try again'\n    });\n  }\n\n  // Use constant-time comparison to prevent timing attacks\n  if (!safeCompare(headerToken, cookieToken)) {\n    console.warn('[CSRF] Token mismatch - possible CSRF attack');\n    return res.status(403).json({\n      error: 'CSRF validation failed',\n      message: 'Security validation failed. Please refresh the page and try again'\n    });\n  }\n\n  // Token is valid\n  next();\n}\n\n/**\n * Conditional CSRF validation middleware\n * Skips validation for certain routes (e.g., webhooks, public endpoints)\n *\n * @param {Object} options - Configuration options\n * @param {string[]} options.skipRoutes - Array of route patterns to skip\n * @returns {Function} Middleware function\n */\nfunction csrfProtection(options = {}) {\n  const { skipRoutes = [] } = options;\n\n  // Default routes to skip CSRF validation\n  const defaultSkipRoutes = [\n    '/webhooks/', // Stripe webhooks use their own signature verification\n    '/health', // Health checks are public\n    '/api-info', // API info is public\n  ];\n\n  const allSkipRoutes = [...defaultSkipRoutes, ...skipRoutes];\n\n  return (req, res, next) => {\n    // Check if this route should skip CSRF validation\n    const shouldSkip = allSkipRoutes.some(route => req.path.startsWith(route));\n\n    if (shouldSkip) {\n      return next();\n    }\n\n    // Apply CSRF validation\n    return validateCsrfToken(req, res, next);\n  };\n}\n\n/**\n * Middleware to ensure CSRF cookie exists\n * Sets a new cookie if one doesn't exist\n * Useful for ensuring cookie is set before any form is shown\n *\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n * @param {Function} next - Next middleware\n */\nfunction ensureCsrfCookie(req, res, next) {\n  // Check if cookie already exists\n  if (!req.cookies?.[CSRF_COOKIE_NAME]) {\n    const token = generateCsrfToken();\n    res.cookie(CSRF_COOKIE_NAME, token, getCsrfCookieOptions());\n  }\n  next();\n}\n\nmodule.exports = {\n  generateCsrfToken,\n  csrfTokenHandler,\n  validateCsrfToken,\n  csrfProtection,\n  ensureCsrfCookie,\n  // Constants for external use\n  CSRF_COOKIE_NAME,\n  CSRF_HEADER_NAME,\n  CSRF_TOKEN_EXPIRY\n};\n","numLines":210,"startLine":1,"totalLines":210}}}
{"parentUuid":"221728e4-72cd-4dfa-9bab-7d79b86c92fc","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012NQohVSZuAhMtthFDyZ8kB","type":"tool_result","content":"     1→/**\n     2→ * Rate Limiter Middleware\n     3→ *\n     4→ * Checks if user has sufficient credits before processing.\n     5→ * Uses atomic credit reservation to prevent race conditions.\n     6→ * Returns 402 Payment Required if insufficient credits.\n     7→ *\n     8→ * SECURITY FEATURES:\n     9→ * - JWT authentication via authenticateToken middleware\n    10→ * - Redis-backed rate limiting with in-memory fallback\n    11→ * - Tiered limits: authenticated users get higher limits than anonymous\n    12→ * - Endpoint-specific limits for sensitive operations\n    13→ * - Proper 429 responses with Retry-After header\n    14→ * - Legacy x-stripe-customer-id header is DISABLED in production for security\n    15→ */\n    16→\n    17→const {\n    18→  deductUsage,\n    19→  getBalance,\n    20→  reserveCredits,\n    21→  confirmReservation,\n    22→  releaseReservation,\n    23→  customerExists,\n    24→  hasFeatureAccess\n    25→} = require('../services/usageTracking');\n    26→const { verifyToken, extractBearerToken } = require('./auth');\n    27→const redisClient = require('../services/redisClient');\n    28→\n    29→// SECURITY: Disable legacy auth in production unless explicitly enabled\n    30→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    31→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n    32→\n    33→// =============================================================================\n    34→// SECURITY: Enhanced IP-based Rate Limiting with Redis Backend\n    35→// =============================================================================\n    36→\n    37→/**\n    38→ * Rate limit configuration\n    39→ * Tiered limits: authenticated users get higher limits than anonymous\n    40→ */\n    41→const RATE_LIMITS = {\n    42→  // Global IP limits\n    43→  global: {\n    44→    anonymous: { max: 100, window: 60 },      // 100 req/min for unauthenticated\n    45→    authenticated: { max: 300, window: 60 }   // 300 req/min for authenticated users\n    46→  },\n    47→  // Endpoint-specific limits (stricter)\n    48→  endpoints: {\n    49→    '/auth/send-code': { max: 5, window: 300 },        // 5 requests per 5 minutes\n    50→    '/auth/verify-code': { max: 10, window: 300 },     // 10 requests per 5 minutes\n    51→    '/music/generate': { max: 10, window: 60 },        // 10 requests per minute\n    52→    '/analyze': { max: 30, window: 60 },               // 30 requests per minute\n    53→    'upload': { max: 20, window: 60 }                  // 20 uploads per minute\n    54→  }\n    55→};\n    56→\n    57→// In-memory fallback for when Redis is unavailable\n    58→const ipRequestCounts = new Map(); // IP -> { count, windowStart }\n    59→\n    60→// Cleanup old entries every 5 minutes to prevent memory leaks\n    61→setInterval(() => {\n    62→  const now = Date.now();\n    63→  for (const [ip, data] of ipRequestCounts.entries()) {\n    64→    if (now - data.windowStart > 120000) { // Clean up entries older than 2 minutes\n    65→      ipRequestCounts.delete(ip);\n    66→    }\n    67→  }\n    68→}, 300000);\n    69→\n    70→/**\n    71→ * SECURITY: Check rate limit using Redis with in-memory fallback\n    72→ * @param {string} key - Redis key for rate limit counter\n    73→ * @param {number} max - Maximum requests allowed\n    74→ * @param {number} windowSeconds - Time window in seconds\n    75→ * @returns {Promise<{allowed: boolean, remaining: number, resetAt: number}>}\n    76→ */\n    77→async function checkRateLimit(key, max, windowSeconds) {\n    78→  try {\n    79→    // Try Redis first (preferred for multi-instance deployments)\n    80→    if (redisClient && redisClient.isConnected) {\n    81→      const current = await redisClient.incr(key);\n    82→      \n    83→      if (current === 1) {\n    84→        // First request in window, set expiry\n    85→        await redisClient.expire(key, windowSeconds);\n    86→      }\n    87→      \n    88→      const ttl = await redisClient.ttl(key);\n    89→      const resetAt = Date.now() + (ttl * 1000);\n    90→      \n    91→      return {\n    92→        allowed: current <= max,\n    93→        remaining: Math.max(0, max - current),\n    94→        resetAt,\n    95→        retryAfter: ttl\n    96→      };\n    97→    }\n    98→  } catch (redisError) {\n    99→    console.warn('[RateLimiter] Redis error, falling back to in-memory:', redisError.message);\n   100→  }\n   101→  \n   102→  // Fallback to in-memory (single-instance only)\n   103→  const now = Date.now();\n   104→  const windowMs = windowSeconds * 1000;\n   105→  const data = ipRequestCounts.get(key);\n   106→  \n   107→  if (!data || now - data.windowStart > windowMs) {\n   108→    // Start new window\n   109→    ipRequestCounts.set(key, { count: 1, windowStart: now });\n   110→    return {\n   111→      allowed: true,\n   112→      remaining: max - 1,\n   113→      resetAt: now + windowMs,\n   114→      retryAfter: windowSeconds\n   115→    };\n   116→  }\n   117→  \n   118→  data.count++;\n   119→  const allowed = data.count <= max;\n   120→  const remaining = Math.max(0, max - data.count);\n   121→  const resetAt = data.windowStart + windowMs;\n   122→  const retryAfter = Math.ceil((resetAt - now) / 1000);\n   123→  \n   124→  return {\n   125→    allowed,\n   126→    remaining,\n   127→    resetAt,\n   128→    retryAfter\n   129→  };\n   130→}\n   131→\n   132→/**\n   133→ * SECURITY: IP-based rate limiting middleware with tiered limits\n   134→ * Authenticated users get higher limits than anonymous users\n   135→ * Returns 429 with Retry-After header when limit exceeded\n   136→ */\n   137→function ipRateLimit(req, res, next) {\n   138→  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n   139→  \n   140→  // Determine if user is authenticated (check for valid JWT token)\n   141→  const authHeader = req.headers['authorization'];\n   142→  const token = extractBearerToken(authHeader);\n   143→  const isAuthenticated = !!token; // Simple check, validation happens in requireCredits\n   144→  \n   145→  // Select appropriate rate limit\n   146→  const limit = isAuthenticated\n   147→    ? RATE_LIMITS.global.authenticated\n   148→    : RATE_LIMITS.global.anonymous;\n   149→  \n   150→  const rateLimitKey = `ratelimit:global:${clientIp}`;\n   151→  \n   152→  checkRateLimit(rateLimitKey, limit.max, limit.window)\n   153→    .then(result => {\n   154→      // Add rate limit headers (industry standard)\n   155→      res.set('X-RateLimit-Limit', limit.max.toString());\n   156→      res.set('X-RateLimit-Remaining', result.remaining.toString());\n   157→      res.set('X-RateLimit-Reset', Math.floor(result.resetAt / 1000).toString());\n   158→      \n   159→      if (!result.allowed) {\n   160→        // SECURITY: Return 429 with Retry-After header\n   161→        res.set('Retry-After', result.retryAfter.toString());\n   162→        console.warn(`[SECURITY] Global rate limit exceeded for IP: ${clientIp} (${isAuthenticated ? 'authenticated' : 'anonymous'})`);\n   163→        return res.status(429).json({\n   164→          error: 'Too many requests',\n   165→          message: 'Please slow down and try again later',\n   166→          retryAfter: result.retryAfter,\n   167→          limit: limit.max,\n   168→          window: limit.window\n   169→        });\n   170→      }\n   171→      \n   172→      next();\n   173→    })\n   174→    .catch(err => {\n   175→      console.error('[RateLimiter] Error checking rate limit:', err);\n   176→      // On error, allow request but log warning\n   177→      console.warn('[RateLimiter] Rate limit check failed, allowing request');\n   178→      next();\n   179→    });\n   180→}\n   181→\n   182→/**\n   183→ * SECURITY: Endpoint-specific rate limiting\n   184→ * Stricter limits for sensitive operations like authentication and file uploads\n   185→ * @param {string} endpointKey - Key from RATE_LIMITS.endpoints\n   186→ */\n   187→function endpointRateLimit(endpointKey) {\n   188→  return async (req, res, next) => {\n   189→    const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n   190→    const limit = RATE_LIMITS.endpoints[endpointKey];\n   191→    \n   192→    if (!limit) {\n   193→      console.warn(`[RateLimiter] No rate limit configured for endpoint: ${endpointKey}`);\n   194→      return next();\n   195→    }\n   196→    \n   197→    const rateLimitKey = `ratelimit:endpoint:${endpointKey}:${clientIp}`;\n   198→    \n   199→    try {\n   200→      const result = await checkRateLimit(rateLimitKey, limit.max, limit.window);\n   201→      \n   202→      // Add rate limit headers\n   203→      res.set('X-RateLimit-Limit', limit.max.toString());\n   204→      res.set('X-RateLimit-Remaining', result.remaining.toString());\n   205→      res.set('X-RateLimit-Reset', Math.floor(result.resetAt / 1000).toString());\n   206→      \n   207→      if (!result.allowed) {\n   208→        // SECURITY: Return 429 with Retry-After header\n   209→        res.set('Retry-After', result.retryAfter.toString());\n   210→        console.warn(`[SECURITY] Endpoint rate limit exceeded for ${endpointKey} from IP: ${clientIp}`);\n   211→        return res.status(429).json({\n   212→          error: 'Too many requests',\n   213→          message: `Rate limit exceeded for this operation. Please try again in ${result.retryAfter} seconds.`,\n   214→          retryAfter: result.retryAfter,\n   215→          limit: limit.max,\n   216→          window: limit.window\n   217→        });\n   218→      }\n   219→      \n   220→      next();\n   221→    } catch (err) {\n   222→      console.error(`[RateLimiter] Error checking endpoint rate limit for ${endpointKey}:`, err);\n   223→      // On error, allow request but log warning\n   224→      console.warn('[RateLimiter] Endpoint rate limit check failed, allowing request');\n   225→      next();\n   226→    }\n   227→  };\n   228→}\n   229→\n   230→// Rate limiting for legacy auth attempts (prevent brute force)\n   231→const legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\n   232→const LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\n   233→const LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n   234→\n   235→/**\n   236→ * Check if IP is rate limited for legacy auth\n   237→ */\n   238→function isLegacyAuthRateLimited(ip) {\n   239→  const now = Date.now();\n   240→  const attempt = legacyAuthAttempts.get(ip);\n   241→\n   242→  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n   243→    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n   244→    return false;\n   245→  }\n   246→\n   247→  attempt.count++;\n   248→  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n   249→    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n   250→    return true;\n   251→  }\n   252→\n   253→  return false;\n   254→}\n   255→\n   256→// Default estimated duration for reservation (1 minute = 60 seconds)\n   257→const DEFAULT_RESERVATION_SECONDS = 60;\n   258→\n   259→/**\n   260→ * Middleware to check and atomically reserve credits before processing\n   261→ *\n   262→ * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n   263→ * Falls back to legacy x-stripe-customer-id header (deprecated)\n   264→ *\n   265→ * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n   266→ *\n   267→ * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n   268→ * where multiple concurrent requests could all pass credit check.\n   269→ */\n   270→function requireCredits(options = {}) {\n   271→  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n   272→\n   273→  return async (req, res, next) => {\n   274→    // SECURITY: Primary auth via JWT token\n   275→    const authHeader = req.headers['authorization'];\n   276→    const token = extractBearerToken(authHeader);\n   277→\n   278→    let stripeCustomerId = null;\n   279→\n   280→    if (token) {\n   281→      const decoded = await verifyToken(token);\n   282→      if (decoded && decoded.sub) {\n   283→        stripeCustomerId = decoded.sub;\n   284→        req.tokenData = decoded;\n   285→      } else {\n   286→        // Token present but invalid\n   287→        return res.status(401).json({\n   288→          error: 'Invalid or expired token',\n   289→          message: 'Please log in again to continue'\n   290→        });\n   291→      }\n   292→    } else {\n   293→      // DEPRECATED: Fallback to legacy header\n   294→      const legacyId = req.headers['x-stripe-customer-id'];\n   295→      if (legacyId) {\n   296→        // SECURITY: Block legacy auth in production unless explicitly enabled\n   297→        if (isProduction && !ALLOW_LEGACY_AUTH) {\n   298→          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n   299→          return res.status(401).json({\n   300→            error: 'Authentication method not supported',\n   301→            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n   302→          });\n   303→        }\n   304→\n   305→        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n   306→        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n   307→        if (isLegacyAuthRateLimited(clientIp)) {\n   308→          return res.status(429).json({\n   309→            error: 'Too many authentication attempts',\n   310→            message: 'Please wait before trying again'\n   311→          });\n   312→        }\n   313→\n   314→        // Validate format to prevent injection\n   315→        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n   316→          return res.status(401).json({\n   317→            error: 'Invalid customer ID format',\n   318→            message: 'Customer ID must be a valid Stripe customer ID'\n   319→          });\n   320→        }\n   321→\n   322→        // SECURITY: Verify customer exists in database before accepting\n   323→        const exists = await customerExists(legacyId);\n   324→        if (!exists) {\n   325→          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n   326→          return res.status(401).json({\n   327→            error: 'Invalid customer ID',\n   328→            message: 'Customer not found'\n   329→          });\n   330→        }\n   331→\n   332→        stripeCustomerId = legacyId;\n   333→        req.isLegacyAuth = true;\n   334→        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n   335→      }\n   336→    }\n   337→\n   338→    if (!stripeCustomerId) {\n   339→      return res.status(401).json({\n   340→        error: 'Authentication required',\n   341→        message: 'Missing Stripe customer ID'\n   342→      });\n   343→    }\n   344→\n   345→    // Store for later use\n   346→    req.stripeCustomerId = stripeCustomerId;\n   347→\n   348→    // Determine estimated duration - use request value, option value, or default\n   349→    const estSeconds = req.estimatedDuration || estimatedSeconds;\n   350→\n   351→    try {\n   352→      // Atomically reserve credits using SELECT...FOR UPDATE\n   353→      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n   354→\n   355→      if (!reservation.success) {\n   356→        // Reservation failed - not enough credits\n   357→        const balance = await getBalance(stripeCustomerId);\n   358→        return res.status(402).json({\n   359→          error: 'Insufficient credits',\n   360→          message: 'Please upgrade your plan or wait for your next billing cycle',\n   361→          balance: {\n   362→            hoursRemaining: balance.hoursRemaining,\n   363→            tier: balance.tier\n   364→          }\n   365→        });\n   366→      }\n   367→\n   368→      // Store reservation info for confirmation/release\n   369→      req.reservation = {\n   370→        id: reservation.reservationId,\n   371→        seconds: estSeconds,\n   372→        hoursReserved: reservation.hoursReserved\n   373→      };\n   374→\n   375→      // Attach helper function to confirm usage with actual duration\n   376→      // This adjusts the reservation if actual duration differs\n   377→      req.deductUsage = async (actualDurationSeconds) => {\n   378→        return await confirmReservation(\n   379→          stripeCustomerId,\n   380→          actualDurationSeconds,\n   381→          estSeconds,\n   382→          endpoint\n   383→        );\n   384→      };\n   385→\n   386→      // Attach helper function to release reservation on failure\n   387→      req.releaseReservation = async (reason = 'processing_failed') => {\n   388→        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n   389→      };\n   390→\n   391→      // Hook into response to auto-release on error responses\n   392→      const originalSend = res.send.bind(res);\n   393→      res.send = function(body) {\n   394→        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n   395→        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n   396→          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n   397→            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n   398→        }\n   399→        return originalSend(body);\n   400→      };\n   401→\n   402→      next();\n   403→    } catch (err) {\n   404→      console.error('[RateLimiter] Error reserving credits:', err);\n   405→      return res.status(500).json({\n   406→        error: 'Credit check failed',\n   407→        message: err.message\n   408→      });\n   409→    }\n   410→  };\n   411→}\n   412→\n   413→/**\n   414→ * Middleware to enforce tier-based feature access\n   415→ *\n   416→ * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n   417→ * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n   418→ *\n   419→ * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n   420→ */\n   421→function requireFeature(featureName) {\n   422→  return async (req, res, next) => {\n   423→    // Must have stripeCustomerId from requireCredits middleware\n   424→    if (!req.stripeCustomerId) {\n   425→      return res.status(401).json({\n   426→        error: 'Authentication required',\n   427→        message: 'Please log in to access this feature'\n   428→      });\n   429→    }\n   430→\n   431→    try {\n   432→      // Get user's current balance (includes tier info)\n   433→      const balance = await getBalance(req.stripeCustomerId);\n   434→\n   435→      // Check if user's tier has access to this feature\n   436→      if (!hasFeatureAccess(balance.tier, featureName)) {\n   437→        // Release any reserved credits since we're blocking the request\n   438→        if (req.releaseReservation) {\n   439→          await req.releaseReservation('feature_not_available');\n   440→        }\n   441→\n   442→        // Determine required tier for helpful error message\n   443→        const requiredTier = getRequiredTierForFeature(featureName);\n   444→\n   445→        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n   446→\n   447→        return res.status(403).json({\n   448→          error: 'Feature not available',\n   449→          message: `This feature requires a ${requiredTier} plan or higher`,\n   450→          requiredFeature: featureName,\n   451→          requiredTier: requiredTier,\n   452→          currentTier: balance.tier\n   453→        });\n   454→      }\n   455→\n   456→      // Feature access granted\n   457→      next();\n   458→    } catch (err) {\n   459→      console.error('[requireFeature] Error checking feature access:', err);\n   460→      return res.status(500).json({\n   461→        error: 'Feature access check failed',\n   462→        message: err.message\n   463→      });\n   464→    }\n   465→  };\n   466→}\n   467→\n   468→/**\n   469→ * Helper to determine required tier for a feature\n   470→ * Used for helpful error messages\n   471→ */\n   472→function getRequiredTierForFeature(featureName) {\n   473→  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n   474→  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n   475→\n   476→  if (teamOnlyFeatures.includes(featureName)) {\n   477→    return 'Team';\n   478→  } else if (proFeatures.includes(featureName)) {\n   479→    return 'Pro';\n   480→  }\n   481→  return 'Starter';\n   482→}\n   483→\n   484→/**\n   485→ * Middleware to track usage after successful response\n   486→ *\n   487→ * Call this after processing to deduct actual usage\n   488→ */\n   489→function trackUsage(endpoint = 'unknown') {\n   490→  return async (req, res, next) => {\n   491→    // Store original json method\n   492→    const originalJson = res.json.bind(res);\n   493→\n   494→    // Override json to track usage on success\n   495→    res.json = async (data) => {\n   496→      // Only deduct on successful responses\n   497→      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n   498→        try {\n   499→          const balance = await deductUsage(\n   500→            req.stripeCustomerId,\n   501→            req.audioDuration,\n   502→            endpoint\n   503→          );\n   504→          // Attach updated balance to response\n   505→          data.balance = balance;\n   506→        } catch (err) {\n   507→          console.error('[RateLimiter] Error deducting usage:', err);\n   508→        }\n   509→      }\n   510→      return originalJson(data);\n   511→    };\n   512→\n   513→    next();\n   514→  };\n   515→}\n   516→\n   517→module.exports = {\n   518→  requireCredits,\n   519→  requireFeature,\n   520→  trackUsage,\n   521→  ipRateLimit\n   522→};\n   523→\n\n</system-reminder>\n"}]},"uuid":"c8288ac3-919e-4329-96b8-65027dd30104","timestamp":"2026-01-11T23:39:02.814Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js","content":"/**\n * Rate Limiter Middleware\n *\n * Checks if user has sufficient credits before processing.\n * Uses atomic credit reservation to prevent race conditions.\n * Returns 402 Payment Required if insufficient credits.\n *\n * SECURITY FEATURES:\n * - JWT authentication via authenticateToken middleware\n * - Redis-backed rate limiting with in-memory fallback\n * - Tiered limits: authenticated users get higher limits than anonymous\n * - Endpoint-specific limits for sensitive operations\n * - Proper 429 responses with Retry-After header\n * - Legacy x-stripe-customer-id header is DISABLED in production for security\n */\n\nconst {\n  deductUsage,\n  getBalance,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  customerExists,\n  hasFeatureAccess\n} = require('../services/usageTracking');\nconst { verifyToken, extractBearerToken } = require('./auth');\nconst redisClient = require('../services/redisClient');\n\n// SECURITY: Disable legacy auth in production unless explicitly enabled\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n\n// =============================================================================\n// SECURITY: Enhanced IP-based Rate Limiting with Redis Backend\n// =============================================================================\n\n/**\n * Rate limit configuration\n * Tiered limits: authenticated users get higher limits than anonymous\n */\nconst RATE_LIMITS = {\n  // Global IP limits\n  global: {\n    anonymous: { max: 100, window: 60 },      // 100 req/min for unauthenticated\n    authenticated: { max: 300, window: 60 }   // 300 req/min for authenticated users\n  },\n  // Endpoint-specific limits (stricter)\n  endpoints: {\n    '/auth/send-code': { max: 5, window: 300 },        // 5 requests per 5 minutes\n    '/auth/verify-code': { max: 10, window: 300 },     // 10 requests per 5 minutes\n    '/music/generate': { max: 10, window: 60 },        // 10 requests per minute\n    '/analyze': { max: 30, window: 60 },               // 30 requests per minute\n    'upload': { max: 20, window: 60 }                  // 20 uploads per minute\n  }\n};\n\n// In-memory fallback for when Redis is unavailable\nconst ipRequestCounts = new Map(); // IP -> { count, windowStart }\n\n// Cleanup old entries every 5 minutes to prevent memory leaks\nsetInterval(() => {\n  const now = Date.now();\n  for (const [ip, data] of ipRequestCounts.entries()) {\n    if (now - data.windowStart > 120000) { // Clean up entries older than 2 minutes\n      ipRequestCounts.delete(ip);\n    }\n  }\n}, 300000);\n\n/**\n * SECURITY: Check rate limit using Redis with in-memory fallback\n * @param {string} key - Redis key for rate limit counter\n * @param {number} max - Maximum requests allowed\n * @param {number} windowSeconds - Time window in seconds\n * @returns {Promise<{allowed: boolean, remaining: number, resetAt: number}>}\n */\nasync function checkRateLimit(key, max, windowSeconds) {\n  try {\n    // Try Redis first (preferred for multi-instance deployments)\n    if (redisClient && redisClient.isConnected) {\n      const current = await redisClient.incr(key);\n      \n      if (current === 1) {\n        // First request in window, set expiry\n        await redisClient.expire(key, windowSeconds);\n      }\n      \n      const ttl = await redisClient.ttl(key);\n      const resetAt = Date.now() + (ttl * 1000);\n      \n      return {\n        allowed: current <= max,\n        remaining: Math.max(0, max - current),\n        resetAt,\n        retryAfter: ttl\n      };\n    }\n  } catch (redisError) {\n    console.warn('[RateLimiter] Redis error, falling back to in-memory:', redisError.message);\n  }\n  \n  // Fallback to in-memory (single-instance only)\n  const now = Date.now();\n  const windowMs = windowSeconds * 1000;\n  const data = ipRequestCounts.get(key);\n  \n  if (!data || now - data.windowStart > windowMs) {\n    // Start new window\n    ipRequestCounts.set(key, { count: 1, windowStart: now });\n    return {\n      allowed: true,\n      remaining: max - 1,\n      resetAt: now + windowMs,\n      retryAfter: windowSeconds\n    };\n  }\n  \n  data.count++;\n  const allowed = data.count <= max;\n  const remaining = Math.max(0, max - data.count);\n  const resetAt = data.windowStart + windowMs;\n  const retryAfter = Math.ceil((resetAt - now) / 1000);\n  \n  return {\n    allowed,\n    remaining,\n    resetAt,\n    retryAfter\n  };\n}\n\n/**\n * SECURITY: IP-based rate limiting middleware with tiered limits\n * Authenticated users get higher limits than anonymous users\n * Returns 429 with Retry-After header when limit exceeded\n */\nfunction ipRateLimit(req, res, next) {\n  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n  \n  // Determine if user is authenticated (check for valid JWT token)\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n  const isAuthenticated = !!token; // Simple check, validation happens in requireCredits\n  \n  // Select appropriate rate limit\n  const limit = isAuthenticated\n    ? RATE_LIMITS.global.authenticated\n    : RATE_LIMITS.global.anonymous;\n  \n  const rateLimitKey = `ratelimit:global:${clientIp}`;\n  \n  checkRateLimit(rateLimitKey, limit.max, limit.window)\n    .then(result => {\n      // Add rate limit headers (industry standard)\n      res.set('X-RateLimit-Limit', limit.max.toString());\n      res.set('X-RateLimit-Remaining', result.remaining.toString());\n      res.set('X-RateLimit-Reset', Math.floor(result.resetAt / 1000).toString());\n      \n      if (!result.allowed) {\n        // SECURITY: Return 429 with Retry-After header\n        res.set('Retry-After', result.retryAfter.toString());\n        console.warn(`[SECURITY] Global rate limit exceeded for IP: ${clientIp} (${isAuthenticated ? 'authenticated' : 'anonymous'})`);\n        return res.status(429).json({\n          error: 'Too many requests',\n          message: 'Please slow down and try again later',\n          retryAfter: result.retryAfter,\n          limit: limit.max,\n          window: limit.window\n        });\n      }\n      \n      next();\n    })\n    .catch(err => {\n      console.error('[RateLimiter] Error checking rate limit:', err);\n      // On error, allow request but log warning\n      console.warn('[RateLimiter] Rate limit check failed, allowing request');\n      next();\n    });\n}\n\n/**\n * SECURITY: Endpoint-specific rate limiting\n * Stricter limits for sensitive operations like authentication and file uploads\n * @param {string} endpointKey - Key from RATE_LIMITS.endpoints\n */\nfunction endpointRateLimit(endpointKey) {\n  return async (req, res, next) => {\n    const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n    const limit = RATE_LIMITS.endpoints[endpointKey];\n    \n    if (!limit) {\n      console.warn(`[RateLimiter] No rate limit configured for endpoint: ${endpointKey}`);\n      return next();\n    }\n    \n    const rateLimitKey = `ratelimit:endpoint:${endpointKey}:${clientIp}`;\n    \n    try {\n      const result = await checkRateLimit(rateLimitKey, limit.max, limit.window);\n      \n      // Add rate limit headers\n      res.set('X-RateLimit-Limit', limit.max.toString());\n      res.set('X-RateLimit-Remaining', result.remaining.toString());\n      res.set('X-RateLimit-Reset', Math.floor(result.resetAt / 1000).toString());\n      \n      if (!result.allowed) {\n        // SECURITY: Return 429 with Retry-After header\n        res.set('Retry-After', result.retryAfter.toString());\n        console.warn(`[SECURITY] Endpoint rate limit exceeded for ${endpointKey} from IP: ${clientIp}`);\n        return res.status(429).json({\n          error: 'Too many requests',\n          message: `Rate limit exceeded for this operation. Please try again in ${result.retryAfter} seconds.`,\n          retryAfter: result.retryAfter,\n          limit: limit.max,\n          window: limit.window\n        });\n      }\n      \n      next();\n    } catch (err) {\n      console.error(`[RateLimiter] Error checking endpoint rate limit for ${endpointKey}:`, err);\n      // On error, allow request but log warning\n      console.warn('[RateLimiter] Endpoint rate limit check failed, allowing request');\n      next();\n    }\n  };\n}\n\n// Rate limiting for legacy auth attempts (prevent brute force)\nconst legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\nconst LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\nconst LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n\n/**\n * Check if IP is rate limited for legacy auth\n */\nfunction isLegacyAuthRateLimited(ip) {\n  const now = Date.now();\n  const attempt = legacyAuthAttempts.get(ip);\n\n  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n    return false;\n  }\n\n  attempt.count++;\n  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n    return true;\n  }\n\n  return false;\n}\n\n// Default estimated duration for reservation (1 minute = 60 seconds)\nconst DEFAULT_RESERVATION_SECONDS = 60;\n\n/**\n * Middleware to check and atomically reserve credits before processing\n *\n * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n * Falls back to legacy x-stripe-customer-id header (deprecated)\n *\n * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n *\n * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n * where multiple concurrent requests could all pass credit check.\n */\nfunction requireCredits(options = {}) {\n  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n\n  return async (req, res, next) => {\n    // SECURITY: Primary auth via JWT token\n    const authHeader = req.headers['authorization'];\n    const token = extractBearerToken(authHeader);\n\n    let stripeCustomerId = null;\n\n    if (token) {\n      const decoded = await verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n        req.tokenData = decoded;\n      } else {\n        // Token present but invalid\n        return res.status(401).json({\n          error: 'Invalid or expired token',\n          message: 'Please log in again to continue'\n        });\n      }\n    } else {\n      // DEPRECATED: Fallback to legacy header\n      const legacyId = req.headers['x-stripe-customer-id'];\n      if (legacyId) {\n        // SECURITY: Block legacy auth in production unless explicitly enabled\n        if (isProduction && !ALLOW_LEGACY_AUTH) {\n          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n          return res.status(401).json({\n            error: 'Authentication method not supported',\n            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n          });\n        }\n\n        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n        if (isLegacyAuthRateLimited(clientIp)) {\n          return res.status(429).json({\n            error: 'Too many authentication attempts',\n            message: 'Please wait before trying again'\n          });\n        }\n\n        // Validate format to prevent injection\n        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n          return res.status(401).json({\n            error: 'Invalid customer ID format',\n            message: 'Customer ID must be a valid Stripe customer ID'\n          });\n        }\n\n        // SECURITY: Verify customer exists in database before accepting\n        const exists = await customerExists(legacyId);\n        if (!exists) {\n          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n          return res.status(401).json({\n            error: 'Invalid customer ID',\n            message: 'Customer not found'\n          });\n        }\n\n        stripeCustomerId = legacyId;\n        req.isLegacyAuth = true;\n        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n      }\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Missing Stripe customer ID'\n      });\n    }\n\n    // Store for later use\n    req.stripeCustomerId = stripeCustomerId;\n\n    // Determine estimated duration - use request value, option value, or default\n    const estSeconds = req.estimatedDuration || estimatedSeconds;\n\n    try {\n      // Atomically reserve credits using SELECT...FOR UPDATE\n      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n\n      if (!reservation.success) {\n        // Reservation failed - not enough credits\n        const balance = await getBalance(stripeCustomerId);\n        return res.status(402).json({\n          error: 'Insufficient credits',\n          message: 'Please upgrade your plan or wait for your next billing cycle',\n          balance: {\n            hoursRemaining: balance.hoursRemaining,\n            tier: balance.tier\n          }\n        });\n      }\n\n      // Store reservation info for confirmation/release\n      req.reservation = {\n        id: reservation.reservationId,\n        seconds: estSeconds,\n        hoursReserved: reservation.hoursReserved\n      };\n\n      // Attach helper function to confirm usage with actual duration\n      // This adjusts the reservation if actual duration differs\n      req.deductUsage = async (actualDurationSeconds) => {\n        return await confirmReservation(\n          stripeCustomerId,\n          actualDurationSeconds,\n          estSeconds,\n          endpoint\n        );\n      };\n\n      // Attach helper function to release reservation on failure\n      req.releaseReservation = async (reason = 'processing_failed') => {\n        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n      };\n\n      // Hook into response to auto-release on error responses\n      const originalSend = res.send.bind(res);\n      res.send = function(body) {\n        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n        }\n        return originalSend(body);\n      };\n\n      next();\n    } catch (err) {\n      console.error('[RateLimiter] Error reserving credits:', err);\n      return res.status(500).json({\n        error: 'Credit check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Middleware to enforce tier-based feature access\n *\n * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n *\n * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n */\nfunction requireFeature(featureName) {\n  return async (req, res, next) => {\n    // Must have stripeCustomerId from requireCredits middleware\n    if (!req.stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please log in to access this feature'\n      });\n    }\n\n    try {\n      // Get user's current balance (includes tier info)\n      const balance = await getBalance(req.stripeCustomerId);\n\n      // Check if user's tier has access to this feature\n      if (!hasFeatureAccess(balance.tier, featureName)) {\n        // Release any reserved credits since we're blocking the request\n        if (req.releaseReservation) {\n          await req.releaseReservation('feature_not_available');\n        }\n\n        // Determine required tier for helpful error message\n        const requiredTier = getRequiredTierForFeature(featureName);\n\n        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n\n        return res.status(403).json({\n          error: 'Feature not available',\n          message: `This feature requires a ${requiredTier} plan or higher`,\n          requiredFeature: featureName,\n          requiredTier: requiredTier,\n          currentTier: balance.tier\n        });\n      }\n\n      // Feature access granted\n      next();\n    } catch (err) {\n      console.error('[requireFeature] Error checking feature access:', err);\n      return res.status(500).json({\n        error: 'Feature access check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Helper to determine required tier for a feature\n * Used for helpful error messages\n */\nfunction getRequiredTierForFeature(featureName) {\n  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n\n  if (teamOnlyFeatures.includes(featureName)) {\n    return 'Team';\n  } else if (proFeatures.includes(featureName)) {\n    return 'Pro';\n  }\n  return 'Starter';\n}\n\n/**\n * Middleware to track usage after successful response\n *\n * Call this after processing to deduct actual usage\n */\nfunction trackUsage(endpoint = 'unknown') {\n  return async (req, res, next) => {\n    // Store original json method\n    const originalJson = res.json.bind(res);\n\n    // Override json to track usage on success\n    res.json = async (data) => {\n      // Only deduct on successful responses\n      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n        try {\n          const balance = await deductUsage(\n            req.stripeCustomerId,\n            req.audioDuration,\n            endpoint\n          );\n          // Attach updated balance to response\n          data.balance = balance;\n        } catch (err) {\n          console.error('[RateLimiter] Error deducting usage:', err);\n        }\n      }\n      return originalJson(data);\n    };\n\n    next();\n  };\n}\n\nmodule.exports = {\n  requireCredits,\n  requireFeature,\n  trackUsage,\n  ipRateLimit\n};\n","numLines":523,"startLine":1,"totalLines":523}}}
{"parentUuid":"c8288ac3-919e-4329-96b8-65027dd30104","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Tux7o8cKQ95tMFL8xCUMpV","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Backend Server\n     3→ *\n     4→ * Main entry point for the SPLICE backend API.\n     5→ * Orchestrates the audio analysis pipeline.\n     6→ *\n     7→ * Slices:\n     8→ * - Slice 4: Transcription (services/transcription.js)\n     9→ * - Slice 5: Take Detection (services/takeDetection.js)\n    10→ *\n    11→ * Architecture: Modular routes (see routes/ directory)\n    12→ */\n    13→\n    14→\n    15→require('dotenv').config();\n    16→\n    17→const express = require('express');\n    18→const cors = require('cors');\n    19→const helmet = require('helmet');\n    20→const cookieParser = require('cookie-parser');\n    21→const fs = require('fs');\n    22→const https = require('https');\n    23→const http = require('http');\n    24→const path = require('path');\n    25→const crypto = require('crypto');\n    26→\n    27→// MEDIUM-005: Request ID Tracing Middleware\n    28→const { requestIdMiddleware } = require('./middleware/requestId');\n    29→\n    30→// HIGH-008: Sentry Error Monitoring Integration\n    31→let Sentry = null;\n    32→if (process.env.SENTRY_DSN) {\n    33→  try {\n    34→    Sentry = require('@sentry/node');\n    35→    console.log('[SPLICE] Sentry module loaded, will initialize after app creation');\n    36→  } catch (_err) {\n    37→    console.warn('[SPLICE] @sentry/node not installed. Run: npm install @sentry/node');\n    38→  }\n    39→}\n    40→\n    41→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\n    42→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    43→\n    44→// Import services\n    45→const usageTracking = require('./services/usageTracking');\n    46→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\n    47→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\n    48→const referralService = require('./services/referralService');\n    49→const licenseService = require('./services/licenseService');\n    50→const emailService = require('./services/emailService');\n    51→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\n    52→const { getSupportedFormats } = require('./services/captionExporter');\n    53→\n    54→// Import route modules\n    55→const healthRoutes = require('./routes/health');\n    56→const analyzeRoutes = require('./routes/analyze');\n    57→const silencesRoutes = require('./routes/silences');\n    58→const detectionRoutes = require('./routes/detection');\n    59→const exportRoutes = require('./routes/export');\n    60→const multitrackRoutes = require('./routes/multitrack');\n    61→const cutListRoutes = require('./routes/cutList');\n    62→const zoomRoutes = require('./routes/zoom');\n    63→const chaptersRoutes = require('./routes/chapters');\n    64→const youtubeRoutes = require('./routes/youtube');\n    65→const captionsRoutes = require('./routes/captions');\n    66→const textEditRoutes = require('./routes/textEdit');\n    67→const reframeRoutes = require('./routes/reframe');\n    68→const batchRoutes = require('./routes/batch');\n    69→const authRoutes = require('./routes/auth');\n    70→const billingRoutes = require('./routes/billing');\n    71→const referralRoutes = require('./routes/referral');\n    72→const licenseRoutes = require('./routes/license');\n    73→const musicRoutes = require('./routes/music');\n    74→\n    75→// Music generation worker (BullMQ background processor)\n    76→const { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\n    77→\n    78→// HIGH-011: API Versioning - v1 routes\n    79→const v1Routes = require('./routes/v1');\n    80→\n    81→// Stripe for webhooks\n    82→const Stripe = require('stripe');\n    83→\n    84→// MEDIUM-008: Pin Stripe API version for stability\n    85→// This prevents breaking changes when Stripe releases new API versions\n    86→// Should match version in services/stripeUsageReporting.js\n    87→const STRIPE_API_VERSION = '2024-12-18.acacia';\n    88→\n    89→// =============================================================================\n    90→// SECURITY: Environment Variable Validation\n    91→// Validate all required environment variables at startup\n    92→// Fail fast with clear error messages if critical secrets are missing\n    93→// =============================================================================\n    94→\n    95→/**\n    96→ * Validate required environment variables\n    97→ * @returns {Object} { valid: boolean, errors: string[] }\n    98→ */\n    99→function validateEnvironmentVariables() {\n   100→  const errors = [];\n   101→  \n   102→  // CRITICAL: Core infrastructure secrets\n   103→  if (!process.env.STRIPE_SECRET_KEY) {\n   104→    errors.push('STRIPE_SECRET_KEY is required (Stripe API key for billing)');\n   105→  }\n   106→  \n   107→  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production') {\n   108→    errors.push('JWT_SECRET must be set to a secure random value (not default)');\n   109→  } else if (process.env.JWT_SECRET.length < 32) {\n   110→    // HIGH-001: Enforce minimum 32 character length for cryptographic security\n   111→    errors.push('JWT_SECRET must be at least 32 characters for cryptographic security');\n   112→  }\n   113→  \n   114→  if (!process.env.DATABASE_URL) {\n   115→    errors.push('DATABASE_URL is required (PostgreSQL connection string)');\n   116→  }\n   117→  \n   118→  if (!process.env.OPENAI_API_KEY) {\n   119→    errors.push('OPENAI_API_KEY is required (OpenAI API for transcription)');\n   120→  }\n   121→  \n   122→  // CRITICAL: Redis required for job queue and rate limiting in production\n   123→  // Support both Railway Redis (REDIS_URL) and Upstash (UPSTASH_REDIS_URL)\n   124→  // In development, will fall back to in-memory storage\n   125→  if (process.env.NODE_ENV === 'production' && !process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n   126→    errors.push('REDIS_URL or UPSTASH_REDIS_URL is required (Redis for job queue and rate limiting)');\n   127→  } else if (!process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n   128→    console.warn('[SPLICE] WARNING: Redis not configured. Using in-memory fallback (not suitable for production).');\n   129→  }\n   130→  \n   131→  // CRITICAL: Webhook secret required in production\n   132→  if (!process.env.STRIPE_WEBHOOK_SECRET) {\n   133→    errors.push('STRIPE_WEBHOOK_SECRET is required (Stripe webhook signature verification)');\n   134→  }\n   135→  \n   136→  // CONDITIONAL: Email provider validation\n   137→  const emailProvider = process.env.EMAIL_PROVIDER || 'sendgrid';\n   138→  if (emailProvider === 'sendgrid' && !process.env.SENDGRID_API_KEY) {\n   139→    errors.push('SENDGRID_API_KEY is required when EMAIL_PROVIDER=sendgrid');\n   140→  }\n   141→  \n   142→  // RECOMMENDED: R2 Storage (warn if missing, don't block)\n   143→  if (!process.env.R2_ACCOUNT_ID || !process.env.R2_ACCESS_KEY_ID || !process.env.R2_SECRET_ACCESS_KEY) {\n   144→    console.warn('[SPLICE] WARNING: R2 storage credentials not configured. Music generation uploads will fail.');\n   145→  }\n   146→  \n   147→  return {\n   148→    valid: errors.length === 0,\n   149→    errors\n   150→  };\n   151→}\n   152→\n   153→// Run validation in production\n   154→if (isProduction) {\n   155→  const validation = validateEnvironmentVariables();\n   156→  \n   157→  if (!validation.valid) {\n   158→    console.error('[SPLICE] ========================================');\n   159→    console.error('[SPLICE] CRITICAL: Missing required environment variables');\n   160→    console.error('[SPLICE] ========================================');\n   161→    validation.errors.forEach(error => {\n   162→      console.error(`[SPLICE]   ❌ ${error}`);\n   163→    });\n   164→    console.error('[SPLICE] ========================================');\n   165→    console.error('[SPLICE] Server startup aborted. Please configure all required environment variables.');\n   166→    console.error('[SPLICE] See .env.example for complete documentation.');\n   167→    process.exit(1);\n   168→  }\n   169→  \n   170→  console.log('[SPLICE] ✅ Environment validation passed');\n   171→}\n   172→\n   173→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n   174→  apiVersion: STRIPE_API_VERSION\n   175→});\n   176→\n   177→// =============================================================================\n   178→// PERF-FIX: Static Response Cache\n   179→// Cache static endpoint responses at startup to avoid repeated computation\n   180→// =============================================================================\n   181→\n   182→// Generate ETag from content\n   183→function generateETag(content) {\n   184→  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n   185→}\n   186→\n   187→// Static response cache - populated at startup\n   188→const STATIC_RESPONSE_CACHE = {\n   189→  profanityLanguages: null,\n   190→  profanityBleeps: null,\n   191→  exportFormats: null\n   192→};\n   193→\n   194→// Initialize cache at startup (called after server starts)\n   195→function initializeStaticCache() {\n   196→  // Cache profanity languages\n   197→  const languages = getSupportedLanguages();\n   198→  STATIC_RESPONSE_CACHE.profanityLanguages = {\n   199→    body: { success: true, languages },\n   200→    etag: generateETag({ languages })\n   201→  };\n   202→\n   203→  // Cache profanity bleeps\n   204→  const sounds = getAvailableBleepSounds();\n   205→  STATIC_RESPONSE_CACHE.profanityBleeps = {\n   206→    body: { success: true, sounds },\n   207→    etag: generateETag({ sounds })\n   208→  };\n   209→\n   210→  // Cache export formats\n   211→  const formats = getSupportedFormats();\n   212→  STATIC_RESPONSE_CACHE.exportFormats = {\n   213→    body: { success: true, formats },\n   214→    etag: generateETag({ formats })\n   215→  };\n   216→\n   217→  console.log('[SPLICE] Static response cache initialized');\n   218→}\n   219→\n   220→// Helper to send cached response with ETag\n   221→function sendCachedResponse(req, res, cacheKey) {\n   222→  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n   223→  if (!cached) {\n   224→    return res.status(500).json({ error: 'Cache not initialized' });\n   225→  }\n   226→\n   227→  // Check If-None-Match header for conditional GET\n   228→  const clientETag = req.headers['if-none-match'];\n   229→  if (clientETag === cached.etag) {\n   230→    return res.status(304).end(); // Not Modified\n   231→  }\n   232→\n   233→  // Send cached response with ETag and cache headers\n   234→  res.set('ETag', cached.etag);\n   235→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n   236→  res.json(cached.body);\n   237→}\n   238→\n   239→// =============================================================================\n   240→// Server Configuration\n   241→// =============================================================================\n   242→\n   243→const app = express();\n   244→const PORT = process.env.PORT || 3847;\n   245→\n   246→// HIGH-008: Initialize Sentry after app creation\n   247→if (Sentry && process.env.SENTRY_DSN) {\n   248→  Sentry.init({\n   249→    dsn: process.env.SENTRY_DSN,\n   250→    environment: process.env.NODE_ENV || 'development',\n   251→    release: process.env.npm_package_version || '6.0.3',\n   252→    tracesSampleRate: isProduction ? 0.1 : 1.0, // 10% in prod, 100% in dev\n   253→    profilesSampleRate: isProduction ? 0.1 : 0, // Profile only in production\n   254→    integrations: [\n   255→      // Automatically instrument HTTP requests\n   256→      Sentry.httpIntegration({ tracing: true }),\n   257→      // Automatically instrument Express\n   258→      Sentry.expressIntegration({ app }),\n   259→    ],\n   260→    // Filter out sensitive data\n   261→    beforeSend(event) {\n   262→      // Remove sensitive headers\n   263→      if (event.request && event.request.headers) {\n   264→        delete event.request.headers.authorization;\n   265→        delete event.request.headers['x-stripe-customer-id'];\n   266→        delete event.request.headers['stripe-signature'];\n   267→      }\n   268→      return event;\n   269→    },\n   270→  });\n   271→  \n   272→  // Add Sentry request handler as first middleware\n   273→  app.use(Sentry.Handlers.requestHandler());\n   274→  app.use(Sentry.Handlers.tracingHandler());\n   275→  \n   276→  console.log('[SPLICE] ✅ Sentry error monitoring initialized');\n   277→}\n   278→\n   279→// MEDIUM-005: Request ID Tracing Middleware\n   280→// Add early in chain to ensure all requests have correlation IDs for logging\n   281→app.use(requestIdMiddleware);\n   282→\n   283→// HTTPS certificates (generated by mkcert) - only for local development\n   284→let httpsOptions = null;\n   285→if (!isProduction) {\n   286→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n   287→  const certPath = path.join(__dirname, 'localhost+1.pem');\n   288→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n   289→    httpsOptions = {\n   290→      key: fs.readFileSync(keyPath),\n   291→      cert: fs.readFileSync(certPath)\n   292→    };\n   293→  }\n   294→}\n   295→\n   296→// =============================================================================\n   297→// Security Configuration\n   298→// =============================================================================\n   299→\n   300→// CORS whitelist - restrict origins in production\n   301→const CORS_WHITELIST = [\n   302→  'http://localhost:3000',\n   303→  'http://localhost:3847',\n   304→  'https://localhost:3847',\n   305→  'http://127.0.0.1:3000',\n   306→  'http://127.0.0.1:3847',\n   307→  'https://127.0.0.1:3847',\n   308→  'https://splice.app',\n   309→  'https://www.splice.app',\n   310→  'https://spliceclips.com',\n   311→  'https://www.spliceclips.com',\n   312→  'https://splice-api-production.up.railway.app',\n   313→  'https://splice-website.vercel.app',\n   314→  // Adobe CEP/UXP panels run from file:// or bolt://\n   315→  'file://',\n   316→  'bolt://'\n   317→];\n   318→\n   319→const corsOptions = {\n   320→  origin: function (origin, callback) {\n   321→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n   322→    if (!origin) {\n   323→      return callback(null, true);\n   324→    }\n   325→    // Check if origin is in whitelist\n   326→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n   327→      return callback(null, true);\n   328→    }\n   329→    // In development, allow all origins with warning\n   330→    if (!isProduction) {\n   331→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n   332→      return callback(null, true);\n   333→    }\n   334→    // In production, reject non-whitelisted origins\n   335→    console.error(`[CORS] Blocked request from: ${origin}`);\n   336→    return callback(new Error('Not allowed by CORS'));\n   337→  },\n   338→  credentials: true,\n   339→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n   340→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n   341→};\n   342→\n   343→app.use(cors(corsOptions));\n   344→\n   345→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n   346→// This ensures rate limiting and logging use the correct client IP\n   347→if (isProduction) {\n   348→  app.set('trust proxy', 1);\n   349→}\n   350→\n   351→// IP-based rate limiting (100 requests/minute per IP)\n   352→app.use(ipRateLimit);\n   353→\n   354→// Security headers via helmet\n   355→app.use(helmet({\n   356→  contentSecurityPolicy: {\n   357→    directives: {\n   358→      defaultSrc: [\"'self'\"],\n   359→      scriptSrc: [\"'self'\"],\n   360→      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n   361→      imgSrc: [\"'self'\", 'data:', 'https:'],\n   362→      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n   363→      fontSrc: [\"'self'\"],\n   364→      objectSrc: [\"'none'\"],\n   365→      mediaSrc: [\"'self'\"],\n   366→      frameSrc: [\"'none'\"]\n   367→    }\n   368→  },\n   369→  hsts: {\n   370→    maxAge: 31536000,\n   371→    includeSubDomains: true,\n   372→    preload: true\n   373→  },\n   374→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n   375→  noSniff: true,\n   376→  xssFilter: true,\n   377→  hidePoweredBy: true\n   378→}));\n   379→\n   380→// Helper to determine tier from price ID with logging\n   381→// Supports both monthly and annual pricing\n   382→function getTierFromPriceId(priceId) {\n   383→  // Monthly prices\n   384→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   385→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   386→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   387→\n   388→  // Annual prices (same tier, just different billing period)\n   389→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n   390→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n   391→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n   392→\n   393→  // Log unknown price ID for debugging\n   394→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   395→  return 'starter';\n   396→}\n   397→\n   398→// =============================================================================\n   399→// Stripe Webhook (must be before express.json())\n   400→// =============================================================================\n   401→\n   402→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   403→  const sig = req.headers['stripe-signature'];\n   404→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   405→\n   406→  let event;\n   407→\n   408→  try {\n   409→    if (webhookSecret) {\n   410→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   411→    } else if (isProduction) {\n   412→      // SECURITY: Reject unsigned webhooks in production\n   413→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   414→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   415→    } else {\n   416→      // For local development testing only\n   417→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   418→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   419→      event = JSON.parse(bodyString);\n   420→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   421→    }\n   422→  } catch (err) {\n   423→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   424→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   425→  }\n   426→\n   427→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   428→\n   429→  // Idempotency check - skip if already processed\n   430→  if (await usageTracking.isEventProcessed(event.id)) {\n   431→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   432→    return res.json({ received: true, skipped: true });\n   433→  }\n   434→\n   435→  try {\n   436→    switch (event.type) {\n   437→      case 'customer.subscription.created':\n   438→      case 'customer.subscription.updated': {\n   439→        const subscription = event.data.object;\n   440→        const customerId = subscription.customer;\n   441→\n   442→        // Validate customerId\n   443→        if (!customerId) {\n   444→          console.error('[SPLICE] Missing customer ID in subscription event');\n   445→          return res.status(400).json({ error: 'Missing customer ID' });\n   446→        }\n   447→\n   448→        // Get tier from price ID\n   449→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   450→        const tier = getTierFromPriceId(priceId);\n   451→\n   452→        // Update user tier and reset hours\n   453→        await usageTracking.updateTier(customerId, tier);\n   454→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   455→\n   456→        // Initialize music credits for new subscriptions\n   457→        if (event.type === 'customer.subscription.created') {\n   458→          await usageTracking.resetMusicCredits(customerId, tier);\n   459→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n   460→        }\n   461→\n   462→        // Update trial end date if present\n   463→        if (subscription.trial_end) {\n   464→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n   465→        }\n   466→\n   467→        // Generate license key for new subscriptions with retry and delivery\n   468→        if (event.type === 'customer.subscription.created') {\n   469→          let licenseResult = null;\n   470→          let retryCount = 0;\n   471→          const maxRetries = 3;\n   472→\n   473→          // Retry mechanism for license key generation\n   474→          while (retryCount < maxRetries) {\n   475→            licenseResult = await licenseService.generateLicenseKey(customerId);\n   476→            if (licenseResult.success) {\n   477→              break;\n   478→            }\n   479→            retryCount++;\n   480→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n   481→            // Wait before retry (exponential backoff)\n   482→            if (retryCount < maxRetries) {\n   483→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n   484→            }\n   485→          }\n   486→\n   487→          if (licenseResult && licenseResult.success) {\n   488→            // SECURITY: Mask license key in logs\n   489→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n   490→\n   491→            // Store license key in Stripe subscription metadata as backup\n   492→            try {\n   493→              await stripe.subscriptions.update(subscription.id, {\n   494→                metadata: {\n   495→                  license_key: licenseResult.key,\n   496→                  license_generated_at: new Date().toISOString()\n   497→                }\n   498→              });\n   499→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n   500→            } catch (stripeErr) {\n   501→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n   502→            }\n   503→\n   504→            // Get customer email and send license key\n   505→            try {\n   506→              const customer = await stripe.customers.retrieve(customerId);\n   507→              if (customer.email) {\n   508→                // SECURITY: Mask sensitive data in logs\n   509→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n   510→\n   511→                // Send license key email\n   512→                try {\n   513→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n   514→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n   515→                } catch (sendErr) {\n   516→                  // Log but don't fail - license is stored in Stripe metadata as backup\n   517→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n   518→                }\n   519→\n   520→                // Store email in database for reference\n   521→                await usageTracking.updateTier(customerId, tier, customer.email);\n   522→              } else {\n   523→                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n   524→              }\n   525→            } catch (emailErr) {\n   526→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n   527→            }\n   528→          } else {\n   529→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n   530→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n   531→            console.error(`[SPLICE] ${errorMsg}`);\n   532→            return res.status(500).json({ error: errorMsg });\n   533→          }\n   534→        }\n   535→        break;\n   536→      }\n   537→\n   538→      case 'customer.subscription.deleted': {\n   539→        const subscription = event.data.object;\n   540→        const customerId = subscription.customer;\n   541→\n   542→        // Validate customerId\n   543→        if (!customerId) {\n   544→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   545→          return res.status(400).json({ error: 'Missing customer ID' });\n   546→        }\n   547→\n   548→        // Downgrade to cancelled (0 hours)\n   549→        await usageTracking.updateTier(customerId, 'cancelled');\n   550→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   551→        break;\n   552→      }\n   553→\n   554→      case 'invoice.payment_succeeded': {\n   555→        const invoice = event.data.object;\n   556→        const customerId = invoice.customer;\n   557→        const subscriptionId = invoice.subscription;\n   558→\n   559→        // Validate customerId\n   560→        if (!customerId) {\n   561→          console.error('[SPLICE] Missing customer ID in invoice event');\n   562→          return res.status(400).json({ error: 'Missing customer ID' });\n   563→        }\n   564→\n   565→        // Reset hours on successful payment (new billing period)\n   566→        let tier = 'starter';\n   567→        if (subscriptionId) {\n   568→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   569→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   570→          tier = getTierFromPriceId(priceId);\n   571→\n   572→          await usageTracking.resetHours(customerId, tier);\n   573→          await usageTracking.resetMusicCredits(customerId, tier);\n   574→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n   575→        }\n   576→\n   577→        // Check for affiliate coupon and record commission\n   578→        const discount = invoice.discount;\n   579→        if (discount && discount.coupon) {\n   580→          const couponId = discount.coupon.id;\n   581→          // Check if this is an affiliate code (like JIMMYN)\n   582→          if (referralService.AFFILIATE_CODES[couponId]) {\n   583→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n   584→            await referralService.recordAffiliateCommission(\n   585→              couponId,\n   586→              customerId,\n   587→              amountPaid,\n   588→              tier\n   589→            );\n   590→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n   591→          }\n   592→        }\n   593→        break;\n   594→      }\n   595→\n   596→      case 'invoice.payment_failed': {\n   597→        const invoice = event.data.object;\n   598→        const customerId = invoice.customer;\n   599→        const attemptCount = invoice.attempt_count || 1;\n   600→\n   601→        // Validate customerId\n   602→        if (!customerId) {\n   603→          console.error('[SPLICE] Missing customer ID in payment_failed event');\n   604→          return res.status(400).json({ error: 'Missing customer ID' });\n   605→        }\n   606→\n   607→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n   608→\n   609→        // Stripe will retry automatically per retry settings\n   610→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n   611→        // Send warning email on final attempt\n   612→        if (attemptCount >= 3) {\n   613→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n   614→          // Send warning email to customer about impending cancellation\n   615→          try {\n   616→            const customer = await stripe.customers.retrieve(customerId);\n   617→            if (customer.email) {\n   618→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n   619→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n   620→            }\n   621→          } catch (emailErr) {\n   622→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n   623→          }\n   624→        }\n   625→        break;\n   626→      }\n   627→\n   628→      case 'customer.deleted': {\n   629→        const customer = event.data.object;\n   630→        const customerId = customer.id;\n   631→\n   632→        // Validate customerId\n   633→        if (!customerId) {\n   634→          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n   635→          return res.status(400).json({ error: 'Missing customer ID' });\n   636→        }\n   637→\n   638→        // Clean up user data - downgrade to cancelled\n   639→        await usageTracking.updateTier(customerId, 'cancelled');\n   640→        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n   641→        break;\n   642→      }\n   643→\n   644→      default:\n   645→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   646→    }\n   647→\n   648→    // Record event as processed (idempotency)\n   649→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   650→\n   651→    res.json({ received: true });\n   652→  } catch (err) {\n   653→    console.error('[SPLICE] Webhook handler error:', err);\n   654→    res.status(500).json({ error: err.message });\n   655→  }\n   656→});\n   657→\n   658→// Parse JSON body for all other routes\n   659→// SECURITY: Limit JSON body size to prevent DoS attacks\n   660→app.use(express.json({ limit: '10mb' }));\n   661→\n   662→// Parse cookies for CSRF token validation\n   663→app.use(cookieParser());\n   664→\n   665→// =============================================================================\n   666→// Route Configuration Options\n   667→// =============================================================================\n   668→\n   669→const routeOptions = {\n   670→  middleware: {\n   671→    requireCredits,\n   672→    requireFeature,\n   673→    authenticateToken\n   674→  },\n   675→  services: {\n   676→    usageTracking,\n   677→    referralService,\n   678→    licenseService,\n   679→    emailService,\n   680→    stripe\n   681→  },\n   682→  authHelpers: {\n   683→    generateToken,\n   684→    generateRefreshToken,\n   685→    verifyToken,\n   686→    maskSensitiveData,\n   687→    blacklistToken\n   688→  },\n   689→  staticCache: STATIC_RESPONSE_CACHE,\n   690→  sendCachedResponse\n   691→};\n   692→\n   693→// =============================================================================\n   694→// Mount Routes\n   695→// =============================================================================\n   696→\n   697→// Health check and system endpoints (no prefix)\n   698→app.use('/', healthRoutes(routeOptions));\n   699→\n   700→// Core analysis endpoints\n   701→app.use('/', analyzeRoutes(routeOptions));\n   702→app.use('/', silencesRoutes(routeOptions));\n   703→app.use('/', detectionRoutes(routeOptions));\n   704→\n   705→// Export endpoints\n   706→app.use('/export', exportRoutes(routeOptions));\n   707→\n   708→// Multitrack/Multicam endpoints\n   709→app.use('/multitrack', multitrackRoutes(routeOptions));\n   710→\n   711→// Cut list generation\n   712→app.use('/cut-list', cutListRoutes(routeOptions));\n   713→\n   714→// Legacy XML processing endpoint (backwards compatibility)\n   715→const { processXMLFile } = require('./services/xmlProcessor');\n   716→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n   717→  const {\n   718→    xmlPath,\n   719→    silences,\n   720→    removeGaps = true,\n   721→    outputPath = null\n   722→  } = req.body;\n   723→\n   724→  if (!xmlPath) {\n   725→    return res.status(400).json({ error: 'xmlPath is required' });\n   726→  }\n   727→\n   728→  if (!silences || !Array.isArray(silences)) {\n   729→    return res.status(400).json({ error: 'silences array is required' });\n   730→  }\n   731→\n   732→  if (!fs.existsSync(xmlPath)) {\n   733→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n   734→  }\n   735→\n   736→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n   737→\n   738→  try {\n   739→    const result = await processXMLFile(xmlPath, silences, {\n   740→      outputPath,\n   741→      removeGaps\n   742→    });\n   743→\n   744→    res.json({\n   745→      success: true,\n   746→      inputPath: xmlPath,\n   747→      outputPath: result.outputPath,\n   748→      stats: result.stats\n   749→    });\n   750→  } catch (err) {\n   751→    console.error('[SPLICE] XML processing error:', err);\n   752→    res.status(500).json({ error: err.message });\n   753→  }\n   754→});\n   755→\n   756→// Auto zoom endpoints\n   757→app.use('/zoom', zoomRoutes(routeOptions));\n   758→\n   759→// Chapter detection endpoints\n   760→app.use('/chapters', chaptersRoutes(routeOptions));\n   761→\n   762→// YouTube content generation\n   763→app.use('/youtube', youtubeRoutes(routeOptions));\n   764→\n   765→// Animated captions endpoints\n   766→app.use('/captions', captionsRoutes(routeOptions));\n   767→\n   768→// Text-based editing endpoints\n   769→app.use('/text-edit', textEditRoutes(routeOptions));\n   770→\n   771→// Social reframe endpoints\n   772→app.use('/reframe', reframeRoutes(routeOptions));\n   773→app.use('/faces', reframeRoutes.facesRouter(routeOptions));\n   774→\n   775→// Batch processing endpoints\n   776→app.use('/batch', batchRoutes(routeOptions));\n   777→\n   778→// Authentication endpoints\n   779→app.use('/auth', authRoutes(routeOptions));\n   780→\n   781→// Billing and credits endpoints\n   782→app.use('/', billingRoutes(routeOptions));\n   783→\n   784→// Referral system endpoints\n   785→app.use('/referral', referralRoutes(routeOptions));\n   786→\n   787→// License key endpoints\n   788→app.use('/license', licenseRoutes(routeOptions));\n   789→\n   790→// AI Music generation endpoints\n   791→app.use('/music', musicRoutes(routeOptions));\n   792→\n   793→// =============================================================================\n   794→// HIGH-011: API Versioning\n   795→// Mount versioned routes under /api/v1 prefix\n   796→// Maintain backwards compatibility with deprecation warnings\n   797→// =============================================================================\n   798→\n   799→// Mount v1 API routes\n   800→app.use('/api/v1', v1Routes(routeOptions));\n   801→\n   802→// Deprecation warning middleware for unversioned API calls\n   803→// This helps clients migrate to versioned endpoints\n   804→app.use('/api', (req, res, next) => {\n   805→  // Skip if already using versioned endpoint\n   806→  if (req.path.startsWith('/v1')) {\n   807→    return next();\n   808→  }\n   809→  \n   810→  // Add deprecation warning header\n   811→  res.set('X-API-Deprecation-Warning', 'Unversioned API endpoints are deprecated. Please migrate to /api/v1/');\n   812→  res.set('X-API-Version', 'unversioned');\n   813→  res.set('Deprecation', 'true');\n   814→  res.set('Sunset', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toUTCString()); // 90 days from now\n   815→  \n   816→  next();\n   817→});\n   818→\n   819→// HIGH-008: Add Sentry error handler (must be after all routes)\n   820→if (Sentry) {\n   821→  app.use(Sentry.Handlers.errorHandler({\n   822→    shouldHandleError(error) {\n   823→      // Capture all 4xx and 5xx errors\n   824→      if (error.status >= 400) {\n   825→        return true;\n   826→      }\n   827→      return true;\n   828→    },\n   829→  }));\n   830→}\n   831→\n   832→// =============================================================================\n   833→// Start Server\n   834→// =============================================================================\n   835→\n   836→// Track active server for graceful shutdown\n   837→let server = null;\n   838→\n   839→// Initialize database and start server\n   840→async function startServer() {\n   841→  try {\n   842→    await usageTracking.initDatabase();\n   843→    await referralService.initReferralTables();\n   844→    await licenseService.initLicenseTables();\n   845→    console.log('[SPLICE] Database initialized');\n   846→\n   847→    // PERF-FIX: Initialize static response cache at startup\n   848→    initializeStaticCache();\n   849→\n   850→    // Start music generation worker (BullMQ background processor)\n   851→    // Only starts if Redis is configured and Replicate API key is available\n   852→    if (process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL) {\n   853→      if (process.env.REPLICATE_API_TOKEN) {\n   854→        try {\n   855→          createMusicWorker();\n   856→          console.log('[SPLICE] ✅ Music generation worker started');\n   857→        } catch (workerErr) {\n   858→          console.error('[SPLICE] ⚠️ Failed to start music worker:', workerErr.message);\n   859→          // Don't fail server startup - music generation will be unavailable\n   860→        }\n   861→      } else {\n   862→        console.warn('[SPLICE] ⚠️ REPLICATE_API_TOKEN not set - music generation disabled');\n   863→      }\n   864→    } else {\n   865→      console.warn('[SPLICE] ⚠️ Redis not configured - music generation queue disabled');\n   866→    }\n   867→\n   868→    if (isProduction || !httpsOptions) {\n   869→      // Production: Railway provides TLS termination, use HTTP\n   870→      server = http.createServer(app).listen(PORT, () => {\n   871→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n   872→      });\n   873→    } else {\n   874→      // Development: Use HTTPS with local certificates\n   875→      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n   876→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n   877→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n   878→      });\n   879→    }\n   880→  } catch (err) {\n   881→    console.error('[SPLICE] Failed to start server:', err);\n   882→    process.exit(1);\n   883→  }\n   884→}\n   885→\n   886→// =============================================================================\n   887→// Graceful Shutdown\n   888→// =============================================================================\n   889→\n   890→async function gracefulShutdown(signal) {\n   891→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n   892→\n   893→  // Stop accepting new connections\n   894→  if (server) {\n   895→    server.close(() => {\n   896→      console.log('[SPLICE] HTTP server closed');\n   897→    });\n   898→  }\n   899→\n   900→  // Shutdown music worker (allows in-progress jobs to complete)\n   901→  try {\n   902→    await shutdownWorker();\n   903→    console.log('[SPLICE] Music worker shut down');\n   904→  } catch (err) {\n   905→    console.error('[SPLICE] Error shutting down music worker:', err.message);\n   906→  }\n   907→\n   908→  // Close database pool\n   909→  try {\n   910→    await usageTracking.closePool();\n   911→    console.log('[SPLICE] Database pool closed');\n   912→  } catch (err) {\n   913→    console.error('[SPLICE] Error closing database pool:', err.message);\n   914→  }\n   915→\n   916→  // Give ongoing requests time to complete (max 10 seconds)\n   917→  setTimeout(() => {\n   918→    console.log('[SPLICE] Graceful shutdown complete');\n   919→    process.exit(0);\n   920→  }, 10000);\n   921→}\n   922→\n   923→// Handle termination signals\n   924→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n   925→process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n   926→\n   927→// Handle uncaught exceptions\n   928→process.on('uncaughtException', (err) => {\n   929→  console.error('[SPLICE] Uncaught exception:', err);\n   930→  gracefulShutdown('uncaughtException');\n   931→});\n   932→\n   933→process.on('unhandledRejection', (reason, promise) => {\n   934→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n   935→});\n   936→\n   937→startServer();\n   938→\n\n</system-reminder>\n"}]},"uuid":"ae124165-5c54-49ab-a2bc-956d5435b0d0","timestamp":"2026-01-11T23:39:03.007Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"/**\n * SPLICE Backend Server\n *\n * Main entry point for the SPLICE backend API.\n * Orchestrates the audio analysis pipeline.\n *\n * Slices:\n * - Slice 4: Transcription (services/transcription.js)\n * - Slice 5: Take Detection (services/takeDetection.js)\n *\n * Architecture: Modular routes (see routes/ directory)\n */\n\n\nrequire('dotenv').config();\n\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst cookieParser = require('cookie-parser');\nconst fs = require('fs');\nconst https = require('https');\nconst http = require('http');\nconst path = require('path');\nconst crypto = require('crypto');\n\n// MEDIUM-005: Request ID Tracing Middleware\nconst { requestIdMiddleware } = require('./middleware/requestId');\n\n// HIGH-008: Sentry Error Monitoring Integration\nlet Sentry = null;\nif (process.env.SENTRY_DSN) {\n  try {\n    Sentry = require('@sentry/node');\n    console.log('[SPLICE] Sentry module loaded, will initialize after app creation');\n  } catch (_err) {\n    console.warn('[SPLICE] @sentry/node not installed. Run: npm install @sentry/node');\n  }\n}\n\n// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// Import services\nconst usageTracking = require('./services/usageTracking');\nconst { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\nconst { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData, blacklistToken } = require('./middleware/auth');\nconst referralService = require('./services/referralService');\nconst licenseService = require('./services/licenseService');\nconst emailService = require('./services/emailService');\nconst { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\nconst { getSupportedFormats } = require('./services/captionExporter');\n\n// Import route modules\nconst healthRoutes = require('./routes/health');\nconst analyzeRoutes = require('./routes/analyze');\nconst silencesRoutes = require('./routes/silences');\nconst detectionRoutes = require('./routes/detection');\nconst exportRoutes = require('./routes/export');\nconst multitrackRoutes = require('./routes/multitrack');\nconst cutListRoutes = require('./routes/cutList');\nconst zoomRoutes = require('./routes/zoom');\nconst chaptersRoutes = require('./routes/chapters');\nconst youtubeRoutes = require('./routes/youtube');\nconst captionsRoutes = require('./routes/captions');\nconst textEditRoutes = require('./routes/textEdit');\nconst reframeRoutes = require('./routes/reframe');\nconst batchRoutes = require('./routes/batch');\nconst authRoutes = require('./routes/auth');\nconst billingRoutes = require('./routes/billing');\nconst referralRoutes = require('./routes/referral');\nconst licenseRoutes = require('./routes/license');\nconst musicRoutes = require('./routes/music');\n\n// Music generation worker (BullMQ background processor)\nconst { createMusicWorker, shutdownWorker } = require('./workers/musicWorker');\n\n// HIGH-011: API Versioning - v1 routes\nconst v1Routes = require('./routes/v1');\n\n// Stripe for webhooks\nconst Stripe = require('stripe');\n\n// MEDIUM-008: Pin Stripe API version for stability\n// This prevents breaking changes when Stripe releases new API versions\n// Should match version in services/stripeUsageReporting.js\nconst STRIPE_API_VERSION = '2024-12-18.acacia';\n\n// =============================================================================\n// SECURITY: Environment Variable Validation\n// Validate all required environment variables at startup\n// Fail fast with clear error messages if critical secrets are missing\n// =============================================================================\n\n/**\n * Validate required environment variables\n * @returns {Object} { valid: boolean, errors: string[] }\n */\nfunction validateEnvironmentVariables() {\n  const errors = [];\n  \n  // CRITICAL: Core infrastructure secrets\n  if (!process.env.STRIPE_SECRET_KEY) {\n    errors.push('STRIPE_SECRET_KEY is required (Stripe API key for billing)');\n  }\n  \n  if (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    errors.push('JWT_SECRET must be set to a secure random value (not default)');\n  } else if (process.env.JWT_SECRET.length < 32) {\n    // HIGH-001: Enforce minimum 32 character length for cryptographic security\n    errors.push('JWT_SECRET must be at least 32 characters for cryptographic security');\n  }\n  \n  if (!process.env.DATABASE_URL) {\n    errors.push('DATABASE_URL is required (PostgreSQL connection string)');\n  }\n  \n  if (!process.env.OPENAI_API_KEY) {\n    errors.push('OPENAI_API_KEY is required (OpenAI API for transcription)');\n  }\n  \n  // CRITICAL: Redis required for job queue and rate limiting in production\n  // Support both Railway Redis (REDIS_URL) and Upstash (UPSTASH_REDIS_URL)\n  // In development, will fall back to in-memory storage\n  if (process.env.NODE_ENV === 'production' && !process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n    errors.push('REDIS_URL or UPSTASH_REDIS_URL is required (Redis for job queue and rate limiting)');\n  } else if (!process.env.REDIS_URL && !process.env.UPSTASH_REDIS_URL) {\n    console.warn('[SPLICE] WARNING: Redis not configured. Using in-memory fallback (not suitable for production).');\n  }\n  \n  // CRITICAL: Webhook secret required in production\n  if (!process.env.STRIPE_WEBHOOK_SECRET) {\n    errors.push('STRIPE_WEBHOOK_SECRET is required (Stripe webhook signature verification)');\n  }\n  \n  // CONDITIONAL: Email provider validation\n  const emailProvider = process.env.EMAIL_PROVIDER || 'sendgrid';\n  if (emailProvider === 'sendgrid' && !process.env.SENDGRID_API_KEY) {\n    errors.push('SENDGRID_API_KEY is required when EMAIL_PROVIDER=sendgrid');\n  }\n  \n  // RECOMMENDED: R2 Storage (warn if missing, don't block)\n  if (!process.env.R2_ACCOUNT_ID || !process.env.R2_ACCESS_KEY_ID || !process.env.R2_SECRET_ACCESS_KEY) {\n    console.warn('[SPLICE] WARNING: R2 storage credentials not configured. Music generation uploads will fail.');\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n\n// Run validation in production\nif (isProduction) {\n  const validation = validateEnvironmentVariables();\n  \n  if (!validation.valid) {\n    console.error('[SPLICE] ========================================');\n    console.error('[SPLICE] CRITICAL: Missing required environment variables');\n    console.error('[SPLICE] ========================================');\n    validation.errors.forEach(error => {\n      console.error(`[SPLICE]   ❌ ${error}`);\n    });\n    console.error('[SPLICE] ========================================');\n    console.error('[SPLICE] Server startup aborted. Please configure all required environment variables.');\n    console.error('[SPLICE] See .env.example for complete documentation.');\n    process.exit(1);\n  }\n  \n  console.log('[SPLICE] ✅ Environment validation passed');\n}\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {\n  apiVersion: STRIPE_API_VERSION\n});\n\n// =============================================================================\n// PERF-FIX: Static Response Cache\n// Cache static endpoint responses at startup to avoid repeated computation\n// =============================================================================\n\n// Generate ETag from content\nfunction generateETag(content) {\n  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n}\n\n// Static response cache - populated at startup\nconst STATIC_RESPONSE_CACHE = {\n  profanityLanguages: null,\n  profanityBleeps: null,\n  exportFormats: null\n};\n\n// Initialize cache at startup (called after server starts)\nfunction initializeStaticCache() {\n  // Cache profanity languages\n  const languages = getSupportedLanguages();\n  STATIC_RESPONSE_CACHE.profanityLanguages = {\n    body: { success: true, languages },\n    etag: generateETag({ languages })\n  };\n\n  // Cache profanity bleeps\n  const sounds = getAvailableBleepSounds();\n  STATIC_RESPONSE_CACHE.profanityBleeps = {\n    body: { success: true, sounds },\n    etag: generateETag({ sounds })\n  };\n\n  // Cache export formats\n  const formats = getSupportedFormats();\n  STATIC_RESPONSE_CACHE.exportFormats = {\n    body: { success: true, formats },\n    etag: generateETag({ formats })\n  };\n\n  console.log('[SPLICE] Static response cache initialized');\n}\n\n// Helper to send cached response with ETag\nfunction sendCachedResponse(req, res, cacheKey) {\n  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n  if (!cached) {\n    return res.status(500).json({ error: 'Cache not initialized' });\n  }\n\n  // Check If-None-Match header for conditional GET\n  const clientETag = req.headers['if-none-match'];\n  if (clientETag === cached.etag) {\n    return res.status(304).end(); // Not Modified\n  }\n\n  // Send cached response with ETag and cache headers\n  res.set('ETag', cached.etag);\n  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n  res.json(cached.body);\n}\n\n// =============================================================================\n// Server Configuration\n// =============================================================================\n\nconst app = express();\nconst PORT = process.env.PORT || 3847;\n\n// HIGH-008: Initialize Sentry after app creation\nif (Sentry && process.env.SENTRY_DSN) {\n  Sentry.init({\n    dsn: process.env.SENTRY_DSN,\n    environment: process.env.NODE_ENV || 'development',\n    release: process.env.npm_package_version || '6.0.3',\n    tracesSampleRate: isProduction ? 0.1 : 1.0, // 10% in prod, 100% in dev\n    profilesSampleRate: isProduction ? 0.1 : 0, // Profile only in production\n    integrations: [\n      // Automatically instrument HTTP requests\n      Sentry.httpIntegration({ tracing: true }),\n      // Automatically instrument Express\n      Sentry.expressIntegration({ app }),\n    ],\n    // Filter out sensitive data\n    beforeSend(event) {\n      // Remove sensitive headers\n      if (event.request && event.request.headers) {\n        delete event.request.headers.authorization;\n        delete event.request.headers['x-stripe-customer-id'];\n        delete event.request.headers['stripe-signature'];\n      }\n      return event;\n    },\n  });\n  \n  // Add Sentry request handler as first middleware\n  app.use(Sentry.Handlers.requestHandler());\n  app.use(Sentry.Handlers.tracingHandler());\n  \n  console.log('[SPLICE] ✅ Sentry error monitoring initialized');\n}\n\n// MEDIUM-005: Request ID Tracing Middleware\n// Add early in chain to ensure all requests have correlation IDs for logging\napp.use(requestIdMiddleware);\n\n// HTTPS certificates (generated by mkcert) - only for local development\nlet httpsOptions = null;\nif (!isProduction) {\n  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n  const certPath = path.join(__dirname, 'localhost+1.pem');\n  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n    httpsOptions = {\n      key: fs.readFileSync(keyPath),\n      cert: fs.readFileSync(certPath)\n    };\n  }\n}\n\n// =============================================================================\n// Security Configuration\n// =============================================================================\n\n// CORS whitelist - restrict origins in production\nconst CORS_WHITELIST = [\n  'http://localhost:3000',\n  'http://localhost:3847',\n  'https://localhost:3847',\n  'http://127.0.0.1:3000',\n  'http://127.0.0.1:3847',\n  'https://127.0.0.1:3847',\n  'https://splice.app',\n  'https://www.splice.app',\n  'https://spliceclips.com',\n  'https://www.spliceclips.com',\n  'https://splice-api-production.up.railway.app',\n  'https://splice-website.vercel.app',\n  // Adobe CEP/UXP panels run from file:// or bolt://\n  'file://',\n  'bolt://'\n];\n\nconst corsOptions = {\n  origin: function (origin, callback) {\n    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n    if (!origin) {\n      return callback(null, true);\n    }\n    // Check if origin is in whitelist\n    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n      return callback(null, true);\n    }\n    // In development, allow all origins with warning\n    if (!isProduction) {\n      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n      return callback(null, true);\n    }\n    // In production, reject non-whitelisted origins\n    console.error(`[CORS] Blocked request from: ${origin}`);\n    return callback(new Error('Not allowed by CORS'));\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature', 'x-csrf-token']\n};\n\napp.use(cors(corsOptions));\n\n// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n// This ensures rate limiting and logging use the correct client IP\nif (isProduction) {\n  app.set('trust proxy', 1);\n}\n\n// IP-based rate limiting (100 requests/minute per IP)\napp.use(ipRateLimit);\n\n// Security headers via helmet\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n  noSniff: true,\n  xssFilter: true,\n  hidePoweredBy: true\n}));\n\n// Helper to determine tier from price ID with logging\n// Supports both monthly and annual pricing\nfunction getTierFromPriceId(priceId) {\n  // Monthly prices\n  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n\n  // Annual prices (same tier, just different billing period)\n  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n\n  // Log unknown price ID for debugging\n  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n  return 'starter';\n}\n\n// =============================================================================\n// Stripe Webhook (must be before express.json())\n// =============================================================================\n\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n  let event;\n\n  try {\n    if (webhookSecret) {\n      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } else if (isProduction) {\n      // SECURITY: Reject unsigned webhooks in production\n      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n    } else {\n      // For local development testing only\n      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n      event = JSON.parse(bodyString);\n      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n    return res.status(400).json({ error: 'Webhook signature verification failed' });\n  }\n\n  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n\n  // Idempotency check - skip if already processed\n  if (await usageTracking.isEventProcessed(event.id)) {\n    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n    return res.json({ received: true, skipped: true });\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Get tier from price ID\n        const priceId = subscription.items?.data?.[0]?.price?.id;\n        const tier = getTierFromPriceId(priceId);\n\n        // Update user tier and reset hours\n        await usageTracking.updateTier(customerId, tier);\n        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n\n        // Initialize music credits for new subscriptions\n        if (event.type === 'customer.subscription.created') {\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Update trial end date if present\n        if (subscription.trial_end) {\n          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n        }\n\n        // Generate license key for new subscriptions with retry and delivery\n        if (event.type === 'customer.subscription.created') {\n          let licenseResult = null;\n          let retryCount = 0;\n          const maxRetries = 3;\n\n          // Retry mechanism for license key generation\n          while (retryCount < maxRetries) {\n            licenseResult = await licenseService.generateLicenseKey(customerId);\n            if (licenseResult.success) {\n              break;\n            }\n            retryCount++;\n            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n            // Wait before retry (exponential backoff)\n            if (retryCount < maxRetries) {\n              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n            }\n          }\n\n          if (licenseResult && licenseResult.success) {\n            // SECURITY: Mask license key in logs\n            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n\n            // Store license key in Stripe subscription metadata as backup\n            try {\n              await stripe.subscriptions.update(subscription.id, {\n                metadata: {\n                  license_key: licenseResult.key,\n                  license_generated_at: new Date().toISOString()\n                }\n              });\n              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n            } catch (stripeErr) {\n              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n            }\n\n            // Get customer email and send license key\n            try {\n              const customer = await stripe.customers.retrieve(customerId);\n              if (customer.email) {\n                // SECURITY: Mask sensitive data in logs\n                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n\n                // Send license key email\n                try {\n                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n                } catch (sendErr) {\n                  // Log but don't fail - license is stored in Stripe metadata as backup\n                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n                }\n\n                // Store email in database for reference\n                await usageTracking.updateTier(customerId, tier, customer.email);\n              } else {\n                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n              }\n            } catch (emailErr) {\n              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n            }\n          } else {\n            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n            console.error(`[SPLICE] ${errorMsg}`);\n            return res.status(500).json({ error: errorMsg });\n          }\n        }\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Downgrade to cancelled (0 hours)\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const subscriptionId = invoice.subscription;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in invoice event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Reset hours on successful payment (new billing period)\n        let tier = 'starter';\n        if (subscriptionId) {\n          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n          const priceId = subscription.items?.data?.[0]?.price?.id;\n          tier = getTierFromPriceId(priceId);\n\n          await usageTracking.resetHours(customerId, tier);\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Check for affiliate coupon and record commission\n        const discount = invoice.discount;\n        if (discount && discount.coupon) {\n          const couponId = discount.coupon.id;\n          // Check if this is an affiliate code (like JIMMYN)\n          if (referralService.AFFILIATE_CODES[couponId]) {\n            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n            await referralService.recordAffiliateCommission(\n              couponId,\n              customerId,\n              amountPaid,\n              tier\n            );\n            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n          }\n        }\n        break;\n      }\n\n      case 'invoice.payment_failed': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const attemptCount = invoice.attempt_count || 1;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in payment_failed event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n\n        // Stripe will retry automatically per retry settings\n        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n        // Send warning email on final attempt\n        if (attemptCount >= 3) {\n          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n          // Send warning email to customer about impending cancellation\n          try {\n            const customer = await stripe.customers.retrieve(customerId);\n            if (customer.email) {\n              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n            }\n          } catch (emailErr) {\n            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n          }\n        }\n        break;\n      }\n\n      case 'customer.deleted': {\n        const customer = event.data.object;\n        const customerId = customer.id;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Clean up user data - downgrade to cancelled\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n        break;\n      }\n\n      default:\n        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n    }\n\n    // Record event as processed (idempotency)\n    await usageTracking.recordWebhookEvent(event.id, event.type);\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error('[SPLICE] Webhook handler error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Parse JSON body for all other routes\n// SECURITY: Limit JSON body size to prevent DoS attacks\napp.use(express.json({ limit: '10mb' }));\n\n// Parse cookies for CSRF token validation\napp.use(cookieParser());\n\n// =============================================================================\n// Route Configuration Options\n// =============================================================================\n\nconst routeOptions = {\n  middleware: {\n    requireCredits,\n    requireFeature,\n    authenticateToken\n  },\n  services: {\n    usageTracking,\n    referralService,\n    licenseService,\n    emailService,\n    stripe\n  },\n  authHelpers: {\n    generateToken,\n    generateRefreshToken,\n    verifyToken,\n    maskSensitiveData,\n    blacklistToken\n  },\n  staticCache: STATIC_RESPONSE_CACHE,\n  sendCachedResponse\n};\n\n// =============================================================================\n// Mount Routes\n// =============================================================================\n\n// Health check and system endpoints (no prefix)\napp.use('/', healthRoutes(routeOptions));\n\n// Core analysis endpoints\napp.use('/', analyzeRoutes(routeOptions));\napp.use('/', silencesRoutes(routeOptions));\napp.use('/', detectionRoutes(routeOptions));\n\n// Export endpoints\napp.use('/export', exportRoutes(routeOptions));\n\n// Multitrack/Multicam endpoints\napp.use('/multitrack', multitrackRoutes(routeOptions));\n\n// Cut list generation\napp.use('/cut-list', cutListRoutes(routeOptions));\n\n// Legacy XML processing endpoint (backwards compatibility)\nconst { processXMLFile } = require('./services/xmlProcessor');\napp.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n  const {\n    xmlPath,\n    silences,\n    removeGaps = true,\n    outputPath = null\n  } = req.body;\n\n  if (!xmlPath) {\n    return res.status(400).json({ error: 'xmlPath is required' });\n  }\n\n  if (!silences || !Array.isArray(silences)) {\n    return res.status(400).json({ error: 'silences array is required' });\n  }\n\n  if (!fs.existsSync(xmlPath)) {\n    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n  }\n\n  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n\n  try {\n    const result = await processXMLFile(xmlPath, silences, {\n      outputPath,\n      removeGaps\n    });\n\n    res.json({\n      success: true,\n      inputPath: xmlPath,\n      outputPath: result.outputPath,\n      stats: result.stats\n    });\n  } catch (err) {\n    console.error('[SPLICE] XML processing error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Auto zoom endpoints\napp.use('/zoom', zoomRoutes(routeOptions));\n\n// Chapter detection endpoints\napp.use('/chapters', chaptersRoutes(routeOptions));\n\n// YouTube content generation\napp.use('/youtube', youtubeRoutes(routeOptions));\n\n// Animated captions endpoints\napp.use('/captions', captionsRoutes(routeOptions));\n\n// Text-based editing endpoints\napp.use('/text-edit', textEditRoutes(routeOptions));\n\n// Social reframe endpoints\napp.use('/reframe', reframeRoutes(routeOptions));\napp.use('/faces', reframeRoutes.facesRouter(routeOptions));\n\n// Batch processing endpoints\napp.use('/batch', batchRoutes(routeOptions));\n\n// Authentication endpoints\napp.use('/auth', authRoutes(routeOptions));\n\n// Billing and credits endpoints\napp.use('/', billingRoutes(routeOptions));\n\n// Referral system endpoints\napp.use('/referral', referralRoutes(routeOptions));\n\n// License key endpoints\napp.use('/license', licenseRoutes(routeOptions));\n\n// AI Music generation endpoints\napp.use('/music', musicRoutes(routeOptions));\n\n// =============================================================================\n// HIGH-011: API Versioning\n// Mount versioned routes under /api/v1 prefix\n// Maintain backwards compatibility with deprecation warnings\n// =============================================================================\n\n// Mount v1 API routes\napp.use('/api/v1', v1Routes(routeOptions));\n\n// Deprecation warning middleware for unversioned API calls\n// This helps clients migrate to versioned endpoints\napp.use('/api', (req, res, next) => {\n  // Skip if already using versioned endpoint\n  if (req.path.startsWith('/v1')) {\n    return next();\n  }\n  \n  // Add deprecation warning header\n  res.set('X-API-Deprecation-Warning', 'Unversioned API endpoints are deprecated. Please migrate to /api/v1/');\n  res.set('X-API-Version', 'unversioned');\n  res.set('Deprecation', 'true');\n  res.set('Sunset', new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toUTCString()); // 90 days from now\n  \n  next();\n});\n\n// HIGH-008: Add Sentry error handler (must be after all routes)\nif (Sentry) {\n  app.use(Sentry.Handlers.errorHandler({\n    shouldHandleError(error) {\n      // Capture all 4xx and 5xx errors\n      if (error.status >= 400) {\n        return true;\n      }\n      return true;\n    },\n  }));\n}\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\n// Track active server for graceful shutdown\nlet server = null;\n\n// Initialize database and start server\nasync function startServer() {\n  try {\n    await usageTracking.initDatabase();\n    await referralService.initReferralTables();\n    await licenseService.initLicenseTables();\n    console.log('[SPLICE] Database initialized');\n\n    // PERF-FIX: Initialize static response cache at startup\n    initializeStaticCache();\n\n    // Start music generation worker (BullMQ background processor)\n    // Only starts if Redis is configured and Replicate API key is available\n    if (process.env.REDIS_URL || process.env.UPSTASH_REDIS_URL) {\n      if (process.env.REPLICATE_API_TOKEN) {\n        try {\n          createMusicWorker();\n          console.log('[SPLICE] ✅ Music generation worker started');\n        } catch (workerErr) {\n          console.error('[SPLICE] ⚠️ Failed to start music worker:', workerErr.message);\n          // Don't fail server startup - music generation will be unavailable\n        }\n      } else {\n        console.warn('[SPLICE] ⚠️ REPLICATE_API_TOKEN not set - music generation disabled');\n      }\n    } else {\n      console.warn('[SPLICE] ⚠️ Redis not configured - music generation queue disabled');\n    }\n\n    if (isProduction || !httpsOptions) {\n      // Production: Railway provides TLS termination, use HTTP\n      server = http.createServer(app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n      });\n    } else {\n      // Development: Use HTTPS with local certificates\n      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n      });\n    }\n  } catch (err) {\n    console.error('[SPLICE] Failed to start server:', err);\n    process.exit(1);\n  }\n}\n\n// =============================================================================\n// Graceful Shutdown\n// =============================================================================\n\nasync function gracefulShutdown(signal) {\n  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n\n  // Stop accepting new connections\n  if (server) {\n    server.close(() => {\n      console.log('[SPLICE] HTTP server closed');\n    });\n  }\n\n  // Shutdown music worker (allows in-progress jobs to complete)\n  try {\n    await shutdownWorker();\n    console.log('[SPLICE] Music worker shut down');\n  } catch (err) {\n    console.error('[SPLICE] Error shutting down music worker:', err.message);\n  }\n\n  // Close database pool\n  try {\n    await usageTracking.closePool();\n    console.log('[SPLICE] Database pool closed');\n  } catch (err) {\n    console.error('[SPLICE] Error closing database pool:', err.message);\n  }\n\n  // Give ongoing requests time to complete (max 10 seconds)\n  setTimeout(() => {\n    console.log('[SPLICE] Graceful shutdown complete');\n    process.exit(0);\n  }, 10000);\n}\n\n// Handle termination signals\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (err) => {\n  console.error('[SPLICE] Uncaught exception:', err);\n  gracefulShutdown('uncaughtException');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n});\n\nstartServer();\n","numLines":938,"startLine":1,"totalLines":938}}}
{"parentUuid":"ae124165-5c54-49ab-a2bc-956d5435b0d0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GVsWMrYKSEAtA3oWD2YEMC","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check for additional middleware files and the Redis client to verify the complete middleware stack:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":29605,"cache_read_input_tokens":27867,"cache_creation":{"ephemeral_5m_input_tokens":29605,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UMaH3vKH9CfrqsR7P1","type":"assistant","uuid":"e3c7fc45-6489-48ad-bfaa-93212d9e5a00","timestamp":"2026-01-11T23:39:07.672Z"}
{"parentUuid":"e3c7fc45-6489-48ad-bfaa-93212d9e5a00","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GVsWMrYKSEAtA3oWD2YEMC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V5YiEAcFLiNEos8ueiwfX2","name":"Glob","input":{"pattern":"/Users/imorgado/SPLICE/splice-backend/middleware/*.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":29605,"cache_read_input_tokens":27867,"cache_creation":{"ephemeral_5m_input_tokens":29605,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UMaH3vKH9CfrqsR7P1","type":"assistant","uuid":"b26db19f-b7f8-48aa-8acb-c5bacf3a679b","timestamp":"2026-01-11T23:39:08.244Z"}
{"parentUuid":"b26db19f-b7f8-48aa-8acb-c5bacf3a679b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GVsWMrYKSEAtA3oWD2YEMC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01McDUvbVcYaT6rEt75XAraA","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/redisClient.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":29605,"cache_read_input_tokens":27867,"cache_creation":{"ephemeral_5m_input_tokens":29605,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UMaH3vKH9CfrqsR7P1","type":"assistant","uuid":"2e7278c7-8aef-4f2b-a906-5c48644ce294","timestamp":"2026-01-11T23:39:08.818Z"}
{"parentUuid":"2e7278c7-8aef-4f2b-a906-5c48644ce294","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GVsWMrYKSEAtA3oWD2YEMC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nx9VNnm5UvJWgBS91KtmyC","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/utils/authLogger.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":29605,"cache_read_input_tokens":27867,"cache_creation":{"ephemeral_5m_input_tokens":29605,"ephemeral_1h_input_tokens":0},"output_tokens":199,"service_tier":"standard"}},"requestId":"req_011CX2UMaH3vKH9CfrqsR7P1","type":"assistant","uuid":"ada1b9ba-57ce-4888-a4e9-996de8665526","timestamp":"2026-01-11T23:39:09.290Z"}
{"parentUuid":"ada1b9ba-57ce-4888-a4e9-996de8665526","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01McDUvbVcYaT6rEt75XAraA","type":"tool_result","content":"     1→/**\n     2→ * Shared Redis Client Service\n     3→ * Supports both Upstash REST API and standard Redis (ioredis)\n     4→ * - Uses @upstash/redis when UPSTASH_REDIS_REST_URL is configured\n     5→ * - Uses ioredis when UPSTASH_REDIS_URL is configured (Railway, standard Redis)\n     6→ * - Provides unified API for caching and storage operations\n     7→ */\n     8→\n     9→const { Redis: UpstashRedis } = require('@upstash/redis');\n    10→const IORedis = require('ioredis');\n    11→\n    12→// Singleton instances\n    13→let client = null;\n    14→let clientType = 'none'; // 'upstash-rest', 'ioredis', or 'none'\n    15→let isConnected = false;\n    16→let connectionError = null;\n    17→\n    18→/**\n    19→ * Initialize Redis client based on available environment variables\n    20→ * Priority: Upstash REST > Standard Redis URL\n    21→ * @returns {Object|null} Redis client or null if not configured\n    22→ */\n    23→function initializeClient() {\n    24→  if (client) {\n    25→    return client;\n    26→  }\n    27→\n    28→  // Try Upstash REST first (for Upstash-specific deployments)\n    29→  const restUrl = process.env.UPSTASH_REDIS_REST_URL;\n    30→  const restToken = process.env.UPSTASH_REDIS_REST_TOKEN;\n    31→\n    32→  if (restUrl && restToken) {\n    33→    try {\n    34→      client = new UpstashRedis({\n    35→        url: restUrl,\n    36→        token: restToken,\n    37→        automaticDeserialization: true,\n    38→      });\n    39→      clientType = 'upstash-rest';\n    40→      isConnected = true;\n    41→      console.log('[Redis] Upstash REST client initialized');\n    42→      return client;\n    43→    } catch (err) {\n    44→      console.error('[Redis] Failed to initialize Upstash REST client:', err.message);\n    45→      connectionError = err;\n    46→    }\n    47→  }\n    48→\n    49→  // Try standard Redis URL (Railway, Docker, local Redis)\n    50→  const redisUrl = process.env.UPSTASH_REDIS_URL || process.env.REDIS_URL;\n    51→\n    52→  if (redisUrl) {\n    53→    try {\n    54→      client = new IORedis(redisUrl, {\n    55→        maxRetriesPerRequest: 3,\n    56→        retryDelayOnFailover: 100,\n    57→        lazyConnect: false,\n    58→        enableReadyCheck: true,\n    59→        connectTimeout: 10000,\n    60→      });\n    61→\n    62→      client.on('connect', () => {\n    63→        isConnected = true;\n    64→        connectionError = null;\n    65→        console.log('[Redis] ioredis client connected');\n    66→      });\n    67→\n    68→      client.on('error', (err) => {\n    69→        console.error('[Redis] ioredis error:', err.message);\n    70→        connectionError = err;\n    71→        // Don't set isConnected to false on transient errors\n    72→      });\n    73→\n    74→      client.on('close', () => {\n    75→        console.log('[Redis] ioredis connection closed');\n    76→      });\n    77→\n    78→      clientType = 'ioredis';\n    79→      isConnected = true; // Optimistically set, will be updated by events\n    80→      console.log('[Redis] ioredis client initialized with URL');\n    81→      return client;\n    82→    } catch (err) {\n    83→      console.error('[Redis] Failed to initialize ioredis client:', err.message);\n    84→      connectionError = err;\n    85→    }\n    86→  }\n    87→\n    88→  console.warn('[Redis] No Redis configuration found - Redis features disabled');\n    89→  console.warn('[Redis] Set UPSTASH_REDIS_URL for standard Redis or UPSTASH_REDIS_REST_URL + UPSTASH_REDIS_REST_TOKEN for Upstash REST');\n    90→  connectionError = new Error('Redis not configured');\n    91→  return null;\n    92→}\n    93→\n    94→/**\n    95→ * Get the Redis client (lazy initialization)\n    96→ * @returns {Object|null} Redis client or null if not configured\n    97→ */\n    98→function getRedisClient() {\n    99→  return initializeClient();\n   100→}\n   101→\n   102→/**\n   103→ * Check if Redis is available and connected\n   104→ * @returns {boolean} True if Redis is available\n   105→ */\n   106→function isRedisAvailable() {\n   107→  const redis = getRedisClient();\n   108→  return redis !== null && isConnected;\n   109→}\n   110→\n   111→/**\n   112→ * Get Redis connection status\n   113→ * @returns {Object} { connected, error, type }\n   114→ */\n   115→function getRedisStatus() {\n   116→  getRedisClient(); // Ensure initialization attempted\n   117→  return {\n   118→    connected: isConnected && client !== null,\n   119→    error: connectionError ? connectionError.message : null,\n   120→    type: clientType\n   121→  };\n   122→}\n   123→\n   124→/**\n   125→ * Ping Redis to check connectivity\n   126→ * @returns {Promise<boolean>} True if ping successful\n   127→ */\n   128→async function pingRedis() {\n   129→  const redis = getRedisClient();\n   130→  if (!redis) {\n   131→    return false;\n   132→  }\n   133→\n   134→  try {\n   135→    const result = await redis.ping();\n   136→    const success = result === 'PONG' || result === 'pong';\n   137→    if (success) {\n   138→      isConnected = true;\n   139→      connectionError = null;\n   140→    }\n   141→    return success;\n   142→  } catch (err) {\n   143→    console.error('[Redis] Ping failed:', err.message);\n   144→    isConnected = false;\n   145→    connectionError = err;\n   146→    return false;\n   147→  }\n   148→}\n   149→\n   150→/**\n   151→ * Set a value with optional TTL\n   152→ * @param {string} key - Redis key\n   153→ * @param {any} value - Value to store (will be JSON serialized for ioredis)\n   154→ * @param {number} ttlSeconds - Optional TTL in seconds\n   155→ * @returns {Promise<boolean>} True if successful\n   156→ */\n   157→async function set(key, value, ttlSeconds = null) {\n   158→  const redis = getRedisClient();\n   159→  if (!redis) {\n   160→    return false;\n   161→  }\n   162→\n   163→  try {\n   164→    // Serialize value for ioredis (Upstash REST handles this automatically)\n   165→    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;\n   166→\n   167→    if (clientType === 'upstash-rest') {\n   168→      if (ttlSeconds) {\n   169→        await redis.set(key, value, { ex: ttlSeconds });\n   170→      } else {\n   171→        await redis.set(key, value);\n   172→      }\n   173→    } else {\n   174→      // ioredis syntax\n   175→      if (ttlSeconds) {\n   176→        await redis.set(key, serializedValue, 'EX', ttlSeconds);\n   177→      } else {\n   178→        await redis.set(key, serializedValue);\n   179→      }\n   180→    }\n   181→    return true;\n   182→  } catch (err) {\n   183→    console.error('[Redis] SET failed:', err.message);\n   184→    return false;\n   185→  }\n   186→}\n   187→\n   188→/**\n   189→ * Get a value\n   190→ * @param {string} key - Redis key\n   191→ * @returns {Promise<any|null>} Value or null if not found\n   192→ */\n   193→async function get(key) {\n   194→  const redis = getRedisClient();\n   195→  if (!redis) {\n   196→    return null;\n   197→  }\n   198→\n   199→  try {\n   200→    const result = await redis.get(key);\n   201→    if (result === null) {\n   202→      return null;\n   203→    }\n   204→    // Parse JSON for ioredis (Upstash REST handles this automatically)\n   205→    if (clientType === 'ioredis' && typeof result === 'string') {\n   206→      try {\n   207→        return JSON.parse(result);\n   208→      } catch {\n   209→        return result; // Return as-is if not JSON\n   210→      }\n   211→    }\n   212→    return result;\n   213→  } catch (err) {\n   214→    console.error('[Redis] GET failed:', err.message);\n   215→    return null;\n   216→  }\n   217→}\n   218→\n   219→/**\n   220→ * Check if a key exists\n   221→ * @param {string} key - Redis key\n   222→ * @returns {Promise<boolean>} True if key exists\n   223→ */\n   224→async function exists(key) {\n   225→  const redis = getRedisClient();\n   226→  if (!redis) {\n   227→    return false;\n   228→  }\n   229→\n   230→  try {\n   231→    const result = await redis.exists(key);\n   232→    return result === 1 || result === true;\n   233→  } catch (err) {\n   234→    console.error('[Redis] EXISTS failed:', err.message);\n   235→    return false;\n   236→  }\n   237→}\n   238→\n   239→/**\n   240→ * Delete a key\n   241→ * @param {string} key - Redis key\n   242→ * @returns {Promise<boolean>} True if deleted\n   243→ */\n   244→async function del(key) {\n   245→  const redis = getRedisClient();\n   246→  if (!redis) {\n   247→    return false;\n   248→  }\n   249→\n   250→  try {\n   251→    await redis.del(key);\n   252→    return true;\n   253→  } catch (err) {\n   254→    console.error('[Redis] DEL failed:', err.message);\n   255→    return false;\n   256→  }\n   257→}\n   258→\n   259→/**\n   260→ * Set a value only if it doesn't exist (SETNX)\n   261→ * @param {string} key - Redis key\n   262→ * @param {any} value - Value to store\n   263→ * @param {number} ttlSeconds - Optional TTL in seconds\n   264→ * @returns {Promise<boolean>} True if set (key didn't exist)\n   265→ */\n   266→async function setNX(key, value, ttlSeconds = null) {\n   267→  const redis = getRedisClient();\n   268→  if (!redis) {\n   269→    return false;\n   270→  }\n   271→\n   272→  try {\n   273→    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;\n   274→\n   275→    if (clientType === 'upstash-rest') {\n   276→      const options = { nx: true };\n   277→      if (ttlSeconds) {\n   278→        options.ex = ttlSeconds;\n   279→      }\n   280→      const result = await redis.set(key, value, options);\n   281→      return result === 'OK';\n   282→    } else {\n   283→      // ioredis: Use SET with NX option\n   284→      const args = [key, serializedValue, 'NX'];\n   285→      if (ttlSeconds) {\n   286→        args.push('EX', ttlSeconds);\n   287→      }\n   288→      const result = await redis.set(...args);\n   289→      return result === 'OK';\n   290→    }\n   291→  } catch (err) {\n   292→    console.error('[Redis] SETNX failed:', err.message);\n   293→    return false;\n   294→  }\n   295→}\n   296→\n   297→/**\n   298→ * Get TTL of a key\n   299→ * @param {string} key - Redis key\n   300→ * @returns {Promise<number>} TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n   301→ */\n   302→async function ttl(key) {\n   303→  const redis = getRedisClient();\n   304→  if (!redis) {\n   305→    return -2;\n   306→  }\n   307→\n   308→  try {\n   309→    return await redis.ttl(key);\n   310→  } catch (err) {\n   311→    console.error('[Redis] TTL failed:', err.message);\n   312→    return -2;\n   313→  }\n   314→}\n   315→\n   316→/**\n   317→ * Gracefully close the Redis connection\n   318→ * @returns {Promise<void>}\n   319→ */\n   320→async function close() {\n   321→  if (client && clientType === 'ioredis') {\n   322→    try {\n   323→      await client.quit();\n   324→      console.log('[Redis] ioredis connection closed gracefully');\n   325→    } catch (err) {\n   326→      console.error('[Redis] Error closing connection:', err.message);\n   327→    }\n   328→  }\n   329→  client = null;\n   330→  clientType = 'none';\n   331→  isConnected = false;\n   332→}\n   333→\n   334→module.exports = {\n   335→  getRedisClient,\n   336→  isRedisAvailable,\n   337→  getRedisStatus,\n   338→  pingRedis,\n   339→  close,\n   340→  // Convenience methods\n   341→  set,\n   342→  get,\n   343→  exists,\n   344→  del,\n   345→  setNX,\n   346→  ttl\n   347→};\n   348→\n\n</system-reminder>\n"}]},"uuid":"32c18164-a131-455c-8d16-3123b260c855","timestamp":"2026-01-11T23:39:09.323Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/redisClient.js","content":"/**\n * Shared Redis Client Service\n * Supports both Upstash REST API and standard Redis (ioredis)\n * - Uses @upstash/redis when UPSTASH_REDIS_REST_URL is configured\n * - Uses ioredis when UPSTASH_REDIS_URL is configured (Railway, standard Redis)\n * - Provides unified API for caching and storage operations\n */\n\nconst { Redis: UpstashRedis } = require('@upstash/redis');\nconst IORedis = require('ioredis');\n\n// Singleton instances\nlet client = null;\nlet clientType = 'none'; // 'upstash-rest', 'ioredis', or 'none'\nlet isConnected = false;\nlet connectionError = null;\n\n/**\n * Initialize Redis client based on available environment variables\n * Priority: Upstash REST > Standard Redis URL\n * @returns {Object|null} Redis client or null if not configured\n */\nfunction initializeClient() {\n  if (client) {\n    return client;\n  }\n\n  // Try Upstash REST first (for Upstash-specific deployments)\n  const restUrl = process.env.UPSTASH_REDIS_REST_URL;\n  const restToken = process.env.UPSTASH_REDIS_REST_TOKEN;\n\n  if (restUrl && restToken) {\n    try {\n      client = new UpstashRedis({\n        url: restUrl,\n        token: restToken,\n        automaticDeserialization: true,\n      });\n      clientType = 'upstash-rest';\n      isConnected = true;\n      console.log('[Redis] Upstash REST client initialized');\n      return client;\n    } catch (err) {\n      console.error('[Redis] Failed to initialize Upstash REST client:', err.message);\n      connectionError = err;\n    }\n  }\n\n  // Try standard Redis URL (Railway, Docker, local Redis)\n  const redisUrl = process.env.UPSTASH_REDIS_URL || process.env.REDIS_URL;\n\n  if (redisUrl) {\n    try {\n      client = new IORedis(redisUrl, {\n        maxRetriesPerRequest: 3,\n        retryDelayOnFailover: 100,\n        lazyConnect: false,\n        enableReadyCheck: true,\n        connectTimeout: 10000,\n      });\n\n      client.on('connect', () => {\n        isConnected = true;\n        connectionError = null;\n        console.log('[Redis] ioredis client connected');\n      });\n\n      client.on('error', (err) => {\n        console.error('[Redis] ioredis error:', err.message);\n        connectionError = err;\n        // Don't set isConnected to false on transient errors\n      });\n\n      client.on('close', () => {\n        console.log('[Redis] ioredis connection closed');\n      });\n\n      clientType = 'ioredis';\n      isConnected = true; // Optimistically set, will be updated by events\n      console.log('[Redis] ioredis client initialized with URL');\n      return client;\n    } catch (err) {\n      console.error('[Redis] Failed to initialize ioredis client:', err.message);\n      connectionError = err;\n    }\n  }\n\n  console.warn('[Redis] No Redis configuration found - Redis features disabled');\n  console.warn('[Redis] Set UPSTASH_REDIS_URL for standard Redis or UPSTASH_REDIS_REST_URL + UPSTASH_REDIS_REST_TOKEN for Upstash REST');\n  connectionError = new Error('Redis not configured');\n  return null;\n}\n\n/**\n * Get the Redis client (lazy initialization)\n * @returns {Object|null} Redis client or null if not configured\n */\nfunction getRedisClient() {\n  return initializeClient();\n}\n\n/**\n * Check if Redis is available and connected\n * @returns {boolean} True if Redis is available\n */\nfunction isRedisAvailable() {\n  const redis = getRedisClient();\n  return redis !== null && isConnected;\n}\n\n/**\n * Get Redis connection status\n * @returns {Object} { connected, error, type }\n */\nfunction getRedisStatus() {\n  getRedisClient(); // Ensure initialization attempted\n  return {\n    connected: isConnected && client !== null,\n    error: connectionError ? connectionError.message : null,\n    type: clientType\n  };\n}\n\n/**\n * Ping Redis to check connectivity\n * @returns {Promise<boolean>} True if ping successful\n */\nasync function pingRedis() {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    const result = await redis.ping();\n    const success = result === 'PONG' || result === 'pong';\n    if (success) {\n      isConnected = true;\n      connectionError = null;\n    }\n    return success;\n  } catch (err) {\n    console.error('[Redis] Ping failed:', err.message);\n    isConnected = false;\n    connectionError = err;\n    return false;\n  }\n}\n\n/**\n * Set a value with optional TTL\n * @param {string} key - Redis key\n * @param {any} value - Value to store (will be JSON serialized for ioredis)\n * @param {number} ttlSeconds - Optional TTL in seconds\n * @returns {Promise<boolean>} True if successful\n */\nasync function set(key, value, ttlSeconds = null) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    // Serialize value for ioredis (Upstash REST handles this automatically)\n    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;\n\n    if (clientType === 'upstash-rest') {\n      if (ttlSeconds) {\n        await redis.set(key, value, { ex: ttlSeconds });\n      } else {\n        await redis.set(key, value);\n      }\n    } else {\n      // ioredis syntax\n      if (ttlSeconds) {\n        await redis.set(key, serializedValue, 'EX', ttlSeconds);\n      } else {\n        await redis.set(key, serializedValue);\n      }\n    }\n    return true;\n  } catch (err) {\n    console.error('[Redis] SET failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get a value\n * @param {string} key - Redis key\n * @returns {Promise<any|null>} Value or null if not found\n */\nasync function get(key) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return null;\n  }\n\n  try {\n    const result = await redis.get(key);\n    if (result === null) {\n      return null;\n    }\n    // Parse JSON for ioredis (Upstash REST handles this automatically)\n    if (clientType === 'ioredis' && typeof result === 'string') {\n      try {\n        return JSON.parse(result);\n      } catch {\n        return result; // Return as-is if not JSON\n      }\n    }\n    return result;\n  } catch (err) {\n    console.error('[Redis] GET failed:', err.message);\n    return null;\n  }\n}\n\n/**\n * Check if a key exists\n * @param {string} key - Redis key\n * @returns {Promise<boolean>} True if key exists\n */\nasync function exists(key) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    const result = await redis.exists(key);\n    return result === 1 || result === true;\n  } catch (err) {\n    console.error('[Redis] EXISTS failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Delete a key\n * @param {string} key - Redis key\n * @returns {Promise<boolean>} True if deleted\n */\nasync function del(key) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    await redis.del(key);\n    return true;\n  } catch (err) {\n    console.error('[Redis] DEL failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Set a value only if it doesn't exist (SETNX)\n * @param {string} key - Redis key\n * @param {any} value - Value to store\n * @param {number} ttlSeconds - Optional TTL in seconds\n * @returns {Promise<boolean>} True if set (key didn't exist)\n */\nasync function setNX(key, value, ttlSeconds = null) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return false;\n  }\n\n  try {\n    const serializedValue = clientType === 'ioredis' ? JSON.stringify(value) : value;\n\n    if (clientType === 'upstash-rest') {\n      const options = { nx: true };\n      if (ttlSeconds) {\n        options.ex = ttlSeconds;\n      }\n      const result = await redis.set(key, value, options);\n      return result === 'OK';\n    } else {\n      // ioredis: Use SET with NX option\n      const args = [key, serializedValue, 'NX'];\n      if (ttlSeconds) {\n        args.push('EX', ttlSeconds);\n      }\n      const result = await redis.set(...args);\n      return result === 'OK';\n    }\n  } catch (err) {\n    console.error('[Redis] SETNX failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get TTL of a key\n * @param {string} key - Redis key\n * @returns {Promise<number>} TTL in seconds, -1 if no TTL, -2 if key doesn't exist\n */\nasync function ttl(key) {\n  const redis = getRedisClient();\n  if (!redis) {\n    return -2;\n  }\n\n  try {\n    return await redis.ttl(key);\n  } catch (err) {\n    console.error('[Redis] TTL failed:', err.message);\n    return -2;\n  }\n}\n\n/**\n * Gracefully close the Redis connection\n * @returns {Promise<void>}\n */\nasync function close() {\n  if (client && clientType === 'ioredis') {\n    try {\n      await client.quit();\n      console.log('[Redis] ioredis connection closed gracefully');\n    } catch (err) {\n      console.error('[Redis] Error closing connection:', err.message);\n    }\n  }\n  client = null;\n  clientType = 'none';\n  isConnected = false;\n}\n\nmodule.exports = {\n  getRedisClient,\n  isRedisAvailable,\n  getRedisStatus,\n  pingRedis,\n  close,\n  // Convenience methods\n  set,\n  get,\n  exists,\n  del,\n  setNX,\n  ttl\n};\n","numLines":348,"startLine":1,"totalLines":348}}}
{"parentUuid":"32c18164-a131-455c-8d16-3123b260c855","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V5YiEAcFLiNEos8ueiwfX2","type":"tool_result","content":"/Users/imorgado/SPLICE/splice-backend/middleware/errorHandler.js\n/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js\n/Users/imorgado/SPLICE/splice-backend/middleware/requestId.js\n/Users/imorgado/SPLICE/splice-backend/middleware/inputValidation.js\n/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js\n/Users/imorgado/SPLICE/splice-backend/middleware/auth.js"}]},"uuid":"a8badf4a-2cbf-4f20-9449-f2002fa82600","timestamp":"2026-01-11T23:39:09.333Z","toolUseResult":{"filenames":["/Users/imorgado/SPLICE/splice-backend/middleware/errorHandler.js","/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js","/Users/imorgado/SPLICE/splice-backend/middleware/requestId.js","/Users/imorgado/SPLICE/splice-backend/middleware/inputValidation.js","/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js","/Users/imorgado/SPLICE/splice-backend/middleware/auth.js"],"durationMs":16,"numFiles":6,"truncated":false}}
{"parentUuid":"a8badf4a-2cbf-4f20-9449-f2002fa82600","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Nx9VNnm5UvJWgBS91KtmyC","type":"tool_result","content":"     1→/**\n     2→ * Structured Authentication Logger\n     3→ *\n     4→ * Provides consistent JSON-formatted logging for authentication events.\n     5→ * Designed to be captured by log aggregators (CloudWatch, Datadog, etc.)\n     6→ *\n     7→ * Log Format:\n     8→ * {\n     9→ *   timestamp: ISO8601 string,\n    10→ *   event_type: string,\n    11→ *   level: 'info' | 'warn' | 'error',\n    12→ *   user_id: string (masked),\n    13→ *   ip_address: string,\n    14→ *   details: object\n    15→ * }\n    16→ */\n    17→\n    18→/**\n    19→ * Event types for authentication logging\n    20→ */\n    21→const AUTH_EVENTS = {\n    22→  // Login events\n    23→  LOGIN_SUCCESS: 'auth.login.success',\n    24→  LOGIN_FAILED: 'auth.login.failed',\n    25→  LOGIN_RATE_LIMITED: 'auth.login.rate_limited',\n    26→\n    27→  // Logout events\n    28→  LOGOUT_SUCCESS: 'auth.logout.success',\n    29→  LOGOUT_FAILED: 'auth.logout.failed',\n    30→\n    31→  // Token events\n    32→  TOKEN_REFRESH_SUCCESS: 'auth.token.refresh_success',\n    33→  TOKEN_REFRESH_FAILED: 'auth.token.refresh_failed',\n    34→  TOKEN_REVOKED: 'auth.token.revoked',\n    35→  TOKEN_EXPIRED: 'auth.token.expired',\n    36→  TOKEN_INVALID: 'auth.token.invalid',\n    37→  TOKEN_BLACKLISTED: 'auth.token.blacklisted',\n    38→\n    39→  // Security events\n    40→  SUSPICIOUS_ACTIVITY: 'auth.security.suspicious',\n    41→  MULTIPLE_FAILED_ATTEMPTS: 'auth.security.multiple_failures',\n    42→  LEGACY_AUTH_USED: 'auth.security.legacy_header',\n    43→\n    44→  // Admin access events (HIGH-007: Database-backed RBAC)\n    45→  ADMIN_ACCESS_GRANTED: 'auth.admin.access_granted',\n    46→  ADMIN_ACCESS_DENIED: 'auth.admin.access_denied',\n    47→\n    48→  // Blacklist events\n    49→  BLACKLIST_CLEANUP: 'auth.blacklist.cleanup'\n    50→};\n    51→\n    52→/**\n    53→ * Log levels\n    54→ */\n    55→const LOG_LEVELS = {\n    56→  INFO: 'info',\n    57→  WARN: 'warn',\n    58→  ERROR: 'error'\n    59→};\n    60→\n    61→/**\n    62→ * In-memory store for tracking failed login attempts per IP\n    63→ * Used to detect suspicious activity\n    64→ */\n    65→const failedAttempts = new Map();\n    66→\n    67→// Cleanup failed attempts every 15 minutes\n    68→const FAILED_ATTEMPTS_TTL = 15 * 60 * 1000;\n    69→const FAILED_ATTEMPTS_THRESHOLD = 5; // Log suspicious after 5 failures\n    70→\n    71→/**\n    72→ * Extract client IP from request\n    73→ * Handles proxied requests (X-Forwarded-For, X-Real-IP)\n    74→ * @param {Object} req - Express request object\n    75→ * @returns {string} Client IP address\n    76→ */\n    77→function getClientIp(req) {\n    78→  if (!req) return 'unknown';\n    79→\n    80→  // Check for proxied IP (common in production behind load balancers)\n    81→  const forwarded = req.headers['x-forwarded-for'];\n    82→  if (forwarded) {\n    83→    // X-Forwarded-For can contain multiple IPs; take the first (client)\n    84→    return forwarded.split(',')[0].trim();\n    85→  }\n    86→\n    87→  const realIp = req.headers['x-real-ip'];\n    88→  if (realIp) {\n    89→    return realIp;\n    90→  }\n    91→\n    92→  // Direct connection\n    93→  return req.ip || req.connection?.remoteAddress || 'unknown';\n    94→}\n    95→\n    96→/**\n    97→ * Mask sensitive data for logging\n    98→ * @param {string} data - Sensitive string to mask\n    99→ * @param {string} type - Type of data ('user_id', 'email', 'token', 'jti', 'license_key')\n   100→ * @returns {string} Masked string\n   101→ */\n   102→function maskData(data, type = 'generic') {\n   103→  if (!data || typeof data !== 'string') {\n   104→    return '[empty]';\n   105→  }\n   106→\n   107→  switch (type) {\n   108→    case 'user_id':\n   109→      // Customer ID: cus_xxxx -> cus_xxxx****\n   110→      if (data.startsWith('cus_') && data.length > 10) {\n   111→        return `cus_${data.slice(4, 8)}****`;\n   112→      }\n   113→      return 'cus_****';\n   114→\n   115→    case 'email':\n   116→      if (data.includes('@')) {\n   117→        const [local, domain] = data.split('@');\n   118→        const maskedLocal = local.length > 2\n   119→          ? `${local[0]}***${local[local.length - 1]}`\n   120→          : '***';\n   121→        return `${maskedLocal}@${domain}`;\n   122→      }\n   123→      return '***@***.***';\n   124→\n   125→    case 'jti':\n   126→      // JWT ID: show first 8 chars\n   127→      if (data.length > 8) {\n   128→        return `${data.slice(0, 8)}...`;\n   129→      }\n   130→      return data;\n   131→\n   132→    case 'token':\n   133→      // JWT token: show first 10 chars\n   134→      if (data.startsWith('eyJ') && data.length > 10) {\n   135→        return `${data.slice(0, 10)}...`;\n   136→      }\n   137→      return '[token]';\n   138→\n   139→    case 'license_key':\n   140→      // License key: SPLICE-XXXX-XXXX-XXXX-XXXX -> SPLICE-XXXX-****-****-****\n   141→      if (data.startsWith('SPLICE-')) {\n   142→        const parts = data.split('-');\n   143→        if (parts.length === 5) {\n   144→          return `${parts[0]}-${parts[1]}-****-****-****`;\n   145→        }\n   146→      }\n   147→      return 'SPLICE-****';\n   148→\n   149→    default:\n   150→      // Generic: show first 4 chars\n   151→      if (data.length > 8) {\n   152→        return `${data.slice(0, 4)}****`;\n   153→      }\n   154→      return '****';\n   155→  }\n   156→}\n   157→\n   158→/**\n   159→ * Create a structured log entry\n   160→ * @param {string} eventType - Event type from AUTH_EVENTS\n   161→ * @param {string} level - Log level from LOG_LEVELS\n   162→ * @param {Object} options - Log options\n   163→ * @returns {Object} Structured log object\n   164→ */\n   165→function createLogEntry(eventType, level, options = {}) {\n   166→  const {\n   167→    userId = null,\n   168→    ipAddress = 'unknown',\n   169→    jti = null,\n   170→    reason = null,\n   171→    email = null,\n   172→    tier = null,\n   173→    details = {}\n   174→  } = options;\n   175→\n   176→  const entry = {\n   177→    timestamp: new Date().toISOString(),\n   178→    event_type: eventType,\n   179→    level,\n   180→    service: 'splice-auth'\n   181→  };\n   182→\n   183→  // Add user context if available (always masked)\n   184→  if (userId) {\n   185→    entry.user_id = maskData(userId, 'user_id');\n   186→  }\n   187→\n   188→  // Add IP address\n   189→  entry.ip_address = ipAddress;\n   190→\n   191→  // Add optional fields\n   192→  if (jti) {\n   193→    entry.jti = maskData(jti, 'jti');\n   194→  }\n   195→\n   196→  if (reason) {\n   197→    entry.reason = reason;\n   198→  }\n   199→\n   200→  if (email) {\n   201→    entry.email = maskData(email, 'email');\n   202→  }\n   203→\n   204→  if (tier) {\n   205→    entry.tier = tier;\n   206→  }\n   207→\n   208→  // Add any additional details\n   209→  if (Object.keys(details).length > 0) {\n   210→    entry.details = details;\n   211→  }\n   212→\n   213→  return entry;\n   214→}\n   215→\n   216→/**\n   217→ * Output a structured log entry\n   218→ * @param {Object} entry - Log entry object\n   219→ */\n   220→function outputLog(entry) {\n   221→  const jsonLog = JSON.stringify(entry);\n   222→\n   223→  switch (entry.level) {\n   224→    case LOG_LEVELS.ERROR:\n   225→      console.error(jsonLog);\n   226→      break;\n   227→    case LOG_LEVELS.WARN:\n   228→      console.warn(jsonLog);\n   229→      break;\n   230→    default:\n   231→      console.log(jsonLog);\n   232→  }\n   233→}\n   234→\n   235→/**\n   236→ * Track failed login attempt for an IP\n   237→ * @param {string} ip - Client IP address\n   238→ * @returns {number} Number of failed attempts from this IP\n   239→ */\n   240→function trackFailedAttempt(ip) {\n   241→  const now = Date.now();\n   242→  const existing = failedAttempts.get(ip) || { count: 0, firstAttempt: now };\n   243→\n   244→  // Reset if TTL expired\n   245→  if (now - existing.firstAttempt > FAILED_ATTEMPTS_TTL) {\n   246→    existing.count = 0;\n   247→    existing.firstAttempt = now;\n   248→  }\n   249→\n   250→  existing.count++;\n   251→  existing.lastAttempt = now;\n   252→  failedAttempts.set(ip, existing);\n   253→\n   254→  return existing.count;\n   255→}\n   256→\n   257→/**\n   258→ * Clear failed attempts for an IP (on successful login)\n   259→ * @param {string} ip - Client IP address\n   260→ */\n   261→function clearFailedAttempts(ip) {\n   262→  failedAttempts.delete(ip);\n   263→}\n   264→\n   265→/**\n   266→ * Get failed attempts info for an IP\n   267→ * @param {string} ip - Client IP address\n   268→ * @returns {Object|null} Failed attempts info or null\n   269→ */\n   270→function getFailedAttempts(ip) {\n   271→  return failedAttempts.get(ip) || null;\n   272→}\n   273→\n   274→// ============================================================================\n   275→// Public Logging Functions\n   276→// ============================================================================\n   277→\n   278→/**\n   279→ * Log successful login\n   280→ * @param {Object} req - Express request object\n   281→ * @param {string} userId - Customer ID\n   282→ * @param {Object} options - Additional options (email, tier)\n   283→ */\n   284→function logLoginSuccess(req, userId, options = {}) {\n   285→  const ip = getClientIp(req);\n   286→  clearFailedAttempts(ip); // Reset failed attempts on success\n   287→\n   288→  const entry = createLogEntry(AUTH_EVENTS.LOGIN_SUCCESS, LOG_LEVELS.INFO, {\n   289→    userId,\n   290→    ipAddress: ip,\n   291→    email: options.email,\n   292→    tier: options.tier\n   293→  });\n   294→\n   295→  outputLog(entry);\n   296→}\n   297→\n   298→/**\n   299→ * Log failed login attempt\n   300→ * @param {Object} req - Express request object\n   301→ * @param {string} reason - Reason for failure\n   302→ * @param {Object} options - Additional options (licenseKey)\n   303→ */\n   304→function logLoginFailed(req, reason, options = {}) {\n   305→  const ip = getClientIp(req);\n   306→  const attemptCount = trackFailedAttempt(ip);\n   307→\n   308→  const entry = createLogEntry(AUTH_EVENTS.LOGIN_FAILED, LOG_LEVELS.WARN, {\n   309→    ipAddress: ip,\n   310→    reason,\n   311→    details: {\n   312→      attempt_count: attemptCount,\n   313→      license_key_provided: !!options.licenseKey,\n   314→      license_key_masked: options.licenseKey ? maskData(options.licenseKey, 'license_key') : null\n   315→    }\n   316→  });\n   317→\n   318→  outputLog(entry);\n   319→\n   320→  // Log suspicious activity if threshold exceeded\n   321→  if (attemptCount >= FAILED_ATTEMPTS_THRESHOLD) {\n   322→    logSuspiciousActivity(req, 'multiple_failed_logins', {\n   323→      attempt_count: attemptCount,\n   324→      window_minutes: Math.floor(FAILED_ATTEMPTS_TTL / 60000)\n   325→    });\n   326→  }\n   327→}\n   328→\n   329→/**\n   330→ * Log successful logout\n   331→ * @param {Object} req - Express request object\n   332→ * @param {string} userId - Customer ID\n   333→ * @param {Object} options - Additional options (jti, refreshTokenRevoked)\n   334→ */\n   335→function logLogoutSuccess(req, userId, options = {}) {\n   336→  const entry = createLogEntry(AUTH_EVENTS.LOGOUT_SUCCESS, LOG_LEVELS.INFO, {\n   337→    userId,\n   338→    ipAddress: getClientIp(req),\n   339→    jti: options.jti,\n   340→    details: {\n   341→      refresh_token_revoked: !!options.refreshTokenRevoked\n   342→    }\n   343→  });\n   344→\n   345→  outputLog(entry);\n   346→}\n   347→\n   348→/**\n   349→ * Log token refresh success\n   350→ * @param {Object} req - Express request object\n   351→ * @param {string} userId - Customer ID\n   352→ */\n   353→function logTokenRefreshSuccess(req, userId) {\n   354→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_SUCCESS, LOG_LEVELS.INFO, {\n   355→    userId,\n   356→    ipAddress: getClientIp(req)\n   357→  });\n   358→\n   359→  outputLog(entry);\n   360→}\n   361→\n   362→/**\n   363→ * Log token refresh failure\n   364→ * @param {Object} req - Express request object\n   365→ * @param {string} reason - Reason for failure\n   366→ */\n   367→function logTokenRefreshFailed(req, reason) {\n   368→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_FAILED, LOG_LEVELS.WARN, {\n   369→    ipAddress: getClientIp(req),\n   370→    reason\n   371→  });\n   372→\n   373→  outputLog(entry);\n   374→}\n   375→\n   376→/**\n   377→ * Log token revocation (blacklisting)\n   378→ * @param {string} userId - Customer ID\n   379→ * @param {string} jti - JWT ID\n   380→ * @param {string} reason - Reason for revocation (logout, security, admin)\n   381→ */\n   382→function logTokenRevoked(userId, jti, reason = 'logout') {\n   383→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REVOKED, LOG_LEVELS.INFO, {\n   384→    userId,\n   385→    jti,\n   386→    reason,\n   387→    ipAddress: 'internal'\n   388→  });\n   389→\n   390→  outputLog(entry);\n   391→}\n   392→\n   393→/**\n   394→ * Log token validation failure (expired)\n   395→ * @param {Object} req - Express request object\n   396→ */\n   397→function logTokenExpired(req) {\n   398→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_EXPIRED, LOG_LEVELS.INFO, {\n   399→    ipAddress: getClientIp(req)\n   400→  });\n   401→\n   402→  outputLog(entry);\n   403→}\n   404→\n   405→/**\n   406→ * Log token validation failure (invalid signature/format)\n   407→ * @param {Object} req - Express request object\n   408→ * @param {string} reason - Specific reason\n   409→ */\n   410→function logTokenInvalid(req, reason) {\n   411→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_INVALID, LOG_LEVELS.WARN, {\n   412→    ipAddress: getClientIp(req),\n   413→    reason\n   414→  });\n   415→\n   416→  outputLog(entry);\n   417→}\n   418→\n   419→/**\n   420→ * Log blacklisted token access attempt\n   421→ * @param {Object} req - Express request object\n   422→ * @param {string} jti - JWT ID\n   423→ */\n   424→function logTokenBlacklisted(req, jti) {\n   425→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_BLACKLISTED, LOG_LEVELS.WARN, {\n   426→    ipAddress: getClientIp(req),\n   427→    jti,\n   428→    reason: 'Token has been revoked'\n   429→  });\n   430→\n   431→  outputLog(entry);\n   432→}\n   433→\n   434→/**\n   435→ * Log suspicious activity\n   436→ * @param {Object} req - Express request object\n   437→ * @param {string} activity - Type of suspicious activity\n   438→ * @param {Object} details - Additional details\n   439→ */\n   440→function logSuspiciousActivity(req, activity, details = {}) {\n   441→  const entry = createLogEntry(AUTH_EVENTS.SUSPICIOUS_ACTIVITY, LOG_LEVELS.WARN, {\n   442→    ipAddress: getClientIp(req),\n   443→    reason: activity,\n   444→    details\n   445→  });\n   446→\n   447→  outputLog(entry);\n   448→}\n   449→\n   450→/**\n   451→ * Log use of legacy authentication header\n   452→ * @param {Object} req - Express request object\n   453→ * @param {string} userId - Customer ID\n   454→ */\n   455→function logLegacyAuthUsed(req, userId) {\n   456→  const entry = createLogEntry(AUTH_EVENTS.LEGACY_AUTH_USED, LOG_LEVELS.WARN, {\n   457→    userId,\n   458→    ipAddress: getClientIp(req),\n   459→    reason: 'x-stripe-customer-id header used instead of JWT'\n   460→  });\n   461→\n   462→  outputLog(entry);\n   463→}\n   464→\n   465→/**\n   466→ * Log blacklist cleanup\n   467→ * @param {number} removedCount - Number of entries removed\n   468→ * @param {number} remainingCount - Number of entries remaining\n   469→ */\n   470→function logBlacklistCleanup(removedCount, remainingCount) {\n   471→  const entry = createLogEntry(AUTH_EVENTS.BLACKLIST_CLEANUP, LOG_LEVELS.INFO, {\n   472→    ipAddress: 'internal',\n   473→    details: {\n   474→      removed_count: removedCount,\n   475→      remaining_count: remainingCount\n   476→    }\n   477→  });\n   478→\n   479→  outputLog(entry);\n   480→}\n   481→\n   482→/**\n   483→ * Log successful admin access (HIGH-007: Database-backed RBAC)\n   484→ * @param {Object} req - Express request object\n   485→ */\n   486→function logAdminAccess(req) {\n   487→  const entry = createLogEntry(AUTH_EVENTS.ADMIN_ACCESS_GRANTED, LOG_LEVELS.INFO, {\n   488→    userId: req.stripeCustomerId || req.user?.id,\n   489→    ipAddress: getClientIp(req),\n   490→    details: {\n   491→      path: req.path,\n   492→      method: req.method,\n   493→      user_agent: req.headers?.['user-agent']\n   494→    }\n   495→  });\n   496→\n   497→  outputLog(entry);\n   498→}\n   499→\n   500→/**\n   501→ * Log denied admin access attempt (HIGH-007: Database-backed RBAC)\n   502→ * @param {Object} req - Express request object\n   503→ * @param {string} reason - Reason for denial\n   504→ */\n   505→function logAdminAccessDenied(req, reason) {\n   506→  const entry = createLogEntry(AUTH_EVENTS.ADMIN_ACCESS_DENIED, LOG_LEVELS.WARN, {\n   507→    userId: req.stripeCustomerId || req.user?.id,\n   508→    ipAddress: getClientIp(req),\n   509→    reason,\n   510→    details: {\n   511→      path: req.path,\n   512→      method: req.method,\n   513→      user_agent: req.headers?.['user-agent']\n   514→    }\n   515→  });\n   516→\n   517→  outputLog(entry);\n   518→}\n   519→\n   520→// Cleanup interval for failed attempts tracking\n   521→setInterval(() => {\n   522→  const now = Date.now();\n   523→  for (const [ip, data] of failedAttempts.entries()) {\n   524→    if (now - data.lastAttempt > FAILED_ATTEMPTS_TTL) {\n   525→      failedAttempts.delete(ip);\n   526→    }\n   527→  }\n   528→}, FAILED_ATTEMPTS_TTL);\n   529→\n   530→module.exports = {\n   531→  // Event types\n   532→  AUTH_EVENTS,\n   533→  LOG_LEVELS,\n   534→\n   535→  // Utility functions\n   536→  getClientIp,\n   537→  maskData,\n   538→\n   539→  // Failed attempts tracking\n   540→  trackFailedAttempt,\n   541→  clearFailedAttempts,\n   542→  getFailedAttempts,\n   543→  FAILED_ATTEMPTS_THRESHOLD,\n   544→\n   545→  // Logging functions\n   546→  logLoginSuccess,\n   547→  logLoginFailed,\n   548→  logLogoutSuccess,\n   549→  logTokenRefreshSuccess,\n   550→  logTokenRefreshFailed,\n   551→  logTokenRevoked,\n   552→  logTokenExpired,\n   553→  logTokenInvalid,\n   554→  logTokenBlacklisted,\n   555→  logSuspiciousActivity,\n   556→  logLegacyAuthUsed,\n   557→  logBlacklistCleanup,\n   558→  // HIGH-007: Admin access logging\n   559→  logAdminAccess,\n   560→  logAdminAccessDenied\n   561→};\n   562→\n\n</system-reminder>\n"}]},"uuid":"6f5a406c-b785-4f22-ae5e-28adf5dfb61a","timestamp":"2026-01-11T23:39:09.323Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/utils/authLogger.js","content":"/**\n * Structured Authentication Logger\n *\n * Provides consistent JSON-formatted logging for authentication events.\n * Designed to be captured by log aggregators (CloudWatch, Datadog, etc.)\n *\n * Log Format:\n * {\n *   timestamp: ISO8601 string,\n *   event_type: string,\n *   level: 'info' | 'warn' | 'error',\n *   user_id: string (masked),\n *   ip_address: string,\n *   details: object\n * }\n */\n\n/**\n * Event types for authentication logging\n */\nconst AUTH_EVENTS = {\n  // Login events\n  LOGIN_SUCCESS: 'auth.login.success',\n  LOGIN_FAILED: 'auth.login.failed',\n  LOGIN_RATE_LIMITED: 'auth.login.rate_limited',\n\n  // Logout events\n  LOGOUT_SUCCESS: 'auth.logout.success',\n  LOGOUT_FAILED: 'auth.logout.failed',\n\n  // Token events\n  TOKEN_REFRESH_SUCCESS: 'auth.token.refresh_success',\n  TOKEN_REFRESH_FAILED: 'auth.token.refresh_failed',\n  TOKEN_REVOKED: 'auth.token.revoked',\n  TOKEN_EXPIRED: 'auth.token.expired',\n  TOKEN_INVALID: 'auth.token.invalid',\n  TOKEN_BLACKLISTED: 'auth.token.blacklisted',\n\n  // Security events\n  SUSPICIOUS_ACTIVITY: 'auth.security.suspicious',\n  MULTIPLE_FAILED_ATTEMPTS: 'auth.security.multiple_failures',\n  LEGACY_AUTH_USED: 'auth.security.legacy_header',\n\n  // Admin access events (HIGH-007: Database-backed RBAC)\n  ADMIN_ACCESS_GRANTED: 'auth.admin.access_granted',\n  ADMIN_ACCESS_DENIED: 'auth.admin.access_denied',\n\n  // Blacklist events\n  BLACKLIST_CLEANUP: 'auth.blacklist.cleanup'\n};\n\n/**\n * Log levels\n */\nconst LOG_LEVELS = {\n  INFO: 'info',\n  WARN: 'warn',\n  ERROR: 'error'\n};\n\n/**\n * In-memory store for tracking failed login attempts per IP\n * Used to detect suspicious activity\n */\nconst failedAttempts = new Map();\n\n// Cleanup failed attempts every 15 minutes\nconst FAILED_ATTEMPTS_TTL = 15 * 60 * 1000;\nconst FAILED_ATTEMPTS_THRESHOLD = 5; // Log suspicious after 5 failures\n\n/**\n * Extract client IP from request\n * Handles proxied requests (X-Forwarded-For, X-Real-IP)\n * @param {Object} req - Express request object\n * @returns {string} Client IP address\n */\nfunction getClientIp(req) {\n  if (!req) return 'unknown';\n\n  // Check for proxied IP (common in production behind load balancers)\n  const forwarded = req.headers['x-forwarded-for'];\n  if (forwarded) {\n    // X-Forwarded-For can contain multiple IPs; take the first (client)\n    return forwarded.split(',')[0].trim();\n  }\n\n  const realIp = req.headers['x-real-ip'];\n  if (realIp) {\n    return realIp;\n  }\n\n  // Direct connection\n  return req.ip || req.connection?.remoteAddress || 'unknown';\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} data - Sensitive string to mask\n * @param {string} type - Type of data ('user_id', 'email', 'token', 'jti', 'license_key')\n * @returns {string} Masked string\n */\nfunction maskData(data, type = 'generic') {\n  if (!data || typeof data !== 'string') {\n    return '[empty]';\n  }\n\n  switch (type) {\n    case 'user_id':\n      // Customer ID: cus_xxxx -> cus_xxxx****\n      if (data.startsWith('cus_') && data.length > 10) {\n        return `cus_${data.slice(4, 8)}****`;\n      }\n      return 'cus_****';\n\n    case 'email':\n      if (data.includes('@')) {\n        const [local, domain] = data.split('@');\n        const maskedLocal = local.length > 2\n          ? `${local[0]}***${local[local.length - 1]}`\n          : '***';\n        return `${maskedLocal}@${domain}`;\n      }\n      return '***@***.***';\n\n    case 'jti':\n      // JWT ID: show first 8 chars\n      if (data.length > 8) {\n        return `${data.slice(0, 8)}...`;\n      }\n      return data;\n\n    case 'token':\n      // JWT token: show first 10 chars\n      if (data.startsWith('eyJ') && data.length > 10) {\n        return `${data.slice(0, 10)}...`;\n      }\n      return '[token]';\n\n    case 'license_key':\n      // License key: SPLICE-XXXX-XXXX-XXXX-XXXX -> SPLICE-XXXX-****-****-****\n      if (data.startsWith('SPLICE-')) {\n        const parts = data.split('-');\n        if (parts.length === 5) {\n          return `${parts[0]}-${parts[1]}-****-****-****`;\n        }\n      }\n      return 'SPLICE-****';\n\n    default:\n      // Generic: show first 4 chars\n      if (data.length > 8) {\n        return `${data.slice(0, 4)}****`;\n      }\n      return '****';\n  }\n}\n\n/**\n * Create a structured log entry\n * @param {string} eventType - Event type from AUTH_EVENTS\n * @param {string} level - Log level from LOG_LEVELS\n * @param {Object} options - Log options\n * @returns {Object} Structured log object\n */\nfunction createLogEntry(eventType, level, options = {}) {\n  const {\n    userId = null,\n    ipAddress = 'unknown',\n    jti = null,\n    reason = null,\n    email = null,\n    tier = null,\n    details = {}\n  } = options;\n\n  const entry = {\n    timestamp: new Date().toISOString(),\n    event_type: eventType,\n    level,\n    service: 'splice-auth'\n  };\n\n  // Add user context if available (always masked)\n  if (userId) {\n    entry.user_id = maskData(userId, 'user_id');\n  }\n\n  // Add IP address\n  entry.ip_address = ipAddress;\n\n  // Add optional fields\n  if (jti) {\n    entry.jti = maskData(jti, 'jti');\n  }\n\n  if (reason) {\n    entry.reason = reason;\n  }\n\n  if (email) {\n    entry.email = maskData(email, 'email');\n  }\n\n  if (tier) {\n    entry.tier = tier;\n  }\n\n  // Add any additional details\n  if (Object.keys(details).length > 0) {\n    entry.details = details;\n  }\n\n  return entry;\n}\n\n/**\n * Output a structured log entry\n * @param {Object} entry - Log entry object\n */\nfunction outputLog(entry) {\n  const jsonLog = JSON.stringify(entry);\n\n  switch (entry.level) {\n    case LOG_LEVELS.ERROR:\n      console.error(jsonLog);\n      break;\n    case LOG_LEVELS.WARN:\n      console.warn(jsonLog);\n      break;\n    default:\n      console.log(jsonLog);\n  }\n}\n\n/**\n * Track failed login attempt for an IP\n * @param {string} ip - Client IP address\n * @returns {number} Number of failed attempts from this IP\n */\nfunction trackFailedAttempt(ip) {\n  const now = Date.now();\n  const existing = failedAttempts.get(ip) || { count: 0, firstAttempt: now };\n\n  // Reset if TTL expired\n  if (now - existing.firstAttempt > FAILED_ATTEMPTS_TTL) {\n    existing.count = 0;\n    existing.firstAttempt = now;\n  }\n\n  existing.count++;\n  existing.lastAttempt = now;\n  failedAttempts.set(ip, existing);\n\n  return existing.count;\n}\n\n/**\n * Clear failed attempts for an IP (on successful login)\n * @param {string} ip - Client IP address\n */\nfunction clearFailedAttempts(ip) {\n  failedAttempts.delete(ip);\n}\n\n/**\n * Get failed attempts info for an IP\n * @param {string} ip - Client IP address\n * @returns {Object|null} Failed attempts info or null\n */\nfunction getFailedAttempts(ip) {\n  return failedAttempts.get(ip) || null;\n}\n\n// ============================================================================\n// Public Logging Functions\n// ============================================================================\n\n/**\n * Log successful login\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n * @param {Object} options - Additional options (email, tier)\n */\nfunction logLoginSuccess(req, userId, options = {}) {\n  const ip = getClientIp(req);\n  clearFailedAttempts(ip); // Reset failed attempts on success\n\n  const entry = createLogEntry(AUTH_EVENTS.LOGIN_SUCCESS, LOG_LEVELS.INFO, {\n    userId,\n    ipAddress: ip,\n    email: options.email,\n    tier: options.tier\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log failed login attempt\n * @param {Object} req - Express request object\n * @param {string} reason - Reason for failure\n * @param {Object} options - Additional options (licenseKey)\n */\nfunction logLoginFailed(req, reason, options = {}) {\n  const ip = getClientIp(req);\n  const attemptCount = trackFailedAttempt(ip);\n\n  const entry = createLogEntry(AUTH_EVENTS.LOGIN_FAILED, LOG_LEVELS.WARN, {\n    ipAddress: ip,\n    reason,\n    details: {\n      attempt_count: attemptCount,\n      license_key_provided: !!options.licenseKey,\n      license_key_masked: options.licenseKey ? maskData(options.licenseKey, 'license_key') : null\n    }\n  });\n\n  outputLog(entry);\n\n  // Log suspicious activity if threshold exceeded\n  if (attemptCount >= FAILED_ATTEMPTS_THRESHOLD) {\n    logSuspiciousActivity(req, 'multiple_failed_logins', {\n      attempt_count: attemptCount,\n      window_minutes: Math.floor(FAILED_ATTEMPTS_TTL / 60000)\n    });\n  }\n}\n\n/**\n * Log successful logout\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n * @param {Object} options - Additional options (jti, refreshTokenRevoked)\n */\nfunction logLogoutSuccess(req, userId, options = {}) {\n  const entry = createLogEntry(AUTH_EVENTS.LOGOUT_SUCCESS, LOG_LEVELS.INFO, {\n    userId,\n    ipAddress: getClientIp(req),\n    jti: options.jti,\n    details: {\n      refresh_token_revoked: !!options.refreshTokenRevoked\n    }\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token refresh success\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n */\nfunction logTokenRefreshSuccess(req, userId) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_SUCCESS, LOG_LEVELS.INFO, {\n    userId,\n    ipAddress: getClientIp(req)\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token refresh failure\n * @param {Object} req - Express request object\n * @param {string} reason - Reason for failure\n */\nfunction logTokenRefreshFailed(req, reason) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_FAILED, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    reason\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token revocation (blacklisting)\n * @param {string} userId - Customer ID\n * @param {string} jti - JWT ID\n * @param {string} reason - Reason for revocation (logout, security, admin)\n */\nfunction logTokenRevoked(userId, jti, reason = 'logout') {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REVOKED, LOG_LEVELS.INFO, {\n    userId,\n    jti,\n    reason,\n    ipAddress: 'internal'\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token validation failure (expired)\n * @param {Object} req - Express request object\n */\nfunction logTokenExpired(req) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_EXPIRED, LOG_LEVELS.INFO, {\n    ipAddress: getClientIp(req)\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token validation failure (invalid signature/format)\n * @param {Object} req - Express request object\n * @param {string} reason - Specific reason\n */\nfunction logTokenInvalid(req, reason) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_INVALID, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    reason\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log blacklisted token access attempt\n * @param {Object} req - Express request object\n * @param {string} jti - JWT ID\n */\nfunction logTokenBlacklisted(req, jti) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_BLACKLISTED, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    jti,\n    reason: 'Token has been revoked'\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log suspicious activity\n * @param {Object} req - Express request object\n * @param {string} activity - Type of suspicious activity\n * @param {Object} details - Additional details\n */\nfunction logSuspiciousActivity(req, activity, details = {}) {\n  const entry = createLogEntry(AUTH_EVENTS.SUSPICIOUS_ACTIVITY, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    reason: activity,\n    details\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log use of legacy authentication header\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n */\nfunction logLegacyAuthUsed(req, userId) {\n  const entry = createLogEntry(AUTH_EVENTS.LEGACY_AUTH_USED, LOG_LEVELS.WARN, {\n    userId,\n    ipAddress: getClientIp(req),\n    reason: 'x-stripe-customer-id header used instead of JWT'\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log blacklist cleanup\n * @param {number} removedCount - Number of entries removed\n * @param {number} remainingCount - Number of entries remaining\n */\nfunction logBlacklistCleanup(removedCount, remainingCount) {\n  const entry = createLogEntry(AUTH_EVENTS.BLACKLIST_CLEANUP, LOG_LEVELS.INFO, {\n    ipAddress: 'internal',\n    details: {\n      removed_count: removedCount,\n      remaining_count: remainingCount\n    }\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log successful admin access (HIGH-007: Database-backed RBAC)\n * @param {Object} req - Express request object\n */\nfunction logAdminAccess(req) {\n  const entry = createLogEntry(AUTH_EVENTS.ADMIN_ACCESS_GRANTED, LOG_LEVELS.INFO, {\n    userId: req.stripeCustomerId || req.user?.id,\n    ipAddress: getClientIp(req),\n    details: {\n      path: req.path,\n      method: req.method,\n      user_agent: req.headers?.['user-agent']\n    }\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log denied admin access attempt (HIGH-007: Database-backed RBAC)\n * @param {Object} req - Express request object\n * @param {string} reason - Reason for denial\n */\nfunction logAdminAccessDenied(req, reason) {\n  const entry = createLogEntry(AUTH_EVENTS.ADMIN_ACCESS_DENIED, LOG_LEVELS.WARN, {\n    userId: req.stripeCustomerId || req.user?.id,\n    ipAddress: getClientIp(req),\n    reason,\n    details: {\n      path: req.path,\n      method: req.method,\n      user_agent: req.headers?.['user-agent']\n    }\n  });\n\n  outputLog(entry);\n}\n\n// Cleanup interval for failed attempts tracking\nsetInterval(() => {\n  const now = Date.now();\n  for (const [ip, data] of failedAttempts.entries()) {\n    if (now - data.lastAttempt > FAILED_ATTEMPTS_TTL) {\n      failedAttempts.delete(ip);\n    }\n  }\n}, FAILED_ATTEMPTS_TTL);\n\nmodule.exports = {\n  // Event types\n  AUTH_EVENTS,\n  LOG_LEVELS,\n\n  // Utility functions\n  getClientIp,\n  maskData,\n\n  // Failed attempts tracking\n  trackFailedAttempt,\n  clearFailedAttempts,\n  getFailedAttempts,\n  FAILED_ATTEMPTS_THRESHOLD,\n\n  // Logging functions\n  logLoginSuccess,\n  logLoginFailed,\n  logLogoutSuccess,\n  logTokenRefreshSuccess,\n  logTokenRefreshFailed,\n  logTokenRevoked,\n  logTokenExpired,\n  logTokenInvalid,\n  logTokenBlacklisted,\n  logSuspiciousActivity,\n  logLegacyAuthUsed,\n  logBlacklistCleanup,\n  // HIGH-007: Admin access logging\n  logAdminAccess,\n  logAdminAccessDenied\n};\n","numLines":562,"startLine":1,"totalLines":562}}}
{"parentUuid":"6f5a406c-b785-4f22-ae5e-28adf5dfb61a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kscc96kBmHGCD41GC8wSdL","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also check the additional middleware files for completeness:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":10845,"cache_read_input_tokens":57472,"cache_creation":{"ephemeral_5m_input_tokens":10845,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UN2z9v2sk5cHSDGLYL","type":"assistant","uuid":"a39cca8c-87bd-4d9c-a6c7-4ab24ab3d1e7","timestamp":"2026-01-11T23:39:12.992Z"}
{"parentUuid":"a39cca8c-87bd-4d9c-a6c7-4ab24ab3d1e7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kscc96kBmHGCD41GC8wSdL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015ktuv4i6dZG8t9gCqwYtZ3","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/requestId.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":10845,"cache_read_input_tokens":57472,"cache_creation":{"ephemeral_5m_input_tokens":10845,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UN2z9v2sk5cHSDGLYL","type":"assistant","uuid":"4e168a40-be6f-4802-8458-db4a5f0eb72e","timestamp":"2026-01-11T23:39:13.885Z"}
{"parentUuid":"4e168a40-be6f-4802-8458-db4a5f0eb72e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kscc96kBmHGCD41GC8wSdL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012hwnz3fTtp9PsDVWSKAg8p","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/inputValidation.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":10845,"cache_read_input_tokens":57472,"cache_creation":{"ephemeral_5m_input_tokens":10845,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UN2z9v2sk5cHSDGLYL","type":"assistant","uuid":"3f85f364-8008-4562-a95c-7c755ee53c94","timestamp":"2026-01-11T23:39:14.272Z"}
{"parentUuid":"3f85f364-8008-4562-a95c-7c755ee53c94","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Kscc96kBmHGCD41GC8wSdL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KMkEfieAVso3XcicA6isgb","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/errorHandler.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":10845,"cache_read_input_tokens":57472,"cache_creation":{"ephemeral_5m_input_tokens":10845,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UN2z9v2sk5cHSDGLYL","type":"assistant","uuid":"de47859c-81f6-49d9-9051-729ebb2941bf","timestamp":"2026-01-11T23:39:14.660Z"}
{"parentUuid":"de47859c-81f6-49d9-9051-729ebb2941bf","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015ktuv4i6dZG8t9gCqwYtZ3","type":"tool_result","content":"     1→/**\n     2→ * Request ID Middleware (MEDIUM-005)\n     3→ * \n     4→ * Adds a unique request ID to each request for tracing through logs.\n     5→ * Uses X-Request-ID header if provided, otherwise generates a new UUID.\n     6→ * \n     7→ * This middleware should be added FIRST in the middleware chain\n     8→ * to ensure all logs have access to the request ID.\n     9→ * \n    10→ * Usage in server.js:\n    11→ *   const { requestIdMiddleware } = require('./middleware/requestId');\n    12→ *   app.use(requestIdMiddleware);\n    13→ */\n    14→\n    15→const { randomUUID } = require('crypto');\n    16→\n    17→/**\n    18→ * Request ID middleware\n    19→ * Attaches a unique requestId to each request and response\n    20→ * \n    21→ * @param {Object} req - Express request object\n    22→ * @param {Object} res - Express response object\n    23→ * @param {Function} next - Express next function\n    24→ */\n    25→function requestIdMiddleware(req, res, next) {\n    26→  // Use incoming header or generate new UUID\n    27→  // Support both X-Request-ID and X-Request-Id (case variations)\n    28→  req.requestId = req.headers['x-request-id'] || \n    29→                  req.headers['x-request-Id'] || \n    30→                  randomUUID();\n    31→  \n    32→  // Add request ID to response headers for client correlation\n    33→  res.setHeader('X-Request-ID', req.requestId);\n    34→  \n    35→  // Also set on res.locals for template access\n    36→  res.locals.requestId = req.requestId;\n    37→  \n    38→  next();\n    39→}\n    40→\n    41→/**\n    42→ * Get request ID from an Express request object\n    43→ * Falls back to generating a new one if not present\n    44→ * \n    45→ * @param {Object} req - Express request object (optional)\n    46→ * @returns {string} Request ID\n    47→ */\n    48→function getRequestId(req) {\n    49→  if (req && req.requestId) {\n    50→    return req.requestId;\n    51→  }\n    52→  return randomUUID();\n    53→}\n    54→\n    55→module.exports = {\n    56→  requestIdMiddleware,\n    57→  getRequestId\n    58→};\n    59→\n\n</system-reminder>\n"}]},"uuid":"adc4334d-458f-41ac-bdc8-e93d9e23a52b","timestamp":"2026-01-11T23:39:14.711Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/requestId.js","content":"/**\n * Request ID Middleware (MEDIUM-005)\n * \n * Adds a unique request ID to each request for tracing through logs.\n * Uses X-Request-ID header if provided, otherwise generates a new UUID.\n * \n * This middleware should be added FIRST in the middleware chain\n * to ensure all logs have access to the request ID.\n * \n * Usage in server.js:\n *   const { requestIdMiddleware } = require('./middleware/requestId');\n *   app.use(requestIdMiddleware);\n */\n\nconst { randomUUID } = require('crypto');\n\n/**\n * Request ID middleware\n * Attaches a unique requestId to each request and response\n * \n * @param {Object} req - Express request object\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nfunction requestIdMiddleware(req, res, next) {\n  // Use incoming header or generate new UUID\n  // Support both X-Request-ID and X-Request-Id (case variations)\n  req.requestId = req.headers['x-request-id'] || \n                  req.headers['x-request-Id'] || \n                  randomUUID();\n  \n  // Add request ID to response headers for client correlation\n  res.setHeader('X-Request-ID', req.requestId);\n  \n  // Also set on res.locals for template access\n  res.locals.requestId = req.requestId;\n  \n  next();\n}\n\n/**\n * Get request ID from an Express request object\n * Falls back to generating a new one if not present\n * \n * @param {Object} req - Express request object (optional)\n * @returns {string} Request ID\n */\nfunction getRequestId(req) {\n  if (req && req.requestId) {\n    return req.requestId;\n  }\n  return randomUUID();\n}\n\nmodule.exports = {\n  requestIdMiddleware,\n  getRequestId\n};\n","numLines":59,"startLine":1,"totalLines":59}}}
{"parentUuid":"adc4334d-458f-41ac-bdc8-e93d9e23a52b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012hwnz3fTtp9PsDVWSKAg8p","type":"tool_result","content":"     1→/**\n     2→ * Input Validation Middleware\n     3→ *\n     4→ * Provides type validation and sanitization for API request parameters\n     5→ * to prevent type confusion attacks and ensure data integrity.\n     6→ *\n     7→ * SECURITY ENHANCEMENTS:\n     8→ * - Email validation with RFC-compliant regex\n     9→ * - File upload validation (type, size, extension whitelist)\n    10→ * - Input sanitization to prevent injection attacks\n    11→ * - Request body size enforcement\n    12→ * - Path traversal prevention\n    13→ */\n    14→\n    15→/**\n    16→ * Validate that a value is a non-empty string\n    17→ * @param {any} value - Value to validate\n    18→ * @param {string} fieldName - Name of the field for error messages\n    19→ * @returns {{valid: boolean, value?: string, error?: string}}\n    20→ */\n    21→function validateString(value, fieldName, options = {}) {\n    22→  const { maxLength = 10000, allowEmpty = false } = options;\n    23→\n    24→  if (value === null || value === undefined) {\n    25→    return { valid: false, error: `${fieldName} is required` };\n    26→  }\n    27→\n    28→  if (typeof value !== 'string') {\n    29→    return { valid: false, error: `${fieldName} must be a string` };\n    30→  }\n    31→\n    32→  if (!allowEmpty && value.trim() === '') {\n    33→    return { valid: false, error: `${fieldName} cannot be empty` };\n    34→  }\n    35→\n    36→  if (value.length > maxLength) {\n    37→    return { valid: false, error: `${fieldName} exceeds maximum length of ${maxLength}` };\n    38→  }\n    39→\n    40→  return { valid: true, value: value.trim() };\n    41→}\n    42→\n    43→/**\n    44→ * Validate that a value is a number within range\n    45→ * @param {any} value - Value to validate\n    46→ * @param {string} fieldName - Name of the field for error messages\n    47→ * @param {Object} options - Validation options\n    48→ * @returns {{valid: boolean, value?: number, error?: string}}\n    49→ */\n    50→function validateNumber(value, fieldName, options = {}) {\n    51→  const { min = -Infinity, max = Infinity, allowNegative = true } = options;\n    52→\n    53→  if (value === null || value === undefined) {\n    54→    return { valid: false, error: `${fieldName} is required` };\n    55→  }\n    56→\n    57→  const num = typeof value === 'string' ? parseFloat(value) : value;\n    58→\n    59→  if (typeof num !== 'number' || isNaN(num)) {\n    60→    return { valid: false, error: `${fieldName} must be a valid number` };\n    61→  }\n    62→\n    63→  if (!allowNegative && num < 0) {\n    64→    return { valid: false, error: `${fieldName} cannot be negative` };\n    65→  }\n    66→\n    67→  if (num < min || num > max) {\n    68→    return { valid: false, error: `${fieldName} must be between ${min} and ${max}` };\n    69→  }\n    70→\n    71→  return { valid: true, value: num };\n    72→}\n    73→\n    74→/**\n    75→ * Validate that a value is a boolean\n    76→ * @param {any} value - Value to validate\n    77→ * @param {string} fieldName - Name of the field for error messages\n    78→ * @returns {{valid: boolean, value?: boolean, error?: string}}\n    79→ */\n    80→function validateBoolean(value, fieldName) {\n    81→  if (value === null || value === undefined) {\n    82→    return { valid: true, value: false }; // Default to false\n    83→  }\n    84→\n    85→  if (typeof value === 'boolean') {\n    86→    return { valid: true, value };\n    87→  }\n    88→\n    89→  if (value === 'true' || value === '1') {\n    90→    return { valid: true, value: true };\n    91→  }\n    92→\n    93→  if (value === 'false' || value === '0') {\n    94→    return { valid: true, value: false };\n    95→  }\n    96→\n    97→  return { valid: false, error: `${fieldName} must be a boolean` };\n    98→}\n    99→\n   100→/**\n   101→ * Validate that a value is an array\n   102→ * @param {any} value - Value to validate\n   103→ * @param {string} fieldName - Name of the field for error messages\n   104→ * @param {Object} options - Validation options\n   105→ * @returns {{valid: boolean, value?: Array, error?: string}}\n   106→ */\n   107→function validateArray(value, fieldName, options = {}) {\n   108→  const { maxItems = 10000, minItems = 0 } = options;\n   109→\n   110→  if (value === null || value === undefined) {\n   111→    if (minItems > 0) {\n   112→      return { valid: false, error: `${fieldName} is required` };\n   113→    }\n   114→    return { valid: true, value: [] };\n   115→  }\n   116→\n   117→  if (!Array.isArray(value)) {\n   118→    return { valid: false, error: `${fieldName} must be an array` };\n   119→  }\n   120→\n   121→  if (value.length < minItems) {\n   122→    return { valid: false, error: `${fieldName} must have at least ${minItems} items` };\n   123→  }\n   124→\n   125→  if (value.length > maxItems) {\n   126→    return { valid: false, error: `${fieldName} exceeds maximum of ${maxItems} items` };\n   127→  }\n   128→\n   129→  return { valid: true, value };\n   130→}\n   131→\n   132→/**\n   133→ * Validate that a value is one of a set of allowed values\n   134→ * @param {any} value - Value to validate\n   135→ * @param {string} fieldName - Name of the field for error messages\n   136→ * @param {Array} allowedValues - Array of allowed values\n   137→ * @returns {{valid: boolean, value?: any, error?: string}}\n   138→ */\n   139→function validateEnum(value, fieldName, allowedValues) {\n   140→  if (value === null || value === undefined) {\n   141→    return { valid: false, error: `${fieldName} is required` };\n   142→  }\n   143→\n   144→  if (!allowedValues.includes(value)) {\n   145→    return { valid: false, error: `${fieldName} must be one of: ${allowedValues.join(', ')}` };\n   146→  }\n   147→\n   148→  return { valid: true, value };\n   149→}\n   150→\n   151→/**\n   152→ * Create a validation middleware for a specific endpoint\n   153→ * @param {Object} schema - Validation schema\n   154→ * @returns {Function} Express middleware\n   155→ */\n   156→function createValidator(schema) {\n   157→  return (req, res, next) => {\n   158→    const errors = [];\n   159→    const validated = {};\n   160→\n   161→    for (const [field, rules] of Object.entries(schema)) {\n   162→      const value = req.body[field];\n   163→      let result;\n   164→\n   165→      switch (rules.type) {\n   166→        case 'string':\n   167→          result = validateString(value, field, rules);\n   168→          break;\n   169→        case 'number':\n   170→          result = validateNumber(value, field, rules);\n   171→          break;\n   172→        case 'boolean':\n   173→          result = validateBoolean(value, field);\n   174→          break;\n   175→        case 'array':\n   176→          result = validateArray(value, field, rules);\n   177→          break;\n   178→        case 'enum':\n   179→          result = validateEnum(value, field, rules.values);\n   180→          break;\n   181→        default:\n   182→          result = { valid: true, value };\n   183→      }\n   184→\n   185→      if (!result.valid) {\n   186→        if (!rules.optional) {\n   187→          errors.push(result.error);\n   188→        }\n   189→      } else {\n   190→        validated[field] = result.value;\n   191→      }\n   192→    }\n   193→\n   194→    if (errors.length > 0) {\n   195→      return res.status(400).json({\n   196→        error: 'Validation failed',\n   197→        details: errors\n   198→      });\n   199→    }\n   200→\n   201→    // Attach validated data to request\n   202→    req.validatedBody = validated;\n   203→    next();\n   204→  };\n   205→}\n   206→\n   207→/**\n   208→ * Common validation schemas for endpoints\n   209→ */\n   210→const validationSchemas = {\n   211→  analyze: {\n   212→    wavPath: { type: 'string', maxLength: 1000 },\n   213→    detectTakes: { type: 'boolean', optional: true }\n   214→  },\n   215→  silences: {\n   216→    wavPath: { type: 'string', maxLength: 1000 },\n   217→    sensitivity: { type: 'number', min: 0, max: 100, optional: true },\n   218→    minSilenceLength: { type: 'number', min: 0.1, max: 60, optional: true }\n   219→  },\n   220→  cutList: {\n   221→    sourceName: { type: 'string', maxLength: 500, optional: true },\n   222→    sourcePath: { type: 'string', maxLength: 1000, optional: true },\n   223→    duration: { type: 'number', min: 0, max: 86400 },\n   224→    silences: { type: 'array', maxItems: 10000 }\n   225→  },\n   226→  chapters: {\n   227→    wavPath: { type: 'string', maxLength: 1000 },\n   228→    transcript: { type: 'string', maxLength: 1000000, optional: true }\n   229→  },\n   230→  musicGenerate: {\n   231→    mood: { type: 'string', maxLength: 100 },\n   232→    duration: { type: 'number', min: 15, max: 600 },\n   233→    instruments: { type: 'array', maxItems: 20, optional: true }\n   234→  }\n   235→};\n   236→\n   237→module.exports = {\n   238→  validateString,\n   239→  validateNumber,\n   240→  validateBoolean,\n   241→  validateArray,\n   242→  validateEnum,\n   243→  createValidator,\n   244→  validationSchemas\n   245→};\n   246→\n\n</system-reminder>\n"}]},"uuid":"1dc6fc02-d63c-4977-8c42-2803ae7bf155","timestamp":"2026-01-11T23:39:14.711Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/inputValidation.js","content":"/**\n * Input Validation Middleware\n *\n * Provides type validation and sanitization for API request parameters\n * to prevent type confusion attacks and ensure data integrity.\n *\n * SECURITY ENHANCEMENTS:\n * - Email validation with RFC-compliant regex\n * - File upload validation (type, size, extension whitelist)\n * - Input sanitization to prevent injection attacks\n * - Request body size enforcement\n * - Path traversal prevention\n */\n\n/**\n * Validate that a value is a non-empty string\n * @param {any} value - Value to validate\n * @param {string} fieldName - Name of the field for error messages\n * @returns {{valid: boolean, value?: string, error?: string}}\n */\nfunction validateString(value, fieldName, options = {}) {\n  const { maxLength = 10000, allowEmpty = false } = options;\n\n  if (value === null || value === undefined) {\n    return { valid: false, error: `${fieldName} is required` };\n  }\n\n  if (typeof value !== 'string') {\n    return { valid: false, error: `${fieldName} must be a string` };\n  }\n\n  if (!allowEmpty && value.trim() === '') {\n    return { valid: false, error: `${fieldName} cannot be empty` };\n  }\n\n  if (value.length > maxLength) {\n    return { valid: false, error: `${fieldName} exceeds maximum length of ${maxLength}` };\n  }\n\n  return { valid: true, value: value.trim() };\n}\n\n/**\n * Validate that a value is a number within range\n * @param {any} value - Value to validate\n * @param {string} fieldName - Name of the field for error messages\n * @param {Object} options - Validation options\n * @returns {{valid: boolean, value?: number, error?: string}}\n */\nfunction validateNumber(value, fieldName, options = {}) {\n  const { min = -Infinity, max = Infinity, allowNegative = true } = options;\n\n  if (value === null || value === undefined) {\n    return { valid: false, error: `${fieldName} is required` };\n  }\n\n  const num = typeof value === 'string' ? parseFloat(value) : value;\n\n  if (typeof num !== 'number' || isNaN(num)) {\n    return { valid: false, error: `${fieldName} must be a valid number` };\n  }\n\n  if (!allowNegative && num < 0) {\n    return { valid: false, error: `${fieldName} cannot be negative` };\n  }\n\n  if (num < min || num > max) {\n    return { valid: false, error: `${fieldName} must be between ${min} and ${max}` };\n  }\n\n  return { valid: true, value: num };\n}\n\n/**\n * Validate that a value is a boolean\n * @param {any} value - Value to validate\n * @param {string} fieldName - Name of the field for error messages\n * @returns {{valid: boolean, value?: boolean, error?: string}}\n */\nfunction validateBoolean(value, fieldName) {\n  if (value === null || value === undefined) {\n    return { valid: true, value: false }; // Default to false\n  }\n\n  if (typeof value === 'boolean') {\n    return { valid: true, value };\n  }\n\n  if (value === 'true' || value === '1') {\n    return { valid: true, value: true };\n  }\n\n  if (value === 'false' || value === '0') {\n    return { valid: true, value: false };\n  }\n\n  return { valid: false, error: `${fieldName} must be a boolean` };\n}\n\n/**\n * Validate that a value is an array\n * @param {any} value - Value to validate\n * @param {string} fieldName - Name of the field for error messages\n * @param {Object} options - Validation options\n * @returns {{valid: boolean, value?: Array, error?: string}}\n */\nfunction validateArray(value, fieldName, options = {}) {\n  const { maxItems = 10000, minItems = 0 } = options;\n\n  if (value === null || value === undefined) {\n    if (minItems > 0) {\n      return { valid: false, error: `${fieldName} is required` };\n    }\n    return { valid: true, value: [] };\n  }\n\n  if (!Array.isArray(value)) {\n    return { valid: false, error: `${fieldName} must be an array` };\n  }\n\n  if (value.length < minItems) {\n    return { valid: false, error: `${fieldName} must have at least ${minItems} items` };\n  }\n\n  if (value.length > maxItems) {\n    return { valid: false, error: `${fieldName} exceeds maximum of ${maxItems} items` };\n  }\n\n  return { valid: true, value };\n}\n\n/**\n * Validate that a value is one of a set of allowed values\n * @param {any} value - Value to validate\n * @param {string} fieldName - Name of the field for error messages\n * @param {Array} allowedValues - Array of allowed values\n * @returns {{valid: boolean, value?: any, error?: string}}\n */\nfunction validateEnum(value, fieldName, allowedValues) {\n  if (value === null || value === undefined) {\n    return { valid: false, error: `${fieldName} is required` };\n  }\n\n  if (!allowedValues.includes(value)) {\n    return { valid: false, error: `${fieldName} must be one of: ${allowedValues.join(', ')}` };\n  }\n\n  return { valid: true, value };\n}\n\n/**\n * Create a validation middleware for a specific endpoint\n * @param {Object} schema - Validation schema\n * @returns {Function} Express middleware\n */\nfunction createValidator(schema) {\n  return (req, res, next) => {\n    const errors = [];\n    const validated = {};\n\n    for (const [field, rules] of Object.entries(schema)) {\n      const value = req.body[field];\n      let result;\n\n      switch (rules.type) {\n        case 'string':\n          result = validateString(value, field, rules);\n          break;\n        case 'number':\n          result = validateNumber(value, field, rules);\n          break;\n        case 'boolean':\n          result = validateBoolean(value, field);\n          break;\n        case 'array':\n          result = validateArray(value, field, rules);\n          break;\n        case 'enum':\n          result = validateEnum(value, field, rules.values);\n          break;\n        default:\n          result = { valid: true, value };\n      }\n\n      if (!result.valid) {\n        if (!rules.optional) {\n          errors.push(result.error);\n        }\n      } else {\n        validated[field] = result.value;\n      }\n    }\n\n    if (errors.length > 0) {\n      return res.status(400).json({\n        error: 'Validation failed',\n        details: errors\n      });\n    }\n\n    // Attach validated data to request\n    req.validatedBody = validated;\n    next();\n  };\n}\n\n/**\n * Common validation schemas for endpoints\n */\nconst validationSchemas = {\n  analyze: {\n    wavPath: { type: 'string', maxLength: 1000 },\n    detectTakes: { type: 'boolean', optional: true }\n  },\n  silences: {\n    wavPath: { type: 'string', maxLength: 1000 },\n    sensitivity: { type: 'number', min: 0, max: 100, optional: true },\n    minSilenceLength: { type: 'number', min: 0.1, max: 60, optional: true }\n  },\n  cutList: {\n    sourceName: { type: 'string', maxLength: 500, optional: true },\n    sourcePath: { type: 'string', maxLength: 1000, optional: true },\n    duration: { type: 'number', min: 0, max: 86400 },\n    silences: { type: 'array', maxItems: 10000 }\n  },\n  chapters: {\n    wavPath: { type: 'string', maxLength: 1000 },\n    transcript: { type: 'string', maxLength: 1000000, optional: true }\n  },\n  musicGenerate: {\n    mood: { type: 'string', maxLength: 100 },\n    duration: { type: 'number', min: 15, max: 600 },\n    instruments: { type: 'array', maxItems: 20, optional: true }\n  }\n};\n\nmodule.exports = {\n  validateString,\n  validateNumber,\n  validateBoolean,\n  validateArray,\n  validateEnum,\n  createValidator,\n  validationSchemas\n};\n","numLines":246,"startLine":1,"totalLines":246}}}
{"parentUuid":"1dc6fc02-d63c-4977-8c42-2803ae7bf155","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KMkEfieAVso3XcicA6isgb","type":"tool_result","content":"     1→/**\n     2→ * Centralized Error Handling Middleware\n     3→ *\n     4→ * Provides unified error handling across all endpoints:\n     5→ * - Custom error classes for different error types\n     6→ * - Consistent JSON response format\n     7→ * - Error codes enum for client-side handling\n     8→ * - Async handler wrapper to eliminate try-catch boilerplate\n     9→ *\n    10→ * @module middleware/errorHandler\n    11→ */\n    12→\n    13→// =============================================================================\n    14→// Error Codes Enum\n    15→// =============================================================================\n    16→\n    17→/**\n    18→ * Standardized error codes for client-side handling\n    19→ */\n    20→const ErrorCodes = {\n    21→  // Authentication errors (401)\n    22→  AUTH_REQUIRED: 'AUTH_REQUIRED',\n    23→  AUTH_INVALID: 'AUTH_INVALID',\n    24→  AUTH_EXPIRED: 'AUTH_EXPIRED',\n    25→\n    26→  // Validation errors (400)\n    27→  VALIDATION_ERROR: 'VALIDATION_ERROR',\n    28→  MISSING_FIELD: 'MISSING_FIELD',\n    29→  INVALID_FORMAT: 'INVALID_FORMAT',\n    30→\n    31→  // Resource errors (404)\n    32→  NOT_FOUND: 'NOT_FOUND',\n    33→  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',\n    34→  FILE_NOT_FOUND: 'FILE_NOT_FOUND',\n    35→\n    36→  // Rate limiting / billing (402, 429)\n    37→  RATE_LIMITED: 'RATE_LIMITED',\n    38→  CREDITS_EXHAUSTED: 'CREDITS_EXHAUSTED',\n    39→  PAYMENT_REQUIRED: 'PAYMENT_REQUIRED',\n    40→\n    41→  // Permission errors (403)\n    42→  ACCESS_DENIED: 'ACCESS_DENIED',\n    43→  OWNERSHIP_REQUIRED: 'OWNERSHIP_REQUIRED',\n    44→\n    45→  // External service errors (502, 503)\n    46→  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',\n    47→  TRANSCRIPTION_FAILED: 'TRANSCRIPTION_FAILED',\n    48→  AI_SERVICE_UNAVAILABLE: 'AI_SERVICE_UNAVAILABLE',\n    49→  DEPENDENCY_MISSING: 'DEPENDENCY_MISSING',\n    50→\n    51→  // File errors (413)\n    52→  FILE_TOO_LARGE: 'FILE_TOO_LARGE',\n    53→\n    54→  // Internal errors (500)\n    55→  INTERNAL_ERROR: 'INTERNAL_ERROR',\n    56→  DATABASE_ERROR: 'DATABASE_ERROR',\n    57→  CONFIGURATION_ERROR: 'CONFIGURATION_ERROR'\n    58→};\n    59→\n    60→// =============================================================================\n    61→// Custom Error Classes\n    62→// =============================================================================\n    63→\n    64→/**\n    65→ * Base application error class\n    66→ * All custom errors extend this class\n    67→ */\n    68→class AppError extends Error {\n    69→  /**\n    70→   * @param {string} message - Human-readable error message\n    71→   * @param {number} statusCode - HTTP status code (default: 500)\n    72→   * @param {string} code - Error code from ErrorCodes enum\n    73→   * @param {object} details - Optional additional error details\n    74→   */\n    75→  constructor(message, statusCode = 500, code = ErrorCodes.INTERNAL_ERROR, details = null) {\n    76→    super(message);\n    77→    this.name = this.constructor.name;\n    78→    this.statusCode = statusCode;\n    79→    this.code = code;\n    80→    this.details = details;\n    81→    this.isOperational = true; // Distinguishes from programming errors\n    82→\n    83→    Error.captureStackTrace(this, this.constructor);\n    84→  }\n    85→\n    86→  /**\n    87→   * Convert error to JSON response format\n    88→   */\n    89→  toJSON() {\n    90→    const response = {\n    91→      success: false,\n    92→      error: {\n    93→        code: this.code,\n    94→        message: this.message\n    95→      }\n    96→    };\n    97→\n    98→    if (this.details) {\n    99→      response.error.details = this.details;\n   100→    }\n   101→\n   102→    return response;\n   103→  }\n   104→}\n   105→\n   106→/**\n   107→ * Validation error (400) - Invalid input data\n   108→ */\n   109→class ValidationError extends AppError {\n   110→  constructor(message, details = null) {\n   111→    super(message, 400, ErrorCodes.VALIDATION_ERROR, details);\n   112→  }\n   113→\n   114→  /**\n   115→   * Create a missing field error\n   116→   * @param {string} fieldName - Name of the missing field\n   117→   */\n   118→  static missingField(fieldName) {\n   119→    return new ValidationError(\n   120→      `${fieldName} is required`,\n   121→      { field: fieldName, code: ErrorCodes.MISSING_FIELD }\n   122→    );\n   123→  }\n   124→\n   125→  /**\n   126→   * Create an invalid format error\n   127→   * @param {string} fieldName - Name of the field\n   128→   * @param {string} expectedFormat - Description of expected format\n   129→   */\n   130→  static invalidFormat(fieldName, expectedFormat) {\n   131→    return new ValidationError(\n   132→      `Invalid ${fieldName} format. Expected: ${expectedFormat}`,\n   133→      { field: fieldName, expected: expectedFormat, code: ErrorCodes.INVALID_FORMAT }\n   134→    );\n   135→  }\n   136→}\n   137→\n   138→/**\n   139→ * Authentication error (401) - Missing or invalid credentials\n   140→ */\n   141→class AuthenticationError extends AppError {\n   142→  constructor(message = 'Authentication required', code = ErrorCodes.AUTH_REQUIRED) {\n   143→    super(message, 401, code);\n   144→  }\n   145→\n   146→  static required() {\n   147→    return new AuthenticationError('Authentication required', ErrorCodes.AUTH_REQUIRED);\n   148→  }\n   149→\n   150→  static invalid() {\n   151→    return new AuthenticationError('Invalid credentials', ErrorCodes.AUTH_INVALID);\n   152→  }\n   153→\n   154→  static expired() {\n   155→    return new AuthenticationError('Token has expired. Please log in again', ErrorCodes.AUTH_EXPIRED);\n   156→  }\n   157→}\n   158→\n   159→/**\n   160→ * Not found error (404) - Resource doesn't exist\n   161→ */\n   162→class NotFoundError extends AppError {\n   163→  constructor(message, resourceType = null) {\n   164→    const code = resourceType === 'file' ? ErrorCodes.FILE_NOT_FOUND : ErrorCodes.RESOURCE_NOT_FOUND;\n   165→    super(message, 404, code, resourceType ? { resourceType } : null);\n   166→  }\n   167→\n   168→  static file(filePath) {\n   169→    return new NotFoundError(`File not found: ${filePath}`, 'file');\n   170→  }\n   171→\n   172→  static resource(resourceType, id) {\n   173→    return new NotFoundError(`${resourceType} not found${id ? `: ${id}` : ''}`, resourceType);\n   174→  }\n   175→}\n   176→\n   177→/**\n   178→ * Access denied error (403) - User lacks permission\n   179→ */\n   180→class AccessDeniedError extends AppError {\n   181→  constructor(message = 'Access denied', code = ErrorCodes.ACCESS_DENIED) {\n   182→    super(message, 403, code);\n   183→  }\n   184→\n   185→  static ownership() {\n   186→    return new AccessDeniedError('Access denied: Resource belongs to another user', ErrorCodes.OWNERSHIP_REQUIRED);\n   187→  }\n   188→}\n   189→\n   190→/**\n   191→ * Rate limit error (429 or 402) - Too many requests or credits exhausted\n   192→ */\n   193→class RateLimitError extends AppError {\n   194→  constructor(message, details = null) {\n   195→    super(message, 429, ErrorCodes.RATE_LIMITED, details);\n   196→  }\n   197→\n   198→  static creditsExhausted(balance = null) {\n   199→    const error = new RateLimitError(\n   200→      'Insufficient credits. Please upgrade your plan or wait for your next billing cycle',\n   201→      balance ? { balance } : null\n   202→    );\n   203→    error.statusCode = 402;\n   204→    error.code = ErrorCodes.CREDITS_EXHAUSTED;\n   205→    return error;\n   206→  }\n   207→}\n   208→\n   209→/**\n   210→ * External service error (502/503) - Third-party service failure\n   211→ */\n   212→class ExternalServiceError extends AppError {\n   213→  constructor(message, serviceName, originalError = null) {\n   214→    const details = { service: serviceName };\n   215→    if (originalError && originalError.message) {\n   216→      details.originalError = originalError.message;\n   217→    }\n   218→    super(message, 502, ErrorCodes.EXTERNAL_SERVICE_ERROR, details);\n   219→    this.serviceName = serviceName;\n   220→  }\n   221→\n   222→  static transcription(originalError = null) {\n   223→    const error = new ExternalServiceError(\n   224→      'Transcription service failed',\n   225→      'whisper',\n   226→      originalError\n   227→    );\n   228→    error.code = ErrorCodes.TRANSCRIPTION_FAILED;\n   229→    return error;\n   230→  }\n   231→\n   232→  static unavailable(serviceName) {\n   233→    const error = new ExternalServiceError(\n   234→      `${serviceName} service is not available`,\n   235→      serviceName\n   236→    );\n   237→    error.statusCode = 503;\n   238→    error.code = ErrorCodes.AI_SERVICE_UNAVAILABLE;\n   239→    return error;\n   240→  }\n   241→\n   242→  static missingDependency(dependencyName, installHint = null) {\n   243→    const details = { dependency: dependencyName };\n   244→    if (installHint) {\n   245→      details.hint = installHint;\n   246→    }\n   247→    const error = new ExternalServiceError(\n   248→      `${dependencyName} is not installed`,\n   249→      dependencyName\n   250→    );\n   251→    error.statusCode = 500;\n   252→    error.code = ErrorCodes.DEPENDENCY_MISSING;\n   253→    error.details = details;\n   254→    return error;\n   255→  }\n   256→}\n   257→\n   258→/**\n   259→ * File too large error (413) - Payload exceeds limit\n   260→ */\n   261→class FileTooLargeError extends AppError {\n   262→  constructor(message, details = null) {\n   263→    super(message, 413, ErrorCodes.FILE_TOO_LARGE, details);\n   264→  }\n   265→\n   266→  static exceeds(actualSizeMB, maxSizeMB) {\n   267→    return new FileTooLargeError(\n   268→      `File too large (${actualSizeMB.toFixed(1)}MB). Maximum allowed: ${maxSizeMB}MB`,\n   269→      { actualSizeMB, maxSizeMB }\n   270→    );\n   271→  }\n   272→}\n   273→\n   274→/**\n   275→ * Database error (500) - Database operation failed\n   276→ */\n   277→class DatabaseError extends AppError {\n   278→  constructor(message = 'Database operation failed', originalError = null) {\n   279→    const details = originalError ? { originalError: originalError.message } : null;\n   280→    super(message, 500, ErrorCodes.DATABASE_ERROR, details);\n   281→  }\n   282→}\n   283→\n   284→// =============================================================================\n   285→// Async Handler Wrapper\n   286→// =============================================================================\n   287→\n   288→/**\n   289→ * Wraps async route handlers to automatically catch errors\n   290→ * Eliminates try-catch boilerplate in every endpoint\n   291→ *\n   292→ * @param {Function} fn - Async route handler function\n   293→ * @returns {Function} Express middleware function\n   294→ *\n   295→ * @example\n   296→ * app.post('/analyze', requireCredits(), asyncHandler(async (req, res) => {\n   297→ *   const result = await someAsyncOperation();\n   298→ *   res.json({ success: true, result });\n   299→ * }));\n   300→ */\n   301→function asyncHandler(fn) {\n   302→  return (req, res, next) => {\n   303→    Promise.resolve(fn(req, res, next)).catch(next);\n   304→  };\n   305→}\n   306→\n   307→// =============================================================================\n   308→// Global Error Handler Middleware\n   309→// =============================================================================\n   310→\n   311→/**\n   312→ * Global error handler middleware\n   313→ * Must be registered last in the middleware chain\n   314→ *\n   315→ * Handles:\n   316→ * - AppError subclasses (operational errors)\n   317→ * - Standard JavaScript errors\n   318→ * - Unknown errors\n   319→ *\n   320→ * @param {Error} err - Error object\n   321→ * @param {Request} req - Express request\n   322→ * @param {Response} res - Express response\n   323→ * @param {Function} next - Express next function\n   324→ */\n   325→function errorHandler(err, req, res, _next) {\n   326→  // Log error (with stack trace in development)\n   327→  const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n   328→\n   329→  if (err.isOperational) {\n   330→    // Operational errors - log warning level\n   331→    console.warn(`[SPLICE] ${err.name}: ${err.message}`, {\n   332→      code: err.code,\n   333→      statusCode: err.statusCode,\n   334→      path: req.path,\n   335→      method: req.method\n   336→    });\n   337→  } else {\n   338→    // Programming errors - log error level with stack\n   339→    console.error(`[SPLICE] Unexpected error:`, {\n   340→      message: err.message,\n   341→      stack: isProduction ? undefined : err.stack,\n   342→      path: req.path,\n   343→      method: req.method\n   344→    });\n   345→  }\n   346→\n   347→  // Handle AppError subclasses\n   348→  if (err instanceof AppError) {\n   349→    return res.status(err.statusCode).json(err.toJSON());\n   350→  }\n   351→\n   352→  // Handle Stripe errors\n   353→  if (err.type && err.type.startsWith('Stripe')) {\n   354→    return res.status(400).json({\n   355→      success: false,\n   356→      error: {\n   357→        code: 'STRIPE_ERROR',\n   358→        message: isProduction ? 'Payment processing error' : err.message\n   359→      }\n   360→    });\n   361→  }\n   362→\n   363→  // Handle JSON parse errors\n   364→  if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {\n   365→    return res.status(400).json({\n   366→      success: false,\n   367→      error: {\n   368→        code: ErrorCodes.VALIDATION_ERROR,\n   369→        message: 'Invalid JSON in request body'\n   370→      }\n   371→    });\n   372→  }\n   373→\n   374→  // Handle unknown/unexpected errors\n   375→  const response = {\n   376→    success: false,\n   377→    error: {\n   378→      code: ErrorCodes.INTERNAL_ERROR,\n   379→      message: isProduction ? 'An unexpected error occurred' : err.message\n   380→    }\n   381→  };\n   382→\n   383→  // Include stack trace in development\n   384→  if (!isProduction && err.stack) {\n   385→    response.error.stack = err.stack;\n   386→  }\n   387→\n   388→  return res.status(500).json(response);\n   389→}\n   390→\n   391→/**\n   392→ * 404 handler for unmatched routes\n   393→ * Register before the global error handler\n   394→ */\n   395→function notFoundHandler(req, res, next) {\n   396→  next(new NotFoundError(`Route not found: ${req.method} ${req.path}`, 'route'));\n   397→}\n   398→\n   399→// =============================================================================\n   400→// Helper Functions\n   401→// =============================================================================\n   402→\n   403→/**\n   404→ * SECURITY: Sanitize error message for production\n   405→ * Hides internal error details from clients in production\n   406→ *\n   407→ * @param {Error} err - Error object\n   408→ * @param {string} fallbackMessage - Message to show in production\n   409→ * @returns {string} Sanitized error message\n   410→ */\n   411→function sanitizeError(err, fallbackMessage = 'An error occurred') {\n   412→  const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n   413→\n   414→  // In production, only show the fallback message\n   415→  // Exception: If error is an AppError (operational), show its message\n   416→  if (isProduction) {\n   417→    if (err instanceof AppError && err.isOperational) {\n   418→      return err.message;\n   419→    }\n   420→    return fallbackMessage;\n   421→  }\n   422→\n   423→  // In development, show full error message\n   424→  return err.message || fallbackMessage;\n   425→}\n   426→\n   427→/**\n   428→ * SECURITY: Create sanitized error response\n   429→ * Use this instead of directly using err.message in responses\n   430→ *\n   431→ * @param {Error} err - Error object\n   432→ * @param {string} fallbackMessage - Message to show in production\n   433→ * @returns {Object} Sanitized error response object\n   434→ */\n   435→function createErrorResponse(err, fallbackMessage = 'An error occurred') {\n   436→  return { error: sanitizeError(err, fallbackMessage) };\n   437→}\n   438→\n   439→/**\n   440→ * Validate required fields in request body\n   441→ * Throws ValidationError if any field is missing\n   442→ *\n   443→ * @param {object} body - Request body\n   444→ * @param {string[]} requiredFields - Array of required field names\n   445→ * @throws {ValidationError} If any required field is missing\n   446→ */\n   447→function validateRequired(body, requiredFields) {\n   448→  for (const field of requiredFields) {\n   449→    if (body[field] === undefined || body[field] === null || body[field] === '') {\n   450→      throw ValidationError.missingField(field);\n   451→    }\n   452→  }\n   453→}\n   454→\n   455→/**\n   456→ * Validate that at least one of the specified fields is present\n   457→ *\n   458→ * @param {object} body - Request body\n   459→ * @param {string[]} fields - Array of field names (at least one required)\n   460→ * @param {string} message - Custom error message\n   461→ * @throws {ValidationError} If none of the fields are present\n   462→ */\n   463→function validateOneOf(body, fields, message) {\n   464→  const hasOne = fields.some(f => body[f] !== undefined && body[f] !== null && body[f] !== '');\n   465→  if (!hasOne) {\n   466→    throw new ValidationError(message || `At least one of ${fields.join(', ')} is required`);\n   467→  }\n   468→}\n   469→\n   470→/**\n   471→ * Validate array field\n   472→ *\n   473→ * @param {object} body - Request body\n   474→ * @param {string} fieldName - Field name\n   475→ * @param {object} options - Validation options\n   476→ * @param {boolean} options.required - Whether field is required\n   477→ * @param {number} options.minLength - Minimum array length\n   478→ * @throws {ValidationError} If validation fails\n   479→ */\n   480→function validateArray(body, fieldName, options = {}) {\n   481→  const { required = true, minLength = 0 } = options;\n   482→  const value = body[fieldName];\n   483→\n   484→  if (required && (value === undefined || value === null)) {\n   485→    throw ValidationError.missingField(fieldName);\n   486→  }\n   487→\n   488→  if (value !== undefined && value !== null) {\n   489→    if (!Array.isArray(value)) {\n   490→      throw new ValidationError(`${fieldName} must be an array`);\n   491→    }\n   492→    if (value.length < minLength) {\n   493→      throw new ValidationError(\n   494→        `${fieldName} must have at least ${minLength} item${minLength === 1 ? '' : 's'}`\n   495→      );\n   496→    }\n   497→  }\n   498→}\n   499→\n   500→/**\n   501→ * Validate numeric field\n   502→ *\n   503→ * @param {object} body - Request body\n   504→ * @param {string} fieldName - Field name\n   505→ * @param {object} options - Validation options\n   506→ * @param {number} options.min - Minimum value\n   507→ * @param {number} options.max - Maximum value\n   508→ * @param {boolean} options.required - Whether field is required\n   509→ * @throws {ValidationError} If validation fails\n   510→ */\n   511→function validateNumber(body, fieldName, options = {}) {\n   512→  const { min, max, required = false } = options;\n   513→  const value = body[fieldName];\n   514→\n   515→  if (required && (value === undefined || value === null)) {\n   516→    throw ValidationError.missingField(fieldName);\n   517→  }\n   518→\n   519→  if (value !== undefined && value !== null) {\n   520→    if (typeof value !== 'number' || isNaN(value)) {\n   521→      throw new ValidationError(`${fieldName} must be a number`);\n   522→    }\n   523→    if (min !== undefined && value < min) {\n   524→      throw new ValidationError(`${fieldName} must be at least ${min}`);\n   525→    }\n   526→    if (max !== undefined && value > max) {\n   527→      throw new ValidationError(`${fieldName} must be at most ${max}`);\n   528→    }\n   529→  }\n   530→}\n   531→\n   532→// =============================================================================\n   533→// Exports\n   534→// =============================================================================\n   535→\n   536→module.exports = {\n   537→  // Error codes\n   538→  ErrorCodes,\n   539→\n   540→  // Error classes\n   541→  AppError,\n   542→  ValidationError,\n   543→  AuthenticationError,\n   544→  NotFoundError,\n   545→  AccessDeniedError,\n   546→  RateLimitError,\n   547→  ExternalServiceError,\n   548→  FileTooLargeError,\n   549→  DatabaseError,\n   550→\n   551→  // Middleware\n   552→  asyncHandler,\n   553→  errorHandler,\n   554→  notFoundHandler,\n   555→\n   556→  // Validation helpers\n   557→  validateRequired,\n   558→  validateOneOf,\n   559→  validateArray,\n   560→  validateNumber,\n   561→\n   562→  // Error sanitization\n   563→  sanitizeError,\n   564→  createErrorResponse\n   565→};\n   566→\n\n</system-reminder>\n"}]},"uuid":"8f25e769-806a-4c5b-8060-61a54c5089f7","timestamp":"2026-01-11T23:39:14.711Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/errorHandler.js","content":"/**\n * Centralized Error Handling Middleware\n *\n * Provides unified error handling across all endpoints:\n * - Custom error classes for different error types\n * - Consistent JSON response format\n * - Error codes enum for client-side handling\n * - Async handler wrapper to eliminate try-catch boilerplate\n *\n * @module middleware/errorHandler\n */\n\n// =============================================================================\n// Error Codes Enum\n// =============================================================================\n\n/**\n * Standardized error codes for client-side handling\n */\nconst ErrorCodes = {\n  // Authentication errors (401)\n  AUTH_REQUIRED: 'AUTH_REQUIRED',\n  AUTH_INVALID: 'AUTH_INVALID',\n  AUTH_EXPIRED: 'AUTH_EXPIRED',\n\n  // Validation errors (400)\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\n  MISSING_FIELD: 'MISSING_FIELD',\n  INVALID_FORMAT: 'INVALID_FORMAT',\n\n  // Resource errors (404)\n  NOT_FOUND: 'NOT_FOUND',\n  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',\n  FILE_NOT_FOUND: 'FILE_NOT_FOUND',\n\n  // Rate limiting / billing (402, 429)\n  RATE_LIMITED: 'RATE_LIMITED',\n  CREDITS_EXHAUSTED: 'CREDITS_EXHAUSTED',\n  PAYMENT_REQUIRED: 'PAYMENT_REQUIRED',\n\n  // Permission errors (403)\n  ACCESS_DENIED: 'ACCESS_DENIED',\n  OWNERSHIP_REQUIRED: 'OWNERSHIP_REQUIRED',\n\n  // External service errors (502, 503)\n  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',\n  TRANSCRIPTION_FAILED: 'TRANSCRIPTION_FAILED',\n  AI_SERVICE_UNAVAILABLE: 'AI_SERVICE_UNAVAILABLE',\n  DEPENDENCY_MISSING: 'DEPENDENCY_MISSING',\n\n  // File errors (413)\n  FILE_TOO_LARGE: 'FILE_TOO_LARGE',\n\n  // Internal errors (500)\n  INTERNAL_ERROR: 'INTERNAL_ERROR',\n  DATABASE_ERROR: 'DATABASE_ERROR',\n  CONFIGURATION_ERROR: 'CONFIGURATION_ERROR'\n};\n\n// =============================================================================\n// Custom Error Classes\n// =============================================================================\n\n/**\n * Base application error class\n * All custom errors extend this class\n */\nclass AppError extends Error {\n  /**\n   * @param {string} message - Human-readable error message\n   * @param {number} statusCode - HTTP status code (default: 500)\n   * @param {string} code - Error code from ErrorCodes enum\n   * @param {object} details - Optional additional error details\n   */\n  constructor(message, statusCode = 500, code = ErrorCodes.INTERNAL_ERROR, details = null) {\n    super(message);\n    this.name = this.constructor.name;\n    this.statusCode = statusCode;\n    this.code = code;\n    this.details = details;\n    this.isOperational = true; // Distinguishes from programming errors\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  /**\n   * Convert error to JSON response format\n   */\n  toJSON() {\n    const response = {\n      success: false,\n      error: {\n        code: this.code,\n        message: this.message\n      }\n    };\n\n    if (this.details) {\n      response.error.details = this.details;\n    }\n\n    return response;\n  }\n}\n\n/**\n * Validation error (400) - Invalid input data\n */\nclass ValidationError extends AppError {\n  constructor(message, details = null) {\n    super(message, 400, ErrorCodes.VALIDATION_ERROR, details);\n  }\n\n  /**\n   * Create a missing field error\n   * @param {string} fieldName - Name of the missing field\n   */\n  static missingField(fieldName) {\n    return new ValidationError(\n      `${fieldName} is required`,\n      { field: fieldName, code: ErrorCodes.MISSING_FIELD }\n    );\n  }\n\n  /**\n   * Create an invalid format error\n   * @param {string} fieldName - Name of the field\n   * @param {string} expectedFormat - Description of expected format\n   */\n  static invalidFormat(fieldName, expectedFormat) {\n    return new ValidationError(\n      `Invalid ${fieldName} format. Expected: ${expectedFormat}`,\n      { field: fieldName, expected: expectedFormat, code: ErrorCodes.INVALID_FORMAT }\n    );\n  }\n}\n\n/**\n * Authentication error (401) - Missing or invalid credentials\n */\nclass AuthenticationError extends AppError {\n  constructor(message = 'Authentication required', code = ErrorCodes.AUTH_REQUIRED) {\n    super(message, 401, code);\n  }\n\n  static required() {\n    return new AuthenticationError('Authentication required', ErrorCodes.AUTH_REQUIRED);\n  }\n\n  static invalid() {\n    return new AuthenticationError('Invalid credentials', ErrorCodes.AUTH_INVALID);\n  }\n\n  static expired() {\n    return new AuthenticationError('Token has expired. Please log in again', ErrorCodes.AUTH_EXPIRED);\n  }\n}\n\n/**\n * Not found error (404) - Resource doesn't exist\n */\nclass NotFoundError extends AppError {\n  constructor(message, resourceType = null) {\n    const code = resourceType === 'file' ? ErrorCodes.FILE_NOT_FOUND : ErrorCodes.RESOURCE_NOT_FOUND;\n    super(message, 404, code, resourceType ? { resourceType } : null);\n  }\n\n  static file(filePath) {\n    return new NotFoundError(`File not found: ${filePath}`, 'file');\n  }\n\n  static resource(resourceType, id) {\n    return new NotFoundError(`${resourceType} not found${id ? `: ${id}` : ''}`, resourceType);\n  }\n}\n\n/**\n * Access denied error (403) - User lacks permission\n */\nclass AccessDeniedError extends AppError {\n  constructor(message = 'Access denied', code = ErrorCodes.ACCESS_DENIED) {\n    super(message, 403, code);\n  }\n\n  static ownership() {\n    return new AccessDeniedError('Access denied: Resource belongs to another user', ErrorCodes.OWNERSHIP_REQUIRED);\n  }\n}\n\n/**\n * Rate limit error (429 or 402) - Too many requests or credits exhausted\n */\nclass RateLimitError extends AppError {\n  constructor(message, details = null) {\n    super(message, 429, ErrorCodes.RATE_LIMITED, details);\n  }\n\n  static creditsExhausted(balance = null) {\n    const error = new RateLimitError(\n      'Insufficient credits. Please upgrade your plan or wait for your next billing cycle',\n      balance ? { balance } : null\n    );\n    error.statusCode = 402;\n    error.code = ErrorCodes.CREDITS_EXHAUSTED;\n    return error;\n  }\n}\n\n/**\n * External service error (502/503) - Third-party service failure\n */\nclass ExternalServiceError extends AppError {\n  constructor(message, serviceName, originalError = null) {\n    const details = { service: serviceName };\n    if (originalError && originalError.message) {\n      details.originalError = originalError.message;\n    }\n    super(message, 502, ErrorCodes.EXTERNAL_SERVICE_ERROR, details);\n    this.serviceName = serviceName;\n  }\n\n  static transcription(originalError = null) {\n    const error = new ExternalServiceError(\n      'Transcription service failed',\n      'whisper',\n      originalError\n    );\n    error.code = ErrorCodes.TRANSCRIPTION_FAILED;\n    return error;\n  }\n\n  static unavailable(serviceName) {\n    const error = new ExternalServiceError(\n      `${serviceName} service is not available`,\n      serviceName\n    );\n    error.statusCode = 503;\n    error.code = ErrorCodes.AI_SERVICE_UNAVAILABLE;\n    return error;\n  }\n\n  static missingDependency(dependencyName, installHint = null) {\n    const details = { dependency: dependencyName };\n    if (installHint) {\n      details.hint = installHint;\n    }\n    const error = new ExternalServiceError(\n      `${dependencyName} is not installed`,\n      dependencyName\n    );\n    error.statusCode = 500;\n    error.code = ErrorCodes.DEPENDENCY_MISSING;\n    error.details = details;\n    return error;\n  }\n}\n\n/**\n * File too large error (413) - Payload exceeds limit\n */\nclass FileTooLargeError extends AppError {\n  constructor(message, details = null) {\n    super(message, 413, ErrorCodes.FILE_TOO_LARGE, details);\n  }\n\n  static exceeds(actualSizeMB, maxSizeMB) {\n    return new FileTooLargeError(\n      `File too large (${actualSizeMB.toFixed(1)}MB). Maximum allowed: ${maxSizeMB}MB`,\n      { actualSizeMB, maxSizeMB }\n    );\n  }\n}\n\n/**\n * Database error (500) - Database operation failed\n */\nclass DatabaseError extends AppError {\n  constructor(message = 'Database operation failed', originalError = null) {\n    const details = originalError ? { originalError: originalError.message } : null;\n    super(message, 500, ErrorCodes.DATABASE_ERROR, details);\n  }\n}\n\n// =============================================================================\n// Async Handler Wrapper\n// =============================================================================\n\n/**\n * Wraps async route handlers to automatically catch errors\n * Eliminates try-catch boilerplate in every endpoint\n *\n * @param {Function} fn - Async route handler function\n * @returns {Function} Express middleware function\n *\n * @example\n * app.post('/analyze', requireCredits(), asyncHandler(async (req, res) => {\n *   const result = await someAsyncOperation();\n *   res.json({ success: true, result });\n * }));\n */\nfunction asyncHandler(fn) {\n  return (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n}\n\n// =============================================================================\n// Global Error Handler Middleware\n// =============================================================================\n\n/**\n * Global error handler middleware\n * Must be registered last in the middleware chain\n *\n * Handles:\n * - AppError subclasses (operational errors)\n * - Standard JavaScript errors\n * - Unknown errors\n *\n * @param {Error} err - Error object\n * @param {Request} req - Express request\n * @param {Response} res - Express response\n * @param {Function} next - Express next function\n */\nfunction errorHandler(err, req, res, _next) {\n  // Log error (with stack trace in development)\n  const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n  if (err.isOperational) {\n    // Operational errors - log warning level\n    console.warn(`[SPLICE] ${err.name}: ${err.message}`, {\n      code: err.code,\n      statusCode: err.statusCode,\n      path: req.path,\n      method: req.method\n    });\n  } else {\n    // Programming errors - log error level with stack\n    console.error(`[SPLICE] Unexpected error:`, {\n      message: err.message,\n      stack: isProduction ? undefined : err.stack,\n      path: req.path,\n      method: req.method\n    });\n  }\n\n  // Handle AppError subclasses\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json(err.toJSON());\n  }\n\n  // Handle Stripe errors\n  if (err.type && err.type.startsWith('Stripe')) {\n    return res.status(400).json({\n      success: false,\n      error: {\n        code: 'STRIPE_ERROR',\n        message: isProduction ? 'Payment processing error' : err.message\n      }\n    });\n  }\n\n  // Handle JSON parse errors\n  if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {\n    return res.status(400).json({\n      success: false,\n      error: {\n        code: ErrorCodes.VALIDATION_ERROR,\n        message: 'Invalid JSON in request body'\n      }\n    });\n  }\n\n  // Handle unknown/unexpected errors\n  const response = {\n    success: false,\n    error: {\n      code: ErrorCodes.INTERNAL_ERROR,\n      message: isProduction ? 'An unexpected error occurred' : err.message\n    }\n  };\n\n  // Include stack trace in development\n  if (!isProduction && err.stack) {\n    response.error.stack = err.stack;\n  }\n\n  return res.status(500).json(response);\n}\n\n/**\n * 404 handler for unmatched routes\n * Register before the global error handler\n */\nfunction notFoundHandler(req, res, next) {\n  next(new NotFoundError(`Route not found: ${req.method} ${req.path}`, 'route'));\n}\n\n// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/**\n * SECURITY: Sanitize error message for production\n * Hides internal error details from clients in production\n *\n * @param {Error} err - Error object\n * @param {string} fallbackMessage - Message to show in production\n * @returns {string} Sanitized error message\n */\nfunction sanitizeError(err, fallbackMessage = 'An error occurred') {\n  const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n  // In production, only show the fallback message\n  // Exception: If error is an AppError (operational), show its message\n  if (isProduction) {\n    if (err instanceof AppError && err.isOperational) {\n      return err.message;\n    }\n    return fallbackMessage;\n  }\n\n  // In development, show full error message\n  return err.message || fallbackMessage;\n}\n\n/**\n * SECURITY: Create sanitized error response\n * Use this instead of directly using err.message in responses\n *\n * @param {Error} err - Error object\n * @param {string} fallbackMessage - Message to show in production\n * @returns {Object} Sanitized error response object\n */\nfunction createErrorResponse(err, fallbackMessage = 'An error occurred') {\n  return { error: sanitizeError(err, fallbackMessage) };\n}\n\n/**\n * Validate required fields in request body\n * Throws ValidationError if any field is missing\n *\n * @param {object} body - Request body\n * @param {string[]} requiredFields - Array of required field names\n * @throws {ValidationError} If any required field is missing\n */\nfunction validateRequired(body, requiredFields) {\n  for (const field of requiredFields) {\n    if (body[field] === undefined || body[field] === null || body[field] === '') {\n      throw ValidationError.missingField(field);\n    }\n  }\n}\n\n/**\n * Validate that at least one of the specified fields is present\n *\n * @param {object} body - Request body\n * @param {string[]} fields - Array of field names (at least one required)\n * @param {string} message - Custom error message\n * @throws {ValidationError} If none of the fields are present\n */\nfunction validateOneOf(body, fields, message) {\n  const hasOne = fields.some(f => body[f] !== undefined && body[f] !== null && body[f] !== '');\n  if (!hasOne) {\n    throw new ValidationError(message || `At least one of ${fields.join(', ')} is required`);\n  }\n}\n\n/**\n * Validate array field\n *\n * @param {object} body - Request body\n * @param {string} fieldName - Field name\n * @param {object} options - Validation options\n * @param {boolean} options.required - Whether field is required\n * @param {number} options.minLength - Minimum array length\n * @throws {ValidationError} If validation fails\n */\nfunction validateArray(body, fieldName, options = {}) {\n  const { required = true, minLength = 0 } = options;\n  const value = body[fieldName];\n\n  if (required && (value === undefined || value === null)) {\n    throw ValidationError.missingField(fieldName);\n  }\n\n  if (value !== undefined && value !== null) {\n    if (!Array.isArray(value)) {\n      throw new ValidationError(`${fieldName} must be an array`);\n    }\n    if (value.length < minLength) {\n      throw new ValidationError(\n        `${fieldName} must have at least ${minLength} item${minLength === 1 ? '' : 's'}`\n      );\n    }\n  }\n}\n\n/**\n * Validate numeric field\n *\n * @param {object} body - Request body\n * @param {string} fieldName - Field name\n * @param {object} options - Validation options\n * @param {number} options.min - Minimum value\n * @param {number} options.max - Maximum value\n * @param {boolean} options.required - Whether field is required\n * @throws {ValidationError} If validation fails\n */\nfunction validateNumber(body, fieldName, options = {}) {\n  const { min, max, required = false } = options;\n  const value = body[fieldName];\n\n  if (required && (value === undefined || value === null)) {\n    throw ValidationError.missingField(fieldName);\n  }\n\n  if (value !== undefined && value !== null) {\n    if (typeof value !== 'number' || isNaN(value)) {\n      throw new ValidationError(`${fieldName} must be a number`);\n    }\n    if (min !== undefined && value < min) {\n      throw new ValidationError(`${fieldName} must be at least ${min}`);\n    }\n    if (max !== undefined && value > max) {\n      throw new ValidationError(`${fieldName} must be at most ${max}`);\n    }\n  }\n}\n\n// =============================================================================\n// Exports\n// =============================================================================\n\nmodule.exports = {\n  // Error codes\n  ErrorCodes,\n\n  // Error classes\n  AppError,\n  ValidationError,\n  AuthenticationError,\n  NotFoundError,\n  AccessDeniedError,\n  RateLimitError,\n  ExternalServiceError,\n  FileTooLargeError,\n  DatabaseError,\n\n  // Middleware\n  asyncHandler,\n  errorHandler,\n  notFoundHandler,\n\n  // Validation helpers\n  validateRequired,\n  validateOneOf,\n  validateArray,\n  validateNumber,\n\n  // Error sanitization\n  sanitizeError,\n  createErrorResponse\n};\n","numLines":566,"startLine":1,"totalLines":566}}}
{"parentUuid":"8f25e769-806a-4c5b-8060-61a54c5089f7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a8e906b","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J2frCKzMGquMXNPjjy7D98","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have all the information needed to provide a comprehensive verification report. Let me compile my findings:\n\n---\n\n## SPLICE Backend Middleware Verification Report\n\n### Overall Verdict: **PASS WITH ISSUES**\n\nThe middleware stack is well-designed with solid security foundations, but there are several issues that should be addressed before production deployment.\n\n---\n\n## Requirements Checklist\n\n### 1. Authentication Middleware (auth.js)\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| JWT token verification | MET | Uses `jsonwebtoken` with proper signature verification |\n| Token blacklist checking (Redis + fallback) | MET | Dual-layer approach: Redis primary, in-memory fallback |\n| Proper error responses for invalid/expired tokens | MET | Clear, specific error messages with appropriate status codes |\n| optionalAuthentication for public routes | MET | Non-blocking auth that sets user context if token present |\n| JWT_SECRET validation in production | MET | Fails fast with process.exit(1) if secret is weak/default |\n| jti claim for token revocation | MET | Uses crypto.randomUUID() for unique token IDs |\n\n**Findings:**\n- Line 34: Default JWT_SECRET fallback exists for development: `'splice-dev-secret-change-in-production'`\n- Lines 45-59: Production validation enforces minimum 32-character secret length - GOOD\n- Lines 113-148: `blacklistToken()` properly uses async/await with Redis TTL matching token expiry\n- Lines 156-207: `isTokenBlacklisted()` migrates fallback entries to Redis when reconnected - GOOD\n- Lines 405-426: Legacy `x-stripe-customer-id` header still supported - documented as deprecated\n\n### 2. CSRF Middleware (csrf.js)\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Double-submit cookie pattern | MET | Token in HttpOnly cookie + X-CSRF-Token header |\n| Token generation | MET | 32-byte cryptographically random token via crypto.randomBytes |\n| Token validation with constant-time comparison | MET | Uses crypto.timingSafeEqual |\n| Proper cookie settings (httpOnly, secure, sameSite) | MET | httpOnly=true, secure=production, sameSite='strict' |\n\n**Findings:**\n- Lines 42-56: `safeCompare()` uses `crypto.timingSafeEqual` for timing-attack resistance - GOOD\n- Lines 62-71: Cookie options are production-appropriate\n- Line 66: `sameSite: 'strict'` provides strong CSRF protection\n\n### 3. Rate Limiter (rateLimiter.js)\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Per-user rate limiting | MET | IP-based with tiered limits (auth vs anon) |\n| Proper Redis integration | PARTIALLY MET | See issue below |\n| Fallback when Redis unavailable | MET | In-memory Map with cleanup interval |\n| Reservation system for long operations | MET | Credit reservation with confirm/release pattern |\n\n**Findings:**\n- **ISSUE (Medium Priority):** Lines 80-81 check `redisClient.isConnected` but `redisClient.js` exports `isRedisAvailable()`, not `isConnected`. This may cause Redis rate limiting to never engage.\n\n```javascript\n// Current code (rateLimiter.js line 80):\nif (redisClient && redisClient.isConnected) {\n```\n\nThe `redisClient` module exports `isRedisAvailable()` function, not an `isConnected` property. This should be:\n```javascript\nif (redisClient && redisClient.isRedisAvailable()) {\n```\n\n- Lines 296-336: Legacy auth is properly blocked in production unless `ALLOW_LEGACY_AUTH=true`\n- Lines 305-312: Legacy auth has rate limiting to prevent brute force\n\n### 4. Server.js Configuration\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Middleware order | MET | Correct order: Sentry -> requestId -> CORS -> helmet -> rate limit -> body parser -> cookie parser |\n| CORS configuration for CEP panel | MET | Includes `file://` and `bolt://` origins for Adobe plugins |\n| Body parser limits | MET | 10MB limit on JSON body |\n| Security headers | MET | Helmet with comprehensive CSP, HSTS, etc. |\n| Health check endpoint | MET | Mounted via healthRoutes |\n\n**Findings:**\n- Lines 272-277: Sentry handlers added first (required for tracing)\n- Lines 281: requestIdMiddleware added early for correlation\n- Line 343: CORS middleware applied\n- Line 352: IP rate limiting applied globally\n- Lines 355-378: Helmet security headers with strict CSP\n- Line 660: JSON body parser with 10MB limit\n- Line 663: Cookie parser for CSRF validation\n- **IMPORTANT:** Stripe webhook handler (line 402) correctly uses `express.raw()` before `express.json()`\n\n---\n\n## Detailed Issues\n\n### Critical Issues: NONE\n\n### High Priority Issues\n\n**H1. Rate Limiter Redis Integration Bug**\n- **File:** `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js`\n- **Lines:** 80-81, 88\n- **Issue:** The rate limiter checks `redisClient.isConnected` but `redisClient.js` exports `isRedisAvailable()` function, not an `isConnected` property.\n- **Impact:** Redis-based rate limiting may never activate, falling back to in-memory storage which is not distributed across instances.\n- **Fix:**\n```javascript\n// Change from:\nif (redisClient && redisClient.isConnected) {\n// To:\nif (redisClient && redisClient.isRedisAvailable()) {\n\n// Also fix the incr/expire/ttl calls to use the client properly:\nconst redis = redisClient.getRedisClient();\nif (redis) {\n  const current = await redis.incr(key);\n  // ...\n}\n```\n\n### Medium Priority Issues\n\n**M1. CSRF Middleware Not Applied Globally**\n- **File:** `/Users/imorgado/SPLICE/splice-backend/server.js`\n- **Issue:** The `validateCsrfToken` or `csrfProtection` middleware is not applied globally in server.js. It appears to be applied per-route in specific route files.\n- **Impact:** Risk of missing CSRF protection on new endpoints if developers forget to add it.\n- **Recommendation:** Consider applying `csrfProtection()` middleware globally after cookie-parser, with skipRoutes for webhooks and health checks.\n\n**M2. Error Handler Middleware Not Registered**\n- **File:** `/Users/imorgado/SPLICE/splice-backend/server.js`\n- **Issue:** The centralized `errorHandler` middleware from `/middleware/errorHandler.js` is not registered in server.js. Only Sentry's error handler is registered.\n- **Impact:** Custom error classes (AppError, ValidationError, etc.) won't get proper JSON formatting in responses if Sentry is not configured.\n- **Recommendation:** Add at the end of server.js:\n```javascript\nconst { errorHandler, notFoundHandler } = require('./middleware/errorHandler');\n// After all routes:\napp.use(notFoundHandler);\napp.use(errorHandler);\n```\n\n**M3. Missing `incr`, `expire`, `ttl` Methods in Redis Client**\n- **File:** `/Users/imorgado/SPLICE/splice-backend/services/redisClient.js`\n- **Issue:** The rate limiter uses `redis.incr()`, `redis.expire()`, and `redis.ttl()` directly, but `redisClient.js` only exports wrapper methods (`set`, `get`, `exists`, `del`, `setNX`, `ttl`). The `incr` and `expire` methods are not exported.\n- **Impact:** Rate limiting with Redis will throw errors when trying to call undefined methods.\n- **Fix:** Add wrapper methods to redisClient.js or have rate limiter use `getRedisClient()` directly.\n\n### Low Priority Issues\n\n**L1. Cleanup Timer Reference**\n- **File:** `/Users/imorgado/SPLICE/splice-backend/middleware/auth.js`\n- **Lines:** 98-101\n- **Issue:** Cleanup timer uses `.unref()` which is correct, but multiple cleanup intervals across files may accumulate if modules are re-required.\n- **Impact:** Minor, unlikely in production.\n\n**L2. Legacy Auth Still Functional**\n- **File:** `/Users/imorgado/SPLICE/splice-backend/middleware/auth.js`\n- **Lines:** 405-426\n- **Issue:** Legacy `x-stripe-customer-id` header authentication is still supported even though it's marked deprecated.\n- **Impact:** Security risk if old clients don't migrate to JWT.\n- **Recommendation:** Add deadline for removal and ensure `ALLOW_LEGACY_AUTH` defaults to false in production (which it does).\n\n---\n\n## Security Analysis\n\n### Positive Security Features\n\n1. **JWT Secret Validation**: Production fails fast if JWT_SECRET is default or under 32 characters\n2. **Token Blacklist**: Redis-backed with automatic TTL expiry matching token lifetime\n3. **CSRF Protection**: Double-submit cookie with constant-time comparison\n4. **Rate Limiting**: Tiered limits for authenticated vs anonymous users\n5. **Helmet Security Headers**: Comprehensive CSP, HSTS with preload, XSS filter\n6. **Trust Proxy**: Correctly set for production to get real client IP\n7. **Structured Auth Logging**: Failed attempts tracked per IP with suspicious activity alerts\n8. **Webhook Signature Verification**: Stripe webhooks verified in production\n9. **Body Size Limits**: 10MB limit prevents DoS via large payloads\n\n### Recommendations\n\n1. **Apply CSRF globally** rather than per-route to prevent accidental omissions\n2. **Fix the Redis rate limiter integration** - this is important for production scaling\n3. **Register the centralized error handler** for consistent error responses\n4. **Set a sunset date for legacy auth** and communicate to clients\n\n---\n\n## Files Reviewed\n\n1. `/Users/imorgado/SPLICE/splice-backend/middleware/auth.js` - JWT authentication, token blacklist\n2. `/Users/imorgado/SPLICE/splice-backend/middleware/csrf.js` - CSRF protection\n3. `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js` - Rate limiting, credit system\n4. `/Users/imorgado/SPLICE/splice-backend/middleware/requestId.js` - Request correlation\n5. `/Users/imorgado/SPLICE/splice-backend/middleware/inputValidation.js` - Input validation helpers\n6. `/Users/imorgado/SPLICE/splice-backend/middleware/errorHandler.js` - Centralized error handling\n7. `/Users/imorgado/SPLICE/splice-backend/server.js` - Main server configuration\n8. `/Users/imorgado/SPLICE/splice-backend/services/redisClient.js` - Redis client abstraction\n9. `/Users/imorgado/SPLICE/splice-backend/utils/authLogger.js` - Structured authentication logging\n\n---\n\n## Summary\n\nThe SPLICE backend middleware is well-architected with strong security foundations. The main issues requiring attention before production are:\n\n1. **[High]** Rate limiter Redis integration has incorrect property access (`isConnected` vs `isRedisAvailable()`)\n2. **[Medium]** Missing `incr`/`expire` methods in Redis client wrapper for rate limiting\n3. **[Medium]** Centralized error handler not registered in server.js\n4. **[Medium]** CSRF protection applied per-route rather than globally\n\nOnce these issues are resolved, the middleware stack will be production-ready."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":10539,"cache_read_input_tokens":68317,"cache_creation":{"ephemeral_5m_input_tokens":10539,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2UNSAvG9pocjone9FgL","type":"assistant","uuid":"f305f64a-1257-473f-b08c-f06e454f2b0a","timestamp":"2026-01-11T23:40:10.277Z"}
