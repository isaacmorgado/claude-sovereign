     1→/**
     2→ * SPLICE CEP Panel - Animated Captions Module
     3→ * Word-by-word animated captions with template gallery and preview
     4→ * v4.0.0 - CEP Migration
     5→ */
     6→
     7→// ============================================================================
     8→// STATE
     9→// ============================================================================
    10→const animatedCaptionsState = {
    11→    templates: [],
    12→    selectedTemplate: 'mrbeast',
    13→    captions: null,
    14→    keywords: [],
    15→    settings: {
    16→        maxWordsPerLine: 4,
    17→        highlightKeywords: true,
    18→        insertEmojis: false,
    19→        emojiFrequency: 'medium'
    20→    },
    21→    isGenerating: false,
    22→    lastTranscript: null
    23→};
    24→
    25→// ============================================================================
    26→// DOM ELEMENT CACHE
    27→// ============================================================================
    28→const captionsUI = {};
    29→
    30→function cacheCaptionElements() {
    31→    captionsUI.section = document.getElementById('captionsSection');
    32→    captionsUI.toggle = document.getElementById('captionsToggle');
    33→    captionsUI.panel = document.getElementById('captionsPanel');
    34→    captionsUI.templateGallery = document.getElementById('captionTemplateGallery');
    35→    captionsUI.previewContainer = document.getElementById('captionPreviewContainer');
    36→    captionsUI.stats = document.getElementById('captionStats');
    37→    captionsUI.status = document.getElementById('captionStatus');
    38→
    39→    // Settings
    40→    captionsUI.wordsPerLine = document.getElementById('captionWordsPerLine');
    41→    captionsUI.highlightKeywords = document.getElementById('captionHighlightKeywords');
    42→    captionsUI.insertEmojis = document.getElementById('captionInsertEmojis');
    43→    captionsUI.emojiFrequency = document.getElementById('captionEmojiFrequency');
    44→
    45→    // Buttons
    46→    captionsUI.generateBtn = document.getElementById('generateCaptionsBtn');
    47→    captionsUI.exportSrtBtn = document.getElementById('exportCaptionsSrtBtn');
    48→    captionsUI.exportMogrtBtn = document.getElementById('exportCaptionsMogrtBtn');
    49→    captionsUI.applyBtn = document.getElementById('applyCaptionsBtn');
    50→    captionsUI.copyBtn = document.getElementById('copyCaptionsBtn');
    51→}
    52→
    53→// ============================================================================
    54→// INITIALIZATION
    55→// ============================================================================
    56→async function initAnimatedCaptions() {
    57→    console.log('[SPLICE Captions] Initializing animated captions module');
    58→
    59→    cacheCaptionElements();
    60→
    61→    if (!captionsUI.section) {
    62→        console.warn('[SPLICE Captions] Captions section not found in DOM');
    63→        return;
    64→    }
    65→
    66→    // Toggle section expand/collapse
    67→    if (captionsUI.toggle) {
    68→        captionsUI.toggle.addEventListener('click', toggleCaptionsSection);
    69→    }
    70→
    71→    // Load templates
    72→    await loadCaptionTemplates();
    73→
    74→    // Setup event listeners
    75→    setupCaptionEventListeners();
    76→
    77→    // Render template gallery
    78→    renderTemplateGallery();
    79→
    80→    console.log('[SPLICE Captions] Module initialized');
    81→}
    82→
    83→// ============================================================================
    84→// SECTION TOGGLE
    85→// ============================================================================
    86→function toggleCaptionsSection() {
    87→    if (!captionsUI.panel || !captionsUI.toggle) return;
    88→
    89→    // Check state BEFORE toggling
    90→    const wasCollapsed = captionsUI.panel.classList.contains('collapsed');
    91→    captionsUI.panel.classList.toggle('collapsed');
    92→    const icon = captionsUI.toggle.querySelector('.toggle-icon');
    93→
    94→    if (icon) {
    95→        // If it was collapsed, it's now expanded (show -)
    96→        icon.textContent = wasCollapsed ? '-' : '+';
    97→    }
    98→}
    99→
   100→// ============================================================================
   101→// LOAD TEMPLATES
   102→// ============================================================================
   103→async function loadCaptionTemplates() {
   104→    try {
   105→        const apiUrl = getBackendUrl();
   106→        const response = await fetchWithTimeout(`${apiUrl}/captions/templates`, {
   107→            method: 'GET',
   108→            headers: { 'Content-Type': 'application/json' }
   109→        }, 30000);
   110→
   111→        if (response.ok) {
   112→            const data = await response.json();
   113→            animatedCaptionsState.templates = data.templates || [];
   114→            console.log(`[SPLICE Captions] Loaded ${animatedCaptionsState.templates.length} templates`);
   115→        }
   116→    } catch (err) {
   117→        console.error('[SPLICE Captions] Failed to load templates:', err);
   118→        // Use fallback templates
   119→        animatedCaptionsState.templates = [
   120→            { id: 'mrbeast', name: 'MrBeast', description: 'Bold, uppercase, colorful' },
   121→            { id: 'hormozi', name: 'Hormozi', description: 'Clean, yellow highlight' },
   122→            { id: 'gaming', name: 'Gaming', description: 'Neon glow, glitch effects' },
   123→            { id: 'corporate', name: 'Corporate', description: 'Subtle, professional' },
   124→            { id: 'karaoke', name: 'Karaoke', description: 'Word-by-word highlight' }
   125→        ];
   126→    }
   127→}
   128→
   129→// ============================================================================
   130→// EVENT LISTENERS
   131→// ============================================================================
   132→function setupCaptionEventListeners() {
   133→    // Template gallery delegation
   134→    if (captionsUI.templateGallery) {
   135→        captionsUI.templateGallery.addEventListener('click', (e) => {
   136→            const card = e.target.closest('.caption-template-card');
   137→            if (card) {
   138→                selectCaptionTemplate(card.dataset.templateId);
   139→            }
   140→        });
   141→    }
   142→
   143→    // Generate button
   144→    if (captionsUI.generateBtn) {
   145→        captionsUI.generateBtn.addEventListener('click', generateCaptions);
   146→    }
   147→
   148→    // Export buttons
   149→    if (captionsUI.exportSrtBtn) {
   150→        captionsUI.exportSrtBtn.addEventListener('click', () => exportCaptions('srt'));
   151→    }
   152→    if (captionsUI.exportMogrtBtn) {
   153→        captionsUI.exportMogrtBtn.addEventListener('click', () => exportCaptions('mogrt'));
   154→    }
   155→
   156→    // Apply to timeline button
   157→    if (captionsUI.applyBtn) {
   158→        captionsUI.applyBtn.addEventListener('click', applyCaptionsToTimeline);
   159→    }
   160→
   161→    // Copy button
   162→    if (captionsUI.copyBtn) {
   163→        captionsUI.copyBtn.addEventListener('click', copyCaptionsToClipboard);
   164→    }
   165→
   166→    // Settings changes
   167→    if (captionsUI.wordsPerLine) {
   168→        captionsUI.wordsPerLine.addEventListener('change', (e) => {
   169→            animatedCaptionsState.settings.maxWordsPerLine = parseInt(e.target.value) || 4;
   170→        });
   171→    }
   172→    if (captionsUI.highlightKeywords) {
   173→        captionsUI.highlightKeywords.addEventListener('change', (e) => {
   174→            animatedCaptionsState.settings.highlightKeywords = e.target.checked;
   175→        });
   176→    }
   177→    if (captionsUI.insertEmojis) {
   178→        captionsUI.insertEmojis.addEventListener('change', (e) => {
   179→            animatedCaptionsState.settings.insertEmojis = e.target.checked;
   180→            // Toggle emoji frequency group visibility
   181→            const emojiFrequencyGroup = document.getElementById('emojiFrequencyGroup');
   182→            if (emojiFrequencyGroup) {
   183→                emojiFrequencyGroup.style.display = e.target.checked ? 'block' : 'none';
   184→            }
   185→        });
   186→    }
   187→    if (captionsUI.emojiFrequency) {
   188→        captionsUI.emojiFrequency.addEventListener('change', (e) => {
   189→            animatedCaptionsState.settings.emojiFrequency = e.target.value;
   190→        });
   191→    }
   192→}
   193→
   194→// ============================================================================
   195→// TEMPLATE GALLERY
   196→// ============================================================================
   197→function renderTemplateGallery() {
   198→    if (!captionsUI.templateGallery) return;
   199→
   200→    const fragment = document.createDocumentFragment();
   201→
   202→    animatedCaptionsState.templates.forEach(template => {
   203→        const card = document.createElement('div');
   204→        card.className = `caption-template-card ${animatedCaptionsState.selectedTemplate === template.id ? 'selected' : ''}`;
   205→        card.dataset.templateId = template.id;
   206→        card.setAttribute('role', 'button');
   207→        card.setAttribute('tabindex', '0');
   208→        card.setAttribute('aria-label', `Select ${escapeHtmlCaptions(template.name)} template`);
   209→
   210→        // SECURITY: Escape template data to prevent XSS (even though it comes from backend/fallback)
   211→        const safeId = escapeHtmlCaptions(template.id);
   212→        const safeName = escapeHtmlCaptions(template.name);
   213→        const safeDesc = escapeHtmlCaptions(template.description);
   214→
   215→        card.innerHTML = `
   216→            <div class="template-preview template-preview-${safeId}">
   217→                <span class="template-preview-text">Hello World</span>
   218→            </div>
   219→            <div class="template-info">
   220→                <span class="template-name">${safeName}</span>
   221→                <span class="template-desc">${safeDesc}</span>
   222→            </div>
   223→        `;
   224→
   225→        fragment.appendChild(card);
   226→    });
   227→
   228→    captionsUI.templateGallery.innerHTML = '';
   229→    captionsUI.templateGallery.appendChild(fragment);
   230→}
   231→
   232→function selectCaptionTemplate(templateId) {
   233→    animatedCaptionsState.selectedTemplate = templateId;
   234→
   235→    // Update UI
   236→    document.querySelectorAll('.caption-template-card').forEach(card => {
   237→        card.classList.toggle('selected', card.dataset.templateId === templateId);
   238→    });
   239→
   240→    console.log(`[SPLICE Captions] Selected template: ${templateId}`);
   241→
   242→    // Re-apply template if we have captions
   243→    if (animatedCaptionsState.captions) {
   244→        applyTemplateToExisting(templateId);
   245→    }
   246→}
   247→
   248→async function applyTemplateToExisting(templateId) {
   249→    if (!animatedCaptionsState.captions) return;
   250→
   251→    try {
   252→        const apiUrl = getBackendUrl();
   253→        const response = await fetchWithTimeout(`${apiUrl}/captions/apply-template`, {
   254→            method: 'POST',
   255→            headers: getAuthHeaders(),
   256→            body: JSON.stringify({
   257→                captionData: { captions: animatedCaptionsState.captions },
   258→                templateId
   259→            })
   260→        }, 30000);
   261→
   262→        if (response.ok) {
   263→            const data = await response.json();
   264→            animatedCaptionsState.captions = data.captions;
   265→            renderCaptionPreview();
   266→        }
   267→    } catch (err) {
   268→        console.error('[SPLICE Captions] Failed to apply template:', err);
   269→    }
   270→}
   271→
   272→// ============================================================================
   273→// CAPTION GENERATION
   274→// ============================================================================
   275→async function generateCaptions() {
   276→    const transcript = getLastTranscript();
   277→    if (!transcript) {
   278→        showCaptionStatus('No transcript available. Run transcription first.', 'error');
   279→        return;
   280→    }
   281→
   282→    // Check online status
   283→    if (typeof isOnline === 'function' && !isOnline()) {
   284→        showCaptionStatus('Offline - Check your connection', 'error');
   285→        return;
   286→    }
   287→
   288→    animatedCaptionsState.isGenerating = true;
   289→    updateGenerateButton(true);
   290→    showCaptionStatus('Generating animated captions...', 'info');
   291→
   292→    try {
   293→        const apiUrl = getBackendUrl();
   294→        const response = await fetchWithTimeout(`${apiUrl}/captions/animate`, {
   295→            method: 'POST',
   296→            headers: getAuthHeaders(),
   297→            body: JSON.stringify({
   298→                transcript,
   299→                template: animatedCaptionsState.selectedTemplate,
   300→                settings: animatedCaptionsState.settings
   301→            })
   302→        }, 120000);
   303→
   304→        if (!response.ok) {
   305→            const errorMsg = await parseErrorResponse(response);
   306→            throw new Error(errorMsg);
   307→        }
   308→
   309→        const data = await response.json();
   310→        animatedCaptionsState.captions = data.captions;
   311→        animatedCaptionsState.keywords = data.keywords || [];
   312→
   313→        // Update UI
   314→        renderCaptionPreview();
   315→        updateCaptionStats(data);
   316→        showCaptionExportActions(true);
   317→        showCaptionStatus(`Generated ${data.totalCaptions} caption lines`, 'success');
   318→
   319→    } catch (err) {
   320→        console.error('[SPLICE Captions] Generation error:', err);
   321→        showCaptionStatus(err.message, 'error');
   322→    } finally {
   323→        animatedCaptionsState.isGenerating = false;
   324→        updateGenerateButton(false);
   325→    }
   326→}
   327→
   328→function getLastTranscript() {
   329→    // Try main module state
   330→    if (window.spliceState?.lastTranscript) {
   331→        return window.spliceState.lastTranscript;
   332→    }
   333→    // Try local state
   334→    if (animatedCaptionsState.lastTranscript) {
   335→        return animatedCaptionsState.lastTranscript;
   336→    }
   337→    return null;
   338→}
   339→
   340→function setCaptionTranscript(transcript) {
   341→    animatedCaptionsState.lastTranscript = transcript;
   342→}
   343→
   344→// ============================================================================
   345→// CAPTION PREVIEW
   346→// ============================================================================
   347→function renderCaptionPreview() {
   348→    if (!captionsUI.previewContainer || !animatedCaptionsState.captions) return;
   349→
   350→    const captions = animatedCaptionsState.captions.slice(0, 10);
   351→    const fragment = document.createDocumentFragment();
   352→
   353→    const list = document.createElement('div');
   354→    list.className = 'caption-preview-list';
   355→
   356→    captions.forEach((caption, i) => {
   357→        const item = document.createElement('div');
   358→        item.className = 'caption-preview-item';
   359→        item.dataset.index = i;
   360→
   361→        const hasKeywords = caption.words?.some(w => w.isKeyword);
   362→        item.innerHTML = `
   363→            <span class="caption-time">${formatCaptionTime(caption.start)}</span>
   364→            <span class="caption-text ${hasKeywords ? 'has-keywords' : ''}">${formatCaptionText(caption)}</span>
   365→        `;
   366→
   367→        list.appendChild(item);
   368→    });
   369→
   370→    if (animatedCaptionsState.captions.length > 10) {
   371→        const more = document.createElement('div');
   372→        more.className = 'caption-preview-more';
   373→        more.textContent = `+ ${animatedCaptionsState.captions.length - 10} more captions`;
   374→        list.appendChild(more);
   375→    }
   376→
   377→    fragment.appendChild(list);
   378→
   379→    captionsUI.previewContainer.innerHTML = '';
   380→    captionsUI.previewContainer.appendChild(fragment);
   381→}
   382→
   383→// SECURITY: Escape HTML to prevent XSS
   384→function escapeHtmlCaptions(str) {
   385→    if (!str) return '';
   386→    const div = document.createElement('div');
   387→    div.textContent = str;
   388→    return div.innerHTML;
   389→}
   390→
   391→function formatCaptionText(caption) {
   392→    if (!caption.words) return escapeHtmlCaptions(caption.text);
   393→
   394→    // SECURITY: Escape user-provided word content to prevent XSS
   395→    return caption.words.map(word => {
   396→        const safeWord = escapeHtmlCaptions(word.word);
   397→        if (word.isKeyword) {
   398→            return `<span class="caption-keyword">${safeWord}</span>`;
   399→        }
   400→        if (word.emoji) {
   401→            const safeEmoji = escapeHtmlCaptions(word.emoji);
   402→            return `${safeWord} ${safeEmoji}`;
   403→        }
   404→        return safeWord;
   405→    }).join(' ');
   406→}
   407→
   408→function formatCaptionTime(seconds) {
   409→    const mins = Math.floor(seconds / 60);
   410→    const secs = Math.floor(seconds % 60);
   411→    return `${mins}:${secs.toString().padStart(2, '0')}`;
   412→}
   413→
   414→function updateCaptionStats(data) {
   415→    if (!captionsUI.stats) return;
   416→
   417→    captionsUI.stats.innerHTML = `
   418→        <span class="stat-item">${data.totalCaptions} lines</span>
   419→        <span class="stat-item">${data.totalWords} words</span>
   420→        <span class="stat-item">${data.keywords?.length || 0} keywords</span>
   421→        <span class="stat-item">${formatCaptionTime(data.duration)}</span>
   422→    `;
   423→}
   424→
   425→// ============================================================================
   426→// EXPORT FUNCTIONS
   427→// ============================================================================
   428→async function exportCaptions(format) {
   429→    if (!animatedCaptionsState.captions) {
   430→        showCaptionStatus('No captions to export. Generate captions first.', 'error');
   431→        return;
   432→    }
   433→
   434→    showCaptionStatus(`Exporting ${format.toUpperCase()}...`, 'info');
   435→
   436→    try {
   437→        const apiUrl = getBackendUrl();
   438→        let endpoint, body;
   439→
   440→        if (format === 'mogrt') {
   441→            endpoint = '/captions/export/mogrt';
   442→            body = {
   443→                captions: animatedCaptionsState.captions,
   444→                settings: { frameRate: 30, width: 1920, height: 1080 }
   445→            };
   446→        } else {
   447→            endpoint = '/export/captions';
   448→            body = {
   449→                transcript: { words: flattenCaptionWords() },
   450→                format
   451→            };
   452→        }
   453→
   454→        const response = await fetchWithTimeout(`${apiUrl}${endpoint}`, {
   455→            method: 'POST',
   456→            headers: getAuthHeaders(),
   457→            body: JSON.stringify(body)
   458→        }, 60000);
   459→
   460→        if (!response.ok) {
   461→            const errorMsg = await parseErrorResponse(response);
   462→            throw new Error(errorMsg);
   463→        }
   464→
   465→        const data = await response.json();
   466→
   467→        if (format === 'mogrt') {
   468→            downloadJSON(data.data, 'animated-captions-mogrt.json');
   469→            showCaptionStatus('MOGRT data exported', 'success');
   470→        } else {
   471→            downloadText(data.content, `captions.${format}`);
   472→            showCaptionStatus(`${format.toUpperCase()} exported`, 'success');
   473→        }
   474→
   475→    } catch (err) {
   476→        console.error('[SPLICE Captions] Export error:', err);
   477→        showCaptionStatus(err.message, 'error');
   478→    }
   479→}
   480→
   481→function flattenCaptionWords() {
   482→    if (!animatedCaptionsState.captions) return [];
   483→
   484→    const words = [];
   485→    animatedCaptionsState.captions.forEach(caption => {
   486→        if (caption.words) {
   487→            caption.words.forEach(w => words.push(w));
   488→        }
   489→    });
   490→    return words;
   491→}
   492→
   493→async function copyCaptionsToClipboard() {
   494→    if (!animatedCaptionsState.captions) {
   495→        showCaptionStatus('No captions to copy', 'error');
   496→        return;
   497→    }
   498→
   499→    const text = animatedCaptionsState.captions
   500→        .map(c => `[${formatCaptionTime(c.start)}] ${c.text}`)
   501→        .join('\n');
   502→
   503→    try {
   504→        await navigator.clipboard.writeText(text);
   505→        showCaptionStatus('Captions copied to clipboard', 'success');
   506→    } catch (err) {
   507→        console.error('[SPLICE Captions] Copy failed:', err);
   508→        showCaptionStatus('Failed to copy', 'error');
   509→    }
   510→}
   511→
   512→// ============================================================================
   513→// TIMELINE INTEGRATION
   514→// ============================================================================
   515→async function applyCaptionsToTimeline() {
   516→    if (!animatedCaptionsState.captions) {
   517→        showCaptionStatus('No captions to apply', 'error');
   518→        return;
   519→    }
   520→
   521→    showCaptionStatus('Applying captions to timeline...', 'info');
   522→
   523→    try {
   524→        // Create markers for each caption
   525→        for (const caption of animatedCaptionsState.captions) {
   526→            const duration = caption.end - caption.start;
   527→            await jsx.call('createMarker', caption.start, caption.text, duration, null, 5); // CERULEAN color
   528→        }
   529→
   530→        showCaptionStatus(`Added ${animatedCaptionsState.captions.length} caption markers`, 'success');
   531→    } catch (err) {
   532→        console.error('[SPLICE Captions] Apply error:', err);
   533→        showCaptionStatus(err.message, 'error');
   534→    }
   535→}
   536→
   537→// ============================================================================
   538→// UI HELPERS
   539→// ============================================================================
   540→function showCaptionExportActions(show) {
   541→    const exportActions = document.getElementById('captionExportActions');
   542→    if (exportActions) {
   543→        exportActions.classList.toggle('hidden', !show);
   544→    }
   545→}
   546→
   547→function showCaptionStatus(message, type = 'info') {
   548→    if (!captionsUI.status) return;
   549→
   550→    captionsUI.status.textContent = message;
   551→    captionsUI.status.className = `caption-status caption-status-${type}`;
   552→
   553→    // Auto-clear after 5 seconds for success/info
   554→    if (type !== 'error') {
   555→        setTimeout(() => {
   556→            captionsUI.status.textContent = '';
   557→            captionsUI.status.className = 'caption-status';
   558→        }, 5000);
   559→    }
   560→}
   561→
   562→function updateGenerateButton(isGenerating) {
   563→    if (!captionsUI.generateBtn) return;
   564→
   565→    captionsUI.generateBtn.disabled = isGenerating;
   566→    captionsUI.generateBtn.textContent = isGenerating ? 'Generating...' : 'Generate Captions';
   567→}
   568→
   569→function downloadJSON(data, filename) {
   570→    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
   571→    const url = URL.createObjectURL(blob);
   572→    const a = document.createElement('a');
   573→    a.href = url;
   574→    a.download = filename;
   575→    a.click();
   576→    URL.revokeObjectURL(url);
   577→}
   578→
   579→function downloadText(content, filename) {
   580→    const blob = new Blob([content], { type: 'text/plain' });
   581→    const url = URL.createObjectURL(blob);
   582→    const a = document.createElement('a');
   583→    a.href = url;
   584→    a.download = filename;
   585→    a.click();
   586→    URL.revokeObjectURL(url);
   587→}
   588→
   589→// ============================================================================
   590→// EXPORTS
   591→// ============================================================================
   592→if (typeof window !== 'undefined') {
   593→    window.initAnimatedCaptions = initAnimatedCaptions;
   594→    window.spliceAnimatedCaptions = {
   595→        init: initAnimatedCaptions,
   596→        generate: generateCaptions,
   597→        setTranscript: setCaptionTranscript,
   598→        selectTemplate: selectCaptionTemplate,
   599→        export: exportCaptions,
   600→        applyToTimeline: applyCaptionsToTimeline,
   601→        getState: () => animatedCaptionsState
   602→    };
   603→}
   604→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
