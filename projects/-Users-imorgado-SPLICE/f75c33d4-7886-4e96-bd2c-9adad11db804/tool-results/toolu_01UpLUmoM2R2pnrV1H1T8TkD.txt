     1→/**
     2→ * SPLICE CEP Panel - Multitrack UI Module
     3→ * Multi-speaker analysis, auto-balance, and timeline building
     4→ * v4.0.0 - CEP Migration
     5→ */
     6→
     7→// ============================================================================
     8→// STATE
     9→// ============================================================================
    10→let speakerConfig = [];
    11→let analysisResults = null;
    12→let isMultitrackOperationInProgress = false;
    13→
    14→// Speaker colors for visual distinction
    15→const SPEAKER_COLORS = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3'];
    16→
    17→// ============================================================================
    18→// DOM ELEMENT CACHE
    19→// ============================================================================
    20→const multitrackUI = {};
    21→
    22→function cacheMultitrackElements() {
    23→    multitrackUI.section = document.getElementById('multitrackSection');
    24→    multitrackUI.toggle = document.getElementById('multitrackToggle');
    25→    multitrackUI.panel = document.getElementById('multitrackPanel');
    26→    multitrackUI.speakerList = document.getElementById('speakerList');
    27→    multitrackUI.addSpeakerBtn = document.getElementById('addSpeakerBtn');
    28→    multitrackUI.wideShotTrack = document.getElementById('wideShotTrack');
    29→
    30→    // Parameters
    31→    multitrackUI.minShotDuration = document.getElementById('minShotDuration');
    32→    multitrackUI.minShotDurationValue = document.getElementById('minShotDurationValue');
    33→    multitrackUI.wideShotPercent = document.getElementById('wideShotPercent');
    34→    multitrackUI.wideShotPercentValue = document.getElementById('wideShotPercentValue');
    35→    multitrackUI.switchingFrequency = document.getElementById('switchingFrequency');
    36→    multitrackUI.switchingFrequencyValue = document.getElementById('switchingFrequencyValue');
    37→    multitrackUI.enableWideShotDetection = document.getElementById('enableWideShotDetection');
    38→
    39→    // Actions
    40→    multitrackUI.analyzeBtn = document.getElementById('analyzeMultitrackBtn');
    41→    multitrackUI.autoBalanceBtn = document.getElementById('autoBalanceBtn');
    42→    multitrackUI.applyBtn = document.getElementById('applyMultitrackBtn');
    43→
    44→    // Preview
    45→    multitrackUI.preview = document.getElementById('multitrackPreview');
    46→    multitrackUI.distributionChart = document.getElementById('distributionChart');
    47→    multitrackUI.speakerStats = document.getElementById('speakerStats');
    48→    multitrackUI.decisionCount = document.getElementById('decisionCount');
    49→    multitrackUI.decisionList = document.getElementById('decisionList');
    50→}
    51→
    52→// ============================================================================
    53→// INITIALIZATION
    54→// ============================================================================
    55→function initMultitrackUI() {
    56→    cacheMultitrackElements();
    57→
    58→    if (!multitrackUI.section) {
    59→        console.warn('[SPLICE Multitrack] Multitrack section not found in DOM');
    60→        return;
    61→    }
    62→
    63→    // Toggle section expand/collapse
    64→    if (multitrackUI.toggle) {
    65→        multitrackUI.toggle.addEventListener('click', toggleMultitrackSection);
    66→    }
    67→
    68→    // Add speaker button
    69→    if (multitrackUI.addSpeakerBtn) {
    70→        multitrackUI.addSpeakerBtn.addEventListener('click', addSpeaker);
    71→    }
    72→
    73→    // Speaker list event delegation (remove buttons, name changes)
    74→    if (multitrackUI.speakerList) {
    75→        multitrackUI.speakerList.addEventListener('click', handleSpeakerListClick);
    76→        multitrackUI.speakerList.addEventListener('change', handleSpeakerListChange);
    77→    }
    78→
    79→    // Parameter sliders
    80→    setupParameterListeners();
    81→
    82→    // Action buttons
    83→    if (multitrackUI.analyzeBtn) {
    84→        multitrackUI.analyzeBtn.addEventListener('click', analyzeMultitrack);
    85→    }
    86→    if (multitrackUI.autoBalanceBtn) {
    87→        multitrackUI.autoBalanceBtn.addEventListener('click', autoBalanceMultitrack);
    88→    }
    89→    if (multitrackUI.applyBtn) {
    90→        multitrackUI.applyBtn.addEventListener('click', applyMultitrackCuts);
    91→    }
    92→
    93→    // Decision list event delegation (seek buttons)
    94→    if (multitrackUI.decisionList) {
    95→        multitrackUI.decisionList.addEventListener('click', handleDecisionListClick);
    96→    }
    97→
    98→    // Initialize speaker config from DOM
    99→    initSpeakerConfigFromDOM();
   100→
   101→    console.log('[SPLICE Multitrack] UI initialized');
   102→}
   103→
   104→// ============================================================================
   105→// SECTION TOGGLE
   106→// ============================================================================
   107→function toggleMultitrackSection() {
   108→    if (!multitrackUI.panel || !multitrackUI.toggle) return;
   109→
   110→    // Check state BEFORE toggling
   111→    const wasCollapsed = multitrackUI.panel.classList.contains('collapsed');
   112→    multitrackUI.panel.classList.toggle('collapsed');
   113→    const icon = multitrackUI.toggle.querySelector('.toggle-icon');
   114→
   115→    if (icon) {
   116→        // If it was collapsed, it's now expanded (show -)
   117→        icon.textContent = wasCollapsed ? '-' : '+';
   118→    }
   119→}
   120→
   121→// ============================================================================
   122→// SPEAKER CONFIGURATION
   123→// ============================================================================
   124→function initSpeakerConfigFromDOM() {
   125→    speakerConfig = [];
   126→    const items = multitrackUI.speakerList?.querySelectorAll('.speaker-item') || [];
   127→
   128→    items.forEach((item, index) => {
   129→        const nameInput = item.querySelector('.speaker-name');
   130→        const trackSelect = item.querySelector('.speaker-track');
   131→
   132→        speakerConfig.push({
   133→            index,
   134→            name: nameInput?.value || `Speaker ${index + 1}`,
   135→            videoTrack: parseInt(trackSelect?.value || index)
   136→        });
   137→    });
   138→}
   139→
   140→function addSpeaker() {
   141→    if (speakerConfig.length >= 4) {
   142→        setStatus('Maximum 4 speakers supported');
   143→        return;
   144→    }
   145→
   146→    const newIndex = speakerConfig.length;
   147→    const defaultName = `Speaker ${newIndex + 1}`;
   148→
   149→    speakerConfig.push({
   150→        index: newIndex,
   151→        name: defaultName,
   152→        videoTrack: newIndex
   153→    });
   154→
   155→    // Add DOM element
   156→    // SECURITY: Escape dynamic content to prevent XSS
   157→    const speakerItem = document.createElement('div');
   158→    speakerItem.className = `speaker-item speaker-${newIndex}`;
   159→    speakerItem.dataset.speakerIndex = newIndex;
   160→    speakerItem.innerHTML = `
   161→        <input type="text" class="speaker-name" value="${escapeHtml(defaultName)}" placeholder="Name" aria-label="Speaker ${newIndex + 1} name">
   162→        <select class="speaker-track" aria-label="Speaker ${newIndex + 1} video track">
   163→            <option value="0" ${newIndex === 0 ? 'selected' : ''}>V1</option>
   164→            <option value="1" ${newIndex === 1 ? 'selected' : ''}>V2</option>
   165→            <option value="2" ${newIndex === 2 ? 'selected' : ''}>V3</option>
   166→            <option value="3" ${newIndex === 3 ? 'selected' : ''}>V4</option>
   167→        </select>
   168→        <button class="speaker-remove-btn" title="Remove speaker" aria-label="Remove speaker ${newIndex + 1}">x</button>
   169→    `;
   170→
   171→    multitrackUI.speakerList.appendChild(speakerItem);
   172→
   173→    // Update remove button visibility
   174→    updateRemoveButtonVisibility();
   175→}
   176→
   177→function removeSpeaker(index) {
   178→    if (speakerConfig.length <= 2) {
   179→        setStatus('Minimum 2 speakers required');
   180→        return;
   181→    }
   182→
   183→    speakerConfig.splice(index, 1);
   184→
   185→    // Remove from DOM
   186→    const item = multitrackUI.speakerList.querySelector(`[data-speaker-index="${index}"]`);
   187→    if (item) {
   188→        item.remove();
   189→    }
   190→
   191→    // Re-index remaining speakers
   192→    reindexSpeakers();
   193→
   194→    // Update remove button visibility
   195→    updateRemoveButtonVisibility();
   196→}
   197→
   198→function reindexSpeakers() {
   199→    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
   200→    items.forEach((item, i) => {
   201→        item.dataset.speakerIndex = i;
   202→        item.className = `speaker-item speaker-${i}`;
   203→
   204→        // Update speakerConfig
   205→        if (speakerConfig[i]) {
   206→            speakerConfig[i].index = i;
   207→        }
   208→    });
   209→}
   210→
   211→function updateRemoveButtonVisibility() {
   212→    const items = multitrackUI.speakerList.querySelectorAll('.speaker-item');
   213→    const canRemove = items.length > 2;
   214→
   215→    items.forEach(item => {
   216→        const btn = item.querySelector('.speaker-remove-btn');
   217→        if (btn) {
   218→            btn.style.display = canRemove ? 'block' : 'none';
   219→        }
   220→    });
   221→}
   222→
   223→function handleSpeakerListClick(e) {
   224→    const removeBtn = e.target.closest('.speaker-remove-btn');
   225→    if (removeBtn) {
   226→        const item = removeBtn.closest('.speaker-item');
   227→        const index = parseInt(item?.dataset.speakerIndex || 0);
   228→        removeSpeaker(index);
   229→    }
   230→}
   231→
   232→function handleSpeakerListChange(e) {
   233→    const item = e.target.closest('.speaker-item');
   234→    if (!item) return;
   235→
   236→    const index = parseInt(item.dataset.speakerIndex || 0);
   237→
   238→    if (e.target.classList.contains('speaker-name')) {
   239→        speakerConfig[index].name = e.target.value;
   240→    } else if (e.target.classList.contains('speaker-track')) {
   241→        speakerConfig[index].videoTrack = parseInt(e.target.value);
   242→    }
   243→}
   244→
   245→// ============================================================================
   246→// PARAMETER LISTENERS
   247→// ============================================================================
   248→function setupParameterListeners() {
   249→    // Min shot duration slider
   250→    if (multitrackUI.minShotDuration && multitrackUI.minShotDurationValue) {
   251→        multitrackUI.minShotDuration.addEventListener('input', () => {
   252→            multitrackUI.minShotDurationValue.textContent =
   253→                parseFloat(multitrackUI.minShotDuration.value).toFixed(1) + 's';
   254→        });
   255→    }
   256→
   257→    // Wide shot percentage slider
   258→    if (multitrackUI.wideShotPercent && multitrackUI.wideShotPercentValue) {
   259→        multitrackUI.wideShotPercent.addEventListener('input', () => {
   260→            multitrackUI.wideShotPercentValue.textContent =
   261→                multitrackUI.wideShotPercent.value + '%';
   262→        });
   263→    }
   264→
   265→    // Switching frequency slider
   266→    if (multitrackUI.switchingFrequency && multitrackUI.switchingFrequencyValue) {
   267→        multitrackUI.switchingFrequency.addEventListener('input', () => {
   268→            multitrackUI.switchingFrequencyValue.textContent =
   269→                multitrackUI.switchingFrequency.value;
   270→        });
   271→    }
   272→}
   273→
   274→// ============================================================================
   275→// GET SETTINGS
   276→// ============================================================================
   277→function getMultitrackSettings() {
   278→    return {
   279→        minShotDuration: parseFloat(multitrackUI.minShotDuration?.value || 2),
   280→        wideShotPercentage: parseInt(multitrackUI.wideShotPercent?.value || 20),
   281→        switchingFrequency: parseInt(multitrackUI.switchingFrequency?.value || 50),
   282→        wideShotEnabled: multitrackUI.enableWideShotDetection?.checked ?? true,
   283→        wideShotTracks: multitrackUI.wideShotTrack?.value !== '-1'
   284→            ? [parseInt(multitrackUI.wideShotTrack.value)]
   285→            : [],
   286→        speakerNames: speakerConfig.map(s => s.name),
   287→        videoTrackMapping: speakerConfig.reduce((acc, s) => {
   288→            acc[s.index] = s.videoTrack;
   289→            return acc;
   290→        }, {})
   291→    };
   292→}
   293→
   294→// ============================================================================
   295→// GET AUDIO PATH (CEP VERSION)
   296→// ============================================================================
   297→async function getAudioPath() {
   298→    try {
   299→        // Try to get audio path from active sequence
   300→        const seqInfo = await jsx.call('getActiveSequence');
   301→        if (seqInfo && seqInfo.audioPath) {
   302→            return seqInfo.audioPath;
   303→        }
   304→
   305→        // Fallback: export sequence audio for analysis
   306→        const exportResult = await jsx.call('exportSequenceAudioForAnalysis');
   307→        if (exportResult && exportResult.path) {
   308→            return exportResult.path;
   309→        }
   310→
   311→        // Last resort: get first clip audio path
   312→        const clipPath = await jsx.call('getFirstClipAudioPath');
   313→        if (clipPath) {
   314→            return clipPath;
   315→        }
   316→
   317→        throw new Error('Could not determine audio path');
   318→    } catch (e) {
   319→        console.error('[SPLICE Multitrack] Failed to get audio path:', e);
   320→        throw e;
   321→    }
   322→}
   323→
   324→// ============================================================================
   325→// ANALYZE MULTITRACK
   326→// ============================================================================
   327→async function analyzeMultitrack() {
   328→    if (isMultitrackOperationInProgress) return;
   329→
   330→    // Check online status
   331→    if (typeof isOnline === 'function' && !isOnline()) {
   332→        setStatus('Offline - Check your connection');
   333→        return;
   334→    }
   335→
   336→    isMultitrackOperationInProgress = true;
   337→    if (multitrackUI.analyzeBtn) {
   338→        multitrackUI.analyzeBtn.disabled = true;
   339→        multitrackUI.analyzeBtn.textContent = 'Analyzing...';
   340→    }
   341→
   342→    try {
   343→        setStatus('Exporting audio tracks...');
   344→
   345→        // Get audio path
   346→        const audioPath = await getAudioPath();
   347→        if (!audioPath) {
   348→            throw new Error('Audio export path not initialized');
   349→        }
   350→
   351→        // For now, we use the main audio path
   352→        // In a full implementation, we'd export separate tracks per speaker
   353→        const audioPaths = [audioPath];
   354→
   355→        // Add additional tracks if multi-track sequence
   356→        if (speakerConfig.length > 1) {
   357→            for (let i = 1; i < speakerConfig.length; i++) {
   358→                audioPaths.push(audioPath);
   359→            }
   360→        }
   361→
   362→        setStatus('Analyzing speakers...');
   363→
   364→        const settings = getMultitrackSettings();
   365→        const apiUrl = getBackendUrl();
   366→
   367→        const response = await fetchWithTimeout(`${apiUrl}/multitrack`, {
   368→            method: 'POST',
   369→            headers: getAuthHeaders(),
   370→            body: JSON.stringify({
   371→                audioPaths,
   372→                speakerNames: settings.speakerNames,
   373→                videoTrackMapping: settings.videoTrackMapping,
   374→                wideShotEnabled: settings.wideShotEnabled,
   375→                wideShotPercentage: settings.wideShotPercentage,
   376→                wideShotTracks: settings.wideShotTracks,
   377→                minShotDuration: settings.minShotDuration,
   378→                switchingFrequency: settings.switchingFrequency
   379→            })
   380→        }, 120000);
   381→
   382→        if (!response.ok) {
   383→            const errorMsg = await parseErrorResponse(response);
   384→            throw new Error(errorMsg);
   385→        }
   386→
   387→        const data = await response.json();
   388→        analysisResults = data;
   389→
   390→        // Display results
   391→        displayMultitrackResults(data);
   392→
   393→        // Enable apply button
   394→        if (multitrackUI.applyBtn) {
   395→            multitrackUI.applyBtn.disabled = false;
   396→        }
   397→
   398→        setStatus(`Analysis complete - ${data.decisions?.length || 0} switching decisions`);
   399→
   400→    } catch (err) {
   401→        console.error('[SPLICE Multitrack] Analysis error:', err);
   402→        setStatus('Analysis failed: ' + err.message, true);
   403→    } finally {
   404→        isMultitrackOperationInProgress = false;
   405→        if (multitrackUI.analyzeBtn) {
   406→            multitrackUI.analyzeBtn.disabled = false;
   407→            multitrackUI.analyzeBtn.textContent = 'Analyze';
   408→        }
   409→    }
   410→}
   411→
   412→// ============================================================================
   413→// AUTO-BALANCE
   414→// ============================================================================
   415→async function autoBalanceMultitrack() {
   416→    if (isMultitrackOperationInProgress) return;
   417→
   418→    // Check online status
   419→    if (typeof isOnline === 'function' && !isOnline()) {
   420→        setStatus('Offline - Check your connection');
   421→        return;
   422→    }
   423→
   424→    isMultitrackOperationInProgress = true;
   425→    if (multitrackUI.autoBalanceBtn) {
   426→        multitrackUI.autoBalanceBtn.disabled = true;
   427→        multitrackUI.autoBalanceBtn.textContent = 'Balancing...';
   428→    }
   429→
   430→    try {
   431→        setStatus('Auto-balancing speaker screentime...');
   432→
   433→        const audioPath = await getAudioPath();
   434→        const audioPaths = [audioPath];
   435→
   436→        // Duplicate for multiple speakers
   437→        for (let i = 1; i < speakerConfig.length; i++) {
   438→            audioPaths.push(audioPath);
   439→        }
   440→
   441→        const settings = getMultitrackSettings();
   442→        const apiUrl = getBackendUrl();
   443→
   444→        const response = await fetchWithTimeout(`${apiUrl}/multitrack/auto-balance`, {
   445→            method: 'POST',
   446→            headers: getAuthHeaders(),
   447→            body: JSON.stringify({
   448→                audioPaths,
   449→                speakerNames: settings.speakerNames,
   450→                videoTrackMapping: settings.videoTrackMapping,
   451→                wideShotEnabled: settings.wideShotEnabled,
   452→                wideShotPercentage: settings.wideShotPercentage,
   453→                wideShotTracks: settings.wideShotTracks,
   454→                minShotDuration: settings.minShotDuration,
   455→                switchingFrequency: settings.switchingFrequency
   456→            })
   457→        }, 120000);
   458→
   459→        if (!response.ok) {
   460→            const errorMsg = await parseErrorResponse(response);
   461→            throw new Error(errorMsg);
   462→        }
   463→
   464→        const data = await response.json();
   465→        analysisResults = data;
   466→
   467→        // Display results
   468→        displayMultitrackResults(data);
   469→
   470→        // Enable apply button
   471→        if (multitrackUI.applyBtn) {
   472→            multitrackUI.applyBtn.disabled = false;
   473→        }
   474→
   475→        const errorInfo = data.finalError ? ` (${data.finalError.toFixed(1)}% deviation)` : '';
   476→        setStatus(`Auto-balance complete${errorInfo}`);
   477→
   478→    } catch (err) {
   479→        console.error('[SPLICE Multitrack] Auto-balance error:', err);
   480→        setStatus('Auto-balance failed: ' + err.message, true);
   481→    } finally {
   482→        isMultitrackOperationInProgress = false;
   483→        if (multitrackUI.autoBalanceBtn) {
   484→            multitrackUI.autoBalanceBtn.disabled = false;
   485→            multitrackUI.autoBalanceBtn.textContent = 'Auto-Balance';
   486→        }
   487→    }
   488→}
   489→
   490→// ============================================================================
   491→// DISPLAY RESULTS
   492→// ============================================================================
   493→function displayMultitrackResults(results) {
   494→    if (!results) return;
   495→
   496→    // Show preview section
   497→    if (multitrackUI.preview) {
   498→        multitrackUI.preview.classList.remove('hidden');
   499→    }
   500→
   501→    // Render distribution chart
   502→    renderDistributionChart(results.metadata);
   503→
   504→    // Render speaker stats
   505→    renderSpeakerStats(results.metadata);
   506→
   507→    // Render decision list
   508→    renderDecisionList(results.decisions || []);
   509→}
   510→
   511→function renderDistributionChart(metadata) {
   512→    if (!multitrackUI.distributionChart || !metadata) return;
   513→
   514→    const speakerPercentages = metadata.speakerPercentages || {};
   515→    const wideShotPct = metadata.wideShotPercentage || 0;
   516→
   517→    const fragment = document.createDocumentFragment();
   518→
   519→    // Add speaker bars
   520→    let speakerIndex = 0;
   521→    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
   522→        if (pct > 0) {
   523→            const bar = document.createElement('div');
   524→            bar.className = `distribution-bar speaker-${speakerIndex % 4}`;
   525→            bar.style.width = `${pct}%`;
   526→            bar.textContent = pct >= 10 ? `${speaker}: ${pct.toFixed(0)}%` : '';
   527→            bar.title = `${speaker}: ${pct.toFixed(1)}%`;
   528→            fragment.appendChild(bar);
   529→        }
   530→        speakerIndex++;
   531→    }
   532→
   533→    // Add wide shot bar
   534→    if (wideShotPct > 0) {
   535→        const bar = document.createElement('div');
   536→        bar.className = 'distribution-bar wide-shot';
   537→        bar.style.width = `${wideShotPct}%`;
   538→        bar.textContent = wideShotPct >= 8 ? `Wide: ${wideShotPct.toFixed(0)}%` : '';
   539→        bar.title = `Wide Shot: ${wideShotPct.toFixed(1)}%`;
   540→        fragment.appendChild(bar);
   541→    }
   542→
   543→    multitrackUI.distributionChart.innerHTML = '';
   544→    multitrackUI.distributionChart.appendChild(fragment);
   545→}
   546→
   547→function renderSpeakerStats(metadata) {
   548→    if (!multitrackUI.speakerStats || !metadata) return;
   549→
   550→    const speakerPercentages = metadata.speakerPercentages || {};
   551→    const wideShotPct = metadata.wideShotPercentage || 0;
   552→
   553→    const fragment = document.createDocumentFragment();
   554→
   555→    // Add speaker stats
   556→    // SECURITY: Escape speaker names to prevent XSS
   557→    let speakerIndex = 0;
   558→    for (const [speaker, pct] of Object.entries(speakerPercentages)) {
   559→        const stat = document.createElement('div');
   560→        stat.className = 'speaker-stat';
   561→        stat.innerHTML = `
   562→            <span class="speaker-stat-dot speaker-${speakerIndex % 4}"></span>
   563→            <span>${escapeHtml(speaker)}: ${escapeHtml(pct.toFixed(1))}%</span>
   564→        `;
   565→        fragment.appendChild(stat);
   566→        speakerIndex++;
   567→    }
   568→
   569→    // Add wide shot stat
   570→    if (wideShotPct > 0) {
   571→        const stat = document.createElement('div');
   572→        stat.className = 'speaker-stat';
   573→        stat.innerHTML = `
   574→            <span class="speaker-stat-dot wide-shot"></span>
   575→            <span>Wide: ${escapeHtml(wideShotPct.toFixed(1))}%</span>
   576→        `;
   577→        fragment.appendChild(stat);
   578→    }
   579→
   580→    // Add avg shot duration
   581→    if (metadata.averageShotDuration) {
   582→        const stat = document.createElement('div');
   583→        stat.className = 'speaker-stat';
   584→        stat.innerHTML = `<span style="color: #888;">Avg: ${escapeHtml(metadata.averageShotDuration.toFixed(1))}s</span>`;
   585→        fragment.appendChild(stat);
   586→    }
   587→
   588→    multitrackUI.speakerStats.innerHTML = '';
   589→    multitrackUI.speakerStats.appendChild(fragment);
   590→}
   591→
   592→function renderDecisionList(decisions) {
   593→    if (!multitrackUI.decisionList) return;
   594→
   595→    // Update count
   596→    if (multitrackUI.decisionCount) {
   597→        multitrackUI.decisionCount.textContent = decisions.length;
   598→    }
   599→
   600→    const fragment = document.createDocumentFragment();
   601→
   602→    // Limit to first 50 for performance
   603→    const displayDecisions = decisions.slice(0, 50);
   604→
   605→    displayDecisions.forEach((decision, i) => {
   606→        const item = document.createElement('div');
   607→        item.className = 'decision-item';
   608→
   609→        const speakerClass = decision.isWideShot ? 'wide-shot' : '';
   610→        const startTime = formatTime(decision.startTime);
   611→        const endTime = formatTime(decision.endTime);
   612→
   613→        // SECURITY: Escape dynamic content to prevent XSS
   614→        item.innerHTML = `
   615→            <span class="decision-time">${escapeHtml(startTime)}-${escapeHtml(endTime)}</span>
   616→            <span class="decision-speaker ${speakerClass}">${escapeHtml(decision.speakerName)}</span>
   617→            <span class="decision-reason">${escapeHtml(decision.reason || '')}</span>
   618→            <button class="decision-seek" data-time="${escapeHtml(decision.startTime)}" title="Seek to ${escapeHtml(startTime)}" aria-label="Seek to ${escapeHtml(startTime)}">&gt;</button>
   619→        `;
   620→
   621→        fragment.appendChild(item);
   622→    });
   623→
   624→    if (decisions.length > 50) {
   625→        const more = document.createElement('div');
   626→        more.className = 'decision-item';
   627→        more.style.justifyContent = 'center';
   628→        more.style.color = '#888';
   629→        more.textContent = `+ ${decisions.length - 50} more decisions`;
   630→        fragment.appendChild(more);
   631→    }
   632→
   633→    multitrackUI.decisionList.innerHTML = '';
   634→    multitrackUI.decisionList.appendChild(fragment);
   635→}
   636→
   637→function handleDecisionListClick(e) {
   638→    const seekBtn = e.target.closest('.decision-seek');
   639→    if (seekBtn) {
   640→        e.stopPropagation();
   641→        const time = parseFloat(seekBtn.dataset.time);
   642→        if (!isNaN(time)) {
   643→            seekToTime(time);
   644→        }
   645→    }
   646→}
   647→
   648→// ============================================================================
   649→// SEEK TO TIME (CEP VERSION)
   650→// ============================================================================
   651→async function seekToTime(seconds) {
   652→    try {
   653→        await jsx.call('seekToTime', seconds);
   654→    } catch (e) {
   655→        console.warn('[SPLICE Multitrack] Failed to seek:', e);
   656→    }
   657→}
   658→
   659→// ============================================================================
   660→// APPLY MULTITRACK CUTS
   661→// ============================================================================
   662→async function applyMultitrackCuts() {
   663→    if (!analysisResults || !analysisResults.decisions) {
   664→        setStatus('No analysis data. Run analysis first.');
   665→        return;
   666→    }
   667→
   668→    if (isMultitrackOperationInProgress) return;
   669→
   670→    isMultitrackOperationInProgress = true;
   671→    if (multitrackUI.applyBtn) {
   672→        multitrackUI.applyBtn.disabled = true;
   673→        multitrackUI.applyBtn.textContent = 'Applying...';
   674→    }
   675→
   676→    try {
   677→        setStatus('Building multitrack sequence...');
   678→
   679→        // Check if builder is available
   680→        if (!window.spliceBuilder) {
   681→            throw new Error('Builder not initialized');
   682→        }
   683→
   684→        // Get active sequence info
   685→        const seqInfo = await jsx.call('getActiveSequence');
   686→        if (!seqInfo) {
   687→            throw new Error('No active sequence');
   688→        }
   689→
   690→        // Create cut list from decisions
   691→        const cutList = {
   692→            version: '3.5',
   693→            source: {
   694→                name: seqInfo.name,
   695→                path: seqInfo.treePath || seqInfo.name
   696→            },
   697→            segments: analysisResults.decisions.map(d => ({
   698→                type: d.isWideShot ? 'wide_shot' : (d.speakerIndex >= 0 ? 'speaker' : 'speech'),
   699→                sourceName: seqInfo.name,
   700→                sourcePath: seqInfo.treePath || seqInfo.name,
   701→                inPoint: d.startTime,
   702→                outPoint: d.endTime,
   703→                speaker: d.speakerName,
   704→                videoTrack: d.videoTrack,
   705→                colorHint: d.isWideShot ? 'yellow' :
   706→                           (d.speakerIndex === 0 ? 'mango' :
   707→                            d.speakerIndex === 1 ? 'caribbean' :
   708→                            d.speakerIndex === 2 ? 'lavender' : 'cerulean')
   709→            })),
   710→            metadata: {
   711→                isMultitrack: true,
   712→                speakerCount: speakerConfig.length,
   713→                decisionCount: analysisResults.decisions.length,
   714→                ...analysisResults.metadata
   715→            }
   716→        };
   717→
   718→        // Build sequence
   719→        const result = await window.spliceBuilder.buildSequenceFromCutList(cutList, {
   720→            suffix: '_MULTITRACK'
   721→        });
   722→
   723→        if (result.success) {
   724→            // Hide preview
   725→            if (multitrackUI.preview) {
   726→                multitrackUI.preview.classList.add('hidden');
   727→            }
   728→
   729→            setStatus(`Multitrack sequence created: ${result.stats?.clipsInserted || 0} clips`);
   730→
   731→            // Clear results
   732→            analysisResults = null;
   733→        } else {
   734→            throw new Error(result.error || 'Failed to build sequence');
   735→        }
   736→
   737→    } catch (err) {
   738→        console.error('[SPLICE Multitrack] Apply error:', err);
   739→        setStatus('Apply failed: ' + err.message, true);
   740→    } finally {
   741→        isMultitrackOperationInProgress = false;
   742→        if (multitrackUI.applyBtn) {
   743→            multitrackUI.applyBtn.disabled = true;
   744→            multitrackUI.applyBtn.textContent = 'Apply';
   745→        }
   746→    }
   747→}
   748→
   749→// ============================================================================
   750→// EXPORTS
   751→// ============================================================================
   752→// Expose for initialization from main.js
   753→if (typeof window !== 'undefined') {
   754→    window.initMultitrackUI = initMultitrackUI;
   755→    window.spliceMultitrack = {
   756→        init: initMultitrackUI,
   757→        analyze: analyzeMultitrack,
   758→        autoBalance: autoBalanceMultitrack,
   759→        apply: applyMultitrackCuts,
   760→        getSettings: getMultitrackSettings,
   761→        getResults: () => analysisResults
   762→    };
   763→}
   764→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
