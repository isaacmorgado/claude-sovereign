{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-cep/panel/js","sessionId":"7fa929e3-00b9-497c-b311-19cb4c6b44f9","version":"2.0.76","gitBranch":"main","agentId":"a09f1cb","slug":"eager-questing-lagoon","type":"user","message":{"role":"user","content":"Analyze /Users/imorgado/SPLICE/splice-cep/panel/js/credits.js for production bottlenecks:\n\n1. **Authentication Flow**: Check for:\n   - Token refresh logic and expiry handling\n   - Race conditions with multiple simultaneous auth requests\n   - Proper CSRF token handling\n\n2. **API Calls**: Check credit checking endpoints for:\n   - Missing timeouts or retries\n   - Excessive polling frequency\n   - Blocking operations\n\n3. **Error Handling**: Verify all network calls have:\n   - Proper try/catch blocks\n   - User-friendly error messages\n   - Fallback behavior\n\n4. **State Management**: Look for:\n   - Credit balance not updating properly\n   - Race conditions with credit deductions\n   - Stale data being displayed\n\nReport issues with line numbers and severity."},"uuid":"e7924e16-0ed5-4249-a14d-69c5c1631994","timestamp":"2026-01-12T16:25:40.143Z"}
{"parentUuid":"e7924e16-0ed5-4249-a14d-69c5c1631994","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-cep/panel/js","sessionId":"7fa929e3-00b9-497c-b311-19cb4c6b44f9","version":"2.0.76","gitBranch":"main","agentId":"a09f1cb","slug":"eager-questing-lagoon","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BTpjsmphwg5r3zJNzLT1T2","type":"message","role":"assistant","content":[{"type":"text","text":"I'll analyze the credits.js file for production bottlenecks and issues."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":6801,"cache_read_input_tokens":24136,"cache_creation":{"ephemeral_5m_input_tokens":6801,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3o7hxjmfALfs42R3fRP","type":"assistant","uuid":"184b0045-824f-4ad1-89da-183f191f78ef","timestamp":"2026-01-12T16:25:43.141Z"}
{"parentUuid":"184b0045-824f-4ad1-89da-183f191f78ef","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-cep/panel/js","sessionId":"7fa929e3-00b9-497c-b311-19cb4c6b44f9","version":"2.0.76","gitBranch":"main","agentId":"a09f1cb","slug":"eager-questing-lagoon","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BTpjsmphwg5r3zJNzLT1T2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Adkm9TiGEpi8qvkBZ1mcYC","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":6801,"cache_read_input_tokens":24136,"cache_creation":{"ephemeral_5m_input_tokens":6801,"ephemeral_1h_input_tokens":0},"output_tokens":92,"service_tier":"standard"}},"requestId":"req_011CX3o7hxjmfALfs42R3fRP","type":"assistant","uuid":"0d2f5a69-a5a9-4b0e-adb5-b2b5bffb62e9","timestamp":"2026-01-12T16:25:43.581Z"}
{"parentUuid":"0d2f5a69-a5a9-4b0e-adb5-b2b5bffb62e9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-cep/panel/js","sessionId":"7fa929e3-00b9-497c-b311-19cb4c6b44f9","version":"2.0.76","gitBranch":"main","agentId":"a09f1cb","slug":"eager-questing-lagoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Adkm9TiGEpi8qvkBZ1mcYC","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Credits Display Module\n     3→ *\n     4→ * Fetches and displays user's remaining hours from the billing backend.\n     5→ * Port of UXP credits.js for CEP compatibility.\n     6→ */\n     7→\n     8→// Track fetch error state for retry UI\n     9→let lastCreditsError = null;\n    10→let creditsRetryCount = 0;\n    11→const MAX_CREDITS_RETRIES = 3;\n    12→\n    13→// Store current credits globally for access checks\n    14→let currentCredits = null;\n    15→\n    16→// Store interval reference for cleanup\n    17→let creditsRefreshInterval = null;\n    18→\n    19→/**\n    20→ * Fetch user's credit balance from backend\n    21→ * @returns {Promise<Object | null>} Credit data including isolation hours, or error object\n    22→ */\n    23→async function fetchCredits() {\n    24→    const settings = getSettings();\n    25→    const customerId = settings.customerId;\n    26→\n    27→    if (!customerId) {\n    28→        console.log('[SPLICE] No customerId configured - credits display disabled');\n    29→        lastCreditsError = null;\n    30→        return null;\n    31→    }\n    32→\n    33→    try {\n    34→        // Ensure we have a valid token before making the request\n    35→        if (typeof ensureValidToken === 'function') {\n    36→            const hasValidToken = await ensureValidToken();\n    37→            if (!hasValidToken && !settings.accessToken) {\n    38→                // No JWT token - will fall back to legacy auth in getAuthHeaders()\n    39→                debugLog('[Credits] No JWT token, using legacy auth');\n    40→            }\n    41→        }\n    42→\n    43→        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    44→            method: 'GET',\n    45→            headers: getAuthHeaders()\n    46→        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n    47→\n    48→        if (!response.ok) {\n    49→            const errorMsg = await parseErrorResponse(response);\n    50→\n    51→            // If unauthorized, try refreshing token and retry once\n    52→            if (response.status === 401 && typeof refreshAccessToken === 'function') {\n    53→                debugLog('[Credits] Got 401, attempting token refresh...');\n    54→                const refreshed = await refreshAccessToken();\n    55→                if (refreshed) {\n    56→                    // Retry with new token\n    57→                    const retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    58→                        method: 'GET',\n    59→                        headers: getAuthHeaders()\n    60→                    }, SPLICE_CONFIG.FETCH_TIMEOUT);\n    61→\n    62→                    if (retryResponse.ok) {\n    63→                        const data = await retryResponse.json();\n    64→                        lastCreditsError = null;\n    65→                        creditsRetryCount = 0;\n    66→                        return {\n    67→                            hoursRemaining: data.hoursRemaining || 0,\n    68→                            hoursTotal: data.hoursTotal || 0,\n    69→                            tierName: data.tierName || 'Free',\n    70→                            tier: data.tier || 'starter',\n    71→                            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n    72→                            isolationHoursTotal: data.isolationHoursTotal || 0,\n    73→                            hasIsolationAccess: data.hasIsolationAccess || false,\n    74→                            isolationOverageRate: data.isolationOverageRate || 0.08,\n    75→                            featureAccess: data.featureAccess || [],\n    76→                            trialDaysRemaining: data.trialDaysRemaining || null,\n    77→                            isOnTrial: data.isOnTrial || false\n    78→                        };\n    79→                    }\n    80→                }\n    81→\n    82→                // Token refresh failed - user needs to re-login\n    83→                console.warn('[SPLICE] Token refresh failed, user needs to re-login');\n    84→                if (typeof clearAuthTokens === 'function') {\n    85→                    clearAuthTokens();\n    86→                }\n    87→                return { _error: true, message: 'Session expired. Please log in again.' };\n    88→            }\n    89→\n    90→            console.error('[SPLICE] Credits fetch failed:', errorMsg);\n    91→            lastCreditsError = errorMsg;\n    92→            return { _error: true, message: errorMsg };\n    93→        }\n    94→\n    95→        const data = await response.json();\n    96→        lastCreditsError = null;\n    97→        creditsRetryCount = 0;\n    98→        return {\n    99→            hoursRemaining: data.hoursRemaining || 0,\n   100→            hoursTotal: data.hoursTotal || 0,\n   101→            tierName: data.tierName || 'Free',\n   102→            tier: data.tier || 'starter',\n   103→            // Isolation hours\n   104→            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n   105→            isolationHoursTotal: data.isolationHoursTotal || 0,\n   106→            hasIsolationAccess: data.hasIsolationAccess || false,\n   107→            isolationOverageRate: data.isolationOverageRate || 0.08,\n   108→            // Feature access\n   109→            featureAccess: data.featureAccess || [],\n   110→            // Trial info\n   111→            trialDaysRemaining: data.trialDaysRemaining || null,\n   112→            isOnTrial: data.isOnTrial || false\n   113→        };\n   114→    } catch (err) {\n   115→        console.error('[SPLICE] Credits fetch error:', err);\n   116→        lastCreditsError = err.message || 'Connection failed';\n   117→        return { _error: true, message: lastCreditsError };\n   118→    }\n   119→}\n   120→\n   121→/**\n   122→ * Clear the credits cache (call on logout)\n   123→ */\n   124→function clearCreditsCache() {\n   125→    currentCredits = null;\n   126→    lastCreditsError = null;\n   127→    creditsRetryCount = 0;\n   128→    console.log('[SPLICE] Credits cache cleared');\n   129→}\n   130→\n   131→/**\n   132→ * Update the credit display in the UI\n   133→ * @param {Object|null} credits - Credit data, error object, or null if unavailable\n   134→ */\n   135→function updateCreditDisplay(credits) {\n   136→    const creditBadge = document.getElementById('creditBadge');\n   137→    if (!creditBadge) return;\n   138→\n   139→    // Handle no customer ID configured\n   140→    if (!credits) {\n   141→        currentCredits = null;\n   142→        creditBadge.style.display = 'flex';\n   143→        creditBadge.textContent = 'Login';\n   144→        creditBadge.title = 'Click to enter license key';\n   145→        creditBadge.classList.remove('ok', 'low');\n   146→        creditBadge.classList.add('login');\n   147→        return;\n   148→    }\n   149→\n   150→    // Handle error state - show error badge with retry\n   151→    if (credits._error) {\n   152→        currentCredits = null;\n   153→        creditBadge.style.display = 'flex';\n   154→        creditBadge.textContent = 'Retry';\n   155→        creditBadge.title = `Error: ${credits.message}\\nClick to retry`;\n   156→        creditBadge.classList.remove('ok', 'low', 'login');\n   157→        creditBadge.classList.add('error');\n   158→        return;\n   159→    }\n   160→\n   161→    // Normal credit display\n   162→    currentCredits = credits;\n   163→    creditBadge.style.display = 'flex';\n   164→\n   165→    // Show referral promo when logged in\n   166→    const referralPromo = document.getElementById('referralPromo');\n   167→    if (referralPromo) {\n   168→        referralPromo.classList.remove('hidden');\n   169→    }\n   170→\n   171→    // Show trial status if on trial\n   172→    if (credits.isOnTrial && credits.trialDaysRemaining) {\n   173→        creditBadge.textContent = `Trial: ${credits.trialDaysRemaining}d`;\n   174→        creditBadge.classList.remove('error', 'login', 'ok', 'low');\n   175→        creditBadge.classList.add('trial');\n   176→    } else {\n   177→        creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n   178→        creditBadge.classList.remove('error', 'login', 'trial');\n   179→    }\n   180→\n   181→    // Build tooltip with isolation info if available\n   182→    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n   183→    if (credits.isOnTrial && credits.trialDaysRemaining) {\n   184→        tooltip = `Trial: ${credits.trialDaysRemaining} days remaining\\n` + tooltip;\n   185→    }\n   186→    if (credits.hasIsolationAccess) {\n   187→        tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n   188→    }\n   189→    creditBadge.title = tooltip;\n   190→\n   191→    // Color based on remaining hours\n   192→    if (credits.hoursRemaining <= 1) {\n   193→        creditBadge.classList.add('low');\n   194→        creditBadge.classList.remove('ok');\n   195→    } else {\n   196→        creditBadge.classList.add('ok');\n   197→        creditBadge.classList.remove('low');\n   198→    }\n   199→\n   200→    // Update isolation checkbox state based on tier access\n   201→    updateIsolationCheckboxState(credits);\n   202→}\n   203→\n   204→/**\n   205→ * Update the isolation checkbox based on tier access\n   206→ */\n   207→function updateIsolationCheckboxState(credits) {\n   208→    const isolatedCheckbox = document.getElementById('sourceIsolated');\n   209→    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n   210→\n   211→    if (!isolatedCheckbox) return;\n   212→\n   213→    if (!credits || !credits.hasIsolationAccess) {\n   214→        // Disable isolation for non-Pro/Team users\n   215→        isolatedCheckbox.disabled = true;\n   216→        isolatedCheckbox.checked = false;\n   217→        if (tierBadge) {\n   218→            tierBadge.textContent = 'Pro+';\n   219→            tierBadge.style.opacity = '1';\n   220→        }\n   221→    } else {\n   222→        // Enable isolation for Pro/Team users\n   223→        isolatedCheckbox.disabled = false;\n   224→        if (tierBadge) {\n   225→            // Show remaining isolation time\n   226→            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n   227→            tierBadge.textContent = `${minsRemaining} min`;\n   228→            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n   229→        }\n   230→    }\n   231→}\n   232→\n   233→/**\n   234→ * Check if user can use isolation and get cost estimate\n   235→ * @param {number} estimatedMinutes - Estimated audio duration in minutes\n   236→ * @returns {Object} Access info with allowed, message, overageCost\n   237→ */\n   238→function checkIsolationAccess(estimatedMinutes = 0) {\n   239→    if (!currentCredits) {\n   240→        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n   241→    }\n   242→\n   243→    if (!currentCredits.hasIsolationAccess) {\n   244→        return {\n   245→            allowed: false,\n   246→            message: 'Vocal isolation requires Pro or Team tier',\n   247→            upgradeRequired: true,\n   248→            overageCost: 0\n   249→        };\n   250→    }\n   251→\n   252→    const estimatedHours = estimatedMinutes / 60;\n   253→    const remaining = currentCredits.isolationHoursRemaining;\n   254→\n   255→    if (remaining >= estimatedHours) {\n   256→        return {\n   257→            allowed: true,\n   258→            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   259→            overageCost: 0\n   260→        };\n   261→    }\n   262→\n   263→    // Calculate overage\n   264→    const overageMinutes = estimatedMinutes - (remaining * 60);\n   265→    const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n   266→\n   267→    return {\n   268→        allowed: true,\n   269→        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n   270→        overageCost,\n   271→        overageMinutes\n   272→    };\n   273→}\n   274→\n   275→/**\n   276→ * Get current credits (for access checks)\n   277→ */\n   278→function getCurrentCredits() {\n   279→    return currentCredits;\n   280→}\n   281→\n   282→/**\n   283→ * Check if user has access to a specific feature based on their tier\n   284→ * @param {string} featureName - The feature to check (e.g., 'social_reframe', 'text_editing', 'multitrack')\n   285→ * @returns {boolean} - True if user has access\n   286→ */\n   287→function hasFeatureAccess(featureName) {\n   288→    if (!currentCredits || !currentCredits.featureAccess) {\n   289→        return false; // Not logged in = no premium features\n   290→    }\n   291→    return currentCredits.featureAccess.includes(featureName);\n   292→}\n   293→\n   294→/**\n   295→ * Get the required tier for a feature\n   296→ * @param {string} featureName - The feature name\n   297→ * @returns {string} - Required tier name\n   298→ */\n   299→function getRequiredTier(featureName) {\n   300→    const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n   301→    const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n   302→\n   303→    if (teamOnlyFeatures.includes(featureName)) {\n   304→        return 'Team';\n   305→    } else if (proFeatures.includes(featureName)) {\n   306→        return 'Pro';\n   307→    }\n   308→    return 'Starter';\n   309→}\n   310→\n   311→/**\n   312→ * Initialize credits display\n   313→ * Fetches credits on load and sets up periodic refresh\n   314→ */\n   315→async function initCredits() {\n   316→    // Clear any existing interval to prevent duplicates\n   317→    if (creditsRefreshInterval) {\n   318→        clearInterval(creditsRefreshInterval);\n   319→    }\n   320→\n   321→    // Initial fetch\n   322→    const credits = await fetchCredits();\n   323→    updateCreditDisplay(credits);\n   324→\n   325→    // Refresh credits every 5 minutes\n   326→    creditsRefreshInterval = setInterval(async () => {\n   327→        const refreshedCredits = await fetchCredits();\n   328→        updateCreditDisplay(refreshedCredits);\n   329→    }, 5 * 60 * 1000);\n   330→}\n   331→\n   332→/**\n   333→ * Cleanup credits module - call on plugin unload\n   334→ */\n   335→function cleanupCredits() {\n   336→    if (creditsRefreshInterval) {\n   337→        clearInterval(creditsRefreshInterval);\n   338→        creditsRefreshInterval = null;\n   339→    }\n   340→}\n   341→\n   342→/**\n   343→ * Manually refresh credits (e.g., after a processing operation)\n   344→ */\n   345→async function refreshCredits() {\n   346→    const credits = await fetchCredits();\n   347→    updateCreditDisplay(credits);\n   348→    return credits;\n   349→}\n   350→\n   351→/**\n   352→ * Retry fetching credits with exponential backoff\n   353→ * Called when user clicks the \"Retry\" badge\n   354→ */\n   355→async function retryFetchCredits() {\n   356→    if (creditsRetryCount >= MAX_CREDITS_RETRIES) {\n   357→        console.warn('[SPLICE] Max retry attempts reached for credits fetch');\n   358→        updateCreditDisplay({\n   359→            _error: true,\n   360→            message: 'Max retries exceeded. Check your connection and try again later.'\n   361→        });\n   362→        creditsRetryCount = 0; // Reset for next attempt\n   363→        return null;\n   364→    }\n   365→\n   366→    creditsRetryCount++;\n   367→    console.log(`[SPLICE] Retrying credits fetch (attempt ${creditsRetryCount}/${MAX_CREDITS_RETRIES})`);\n   368→\n   369→    // Exponential backoff: 1s, 2s, 4s\n   370→    const delay = Math.pow(2, creditsRetryCount - 1) * 1000;\n   371→\n   372→    // Show retrying state\n   373→    const creditBadge = document.getElementById('creditBadge');\n   374→    if (creditBadge) {\n   375→        creditBadge.textContent = `Retry ${creditsRetryCount}...`;\n   376→        creditBadge.classList.add('retrying');\n   377→    }\n   378→\n   379→    await new Promise(resolve => setTimeout(resolve, delay));\n   380→\n   381→    const credits = await fetchCredits();\n   382→\n   383→    if (creditBadge) {\n   384→        creditBadge.classList.remove('retrying');\n   385→    }\n   386→\n   387→    updateCreditDisplay(credits);\n   388→    return credits;\n   389→}\n   390→\n   391→/**\n   392→ * Handle click on credit badge\n   393→ * - If error state: retry fetching\n   394→ * - If login state: open login modal\n   395→ * - Otherwise: refresh credits\n   396→ */\n   397→function handleCreditBadgeClick() {\n   398→    const creditBadge = document.getElementById('creditBadge');\n   399→    if (!creditBadge) return;\n   400→\n   401→    if (creditBadge.classList.contains('error')) {\n   402→        retryFetchCredits();\n   403→    } else if (creditBadge.classList.contains('login')) {\n   404→        // Open login modal (handled in main.js)\n   405→        const loginModal = document.getElementById('loginModal');\n   406→        if (loginModal) {\n   407→            loginModal.classList.remove('hidden');\n   408→        }\n   409→    } else {\n   410→        // Normal state - just refresh\n   411→        refreshCredits();\n   412→    }\n   413→}\n   414→\n   415→// Export for window access\n   416→window.fetchCredits = fetchCredits;\n   417→window.clearCreditsCache = clearCreditsCache;\n   418→window.updateCreditDisplay = updateCreditDisplay;\n   419→window.checkIsolationAccess = checkIsolationAccess;\n   420→window.getCurrentCredits = getCurrentCredits;\n   421→window.hasFeatureAccess = hasFeatureAccess;\n   422→window.getRequiredTier = getRequiredTier;\n   423→window.initCredits = initCredits;\n   424→window.cleanupCredits = cleanupCredits;\n   425→window.refreshCredits = refreshCredits;\n   426→window.retryFetchCredits = retryFetchCredits;\n   427→window.handleCreditBadgeClick = handleCreditBadgeClick;\n   428→\n   429→\n\n</system-reminder>\n"}]},"uuid":"bc8d8c9c-5fa1-45be-bb8f-74a628a565a1","timestamp":"2026-01-12T16:25:43.605Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js","content":"/**\n * SPLICE CEP Credits Display Module\n *\n * Fetches and displays user's remaining hours from the billing backend.\n * Port of UXP credits.js for CEP compatibility.\n */\n\n// Track fetch error state for retry UI\nlet lastCreditsError = null;\nlet creditsRetryCount = 0;\nconst MAX_CREDITS_RETRIES = 3;\n\n// Store current credits globally for access checks\nlet currentCredits = null;\n\n// Store interval reference for cleanup\nlet creditsRefreshInterval = null;\n\n/**\n * Fetch user's credit balance from backend\n * @returns {Promise<Object | null>} Credit data including isolation hours, or error object\n */\nasync function fetchCredits() {\n    const settings = getSettings();\n    const customerId = settings.customerId;\n\n    if (!customerId) {\n        console.log('[SPLICE] No customerId configured - credits display disabled');\n        lastCreditsError = null;\n        return null;\n    }\n\n    try {\n        // Ensure we have a valid token before making the request\n        if (typeof ensureValidToken === 'function') {\n            const hasValidToken = await ensureValidToken();\n            if (!hasValidToken && !settings.accessToken) {\n                // No JWT token - will fall back to legacy auth in getAuthHeaders()\n                debugLog('[Credits] No JWT token, using legacy auth');\n            }\n        }\n\n        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n            method: 'GET',\n            headers: getAuthHeaders()\n        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n        if (!response.ok) {\n            const errorMsg = await parseErrorResponse(response);\n\n            // If unauthorized, try refreshing token and retry once\n            if (response.status === 401 && typeof refreshAccessToken === 'function') {\n                debugLog('[Credits] Got 401, attempting token refresh...');\n                const refreshed = await refreshAccessToken();\n                if (refreshed) {\n                    // Retry with new token\n                    const retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n                        method: 'GET',\n                        headers: getAuthHeaders()\n                    }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n                    if (retryResponse.ok) {\n                        const data = await retryResponse.json();\n                        lastCreditsError = null;\n                        creditsRetryCount = 0;\n                        return {\n                            hoursRemaining: data.hoursRemaining || 0,\n                            hoursTotal: data.hoursTotal || 0,\n                            tierName: data.tierName || 'Free',\n                            tier: data.tier || 'starter',\n                            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n                            isolationHoursTotal: data.isolationHoursTotal || 0,\n                            hasIsolationAccess: data.hasIsolationAccess || false,\n                            isolationOverageRate: data.isolationOverageRate || 0.08,\n                            featureAccess: data.featureAccess || [],\n                            trialDaysRemaining: data.trialDaysRemaining || null,\n                            isOnTrial: data.isOnTrial || false\n                        };\n                    }\n                }\n\n                // Token refresh failed - user needs to re-login\n                console.warn('[SPLICE] Token refresh failed, user needs to re-login');\n                if (typeof clearAuthTokens === 'function') {\n                    clearAuthTokens();\n                }\n                return { _error: true, message: 'Session expired. Please log in again.' };\n            }\n\n            console.error('[SPLICE] Credits fetch failed:', errorMsg);\n            lastCreditsError = errorMsg;\n            return { _error: true, message: errorMsg };\n        }\n\n        const data = await response.json();\n        lastCreditsError = null;\n        creditsRetryCount = 0;\n        return {\n            hoursRemaining: data.hoursRemaining || 0,\n            hoursTotal: data.hoursTotal || 0,\n            tierName: data.tierName || 'Free',\n            tier: data.tier || 'starter',\n            // Isolation hours\n            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n            isolationHoursTotal: data.isolationHoursTotal || 0,\n            hasIsolationAccess: data.hasIsolationAccess || false,\n            isolationOverageRate: data.isolationOverageRate || 0.08,\n            // Feature access\n            featureAccess: data.featureAccess || [],\n            // Trial info\n            trialDaysRemaining: data.trialDaysRemaining || null,\n            isOnTrial: data.isOnTrial || false\n        };\n    } catch (err) {\n        console.error('[SPLICE] Credits fetch error:', err);\n        lastCreditsError = err.message || 'Connection failed';\n        return { _error: true, message: lastCreditsError };\n    }\n}\n\n/**\n * Clear the credits cache (call on logout)\n */\nfunction clearCreditsCache() {\n    currentCredits = null;\n    lastCreditsError = null;\n    creditsRetryCount = 0;\n    console.log('[SPLICE] Credits cache cleared');\n}\n\n/**\n * Update the credit display in the UI\n * @param {Object|null} credits - Credit data, error object, or null if unavailable\n */\nfunction updateCreditDisplay(credits) {\n    const creditBadge = document.getElementById('creditBadge');\n    if (!creditBadge) return;\n\n    // Handle no customer ID configured\n    if (!credits) {\n        currentCredits = null;\n        creditBadge.style.display = 'flex';\n        creditBadge.textContent = 'Login';\n        creditBadge.title = 'Click to enter license key';\n        creditBadge.classList.remove('ok', 'low');\n        creditBadge.classList.add('login');\n        return;\n    }\n\n    // Handle error state - show error badge with retry\n    if (credits._error) {\n        currentCredits = null;\n        creditBadge.style.display = 'flex';\n        creditBadge.textContent = 'Retry';\n        creditBadge.title = `Error: ${credits.message}\\nClick to retry`;\n        creditBadge.classList.remove('ok', 'low', 'login');\n        creditBadge.classList.add('error');\n        return;\n    }\n\n    // Normal credit display\n    currentCredits = credits;\n    creditBadge.style.display = 'flex';\n\n    // Show referral promo when logged in\n    const referralPromo = document.getElementById('referralPromo');\n    if (referralPromo) {\n        referralPromo.classList.remove('hidden');\n    }\n\n    // Show trial status if on trial\n    if (credits.isOnTrial && credits.trialDaysRemaining) {\n        creditBadge.textContent = `Trial: ${credits.trialDaysRemaining}d`;\n        creditBadge.classList.remove('error', 'login', 'ok', 'low');\n        creditBadge.classList.add('trial');\n    } else {\n        creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n        creditBadge.classList.remove('error', 'login', 'trial');\n    }\n\n    // Build tooltip with isolation info if available\n    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n    if (credits.isOnTrial && credits.trialDaysRemaining) {\n        tooltip = `Trial: ${credits.trialDaysRemaining} days remaining\\n` + tooltip;\n    }\n    if (credits.hasIsolationAccess) {\n        tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n    }\n    creditBadge.title = tooltip;\n\n    // Color based on remaining hours\n    if (credits.hoursRemaining <= 1) {\n        creditBadge.classList.add('low');\n        creditBadge.classList.remove('ok');\n    } else {\n        creditBadge.classList.add('ok');\n        creditBadge.classList.remove('low');\n    }\n\n    // Update isolation checkbox state based on tier access\n    updateIsolationCheckboxState(credits);\n}\n\n/**\n * Update the isolation checkbox based on tier access\n */\nfunction updateIsolationCheckboxState(credits) {\n    const isolatedCheckbox = document.getElementById('sourceIsolated');\n    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n\n    if (!isolatedCheckbox) return;\n\n    if (!credits || !credits.hasIsolationAccess) {\n        // Disable isolation for non-Pro/Team users\n        isolatedCheckbox.disabled = true;\n        isolatedCheckbox.checked = false;\n        if (tierBadge) {\n            tierBadge.textContent = 'Pro+';\n            tierBadge.style.opacity = '1';\n        }\n    } else {\n        // Enable isolation for Pro/Team users\n        isolatedCheckbox.disabled = false;\n        if (tierBadge) {\n            // Show remaining isolation time\n            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n            tierBadge.textContent = `${minsRemaining} min`;\n            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n        }\n    }\n}\n\n/**\n * Check if user can use isolation and get cost estimate\n * @param {number} estimatedMinutes - Estimated audio duration in minutes\n * @returns {Object} Access info with allowed, message, overageCost\n */\nfunction checkIsolationAccess(estimatedMinutes = 0) {\n    if (!currentCredits) {\n        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n    }\n\n    if (!currentCredits.hasIsolationAccess) {\n        return {\n            allowed: false,\n            message: 'Vocal isolation requires Pro or Team tier',\n            upgradeRequired: true,\n            overageCost: 0\n        };\n    }\n\n    const estimatedHours = estimatedMinutes / 60;\n    const remaining = currentCredits.isolationHoursRemaining;\n\n    if (remaining >= estimatedHours) {\n        return {\n            allowed: true,\n            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n            overageCost: 0\n        };\n    }\n\n    // Calculate overage\n    const overageMinutes = estimatedMinutes - (remaining * 60);\n    const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n\n    return {\n        allowed: true,\n        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n        overageCost,\n        overageMinutes\n    };\n}\n\n/**\n * Get current credits (for access checks)\n */\nfunction getCurrentCredits() {\n    return currentCredits;\n}\n\n/**\n * Check if user has access to a specific feature based on their tier\n * @param {string} featureName - The feature to check (e.g., 'social_reframe', 'text_editing', 'multitrack')\n * @returns {boolean} - True if user has access\n */\nfunction hasFeatureAccess(featureName) {\n    if (!currentCredits || !currentCredits.featureAccess) {\n        return false; // Not logged in = no premium features\n    }\n    return currentCredits.featureAccess.includes(featureName);\n}\n\n/**\n * Get the required tier for a feature\n * @param {string} featureName - The feature name\n * @returns {string} - Required tier name\n */\nfunction getRequiredTier(featureName) {\n    const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n    const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n\n    if (teamOnlyFeatures.includes(featureName)) {\n        return 'Team';\n    } else if (proFeatures.includes(featureName)) {\n        return 'Pro';\n    }\n    return 'Starter';\n}\n\n/**\n * Initialize credits display\n * Fetches credits on load and sets up periodic refresh\n */\nasync function initCredits() {\n    // Clear any existing interval to prevent duplicates\n    if (creditsRefreshInterval) {\n        clearInterval(creditsRefreshInterval);\n    }\n\n    // Initial fetch\n    const credits = await fetchCredits();\n    updateCreditDisplay(credits);\n\n    // Refresh credits every 5 minutes\n    creditsRefreshInterval = setInterval(async () => {\n        const refreshedCredits = await fetchCredits();\n        updateCreditDisplay(refreshedCredits);\n    }, 5 * 60 * 1000);\n}\n\n/**\n * Cleanup credits module - call on plugin unload\n */\nfunction cleanupCredits() {\n    if (creditsRefreshInterval) {\n        clearInterval(creditsRefreshInterval);\n        creditsRefreshInterval = null;\n    }\n}\n\n/**\n * Manually refresh credits (e.g., after a processing operation)\n */\nasync function refreshCredits() {\n    const credits = await fetchCredits();\n    updateCreditDisplay(credits);\n    return credits;\n}\n\n/**\n * Retry fetching credits with exponential backoff\n * Called when user clicks the \"Retry\" badge\n */\nasync function retryFetchCredits() {\n    if (creditsRetryCount >= MAX_CREDITS_RETRIES) {\n        console.warn('[SPLICE] Max retry attempts reached for credits fetch');\n        updateCreditDisplay({\n            _error: true,\n            message: 'Max retries exceeded. Check your connection and try again later.'\n        });\n        creditsRetryCount = 0; // Reset for next attempt\n        return null;\n    }\n\n    creditsRetryCount++;\n    console.log(`[SPLICE] Retrying credits fetch (attempt ${creditsRetryCount}/${MAX_CREDITS_RETRIES})`);\n\n    // Exponential backoff: 1s, 2s, 4s\n    const delay = Math.pow(2, creditsRetryCount - 1) * 1000;\n\n    // Show retrying state\n    const creditBadge = document.getElementById('creditBadge');\n    if (creditBadge) {\n        creditBadge.textContent = `Retry ${creditsRetryCount}...`;\n        creditBadge.classList.add('retrying');\n    }\n\n    await new Promise(resolve => setTimeout(resolve, delay));\n\n    const credits = await fetchCredits();\n\n    if (creditBadge) {\n        creditBadge.classList.remove('retrying');\n    }\n\n    updateCreditDisplay(credits);\n    return credits;\n}\n\n/**\n * Handle click on credit badge\n * - If error state: retry fetching\n * - If login state: open login modal\n * - Otherwise: refresh credits\n */\nfunction handleCreditBadgeClick() {\n    const creditBadge = document.getElementById('creditBadge');\n    if (!creditBadge) return;\n\n    if (creditBadge.classList.contains('error')) {\n        retryFetchCredits();\n    } else if (creditBadge.classList.contains('login')) {\n        // Open login modal (handled in main.js)\n        const loginModal = document.getElementById('loginModal');\n        if (loginModal) {\n            loginModal.classList.remove('hidden');\n        }\n    } else {\n        // Normal state - just refresh\n        refreshCredits();\n    }\n}\n\n// Export for window access\nwindow.fetchCredits = fetchCredits;\nwindow.clearCreditsCache = clearCreditsCache;\nwindow.updateCreditDisplay = updateCreditDisplay;\nwindow.checkIsolationAccess = checkIsolationAccess;\nwindow.getCurrentCredits = getCurrentCredits;\nwindow.hasFeatureAccess = hasFeatureAccess;\nwindow.getRequiredTier = getRequiredTier;\nwindow.initCredits = initCredits;\nwindow.cleanupCredits = cleanupCredits;\nwindow.refreshCredits = refreshCredits;\nwindow.retryFetchCredits = retryFetchCredits;\nwindow.handleCreditBadgeClick = handleCreditBadgeClick;\n\n","numLines":429,"startLine":1,"totalLines":429}}}
{"parentUuid":"bc8d8c9c-5fa1-45be-bb8f-74a628a565a1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-cep/panel/js","sessionId":"7fa929e3-00b9-497c-b311-19cb4c6b44f9","version":"2.0.76","gitBranch":"main","agentId":"a09f1cb","slug":"eager-questing-lagoon","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01NMdw1Ky8KURSZvuGezRjxP","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll check the dependencies (config.js) to understand the helper functions being used:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":5680,"cache_read_input_tokens":30937,"cache_creation":{"ephemeral_5m_input_tokens":5680,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3o7xGxXVWLf3uhK2ozK","type":"assistant","uuid":"a55039d4-3399-44ce-902f-e891299f748c","timestamp":"2026-01-12T16:25:46.988Z"}
{"parentUuid":"a55039d4-3399-44ce-902f-e891299f748c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-cep/panel/js","sessionId":"7fa929e3-00b9-497c-b311-19cb4c6b44f9","version":"2.0.76","gitBranch":"main","agentId":"a09f1cb","slug":"eager-questing-lagoon","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01NMdw1Ky8KURSZvuGezRjxP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014Kr4ZodiUi1pYesvyEmit7","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":5680,"cache_read_input_tokens":30937,"cache_creation":{"ephemeral_5m_input_tokens":5680,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3o7xGxXVWLf3uhK2ozK","type":"assistant","uuid":"39188497-5b9b-4656-acd3-1068fbc4ac86","timestamp":"2026-01-12T16:25:48.293Z"}
{"parentUuid":"39188497-5b9b-4656-acd3-1068fbc4ac86","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-cep/panel/js","sessionId":"7fa929e3-00b9-497c-b311-19cb4c6b44f9","version":"2.0.76","gitBranch":"main","agentId":"a09f1cb","slug":"eager-questing-lagoon","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014Kr4ZodiUi1pYesvyEmit7","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Panel Configuration\n     3→ * Backend URLs, paths, and utility functions\n     4→ */\n     5→\n     6→// ============================================================================\n     7→// DEBUG MODE CONFIGURATION\n     8→// ============================================================================\n     9→\n    10→/**\n    11→ * Debug mode flag - enables verbose diagnostic logging\n    12→ * Can be enabled via localStorage for troubleshooting:\n    13→ *   localStorage.setItem('spliceDebugMode', 'true');\n    14→ *\n    15→ * Default: false (production mode - minimal logging)\n    16→ */\n    17→const SPLICE_DEBUG = localStorage.getItem('spliceDebugMode') === 'true';\n    18→\n    19→/**\n    20→ * Debug logging function - only outputs when debug mode is enabled\n    21→ * Use this for diagnostic/development logging that should be silent in production\n    22→ * @param {...any} args - Arguments to log (prefixed with [SPLICE DEBUG])\n    23→ */\n    24→function debugLog(...args) {\n    25→    if (SPLICE_DEBUG) {\n    26→        console.log('[SPLICE DEBUG]', ...args);\n    27→    }\n    28→}\n    29→\n    30→/**\n    31→ * Debug fetch logging - verbose fetch request/response logging\n    32→ * @param {...any} args - Arguments to log (prefixed with [SPLICE FETCH])\n    33→ */\n    34→function debugFetch(...args) {\n    35→    if (SPLICE_DEBUG) {\n    36→        console.log('[SPLICE FETCH]', ...args);\n    37→    }\n    38→}\n    39→\n    40→// ============================================================================\n    41→// BACKEND CONFIGURATION\n    42→// ============================================================================\n    43→const SPLICE_CONFIG = {\n    44→    VERSION: '6.0.3',\n    45→    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    46→    BACKEND_DEV: 'https://127.0.0.1:3847',\n    47→    FETCH_TIMEOUT: 120000, // 2 minutes\n    48→    RETRY_ATTEMPTS: 3,\n    49→    RETRY_DELAY: 1000\n    50→};\n    51→\n    52→/**\n    53→ * Get the backend URL based on environment\n    54→ * FIXED: CEP panels always run from file://, so we default to PROD\n    55→ * Use localStorage to override for local development if needed\n    56→ */\n    57→function getBackendUrl() {\n    58→    // Priority 1: Allow override via localStorage (for local dev testing)\n    59→    const customUrl = localStorage.getItem('spliceBackendUrl');\n    60→    if (customUrl) {\n    61→        debugLog('Using custom backend URL from localStorage:', customUrl);\n    62→        return customUrl;\n    63→    }\n    64→\n    65→    // Priority 2: Default to production backend\n    66→    // (CEP panels always run from file://, so can't reliably detect dev mode)\n    67→    debugLog('Using production backend URL:', SPLICE_CONFIG.BACKEND_PROD);\n    68→    return SPLICE_CONFIG.BACKEND_PROD;\n    69→}\n    70→\n    71→// ============================================================================\n    72→// JSX BRIDGE - Communicate with Premiere Pro\n    73→// ============================================================================\n    74→const jsx = {\n    75→    cs: null,\n    76→    _initPromise: null,\n    77→    _initialized: false,\n    78→    _jsxReady: false,\n    79→\n    80→    /**\n    81→     * Initialize the CSInterface with FireCut-style retry logic\n    82→     * Returns a promise that resolves when ready (true/false)\n    83→     * Does NOT reject - gracefully handles missing CEP environment\n    84→     */\n    85→    init: function() {\n    86→        if (this._initPromise) return this._initPromise;\n    87→\n    88→        this._initPromise = this._initWithRetry();\n    89→        return this._initPromise;\n    90→    },\n    91→\n    92→    /**\n    93→     * FireCut-style retry logic for CSInterface initialization\n    94→     * Retries up to 5 times with exponential backoff\n    95→     */\n    96→    _initWithRetry: async function() {\n    97→        const maxRetries = 5;\n    98→        const baseDelay = 200; // Start with 200ms, will double each retry\n    99→\n   100→        for (let attempt = 1; attempt <= maxRetries; attempt++) {\n   101→            const success = await this._tryInit(attempt);\n   102→            if (success) {\n   103→                // After CSInterface init, verify JSX is ready\n   104→                const jsxReady = await this._verifyJSXReady();\n   105→                if (jsxReady) {\n   106→                    this._jsxReady = true;\n   107→                    debugLog(`[JSX] Full initialization complete on attempt ${attempt}`);\n   108→                    return true;\n   109→                } else {\n   110→                    debugLog(`[JSX] CSInterface ready but JSX not responding, attempt ${attempt}/${maxRetries}`);\n   111→                }\n   112→            }\n   113→\n   114→            if (attempt < maxRetries) {\n   115→                const delay = baseDelay * Math.pow(2, attempt - 1);\n   116→                debugLog(`[JSX] Init attempt ${attempt} failed, retrying in ${delay}ms...`);\n   117→                await this._delay(delay);\n   118→            }\n   119→        }\n   120→\n   121→        console.warn('[JSX] Initialization failed after all retries - panel may have limited functionality');\n   122→        return this._initialized;\n   123→    },\n   124→\n   125→    /**\n   126→     * Single initialization attempt\n   127→     */\n   128→    _tryInit: function(attempt) {\n   129→        return new Promise((resolve) => {\n   130→            try {\n   131→                if (typeof CSInterface !== 'undefined') {\n   132→                    this.cs = new CSInterface();\n   133→                    // Verify we're in a real CEP environment by checking for __adobe_cep__\n   134→                    if (window.__adobe_cep__) {\n   135→                        this._initialized = true;\n   136→                        debugLog(`[JSX] CSInterface initialized successfully (CEP environment detected) - attempt ${attempt}`);\n   137→                        resolve(true);\n   138→                    } else {\n   139→                        // CSInterface exists but no CEP runtime - browser/dev mode\n   140→                        this._initialized = true;\n   141→                        debugLog(`[JSX] CSInterface initialized (development/browser mode) - attempt ${attempt}`);\n   142→                        resolve(true);\n   143→                    }\n   144→                } else {\n   145→                    debugLog(`[JSX] CSInterface not yet available - attempt ${attempt}`);\n   146→                    resolve(false);\n   147→                }\n   148→            } catch (err) {\n   149→                console.error(`[JSX] Init attempt ${attempt} error:`, err);\n   150→                resolve(false);\n   151→            }\n   152→        });\n   153→    },\n   154→\n   155→    /**\n   156→     * FireCut-style JSX readiness verification\n   157→     * Tests that hostScript.jsx is actually loaded and responding\n   158→     */\n   159→    _verifyJSXReady: async function() {\n   160→        if (!this.cs) return false;\n   161→\n   162→        return new Promise((resolve) => {\n   163→            const timeout = setTimeout(() => {\n   164→                debugLog('[JSX] JSX readiness check timed out');\n   165→                resolve(false);\n   166→            }, 2000);\n   167→\n   168→            try {\n   169→                // Simple test that hostScript.jsx is loaded and responding\n   170→                this.cs.evalScript('(function() { return typeof getActiveSequence === \"function\" ? \"ready\" : \"not_ready\"; })()', (result) => {\n   171→                    clearTimeout(timeout);\n   172→                    if (result === 'ready') {\n   173→                        debugLog('[JSX] JSX bridge verified ready - hostScript.jsx loaded');\n   174→                        resolve(true);\n   175→                    } else {\n   176→                        debugLog('[JSX] JSX functions not yet available:', result);\n   177→                        resolve(false);\n   178→                    }\n   179→                });\n   180→            } catch (err) {\n   181→                clearTimeout(timeout);\n   182→                debugLog('[JSX] JSX readiness check error:', err);\n   183→                resolve(false);\n   184→            }\n   185→        });\n   186→    },\n   187→\n   188→    /**\n   189→     * Helper for async delay\n   190→     */\n   191→    _delay: function(ms) {\n   192→        return new Promise(resolve => setTimeout(resolve, ms));\n   193→    },\n   194→\n   195→    /**\n   196→     * Ensure JSX is initialized before making calls\n   197→     */\n   198→    ensureInitialized: async function() {\n   199→        if (!this._initialized) {\n   200→            await this.init();\n   201→        }\n   202→        if (!this.cs) {\n   203→            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n   204→        }\n   205→    },\n   206→\n   207→    /**\n   208→     * Execute ExtendScript in Premiere Pro\n   209→     * @param {string} script - ExtendScript to execute\n   210→     * @returns {Promise<any>} - Parsed result\n   211→     */\n   212→    evalScript: async function(script) {\n   213→        await this.ensureInitialized();\n   214→\n   215→        return new Promise((resolve, reject) => {\n   216→            this.cs.evalScript(script, (result) => {\n   217→                if (result === 'undefined' || result === undefined) {\n   218→                    resolve(null);\n   219→                    return;\n   220→                }\n   221→\n   222→                // Check for EvalScript error or ExtendScript runtime errors\n   223→                if (typeof result === 'string' && (\n   224→                    result.indexOf('EvalScript error') !== -1 ||\n   225→                    result.indexOf('Error:') !== -1 ||\n   226→                    result.indexOf('TypeError:') !== -1 ||\n   227→                    result.indexOf('ReferenceError:') !== -1\n   228→                )) {\n   229→                    reject(new Error(result));\n   230→                    return;\n   231→                }\n   232→\n   233→                // Try to parse JSON\n   234→                try {\n   235→                    const parsed = JSON.parse(result);\n   236→                    if (parsed.error) {\n   237→                        reject(new Error(parsed.error));\n   238→                    } else {\n   239→                        resolve(parsed);\n   240→                    }\n   241→                } catch (e) {\n   242→                    // Return as-is if not JSON\n   243→                    resolve(result);\n   244→                }\n   245→            });\n   246→        });\n   247→    },\n   248→\n   249→    /**\n   250→     * Call a JSX function with arguments\n   251→     * @param {string} funcName - Function name\n   252→     * @param {...any} args - Arguments to pass\n   253→     * @returns {Promise<any>}\n   254→     */\n   255→    call: async function(funcName, ...args) {\n   256→        await this.ensureInitialized();\n   257→\n   258→        const escapedArgs = args.map(arg => {\n   259→            if (arg === null || arg === undefined) return 'null';\n   260→            if (typeof arg === 'string') {\n   261→                // Escape backslashes first, then other special chars\n   262→                return `'${arg\n   263→                    .replace(/\\\\/g, '\\\\\\\\')\n   264→                    .replace(/'/g, \"\\\\'\")\n   265→                    .replace(/\\r/g, '\\\\r')\n   266→                    .replace(/\\n/g, '\\\\n')\n   267→                    .replace(/\\t/g, '\\\\t')}'`;\n   268→            }\n   269→            if (typeof arg === 'object') {\n   270→                return `'${JSON.stringify(arg)\n   271→                    .replace(/\\\\/g, '\\\\\\\\')\n   272→                    .replace(/'/g, \"\\\\'\")}'`;\n   273→            }\n   274→            return String(arg);\n   275→        });\n   276→\n   277→        const script = `${funcName}(${escapedArgs.join(', ')})`;\n   278→        return this.evalScript(script);\n   279→    }\n   280→};\n   281→\n   282→// ============================================================================\n   283→// FETCH UTILITIES\n   284→// ============================================================================\n   285→\n   286→/**\n   287→ * Fetch with timeout support\n   288→ * @param {string} url - URL to fetch\n   289→ * @param {object} options - Fetch options\n   290→ * @param {number} timeout - Timeout in ms\n   291→ */\n   292→async function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n   293→    // DIAGNOSTIC: Log fetch request details (debug mode only)\n   294→    debugFetch('=== FETCH REQUEST START ===');\n   295→    debugFetch('URL:', url);\n   296→    debugFetch('Method:', options?.method || 'GET');\n   297→    debugFetch('Headers:', options?.headers);\n   298→    debugFetch('Timeout:', timeout);\n   299→    debugFetch('Is CEP environment:', typeof CSInterface !== 'undefined');\n   300→    debugFetch('=================================');\n   301→\n   302→    const controller = new AbortController();\n   303→    const timeoutId = setTimeout(() => controller.abort(), timeout);\n   304→\n   305→    try {\n   306→        const response = await fetch(url, {\n   307→            ...options,\n   308→            signal: controller.signal\n   309→        });\n   310→        clearTimeout(timeoutId);\n   311→\n   312→        // DIAGNOSTIC: Log successful response (debug mode only)\n   313→        debugFetch('=== FETCH RESPONSE SUCCESS ===');\n   314→        debugFetch('Status:', response.status);\n   315→        debugFetch('OK:', response.ok);\n   316→        debugFetch('=================================');\n   317→\n   318→        return response;\n   319→    } catch (error) {\n   320→        clearTimeout(timeoutId);\n   321→\n   322→        // DIAGNOSTIC: Log raw fetch error (debug mode only)\n   323→        debugFetch('=== FETCH ERROR CAUGHT ===');\n   324→        debugFetch('Error name:', error?.name);\n   325→        debugFetch('Error message:', error?.message);\n   326→        debugFetch('Error type:', typeof error);\n   327→        debugFetch('Error constructor:', error?.constructor?.name);\n   328→        debugFetch('Is AbortError:', error.name === 'AbortError');\n   329→        debugFetch('Is TypeError:', error.name === 'TypeError');\n   330→        debugFetch('Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\n   331→        debugFetch('=================================');\n   332→\n   333→        if (error.name === 'AbortError') {\n   334→            throw new Error(`Request timeout after ${timeout}ms`);\n   335→        }\n   336→        throw error;\n   337→    }\n   338→}\n   339→\n   340→/**\n   341→ * Parse error response from backend\n   342→ * @param {Response} response - Fetch response\n   343→ */\n   344→async function parseErrorResponse(response) {\n   345→    try {\n   346→        const data = await response.json();\n   347→        return data.error || data.message || `HTTP ${response.status}`;\n   348→    } catch {\n   349→        return `HTTP ${response.status}: ${response.statusText}`;\n   350→    }\n   351→}\n   352→\n   353→/**\n   354→ * Get auth headers for API requests\n   355→ * Uses JWT Bearer token if available, with legacy fallback\n   356→ */\n   357→function getAuthHeaders() {\n   358→    const headers = { 'Content-Type': 'application/json' };\n   359→    const settings = getSettings();\n   360→\n   361→    // Prefer JWT Bearer token (modern auth)\n   362→    if (settings.accessToken) {\n   363→        headers['Authorization'] = `Bearer ${settings.accessToken}`;\n   364→        return headers;\n   365→    }\n   366→\n   367→    // Legacy fallback for backwards compatibility\n   368→    // This will be removed after 2026-04-11\n   369→    if (settings.customerId) {\n   370→        headers['x-stripe-customer-id'] = settings.customerId;\n   371→        console.warn('[SPLICE] Using deprecated x-stripe-customer-id header. Please re-login to upgrade to JWT auth.');\n   372→    }\n   373→\n   374→    return headers;\n   375→}\n   376→\n   377→/**\n   378→ * Check if the access token is expired or about to expire\n   379→ * @returns {boolean} True if token needs refresh\n   380→ */\n   381→function isTokenExpired() {\n   382→    const settings = getSettings();\n   383→    if (!settings.tokenExpiry) return true;\n   384→\n   385→    // Refresh if less than 5 minutes remaining\n   386→    const bufferMs = 5 * 60 * 1000;\n   387→    return Date.now() >= (settings.tokenExpiry - bufferMs);\n   388→}\n   389→\n   390→/**\n   391→ * Refresh the access token using the refresh token\n   392→ * @returns {Promise<boolean>} True if refresh succeeded\n   393→ */\n   394→async function refreshAccessToken() {\n   395→    const settings = getSettings();\n   396→\n   397→    if (!settings.refreshToken) {\n   398→        debugLog('[Auth] No refresh token available');\n   399→        return false;\n   400→    }\n   401→\n   402→    try {\n   403→        debugLog('[Auth] Refreshing access token...');\n   404→\n   405→        const response = await fetchWithTimeout(`${getBackendUrl()}/auth/refresh`, {\n   406→            method: 'POST',\n   407→            headers: { 'Content-Type': 'application/json' },\n   408→            body: JSON.stringify({ refreshToken: settings.refreshToken })\n   409→        }, 30000);\n   410→\n   411→        if (!response.ok) {\n   412→            const errorMsg = await parseErrorResponse(response);\n   413→            console.error('[Auth] Token refresh failed:', errorMsg);\n   414→\n   415→            // If refresh token is invalid, clear auth and require re-login\n   416→            if (response.status === 401) {\n   417→                clearAuthTokens();\n   418→            }\n   419→            return false;\n   420→        }\n   421→\n   422→        const data = await response.json();\n   423→\n   424→        // Save new access token\n   425→        const expiresInMs = (data.expiresIn || 86400) * 1000; // Default 24h\n   426→        saveSettings({\n   427→            accessToken: data.token,\n   428→            tokenExpiry: Date.now() + expiresInMs\n   429→        });\n   430→\n   431→        debugLog('[Auth] Access token refreshed successfully');\n   432→        return true;\n   433→    } catch (err) {\n   434→        console.error('[Auth] Token refresh error:', err);\n   435→        return false;\n   436→    }\n   437→}\n   438→\n   439→/**\n   440→ * Clear all auth tokens (call on logout or auth failure)\n   441→ */\n   442→function clearAuthTokens() {\n   443→    saveSettings({\n   444→        accessToken: null,\n   445→        refreshToken: null,\n   446→        tokenExpiry: null\n   447→    });\n   448→    debugLog('[Auth] Auth tokens cleared');\n   449→}\n   450→\n   451→/**\n   452→ * Ensure we have a valid access token, refreshing if needed\n   453→ * @returns {Promise<boolean>} True if we have a valid token\n   454→ */\n   455→async function ensureValidToken() {\n   456→    const settings = getSettings();\n   457→\n   458→    // No token at all - need to login\n   459→    if (!settings.accessToken) {\n   460→        return false;\n   461→    }\n   462→\n   463→    // Token not expired - good to go\n   464→    if (!isTokenExpired()) {\n   465→        return true;\n   466→    }\n   467→\n   468→    // Try to refresh\n   469→    return await refreshAccessToken();\n   470→}\n   471→\n   472→// ============================================================================\n   473→// SETTINGS MANAGEMENT\n   474→// ============================================================================\n   475→\n   476→const DEFAULT_SETTINGS = {\n   477→    sensitivity: 50,\n   478→    minSilenceLength: 0.5,\n   479→    sourceIsolated: false,\n   480→    enableTakesDetection: true,\n   481→    enableJCut: false,\n   482→    jcutLeadIn: 0.3,\n   483→    jcutLeadOut: 0.2,\n   484→    enableZoom: false,\n   485→    zoomFrequency: 'medium',\n   486→    zoomPreset: 'medium',\n   487→    zoomPlacement: 'sentence_start',\n   488→    enableChapters: false,\n   489→    maxChapters: 10,\n   490→    minChapterLength: 60,\n   491→    enableProfanity: false,\n   492→    profanityLanguage: 'en',\n   493→    bleepType: 'standard',\n   494→    // Authentication\n   495→    customerId: null,\n   496→    licenseKey: null,\n   497→    accessToken: null,\n   498→    refreshToken: null,\n   499→    tokenExpiry: null,\n   500→    // UI State\n   501→    expandedOptions: false,\n   502→    activePreset: 'podcast',\n   503→    rememberOptions: false\n   504→};\n   505→\n   506→// Current storage version for future migrations\n   507→const SETTINGS_STORAGE_VERSION = 2;\n   508→\n   509→// Fields that contain sensitive data and should be encrypted\n   510→const SENSITIVE_FIELDS = ['customerId', 'licenseKey', 'accessToken', 'refreshToken'];\n   511→\n   512→// ============================================================================\n   513→// ENCRYPTION HELPERS FOR SENSITIVE DATA (CEP-CRIT-002 FIX)\n   514→// Uses AES-GCM encryption via Web Crypto API for proper security\n   515→// ============================================================================\n   516→\n   517→// Encryption constants\n   518→const SPLICE_ENCRYPTION = {\n   519→    ALGORITHM: 'AES-GCM',\n   520→    KEY_LENGTH: 256,\n   521→    IV_LENGTH: 12,\n   522→    TAG_LENGTH: 128,\n   523→    SALT: 'SPLICE_PANEL_SALT_v1', // Static salt for key derivation\n   524→    ITERATIONS: 100000,\n   525→    PREFIX: 'ENC:v1:'  // Prefix to identify encrypted values\n   526→};\n   527→\n   528→// Cached encryption key (derived once per session)\n   529→let _encryptionKey = null;\n   530→\n   531→/**\n   532→ * Get or derive the encryption key from a machine-specific identifier\n   533→ * Uses PBKDF2 to derive a strong key from available identifiers\n   534→ * @returns {Promise<CryptoKey>} The derived encryption key\n   535→ */\n   536→async function getEncryptionKey() {\n   537→    if (_encryptionKey) {\n   538→        return _encryptionKey;\n   539→    }\n   540→\n   541→    try {\n   542→        // Use a combination of identifiers for key derivation\n   543→        // In CEP, we use localStorage ID + app version as the key material\n   544→        let keyMaterial = localStorage.getItem('splice_device_id');\n   545→        if (!keyMaterial) {\n   546→            // Generate a random device ID on first use\n   547→            keyMaterial = crypto.randomUUID ? crypto.randomUUID() :\n   548→                'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n   549→                    const r = Math.random() * 16 | 0;\n   550→                    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n   551→                    return v.toString(16);\n   552→                });\n   553→            localStorage.setItem('splice_device_id', keyMaterial);\n   554→        }\n   555→\n   556→        const encoder = new TextEncoder();\n   557→        const keyData = encoder.encode(keyMaterial + SPLICE_ENCRYPTION.SALT);\n   558→\n   559→        // Import the key material for PBKDF2\n   560→        const baseKey = await crypto.subtle.importKey(\n   561→            'raw',\n   562→            keyData,\n   563→            'PBKDF2',\n   564→            false,\n   565→            ['deriveKey']\n   566→        );\n   567→\n   568→        // Derive the actual AES key\n   569→        _encryptionKey = await crypto.subtle.deriveKey(\n   570→            {\n   571→                name: 'PBKDF2',\n   572→                salt: encoder.encode(SPLICE_ENCRYPTION.SALT),\n   573→                iterations: SPLICE_ENCRYPTION.ITERATIONS,\n   574→                hash: 'SHA-256'\n   575→            },\n   576→            baseKey,\n   577→            {\n   578→                name: SPLICE_ENCRYPTION.ALGORITHM,\n   579→                length: SPLICE_ENCRYPTION.KEY_LENGTH\n   580→            },\n   581→            false,\n   582→            ['encrypt', 'decrypt']\n   583→        );\n   584→\n   585→        return _encryptionKey;\n   586→    } catch (e) {\n   587→        debugLog('[Config] Key derivation error:', e);\n   588→        return null;\n   589→    }\n   590→}\n   591→\n   592→/**\n   593→ * Encrypt data for secure localStorage storage using AES-GCM\n   594→ *\n   595→ * @param {any} data - Data to encrypt\n   596→ * @returns {Promise<string|null>} Encrypted string with prefix or null on error\n   597→ */\n   598→async function encryptForStorageAsync(data) {\n   599→    try {\n   600→        if (data === null || data === undefined) {\n   601→            return null;\n   602→        }\n   603→\n   604→        const key = await getEncryptionKey();\n   605→        if (!key) {\n   606→            // Fallback to legacy encoding if crypto not available\n   607→            debugLog('[Config] Crypto not available, using legacy encoding');\n   608→            return legacyEncode(data);\n   609→        }\n   610→\n   611→        const encoder = new TextEncoder();\n   612→        const jsonStr = JSON.stringify(data);\n   613→        const plaintext = encoder.encode(jsonStr);\n   614→\n   615→        // Generate random IV\n   616→        const iv = crypto.getRandomValues(new Uint8Array(SPLICE_ENCRYPTION.IV_LENGTH));\n   617→\n   618→        // Encrypt\n   619→        const ciphertext = await crypto.subtle.encrypt(\n   620→            {\n   621→                name: SPLICE_ENCRYPTION.ALGORITHM,\n   622→                iv: iv,\n   623→                tagLength: SPLICE_ENCRYPTION.TAG_LENGTH\n   624→            },\n   625→            key,\n   626→            plaintext\n   627→        );\n   628→\n   629→        // Combine IV + ciphertext and encode as base64\n   630→        const combined = new Uint8Array(iv.length + ciphertext.byteLength);\n   631→        combined.set(iv);\n   632→        combined.set(new Uint8Array(ciphertext), iv.length);\n   633→\n   634→        // Convert to base64 with prefix\n   635→        const base64 = btoa(String.fromCharCode(...combined));\n   636→        return SPLICE_ENCRYPTION.PREFIX + base64;\n   637→    } catch (e) {\n   638→        debugLog('[Config] Encryption error:', e);\n   639→        return legacyEncode(data);\n   640→    }\n   641→}\n   642→\n   643→/**\n   644→ * Decrypt data from localStorage using AES-GCM\n   645→ *\n   646→ * @param {string} data - Encrypted string\n   647→ * @returns {Promise<any|null>} Decrypted data or null on error\n   648→ */\n   649→async function decryptFromStorageAsync(data) {\n   650→    try {\n   651→        if (!data || typeof data !== 'string') {\n   652→            return null;\n   653→        }\n   654→\n   655→        // Check if this is the new encrypted format\n   656→        if (!data.startsWith(SPLICE_ENCRYPTION.PREFIX)) {\n   657→            // Try legacy decoding for backward compatibility\n   658→            return legacyDecode(data);\n   659→        }\n   660→\n   661→        const key = await getEncryptionKey();\n   662→        if (!key) {\n   663→            debugLog('[Config] Crypto not available for decryption');\n   664→            return null;\n   665→        }\n   666→\n   667→        // Remove prefix and decode base64\n   668→        const base64Data = data.slice(SPLICE_ENCRYPTION.PREFIX.length);\n   669→        const combined = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));\n   670→\n   671→        // Extract IV and ciphertext\n   672→        const iv = combined.slice(0, SPLICE_ENCRYPTION.IV_LENGTH);\n   673→        const ciphertext = combined.slice(SPLICE_ENCRYPTION.IV_LENGTH);\n   674→\n   675→        // Decrypt\n   676→        const plaintext = await crypto.subtle.decrypt(\n   677→            {\n   678→                name: SPLICE_ENCRYPTION.ALGORITHM,\n   679→                iv: iv,\n   680→                tagLength: SPLICE_ENCRYPTION.TAG_LENGTH\n   681→            },\n   682→            key,\n   683→            ciphertext\n   684→        );\n   685→\n   686→        const decoder = new TextDecoder();\n   687→        const jsonStr = decoder.decode(plaintext);\n   688→        return JSON.parse(jsonStr);\n   689→    } catch (e) {\n   690→        // Try legacy decoding as fallback\n   691→        return legacyDecode(data);\n   692→    }\n   693→}\n   694→\n   695→/**\n   696→ * Legacy encoding (Base64) for backward compatibility\n   697→ * @param {any} data - Data to encode\n   698→ * @returns {string|null} Encoded string\n   699→ */\n   700→function legacyEncode(data) {\n   701→    try {\n   702→        if (data === null || data === undefined) {\n   703→            return null;\n   704→        }\n   705→        const jsonStr = JSON.stringify(data);\n   706→        const encoded = encodeURIComponent(jsonStr);\n   707→        return btoa(encoded);\n   708→    } catch (e) {\n   709→        return null;\n   710→    }\n   711→}\n   712→\n   713→/**\n   714→ * Legacy decoding (Base64) for backward compatibility\n   715→ * @param {string} data - Encoded string\n   716→ * @returns {any|null} Decoded data\n   717→ */\n   718→function legacyDecode(data) {\n   719→    try {\n   720→        if (!data || typeof data !== 'string') {\n   721→            return null;\n   722→        }\n   723→        // Skip if it has the encryption prefix\n   724→        if (data.startsWith(SPLICE_ENCRYPTION.PREFIX)) {\n   725→            return null;\n   726→        }\n   727→        const decoded = atob(data);\n   728→        const jsonStr = decodeURIComponent(decoded);\n   729→        return JSON.parse(jsonStr);\n   730→    } catch (e) {\n   731→        return null;\n   732→    }\n   733→}\n   734→\n   735→/**\n   736→ * Synchronous wrapper for encryption (starts async operation)\n   737→ * For backward compatibility with existing sync code\n   738→ * @param {any} data - Data to encode\n   739→ * @returns {string|null} Encoded string (legacy format until async completes)\n   740→ */\n   741→function encryptForStorage(data) {\n   742→    // Return legacy encoding synchronously\n   743→    // The async version should be preferred for new code\n   744→    return legacyEncode(data);\n   745→}\n   746→\n   747→/**\n   748→ * Synchronous wrapper for decryption\n   749→ * For backward compatibility with existing sync code\n   750→ * @param {string} data - Encoded string\n   751→ * @returns {any|null} Decoded data\n   752→ */\n   753→function decryptFromStorage(data) {\n   754→    // Handle new encrypted format by returning null (needs async)\n   755→    if (data && data.startsWith(SPLICE_ENCRYPTION.PREFIX)) {\n   756→        debugLog('[Config] Encrypted data requires async decryption');\n   757→        return null;\n   758→    }\n   759→    return legacyDecode(data);\n   760→}\n   761→\n   762→/**\n   763→ * Check if a value appears to be encrypted\n   764→ *\n   765→ * @param {any} value - Value to check\n   766→ * @returns {boolean} True if value appears to be encrypted\n   767→ */\n   768→function isEncryptedValue(value) {\n   769→    if (!value || typeof value !== 'string') {\n   770→        return false;\n   771→    }\n   772→    // New encryption format\n   773→    if (value.startsWith(SPLICE_ENCRYPTION.PREFIX)) {\n   774→        return true;\n   775→    }\n   776→    // Unencrypted values typically start with known patterns\n   777→    if (value.startsWith('cus_') || value.startsWith('SPLICE-')) {\n   778→        return false;\n   779→    }\n   780→    // Check if it's legacy base64 encoded JSON\n   781→    try {\n   782→        const decoded = atob(value);\n   783→        const jsonStr = decodeURIComponent(decoded);\n   784→        JSON.parse(jsonStr);\n   785→        return true;\n   786→    } catch {\n   787→        return false;\n   788→    }\n   789→}\n   790→\n   791→/**\n   792→ * Encrypt sensitive fields in settings object\n   793→ *\n   794→ * @param {Object} settings - Settings object with plaintext sensitive fields\n   795→ * @returns {Object} Settings with encrypted sensitive fields\n   796→ */\n   797→function encryptSensitiveFields(settings) {\n   798→    const encrypted = { ...settings };\n   799→\n   800→    for (const field of SENSITIVE_FIELDS) {\n   801→        if (encrypted[field] !== null && encrypted[field] !== undefined) {\n   802→            // Only encrypt if not already encrypted\n   803→            if (!isEncryptedValue(encrypted[field])) {\n   804→                encrypted[field] = encryptForStorage(encrypted[field]);\n   805→                debugLog(`[Config] Encrypted field: ${field}`);\n   806→            }\n   807→        }\n   808→    }\n   809→\n   810→    return encrypted;\n   811→}\n   812→\n   813→/**\n   814→ * Decrypt sensitive fields in settings object\n   815→ *\n   816→ * @param {Object} settings - Settings object with encrypted sensitive fields\n   817→ * @returns {Object} Settings with decrypted sensitive fields\n   818→ */\n   819→function decryptSensitiveFields(settings) {\n   820→    const decrypted = { ...settings };\n   821→\n   822→    for (const field of SENSITIVE_FIELDS) {\n   823→        if (decrypted[field] !== null && decrypted[field] !== undefined) {\n   824→            // Check if it looks encrypted before attempting to decrypt\n   825→            if (isEncryptedValue(decrypted[field])) {\n   826→                const decryptedValue = decryptFromStorage(decrypted[field]);\n   827→                if (decryptedValue !== null) {\n   828→                    decrypted[field] = decryptedValue;\n   829→                    debugLog(`[Config] Decrypted field: ${field}`);\n   830→                }\n   831→            }\n   832→            // If not encrypted (legacy data), keep the original value\n   833→        }\n   834→    }\n   835→\n   836→    return decrypted;\n   837→}\n   838→\n   839→/**\n   840→ * Internal save function to avoid recursion during migration\n   841→ * @private\n   842→ */\n   843→function _saveSettingsInternal(settings) {\n   844→    try {\n   845→        // Encrypt sensitive fields before storing\n   846→        const toStore = encryptSensitiveFields(settings);\n   847→\n   848→        // Add version marker for future migrations\n   849→        toStore._storageVersion = SETTINGS_STORAGE_VERSION;\n   850→\n   851→        localStorage.setItem('spliceSettings', JSON.stringify(toStore));\n   852→        return true;\n   853→    } catch (e) {\n   854→        console.warn('[Config] Error saving settings:', e);\n   855→        return false;\n   856→    }\n   857→}\n   858→\n   859→/**\n   860→ * Get settings from localStorage\n   861→ * Handles migration from unencrypted to encrypted storage format\n   862→ */\n   863→function getSettings() {\n   864→    try {\n   865→        const stored = localStorage.getItem('spliceSettings');\n   866→        if (stored) {\n   867→            const parsed = JSON.parse(stored);\n   868→\n   869→            // Decrypt sensitive fields (handles both encrypted and legacy unencrypted data)\n   870→            const decrypted = decryptSensitiveFields(parsed);\n   871→\n   872→            // Check if migration is needed (no version marker = legacy data)\n   873→            if (!parsed._storageVersion) {\n   874→                // Migrate legacy data: save with encryption and version marker\n   875→                debugLog('[Config] Migrating legacy settings to encrypted format');\n   876→                const migratedSettings = { ...DEFAULT_SETTINGS, ...decrypted };\n   877→                // Use internal save to avoid infinite recursion\n   878→                _saveSettingsInternal(migratedSettings);\n   879→            }\n   880→\n   881→            // Return merged settings without internal fields\n   882→            const result = { ...DEFAULT_SETTINGS, ...decrypted };\n   883→            delete result._storageVersion;\n   884→            return result;\n   885→        }\n   886→    } catch (e) {\n   887→        console.warn('[Config] Error loading settings:', e);\n   888→    }\n   889→    return { ...DEFAULT_SETTINGS };\n   890→}\n   891→\n   892→/**\n   893→ * Save settings to localStorage\n   894→ * Encrypts sensitive fields before storing\n   895→ */\n   896→function saveSettings(settings) {\n   897→    try {\n   898→        // Get current settings (decrypted) and merge with new settings\n   899→        const current = getSettings();\n   900→        const merged = { ...current, ...settings };\n   901→\n   902→        return _saveSettingsInternal(merged);\n   903→    } catch (e) {\n   904→        console.warn('[Config] Error saving settings:', e);\n   905→        return false;\n   906→    }\n   907→}\n   908→\n   909→/**\n   910→ * Clear specific setting\n   911→ */\n   912→function clearSetting(key) {\n   913→    const settings = getSettings();\n   914→    delete settings[key];\n   915→    _saveSettingsInternal(settings);\n   916→}\n   917→\n   918→// ============================================================================\n   919→// OFFLINE DETECTION\n   920→// ============================================================================\n   921→\n   922→let isOnlineState = true;\n   923→let offlineCheckInterval = null;\n   924→\n   925→/**\n   926→ * Check if online\n   927→ */\n   928→function isOnline() {\n   929→    return isOnlineState && navigator.onLine;\n   930→}\n   931→\n   932→/**\n   933→ * Initialize offline detection\n   934→ */\n   935→function initOfflineDetection() {\n   936→    // Browser events\n   937→    window.addEventListener('online', () => {\n   938→        isOnlineState = true;\n   939→        updateOfflineUI(true);\n   940→    });\n   941→\n   942→    window.addEventListener('offline', () => {\n   943→        isOnlineState = false;\n   944→        updateOfflineUI(false);\n   945→    });\n   946→\n   947→    // Periodic check\n   948→    offlineCheckInterval = setInterval(async () => {\n   949→        try {\n   950→            const response = await fetchWithTimeout(\n   951→                `${getBackendUrl()}/health`,\n   952→                { method: 'GET' },\n   953→                5000\n   954→            );\n   955→            isOnlineState = response.ok;\n   956→        } catch {\n   957→            isOnlineState = false;\n   958→        }\n   959→        updateOfflineUI(isOnlineState);\n   960→    }, 30000);\n   961→}\n   962→\n   963→/**\n   964→ * Update UI based on online state\n   965→ */\n   966→function updateOfflineUI(online) {\n   967→    const goBtn = document.getElementById('goBtn');\n   968→    const status = document.getElementById('status');\n   969→\n   970→    if (goBtn) {\n   971→        goBtn.disabled = !online;\n   972→    }\n   973→\n   974→    if (status) {\n   975→        if (!online) {\n   976→            status.textContent = 'Offline - Check your connection';\n   977→            status.style.color = '#dc3545';\n   978→        } else {\n   979→            // Reset status when back online\n   980→            status.textContent = 'Ready';\n   981→            status.style.color = '#888';\n   982→        }\n   983→    }\n   984→}\n   985→\n   986→// ============================================================================\n   987→// UTILITY FUNCTIONS\n   988→// ============================================================================\n   989→\n   990→/**\n   991→ * SECURITY: Escape HTML to prevent XSS attacks\n   992→ * Use this when inserting untrusted content into innerHTML\n   993→ * @param {string} str - String to escape\n   994→ * @returns {string} Escaped string safe for innerHTML\n   995→ */\n   996→function escapeHtml(str) {\n   997→    if (str === null || str === undefined) return '';\n   998→    if (typeof str !== 'string') str = String(str);\n   999→\n  1000→    const escapeMap = {\n  1001→        '&': '&amp;',\n  1002→        '<': '&lt;',\n  1003→        '>': '&gt;',\n  1004→        '\"': '&quot;',\n  1005→        \"'\": '&#x27;',\n  1006→        '/': '&#x2F;',\n  1007→        '`': '&#x60;'\n  1008→    };\n  1009→\n  1010→    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n  1011→}\n  1012→\n  1013→/**\n  1014→ * SECURITY: Create safe HTML from template with escaped values\n  1015→ * @param {TemplateStringsArray} strings - Template strings\n  1016→ * @param {...any} values - Values to escape\n  1017→ * @returns {string} HTML with escaped values\n  1018→ */\n  1019→function safeHtml(strings, ...values) {\n  1020→    return strings.reduce((result, str, i) => {\n  1021→        const value = values[i - 1];\n  1022→        const escaped = escapeHtml(value);\n  1023→        return result + escaped + str;\n  1024→    });\n  1025→}\n  1026→\n  1027→/**\n  1028→ * Format time in MM:SS or HH:MM:SS\n  1029→ */\n  1030→function formatTime(seconds) {\n  1031→    if (isNaN(seconds) || seconds < 0) return '0:00';\n  1032→\n  1033→    const hours = Math.floor(seconds / 3600);\n  1034→    const minutes = Math.floor((seconds % 3600) / 60);\n  1035→    const secs = Math.floor(seconds % 60);\n  1036→\n  1037→    if (hours > 0) {\n  1038→        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  1039→    }\n  1040→    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n  1041→}\n  1042→\n  1043→/**\n  1044→ * Set status message\n  1045→ */\n  1046→function setStatus(message, isError = false) {\n  1047→    const status = document.getElementById('status');\n  1048→    if (status) {\n  1049→        status.textContent = message;\n  1050→        status.style.color = isError ? '#dc3545' : '#888';\n  1051→    }\n  1052→}\n  1053→\n  1054→/**\n  1055→ * Debounce function calls\n  1056→ */\n  1057→function debounce(func, wait) {\n  1058→    let timeout;\n  1059→    return function executedFunction(...args) {\n  1060→        const later = () => {\n  1061→            clearTimeout(timeout);\n  1062→            func(...args);\n  1063→        };\n  1064→        clearTimeout(timeout);\n  1065→        timeout = setTimeout(later, wait);\n  1066→    };\n  1067→}\n  1068→\n  1069→// ============================================================================\n  1070→// PRESET PROFILES\n  1071→// ============================================================================\n  1072→\n  1073→/**\n  1074→ * Detection presets for different content types.\n  1075→ * Each preset defines optimal settings for a specific use case.\n  1076→ */\n  1077→const PRESETS = {\n  1078→    // Custom - user-defined settings (default)\n  1079→    custom: {\n  1080→        name: 'Custom',\n  1081→        description: 'Your custom settings',\n  1082→        icon: 'settings',\n  1083→        settings: null // Uses current user settings\n  1084→    },\n  1085→\n  1086→    // Podcast - longer pauses are natural, be conservative\n  1087→    podcast: {\n  1088→        name: 'Podcast',\n  1089→        description: 'Longer natural pauses, J-Cuts enabled',\n  1090→        icon: 'mic',\n  1091→        settings: {\n  1092→            sensitivity: 35,\n  1093→            threshold: -35,\n  1094→            minSilenceLength: 0.8,\n  1095→            paddingStart: 0.15,\n  1096→            paddingEnd: 0.15,\n  1097→            enableTakesDetection: true,\n  1098→            enableJCut: true,\n  1099→            jCutLeadIn: 0.3,\n  1100→            jCutLeadOut: 0.2\n  1101→        }\n  1102→    },\n  1103→\n  1104→    // Interview - balanced, respects speaker pauses\n  1105→    interview: {\n  1106→        name: 'Interview',\n  1107→        description: 'Balanced cuts, J-Cuts for smooth transitions',\n  1108→        icon: 'people',\n  1109→        settings: {\n  1110→            sensitivity: 50,\n  1111→            threshold: -32,\n  1112→            minSilenceLength: 0.5,\n  1113→            paddingStart: 0.12,\n  1114→            paddingEnd: 0.08,\n  1115→            enableTakesDetection: true,\n  1116→            enableJCut: true,\n  1117→            jCutLeadIn: 0.25,\n  1118→            jCutLeadOut: 0.15\n  1119→        }\n  1120→    },\n  1121→\n  1122→    // Reaction video - fast pacing, quick cuts\n  1123→    reaction: {\n  1124→        name: 'Reaction',\n  1125→        description: 'Fast-paced, tight cuts for energy',\n  1126→        icon: 'bolt',\n  1127→        settings: {\n  1128→            sensitivity: 70,\n  1129→            threshold: -28,\n  1130→            minSilenceLength: 0.3,\n  1131→            paddingStart: 0.05,\n  1132→            paddingEnd: 0.03,\n  1133→            enableTakesDetection: false,\n  1134→            enableJCut: false,\n  1135→            jCutLeadIn: 0,\n  1136→            jCutLeadOut: 0\n  1137→        }\n  1138→    },\n  1139→\n  1140→    // Tutorial/Educational - preserve thinking pauses\n  1141→    tutorial: {\n  1142→        name: 'Tutorial',\n  1143→        description: 'Preserves teaching pace, J-Cuts enabled',\n  1144→        icon: 'school',\n  1145→        settings: {\n  1146→            sensitivity: 30,\n  1147→            threshold: -38,\n  1148→            minSilenceLength: 1.0,\n  1149→            paddingStart: 0.2,\n  1150→            paddingEnd: 0.15,\n  1151→            enableTakesDetection: true,\n  1152→            enableJCut: true,\n  1153→            jCutLeadIn: 0.35,\n  1154→            jCutLeadOut: 0.25\n  1155→        }\n  1156→    },\n  1157→\n  1158→    // Vlog/YouTube - punchy edits, engagement-focused\n  1159→    vlog: {\n  1160→        name: 'Vlog',\n  1161→        description: 'Punchy edits for YouTube engagement',\n  1162→        icon: 'videocam',\n  1163→        settings: {\n  1164→            sensitivity: 65,\n  1165→            threshold: -30,\n  1166→            minSilenceLength: 0.35,\n  1167→            paddingStart: 0.08,\n  1168→            paddingEnd: 0.05,\n  1169→            enableTakesDetection: true,\n  1170→            enableJCut: false,\n  1171→            jCutLeadIn: 0,\n  1172→            jCutLeadOut: 0\n  1173→        }\n  1174→    }\n  1175→};\n  1176→\n  1177→/**\n  1178→ * List of built-in preset IDs\n  1179→ */\n  1180→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n  1181→\n  1182→/**\n  1183→ * Get all available presets\n  1184→ * @returns {Object} All preset definitions\n  1185→ */\n  1186→function getPresets() {\n  1187→    return { ...PRESETS };\n  1188→}\n  1189→\n  1190→/**\n  1191→ * Get a specific preset by name\n  1192→ * @param {string} presetName - Name of the preset\n  1193→ * @returns {Object|null} Preset definition or null if not found\n  1194→ */\n  1195→function getPreset(presetName) {\n  1196→    return PRESETS[presetName] || null;\n  1197→}\n  1198→\n  1199→/**\n  1200→ * Check if a preset is a built-in preset\n  1201→ * @param {string} id - Preset ID to check\n  1202→ * @returns {boolean} True if built-in, false if custom\n  1203→ */\n  1204→function isBuiltInPreset(id) {\n  1205→    return BUILT_IN_PRESET_IDS.includes(id);\n  1206→}\n  1207→\n  1208→/**\n  1209→ * Apply a preset to current settings\n  1210→ * @param {string} presetName - Name of the preset to apply\n  1211→ * @returns {Object} The applied settings\n  1212→ */\n  1213→function applyPreset(presetName) {\n  1214→    const preset = PRESETS[presetName];\n  1215→\n  1216→    if (!preset) {\n  1217→        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n  1218→        return getSettings();\n  1219→    }\n  1220→\n  1221→    // Custom preset uses current settings\n  1222→    if (presetName === 'custom' || !preset.settings) {\n  1223→        saveSettings({ activePreset: 'custom' });\n  1224→        return getSettings();\n  1225→    }\n  1226→\n  1227→    // Apply preset settings\n  1228→    const newSettings = {\n  1229→        ...preset.settings,\n  1230→        activePreset: presetName\n  1231→    };\n  1232→\n  1233→    saveSettings(newSettings);\n  1234→    debugLog(`Applied preset: ${preset.name}`);\n  1235→\n  1236→    return getSettings();\n  1237→}\n  1238→\n  1239→/**\n  1240→ * Get the currently active preset\n  1241→ * @returns {string} Active preset name\n  1242→ */\n  1243→function getActivePreset() {\n  1244→    const settings = getSettings();\n  1245→    return settings.activePreset || 'custom';\n  1246→}\n  1247→\n  1248→/**\n  1249→ * Initialize preset selector\n  1250→ */\n  1251→function initPresetSelector() {\n  1252→    const presetSelector = document.getElementById('presetSelector');\n  1253→    const sensitivitySlider = document.getElementById('sensitivitySlider');\n  1254→\n  1255→    if (!presetSelector) return;\n  1256→\n  1257→    // Set initial value from settings\n  1258→    const settings = getSettings();\n  1259→    presetSelector.value = settings.activePreset || 'podcast';\n  1260→\n  1261→    // Handle preset change\n  1262→    presetSelector.addEventListener('change', () => {\n  1263→        const presetId = presetSelector.value;\n  1264→        const appliedSettings = applyPreset(presetId);\n  1265→\n  1266→        // Update sensitivity slider to match preset\n  1267→        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n  1268→            sensitivitySlider.value = appliedSettings.sensitivity;\n  1269→            // Update display value\n  1270→            const sensitivityValue = document.getElementById('sensitivityValue');\n  1271→            if (sensitivityValue) {\n  1272→                sensitivityValue.textContent = appliedSettings.sensitivity;\n  1273→            }\n  1274→        }\n  1275→\n  1276→        // Update takes detection checkbox\n  1277→        const enableTakesDetection = document.getElementById('enableTakesDetection');\n  1278→        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n  1279→            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n  1280→        }\n  1281→\n  1282→        // Update J-Cut checkbox\n  1283→        const enableJCut = document.getElementById('enableJCut');\n  1284→        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n  1285→            enableJCut.checked = appliedSettings.enableJCut;\n  1286→            // Toggle J-Cut settings visibility\n  1287→            const jcutSettings = document.getElementById('jcutSettings');\n  1288→            if (jcutSettings) {\n  1289→                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n  1290→            }\n  1291→        }\n  1292→\n  1293→        const preset = getPreset(presetId);\n  1294→        if (preset) {\n  1295→            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n  1296→        }\n  1297→    });\n  1298→\n  1299→    // Switch to custom when user manually changes sensitivity\n  1300→    if (sensitivitySlider) {\n  1301→        sensitivitySlider.addEventListener('change', () => {\n  1302→            if (presetSelector.value !== 'custom') {\n  1303→                presetSelector.value = 'custom';\n  1304→                saveSettings({ activePreset: 'custom' });\n  1305→            }\n  1306→        });\n  1307→    }\n  1308→}\n  1309→\n  1310→// ============================================================================\n  1311→// LOGIN MODAL\n  1312→// ============================================================================\n  1313→\n  1314→/**\n  1315→ * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n  1316→ * Character set excludes confusing chars: 0/O, 1/I/L\n  1317→ */\n  1318→function isValidLicenseKeyFormat(key) {\n  1319→    if (!key || typeof key !== 'string') return false;\n  1320→    const normalized = key.toUpperCase().trim();\n  1321→    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n  1322→    return pattern.test(normalized);\n  1323→}\n  1324→\n  1325→/**\n  1326→ * Initialize login modal handlers\n  1327→ */\n  1328→function initLoginModal() {\n  1329→    const loginModal = document.getElementById('loginModal');\n  1330→    const closeLoginBtn = document.getElementById('closeLoginBtn');\n  1331→    const saveLoginBtn = document.getElementById('saveLoginBtn');\n  1332→    const licenseKeyInput = document.getElementById('licenseKeyInput');\n  1333→    const creditBadge = document.getElementById('creditBadge');\n  1334→\n  1335→    // Handle credit badge click - retry on error, or show login modal\n  1336→    if (creditBadge) {\n  1337→        creditBadge.addEventListener('click', async () => {\n  1338→            if (creditBadge.classList.contains('error')) {\n  1339→                creditBadge.textContent = '...';\n  1340→                if (typeof refreshCredits === 'function') {\n  1341→                    await refreshCredits();\n  1342→                }\n  1343→                return;\n  1344→            }\n  1345→            showLoginModal();\n  1346→        });\n  1347→    }\n  1348→\n  1349→    // Close login modal\n  1350→    if (closeLoginBtn && loginModal) {\n  1351→        closeLoginBtn.addEventListener('click', () => {\n  1352→            loginModal.classList.add('hidden');\n  1353→        });\n  1354→    }\n  1355→\n  1356→    // Close on backdrop click\n  1357→    if (loginModal) {\n  1358→        loginModal.addEventListener('click', (e) => {\n  1359→            if (e.target === loginModal) {\n  1360→                loginModal.classList.add('hidden');\n  1361→            }\n  1362→        });\n  1363→    }\n  1364→\n  1365→    // Activate license key\n  1366→    if (saveLoginBtn) {\n  1367→        saveLoginBtn.addEventListener('click', async () => {\n  1368→            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n  1369→\n  1370→            if (!licenseKey) {\n  1371→                showLoginError('Please enter your license key');\n  1372→                return;\n  1373→            }\n  1374→\n  1375→            if (!isValidLicenseKeyFormat(licenseKey)) {\n  1376→                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n  1377→                return;\n  1378→            }\n  1379→\n  1380→            saveLoginBtn.disabled = true;\n  1381→            saveLoginBtn.textContent = 'Activating...';\n  1382→\n  1383→            try {\n  1384→                // Use /auth/login endpoint which returns JWT tokens\n  1385→                const response = await fetchWithTimeout(`${getBackendUrl()}/auth/login`, {\n  1386→                    method: 'POST',\n  1387→                    headers: { 'Content-Type': 'application/json' },\n  1388→                    body: JSON.stringify({ licenseKey: licenseKey })\n  1389→                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n  1390→\n  1391→                const result = await response.json();\n  1392→\n  1393→                if (!result.success) {\n  1394→                    showLoginError(result.error || 'Activation failed');\n  1395→                    return;\n  1396→                }\n  1397→\n  1398→                // Store JWT tokens and customer info\n  1399→                const expiresInMs = (result.expiresIn || 86400) * 1000; // Default 24h\n  1400→                saveSettings({\n  1401→                    customerId: result.customerId,\n  1402→                    accessToken: result.token,\n  1403→                    refreshToken: result.refreshToken,\n  1404→                    tokenExpiry: Date.now() + expiresInMs,\n  1405→                    licenseKey: licenseKey // Keep for re-authentication\n  1406→                });\n  1407→\n  1408→                loginModal?.classList.add('hidden');\n  1409→\n  1410→                if (typeof refreshCredits === 'function') {\n  1411→                    await refreshCredits();\n  1412→                }\n  1413→\n  1414→                const tierName = result.tier ? result.tier.charAt(0).toUpperCase() + result.tier.slice(1) : 'Unknown';\n  1415→                setStatus(`License activated! ${tierName} tier`);\n  1416→            } catch (err) {\n  1417→                console.error('[SPLICE] License activation error:', err);\n  1418→\n  1419→                // DIAGNOSTIC LOGGING: Capture exact error details (debug mode only)\n  1420→                debugLog('=== CEP LICENSE ACTIVATION ERROR DIAGNOSTICS ===');\n  1421→                debugLog('Error name:', err?.name);\n  1422→                debugLog('Error message:', err?.message);\n  1423→                debugLog('Error stack:', err?.stack);\n  1424→                debugLog('Backend URL:', getBackendUrl());\n  1425→                debugLog('Fetch timeout:', SPLICE_CONFIG.FETCH_TIMEOUT);\n  1426→                debugLog('Is CEP environment:', typeof CSInterface !== 'undefined');\n  1427→                debugLog('User agent:', navigator?.userAgent);\n  1428→                debugLog('Error constructor:', err?.constructor?.name);\n  1429→                debugLog('Is TypeError:', err?.name === 'TypeError');\n  1430→                debugLog('Message contains \"Failed to fetch\":', err?.message?.includes('Failed to fetch'));\n  1431→                debugLog('Message contains \"fetch\":', err?.message?.toLowerCase()?.includes('fetch'));\n  1432→                debugLog('Message contains \"network\":', err?.message?.toLowerCase()?.includes('network'));\n  1433→                debugLog('Message contains \"CORS\":', err?.message?.toLowerCase()?.includes('cors'));\n  1434→                debugLog('Message contains \"SSL\":', err?.message?.toLowerCase()?.includes('ssl'));\n  1435→                debugLog('Message contains \"certificate\":', err?.message?.toLowerCase()?.includes('certificate'));\n  1436→                debugLog('Full error object:', JSON.stringify(err, Object.getOwnPropertyNames(err)));\n  1437→                debugLog('================================================');\n  1438→\n  1439→                // Provide detailed error message based on error type\n  1440→                let errorMessage = 'Connection error. ';\n  1441→\n  1442→                if (err.message === 'Request timed out') {\n  1443→                    errorMessage += 'Server is not responding. Check if backend is running.';\n  1444→                } else if (err.message?.includes('Failed to fetch') || err.name === 'TypeError') {\n  1445→                    errorMessage += `Cannot reach ${getBackendUrl()}. Check network/firewall.`;\n  1446→                } else if (err.message?.includes('CORS')) {\n  1447→                    errorMessage += 'CORS error. Contact support.';\n  1448→                } else if (err.message?.includes('SSL') || err.message?.includes('certificate')) {\n  1449→                    errorMessage += 'SSL certificate error. Try updating your system certificates.';\n  1450→                } else if (err.message) {\n  1451→                    errorMessage += err.message;\n  1452→                } else {\n  1453→                    errorMessage += 'Unknown error. Check console for details.';\n  1454→                }\n  1455→\n  1456→                debugLog('Final error message shown to user:', errorMessage);\n  1457→                showLoginError(errorMessage);\n  1458→            } finally {\n  1459→                saveLoginBtn.disabled = false;\n  1460→                saveLoginBtn.textContent = 'Activate';\n  1461→            }\n  1462→        });\n  1463→    }\n  1464→\n  1465→    // Email lookup\n  1466→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n  1467→    const lookupEmailInput = document.getElementById('lookupEmailInput');\n  1468→\n  1469→    if (lookupLicenseBtn) {\n  1470→        lookupLicenseBtn.addEventListener('click', async () => {\n  1471→            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n  1472→\n  1473→            if (!email) {\n  1474→                showLoginError('Please enter your email address');\n  1475→                return;\n  1476→            }\n  1477→\n  1478→            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  1479→            if (!emailRegex.test(email)) {\n  1480→                showLoginError('Please enter a valid email address');\n  1481→                return;\n  1482→            }\n  1483→\n  1484→            lookupLicenseBtn.disabled = true;\n  1485→            lookupLicenseBtn.textContent = 'Looking up...';\n  1486→\n  1487→            try {\n  1488→                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n  1489→                    method: 'POST',\n  1490→                    headers: { 'Content-Type': 'application/json' },\n  1491→                    body: JSON.stringify({ email })\n  1492→                }, 30000);\n  1493→\n  1494→                const result = await response.json();\n  1495→\n  1496→                // Note: For security, the backend does NOT return the license key directly.\n  1497→                // It sends the key via email to prevent enumeration attacks.\n  1498→                if (result.success) {\n  1499→                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n  1500→                } else {\n  1501→                    showLoginError(result.error || 'Lookup failed. Please try again.');\n  1502→                }\n  1503→            } catch (err) {\n  1504→                console.error('[SPLICE] License lookup error:', err);\n  1505→                showLoginError('Failed to look up license. Please try again.');\n  1506→            } finally {\n  1507→                lookupLicenseBtn.disabled = false;\n  1508→                lookupLicenseBtn.textContent = 'Lookup';\n  1509→            }\n  1510→        });\n  1511→    }\n  1512→\n  1513→    // Handle external URL buttons\n  1514→    // CEP panels cannot use target=\"_blank\" for security reasons.\n  1515→    // Must use CSInterface.openURLInDefaultBrowser() instead.\n  1516→    initExternalLinkButtons();\n  1517→}\n  1518→\n  1519→/**\n  1520→ * Initialize all external link buttons that need CSInterface.openURLInDefaultBrowser()\n  1521→ * CEP panels cannot use target=\"_blank\" due to security restrictions\n  1522→ */\n  1523→function initExternalLinkButtons() {\n  1524→    // Check if CSInterface is available\n  1525→    if (typeof CSInterface === 'undefined') {\n  1526→        console.warn('[SPLICE] CSInterface not available - external links disabled');\n  1527→        return;\n  1528→    }\n  1529→\n  1530→    let cs;\n  1531→    try {\n  1532→        cs = new CSInterface();\n  1533→    } catch (e) {\n  1534→        console.warn('[SPLICE] Failed to create CSInterface:', e.message);\n  1535→        return;\n  1536→    }\n  1537→\n  1538→    // Buy a License button\n  1539→    const buyLicenseBtn = document.querySelector('.btn-buy-license');\n  1540→\n  1541→    if (buyLicenseBtn) {\n  1542→        buyLicenseBtn.addEventListener('click', (e) => {\n  1543→            e.preventDefault();\n  1544→            e.stopPropagation();\n  1545→\n  1546→            // Visual feedback\n  1547→            buyLicenseBtn.textContent = 'Opening...';\n  1548→            buyLicenseBtn.style.backgroundColor = '#28a745';\n  1549→\n  1550→            try {\n  1551→                cs.openURLInDefaultBrowser('https://spliceclips.com/pricing');\n  1552→\n  1553→                // Reset button after a delay\n  1554→                setTimeout(() => {\n  1555→                    buyLicenseBtn.textContent = 'Buy License';\n  1556→                    buyLicenseBtn.style.backgroundColor = '';\n  1557→                }, 2000);\n  1558→            } catch (err) {\n  1559→                console.error('[SPLICE] Failed to open URL:', err.message);\n  1560→                buyLicenseBtn.textContent = 'Error';\n  1561→                buyLicenseBtn.style.backgroundColor = '#dc3545';\n  1562→            }\n  1563→        });\n  1564→    }\n  1565→    \n  1566→    // View Plans button (in upgrade modal)\n  1567→    const viewPlansBtn = document.querySelector('.btn-view-plans');\n  1568→    if (viewPlansBtn) {\n  1569→        viewPlansBtn.addEventListener('click', (e) => {\n  1570→            e.preventDefault();\n  1571→            e.stopPropagation();\n  1572→            const url = viewPlansBtn.dataset.url || 'https://spliceclips.com/pricing';\n  1573→            cs.openURLInDefaultBrowser(url);\n  1574→        });\n  1575→    }\n  1576→    \n  1577→    // Referral link button\n  1578→    const referralBtn = document.querySelector('.btn-referral');\n  1579→    if (referralBtn) {\n  1580→        referralBtn.addEventListener('click', (e) => {\n  1581→            e.preventDefault();\n  1582→            e.stopPropagation();\n  1583→            const url = referralBtn.dataset.url || 'https://splice.video/referrals';\n  1584→            cs.openURLInDefaultBrowser(url);\n  1585→        });\n  1586→    }\n  1587→}\n  1588→\n  1589→/**\n  1590→ * Show login modal\n  1591→ */\n  1592→function showLoginModal() {\n  1593→    const loginModal = document.getElementById('loginModal');\n  1594→    const loginError = document.getElementById('loginError');\n  1595→    if (loginError) loginError.style.display = 'none';\n  1596→    if (loginModal) loginModal.classList.remove('hidden');\n  1597→}\n  1598→\n  1599→/**\n  1600→ * Show login error message\n  1601→ */\n  1602→function showLoginError(message) {\n  1603→    const loginError = document.getElementById('loginError');\n  1604→    if (loginError) {\n  1605→        loginError.textContent = message;\n  1606→        loginError.style.display = 'block';\n  1607→    }\n  1608→}\n  1609→\n  1610→/**\n  1611→ * Check if user is logged in\n  1612→ */\n  1613→function isLoggedIn() {\n  1614→    const settings = getSettings();\n  1615→    return !!settings.customerId;\n  1616→}\n  1617→\n  1618→/**\n  1619→ * Logout - clear all auth data\n  1620→ */\n  1621→function logout() {\n  1622→    // Clear all auth-related settings\n  1623→    saveSettings({\n  1624→        customerId: null,\n  1625→        accessToken: null,\n  1626→        refreshToken: null,\n  1627→        tokenExpiry: null,\n  1628→        licenseKey: null\n  1629→    });\n  1630→\n  1631→    if (typeof clearCreditsCache === 'function') {\n  1632→        clearCreditsCache();\n  1633→    }\n  1634→    if (typeof updateCreditDisplay === 'function') {\n  1635→        updateCreditDisplay(null);\n  1636→    }\n  1637→    setStatus('Logged out');\n  1638→}\n  1639→\n  1640→// Initialize JSX bridge when loaded\n  1641→document.addEventListener('DOMContentLoaded', () => {\n  1642→    jsx.init();\n  1643→});\n  1644→\n  1645→// Export for modules\n  1646→window.SPLICE_CONFIG = SPLICE_CONFIG;\n  1647→window.SPLICE_DEBUG = SPLICE_DEBUG;\n  1648→window.debugLog = debugLog;\n  1649→window.debugFetch = debugFetch;\n  1650→window.getBackendUrl = getBackendUrl;\n  1651→window.fetchWithTimeout = fetchWithTimeout;\n  1652→window.parseErrorResponse = parseErrorResponse;\n  1653→window.getAuthHeaders = getAuthHeaders;\n  1654→window.getSettings = getSettings;\n  1655→window.saveSettings = saveSettings;\n  1656→window.clearSetting = clearSetting;\n  1657→window.isOnline = isOnline;\n  1658→window.initOfflineDetection = initOfflineDetection;\n  1659→window.formatTime = formatTime;\n  1660→window.setStatus = setStatus;\n  1661→window.debounce = debounce;\n  1662→window.jsx = jsx;\n  1663→window.PRESETS = PRESETS;\n  1664→window.getPresets = getPresets;\n  1665→window.getPreset = getPreset;\n  1666→window.applyPreset = applyPreset;\n  1667→window.getActivePreset = getActivePreset;\n  1668→window.isBuiltInPreset = isBuiltInPreset;\n  1669→window.initPresetSelector = initPresetSelector;\n  1670→window.initLoginModal = initLoginModal;\n  1671→window.showLoginModal = showLoginModal;\n  1672→window.isLoggedIn = isLoggedIn;\n  1673→window.logout = logout;\n  1674→window.escapeHtml = escapeHtml;\n  1675→window.safeHtml = safeHtml;\n  1676→// JWT Auth functions\n  1677→window.isTokenExpired = isTokenExpired;\n  1678→window.refreshAccessToken = refreshAccessToken;\n  1679→window.clearAuthTokens = clearAuthTokens;\n  1680→window.ensureValidToken = ensureValidToken;\n  1681→\n\n</system-reminder>\n"}]},"uuid":"1ab360c5-b771-4bbc-9dfc-fb7142bb2794","timestamp":"2026-01-12T16:25:48.563Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js","content":"/**\n * SPLICE CEP Panel Configuration\n * Backend URLs, paths, and utility functions\n */\n\n// ============================================================================\n// DEBUG MODE CONFIGURATION\n// ============================================================================\n\n/**\n * Debug mode flag - enables verbose diagnostic logging\n * Can be enabled via localStorage for troubleshooting:\n *   localStorage.setItem('spliceDebugMode', 'true');\n *\n * Default: false (production mode - minimal logging)\n */\nconst SPLICE_DEBUG = localStorage.getItem('spliceDebugMode') === 'true';\n\n/**\n * Debug logging function - only outputs when debug mode is enabled\n * Use this for diagnostic/development logging that should be silent in production\n * @param {...any} args - Arguments to log (prefixed with [SPLICE DEBUG])\n */\nfunction debugLog(...args) {\n    if (SPLICE_DEBUG) {\n        console.log('[SPLICE DEBUG]', ...args);\n    }\n}\n\n/**\n * Debug fetch logging - verbose fetch request/response logging\n * @param {...any} args - Arguments to log (prefixed with [SPLICE FETCH])\n */\nfunction debugFetch(...args) {\n    if (SPLICE_DEBUG) {\n        console.log('[SPLICE FETCH]', ...args);\n    }\n}\n\n// ============================================================================\n// BACKEND CONFIGURATION\n// ============================================================================\nconst SPLICE_CONFIG = {\n    VERSION: '6.0.3',\n    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    BACKEND_DEV: 'https://127.0.0.1:3847',\n    FETCH_TIMEOUT: 120000, // 2 minutes\n    RETRY_ATTEMPTS: 3,\n    RETRY_DELAY: 1000\n};\n\n/**\n * Get the backend URL based on environment\n * FIXED: CEP panels always run from file://, so we default to PROD\n * Use localStorage to override for local development if needed\n */\nfunction getBackendUrl() {\n    // Priority 1: Allow override via localStorage (for local dev testing)\n    const customUrl = localStorage.getItem('spliceBackendUrl');\n    if (customUrl) {\n        debugLog('Using custom backend URL from localStorage:', customUrl);\n        return customUrl;\n    }\n\n    // Priority 2: Default to production backend\n    // (CEP panels always run from file://, so can't reliably detect dev mode)\n    debugLog('Using production backend URL:', SPLICE_CONFIG.BACKEND_PROD);\n    return SPLICE_CONFIG.BACKEND_PROD;\n}\n\n// ============================================================================\n// JSX BRIDGE - Communicate with Premiere Pro\n// ============================================================================\nconst jsx = {\n    cs: null,\n    _initPromise: null,\n    _initialized: false,\n    _jsxReady: false,\n\n    /**\n     * Initialize the CSInterface with FireCut-style retry logic\n     * Returns a promise that resolves when ready (true/false)\n     * Does NOT reject - gracefully handles missing CEP environment\n     */\n    init: function() {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = this._initWithRetry();\n        return this._initPromise;\n    },\n\n    /**\n     * FireCut-style retry logic for CSInterface initialization\n     * Retries up to 5 times with exponential backoff\n     */\n    _initWithRetry: async function() {\n        const maxRetries = 5;\n        const baseDelay = 200; // Start with 200ms, will double each retry\n\n        for (let attempt = 1; attempt <= maxRetries; attempt++) {\n            const success = await this._tryInit(attempt);\n            if (success) {\n                // After CSInterface init, verify JSX is ready\n                const jsxReady = await this._verifyJSXReady();\n                if (jsxReady) {\n                    this._jsxReady = true;\n                    debugLog(`[JSX] Full initialization complete on attempt ${attempt}`);\n                    return true;\n                } else {\n                    debugLog(`[JSX] CSInterface ready but JSX not responding, attempt ${attempt}/${maxRetries}`);\n                }\n            }\n\n            if (attempt < maxRetries) {\n                const delay = baseDelay * Math.pow(2, attempt - 1);\n                debugLog(`[JSX] Init attempt ${attempt} failed, retrying in ${delay}ms...`);\n                await this._delay(delay);\n            }\n        }\n\n        console.warn('[JSX] Initialization failed after all retries - panel may have limited functionality');\n        return this._initialized;\n    },\n\n    /**\n     * Single initialization attempt\n     */\n    _tryInit: function(attempt) {\n        return new Promise((resolve) => {\n            try {\n                if (typeof CSInterface !== 'undefined') {\n                    this.cs = new CSInterface();\n                    // Verify we're in a real CEP environment by checking for __adobe_cep__\n                    if (window.__adobe_cep__) {\n                        this._initialized = true;\n                        debugLog(`[JSX] CSInterface initialized successfully (CEP environment detected) - attempt ${attempt}`);\n                        resolve(true);\n                    } else {\n                        // CSInterface exists but no CEP runtime - browser/dev mode\n                        this._initialized = true;\n                        debugLog(`[JSX] CSInterface initialized (development/browser mode) - attempt ${attempt}`);\n                        resolve(true);\n                    }\n                } else {\n                    debugLog(`[JSX] CSInterface not yet available - attempt ${attempt}`);\n                    resolve(false);\n                }\n            } catch (err) {\n                console.error(`[JSX] Init attempt ${attempt} error:`, err);\n                resolve(false);\n            }\n        });\n    },\n\n    /**\n     * FireCut-style JSX readiness verification\n     * Tests that hostScript.jsx is actually loaded and responding\n     */\n    _verifyJSXReady: async function() {\n        if (!this.cs) return false;\n\n        return new Promise((resolve) => {\n            const timeout = setTimeout(() => {\n                debugLog('[JSX] JSX readiness check timed out');\n                resolve(false);\n            }, 2000);\n\n            try {\n                // Simple test that hostScript.jsx is loaded and responding\n                this.cs.evalScript('(function() { return typeof getActiveSequence === \"function\" ? \"ready\" : \"not_ready\"; })()', (result) => {\n                    clearTimeout(timeout);\n                    if (result === 'ready') {\n                        debugLog('[JSX] JSX bridge verified ready - hostScript.jsx loaded');\n                        resolve(true);\n                    } else {\n                        debugLog('[JSX] JSX functions not yet available:', result);\n                        resolve(false);\n                    }\n                });\n            } catch (err) {\n                clearTimeout(timeout);\n                debugLog('[JSX] JSX readiness check error:', err);\n                resolve(false);\n            }\n        });\n    },\n\n    /**\n     * Helper for async delay\n     */\n    _delay: function(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    },\n\n    /**\n     * Ensure JSX is initialized before making calls\n     */\n    ensureInitialized: async function() {\n        if (!this._initialized) {\n            await this.init();\n        }\n        if (!this.cs) {\n            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n        }\n    },\n\n    /**\n     * Execute ExtendScript in Premiere Pro\n     * @param {string} script - ExtendScript to execute\n     * @returns {Promise<any>} - Parsed result\n     */\n    evalScript: async function(script) {\n        await this.ensureInitialized();\n\n        return new Promise((resolve, reject) => {\n            this.cs.evalScript(script, (result) => {\n                if (result === 'undefined' || result === undefined) {\n                    resolve(null);\n                    return;\n                }\n\n                // Check for EvalScript error or ExtendScript runtime errors\n                if (typeof result === 'string' && (\n                    result.indexOf('EvalScript error') !== -1 ||\n                    result.indexOf('Error:') !== -1 ||\n                    result.indexOf('TypeError:') !== -1 ||\n                    result.indexOf('ReferenceError:') !== -1\n                )) {\n                    reject(new Error(result));\n                    return;\n                }\n\n                // Try to parse JSON\n                try {\n                    const parsed = JSON.parse(result);\n                    if (parsed.error) {\n                        reject(new Error(parsed.error));\n                    } else {\n                        resolve(parsed);\n                    }\n                } catch (e) {\n                    // Return as-is if not JSON\n                    resolve(result);\n                }\n            });\n        });\n    },\n\n    /**\n     * Call a JSX function with arguments\n     * @param {string} funcName - Function name\n     * @param {...any} args - Arguments to pass\n     * @returns {Promise<any>}\n     */\n    call: async function(funcName, ...args) {\n        await this.ensureInitialized();\n\n        const escapedArgs = args.map(arg => {\n            if (arg === null || arg === undefined) return 'null';\n            if (typeof arg === 'string') {\n                // Escape backslashes first, then other special chars\n                return `'${arg\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")\n                    .replace(/\\r/g, '\\\\r')\n                    .replace(/\\n/g, '\\\\n')\n                    .replace(/\\t/g, '\\\\t')}'`;\n            }\n            if (typeof arg === 'object') {\n                return `'${JSON.stringify(arg)\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")}'`;\n            }\n            return String(arg);\n        });\n\n        const script = `${funcName}(${escapedArgs.join(', ')})`;\n        return this.evalScript(script);\n    }\n};\n\n// ============================================================================\n// FETCH UTILITIES\n// ============================================================================\n\n/**\n * Fetch with timeout support\n * @param {string} url - URL to fetch\n * @param {object} options - Fetch options\n * @param {number} timeout - Timeout in ms\n */\nasync function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n    // DIAGNOSTIC: Log fetch request details (debug mode only)\n    debugFetch('=== FETCH REQUEST START ===');\n    debugFetch('URL:', url);\n    debugFetch('Method:', options?.method || 'GET');\n    debugFetch('Headers:', options?.headers);\n    debugFetch('Timeout:', timeout);\n    debugFetch('Is CEP environment:', typeof CSInterface !== 'undefined');\n    debugFetch('=================================');\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n        const response = await fetch(url, {\n            ...options,\n            signal: controller.signal\n        });\n        clearTimeout(timeoutId);\n\n        // DIAGNOSTIC: Log successful response (debug mode only)\n        debugFetch('=== FETCH RESPONSE SUCCESS ===');\n        debugFetch('Status:', response.status);\n        debugFetch('OK:', response.ok);\n        debugFetch('=================================');\n\n        return response;\n    } catch (error) {\n        clearTimeout(timeoutId);\n\n        // DIAGNOSTIC: Log raw fetch error (debug mode only)\n        debugFetch('=== FETCH ERROR CAUGHT ===');\n        debugFetch('Error name:', error?.name);\n        debugFetch('Error message:', error?.message);\n        debugFetch('Error type:', typeof error);\n        debugFetch('Error constructor:', error?.constructor?.name);\n        debugFetch('Is AbortError:', error.name === 'AbortError');\n        debugFetch('Is TypeError:', error.name === 'TypeError');\n        debugFetch('Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\n        debugFetch('=================================');\n\n        if (error.name === 'AbortError') {\n            throw new Error(`Request timeout after ${timeout}ms`);\n        }\n        throw error;\n    }\n}\n\n/**\n * Parse error response from backend\n * @param {Response} response - Fetch response\n */\nasync function parseErrorResponse(response) {\n    try {\n        const data = await response.json();\n        return data.error || data.message || `HTTP ${response.status}`;\n    } catch {\n        return `HTTP ${response.status}: ${response.statusText}`;\n    }\n}\n\n/**\n * Get auth headers for API requests\n * Uses JWT Bearer token if available, with legacy fallback\n */\nfunction getAuthHeaders() {\n    const headers = { 'Content-Type': 'application/json' };\n    const settings = getSettings();\n\n    // Prefer JWT Bearer token (modern auth)\n    if (settings.accessToken) {\n        headers['Authorization'] = `Bearer ${settings.accessToken}`;\n        return headers;\n    }\n\n    // Legacy fallback for backwards compatibility\n    // This will be removed after 2026-04-11\n    if (settings.customerId) {\n        headers['x-stripe-customer-id'] = settings.customerId;\n        console.warn('[SPLICE] Using deprecated x-stripe-customer-id header. Please re-login to upgrade to JWT auth.');\n    }\n\n    return headers;\n}\n\n/**\n * Check if the access token is expired or about to expire\n * @returns {boolean} True if token needs refresh\n */\nfunction isTokenExpired() {\n    const settings = getSettings();\n    if (!settings.tokenExpiry) return true;\n\n    // Refresh if less than 5 minutes remaining\n    const bufferMs = 5 * 60 * 1000;\n    return Date.now() >= (settings.tokenExpiry - bufferMs);\n}\n\n/**\n * Refresh the access token using the refresh token\n * @returns {Promise<boolean>} True if refresh succeeded\n */\nasync function refreshAccessToken() {\n    const settings = getSettings();\n\n    if (!settings.refreshToken) {\n        debugLog('[Auth] No refresh token available');\n        return false;\n    }\n\n    try {\n        debugLog('[Auth] Refreshing access token...');\n\n        const response = await fetchWithTimeout(`${getBackendUrl()}/auth/refresh`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ refreshToken: settings.refreshToken })\n        }, 30000);\n\n        if (!response.ok) {\n            const errorMsg = await parseErrorResponse(response);\n            console.error('[Auth] Token refresh failed:', errorMsg);\n\n            // If refresh token is invalid, clear auth and require re-login\n            if (response.status === 401) {\n                clearAuthTokens();\n            }\n            return false;\n        }\n\n        const data = await response.json();\n\n        // Save new access token\n        const expiresInMs = (data.expiresIn || 86400) * 1000; // Default 24h\n        saveSettings({\n            accessToken: data.token,\n            tokenExpiry: Date.now() + expiresInMs\n        });\n\n        debugLog('[Auth] Access token refreshed successfully');\n        return true;\n    } catch (err) {\n        console.error('[Auth] Token refresh error:', err);\n        return false;\n    }\n}\n\n/**\n * Clear all auth tokens (call on logout or auth failure)\n */\nfunction clearAuthTokens() {\n    saveSettings({\n        accessToken: null,\n        refreshToken: null,\n        tokenExpiry: null\n    });\n    debugLog('[Auth] Auth tokens cleared');\n}\n\n/**\n * Ensure we have a valid access token, refreshing if needed\n * @returns {Promise<boolean>} True if we have a valid token\n */\nasync function ensureValidToken() {\n    const settings = getSettings();\n\n    // No token at all - need to login\n    if (!settings.accessToken) {\n        return false;\n    }\n\n    // Token not expired - good to go\n    if (!isTokenExpired()) {\n        return true;\n    }\n\n    // Try to refresh\n    return await refreshAccessToken();\n}\n\n// ============================================================================\n// SETTINGS MANAGEMENT\n// ============================================================================\n\nconst DEFAULT_SETTINGS = {\n    sensitivity: 50,\n    minSilenceLength: 0.5,\n    sourceIsolated: false,\n    enableTakesDetection: true,\n    enableJCut: false,\n    jcutLeadIn: 0.3,\n    jcutLeadOut: 0.2,\n    enableZoom: false,\n    zoomFrequency: 'medium',\n    zoomPreset: 'medium',\n    zoomPlacement: 'sentence_start',\n    enableChapters: false,\n    maxChapters: 10,\n    minChapterLength: 60,\n    enableProfanity: false,\n    profanityLanguage: 'en',\n    bleepType: 'standard',\n    // Authentication\n    customerId: null,\n    licenseKey: null,\n    accessToken: null,\n    refreshToken: null,\n    tokenExpiry: null,\n    // UI State\n    expandedOptions: false,\n    activePreset: 'podcast',\n    rememberOptions: false\n};\n\n// Current storage version for future migrations\nconst SETTINGS_STORAGE_VERSION = 2;\n\n// Fields that contain sensitive data and should be encrypted\nconst SENSITIVE_FIELDS = ['customerId', 'licenseKey', 'accessToken', 'refreshToken'];\n\n// ============================================================================\n// ENCRYPTION HELPERS FOR SENSITIVE DATA (CEP-CRIT-002 FIX)\n// Uses AES-GCM encryption via Web Crypto API for proper security\n// ============================================================================\n\n// Encryption constants\nconst SPLICE_ENCRYPTION = {\n    ALGORITHM: 'AES-GCM',\n    KEY_LENGTH: 256,\n    IV_LENGTH: 12,\n    TAG_LENGTH: 128,\n    SALT: 'SPLICE_PANEL_SALT_v1', // Static salt for key derivation\n    ITERATIONS: 100000,\n    PREFIX: 'ENC:v1:'  // Prefix to identify encrypted values\n};\n\n// Cached encryption key (derived once per session)\nlet _encryptionKey = null;\n\n/**\n * Get or derive the encryption key from a machine-specific identifier\n * Uses PBKDF2 to derive a strong key from available identifiers\n * @returns {Promise<CryptoKey>} The derived encryption key\n */\nasync function getEncryptionKey() {\n    if (_encryptionKey) {\n        return _encryptionKey;\n    }\n\n    try {\n        // Use a combination of identifiers for key derivation\n        // In CEP, we use localStorage ID + app version as the key material\n        let keyMaterial = localStorage.getItem('splice_device_id');\n        if (!keyMaterial) {\n            // Generate a random device ID on first use\n            keyMaterial = crypto.randomUUID ? crypto.randomUUID() :\n                'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n                    const r = Math.random() * 16 | 0;\n                    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n                    return v.toString(16);\n                });\n            localStorage.setItem('splice_device_id', keyMaterial);\n        }\n\n        const encoder = new TextEncoder();\n        const keyData = encoder.encode(keyMaterial + SPLICE_ENCRYPTION.SALT);\n\n        // Import the key material for PBKDF2\n        const baseKey = await crypto.subtle.importKey(\n            'raw',\n            keyData,\n            'PBKDF2',\n            false,\n            ['deriveKey']\n        );\n\n        // Derive the actual AES key\n        _encryptionKey = await crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt: encoder.encode(SPLICE_ENCRYPTION.SALT),\n                iterations: SPLICE_ENCRYPTION.ITERATIONS,\n                hash: 'SHA-256'\n            },\n            baseKey,\n            {\n                name: SPLICE_ENCRYPTION.ALGORITHM,\n                length: SPLICE_ENCRYPTION.KEY_LENGTH\n            },\n            false,\n            ['encrypt', 'decrypt']\n        );\n\n        return _encryptionKey;\n    } catch (e) {\n        debugLog('[Config] Key derivation error:', e);\n        return null;\n    }\n}\n\n/**\n * Encrypt data for secure localStorage storage using AES-GCM\n *\n * @param {any} data - Data to encrypt\n * @returns {Promise<string|null>} Encrypted string with prefix or null on error\n */\nasync function encryptForStorageAsync(data) {\n    try {\n        if (data === null || data === undefined) {\n            return null;\n        }\n\n        const key = await getEncryptionKey();\n        if (!key) {\n            // Fallback to legacy encoding if crypto not available\n            debugLog('[Config] Crypto not available, using legacy encoding');\n            return legacyEncode(data);\n        }\n\n        const encoder = new TextEncoder();\n        const jsonStr = JSON.stringify(data);\n        const plaintext = encoder.encode(jsonStr);\n\n        // Generate random IV\n        const iv = crypto.getRandomValues(new Uint8Array(SPLICE_ENCRYPTION.IV_LENGTH));\n\n        // Encrypt\n        const ciphertext = await crypto.subtle.encrypt(\n            {\n                name: SPLICE_ENCRYPTION.ALGORITHM,\n                iv: iv,\n                tagLength: SPLICE_ENCRYPTION.TAG_LENGTH\n            },\n            key,\n            plaintext\n        );\n\n        // Combine IV + ciphertext and encode as base64\n        const combined = new Uint8Array(iv.length + ciphertext.byteLength);\n        combined.set(iv);\n        combined.set(new Uint8Array(ciphertext), iv.length);\n\n        // Convert to base64 with prefix\n        const base64 = btoa(String.fromCharCode(...combined));\n        return SPLICE_ENCRYPTION.PREFIX + base64;\n    } catch (e) {\n        debugLog('[Config] Encryption error:', e);\n        return legacyEncode(data);\n    }\n}\n\n/**\n * Decrypt data from localStorage using AES-GCM\n *\n * @param {string} data - Encrypted string\n * @returns {Promise<any|null>} Decrypted data or null on error\n */\nasync function decryptFromStorageAsync(data) {\n    try {\n        if (!data || typeof data !== 'string') {\n            return null;\n        }\n\n        // Check if this is the new encrypted format\n        if (!data.startsWith(SPLICE_ENCRYPTION.PREFIX)) {\n            // Try legacy decoding for backward compatibility\n            return legacyDecode(data);\n        }\n\n        const key = await getEncryptionKey();\n        if (!key) {\n            debugLog('[Config] Crypto not available for decryption');\n            return null;\n        }\n\n        // Remove prefix and decode base64\n        const base64Data = data.slice(SPLICE_ENCRYPTION.PREFIX.length);\n        const combined = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));\n\n        // Extract IV and ciphertext\n        const iv = combined.slice(0, SPLICE_ENCRYPTION.IV_LENGTH);\n        const ciphertext = combined.slice(SPLICE_ENCRYPTION.IV_LENGTH);\n\n        // Decrypt\n        const plaintext = await crypto.subtle.decrypt(\n            {\n                name: SPLICE_ENCRYPTION.ALGORITHM,\n                iv: iv,\n                tagLength: SPLICE_ENCRYPTION.TAG_LENGTH\n            },\n            key,\n            ciphertext\n        );\n\n        const decoder = new TextDecoder();\n        const jsonStr = decoder.decode(plaintext);\n        return JSON.parse(jsonStr);\n    } catch (e) {\n        // Try legacy decoding as fallback\n        return legacyDecode(data);\n    }\n}\n\n/**\n * Legacy encoding (Base64) for backward compatibility\n * @param {any} data - Data to encode\n * @returns {string|null} Encoded string\n */\nfunction legacyEncode(data) {\n    try {\n        if (data === null || data === undefined) {\n            return null;\n        }\n        const jsonStr = JSON.stringify(data);\n        const encoded = encodeURIComponent(jsonStr);\n        return btoa(encoded);\n    } catch (e) {\n        return null;\n    }\n}\n\n/**\n * Legacy decoding (Base64) for backward compatibility\n * @param {string} data - Encoded string\n * @returns {any|null} Decoded data\n */\nfunction legacyDecode(data) {\n    try {\n        if (!data || typeof data !== 'string') {\n            return null;\n        }\n        // Skip if it has the encryption prefix\n        if (data.startsWith(SPLICE_ENCRYPTION.PREFIX)) {\n            return null;\n        }\n        const decoded = atob(data);\n        const jsonStr = decodeURIComponent(decoded);\n        return JSON.parse(jsonStr);\n    } catch (e) {\n        return null;\n    }\n}\n\n/**\n * Synchronous wrapper for encryption (starts async operation)\n * For backward compatibility with existing sync code\n * @param {any} data - Data to encode\n * @returns {string|null} Encoded string (legacy format until async completes)\n */\nfunction encryptForStorage(data) {\n    // Return legacy encoding synchronously\n    // The async version should be preferred for new code\n    return legacyEncode(data);\n}\n\n/**\n * Synchronous wrapper for decryption\n * For backward compatibility with existing sync code\n * @param {string} data - Encoded string\n * @returns {any|null} Decoded data\n */\nfunction decryptFromStorage(data) {\n    // Handle new encrypted format by returning null (needs async)\n    if (data && data.startsWith(SPLICE_ENCRYPTION.PREFIX)) {\n        debugLog('[Config] Encrypted data requires async decryption');\n        return null;\n    }\n    return legacyDecode(data);\n}\n\n/**\n * Check if a value appears to be encrypted\n *\n * @param {any} value - Value to check\n * @returns {boolean} True if value appears to be encrypted\n */\nfunction isEncryptedValue(value) {\n    if (!value || typeof value !== 'string') {\n        return false;\n    }\n    // New encryption format\n    if (value.startsWith(SPLICE_ENCRYPTION.PREFIX)) {\n        return true;\n    }\n    // Unencrypted values typically start with known patterns\n    if (value.startsWith('cus_') || value.startsWith('SPLICE-')) {\n        return false;\n    }\n    // Check if it's legacy base64 encoded JSON\n    try {\n        const decoded = atob(value);\n        const jsonStr = decodeURIComponent(decoded);\n        JSON.parse(jsonStr);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Encrypt sensitive fields in settings object\n *\n * @param {Object} settings - Settings object with plaintext sensitive fields\n * @returns {Object} Settings with encrypted sensitive fields\n */\nfunction encryptSensitiveFields(settings) {\n    const encrypted = { ...settings };\n\n    for (const field of SENSITIVE_FIELDS) {\n        if (encrypted[field] !== null && encrypted[field] !== undefined) {\n            // Only encrypt if not already encrypted\n            if (!isEncryptedValue(encrypted[field])) {\n                encrypted[field] = encryptForStorage(encrypted[field]);\n                debugLog(`[Config] Encrypted field: ${field}`);\n            }\n        }\n    }\n\n    return encrypted;\n}\n\n/**\n * Decrypt sensitive fields in settings object\n *\n * @param {Object} settings - Settings object with encrypted sensitive fields\n * @returns {Object} Settings with decrypted sensitive fields\n */\nfunction decryptSensitiveFields(settings) {\n    const decrypted = { ...settings };\n\n    for (const field of SENSITIVE_FIELDS) {\n        if (decrypted[field] !== null && decrypted[field] !== undefined) {\n            // Check if it looks encrypted before attempting to decrypt\n            if (isEncryptedValue(decrypted[field])) {\n                const decryptedValue = decryptFromStorage(decrypted[field]);\n                if (decryptedValue !== null) {\n                    decrypted[field] = decryptedValue;\n                    debugLog(`[Config] Decrypted field: ${field}`);\n                }\n            }\n            // If not encrypted (legacy data), keep the original value\n        }\n    }\n\n    return decrypted;\n}\n\n/**\n * Internal save function to avoid recursion during migration\n * @private\n */\nfunction _saveSettingsInternal(settings) {\n    try {\n        // Encrypt sensitive fields before storing\n        const toStore = encryptSensitiveFields(settings);\n\n        // Add version marker for future migrations\n        toStore._storageVersion = SETTINGS_STORAGE_VERSION;\n\n        localStorage.setItem('spliceSettings', JSON.stringify(toStore));\n        return true;\n    } catch (e) {\n        console.warn('[Config] Error saving settings:', e);\n        return false;\n    }\n}\n\n/**\n * Get settings from localStorage\n * Handles migration from unencrypted to encrypted storage format\n */\nfunction getSettings() {\n    try {\n        const stored = localStorage.getItem('spliceSettings');\n        if (stored) {\n            const parsed = JSON.parse(stored);\n\n            // Decrypt sensitive fields (handles both encrypted and legacy unencrypted data)\n            const decrypted = decryptSensitiveFields(parsed);\n\n            // Check if migration is needed (no version marker = legacy data)\n            if (!parsed._storageVersion) {\n                // Migrate legacy data: save with encryption and version marker\n                debugLog('[Config] Migrating legacy settings to encrypted format');\n                const migratedSettings = { ...DEFAULT_SETTINGS, ...decrypted };\n                // Use internal save to avoid infinite recursion\n                _saveSettingsInternal(migratedSettings);\n            }\n\n            // Return merged settings without internal fields\n            const result = { ...DEFAULT_SETTINGS, ...decrypted };\n            delete result._storageVersion;\n            return result;\n        }\n    } catch (e) {\n        console.warn('[Config] Error loading settings:', e);\n    }\n    return { ...DEFAULT_SETTINGS };\n}\n\n/**\n * Save settings to localStorage\n * Encrypts sensitive fields before storing\n */\nfunction saveSettings(settings) {\n    try {\n        // Get current settings (decrypted) and merge with new settings\n        const current = getSettings();\n        const merged = { ...current, ...settings };\n\n        return _saveSettingsInternal(merged);\n    } catch (e) {\n        console.warn('[Config] Error saving settings:', e);\n        return false;\n    }\n}\n\n/**\n * Clear specific setting\n */\nfunction clearSetting(key) {\n    const settings = getSettings();\n    delete settings[key];\n    _saveSettingsInternal(settings);\n}\n\n// ============================================================================\n// OFFLINE DETECTION\n// ============================================================================\n\nlet isOnlineState = true;\nlet offlineCheckInterval = null;\n\n/**\n * Check if online\n */\nfunction isOnline() {\n    return isOnlineState && navigator.onLine;\n}\n\n/**\n * Initialize offline detection\n */\nfunction initOfflineDetection() {\n    // Browser events\n    window.addEventListener('online', () => {\n        isOnlineState = true;\n        updateOfflineUI(true);\n    });\n\n    window.addEventListener('offline', () => {\n        isOnlineState = false;\n        updateOfflineUI(false);\n    });\n\n    // Periodic check\n    offlineCheckInterval = setInterval(async () => {\n        try {\n            const response = await fetchWithTimeout(\n                `${getBackendUrl()}/health`,\n                { method: 'GET' },\n                5000\n            );\n            isOnlineState = response.ok;\n        } catch {\n            isOnlineState = false;\n        }\n        updateOfflineUI(isOnlineState);\n    }, 30000);\n}\n\n/**\n * Update UI based on online state\n */\nfunction updateOfflineUI(online) {\n    const goBtn = document.getElementById('goBtn');\n    const status = document.getElementById('status');\n\n    if (goBtn) {\n        goBtn.disabled = !online;\n    }\n\n    if (status) {\n        if (!online) {\n            status.textContent = 'Offline - Check your connection';\n            status.style.color = '#dc3545';\n        } else {\n            // Reset status when back online\n            status.textContent = 'Ready';\n            status.style.color = '#888';\n        }\n    }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * SECURITY: Escape HTML to prevent XSS attacks\n * Use this when inserting untrusted content into innerHTML\n * @param {string} str - String to escape\n * @returns {string} Escaped string safe for innerHTML\n */\nfunction escapeHtml(str) {\n    if (str === null || str === undefined) return '';\n    if (typeof str !== 'string') str = String(str);\n\n    const escapeMap = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;',\n        '/': '&#x2F;',\n        '`': '&#x60;'\n    };\n\n    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n}\n\n/**\n * SECURITY: Create safe HTML from template with escaped values\n * @param {TemplateStringsArray} strings - Template strings\n * @param {...any} values - Values to escape\n * @returns {string} HTML with escaped values\n */\nfunction safeHtml(strings, ...values) {\n    return strings.reduce((result, str, i) => {\n        const value = values[i - 1];\n        const escaped = escapeHtml(value);\n        return result + escaped + str;\n    });\n}\n\n/**\n * Format time in MM:SS or HH:MM:SS\n */\nfunction formatTime(seconds) {\n    if (isNaN(seconds) || seconds < 0) return '0:00';\n\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n\n    if (hours > 0) {\n        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Set status message\n */\nfunction setStatus(message, isError = false) {\n    const status = document.getElementById('status');\n    if (status) {\n        status.textContent = message;\n        status.style.color = isError ? '#dc3545' : '#888';\n    }\n}\n\n/**\n * Debounce function calls\n */\nfunction debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n        const later = () => {\n            clearTimeout(timeout);\n            func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n\n// ============================================================================\n// PRESET PROFILES\n// ============================================================================\n\n/**\n * Detection presets for different content types.\n * Each preset defines optimal settings for a specific use case.\n */\nconst PRESETS = {\n    // Custom - user-defined settings (default)\n    custom: {\n        name: 'Custom',\n        description: 'Your custom settings',\n        icon: 'settings',\n        settings: null // Uses current user settings\n    },\n\n    // Podcast - longer pauses are natural, be conservative\n    podcast: {\n        name: 'Podcast',\n        description: 'Longer natural pauses, J-Cuts enabled',\n        icon: 'mic',\n        settings: {\n            sensitivity: 35,\n            threshold: -35,\n            minSilenceLength: 0.8,\n            paddingStart: 0.15,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.3,\n            jCutLeadOut: 0.2\n        }\n    },\n\n    // Interview - balanced, respects speaker pauses\n    interview: {\n        name: 'Interview',\n        description: 'Balanced cuts, J-Cuts for smooth transitions',\n        icon: 'people',\n        settings: {\n            sensitivity: 50,\n            threshold: -32,\n            minSilenceLength: 0.5,\n            paddingStart: 0.12,\n            paddingEnd: 0.08,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.25,\n            jCutLeadOut: 0.15\n        }\n    },\n\n    // Reaction video - fast pacing, quick cuts\n    reaction: {\n        name: 'Reaction',\n        description: 'Fast-paced, tight cuts for energy',\n        icon: 'bolt',\n        settings: {\n            sensitivity: 70,\n            threshold: -28,\n            minSilenceLength: 0.3,\n            paddingStart: 0.05,\n            paddingEnd: 0.03,\n            enableTakesDetection: false,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    },\n\n    // Tutorial/Educational - preserve thinking pauses\n    tutorial: {\n        name: 'Tutorial',\n        description: 'Preserves teaching pace, J-Cuts enabled',\n        icon: 'school',\n        settings: {\n            sensitivity: 30,\n            threshold: -38,\n            minSilenceLength: 1.0,\n            paddingStart: 0.2,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.35,\n            jCutLeadOut: 0.25\n        }\n    },\n\n    // Vlog/YouTube - punchy edits, engagement-focused\n    vlog: {\n        name: 'Vlog',\n        description: 'Punchy edits for YouTube engagement',\n        icon: 'videocam',\n        settings: {\n            sensitivity: 65,\n            threshold: -30,\n            minSilenceLength: 0.35,\n            paddingStart: 0.08,\n            paddingEnd: 0.05,\n            enableTakesDetection: true,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    }\n};\n\n/**\n * List of built-in preset IDs\n */\nconst BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n\n/**\n * Get all available presets\n * @returns {Object} All preset definitions\n */\nfunction getPresets() {\n    return { ...PRESETS };\n}\n\n/**\n * Get a specific preset by name\n * @param {string} presetName - Name of the preset\n * @returns {Object|null} Preset definition or null if not found\n */\nfunction getPreset(presetName) {\n    return PRESETS[presetName] || null;\n}\n\n/**\n * Check if a preset is a built-in preset\n * @param {string} id - Preset ID to check\n * @returns {boolean} True if built-in, false if custom\n */\nfunction isBuiltInPreset(id) {\n    return BUILT_IN_PRESET_IDS.includes(id);\n}\n\n/**\n * Apply a preset to current settings\n * @param {string} presetName - Name of the preset to apply\n * @returns {Object} The applied settings\n */\nfunction applyPreset(presetName) {\n    const preset = PRESETS[presetName];\n\n    if (!preset) {\n        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n        return getSettings();\n    }\n\n    // Custom preset uses current settings\n    if (presetName === 'custom' || !preset.settings) {\n        saveSettings({ activePreset: 'custom' });\n        return getSettings();\n    }\n\n    // Apply preset settings\n    const newSettings = {\n        ...preset.settings,\n        activePreset: presetName\n    };\n\n    saveSettings(newSettings);\n    debugLog(`Applied preset: ${preset.name}`);\n\n    return getSettings();\n}\n\n/**\n * Get the currently active preset\n * @returns {string} Active preset name\n */\nfunction getActivePreset() {\n    const settings = getSettings();\n    return settings.activePreset || 'custom';\n}\n\n/**\n * Initialize preset selector\n */\nfunction initPresetSelector() {\n    const presetSelector = document.getElementById('presetSelector');\n    const sensitivitySlider = document.getElementById('sensitivitySlider');\n\n    if (!presetSelector) return;\n\n    // Set initial value from settings\n    const settings = getSettings();\n    presetSelector.value = settings.activePreset || 'podcast';\n\n    // Handle preset change\n    presetSelector.addEventListener('change', () => {\n        const presetId = presetSelector.value;\n        const appliedSettings = applyPreset(presetId);\n\n        // Update sensitivity slider to match preset\n        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n            sensitivitySlider.value = appliedSettings.sensitivity;\n            // Update display value\n            const sensitivityValue = document.getElementById('sensitivityValue');\n            if (sensitivityValue) {\n                sensitivityValue.textContent = appliedSettings.sensitivity;\n            }\n        }\n\n        // Update takes detection checkbox\n        const enableTakesDetection = document.getElementById('enableTakesDetection');\n        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n        }\n\n        // Update J-Cut checkbox\n        const enableJCut = document.getElementById('enableJCut');\n        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n            enableJCut.checked = appliedSettings.enableJCut;\n            // Toggle J-Cut settings visibility\n            const jcutSettings = document.getElementById('jcutSettings');\n            if (jcutSettings) {\n                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n            }\n        }\n\n        const preset = getPreset(presetId);\n        if (preset) {\n            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n        }\n    });\n\n    // Switch to custom when user manually changes sensitivity\n    if (sensitivitySlider) {\n        sensitivitySlider.addEventListener('change', () => {\n            if (presetSelector.value !== 'custom') {\n                presetSelector.value = 'custom';\n                saveSettings({ activePreset: 'custom' });\n            }\n        });\n    }\n}\n\n// ============================================================================\n// LOGIN MODAL\n// ============================================================================\n\n/**\n * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n * Character set excludes confusing chars: 0/O, 1/I/L\n */\nfunction isValidLicenseKeyFormat(key) {\n    if (!key || typeof key !== 'string') return false;\n    const normalized = key.toUpperCase().trim();\n    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n    return pattern.test(normalized);\n}\n\n/**\n * Initialize login modal handlers\n */\nfunction initLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const closeLoginBtn = document.getElementById('closeLoginBtn');\n    const saveLoginBtn = document.getElementById('saveLoginBtn');\n    const licenseKeyInput = document.getElementById('licenseKeyInput');\n    const creditBadge = document.getElementById('creditBadge');\n\n    // Handle credit badge click - retry on error, or show login modal\n    if (creditBadge) {\n        creditBadge.addEventListener('click', async () => {\n            if (creditBadge.classList.contains('error')) {\n                creditBadge.textContent = '...';\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n                return;\n            }\n            showLoginModal();\n        });\n    }\n\n    // Close login modal\n    if (closeLoginBtn && loginModal) {\n        closeLoginBtn.addEventListener('click', () => {\n            loginModal.classList.add('hidden');\n        });\n    }\n\n    // Close on backdrop click\n    if (loginModal) {\n        loginModal.addEventListener('click', (e) => {\n            if (e.target === loginModal) {\n                loginModal.classList.add('hidden');\n            }\n        });\n    }\n\n    // Activate license key\n    if (saveLoginBtn) {\n        saveLoginBtn.addEventListener('click', async () => {\n            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n\n            if (!licenseKey) {\n                showLoginError('Please enter your license key');\n                return;\n            }\n\n            if (!isValidLicenseKeyFormat(licenseKey)) {\n                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n                return;\n            }\n\n            saveLoginBtn.disabled = true;\n            saveLoginBtn.textContent = 'Activating...';\n\n            try {\n                // Use /auth/login endpoint which returns JWT tokens\n                const response = await fetchWithTimeout(`${getBackendUrl()}/auth/login`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ licenseKey: licenseKey })\n                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n                const result = await response.json();\n\n                if (!result.success) {\n                    showLoginError(result.error || 'Activation failed');\n                    return;\n                }\n\n                // Store JWT tokens and customer info\n                const expiresInMs = (result.expiresIn || 86400) * 1000; // Default 24h\n                saveSettings({\n                    customerId: result.customerId,\n                    accessToken: result.token,\n                    refreshToken: result.refreshToken,\n                    tokenExpiry: Date.now() + expiresInMs,\n                    licenseKey: licenseKey // Keep for re-authentication\n                });\n\n                loginModal?.classList.add('hidden');\n\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n\n                const tierName = result.tier ? result.tier.charAt(0).toUpperCase() + result.tier.slice(1) : 'Unknown';\n                setStatus(`License activated! ${tierName} tier`);\n            } catch (err) {\n                console.error('[SPLICE] License activation error:', err);\n\n                // DIAGNOSTIC LOGGING: Capture exact error details (debug mode only)\n                debugLog('=== CEP LICENSE ACTIVATION ERROR DIAGNOSTICS ===');\n                debugLog('Error name:', err?.name);\n                debugLog('Error message:', err?.message);\n                debugLog('Error stack:', err?.stack);\n                debugLog('Backend URL:', getBackendUrl());\n                debugLog('Fetch timeout:', SPLICE_CONFIG.FETCH_TIMEOUT);\n                debugLog('Is CEP environment:', typeof CSInterface !== 'undefined');\n                debugLog('User agent:', navigator?.userAgent);\n                debugLog('Error constructor:', err?.constructor?.name);\n                debugLog('Is TypeError:', err?.name === 'TypeError');\n                debugLog('Message contains \"Failed to fetch\":', err?.message?.includes('Failed to fetch'));\n                debugLog('Message contains \"fetch\":', err?.message?.toLowerCase()?.includes('fetch'));\n                debugLog('Message contains \"network\":', err?.message?.toLowerCase()?.includes('network'));\n                debugLog('Message contains \"CORS\":', err?.message?.toLowerCase()?.includes('cors'));\n                debugLog('Message contains \"SSL\":', err?.message?.toLowerCase()?.includes('ssl'));\n                debugLog('Message contains \"certificate\":', err?.message?.toLowerCase()?.includes('certificate'));\n                debugLog('Full error object:', JSON.stringify(err, Object.getOwnPropertyNames(err)));\n                debugLog('================================================');\n\n                // Provide detailed error message based on error type\n                let errorMessage = 'Connection error. ';\n\n                if (err.message === 'Request timed out') {\n                    errorMessage += 'Server is not responding. Check if backend is running.';\n                } else if (err.message?.includes('Failed to fetch') || err.name === 'TypeError') {\n                    errorMessage += `Cannot reach ${getBackendUrl()}. Check network/firewall.`;\n                } else if (err.message?.includes('CORS')) {\n                    errorMessage += 'CORS error. Contact support.';\n                } else if (err.message?.includes('SSL') || err.message?.includes('certificate')) {\n                    errorMessage += 'SSL certificate error. Try updating your system certificates.';\n                } else if (err.message) {\n                    errorMessage += err.message;\n                } else {\n                    errorMessage += 'Unknown error. Check console for details.';\n                }\n\n                debugLog('Final error message shown to user:', errorMessage);\n                showLoginError(errorMessage);\n            } finally {\n                saveLoginBtn.disabled = false;\n                saveLoginBtn.textContent = 'Activate';\n            }\n        });\n    }\n\n    // Email lookup\n    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n    const lookupEmailInput = document.getElementById('lookupEmailInput');\n\n    if (lookupLicenseBtn) {\n        lookupLicenseBtn.addEventListener('click', async () => {\n            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n\n            if (!email) {\n                showLoginError('Please enter your email address');\n                return;\n            }\n\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(email)) {\n                showLoginError('Please enter a valid email address');\n                return;\n            }\n\n            lookupLicenseBtn.disabled = true;\n            lookupLicenseBtn.textContent = 'Looking up...';\n\n            try {\n                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ email })\n                }, 30000);\n\n                const result = await response.json();\n\n                // Note: For security, the backend does NOT return the license key directly.\n                // It sends the key via email to prevent enumeration attacks.\n                if (result.success) {\n                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n                } else {\n                    showLoginError(result.error || 'Lookup failed. Please try again.');\n                }\n            } catch (err) {\n                console.error('[SPLICE] License lookup error:', err);\n                showLoginError('Failed to look up license. Please try again.');\n            } finally {\n                lookupLicenseBtn.disabled = false;\n                lookupLicenseBtn.textContent = 'Lookup';\n            }\n        });\n    }\n\n    // Handle external URL buttons\n    // CEP panels cannot use target=\"_blank\" for security reasons.\n    // Must use CSInterface.openURLInDefaultBrowser() instead.\n    initExternalLinkButtons();\n}\n\n/**\n * Initialize all external link buttons that need CSInterface.openURLInDefaultBrowser()\n * CEP panels cannot use target=\"_blank\" due to security restrictions\n */\nfunction initExternalLinkButtons() {\n    // Check if CSInterface is available\n    if (typeof CSInterface === 'undefined') {\n        console.warn('[SPLICE] CSInterface not available - external links disabled');\n        return;\n    }\n\n    let cs;\n    try {\n        cs = new CSInterface();\n    } catch (e) {\n        console.warn('[SPLICE] Failed to create CSInterface:', e.message);\n        return;\n    }\n\n    // Buy a License button\n    const buyLicenseBtn = document.querySelector('.btn-buy-license');\n\n    if (buyLicenseBtn) {\n        buyLicenseBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n\n            // Visual feedback\n            buyLicenseBtn.textContent = 'Opening...';\n            buyLicenseBtn.style.backgroundColor = '#28a745';\n\n            try {\n                cs.openURLInDefaultBrowser('https://spliceclips.com/pricing');\n\n                // Reset button after a delay\n                setTimeout(() => {\n                    buyLicenseBtn.textContent = 'Buy License';\n                    buyLicenseBtn.style.backgroundColor = '';\n                }, 2000);\n            } catch (err) {\n                console.error('[SPLICE] Failed to open URL:', err.message);\n                buyLicenseBtn.textContent = 'Error';\n                buyLicenseBtn.style.backgroundColor = '#dc3545';\n            }\n        });\n    }\n    \n    // View Plans button (in upgrade modal)\n    const viewPlansBtn = document.querySelector('.btn-view-plans');\n    if (viewPlansBtn) {\n        viewPlansBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const url = viewPlansBtn.dataset.url || 'https://spliceclips.com/pricing';\n            cs.openURLInDefaultBrowser(url);\n        });\n    }\n    \n    // Referral link button\n    const referralBtn = document.querySelector('.btn-referral');\n    if (referralBtn) {\n        referralBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const url = referralBtn.dataset.url || 'https://splice.video/referrals';\n            cs.openURLInDefaultBrowser(url);\n        });\n    }\n}\n\n/**\n * Show login modal\n */\nfunction showLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const loginError = document.getElementById('loginError');\n    if (loginError) loginError.style.display = 'none';\n    if (loginModal) loginModal.classList.remove('hidden');\n}\n\n/**\n * Show login error message\n */\nfunction showLoginError(message) {\n    const loginError = document.getElementById('loginError');\n    if (loginError) {\n        loginError.textContent = message;\n        loginError.style.display = 'block';\n    }\n}\n\n/**\n * Check if user is logged in\n */\nfunction isLoggedIn() {\n    const settings = getSettings();\n    return !!settings.customerId;\n}\n\n/**\n * Logout - clear all auth data\n */\nfunction logout() {\n    // Clear all auth-related settings\n    saveSettings({\n        customerId: null,\n        accessToken: null,\n        refreshToken: null,\n        tokenExpiry: null,\n        licenseKey: null\n    });\n\n    if (typeof clearCreditsCache === 'function') {\n        clearCreditsCache();\n    }\n    if (typeof updateCreditDisplay === 'function') {\n        updateCreditDisplay(null);\n    }\n    setStatus('Logged out');\n}\n\n// Initialize JSX bridge when loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    jsx.init();\n});\n\n// Export for modules\nwindow.SPLICE_CONFIG = SPLICE_CONFIG;\nwindow.SPLICE_DEBUG = SPLICE_DEBUG;\nwindow.debugLog = debugLog;\nwindow.debugFetch = debugFetch;\nwindow.getBackendUrl = getBackendUrl;\nwindow.fetchWithTimeout = fetchWithTimeout;\nwindow.parseErrorResponse = parseErrorResponse;\nwindow.getAuthHeaders = getAuthHeaders;\nwindow.getSettings = getSettings;\nwindow.saveSettings = saveSettings;\nwindow.clearSetting = clearSetting;\nwindow.isOnline = isOnline;\nwindow.initOfflineDetection = initOfflineDetection;\nwindow.formatTime = formatTime;\nwindow.setStatus = setStatus;\nwindow.debounce = debounce;\nwindow.jsx = jsx;\nwindow.PRESETS = PRESETS;\nwindow.getPresets = getPresets;\nwindow.getPreset = getPreset;\nwindow.applyPreset = applyPreset;\nwindow.getActivePreset = getActivePreset;\nwindow.isBuiltInPreset = isBuiltInPreset;\nwindow.initPresetSelector = initPresetSelector;\nwindow.initLoginModal = initLoginModal;\nwindow.showLoginModal = showLoginModal;\nwindow.isLoggedIn = isLoggedIn;\nwindow.logout = logout;\nwindow.escapeHtml = escapeHtml;\nwindow.safeHtml = safeHtml;\n// JWT Auth functions\nwindow.isTokenExpired = isTokenExpired;\nwindow.refreshAccessToken = refreshAccessToken;\nwindow.clearAuthTokens = clearAuthTokens;\nwindow.ensureValidToken = ensureValidToken;\n","numLines":1681,"startLine":1,"totalLines":1681}}}
{"parentUuid":"1ab360c5-b771-4bbc-9dfc-fb7142bb2794","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE/splice-cep/panel/js","sessionId":"7fa929e3-00b9-497c-b311-19cb4c6b44f9","version":"2.0.76","gitBranch":"main","agentId":"a09f1cb","slug":"eager-questing-lagoon","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KBoYAur3jqZr3ZtCjb5Vbh","type":"message","role":"assistant","content":[{"type":"text","text":"## Production Bottleneck Analysis: `/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js`\n\n### Bug Summary\nMultiple race conditions, token refresh loops, and missing error boundaries in the credits module that could cause authentication failures, stale data display, and poor user experience under production load.\n\n---\n\n## Root Cause Analysis\n\n### **CRITICAL ISSUES**\n\n#### **1. Token Refresh Race Condition (SEVERITY: HIGH)**\n**Location:** `credits.js:52-88`\n\n**Root Cause:** Multiple simultaneous API calls can trigger concurrent token refresh attempts, causing race conditions and potential token invalidation.\n\n**Trace Path:**\n1. User action triggers `fetchCredits()` at line 23\n2. Gets 401 response (line 52)\n3. Calls `refreshAccessToken()` (line 54)\n4. During refresh, another `fetchCredits()` call starts (e.g., from 5-minute interval at line 326)\n5. Second call also gets 401 and triggers refresh\n6. Both refresh operations compete, potentially invalidating each other's tokens\n\n**The Bug:**\n```javascript\n// credits.js:52-54\nif (response.status === 401 && typeof refreshAccessToken === 'function') {\n    debugLog('[Credits] Got 401, attempting token refresh...');\n    const refreshed = await refreshAccessToken();\n```\n\nNo locking mechanism prevents concurrent refresh attempts. If two `fetchCredits()` calls happen simultaneously (one from interval, one from user action), both will attempt to refresh tokens.\n\n**Fix Required:**\n```javascript\n// Add refresh lock at module level\nlet _refreshInProgress = false;\nlet _refreshPromise = null;\n\nasync function fetchCredits() {\n    // ... existing code ...\n    \n    if (response.status === 401 && typeof refreshAccessToken === 'function') {\n        debugLog('[Credits] Got 401, attempting token refresh...');\n        \n        // Wait for in-progress refresh instead of starting a new one\n        if (_refreshInProgress) {\n            debugLog('[Credits] Refresh already in progress, waiting...');\n            await _refreshPromise;\n            // Retry with hopefully-refreshed token\n            const retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n                method: 'GET',\n                headers: getAuthHeaders()\n            }, SPLICE_CONFIG.FETCH_TIMEOUT);\n            // ... handle retry response ...\n            return;\n        }\n        \n        _refreshInProgress = true;\n        _refreshPromise = refreshAccessToken();\n        const refreshed = await _refreshPromise;\n        _refreshInProgress = false;\n        _refreshPromise = null;\n        \n        // ... rest of existing code ...\n    }\n}\n```\n\n---\n\n#### **2. Nested Retry Loop Without Timeout (SEVERITY: HIGH)**\n**Location:** `credits.js:52-88`\n\n**Root Cause:** After token refresh, the code immediately retries the `/credits` request without respecting the original timeout. If the refresh succeeds but the backend is slow, this creates a blocking operation.\n\n**The Bug:**\n```javascript\n// credits.js:57-60\nconst retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    method: 'GET',\n    headers: getAuthHeaders()\n}, SPLICE_CONFIG.FETCH_TIMEOUT); // Uses full 120s timeout again!\n```\n\nIf the first request takes 115 seconds and times out, then token refresh takes 5 seconds, the retry will wait another 120 seconds. Total: 240 seconds of blocking.\n\n**Fix Required:**\nUse a reduced timeout for retry attempts:\n```javascript\nconst RETRY_TIMEOUT = 30000; // 30 seconds for retry\nconst retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    method: 'GET',\n    headers: getAuthHeaders()\n}, RETRY_TIMEOUT);\n```\n\n---\n\n#### **3. Interval Continues After Errors (SEVERITY: MEDIUM)**\n**Location:** `credits.js:326-329`\n\n**Root Cause:** The 5-minute refresh interval continues firing even after repeated failures, causing unnecessary network traffic and log spam.\n\n**The Bug:**\n```javascript\n// credits.js:326-329\ncreditsRefreshInterval = setInterval(async () => {\n    const refreshedCredits = await fetchCredits();\n    updateCreditDisplay(refreshedCredits);\n}, 5 * 60 * 1000);\n```\n\nIf the backend is down or the user is offline, this will fire every 5 minutes indefinitely, creating error logs and wasting resources.\n\n**Fix Required:**\n```javascript\nlet consecutiveFailures = 0;\nconst MAX_CONSECUTIVE_FAILURES = 3;\n\ncreditsRefreshInterval = setInterval(async () => {\n    const refreshedCredits = await fetchCredits();\n    \n    if (refreshedCredits && refreshedCredits._error) {\n        consecutiveFailures++;\n        if (consecutiveFailures >= MAX_CONSECUTIVE_FAILURES) {\n            debugLog('[Credits] Too many consecutive failures, pausing refresh');\n            clearInterval(creditsRefreshInterval);\n            creditsRefreshInterval = null;\n            // Show UI to manually retry\n            updateCreditDisplay({\n                _error: true,\n                message: 'Auto-refresh paused due to errors. Click to retry.'\n            });\n            return;\n        }\n    } else {\n        consecutiveFailures = 0;\n    }\n    \n    updateCreditDisplay(refreshedCredits);\n}, 5 * 60 * 1000);\n```\n\n---\n\n#### **4. Missing Abort Controller Cleanup (SEVERITY: MEDIUM)**\n**Location:** `credits.js:43-46`\n\n**Root Cause:** When using `fetchWithTimeout()`, if the component unmounts or the user triggers another fetch before the first completes, the old request continues in the background.\n\n**The Bug:**\n```javascript\n// credits.js:43-46\nconst response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    method: 'GET',\n    headers: getAuthHeaders()\n}, SPLICE_CONFIG.FETCH_TIMEOUT);\n```\n\nNo way to cancel in-flight requests. If user clicks refresh button rapidly, multiple requests pile up.\n\n**Fix Required:**\n```javascript\n// Add module-level abort controller\nlet _currentFetchController = null;\n\nasync function fetchCredits() {\n    // Cancel previous fetch if still running\n    if (_currentFetchController) {\n        _currentFetchController.abort();\n        debugLog('[Credits] Cancelled previous fetch');\n    }\n    \n    _currentFetchController = new AbortController();\n    \n    try {\n        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n            method: 'GET',\n            headers: getAuthHeaders(),\n            signal: _currentFetchController.signal // Add abort signal\n        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n        \n        // ... rest of code ...\n    } catch (err) {\n        if (err.name === 'AbortError') {\n            debugLog('[Credits] Fetch was cancelled');\n            return null;\n        }\n        // ... existing error handling ...\n    } finally {\n        _currentFetchController = null;\n    }\n}\n```\n\n---\n\n#### **5. State Update Race Condition (SEVERITY: MEDIUM)**\n**Location:** `credits.js:162, 239-280`\n\n**Root Cause:** `currentCredits` global variable can be updated by async operations in any order, leading to stale data display.\n\n**The Bug:**\n```javascript\n// credits.js:162\ncurrentCredits = credits;\n\n// If two fetchCredits() calls happen:\n// 1. Call A starts at t=0\n// 2. Call B starts at t=1\n// 3. Call B completes at t=5 → sets currentCredits to X\n// 4. Call A completes at t=10 → sets currentCredits to Y (stale!)\n```\n\nThe last fetch to complete wins, even if it started earlier and has stale data.\n\n**Fix Required:**\n```javascript\n// Add request versioning\nlet _fetchVersion = 0;\n\nasync function fetchCredits() {\n    const thisVersion = ++_fetchVersion;\n    \n    // ... fetch logic ...\n    \n    // Only update if this is still the latest fetch\n    if (thisVersion === _fetchVersion) {\n        currentCredits = credits;\n        updateCreditDisplay(credits);\n    } else {\n        debugLog('[Credits] Discarding stale fetch result');\n    }\n}\n```\n\n---\n\n#### **6. Exponential Backoff Implementation Error (SEVERITY: LOW)**\n**Location:** `credits.js:369-370`\n\n**Root Cause:** The exponential backoff only applies to the `retryFetchCredits()` function, not the automatic 401 retry in `fetchCredits()`.\n\n**The Bug:**\n```javascript\n// credits.js:52-88 - No backoff before retry\nif (refreshed) {\n    // Immediately retries without any delay\n    const retryResponse = await fetchWithTimeout(...)\n}\n\n// vs\n\n// credits.js:369-370 - Has backoff\nconst delay = Math.pow(2, creditsRetryCount - 1) * 1000;\nawait new Promise(resolve => setTimeout(resolve, delay));\n```\n\nInconsistent retry behavior can cause backend hammering.\n\n**Fix Required:**\nApply consistent backoff across all retry paths.\n\n---\n\n### **MEDIUM ISSUES**\n\n#### **7. Missing CSRF Token Handling (SEVERITY: MEDIUM)**\n**Location:** `credits.js:43-46`\n\n**The Bug:**\nAccording to `CLAUDE.md`, CSRF tokens are required for state-changing endpoints. While `/credits` is a GET request, if the backend enforces CSRF on all authenticated routes, this will fail.\n\n```javascript\nheaders: getAuthHeaders() // Missing CSRF token\n```\n\n**Fix Required:**\nCheck if CSRF is required for GET requests in production. If yes, add token:\n```javascript\nconst headers = getAuthHeaders();\nconst csrfToken = getCsrfToken(); // From config.js or separate module\nif (csrfToken) {\n    headers['X-CSRF-Token'] = csrfToken;\n}\n```\n\n---\n\n#### **8. Polling Frequency Too Aggressive (SEVERITY: LOW)**\n**Location:** `credits.js:325-329`\n\n**The Bug:**\n5-minute polling is too frequent for credit balance, which changes slowly. This creates unnecessary load on the backend.\n\n```javascript\n}, 5 * 60 * 1000); // Every 5 minutes\n```\n\n**Fix Required:**\nIncrease to 15-30 minutes unless user action triggers manual refresh:\n```javascript\n}, 15 * 60 * 1000); // Every 15 minutes\n```\n\n---\n\n### **ERROR HANDLING GAPS**\n\n#### **9. Generic Error Messages (SEVERITY: LOW)**\n**Location:** `credits.js:116-117`\n\n**The Bug:**\nError messages don't differentiate between network errors, server errors, and client errors.\n\n```javascript\nlastCreditsError = err.message || 'Connection failed';\n```\n\n**Fix Required:**\n```javascript\nif (err.name === 'AbortError') {\n    lastCreditsError = 'Request cancelled';\n} else if (err.message?.includes('timeout')) {\n    lastCreditsError = 'Request timed out - server may be slow';\n} else if (err.message?.includes('Failed to fetch')) {\n    lastCreditsError = 'Cannot reach server - check connection';\n} else {\n    lastCreditsError = err.message || 'Unknown error';\n}\n```\n\n---\n\n#### **10. Silent Failure on ensureValidToken (SEVERITY: MEDIUM)**\n**Location:** `credits.js:35-41`\n\n**The Bug:**\nIf `ensureValidToken()` fails, the code logs but continues with potentially invalid credentials.\n\n```javascript\nif (!hasValidToken && !settings.accessToken) {\n    // No JWT token - will fall back to legacy auth in getAuthHeaders()\n    debugLog('[Credits] No JWT token, using legacy auth');\n}\n```\n\nShould explicitly handle the case where legacy auth is also unavailable.\n\n**Fix Required:**\n```javascript\nif (!hasValidToken && !settings.accessToken) {\n    if (!settings.customerId) {\n        // No auth at all - don't make request\n        return { _error: true, message: 'Not logged in' };\n    }\n    debugLog('[Credits] No JWT token, using legacy auth');\n}\n```\n\n---\n\n## Regression Test Suite\n\n```javascript\n// Test 1: Concurrent fetch calls don't cause double-refresh\ntest('should handle concurrent fetchCredits without double-refresh', async () => {\n    const promise1 = fetchCredits();\n    const promise2 = fetchCredits();\n    \n    const [result1, result2] = await Promise.all([promise1, promise2]);\n    \n    expect(refreshAccessToken).toHaveBeenCalledTimes(1); // Not 2!\n});\n\n// Test 2: Stale results are discarded\ntest('should discard stale fetch results', async () => {\n    const slow = fetchCredits(); // Takes 10s\n    await delay(100);\n    const fast = fetchCredits(); // Takes 1s\n    \n    await Promise.all([slow, fast]);\n    \n    expect(currentCredits).toEqual(fastResult); // Not slowResult!\n});\n\n// Test 3: Interval stops after consecutive failures\ntest('should stop interval after 3 consecutive failures', async () => {\n    mockFetch.mockRejectedValue(new Error('Network error'));\n    \n    initCredits();\n    \n    // Simulate 3 interval ticks\n    for (let i = 0; i < 3; i++) {\n        await advanceTimersByTime(5 * 60 * 1000);\n    }\n    \n    expect(creditsRefreshInterval).toBeNull();\n});\n\n// Test 4: Abort previous fetch on new fetch\ntest('should abort previous fetch when new fetch starts', async () => {\n    const controller = new AbortController();\n    const promise1 = fetchCredits();\n    const promise2 = fetchCredits();\n    \n    expect(controller.signal.aborted).toBe(true);\n});\n\n// Test 5: Retry uses reduced timeout\ntest('should use reduced timeout for retry after token refresh', async () => {\n    mockFetch.mockResolvedValueOnce({ ok: false, status: 401 });\n    mockFetch.mockResolvedValueOnce({ ok: true, json: async () => ({ hoursRemaining: 5 }) });\n    \n    await fetchCredits();\n    \n    expect(fetchWithTimeout).toHaveBeenLastCalledWith(\n        expect.any(String),\n        expect.any(Object),\n        30000 // Not 120000!\n    );\n});\n```\n\n---\n\n## Prevention Strategy\n\n### **Invariants to Add**\n1. **Single Refresh Lock:** Only one token refresh can run at a time across all modules\n2. **Fetch Versioning:** Discard results from stale fetches\n3. **Circuit Breaker:** Auto-pause intervals after consecutive failures\n4. **Timeout Budget:** Track cumulative timeout across retry chain\n\n### **Monitoring to Add**\n```javascript\n// Add performance tracking\nconst perfStart = performance.now();\nconst credits = await fetchCredits();\nconst duration = performance.now() - perfStart;\n\nif (duration > 10000) {\n    console.warn(`[Credits] Slow fetch: ${duration}ms`);\n    // Send to analytics/monitoring\n}\n```\n\n### **Type Guards Needed**\n```typescript\ninterface CreditsResponse {\n    _error?: boolean;\n    message?: string;\n    hoursRemaining?: number;\n    // ... other fields\n}\n\nfunction isErrorResponse(data: unknown): data is { _error: true; message: string } {\n    return typeof data === 'object' && data !== null && '_error' in data && data._error === true;\n}\n```\n\n---\n\n## Summary Table\n\n| Issue | Severity | Line(s) | Impact | Fix Complexity |\n|-------|----------|---------|--------|----------------|\n| Token refresh race condition | **HIGH** | 52-88 | Auth failures, token invalidation | Medium |\n| Nested retry without timeout | **HIGH** | 57-60 | 240s blocking, poor UX | Low |\n| Interval continues after errors | **MEDIUM** | 326-329 | Network spam, log pollution | Low |\n| Missing abort controller | **MEDIUM** | 43-46 | Memory leaks, duplicate requests | Medium |\n| State update race condition | **MEDIUM** | 162, 239-280 | Stale data display | Medium |\n| Exponential backoff inconsistency | **LOW** | 52-88, 369-370 | Backend hammering | Low |\n| Missing CSRF token | **MEDIUM** | 43-46 | Auth failures if enforced | Low |\n| Polling too frequent | **LOW** | 325-329 | Unnecessary backend load | Trivial |\n| Generic error messages | **LOW** | 116-117 | Poor UX | Low |\n| Silent ensureValidToken failure | **MEDIUM** | 35-41 | Requests with invalid auth | Low |\n\n**Total Critical Path Issues:** 5 high/medium severity bugs that will cause production failures under load."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":20510,"cache_read_input_tokens":36617,"cache_creation":{"ephemeral_5m_input_tokens":20510,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3o8KYPaSb3XBQipY19b","type":"assistant","uuid":"4366b73e-e266-4bbd-97ae-d6ec57a816aa","timestamp":"2026-01-12T16:26:59.678Z"}
