     1→/**
     2→ * SPLICE CEP Credits Display Module
     3→ *
     4→ * Fetches and displays user's remaining hours from the billing backend.
     5→ * Port of UXP credits.js for CEP compatibility.
     6→ */
     7→
     8→// Track fetch error state for retry UI
     9→let lastCreditsError = null;
    10→let creditsRetryCount = 0;
    11→const MAX_CREDITS_RETRIES = 3;
    12→
    13→// Store current credits globally for access checks
    14→let currentCredits = null;
    15→
    16→// Store interval reference for cleanup
    17→let creditsRefreshInterval = null;
    18→
    19→/**
    20→ * Fetch user's credit balance from backend
    21→ * @returns {Promise<Object | null>} Credit data including isolation hours, or error object
    22→ */
    23→async function fetchCredits() {
    24→    const settings = getSettings();
    25→    const customerId = settings.customerId;
    26→
    27→    if (!customerId) {
    28→        console.log('[SPLICE] No customerId configured - credits display disabled');
    29→        lastCreditsError = null;
    30→        return null;
    31→    }
    32→
    33→    try {
    34→        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {
    35→            method: 'GET',
    36→            headers: {
    37→                'x-stripe-customer-id': customerId
    38→            }
    39→        }, SPLICE_CONFIG.FETCH_TIMEOUT);
    40→
    41→        if (!response.ok) {
    42→            const errorMsg = await parseErrorResponse(response);
    43→            console.error('[SPLICE] Credits fetch failed:', errorMsg);
    44→            lastCreditsError = errorMsg;
    45→            return { _error: true, message: errorMsg };
    46→        }
    47→
    48→        const data = await response.json();
    49→        lastCreditsError = null;
    50→        creditsRetryCount = 0;
    51→        return {
    52→            hoursRemaining: data.hoursRemaining || 0,
    53→            hoursTotal: data.hoursTotal || 0,
    54→            tierName: data.tierName || 'Free',
    55→            tier: data.tier || 'starter',
    56→            // Isolation hours
    57→            isolationHoursRemaining: data.isolationHoursRemaining || 0,
    58→            isolationHoursTotal: data.isolationHoursTotal || 0,
    59→            hasIsolationAccess: data.hasIsolationAccess || false,
    60→            isolationOverageRate: data.isolationOverageRate || 0.08,
    61→            // Feature access
    62→            featureAccess: data.featureAccess || [],
    63→            // Trial info
    64→            trialDaysRemaining: data.trialDaysRemaining || null,
    65→            isOnTrial: data.isOnTrial || false
    66→        };
    67→    } catch (err) {
    68→        console.error('[SPLICE] Credits fetch error:', err);
    69→        lastCreditsError = err.message || 'Connection failed';
    70→        return { _error: true, message: lastCreditsError };
    71→    }
    72→}
    73→
    74→/**
    75→ * Clear the credits cache (call on logout)
    76→ */
    77→function clearCreditsCache() {
    78→    currentCredits = null;
    79→    lastCreditsError = null;
    80→    creditsRetryCount = 0;
    81→    console.log('[SPLICE] Credits cache cleared');
    82→}
    83→
    84→/**
    85→ * Update the credit display in the UI
    86→ * @param {Object|null} credits - Credit data, error object, or null if unavailable
    87→ */
    88→function updateCreditDisplay(credits) {
    89→    const creditBadge = document.getElementById('creditBadge');
    90→    if (!creditBadge) return;
    91→
    92→    // Handle no customer ID configured
    93→    if (!credits) {
    94→        currentCredits = null;
    95→        creditBadge.style.display = 'flex';
    96→        creditBadge.textContent = 'Login';
    97→        creditBadge.title = 'Click to enter license key';
    98→        creditBadge.classList.remove('ok', 'low');
    99→        creditBadge.classList.add('login');
   100→        return;
   101→    }
   102→
   103→    // Handle error state - show error badge with retry
   104→    if (credits._error) {
   105→        currentCredits = null;
   106→        creditBadge.style.display = 'flex';
   107→        creditBadge.textContent = 'Retry';
   108→        creditBadge.title = `Error: ${credits.message}\nClick to retry`;
   109→        creditBadge.classList.remove('ok', 'low', 'login');
   110→        creditBadge.classList.add('error');
   111→        return;
   112→    }
   113→
   114→    // Normal credit display
   115→    currentCredits = credits;
   116→    creditBadge.style.display = 'flex';
   117→
   118→    // Show referral promo when logged in
   119→    const referralPromo = document.getElementById('referralPromo');
   120→    if (referralPromo) {
   121→        referralPromo.classList.remove('hidden');
   122→    }
   123→
   124→    // Show trial status if on trial
   125→    if (credits.isOnTrial && credits.trialDaysRemaining) {
   126→        creditBadge.textContent = `Trial: ${credits.trialDaysRemaining}d`;
   127→        creditBadge.classList.remove('error', 'login', 'ok', 'low');
   128→        creditBadge.classList.add('trial');
   129→    } else {
   130→        creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;
   131→        creditBadge.classList.remove('error', 'login', 'trial');
   132→    }
   133→
   134→    // Build tooltip with isolation info if available
   135→    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;
   136→    if (credits.isOnTrial && credits.trialDaysRemaining) {
   137→        tooltip = `Trial: ${credits.trialDaysRemaining} days remaining\n` + tooltip;
   138→    }
   139→    if (credits.hasIsolationAccess) {
   140→        tooltip += `\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;
   141→    }
   142→    creditBadge.title = tooltip;
   143→
   144→    // Color based on remaining hours
   145→    if (credits.hoursRemaining <= 1) {
   146→        creditBadge.classList.add('low');
   147→        creditBadge.classList.remove('ok');
   148→    } else {
   149→        creditBadge.classList.add('ok');
   150→        creditBadge.classList.remove('low');
   151→    }
   152→
   153→    // Update isolation checkbox state based on tier access
   154→    updateIsolationCheckboxState(credits);
   155→}
   156→
   157→/**
   158→ * Update the isolation checkbox based on tier access
   159→ */
   160→function updateIsolationCheckboxState(credits) {
   161→    const isolatedCheckbox = document.getElementById('sourceIsolated');
   162→    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');
   163→
   164→    if (!isolatedCheckbox) return;
   165→
   166→    if (!credits || !credits.hasIsolationAccess) {
   167→        // Disable isolation for non-Pro/Team users
   168→        isolatedCheckbox.disabled = true;
   169→        isolatedCheckbox.checked = false;
   170→        if (tierBadge) {
   171→            tierBadge.textContent = 'Pro+';
   172→            tierBadge.style.opacity = '1';
   173→        }
   174→    } else {
   175→        // Enable isolation for Pro/Team users
   176→        isolatedCheckbox.disabled = false;
   177→        if (tierBadge) {
   178→            // Show remaining isolation time
   179→            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);
   180→            tierBadge.textContent = `${minsRemaining} min`;
   181→            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';
   182→        }
   183→    }
   184→}
   185→
   186→/**
   187→ * Check if user can use isolation and get cost estimate
   188→ * @param {number} estimatedMinutes - Estimated audio duration in minutes
   189→ * @returns {Object} Access info with allowed, message, overageCost
   190→ */
   191→function checkIsolationAccess(estimatedMinutes = 0) {
   192→    if (!currentCredits) {
   193→        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };
   194→    }
   195→
   196→    if (!currentCredits.hasIsolationAccess) {
   197→        return {
   198→            allowed: false,
   199→            message: 'Vocal isolation requires Pro or Team tier',
   200→            upgradeRequired: true,
   201→            overageCost: 0
   202→        };
   203→    }
   204→
   205→    const estimatedHours = estimatedMinutes / 60;
   206→    const remaining = currentCredits.isolationHoursRemaining;
   207→
   208→    if (remaining >= estimatedHours) {
   209→        return {
   210→            allowed: true,
   211→            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,
   212→            overageCost: 0
   213→        };
   214→    }
   215→
   216→    // Calculate overage
   217→    const overageMinutes = estimatedMinutes - (remaining * 60);
   218→    const overageCost = overageMinutes * currentCredits.isolationOverageRate;
   219→
   220→    return {
   221→        allowed: true,
   222→        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,
   223→        overageCost,
   224→        overageMinutes
   225→    };
   226→}
   227→
   228→/**
   229→ * Get current credits (for access checks)
   230→ */
   231→function getCurrentCredits() {
   232→    return currentCredits;
   233→}
   234→
   235→/**
   236→ * Check if user has access to a specific feature based on their tier
   237→ * @param {string} featureName - The feature to check (e.g., 'social_reframe', 'text_editing', 'multitrack')
   238→ * @returns {boolean} - True if user has access
   239→ */
   240→function hasFeatureAccess(featureName) {
   241→    if (!currentCredits || !currentCredits.featureAccess) {
   242→        return false; // Not logged in = no premium features
   243→    }
   244→    return currentCredits.featureAccess.includes(featureName);
   245→}
   246→
   247→/**
   248→ * Get the required tier for a feature
   249→ * @param {string} featureName - The feature name
   250→ * @returns {string} - Required tier name
   251→ */
   252→function getRequiredTier(featureName) {
   253→    const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];
   254→    const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];
   255→
   256→    if (teamOnlyFeatures.includes(featureName)) {
   257→        return 'Team';
   258→    } else if (proFeatures.includes(featureName)) {
   259→        return 'Pro';
   260→    }
   261→    return 'Starter';
   262→}
   263→
   264→/**
   265→ * Initialize credits display
   266→ * Fetches credits on load and sets up periodic refresh
   267→ */
   268→async function initCredits() {
   269→    // Clear any existing interval to prevent duplicates
   270→    if (creditsRefreshInterval) {
   271→        clearInterval(creditsRefreshInterval);
   272→    }
   273→
   274→    // Initial fetch
   275→    const credits = await fetchCredits();
   276→    updateCreditDisplay(credits);
   277→
   278→    // Refresh credits every 5 minutes
   279→    creditsRefreshInterval = setInterval(async () => {
   280→        const refreshedCredits = await fetchCredits();
   281→        updateCreditDisplay(refreshedCredits);
   282→    }, 5 * 60 * 1000);
   283→}
   284→
   285→/**
   286→ * Cleanup credits module - call on plugin unload
   287→ */
   288→function cleanupCredits() {
   289→    if (creditsRefreshInterval) {
   290→        clearInterval(creditsRefreshInterval);
   291→        creditsRefreshInterval = null;
   292→    }
   293→}
   294→
   295→/**
   296→ * Manually refresh credits (e.g., after a processing operation)
   297→ */
   298→async function refreshCredits() {
   299→    const credits = await fetchCredits();
   300→    updateCreditDisplay(credits);
   301→    return credits;
   302→}
   303→
   304→/**
   305→ * Retry fetching credits with exponential backoff
   306→ * Called when user clicks the "Retry" badge
   307→ */
   308→async function retryFetchCredits() {
   309→    if (creditsRetryCount >= MAX_CREDITS_RETRIES) {
   310→        console.warn('[SPLICE] Max retry attempts reached for credits fetch');
   311→        updateCreditDisplay({
   312→            _error: true,
   313→            message: 'Max retries exceeded. Check your connection and try again later.'
   314→        });
   315→        creditsRetryCount = 0; // Reset for next attempt
   316→        return null;
   317→    }
   318→
   319→    creditsRetryCount++;
   320→    console.log(`[SPLICE] Retrying credits fetch (attempt ${creditsRetryCount}/${MAX_CREDITS_RETRIES})`);
   321→
   322→    // Exponential backoff: 1s, 2s, 4s
   323→    const delay = Math.pow(2, creditsRetryCount - 1) * 1000;
   324→
   325→    // Show retrying state
   326→    const creditBadge = document.getElementById('creditBadge');
   327→    if (creditBadge) {
   328→        creditBadge.textContent = `Retry ${creditsRetryCount}...`;
   329→        creditBadge.classList.add('retrying');
   330→    }
   331→
   332→    await new Promise(resolve => setTimeout(resolve, delay));
   333→
   334→    const credits = await fetchCredits();
   335→
   336→    if (creditBadge) {
   337→        creditBadge.classList.remove('retrying');
   338→    }
   339→
   340→    updateCreditDisplay(credits);
   341→    return credits;
   342→}
   343→
   344→/**
   345→ * Handle click on credit badge
   346→ * - If error state: retry fetching
   347→ * - If login state: open login modal
   348→ * - Otherwise: refresh credits
   349→ */
   350→function handleCreditBadgeClick() {
   351→    const creditBadge = document.getElementById('creditBadge');
   352→    if (!creditBadge) return;
   353→
   354→    if (creditBadge.classList.contains('error')) {
   355→        retryFetchCredits();
   356→    } else if (creditBadge.classList.contains('login')) {
   357→        // Open login modal (handled in main.js)
   358→        const loginModal = document.getElementById('loginModal');
   359→        if (loginModal) {
   360→            loginModal.classList.remove('hidden');
   361→        }
   362→    } else {
   363→        // Normal state - just refresh
   364→        refreshCredits();
   365→    }
   366→}
   367→
   368→// Export for window access
   369→window.fetchCredits = fetchCredits;
   370→window.clearCreditsCache = clearCreditsCache;
   371→window.updateCreditDisplay = updateCreditDisplay;
   372→window.checkIsolationAccess = checkIsolationAccess;
   373→window.getCurrentCredits = getCurrentCredits;
   374→window.hasFeatureAccess = hasFeatureAccess;
   375→window.getRequiredTier = getRequiredTier;
   376→window.initCredits = initCredits;
   377→window.cleanupCredits = cleanupCredits;
   378→window.refreshCredits = refreshCredits;
   379→window.retryFetchCredits = retryFetchCredits;
   380→window.handleCreditBadgeClick = handleCreditBadgeClick;
   381→
   382→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
