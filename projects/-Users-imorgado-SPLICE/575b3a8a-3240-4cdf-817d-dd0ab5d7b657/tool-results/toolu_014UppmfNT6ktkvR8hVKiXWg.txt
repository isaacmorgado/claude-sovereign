     1→/**
     2→ * SPLICE Backend Server
     3→ *
     4→ * Main entry point for the SPLICE backend API.
     5→ * Orchestrates the audio analysis pipeline.
     6→ *
     7→ * Slices:
     8→ * - Slice 4: Transcription (services/transcription.js)
     9→ * - Slice 5: Take Detection (services/takeDetection.js)
    10→ *
    11→ * Architecture: Modular routes (see routes/ directory)
    12→ */
    13→
    14→
    15→require('dotenv').config();
    16→
    17→const express = require('express');
    18→const cors = require('cors');
    19→const helmet = require('helmet');
    20→const fs = require('fs');
    21→const https = require('https');
    22→const http = require('http');
    23→const path = require('path');
    24→const crypto = require('crypto');
    25→
    26→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)
    27→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;
    28→
    29→// Import services
    30→const usageTracking = require('./services/usageTracking');
    31→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');
    32→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData } = require('./middleware/auth');
    33→const referralService = require('./services/referralService');
    34→const licenseService = require('./services/licenseService');
    35→const emailService = require('./services/emailService');
    36→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');
    37→const { getSupportedFormats } = require('./services/captionExporter');
    38→
    39→// Import route modules
    40→const healthRoutes = require('./routes/health');
    41→const analyzeRoutes = require('./routes/analyze');
    42→const silencesRoutes = require('./routes/silences');
    43→const detectionRoutes = require('./routes/detection');
    44→const exportRoutes = require('./routes/export');
    45→const multitrackRoutes = require('./routes/multitrack');
    46→const cutListRoutes = require('./routes/cutList');
    47→const zoomRoutes = require('./routes/zoom');
    48→const chaptersRoutes = require('./routes/chapters');
    49→const youtubeRoutes = require('./routes/youtube');
    50→const captionsRoutes = require('./routes/captions');
    51→const textEditRoutes = require('./routes/textEdit');
    52→const reframeRoutes = require('./routes/reframe');
    53→const batchRoutes = require('./routes/batch');
    54→const authRoutes = require('./routes/auth');
    55→const billingRoutes = require('./routes/billing');
    56→const referralRoutes = require('./routes/referral');
    57→const licenseRoutes = require('./routes/license');
    58→const musicRoutes = require('./routes/music');
    59→
    60→// Stripe for webhooks
    61→const Stripe = require('stripe');
    62→
    63→// Validate STRIPE_SECRET_KEY in production - exit if missing
    64→if (isProduction && !process.env.STRIPE_SECRET_KEY) {
    65→  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');
    66→  process.exit(1);
    67→}
    68→
    69→// Validate JWT_SECRET in production - exit if using default
    70→if (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {
    71→  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');
    72→  process.exit(1);
    73→}
    74→
    75→// Validate DATABASE_URL in production
    76→if (isProduction && !process.env.DATABASE_URL) {
    77→  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');
    78→  process.exit(1);
    79→}
    80→
    81→// Validate OPENAI_API_KEY in production
    82→if (isProduction && !process.env.OPENAI_API_KEY) {
    83→  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');
    84→  process.exit(1);
    85→}
    86→
    87→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
    88→
    89→// =============================================================================
    90→// PERF-FIX: Static Response Cache
    91→// Cache static endpoint responses at startup to avoid repeated computation
    92→// =============================================================================
    93→
    94→// Generate ETag from content
    95→function generateETag(content) {
    96→  return `"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}"`;
    97→}
    98→
    99→// Static response cache - populated at startup
   100→const STATIC_RESPONSE_CACHE = {
   101→  profanityLanguages: null,
   102→  profanityBleeps: null,
   103→  exportFormats: null
   104→};
   105→
   106→// Initialize cache at startup (called after server starts)
   107→function initializeStaticCache() {
   108→  // Cache profanity languages
   109→  const languages = getSupportedLanguages();
   110→  STATIC_RESPONSE_CACHE.profanityLanguages = {
   111→    body: { success: true, languages },
   112→    etag: generateETag({ languages })
   113→  };
   114→
   115→  // Cache profanity bleeps
   116→  const sounds = getAvailableBleepSounds();
   117→  STATIC_RESPONSE_CACHE.profanityBleeps = {
   118→    body: { success: true, sounds },
   119→    etag: generateETag({ sounds })
   120→  };
   121→
   122→  // Cache export formats
   123→  const formats = getSupportedFormats();
   124→  STATIC_RESPONSE_CACHE.exportFormats = {
   125→    body: { success: true, formats },
   126→    etag: generateETag({ formats })
   127→  };
   128→
   129→  console.log('[SPLICE] Static response cache initialized');
   130→}
   131→
   132→// Helper to send cached response with ETag
   133→function sendCachedResponse(req, res, cacheKey) {
   134→  const cached = STATIC_RESPONSE_CACHE[cacheKey];
   135→  if (!cached) {
   136→    return res.status(500).json({ error: 'Cache not initialized' });
   137→  }
   138→
   139→  // Check If-None-Match header for conditional GET
   140→  const clientETag = req.headers['if-none-match'];
   141→  if (clientETag === cached.etag) {
   142→    return res.status(304).end(); // Not Modified
   143→  }
   144→
   145→  // Send cached response with ETag and cache headers
   146→  res.set('ETag', cached.etag);
   147→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours
   148→  res.json(cached.body);
   149→}
   150→
   151→// =============================================================================
   152→// Server Configuration
   153→// =============================================================================
   154→
   155→const app = express();
   156→const PORT = process.env.PORT || 3847;
   157→
   158→// HTTPS certificates (generated by mkcert) - only for local development
   159→let httpsOptions = null;
   160→if (!isProduction) {
   161→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');
   162→  const certPath = path.join(__dirname, 'localhost+1.pem');
   163→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
   164→    httpsOptions = {
   165→      key: fs.readFileSync(keyPath),
   166→      cert: fs.readFileSync(certPath)
   167→    };
   168→  }
   169→}
   170→
   171→// =============================================================================
   172→// Security Configuration
   173→// =============================================================================
   174→
   175→// CORS whitelist - restrict origins in production
   176→const CORS_WHITELIST = [
   177→  'http://localhost:3000',
   178→  'http://localhost:3847',
   179→  'https://localhost:3847',
   180→  'http://127.0.0.1:3000',
   181→  'http://127.0.0.1:3847',
   182→  'https://127.0.0.1:3847',
   183→  'https://splice.app',
   184→  'https://www.splice.app',
   185→  'https://splice-api-production.up.railway.app',
   186→  'https://splice-website.vercel.app',
   187→  // Adobe CEP/UXP panels run from file:// or bolt://
   188→  'file://',
   189→  'bolt://'
   190→];
   191→
   192→const corsOptions = {
   193→  origin: function (origin, callback) {
   194→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)
   195→    if (!origin) {
   196→      return callback(null, true);
   197→    }
   198→    // Check if origin is in whitelist
   199→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {
   200→      return callback(null, true);
   201→    }
   202→    // In development, allow all origins with warning
   203→    if (!isProduction) {
   204→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);
   205→      return callback(null, true);
   206→    }
   207→    // In production, reject non-whitelisted origins
   208→    console.error(`[CORS] Blocked request from: ${origin}`);
   209→    return callback(new Error('Not allowed by CORS'));
   210→  },
   211→  credentials: true,
   212→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
   213→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature']
   214→};
   215→
   216→app.use(cors(corsOptions));
   217→
   218→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers
   219→// This ensures rate limiting and logging use the correct client IP
   220→if (isProduction) {
   221→  app.set('trust proxy', 1);
   222→}
   223→
   224→// IP-based rate limiting (100 requests/minute per IP)
   225→app.use(ipRateLimit);
   226→
   227→// Security headers via helmet
   228→app.use(helmet({
   229→  contentSecurityPolicy: {
   230→    directives: {
   231→      defaultSrc: ["'self'"],
   232→      scriptSrc: ["'self'"],
   233→      styleSrc: ["'self'", "'unsafe-inline'"],
   234→      imgSrc: ["'self'", 'data:', 'https:'],
   235→      connectSrc: ["'self'", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],
   236→      fontSrc: ["'self'"],
   237→      objectSrc: ["'none'"],
   238→      mediaSrc: ["'self'"],
   239→      frameSrc: ["'none'"]
   240→    }
   241→  },
   242→  hsts: {
   243→    maxAge: 31536000,
   244→    includeSubDomains: true,
   245→    preload: true
   246→  },
   247→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
   248→  noSniff: true,
   249→  xssFilter: true,
   250→  hidePoweredBy: true
   251→}));
   252→
   253→// Helper to determine tier from price ID with logging
   254→// Supports both monthly and annual pricing
   255→function getTierFromPriceId(priceId) {
   256→  // Monthly prices
   257→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';
   258→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';
   259→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';
   260→
   261→  // Annual prices (same tier, just different billing period)
   262→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';
   263→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';
   264→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';
   265→
   266→  // Log unknown price ID for debugging
   267→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);
   268→  return 'starter';
   269→}
   270→
   271→// =============================================================================
   272→// Stripe Webhook (must be before express.json())
   273→// =============================================================================
   274→
   275→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
   276→  const sig = req.headers['stripe-signature'];
   277→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
   278→
   279→  let event;
   280→
   281→  try {
   282→    if (webhookSecret) {
   283→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
   284→    } else if (isProduction) {
   285→      // SECURITY: Reject unsigned webhooks in production
   286→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');
   287→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });
   288→    } else {
   289→      // For local development testing only
   290→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse
   291→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');
   292→      event = JSON.parse(bodyString);
   293→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');
   294→    }
   295→  } catch (err) {
   296→    console.error('[SPLICE] Webhook signature verification failed:', err.message);
   297→    return res.status(400).json({ error: 'Webhook signature verification failed' });
   298→  }
   299→
   300→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);
   301→
   302→  // Idempotency check - skip if already processed
   303→  if (await usageTracking.isEventProcessed(event.id)) {
   304→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);
   305→    return res.json({ received: true, skipped: true });
   306→  }
   307→
   308→  try {
   309→    switch (event.type) {
   310→      case 'customer.subscription.created':
   311→      case 'customer.subscription.updated': {
   312→        const subscription = event.data.object;
   313→        const customerId = subscription.customer;
   314→
   315→        // Validate customerId
   316→        if (!customerId) {
   317→          console.error('[SPLICE] Missing customer ID in subscription event');
   318→          return res.status(400).json({ error: 'Missing customer ID' });
   319→        }
   320→
   321→        // Get tier from price ID
   322→        const priceId = subscription.items?.data?.[0]?.price?.id;
   323→        const tier = getTierFromPriceId(priceId);
   324→
   325→        // Update user tier and reset hours
   326→        await usageTracking.updateTier(customerId, tier);
   327→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);
   328→
   329→        // Initialize music credits for new subscriptions
   330→        if (event.type === 'customer.subscription.created') {
   331→          await usageTracking.resetMusicCredits(customerId, tier);
   332→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);
   333→        }
   334→
   335→        // Update trial end date if present
   336→        if (subscription.trial_end) {
   337→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);
   338→        }
   339→
   340→        // Generate license key for new subscriptions with retry and delivery
   341→        if (event.type === 'customer.subscription.created') {
   342→          let licenseResult = null;
   343→          let retryCount = 0;
   344→          const maxRetries = 3;
   345→
   346→          // Retry mechanism for license key generation
   347→          while (retryCount < maxRetries) {
   348→            licenseResult = await licenseService.generateLicenseKey(customerId);
   349→            if (licenseResult.success) {
   350→              break;
   351→            }
   352→            retryCount++;
   353→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);
   354→            // Wait before retry (exponential backoff)
   355→            if (retryCount < maxRetries) {
   356→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
   357→            }
   358→          }
   359→
   360→          if (licenseResult && licenseResult.success) {
   361→            // SECURITY: Mask license key in logs
   362→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);
   363→
   364→            // Store license key in Stripe subscription metadata as backup
   365→            try {
   366→              await stripe.subscriptions.update(subscription.id, {
   367→                metadata: {
   368→                  license_key: licenseResult.key,
   369→                  license_generated_at: new Date().toISOString()
   370→                }
   371→              });
   372→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);
   373→            } catch (stripeErr) {
   374→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);
   375→            }
   376→
   377→            // Get customer email and send license key
   378→            try {
   379→              const customer = await stripe.customers.retrieve(customerId);
   380→              if (customer.email) {
   381→                // SECURITY: Mask sensitive data in logs
   382→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);
   383→
   384→                // Send license key email
   385→                try {
   386→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);
   387→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);
   388→                } catch (sendErr) {
   389→                  // Log but don't fail - license is stored in Stripe metadata as backup
   390→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);
   391→                }
   392→
   393→                // Store email in database for reference
   394→                await usageTracking.updateTier(customerId, tier, customer.email);
   395→              } else {
   396→                console.warn(`[SPLICE] No email found for customer ${customerId}`);
   397→              }
   398→            } catch (emailErr) {
   399→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);
   400→            }
   401→          } else {
   402→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry
   403→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;
   404→            console.error(`[SPLICE] ${errorMsg}`);
   405→            return res.status(500).json({ error: errorMsg });
   406→          }
   407→        }
   408→        break;
   409→      }
   410→
   411→      case 'customer.subscription.deleted': {
   412→        const subscription = event.data.object;
   413→        const customerId = subscription.customer;
   414→
   415→        // Validate customerId
   416→        if (!customerId) {
   417→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');
   418→          return res.status(400).json({ error: 'Missing customer ID' });
   419→        }
   420→
   421→        // Downgrade to cancelled (0 hours)
   422→        await usageTracking.updateTier(customerId, 'cancelled');
   423→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);
   424→        break;
   425→      }
   426→
   427→      case 'invoice.payment_succeeded': {
   428→        const invoice = event.data.object;
   429→        const customerId = invoice.customer;
   430→        const subscriptionId = invoice.subscription;
   431→
   432→        // Validate customerId
   433→        if (!customerId) {
   434→          console.error('[SPLICE] Missing customer ID in invoice event');
   435→          return res.status(400).json({ error: 'Missing customer ID' });
   436→        }
   437→
   438→        // Reset hours on successful payment (new billing period)
   439→        let tier = 'starter';
   440→        if (subscriptionId) {
   441→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);
   442→          const priceId = subscription.items?.data?.[0]?.price?.id;
   443→          tier = getTierFromPriceId(priceId);
   444→
   445→          await usageTracking.resetHours(customerId, tier);
   446→          await usageTracking.resetMusicCredits(customerId, tier);
   447→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);
   448→        }
   449→
   450→        // Check for affiliate coupon and record commission
   451→        const discount = invoice.discount;
   452→        if (discount && discount.coupon) {
   453→          const couponId = discount.coupon.id;
   454→          // Check if this is an affiliate code (like JIMMYN)
   455→          if (referralService.AFFILIATE_CODES[couponId]) {
   456→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars
   457→            await referralService.recordAffiliateCommission(
   458→              couponId,
   459→              customerId,
   460→              amountPaid,
   461→              tier
   462→            );
   463→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);
   464→          }
   465→        }
   466→        break;
   467→      }
   468→
   469→      case 'invoice.payment_failed': {
   470→        const invoice = event.data.object;
   471→        const customerId = invoice.customer;
   472→        const attemptCount = invoice.attempt_count || 1;
   473→
   474→        // Validate customerId
   475→        if (!customerId) {
   476→          console.error('[SPLICE] Missing customer ID in payment_failed event');
   477→          return res.status(400).json({ error: 'Missing customer ID' });
   478→        }
   479→
   480→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);
   481→
   482→        // Stripe will retry automatically per retry settings
   483→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted
   484→        // Send warning email on final attempt
   485→        if (attemptCount >= 3) {
   486→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);
   487→          // Send warning email to customer about impending cancellation
   488→          try {
   489→            const customer = await stripe.customers.retrieve(customerId);
   490→            if (customer.email) {
   491→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);
   492→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);
   493→            }
   494→          } catch (emailErr) {
   495→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);
   496→          }
   497→        }
   498→        break;
   499→      }
   500→
   501→      case 'customer.deleted': {
   502→        const customer = event.data.object;
   503→        const customerId = customer.id;
   504→
   505→        // Validate customerId
   506→        if (!customerId) {
   507→          console.error('[SPLICE] Missing customer ID in customer.deleted event');
   508→          return res.status(400).json({ error: 'Missing customer ID' });
   509→        }
   510→
   511→        // Clean up user data - downgrade to cancelled
   512→        await usageTracking.updateTier(customerId, 'cancelled');
   513→        console.log(`[SPLICE] Customer deleted: ${customerId}`);
   514→        break;
   515→      }
   516→
   517→      default:
   518→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);
   519→    }
   520→
   521→    // Record event as processed (idempotency)
   522→    await usageTracking.recordWebhookEvent(event.id, event.type);
   523→
   524→    res.json({ received: true });
   525→  } catch (err) {
   526→    console.error('[SPLICE] Webhook handler error:', err);
   527→    res.status(500).json({ error: err.message });
   528→  }
   529→});
   530→
   531→// Parse JSON body for all other routes
   532→// SECURITY: Limit JSON body size to prevent DoS attacks
   533→app.use(express.json({ limit: '10mb' }));
   534→
   535→// =============================================================================
   536→// Route Configuration Options
   537→// =============================================================================
   538→
   539→const routeOptions = {
   540→  middleware: {
   541→    requireCredits,
   542→    requireFeature,
   543→    authenticateToken
   544→  },
   545→  services: {
   546→    usageTracking,
   547→    referralService,
   548→    licenseService,
   549→    emailService,
   550→    stripe
   551→  },
   552→  authHelpers: {
   553→    generateToken,
   554→    generateRefreshToken,
   555→    verifyToken,
   556→    maskSensitiveData
   557→  },
   558→  staticCache: STATIC_RESPONSE_CACHE,
   559→  sendCachedResponse
   560→};
   561→
   562→// =============================================================================
   563→// Mount Routes
   564→// =============================================================================
   565→
   566→// Health check and system endpoints (no prefix)
   567→app.use('/', healthRoutes(routeOptions));
   568→
   569→// Core analysis endpoints
   570→app.use('/', analyzeRoutes(routeOptions));
   571→app.use('/', silencesRoutes(routeOptions));
   572→app.use('/', detectionRoutes(routeOptions));
   573→
   574→// Export endpoints
   575→app.use('/export', exportRoutes(routeOptions));
   576→
   577→// Multitrack/Multicam endpoints
   578→app.use('/multitrack', multitrackRoutes(routeOptions));
   579→
   580→// Cut list generation
   581→app.use('/cut-list', cutListRoutes(routeOptions));
   582→
   583→// Legacy XML processing endpoint (backwards compatibility)
   584→const { processXMLFile } = require('./services/xmlProcessor');
   585→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {
   586→  const {
   587→    xmlPath,
   588→    silences,
   589→    removeGaps = true,
   590→    outputPath = null
   591→  } = req.body;
   592→
   593→  if (!xmlPath) {
   594→    return res.status(400).json({ error: 'xmlPath is required' });
   595→  }
   596→
   597→  if (!silences || !Array.isArray(silences)) {
   598→    return res.status(400).json({ error: 'silences array is required' });
   599→  }
   600→
   601→  if (!fs.existsSync(xmlPath)) {
   602→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });
   603→  }
   604→
   605→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);
   606→
   607→  try {
   608→    const result = await processXMLFile(xmlPath, silences, {
   609→      outputPath,
   610→      removeGaps
   611→    });
   612→
   613→    res.json({
   614→      success: true,
   615→      inputPath: xmlPath,
   616→      outputPath: result.outputPath,
   617→      stats: result.stats
   618→    });
   619→  } catch (err) {
   620→    console.error('[SPLICE] XML processing error:', err);
   621→    res.status(500).json({ error: err.message });
   622→  }
   623→});
   624→
   625→// Auto zoom endpoints
   626→app.use('/zoom', zoomRoutes(routeOptions));
   627→
   628→// Chapter detection endpoints
   629→app.use('/chapters', chaptersRoutes(routeOptions));
   630→
   631→// YouTube content generation
   632→app.use('/youtube', youtubeRoutes(routeOptions));
   633→
   634→// Animated captions endpoints
   635→app.use('/captions', captionsRoutes(routeOptions));
   636→
   637→// Text-based editing endpoints
   638→app.use('/text-edit', textEditRoutes(routeOptions));
   639→
   640→// Social reframe endpoints
   641→app.use('/reframe', reframeRoutes(routeOptions));
   642→app.use('/faces', reframeRoutes.facesRouter(routeOptions));
   643→
   644→// Batch processing endpoints
   645→app.use('/batch', batchRoutes(routeOptions));
   646→
   647→// Authentication endpoints
   648→app.use('/auth', authRoutes(routeOptions));
   649→
   650→// Billing and credits endpoints
   651→app.use('/', billingRoutes(routeOptions));
   652→
   653→// Referral system endpoints
   654→app.use('/referral', referralRoutes(routeOptions));
   655→
   656→// License key endpoints
   657→app.use('/license', licenseRoutes(routeOptions));
   658→
   659→// AI Music generation endpoints
   660→app.use('/music', musicRoutes(routeOptions));
   661→
   662→// =============================================================================
   663→// Start Server
   664→// =============================================================================
   665→
   666→// Track active server for graceful shutdown
   667→let server = null;
   668→
   669→// Initialize database and start server
   670→async function startServer() {
   671→  try {
   672→    await usageTracking.initDatabase();
   673→    await referralService.initReferralTables();
   674→    await licenseService.initLicenseTables();
   675→    console.log('[SPLICE] Database initialized');
   676→
   677→    // PERF-FIX: Initialize static response cache at startup
   678→    initializeStaticCache();
   679→
   680→    if (isProduction || !httpsOptions) {
   681→      // Production: Railway provides TLS termination, use HTTP
   682→      server = http.createServer(app).listen(PORT, () => {
   683→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);
   684→      });
   685→    } else {
   686→      // Development: Use HTTPS with local certificates
   687→      server = https.createServer(httpsOptions, app).listen(PORT, () => {
   688→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);
   689→        console.log(`[SPLICE] POST /analyze with { "wavPath": "/path/to/audio.wav" }`);
   690→      });
   691→    }
   692→  } catch (err) {
   693→    console.error('[SPLICE] Failed to start server:', err);
   694→    process.exit(1);
   695→  }
   696→}
   697→
   698→// =============================================================================
   699→// Graceful Shutdown
   700→// =============================================================================
   701→
   702→async function gracefulShutdown(signal) {
   703→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);
   704→
   705→  // Stop accepting new connections
   706→  if (server) {
   707→    server.close(() => {
   708→      console.log('[SPLICE] HTTP server closed');
   709→    });
   710→  }
   711→
   712→  // Close database pool
   713→  try {
   714→    await usageTracking.closePool();
   715→    console.log('[SPLICE] Database pool closed');
   716→  } catch (err) {
   717→    console.error('[SPLICE] Error closing database pool:', err.message);
   718→  }
   719→
   720→  // Give ongoing requests time to complete (max 10 seconds)
   721→  setTimeout(() => {
   722→    console.log('[SPLICE] Graceful shutdown complete');
   723→    process.exit(0);
   724→  }, 10000);
   725→}
   726→
   727→// Handle termination signals
   728→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
   729→process.on('SIGINT', () => gracefulShutdown('SIGINT'));
   730→
   731→// Handle uncaught exceptions
   732→process.on('uncaughtException', (err) => {
   733→  console.error('[SPLICE] Uncaught exception:', err);
   734→  gracefulShutdown('uncaughtException');
   735→});
   736→
   737→process.on('unhandledRejection', (reason, promise) => {
   738→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);
   739→});
   740→
   741→startServer();
   742→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
