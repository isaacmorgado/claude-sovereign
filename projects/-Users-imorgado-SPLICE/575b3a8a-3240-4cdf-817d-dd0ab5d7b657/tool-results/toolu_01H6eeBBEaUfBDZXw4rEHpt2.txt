     1→/**
     2→ * Usage Tracking Service
     3→ *
     4→ * Tracks user credit balances and usage for billing.
     5→ * Uses PostgreSQL for persistence.
     6→ */
     7→
     8→const { Pool } = require('pg');
     9→const { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');
    10→
    11→// PostgreSQL connection pool with proper limits
    12→const pool = new Pool({
    13→  connectionString: process.env.DATABASE_URL,
    14→  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
    15→  // PERFORMANCE: Set connection pool limits
    16→  max: 20,                    // Maximum number of clients in the pool
    17→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds
    18→  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection
    19→});
    20→
    21→// Hours per tier (regular processing)
    22→// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo
    23→// Target margins: 79-82%
    24→const TIER_HOURS = {
    25→  starter: 4,    // 4 hrs/month
    26→  pro: 15,       // 15 hrs/month
    27→  team: 50,      // 50 hrs/month
    28→  cancelled: 0
    29→};
    30→
    31→// Overage rate for processing hours beyond included
    32→const HOURS_OVERAGE_RATE = 2.00; // $2/hour
    33→
    34→// Isolation minutes per tier (sized to maintain 80% margins)
    35→const TIER_ISOLATION_MINUTES = {
    36→  starter: 0,     // No isolation access
    37→  pro: 45,        // 45 minutes included
    38→  team: 180,      // 3 hours included
    39→  cancelled: 0
    40→};
    41→
    42→// Convert to hours for database storage
    43→const TIER_ISOLATION_HOURS = {
    44→  starter: 0,
    45→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours
    46→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours
    47→  cancelled: 0
    48→};
    49→
    50→// Overage rate for isolation beyond included minutes
    51→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)
    52→
    53→/**
    54→ * Initialize database tables
    55→ */
    56→async function initDatabase() {
    57→  const client = await pool.connect();
    58→  try {
    59→    await client.query(`
    60→      CREATE TABLE IF NOT EXISTS users (
    61→        id SERIAL PRIMARY KEY,
    62→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,
    63→        email VARCHAR(255),
    64→        tier VARCHAR(50) DEFAULT 'starter',
    65→        hours_remaining DECIMAL(10,4) DEFAULT 15,
    66→        hours_total DECIMAL(10,4) DEFAULT 15,
    67→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,
    68→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,
    69→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    70→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    71→      )
    72→    `);
    73→
    74→    // Add isolation columns if they don't exist (for existing databases)
    75→    await client.query(`
    76→      DO $$
    77→      BEGIN
    78→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN
    79→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;
    80→        END IF;
    81→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN
    82→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;
    83→        END IF;
    84→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN
    85→          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;
    86→        END IF;
    87→      END $$;
    88→    `);
    89→
    90→    await client.query(`
    91→      CREATE TABLE IF NOT EXISTS usage_log (
    92→        id SERIAL PRIMARY KEY,
    93→        user_id INTEGER REFERENCES users(id),
    94→        stripe_customer_id VARCHAR(255),
    95→        audio_duration_seconds DECIMAL(10,2),
    96→        hours_used DECIMAL(10,6),
    97→        endpoint VARCHAR(100),
    98→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    99→      )
   100→    `);
   101→
   102→    await client.query(`
   103→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)
   104→    `);
   105→
   106→    await client.query(`
   107→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)
   108→    `);
   109→
   110→    // PERFORMANCE: Add composite index for efficient customer usage history queries
   111→    await client.query(`
   112→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created
   113→      ON usage_log(stripe_customer_id, created_at DESC)
   114→    `);
   115→
   116→    // Webhook events table for idempotency
   117→    await client.query(`
   118→      CREATE TABLE IF NOT EXISTS webhook_events (
   119→        id SERIAL PRIMARY KEY,
   120→        event_id VARCHAR(255) UNIQUE NOT NULL,
   121→        event_type VARCHAR(100),
   122→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   123→      )
   124→    `);
   125→
   126→    await client.query(`
   127→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)
   128→    `);
   129→
   130→    console.log('[UsageTracking] Database initialized');
   131→  } finally {
   132→    client.release();
   133→  }
   134→}
   135→
   136→/**
   137→ * Get or create a user by Stripe customer ID
   138→ * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation
   139→ */
   140→async function getOrCreateUser(stripeCustomerId, email = null) {
   141→  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases
   142→  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING
   143→  const result = await pool.query(
   144→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)
   145→     VALUES ($1, $2, 'starter', $3, $3, $4, $4)
   146→     ON CONFLICT (stripe_customer_id) DO UPDATE
   147→     SET stripe_customer_id = EXCLUDED.stripe_customer_id
   148→     RETURNING *`,
   149→    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]
   150→  );
   151→
   152→  return result.rows[0];
   153→}
   154→
   155→/**
   156→ * Check if a customer exists in the database (without creating)
   157→ * SECURITY: Used to validate legacy auth attempts
   158→ */
   159→async function customerExists(stripeCustomerId) {
   160→  if (!stripeCustomerId) return false;
   161→
   162→  try {
   163→    const result = await pool.query(
   164→      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',
   165→      [stripeCustomerId]
   166→    );
   167→    return result.rows.length > 0;
   168→  } catch (err) {
   169→    console.error('[SPLICE] customerExists check failed:', err.message);
   170→    return false;
   171→  }
   172→}
   173→
   174→/**
   175→ * Get user's current credit balance
   176→ */
   177→async function getBalance(stripeCustomerId) {
   178→  const user = await getOrCreateUser(stripeCustomerId);
   179→  const hoursTotal = parseFloat(user.hours_total);
   180→  const hoursRemaining = parseFloat(user.hours_remaining);
   181→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);
   182→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);
   183→
   184→  // Tier display names
   185→  const tierNames = {
   186→    starter: 'Starter',
   187→    pro: 'Pro',
   188→    team: 'Team',
   189→    cancelled: 'Cancelled'
   190→  };
   191→
   192→  // Calculate trial days remaining
   193→  let trialDaysRemaining = null;
   194→  let isOnTrial = false;
   195→  if (user.trial_end) {
   196→    const trialEnd = new Date(user.trial_end);
   197→    const now = new Date();
   198→    const diffMs = trialEnd.getTime() - now.getTime();
   199→    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
   200→    if (diffDays > 0) {
   201→      trialDaysRemaining = diffDays;
   202→      isOnTrial = true;
   203→    }
   204→  }
   205→
   206→  return {
   207→    hoursRemaining,
   208→    hoursTotal,
   209→    isolationHoursRemaining,
   210→    isolationHoursTotal,
   211→    tier: user.tier,
   212→    tierName: tierNames[user.tier] || user.tier,
   213→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',
   214→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',
   215→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,
   216→    isolationOverageRate: ISOLATION_OVERAGE_RATE,
   217→    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,
   218→    trialDaysRemaining,
   219→    isOnTrial
   220→  };
   221→}
   222→
   223→/**
   224→ * Check if user has enough credits for estimated duration
   225→ */
   226→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {
   227→  const balance = await getBalance(stripeCustomerId);
   228→  const estimatedHours = estimatedSeconds / 3600;
   229→  return balance.hoursRemaining >= estimatedHours;
   230→}
   231→
   232→/**
   233→ * Reserve credits atomically using SELECT ... FOR UPDATE
   234→ * This prevents race conditions where multiple requests pass credit check
   235→ * before any deduction occurs.
   236→ *
   237→ * @param {string} stripeCustomerId - Customer ID
   238→ * @param {number} estimatedSeconds - Estimated processing time in seconds
   239→ * @param {string} endpoint - Endpoint name for tracking
   240→ * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}
   241→ */
   242→async function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {
   243→  const estimatedHours = estimatedSeconds / 3600;
   244→  const client = await pool.connect();
   245→
   246→  try {
   247→    await client.query('BEGIN');
   248→
   249→    // Lock the row for this customer - prevents concurrent modifications
   250→    const result = await client.query(
   251→      `SELECT id, hours_remaining FROM users
   252→       WHERE stripe_customer_id = $1
   253→       FOR UPDATE`,
   254→      [stripeCustomerId]
   255→    );
   256→
   257→    if (result.rows.length === 0) {
   258→      // Create user if doesn't exist (within transaction)
   259→      const newUser = await client.query(
   260→        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)
   261→         VALUES ($1, 'starter', $2, $2)
   262→         RETURNING id, hours_remaining`,
   263→        [stripeCustomerId, TIER_HOURS.starter]
   264→      );
   265→      result.rows = newUser.rows;
   266→    }
   267→
   268→    const user = result.rows[0];
   269→    const hoursRemaining = parseFloat(user.hours_remaining);
   270→
   271→    // Check if enough credits
   272→    if (hoursRemaining < estimatedHours) {
   273→      await client.query('ROLLBACK');
   274→      return {
   275→        success: false,
   276→        error: 'Insufficient credits',
   277→        hoursRemaining,
   278→        hoursRequired: estimatedHours
   279→      };
   280→    }
   281→
   282→    // Generate unique reservation ID
   283→    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
   284→
   285→    // Reserve credits by deducting the estimated amount
   286→    await client.query(
   287→      `UPDATE users
   288→       SET hours_remaining = hours_remaining - $1,
   289→           updated_at = CURRENT_TIMESTAMP
   290→       WHERE stripe_customer_id = $2`,
   291→      [estimatedHours, stripeCustomerId]
   292→    );
   293→
   294→    // Log the reservation
   295→    await client.query(
   296→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)
   297→       VALUES ($1, $2, $3, $4, $5)`,
   298→      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]
   299→    );
   300→
   301→    await client.query('COMMIT');
   302→
   303→    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);
   304→
   305→    return {
   306→      success: true,
   307→      reservationId,
   308→      hoursReserved: estimatedHours,
   309→      hoursRemaining: hoursRemaining - estimatedHours
   310→    };
   311→  } catch (err) {
   312→    await client.query('ROLLBACK');
   313→    console.error('[UsageTracking] Reservation error:', err);
   314→    throw err;
   315→  } finally {
   316→    client.release();
   317→  }
   318→}
   319→
   320→/**
   321→ * Confirm a reservation (finalize usage) or adjust for actual duration
   322→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE
   323→ *
   324→ * @param {string} stripeCustomerId - Customer ID
   325→ * @param {number} actualSeconds - Actual processing time in seconds
   326→ * @param {number} reservedSeconds - Originally reserved seconds
   327→ * @param {string} endpoint - Endpoint name
   328→ * @returns {Promise<object>} Updated balance
   329→ */
   330→async function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {
   331→  const actualHours = actualSeconds / 3600;
   332→  const reservedHours = reservedSeconds / 3600;
   333→  const difference = reservedHours - actualHours;
   334→
   335→  const client = await pool.connect();
   336→  try {
   337→    await client.query('BEGIN');
   338→
   339→    // Lock the row and get current state
   340→    const result = await client.query(
   341→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier
   342→       FROM users
   343→       WHERE stripe_customer_id = $1
   344→       FOR UPDATE`,
   345→      [stripeCustomerId]
   346→    );
   347→
   348→    if (result.rows.length === 0) {
   349→      await client.query('ROLLBACK');
   350→      throw new Error('User not found');
   351→    }
   352→
   353→    let user = result.rows[0];
   354→
   355→    // If actual usage was less than reserved, refund the difference
   356→    if (difference > 0) {
   357→      const updateResult = await client.query(
   358→        `UPDATE users
   359→         SET hours_remaining = hours_remaining + $1,
   360→             updated_at = CURRENT_TIMESTAMP
   361→         WHERE stripe_customer_id = $2
   362→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,
   363→        [difference, stripeCustomerId]
   364→      );
   365→      user = { ...user, ...updateResult.rows[0] };
   366→
   367→      // Log the adjustment
   368→      await client.query(
   369→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)
   370→         VALUES ($1, $2, $3, $4, $5)`,
   371→        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]
   372→      );
   373→    } else if (difference < 0) {
   374→      // Actual usage was more than reserved - deduct the extra
   375→      const updateResult = await client.query(
   376→        `UPDATE users
   377→         SET hours_remaining = GREATEST(0, hours_remaining - $1),
   378→             updated_at = CURRENT_TIMESTAMP
   379→         WHERE stripe_customer_id = $2
   380→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,
   381→        [-difference, stripeCustomerId]
   382→      );
   383→      user = { ...user, ...updateResult.rows[0] };
   384→
   385→      // Log the additional usage
   386→      await client.query(
   387→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)
   388→         VALUES ($1, $2, $3, $4, $5)`,
   389→        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]
   390→      );
   391→    }
   392→
   393→    await client.query('COMMIT');
   394→
   395→    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);
   396→
   397→    // Build balance from data we already have (no extra SELECT needed)
   398→    const hoursTotal = parseFloat(user.hours_total);
   399→    const hoursRemaining = parseFloat(user.hours_remaining);
   400→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);
   401→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);
   402→
   403→    const tierNames = {
   404→      starter: 'Starter',
   405→      pro: 'Pro',
   406→      team: 'Team',
   407→      cancelled: 'Cancelled'
   408→    };
   409→
   410→    return {
   411→      hoursRemaining,
   412→      hoursTotal,
   413→      isolationHoursRemaining,
   414→      isolationHoursTotal,
   415→      tier: user.tier,
   416→      tierName: tierNames[user.tier] || user.tier,
   417→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',
   418→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',
   419→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,
   420→      isolationOverageRate: ISOLATION_OVERAGE_RATE
   421→    };
   422→  } catch (err) {
   423→    await client.query('ROLLBACK');
   424→    throw err;
   425→  } finally {
   426→    client.release();
   427→  }
   428→}
   429→
   430→/**
   431→ * Release a reservation (refund credits on processing failure)
   432→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE
   433→ *
   434→ * @param {string} stripeCustomerId - Customer ID
   435→ * @param {number} reservedSeconds - Originally reserved seconds
   436→ * @param {string} endpoint - Endpoint name
   437→ * @param {string} reason - Reason for release
   438→ * @returns {Promise<object>} Updated balance
   439→ */
   440→async function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {
   441→  const reservedHours = reservedSeconds / 3600;
   442→
   443→  const client = await pool.connect();
   444→  try {
   445→    await client.query('BEGIN');
   446→
   447→    // Lock the row and get id for logging
   448→    const result = await client.query(
   449→      `SELECT id FROM users
   450→       WHERE stripe_customer_id = $1
   451→       FOR UPDATE`,
   452→      [stripeCustomerId]
   453→    );
   454→
   455→    if (result.rows.length === 0) {
   456→      await client.query('ROLLBACK');
   457→      throw new Error('User not found');
   458→    }
   459→
   460→    const userId = result.rows[0].id;
   461→
   462→    // Refund the reserved amount with RETURNING
   463→    const updateResult = await client.query(
   464→      `UPDATE users
   465→       SET hours_remaining = hours_remaining + $1,
   466→           updated_at = CURRENT_TIMESTAMP
   467→       WHERE stripe_customer_id = $2
   468→       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,
   469→      [reservedHours, stripeCustomerId]
   470→    );
   471→
   472→    const user = updateResult.rows[0];
   473→
   474→    // Log the refund
   475→    await client.query(
   476→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)
   477→       VALUES ($1, $2, $3, $4, $5)`,
   478→      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]
   479→    );
   480→
   481→    await client.query('COMMIT');
   482→
   483→    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);
   484→
   485→    // Build balance from RETURNING data (no extra SELECT needed)
   486→    const hoursTotal = parseFloat(user.hours_total);
   487→    const hoursRemaining = parseFloat(user.hours_remaining);
   488→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);
   489→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);
   490→
   491→    const tierNames = {
   492→      starter: 'Starter',
   493→      pro: 'Pro',
   494→      team: 'Team',
   495→      cancelled: 'Cancelled'
   496→    };
   497→
   498→    return {
   499→      hoursRemaining,
   500→      hoursTotal,
   501→      isolationHoursRemaining,
   502→      isolationHoursTotal,
   503→      tier: user.tier,
   504→      tierName: tierNames[user.tier] || user.tier,
   505→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',
   506→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',
   507→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,
   508→      isolationOverageRate: ISOLATION_OVERAGE_RATE
   509→    };
   510→  } catch (err) {
   511→    await client.query('ROLLBACK');
   512→    throw err;
   513→  } finally {
   514→    client.release();
   515→  }
   516→}
   517→
   518→/**
   519→ * Check if user can use vocal isolation
   520→ * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }
   521→ */
   522→async function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {
   523→  const balance = await getBalance(stripeCustomerId);
   524→
   525→  // Starter tier has no isolation access
   526→  if (!balance.hasIsolationAccess) {
   527→    return {
   528→      allowed: false,
   529→      reason: 'upgrade_required',
   530→      message: 'Vocal isolation requires Pro or Team tier',
   531→      hasIncludedHours: false,
   532→      overageRequired: false,
   533→      overageCost: 0
   534→    };
   535→  }
   536→
   537→  const estimatedHours = estimatedMinutes / 60;
   538→  const remainingIncluded = balance.isolationHoursRemaining;
   539→
   540→  // Check if within included hours
   541→  if (remainingIncluded >= estimatedHours) {
   542→    return {
   543→      allowed: true,
   544→      reason: 'included',
   545→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,
   546→      hasIncludedHours: true,
   547→      overageRequired: false,
   548→      overageCost: 0,
   549→      isolationHoursRemaining: remainingIncluded - estimatedHours
   550→    };
   551→  }
   552→
   553→  // Calculate overage
   554→  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);
   555→  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;
   556→
   557→  return {
   558→    allowed: true,
   559→    reason: 'overage',
   560→    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,
   561→    hasIncludedHours: remainingIncluded > 0,
   562→    overageRequired: true,
   563→    overageMinutes,
   564→    overageCost,
   565→    isolationHoursRemaining: 0
   566→  };
   567→}
   568→
   569→/**
   570→ * Deduct isolation usage from user's balance
   571→ * Returns overage cost if beyond included hours
   572→ * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)
   573→ */
   574→async function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {
   575→  const durationMinutes = audioDurationSeconds / 60;
   576→  const durationHours = audioDurationSeconds / 3600;
   577→
   578→  const client = await pool.connect();
   579→  try {
   580→    await client.query('BEGIN');
   581→
   582→    // Lock the row for this customer - prevents concurrent modifications
   583→    const userResult = await client.query(
   584→      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier
   585→       FROM users WHERE stripe_customer_id = $1
   586→       FOR UPDATE`,
   587→      [stripeCustomerId]
   588→    );
   589→
   590→    if (userResult.rows.length === 0) {
   591→      await client.query('ROLLBACK');
   592→      throw new Error('User not found');
   593→    }
   594→
   595→    const user = userResult.rows[0];
   596→    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);
   597→
   598→    let overageCost = 0;
   599→    let hoursFromIncluded = 0;
   600→    let overageMinutes = 0;
   601→
   602→    if (remainingIncluded >= durationHours) {
   603→      // Fully covered by included hours
   604→      hoursFromIncluded = durationHours;
   605→    } else {
   606→      // Partial or full overage
   607→      hoursFromIncluded = remainingIncluded;
   608→      overageMinutes = durationMinutes - (remainingIncluded * 60);
   609→      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;
   610→    }
   611→
   612→    // Update isolation balance with RETURNING to get new values
   613→    const updateResult = await client.query(
   614→      `UPDATE users
   615→       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),
   616→           updated_at = CURRENT_TIMESTAMP
   617→       WHERE stripe_customer_id = $2
   618→       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,
   619→      [durationHours, stripeCustomerId]
   620→    );
   621→
   622→    const updatedUser = updateResult.rows[0];
   623→
   624→    // Log usage (mark as isolation)
   625→    await client.query(
   626→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)
   627→       VALUES ($1, $2, $3, $4, $5)`,
   628→      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]
   629→    );
   630→
   631→    await client.query('COMMIT');
   632→
   633→    // Build balance from RETURNING data (no extra SELECT needed)
   634→    const hoursTotal = parseFloat(updatedUser.hours_total);
   635→    const hoursRemaining = parseFloat(updatedUser.hours_remaining);
   636→    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);
   637→    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);
   638→
   639→    const tierNames = {
   640→      starter: 'Starter',
   641→      pro: 'Pro',
   642→      team: 'Team',
   643→      cancelled: 'Cancelled'
   644→    };
   645→
   646→    return {
   647→      hoursRemaining,
   648→      hoursTotal,
   649→      isolationHoursRemaining,
   650→      isolationHoursTotal,
   651→      tier: updatedUser.tier,
   652→      tierName: tierNames[updatedUser.tier] || updatedUser.tier,
   653→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',
   654→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',
   655→      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,
   656→      isolationOverageRate: ISOLATION_OVERAGE_RATE,
   657→      isolationUsed: {
   658→        durationMinutes,
   659→        hoursFromIncluded,
   660→        overageMinutes,
   661→        overageCost
   662→      }
   663→    };
   664→  } catch (err) {
   665→    await client.query('ROLLBACK');
   666→    throw err;
   667→  } finally {
   668→    client.release();
   669→  }
   670→}
   671→
   672→/**
   673→ * Deduct usage from user's balance
   674→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE
   675→ * Uses transaction with rollback on failure for atomic UPDATE + INSERT
   676→ * Reports overage to Stripe for billing when user exceeds included hours
   677→ */
   678→async function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {
   679→  const hoursUsed = audioDurationSeconds / 3600;
   680→
   681→  const client = await pool.connect();
   682→  try {
   683→    await client.query('BEGIN');
   684→
   685→    // First get current balance to calculate overage
   686→    const currentResult = await client.query(
   687→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier
   688→       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,
   689→      [stripeCustomerId]
   690→    );
   691→
   692→    if (currentResult.rows.length === 0) {
   693→      await client.query('ROLLBACK');
   694→      throw new Error('User not found');
   695→    }
   696→
   697→    const currentUser = currentResult.rows[0];
   698→    const currentRemaining = parseFloat(currentUser.hours_remaining);
   699→
   700→    // Calculate overage (hours used beyond what's remaining)
   701→    let overageHours = 0;
   702→    if (hoursUsed > currentRemaining) {
   703→      overageHours = hoursUsed - currentRemaining;
   704→    }
   705→
   706→    // Update balance (clamp at 0)
   707→    const updateResult = await client.query(
   708→      `UPDATE users
   709→       SET hours_remaining = GREATEST(0, hours_remaining - $1),
   710→           updated_at = CURRENT_TIMESTAMP
   711→       WHERE stripe_customer_id = $2
   712→       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,
   713→      [hoursUsed, stripeCustomerId]
   714→    );
   715→
   716→    const user = updateResult.rows[0];
   717→
   718→    // Log usage
   719→    await client.query(
   720→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)
   721→       VALUES ($1, $2, $3, $4, $5)`,
   722→      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]
   723→    );
   724→
   725→    await client.query('COMMIT');
   726→
   727→    // Report overage to Stripe if any (after commit to not block transaction)
   728→    let overageCharge = 0;
   729→    if (overageHours > 0) {
   730→      overageCharge = overageHours * HOURS_OVERAGE_RATE;
   731→      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);
   732→      if (usageReport.success) {
   733→        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);
   734→      } else {
   735→        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);
   736→      }
   737→    }
   738→
   739→    // Build balance from RETURNING data (no extra SELECT needed)
   740→    const hoursTotal = parseFloat(user.hours_total);
   741→    const hoursRemaining = parseFloat(user.hours_remaining);
   742→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);
   743→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);
   744→
   745→    const tierNames = {
   746→      starter: 'Starter',
   747→      pro: 'Pro',
   748→      team: 'Team',
   749→      cancelled: 'Cancelled'
   750→    };
   751→
   752→    return {
   753→      hoursRemaining,
   754→      hoursTotal,
   755→      isolationHoursRemaining,
   756→      isolationHoursTotal,
   757→      tier: user.tier,
   758→      tierName: tierNames[user.tier] || user.tier,
   759→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',
   760→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',
   761→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,
   762→      isolationOverageRate: ISOLATION_OVERAGE_RATE,
   763→      overageHours,
   764→      overageCharge
   765→    };
   766→  } catch (err) {
   767→    await client.query('ROLLBACK');
   768→    throw err;
   769→  } finally {
   770→    client.release();
   771→  }
   772→}
   773→
   774→/**
   775→ * Reset user's hours for new billing period
   776→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE
   777→ */
   778→async function resetHours(stripeCustomerId, tier) {
   779→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;
   780→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;
   781→
   782→  const result = await pool.query(
   783→    `UPDATE users
   784→     SET hours_remaining = $1, hours_total = $1,
   785→         isolation_hours_remaining = $2, isolation_hours_total = $2,
   786→         tier = $3, updated_at = CURRENT_TIMESTAMP
   787→     WHERE stripe_customer_id = $4
   788→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,
   789→    [hours, isolationHours, tier, stripeCustomerId]
   790→  );
   791→
   792→  if (result.rows.length === 0) {
   793→    // User doesn't exist, create and return default balance
   794→    return await getBalance(stripeCustomerId);
   795→  }
   796→
   797→  const user = result.rows[0];
   798→  const hoursTotal = parseFloat(user.hours_total);
   799→  const hoursRemaining = parseFloat(user.hours_remaining);
   800→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);
   801→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);
   802→
   803→  const tierNames = {
   804→    starter: 'Starter',
   805→    pro: 'Pro',
   806→    team: 'Team',
   807→    cancelled: 'Cancelled'
   808→  };
   809→
   810→  return {
   811→    hoursRemaining,
   812→    hoursTotal,
   813→    isolationHoursRemaining,
   814→    isolationHoursTotal,
   815→    tier: user.tier,
   816→    tierName: tierNames[user.tier] || user.tier,
   817→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',
   818→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',
   819→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,
   820→    isolationOverageRate: ISOLATION_OVERAGE_RATE
   821→  };
   822→}
   823→
   824→/**
   825→ * Update user's tier (from Stripe webhook)
   826→ * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert
   827→ */
   828→async function updateTier(stripeCustomerId, tier, email = null) {
   829→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;
   830→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;
   831→
   832→  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query
   833→  const result = await pool.query(
   834→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)
   835→     VALUES ($1, $2, $3, $4, $4, $5, $5)
   836→     ON CONFLICT (stripe_customer_id) DO UPDATE
   837→     SET tier = $3, hours_remaining = $4, hours_total = $4,
   838→         isolation_hours_remaining = $5, isolation_hours_total = $5,
   839→         updated_at = CURRENT_TIMESTAMP
   840→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,
   841→    [stripeCustomerId, email, tier, hours, isolationHours]
   842→  );
   843→
   844→  const user = result.rows[0];
   845→  const hoursTotal = parseFloat(user.hours_total);
   846→  const hoursRemaining = parseFloat(user.hours_remaining);
   847→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);
   848→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);
   849→
   850→  const tierNames = {
   851→    starter: 'Starter',
   852→    pro: 'Pro',
   853→    team: 'Team',
   854→    cancelled: 'Cancelled'
   855→  };
   856→
   857→  return {
   858→    hoursRemaining,
   859→    hoursTotal,
   860→    isolationHoursRemaining,
   861→    isolationHoursTotal,
   862→    tier: user.tier,
   863→    tierName: tierNames[user.tier] || user.tier,
   864→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',
   865→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',
   866→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,
   867→    isolationOverageRate: ISOLATION_OVERAGE_RATE
   868→  };
   869→}
   870→
   871→/**
   872→ * Get usage history for a user
   873→ */
   874→async function getUsageHistory(stripeCustomerId, limit = 50) {
   875→  const result = await pool.query(
   876→    `SELECT * FROM usage_log
   877→     WHERE stripe_customer_id = $1
   878→     ORDER BY created_at DESC
   879→     LIMIT $2`,
   880→    [stripeCustomerId, limit]
   881→  );
   882→  return result.rows;
   883→}
   884→
   885→/**
   886→ * Check if webhook event has already been processed (idempotency)
   887→ */
   888→async function isEventProcessed(eventId) {
   889→  const result = await pool.query(
   890→    'SELECT id FROM webhook_events WHERE event_id = $1',
   891→    [eventId]
   892→  );
   893→  return result.rows.length > 0;
   894→}
   895→
   896→/**
   897→ * Record a processed webhook event
   898→ */
   899→async function recordWebhookEvent(eventId, eventType) {
   900→  try {
   901→    await pool.query(
   902→      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',
   903→      [eventId, eventType]
   904→    );
   905→  } catch (err) {
   906→    // Ignore duplicate key errors (race condition safety)
   907→    if (err.code !== '23505') throw err;
   908→  }
   909→}
   910→
   911→// =============================================================================
   912→// Music Credits Functions (Phase 4 - AI Music Feature)
   913→// =============================================================================
   914→
   915→// Music credits per tier
   916→// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo
   917→const TIER_MUSIC_CREDITS = {
   918→  starter: 2,    // 2 songs/month
   919→  pro: 10,       // 10 songs/month
   920→  team: 50,      // 50 songs/month
   921→  cancelled: 0
   922→};
   923→
   924→// Feature access by tier - defines which features each tier can use
   925→const TIER_FEATURES = {
   926→  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],
   927→  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',
   928→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',
   929→    'profanity_detection', 'chapter_detection'],
   930→  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',
   931→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',
   932→    'profanity_detection', 'chapter_detection', 'multitrack',
   933→    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],
   934→  cancelled: []
   935→};
   936→
   937→/**
   938→ * Check if a tier has access to a specific feature
   939→ * @param {string} tier - User's tier (starter, pro, team)
   940→ * @param {string} feature - Feature name to check
   941→ * @returns {boolean}
   942→ */
   943→function hasFeatureAccess(tier, feature) {
   944→  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;
   945→  return tierFeatures.includes(feature);
   946→}
   947→
   948→// Flat overage rate for music (simplified pricing)
   949→const MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers
   950→
   951→// Legacy overage rates (kept for backwards compatibility)
   952→const MUSIC_OVERAGE_RATES = {
   953→  starter: 1.00,  // $1.00/song
   954→  pro: 1.00,      // $1.00/song
   955→  team: 1.00      // $1.00/song
   956→};
   957→
   958→/**
   959→ * Get music credits balance for a customer
   960→ * @param {string} stripeCustomerId - Stripe customer ID
   961→ * @returns {Promise<{remaining: number, total: number, tier: string}>}
   962→ */
   963→async function getMusicCredits(stripeCustomerId) {
   964→  const result = await pool.query(
   965→    `SELECT music_credits_remaining, music_credits_total, tier
   966→     FROM users
   967→     WHERE stripe_customer_id = $1`,
   968→    [stripeCustomerId]
   969→  );
   970→
   971→  if (result.rows.length === 0) {
   972→    return { remaining: 0, total: 0, tier: 'starter' };
   973→  }
   974→
   975→  const row = result.rows[0];
   976→  return {
   977→    remaining: row.music_credits_remaining || 0,
   978→    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,
   979→    tier: row.tier || 'starter'
   980→  };
   981→}
   982→
   983→/**
   984→ * Check if customer has music credits available
   985→ * @param {string} stripeCustomerId - Stripe customer ID
   986→ * @returns {Promise<boolean>}
   987→ */
   988→async function hasMusicCredits(stripeCustomerId) {
   989→  const credits = await getMusicCredits(stripeCustomerId);
   990→  return credits.remaining > 0;
   991→}
   992→
   993→/**
   994→ * Deduct one music credit from customer
   995→ * @param {string} stripeCustomerId - Stripe customer ID
   996→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}
   997→ */
   998→async function deductMusicCredit(stripeCustomerId) {
   999→  const client = await pool.connect();
  1000→  try {
  1001→    await client.query('BEGIN');
  1002→
  1003→    // Lock row for update
  1004→    const result = await client.query(
  1005→      `SELECT music_credits_remaining, tier
  1006→       FROM users
  1007→       WHERE stripe_customer_id = $1
  1008→       FOR UPDATE`,
  1009→      [stripeCustomerId]
  1010→    );
  1011→
  1012→    if (result.rows.length === 0) {
  1013→      await client.query('ROLLBACK');
  1014→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };
  1015→    }
  1016→
  1017→    const { music_credits_remaining } = result.rows[0];
  1018→    let charged = 0;
  1019→
  1020→    if (music_credits_remaining > 0) {
  1021→      // Deduct from included credits
  1022→      await client.query(
  1023→        `UPDATE users
  1024→         SET music_credits_remaining = music_credits_remaining - 1,
  1025→             updated_at = CURRENT_TIMESTAMP
  1026→         WHERE stripe_customer_id = $1`,
  1027→        [stripeCustomerId]
  1028→      );
  1029→    } else {
  1030→      // Overage - charge flat rate ($1/song)
  1031→      charged = MUSIC_OVERAGE_RATE;
  1032→
  1033→      // Report overage to Stripe meter for billing
  1034→      const usageReport = await reportMusicOverage(stripeCustomerId, 1);
  1035→      if (usageReport.success) {
  1036→        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);
  1037→      } else {
  1038→        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);
  1039→      }
  1040→    }
  1041→
  1042→    // Log the usage
  1043→    await client.query(
  1044→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)
  1045→       VALUES ($1, 1, $2)
  1046→       ON CONFLICT DO NOTHING`,
  1047→      [stripeCustomerId, charged]
  1048→    );
  1049→
  1050→    await client.query('COMMIT');
  1051→
  1052→    const newCredits = await getMusicCredits(stripeCustomerId);
  1053→    return {
  1054→      success: true,
  1055→      remaining: newCredits.remaining,
  1056→      charged
  1057→    };
  1058→
  1059→  } catch (err) {
  1060→    await client.query('ROLLBACK');
  1061→    console.error('[SPLICE] Music credit deduction error:', err.message);
  1062→    return { success: false, remaining: 0, charged: 0, error: err.message };
  1063→  } finally {
  1064→    client.release();
  1065→  }
  1066→}
  1067→
  1068→/**
  1069→ * Reset music credits based on tier (called on subscription renewal)
  1070→ * @param {string} stripeCustomerId - Stripe customer ID
  1071→ * @param {string} tier - Subscription tier
  1072→ */
  1073→async function resetMusicCredits(stripeCustomerId, tier) {
  1074→  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;
  1075→
  1076→  await pool.query(
  1077→    `UPDATE users
  1078→     SET music_credits_remaining = $2,
  1079→         music_credits_total = $2,
  1080→         music_credits_reset_at = CURRENT_TIMESTAMP,
  1081→         updated_at = CURRENT_TIMESTAMP
  1082→     WHERE stripe_customer_id = $1`,
  1083→    [stripeCustomerId, credits]
  1084→  );
  1085→}
  1086→
  1087→/**
  1088→ * Add music credits (for promotional or overage purchases)
  1089→ * @param {string} stripeCustomerId - Stripe customer ID
  1090→ * @param {number} credits - Number of credits to add
  1091→ * @returns {Promise<{success: boolean, newBalance: number}>}
  1092→ */
  1093→async function addMusicCredits(stripeCustomerId, credits) {
  1094→  const result = await pool.query(
  1095→    `UPDATE users
  1096→     SET music_credits_remaining = music_credits_remaining + $2,
  1097→         updated_at = CURRENT_TIMESTAMP
  1098→     WHERE stripe_customer_id = $1
  1099→     RETURNING music_credits_remaining`,
  1100→    [stripeCustomerId, credits]
  1101→  );
  1102→
  1103→  if (result.rows.length === 0) {
  1104→    return { success: false, newBalance: 0 };
  1105→  }
  1106→
  1107→  return {
  1108→    success: true,
  1109→    newBalance: result.rows[0].music_credits_remaining
  1110→  };
  1111→}
  1112→
  1113→/**
  1114→ * Get music usage history for a customer
  1115→ * @param {string} stripeCustomerId - Stripe customer ID
  1116→ * @param {number} limit - Max records to return
  1117→ * @returns {Promise<Object[]>}
  1118→ */
  1119→async function getMusicUsageHistory(stripeCustomerId, limit = 50) {
  1120→  const result = await pool.query(
  1121→    `SELECT * FROM music_usage_log
  1122→     WHERE stripe_customer_id = $1
  1123→     ORDER BY created_at DESC
  1124→     LIMIT $2`,
  1125→    [stripeCustomerId, limit]
  1126→  );
  1127→  return result.rows;
  1128→}
  1129→
  1130→/**
  1131→ * Initialize music credits columns (migration helper)
  1132→ */
  1133→async function initMusicCreditsColumns() {
  1134→  const client = await pool.connect();
  1135→  try {
  1136→    // Add music credits columns if they don't exist
  1137→    await client.query(`
  1138→      DO $$
  1139→      BEGIN
  1140→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN
  1141→          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;
  1142→        END IF;
  1143→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN
  1144→          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;
  1145→        END IF;
  1146→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN
  1147→          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;
  1148→        END IF;
  1149→      END $$;
  1150→    `);
  1151→
  1152→    // Create music usage log table
  1153→    await client.query(`
  1154→      CREATE TABLE IF NOT EXISTS music_usage_log (
  1155→        id SERIAL PRIMARY KEY,
  1156→        stripe_customer_id VARCHAR(255) NOT NULL,
  1157→        credits_used INTEGER DEFAULT 1,
  1158→        overage_charged DECIMAL(10,2) DEFAULT 0,
  1159→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  1160→      )
  1161→    `);
  1162→
  1163→    await client.query(`
  1164→      CREATE INDEX IF NOT EXISTS idx_music_usage_customer
  1165→      ON music_usage_log(stripe_customer_id)
  1166→    `);
  1167→
  1168→    console.log('[SPLICE] Music credits columns initialized');
  1169→  } finally {
  1170→    client.release();
  1171→  }
  1172→}
  1173→
  1174→// Variations credits cost (equivalent to 2.5 music credits)
  1175→const VARIATIONS_CREDIT_COST = 2.5;
  1176→
  1177→// Overage rates for variations (higher than single music due to 3 parallel generations)
  1178→const VARIATIONS_OVERAGE_RATES = {
  1179→  starter: 1.25,  // $1.25/variations (2.5x $0.50)
  1180→  pro: 0.75,      // $0.75/variations (2.5x $0.30)
  1181→  team: 0.50      // $0.50/variations (2.5x $0.20)
  1182→};
  1183→
  1184→// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)
  1185→const SCENE_AWARE_CREDIT_COST = 1.5;
  1186→
  1187→// Overage rates for scene-aware music (75% margin)
  1188→const SCENE_AWARE_OVERAGE_RATES = {
  1189→  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)
  1190→  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)
  1191→  team: 0.30      // $0.30/scene-aware (1.5x $0.20)
  1192→};
  1193→
  1194→/**
  1195→ * Check if customer has enough credits for variations (2.5 credits)
  1196→ * @param {string} stripeCustomerId - Stripe customer ID
  1197→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}
  1198→ */
  1199→async function checkVariationsCredits(stripeCustomerId) {
  1200→  const credits = await getMusicCredits(stripeCustomerId);
  1201→  const creditsRequired = VARIATIONS_CREDIT_COST;
  1202→
  1203→  // Allow if they have at least 1 credit (we'll charge overage for the rest)
  1204→  // Or if they're on a paid tier (overage allowed)
  1205→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';
  1206→
  1207→  return {
  1208→    canGenerate,
  1209→    creditsAvailable: credits.remaining,
  1210→    creditsRequired,
  1211→    tier: credits.tier
  1212→  };
  1213→}
  1214→
  1215→/**
  1216→ * Deduct variations credit from customer (2.5 credits worth)
  1217→ * @param {string} stripeCustomerId - Stripe customer ID
  1218→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}
  1219→ */
  1220→async function deductVariationsCredit(stripeCustomerId) {
  1221→  const client = await pool.connect();
  1222→  try {
  1223→    await client.query('BEGIN');
  1224→
  1225→    // Lock row for update
  1226→    const result = await client.query(
  1227→      `SELECT music_credits_remaining, tier
  1228→       FROM users
  1229→       WHERE stripe_customer_id = $1
  1230→       FOR UPDATE`,
  1231→      [stripeCustomerId]
  1232→    );
  1233→
  1234→    if (result.rows.length === 0) {
  1235→      await client.query('ROLLBACK');
  1236→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };
  1237→    }
  1238→
  1239→    const { music_credits_remaining, tier } = result.rows[0];
  1240→    let charged = 0;
  1241→    let creditsDeducted = 0;
  1242→
  1243→    // Determine how many credits to deduct vs overage to charge
  1244→    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {
  1245→      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)
  1246→      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);
  1247→      await client.query(
  1248→        `UPDATE users
  1249→         SET music_credits_remaining = music_credits_remaining - $2,
  1250→             updated_at = CURRENT_TIMESTAMP
  1251→         WHERE stripe_customer_id = $1`,
  1252→        [stripeCustomerId, creditsDeducted]
  1253→      );
  1254→    } else if (music_credits_remaining > 0) {
  1255→      // Partial credits - deduct what they have and charge overage for the rest
  1256→      const creditsPortion = music_credits_remaining;
  1257→      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;
  1258→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;
  1259→      charged = overagePortion * overageRate;
  1260→
  1261→      creditsDeducted = creditsPortion;
  1262→      await client.query(
  1263→        `UPDATE users
  1264→         SET music_credits_remaining = 0,
  1265→             updated_at = CURRENT_TIMESTAMP
  1266→         WHERE stripe_customer_id = $1`,
  1267→        [stripeCustomerId]
  1268→      );
  1269→
  1270→      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);
  1271→    } else {
  1272→      // No credits - full overage
  1273→      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;
  1274→      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);
  1275→    }
  1276→
  1277→    // Log the usage
  1278→    await client.query(
  1279→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)
  1280→       VALUES ($1, $2, $3)
  1281→       ON CONFLICT DO NOTHING`,
  1282→      [stripeCustomerId, creditsDeducted, charged]
  1283→    );
  1284→
  1285→    await client.query('COMMIT');
  1286→
  1287→    const newCredits = await getMusicCredits(stripeCustomerId);
  1288→    return {
  1289→      success: true,
  1290→      remaining: newCredits.remaining,
  1291→      creditsDeducted,
  1292→      charged
  1293→    };
  1294→
  1295→  } catch (err) {
  1296→    await client.query('ROLLBACK');
  1297→    console.error('[SPLICE] Variations credit deduction error:', err.message);
  1298→    return { success: false, remaining: 0, charged: 0, error: err.message };
  1299→  } finally {
  1300→    client.release();
  1301→  }
  1302→}
  1303→
  1304→/**
  1305→ * Check if customer has enough credits for scene-aware music (1.5 credits)
  1306→ * @param {string} stripeCustomerId - Stripe customer ID
  1307→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}
  1308→ */
  1309→async function checkSceneAwareCredits(stripeCustomerId) {
  1310→  const credits = await getMusicCredits(stripeCustomerId);
  1311→  const creditsRequired = SCENE_AWARE_CREDIT_COST;
  1312→
  1313→  // Allow if they have at least 1 credit (we'll charge overage for the rest)
  1314→  // Or if they're on a paid tier (overage allowed)
  1315→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';
  1316→
  1317→  return {
  1318→    canGenerate,
  1319→    creditsAvailable: credits.remaining,
  1320→    creditsRequired,
  1321→    tier: credits.tier
  1322→  };
  1323→}
  1324→
  1325→/**
  1326→ * Deduct scene-aware music credit from customer (1.5 credits worth)
  1327→ * @param {string} stripeCustomerId - Stripe customer ID
  1328→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}
  1329→ */
  1330→async function deductSceneAwareCredit(stripeCustomerId) {
  1331→  const client = await pool.connect();
  1332→  try {
  1333→    await client.query('BEGIN');
  1334→
  1335→    // Lock row for update
  1336→    const result = await client.query(
  1337→      `SELECT music_credits_remaining, tier
  1338→       FROM users
  1339→       WHERE stripe_customer_id = $1
  1340→       FOR UPDATE`,
  1341→      [stripeCustomerId]
  1342→    );
  1343→
  1344→    if (result.rows.length === 0) {
  1345→      await client.query('ROLLBACK');
  1346→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };
  1347→    }
  1348→
  1349→    const { music_credits_remaining, tier } = result.rows[0];
  1350→    let charged = 0;
  1351→    let creditsDeducted = 0;
  1352→
  1353→    // Determine how many credits to deduct vs overage to charge
  1354→    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {
  1355→      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)
  1356→      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);
  1357→      await client.query(
  1358→        `UPDATE users
  1359→         SET music_credits_remaining = music_credits_remaining - $2,
  1360→             updated_at = CURRENT_TIMESTAMP
  1361→         WHERE stripe_customer_id = $1`,
  1362→        [stripeCustomerId, creditsDeducted]
  1363→      );
  1364→    } else if (music_credits_remaining > 0) {
  1365→      // Partial credits - deduct what they have and charge overage for the rest
  1366→      const creditsPortion = music_credits_remaining;
  1367→      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;
  1368→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;
  1369→      charged = overagePortion * overageRate;
  1370→
  1371→      creditsDeducted = creditsPortion;
  1372→      await client.query(
  1373→        `UPDATE users
  1374→         SET music_credits_remaining = 0,
  1375→             updated_at = CURRENT_TIMESTAMP
  1376→         WHERE stripe_customer_id = $1`,
  1377→        [stripeCustomerId]
  1378→      );
  1379→
  1380→      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);
  1381→    } else {
  1382→      // No credits - full overage
  1383→      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;
  1384→      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);
  1385→    }
  1386→
  1387→    // Log the usage
  1388→    await client.query(
  1389→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)
  1390→       VALUES ($1, $2, $3)
  1391→       ON CONFLICT DO NOTHING`,
  1392→      [stripeCustomerId, creditsDeducted, charged]
  1393→    );
  1394→
  1395→    await client.query('COMMIT');
  1396→
  1397→    const newCredits = await getMusicCredits(stripeCustomerId);
  1398→    return {
  1399→      success: true,
  1400→      remaining: newCredits.remaining,
  1401→      creditsDeducted,
  1402→      charged
  1403→    };
  1404→
  1405→  } catch (err) {
  1406→    await client.query('ROLLBACK');
  1407→    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);
  1408→    return { success: false, remaining: 0, charged: 0, error: err.message };
  1409→  } finally {
  1410→    client.release();
  1411→  }
  1412→}
  1413→
  1414→/**
  1415→ * Close the database connection pool
  1416→ * Used for graceful shutdown
  1417→ */
  1418→async function closePool() {
  1419→  await pool.end();
  1420→}
  1421→
  1422→/**
  1423→ * Update trial end date for a customer
  1424→ * @param {string} stripeCustomerId - Customer ID
  1425→ * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)
  1426→ */
  1427→async function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {
  1428→  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;
  1429→
  1430→  await pool.query(
  1431→    `UPDATE users
  1432→     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP
  1433→     WHERE stripe_customer_id = $1`,
  1434→    [stripeCustomerId, trialEnd]
  1435→  );
  1436→
  1437→  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);
  1438→}
  1439→
  1440→/**
  1441→ * Check database connectivity
  1442→ * Used for health checks
  1443→ */
  1444→async function checkDatabase() {
  1445→  const client = await pool.connect();
  1446→  try {
  1447→    const result = await client.query('SELECT 1 as health');
  1448→    return result.rows[0].health === 1;
  1449→  } finally {
  1450→    client.release();
  1451→  }
  1452→}
  1453→
  1454→module.exports = {
  1455→  initDatabase,
  1456→  getOrCreateUser,
  1457→  customerExists,
  1458→  getBalance,
  1459→  hasCredits,
  1460→  reserveCredits,
  1461→  confirmReservation,
  1462→  releaseReservation,
  1463→  checkIsolationAccess,
  1464→  deductUsage,
  1465→  deductIsolationUsage,
  1466→  resetHours,
  1467→  updateTier,
  1468→  getUsageHistory,
  1469→  isEventProcessed,
  1470→  recordWebhookEvent,
  1471→  // Music credits functions
  1472→  getMusicCredits,
  1473→  hasMusicCredits,
  1474→  deductMusicCredit,
  1475→  resetMusicCredits,
  1476→  addMusicCredits,
  1477→  getMusicUsageHistory,
  1478→  initMusicCreditsColumns,
  1479→  // Variations credits functions
  1480→  checkVariationsCredits,
  1481→  deductVariationsCredit,
  1482→  // Scene-aware credits functions
  1483→  checkSceneAwareCredits,
  1484→  deductSceneAwareCredit,
  1485→  // Pool management
  1486→  closePool,
  1487→  checkDatabase,
  1488→  // Trial management
  1489→  updateTrialEnd,
  1490→  // Constants
  1491→  TIER_HOURS,
  1492→  TIER_ISOLATION_MINUTES,
  1493→  TIER_ISOLATION_HOURS,
  1494→  ISOLATION_OVERAGE_RATE,
  1495→  HOURS_OVERAGE_RATE,
  1496→  TIER_MUSIC_CREDITS,
  1497→  MUSIC_OVERAGE_RATE,
  1498→  MUSIC_OVERAGE_RATES,
  1499→  VARIATIONS_CREDIT_COST,
  1500→  VARIATIONS_OVERAGE_RATES,
  1501→  SCENE_AWARE_CREDIT_COST,
  1502→  SCENE_AWARE_OVERAGE_RATES,
  1503→  // Feature access
  1504→  TIER_FEATURES,
  1505→  hasFeatureAccess
  1506→};
  1507→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
