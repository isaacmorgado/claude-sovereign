{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","type":"user","message":{"role":"user","content":"Perform an end-to-end audit of the tier-based feature gating implementation in SPLICE. This is a re-audit after fixes were applied.\n\nValidate the following requirements:\n\n## Backend Requirements\n1. TIER_FEATURES map exists with proper feature definitions for each tier (starter, pro, team) in usageTracking.js\n2. hasFeatureAccess(tier, feature) function correctly checks feature access and is exported\n3. /credits endpoint includes featureAccess array in response\n4. requireFeature middleware exists in rateLimiter.js and is exported\n5. requireFeature is imported in server.js and added to routeOptions.middleware\n\n## Route Enforcement - CRITICAL\n6. reframe.js routes destructure requireFeature from options.middleware\n7. All reframe.js POST endpoints use requireFeature('social_reframe') middleware AFTER requireCredits\n8. textEdit.js routes destructure requireFeature from options.middleware  \n9. All textEdit.js POST endpoints use requireFeature('text_editing') middleware AFTER requireCredits\n10. multitrack.js routes destructure requireFeature from options.middleware\n11. All multitrack.js POST endpoints use requireFeature('multitrack') middleware AFTER requireCredits\n\n## Security Requirements\n12. requireFeature middleware returns 403 with proper error message when access denied\n13. requireFeature middleware releases reserved credits when access is denied\n14. Feature gating is now enforced on BACKEND (not just frontend)\n\nReport each requirement as PASS/FAIL with specific file:line references."},"uuid":"ec142c9c-ded6-48b9-8e3f-54e58f8b803b","timestamp":"2025-12-29T04:07:33.987Z"}
{"parentUuid":"ec142c9c-ded6-48b9-8e3f-54e58f8b803b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TE1QD2g1ndnZzWZ3SChAXR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BGGknLcodNVyxcRuMQBdVv","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":28934,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":28934,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWaKWMoKc2PuVGDrqFCy9","type":"assistant","uuid":"fe353542-a934-44ab-8a61-0422a39b065e","timestamp":"2025-12-29T04:07:38.546Z"}
{"parentUuid":"fe353542-a934-44ab-8a61-0422a39b065e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TE1QD2g1ndnZzWZ3SChAXR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CZ6Y9hAV1WhLaAGFPMJ8eq","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":28934,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":28934,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWaKWMoKc2PuVGDrqFCy9","type":"assistant","uuid":"7c3f2635-e68e-4fa6-ab1b-b004adc4ca9d","timestamp":"2025-12-29T04:07:39.320Z"}
{"parentUuid":"7c3f2635-e68e-4fa6-ab1b-b004adc4ca9d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TE1QD2g1ndnZzWZ3SChAXR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017hW2jTmW3w7XFQVbWsJR6H","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":28934,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":28934,"ephemeral_1h_input_tokens":0},"output_tokens":183,"service_tier":"standard"}},"requestId":"req_011CWaKWMoKc2PuVGDrqFCy9","type":"assistant","uuid":"fdc9ed01-6e90-4c74-b54e-7a1256409699","timestamp":"2025-12-29T04:07:39.714Z"}
{"parentUuid":"fdc9ed01-6e90-4c74-b54e-7a1256409699","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CZ6Y9hAV1WhLaAGFPMJ8eq","type":"tool_result","content":"     1→/**\n     2→ * Rate Limiter Middleware\n     3→ *\n     4→ * Checks if user has sufficient credits before processing.\n     5→ * Uses atomic credit reservation to prevent race conditions.\n     6→ * Returns 402 Payment Required if insufficient credits.\n     7→ *\n     8→ * SECURITY: Uses JWT authentication via authenticateToken middleware.\n     9→ * Legacy x-stripe-customer-id header is DISABLED in production for security.\n    10→ */\n    11→\n    12→const {\n    13→  deductUsage,\n    14→  getBalance,\n    15→  reserveCredits,\n    16→  confirmReservation,\n    17→  releaseReservation,\n    18→  customerExists,\n    19→  hasFeatureAccess\n    20→} = require('../services/usageTracking');\n    21→const { verifyToken, extractBearerToken } = require('./auth');\n    22→\n    23→// SECURITY: Disable legacy auth in production unless explicitly enabled\n    24→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    25→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n    26→\n    27→// =============================================================================\n    28→// IP-based Rate Limiting\n    29→// =============================================================================\n    30→\n    31→// General rate limiting per IP\n    32→const ipRequestCounts = new Map(); // IP -> { count, windowStart }\n    33→const IP_RATE_LIMIT_WINDOW_MS = 60000; // 1 minute window\n    34→const IP_RATE_LIMIT_MAX_REQUESTS = 100; // 100 requests per minute per IP\n    35→\n    36→// Cleanup old entries every 5 minutes to prevent memory leaks\n    37→setInterval(() => {\n    38→  const now = Date.now();\n    39→  for (const [ip, data] of ipRequestCounts.entries()) {\n    40→    if (now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS * 2) {\n    41→      ipRequestCounts.delete(ip);\n    42→    }\n    43→  }\n    44→}, 300000);\n    45→\n    46→/**\n    47→ * Check if IP is rate limited\n    48→ * @param {string} ip - Client IP address\n    49→ * @returns {boolean} True if rate limited\n    50→ */\n    51→function isIpRateLimited(ip) {\n    52→  const now = Date.now();\n    53→  const data = ipRequestCounts.get(ip);\n    54→\n    55→  if (!data || now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS) {\n    56→    // Start new window\n    57→    ipRequestCounts.set(ip, { count: 1, windowStart: now });\n    58→    return false;\n    59→  }\n    60→\n    61→  data.count++;\n    62→  if (data.count > IP_RATE_LIMIT_MAX_REQUESTS) {\n    63→    return true;\n    64→  }\n    65→\n    66→  return false;\n    67→}\n    68→\n    69→/**\n    70→ * IP-based rate limiting middleware\n    71→ * Limits requests per IP to prevent abuse\n    72→ */\n    73→function ipRateLimit(req, res, next) {\n    74→  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n    75→\n    76→  if (isIpRateLimited(clientIp)) {\n    77→    console.warn(`[SECURITY] IP rate limit exceeded for: ${clientIp}`);\n    78→    return res.status(429).json({\n    79→      error: 'Too many requests',\n    80→      message: 'Please slow down and try again later',\n    81→      retryAfter: 60\n    82→    });\n    83→  }\n    84→\n    85→  next();\n    86→}\n    87→\n    88→// Rate limiting for legacy auth attempts (prevent brute force)\n    89→const legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\n    90→const LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\n    91→const LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n    92→\n    93→/**\n    94→ * Check if IP is rate limited for legacy auth\n    95→ */\n    96→function isLegacyAuthRateLimited(ip) {\n    97→  const now = Date.now();\n    98→  const attempt = legacyAuthAttempts.get(ip);\n    99→\n   100→  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n   101→    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n   102→    return false;\n   103→  }\n   104→\n   105→  attempt.count++;\n   106→  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n   107→    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n   108→    return true;\n   109→  }\n   110→\n   111→  return false;\n   112→}\n   113→\n   114→// Default estimated duration for reservation (1 minute = 60 seconds)\n   115→const DEFAULT_RESERVATION_SECONDS = 60;\n   116→\n   117→/**\n   118→ * Middleware to check and atomically reserve credits before processing\n   119→ *\n   120→ * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n   121→ * Falls back to legacy x-stripe-customer-id header (deprecated)\n   122→ *\n   123→ * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n   124→ *\n   125→ * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n   126→ * where multiple concurrent requests could all pass credit check.\n   127→ */\n   128→function requireCredits(options = {}) {\n   129→  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n   130→\n   131→  return async (req, res, next) => {\n   132→    // SECURITY: Primary auth via JWT token\n   133→    const authHeader = req.headers['authorization'];\n   134→    const token = extractBearerToken(authHeader);\n   135→\n   136→    let stripeCustomerId = null;\n   137→\n   138→    if (token) {\n   139→      const decoded = verifyToken(token);\n   140→      if (decoded && decoded.sub) {\n   141→        stripeCustomerId = decoded.sub;\n   142→        req.tokenData = decoded;\n   143→      } else {\n   144→        // Token present but invalid\n   145→        return res.status(401).json({\n   146→          error: 'Invalid or expired token',\n   147→          message: 'Please log in again to continue'\n   148→        });\n   149→      }\n   150→    } else {\n   151→      // DEPRECATED: Fallback to legacy header\n   152→      const legacyId = req.headers['x-stripe-customer-id'];\n   153→      if (legacyId) {\n   154→        // SECURITY: Block legacy auth in production unless explicitly enabled\n   155→        if (isProduction && !ALLOW_LEGACY_AUTH) {\n   156→          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n   157→          return res.status(401).json({\n   158→            error: 'Authentication method not supported',\n   159→            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n   160→          });\n   161→        }\n   162→\n   163→        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n   164→        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n   165→        if (isLegacyAuthRateLimited(clientIp)) {\n   166→          return res.status(429).json({\n   167→            error: 'Too many authentication attempts',\n   168→            message: 'Please wait before trying again'\n   169→          });\n   170→        }\n   171→\n   172→        // Validate format to prevent injection\n   173→        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n   174→          return res.status(401).json({\n   175→            error: 'Invalid customer ID format',\n   176→            message: 'Customer ID must be a valid Stripe customer ID'\n   177→          });\n   178→        }\n   179→\n   180→        // SECURITY: Verify customer exists in database before accepting\n   181→        const exists = await customerExists(legacyId);\n   182→        if (!exists) {\n   183→          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n   184→          return res.status(401).json({\n   185→            error: 'Invalid customer ID',\n   186→            message: 'Customer not found'\n   187→          });\n   188→        }\n   189→\n   190→        stripeCustomerId = legacyId;\n   191→        req.isLegacyAuth = true;\n   192→        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n   193→      }\n   194→    }\n   195→\n   196→    if (!stripeCustomerId) {\n   197→      return res.status(401).json({\n   198→        error: 'Authentication required',\n   199→        message: 'Missing Stripe customer ID'\n   200→      });\n   201→    }\n   202→\n   203→    // Store for later use\n   204→    req.stripeCustomerId = stripeCustomerId;\n   205→\n   206→    // Determine estimated duration - use request value, option value, or default\n   207→    const estSeconds = req.estimatedDuration || estimatedSeconds;\n   208→\n   209→    try {\n   210→      // Atomically reserve credits using SELECT...FOR UPDATE\n   211→      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n   212→\n   213→      if (!reservation.success) {\n   214→        // Reservation failed - not enough credits\n   215→        const balance = await getBalance(stripeCustomerId);\n   216→        return res.status(402).json({\n   217→          error: 'Insufficient credits',\n   218→          message: 'Please upgrade your plan or wait for your next billing cycle',\n   219→          balance: {\n   220→            hoursRemaining: balance.hoursRemaining,\n   221→            tier: balance.tier\n   222→          }\n   223→        });\n   224→      }\n   225→\n   226→      // Store reservation info for confirmation/release\n   227→      req.reservation = {\n   228→        id: reservation.reservationId,\n   229→        seconds: estSeconds,\n   230→        hoursReserved: reservation.hoursReserved\n   231→      };\n   232→\n   233→      // Attach helper function to confirm usage with actual duration\n   234→      // This adjusts the reservation if actual duration differs\n   235→      req.deductUsage = async (actualDurationSeconds) => {\n   236→        return await confirmReservation(\n   237→          stripeCustomerId,\n   238→          actualDurationSeconds,\n   239→          estSeconds,\n   240→          endpoint\n   241→        );\n   242→      };\n   243→\n   244→      // Attach helper function to release reservation on failure\n   245→      req.releaseReservation = async (reason = 'processing_failed') => {\n   246→        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n   247→      };\n   248→\n   249→      // Hook into response to auto-release on error responses\n   250→      const originalSend = res.send.bind(res);\n   251→      res.send = function(body) {\n   252→        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n   253→        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n   254→          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n   255→            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n   256→        }\n   257→        return originalSend(body);\n   258→      };\n   259→\n   260→      next();\n   261→    } catch (err) {\n   262→      console.error('[RateLimiter] Error reserving credits:', err);\n   263→      return res.status(500).json({\n   264→        error: 'Credit check failed',\n   265→        message: err.message\n   266→      });\n   267→    }\n   268→  };\n   269→}\n   270→\n   271→/**\n   272→ * Middleware to enforce tier-based feature access\n   273→ *\n   274→ * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n   275→ * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n   276→ *\n   277→ * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n   278→ */\n   279→function requireFeature(featureName) {\n   280→  return async (req, res, next) => {\n   281→    // Must have stripeCustomerId from requireCredits middleware\n   282→    if (!req.stripeCustomerId) {\n   283→      return res.status(401).json({\n   284→        error: 'Authentication required',\n   285→        message: 'Please log in to access this feature'\n   286→      });\n   287→    }\n   288→\n   289→    try {\n   290→      // Get user's current balance (includes tier info)\n   291→      const balance = await getBalance(req.stripeCustomerId);\n   292→\n   293→      // Check if user's tier has access to this feature\n   294→      if (!hasFeatureAccess(balance.tier, featureName)) {\n   295→        // Release any reserved credits since we're blocking the request\n   296→        if (req.releaseReservation) {\n   297→          await req.releaseReservation('feature_not_available');\n   298→        }\n   299→\n   300→        // Determine required tier for helpful error message\n   301→        const requiredTier = getRequiredTierForFeature(featureName);\n   302→\n   303→        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n   304→\n   305→        return res.status(403).json({\n   306→          error: 'Feature not available',\n   307→          message: `This feature requires a ${requiredTier} plan or higher`,\n   308→          requiredFeature: featureName,\n   309→          requiredTier: requiredTier,\n   310→          currentTier: balance.tier\n   311→        });\n   312→      }\n   313→\n   314→      // Feature access granted\n   315→      next();\n   316→    } catch (err) {\n   317→      console.error('[requireFeature] Error checking feature access:', err);\n   318→      return res.status(500).json({\n   319→        error: 'Feature access check failed',\n   320→        message: err.message\n   321→      });\n   322→    }\n   323→  };\n   324→}\n   325→\n   326→/**\n   327→ * Helper to determine required tier for a feature\n   328→ * Used for helpful error messages\n   329→ */\n   330→function getRequiredTierForFeature(featureName) {\n   331→  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n   332→  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n   333→\n   334→  if (teamOnlyFeatures.includes(featureName)) {\n   335→    return 'Team';\n   336→  } else if (proFeatures.includes(featureName)) {\n   337→    return 'Pro';\n   338→  }\n   339→  return 'Starter';\n   340→}\n   341→\n   342→/**\n   343→ * Middleware to track usage after successful response\n   344→ *\n   345→ * Call this after processing to deduct actual usage\n   346→ */\n   347→function trackUsage(endpoint = 'unknown') {\n   348→  return async (req, res, next) => {\n   349→    // Store original json method\n   350→    const originalJson = res.json.bind(res);\n   351→\n   352→    // Override json to track usage on success\n   353→    res.json = async (data) => {\n   354→      // Only deduct on successful responses\n   355→      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n   356→        try {\n   357→          const balance = await deductUsage(\n   358→            req.stripeCustomerId,\n   359→            req.audioDuration,\n   360→            endpoint\n   361→          );\n   362→          // Attach updated balance to response\n   363→          data.balance = balance;\n   364→        } catch (err) {\n   365→          console.error('[RateLimiter] Error deducting usage:', err);\n   366→        }\n   367→      }\n   368→      return originalJson(data);\n   369→    };\n   370→\n   371→    next();\n   372→  };\n   373→}\n   374→\n   375→module.exports = {\n   376→  requireCredits,\n   377→  requireFeature,\n   378→  trackUsage,\n   379→  ipRateLimit\n   380→};\n   381→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"67a8abad-6520-425c-b2b8-ed58c47bd39f","timestamp":"2025-12-29T04:07:39.765Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js","content":"/**\n * Rate Limiter Middleware\n *\n * Checks if user has sufficient credits before processing.\n * Uses atomic credit reservation to prevent race conditions.\n * Returns 402 Payment Required if insufficient credits.\n *\n * SECURITY: Uses JWT authentication via authenticateToken middleware.\n * Legacy x-stripe-customer-id header is DISABLED in production for security.\n */\n\nconst {\n  deductUsage,\n  getBalance,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  customerExists,\n  hasFeatureAccess\n} = require('../services/usageTracking');\nconst { verifyToken, extractBearerToken } = require('./auth');\n\n// SECURITY: Disable legacy auth in production unless explicitly enabled\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true';\n\n// =============================================================================\n// IP-based Rate Limiting\n// =============================================================================\n\n// General rate limiting per IP\nconst ipRequestCounts = new Map(); // IP -> { count, windowStart }\nconst IP_RATE_LIMIT_WINDOW_MS = 60000; // 1 minute window\nconst IP_RATE_LIMIT_MAX_REQUESTS = 100; // 100 requests per minute per IP\n\n// Cleanup old entries every 5 minutes to prevent memory leaks\nsetInterval(() => {\n  const now = Date.now();\n  for (const [ip, data] of ipRequestCounts.entries()) {\n    if (now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS * 2) {\n      ipRequestCounts.delete(ip);\n    }\n  }\n}, 300000);\n\n/**\n * Check if IP is rate limited\n * @param {string} ip - Client IP address\n * @returns {boolean} True if rate limited\n */\nfunction isIpRateLimited(ip) {\n  const now = Date.now();\n  const data = ipRequestCounts.get(ip);\n\n  if (!data || now - data.windowStart > IP_RATE_LIMIT_WINDOW_MS) {\n    // Start new window\n    ipRequestCounts.set(ip, { count: 1, windowStart: now });\n    return false;\n  }\n\n  data.count++;\n  if (data.count > IP_RATE_LIMIT_MAX_REQUESTS) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * IP-based rate limiting middleware\n * Limits requests per IP to prevent abuse\n */\nfunction ipRateLimit(req, res, next) {\n  const clientIp = req.ip || req.headers['x-forwarded-for']?.split(',')[0] || req.connection?.remoteAddress || 'unknown';\n\n  if (isIpRateLimited(clientIp)) {\n    console.warn(`[SECURITY] IP rate limit exceeded for: ${clientIp}`);\n    return res.status(429).json({\n      error: 'Too many requests',\n      message: 'Please slow down and try again later',\n      retryAfter: 60\n    });\n  }\n\n  next();\n}\n\n// Rate limiting for legacy auth attempts (prevent brute force)\nconst legacyAuthAttempts = new Map(); // IP -> { count, timestamp }\nconst LEGACY_AUTH_WINDOW_MS = 60000; // 1 minute\nconst LEGACY_AUTH_MAX_ATTEMPTS = 5; // 5 attempts per minute\n\n/**\n * Check if IP is rate limited for legacy auth\n */\nfunction isLegacyAuthRateLimited(ip) {\n  const now = Date.now();\n  const attempt = legacyAuthAttempts.get(ip);\n\n  if (!attempt || (now - attempt.timestamp) > LEGACY_AUTH_WINDOW_MS) {\n    legacyAuthAttempts.set(ip, { count: 1, timestamp: now });\n    return false;\n  }\n\n  attempt.count++;\n  if (attempt.count > LEGACY_AUTH_MAX_ATTEMPTS) {\n    console.warn(`[SECURITY] Legacy auth rate limit exceeded for IP: ${ip}`);\n    return true;\n  }\n\n  return false;\n}\n\n// Default estimated duration for reservation (1 minute = 60 seconds)\nconst DEFAULT_RESERVATION_SECONDS = 60;\n\n/**\n * Middleware to check and atomically reserve credits before processing\n *\n * SECURITY: Authenticates via JWT token (Authorization: Bearer <token>)\n * Falls back to legacy x-stripe-customer-id header (deprecated)\n *\n * Uses req.estimatedDuration (in seconds) for pre-check, defaults to 60s\n *\n * This middleware uses SELECT...FOR UPDATE to prevent race conditions\n * where multiple concurrent requests could all pass credit check.\n */\nfunction requireCredits(options = {}) {\n  const { endpoint = 'unknown', estimatedSeconds = DEFAULT_RESERVATION_SECONDS } = options;\n\n  return async (req, res, next) => {\n    // SECURITY: Primary auth via JWT token\n    const authHeader = req.headers['authorization'];\n    const token = extractBearerToken(authHeader);\n\n    let stripeCustomerId = null;\n\n    if (token) {\n      const decoded = verifyToken(token);\n      if (decoded && decoded.sub) {\n        stripeCustomerId = decoded.sub;\n        req.tokenData = decoded;\n      } else {\n        // Token present but invalid\n        return res.status(401).json({\n          error: 'Invalid or expired token',\n          message: 'Please log in again to continue'\n        });\n      }\n    } else {\n      // DEPRECATED: Fallback to legacy header\n      const legacyId = req.headers['x-stripe-customer-id'];\n      if (legacyId) {\n        // SECURITY: Block legacy auth in production unless explicitly enabled\n        if (isProduction && !ALLOW_LEGACY_AUTH) {\n          console.warn(`[SECURITY] Legacy auth blocked in production for ${endpoint}`);\n          return res.status(401).json({\n            error: 'Authentication method not supported',\n            message: 'Please use JWT authentication. Legacy header auth is disabled in production.'\n          });\n        }\n\n        // SECURITY: Rate limit legacy auth attempts to prevent brute force\n        const clientIp = req.ip || req.connection?.remoteAddress || 'unknown';\n        if (isLegacyAuthRateLimited(clientIp)) {\n          return res.status(429).json({\n            error: 'Too many authentication attempts',\n            message: 'Please wait before trying again'\n          });\n        }\n\n        // Validate format to prevent injection\n        if (!legacyId.match(/^cus_[a-zA-Z0-9]{14,}$/)) {\n          return res.status(401).json({\n            error: 'Invalid customer ID format',\n            message: 'Customer ID must be a valid Stripe customer ID'\n          });\n        }\n\n        // SECURITY: Verify customer exists in database before accepting\n        const exists = await customerExists(legacyId);\n        if (!exists) {\n          console.warn(`[SECURITY] Legacy auth attempt with non-existent customer: ${legacyId}`);\n          return res.status(401).json({\n            error: 'Invalid customer ID',\n            message: 'Customer not found'\n          });\n        }\n\n        stripeCustomerId = legacyId;\n        req.isLegacyAuth = true;\n        console.warn(`[RateLimiter] DEPRECATED: Legacy auth header used for ${endpoint} - migrate to JWT`);\n      }\n    }\n\n    if (!stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Missing Stripe customer ID'\n      });\n    }\n\n    // Store for later use\n    req.stripeCustomerId = stripeCustomerId;\n\n    // Determine estimated duration - use request value, option value, or default\n    const estSeconds = req.estimatedDuration || estimatedSeconds;\n\n    try {\n      // Atomically reserve credits using SELECT...FOR UPDATE\n      const reservation = await reserveCredits(stripeCustomerId, estSeconds, endpoint);\n\n      if (!reservation.success) {\n        // Reservation failed - not enough credits\n        const balance = await getBalance(stripeCustomerId);\n        return res.status(402).json({\n          error: 'Insufficient credits',\n          message: 'Please upgrade your plan or wait for your next billing cycle',\n          balance: {\n            hoursRemaining: balance.hoursRemaining,\n            tier: balance.tier\n          }\n        });\n      }\n\n      // Store reservation info for confirmation/release\n      req.reservation = {\n        id: reservation.reservationId,\n        seconds: estSeconds,\n        hoursReserved: reservation.hoursReserved\n      };\n\n      // Attach helper function to confirm usage with actual duration\n      // This adjusts the reservation if actual duration differs\n      req.deductUsage = async (actualDurationSeconds) => {\n        return await confirmReservation(\n          stripeCustomerId,\n          actualDurationSeconds,\n          estSeconds,\n          endpoint\n        );\n      };\n\n      // Attach helper function to release reservation on failure\n      req.releaseReservation = async (reason = 'processing_failed') => {\n        return await releaseReservation(stripeCustomerId, estSeconds, endpoint, reason);\n      };\n\n      // Hook into response to auto-release on error responses\n      const originalSend = res.send.bind(res);\n      res.send = function(body) {\n        // If response is an error (4xx/5xx) and no usage was confirmed, release reservation\n        if (res.statusCode >= 400 && req.reservation && !req.usageConfirmed) {\n          releaseReservation(stripeCustomerId, estSeconds, endpoint, `error_${res.statusCode}`)\n            .catch(err => console.error('[RateLimiter] Failed to release reservation:', err));\n        }\n        return originalSend(body);\n      };\n\n      next();\n    } catch (err) {\n      console.error('[RateLimiter] Error reserving credits:', err);\n      return res.status(500).json({\n        error: 'Credit check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Middleware to enforce tier-based feature access\n *\n * SECURITY: Must be called AFTER requireCredits which sets req.stripeCustomerId\n * Returns 403 Forbidden if user's tier doesn't have access to the feature.\n *\n * @param {string} featureName - Feature to check access for (e.g., 'social_reframe', 'text_editing', 'multitrack')\n */\nfunction requireFeature(featureName) {\n  return async (req, res, next) => {\n    // Must have stripeCustomerId from requireCredits middleware\n    if (!req.stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please log in to access this feature'\n      });\n    }\n\n    try {\n      // Get user's current balance (includes tier info)\n      const balance = await getBalance(req.stripeCustomerId);\n\n      // Check if user's tier has access to this feature\n      if (!hasFeatureAccess(balance.tier, featureName)) {\n        // Release any reserved credits since we're blocking the request\n        if (req.releaseReservation) {\n          await req.releaseReservation('feature_not_available');\n        }\n\n        // Determine required tier for helpful error message\n        const requiredTier = getRequiredTierForFeature(featureName);\n\n        console.warn(`[SECURITY] Feature access denied: ${featureName} requires ${requiredTier}, user has ${balance.tier}`);\n\n        return res.status(403).json({\n          error: 'Feature not available',\n          message: `This feature requires a ${requiredTier} plan or higher`,\n          requiredFeature: featureName,\n          requiredTier: requiredTier,\n          currentTier: balance.tier\n        });\n      }\n\n      // Feature access granted\n      next();\n    } catch (err) {\n      console.error('[requireFeature] Error checking feature access:', err);\n      return res.status(500).json({\n        error: 'Feature access check failed',\n        message: err.message\n      });\n    }\n  };\n}\n\n/**\n * Helper to determine required tier for a feature\n * Used for helpful error messages\n */\nfunction getRequiredTierForFeature(featureName) {\n  const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n  const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n\n  if (teamOnlyFeatures.includes(featureName)) {\n    return 'Team';\n  } else if (proFeatures.includes(featureName)) {\n    return 'Pro';\n  }\n  return 'Starter';\n}\n\n/**\n * Middleware to track usage after successful response\n *\n * Call this after processing to deduct actual usage\n */\nfunction trackUsage(endpoint = 'unknown') {\n  return async (req, res, next) => {\n    // Store original json method\n    const originalJson = res.json.bind(res);\n\n    // Override json to track usage on success\n    res.json = async (data) => {\n      // Only deduct on successful responses\n      if (res.statusCode >= 200 && res.statusCode < 300 && req.audioDuration) {\n        try {\n          const balance = await deductUsage(\n            req.stripeCustomerId,\n            req.audioDuration,\n            endpoint\n          );\n          // Attach updated balance to response\n          data.balance = balance;\n        } catch (err) {\n          console.error('[RateLimiter] Error deducting usage:', err);\n        }\n      }\n      return originalJson(data);\n    };\n\n    next();\n  };\n}\n\nmodule.exports = {\n  requireCredits,\n  requireFeature,\n  trackUsage,\n  ipRateLimit\n};\n","numLines":381,"startLine":1,"totalLines":381}}}
{"parentUuid":"67a8abad-6520-425c-b2b8-ed58c47bd39f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BGGknLcodNVyxcRuMQBdVv","type":"tool_result","content":"     1→/**\n     2→ * Usage Tracking Service\n     3→ *\n     4→ * Tracks user credit balances and usage for billing.\n     5→ * Uses PostgreSQL for persistence.\n     6→ */\n     7→\n     8→const { Pool } = require('pg');\n     9→const { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n    10→\n    11→// PostgreSQL connection pool with proper limits\n    12→const pool = new Pool({\n    13→  connectionString: process.env.DATABASE_URL,\n    14→  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    15→  // PERFORMANCE: Set connection pool limits\n    16→  max: 20,                    // Maximum number of clients in the pool\n    17→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n    18→  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n    19→});\n    20→\n    21→// Hours per tier (regular processing)\n    22→// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n    23→// Target margins: 79-82%\n    24→const TIER_HOURS = {\n    25→  starter: 4,    // 4 hrs/month\n    26→  pro: 15,       // 15 hrs/month\n    27→  team: 50,      // 50 hrs/month\n    28→  cancelled: 0\n    29→};\n    30→\n    31→// Overage rate for processing hours beyond included\n    32→const HOURS_OVERAGE_RATE = 2.00; // $2/hour\n    33→\n    34→// Isolation minutes per tier (sized to maintain 80% margins)\n    35→const TIER_ISOLATION_MINUTES = {\n    36→  starter: 0,     // No isolation access\n    37→  pro: 45,        // 45 minutes included\n    38→  team: 180,      // 3 hours included\n    39→  cancelled: 0\n    40→};\n    41→\n    42→// Convert to hours for database storage\n    43→const TIER_ISOLATION_HOURS = {\n    44→  starter: 0,\n    45→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n    46→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n    47→  cancelled: 0\n    48→};\n    49→\n    50→// Overage rate for isolation beyond included minutes\n    51→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n    52→\n    53→/**\n    54→ * Initialize database tables\n    55→ */\n    56→async function initDatabase() {\n    57→  const client = await pool.connect();\n    58→  try {\n    59→    await client.query(`\n    60→      CREATE TABLE IF NOT EXISTS users (\n    61→        id SERIAL PRIMARY KEY,\n    62→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n    63→        email VARCHAR(255),\n    64→        tier VARCHAR(50) DEFAULT 'starter',\n    65→        hours_remaining DECIMAL(10,4) DEFAULT 15,\n    66→        hours_total DECIMAL(10,4) DEFAULT 15,\n    67→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n    68→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n    69→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    70→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    71→      )\n    72→    `);\n    73→\n    74→    // Add isolation columns if they don't exist (for existing databases)\n    75→    await client.query(`\n    76→      DO $$\n    77→      BEGIN\n    78→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n    79→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n    80→        END IF;\n    81→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n    82→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n    83→        END IF;\n    84→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n    85→          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n    86→        END IF;\n    87→      END $$;\n    88→    `);\n    89→\n    90→    await client.query(`\n    91→      CREATE TABLE IF NOT EXISTS usage_log (\n    92→        id SERIAL PRIMARY KEY,\n    93→        user_id INTEGER REFERENCES users(id),\n    94→        stripe_customer_id VARCHAR(255),\n    95→        audio_duration_seconds DECIMAL(10,2),\n    96→        hours_used DECIMAL(10,6),\n    97→        endpoint VARCHAR(100),\n    98→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    99→      )\n   100→    `);\n   101→\n   102→    await client.query(`\n   103→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n   104→    `);\n   105→\n   106→    await client.query(`\n   107→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n   108→    `);\n   109→\n   110→    // PERFORMANCE: Add composite index for efficient customer usage history queries\n   111→    await client.query(`\n   112→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n   113→      ON usage_log(stripe_customer_id, created_at DESC)\n   114→    `);\n   115→\n   116→    // Webhook events table for idempotency\n   117→    await client.query(`\n   118→      CREATE TABLE IF NOT EXISTS webhook_events (\n   119→        id SERIAL PRIMARY KEY,\n   120→        event_id VARCHAR(255) UNIQUE NOT NULL,\n   121→        event_type VARCHAR(100),\n   122→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   123→      )\n   124→    `);\n   125→\n   126→    await client.query(`\n   127→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n   128→    `);\n   129→\n   130→    console.log('[UsageTracking] Database initialized');\n   131→  } finally {\n   132→    client.release();\n   133→  }\n   134→}\n   135→\n   136→/**\n   137→ * Get or create a user by Stripe customer ID\n   138→ * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n   139→ */\n   140→async function getOrCreateUser(stripeCustomerId, email = null) {\n   141→  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n   142→  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n   143→  const result = await pool.query(\n   144→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   145→     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   146→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   147→     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n   148→     RETURNING *`,\n   149→    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n   150→  );\n   151→\n   152→  return result.rows[0];\n   153→}\n   154→\n   155→/**\n   156→ * Check if a customer exists in the database (without creating)\n   157→ * SECURITY: Used to validate legacy auth attempts\n   158→ */\n   159→async function customerExists(stripeCustomerId) {\n   160→  if (!stripeCustomerId) return false;\n   161→\n   162→  try {\n   163→    const result = await pool.query(\n   164→      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n   165→      [stripeCustomerId]\n   166→    );\n   167→    return result.rows.length > 0;\n   168→  } catch (err) {\n   169→    console.error('[SPLICE] customerExists check failed:', err.message);\n   170→    return false;\n   171→  }\n   172→}\n   173→\n   174→/**\n   175→ * Get user's current credit balance\n   176→ */\n   177→async function getBalance(stripeCustomerId) {\n   178→  const user = await getOrCreateUser(stripeCustomerId);\n   179→  const hoursTotal = parseFloat(user.hours_total);\n   180→  const hoursRemaining = parseFloat(user.hours_remaining);\n   181→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   182→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   183→\n   184→  // Tier display names\n   185→  const tierNames = {\n   186→    starter: 'Starter',\n   187→    pro: 'Pro',\n   188→    team: 'Team',\n   189→    cancelled: 'Cancelled'\n   190→  };\n   191→\n   192→  // Calculate trial days remaining\n   193→  let trialDaysRemaining = null;\n   194→  let isOnTrial = false;\n   195→  if (user.trial_end) {\n   196→    const trialEnd = new Date(user.trial_end);\n   197→    const now = new Date();\n   198→    const diffMs = trialEnd.getTime() - now.getTime();\n   199→    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n   200→    if (diffDays > 0) {\n   201→      trialDaysRemaining = diffDays;\n   202→      isOnTrial = true;\n   203→    }\n   204→  }\n   205→\n   206→  return {\n   207→    hoursRemaining,\n   208→    hoursTotal,\n   209→    isolationHoursRemaining,\n   210→    isolationHoursTotal,\n   211→    tier: user.tier,\n   212→    tierName: tierNames[user.tier] || user.tier,\n   213→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   214→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   215→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   216→    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   217→    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n   218→    trialDaysRemaining,\n   219→    isOnTrial\n   220→  };\n   221→}\n   222→\n   223→/**\n   224→ * Check if user has enough credits for estimated duration\n   225→ */\n   226→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n   227→  const balance = await getBalance(stripeCustomerId);\n   228→  const estimatedHours = estimatedSeconds / 3600;\n   229→  return balance.hoursRemaining >= estimatedHours;\n   230→}\n   231→\n   232→/**\n   233→ * Reserve credits atomically using SELECT ... FOR UPDATE\n   234→ * This prevents race conditions where multiple requests pass credit check\n   235→ * before any deduction occurs.\n   236→ *\n   237→ * @param {string} stripeCustomerId - Customer ID\n   238→ * @param {number} estimatedSeconds - Estimated processing time in seconds\n   239→ * @param {string} endpoint - Endpoint name for tracking\n   240→ * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n   241→ */\n   242→async function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n   243→  const estimatedHours = estimatedSeconds / 3600;\n   244→  const client = await pool.connect();\n   245→\n   246→  try {\n   247→    await client.query('BEGIN');\n   248→\n   249→    // Lock the row for this customer - prevents concurrent modifications\n   250→    const result = await client.query(\n   251→      `SELECT id, hours_remaining FROM users\n   252→       WHERE stripe_customer_id = $1\n   253→       FOR UPDATE`,\n   254→      [stripeCustomerId]\n   255→    );\n   256→\n   257→    if (result.rows.length === 0) {\n   258→      // Create user if doesn't exist (within transaction)\n   259→      const newUser = await client.query(\n   260→        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n   261→         VALUES ($1, 'starter', $2, $2)\n   262→         RETURNING id, hours_remaining`,\n   263→        [stripeCustomerId, TIER_HOURS.starter]\n   264→      );\n   265→      result.rows = newUser.rows;\n   266→    }\n   267→\n   268→    const user = result.rows[0];\n   269→    const hoursRemaining = parseFloat(user.hours_remaining);\n   270→\n   271→    // Check if enough credits\n   272→    if (hoursRemaining < estimatedHours) {\n   273→      await client.query('ROLLBACK');\n   274→      return {\n   275→        success: false,\n   276→        error: 'Insufficient credits',\n   277→        hoursRemaining,\n   278→        hoursRequired: estimatedHours\n   279→      };\n   280→    }\n   281→\n   282→    // Generate unique reservation ID\n   283→    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   284→\n   285→    // Reserve credits by deducting the estimated amount\n   286→    await client.query(\n   287→      `UPDATE users\n   288→       SET hours_remaining = hours_remaining - $1,\n   289→           updated_at = CURRENT_TIMESTAMP\n   290→       WHERE stripe_customer_id = $2`,\n   291→      [estimatedHours, stripeCustomerId]\n   292→    );\n   293→\n   294→    // Log the reservation\n   295→    await client.query(\n   296→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   297→       VALUES ($1, $2, $3, $4, $5)`,\n   298→      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n   299→    );\n   300→\n   301→    await client.query('COMMIT');\n   302→\n   303→    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n   304→\n   305→    return {\n   306→      success: true,\n   307→      reservationId,\n   308→      hoursReserved: estimatedHours,\n   309→      hoursRemaining: hoursRemaining - estimatedHours\n   310→    };\n   311→  } catch (err) {\n   312→    await client.query('ROLLBACK');\n   313→    console.error('[UsageTracking] Reservation error:', err);\n   314→    throw err;\n   315→  } finally {\n   316→    client.release();\n   317→  }\n   318→}\n   319→\n   320→/**\n   321→ * Confirm a reservation (finalize usage) or adjust for actual duration\n   322→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   323→ *\n   324→ * @param {string} stripeCustomerId - Customer ID\n   325→ * @param {number} actualSeconds - Actual processing time in seconds\n   326→ * @param {number} reservedSeconds - Originally reserved seconds\n   327→ * @param {string} endpoint - Endpoint name\n   328→ * @returns {Promise<object>} Updated balance\n   329→ */\n   330→async function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n   331→  const actualHours = actualSeconds / 3600;\n   332→  const reservedHours = reservedSeconds / 3600;\n   333→  const difference = reservedHours - actualHours;\n   334→\n   335→  const client = await pool.connect();\n   336→  try {\n   337→    await client.query('BEGIN');\n   338→\n   339→    // Lock the row and get current state\n   340→    const result = await client.query(\n   341→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   342→       FROM users\n   343→       WHERE stripe_customer_id = $1\n   344→       FOR UPDATE`,\n   345→      [stripeCustomerId]\n   346→    );\n   347→\n   348→    if (result.rows.length === 0) {\n   349→      await client.query('ROLLBACK');\n   350→      throw new Error('User not found');\n   351→    }\n   352→\n   353→    let user = result.rows[0];\n   354→\n   355→    // If actual usage was less than reserved, refund the difference\n   356→    if (difference > 0) {\n   357→      const updateResult = await client.query(\n   358→        `UPDATE users\n   359→         SET hours_remaining = hours_remaining + $1,\n   360→             updated_at = CURRENT_TIMESTAMP\n   361→         WHERE stripe_customer_id = $2\n   362→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   363→        [difference, stripeCustomerId]\n   364→      );\n   365→      user = { ...user, ...updateResult.rows[0] };\n   366→\n   367→      // Log the adjustment\n   368→      await client.query(\n   369→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   370→         VALUES ($1, $2, $3, $4, $5)`,\n   371→        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n   372→      );\n   373→    } else if (difference < 0) {\n   374→      // Actual usage was more than reserved - deduct the extra\n   375→      const updateResult = await client.query(\n   376→        `UPDATE users\n   377→         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   378→             updated_at = CURRENT_TIMESTAMP\n   379→         WHERE stripe_customer_id = $2\n   380→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   381→        [-difference, stripeCustomerId]\n   382→      );\n   383→      user = { ...user, ...updateResult.rows[0] };\n   384→\n   385→      // Log the additional usage\n   386→      await client.query(\n   387→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   388→         VALUES ($1, $2, $3, $4, $5)`,\n   389→        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n   390→      );\n   391→    }\n   392→\n   393→    await client.query('COMMIT');\n   394→\n   395→    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n   396→\n   397→    // Build balance from data we already have (no extra SELECT needed)\n   398→    const hoursTotal = parseFloat(user.hours_total);\n   399→    const hoursRemaining = parseFloat(user.hours_remaining);\n   400→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   401→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   402→\n   403→    const tierNames = {\n   404→      starter: 'Starter',\n   405→      pro: 'Pro',\n   406→      team: 'Team',\n   407→      cancelled: 'Cancelled'\n   408→    };\n   409→\n   410→    return {\n   411→      hoursRemaining,\n   412→      hoursTotal,\n   413→      isolationHoursRemaining,\n   414→      isolationHoursTotal,\n   415→      tier: user.tier,\n   416→      tierName: tierNames[user.tier] || user.tier,\n   417→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   418→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   419→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   420→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   421→    };\n   422→  } catch (err) {\n   423→    await client.query('ROLLBACK');\n   424→    throw err;\n   425→  } finally {\n   426→    client.release();\n   427→  }\n   428→}\n   429→\n   430→/**\n   431→ * Release a reservation (refund credits on processing failure)\n   432→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   433→ *\n   434→ * @param {string} stripeCustomerId - Customer ID\n   435→ * @param {number} reservedSeconds - Originally reserved seconds\n   436→ * @param {string} endpoint - Endpoint name\n   437→ * @param {string} reason - Reason for release\n   438→ * @returns {Promise<object>} Updated balance\n   439→ */\n   440→async function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n   441→  const reservedHours = reservedSeconds / 3600;\n   442→\n   443→  const client = await pool.connect();\n   444→  try {\n   445→    await client.query('BEGIN');\n   446→\n   447→    // Lock the row and get id for logging\n   448→    const result = await client.query(\n   449→      `SELECT id FROM users\n   450→       WHERE stripe_customer_id = $1\n   451→       FOR UPDATE`,\n   452→      [stripeCustomerId]\n   453→    );\n   454→\n   455→    if (result.rows.length === 0) {\n   456→      await client.query('ROLLBACK');\n   457→      throw new Error('User not found');\n   458→    }\n   459→\n   460→    const userId = result.rows[0].id;\n   461→\n   462→    // Refund the reserved amount with RETURNING\n   463→    const updateResult = await client.query(\n   464→      `UPDATE users\n   465→       SET hours_remaining = hours_remaining + $1,\n   466→           updated_at = CURRENT_TIMESTAMP\n   467→       WHERE stripe_customer_id = $2\n   468→       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   469→      [reservedHours, stripeCustomerId]\n   470→    );\n   471→\n   472→    const user = updateResult.rows[0];\n   473→\n   474→    // Log the refund\n   475→    await client.query(\n   476→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   477→       VALUES ($1, $2, $3, $4, $5)`,\n   478→      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n   479→    );\n   480→\n   481→    await client.query('COMMIT');\n   482→\n   483→    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n   484→\n   485→    // Build balance from RETURNING data (no extra SELECT needed)\n   486→    const hoursTotal = parseFloat(user.hours_total);\n   487→    const hoursRemaining = parseFloat(user.hours_remaining);\n   488→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   489→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   490→\n   491→    const tierNames = {\n   492→      starter: 'Starter',\n   493→      pro: 'Pro',\n   494→      team: 'Team',\n   495→      cancelled: 'Cancelled'\n   496→    };\n   497→\n   498→    return {\n   499→      hoursRemaining,\n   500→      hoursTotal,\n   501→      isolationHoursRemaining,\n   502→      isolationHoursTotal,\n   503→      tier: user.tier,\n   504→      tierName: tierNames[user.tier] || user.tier,\n   505→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   506→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   507→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   508→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   509→    };\n   510→  } catch (err) {\n   511→    await client.query('ROLLBACK');\n   512→    throw err;\n   513→  } finally {\n   514→    client.release();\n   515→  }\n   516→}\n   517→\n   518→/**\n   519→ * Check if user can use vocal isolation\n   520→ * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n   521→ */\n   522→async function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n   523→  const balance = await getBalance(stripeCustomerId);\n   524→\n   525→  // Starter tier has no isolation access\n   526→  if (!balance.hasIsolationAccess) {\n   527→    return {\n   528→      allowed: false,\n   529→      reason: 'upgrade_required',\n   530→      message: 'Vocal isolation requires Pro or Team tier',\n   531→      hasIncludedHours: false,\n   532→      overageRequired: false,\n   533→      overageCost: 0\n   534→    };\n   535→  }\n   536→\n   537→  const estimatedHours = estimatedMinutes / 60;\n   538→  const remainingIncluded = balance.isolationHoursRemaining;\n   539→\n   540→  // Check if within included hours\n   541→  if (remainingIncluded >= estimatedHours) {\n   542→    return {\n   543→      allowed: true,\n   544→      reason: 'included',\n   545→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   546→      hasIncludedHours: true,\n   547→      overageRequired: false,\n   548→      overageCost: 0,\n   549→      isolationHoursRemaining: remainingIncluded - estimatedHours\n   550→    };\n   551→  }\n   552→\n   553→  // Calculate overage\n   554→  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n   555→  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   556→\n   557→  return {\n   558→    allowed: true,\n   559→    reason: 'overage',\n   560→    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n   561→    hasIncludedHours: remainingIncluded > 0,\n   562→    overageRequired: true,\n   563→    overageMinutes,\n   564→    overageCost,\n   565→    isolationHoursRemaining: 0\n   566→  };\n   567→}\n   568→\n   569→/**\n   570→ * Deduct isolation usage from user's balance\n   571→ * Returns overage cost if beyond included hours\n   572→ * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n   573→ */\n   574→async function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n   575→  const durationMinutes = audioDurationSeconds / 60;\n   576→  const durationHours = audioDurationSeconds / 3600;\n   577→\n   578→  const client = await pool.connect();\n   579→  try {\n   580→    await client.query('BEGIN');\n   581→\n   582→    // Lock the row for this customer - prevents concurrent modifications\n   583→    const userResult = await client.query(\n   584→      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n   585→       FROM users WHERE stripe_customer_id = $1\n   586→       FOR UPDATE`,\n   587→      [stripeCustomerId]\n   588→    );\n   589→\n   590→    if (userResult.rows.length === 0) {\n   591→      await client.query('ROLLBACK');\n   592→      throw new Error('User not found');\n   593→    }\n   594→\n   595→    const user = userResult.rows[0];\n   596→    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n   597→\n   598→    let overageCost = 0;\n   599→    let hoursFromIncluded = 0;\n   600→    let overageMinutes = 0;\n   601→\n   602→    if (remainingIncluded >= durationHours) {\n   603→      // Fully covered by included hours\n   604→      hoursFromIncluded = durationHours;\n   605→    } else {\n   606→      // Partial or full overage\n   607→      hoursFromIncluded = remainingIncluded;\n   608→      overageMinutes = durationMinutes - (remainingIncluded * 60);\n   609→      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   610→    }\n   611→\n   612→    // Update isolation balance with RETURNING to get new values\n   613→    const updateResult = await client.query(\n   614→      `UPDATE users\n   615→       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n   616→           updated_at = CURRENT_TIMESTAMP\n   617→       WHERE stripe_customer_id = $2\n   618→       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n   619→      [durationHours, stripeCustomerId]\n   620→    );\n   621→\n   622→    const updatedUser = updateResult.rows[0];\n   623→\n   624→    // Log usage (mark as isolation)\n   625→    await client.query(\n   626→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   627→       VALUES ($1, $2, $3, $4, $5)`,\n   628→      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n   629→    );\n   630→\n   631→    await client.query('COMMIT');\n   632→\n   633→    // Build balance from RETURNING data (no extra SELECT needed)\n   634→    const hoursTotal = parseFloat(updatedUser.hours_total);\n   635→    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n   636→    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n   637→    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n   638→\n   639→    const tierNames = {\n   640→      starter: 'Starter',\n   641→      pro: 'Pro',\n   642→      team: 'Team',\n   643→      cancelled: 'Cancelled'\n   644→    };\n   645→\n   646→    return {\n   647→      hoursRemaining,\n   648→      hoursTotal,\n   649→      isolationHoursRemaining,\n   650→      isolationHoursTotal,\n   651→      tier: updatedUser.tier,\n   652→      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n   653→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   654→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   655→      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n   656→      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   657→      isolationUsed: {\n   658→        durationMinutes,\n   659→        hoursFromIncluded,\n   660→        overageMinutes,\n   661→        overageCost\n   662→      }\n   663→    };\n   664→  } catch (err) {\n   665→    await client.query('ROLLBACK');\n   666→    throw err;\n   667→  } finally {\n   668→    client.release();\n   669→  }\n   670→}\n   671→\n   672→/**\n   673→ * Deduct usage from user's balance\n   674→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   675→ * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n   676→ * Reports overage to Stripe for billing when user exceeds included hours\n   677→ */\n   678→async function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n   679→  const hoursUsed = audioDurationSeconds / 3600;\n   680→\n   681→  const client = await pool.connect();\n   682→  try {\n   683→    await client.query('BEGIN');\n   684→\n   685→    // First get current balance to calculate overage\n   686→    const currentResult = await client.query(\n   687→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   688→       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n   689→      [stripeCustomerId]\n   690→    );\n   691→\n   692→    if (currentResult.rows.length === 0) {\n   693→      await client.query('ROLLBACK');\n   694→      throw new Error('User not found');\n   695→    }\n   696→\n   697→    const currentUser = currentResult.rows[0];\n   698→    const currentRemaining = parseFloat(currentUser.hours_remaining);\n   699→\n   700→    // Calculate overage (hours used beyond what's remaining)\n   701→    let overageHours = 0;\n   702→    if (hoursUsed > currentRemaining) {\n   703→      overageHours = hoursUsed - currentRemaining;\n   704→    }\n   705→\n   706→    // Update balance (clamp at 0)\n   707→    const updateResult = await client.query(\n   708→      `UPDATE users\n   709→       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   710→           updated_at = CURRENT_TIMESTAMP\n   711→       WHERE stripe_customer_id = $2\n   712→       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   713→      [hoursUsed, stripeCustomerId]\n   714→    );\n   715→\n   716→    const user = updateResult.rows[0];\n   717→\n   718→    // Log usage\n   719→    await client.query(\n   720→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   721→       VALUES ($1, $2, $3, $4, $5)`,\n   722→      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n   723→    );\n   724→\n   725→    await client.query('COMMIT');\n   726→\n   727→    // Report overage to Stripe if any (after commit to not block transaction)\n   728→    let overageCharge = 0;\n   729→    if (overageHours > 0) {\n   730→      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n   731→      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n   732→      if (usageReport.success) {\n   733→        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n   734→      } else {\n   735→        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n   736→      }\n   737→    }\n   738→\n   739→    // Build balance from RETURNING data (no extra SELECT needed)\n   740→    const hoursTotal = parseFloat(user.hours_total);\n   741→    const hoursRemaining = parseFloat(user.hours_remaining);\n   742→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   743→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   744→\n   745→    const tierNames = {\n   746→      starter: 'Starter',\n   747→      pro: 'Pro',\n   748→      team: 'Team',\n   749→      cancelled: 'Cancelled'\n   750→    };\n   751→\n   752→    return {\n   753→      hoursRemaining,\n   754→      hoursTotal,\n   755→      isolationHoursRemaining,\n   756→      isolationHoursTotal,\n   757→      tier: user.tier,\n   758→      tierName: tierNames[user.tier] || user.tier,\n   759→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   760→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   761→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   762→      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   763→      overageHours,\n   764→      overageCharge\n   765→    };\n   766→  } catch (err) {\n   767→    await client.query('ROLLBACK');\n   768→    throw err;\n   769→  } finally {\n   770→    client.release();\n   771→  }\n   772→}\n   773→\n   774→/**\n   775→ * Reset user's hours for new billing period\n   776→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   777→ */\n   778→async function resetHours(stripeCustomerId, tier) {\n   779→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   780→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   781→\n   782→  const result = await pool.query(\n   783→    `UPDATE users\n   784→     SET hours_remaining = $1, hours_total = $1,\n   785→         isolation_hours_remaining = $2, isolation_hours_total = $2,\n   786→         tier = $3, updated_at = CURRENT_TIMESTAMP\n   787→     WHERE stripe_customer_id = $4\n   788→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   789→    [hours, isolationHours, tier, stripeCustomerId]\n   790→  );\n   791→\n   792→  if (result.rows.length === 0) {\n   793→    // User doesn't exist, create and return default balance\n   794→    return await getBalance(stripeCustomerId);\n   795→  }\n   796→\n   797→  const user = result.rows[0];\n   798→  const hoursTotal = parseFloat(user.hours_total);\n   799→  const hoursRemaining = parseFloat(user.hours_remaining);\n   800→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   801→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   802→\n   803→  const tierNames = {\n   804→    starter: 'Starter',\n   805→    pro: 'Pro',\n   806→    team: 'Team',\n   807→    cancelled: 'Cancelled'\n   808→  };\n   809→\n   810→  return {\n   811→    hoursRemaining,\n   812→    hoursTotal,\n   813→    isolationHoursRemaining,\n   814→    isolationHoursTotal,\n   815→    tier: user.tier,\n   816→    tierName: tierNames[user.tier] || user.tier,\n   817→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   818→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   819→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   820→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   821→  };\n   822→}\n   823→\n   824→/**\n   825→ * Update user's tier (from Stripe webhook)\n   826→ * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n   827→ */\n   828→async function updateTier(stripeCustomerId, tier, email = null) {\n   829→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   830→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   831→\n   832→  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n   833→  const result = await pool.query(\n   834→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   835→     VALUES ($1, $2, $3, $4, $4, $5, $5)\n   836→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   837→     SET tier = $3, hours_remaining = $4, hours_total = $4,\n   838→         isolation_hours_remaining = $5, isolation_hours_total = $5,\n   839→         updated_at = CURRENT_TIMESTAMP\n   840→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   841→    [stripeCustomerId, email, tier, hours, isolationHours]\n   842→  );\n   843→\n   844→  const user = result.rows[0];\n   845→  const hoursTotal = parseFloat(user.hours_total);\n   846→  const hoursRemaining = parseFloat(user.hours_remaining);\n   847→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   848→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   849→\n   850→  const tierNames = {\n   851→    starter: 'Starter',\n   852→    pro: 'Pro',\n   853→    team: 'Team',\n   854→    cancelled: 'Cancelled'\n   855→  };\n   856→\n   857→  return {\n   858→    hoursRemaining,\n   859→    hoursTotal,\n   860→    isolationHoursRemaining,\n   861→    isolationHoursTotal,\n   862→    tier: user.tier,\n   863→    tierName: tierNames[user.tier] || user.tier,\n   864→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   865→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   866→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   867→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   868→  };\n   869→}\n   870→\n   871→/**\n   872→ * Get usage history for a user\n   873→ */\n   874→async function getUsageHistory(stripeCustomerId, limit = 50) {\n   875→  const result = await pool.query(\n   876→    `SELECT * FROM usage_log\n   877→     WHERE stripe_customer_id = $1\n   878→     ORDER BY created_at DESC\n   879→     LIMIT $2`,\n   880→    [stripeCustomerId, limit]\n   881→  );\n   882→  return result.rows;\n   883→}\n   884→\n   885→/**\n   886→ * Check if webhook event has already been processed (idempotency)\n   887→ */\n   888→async function isEventProcessed(eventId) {\n   889→  const result = await pool.query(\n   890→    'SELECT id FROM webhook_events WHERE event_id = $1',\n   891→    [eventId]\n   892→  );\n   893→  return result.rows.length > 0;\n   894→}\n   895→\n   896→/**\n   897→ * Record a processed webhook event\n   898→ */\n   899→async function recordWebhookEvent(eventId, eventType) {\n   900→  try {\n   901→    await pool.query(\n   902→      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n   903→      [eventId, eventType]\n   904→    );\n   905→  } catch (err) {\n   906→    // Ignore duplicate key errors (race condition safety)\n   907→    if (err.code !== '23505') throw err;\n   908→  }\n   909→}\n   910→\n   911→// =============================================================================\n   912→// Music Credits Functions (Phase 4 - AI Music Feature)\n   913→// =============================================================================\n   914→\n   915→// Music credits per tier\n   916→// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n   917→const TIER_MUSIC_CREDITS = {\n   918→  starter: 2,    // 2 songs/month\n   919→  pro: 10,       // 10 songs/month\n   920→  team: 50,      // 50 songs/month\n   921→  cancelled: 0\n   922→};\n   923→\n   924→// Feature access by tier - defines which features each tier can use\n   925→const TIER_FEATURES = {\n   926→  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n   927→  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n   928→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n   929→    'profanity_detection', 'chapter_detection'],\n   930→  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n   931→    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n   932→    'profanity_detection', 'chapter_detection', 'multitrack',\n   933→    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n   934→  cancelled: []\n   935→};\n   936→\n   937→/**\n   938→ * Check if a tier has access to a specific feature\n   939→ * @param {string} tier - User's tier (starter, pro, team)\n   940→ * @param {string} feature - Feature name to check\n   941→ * @returns {boolean}\n   942→ */\n   943→function hasFeatureAccess(tier, feature) {\n   944→  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n   945→  return tierFeatures.includes(feature);\n   946→}\n   947→\n   948→// Flat overage rate for music (simplified pricing)\n   949→const MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n   950→\n   951→// Legacy overage rates (kept for backwards compatibility)\n   952→const MUSIC_OVERAGE_RATES = {\n   953→  starter: 1.00,  // $1.00/song\n   954→  pro: 1.00,      // $1.00/song\n   955→  team: 1.00      // $1.00/song\n   956→};\n   957→\n   958→/**\n   959→ * Get music credits balance for a customer\n   960→ * @param {string} stripeCustomerId - Stripe customer ID\n   961→ * @returns {Promise<{remaining: number, total: number, tier: string}>}\n   962→ */\n   963→async function getMusicCredits(stripeCustomerId) {\n   964→  const result = await pool.query(\n   965→    `SELECT music_credits_remaining, music_credits_total, tier\n   966→     FROM users\n   967→     WHERE stripe_customer_id = $1`,\n   968→    [stripeCustomerId]\n   969→  );\n   970→\n   971→  if (result.rows.length === 0) {\n   972→    return { remaining: 0, total: 0, tier: 'starter' };\n   973→  }\n   974→\n   975→  const row = result.rows[0];\n   976→  return {\n   977→    remaining: row.music_credits_remaining || 0,\n   978→    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n   979→    tier: row.tier || 'starter'\n   980→  };\n   981→}\n   982→\n   983→/**\n   984→ * Check if customer has music credits available\n   985→ * @param {string} stripeCustomerId - Stripe customer ID\n   986→ * @returns {Promise<boolean>}\n   987→ */\n   988→async function hasMusicCredits(stripeCustomerId) {\n   989→  const credits = await getMusicCredits(stripeCustomerId);\n   990→  return credits.remaining > 0;\n   991→}\n   992→\n   993→/**\n   994→ * Deduct one music credit from customer\n   995→ * @param {string} stripeCustomerId - Stripe customer ID\n   996→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n   997→ */\n   998→async function deductMusicCredit(stripeCustomerId) {\n   999→  const client = await pool.connect();\n  1000→  try {\n  1001→    await client.query('BEGIN');\n  1002→\n  1003→    // Lock row for update\n  1004→    const result = await client.query(\n  1005→      `SELECT music_credits_remaining, tier\n  1006→       FROM users\n  1007→       WHERE stripe_customer_id = $1\n  1008→       FOR UPDATE`,\n  1009→      [stripeCustomerId]\n  1010→    );\n  1011→\n  1012→    if (result.rows.length === 0) {\n  1013→      await client.query('ROLLBACK');\n  1014→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1015→    }\n  1016→\n  1017→    const { music_credits_remaining } = result.rows[0];\n  1018→    let charged = 0;\n  1019→\n  1020→    if (music_credits_remaining > 0) {\n  1021→      // Deduct from included credits\n  1022→      await client.query(\n  1023→        `UPDATE users\n  1024→         SET music_credits_remaining = music_credits_remaining - 1,\n  1025→             updated_at = CURRENT_TIMESTAMP\n  1026→         WHERE stripe_customer_id = $1`,\n  1027→        [stripeCustomerId]\n  1028→      );\n  1029→    } else {\n  1030→      // Overage - charge flat rate ($1/song)\n  1031→      charged = MUSIC_OVERAGE_RATE;\n  1032→\n  1033→      // Report overage to Stripe meter for billing\n  1034→      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n  1035→      if (usageReport.success) {\n  1036→        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n  1037→      } else {\n  1038→        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n  1039→      }\n  1040→    }\n  1041→\n  1042→    // Log the usage\n  1043→    await client.query(\n  1044→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1045→       VALUES ($1, 1, $2)\n  1046→       ON CONFLICT DO NOTHING`,\n  1047→      [stripeCustomerId, charged]\n  1048→    );\n  1049→\n  1050→    await client.query('COMMIT');\n  1051→\n  1052→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1053→    return {\n  1054→      success: true,\n  1055→      remaining: newCredits.remaining,\n  1056→      charged\n  1057→    };\n  1058→\n  1059→  } catch (err) {\n  1060→    await client.query('ROLLBACK');\n  1061→    console.error('[SPLICE] Music credit deduction error:', err.message);\n  1062→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1063→  } finally {\n  1064→    client.release();\n  1065→  }\n  1066→}\n  1067→\n  1068→/**\n  1069→ * Reset music credits based on tier (called on subscription renewal)\n  1070→ * @param {string} stripeCustomerId - Stripe customer ID\n  1071→ * @param {string} tier - Subscription tier\n  1072→ */\n  1073→async function resetMusicCredits(stripeCustomerId, tier) {\n  1074→  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n  1075→\n  1076→  await pool.query(\n  1077→    `UPDATE users\n  1078→     SET music_credits_remaining = $2,\n  1079→         music_credits_total = $2,\n  1080→         music_credits_reset_at = CURRENT_TIMESTAMP,\n  1081→         updated_at = CURRENT_TIMESTAMP\n  1082→     WHERE stripe_customer_id = $1`,\n  1083→    [stripeCustomerId, credits]\n  1084→  );\n  1085→}\n  1086→\n  1087→/**\n  1088→ * Add music credits (for promotional or overage purchases)\n  1089→ * @param {string} stripeCustomerId - Stripe customer ID\n  1090→ * @param {number} credits - Number of credits to add\n  1091→ * @returns {Promise<{success: boolean, newBalance: number}>}\n  1092→ */\n  1093→async function addMusicCredits(stripeCustomerId, credits) {\n  1094→  const result = await pool.query(\n  1095→    `UPDATE users\n  1096→     SET music_credits_remaining = music_credits_remaining + $2,\n  1097→         updated_at = CURRENT_TIMESTAMP\n  1098→     WHERE stripe_customer_id = $1\n  1099→     RETURNING music_credits_remaining`,\n  1100→    [stripeCustomerId, credits]\n  1101→  );\n  1102→\n  1103→  if (result.rows.length === 0) {\n  1104→    return { success: false, newBalance: 0 };\n  1105→  }\n  1106→\n  1107→  return {\n  1108→    success: true,\n  1109→    newBalance: result.rows[0].music_credits_remaining\n  1110→  };\n  1111→}\n  1112→\n  1113→/**\n  1114→ * Get music usage history for a customer\n  1115→ * @param {string} stripeCustomerId - Stripe customer ID\n  1116→ * @param {number} limit - Max records to return\n  1117→ * @returns {Promise<Object[]>}\n  1118→ */\n  1119→async function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  1120→  const result = await pool.query(\n  1121→    `SELECT * FROM music_usage_log\n  1122→     WHERE stripe_customer_id = $1\n  1123→     ORDER BY created_at DESC\n  1124→     LIMIT $2`,\n  1125→    [stripeCustomerId, limit]\n  1126→  );\n  1127→  return result.rows;\n  1128→}\n  1129→\n  1130→/**\n  1131→ * Initialize music credits columns (migration helper)\n  1132→ */\n  1133→async function initMusicCreditsColumns() {\n  1134→  const client = await pool.connect();\n  1135→  try {\n  1136→    // Add music credits columns if they don't exist\n  1137→    await client.query(`\n  1138→      DO $$\n  1139→      BEGIN\n  1140→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n  1141→          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n  1142→        END IF;\n  1143→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n  1144→          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n  1145→        END IF;\n  1146→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n  1147→          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n  1148→        END IF;\n  1149→      END $$;\n  1150→    `);\n  1151→\n  1152→    // Create music usage log table\n  1153→    await client.query(`\n  1154→      CREATE TABLE IF NOT EXISTS music_usage_log (\n  1155→        id SERIAL PRIMARY KEY,\n  1156→        stripe_customer_id VARCHAR(255) NOT NULL,\n  1157→        credits_used INTEGER DEFAULT 1,\n  1158→        overage_charged DECIMAL(10,2) DEFAULT 0,\n  1159→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n  1160→      )\n  1161→    `);\n  1162→\n  1163→    await client.query(`\n  1164→      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n  1165→      ON music_usage_log(stripe_customer_id)\n  1166→    `);\n  1167→\n  1168→    console.log('[SPLICE] Music credits columns initialized');\n  1169→  } finally {\n  1170→    client.release();\n  1171→  }\n  1172→}\n  1173→\n  1174→// Variations credits cost (equivalent to 2.5 music credits)\n  1175→const VARIATIONS_CREDIT_COST = 2.5;\n  1176→\n  1177→// Overage rates for variations (higher than single music due to 3 parallel generations)\n  1178→const VARIATIONS_OVERAGE_RATES = {\n  1179→  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  1180→  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  1181→  team: 0.50      // $0.50/variations (2.5x $0.20)\n  1182→};\n  1183→\n  1184→// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\n  1185→const SCENE_AWARE_CREDIT_COST = 1.5;\n  1186→\n  1187→// Overage rates for scene-aware music (75% margin)\n  1188→const SCENE_AWARE_OVERAGE_RATES = {\n  1189→  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  1190→  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  1191→  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n  1192→};\n  1193→\n  1194→/**\n  1195→ * Check if customer has enough credits for variations (2.5 credits)\n  1196→ * @param {string} stripeCustomerId - Stripe customer ID\n  1197→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1198→ */\n  1199→async function checkVariationsCredits(stripeCustomerId) {\n  1200→  const credits = await getMusicCredits(stripeCustomerId);\n  1201→  const creditsRequired = VARIATIONS_CREDIT_COST;\n  1202→\n  1203→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1204→  // Or if they're on a paid tier (overage allowed)\n  1205→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1206→\n  1207→  return {\n  1208→    canGenerate,\n  1209→    creditsAvailable: credits.remaining,\n  1210→    creditsRequired,\n  1211→    tier: credits.tier\n  1212→  };\n  1213→}\n  1214→\n  1215→/**\n  1216→ * Deduct variations credit from customer (2.5 credits worth)\n  1217→ * @param {string} stripeCustomerId - Stripe customer ID\n  1218→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1219→ */\n  1220→async function deductVariationsCredit(stripeCustomerId) {\n  1221→  const client = await pool.connect();\n  1222→  try {\n  1223→    await client.query('BEGIN');\n  1224→\n  1225→    // Lock row for update\n  1226→    const result = await client.query(\n  1227→      `SELECT music_credits_remaining, tier\n  1228→       FROM users\n  1229→       WHERE stripe_customer_id = $1\n  1230→       FOR UPDATE`,\n  1231→      [stripeCustomerId]\n  1232→    );\n  1233→\n  1234→    if (result.rows.length === 0) {\n  1235→      await client.query('ROLLBACK');\n  1236→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1237→    }\n  1238→\n  1239→    const { music_credits_remaining, tier } = result.rows[0];\n  1240→    let charged = 0;\n  1241→    let creditsDeducted = 0;\n  1242→\n  1243→    // Determine how many credits to deduct vs overage to charge\n  1244→    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n  1245→      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n  1246→      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n  1247→      await client.query(\n  1248→        `UPDATE users\n  1249→         SET music_credits_remaining = music_credits_remaining - $2,\n  1250→             updated_at = CURRENT_TIMESTAMP\n  1251→         WHERE stripe_customer_id = $1`,\n  1252→        [stripeCustomerId, creditsDeducted]\n  1253→      );\n  1254→    } else if (music_credits_remaining > 0) {\n  1255→      // Partial credits - deduct what they have and charge overage for the rest\n  1256→      const creditsPortion = music_credits_remaining;\n  1257→      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n  1258→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1259→      charged = overagePortion * overageRate;\n  1260→\n  1261→      creditsDeducted = creditsPortion;\n  1262→      await client.query(\n  1263→        `UPDATE users\n  1264→         SET music_credits_remaining = 0,\n  1265→             updated_at = CURRENT_TIMESTAMP\n  1266→         WHERE stripe_customer_id = $1`,\n  1267→        [stripeCustomerId]\n  1268→      );\n  1269→\n  1270→      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1271→    } else {\n  1272→      // No credits - full overage\n  1273→      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n  1274→      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1275→    }\n  1276→\n  1277→    // Log the usage\n  1278→    await client.query(\n  1279→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1280→       VALUES ($1, $2, $3)\n  1281→       ON CONFLICT DO NOTHING`,\n  1282→      [stripeCustomerId, creditsDeducted, charged]\n  1283→    );\n  1284→\n  1285→    await client.query('COMMIT');\n  1286→\n  1287→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1288→    return {\n  1289→      success: true,\n  1290→      remaining: newCredits.remaining,\n  1291→      creditsDeducted,\n  1292→      charged\n  1293→    };\n  1294→\n  1295→  } catch (err) {\n  1296→    await client.query('ROLLBACK');\n  1297→    console.error('[SPLICE] Variations credit deduction error:', err.message);\n  1298→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1299→  } finally {\n  1300→    client.release();\n  1301→  }\n  1302→}\n  1303→\n  1304→/**\n  1305→ * Check if customer has enough credits for scene-aware music (1.5 credits)\n  1306→ * @param {string} stripeCustomerId - Stripe customer ID\n  1307→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1308→ */\n  1309→async function checkSceneAwareCredits(stripeCustomerId) {\n  1310→  const credits = await getMusicCredits(stripeCustomerId);\n  1311→  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n  1312→\n  1313→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1314→  // Or if they're on a paid tier (overage allowed)\n  1315→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1316→\n  1317→  return {\n  1318→    canGenerate,\n  1319→    creditsAvailable: credits.remaining,\n  1320→    creditsRequired,\n  1321→    tier: credits.tier\n  1322→  };\n  1323→}\n  1324→\n  1325→/**\n  1326→ * Deduct scene-aware music credit from customer (1.5 credits worth)\n  1327→ * @param {string} stripeCustomerId - Stripe customer ID\n  1328→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1329→ */\n  1330→async function deductSceneAwareCredit(stripeCustomerId) {\n  1331→  const client = await pool.connect();\n  1332→  try {\n  1333→    await client.query('BEGIN');\n  1334→\n  1335→    // Lock row for update\n  1336→    const result = await client.query(\n  1337→      `SELECT music_credits_remaining, tier\n  1338→       FROM users\n  1339→       WHERE stripe_customer_id = $1\n  1340→       FOR UPDATE`,\n  1341→      [stripeCustomerId]\n  1342→    );\n  1343→\n  1344→    if (result.rows.length === 0) {\n  1345→      await client.query('ROLLBACK');\n  1346→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1347→    }\n  1348→\n  1349→    const { music_credits_remaining, tier } = result.rows[0];\n  1350→    let charged = 0;\n  1351→    let creditsDeducted = 0;\n  1352→\n  1353→    // Determine how many credits to deduct vs overage to charge\n  1354→    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n  1355→      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n  1356→      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n  1357→      await client.query(\n  1358→        `UPDATE users\n  1359→         SET music_credits_remaining = music_credits_remaining - $2,\n  1360→             updated_at = CURRENT_TIMESTAMP\n  1361→         WHERE stripe_customer_id = $1`,\n  1362→        [stripeCustomerId, creditsDeducted]\n  1363→      );\n  1364→    } else if (music_credits_remaining > 0) {\n  1365→      // Partial credits - deduct what they have and charge overage for the rest\n  1366→      const creditsPortion = music_credits_remaining;\n  1367→      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n  1368→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1369→      charged = overagePortion * overageRate;\n  1370→\n  1371→      creditsDeducted = creditsPortion;\n  1372→      await client.query(\n  1373→        `UPDATE users\n  1374→         SET music_credits_remaining = 0,\n  1375→             updated_at = CURRENT_TIMESTAMP\n  1376→         WHERE stripe_customer_id = $1`,\n  1377→        [stripeCustomerId]\n  1378→      );\n  1379→\n  1380→      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1381→    } else {\n  1382→      // No credits - full overage\n  1383→      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n  1384→      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1385→    }\n  1386→\n  1387→    // Log the usage\n  1388→    await client.query(\n  1389→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1390→       VALUES ($1, $2, $3)\n  1391→       ON CONFLICT DO NOTHING`,\n  1392→      [stripeCustomerId, creditsDeducted, charged]\n  1393→    );\n  1394→\n  1395→    await client.query('COMMIT');\n  1396→\n  1397→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1398→    return {\n  1399→      success: true,\n  1400→      remaining: newCredits.remaining,\n  1401→      creditsDeducted,\n  1402→      charged\n  1403→    };\n  1404→\n  1405→  } catch (err) {\n  1406→    await client.query('ROLLBACK');\n  1407→    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n  1408→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1409→  } finally {\n  1410→    client.release();\n  1411→  }\n  1412→}\n  1413→\n  1414→/**\n  1415→ * Close the database connection pool\n  1416→ * Used for graceful shutdown\n  1417→ */\n  1418→async function closePool() {\n  1419→  await pool.end();\n  1420→}\n  1421→\n  1422→/**\n  1423→ * Update trial end date for a customer\n  1424→ * @param {string} stripeCustomerId - Customer ID\n  1425→ * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n  1426→ */\n  1427→async function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  1428→  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n  1429→\n  1430→  await pool.query(\n  1431→    `UPDATE users\n  1432→     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n  1433→     WHERE stripe_customer_id = $1`,\n  1434→    [stripeCustomerId, trialEnd]\n  1435→  );\n  1436→\n  1437→  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n  1438→}\n  1439→\n  1440→/**\n  1441→ * Check database connectivity\n  1442→ * Used for health checks\n  1443→ */\n  1444→async function checkDatabase() {\n  1445→  const client = await pool.connect();\n  1446→  try {\n  1447→    const result = await client.query('SELECT 1 as health');\n  1448→    return result.rows[0].health === 1;\n  1449→  } finally {\n  1450→    client.release();\n  1451→  }\n  1452→}\n  1453→\n  1454→module.exports = {\n  1455→  initDatabase,\n  1456→  getOrCreateUser,\n  1457→  customerExists,\n  1458→  getBalance,\n  1459→  hasCredits,\n  1460→  reserveCredits,\n  1461→  confirmReservation,\n  1462→  releaseReservation,\n  1463→  checkIsolationAccess,\n  1464→  deductUsage,\n  1465→  deductIsolationUsage,\n  1466→  resetHours,\n  1467→  updateTier,\n  1468→  getUsageHistory,\n  1469→  isEventProcessed,\n  1470→  recordWebhookEvent,\n  1471→  // Music credits functions\n  1472→  getMusicCredits,\n  1473→  hasMusicCredits,\n  1474→  deductMusicCredit,\n  1475→  resetMusicCredits,\n  1476→  addMusicCredits,\n  1477→  getMusicUsageHistory,\n  1478→  initMusicCreditsColumns,\n  1479→  // Variations credits functions\n  1480→  checkVariationsCredits,\n  1481→  deductVariationsCredit,\n  1482→  // Scene-aware credits functions\n  1483→  checkSceneAwareCredits,\n  1484→  deductSceneAwareCredit,\n  1485→  // Pool management\n  1486→  closePool,\n  1487→  checkDatabase,\n  1488→  // Trial management\n  1489→  updateTrialEnd,\n  1490→  // Constants\n  1491→  TIER_HOURS,\n  1492→  TIER_ISOLATION_MINUTES,\n  1493→  TIER_ISOLATION_HOURS,\n  1494→  ISOLATION_OVERAGE_RATE,\n  1495→  HOURS_OVERAGE_RATE,\n  1496→  TIER_MUSIC_CREDITS,\n  1497→  MUSIC_OVERAGE_RATE,\n  1498→  MUSIC_OVERAGE_RATES,\n  1499→  VARIATIONS_CREDIT_COST,\n  1500→  VARIATIONS_OVERAGE_RATES,\n  1501→  SCENE_AWARE_CREDIT_COST,\n  1502→  SCENE_AWARE_OVERAGE_RATES,\n  1503→  // Feature access\n  1504→  TIER_FEATURES,\n  1505→  hasFeatureAccess\n  1506→};\n  1507→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2127e0eb-0d52-4718-9e11-09c14ffeb05d","timestamp":"2025-12-29T04:07:39.935Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"/**\n * Usage Tracking Service\n *\n * Tracks user credit balances and usage for billing.\n * Uses PostgreSQL for persistence.\n */\n\nconst { Pool } = require('pg');\nconst { reportHoursOverage, reportMusicOverage } = require('./stripeUsageReporting');\n\n// PostgreSQL connection pool with proper limits\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n  // PERFORMANCE: Set connection pool limits\n  max: 20,                    // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n});\n\n// Hours per tier (regular processing)\n// Pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\n// Target margins: 79-82%\nconst TIER_HOURS = {\n  starter: 4,    // 4 hrs/month\n  pro: 15,       // 15 hrs/month\n  team: 50,      // 50 hrs/month\n  cancelled: 0\n};\n\n// Overage rate for processing hours beyond included\nconst HOURS_OVERAGE_RATE = 2.00; // $2/hour\n\n// Isolation minutes per tier (sized to maintain 80% margins)\nconst TIER_ISOLATION_MINUTES = {\n  starter: 0,     // No isolation access\n  pro: 45,        // 45 minutes included\n  team: 180,      // 3 hours included\n  cancelled: 0\n};\n\n// Convert to hours for database storage\nconst TIER_ISOLATION_HOURS = {\n  starter: 0,\n  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n  cancelled: 0\n};\n\n// Overage rate for isolation beyond included minutes\nconst ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n\n/**\n * Initialize database tables\n */\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n        email VARCHAR(255),\n        tier VARCHAR(50) DEFAULT 'starter',\n        hours_remaining DECIMAL(10,4) DEFAULT 15,\n        hours_total DECIMAL(10,4) DEFAULT 15,\n        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Add isolation columns if they don't exist (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'trial_end') THEN\n          ALTER TABLE users ADD COLUMN trial_end TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS usage_log (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        stripe_customer_id VARCHAR(255),\n        audio_duration_seconds DECIMAL(10,2),\n        hours_used DECIMAL(10,6),\n        endpoint VARCHAR(100),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    `);\n\n    // PERFORMANCE: Add composite index for efficient customer usage history queries\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n      ON usage_log(stripe_customer_id, created_at DESC)\n    `);\n\n    // Webhook events table for idempotency\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id SERIAL PRIMARY KEY,\n        event_id VARCHAR(255) UNIQUE NOT NULL,\n        event_type VARCHAR(100),\n        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n    `);\n\n    console.log('[UsageTracking] Database initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get or create a user by Stripe customer ID\n * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n */\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n     RETURNING *`,\n    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n  );\n\n  return result.rows[0];\n}\n\n/**\n * Check if a customer exists in the database (without creating)\n * SECURITY: Used to validate legacy auth attempts\n */\nasync function customerExists(stripeCustomerId) {\n  if (!stripeCustomerId) return false;\n\n  try {\n    const result = await pool.query(\n      'SELECT 1 FROM users WHERE stripe_customer_id = $1 LIMIT 1',\n      [stripeCustomerId]\n    );\n    return result.rows.length > 0;\n  } catch (err) {\n    console.error('[SPLICE] customerExists check failed:', err.message);\n    return false;\n  }\n}\n\n/**\n * Get user's current credit balance\n */\nasync function getBalance(stripeCustomerId) {\n  const user = await getOrCreateUser(stripeCustomerId);\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  // Tier display names\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  // Calculate trial days remaining\n  let trialDaysRemaining = null;\n  let isOnTrial = false;\n  if (user.trial_end) {\n    const trialEnd = new Date(user.trial_end);\n    const now = new Date();\n    const diffMs = trialEnd.getTime() - now.getTime();\n    const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));\n    if (diffDays > 0) {\n      trialDaysRemaining = diffDays;\n      isOnTrial = true;\n    }\n  }\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE,\n    featureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n    trialDaysRemaining,\n    isOnTrial\n  };\n}\n\n/**\n * Check if user has enough credits for estimated duration\n */\nasync function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n  const balance = await getBalance(stripeCustomerId);\n  const estimatedHours = estimatedSeconds / 3600;\n  return balance.hoursRemaining >= estimatedHours;\n}\n\n/**\n * Reserve credits atomically using SELECT ... FOR UPDATE\n * This prevents race conditions where multiple requests pass credit check\n * before any deduction occurs.\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} estimatedSeconds - Estimated processing time in seconds\n * @param {string} endpoint - Endpoint name for tracking\n * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n */\nasync function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n  const estimatedHours = estimatedSeconds / 3600;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, hours_remaining FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      // Create user if doesn't exist (within transaction)\n      const newUser = await client.query(\n        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n         VALUES ($1, 'starter', $2, $2)\n         RETURNING id, hours_remaining`,\n        [stripeCustomerId, TIER_HOURS.starter]\n      );\n      result.rows = newUser.rows;\n    }\n\n    const user = result.rows[0];\n    const hoursRemaining = parseFloat(user.hours_remaining);\n\n    // Check if enough credits\n    if (hoursRemaining < estimatedHours) {\n      await client.query('ROLLBACK');\n      return {\n        success: false,\n        error: 'Insufficient credits',\n        hoursRemaining,\n        hoursRequired: estimatedHours\n      };\n    }\n\n    // Generate unique reservation ID\n    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Reserve credits by deducting the estimated amount\n    await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining - $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [estimatedHours, stripeCustomerId]\n    );\n\n    // Log the reservation\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n\n    return {\n      success: true,\n      reservationId,\n      hoursReserved: estimatedHours,\n      hoursRemaining: hoursRemaining - estimatedHours\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[UsageTracking] Reservation error:', err);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Confirm a reservation (finalize usage) or adjust for actual duration\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} actualSeconds - Actual processing time in seconds\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @returns {Promise<object>} Updated balance\n */\nasync function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n  const actualHours = actualSeconds / 3600;\n  const reservedHours = reservedSeconds / 3600;\n  const difference = reservedHours - actualHours;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get current state\n    const result = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    let user = result.rows[0];\n\n    // If actual usage was less than reserved, refund the difference\n    if (difference > 0) {\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = hours_remaining + $1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the adjustment\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n      );\n    } else if (difference < 0) {\n      // Actual usage was more than reserved - deduct the extra\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [-difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the additional usage\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n      );\n    }\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n\n    // Build balance from data we already have (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Release a reservation (refund credits on processing failure)\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @param {string} reason - Reason for release\n * @returns {Promise<object>} Updated balance\n */\nasync function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n  const reservedHours = reservedSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get id for logging\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const userId = result.rows[0].id;\n\n    // Refund the reserved amount with RETURNING\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining + $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [reservedHours, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log the refund\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if user can use vocal isolation\n * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n */\nasync function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n  const balance = await getBalance(stripeCustomerId);\n\n  // Starter tier has no isolation access\n  if (!balance.hasIsolationAccess) {\n    return {\n      allowed: false,\n      reason: 'upgrade_required',\n      message: 'Vocal isolation requires Pro or Team tier',\n      hasIncludedHours: false,\n      overageRequired: false,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remainingIncluded = balance.isolationHoursRemaining;\n\n  // Check if within included hours\n  if (remainingIncluded >= estimatedHours) {\n    return {\n      allowed: true,\n      reason: 'included',\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      hasIncludedHours: true,\n      overageRequired: false,\n      overageCost: 0,\n      isolationHoursRemaining: remainingIncluded - estimatedHours\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n\n  return {\n    allowed: true,\n    reason: 'overage',\n    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n    hasIncludedHours: remainingIncluded > 0,\n    overageRequired: true,\n    overageMinutes,\n    overageCost,\n    isolationHoursRemaining: 0\n  };\n}\n\n/**\n * Deduct isolation usage from user's balance\n * Returns overage cost if beyond included hours\n * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n */\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n  const durationMinutes = audioDurationSeconds / 60;\n  const durationHours = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const userResult = await client.query(\n      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n       FROM users WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n\n    let overageCost = 0;\n    let hoursFromIncluded = 0;\n    let overageMinutes = 0;\n\n    if (remainingIncluded >= durationHours) {\n      // Fully covered by included hours\n      hoursFromIncluded = durationHours;\n    } else {\n      // Partial or full overage\n      hoursFromIncluded = remainingIncluded;\n      overageMinutes = durationMinutes - (remainingIncluded * 60);\n      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n    }\n\n    // Update isolation balance with RETURNING to get new values\n    const updateResult = await client.query(\n      `UPDATE users\n       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n      [durationHours, stripeCustomerId]\n    );\n\n    const updatedUser = updateResult.rows[0];\n\n    // Log usage (mark as isolation)\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(updatedUser.hours_total);\n    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: updatedUser.tier,\n      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      isolationUsed: {\n        durationMinutes,\n        hoursFromIncluded,\n        overageMinutes,\n        overageCost\n      }\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct usage from user's balance\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n * Reports overage to Stripe for billing when user exceeds included hours\n */\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // First get current balance to calculate overage\n    const currentResult = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users WHERE stripe_customer_id = $1 FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (currentResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const currentUser = currentResult.rows[0];\n    const currentRemaining = parseFloat(currentUser.hours_remaining);\n\n    // Calculate overage (hours used beyond what's remaining)\n    let overageHours = 0;\n    if (hoursUsed > currentRemaining) {\n      overageHours = hoursUsed - currentRemaining;\n    }\n\n    // Update balance (clamp at 0)\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [hoursUsed, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log usage\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Report overage to Stripe if any (after commit to not block transaction)\n    let overageCharge = 0;\n    if (overageHours > 0) {\n      overageCharge = overageHours * HOURS_OVERAGE_RATE;\n      const usageReport = await reportHoursOverage(stripeCustomerId, overageHours);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Hours overage reported to Stripe: ${stripeCustomerId} - ${overageHours.toFixed(2)}hrs ($${overageCharge.toFixed(2)})`);\n      } else {\n        console.warn(`[SPLICE] Hours overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      overageHours,\n      overageCharge\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset user's hours for new billing period\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n */\nasync function resetHours(stripeCustomerId, tier) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  const result = await pool.query(\n    `UPDATE users\n     SET hours_remaining = $1, hours_total = $1,\n         isolation_hours_remaining = $2, isolation_hours_total = $2,\n         tier = $3, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $4\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [hours, isolationHours, tier, stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    // User doesn't exist, create and return default balance\n    return await getBalance(stripeCustomerId);\n  }\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Update user's tier (from Stripe webhook)\n * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n */\nasync function updateTier(stripeCustomerId, tier, email = null) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, $3, $4, $4, $5, $5)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET tier = $3, hours_remaining = $4, hours_total = $4,\n         isolation_hours_remaining = $5, isolation_hours_total = $5,\n         updated_at = CURRENT_TIMESTAMP\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [stripeCustomerId, email, tier, hours, isolationHours]\n  );\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Get usage history for a user\n */\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Check if webhook event has already been processed (idempotency)\n */\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n\n/**\n * Record a processed webhook event\n */\nasync function recordWebhookEvent(eventId, eventType) {\n  try {\n    await pool.query(\n      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n      [eventId, eventType]\n    );\n  } catch (err) {\n    // Ignore duplicate key errors (race condition safety)\n    if (err.code !== '23505') throw err;\n  }\n}\n\n// =============================================================================\n// Music Credits Functions (Phase 4 - AI Music Feature)\n// =============================================================================\n\n// Music credits per tier\n// Matches new pricing: Starter $15/mo, Pro $39/mo, Team $129/mo\nconst TIER_MUSIC_CREDITS = {\n  starter: 2,    // 2 songs/month\n  pro: 10,       // 10 songs/month\n  team: 50,      // 50 songs/month\n  cancelled: 0\n};\n\n// Feature access by tier - defines which features each tier can use\nconst TIER_FEATURES = {\n  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection'],\n  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection', 'multitrack',\n    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n  cancelled: []\n};\n\n/**\n * Check if a tier has access to a specific feature\n * @param {string} tier - User's tier (starter, pro, team)\n * @param {string} feature - Feature name to check\n * @returns {boolean}\n */\nfunction hasFeatureAccess(tier, feature) {\n  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n  return tierFeatures.includes(feature);\n}\n\n// Flat overage rate for music (simplified pricing)\nconst MUSIC_OVERAGE_RATE = 1.00; // $1/song for all tiers\n\n// Legacy overage rates (kept for backwards compatibility)\nconst MUSIC_OVERAGE_RATES = {\n  starter: 1.00,  // $1.00/song\n  pro: 1.00,      // $1.00/song\n  team: 1.00      // $1.00/song\n};\n\n/**\n * Get music credits balance for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{remaining: number, total: number, tier: string}>}\n */\nasync function getMusicCredits(stripeCustomerId) {\n  const result = await pool.query(\n    `SELECT music_credits_remaining, music_credits_total, tier\n     FROM users\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { remaining: 0, total: 0, tier: 'starter' };\n  }\n\n  const row = result.rows[0];\n  return {\n    remaining: row.music_credits_remaining || 0,\n    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n    tier: row.tier || 'starter'\n  };\n}\n\n/**\n * Check if customer has music credits available\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<boolean>}\n */\nasync function hasMusicCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  return credits.remaining > 0;\n}\n\n/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining } = result.rows[0];\n    let charged = 0;\n\n    if (music_credits_remaining > 0) {\n      // Deduct from included credits\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - 1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n    } else {\n      // Overage - charge flat rate ($1/song)\n      charged = MUSIC_OVERAGE_RATE;\n\n      // Report overage to Stripe meter for billing\n      const usageReport = await reportMusicOverage(stripeCustomerId, 1);\n      if (usageReport.success) {\n        console.log(`[SPLICE] Music overage reported to Stripe: ${stripeCustomerId} - $${charged}`);\n      } else {\n        console.warn(`[SPLICE] Music overage billing failed: ${usageReport.error}`);\n      }\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, 1, $2)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset music credits based on tier (called on subscription renewal)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {string} tier - Subscription tier\n */\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n\n  await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = $2,\n         music_credits_total = $2,\n         music_credits_reset_at = CURRENT_TIMESTAMP,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, credits]\n  );\n}\n\n/**\n * Add music credits (for promotional or overage purchases)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} credits - Number of credits to add\n * @returns {Promise<{success: boolean, newBalance: number}>}\n */\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const result = await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = music_credits_remaining + $2,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1\n     RETURNING music_credits_remaining`,\n    [stripeCustomerId, credits]\n  );\n\n  if (result.rows.length === 0) {\n    return { success: false, newBalance: 0 };\n  }\n\n  return {\n    success: true,\n    newBalance: result.rows[0].music_credits_remaining\n  };\n}\n\n/**\n * Get music usage history for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} limit - Max records to return\n * @returns {Promise<Object[]>}\n */\nasync function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM music_usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Initialize music credits columns (migration helper)\n */\nasync function initMusicCreditsColumns() {\n  const client = await pool.connect();\n  try {\n    // Add music credits columns if they don't exist\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    // Create music usage log table\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS music_usage_log (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        credits_used INTEGER DEFAULT 1,\n        overage_charged DECIMAL(10,2) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n      ON music_usage_log(stripe_customer_id)\n    `);\n\n    console.log('[SPLICE] Music credits columns initialized');\n  } finally {\n    client.release();\n  }\n}\n\n// Variations credits cost (equivalent to 2.5 music credits)\nconst VARIATIONS_CREDIT_COST = 2.5;\n\n// Overage rates for variations (higher than single music due to 3 parallel generations)\nconst VARIATIONS_OVERAGE_RATES = {\n  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  team: 0.50      // $0.50/variations (2.5x $0.20)\n};\n\n// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\nconst SCENE_AWARE_CREDIT_COST = 1.5;\n\n// Overage rates for scene-aware music (75% margin)\nconst SCENE_AWARE_OVERAGE_RATES = {\n  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n};\n\n/**\n * Check if customer has enough credits for variations (2.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkVariationsCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = VARIATIONS_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct variations credit from customer (2.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductVariationsCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Variations credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if customer has enough credits for scene-aware music (1.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkSceneAwareCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct scene-aware music credit from customer (1.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductSceneAwareCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Close the database connection pool\n * Used for graceful shutdown\n */\nasync function closePool() {\n  await pool.end();\n}\n\n/**\n * Update trial end date for a customer\n * @param {string} stripeCustomerId - Customer ID\n * @param {number|null} trialEndTimestamp - Unix timestamp of trial end (null to clear)\n */\nasync function updateTrialEnd(stripeCustomerId, trialEndTimestamp) {\n  const trialEnd = trialEndTimestamp ? new Date(trialEndTimestamp * 1000) : null;\n\n  await pool.query(\n    `UPDATE users\n     SET trial_end = $2, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, trialEnd]\n  );\n\n  console.log(`[SPLICE] Updated trial_end for ${stripeCustomerId}: ${trialEnd ? trialEnd.toISOString() : 'null'}`);\n}\n\n/**\n * Check database connectivity\n * Used for health checks\n */\nasync function checkDatabase() {\n  const client = await pool.connect();\n  try {\n    const result = await client.query('SELECT 1 as health');\n    return result.rows[0].health === 1;\n  } finally {\n    client.release();\n  }\n}\n\nmodule.exports = {\n  initDatabase,\n  getOrCreateUser,\n  customerExists,\n  getBalance,\n  hasCredits,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  checkIsolationAccess,\n  deductUsage,\n  deductIsolationUsage,\n  resetHours,\n  updateTier,\n  getUsageHistory,\n  isEventProcessed,\n  recordWebhookEvent,\n  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  resetMusicCredits,\n  addMusicCredits,\n  getMusicUsageHistory,\n  initMusicCreditsColumns,\n  // Variations credits functions\n  checkVariationsCredits,\n  deductVariationsCredit,\n  // Scene-aware credits functions\n  checkSceneAwareCredits,\n  deductSceneAwareCredit,\n  // Pool management\n  closePool,\n  checkDatabase,\n  // Trial management\n  updateTrialEnd,\n  // Constants\n  TIER_HOURS,\n  TIER_ISOLATION_MINUTES,\n  TIER_ISOLATION_HOURS,\n  ISOLATION_OVERAGE_RATE,\n  HOURS_OVERAGE_RATE,\n  TIER_MUSIC_CREDITS,\n  MUSIC_OVERAGE_RATE,\n  MUSIC_OVERAGE_RATES,\n  VARIATIONS_CREDIT_COST,\n  VARIATIONS_OVERAGE_RATES,\n  SCENE_AWARE_CREDIT_COST,\n  SCENE_AWARE_OVERAGE_RATES,\n  // Feature access\n  TIER_FEATURES,\n  hasFeatureAccess\n};\n","numLines":1507,"startLine":1,"totalLines":1507}}}
{"parentUuid":"2127e0eb-0d52-4718-9e11-09c14ffeb05d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017hW2jTmW3w7XFQVbWsJR6H","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Backend Server\n     3→ *\n     4→ * Main entry point for the SPLICE backend API.\n     5→ * Orchestrates the audio analysis pipeline.\n     6→ *\n     7→ * Slices:\n     8→ * - Slice 4: Transcription (services/transcription.js)\n     9→ * - Slice 5: Take Detection (services/takeDetection.js)\n    10→ *\n    11→ * Architecture: Modular routes (see routes/ directory)\n    12→ */\n    13→\n    14→\n    15→require('dotenv').config();\n    16→\n    17→const express = require('express');\n    18→const cors = require('cors');\n    19→const helmet = require('helmet');\n    20→const fs = require('fs');\n    21→const https = require('https');\n    22→const http = require('http');\n    23→const path = require('path');\n    24→const crypto = require('crypto');\n    25→\n    26→// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\n    27→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    28→\n    29→// Import services\n    30→const usageTracking = require('./services/usageTracking');\n    31→const { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\n    32→const { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData } = require('./middleware/auth');\n    33→const referralService = require('./services/referralService');\n    34→const licenseService = require('./services/licenseService');\n    35→const emailService = require('./services/emailService');\n    36→const { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\n    37→const { getSupportedFormats } = require('./services/captionExporter');\n    38→\n    39→// Import route modules\n    40→const healthRoutes = require('./routes/health');\n    41→const analyzeRoutes = require('./routes/analyze');\n    42→const silencesRoutes = require('./routes/silences');\n    43→const detectionRoutes = require('./routes/detection');\n    44→const exportRoutes = require('./routes/export');\n    45→const multitrackRoutes = require('./routes/multitrack');\n    46→const cutListRoutes = require('./routes/cutList');\n    47→const zoomRoutes = require('./routes/zoom');\n    48→const chaptersRoutes = require('./routes/chapters');\n    49→const youtubeRoutes = require('./routes/youtube');\n    50→const captionsRoutes = require('./routes/captions');\n    51→const textEditRoutes = require('./routes/textEdit');\n    52→const reframeRoutes = require('./routes/reframe');\n    53→const batchRoutes = require('./routes/batch');\n    54→const authRoutes = require('./routes/auth');\n    55→const billingRoutes = require('./routes/billing');\n    56→const referralRoutes = require('./routes/referral');\n    57→const licenseRoutes = require('./routes/license');\n    58→const musicRoutes = require('./routes/music');\n    59→\n    60→// Stripe for webhooks\n    61→const Stripe = require('stripe');\n    62→\n    63→// Validate STRIPE_SECRET_KEY in production - exit if missing\n    64→if (isProduction && !process.env.STRIPE_SECRET_KEY) {\n    65→  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');\n    66→  process.exit(1);\n    67→}\n    68→\n    69→// Validate JWT_SECRET in production - exit if using default\n    70→if (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {\n    71→  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');\n    72→  process.exit(1);\n    73→}\n    74→\n    75→// Validate DATABASE_URL in production\n    76→if (isProduction && !process.env.DATABASE_URL) {\n    77→  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');\n    78→  process.exit(1);\n    79→}\n    80→\n    81→// Validate OPENAI_API_KEY in production\n    82→if (isProduction && !process.env.OPENAI_API_KEY) {\n    83→  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');\n    84→  process.exit(1);\n    85→}\n    86→\n    87→const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n    88→\n    89→// =============================================================================\n    90→// PERF-FIX: Static Response Cache\n    91→// Cache static endpoint responses at startup to avoid repeated computation\n    92→// =============================================================================\n    93→\n    94→// Generate ETag from content\n    95→function generateETag(content) {\n    96→  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n    97→}\n    98→\n    99→// Static response cache - populated at startup\n   100→const STATIC_RESPONSE_CACHE = {\n   101→  profanityLanguages: null,\n   102→  profanityBleeps: null,\n   103→  exportFormats: null\n   104→};\n   105→\n   106→// Initialize cache at startup (called after server starts)\n   107→function initializeStaticCache() {\n   108→  // Cache profanity languages\n   109→  const languages = getSupportedLanguages();\n   110→  STATIC_RESPONSE_CACHE.profanityLanguages = {\n   111→    body: { success: true, languages },\n   112→    etag: generateETag({ languages })\n   113→  };\n   114→\n   115→  // Cache profanity bleeps\n   116→  const sounds = getAvailableBleepSounds();\n   117→  STATIC_RESPONSE_CACHE.profanityBleeps = {\n   118→    body: { success: true, sounds },\n   119→    etag: generateETag({ sounds })\n   120→  };\n   121→\n   122→  // Cache export formats\n   123→  const formats = getSupportedFormats();\n   124→  STATIC_RESPONSE_CACHE.exportFormats = {\n   125→    body: { success: true, formats },\n   126→    etag: generateETag({ formats })\n   127→  };\n   128→\n   129→  console.log('[SPLICE] Static response cache initialized');\n   130→}\n   131→\n   132→// Helper to send cached response with ETag\n   133→function sendCachedResponse(req, res, cacheKey) {\n   134→  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n   135→  if (!cached) {\n   136→    return res.status(500).json({ error: 'Cache not initialized' });\n   137→  }\n   138→\n   139→  // Check If-None-Match header for conditional GET\n   140→  const clientETag = req.headers['if-none-match'];\n   141→  if (clientETag === cached.etag) {\n   142→    return res.status(304).end(); // Not Modified\n   143→  }\n   144→\n   145→  // Send cached response with ETag and cache headers\n   146→  res.set('ETag', cached.etag);\n   147→  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n   148→  res.json(cached.body);\n   149→}\n   150→\n   151→// =============================================================================\n   152→// Server Configuration\n   153→// =============================================================================\n   154→\n   155→const app = express();\n   156→const PORT = process.env.PORT || 3847;\n   157→\n   158→// HTTPS certificates (generated by mkcert) - only for local development\n   159→let httpsOptions = null;\n   160→if (!isProduction) {\n   161→  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n   162→  const certPath = path.join(__dirname, 'localhost+1.pem');\n   163→  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n   164→    httpsOptions = {\n   165→      key: fs.readFileSync(keyPath),\n   166→      cert: fs.readFileSync(certPath)\n   167→    };\n   168→  }\n   169→}\n   170→\n   171→// =============================================================================\n   172→// Security Configuration\n   173→// =============================================================================\n   174→\n   175→// CORS whitelist - restrict origins in production\n   176→const CORS_WHITELIST = [\n   177→  'http://localhost:3000',\n   178→  'http://localhost:3847',\n   179→  'https://localhost:3847',\n   180→  'http://127.0.0.1:3000',\n   181→  'http://127.0.0.1:3847',\n   182→  'https://127.0.0.1:3847',\n   183→  'https://splice.app',\n   184→  'https://www.splice.app',\n   185→  'https://splice-api-production.up.railway.app',\n   186→  'https://splice-website.vercel.app',\n   187→  // Adobe CEP/UXP panels run from file:// or bolt://\n   188→  'file://',\n   189→  'bolt://'\n   190→];\n   191→\n   192→const corsOptions = {\n   193→  origin: function (origin, callback) {\n   194→    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n   195→    if (!origin) {\n   196→      return callback(null, true);\n   197→    }\n   198→    // Check if origin is in whitelist\n   199→    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n   200→      return callback(null, true);\n   201→    }\n   202→    // In development, allow all origins with warning\n   203→    if (!isProduction) {\n   204→      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n   205→      return callback(null, true);\n   206→    }\n   207→    // In production, reject non-whitelisted origins\n   208→    console.error(`[CORS] Blocked request from: ${origin}`);\n   209→    return callback(new Error('Not allowed by CORS'));\n   210→  },\n   211→  credentials: true,\n   212→  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n   213→  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature']\n   214→};\n   215→\n   216→app.use(cors(corsOptions));\n   217→\n   218→// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n   219→// This ensures rate limiting and logging use the correct client IP\n   220→if (isProduction) {\n   221→  app.set('trust proxy', 1);\n   222→}\n   223→\n   224→// IP-based rate limiting (100 requests/minute per IP)\n   225→app.use(ipRateLimit);\n   226→\n   227→// Security headers via helmet\n   228→app.use(helmet({\n   229→  contentSecurityPolicy: {\n   230→    directives: {\n   231→      defaultSrc: [\"'self'\"],\n   232→      scriptSrc: [\"'self'\"],\n   233→      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n   234→      imgSrc: [\"'self'\", 'data:', 'https:'],\n   235→      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n   236→      fontSrc: [\"'self'\"],\n   237→      objectSrc: [\"'none'\"],\n   238→      mediaSrc: [\"'self'\"],\n   239→      frameSrc: [\"'none'\"]\n   240→    }\n   241→  },\n   242→  hsts: {\n   243→    maxAge: 31536000,\n   244→    includeSubDomains: true,\n   245→    preload: true\n   246→  },\n   247→  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n   248→  noSniff: true,\n   249→  xssFilter: true,\n   250→  hidePoweredBy: true\n   251→}));\n   252→\n   253→// Helper to determine tier from price ID with logging\n   254→// Supports both monthly and annual pricing\n   255→function getTierFromPriceId(priceId) {\n   256→  // Monthly prices\n   257→  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n   258→  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n   259→  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n   260→\n   261→  // Annual prices (same tier, just different billing period)\n   262→  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n   263→  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n   264→  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n   265→\n   266→  // Log unknown price ID for debugging\n   267→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   268→  return 'starter';\n   269→}\n   270→\n   271→// =============================================================================\n   272→// Stripe Webhook (must be before express.json())\n   273→// =============================================================================\n   274→\n   275→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   276→  const sig = req.headers['stripe-signature'];\n   277→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   278→\n   279→  let event;\n   280→\n   281→  try {\n   282→    if (webhookSecret) {\n   283→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   284→    } else if (isProduction) {\n   285→      // SECURITY: Reject unsigned webhooks in production\n   286→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   287→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   288→    } else {\n   289→      // For local development testing only\n   290→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   291→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   292→      event = JSON.parse(bodyString);\n   293→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   294→    }\n   295→  } catch (err) {\n   296→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   297→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   298→  }\n   299→\n   300→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   301→\n   302→  // Idempotency check - skip if already processed\n   303→  if (await usageTracking.isEventProcessed(event.id)) {\n   304→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   305→    return res.json({ received: true, skipped: true });\n   306→  }\n   307→\n   308→  try {\n   309→    switch (event.type) {\n   310→      case 'customer.subscription.created':\n   311→      case 'customer.subscription.updated': {\n   312→        const subscription = event.data.object;\n   313→        const customerId = subscription.customer;\n   314→\n   315→        // Validate customerId\n   316→        if (!customerId) {\n   317→          console.error('[SPLICE] Missing customer ID in subscription event');\n   318→          return res.status(400).json({ error: 'Missing customer ID' });\n   319→        }\n   320→\n   321→        // Get tier from price ID\n   322→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   323→        const tier = getTierFromPriceId(priceId);\n   324→\n   325→        // Update user tier and reset hours\n   326→        await usageTracking.updateTier(customerId, tier);\n   327→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   328→\n   329→        // Initialize music credits for new subscriptions\n   330→        if (event.type === 'customer.subscription.created') {\n   331→          await usageTracking.resetMusicCredits(customerId, tier);\n   332→          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n   333→        }\n   334→\n   335→        // Update trial end date if present\n   336→        if (subscription.trial_end) {\n   337→          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n   338→        }\n   339→\n   340→        // Generate license key for new subscriptions with retry and delivery\n   341→        if (event.type === 'customer.subscription.created') {\n   342→          let licenseResult = null;\n   343→          let retryCount = 0;\n   344→          const maxRetries = 3;\n   345→\n   346→          // Retry mechanism for license key generation\n   347→          while (retryCount < maxRetries) {\n   348→            licenseResult = await licenseService.generateLicenseKey(customerId);\n   349→            if (licenseResult.success) {\n   350→              break;\n   351→            }\n   352→            retryCount++;\n   353→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n   354→            // Wait before retry (exponential backoff)\n   355→            if (retryCount < maxRetries) {\n   356→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n   357→            }\n   358→          }\n   359→\n   360→          if (licenseResult && licenseResult.success) {\n   361→            // SECURITY: Mask license key in logs\n   362→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n   363→\n   364→            // Store license key in Stripe subscription metadata as backup\n   365→            try {\n   366→              await stripe.subscriptions.update(subscription.id, {\n   367→                metadata: {\n   368→                  license_key: licenseResult.key,\n   369→                  license_generated_at: new Date().toISOString()\n   370→                }\n   371→              });\n   372→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n   373→            } catch (stripeErr) {\n   374→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n   375→            }\n   376→\n   377→            // Get customer email and send license key\n   378→            try {\n   379→              const customer = await stripe.customers.retrieve(customerId);\n   380→              if (customer.email) {\n   381→                // SECURITY: Mask sensitive data in logs\n   382→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n   383→\n   384→                // Send license key email\n   385→                try {\n   386→                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n   387→                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n   388→                } catch (sendErr) {\n   389→                  // Log but don't fail - license is stored in Stripe metadata as backup\n   390→                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n   391→                }\n   392→\n   393→                // Store email in database for reference\n   394→                await usageTracking.updateTier(customerId, tier, customer.email);\n   395→              } else {\n   396→                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n   397→              }\n   398→            } catch (emailErr) {\n   399→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n   400→            }\n   401→          } else {\n   402→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n   403→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n   404→            console.error(`[SPLICE] ${errorMsg}`);\n   405→            return res.status(500).json({ error: errorMsg });\n   406→          }\n   407→        }\n   408→        break;\n   409→      }\n   410→\n   411→      case 'customer.subscription.deleted': {\n   412→        const subscription = event.data.object;\n   413→        const customerId = subscription.customer;\n   414→\n   415→        // Validate customerId\n   416→        if (!customerId) {\n   417→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   418→          return res.status(400).json({ error: 'Missing customer ID' });\n   419→        }\n   420→\n   421→        // Downgrade to cancelled (0 hours)\n   422→        await usageTracking.updateTier(customerId, 'cancelled');\n   423→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   424→        break;\n   425→      }\n   426→\n   427→      case 'invoice.payment_succeeded': {\n   428→        const invoice = event.data.object;\n   429→        const customerId = invoice.customer;\n   430→        const subscriptionId = invoice.subscription;\n   431→\n   432→        // Validate customerId\n   433→        if (!customerId) {\n   434→          console.error('[SPLICE] Missing customer ID in invoice event');\n   435→          return res.status(400).json({ error: 'Missing customer ID' });\n   436→        }\n   437→\n   438→        // Reset hours on successful payment (new billing period)\n   439→        let tier = 'starter';\n   440→        if (subscriptionId) {\n   441→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   442→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   443→          tier = getTierFromPriceId(priceId);\n   444→\n   445→          await usageTracking.resetHours(customerId, tier);\n   446→          await usageTracking.resetMusicCredits(customerId, tier);\n   447→          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n   448→        }\n   449→\n   450→        // Check for affiliate coupon and record commission\n   451→        const discount = invoice.discount;\n   452→        if (discount && discount.coupon) {\n   453→          const couponId = discount.coupon.id;\n   454→          // Check if this is an affiliate code (like JIMMYN)\n   455→          if (referralService.AFFILIATE_CODES[couponId]) {\n   456→            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n   457→            await referralService.recordAffiliateCommission(\n   458→              couponId,\n   459→              customerId,\n   460→              amountPaid,\n   461→              tier\n   462→            );\n   463→            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n   464→          }\n   465→        }\n   466→        break;\n   467→      }\n   468→\n   469→      case 'invoice.payment_failed': {\n   470→        const invoice = event.data.object;\n   471→        const customerId = invoice.customer;\n   472→        const attemptCount = invoice.attempt_count || 1;\n   473→\n   474→        // Validate customerId\n   475→        if (!customerId) {\n   476→          console.error('[SPLICE] Missing customer ID in payment_failed event');\n   477→          return res.status(400).json({ error: 'Missing customer ID' });\n   478→        }\n   479→\n   480→        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n   481→\n   482→        // Stripe will retry automatically per retry settings\n   483→        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n   484→        // Send warning email on final attempt\n   485→        if (attemptCount >= 3) {\n   486→          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n   487→          // Send warning email to customer about impending cancellation\n   488→          try {\n   489→            const customer = await stripe.customers.retrieve(customerId);\n   490→            if (customer.email) {\n   491→              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n   492→              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n   493→            }\n   494→          } catch (emailErr) {\n   495→            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n   496→          }\n   497→        }\n   498→        break;\n   499→      }\n   500→\n   501→      case 'customer.deleted': {\n   502→        const customer = event.data.object;\n   503→        const customerId = customer.id;\n   504→\n   505→        // Validate customerId\n   506→        if (!customerId) {\n   507→          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n   508→          return res.status(400).json({ error: 'Missing customer ID' });\n   509→        }\n   510→\n   511→        // Clean up user data - downgrade to cancelled\n   512→        await usageTracking.updateTier(customerId, 'cancelled');\n   513→        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n   514→        break;\n   515→      }\n   516→\n   517→      default:\n   518→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   519→    }\n   520→\n   521→    // Record event as processed (idempotency)\n   522→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   523→\n   524→    res.json({ received: true });\n   525→  } catch (err) {\n   526→    console.error('[SPLICE] Webhook handler error:', err);\n   527→    res.status(500).json({ error: err.message });\n   528→  }\n   529→});\n   530→\n   531→// Parse JSON body for all other routes\n   532→// SECURITY: Limit JSON body size to prevent DoS attacks\n   533→app.use(express.json({ limit: '10mb' }));\n   534→\n   535→// =============================================================================\n   536→// Route Configuration Options\n   537→// =============================================================================\n   538→\n   539→const routeOptions = {\n   540→  middleware: {\n   541→    requireCredits,\n   542→    requireFeature,\n   543→    authenticateToken\n   544→  },\n   545→  services: {\n   546→    usageTracking,\n   547→    referralService,\n   548→    licenseService,\n   549→    emailService,\n   550→    stripe\n   551→  },\n   552→  authHelpers: {\n   553→    generateToken,\n   554→    generateRefreshToken,\n   555→    verifyToken,\n   556→    maskSensitiveData\n   557→  },\n   558→  staticCache: STATIC_RESPONSE_CACHE,\n   559→  sendCachedResponse\n   560→};\n   561→\n   562→// =============================================================================\n   563→// Mount Routes\n   564→// =============================================================================\n   565→\n   566→// Health check and system endpoints (no prefix)\n   567→app.use('/', healthRoutes(routeOptions));\n   568→\n   569→// Core analysis endpoints\n   570→app.use('/', analyzeRoutes(routeOptions));\n   571→app.use('/', silencesRoutes(routeOptions));\n   572→app.use('/', detectionRoutes(routeOptions));\n   573→\n   574→// Export endpoints\n   575→app.use('/export', exportRoutes(routeOptions));\n   576→\n   577→// Multitrack/Multicam endpoints\n   578→app.use('/multitrack', multitrackRoutes(routeOptions));\n   579→\n   580→// Cut list generation\n   581→app.use('/cut-list', cutListRoutes(routeOptions));\n   582→\n   583→// Legacy XML processing endpoint (backwards compatibility)\n   584→const { processXMLFile } = require('./services/xmlProcessor');\n   585→app.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n   586→  const {\n   587→    xmlPath,\n   588→    silences,\n   589→    removeGaps = true,\n   590→    outputPath = null\n   591→  } = req.body;\n   592→\n   593→  if (!xmlPath) {\n   594→    return res.status(400).json({ error: 'xmlPath is required' });\n   595→  }\n   596→\n   597→  if (!silences || !Array.isArray(silences)) {\n   598→    return res.status(400).json({ error: 'silences array is required' });\n   599→  }\n   600→\n   601→  if (!fs.existsSync(xmlPath)) {\n   602→    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n   603→  }\n   604→\n   605→  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n   606→\n   607→  try {\n   608→    const result = await processXMLFile(xmlPath, silences, {\n   609→      outputPath,\n   610→      removeGaps\n   611→    });\n   612→\n   613→    res.json({\n   614→      success: true,\n   615→      inputPath: xmlPath,\n   616→      outputPath: result.outputPath,\n   617→      stats: result.stats\n   618→    });\n   619→  } catch (err) {\n   620→    console.error('[SPLICE] XML processing error:', err);\n   621→    res.status(500).json({ error: err.message });\n   622→  }\n   623→});\n   624→\n   625→// Auto zoom endpoints\n   626→app.use('/zoom', zoomRoutes(routeOptions));\n   627→\n   628→// Chapter detection endpoints\n   629→app.use('/chapters', chaptersRoutes(routeOptions));\n   630→\n   631→// YouTube content generation\n   632→app.use('/youtube', youtubeRoutes(routeOptions));\n   633→\n   634→// Animated captions endpoints\n   635→app.use('/captions', captionsRoutes(routeOptions));\n   636→\n   637→// Text-based editing endpoints\n   638→app.use('/text-edit', textEditRoutes(routeOptions));\n   639→\n   640→// Social reframe endpoints\n   641→app.use('/reframe', reframeRoutes(routeOptions));\n   642→app.use('/faces', reframeRoutes.facesRouter(routeOptions));\n   643→\n   644→// Batch processing endpoints\n   645→app.use('/batch', batchRoutes(routeOptions));\n   646→\n   647→// Authentication endpoints\n   648→app.use('/auth', authRoutes(routeOptions));\n   649→\n   650→// Billing and credits endpoints\n   651→app.use('/', billingRoutes(routeOptions));\n   652→\n   653→// Referral system endpoints\n   654→app.use('/referral', referralRoutes(routeOptions));\n   655→\n   656→// License key endpoints\n   657→app.use('/license', licenseRoutes(routeOptions));\n   658→\n   659→// AI Music generation endpoints\n   660→app.use('/music', musicRoutes(routeOptions));\n   661→\n   662→// =============================================================================\n   663→// Start Server\n   664→// =============================================================================\n   665→\n   666→// Track active server for graceful shutdown\n   667→let server = null;\n   668→\n   669→// Initialize database and start server\n   670→async function startServer() {\n   671→  try {\n   672→    await usageTracking.initDatabase();\n   673→    await referralService.initReferralTables();\n   674→    await licenseService.initLicenseTables();\n   675→    console.log('[SPLICE] Database initialized');\n   676→\n   677→    // PERF-FIX: Initialize static response cache at startup\n   678→    initializeStaticCache();\n   679→\n   680→    if (isProduction || !httpsOptions) {\n   681→      // Production: Railway provides TLS termination, use HTTP\n   682→      server = http.createServer(app).listen(PORT, () => {\n   683→        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n   684→      });\n   685→    } else {\n   686→      // Development: Use HTTPS with local certificates\n   687→      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n   688→        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n   689→        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n   690→      });\n   691→    }\n   692→  } catch (err) {\n   693→    console.error('[SPLICE] Failed to start server:', err);\n   694→    process.exit(1);\n   695→  }\n   696→}\n   697→\n   698→// =============================================================================\n   699→// Graceful Shutdown\n   700→// =============================================================================\n   701→\n   702→async function gracefulShutdown(signal) {\n   703→  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n   704→\n   705→  // Stop accepting new connections\n   706→  if (server) {\n   707→    server.close(() => {\n   708→      console.log('[SPLICE] HTTP server closed');\n   709→    });\n   710→  }\n   711→\n   712→  // Close database pool\n   713→  try {\n   714→    await usageTracking.closePool();\n   715→    console.log('[SPLICE] Database pool closed');\n   716→  } catch (err) {\n   717→    console.error('[SPLICE] Error closing database pool:', err.message);\n   718→  }\n   719→\n   720→  // Give ongoing requests time to complete (max 10 seconds)\n   721→  setTimeout(() => {\n   722→    console.log('[SPLICE] Graceful shutdown complete');\n   723→    process.exit(0);\n   724→  }, 10000);\n   725→}\n   726→\n   727→// Handle termination signals\n   728→process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n   729→process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n   730→\n   731→// Handle uncaught exceptions\n   732→process.on('uncaughtException', (err) => {\n   733→  console.error('[SPLICE] Uncaught exception:', err);\n   734→  gracefulShutdown('uncaughtException');\n   735→});\n   736→\n   737→process.on('unhandledRejection', (reason, promise) => {\n   738→  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n   739→});\n   740→\n   741→startServer();\n   742→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f3f532b3-51df-4e70-a0d0-8e4e45820bce","timestamp":"2025-12-29T04:07:39.986Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"/**\n * SPLICE Backend Server\n *\n * Main entry point for the SPLICE backend API.\n * Orchestrates the audio analysis pipeline.\n *\n * Slices:\n * - Slice 4: Transcription (services/transcription.js)\n * - Slice 5: Take Detection (services/takeDetection.js)\n *\n * Architecture: Modular routes (see routes/ directory)\n */\n\n\nrequire('dotenv').config();\n\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst fs = require('fs');\nconst https = require('https');\nconst http = require('http');\nconst path = require('path');\nconst crypto = require('crypto');\n\n// Check if running in production (Railway injects RAILWAY_ENVIRONMENT)\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// Import services\nconst usageTracking = require('./services/usageTracking');\nconst { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\nconst { generateToken, generateRefreshToken, verifyToken, authenticateToken, maskSensitiveData } = require('./middleware/auth');\nconst referralService = require('./services/referralService');\nconst licenseService = require('./services/licenseService');\nconst emailService = require('./services/emailService');\nconst { getSupportedLanguages, getAvailableBleepSounds } = require('./services/profanityDetection');\nconst { getSupportedFormats } = require('./services/captionExporter');\n\n// Import route modules\nconst healthRoutes = require('./routes/health');\nconst analyzeRoutes = require('./routes/analyze');\nconst silencesRoutes = require('./routes/silences');\nconst detectionRoutes = require('./routes/detection');\nconst exportRoutes = require('./routes/export');\nconst multitrackRoutes = require('./routes/multitrack');\nconst cutListRoutes = require('./routes/cutList');\nconst zoomRoutes = require('./routes/zoom');\nconst chaptersRoutes = require('./routes/chapters');\nconst youtubeRoutes = require('./routes/youtube');\nconst captionsRoutes = require('./routes/captions');\nconst textEditRoutes = require('./routes/textEdit');\nconst reframeRoutes = require('./routes/reframe');\nconst batchRoutes = require('./routes/batch');\nconst authRoutes = require('./routes/auth');\nconst billingRoutes = require('./routes/billing');\nconst referralRoutes = require('./routes/referral');\nconst licenseRoutes = require('./routes/license');\nconst musicRoutes = require('./routes/music');\n\n// Stripe for webhooks\nconst Stripe = require('stripe');\n\n// Validate STRIPE_SECRET_KEY in production - exit if missing\nif (isProduction && !process.env.STRIPE_SECRET_KEY) {\n  console.error('[SPLICE] CRITICAL: STRIPE_SECRET_KEY is required in production');\n  process.exit(1);\n}\n\n// Validate JWT_SECRET in production - exit if using default\nif (isProduction && (!process.env.JWT_SECRET || process.env.JWT_SECRET === 'splice-dev-secret-change-in-production')) {\n  console.error('[SPLICE] CRITICAL: JWT_SECRET must be set to a secure value in production');\n  process.exit(1);\n}\n\n// Validate DATABASE_URL in production\nif (isProduction && !process.env.DATABASE_URL) {\n  console.error('[SPLICE] CRITICAL: DATABASE_URL is required in production');\n  process.exit(1);\n}\n\n// Validate OPENAI_API_KEY in production\nif (isProduction && !process.env.OPENAI_API_KEY) {\n  console.error('[SPLICE] CRITICAL: OPENAI_API_KEY is required in production');\n  process.exit(1);\n}\n\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\n\n// =============================================================================\n// PERF-FIX: Static Response Cache\n// Cache static endpoint responses at startup to avoid repeated computation\n// =============================================================================\n\n// Generate ETag from content\nfunction generateETag(content) {\n  return `\"${crypto.createHash('md5').update(JSON.stringify(content)).digest('hex')}\"`;\n}\n\n// Static response cache - populated at startup\nconst STATIC_RESPONSE_CACHE = {\n  profanityLanguages: null,\n  profanityBleeps: null,\n  exportFormats: null\n};\n\n// Initialize cache at startup (called after server starts)\nfunction initializeStaticCache() {\n  // Cache profanity languages\n  const languages = getSupportedLanguages();\n  STATIC_RESPONSE_CACHE.profanityLanguages = {\n    body: { success: true, languages },\n    etag: generateETag({ languages })\n  };\n\n  // Cache profanity bleeps\n  const sounds = getAvailableBleepSounds();\n  STATIC_RESPONSE_CACHE.profanityBleeps = {\n    body: { success: true, sounds },\n    etag: generateETag({ sounds })\n  };\n\n  // Cache export formats\n  const formats = getSupportedFormats();\n  STATIC_RESPONSE_CACHE.exportFormats = {\n    body: { success: true, formats },\n    etag: generateETag({ formats })\n  };\n\n  console.log('[SPLICE] Static response cache initialized');\n}\n\n// Helper to send cached response with ETag\nfunction sendCachedResponse(req, res, cacheKey) {\n  const cached = STATIC_RESPONSE_CACHE[cacheKey];\n  if (!cached) {\n    return res.status(500).json({ error: 'Cache not initialized' });\n  }\n\n  // Check If-None-Match header for conditional GET\n  const clientETag = req.headers['if-none-match'];\n  if (clientETag === cached.etag) {\n    return res.status(304).end(); // Not Modified\n  }\n\n  // Send cached response with ETag and cache headers\n  res.set('ETag', cached.etag);\n  res.set('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours\n  res.json(cached.body);\n}\n\n// =============================================================================\n// Server Configuration\n// =============================================================================\n\nconst app = express();\nconst PORT = process.env.PORT || 3847;\n\n// HTTPS certificates (generated by mkcert) - only for local development\nlet httpsOptions = null;\nif (!isProduction) {\n  const keyPath = path.join(__dirname, 'localhost+1-key.pem');\n  const certPath = path.join(__dirname, 'localhost+1.pem');\n  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {\n    httpsOptions = {\n      key: fs.readFileSync(keyPath),\n      cert: fs.readFileSync(certPath)\n    };\n  }\n}\n\n// =============================================================================\n// Security Configuration\n// =============================================================================\n\n// CORS whitelist - restrict origins in production\nconst CORS_WHITELIST = [\n  'http://localhost:3000',\n  'http://localhost:3847',\n  'https://localhost:3847',\n  'http://127.0.0.1:3000',\n  'http://127.0.0.1:3847',\n  'https://127.0.0.1:3847',\n  'https://splice.app',\n  'https://www.splice.app',\n  'https://splice-api-production.up.railway.app',\n  'https://splice-website.vercel.app',\n  // Adobe CEP/UXP panels run from file:// or bolt://\n  'file://',\n  'bolt://'\n];\n\nconst corsOptions = {\n  origin: function (origin, callback) {\n    // Allow requests with no origin (like mobile apps, Postman, or Adobe plugins)\n    if (!origin) {\n      return callback(null, true);\n    }\n    // Check if origin is in whitelist\n    if (CORS_WHITELIST.some(allowed => origin.startsWith(allowed) || origin === allowed)) {\n      return callback(null, true);\n    }\n    // In development, allow all origins with warning\n    if (!isProduction) {\n      console.warn(`[CORS] Non-whitelisted origin in dev: ${origin}`);\n      return callback(null, true);\n    }\n    // In production, reject non-whitelisted origins\n    console.error(`[CORS] Blocked request from: ${origin}`);\n    return callback(new Error('Not allowed by CORS'));\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'x-stripe-customer-id', 'stripe-signature']\n};\n\napp.use(cors(corsOptions));\n\n// SECURITY: Trust proxy for accurate client IP behind Railway/load balancers\n// This ensures rate limiting and logging use the correct client IP\nif (isProduction) {\n  app.set('trust proxy', 1);\n}\n\n// IP-based rate limiting (100 requests/minute per IP)\napp.use(ipRateLimit);\n\n// Security headers via helmet\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\", 'https://api.stripe.com', 'https://api.openai.com', 'https://api.replicate.com'],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },\n  noSniff: true,\n  xssFilter: true,\n  hidePoweredBy: true\n}));\n\n// Helper to determine tier from price ID with logging\n// Supports both monthly and annual pricing\nfunction getTierFromPriceId(priceId) {\n  // Monthly prices\n  if (priceId === process.env.STRIPE_PRICE_STARTER) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM) return 'team';\n\n  // Annual prices (same tier, just different billing period)\n  if (priceId === process.env.STRIPE_PRICE_STARTER_ANNUAL) return 'starter';\n  if (priceId === process.env.STRIPE_PRICE_PRO_ANNUAL) return 'pro';\n  if (priceId === process.env.STRIPE_PRICE_TEAM_ANNUAL) return 'team';\n\n  // Log unknown price ID for debugging\n  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n  return 'starter';\n}\n\n// =============================================================================\n// Stripe Webhook (must be before express.json())\n// =============================================================================\n\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n  let event;\n\n  try {\n    if (webhookSecret) {\n      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } else if (isProduction) {\n      // SECURITY: Reject unsigned webhooks in production\n      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n    } else {\n      // For local development testing only\n      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n      event = JSON.parse(bodyString);\n      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n    return res.status(400).json({ error: 'Webhook signature verification failed' });\n  }\n\n  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n\n  // Idempotency check - skip if already processed\n  if (await usageTracking.isEventProcessed(event.id)) {\n    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n    return res.json({ received: true, skipped: true });\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Get tier from price ID\n        const priceId = subscription.items?.data?.[0]?.price?.id;\n        const tier = getTierFromPriceId(priceId);\n\n        // Update user tier and reset hours\n        await usageTracking.updateTier(customerId, tier);\n        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n\n        // Initialize music credits for new subscriptions\n        if (event.type === 'customer.subscription.created') {\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Initialized music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Update trial end date if present\n        if (subscription.trial_end) {\n          await usageTracking.updateTrialEnd(customerId, subscription.trial_end);\n        }\n\n        // Generate license key for new subscriptions with retry and delivery\n        if (event.type === 'customer.subscription.created') {\n          let licenseResult = null;\n          let retryCount = 0;\n          const maxRetries = 3;\n\n          // Retry mechanism for license key generation\n          while (retryCount < maxRetries) {\n            licenseResult = await licenseService.generateLicenseKey(customerId);\n            if (licenseResult.success) {\n              break;\n            }\n            retryCount++;\n            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n            // Wait before retry (exponential backoff)\n            if (retryCount < maxRetries) {\n              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n            }\n          }\n\n          if (licenseResult && licenseResult.success) {\n            // SECURITY: Mask license key in logs\n            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n\n            // Store license key in Stripe subscription metadata as backup\n            try {\n              await stripe.subscriptions.update(subscription.id, {\n                metadata: {\n                  license_key: licenseResult.key,\n                  license_generated_at: new Date().toISOString()\n                }\n              });\n              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n            } catch (stripeErr) {\n              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n            }\n\n            // Get customer email and send license key\n            try {\n              const customer = await stripe.customers.retrieve(customerId);\n              if (customer.email) {\n                // SECURITY: Mask sensitive data in logs\n                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n\n                // Send license key email\n                try {\n                  await emailService.sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n                  console.log(`[SPLICE] License key email sent to ${maskSensitiveData(customer.email)}`);\n                } catch (sendErr) {\n                  // Log but don't fail - license is stored in Stripe metadata as backup\n                  console.error(`[SPLICE] Failed to send license email:`, sendErr.message);\n                }\n\n                // Store email in database for reference\n                await usageTracking.updateTier(customerId, tier, customer.email);\n              } else {\n                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n              }\n            } catch (emailErr) {\n              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n            }\n          } else {\n            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n            console.error(`[SPLICE] ${errorMsg}`);\n            return res.status(500).json({ error: errorMsg });\n          }\n        }\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Downgrade to cancelled (0 hours)\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const subscriptionId = invoice.subscription;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in invoice event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Reset hours on successful payment (new billing period)\n        let tier = 'starter';\n        if (subscriptionId) {\n          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n          const priceId = subscription.items?.data?.[0]?.price?.id;\n          tier = getTierFromPriceId(priceId);\n\n          await usageTracking.resetHours(customerId, tier);\n          await usageTracking.resetMusicCredits(customerId, tier);\n          console.log(`[SPLICE] Reset hours and music credits for customer ${customerId} (tier: ${tier})`);\n        }\n\n        // Check for affiliate coupon and record commission\n        const discount = invoice.discount;\n        if (discount && discount.coupon) {\n          const couponId = discount.coupon.id;\n          // Check if this is an affiliate code (like JIMMYN)\n          if (referralService.AFFILIATE_CODES[couponId]) {\n            const amountPaid = invoice.amount_paid / 100; // Convert cents to dollars\n            await referralService.recordAffiliateCommission(\n              couponId,\n              customerId,\n              amountPaid,\n              tier\n            );\n            console.log(`[SPLICE] Recorded affiliate commission for ${couponId}`);\n          }\n        }\n        break;\n      }\n\n      case 'invoice.payment_failed': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const attemptCount = invoice.attempt_count || 1;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in payment_failed event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        console.warn(`[SPLICE] Payment failed for customer ${customerId} (attempt ${attemptCount})`);\n\n        // Stripe will retry automatically per retry settings\n        // On final failure, Stripe will cancel subscription which triggers customer.subscription.deleted\n        // Send warning email on final attempt\n        if (attemptCount >= 3) {\n          console.error(`[SPLICE] Final payment attempt failed for customer ${customerId}`);\n          // Send warning email to customer about impending cancellation\n          try {\n            const customer = await stripe.customers.retrieve(customerId);\n            if (customer.email) {\n              await emailService.sendPaymentWarningEmail(customer.email, attemptCount);\n              console.log(`[SPLICE] Payment warning email sent to ${maskSensitiveData(customer.email)}`);\n            }\n          } catch (emailErr) {\n            console.error(`[SPLICE] Failed to send payment warning email:`, emailErr.message);\n          }\n        }\n        break;\n      }\n\n      case 'customer.deleted': {\n        const customer = event.data.object;\n        const customerId = customer.id;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in customer.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Clean up user data - downgrade to cancelled\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Customer deleted: ${customerId}`);\n        break;\n      }\n\n      default:\n        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n    }\n\n    // Record event as processed (idempotency)\n    await usageTracking.recordWebhookEvent(event.id, event.type);\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error('[SPLICE] Webhook handler error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Parse JSON body for all other routes\n// SECURITY: Limit JSON body size to prevent DoS attacks\napp.use(express.json({ limit: '10mb' }));\n\n// =============================================================================\n// Route Configuration Options\n// =============================================================================\n\nconst routeOptions = {\n  middleware: {\n    requireCredits,\n    requireFeature,\n    authenticateToken\n  },\n  services: {\n    usageTracking,\n    referralService,\n    licenseService,\n    emailService,\n    stripe\n  },\n  authHelpers: {\n    generateToken,\n    generateRefreshToken,\n    verifyToken,\n    maskSensitiveData\n  },\n  staticCache: STATIC_RESPONSE_CACHE,\n  sendCachedResponse\n};\n\n// =============================================================================\n// Mount Routes\n// =============================================================================\n\n// Health check and system endpoints (no prefix)\napp.use('/', healthRoutes(routeOptions));\n\n// Core analysis endpoints\napp.use('/', analyzeRoutes(routeOptions));\napp.use('/', silencesRoutes(routeOptions));\napp.use('/', detectionRoutes(routeOptions));\n\n// Export endpoints\napp.use('/export', exportRoutes(routeOptions));\n\n// Multitrack/Multicam endpoints\napp.use('/multitrack', multitrackRoutes(routeOptions));\n\n// Cut list generation\napp.use('/cut-list', cutListRoutes(routeOptions));\n\n// Legacy XML processing endpoint (backwards compatibility)\nconst { processXMLFile } = require('./services/xmlProcessor');\napp.post('/process-xml', requireCredits({ endpoint: 'process-xml' }), async (req, res) => {\n  const {\n    xmlPath,\n    silences,\n    removeGaps = true,\n    outputPath = null\n  } = req.body;\n\n  if (!xmlPath) {\n    return res.status(400).json({ error: 'xmlPath is required' });\n  }\n\n  if (!silences || !Array.isArray(silences)) {\n    return res.status(400).json({ error: 'silences array is required' });\n  }\n\n  if (!fs.existsSync(xmlPath)) {\n    return res.status(404).json({ error: `XML file not found: ${xmlPath}` });\n  }\n\n  console.log(`[SPLICE] Processing XML: ${xmlPath} with ${silences.length} silence(s)`);\n\n  try {\n    const result = await processXMLFile(xmlPath, silences, {\n      outputPath,\n      removeGaps\n    });\n\n    res.json({\n      success: true,\n      inputPath: xmlPath,\n      outputPath: result.outputPath,\n      stats: result.stats\n    });\n  } catch (err) {\n    console.error('[SPLICE] XML processing error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Auto zoom endpoints\napp.use('/zoom', zoomRoutes(routeOptions));\n\n// Chapter detection endpoints\napp.use('/chapters', chaptersRoutes(routeOptions));\n\n// YouTube content generation\napp.use('/youtube', youtubeRoutes(routeOptions));\n\n// Animated captions endpoints\napp.use('/captions', captionsRoutes(routeOptions));\n\n// Text-based editing endpoints\napp.use('/text-edit', textEditRoutes(routeOptions));\n\n// Social reframe endpoints\napp.use('/reframe', reframeRoutes(routeOptions));\napp.use('/faces', reframeRoutes.facesRouter(routeOptions));\n\n// Batch processing endpoints\napp.use('/batch', batchRoutes(routeOptions));\n\n// Authentication endpoints\napp.use('/auth', authRoutes(routeOptions));\n\n// Billing and credits endpoints\napp.use('/', billingRoutes(routeOptions));\n\n// Referral system endpoints\napp.use('/referral', referralRoutes(routeOptions));\n\n// License key endpoints\napp.use('/license', licenseRoutes(routeOptions));\n\n// AI Music generation endpoints\napp.use('/music', musicRoutes(routeOptions));\n\n// =============================================================================\n// Start Server\n// =============================================================================\n\n// Track active server for graceful shutdown\nlet server = null;\n\n// Initialize database and start server\nasync function startServer() {\n  try {\n    await usageTracking.initDatabase();\n    await referralService.initReferralTables();\n    await licenseService.initLicenseTables();\n    console.log('[SPLICE] Database initialized');\n\n    // PERF-FIX: Initialize static response cache at startup\n    initializeStaticCache();\n\n    if (isProduction || !httpsOptions) {\n      // Production: Railway provides TLS termination, use HTTP\n      server = http.createServer(app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at http://0.0.0.0:${PORT} (production)`);\n      });\n    } else {\n      // Development: Use HTTPS with local certificates\n      server = https.createServer(httpsOptions, app).listen(PORT, () => {\n        console.log(`[SPLICE] Backend running at https://127.0.0.1:${PORT} (development)`);\n        console.log(`[SPLICE] POST /analyze with { \"wavPath\": \"/path/to/audio.wav\" }`);\n      });\n    }\n  } catch (err) {\n    console.error('[SPLICE] Failed to start server:', err);\n    process.exit(1);\n  }\n}\n\n// =============================================================================\n// Graceful Shutdown\n// =============================================================================\n\nasync function gracefulShutdown(signal) {\n  console.log(`[SPLICE] Received ${signal}, starting graceful shutdown...`);\n\n  // Stop accepting new connections\n  if (server) {\n    server.close(() => {\n      console.log('[SPLICE] HTTP server closed');\n    });\n  }\n\n  // Close database pool\n  try {\n    await usageTracking.closePool();\n    console.log('[SPLICE] Database pool closed');\n  } catch (err) {\n    console.error('[SPLICE] Error closing database pool:', err.message);\n  }\n\n  // Give ongoing requests time to complete (max 10 seconds)\n  setTimeout(() => {\n    console.log('[SPLICE] Graceful shutdown complete');\n    process.exit(0);\n  }, 10000);\n}\n\n// Handle termination signals\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (err) => {\n  console.error('[SPLICE] Uncaught exception:', err);\n  gracefulShutdown('uncaughtException');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('[SPLICE] Unhandled rejection at:', promise, 'reason:', reason);\n});\n\nstartServer();\n","numLines":742,"startLine":1,"totalLines":742}}}
{"parentUuid":"f3f532b3-51df-4e70-a0d0-8e4e45820bce","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","message":{"model":"claude-opus-4-5-20251101","id":"msg_011d5oJzgeTsbTjopxWRdS2X","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the route files to verify the feature gating implementation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":35908,"cache_read_input_tokens":28934,"cache_creation":{"ephemeral_5m_input_tokens":35908,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWaKWokmo8LLhyzbmE6rX","type":"assistant","uuid":"3872d02e-c082-4369-bbd7-4af73fe86b9f","timestamp":"2025-12-29T04:07:43.934Z"}
{"parentUuid":"3872d02e-c082-4369-bbd7-4af73fe86b9f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","message":{"model":"claude-opus-4-5-20251101","id":"msg_011d5oJzgeTsbTjopxWRdS2X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qbw91HNAHCNWYUzdMWgC4b","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/reframe.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":35908,"cache_read_input_tokens":28934,"cache_creation":{"ephemeral_5m_input_tokens":35908,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWaKWokmo8LLhyzbmE6rX","type":"assistant","uuid":"3baaaecc-91e4-4186-afae-66a64e2846e7","timestamp":"2025-12-29T04:07:44.841Z"}
{"parentUuid":"3baaaecc-91e4-4186-afae-66a64e2846e7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","message":{"model":"claude-opus-4-5-20251101","id":"msg_011d5oJzgeTsbTjopxWRdS2X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Daf5qtYmL4qFqhAemoyE2Y","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/textEdit.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":35908,"cache_read_input_tokens":28934,"cache_creation":{"ephemeral_5m_input_tokens":35908,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWaKWokmo8LLhyzbmE6rX","type":"assistant","uuid":"633ae5b9-6685-4876-a2cc-b5399551219b","timestamp":"2025-12-29T04:07:45.512Z"}
{"parentUuid":"633ae5b9-6685-4876-a2cc-b5399551219b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","message":{"model":"claude-opus-4-5-20251101","id":"msg_011d5oJzgeTsbTjopxWRdS2X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CYXoeGHi1nYSBniRk7wLZk","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/routes/multitrack.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":35908,"cache_read_input_tokens":28934,"cache_creation":{"ephemeral_5m_input_tokens":35908,"ephemeral_1h_input_tokens":0},"output_tokens":198,"service_tier":"standard"}},"requestId":"req_011CWaKWokmo8LLhyzbmE6rX","type":"assistant","uuid":"f94cffdf-eb16-4353-8e89-484e4b42b734","timestamp":"2025-12-29T04:07:46.161Z"}
{"parentUuid":"f94cffdf-eb16-4353-8e89-484e4b42b734","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qbw91HNAHCNWYUzdMWgC4b","type":"tool_result","content":"     1→/**\n     2→ * Reframe Routes\n     3→ *\n     4→ * Social reframe and face detection endpoints\n     5→ */\n     6→\n     7→const express = require('express');\n     8→\n     9→/**\n    10→ * Create reframe routes\n    11→ * @param {Object} options - Route configuration options\n    12→ * @param {Object} options.middleware - Shared middleware (requireCredits)\n    13→ * @returns {express.Router}\n    14→ */\n    15→function createReframeRoutes(options = {}) {\n    16→  const router = express.Router();\n    17→  const { requireCredits, requireFeature } = options.middleware || {};\n    18→\n    19→  /**\n    20→   * POST /analyze - Analyze video for reframe with face tracking\n    21→   * Requires: Pro tier or higher (social_reframe feature)\n    22→   */\n    23→  router.post('/analyze', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    24→    const { videoPath, options: analyzeOptions = {} } = req.body;\n    25→\n    26→    if (!videoPath) {\n    27→      return res.status(400).json({ error: 'videoPath is required' });\n    28→    }\n    29→\n    30→    try {\n    31→      const { analyzeForReframe } = require('../services/socialReframe');\n    32→      const result = await analyzeForReframe(videoPath, analyzeOptions);\n    33→\n    34→      if (!result.success) {\n    35→        return res.status(400).json({ error: result.error });\n    36→      }\n    37→\n    38→      // Deduct usage\n    39→      if (req.deductUsage) {\n    40→        await req.deductUsage(1.0); // 1 credit for analysis\n    41→      }\n    42→\n    43→      res.json(result);\n    44→    } catch (err) {\n    45→      console.error('[SPLICE] Reframe analyze error:', err);\n    46→      res.status(500).json({ error: err.message });\n    47→    }\n    48→  });\n    49→\n    50→  /**\n    51→   * POST /calculate - Calculate crop positions for aspect ratio\n    52→   * Requires: Pro tier or higher (social_reframe feature)\n    53→   */\n    54→  router.post('/calculate', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    55→    const { tracking, targetAspect } = req.body;\n    56→\n    57→    if (!tracking) {\n    58→      return res.status(400).json({ error: 'tracking data is required' });\n    59→    }\n    60→\n    61→    if (!targetAspect) {\n    62→      return res.status(400).json({ error: 'targetAspect is required' });\n    63→    }\n    64→\n    65→    try {\n    66→      const { calculateReframeCrops } = require('../services/socialReframe');\n    67→      const result = calculateReframeCrops(tracking, targetAspect);\n    68→\n    69→      // Deduct usage\n    70→      if (req.deductUsage) {\n    71→        await req.deductUsage(0.25); // 0.25 credits\n    72→      }\n    73→\n    74→      res.json({ success: true, crops: result });\n    75→    } catch (err) {\n    76→      console.error('[SPLICE] Reframe calculate error:', err);\n    77→      res.status(500).json({ error: err.message });\n    78→    }\n    79→  });\n    80→\n    81→  /**\n    82→   * POST /motion-path - Generate smooth motion path\n    83→   * Requires: Pro tier or higher (social_reframe feature)\n    84→   */\n    85→  router.post('/motion-path', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    86→    const { crops, duration, frameRate } = req.body;\n    87→\n    88→    if (!crops || !Array.isArray(crops)) {\n    89→      return res.status(400).json({ error: 'crops array is required' });\n    90→    }\n    91→\n    92→    if (!duration || !frameRate) {\n    93→      return res.status(400).json({ error: 'duration and frameRate are required' });\n    94→    }\n    95→\n    96→    try {\n    97→      const { generateMotionPath } = require('../services/socialReframe');\n    98→      const result = generateMotionPath(crops, duration, frameRate);\n    99→\n   100→      if (!result.success) {\n   101→        return res.status(400).json({ error: result.error });\n   102→      }\n   103→\n   104→      // Deduct usage\n   105→      if (req.deductUsage) {\n   106→        await req.deductUsage(0.25); // 0.25 credits\n   107→      }\n   108→\n   109→      res.json(result);\n   110→    } catch (err) {\n   111→      console.error('[SPLICE] Reframe motion-path error:', err);\n   112→      res.status(500).json({ error: err.message });\n   113→    }\n   114→  });\n   115→\n   116→  /**\n   117→   * POST /export - Batch export all formats\n   118→   * Requires: Pro tier or higher (social_reframe feature)\n   119→   */\n   120→  router.post('/export', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n   121→    const { videoPath, formats = ['portrait', 'square'], settings = {} } = req.body;\n   122→\n   123→    if (!videoPath) {\n   124→      return res.status(400).json({ error: 'videoPath is required' });\n   125→    }\n   126→\n   127→    try {\n   128→      const { batchExportFormats } = require('../services/socialReframe');\n   129→      const result = await batchExportFormats(videoPath, formats, settings);\n   130→\n   131→      if (!result.success) {\n   132→        return res.status(400).json({ error: result.error });\n   133→      }\n   134→\n   135→      // Deduct usage per format\n   136→      if (req.deductUsage) {\n   137→        await req.deductUsage(0.5 * formats.length);\n   138→      }\n   139→\n   140→      res.json(result);\n   141→    } catch (err) {\n   142→      console.error('[SPLICE] Reframe export error:', err);\n   143→      res.status(500).json({ error: err.message });\n   144→    }\n   145→  });\n   146→\n   147→  /**\n   148→   * GET /platforms - Get available platforms and aspect ratios\n   149→   */\n   150→  router.get('/platforms', (req, res) => {\n   151→    const { getPlatformPresets } = require('../services/socialReframe');\n   152→    res.json(getPlatformPresets());\n   153→  });\n   154→\n   155→  /**\n   156→   * GET /safe-zones/:platform - Get safe zones for platform\n   157→   */\n   158→  router.get('/safe-zones/:platform', (req, res) => {\n   159→    const { getSafeZones } = require('../services/socialReframe');\n   160→    const result = getSafeZones(req.params.platform);\n   161→\n   162→    if (!result.success) {\n   163→      return res.status(404).json(result);\n   164→    }\n   165→\n   166→    res.json(result);\n   167→  });\n   168→\n   169→  return router;\n   170→}\n   171→\n   172→/**\n   173→ * Create faces router (separate router for /faces prefix)\n   174→ * @param {Object} options - Route configuration options\n   175→ * @returns {express.Router}\n   176→ */\n   177→function createFacesRouter(options = {}) {\n   178→  const router = express.Router();\n   179→  const { requireCredits, requireFeature } = options.middleware || {};\n   180→\n   181→  /**\n   182→   * POST /detect - Detect faces in video\n   183→   * Requires: Pro tier or higher (social_reframe feature)\n   184→   */\n   185→  router.post('/detect', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n   186→    const { videoPath, options: detectOptions = {} } = req.body;\n   187→\n   188→    if (!videoPath) {\n   189→      return res.status(400).json({ error: 'videoPath is required' });\n   190→    }\n   191→\n   192→    try {\n   193→      const { detectFaces } = require('../services/faceDetection');\n   194→      const result = await detectFaces(videoPath, detectOptions);\n   195→\n   196→      if (!result.success) {\n   197→        return res.status(400).json({ error: result.error });\n   198→      }\n   199→\n   200→      // Deduct usage\n   201→      if (req.deductUsage) {\n   202→        await req.deductUsage(0.5); // 0.5 credits\n   203→      }\n   204→\n   205→      res.json(result);\n   206→    } catch (err) {\n   207→      console.error('[SPLICE] Face detect error:', err);\n   208→      res.status(500).json({ error: err.message });\n   209→    }\n   210→  });\n   211→\n   212→  /**\n   213→   * POST /track - Track faces throughout video\n   214→   * Requires: Pro tier or higher (social_reframe feature)\n   215→   */\n   216→  router.post('/track', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n   217→    const { videoPath, options: trackOptions = {} } = req.body;\n   218→\n   219→    if (!videoPath) {\n   220→      return res.status(400).json({ error: 'videoPath is required' });\n   221→    }\n   222→\n   223→    try {\n   224→      const { trackFaces } = require('../services/faceDetection');\n   225→      const result = await trackFaces(videoPath, trackOptions);\n   226→\n   227→      if (!result.success) {\n   228→        return res.status(400).json({ error: result.error });\n   229→      }\n   230→\n   231→      // Deduct usage\n   232→      if (req.deductUsage) {\n   233→        await req.deductUsage(1.0); // 1 credit for tracking\n   234→      }\n   235→\n   236→      res.json(result);\n   237→    } catch (err) {\n   238→      console.error('[SPLICE] Face track error:', err);\n   239→      res.status(500).json({ error: err.message });\n   240→    }\n   241→  });\n   242→\n   243→  /**\n   244→   * POST /identify-speaker - Identify primary speaker\n   245→   * Requires: Pro tier or higher (social_reframe feature)\n   246→   */\n   247→  router.post('/identify-speaker', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n   248→    const { faces, audioAnalysis = null } = req.body;\n   249→\n   250→    if (!faces || !Array.isArray(faces)) {\n   251→      return res.status(400).json({ error: 'faces array is required' });\n   252→    }\n   253→\n   254→    try {\n   255→      const { identifySpeaker } = require('../services/faceDetection');\n   256→      const result = identifySpeaker(faces, audioAnalysis);\n   257→\n   258→      // Deduct usage for speaker identification\n   259→      if (req.deductUsage) {\n   260→        await req.deductUsage(0.1); // 0.1 credits for speaker identification\n   261→      }\n   262→\n   263→      res.json(result);\n   264→    } catch (err) {\n   265→      console.error('[SPLICE] Identify speaker error:', err);\n   266→      res.status(500).json({ error: err.message });\n   267→    }\n   268→  });\n   269→\n   270→  return router;\n   271→}\n   272→\n   273→// Attach facesRouter factory to main export\n   274→createReframeRoutes.facesRouter = createFacesRouter;\n   275→\n   276→module.exports = createReframeRoutes;\n   277→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ba48c508-3af8-44f9-8a73-0915ba5e92a2","timestamp":"2025-12-29T04:07:46.205Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/reframe.js","content":"/**\n * Reframe Routes\n *\n * Social reframe and face detection endpoints\n */\n\nconst express = require('express');\n\n/**\n * Create reframe routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (requireCredits)\n * @returns {express.Router}\n */\nfunction createReframeRoutes(options = {}) {\n  const router = express.Router();\n  const { requireCredits, requireFeature } = options.middleware || {};\n\n  /**\n   * POST /analyze - Analyze video for reframe with face tracking\n   * Requires: Pro tier or higher (social_reframe feature)\n   */\n  router.post('/analyze', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    const { videoPath, options: analyzeOptions = {} } = req.body;\n\n    if (!videoPath) {\n      return res.status(400).json({ error: 'videoPath is required' });\n    }\n\n    try {\n      const { analyzeForReframe } = require('../services/socialReframe');\n      const result = await analyzeForReframe(videoPath, analyzeOptions);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(1.0); // 1 credit for analysis\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Reframe analyze error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /calculate - Calculate crop positions for aspect ratio\n   * Requires: Pro tier or higher (social_reframe feature)\n   */\n  router.post('/calculate', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    const { tracking, targetAspect } = req.body;\n\n    if (!tracking) {\n      return res.status(400).json({ error: 'tracking data is required' });\n    }\n\n    if (!targetAspect) {\n      return res.status(400).json({ error: 'targetAspect is required' });\n    }\n\n    try {\n      const { calculateReframeCrops } = require('../services/socialReframe');\n      const result = calculateReframeCrops(tracking, targetAspect);\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(0.25); // 0.25 credits\n      }\n\n      res.json({ success: true, crops: result });\n    } catch (err) {\n      console.error('[SPLICE] Reframe calculate error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /motion-path - Generate smooth motion path\n   * Requires: Pro tier or higher (social_reframe feature)\n   */\n  router.post('/motion-path', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    const { crops, duration, frameRate } = req.body;\n\n    if (!crops || !Array.isArray(crops)) {\n      return res.status(400).json({ error: 'crops array is required' });\n    }\n\n    if (!duration || !frameRate) {\n      return res.status(400).json({ error: 'duration and frameRate are required' });\n    }\n\n    try {\n      const { generateMotionPath } = require('../services/socialReframe');\n      const result = generateMotionPath(crops, duration, frameRate);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(0.25); // 0.25 credits\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Reframe motion-path error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /export - Batch export all formats\n   * Requires: Pro tier or higher (social_reframe feature)\n   */\n  router.post('/export', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    const { videoPath, formats = ['portrait', 'square'], settings = {} } = req.body;\n\n    if (!videoPath) {\n      return res.status(400).json({ error: 'videoPath is required' });\n    }\n\n    try {\n      const { batchExportFormats } = require('../services/socialReframe');\n      const result = await batchExportFormats(videoPath, formats, settings);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage per format\n      if (req.deductUsage) {\n        await req.deductUsage(0.5 * formats.length);\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Reframe export error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * GET /platforms - Get available platforms and aspect ratios\n   */\n  router.get('/platforms', (req, res) => {\n    const { getPlatformPresets } = require('../services/socialReframe');\n    res.json(getPlatformPresets());\n  });\n\n  /**\n   * GET /safe-zones/:platform - Get safe zones for platform\n   */\n  router.get('/safe-zones/:platform', (req, res) => {\n    const { getSafeZones } = require('../services/socialReframe');\n    const result = getSafeZones(req.params.platform);\n\n    if (!result.success) {\n      return res.status(404).json(result);\n    }\n\n    res.json(result);\n  });\n\n  return router;\n}\n\n/**\n * Create faces router (separate router for /faces prefix)\n * @param {Object} options - Route configuration options\n * @returns {express.Router}\n */\nfunction createFacesRouter(options = {}) {\n  const router = express.Router();\n  const { requireCredits, requireFeature } = options.middleware || {};\n\n  /**\n   * POST /detect - Detect faces in video\n   * Requires: Pro tier or higher (social_reframe feature)\n   */\n  router.post('/detect', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    const { videoPath, options: detectOptions = {} } = req.body;\n\n    if (!videoPath) {\n      return res.status(400).json({ error: 'videoPath is required' });\n    }\n\n    try {\n      const { detectFaces } = require('../services/faceDetection');\n      const result = await detectFaces(videoPath, detectOptions);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(0.5); // 0.5 credits\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Face detect error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /track - Track faces throughout video\n   * Requires: Pro tier or higher (social_reframe feature)\n   */\n  router.post('/track', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    const { videoPath, options: trackOptions = {} } = req.body;\n\n    if (!videoPath) {\n      return res.status(400).json({ error: 'videoPath is required' });\n    }\n\n    try {\n      const { trackFaces } = require('../services/faceDetection');\n      const result = await trackFaces(videoPath, trackOptions);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(1.0); // 1 credit for tracking\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Face track error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /identify-speaker - Identify primary speaker\n   * Requires: Pro tier or higher (social_reframe feature)\n   */\n  router.post('/identify-speaker', requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe'), async (req, res) => {\n    const { faces, audioAnalysis = null } = req.body;\n\n    if (!faces || !Array.isArray(faces)) {\n      return res.status(400).json({ error: 'faces array is required' });\n    }\n\n    try {\n      const { identifySpeaker } = require('../services/faceDetection');\n      const result = identifySpeaker(faces, audioAnalysis);\n\n      // Deduct usage for speaker identification\n      if (req.deductUsage) {\n        await req.deductUsage(0.1); // 0.1 credits for speaker identification\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Identify speaker error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  return router;\n}\n\n// Attach facesRouter factory to main export\ncreateReframeRoutes.facesRouter = createFacesRouter;\n\nmodule.exports = createReframeRoutes;\n","numLines":277,"startLine":1,"totalLines":277}}}
{"parentUuid":"ba48c508-3af8-44f9-8a73-0915ba5e92a2","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Daf5qtYmL4qFqhAemoyE2Y","type":"tool_result","content":"     1→/**\n     2→ * Text Edit Routes\n     3→ *\n     4→ * Text-based editing endpoints\n     5→ */\n     6→\n     7→const express = require('express');\n     8→\n     9→/**\n    10→ * Create text edit routes\n    11→ * @param {Object} options - Route configuration options\n    12→ * @param {Object} options.middleware - Shared middleware (requireCredits)\n    13→ * @returns {express.Router}\n    14→ */\n    15→function createTextEditRoutes(options = {}) {\n    16→  const router = express.Router();\n    17→  const { requireCredits, requireFeature } = options.middleware || {};\n    18→\n    19→  /**\n    20→   * POST /prepare - Create editable transcript structure\n    21→   * Requires: Pro tier or higher (text_editing feature)\n    22→   *\n    23→   * Converts transcript to editable format with unique word IDs.\n    24→   */\n    25→  router.post('/prepare', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n    26→    const { transcript } = req.body;\n    27→\n    28→    if (!transcript) {\n    29→      return res.status(400).json({ error: 'transcript is required' });\n    30→    }\n    31→\n    32→    try {\n    33→      const { generateEditableTranscript } = require('../services/textBasedEditing');\n    34→      const result = generateEditableTranscript(transcript);\n    35→\n    36→      if (!result.success) {\n    37→        return res.status(400).json({ error: result.error });\n    38→      }\n    39→\n    40→      // Deduct usage\n    41→      if (req.deductUsage) {\n    42→        await req.deductUsage(0.25); // 0.25 credits\n    43→      }\n    44→\n    45→      res.json(result);\n    46→    } catch (err) {\n    47→      console.error('[SPLICE] Text-edit prepare error:', err);\n    48→      res.status(500).json({ error: err.message });\n    49→    }\n    50→  });\n    51→\n    52→  /**\n    53→   * POST /apply - Apply text edits and get operations\n    54→   * Requires: Pro tier or higher (text_editing feature)\n    55→   *\n    56→   * Compares original and edited text, returns edit operations.\n    57→   */\n    58→  router.post('/apply', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n    59→    const { transcript, editedText } = req.body;\n    60→\n    61→    if (!transcript) {\n    62→      return res.status(400).json({ error: 'transcript is required' });\n    63→    }\n    64→\n    65→    if (typeof editedText !== 'string') {\n    66→      return res.status(400).json({ error: 'editedText is required' });\n    67→    }\n    68→\n    69→    try {\n    70→      const { applyTextEdits } = require('../services/textBasedEditing');\n    71→      const result = applyTextEdits(transcript, editedText);\n    72→\n    73→      if (!result.success) {\n    74→        return res.status(400).json({ error: result.error });\n    75→      }\n    76→\n    77→      // Deduct usage\n    78→      if (req.deductUsage) {\n    79→        await req.deductUsage(0.5); // 0.5 credits\n    80→      }\n    81→\n    82→      res.json(result);\n    83→    } catch (err) {\n    84→      console.error('[SPLICE] Text-edit apply error:', err);\n    85→      res.status(500).json({ error: err.message });\n    86→    }\n    87→  });\n    88→\n    89→  /**\n    90→   * POST /search - Search transcript with timestamps\n    91→   * Requires: Pro tier or higher (text_editing feature)\n    92→   */\n    93→  router.post('/search', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n    94→    const { transcript, searchText } = req.body;\n    95→\n    96→    if (!transcript) {\n    97→      return res.status(400).json({ error: 'transcript is required' });\n    98→    }\n    99→\n   100→    if (!searchText) {\n   101→      return res.status(400).json({ error: 'searchText is required' });\n   102→    }\n   103→\n   104→    try {\n   105→      const { searchTranscript } = require('../services/textBasedEditing');\n   106→      const result = searchTranscript(transcript, searchText);\n   107→\n   108→      if (!result.success) {\n   109→        return res.status(400).json({ error: result.error });\n   110→      }\n   111→\n   112→      // Deduct usage\n   113→      if (req.deductUsage) {\n   114→        await req.deductUsage(0.1); // 0.1 credits\n   115→      }\n   116→\n   117→      res.json(result);\n   118→    } catch (err) {\n   119→      console.error('[SPLICE] Text-edit search error:', err);\n   120→      res.status(500).json({ error: err.message });\n   121→    }\n   122→  });\n   123→\n   124→  /**\n   125→   * POST /replace - Search and replace (generates cut operations)\n   126→   * Requires: Pro tier or higher (text_editing feature)\n   127→   */\n   128→  router.post('/replace', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n   129→    const { transcript, searchText, replaceText = '' } = req.body;\n   130→\n   131→    if (!transcript) {\n   132→      return res.status(400).json({ error: 'transcript is required' });\n   133→    }\n   134→\n   135→    if (!searchText) {\n   136→      return res.status(400).json({ error: 'searchText is required' });\n   137→    }\n   138→\n   139→    try {\n   140→      const { searchAndReplace } = require('../services/textBasedEditing');\n   141→      const result = searchAndReplace(transcript, searchText, replaceText);\n   142→\n   143→      if (!result.success) {\n   144→        return res.status(400).json({ error: result.error });\n   145→      }\n   146→\n   147→      // Deduct usage\n   148→      if (req.deductUsage) {\n   149→        await req.deductUsage(0.25); // 0.25 credits\n   150→      }\n   151→\n   152→      res.json(result);\n   153→    } catch (err) {\n   154→      console.error('[SPLICE] Text-edit replace error:', err);\n   155→      res.status(500).json({ error: err.message });\n   156→    }\n   157→  });\n   158→\n   159→  /**\n   160→   * POST /preview - Preview edits without applying\n   161→   * Requires: Pro tier or higher (text_editing feature)\n   162→   */\n   163→  router.post('/preview', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n   164→    const { transcript, editedText } = req.body;\n   165→\n   166→    if (!transcript) {\n   167→      return res.status(400).json({ error: 'transcript is required' });\n   168→    }\n   169→\n   170→    if (typeof editedText !== 'string') {\n   171→      return res.status(400).json({ error: 'editedText is required' });\n   172→    }\n   173→\n   174→    try {\n   175→      const { previewEdits } = require('../services/textBasedEditing');\n   176→      const result = previewEdits(transcript, editedText);\n   177→\n   178→      if (!result.success) {\n   179→        return res.status(400).json({ error: result.error });\n   180→      }\n   181→\n   182→      // Deduct usage (small amount for preview)\n   183→      if (req.deductUsage) {\n   184→        await req.deductUsage(0.1); // 0.1 credits\n   185→      }\n   186→\n   187→      res.json(result);\n   188→    } catch (err) {\n   189→      console.error('[SPLICE] Text-edit preview error:', err);\n   190→      res.status(500).json({ error: err.message });\n   191→    }\n   192→  });\n   193→\n   194→  /**\n   195→   * POST /cut-list - Generate cut list from edit operations\n   196→   * Requires: Pro tier or higher (text_editing feature)\n   197→   */\n   198→  router.post('/cut-list', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n   199→    const { operations, sourceInfo = {} } = req.body;\n   200→\n   201→    if (!operations || !Array.isArray(operations)) {\n   202→      return res.status(400).json({ error: 'operations array is required' });\n   203→    }\n   204→\n   205→    try {\n   206→      const { generateEditCutList } = require('../services/textBasedEditing');\n   207→      const result = generateEditCutList(operations, sourceInfo);\n   208→\n   209→      if (!result.success) {\n   210→        return res.status(400).json({ error: result.error });\n   211→      }\n   212→\n   213→      // Deduct usage\n   214→      if (req.deductUsage) {\n   215→        await req.deductUsage(0.25); // 0.25 credits\n   216→      }\n   217→\n   218→      res.json(result);\n   219→    } catch (err) {\n   220→      console.error('[SPLICE] Text-edit cut-list error:', err);\n   221→      res.status(500).json({ error: err.message });\n   222→    }\n   223→  });\n   224→\n   225→  return router;\n   226→}\n   227→\n   228→module.exports = createTextEditRoutes;\n   229→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"676d82e9-6686-4118-a83d-3331ec70363f","timestamp":"2025-12-29T04:07:46.205Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/textEdit.js","content":"/**\n * Text Edit Routes\n *\n * Text-based editing endpoints\n */\n\nconst express = require('express');\n\n/**\n * Create text edit routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (requireCredits)\n * @returns {express.Router}\n */\nfunction createTextEditRoutes(options = {}) {\n  const router = express.Router();\n  const { requireCredits, requireFeature } = options.middleware || {};\n\n  /**\n   * POST /prepare - Create editable transcript structure\n   * Requires: Pro tier or higher (text_editing feature)\n   *\n   * Converts transcript to editable format with unique word IDs.\n   */\n  router.post('/prepare', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n    const { transcript } = req.body;\n\n    if (!transcript) {\n      return res.status(400).json({ error: 'transcript is required' });\n    }\n\n    try {\n      const { generateEditableTranscript } = require('../services/textBasedEditing');\n      const result = generateEditableTranscript(transcript);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(0.25); // 0.25 credits\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Text-edit prepare error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /apply - Apply text edits and get operations\n   * Requires: Pro tier or higher (text_editing feature)\n   *\n   * Compares original and edited text, returns edit operations.\n   */\n  router.post('/apply', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n    const { transcript, editedText } = req.body;\n\n    if (!transcript) {\n      return res.status(400).json({ error: 'transcript is required' });\n    }\n\n    if (typeof editedText !== 'string') {\n      return res.status(400).json({ error: 'editedText is required' });\n    }\n\n    try {\n      const { applyTextEdits } = require('../services/textBasedEditing');\n      const result = applyTextEdits(transcript, editedText);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(0.5); // 0.5 credits\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Text-edit apply error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /search - Search transcript with timestamps\n   * Requires: Pro tier or higher (text_editing feature)\n   */\n  router.post('/search', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n    const { transcript, searchText } = req.body;\n\n    if (!transcript) {\n      return res.status(400).json({ error: 'transcript is required' });\n    }\n\n    if (!searchText) {\n      return res.status(400).json({ error: 'searchText is required' });\n    }\n\n    try {\n      const { searchTranscript } = require('../services/textBasedEditing');\n      const result = searchTranscript(transcript, searchText);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(0.1); // 0.1 credits\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Text-edit search error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /replace - Search and replace (generates cut operations)\n   * Requires: Pro tier or higher (text_editing feature)\n   */\n  router.post('/replace', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n    const { transcript, searchText, replaceText = '' } = req.body;\n\n    if (!transcript) {\n      return res.status(400).json({ error: 'transcript is required' });\n    }\n\n    if (!searchText) {\n      return res.status(400).json({ error: 'searchText is required' });\n    }\n\n    try {\n      const { searchAndReplace } = require('../services/textBasedEditing');\n      const result = searchAndReplace(transcript, searchText, replaceText);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(0.25); // 0.25 credits\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Text-edit replace error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /preview - Preview edits without applying\n   * Requires: Pro tier or higher (text_editing feature)\n   */\n  router.post('/preview', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n    const { transcript, editedText } = req.body;\n\n    if (!transcript) {\n      return res.status(400).json({ error: 'transcript is required' });\n    }\n\n    if (typeof editedText !== 'string') {\n      return res.status(400).json({ error: 'editedText is required' });\n    }\n\n    try {\n      const { previewEdits } = require('../services/textBasedEditing');\n      const result = previewEdits(transcript, editedText);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage (small amount for preview)\n      if (req.deductUsage) {\n        await req.deductUsage(0.1); // 0.1 credits\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Text-edit preview error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /cut-list - Generate cut list from edit operations\n   * Requires: Pro tier or higher (text_editing feature)\n   */\n  router.post('/cut-list', requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing'), async (req, res) => {\n    const { operations, sourceInfo = {} } = req.body;\n\n    if (!operations || !Array.isArray(operations)) {\n      return res.status(400).json({ error: 'operations array is required' });\n    }\n\n    try {\n      const { generateEditCutList } = require('../services/textBasedEditing');\n      const result = generateEditCutList(operations, sourceInfo);\n\n      if (!result.success) {\n        return res.status(400).json({ error: result.error });\n      }\n\n      // Deduct usage\n      if (req.deductUsage) {\n        await req.deductUsage(0.25); // 0.25 credits\n      }\n\n      res.json(result);\n    } catch (err) {\n      console.error('[SPLICE] Text-edit cut-list error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createTextEditRoutes;\n","numLines":229,"startLine":1,"totalLines":229}}}
{"parentUuid":"676d82e9-6686-4118-a83d-3331ec70363f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CYXoeGHi1nYSBniRk7wLZk","type":"tool_result","content":"     1→/**\n     2→ * Multitrack Routes\n     3→ *\n     4→ * Multitrack/Multicam analysis endpoints\n     5→ */\n     6→\n     7→const express = require('express');\n     8→const fs = require('fs');\n     9→const { isFFprobeInstalled } = require('../services/ffprobeSilence');\n    10→const {\n    11→  analyzeMultitrack,\n    12→  autoBalanceMultitrack,\n    13→  advancedBalanceMultitrack\n    14→} = require('../services/multitrackAnalysis');\n    15→\n    16→/**\n    17→ * Create multitrack routes\n    18→ * @param {Object} options - Route configuration options\n    19→ * @param {Object} options.middleware - Shared middleware (requireCredits)\n    20→ * @returns {express.Router}\n    21→ */\n    22→function createMultitrackRoutes(options = {}) {\n    23→  const router = express.Router();\n    24→  const { requireCredits, requireFeature } = options.middleware || {};\n    25→\n    26→  /**\n    27→   * POST / - Analyze multiple audio tracks for multicam editing\n    28→   *\n    29→   * Analyzes audio levels across multiple tracks to determine optimal\n    30→   * video angle selection based on who is speaking.\n    31→   *\n    32→   * Options:\n    33→   * - audioPaths: Array of paths to audio files (one per speaker) - required\n    34→   * - speakerNames: Array of speaker names (optional)\n    35→   * - videoTrackMapping: Object mapping speaker index to video track { 0: 0, 1: 1 }\n    36→   * - minShotDuration: Minimum seconds before next cut (default: 2.0)\n    37→   * - switchingFrequency: How often to allow cuts 0-100 (default: 50)\n    38→   * - wideShotEnabled: Enable wide shot detection (default: true)\n    39→   * - wideShotPercentage: Target % of wide shots (default: 20)\n    40→   * - wideShotTracks: Video track indices for wide shots\n    41→   * - cutawayEnabled: Enable cutaway insertion (default: false)\n    42→   * - cutawayTracks: Video track indices for cutaways\n    43→   * - speakerBoosts: Per-speaker dB adjustments { \"Speaker 1\": 5 }\n    44→   *\n    45→   * Requires: Team tier (multitrack feature)\n    46→   */\n    47→  router.post('/', requireCredits({ endpoint: 'multitrack' }), requireFeature('multitrack'), async (req, res) => {\n    48→    const {\n    49→      audioPaths,\n    50→      speakerNames,\n    51→      videoTrackMapping = {},\n    52→      minShotDuration = 2.0,\n    53→      switchingFrequency = 50,\n    54→      wideShotEnabled = true,\n    55→      wideShotPercentage = 20,\n    56→      wideShotTracks = [],\n    57→      cutawayEnabled = false,\n    58→      cutawayTracks = [],\n    59→      speakerBoosts = {},\n    60→      frameRate = 30\n    61→    } = req.body;\n    62→\n    63→    // Validate audioPaths\n    64→    if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length === 0) {\n    65→      return res.status(400).json({ error: 'audioPaths array is required (at least 1 path)' });\n    66→    }\n    67→\n    68→    // Validate all files exist\n    69→    for (const audioPath of audioPaths) {\n    70→      if (!fs.existsSync(audioPath)) {\n    71→        return res.status(404).json({ error: `File not found: ${audioPath}` });\n    72→      }\n    73→    }\n    74→\n    75→    // Check FFprobe availability\n    76→    const ffprobeAvailable = await isFFprobeInstalled();\n    77→    if (!ffprobeAvailable) {\n    78→      return res.status(500).json({\n    79→        error: 'FFprobe not installed. Run: brew install ffmpeg'\n    80→      });\n    81→    }\n    82→\n    83→    console.log(`[SPLICE] Multitrack analysis: ${audioPaths.length} track(s)`);\n    84→\n    85→    try {\n    86→      const result = await analyzeMultitrack(audioPaths, {\n    87→        speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n    88→        videoTrackMapping,\n    89→        minShotDuration,\n    90→        switchingFrequency,\n    91→        wideShotEnabled,\n    92→        wideShotPercentage,\n    93→        wideShotTracks,\n    94→        cutawayEnabled,\n    95→        cutawayTracks,\n    96→        speakerBoosts,\n    97→        frameRate\n    98→      });\n    99→\n   100→      // Deduct usage based on total duration (use longest track)\n   101→      const audioDuration = result.metadata?.totalDuration || 0;\n   102→      let balance = null;\n   103→      if (audioDuration > 0 && req.deductUsage) {\n   104→        balance = await req.deductUsage(audioDuration);\n   105→      }\n   106→\n   107→      res.json({\n   108→        success: true,\n   109→        ...result,\n   110→        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   111→      });\n   112→    } catch (err) {\n   113→      console.error('[SPLICE] Multitrack analysis error:', err);\n   114→      res.status(500).json({ error: err.message });\n   115→    }\n   116→  });\n   117→\n   118→  /**\n   119→   * POST /auto-balance - Auto-balance speaker screentime\n   120→   * Requires: Team tier (multitrack feature)\n   121→   *\n   122→   * Automatically adjusts speaker boosts to achieve equal screentime distribution.\n   123→   * Runs multiple iterations to find optimal parameters.\n   124→   */\n   125→  router.post('/auto-balance', requireCredits({ endpoint: 'multitrack-auto-balance' }), requireFeature('multitrack'), async (req, res) => {\n   126→    const {\n   127→      audioPaths,\n   128→      speakerNames,\n   129→      videoTrackMapping = {},\n   130→      minShotDuration = 2.0,\n   131→      switchingFrequency = 50,\n   132→      wideShotEnabled = false, // Disable wide shots for balance calc\n   133→      frameRate = 30\n   134→    } = req.body;\n   135→\n   136→    // Validate audioPaths\n   137→    if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length < 2) {\n   138→      return res.status(400).json({ error: 'audioPaths array requires at least 2 tracks for balancing' });\n   139→    }\n   140→\n   141→    // Validate all files exist\n   142→    for (const audioPath of audioPaths) {\n   143→      if (!fs.existsSync(audioPath)) {\n   144→        return res.status(404).json({ error: `File not found: ${audioPath}` });\n   145→      }\n   146→    }\n   147→\n   148→    // Check FFprobe availability\n   149→    const ffprobeAvailable = await isFFprobeInstalled();\n   150→    if (!ffprobeAvailable) {\n   151→      return res.status(500).json({\n   152→        error: 'FFprobe not installed. Run: brew install ffmpeg'\n   153→      });\n   154→    }\n   155→\n   156→    console.log(`[SPLICE] Auto-balancing multitrack: ${audioPaths.length} track(s)`);\n   157→\n   158→    try {\n   159→      const result = await autoBalanceMultitrack(audioPaths, {\n   160→        speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n   161→        videoTrackMapping,\n   162→        minShotDuration,\n   163→        switchingFrequency,\n   164→        wideShotEnabled,\n   165→        frameRate\n   166→      });\n   167→\n   168→      // Deduct usage based on total duration\n   169→      const audioDuration = result.metadata?.totalDuration || 0;\n   170→      let balance = null;\n   171→      if (audioDuration > 0 && req.deductUsage) {\n   172→        balance = await req.deductUsage(audioDuration);\n   173→      }\n   174→\n   175→      res.json({\n   176→        success: true,\n   177→        ...result,\n   178→        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   179→      });\n   180→    } catch (err) {\n   181→      console.error('[SPLICE] Auto-balance error:', err);\n   182→      res.status(500).json({ error: err.message });\n   183→    }\n   184→  });\n   185→\n   186→  /**\n   187→   * POST /advanced-balance - Advanced GA-optimized balancing\n   188→   * Requires: Team tier (multitrack feature)\n   189→   *\n   190→   * Uses genetic algorithm optimization with constraints:\n   191→   * - maxConsecutiveSeconds: Prevent single speaker dominating too long\n   192→   * - momentumFactor: Reduce rapid switching between speakers\n   193→   * - targetDistribution: Custom target percentages per speaker\n   194→   */\n   195→  router.post('/advanced-balance', requireCredits({ endpoint: 'multitrack-advanced' }), requireFeature('multitrack'), async (req, res) => {\n   196→    const {\n   197→      audioPaths,\n   198→      speakerNames,\n   199→      videoTrackMapping = {},\n   200→      minShotDuration = 2.0,\n   201→      switchingFrequency = 50,\n   202→      frameRate = 30,\n   203→      // Advanced options\n   204→      maxConsecutiveSeconds = 30,\n   205→      momentumFactor = 0.7,\n   206→      populationSize = 20,\n   207→      generations = 10,\n   208→      targetDistribution = null\n   209→    } = req.body;\n   210→\n   211→    // Validate audioPaths\n   212→    if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length < 2) {\n   213→      return res.status(400).json({ error: 'audioPaths array requires at least 2 tracks for balancing' });\n   214→    }\n   215→\n   216→    // Validate all files exist\n   217→    for (const audioPath of audioPaths) {\n   218→      if (!fs.existsSync(audioPath)) {\n   219→        return res.status(404).json({ error: `File not found: ${audioPath}` });\n   220→      }\n   221→    }\n   222→\n   223→    // Validate constraints\n   224→    if (maxConsecutiveSeconds < 5 || maxConsecutiveSeconds > 120) {\n   225→      return res.status(400).json({ error: 'maxConsecutiveSeconds must be between 5 and 120' });\n   226→    }\n   227→    if (momentumFactor < 0 || momentumFactor > 1) {\n   228→      return res.status(400).json({ error: 'momentumFactor must be between 0 and 1' });\n   229→    }\n   230→\n   231→    // Check FFprobe availability\n   232→    const ffprobeAvailable = await isFFprobeInstalled();\n   233→    if (!ffprobeAvailable) {\n   234→      return res.status(500).json({\n   235→        error: 'FFprobe not installed. Run: brew install ffmpeg'\n   236→      });\n   237→    }\n   238→\n   239→    console.log(`[SPLICE] Advanced balancing multitrack: ${audioPaths.length} track(s)`);\n   240→    console.log(`  - Max consecutive: ${maxConsecutiveSeconds}s, Momentum: ${momentumFactor}`);\n   241→\n   242→    try {\n   243→      const result = await advancedBalanceMultitrack(audioPaths, {\n   244→        speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n   245→        videoTrackMapping,\n   246→        minShotDuration,\n   247→        switchingFrequency,\n   248→        frameRate,\n   249→        maxConsecutiveSeconds,\n   250→        momentumFactor,\n   251→        populationSize,\n   252→        generations,\n   253→        targetDistribution\n   254→      });\n   255→\n   256→      // Deduct usage based on total duration\n   257→      const audioDuration = result.metadata?.totalDuration || 0;\n   258→      let balance = null;\n   259→      if (audioDuration > 0 && req.deductUsage) {\n   260→        balance = await req.deductUsage(audioDuration);\n   261→      }\n   262→\n   263→      res.json({\n   264→        success: true,\n   265→        ...result,\n   266→        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n   267→      });\n   268→    } catch (err) {\n   269→      console.error('[SPLICE] Advanced balance error:', err);\n   270→      res.status(500).json({ error: err.message });\n   271→    }\n   272→  });\n   273→\n   274→  return router;\n   275→}\n   276→\n   277→module.exports = createMultitrackRoutes;\n   278→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c5f35d8e-10ab-41ef-9b91-a48faa054fa4","timestamp":"2025-12-29T04:07:46.205Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/routes/multitrack.js","content":"/**\n * Multitrack Routes\n *\n * Multitrack/Multicam analysis endpoints\n */\n\nconst express = require('express');\nconst fs = require('fs');\nconst { isFFprobeInstalled } = require('../services/ffprobeSilence');\nconst {\n  analyzeMultitrack,\n  autoBalanceMultitrack,\n  advancedBalanceMultitrack\n} = require('../services/multitrackAnalysis');\n\n/**\n * Create multitrack routes\n * @param {Object} options - Route configuration options\n * @param {Object} options.middleware - Shared middleware (requireCredits)\n * @returns {express.Router}\n */\nfunction createMultitrackRoutes(options = {}) {\n  const router = express.Router();\n  const { requireCredits, requireFeature } = options.middleware || {};\n\n  /**\n   * POST / - Analyze multiple audio tracks for multicam editing\n   *\n   * Analyzes audio levels across multiple tracks to determine optimal\n   * video angle selection based on who is speaking.\n   *\n   * Options:\n   * - audioPaths: Array of paths to audio files (one per speaker) - required\n   * - speakerNames: Array of speaker names (optional)\n   * - videoTrackMapping: Object mapping speaker index to video track { 0: 0, 1: 1 }\n   * - minShotDuration: Minimum seconds before next cut (default: 2.0)\n   * - switchingFrequency: How often to allow cuts 0-100 (default: 50)\n   * - wideShotEnabled: Enable wide shot detection (default: true)\n   * - wideShotPercentage: Target % of wide shots (default: 20)\n   * - wideShotTracks: Video track indices for wide shots\n   * - cutawayEnabled: Enable cutaway insertion (default: false)\n   * - cutawayTracks: Video track indices for cutaways\n   * - speakerBoosts: Per-speaker dB adjustments { \"Speaker 1\": 5 }\n   *\n   * Requires: Team tier (multitrack feature)\n   */\n  router.post('/', requireCredits({ endpoint: 'multitrack' }), requireFeature('multitrack'), async (req, res) => {\n    const {\n      audioPaths,\n      speakerNames,\n      videoTrackMapping = {},\n      minShotDuration = 2.0,\n      switchingFrequency = 50,\n      wideShotEnabled = true,\n      wideShotPercentage = 20,\n      wideShotTracks = [],\n      cutawayEnabled = false,\n      cutawayTracks = [],\n      speakerBoosts = {},\n      frameRate = 30\n    } = req.body;\n\n    // Validate audioPaths\n    if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length === 0) {\n      return res.status(400).json({ error: 'audioPaths array is required (at least 1 path)' });\n    }\n\n    // Validate all files exist\n    for (const audioPath of audioPaths) {\n      if (!fs.existsSync(audioPath)) {\n        return res.status(404).json({ error: `File not found: ${audioPath}` });\n      }\n    }\n\n    // Check FFprobe availability\n    const ffprobeAvailable = await isFFprobeInstalled();\n    if (!ffprobeAvailable) {\n      return res.status(500).json({\n        error: 'FFprobe not installed. Run: brew install ffmpeg'\n      });\n    }\n\n    console.log(`[SPLICE] Multitrack analysis: ${audioPaths.length} track(s)`);\n\n    try {\n      const result = await analyzeMultitrack(audioPaths, {\n        speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n        videoTrackMapping,\n        minShotDuration,\n        switchingFrequency,\n        wideShotEnabled,\n        wideShotPercentage,\n        wideShotTracks,\n        cutawayEnabled,\n        cutawayTracks,\n        speakerBoosts,\n        frameRate\n      });\n\n      // Deduct usage based on total duration (use longest track)\n      const audioDuration = result.metadata?.totalDuration || 0;\n      let balance = null;\n      if (audioDuration > 0 && req.deductUsage) {\n        balance = await req.deductUsage(audioDuration);\n      }\n\n      res.json({\n        success: true,\n        ...result,\n        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n      });\n    } catch (err) {\n      console.error('[SPLICE] Multitrack analysis error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /auto-balance - Auto-balance speaker screentime\n   * Requires: Team tier (multitrack feature)\n   *\n   * Automatically adjusts speaker boosts to achieve equal screentime distribution.\n   * Runs multiple iterations to find optimal parameters.\n   */\n  router.post('/auto-balance', requireCredits({ endpoint: 'multitrack-auto-balance' }), requireFeature('multitrack'), async (req, res) => {\n    const {\n      audioPaths,\n      speakerNames,\n      videoTrackMapping = {},\n      minShotDuration = 2.0,\n      switchingFrequency = 50,\n      wideShotEnabled = false, // Disable wide shots for balance calc\n      frameRate = 30\n    } = req.body;\n\n    // Validate audioPaths\n    if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length < 2) {\n      return res.status(400).json({ error: 'audioPaths array requires at least 2 tracks for balancing' });\n    }\n\n    // Validate all files exist\n    for (const audioPath of audioPaths) {\n      if (!fs.existsSync(audioPath)) {\n        return res.status(404).json({ error: `File not found: ${audioPath}` });\n      }\n    }\n\n    // Check FFprobe availability\n    const ffprobeAvailable = await isFFprobeInstalled();\n    if (!ffprobeAvailable) {\n      return res.status(500).json({\n        error: 'FFprobe not installed. Run: brew install ffmpeg'\n      });\n    }\n\n    console.log(`[SPLICE] Auto-balancing multitrack: ${audioPaths.length} track(s)`);\n\n    try {\n      const result = await autoBalanceMultitrack(audioPaths, {\n        speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n        videoTrackMapping,\n        minShotDuration,\n        switchingFrequency,\n        wideShotEnabled,\n        frameRate\n      });\n\n      // Deduct usage based on total duration\n      const audioDuration = result.metadata?.totalDuration || 0;\n      let balance = null;\n      if (audioDuration > 0 && req.deductUsage) {\n        balance = await req.deductUsage(audioDuration);\n      }\n\n      res.json({\n        success: true,\n        ...result,\n        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n      });\n    } catch (err) {\n      console.error('[SPLICE] Auto-balance error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  /**\n   * POST /advanced-balance - Advanced GA-optimized balancing\n   * Requires: Team tier (multitrack feature)\n   *\n   * Uses genetic algorithm optimization with constraints:\n   * - maxConsecutiveSeconds: Prevent single speaker dominating too long\n   * - momentumFactor: Reduce rapid switching between speakers\n   * - targetDistribution: Custom target percentages per speaker\n   */\n  router.post('/advanced-balance', requireCredits({ endpoint: 'multitrack-advanced' }), requireFeature('multitrack'), async (req, res) => {\n    const {\n      audioPaths,\n      speakerNames,\n      videoTrackMapping = {},\n      minShotDuration = 2.0,\n      switchingFrequency = 50,\n      frameRate = 30,\n      // Advanced options\n      maxConsecutiveSeconds = 30,\n      momentumFactor = 0.7,\n      populationSize = 20,\n      generations = 10,\n      targetDistribution = null\n    } = req.body;\n\n    // Validate audioPaths\n    if (!audioPaths || !Array.isArray(audioPaths) || audioPaths.length < 2) {\n      return res.status(400).json({ error: 'audioPaths array requires at least 2 tracks for balancing' });\n    }\n\n    // Validate all files exist\n    for (const audioPath of audioPaths) {\n      if (!fs.existsSync(audioPath)) {\n        return res.status(404).json({ error: `File not found: ${audioPath}` });\n      }\n    }\n\n    // Validate constraints\n    if (maxConsecutiveSeconds < 5 || maxConsecutiveSeconds > 120) {\n      return res.status(400).json({ error: 'maxConsecutiveSeconds must be between 5 and 120' });\n    }\n    if (momentumFactor < 0 || momentumFactor > 1) {\n      return res.status(400).json({ error: 'momentumFactor must be between 0 and 1' });\n    }\n\n    // Check FFprobe availability\n    const ffprobeAvailable = await isFFprobeInstalled();\n    if (!ffprobeAvailable) {\n      return res.status(500).json({\n        error: 'FFprobe not installed. Run: brew install ffmpeg'\n      });\n    }\n\n    console.log(`[SPLICE] Advanced balancing multitrack: ${audioPaths.length} track(s)`);\n    console.log(`  - Max consecutive: ${maxConsecutiveSeconds}s, Momentum: ${momentumFactor}`);\n\n    try {\n      const result = await advancedBalanceMultitrack(audioPaths, {\n        speakerNames: speakerNames || audioPaths.map((_, i) => `Speaker ${i + 1}`),\n        videoTrackMapping,\n        minShotDuration,\n        switchingFrequency,\n        frameRate,\n        maxConsecutiveSeconds,\n        momentumFactor,\n        populationSize,\n        generations,\n        targetDistribution\n      });\n\n      // Deduct usage based on total duration\n      const audioDuration = result.metadata?.totalDuration || 0;\n      let balance = null;\n      if (audioDuration > 0 && req.deductUsage) {\n        balance = await req.deductUsage(audioDuration);\n      }\n\n      res.json({\n        success: true,\n        ...result,\n        balance: balance ? { hoursRemaining: balance.hoursRemaining, tier: balance.tier } : undefined\n      });\n    } catch (err) {\n      console.error('[SPLICE] Advanced balance error:', err);\n      res.status(500).json({ error: err.message });\n    }\n  });\n\n  return router;\n}\n\nmodule.exports = createMultitrackRoutes;\n","numLines":278,"startLine":1,"totalLines":278}}}
{"parentUuid":"c5f35d8e-10ab-41ef-9b91-a48faa054fa4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"9bf7f4f9-f57a-4d0a-b77b-5068207d22a0","version":"2.0.76","gitBranch":"main","agentId":"a582af4","slug":"cached-watching-patterson","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WjDkgoMEFd9mUsQFtg4MMo","type":"message","role":"assistant","content":[{"type":"text","text":"I have now reviewed all the relevant files. Let me compile the comprehensive audit report:\n\n---\n\n# Tier-Based Feature Gating Audit Report\n\n## Overall Verdict: **PASS**\n\nAll 14 requirements have been validated and are correctly implemented.\n\n---\n\n## Backend Requirements\n\n### Requirement 1: TIER_FEATURES map exists with proper feature definitions\n**Verdict: PASS**\n\n**File:** `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js:925-935`\n\n```javascript\nconst TIER_FEATURES = {\n  starter: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export'],\n  pro: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection'],\n  team: ['silence_removal', 'take_detection', 'basic_captions', 'filler_word', 'caption_export',\n    'vocal_isolation', 'social_reframe', 'text_editing', 'all_captions',\n    'profanity_detection', 'chapter_detection', 'multitrack',\n    'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'],\n  cancelled: []\n};\n```\n\nFeature access is properly tiered:\n- **Starter**: Basic features (silence_removal, take_detection, basic_captions, filler_word, caption_export)\n- **Pro**: Adds vocal_isolation, social_reframe, text_editing, all_captions, profanity_detection, chapter_detection\n- **Team**: Adds multitrack, music_to_cut, mood_timeline, youtube_metadata, profanity_bleeping\n\n---\n\n### Requirement 2: hasFeatureAccess(tier, feature) function correctly checks feature access and is exported\n**Verdict: PASS**\n\n**File:** `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js:943-946`\n\n```javascript\nfunction hasFeatureAccess(tier, feature) {\n  const tierFeatures = TIER_FEATURES[tier] || TIER_FEATURES.starter;\n  return tierFeatures.includes(feature);\n}\n```\n\n**Export:** `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js:1504-1505`\n\n```javascript\n// Feature access\nTIER_FEATURES,\nhasFeatureAccess\n```\n\n---\n\n### Requirement 3: /credits endpoint includes featureAccess array in response\n**Verdict: PASS**\n\n**File:** `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js:217`\n\nThe `getBalance()` function (which powers the `/credits` endpoint) includes:\n\n```javascript\nfeatureAccess: TIER_FEATURES[user.tier] || TIER_FEATURES.starter,\n```\n\n---\n\n### Requirement 4: requireFeature middleware exists in rateLimiter.js and is exported\n**Verdict: PASS**\n\n**File:** `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js:279-324`\n\n```javascript\nfunction requireFeature(featureName) {\n  return async (req, res, next) => {\n    // Must have stripeCustomerId from requireCredits middleware\n    if (!req.stripeCustomerId) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        message: 'Please log in to access this feature'\n      });\n    }\n\n    try {\n      // Get user's current balance (includes tier info)\n      const balance = await getBalance(req.stripeCustomerId);\n\n      // Check if user's tier has access to this feature\n      if (!hasFeatureAccess(balance.tier, featureName)) {\n        // Release any reserved credits since we're blocking the request\n        if (req.releaseReservation) {\n          await req.releaseReservation('feature_not_available');\n        }\n        // ... returns 403\n      }\n      // Feature access granted\n      next();\n    } catch (err) { ... }\n  };\n}\n```\n\n**Export:** `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js:375-380`\n\n```javascript\nmodule.exports = {\n  requireCredits,\n  requireFeature,\n  trackUsage,\n  ipRateLimit\n};\n```\n\n---\n\n### Requirement 5: requireFeature is imported in server.js and added to routeOptions.middleware\n**Verdict: PASS**\n\n**Import:** `/Users/imorgado/SPLICE/splice-backend/server.js:31`\n\n```javascript\nconst { requireCredits, requireFeature, ipRateLimit } = require('./middleware/rateLimiter');\n```\n\n**Route Options:** `/Users/imorgado/SPLICE/splice-backend/server.js:539-544`\n\n```javascript\nconst routeOptions = {\n  middleware: {\n    requireCredits,\n    requireFeature,\n    authenticateToken\n  },\n  // ...\n};\n```\n\n---\n\n## Route Enforcement - CRITICAL\n\n### Requirement 6: reframe.js routes destructure requireFeature from options.middleware\n**Verdict: PASS**\n\n**File:** `/Users/imorgado/SPLICE/splice-backend/routes/reframe.js:17`\n\n```javascript\nconst { requireCredits, requireFeature } = options.middleware || {};\n```\n\n---\n\n### Requirement 7: All reframe.js POST endpoints use requireFeature('social_reframe') middleware AFTER requireCredits\n**Verdict: PASS**\n\nAll POST endpoints in reframe.js correctly chain middleware:\n\n| Endpoint | Line | Middleware Chain |\n|----------|------|------------------|\n| POST /analyze | 23 | `requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe')` |\n| POST /calculate | 54 | `requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe')` |\n| POST /motion-path | 85 | `requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe')` |\n| POST /export | 120 | `requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe')` |\n| POST /faces/detect | 185 | `requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe')` |\n| POST /faces/track | 216 | `requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe')` |\n| POST /faces/identify-speaker | 247 | `requireCredits({ endpoint: 'reframe' }), requireFeature('social_reframe')` |\n\n---\n\n### Requirement 8: textEdit.js routes destructure requireFeature from options.middleware\n**Verdict: PASS**\n\n**File:** `/Users/imorgado/SPLICE/splice-backend/routes/textEdit.js:17`\n\n```javascript\nconst { requireCredits, requireFeature } = options.middleware || {};\n```\n\n---\n\n### Requirement 9: All textEdit.js POST endpoints use requireFeature('text_editing') middleware AFTER requireCredits\n**Verdict: PASS**\n\nAll POST endpoints in textEdit.js correctly chain middleware:\n\n| Endpoint | Line | Middleware Chain |\n|----------|------|------------------|\n| POST /prepare | 25 | `requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing')` |\n| POST /apply | 58 | `requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing')` |\n| POST /search | 93 | `requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing')` |\n| POST /replace | 128 | `requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing')` |\n| POST /preview | 163 | `requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing')` |\n| POST /cut-list | 198 | `requireCredits({ endpoint: 'text-edit' }), requireFeature('text_editing')` |\n\n---\n\n### Requirement 10: multitrack.js routes destructure requireFeature from options.middleware\n**Verdict: PASS**\n\n**File:** `/Users/imorgado/SPLICE/splice-backend/routes/multitrack.js:24`\n\n```javascript\nconst { requireCredits, requireFeature } = options.middleware || {};\n```\n\n---\n\n### Requirement 11: All multitrack.js POST endpoints use requireFeature('multitrack') middleware AFTER requireCredits\n**Verdict: PASS**\n\nAll POST endpoints in multitrack.js correctly chain middleware:\n\n| Endpoint | Line | Middleware Chain |\n|----------|------|------------------|\n| POST / | 47 | `requireCredits({ endpoint: 'multitrack' }), requireFeature('multitrack')` |\n| POST /auto-balance | 125 | `requireCredits({ endpoint: 'multitrack-auto-balance' }), requireFeature('multitrack')` |\n| POST /advanced-balance | 195 | `requireCredits({ endpoint: 'multitrack-advanced' }), requireFeature('multitrack')` |\n\n---\n\n## Security Requirements\n\n### Requirement 12: requireFeature middleware returns 403 with proper error message when access denied\n**Verdict: PASS**\n\n**File:** `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js:305-311`\n\n```javascript\nreturn res.status(403).json({\n  error: 'Feature not available',\n  message: `This feature requires a ${requiredTier} plan or higher`,\n  requiredFeature: featureName,\n  requiredTier: requiredTier,\n  currentTier: balance.tier\n});\n```\n\nThe error response includes:\n- Correct HTTP status code: 403 Forbidden\n- Clear error message\n- Required feature name\n- Required tier for upgrade guidance\n- Current user tier for context\n\n---\n\n### Requirement 13: requireFeature middleware releases reserved credits when access is denied\n**Verdict: PASS**\n\n**File:** `/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js:295-298`\n\n```javascript\n// Release any reserved credits since we're blocking the request\nif (req.releaseReservation) {\n  await req.releaseReservation('feature_not_available');\n}\n```\n\nThis ensures that:\n1. Credits reserved by `requireCredits` middleware are properly returned\n2. The release reason is logged as `'feature_not_available'`\n3. Users are not charged for features they cannot access\n\n---\n\n### Requirement 14: Feature gating is now enforced on BACKEND (not just frontend)\n**Verdict: PASS**\n\nBackend enforcement is confirmed through:\n\n1. **Middleware Architecture**: `requireFeature` is Express middleware that runs before route handlers\n2. **Database Check**: Line 291 calls `getBalance(req.stripeCustomerId)` to get tier from database\n3. **Server-side Validation**: Line 294 uses `hasFeatureAccess(balance.tier, featureName)` to validate\n4. **No Client Trust**: The backend does not trust any client-provided tier information; it always queries the database\n\n---\n\n## Summary\n\n| # | Requirement | Verdict | File:Line |\n|---|-------------|---------|-----------|\n| 1 | TIER_FEATURES map exists | PASS | usageTracking.js:925-935 |\n| 2 | hasFeatureAccess function exported | PASS | usageTracking.js:943-946, 1504-1505 |\n| 3 | /credits includes featureAccess | PASS | usageTracking.js:217 |\n| 4 | requireFeature middleware exists | PASS | rateLimiter.js:279-324 |\n| 5 | requireFeature in routeOptions | PASS | server.js:31, 539-544 |\n| 6 | reframe.js destructures requireFeature | PASS | reframe.js:17 |\n| 7 | reframe.js POST endpoints gated | PASS | reframe.js:23,54,85,120,185,216,247 |\n| 8 | textEdit.js destructures requireFeature | PASS | textEdit.js:17 |\n| 9 | textEdit.js POST endpoints gated | PASS | textEdit.js:25,58,93,128,163,198 |\n| 10 | multitrack.js destructures requireFeature | PASS | multitrack.js:24 |\n| 11 | multitrack.js POST endpoints gated | PASS | multitrack.js:47,125,195 |\n| 12 | Returns 403 with proper error | PASS | rateLimiter.js:305-311 |\n| 13 | Releases reserved credits on deny | PASS | rateLimiter.js:295-298 |\n| 14 | Backend enforcement (not frontend-only) | PASS | Architecture verified |\n\n---\n\n## Recommendations\n\nNo critical issues found. The implementation is complete and secure.\n\n**Optional Enhancements (Low Priority):**\n1. Consider adding feature gating logging/metrics for analytics\n2. Consider adding unit tests specifically for feature gating middleware\n3. Consider adding feature access to the `/health` endpoint response for debugging"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":10524,"cache_read_input_tokens":64842,"cache_creation":{"ephemeral_5m_input_tokens":10524,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWaKXGUs9TXwmEXF2PKwP","type":"assistant","uuid":"118f21f5-85d9-44b5-aad1-432d6de10450","timestamp":"2025-12-29T04:08:41.891Z"}
