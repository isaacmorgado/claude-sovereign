{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":"Verify the complete AI detection workflow in the CEP panel to ensure beta testers won't have problems.\n\nRead /Users/imorgado/SPLICE/splice-cep/panel/js/main.js and trace the complete detection workflow:\n\n1. **Pre-detection Checks**:\n   - Sequence open validation (checkSequenceOpen with retries)\n   - Audio export for analysis\n   - User authentication check\n\n2. **Detection Flow** (runDetection function):\n   - Progress UI updates\n   - Silence detection call\n   - Take detection call (if enabled)\n   - Profanity detection call (if enabled)\n   - Chapter detection call (if enabled)\n   - Zoom detection call (if enabled)\n\n3. **Error Handling**:\n   - Network errors\n   - 401 unauthorized handling\n   - 402 payment required (insufficient credits)\n   - Backend error responses\n   - User-friendly error messages via setStatus()\n\n4. **Results Handling**:\n   - Preview list population\n   - Silence/take/chapter/zoom data storage\n   - UI updates after detection\n\n5. **Apply Operations**:\n   - Marker creation\n   - Razor cuts\n   - Sequence building\n\nVerify that a beta tester going through this workflow will:\n- See clear progress indicators\n- Get helpful error messages if something fails\n- Be able to retry on failures\n- See their detection results clearly\n\nReturn a workflow verification report identifying any potential issues beta testers might encounter."},"uuid":"9a404537-615b-4386-a476-2099ae098758","timestamp":"2026-01-12T01:11:52.531Z"}
{"parentUuid":"9a404537-615b-4386-a476-2099ae098758","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_019mHEK5V4Kwuj2QZbp4Xex8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011xpD5mK6cBNA26vViWa6zv","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/main.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":27945,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27945,"ephemeral_1h_input_tokens":0},"output_tokens":74,"service_tier":"standard"}},"requestId":"req_011CX2bS86uK7Uz923DnxLaA","type":"assistant","uuid":"96810bae-7ebf-4bf9-bfd8-aa9c5d842745","timestamp":"2026-01-12T01:11:56.063Z"}
{"parentUuid":"96810bae-7ebf-4bf9-bfd8-aa9c5d842745","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011xpD5mK6cBNA26vViWa6zv","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Panel - Main Entry Point\n     3→ * v4.0.0 - CEP Migration\n     4→ */\n     5→\n     6→// ============================================================================\n     7→// CACHED DOM ELEMENTS\n     8→// ============================================================================\n     9→const ui = {};\n    10→\n    11→function cacheUIElements() {\n    12→    ui.status = document.getElementById('status');\n    13→    ui.goBtn = document.getElementById('goBtn');\n    14→    ui.optionsToggle = document.getElementById('optionsToggle');\n    15→    ui.optionsPanel = document.getElementById('optionsPanel');\n    16→\n    17→    // Sliders and options\n    18→    ui.sensitivitySlider = document.getElementById('sensitivitySlider');\n    19→    ui.sensitivityValue = document.getElementById('sensitivityValue');\n    20→    ui.sourceOriginal = document.getElementById('sourceOriginal');\n    21→    ui.sourceIsolated = document.getElementById('sourceIsolated');\n    22→\n    23→    // Feature toggles\n    24→    ui.enableTakesDetection = document.getElementById('enableTakesDetection');\n    25→    ui.enableJCut = document.getElementById('enableJCut');\n    26→    ui.jcutSettings = document.getElementById('jcutSettings');\n    27→    ui.jcutLeadIn = document.getElementById('jcutLeadIn');\n    28→    ui.jcutLeadInValue = document.getElementById('jcutLeadInValue');\n    29→    ui.jcutLeadOut = document.getElementById('jcutLeadOut');\n    30→    ui.jcutLeadOutValue = document.getElementById('jcutLeadOutValue');\n    31→\n    32→    // Zoom settings\n    33→    ui.enableZoom = document.getElementById('enableZoom');\n    34→    ui.zoomSettings = document.getElementById('zoomSettings');\n    35→    ui.zoomFrequency = document.getElementById('zoomFrequency');\n    36→    ui.zoomPreset = document.getElementById('zoomPreset');\n    37→    ui.zoomPlacement = document.getElementById('zoomPlacement');\n    38→\n    39→    // Chapter settings\n    40→    ui.enableChapters = document.getElementById('enableChapters');\n    41→    ui.chapterSettings = document.getElementById('chapterSettings');\n    42→    ui.maxChapters = document.getElementById('maxChapters');\n    43→    ui.minChapterLength = document.getElementById('minChapterLength');\n    44→\n    45→    // Profanity settings\n    46→    ui.enableProfanity = document.getElementById('enableProfanity');\n    47→    ui.profanitySettings = document.getElementById('profanitySettings');\n    48→\n    49→    // Filler word settings\n    50→    ui.enableFillerDetection = document.getElementById('enableFillerDetection');\n    51→    ui.fillerSettings = document.getElementById('fillerSettings');\n    52→\n    53→    // Progress\n    54→    ui.progressContainer = document.getElementById('progressContainer');\n    55→    ui.progressBar = document.getElementById('progressBar');\n    56→    ui.progressText = document.getElementById('progressText');\n    57→    ui.resultsEmpty = document.getElementById('resultsEmpty');\n    58→\n    59→    // Preview\n    60→    ui.combinedPreview = document.getElementById('combinedPreview');\n    61→    ui.previewList = document.getElementById('previewList');\n    62→    ui.silenceCount = document.getElementById('silenceCount');\n    63→    ui.takeCount = document.getElementById('takeCount');\n    64→    ui.selectedCount = document.getElementById('selectedCount');\n    65→    ui.selectAllSilences = document.getElementById('selectAllSilences');\n    66→    ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');\n    67→    ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');\n    68→    ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');\n    69→\n    70→    // Results\n    71→    ui.zoomResults = document.getElementById('zoomResults');\n    72→    ui.zoomList = document.getElementById('zoomList');\n    73→    ui.chapterResults = document.getElementById('chapterResults');\n    74→    ui.chapterList = document.getElementById('chapterList');\n    75→    ui.copyYouTubeBtn = document.getElementById('copyYouTubeBtn');\n    76→    ui.addChapterMarkersBtn = document.getElementById('addChapterMarkersBtn');\n    77→\n    78→    // Modals\n    79→    ui.settingsBtn = document.getElementById('settingsBtn');\n    80→    ui.settingsModal = document.getElementById('settingsModal');\n    81→    ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');\n    82→    ui.loginModal = document.getElementById('loginModal');\n    83→    ui.closeLoginBtn = document.getElementById('closeLoginBtn');\n    84→    ui.licenseKeyInput = document.getElementById('licenseKeyInput');\n    85→    ui.saveLoginBtn = document.getElementById('saveLoginBtn');\n    86→\n    87→    // Credit badge\n    88→    ui.creditBadge = document.getElementById('creditBadge');\n    89→\n    90→    // Preset selector\n    91→    ui.presetSelector = document.getElementById('presetSelector');\n    92→}\n    93→\n    94→// ============================================================================\n    95→// STATE MANAGEMENT\n    96→// ============================================================================\n    97→let previewSilences = [];\n    98→let previewTakes = [];\n    99→let currentChapters = [];\n   100→let currentZooms = [];\n   101→let currentProfanity = [];\n   102→let selectedSilenceIndices = new Set();\n   103→let isOperationInProgress = false;\n   104→let lastDetectionResult = null;\n   105→let currentAudioPath = null;\n   106→let currentSequenceInfo = null;\n   107→let currentTranscript = null;\n   108→\n   109→// Global state for captions/reframe modules\n   110→window.spliceState = {\n   111→    lastTranscript: null,\n   112→    currentVideoPath: null,\n   113→    activeSequence: null,\n   114→    audioPath: null\n   115→};\n   116→\n   117→// Also expose transcript globally for music module\n   118→window.currentTranscript = null;\n   119→\n   120→// ============================================================================\n   121→// INITIALIZATION\n   122→// ============================================================================\n   123→document.addEventListener('DOMContentLoaded', async () => {\n   124→    // Premium Loading Experience\n   125→    setTimeout(() => {\n   126→        const loader = document.getElementById('loading-overlay');\n   127→        if (loader) loader.classList.add('hidden');\n   128→    }, 800); // Small delay for smooth perception\n   129→    debugLog('Initializing CEP panel...');\n   130→\n   131→    // Debug: Show init started\n   132→    const statusEl = document.getElementById('status');\n   133→    if (statusEl) statusEl.textContent = 'Initializing...';\n   134→\n   135→    // Cache DOM elements\n   136→    cacheUIElements();\n   137→\n   138→    // Load settings\n   139→    loadSettingsToUI();\n   140→\n   141→    // Initialize UI handlers\n   142→    initOptionsToggle();\n   143→    initSliders();\n   144→    initFeatureToggles();\n   145→    initPresetSelector();\n   146→    initGoButton();\n   147→    initPreviewHandlers();\n   148→    initModals();\n   149→    initLoginModal();\n   150→    initCredits();\n   151→    initHelpButton();\n   152→\n   153→    // Initialize offline detection\n   154→    if (typeof initOfflineDetection === 'function') {\n   155→        initOfflineDetection();\n   156→    }\n   157→\n   158→    // Initialize multitrack UI\n   159→    if (typeof initMultitrackUI === 'function') {\n   160→        initMultitrackUI();\n   161→    }\n   162→\n   163→    // Initialize animated captions UI\n   164→    if (typeof initAnimatedCaptions === 'function') {\n   165→        initAnimatedCaptions();\n   166→    }\n   167→\n   168→    // Initialize text editor UI\n   169→    if (typeof initTextEditor === 'function') {\n   170→        initTextEditor();\n   171→    }\n   172→\n   173→    // Initialize text editor section toggle\n   174→    initTextEditorToggle();\n   175→\n   176→    // Initialize social reframe UI\n   177→    if (typeof initSocialReframe === 'function') {\n   178→        initSocialReframe();\n   179→    }\n   180→\n   181→    // Initialize social reframe section toggle\n   182→    initSocialReframeToggle();\n   183→\n   184→    // Initialize music UI\n   185→    if (typeof initMusicModule === 'function') {\n   186→        initMusicModule();\n   187→    }\n   188→\n   189→    // Initialize music section toggle\n   190→    initMusicToggle();\n   191→\n   192→    // Initialize JSX bridge first, then check connection\n   193→    // This ensures jsx.init() completes before checkJSXConnection() uses it\n   194→    await jsx.init();\n   195→    await checkJSXConnection();\n   196→\n   197→    // Initialize sequence event listeners for real-time state updates\n   198→    initSequenceEventListeners();\n   199→\n   200→    setStatus('Ready');\n   201→    debugLog('CEP panel initialized');\n   202→});\n   203→\n   204→// ============================================================================\n   205→// SEQUENCE EVENT LISTENERS\n   206→// ============================================================================\n   207→/**\n   208→ * Initialize event listeners for sequence state changes\n   209→ * This provides real-time updates when sequences are activated/deactivated\n   210→ */\n   211→function initSequenceEventListeners() {\n   212→    if (!jsx.cs) {\n   213→        console.warn('[SPLICE] Cannot init sequence listeners - CSInterface not available');\n   214→        return;\n   215→    }\n   216→\n   217→    try {\n   218→        // Listen for sequence activation events\n   219→        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceActivated', async (event) => {\n   220→            debugLog('Sequence activated event received');\n   221→            try {\n   222→                const seqInfo = await jsx.call('getActiveSequence');\n   223→                if (seqInfo && !seqInfo.error) {\n   224→                    window.spliceState.activeSequence = seqInfo;\n   225→                    setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));\n   226→                    debugLog('Active sequence updated:', seqInfo.name);\n   227→                }\n   228→            } catch (e) {\n   229→                console.warn('[SPLICE] Failed to get sequence info on activation:', e.message);\n   230→            }\n   231→        });\n   232→\n   233→        // Listen for sequence close/deactivation\n   234→        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceDeactivated', () => {\n   235→            debugLog('Sequence deactivated event');\n   236→            window.spliceState.activeSequence = null;\n   237→            setStatus('No sequence open', true);\n   238→        });\n   239→\n   240→        // Listen for project item selection changes (includes sequences)\n   241→        jsx.cs.addEventListener('com.adobe.csxs.events.SelectionChanged', async () => {\n   242→            // Debounce rapid selection changes\n   243→            if (window._selectionChangeTimeout) {\n   244→                clearTimeout(window._selectionChangeTimeout);\n   245→            }\n   246→            window._selectionChangeTimeout = setTimeout(async () => {\n   247→                try {\n   248→                    const hasSequence = await checkSequenceOpen(0, 0); // Quick check, no retries\n   249→                    if (hasSequence && !window.spliceState.activeSequence) {\n   250→                        const seqInfo = await jsx.call('getActiveSequence');\n   251→                        if (seqInfo && !seqInfo.error) {\n   252→                            window.spliceState.activeSequence = seqInfo;\n   253→                            debugLog('Sequence detected via selection change:', seqInfo.name);\n   254→                        }\n   255→                    }\n   256→                } catch (e) {\n   257→                    // Ignore errors during selection change - it's just for proactive updates\n   258→                }\n   259→            }, 200);\n   260→        });\n   261→\n   262→        debugLog('Sequence event listeners initialized');\n   263→    } catch (e) {\n   264→        console.error('[SPLICE] Failed to init sequence event listeners:', e.message);\n   265→    }\n   266→}\n   267→\n   268→// ============================================================================\n   269→// JSX CONNECTION CHECK\n   270→// ============================================================================\n   271→async function checkJSXConnection() {\n   272→    try {\n   273→        const result = await jsx.call('getVersion');\n   274→        debugLog('JSX connection OK, version:', result);\n   275→        return true;\n   276→    } catch (e) {\n   277→        console.warn('[SPLICE] JSX connection failed:', e.message);\n   278→        setStatus('Premiere Pro connection failed', true);\n   279→        return false;\n   280→    }\n   281→}\n   282→\n   283→/**\n   284→ * Check if a sequence is currently open in the Timeline\n   285→ * Enhanced with logging and retry logic\n   286→ * @param {number} retries - Number of retry attempts (default: 2)\n   287→ * @param {number} delayMs - Delay between retries in ms (default: 300)\n   288→ * @returns {Promise<boolean>} true if sequence is open\n   289→ */\n   290→async function checkSequenceOpen(retries = 2, delayMs = 300) {\n   291→    for (let attempt = 0; attempt <= retries; attempt++) {\n   292→        try {\n   293→            const result = await jsx.call('checkSequenceOpen');\n   294→            debugLog('checkSequenceOpen attempt', attempt + 1, 'result:', result, 'type:', typeof result);\n   295→\n   296→            if (result === true || result === 'true') {\n   297→                return true;\n   298→            }\n   299→\n   300→            // If false, wait and retry (sequence might be loading)\n   301→            if (attempt < retries) {\n   302→                debugLog('checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');\n   303→                await new Promise(r => setTimeout(r, delayMs));\n   304→            }\n   305→        } catch (error) {\n   306→            console.error('[SPLICE] checkSequenceOpen attempt', attempt + 1, 'failed:', error.message);\n   307→\n   308→            // On last attempt, return false but log the actual error\n   309→            if (attempt === retries) {\n   310→                console.error('[SPLICE] checkSequenceOpen: All attempts failed. Last error:', error.message);\n   311→                // Store error for diagnostics\n   312→                window.spliceState.lastSequenceCheckError = error.message;\n   313→                return false;\n   314→            }\n   315→\n   316→            // Wait before retry\n   317→            await new Promise(r => setTimeout(r, delayMs));\n   318→        }\n   319→    }\n   320→    return false;\n   321→}\n   322→\n   323→// ============================================================================\n   324→// OPTIONS TOGGLE\n   325→// ============================================================================\n   326→function initOptionsToggle() {\n   327→    debugLog('initOptionsToggle - toggle:', !!ui.optionsToggle, 'panel:', !!ui.optionsPanel);\n   328→    if (ui.optionsToggle && ui.optionsPanel) {\n   329→        ui.optionsToggle.addEventListener('click', () => {\n   330→            debugLog('Options toggle clicked');\n   331→            // Check current state BEFORE toggling\n   332→            const wasCollapsed = ui.optionsPanel.classList.contains('collapsed');\n   333→            ui.optionsPanel.classList.toggle('collapsed');\n   334→            // If it was collapsed, it's now expanded (show 'expanded' class)\n   335→            ui.optionsToggle.classList.toggle('expanded', wasCollapsed);\n   336→            saveSettings({ expandedOptions: wasCollapsed });\n   337→        });\n   338→\n   339→        // Restore state\n   340→        const settings = getSettings();\n   341→        if (!settings.expandedOptions) {\n   342→            ui.optionsPanel.classList.add('collapsed');\n   343→            ui.optionsToggle.classList.remove('expanded');\n   344→        } else {\n   345→            ui.optionsToggle.classList.add('expanded');\n   346→            ui.optionsPanel.classList.remove('collapsed');\n   347→        }\n   348→    }\n   349→}\n   350→\n   351→// ============================================================================\n   352→// TEXT EDITOR TOGGLE\n   353→// ============================================================================\n   354→function initTextEditorToggle() {\n   355→    const toggle = document.getElementById('textEditorToggle');\n   356→    const panel = document.getElementById('text-editor-panel');\n   357→    debugLog('initTextEditorToggle - toggle:', !!toggle, 'panel:', !!panel);\n   358→\n   359→    if (toggle && panel) {\n   360→        toggle.addEventListener('click', (e) => {\n   361→            e.preventDefault();\n   362→            e.stopPropagation();\n   363→            debugLog('Text Editor toggle clicked');\n   364→            setStatus('Text Editor: ' + (panel.classList.contains('collapsed') ? 'Opening' : 'Closing'));\n   365→            // Check state BEFORE toggling\n   366→            const wasCollapsed = panel.classList.contains('collapsed');\n   367→            panel.classList.toggle('collapsed');\n   368→            const icon = toggle.querySelector('.toggle-icon');\n   369→            debugLog('wasCollapsed:', wasCollapsed, 'icon:', !!icon);\n   370→            if (icon) {\n   371→                // If it was collapsed, it's now expanded (show -)\n   372→                icon.textContent = wasCollapsed ? '-' : '+';\n   373→            }\n   374→        });\n   375→    } else {\n   376→        console.error('[SPLICE] Text Editor toggle elements not found!');\n   377→    }\n   378→}\n   379→\n   380→// ============================================================================\n   381→// SOCIAL REFRAME TOGGLE\n   382→// ============================================================================\n   383→function initSocialReframeToggle() {\n   384→    const toggle = document.getElementById('socialReframeToggle');\n   385→    const panel = document.getElementById('social-reframe-panel');\n   386→    debugLog('initSocialReframeToggle - toggle:', !!toggle, 'panel:', !!panel);\n   387→\n   388→    if (toggle && panel) {\n   389→        toggle.addEventListener('click', () => {\n   390→            debugLog('Social Reframe toggle clicked');\n   391→            // Check state BEFORE toggling\n   392→            const wasCollapsed = panel.classList.contains('collapsed');\n   393→            panel.classList.toggle('collapsed');\n   394→            const icon = toggle.querySelector('.toggle-icon');\n   395→            if (icon) {\n   396→                // If it was collapsed, it's now expanded (show -)\n   397→                icon.textContent = wasCollapsed ? '-' : '+';\n   398→            }\n   399→        });\n   400→    } else {\n   401→        console.error('[SPLICE] Social Reframe toggle elements not found!');\n   402→    }\n   403→}\n   404→\n   405→// ============================================================================\n   406→// MUSIC TOGGLE\n   407→// ============================================================================\n   408→function initMusicToggle() {\n   409→    const toggle = document.getElementById('musicToggle');\n   410→    const panel = document.getElementById('music-panel');\n   411→    debugLog('initMusicToggle - toggle:', !!toggle, 'panel:', !!panel);\n   412→\n   413→    if (toggle && panel) {\n   414→        toggle.addEventListener('click', () => {\n   415→            debugLog('Music toggle clicked');\n   416→            // Check state BEFORE toggling\n   417→            const wasCollapsed = panel.classList.contains('collapsed');\n   418→            panel.classList.toggle('collapsed');\n   419→            const icon = toggle.querySelector('.toggle-icon');\n   420→            if (icon) {\n   421→                // If it was collapsed, it's now expanded (show -)\n   422→                icon.textContent = wasCollapsed ? '-' : '+';\n   423→            }\n   424→        });\n   425→    } else {\n   426→        console.error('[SPLICE] Music toggle elements not found!');\n   427→    }\n   428→}\n   429→\n   430→// ============================================================================\n   431→// SLIDERS\n   432→// ============================================================================\n   433→function initSliders() {\n   434→    // Sensitivity slider\n   435→    if (ui.sensitivitySlider && ui.sensitivityValue) {\n   436→        ui.sensitivitySlider.addEventListener('input', () => {\n   437→            ui.sensitivityValue.textContent = ui.sensitivitySlider.value;\n   438→            saveSettings({ sensitivity: parseInt(ui.sensitivitySlider.value) });\n   439→        });\n   440→    }\n   441→\n   442→    // J-Cut sliders\n   443→    if (ui.jcutLeadIn && ui.jcutLeadInValue) {\n   444→        ui.jcutLeadIn.addEventListener('input', () => {\n   445→            const val = (ui.jcutLeadIn.value / 100).toFixed(2);\n   446→            ui.jcutLeadInValue.textContent = val + 's';\n   447→            saveSettings({ jcutLeadIn: parseFloat(val) });\n   448→        });\n   449→    }\n   450→\n   451→    if (ui.jcutLeadOut && ui.jcutLeadOutValue) {\n   452→        ui.jcutLeadOut.addEventListener('input', () => {\n   453→            const val = (ui.jcutLeadOut.value / 100).toFixed(2);\n   454→            ui.jcutLeadOutValue.textContent = val + 's';\n   455→            saveSettings({ jcutLeadOut: parseFloat(val) });\n   456→        });\n   457→    }\n   458→}\n   459→\n   460→// ============================================================================\n   461→// FEATURE TOGGLES\n   462→// ============================================================================\n   463→function initFeatureToggles() {\n   464→    // J-Cut toggle\n   465→    if (ui.enableJCut && ui.jcutSettings) {\n   466→        ui.enableJCut.addEventListener('change', () => {\n   467→            ui.jcutSettings.classList.toggle('collapsed', !ui.enableJCut.checked);\n   468→            saveSettings({ enableJCut: ui.enableJCut.checked });\n   469→        });\n   470→    }\n   471→\n   472→    // Zoom toggle\n   473→    if (ui.enableZoom && ui.zoomSettings) {\n   474→        ui.enableZoom.addEventListener('change', () => {\n   475→            ui.zoomSettings.classList.toggle('collapsed', !ui.enableZoom.checked);\n   476→            saveSettings({ enableZoom: ui.enableZoom.checked });\n   477→        });\n   478→    }\n   479→\n   480→    // Chapters toggle\n   481→    if (ui.enableChapters && ui.chapterSettings) {\n   482→        ui.enableChapters.addEventListener('change', () => {\n   483→            ui.chapterSettings.classList.toggle('collapsed', !ui.enableChapters.checked);\n   484→            saveSettings({ enableChapters: ui.enableChapters.checked });\n   485→        });\n   486→    }\n   487→\n   488→    // Takes detection toggle\n   489→    if (ui.enableTakesDetection) {\n   490→        ui.enableTakesDetection.addEventListener('change', () => {\n   491→            saveSettings({ enableTakesDetection: ui.enableTakesDetection.checked });\n   492→        });\n   493→    }\n   494→\n   495→    // Profanity detection toggle\n   496→    if (ui.enableProfanity && ui.profanitySettings) {\n   497→        ui.enableProfanity.addEventListener('change', () => {\n   498→            ui.profanitySettings.classList.toggle('collapsed', !ui.enableProfanity.checked);\n   499→            saveSettings({ enableProfanity: ui.enableProfanity.checked });\n   500→        });\n   501→    }\n   502→\n   503→    // Filler word detection toggle\n   504→    if (ui.enableFillerDetection && ui.fillerSettings) {\n   505→        ui.enableFillerDetection.addEventListener('change', () => {\n   506→            ui.fillerSettings.classList.toggle('collapsed', !ui.enableFillerDetection.checked);\n   507→            saveSettings({ enableFillerDetection: ui.enableFillerDetection.checked });\n   508→        });\n   509→    }\n   510→}\n   511→\n   512→// ============================================================================\n   513→// PRESET SELECTOR\n   514→// ============================================================================\n   515→// PRESETS is defined in config.js\n   516→\n   517→function initPresetSelector() {\n   518→    if (!ui.presetSelector) return;\n   519→\n   520→    ui.presetSelector.addEventListener('change', () => {\n   521→        const presetId = ui.presetSelector.value;\n   522→        applyPreset(presetId);\n   523→    });\n   524→\n   525→    // Load current preset\n   526→    const settings = getSettings();\n   527→    if (settings.activePreset) {\n   528→        ui.presetSelector.value = settings.activePreset;\n   529→    }\n   530→}\n   531→\n   532→function applyPreset(presetId) {\n   533→    const preset = PRESETS[presetId];\n   534→    if (!preset) return;\n   535→\n   536→    // Custom preset - keep current settings\n   537→    if (presetId === 'custom' || !preset.settings) {\n   538→        saveSettings({ activePreset: 'custom' });\n   539→        setStatus('Using custom settings');\n   540→        return;\n   541→    }\n   542→\n   543→    const settings = preset.settings;\n   544→\n   545→    // Apply to UI\n   546→    if (ui.sensitivitySlider && settings.sensitivity !== undefined) {\n   547→        ui.sensitivitySlider.value = settings.sensitivity;\n   548→        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n   549→    }\n   550→\n   551→    if (ui.enableJCut) {\n   552→        ui.enableJCut.checked = settings.enableJCut || false;\n   553→        if (ui.jcutSettings) {\n   554→            ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n   555→        }\n   556→    }\n   557→\n   558→    if (settings.jCutLeadIn !== undefined && ui.jcutLeadIn) {\n   559→        ui.jcutLeadIn.value = Math.round(settings.jCutLeadIn * 100);\n   560→        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jCutLeadIn + 's';\n   561→    }\n   562→\n   563→    if (settings.jCutLeadOut !== undefined && ui.jcutLeadOut) {\n   564→        ui.jcutLeadOut.value = Math.round(settings.jCutLeadOut * 100);\n   565→        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jCutLeadOut + 's';\n   566→    }\n   567→\n   568→    // Save merged settings\n   569→    saveSettings({\n   570→        activePreset: presetId,\n   571→        sensitivity: settings.sensitivity,\n   572→        threshold: settings.threshold,\n   573→        minSilenceLength: settings.minSilenceLength,\n   574→        paddingStart: settings.paddingStart,\n   575→        paddingEnd: settings.paddingEnd,\n   576→        enableTakesDetection: settings.enableTakesDetection,\n   577→        enableJCut: settings.enableJCut || false,\n   578→        jcutLeadIn: settings.jCutLeadIn || 0.3,\n   579→        jcutLeadOut: settings.jCutLeadOut || 0.2\n   580→    });\n   581→\n   582→    setStatus(`Applied ${preset.name} preset`);\n   583→}\n   584→\n   585→// ============================================================================\n   586→// LOAD SETTINGS TO UI\n   587→// ============================================================================\n   588→function loadSettingsToUI() {\n   589→    const settings = getSettings();\n   590→\n   591→    if (ui.sensitivitySlider) {\n   592→        ui.sensitivitySlider.value = settings.sensitivity;\n   593→        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n   594→    }\n   595→\n   596→    if (ui.enableTakesDetection) ui.enableTakesDetection.checked = settings.enableTakesDetection;\n   597→    if (ui.enableJCut) ui.enableJCut.checked = settings.enableJCut;\n   598→    if (ui.enableZoom) ui.enableZoom.checked = settings.enableZoom;\n   599→    if (ui.enableChapters) ui.enableChapters.checked = settings.enableChapters;\n   600→\n   601→    if (ui.jcutSettings) ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n   602→    if (ui.zoomSettings) ui.zoomSettings.classList.toggle('collapsed', !settings.enableZoom);\n   603→    if (ui.chapterSettings) ui.chapterSettings.classList.toggle('collapsed', !settings.enableChapters);\n   604→\n   605→    if (ui.jcutLeadIn) {\n   606→        ui.jcutLeadIn.value = Math.round(settings.jcutLeadIn * 100);\n   607→        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jcutLeadIn + 's';\n   608→    }\n   609→    if (ui.jcutLeadOut) {\n   610→        ui.jcutLeadOut.value = Math.round(settings.jcutLeadOut * 100);\n   611→        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jcutLeadOut + 's';\n   612→    }\n   613→\n   614→    if (ui.presetSelector && settings.activePreset) {\n   615→        ui.presetSelector.value = settings.activePreset;\n   616→    }\n   617→}\n   618→\n   619→// ============================================================================\n   620→// GO BUTTON - MAIN WORKFLOW\n   621→// ============================================================================\n   622→function initGoButton() {\n   623→    if (!ui.goBtn) return;\n   624→\n   625→    ui.goBtn.addEventListener('click', async () => {\n   626→        if (isOperationInProgress) return;\n   627→        await runDetection();\n   628→    });\n   629→}\n   630→\n   631→async function runDetection() {\n   632→    if (isOperationInProgress) return;\n   633→\n   634→    // Check sequence with enhanced error messaging\n   635→    const hasSequence = await checkSequenceOpen();\n   636→    if (!hasSequence) {\n   637→        // Check if there was a communication error vs just no sequence\n   638→        const lastError = window.spliceState.lastSequenceCheckError;\n   639→        if (lastError && (lastError.includes('CEP') || lastError.includes('communication') || lastError.includes('evalScript'))) {\n   640→            setStatus('Premiere Pro connection issue - try reopening panel', true);\n   641→            console.error('[SPLICE] runDetection: JSX communication failure:', lastError);\n   642→        } else {\n   643→            setStatus('Please open a sequence in the Timeline first', true);\n   644→            debugLog('runDetection: No active sequence in Timeline');\n   645→        }\n   646→        // Clear the error for next check\n   647→        window.spliceState.lastSequenceCheckError = null;\n   648→        return;\n   649→    }\n   650→\n   651→    // Check online\n   652→    if (!isOnline()) {\n   653→        setStatus('Offline - Check your connection', true);\n   654→        return;\n   655→    }\n   656→\n   657→    isOperationInProgress = true;\n   658→    ui.goBtn.disabled = true;\n   659→    showProgress('Detecting silences...');\n   660→\n   661→    try {\n   662→        const settings = getSettings();\n   663→\n   664→        // Get sequence info\n   665→        const seqInfo = await jsx.call('getActiveSequence');\n   666→        debugLog('Sequence info:', seqInfo);\n   667→\n   668→        // Store sequence info for later use\n   669→        currentSequenceInfo = seqInfo;\n   670→        window.spliceState.activeSequence = seqInfo;\n   671→        if (seqInfo && seqInfo.videoPath) {\n   672→            window.spliceState.currentVideoPath = seqInfo.videoPath;\n   673→        }\n   674→\n   675→        // Export audio via JSX for silence detection\n   676→        updateProgress(10, 'Exporting audio...');\n   677→\n   678→        let audioFilePath = null;\n   679→        try {\n   680→            // Get sequence info for audio export\n   681→            const exportResult = await jsx.call('exportSequenceAudioForAnalysis');\n   682→            if (exportResult && exportResult.success && exportResult.outputPath) {\n   683→                audioFilePath = exportResult.outputPath;\n   684→                debugLog('Audio exported to:', audioFilePath);\n   685→            } else if (exportResult && exportResult.error) {\n   686→                throw new Error(exportResult.error);\n   687→            }\n   688→        } catch (exportError) {\n   689→            console.warn('[SPLICE] Audio export failed, trying fallback:', exportError.message);\n   690→            // Try to get audio from first clip in timeline\n   691→            try {\n   692→                const clipInfo = await jsx.call('getFirstClipAudioPath');\n   693→                if (clipInfo && clipInfo.path) {\n   694→                    audioFilePath = clipInfo.path;\n   695→                    debugLog('Using clip audio path:', audioFilePath);\n   696→                }\n   697→            } catch (clipError) {\n   698→                console.warn('[SPLICE] Fallback audio path failed:', clipError.message);\n   699→            }\n   700→        }\n   701→\n   702→        if (!audioFilePath) {\n   703→            throw new Error('Could not export or locate audio file. Please ensure sequence has audio tracks.');\n   704→        }\n   705→\n   706→        // Store audio path globally for other modules\n   707→        currentAudioPath = audioFilePath;\n   708→        window.spliceState.audioPath = audioFilePath;\n   709→\n   710→        // Call backend for silence detection with audio file path\n   711→        updateProgress(30, 'Detecting silences...');\n   712→        const silenceResponse = await fetchWithTimeout(\n   713→            `${getBackendUrl()}/silences-rms`,\n   714→            {\n   715→                method: 'POST',\n   716→                headers: getAuthHeaders(),\n   717→                body: JSON.stringify({\n   718→                    wavPath: audioFilePath,\n   719→                    sensitivity: settings.sensitivity,\n   720→                    minSilenceLength: settings.minSilenceLength || 0.5\n   721→                })\n   722→            }\n   723→        );\n   724→\n   725→        if (!silenceResponse.ok) {\n   726→            throw new Error(await parseErrorResponse(silenceResponse));\n   727→        }\n   728→\n   729→        const silenceData = await silenceResponse.json();\n   730→        previewSilences = silenceData.silences || [];\n   731→\n   732→        // Detect takes if enabled\n   733→        if (settings.enableTakesDetection) {\n   734→            updateProgress(60, 'Detecting takes...');\n   735→            try {\n   736→                const analyzeResponse = await fetchWithTimeout(\n   737→                    `${getBackendUrl()}/analyze`,\n   738→                    {\n   739→                        method: 'POST',\n   740→                        headers: getAuthHeaders(),\n   741→                        body: JSON.stringify({\n   742→                            wavPath: audioFilePath,\n   743→                            detectTakes: true\n   744→                        })\n   745→                    }\n   746→                );\n   747→\n   748→                if (analyzeResponse.ok) {\n   749→                    const analyzeData = await analyzeResponse.json();\n   750→                    previewTakes = analyzeData.takes || [];\n   751→\n   752→                    // Store transcript for captions/music modules\n   753→                    if (analyzeData.transcript) {\n   754→                        currentTranscript = analyzeData.transcript;\n   755→                        window.currentTranscript = analyzeData.transcript;\n   756→                        window.spliceState.lastTranscript = analyzeData.transcript;\n   757→                    }\n   758→                } else {\n   759→                    // Handle specific error codes\n   760→                    const errorMsg = await parseErrorResponse(analyzeResponse);\n   761→                    if (analyzeResponse.status === 402) {\n   762→                        console.warn('[SPLICE] Takes detection skipped: insufficient credits');\n   763→                        setStatus('Takes detection skipped: insufficient credits', true);\n   764→                    } else if (analyzeResponse.status === 401) {\n   765→                        console.warn('[SPLICE] Takes detection skipped: authentication required');\n   766→                    } else {\n   767→                        console.warn('[SPLICE] Takes detection failed:', errorMsg);\n   768→                    }\n   769→                }\n   770→            } catch (e) {\n   771→                console.warn('[SPLICE] Takes detection failed:', e.message);\n   772→            }\n   773→        }\n   774→\n   775→        // Detect profanity if enabled\n   776→        if (settings.enableProfanity) {\n   777→            updateProgress(65, 'Detecting profanity...');\n   778→            try {\n   779→                const profanityResponse = await fetchWithTimeout(\n   780→                    `${getBackendUrl()}/profanity`,\n   781→                    {\n   782→                        method: 'POST',\n   783→                        headers: getAuthHeaders(),\n   784→                        body: JSON.stringify({\n   785→                            wavPath: audioFilePath,\n   786→                            language: settings.profanityLanguage || 'en',\n   787→                            bleepType: settings.bleepType || 'standard'\n   788→                        })\n   789→                    }\n   790→                );\n   791→\n   792→                if (profanityResponse.ok) {\n   793→                    const profanityData = await profanityResponse.json();\n   794→                    // Backend returns 'words' array, not 'instances'\n   795→                    currentProfanity = profanityData.words || profanityData.instances || [];\n   796→                    if (currentProfanity.length > 0) {\n   797→                        debugLog(`Found ${currentProfanity.length} profanity instances`);\n   798→                    }\n   799→                } else {\n   800→                    console.warn('[SPLICE] Profanity detection failed:', await parseErrorResponse(profanityResponse));\n   801→                }\n   802→            } catch (e) {\n   803→                console.warn('[SPLICE] Profanity detection failed:', e.message);\n   804→            }\n   805→        }\n   806→\n   807→        // Detect chapters if enabled\n   808→        if (settings.enableChapters) {\n   809→            updateProgress(80, 'Detecting chapters...');\n   810→            try {\n   811→                const chapterResponse = await fetchWithTimeout(\n   812→                    `${getBackendUrl()}/chapters`,\n   813→                    {\n   814→                        method: 'POST',\n   815→                        headers: getAuthHeaders(),\n   816→                        body: JSON.stringify({\n   817→                            wavPath: audioFilePath,\n   818→                            transcript: currentTranscript,\n   819→                            maxChapters: settings.maxChapters || 10,\n   820→                            minChapterLength: settings.minChapterLength || 60\n   821→                        })\n   822→                    }\n   823→                );\n   824→\n   825→                if (chapterResponse.ok) {\n   826→                    const chapterData = await chapterResponse.json();\n   827→                    currentChapters = chapterData.chapters || [];\n   828→                } else {\n   829→                    const errorMsg = await parseErrorResponse(chapterResponse);\n   830→                    console.warn('[SPLICE] Chapter detection failed:', errorMsg);\n   831→                    // Don't block workflow, just notify user\n   832→                    setStatus('Chapter detection skipped: ' + errorMsg, true);\n   833→                }\n   834→            } catch (e) {\n   835→                console.warn('[SPLICE] Chapter detection failed:', e);\n   836→                setStatus('Chapter detection failed - continuing without chapters', true);\n   837→            }\n   838→        }\n   839→\n   840→        // Detect zoom points if enabled\n   841→        if (settings.enableZoom) {\n   842→            updateProgress(90, 'Detecting zoom points...');\n   843→            try {\n   844→                const zoomResponse = await fetchWithTimeout(\n   845→                    `${getBackendUrl()}/zoom`,\n   846→                    {\n   847→                        method: 'POST',\n   848→                        headers: getAuthHeaders(),\n   849→                        body: JSON.stringify({\n   850→                            wavPath: audioFilePath,\n   851→                            transcript: currentTranscript,\n   852→                            frequency: settings.zoomFrequency || 'medium',\n   853→                            preset: settings.zoomPreset || 'medium',\n   854→                            placement: settings.zoomPlacement || 'sentence_start'\n   855→                        })\n   856→                    }\n   857→                );\n   858→\n   859→                if (zoomResponse.ok) {\n   860→                    const zoomData = await zoomResponse.json();\n   861→                    currentZooms = zoomData.zoomPoints || [];\n   862→                } else {\n   863→                    const errorMsg = await parseErrorResponse(zoomResponse);\n   864→                    console.warn('[SPLICE] Zoom detection failed:', errorMsg);\n   865→                    setStatus('Zoom detection skipped: ' + errorMsg, true);\n   866→                }\n   867→            } catch (e) {\n   868→                console.warn('[SPLICE] Zoom detection failed:', e);\n   869→                setStatus('Zoom detection failed - continuing without zoom points', true);\n   870→            }\n   871→        }\n   872→\n   873→        // Store results\n   874→        lastDetectionResult = {\n   875→            silences: previewSilences,\n   876→            takes: previewTakes,\n   877→            chapters: currentChapters,\n   878→            zooms: currentZooms\n   879→        };\n   880→\n   881→        // Show preview\n   882→        hideProgress();\n   883→        showCombinedPreview();\n   884→        setStatus(`Found ${previewSilences.length} silences, ${previewTakes.length} takes`);\n   885→\n   886→    } catch (error) {\n   887→        console.error('[SPLICE] Detection error:', error);\n   888→        setStatus('Detection failed: ' + error.message, true);\n   889→        hideProgress();\n   890→    } finally {\n   891→        isOperationInProgress = false;\n   892→        ui.goBtn.disabled = false;\n   893→    }\n   894→}\n   895→\n   896→// ============================================================================\n   897→// PROGRESS UI\n   898→// ============================================================================\n   899→function showProgress(message) {\n   900→    if (ui.progressContainer) ui.progressContainer.classList.remove('hidden');\n   901→    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n   902→    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n   903→    updateProgress(0, message);\n   904→}\n   905→\n   906→function updateProgress(percent, message) {\n   907→    if (ui.progressBar) ui.progressBar.style.width = percent + '%';\n   908→    if (ui.progressText) ui.progressText.textContent = message || '';\n   909→}\n   910→\n   911→function hideProgress() {\n   912→    if (ui.progressContainer) ui.progressContainer.classList.add('hidden');\n   913→}\n   914→\n   915→// ============================================================================\n   916→// COMBINED PREVIEW\n   917→// ============================================================================\n   918→function showCombinedPreview() {\n   919→    if (!ui.combinedPreview) return;\n   920→\n   921→    ui.combinedPreview.classList.remove('hidden');\n   922→    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n   923→\n   924→    // Update counts\n   925→    if (ui.silenceCount) ui.silenceCount.textContent = previewSilences.length;\n   926→    if (ui.takeCount) ui.takeCount.textContent = previewTakes.length;\n   927→\n   928→    // Select all by default\n   929→    selectedSilenceIndices.clear();\n   930→    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n   931→    updateSelectedCount();\n   932→\n   933→    // Render preview list\n   934→    renderPreviewList();\n   935→\n   936→    // Show chapter results if available\n   937→    if (currentChapters.length > 0 && ui.chapterResults) {\n   938→        ui.chapterResults.classList.remove('hidden');\n   939→        renderChapterList();\n   940→    }\n   941→\n   942→    // Show zoom results if available\n   943→    if (currentZooms.length > 0 && ui.zoomResults) {\n   944→        ui.zoomResults.classList.remove('hidden');\n   945→    }\n   946→}\n   947→\n   948→function renderPreviewList() {\n   949→    if (!ui.previewList) return;\n   950→\n   951→    const html = [];\n   952→\n   953→    // Render silences\n   954→    previewSilences.forEach((silence, i) => {\n   955→        const isSelected = selectedSilenceIndices.has(i);\n   956→        const duration = silence.end - silence.start;\n   957→        html.push(`\n   958→            <div class=\"preview-item ${isSelected ? '' : 'excluded'}\" data-index=\"${i}\" data-type=\"silence\">\n   959→                <input type=\"checkbox\" class=\"preview-item-check\" ${isSelected ? 'checked' : ''}>\n   960→                <div class=\"preview-item-info\">\n   961→                    <div class=\"preview-item-time\">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>\n   962→                    <div class=\"preview-item-duration\">${duration.toFixed(2)}s silence</div>\n   963→                </div>\n   964→            </div>\n   965→        `);\n   966→    });\n   967→\n   968→    // Render takes\n   969→    previewTakes.forEach((take, i) => {\n   970→        // SECURITY: Escape take label to prevent XSS\n   971→        const safeLabel = escapeHtml(take.label || 'Take ' + (take.takeNumber || i + 1));\n   972→        html.push(`\n   973→            <div class=\"preview-item take-item\" data-index=\"${i}\" data-type=\"take\">\n   974→                <div class=\"preview-item-icon\">🎬</div>\n   975→                <div class=\"preview-item-info\">\n   976→                    <div class=\"preview-item-time\">${formatTime(take.start)} - ${formatTime(take.end)}</div>\n   977→                    <div class=\"preview-item-label\">${safeLabel}</div>\n   978→                </div>\n   979→            </div>\n   980→        `);\n   981→    });\n   982→\n   983→    ui.previewList.innerHTML = html.join('');\n   984→\n   985→    // Add click handlers\n   986→    ui.previewList.querySelectorAll('.preview-item').forEach(item => {\n   987→        item.addEventListener('click', (e) => {\n   988→            const index = parseInt(item.dataset.index);\n   989→            const type = item.dataset.type;\n   990→\n   991→            if (e.target.classList.contains('preview-item-check')) {\n   992→                // Checkbox clicked\n   993→                toggleSilenceSelection(index);\n   994→            } else {\n   995→                // Item clicked - seek to time\n   996→                const data = type === 'silence' ? previewSilences[index] : previewTakes[index];\n   997→                seekToTime(data.start);\n   998→            }\n   999→        });\n  1000→    });\n  1001→}\n  1002→\n  1003→function toggleSilenceSelection(index) {\n  1004→    if (selectedSilenceIndices.has(index)) {\n  1005→        selectedSilenceIndices.delete(index);\n  1006→    } else {\n  1007→        selectedSilenceIndices.add(index);\n  1008→    }\n  1009→    updateSelectedCount();\n  1010→    renderPreviewList();\n  1011→}\n  1012→\n  1013→function updateSelectedCount() {\n  1014→    if (ui.selectedCount) {\n  1015→        ui.selectedCount.textContent = selectedSilenceIndices.size;\n  1016→    }\n  1017→    if (ui.selectAllSilences) {\n  1018→        ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length;\n  1019→    }\n  1020→}\n  1021→\n  1022→async function seekToTime(seconds) {\n  1023→    try {\n  1024→        // Check if there's an active sequence before seeking\n  1025→        if (!app?.project?.activeSequence) {\n  1026→            debugLog('No active sequence to seek in');\n  1027→            return;\n  1028→        }\n  1029→        // Use JSX to set playhead position\n  1030→        // Note: setPlayerPosition expects ticks as a string without quotes around the number value\n  1031→        const ticks = Math.round(seconds * 254016000000);\n  1032→        await jsx.evalScript(`app.project.activeSequence.setPlayerPosition(${ticks})`);\n  1033→    } catch (e) {\n  1034→        console.warn('[SPLICE] Seek failed:', e);\n  1035→    }\n  1036→}\n  1037→\n  1038→// ============================================================================\n  1039→// CHAPTER LIST\n  1040→// ============================================================================\n  1041→function renderChapterList() {\n  1042→    if (!ui.chapterList) return;\n  1043→\n  1044→    const html = currentChapters.map((chapter, i) => {\n  1045→        // SECURITY: Escape chapter title to prevent XSS\n  1046→        const safeTitle = escapeHtml(chapter.title);\n  1047→        return `\n  1048→            <div class=\"chapter-item\" data-index=\"${i}\">\n  1049→                <div class=\"chapter-time\">${formatTime(chapter.startTime)}</div>\n  1050→                <div class=\"chapter-title\">${safeTitle}</div>\n  1051→            </div>\n  1052→        `;\n  1053→    }).join('');\n  1054→\n  1055→    ui.chapterList.innerHTML = html;\n  1056→\n  1057→    // Add click handlers\n  1058→    ui.chapterList.querySelectorAll('.chapter-item').forEach(item => {\n  1059→        item.addEventListener('click', () => {\n  1060→            const index = parseInt(item.dataset.index);\n  1061→            seekToTime(currentChapters[index].startTime);\n  1062→        });\n  1063→    });\n  1064→}\n  1065→\n  1066→// ============================================================================\n  1067→// PREVIEW HANDLERS\n  1068→// ============================================================================\n  1069→function initPreviewHandlers() {\n  1070→    // Select all checkbox\n  1071→    if (ui.selectAllSilences) {\n  1072→        ui.selectAllSilences.addEventListener('change', () => {\n  1073→            if (ui.selectAllSilences.checked) {\n  1074→                previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n  1075→            } else {\n  1076→                selectedSilenceIndices.clear();\n  1077→            }\n  1078→            updateSelectedCount();\n  1079→            renderPreviewList();\n  1080→        });\n  1081→    }\n  1082→\n  1083→    // Apply button\n  1084→    if (ui.applyPreviewBtn) {\n  1085→        ui.applyPreviewBtn.addEventListener('click', applyPreviewAndMarkers);\n  1086→    }\n  1087→\n  1088→    // Cancel button\n  1089→    if (ui.cancelPreviewBtn) {\n  1090→        ui.cancelPreviewBtn.addEventListener('click', hidePreview);\n  1091→    }\n  1092→\n  1093→    // Build sequence button\n  1094→    if (ui.buildSequenceBtn) {\n  1095→        ui.buildSequenceBtn.addEventListener('click', buildSequence);\n  1096→    }\n  1097→\n  1098→    // Copy YouTube timestamps\n  1099→    if (ui.copyYouTubeBtn) {\n  1100→        ui.copyYouTubeBtn.addEventListener('click', copyYouTubeTimestamps);\n  1101→    }\n  1102→\n  1103→    // Add chapter markers\n  1104→    if (ui.addChapterMarkersBtn) {\n  1105→        ui.addChapterMarkersBtn.addEventListener('click', addChapterMarkers);\n  1106→    }\n  1107→\n  1108→    // Apply zoom markers\n  1109→    const applyZoomsBtn = document.getElementById('applyZoomsBtn');\n  1110→    if (applyZoomsBtn) {\n  1111→        applyZoomsBtn.addEventListener('click', applyZoomMarkers);\n  1112→    }\n  1113→}\n  1114→\n  1115→async function applyPreviewAndMarkers() {\n  1116→    if (isOperationInProgress) return;\n  1117→\n  1118→    isOperationInProgress = true;\n  1119→    setStatus('Adding markers...');\n  1120→\n  1121→    try {\n  1122→        // Add silence markers\n  1123→        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n  1124→        for (const silence of selectedSilences) {\n  1125→            await jsx.call('createMarker', silence.start, 'SPLICE: Silence', silence.end - silence.start, null, 1);\n  1126→        }\n  1127→\n  1128→        // Add take markers\n  1129→        for (const take of previewTakes) {\n  1130→            await jsx.call('createMarker', take.start, take.label || `Take ${take.takeNumber}`, take.end - take.start, null, 5);\n  1131→        }\n  1132→\n  1133→        setStatus(`Added ${selectedSilences.length + previewTakes.length} markers`);\n  1134→    } catch (error) {\n  1135→        setStatus('Failed to add markers: ' + error.message, true);\n  1136→    } finally {\n  1137→        isOperationInProgress = false;\n  1138→    }\n  1139→}\n  1140→\n  1141→function hidePreview() {\n  1142→    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n  1143→    if (ui.chapterResults) ui.chapterResults.classList.add('hidden');\n  1144→    if (ui.zoomResults) ui.zoomResults.classList.add('hidden');\n  1145→    if (ui.resultsEmpty) ui.resultsEmpty.classList.remove('hidden');\n  1146→    previewSilences = [];\n  1147→    previewTakes = [];\n  1148→    selectedSilenceIndices.clear();\n  1149→}\n  1150→\n  1151→async function buildSequence() {\n  1152→    if (isOperationInProgress) return;\n  1153→\n  1154→    isOperationInProgress = true;\n  1155→    setStatus('Building sequence...');\n  1156→\n  1157→    try {\n  1158→        const settings = getSettings();\n  1159→\n  1160→        // Ensure we have sequence info\n  1161→        if (!currentSequenceInfo) {\n  1162→            currentSequenceInfo = await jsx.call('getActiveSequence');\n  1163→        }\n  1164→\n  1165→        // Create cut list from selected silences\n  1166→        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n  1167→\n  1168→        // Calculate total duration from sequence info or last silence\n  1169→        let duration = 0;\n  1170→        if (currentSequenceInfo && currentSequenceInfo.duration) {\n  1171→            duration = currentSequenceInfo.duration;\n  1172→        } else if (previewSilences.length > 0) {\n  1173→            const lastSilence = previewSilences[previewSilences.length - 1];\n  1174→            duration = lastSilence.end + 10; // Add buffer\n  1175→        }\n  1176→\n  1177→        // Call backend to generate cut list\n  1178→        const cutListResponse = await fetchWithTimeout(\n  1179→            `${getBackendUrl()}/cut-list`,\n  1180→            {\n  1181→                method: 'POST',\n  1182→                headers: getAuthHeaders(),\n  1183→                body: JSON.stringify({\n  1184→                    sourceName: currentSequenceInfo?.name || 'Untitled Sequence',\n  1185→                    sourcePath: currentSequenceInfo?.treePath || currentSequenceInfo?.name || 'Untitled',\n  1186→                    duration: duration,\n  1187→                    silences: selectedSilences,\n  1188→                    takes: previewTakes,\n  1189→                    enableTakes: settings.enableTakesDetection,\n  1190→                    jCutOffset: settings.enableJCut ? settings.jcutLeadIn : 0,\n  1191→                    lCutOffset: settings.enableJCut ? settings.jcutLeadOut : 0\n  1192→                })\n  1193→            }\n  1194→        );\n  1195→\n  1196→        if (!cutListResponse.ok) {\n  1197→            throw new Error(await parseErrorResponse(cutListResponse));\n  1198→        }\n  1199→\n  1200→        const cutList = await cutListResponse.json();\n  1201→\n  1202→        // Build sequence via JSX\n  1203→        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));\n  1204→\n  1205→        if (result && result.success) {\n  1206→            setStatus(`Built sequence: ${result.sequenceName}`);\n  1207→            hidePreview();\n  1208→        } else {\n  1209→            throw new Error(result?.error || 'Build failed');\n  1210→        }\n  1211→    } catch (error) {\n  1212→        setStatus('Build failed: ' + error.message, true);\n  1213→    } finally {\n  1214→        isOperationInProgress = false;\n  1215→    }\n  1216→}\n  1217→\n  1218→function copyYouTubeTimestamps() {\n  1219→    if (currentChapters.length === 0) return;\n  1220→\n  1221→    const timestamps = currentChapters.map(ch =>\n  1222→        `${formatTime(ch.startTime)} ${ch.title}`\n  1223→    ).join('\\n');\n  1224→\n  1225→    navigator.clipboard.writeText(timestamps).then(() => {\n  1226→        setStatus('Copied YouTube timestamps');\n  1227→    }).catch(() => {\n  1228→        setStatus('Failed to copy', true);\n  1229→    });\n  1230→}\n  1231→\n  1232→async function addChapterMarkers() {\n  1233→    if (isOperationInProgress || currentChapters.length === 0) return;\n  1234→\n  1235→    isOperationInProgress = true;\n  1236→    setStatus('Adding chapter markers...');\n  1237→\n  1238→    try {\n  1239→        for (const chapter of currentChapters) {\n  1240→            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);\n  1241→        }\n  1242→        setStatus(`Added ${currentChapters.length} chapter markers`);\n  1243→    } catch (error) {\n  1244→        setStatus('Failed to add markers: ' + error.message, true);\n  1245→    } finally {\n  1246→        isOperationInProgress = false;\n  1247→    }\n  1248→}\n  1249→\n  1250→/**\n  1251→ * Apply zoom point markers to the timeline\n  1252→ */\n  1253→async function applyZoomMarkers() {\n  1254→    if (isOperationInProgress || currentZooms.length === 0) return;\n  1255→\n  1256→    isOperationInProgress = true;\n  1257→    setStatus('Adding zoom markers...');\n  1258→\n  1259→    try {\n  1260→        for (const zoom of currentZooms) {\n  1261→            // Create a marker for each zoom point with zoom intensity info\n  1262→            const comment = `Zoom ${zoom.intensity || 'medium'} - ${zoom.reason || 'emphasis'}`;\n  1263→            await jsx.call('createMarker', zoom.time, 'SPLICE: Zoom', 0.5, comment, 3);\n  1264→        }\n  1265→        setStatus(`Added ${currentZooms.length} zoom markers`);\n  1266→    } catch (error) {\n  1267→        setStatus('Failed to add zoom markers: ' + error.message, true);\n  1268→    } finally {\n  1269→        isOperationInProgress = false;\n  1270→    }\n  1271→}\n  1272→\n  1273→// ============================================================================\n  1274→// MODALS\n  1275→// ============================================================================\n  1276→function initModals() {\n  1277→    // Settings modal\n  1278→    if (ui.settingsBtn && ui.settingsModal) {\n  1279→        ui.settingsBtn.addEventListener('click', () => {\n  1280→            ui.settingsModal.classList.remove('hidden');\n  1281→            // Sync remember options checkbox with current settings\n  1282→            const rememberOptions = document.getElementById('rememberOptions');\n  1283→            if (rememberOptions) {\n  1284→                rememberOptions.checked = getSettings().rememberOptions;\n  1285→            }\n  1286→        });\n  1287→    }\n  1288→\n  1289→    if (ui.closeSettingsBtn && ui.settingsModal) {\n  1290→        ui.closeSettingsBtn.addEventListener('click', () => {\n  1291→            ui.settingsModal.classList.add('hidden');\n  1292→        });\n  1293→    }\n  1294→\n  1295→    // Remember options checkbox\n  1296→    const rememberOptions = document.getElementById('rememberOptions');\n  1297→    if (rememberOptions) {\n  1298→        rememberOptions.addEventListener('change', () => {\n  1299→            saveSettings({ rememberOptions: rememberOptions.checked });\n  1300→            if (rememberOptions.checked) {\n  1301→                setStatus('Options will be remembered');\n  1302→            } else {\n  1303→                setStatus('Options will reset to defaults');\n  1304→            }\n  1305→        });\n  1306→    }\n  1307→\n  1308→    // Credit badge click handler (handles login, retry, and refresh)\n  1309→    if (ui.creditBadge) {\n  1310→        ui.creditBadge.addEventListener('click', () => {\n  1311→            // Use the centralized handler from credits.js\n  1312→            if (typeof handleCreditBadgeClick === 'function') {\n  1313→                handleCreditBadgeClick();\n  1314→            } else {\n  1315→                // Fallback if credits.js not loaded yet\n  1316→                const settings = getSettings();\n  1317→                if (!settings.customerId) {\n  1318→                    showLoginModal();\n  1319→                }\n  1320→            }\n  1321→        });\n  1322→    }\n  1323→\n  1324→    if (ui.closeLoginBtn && ui.loginModal) {\n  1325→        ui.closeLoginBtn.addEventListener('click', () => {\n  1326→            ui.loginModal.classList.add('hidden');\n  1327→        });\n  1328→    }\n  1329→\n  1330→    // Note: saveLoginBtn handler is registered in initLoginModal() (config.js)\n  1331→    // to avoid duplicate event listeners\n  1332→\n  1333→    // License lookup button\n  1334→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n  1335→    if (lookupLicenseBtn) {\n  1336→        lookupLicenseBtn.addEventListener('click', lookupLicense);\n  1337→    }\n  1338→\n  1339→    // Close modals on backdrop click\n  1340→    document.querySelectorAll('.modal').forEach(modal => {\n  1341→        modal.addEventListener('click', (e) => {\n  1342→            if (e.target === modal) {\n  1343→                modal.classList.add('hidden');\n  1344→            }\n  1345→        });\n  1346→    });\n  1347→}\n  1348→\n  1349→function showLoginModal() {\n  1350→    if (ui.loginModal) ui.loginModal.classList.remove('hidden');\n  1351→}\n  1352→\n  1353→/**\n  1354→ * Show upgrade modal when user tries to access a gated feature\n  1355→ * @param {string} featureName - Display name of the feature\n  1356→ * @param {string} requiredTier - Required tier (Pro, Team)\n  1357→ */\n  1358→function showUpgradeModal(featureName, requiredTier = 'Pro') {\n  1359→    const modal = document.getElementById('upgradeModal');\n  1360→    const featureText = document.getElementById('upgradeFeatureName');\n  1361→    const tierText = document.getElementById('upgradeRequiredTier');\n  1362→\n  1363→    if (featureText) {\n  1364→        featureText.textContent = featureName;\n  1365→    }\n  1366→    if (tierText) {\n  1367→        tierText.textContent = requiredTier;\n  1368→    }\n  1369→    if (modal) {\n  1370→        modal.classList.remove('hidden');\n  1371→    }\n  1372→}\n  1373→\n  1374→/**\n  1375→ * Close the upgrade modal\n  1376→ */\n  1377→function closeUpgradeModal() {\n  1378→    const modal = document.getElementById('upgradeModal');\n  1379→    if (modal) {\n  1380→        modal.classList.add('hidden');\n  1381→    }\n  1382→}\n  1383→\n  1384→// Expose showUpgradeModal and closeUpgradeModal globally for feature modules\n  1385→window.showUpgradeModal = showUpgradeModal;\n  1386→window.closeUpgradeModal = closeUpgradeModal;\n  1387→\n  1388→async function activateLicense() {\n  1389→    if (!ui.licenseKeyInput) return;\n  1390→\n  1391→    const licenseKey = ui.licenseKeyInput.value.trim();\n  1392→    if (!licenseKey) {\n  1393→        setStatus('Please enter a license key', true);\n  1394→        return;\n  1395→    }\n  1396→\n  1397→    try {\n  1398→        const response = await fetchWithTimeout(\n  1399→            `${getBackendUrl()}/license/activate`,\n  1400→            {\n  1401→                method: 'POST',\n  1402→                headers: { 'Content-Type': 'application/json' },\n  1403→                body: JSON.stringify({ key: licenseKey })\n  1404→            }\n  1405→        );\n  1406→\n  1407→        if (!response.ok) {\n  1408→            throw new Error(await parseErrorResponse(response));\n  1409→        }\n  1410→\n  1411→        const data = await response.json();\n  1412→        saveSettings({\n  1413→            customerId: data.customerId,\n  1414→            licenseKey: licenseKey\n  1415→        });\n  1416→\n  1417→        if (ui.loginModal) ui.loginModal.classList.add('hidden');\n  1418→        setStatus('License activated');\n  1419→        updateCredits();\n  1420→    } catch (error) {\n  1421→        setStatus('Activation failed: ' + error.message, true);\n  1422→    }\n  1423→}\n  1424→\n  1425→/**\n  1426→ * Look up license key by email address\n  1427→ */\n  1428→async function lookupLicense() {\n  1429→    const lookupEmailInput = document.getElementById('lookupEmailInput');\n  1430→    const licenseKeyInput = document.getElementById('licenseKeyInput');\n  1431→\n  1432→    if (!lookupEmailInput) return;\n  1433→\n  1434→    const email = lookupEmailInput.value.trim().toLowerCase();\n  1435→    if (!email) {\n  1436→        setStatus('Please enter your email address', true);\n  1437→        return;\n  1438→    }\n  1439→\n  1440→    // Basic email validation\n  1441→    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  1442→    if (!emailRegex.test(email)) {\n  1443→        setStatus('Please enter a valid email address', true);\n  1444→        return;\n  1445→    }\n  1446→\n  1447→    const lookupBtn = document.getElementById('lookupLicenseBtn');\n  1448→    if (lookupBtn) {\n  1449→        lookupBtn.disabled = true;\n  1450→        lookupBtn.textContent = 'Looking up...';\n  1451→    }\n  1452→\n  1453→    try {\n  1454→        const response = await fetchWithTimeout(\n  1455→            `${getBackendUrl()}/license/lookup`,\n  1456→            {\n  1457→                method: 'POST',\n  1458→                headers: { 'Content-Type': 'application/json' },\n  1459→                body: JSON.stringify({ email })\n  1460→            },\n  1461→            30000\n  1462→        );\n  1463→\n  1464→        const result = await response.json();\n  1465→\n  1466→        // Note: For security, the backend does NOT return the license key directly.\n  1467→        // It sends the key via email to prevent enumeration attacks.\n  1468→        if (result.success) {\n  1469→            setStatus(result.message || 'If a license exists, it has been sent to your email.');\n  1470→        } else {\n  1471→            setStatus(result.error || 'Lookup failed. Please try again.', true);\n  1472→        }\n  1473→    } catch (error) {\n  1474→        setStatus('Lookup failed: ' + error.message, true);\n  1475→    } finally {\n  1476→        if (lookupBtn) {\n  1477→            lookupBtn.disabled = false;\n  1478→            lookupBtn.textContent = 'Lookup';\n  1479→        }\n  1480→    }\n  1481→}\n  1482→\n  1483→// ============================================================================\n  1484→// CREDITS\n  1485→// ============================================================================\n  1486→function initCredits() {\n  1487→    updateCredits();\n  1488→}\n  1489→\n  1490→async function updateCredits() {\n  1491→    if (!ui.creditBadge) return;\n  1492→\n  1493→    const settings = getSettings();\n  1494→    if (!settings.customerId) {\n  1495→        ui.creditBadge.className = 'credit-badge login';\n  1496→        ui.creditBadge.textContent = 'Login';\n  1497→        ui.creditBadge.style.display = 'flex';\n  1498→        return;\n  1499→    }\n  1500→\n  1501→    try {\n  1502→        const response = await fetchWithTimeout(\n  1503→            `${getBackendUrl()}/credits`,\n  1504→            {\n  1505→                method: 'GET',\n  1506→                headers: getAuthHeaders()\n  1507→            }\n  1508→        );\n  1509→\n  1510→        if (response.ok) {\n  1511→            const data = await response.json();\n  1512→            // Backend returns hoursRemaining (not remainingMinutes)\n  1513→            const hours = (data.hoursRemaining || 0).toFixed(1);\n  1514→            ui.creditBadge.textContent = `${hours}h`;\n  1515→            // Low warning when less than 1 hour remaining\n  1516→            ui.creditBadge.className = data.hoursRemaining < 1 ? 'credit-badge low' : 'credit-badge ok';\n  1517→            ui.creditBadge.style.display = 'flex';\n  1518→        } else {\n  1519→            ui.creditBadge.className = 'credit-badge error';\n  1520→            ui.creditBadge.textContent = 'Error';\n  1521→            ui.creditBadge.style.display = 'flex';\n  1522→        }\n  1523→    } catch {\n  1524→        ui.creditBadge.className = 'credit-badge error';\n  1525→        ui.creditBadge.textContent = 'Offline';\n  1526→        ui.creditBadge.style.display = 'flex';\n  1527→    }\n  1528→}\n  1529→\n  1530→// ============================================================================\n  1531→// HELP BUTTON\n  1532→// ============================================================================\n  1533→function initHelpButton() {\n  1534→    const helpBtn = document.getElementById('helpBtn');\n  1535→    if (helpBtn) {\n  1536→        helpBtn.addEventListener('click', () => {\n  1537→            setStatus('Silence: removes quiet gaps | Takes: detects repeated content | Chapters: AI topic segmentation');\n  1538→        });\n  1539→    }\n  1540→}\n  1541→\n  1542→// Export for debugging\n  1543→window.spliceDebug = {\n  1544→    getState: () => ({\n  1545→        silences: previewSilences,\n  1546→        takes: previewTakes,\n  1547→        chapters: currentChapters,\n  1548→        zooms: currentZooms,\n  1549→        selected: Array.from(selectedSilenceIndices)\n  1550→    }),\n  1551→    jsx,\n  1552→    runDetection\n  1553→};\n  1554→\n\n</system-reminder>\n"}]},"uuid":"cf360289-318e-4201-b53c-f598a5e51e94","timestamp":"2026-01-12T01:11:56.209Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/main.js","content":"/**\n * SPLICE CEP Panel - Main Entry Point\n * v4.0.0 - CEP Migration\n */\n\n// ============================================================================\n// CACHED DOM ELEMENTS\n// ============================================================================\nconst ui = {};\n\nfunction cacheUIElements() {\n    ui.status = document.getElementById('status');\n    ui.goBtn = document.getElementById('goBtn');\n    ui.optionsToggle = document.getElementById('optionsToggle');\n    ui.optionsPanel = document.getElementById('optionsPanel');\n\n    // Sliders and options\n    ui.sensitivitySlider = document.getElementById('sensitivitySlider');\n    ui.sensitivityValue = document.getElementById('sensitivityValue');\n    ui.sourceOriginal = document.getElementById('sourceOriginal');\n    ui.sourceIsolated = document.getElementById('sourceIsolated');\n\n    // Feature toggles\n    ui.enableTakesDetection = document.getElementById('enableTakesDetection');\n    ui.enableJCut = document.getElementById('enableJCut');\n    ui.jcutSettings = document.getElementById('jcutSettings');\n    ui.jcutLeadIn = document.getElementById('jcutLeadIn');\n    ui.jcutLeadInValue = document.getElementById('jcutLeadInValue');\n    ui.jcutLeadOut = document.getElementById('jcutLeadOut');\n    ui.jcutLeadOutValue = document.getElementById('jcutLeadOutValue');\n\n    // Zoom settings\n    ui.enableZoom = document.getElementById('enableZoom');\n    ui.zoomSettings = document.getElementById('zoomSettings');\n    ui.zoomFrequency = document.getElementById('zoomFrequency');\n    ui.zoomPreset = document.getElementById('zoomPreset');\n    ui.zoomPlacement = document.getElementById('zoomPlacement');\n\n    // Chapter settings\n    ui.enableChapters = document.getElementById('enableChapters');\n    ui.chapterSettings = document.getElementById('chapterSettings');\n    ui.maxChapters = document.getElementById('maxChapters');\n    ui.minChapterLength = document.getElementById('minChapterLength');\n\n    // Profanity settings\n    ui.enableProfanity = document.getElementById('enableProfanity');\n    ui.profanitySettings = document.getElementById('profanitySettings');\n\n    // Filler word settings\n    ui.enableFillerDetection = document.getElementById('enableFillerDetection');\n    ui.fillerSettings = document.getElementById('fillerSettings');\n\n    // Progress\n    ui.progressContainer = document.getElementById('progressContainer');\n    ui.progressBar = document.getElementById('progressBar');\n    ui.progressText = document.getElementById('progressText');\n    ui.resultsEmpty = document.getElementById('resultsEmpty');\n\n    // Preview\n    ui.combinedPreview = document.getElementById('combinedPreview');\n    ui.previewList = document.getElementById('previewList');\n    ui.silenceCount = document.getElementById('silenceCount');\n    ui.takeCount = document.getElementById('takeCount');\n    ui.selectedCount = document.getElementById('selectedCount');\n    ui.selectAllSilences = document.getElementById('selectAllSilences');\n    ui.applyPreviewBtn = document.getElementById('applyPreviewBtn');\n    ui.cancelPreviewBtn = document.getElementById('cancelPreviewBtn');\n    ui.buildSequenceBtn = document.getElementById('buildSequenceBtn');\n\n    // Results\n    ui.zoomResults = document.getElementById('zoomResults');\n    ui.zoomList = document.getElementById('zoomList');\n    ui.chapterResults = document.getElementById('chapterResults');\n    ui.chapterList = document.getElementById('chapterList');\n    ui.copyYouTubeBtn = document.getElementById('copyYouTubeBtn');\n    ui.addChapterMarkersBtn = document.getElementById('addChapterMarkersBtn');\n\n    // Modals\n    ui.settingsBtn = document.getElementById('settingsBtn');\n    ui.settingsModal = document.getElementById('settingsModal');\n    ui.closeSettingsBtn = document.getElementById('closeSettingsBtn');\n    ui.loginModal = document.getElementById('loginModal');\n    ui.closeLoginBtn = document.getElementById('closeLoginBtn');\n    ui.licenseKeyInput = document.getElementById('licenseKeyInput');\n    ui.saveLoginBtn = document.getElementById('saveLoginBtn');\n\n    // Credit badge\n    ui.creditBadge = document.getElementById('creditBadge');\n\n    // Preset selector\n    ui.presetSelector = document.getElementById('presetSelector');\n}\n\n// ============================================================================\n// STATE MANAGEMENT\n// ============================================================================\nlet previewSilences = [];\nlet previewTakes = [];\nlet currentChapters = [];\nlet currentZooms = [];\nlet currentProfanity = [];\nlet selectedSilenceIndices = new Set();\nlet isOperationInProgress = false;\nlet lastDetectionResult = null;\nlet currentAudioPath = null;\nlet currentSequenceInfo = null;\nlet currentTranscript = null;\n\n// Global state for captions/reframe modules\nwindow.spliceState = {\n    lastTranscript: null,\n    currentVideoPath: null,\n    activeSequence: null,\n    audioPath: null\n};\n\n// Also expose transcript globally for music module\nwindow.currentTranscript = null;\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\ndocument.addEventListener('DOMContentLoaded', async () => {\n    // Premium Loading Experience\n    setTimeout(() => {\n        const loader = document.getElementById('loading-overlay');\n        if (loader) loader.classList.add('hidden');\n    }, 800); // Small delay for smooth perception\n    debugLog('Initializing CEP panel...');\n\n    // Debug: Show init started\n    const statusEl = document.getElementById('status');\n    if (statusEl) statusEl.textContent = 'Initializing...';\n\n    // Cache DOM elements\n    cacheUIElements();\n\n    // Load settings\n    loadSettingsToUI();\n\n    // Initialize UI handlers\n    initOptionsToggle();\n    initSliders();\n    initFeatureToggles();\n    initPresetSelector();\n    initGoButton();\n    initPreviewHandlers();\n    initModals();\n    initLoginModal();\n    initCredits();\n    initHelpButton();\n\n    // Initialize offline detection\n    if (typeof initOfflineDetection === 'function') {\n        initOfflineDetection();\n    }\n\n    // Initialize multitrack UI\n    if (typeof initMultitrackUI === 'function') {\n        initMultitrackUI();\n    }\n\n    // Initialize animated captions UI\n    if (typeof initAnimatedCaptions === 'function') {\n        initAnimatedCaptions();\n    }\n\n    // Initialize text editor UI\n    if (typeof initTextEditor === 'function') {\n        initTextEditor();\n    }\n\n    // Initialize text editor section toggle\n    initTextEditorToggle();\n\n    // Initialize social reframe UI\n    if (typeof initSocialReframe === 'function') {\n        initSocialReframe();\n    }\n\n    // Initialize social reframe section toggle\n    initSocialReframeToggle();\n\n    // Initialize music UI\n    if (typeof initMusicModule === 'function') {\n        initMusicModule();\n    }\n\n    // Initialize music section toggle\n    initMusicToggle();\n\n    // Initialize JSX bridge first, then check connection\n    // This ensures jsx.init() completes before checkJSXConnection() uses it\n    await jsx.init();\n    await checkJSXConnection();\n\n    // Initialize sequence event listeners for real-time state updates\n    initSequenceEventListeners();\n\n    setStatus('Ready');\n    debugLog('CEP panel initialized');\n});\n\n// ============================================================================\n// SEQUENCE EVENT LISTENERS\n// ============================================================================\n/**\n * Initialize event listeners for sequence state changes\n * This provides real-time updates when sequences are activated/deactivated\n */\nfunction initSequenceEventListeners() {\n    if (!jsx.cs) {\n        console.warn('[SPLICE] Cannot init sequence listeners - CSInterface not available');\n        return;\n    }\n\n    try {\n        // Listen for sequence activation events\n        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceActivated', async (event) => {\n            debugLog('Sequence activated event received');\n            try {\n                const seqInfo = await jsx.call('getActiveSequence');\n                if (seqInfo && !seqInfo.error) {\n                    window.spliceState.activeSequence = seqInfo;\n                    setStatus('Sequence: ' + (seqInfo.name || 'Unknown'));\n                    debugLog('Active sequence updated:', seqInfo.name);\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Failed to get sequence info on activation:', e.message);\n            }\n        });\n\n        // Listen for sequence close/deactivation\n        jsx.cs.addEventListener('com.adobe.csxs.events.SequenceDeactivated', () => {\n            debugLog('Sequence deactivated event');\n            window.spliceState.activeSequence = null;\n            setStatus('No sequence open', true);\n        });\n\n        // Listen for project item selection changes (includes sequences)\n        jsx.cs.addEventListener('com.adobe.csxs.events.SelectionChanged', async () => {\n            // Debounce rapid selection changes\n            if (window._selectionChangeTimeout) {\n                clearTimeout(window._selectionChangeTimeout);\n            }\n            window._selectionChangeTimeout = setTimeout(async () => {\n                try {\n                    const hasSequence = await checkSequenceOpen(0, 0); // Quick check, no retries\n                    if (hasSequence && !window.spliceState.activeSequence) {\n                        const seqInfo = await jsx.call('getActiveSequence');\n                        if (seqInfo && !seqInfo.error) {\n                            window.spliceState.activeSequence = seqInfo;\n                            debugLog('Sequence detected via selection change:', seqInfo.name);\n                        }\n                    }\n                } catch (e) {\n                    // Ignore errors during selection change - it's just for proactive updates\n                }\n            }, 200);\n        });\n\n        debugLog('Sequence event listeners initialized');\n    } catch (e) {\n        console.error('[SPLICE] Failed to init sequence event listeners:', e.message);\n    }\n}\n\n// ============================================================================\n// JSX CONNECTION CHECK\n// ============================================================================\nasync function checkJSXConnection() {\n    try {\n        const result = await jsx.call('getVersion');\n        debugLog('JSX connection OK, version:', result);\n        return true;\n    } catch (e) {\n        console.warn('[SPLICE] JSX connection failed:', e.message);\n        setStatus('Premiere Pro connection failed', true);\n        return false;\n    }\n}\n\n/**\n * Check if a sequence is currently open in the Timeline\n * Enhanced with logging and retry logic\n * @param {number} retries - Number of retry attempts (default: 2)\n * @param {number} delayMs - Delay between retries in ms (default: 300)\n * @returns {Promise<boolean>} true if sequence is open\n */\nasync function checkSequenceOpen(retries = 2, delayMs = 300) {\n    for (let attempt = 0; attempt <= retries; attempt++) {\n        try {\n            const result = await jsx.call('checkSequenceOpen');\n            debugLog('checkSequenceOpen attempt', attempt + 1, 'result:', result, 'type:', typeof result);\n\n            if (result === true || result === 'true') {\n                return true;\n            }\n\n            // If false, wait and retry (sequence might be loading)\n            if (attempt < retries) {\n                debugLog('checkSequenceOpen: No sequence found, retrying in', delayMs, 'ms...');\n                await new Promise(r => setTimeout(r, delayMs));\n            }\n        } catch (error) {\n            console.error('[SPLICE] checkSequenceOpen attempt', attempt + 1, 'failed:', error.message);\n\n            // On last attempt, return false but log the actual error\n            if (attempt === retries) {\n                console.error('[SPLICE] checkSequenceOpen: All attempts failed. Last error:', error.message);\n                // Store error for diagnostics\n                window.spliceState.lastSequenceCheckError = error.message;\n                return false;\n            }\n\n            // Wait before retry\n            await new Promise(r => setTimeout(r, delayMs));\n        }\n    }\n    return false;\n}\n\n// ============================================================================\n// OPTIONS TOGGLE\n// ============================================================================\nfunction initOptionsToggle() {\n    debugLog('initOptionsToggle - toggle:', !!ui.optionsToggle, 'panel:', !!ui.optionsPanel);\n    if (ui.optionsToggle && ui.optionsPanel) {\n        ui.optionsToggle.addEventListener('click', () => {\n            debugLog('Options toggle clicked');\n            // Check current state BEFORE toggling\n            const wasCollapsed = ui.optionsPanel.classList.contains('collapsed');\n            ui.optionsPanel.classList.toggle('collapsed');\n            // If it was collapsed, it's now expanded (show 'expanded' class)\n            ui.optionsToggle.classList.toggle('expanded', wasCollapsed);\n            saveSettings({ expandedOptions: wasCollapsed });\n        });\n\n        // Restore state\n        const settings = getSettings();\n        if (!settings.expandedOptions) {\n            ui.optionsPanel.classList.add('collapsed');\n            ui.optionsToggle.classList.remove('expanded');\n        } else {\n            ui.optionsToggle.classList.add('expanded');\n            ui.optionsPanel.classList.remove('collapsed');\n        }\n    }\n}\n\n// ============================================================================\n// TEXT EDITOR TOGGLE\n// ============================================================================\nfunction initTextEditorToggle() {\n    const toggle = document.getElementById('textEditorToggle');\n    const panel = document.getElementById('text-editor-panel');\n    debugLog('initTextEditorToggle - toggle:', !!toggle, 'panel:', !!panel);\n\n    if (toggle && panel) {\n        toggle.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            debugLog('Text Editor toggle clicked');\n            setStatus('Text Editor: ' + (panel.classList.contains('collapsed') ? 'Opening' : 'Closing'));\n            // Check state BEFORE toggling\n            const wasCollapsed = panel.classList.contains('collapsed');\n            panel.classList.toggle('collapsed');\n            const icon = toggle.querySelector('.toggle-icon');\n            debugLog('wasCollapsed:', wasCollapsed, 'icon:', !!icon);\n            if (icon) {\n                // If it was collapsed, it's now expanded (show -)\n                icon.textContent = wasCollapsed ? '-' : '+';\n            }\n        });\n    } else {\n        console.error('[SPLICE] Text Editor toggle elements not found!');\n    }\n}\n\n// ============================================================================\n// SOCIAL REFRAME TOGGLE\n// ============================================================================\nfunction initSocialReframeToggle() {\n    const toggle = document.getElementById('socialReframeToggle');\n    const panel = document.getElementById('social-reframe-panel');\n    debugLog('initSocialReframeToggle - toggle:', !!toggle, 'panel:', !!panel);\n\n    if (toggle && panel) {\n        toggle.addEventListener('click', () => {\n            debugLog('Social Reframe toggle clicked');\n            // Check state BEFORE toggling\n            const wasCollapsed = panel.classList.contains('collapsed');\n            panel.classList.toggle('collapsed');\n            const icon = toggle.querySelector('.toggle-icon');\n            if (icon) {\n                // If it was collapsed, it's now expanded (show -)\n                icon.textContent = wasCollapsed ? '-' : '+';\n            }\n        });\n    } else {\n        console.error('[SPLICE] Social Reframe toggle elements not found!');\n    }\n}\n\n// ============================================================================\n// MUSIC TOGGLE\n// ============================================================================\nfunction initMusicToggle() {\n    const toggle = document.getElementById('musicToggle');\n    const panel = document.getElementById('music-panel');\n    debugLog('initMusicToggle - toggle:', !!toggle, 'panel:', !!panel);\n\n    if (toggle && panel) {\n        toggle.addEventListener('click', () => {\n            debugLog('Music toggle clicked');\n            // Check state BEFORE toggling\n            const wasCollapsed = panel.classList.contains('collapsed');\n            panel.classList.toggle('collapsed');\n            const icon = toggle.querySelector('.toggle-icon');\n            if (icon) {\n                // If it was collapsed, it's now expanded (show -)\n                icon.textContent = wasCollapsed ? '-' : '+';\n            }\n        });\n    } else {\n        console.error('[SPLICE] Music toggle elements not found!');\n    }\n}\n\n// ============================================================================\n// SLIDERS\n// ============================================================================\nfunction initSliders() {\n    // Sensitivity slider\n    if (ui.sensitivitySlider && ui.sensitivityValue) {\n        ui.sensitivitySlider.addEventListener('input', () => {\n            ui.sensitivityValue.textContent = ui.sensitivitySlider.value;\n            saveSettings({ sensitivity: parseInt(ui.sensitivitySlider.value) });\n        });\n    }\n\n    // J-Cut sliders\n    if (ui.jcutLeadIn && ui.jcutLeadInValue) {\n        ui.jcutLeadIn.addEventListener('input', () => {\n            const val = (ui.jcutLeadIn.value / 100).toFixed(2);\n            ui.jcutLeadInValue.textContent = val + 's';\n            saveSettings({ jcutLeadIn: parseFloat(val) });\n        });\n    }\n\n    if (ui.jcutLeadOut && ui.jcutLeadOutValue) {\n        ui.jcutLeadOut.addEventListener('input', () => {\n            const val = (ui.jcutLeadOut.value / 100).toFixed(2);\n            ui.jcutLeadOutValue.textContent = val + 's';\n            saveSettings({ jcutLeadOut: parseFloat(val) });\n        });\n    }\n}\n\n// ============================================================================\n// FEATURE TOGGLES\n// ============================================================================\nfunction initFeatureToggles() {\n    // J-Cut toggle\n    if (ui.enableJCut && ui.jcutSettings) {\n        ui.enableJCut.addEventListener('change', () => {\n            ui.jcutSettings.classList.toggle('collapsed', !ui.enableJCut.checked);\n            saveSettings({ enableJCut: ui.enableJCut.checked });\n        });\n    }\n\n    // Zoom toggle\n    if (ui.enableZoom && ui.zoomSettings) {\n        ui.enableZoom.addEventListener('change', () => {\n            ui.zoomSettings.classList.toggle('collapsed', !ui.enableZoom.checked);\n            saveSettings({ enableZoom: ui.enableZoom.checked });\n        });\n    }\n\n    // Chapters toggle\n    if (ui.enableChapters && ui.chapterSettings) {\n        ui.enableChapters.addEventListener('change', () => {\n            ui.chapterSettings.classList.toggle('collapsed', !ui.enableChapters.checked);\n            saveSettings({ enableChapters: ui.enableChapters.checked });\n        });\n    }\n\n    // Takes detection toggle\n    if (ui.enableTakesDetection) {\n        ui.enableTakesDetection.addEventListener('change', () => {\n            saveSettings({ enableTakesDetection: ui.enableTakesDetection.checked });\n        });\n    }\n\n    // Profanity detection toggle\n    if (ui.enableProfanity && ui.profanitySettings) {\n        ui.enableProfanity.addEventListener('change', () => {\n            ui.profanitySettings.classList.toggle('collapsed', !ui.enableProfanity.checked);\n            saveSettings({ enableProfanity: ui.enableProfanity.checked });\n        });\n    }\n\n    // Filler word detection toggle\n    if (ui.enableFillerDetection && ui.fillerSettings) {\n        ui.enableFillerDetection.addEventListener('change', () => {\n            ui.fillerSettings.classList.toggle('collapsed', !ui.enableFillerDetection.checked);\n            saveSettings({ enableFillerDetection: ui.enableFillerDetection.checked });\n        });\n    }\n}\n\n// ============================================================================\n// PRESET SELECTOR\n// ============================================================================\n// PRESETS is defined in config.js\n\nfunction initPresetSelector() {\n    if (!ui.presetSelector) return;\n\n    ui.presetSelector.addEventListener('change', () => {\n        const presetId = ui.presetSelector.value;\n        applyPreset(presetId);\n    });\n\n    // Load current preset\n    const settings = getSettings();\n    if (settings.activePreset) {\n        ui.presetSelector.value = settings.activePreset;\n    }\n}\n\nfunction applyPreset(presetId) {\n    const preset = PRESETS[presetId];\n    if (!preset) return;\n\n    // Custom preset - keep current settings\n    if (presetId === 'custom' || !preset.settings) {\n        saveSettings({ activePreset: 'custom' });\n        setStatus('Using custom settings');\n        return;\n    }\n\n    const settings = preset.settings;\n\n    // Apply to UI\n    if (ui.sensitivitySlider && settings.sensitivity !== undefined) {\n        ui.sensitivitySlider.value = settings.sensitivity;\n        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n    }\n\n    if (ui.enableJCut) {\n        ui.enableJCut.checked = settings.enableJCut || false;\n        if (ui.jcutSettings) {\n            ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n        }\n    }\n\n    if (settings.jCutLeadIn !== undefined && ui.jcutLeadIn) {\n        ui.jcutLeadIn.value = Math.round(settings.jCutLeadIn * 100);\n        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jCutLeadIn + 's';\n    }\n\n    if (settings.jCutLeadOut !== undefined && ui.jcutLeadOut) {\n        ui.jcutLeadOut.value = Math.round(settings.jCutLeadOut * 100);\n        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jCutLeadOut + 's';\n    }\n\n    // Save merged settings\n    saveSettings({\n        activePreset: presetId,\n        sensitivity: settings.sensitivity,\n        threshold: settings.threshold,\n        minSilenceLength: settings.minSilenceLength,\n        paddingStart: settings.paddingStart,\n        paddingEnd: settings.paddingEnd,\n        enableTakesDetection: settings.enableTakesDetection,\n        enableJCut: settings.enableJCut || false,\n        jcutLeadIn: settings.jCutLeadIn || 0.3,\n        jcutLeadOut: settings.jCutLeadOut || 0.2\n    });\n\n    setStatus(`Applied ${preset.name} preset`);\n}\n\n// ============================================================================\n// LOAD SETTINGS TO UI\n// ============================================================================\nfunction loadSettingsToUI() {\n    const settings = getSettings();\n\n    if (ui.sensitivitySlider) {\n        ui.sensitivitySlider.value = settings.sensitivity;\n        if (ui.sensitivityValue) ui.sensitivityValue.textContent = settings.sensitivity;\n    }\n\n    if (ui.enableTakesDetection) ui.enableTakesDetection.checked = settings.enableTakesDetection;\n    if (ui.enableJCut) ui.enableJCut.checked = settings.enableJCut;\n    if (ui.enableZoom) ui.enableZoom.checked = settings.enableZoom;\n    if (ui.enableChapters) ui.enableChapters.checked = settings.enableChapters;\n\n    if (ui.jcutSettings) ui.jcutSettings.classList.toggle('collapsed', !settings.enableJCut);\n    if (ui.zoomSettings) ui.zoomSettings.classList.toggle('collapsed', !settings.enableZoom);\n    if (ui.chapterSettings) ui.chapterSettings.classList.toggle('collapsed', !settings.enableChapters);\n\n    if (ui.jcutLeadIn) {\n        ui.jcutLeadIn.value = Math.round(settings.jcutLeadIn * 100);\n        if (ui.jcutLeadInValue) ui.jcutLeadInValue.textContent = settings.jcutLeadIn + 's';\n    }\n    if (ui.jcutLeadOut) {\n        ui.jcutLeadOut.value = Math.round(settings.jcutLeadOut * 100);\n        if (ui.jcutLeadOutValue) ui.jcutLeadOutValue.textContent = settings.jcutLeadOut + 's';\n    }\n\n    if (ui.presetSelector && settings.activePreset) {\n        ui.presetSelector.value = settings.activePreset;\n    }\n}\n\n// ============================================================================\n// GO BUTTON - MAIN WORKFLOW\n// ============================================================================\nfunction initGoButton() {\n    if (!ui.goBtn) return;\n\n    ui.goBtn.addEventListener('click', async () => {\n        if (isOperationInProgress) return;\n        await runDetection();\n    });\n}\n\nasync function runDetection() {\n    if (isOperationInProgress) return;\n\n    // Check sequence with enhanced error messaging\n    const hasSequence = await checkSequenceOpen();\n    if (!hasSequence) {\n        // Check if there was a communication error vs just no sequence\n        const lastError = window.spliceState.lastSequenceCheckError;\n        if (lastError && (lastError.includes('CEP') || lastError.includes('communication') || lastError.includes('evalScript'))) {\n            setStatus('Premiere Pro connection issue - try reopening panel', true);\n            console.error('[SPLICE] runDetection: JSX communication failure:', lastError);\n        } else {\n            setStatus('Please open a sequence in the Timeline first', true);\n            debugLog('runDetection: No active sequence in Timeline');\n        }\n        // Clear the error for next check\n        window.spliceState.lastSequenceCheckError = null;\n        return;\n    }\n\n    // Check online\n    if (!isOnline()) {\n        setStatus('Offline - Check your connection', true);\n        return;\n    }\n\n    isOperationInProgress = true;\n    ui.goBtn.disabled = true;\n    showProgress('Detecting silences...');\n\n    try {\n        const settings = getSettings();\n\n        // Get sequence info\n        const seqInfo = await jsx.call('getActiveSequence');\n        debugLog('Sequence info:', seqInfo);\n\n        // Store sequence info for later use\n        currentSequenceInfo = seqInfo;\n        window.spliceState.activeSequence = seqInfo;\n        if (seqInfo && seqInfo.videoPath) {\n            window.spliceState.currentVideoPath = seqInfo.videoPath;\n        }\n\n        // Export audio via JSX for silence detection\n        updateProgress(10, 'Exporting audio...');\n\n        let audioFilePath = null;\n        try {\n            // Get sequence info for audio export\n            const exportResult = await jsx.call('exportSequenceAudioForAnalysis');\n            if (exportResult && exportResult.success && exportResult.outputPath) {\n                audioFilePath = exportResult.outputPath;\n                debugLog('Audio exported to:', audioFilePath);\n            } else if (exportResult && exportResult.error) {\n                throw new Error(exportResult.error);\n            }\n        } catch (exportError) {\n            console.warn('[SPLICE] Audio export failed, trying fallback:', exportError.message);\n            // Try to get audio from first clip in timeline\n            try {\n                const clipInfo = await jsx.call('getFirstClipAudioPath');\n                if (clipInfo && clipInfo.path) {\n                    audioFilePath = clipInfo.path;\n                    debugLog('Using clip audio path:', audioFilePath);\n                }\n            } catch (clipError) {\n                console.warn('[SPLICE] Fallback audio path failed:', clipError.message);\n            }\n        }\n\n        if (!audioFilePath) {\n            throw new Error('Could not export or locate audio file. Please ensure sequence has audio tracks.');\n        }\n\n        // Store audio path globally for other modules\n        currentAudioPath = audioFilePath;\n        window.spliceState.audioPath = audioFilePath;\n\n        // Call backend for silence detection with audio file path\n        updateProgress(30, 'Detecting silences...');\n        const silenceResponse = await fetchWithTimeout(\n            `${getBackendUrl()}/silences-rms`,\n            {\n                method: 'POST',\n                headers: getAuthHeaders(),\n                body: JSON.stringify({\n                    wavPath: audioFilePath,\n                    sensitivity: settings.sensitivity,\n                    minSilenceLength: settings.minSilenceLength || 0.5\n                })\n            }\n        );\n\n        if (!silenceResponse.ok) {\n            throw new Error(await parseErrorResponse(silenceResponse));\n        }\n\n        const silenceData = await silenceResponse.json();\n        previewSilences = silenceData.silences || [];\n\n        // Detect takes if enabled\n        if (settings.enableTakesDetection) {\n            updateProgress(60, 'Detecting takes...');\n            try {\n                const analyzeResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/analyze`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            detectTakes: true\n                        })\n                    }\n                );\n\n                if (analyzeResponse.ok) {\n                    const analyzeData = await analyzeResponse.json();\n                    previewTakes = analyzeData.takes || [];\n\n                    // Store transcript for captions/music modules\n                    if (analyzeData.transcript) {\n                        currentTranscript = analyzeData.transcript;\n                        window.currentTranscript = analyzeData.transcript;\n                        window.spliceState.lastTranscript = analyzeData.transcript;\n                    }\n                } else {\n                    // Handle specific error codes\n                    const errorMsg = await parseErrorResponse(analyzeResponse);\n                    if (analyzeResponse.status === 402) {\n                        console.warn('[SPLICE] Takes detection skipped: insufficient credits');\n                        setStatus('Takes detection skipped: insufficient credits', true);\n                    } else if (analyzeResponse.status === 401) {\n                        console.warn('[SPLICE] Takes detection skipped: authentication required');\n                    } else {\n                        console.warn('[SPLICE] Takes detection failed:', errorMsg);\n                    }\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Takes detection failed:', e.message);\n            }\n        }\n\n        // Detect profanity if enabled\n        if (settings.enableProfanity) {\n            updateProgress(65, 'Detecting profanity...');\n            try {\n                const profanityResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/profanity`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            language: settings.profanityLanguage || 'en',\n                            bleepType: settings.bleepType || 'standard'\n                        })\n                    }\n                );\n\n                if (profanityResponse.ok) {\n                    const profanityData = await profanityResponse.json();\n                    // Backend returns 'words' array, not 'instances'\n                    currentProfanity = profanityData.words || profanityData.instances || [];\n                    if (currentProfanity.length > 0) {\n                        debugLog(`Found ${currentProfanity.length} profanity instances`);\n                    }\n                } else {\n                    console.warn('[SPLICE] Profanity detection failed:', await parseErrorResponse(profanityResponse));\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Profanity detection failed:', e.message);\n            }\n        }\n\n        // Detect chapters if enabled\n        if (settings.enableChapters) {\n            updateProgress(80, 'Detecting chapters...');\n            try {\n                const chapterResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/chapters`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            transcript: currentTranscript,\n                            maxChapters: settings.maxChapters || 10,\n                            minChapterLength: settings.minChapterLength || 60\n                        })\n                    }\n                );\n\n                if (chapterResponse.ok) {\n                    const chapterData = await chapterResponse.json();\n                    currentChapters = chapterData.chapters || [];\n                } else {\n                    const errorMsg = await parseErrorResponse(chapterResponse);\n                    console.warn('[SPLICE] Chapter detection failed:', errorMsg);\n                    // Don't block workflow, just notify user\n                    setStatus('Chapter detection skipped: ' + errorMsg, true);\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Chapter detection failed:', e);\n                setStatus('Chapter detection failed - continuing without chapters', true);\n            }\n        }\n\n        // Detect zoom points if enabled\n        if (settings.enableZoom) {\n            updateProgress(90, 'Detecting zoom points...');\n            try {\n                const zoomResponse = await fetchWithTimeout(\n                    `${getBackendUrl()}/zoom`,\n                    {\n                        method: 'POST',\n                        headers: getAuthHeaders(),\n                        body: JSON.stringify({\n                            wavPath: audioFilePath,\n                            transcript: currentTranscript,\n                            frequency: settings.zoomFrequency || 'medium',\n                            preset: settings.zoomPreset || 'medium',\n                            placement: settings.zoomPlacement || 'sentence_start'\n                        })\n                    }\n                );\n\n                if (zoomResponse.ok) {\n                    const zoomData = await zoomResponse.json();\n                    currentZooms = zoomData.zoomPoints || [];\n                } else {\n                    const errorMsg = await parseErrorResponse(zoomResponse);\n                    console.warn('[SPLICE] Zoom detection failed:', errorMsg);\n                    setStatus('Zoom detection skipped: ' + errorMsg, true);\n                }\n            } catch (e) {\n                console.warn('[SPLICE] Zoom detection failed:', e);\n                setStatus('Zoom detection failed - continuing without zoom points', true);\n            }\n        }\n\n        // Store results\n        lastDetectionResult = {\n            silences: previewSilences,\n            takes: previewTakes,\n            chapters: currentChapters,\n            zooms: currentZooms\n        };\n\n        // Show preview\n        hideProgress();\n        showCombinedPreview();\n        setStatus(`Found ${previewSilences.length} silences, ${previewTakes.length} takes`);\n\n    } catch (error) {\n        console.error('[SPLICE] Detection error:', error);\n        setStatus('Detection failed: ' + error.message, true);\n        hideProgress();\n    } finally {\n        isOperationInProgress = false;\n        ui.goBtn.disabled = false;\n    }\n}\n\n// ============================================================================\n// PROGRESS UI\n// ============================================================================\nfunction showProgress(message) {\n    if (ui.progressContainer) ui.progressContainer.classList.remove('hidden');\n    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n    updateProgress(0, message);\n}\n\nfunction updateProgress(percent, message) {\n    if (ui.progressBar) ui.progressBar.style.width = percent + '%';\n    if (ui.progressText) ui.progressText.textContent = message || '';\n}\n\nfunction hideProgress() {\n    if (ui.progressContainer) ui.progressContainer.classList.add('hidden');\n}\n\n// ============================================================================\n// COMBINED PREVIEW\n// ============================================================================\nfunction showCombinedPreview() {\n    if (!ui.combinedPreview) return;\n\n    ui.combinedPreview.classList.remove('hidden');\n    if (ui.resultsEmpty) ui.resultsEmpty.classList.add('hidden');\n\n    // Update counts\n    if (ui.silenceCount) ui.silenceCount.textContent = previewSilences.length;\n    if (ui.takeCount) ui.takeCount.textContent = previewTakes.length;\n\n    // Select all by default\n    selectedSilenceIndices.clear();\n    previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n    updateSelectedCount();\n\n    // Render preview list\n    renderPreviewList();\n\n    // Show chapter results if available\n    if (currentChapters.length > 0 && ui.chapterResults) {\n        ui.chapterResults.classList.remove('hidden');\n        renderChapterList();\n    }\n\n    // Show zoom results if available\n    if (currentZooms.length > 0 && ui.zoomResults) {\n        ui.zoomResults.classList.remove('hidden');\n    }\n}\n\nfunction renderPreviewList() {\n    if (!ui.previewList) return;\n\n    const html = [];\n\n    // Render silences\n    previewSilences.forEach((silence, i) => {\n        const isSelected = selectedSilenceIndices.has(i);\n        const duration = silence.end - silence.start;\n        html.push(`\n            <div class=\"preview-item ${isSelected ? '' : 'excluded'}\" data-index=\"${i}\" data-type=\"silence\">\n                <input type=\"checkbox\" class=\"preview-item-check\" ${isSelected ? 'checked' : ''}>\n                <div class=\"preview-item-info\">\n                    <div class=\"preview-item-time\">${formatTime(silence.start)} - ${formatTime(silence.end)}</div>\n                    <div class=\"preview-item-duration\">${duration.toFixed(2)}s silence</div>\n                </div>\n            </div>\n        `);\n    });\n\n    // Render takes\n    previewTakes.forEach((take, i) => {\n        // SECURITY: Escape take label to prevent XSS\n        const safeLabel = escapeHtml(take.label || 'Take ' + (take.takeNumber || i + 1));\n        html.push(`\n            <div class=\"preview-item take-item\" data-index=\"${i}\" data-type=\"take\">\n                <div class=\"preview-item-icon\">🎬</div>\n                <div class=\"preview-item-info\">\n                    <div class=\"preview-item-time\">${formatTime(take.start)} - ${formatTime(take.end)}</div>\n                    <div class=\"preview-item-label\">${safeLabel}</div>\n                </div>\n            </div>\n        `);\n    });\n\n    ui.previewList.innerHTML = html.join('');\n\n    // Add click handlers\n    ui.previewList.querySelectorAll('.preview-item').forEach(item => {\n        item.addEventListener('click', (e) => {\n            const index = parseInt(item.dataset.index);\n            const type = item.dataset.type;\n\n            if (e.target.classList.contains('preview-item-check')) {\n                // Checkbox clicked\n                toggleSilenceSelection(index);\n            } else {\n                // Item clicked - seek to time\n                const data = type === 'silence' ? previewSilences[index] : previewTakes[index];\n                seekToTime(data.start);\n            }\n        });\n    });\n}\n\nfunction toggleSilenceSelection(index) {\n    if (selectedSilenceIndices.has(index)) {\n        selectedSilenceIndices.delete(index);\n    } else {\n        selectedSilenceIndices.add(index);\n    }\n    updateSelectedCount();\n    renderPreviewList();\n}\n\nfunction updateSelectedCount() {\n    if (ui.selectedCount) {\n        ui.selectedCount.textContent = selectedSilenceIndices.size;\n    }\n    if (ui.selectAllSilences) {\n        ui.selectAllSilences.checked = selectedSilenceIndices.size === previewSilences.length;\n    }\n}\n\nasync function seekToTime(seconds) {\n    try {\n        // Check if there's an active sequence before seeking\n        if (!app?.project?.activeSequence) {\n            debugLog('No active sequence to seek in');\n            return;\n        }\n        // Use JSX to set playhead position\n        // Note: setPlayerPosition expects ticks as a string without quotes around the number value\n        const ticks = Math.round(seconds * 254016000000);\n        await jsx.evalScript(`app.project.activeSequence.setPlayerPosition(${ticks})`);\n    } catch (e) {\n        console.warn('[SPLICE] Seek failed:', e);\n    }\n}\n\n// ============================================================================\n// CHAPTER LIST\n// ============================================================================\nfunction renderChapterList() {\n    if (!ui.chapterList) return;\n\n    const html = currentChapters.map((chapter, i) => {\n        // SECURITY: Escape chapter title to prevent XSS\n        const safeTitle = escapeHtml(chapter.title);\n        return `\n            <div class=\"chapter-item\" data-index=\"${i}\">\n                <div class=\"chapter-time\">${formatTime(chapter.startTime)}</div>\n                <div class=\"chapter-title\">${safeTitle}</div>\n            </div>\n        `;\n    }).join('');\n\n    ui.chapterList.innerHTML = html;\n\n    // Add click handlers\n    ui.chapterList.querySelectorAll('.chapter-item').forEach(item => {\n        item.addEventListener('click', () => {\n            const index = parseInt(item.dataset.index);\n            seekToTime(currentChapters[index].startTime);\n        });\n    });\n}\n\n// ============================================================================\n// PREVIEW HANDLERS\n// ============================================================================\nfunction initPreviewHandlers() {\n    // Select all checkbox\n    if (ui.selectAllSilences) {\n        ui.selectAllSilences.addEventListener('change', () => {\n            if (ui.selectAllSilences.checked) {\n                previewSilences.forEach((_, i) => selectedSilenceIndices.add(i));\n            } else {\n                selectedSilenceIndices.clear();\n            }\n            updateSelectedCount();\n            renderPreviewList();\n        });\n    }\n\n    // Apply button\n    if (ui.applyPreviewBtn) {\n        ui.applyPreviewBtn.addEventListener('click', applyPreviewAndMarkers);\n    }\n\n    // Cancel button\n    if (ui.cancelPreviewBtn) {\n        ui.cancelPreviewBtn.addEventListener('click', hidePreview);\n    }\n\n    // Build sequence button\n    if (ui.buildSequenceBtn) {\n        ui.buildSequenceBtn.addEventListener('click', buildSequence);\n    }\n\n    // Copy YouTube timestamps\n    if (ui.copyYouTubeBtn) {\n        ui.copyYouTubeBtn.addEventListener('click', copyYouTubeTimestamps);\n    }\n\n    // Add chapter markers\n    if (ui.addChapterMarkersBtn) {\n        ui.addChapterMarkersBtn.addEventListener('click', addChapterMarkers);\n    }\n\n    // Apply zoom markers\n    const applyZoomsBtn = document.getElementById('applyZoomsBtn');\n    if (applyZoomsBtn) {\n        applyZoomsBtn.addEventListener('click', applyZoomMarkers);\n    }\n}\n\nasync function applyPreviewAndMarkers() {\n    if (isOperationInProgress) return;\n\n    isOperationInProgress = true;\n    setStatus('Adding markers...');\n\n    try {\n        // Add silence markers\n        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n        for (const silence of selectedSilences) {\n            await jsx.call('createMarker', silence.start, 'SPLICE: Silence', silence.end - silence.start, null, 1);\n        }\n\n        // Add take markers\n        for (const take of previewTakes) {\n            await jsx.call('createMarker', take.start, take.label || `Take ${take.takeNumber}`, take.end - take.start, null, 5);\n        }\n\n        setStatus(`Added ${selectedSilences.length + previewTakes.length} markers`);\n    } catch (error) {\n        setStatus('Failed to add markers: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\nfunction hidePreview() {\n    if (ui.combinedPreview) ui.combinedPreview.classList.add('hidden');\n    if (ui.chapterResults) ui.chapterResults.classList.add('hidden');\n    if (ui.zoomResults) ui.zoomResults.classList.add('hidden');\n    if (ui.resultsEmpty) ui.resultsEmpty.classList.remove('hidden');\n    previewSilences = [];\n    previewTakes = [];\n    selectedSilenceIndices.clear();\n}\n\nasync function buildSequence() {\n    if (isOperationInProgress) return;\n\n    isOperationInProgress = true;\n    setStatus('Building sequence...');\n\n    try {\n        const settings = getSettings();\n\n        // Ensure we have sequence info\n        if (!currentSequenceInfo) {\n            currentSequenceInfo = await jsx.call('getActiveSequence');\n        }\n\n        // Create cut list from selected silences\n        const selectedSilences = previewSilences.filter((_, i) => selectedSilenceIndices.has(i));\n\n        // Calculate total duration from sequence info or last silence\n        let duration = 0;\n        if (currentSequenceInfo && currentSequenceInfo.duration) {\n            duration = currentSequenceInfo.duration;\n        } else if (previewSilences.length > 0) {\n            const lastSilence = previewSilences[previewSilences.length - 1];\n            duration = lastSilence.end + 10; // Add buffer\n        }\n\n        // Call backend to generate cut list\n        const cutListResponse = await fetchWithTimeout(\n            `${getBackendUrl()}/cut-list`,\n            {\n                method: 'POST',\n                headers: getAuthHeaders(),\n                body: JSON.stringify({\n                    sourceName: currentSequenceInfo?.name || 'Untitled Sequence',\n                    sourcePath: currentSequenceInfo?.treePath || currentSequenceInfo?.name || 'Untitled',\n                    duration: duration,\n                    silences: selectedSilences,\n                    takes: previewTakes,\n                    enableTakes: settings.enableTakesDetection,\n                    jCutOffset: settings.enableJCut ? settings.jcutLeadIn : 0,\n                    lCutOffset: settings.enableJCut ? settings.jcutLeadOut : 0\n                })\n            }\n        );\n\n        if (!cutListResponse.ok) {\n            throw new Error(await parseErrorResponse(cutListResponse));\n        }\n\n        const cutList = await cutListResponse.json();\n\n        // Build sequence via JSX\n        const result = await jsx.call('buildSequenceFromCutList', JSON.stringify(cutList));\n\n        if (result && result.success) {\n            setStatus(`Built sequence: ${result.sequenceName}`);\n            hidePreview();\n        } else {\n            throw new Error(result?.error || 'Build failed');\n        }\n    } catch (error) {\n        setStatus('Build failed: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\nfunction copyYouTubeTimestamps() {\n    if (currentChapters.length === 0) return;\n\n    const timestamps = currentChapters.map(ch =>\n        `${formatTime(ch.startTime)} ${ch.title}`\n    ).join('\\n');\n\n    navigator.clipboard.writeText(timestamps).then(() => {\n        setStatus('Copied YouTube timestamps');\n    }).catch(() => {\n        setStatus('Failed to copy', true);\n    });\n}\n\nasync function addChapterMarkers() {\n    if (isOperationInProgress || currentChapters.length === 0) return;\n\n    isOperationInProgress = true;\n    setStatus('Adding chapter markers...');\n\n    try {\n        for (const chapter of currentChapters) {\n            await jsx.call('addChapterMarker', chapter.startTime, chapter.title, chapter.description);\n        }\n        setStatus(`Added ${currentChapters.length} chapter markers`);\n    } catch (error) {\n        setStatus('Failed to add markers: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\n/**\n * Apply zoom point markers to the timeline\n */\nasync function applyZoomMarkers() {\n    if (isOperationInProgress || currentZooms.length === 0) return;\n\n    isOperationInProgress = true;\n    setStatus('Adding zoom markers...');\n\n    try {\n        for (const zoom of currentZooms) {\n            // Create a marker for each zoom point with zoom intensity info\n            const comment = `Zoom ${zoom.intensity || 'medium'} - ${zoom.reason || 'emphasis'}`;\n            await jsx.call('createMarker', zoom.time, 'SPLICE: Zoom', 0.5, comment, 3);\n        }\n        setStatus(`Added ${currentZooms.length} zoom markers`);\n    } catch (error) {\n        setStatus('Failed to add zoom markers: ' + error.message, true);\n    } finally {\n        isOperationInProgress = false;\n    }\n}\n\n// ============================================================================\n// MODALS\n// ============================================================================\nfunction initModals() {\n    // Settings modal\n    if (ui.settingsBtn && ui.settingsModal) {\n        ui.settingsBtn.addEventListener('click', () => {\n            ui.settingsModal.classList.remove('hidden');\n            // Sync remember options checkbox with current settings\n            const rememberOptions = document.getElementById('rememberOptions');\n            if (rememberOptions) {\n                rememberOptions.checked = getSettings().rememberOptions;\n            }\n        });\n    }\n\n    if (ui.closeSettingsBtn && ui.settingsModal) {\n        ui.closeSettingsBtn.addEventListener('click', () => {\n            ui.settingsModal.classList.add('hidden');\n        });\n    }\n\n    // Remember options checkbox\n    const rememberOptions = document.getElementById('rememberOptions');\n    if (rememberOptions) {\n        rememberOptions.addEventListener('change', () => {\n            saveSettings({ rememberOptions: rememberOptions.checked });\n            if (rememberOptions.checked) {\n                setStatus('Options will be remembered');\n            } else {\n                setStatus('Options will reset to defaults');\n            }\n        });\n    }\n\n    // Credit badge click handler (handles login, retry, and refresh)\n    if (ui.creditBadge) {\n        ui.creditBadge.addEventListener('click', () => {\n            // Use the centralized handler from credits.js\n            if (typeof handleCreditBadgeClick === 'function') {\n                handleCreditBadgeClick();\n            } else {\n                // Fallback if credits.js not loaded yet\n                const settings = getSettings();\n                if (!settings.customerId) {\n                    showLoginModal();\n                }\n            }\n        });\n    }\n\n    if (ui.closeLoginBtn && ui.loginModal) {\n        ui.closeLoginBtn.addEventListener('click', () => {\n            ui.loginModal.classList.add('hidden');\n        });\n    }\n\n    // Note: saveLoginBtn handler is registered in initLoginModal() (config.js)\n    // to avoid duplicate event listeners\n\n    // License lookup button\n    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n    if (lookupLicenseBtn) {\n        lookupLicenseBtn.addEventListener('click', lookupLicense);\n    }\n\n    // Close modals on backdrop click\n    document.querySelectorAll('.modal').forEach(modal => {\n        modal.addEventListener('click', (e) => {\n            if (e.target === modal) {\n                modal.classList.add('hidden');\n            }\n        });\n    });\n}\n\nfunction showLoginModal() {\n    if (ui.loginModal) ui.loginModal.classList.remove('hidden');\n}\n\n/**\n * Show upgrade modal when user tries to access a gated feature\n * @param {string} featureName - Display name of the feature\n * @param {string} requiredTier - Required tier (Pro, Team)\n */\nfunction showUpgradeModal(featureName, requiredTier = 'Pro') {\n    const modal = document.getElementById('upgradeModal');\n    const featureText = document.getElementById('upgradeFeatureName');\n    const tierText = document.getElementById('upgradeRequiredTier');\n\n    if (featureText) {\n        featureText.textContent = featureName;\n    }\n    if (tierText) {\n        tierText.textContent = requiredTier;\n    }\n    if (modal) {\n        modal.classList.remove('hidden');\n    }\n}\n\n/**\n * Close the upgrade modal\n */\nfunction closeUpgradeModal() {\n    const modal = document.getElementById('upgradeModal');\n    if (modal) {\n        modal.classList.add('hidden');\n    }\n}\n\n// Expose showUpgradeModal and closeUpgradeModal globally for feature modules\nwindow.showUpgradeModal = showUpgradeModal;\nwindow.closeUpgradeModal = closeUpgradeModal;\n\nasync function activateLicense() {\n    if (!ui.licenseKeyInput) return;\n\n    const licenseKey = ui.licenseKeyInput.value.trim();\n    if (!licenseKey) {\n        setStatus('Please enter a license key', true);\n        return;\n    }\n\n    try {\n        const response = await fetchWithTimeout(\n            `${getBackendUrl()}/license/activate`,\n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ key: licenseKey })\n            }\n        );\n\n        if (!response.ok) {\n            throw new Error(await parseErrorResponse(response));\n        }\n\n        const data = await response.json();\n        saveSettings({\n            customerId: data.customerId,\n            licenseKey: licenseKey\n        });\n\n        if (ui.loginModal) ui.loginModal.classList.add('hidden');\n        setStatus('License activated');\n        updateCredits();\n    } catch (error) {\n        setStatus('Activation failed: ' + error.message, true);\n    }\n}\n\n/**\n * Look up license key by email address\n */\nasync function lookupLicense() {\n    const lookupEmailInput = document.getElementById('lookupEmailInput');\n    const licenseKeyInput = document.getElementById('licenseKeyInput');\n\n    if (!lookupEmailInput) return;\n\n    const email = lookupEmailInput.value.trim().toLowerCase();\n    if (!email) {\n        setStatus('Please enter your email address', true);\n        return;\n    }\n\n    // Basic email validation\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n        setStatus('Please enter a valid email address', true);\n        return;\n    }\n\n    const lookupBtn = document.getElementById('lookupLicenseBtn');\n    if (lookupBtn) {\n        lookupBtn.disabled = true;\n        lookupBtn.textContent = 'Looking up...';\n    }\n\n    try {\n        const response = await fetchWithTimeout(\n            `${getBackendUrl()}/license/lookup`,\n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ email })\n            },\n            30000\n        );\n\n        const result = await response.json();\n\n        // Note: For security, the backend does NOT return the license key directly.\n        // It sends the key via email to prevent enumeration attacks.\n        if (result.success) {\n            setStatus(result.message || 'If a license exists, it has been sent to your email.');\n        } else {\n            setStatus(result.error || 'Lookup failed. Please try again.', true);\n        }\n    } catch (error) {\n        setStatus('Lookup failed: ' + error.message, true);\n    } finally {\n        if (lookupBtn) {\n            lookupBtn.disabled = false;\n            lookupBtn.textContent = 'Lookup';\n        }\n    }\n}\n\n// ============================================================================\n// CREDITS\n// ============================================================================\nfunction initCredits() {\n    updateCredits();\n}\n\nasync function updateCredits() {\n    if (!ui.creditBadge) return;\n\n    const settings = getSettings();\n    if (!settings.customerId) {\n        ui.creditBadge.className = 'credit-badge login';\n        ui.creditBadge.textContent = 'Login';\n        ui.creditBadge.style.display = 'flex';\n        return;\n    }\n\n    try {\n        const response = await fetchWithTimeout(\n            `${getBackendUrl()}/credits`,\n            {\n                method: 'GET',\n                headers: getAuthHeaders()\n            }\n        );\n\n        if (response.ok) {\n            const data = await response.json();\n            // Backend returns hoursRemaining (not remainingMinutes)\n            const hours = (data.hoursRemaining || 0).toFixed(1);\n            ui.creditBadge.textContent = `${hours}h`;\n            // Low warning when less than 1 hour remaining\n            ui.creditBadge.className = data.hoursRemaining < 1 ? 'credit-badge low' : 'credit-badge ok';\n            ui.creditBadge.style.display = 'flex';\n        } else {\n            ui.creditBadge.className = 'credit-badge error';\n            ui.creditBadge.textContent = 'Error';\n            ui.creditBadge.style.display = 'flex';\n        }\n    } catch {\n        ui.creditBadge.className = 'credit-badge error';\n        ui.creditBadge.textContent = 'Offline';\n        ui.creditBadge.style.display = 'flex';\n    }\n}\n\n// ============================================================================\n// HELP BUTTON\n// ============================================================================\nfunction initHelpButton() {\n    const helpBtn = document.getElementById('helpBtn');\n    if (helpBtn) {\n        helpBtn.addEventListener('click', () => {\n            setStatus('Silence: removes quiet gaps | Takes: detects repeated content | Chapters: AI topic segmentation');\n        });\n    }\n}\n\n// Export for debugging\nwindow.spliceDebug = {\n    getState: () => ({\n        silences: previewSilences,\n        takes: previewTakes,\n        chapters: currentChapters,\n        zooms: currentZooms,\n        selected: Array.from(selectedSilenceIndices)\n    }),\n    jsx,\n    runDetection\n};\n","numLines":1554,"startLine":1,"totalLines":1554}}}
{"parentUuid":"cf360289-318e-4201-b53c-f598a5e51e94","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01T72iL5an6NVLVx1aAaykwx","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also read the supporting files that contain critical helper functions referenced in main.js:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":20358,"cache_read_input_tokens":27945,"cache_creation":{"ephemeral_5m_input_tokens":20358,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2bSPx9k8EKkBXXkUSm6","type":"assistant","uuid":"fdc4aa84-7aab-4408-a67c-0291f8105610","timestamp":"2026-01-12T01:12:00.035Z"}
{"parentUuid":"fdc4aa84-7aab-4408-a67c-0291f8105610","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01T72iL5an6NVLVx1aAaykwx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012jVaTcAuWmAp68EfpXNGtx","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":20358,"cache_read_input_tokens":27945,"cache_creation":{"ephemeral_5m_input_tokens":20358,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2bSPx9k8EKkBXXkUSm6","type":"assistant","uuid":"4be4f5b0-5631-4669-9663-d8219a650787","timestamp":"2026-01-12T01:12:01.106Z"}
{"parentUuid":"4be4f5b0-5631-4669-9663-d8219a650787","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01T72iL5an6NVLVx1aAaykwx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UivwrHL8KVoG5jboDuJXYy","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":20358,"cache_read_input_tokens":27945,"cache_creation":{"ephemeral_5m_input_tokens":20358,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2bSPx9k8EKkBXXkUSm6","type":"assistant","uuid":"c7ec1a46-f781-40ed-aae8-c0589ec9c85d","timestamp":"2026-01-12T01:12:01.490Z"}
{"parentUuid":"c7ec1a46-f781-40ed-aae8-c0589ec9c85d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01T72iL5an6NVLVx1aAaykwx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014peMinMvQCc1EUjLS2puit","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/panel/js/network.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":20358,"cache_read_input_tokens":27945,"cache_creation":{"ephemeral_5m_input_tokens":20358,"ephemeral_1h_input_tokens":0},"output_tokens":208,"service_tier":"standard"}},"requestId":"req_011CX2bSPx9k8EKkBXXkUSm6","type":"assistant","uuid":"de315817-8cd7-4d97-bc58-0621a719f517","timestamp":"2026-01-12T01:12:01.910Z"}
{"parentUuid":"de315817-8cd7-4d97-bc58-0621a719f517","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File does not exist.</tool_use_error>","is_error":true,"tool_use_id":"toolu_014peMinMvQCc1EUjLS2puit"}]},"uuid":"dbb61638-1aa3-4f67-9257-299ffbc0355b","timestamp":"2026-01-12T01:12:01.925Z","toolUseResult":"Error: File does not exist."}
{"parentUuid":"dbb61638-1aa3-4f67-9257-299ffbc0355b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UivwrHL8KVoG5jboDuJXYy","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Credits Display Module\n     3→ *\n     4→ * Fetches and displays user's remaining hours from the billing backend.\n     5→ * Port of UXP credits.js for CEP compatibility.\n     6→ */\n     7→\n     8→// Track fetch error state for retry UI\n     9→let lastCreditsError = null;\n    10→let creditsRetryCount = 0;\n    11→const MAX_CREDITS_RETRIES = 3;\n    12→\n    13→// Store current credits globally for access checks\n    14→let currentCredits = null;\n    15→\n    16→// Store interval reference for cleanup\n    17→let creditsRefreshInterval = null;\n    18→\n    19→/**\n    20→ * Fetch user's credit balance from backend\n    21→ * @returns {Promise<Object | null>} Credit data including isolation hours, or error object\n    22→ */\n    23→async function fetchCredits() {\n    24→    const settings = getSettings();\n    25→    const customerId = settings.customerId;\n    26→\n    27→    if (!customerId) {\n    28→        console.log('[SPLICE] No customerId configured - credits display disabled');\n    29→        lastCreditsError = null;\n    30→        return null;\n    31→    }\n    32→\n    33→    try {\n    34→        // Ensure we have a valid token before making the request\n    35→        if (typeof ensureValidToken === 'function') {\n    36→            const hasValidToken = await ensureValidToken();\n    37→            if (!hasValidToken && !settings.accessToken) {\n    38→                // No JWT token - will fall back to legacy auth in getAuthHeaders()\n    39→                debugLog('[Credits] No JWT token, using legacy auth');\n    40→            }\n    41→        }\n    42→\n    43→        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    44→            method: 'GET',\n    45→            headers: getAuthHeaders()\n    46→        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n    47→\n    48→        if (!response.ok) {\n    49→            const errorMsg = await parseErrorResponse(response);\n    50→\n    51→            // If unauthorized, try refreshing token and retry once\n    52→            if (response.status === 401 && typeof refreshAccessToken === 'function') {\n    53→                debugLog('[Credits] Got 401, attempting token refresh...');\n    54→                const refreshed = await refreshAccessToken();\n    55→                if (refreshed) {\n    56→                    // Retry with new token\n    57→                    const retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n    58→                        method: 'GET',\n    59→                        headers: getAuthHeaders()\n    60→                    }, SPLICE_CONFIG.FETCH_TIMEOUT);\n    61→\n    62→                    if (retryResponse.ok) {\n    63→                        const data = await retryResponse.json();\n    64→                        lastCreditsError = null;\n    65→                        creditsRetryCount = 0;\n    66→                        return {\n    67→                            hoursRemaining: data.hoursRemaining || 0,\n    68→                            hoursTotal: data.hoursTotal || 0,\n    69→                            tierName: data.tierName || 'Free',\n    70→                            tier: data.tier || 'starter',\n    71→                            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n    72→                            isolationHoursTotal: data.isolationHoursTotal || 0,\n    73→                            hasIsolationAccess: data.hasIsolationAccess || false,\n    74→                            isolationOverageRate: data.isolationOverageRate || 0.08,\n    75→                            featureAccess: data.featureAccess || [],\n    76→                            trialDaysRemaining: data.trialDaysRemaining || null,\n    77→                            isOnTrial: data.isOnTrial || false\n    78→                        };\n    79→                    }\n    80→                }\n    81→\n    82→                // Token refresh failed - user needs to re-login\n    83→                console.warn('[SPLICE] Token refresh failed, user needs to re-login');\n    84→                if (typeof clearAuthTokens === 'function') {\n    85→                    clearAuthTokens();\n    86→                }\n    87→                return { _error: true, message: 'Session expired. Please log in again.' };\n    88→            }\n    89→\n    90→            console.error('[SPLICE] Credits fetch failed:', errorMsg);\n    91→            lastCreditsError = errorMsg;\n    92→            return { _error: true, message: errorMsg };\n    93→        }\n    94→\n    95→        const data = await response.json();\n    96→        lastCreditsError = null;\n    97→        creditsRetryCount = 0;\n    98→        return {\n    99→            hoursRemaining: data.hoursRemaining || 0,\n   100→            hoursTotal: data.hoursTotal || 0,\n   101→            tierName: data.tierName || 'Free',\n   102→            tier: data.tier || 'starter',\n   103→            // Isolation hours\n   104→            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n   105→            isolationHoursTotal: data.isolationHoursTotal || 0,\n   106→            hasIsolationAccess: data.hasIsolationAccess || false,\n   107→            isolationOverageRate: data.isolationOverageRate || 0.08,\n   108→            // Feature access\n   109→            featureAccess: data.featureAccess || [],\n   110→            // Trial info\n   111→            trialDaysRemaining: data.trialDaysRemaining || null,\n   112→            isOnTrial: data.isOnTrial || false\n   113→        };\n   114→    } catch (err) {\n   115→        console.error('[SPLICE] Credits fetch error:', err);\n   116→        lastCreditsError = err.message || 'Connection failed';\n   117→        return { _error: true, message: lastCreditsError };\n   118→    }\n   119→}\n   120→\n   121→/**\n   122→ * Clear the credits cache (call on logout)\n   123→ */\n   124→function clearCreditsCache() {\n   125→    currentCredits = null;\n   126→    lastCreditsError = null;\n   127→    creditsRetryCount = 0;\n   128→    console.log('[SPLICE] Credits cache cleared');\n   129→}\n   130→\n   131→/**\n   132→ * Update the credit display in the UI\n   133→ * @param {Object|null} credits - Credit data, error object, or null if unavailable\n   134→ */\n   135→function updateCreditDisplay(credits) {\n   136→    const creditBadge = document.getElementById('creditBadge');\n   137→    if (!creditBadge) return;\n   138→\n   139→    // Handle no customer ID configured\n   140→    if (!credits) {\n   141→        currentCredits = null;\n   142→        creditBadge.style.display = 'flex';\n   143→        creditBadge.textContent = 'Login';\n   144→        creditBadge.title = 'Click to enter license key';\n   145→        creditBadge.classList.remove('ok', 'low');\n   146→        creditBadge.classList.add('login');\n   147→        return;\n   148→    }\n   149→\n   150→    // Handle error state - show error badge with retry\n   151→    if (credits._error) {\n   152→        currentCredits = null;\n   153→        creditBadge.style.display = 'flex';\n   154→        creditBadge.textContent = 'Retry';\n   155→        creditBadge.title = `Error: ${credits.message}\\nClick to retry`;\n   156→        creditBadge.classList.remove('ok', 'low', 'login');\n   157→        creditBadge.classList.add('error');\n   158→        return;\n   159→    }\n   160→\n   161→    // Normal credit display\n   162→    currentCredits = credits;\n   163→    creditBadge.style.display = 'flex';\n   164→\n   165→    // Show referral promo when logged in\n   166→    const referralPromo = document.getElementById('referralPromo');\n   167→    if (referralPromo) {\n   168→        referralPromo.classList.remove('hidden');\n   169→    }\n   170→\n   171→    // Show trial status if on trial\n   172→    if (credits.isOnTrial && credits.trialDaysRemaining) {\n   173→        creditBadge.textContent = `Trial: ${credits.trialDaysRemaining}d`;\n   174→        creditBadge.classList.remove('error', 'login', 'ok', 'low');\n   175→        creditBadge.classList.add('trial');\n   176→    } else {\n   177→        creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n   178→        creditBadge.classList.remove('error', 'login', 'trial');\n   179→    }\n   180→\n   181→    // Build tooltip with isolation info if available\n   182→    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n   183→    if (credits.isOnTrial && credits.trialDaysRemaining) {\n   184→        tooltip = `Trial: ${credits.trialDaysRemaining} days remaining\\n` + tooltip;\n   185→    }\n   186→    if (credits.hasIsolationAccess) {\n   187→        tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n   188→    }\n   189→    creditBadge.title = tooltip;\n   190→\n   191→    // Color based on remaining hours\n   192→    if (credits.hoursRemaining <= 1) {\n   193→        creditBadge.classList.add('low');\n   194→        creditBadge.classList.remove('ok');\n   195→    } else {\n   196→        creditBadge.classList.add('ok');\n   197→        creditBadge.classList.remove('low');\n   198→    }\n   199→\n   200→    // Update isolation checkbox state based on tier access\n   201→    updateIsolationCheckboxState(credits);\n   202→}\n   203→\n   204→/**\n   205→ * Update the isolation checkbox based on tier access\n   206→ */\n   207→function updateIsolationCheckboxState(credits) {\n   208→    const isolatedCheckbox = document.getElementById('sourceIsolated');\n   209→    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n   210→\n   211→    if (!isolatedCheckbox) return;\n   212→\n   213→    if (!credits || !credits.hasIsolationAccess) {\n   214→        // Disable isolation for non-Pro/Team users\n   215→        isolatedCheckbox.disabled = true;\n   216→        isolatedCheckbox.checked = false;\n   217→        if (tierBadge) {\n   218→            tierBadge.textContent = 'Pro+';\n   219→            tierBadge.style.opacity = '1';\n   220→        }\n   221→    } else {\n   222→        // Enable isolation for Pro/Team users\n   223→        isolatedCheckbox.disabled = false;\n   224→        if (tierBadge) {\n   225→            // Show remaining isolation time\n   226→            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n   227→            tierBadge.textContent = `${minsRemaining} min`;\n   228→            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n   229→        }\n   230→    }\n   231→}\n   232→\n   233→/**\n   234→ * Check if user can use isolation and get cost estimate\n   235→ * @param {number} estimatedMinutes - Estimated audio duration in minutes\n   236→ * @returns {Object} Access info with allowed, message, overageCost\n   237→ */\n   238→function checkIsolationAccess(estimatedMinutes = 0) {\n   239→    if (!currentCredits) {\n   240→        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n   241→    }\n   242→\n   243→    if (!currentCredits.hasIsolationAccess) {\n   244→        return {\n   245→            allowed: false,\n   246→            message: 'Vocal isolation requires Pro or Team tier',\n   247→            upgradeRequired: true,\n   248→            overageCost: 0\n   249→        };\n   250→    }\n   251→\n   252→    const estimatedHours = estimatedMinutes / 60;\n   253→    const remaining = currentCredits.isolationHoursRemaining;\n   254→\n   255→    if (remaining >= estimatedHours) {\n   256→        return {\n   257→            allowed: true,\n   258→            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   259→            overageCost: 0\n   260→        };\n   261→    }\n   262→\n   263→    // Calculate overage\n   264→    const overageMinutes = estimatedMinutes - (remaining * 60);\n   265→    const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n   266→\n   267→    return {\n   268→        allowed: true,\n   269→        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n   270→        overageCost,\n   271→        overageMinutes\n   272→    };\n   273→}\n   274→\n   275→/**\n   276→ * Get current credits (for access checks)\n   277→ */\n   278→function getCurrentCredits() {\n   279→    return currentCredits;\n   280→}\n   281→\n   282→/**\n   283→ * Check if user has access to a specific feature based on their tier\n   284→ * @param {string} featureName - The feature to check (e.g., 'social_reframe', 'text_editing', 'multitrack')\n   285→ * @returns {boolean} - True if user has access\n   286→ */\n   287→function hasFeatureAccess(featureName) {\n   288→    if (!currentCredits || !currentCredits.featureAccess) {\n   289→        return false; // Not logged in = no premium features\n   290→    }\n   291→    return currentCredits.featureAccess.includes(featureName);\n   292→}\n   293→\n   294→/**\n   295→ * Get the required tier for a feature\n   296→ * @param {string} featureName - The feature name\n   297→ * @returns {string} - Required tier name\n   298→ */\n   299→function getRequiredTier(featureName) {\n   300→    const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n   301→    const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n   302→\n   303→    if (teamOnlyFeatures.includes(featureName)) {\n   304→        return 'Team';\n   305→    } else if (proFeatures.includes(featureName)) {\n   306→        return 'Pro';\n   307→    }\n   308→    return 'Starter';\n   309→}\n   310→\n   311→/**\n   312→ * Initialize credits display\n   313→ * Fetches credits on load and sets up periodic refresh\n   314→ */\n   315→async function initCredits() {\n   316→    // Clear any existing interval to prevent duplicates\n   317→    if (creditsRefreshInterval) {\n   318→        clearInterval(creditsRefreshInterval);\n   319→    }\n   320→\n   321→    // Initial fetch\n   322→    const credits = await fetchCredits();\n   323→    updateCreditDisplay(credits);\n   324→\n   325→    // Refresh credits every 5 minutes\n   326→    creditsRefreshInterval = setInterval(async () => {\n   327→        const refreshedCredits = await fetchCredits();\n   328→        updateCreditDisplay(refreshedCredits);\n   329→    }, 5 * 60 * 1000);\n   330→}\n   331→\n   332→/**\n   333→ * Cleanup credits module - call on plugin unload\n   334→ */\n   335→function cleanupCredits() {\n   336→    if (creditsRefreshInterval) {\n   337→        clearInterval(creditsRefreshInterval);\n   338→        creditsRefreshInterval = null;\n   339→    }\n   340→}\n   341→\n   342→/**\n   343→ * Manually refresh credits (e.g., after a processing operation)\n   344→ */\n   345→async function refreshCredits() {\n   346→    const credits = await fetchCredits();\n   347→    updateCreditDisplay(credits);\n   348→    return credits;\n   349→}\n   350→\n   351→/**\n   352→ * Retry fetching credits with exponential backoff\n   353→ * Called when user clicks the \"Retry\" badge\n   354→ */\n   355→async function retryFetchCredits() {\n   356→    if (creditsRetryCount >= MAX_CREDITS_RETRIES) {\n   357→        console.warn('[SPLICE] Max retry attempts reached for credits fetch');\n   358→        updateCreditDisplay({\n   359→            _error: true,\n   360→            message: 'Max retries exceeded. Check your connection and try again later.'\n   361→        });\n   362→        creditsRetryCount = 0; // Reset for next attempt\n   363→        return null;\n   364→    }\n   365→\n   366→    creditsRetryCount++;\n   367→    console.log(`[SPLICE] Retrying credits fetch (attempt ${creditsRetryCount}/${MAX_CREDITS_RETRIES})`);\n   368→\n   369→    // Exponential backoff: 1s, 2s, 4s\n   370→    const delay = Math.pow(2, creditsRetryCount - 1) * 1000;\n   371→\n   372→    // Show retrying state\n   373→    const creditBadge = document.getElementById('creditBadge');\n   374→    if (creditBadge) {\n   375→        creditBadge.textContent = `Retry ${creditsRetryCount}...`;\n   376→        creditBadge.classList.add('retrying');\n   377→    }\n   378→\n   379→    await new Promise(resolve => setTimeout(resolve, delay));\n   380→\n   381→    const credits = await fetchCredits();\n   382→\n   383→    if (creditBadge) {\n   384→        creditBadge.classList.remove('retrying');\n   385→    }\n   386→\n   387→    updateCreditDisplay(credits);\n   388→    return credits;\n   389→}\n   390→\n   391→/**\n   392→ * Handle click on credit badge\n   393→ * - If error state: retry fetching\n   394→ * - If login state: open login modal\n   395→ * - Otherwise: refresh credits\n   396→ */\n   397→function handleCreditBadgeClick() {\n   398→    const creditBadge = document.getElementById('creditBadge');\n   399→    if (!creditBadge) return;\n   400→\n   401→    if (creditBadge.classList.contains('error')) {\n   402→        retryFetchCredits();\n   403→    } else if (creditBadge.classList.contains('login')) {\n   404→        // Open login modal (handled in main.js)\n   405→        const loginModal = document.getElementById('loginModal');\n   406→        if (loginModal) {\n   407→            loginModal.classList.remove('hidden');\n   408→        }\n   409→    } else {\n   410→        // Normal state - just refresh\n   411→        refreshCredits();\n   412→    }\n   413→}\n   414→\n   415→// Export for window access\n   416→window.fetchCredits = fetchCredits;\n   417→window.clearCreditsCache = clearCreditsCache;\n   418→window.updateCreditDisplay = updateCreditDisplay;\n   419→window.checkIsolationAccess = checkIsolationAccess;\n   420→window.getCurrentCredits = getCurrentCredits;\n   421→window.hasFeatureAccess = hasFeatureAccess;\n   422→window.getRequiredTier = getRequiredTier;\n   423→window.initCredits = initCredits;\n   424→window.cleanupCredits = cleanupCredits;\n   425→window.refreshCredits = refreshCredits;\n   426→window.retryFetchCredits = retryFetchCredits;\n   427→window.handleCreditBadgeClick = handleCreditBadgeClick;\n   428→\n   429→\n\n</system-reminder>\n"}]},"uuid":"5b41cdb0-2ae1-4a11-9f25-f87a011fca8f","timestamp":"2026-01-12T01:12:01.961Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js","content":"/**\n * SPLICE CEP Credits Display Module\n *\n * Fetches and displays user's remaining hours from the billing backend.\n * Port of UXP credits.js for CEP compatibility.\n */\n\n// Track fetch error state for retry UI\nlet lastCreditsError = null;\nlet creditsRetryCount = 0;\nconst MAX_CREDITS_RETRIES = 3;\n\n// Store current credits globally for access checks\nlet currentCredits = null;\n\n// Store interval reference for cleanup\nlet creditsRefreshInterval = null;\n\n/**\n * Fetch user's credit balance from backend\n * @returns {Promise<Object | null>} Credit data including isolation hours, or error object\n */\nasync function fetchCredits() {\n    const settings = getSettings();\n    const customerId = settings.customerId;\n\n    if (!customerId) {\n        console.log('[SPLICE] No customerId configured - credits display disabled');\n        lastCreditsError = null;\n        return null;\n    }\n\n    try {\n        // Ensure we have a valid token before making the request\n        if (typeof ensureValidToken === 'function') {\n            const hasValidToken = await ensureValidToken();\n            if (!hasValidToken && !settings.accessToken) {\n                // No JWT token - will fall back to legacy auth in getAuthHeaders()\n                debugLog('[Credits] No JWT token, using legacy auth');\n            }\n        }\n\n        const response = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n            method: 'GET',\n            headers: getAuthHeaders()\n        }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n        if (!response.ok) {\n            const errorMsg = await parseErrorResponse(response);\n\n            // If unauthorized, try refreshing token and retry once\n            if (response.status === 401 && typeof refreshAccessToken === 'function') {\n                debugLog('[Credits] Got 401, attempting token refresh...');\n                const refreshed = await refreshAccessToken();\n                if (refreshed) {\n                    // Retry with new token\n                    const retryResponse = await fetchWithTimeout(`${getBackendUrl()}/credits`, {\n                        method: 'GET',\n                        headers: getAuthHeaders()\n                    }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n                    if (retryResponse.ok) {\n                        const data = await retryResponse.json();\n                        lastCreditsError = null;\n                        creditsRetryCount = 0;\n                        return {\n                            hoursRemaining: data.hoursRemaining || 0,\n                            hoursTotal: data.hoursTotal || 0,\n                            tierName: data.tierName || 'Free',\n                            tier: data.tier || 'starter',\n                            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n                            isolationHoursTotal: data.isolationHoursTotal || 0,\n                            hasIsolationAccess: data.hasIsolationAccess || false,\n                            isolationOverageRate: data.isolationOverageRate || 0.08,\n                            featureAccess: data.featureAccess || [],\n                            trialDaysRemaining: data.trialDaysRemaining || null,\n                            isOnTrial: data.isOnTrial || false\n                        };\n                    }\n                }\n\n                // Token refresh failed - user needs to re-login\n                console.warn('[SPLICE] Token refresh failed, user needs to re-login');\n                if (typeof clearAuthTokens === 'function') {\n                    clearAuthTokens();\n                }\n                return { _error: true, message: 'Session expired. Please log in again.' };\n            }\n\n            console.error('[SPLICE] Credits fetch failed:', errorMsg);\n            lastCreditsError = errorMsg;\n            return { _error: true, message: errorMsg };\n        }\n\n        const data = await response.json();\n        lastCreditsError = null;\n        creditsRetryCount = 0;\n        return {\n            hoursRemaining: data.hoursRemaining || 0,\n            hoursTotal: data.hoursTotal || 0,\n            tierName: data.tierName || 'Free',\n            tier: data.tier || 'starter',\n            // Isolation hours\n            isolationHoursRemaining: data.isolationHoursRemaining || 0,\n            isolationHoursTotal: data.isolationHoursTotal || 0,\n            hasIsolationAccess: data.hasIsolationAccess || false,\n            isolationOverageRate: data.isolationOverageRate || 0.08,\n            // Feature access\n            featureAccess: data.featureAccess || [],\n            // Trial info\n            trialDaysRemaining: data.trialDaysRemaining || null,\n            isOnTrial: data.isOnTrial || false\n        };\n    } catch (err) {\n        console.error('[SPLICE] Credits fetch error:', err);\n        lastCreditsError = err.message || 'Connection failed';\n        return { _error: true, message: lastCreditsError };\n    }\n}\n\n/**\n * Clear the credits cache (call on logout)\n */\nfunction clearCreditsCache() {\n    currentCredits = null;\n    lastCreditsError = null;\n    creditsRetryCount = 0;\n    console.log('[SPLICE] Credits cache cleared');\n}\n\n/**\n * Update the credit display in the UI\n * @param {Object|null} credits - Credit data, error object, or null if unavailable\n */\nfunction updateCreditDisplay(credits) {\n    const creditBadge = document.getElementById('creditBadge');\n    if (!creditBadge) return;\n\n    // Handle no customer ID configured\n    if (!credits) {\n        currentCredits = null;\n        creditBadge.style.display = 'flex';\n        creditBadge.textContent = 'Login';\n        creditBadge.title = 'Click to enter license key';\n        creditBadge.classList.remove('ok', 'low');\n        creditBadge.classList.add('login');\n        return;\n    }\n\n    // Handle error state - show error badge with retry\n    if (credits._error) {\n        currentCredits = null;\n        creditBadge.style.display = 'flex';\n        creditBadge.textContent = 'Retry';\n        creditBadge.title = `Error: ${credits.message}\\nClick to retry`;\n        creditBadge.classList.remove('ok', 'low', 'login');\n        creditBadge.classList.add('error');\n        return;\n    }\n\n    // Normal credit display\n    currentCredits = credits;\n    creditBadge.style.display = 'flex';\n\n    // Show referral promo when logged in\n    const referralPromo = document.getElementById('referralPromo');\n    if (referralPromo) {\n        referralPromo.classList.remove('hidden');\n    }\n\n    // Show trial status if on trial\n    if (credits.isOnTrial && credits.trialDaysRemaining) {\n        creditBadge.textContent = `Trial: ${credits.trialDaysRemaining}d`;\n        creditBadge.classList.remove('error', 'login', 'ok', 'low');\n        creditBadge.classList.add('trial');\n    } else {\n        creditBadge.textContent = `${credits.hoursRemaining.toFixed(1)} hrs`;\n        creditBadge.classList.remove('error', 'login', 'trial');\n    }\n\n    // Build tooltip with isolation info if available\n    let tooltip = `${credits.tierName}: ${credits.hoursRemaining.toFixed(1)} / ${credits.hoursTotal} hours`;\n    if (credits.isOnTrial && credits.trialDaysRemaining) {\n        tooltip = `Trial: ${credits.trialDaysRemaining} days remaining\\n` + tooltip;\n    }\n    if (credits.hasIsolationAccess) {\n        tooltip += `\\nIsolation: ${(credits.isolationHoursRemaining * 60).toFixed(0)} / ${(credits.isolationHoursTotal * 60).toFixed(0)} min`;\n    }\n    creditBadge.title = tooltip;\n\n    // Color based on remaining hours\n    if (credits.hoursRemaining <= 1) {\n        creditBadge.classList.add('low');\n        creditBadge.classList.remove('ok');\n    } else {\n        creditBadge.classList.add('ok');\n        creditBadge.classList.remove('low');\n    }\n\n    // Update isolation checkbox state based on tier access\n    updateIsolationCheckboxState(credits);\n}\n\n/**\n * Update the isolation checkbox based on tier access\n */\nfunction updateIsolationCheckboxState(credits) {\n    const isolatedCheckbox = document.getElementById('sourceIsolated');\n    const tierBadge = isolatedCheckbox?.parentElement?.querySelector('.tier-badge');\n\n    if (!isolatedCheckbox) return;\n\n    if (!credits || !credits.hasIsolationAccess) {\n        // Disable isolation for non-Pro/Team users\n        isolatedCheckbox.disabled = true;\n        isolatedCheckbox.checked = false;\n        if (tierBadge) {\n            tierBadge.textContent = 'Pro+';\n            tierBadge.style.opacity = '1';\n        }\n    } else {\n        // Enable isolation for Pro/Team users\n        isolatedCheckbox.disabled = false;\n        if (tierBadge) {\n            // Show remaining isolation time\n            const minsRemaining = (credits.isolationHoursRemaining * 60).toFixed(0);\n            tierBadge.textContent = `${minsRemaining} min`;\n            tierBadge.style.opacity = credits.isolationHoursRemaining > 0 ? '1' : '0.6';\n        }\n    }\n}\n\n/**\n * Check if user can use isolation and get cost estimate\n * @param {number} estimatedMinutes - Estimated audio duration in minutes\n * @returns {Object} Access info with allowed, message, overageCost\n */\nfunction checkIsolationAccess(estimatedMinutes = 0) {\n    if (!currentCredits) {\n        return { allowed: false, message: 'Credits not loaded', overageCost: 0 };\n    }\n\n    if (!currentCredits.hasIsolationAccess) {\n        return {\n            allowed: false,\n            message: 'Vocal isolation requires Pro or Team tier',\n            upgradeRequired: true,\n            overageCost: 0\n        };\n    }\n\n    const estimatedHours = estimatedMinutes / 60;\n    const remaining = currentCredits.isolationHoursRemaining;\n\n    if (remaining >= estimatedHours) {\n        return {\n            allowed: true,\n            message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n            overageCost: 0\n        };\n    }\n\n    // Calculate overage\n    const overageMinutes = estimatedMinutes - (remaining * 60);\n    const overageCost = overageMinutes * currentCredits.isolationOverageRate;\n\n    return {\n        allowed: true,\n        message: `${remaining > 0 ? `${(remaining * 60).toFixed(0)} included + ` : ''}${overageMinutes.toFixed(0)} min overage ($${overageCost.toFixed(2)})`,\n        overageCost,\n        overageMinutes\n    };\n}\n\n/**\n * Get current credits (for access checks)\n */\nfunction getCurrentCredits() {\n    return currentCredits;\n}\n\n/**\n * Check if user has access to a specific feature based on their tier\n * @param {string} featureName - The feature to check (e.g., 'social_reframe', 'text_editing', 'multitrack')\n * @returns {boolean} - True if user has access\n */\nfunction hasFeatureAccess(featureName) {\n    if (!currentCredits || !currentCredits.featureAccess) {\n        return false; // Not logged in = no premium features\n    }\n    return currentCredits.featureAccess.includes(featureName);\n}\n\n/**\n * Get the required tier for a feature\n * @param {string} featureName - The feature name\n * @returns {string} - Required tier name\n */\nfunction getRequiredTier(featureName) {\n    const teamOnlyFeatures = ['multitrack', 'music_to_cut', 'mood_timeline', 'youtube_metadata', 'profanity_bleeping'];\n    const proFeatures = ['vocal_isolation', 'social_reframe', 'text_editing', 'all_captions', 'profanity_detection', 'chapter_detection'];\n\n    if (teamOnlyFeatures.includes(featureName)) {\n        return 'Team';\n    } else if (proFeatures.includes(featureName)) {\n        return 'Pro';\n    }\n    return 'Starter';\n}\n\n/**\n * Initialize credits display\n * Fetches credits on load and sets up periodic refresh\n */\nasync function initCredits() {\n    // Clear any existing interval to prevent duplicates\n    if (creditsRefreshInterval) {\n        clearInterval(creditsRefreshInterval);\n    }\n\n    // Initial fetch\n    const credits = await fetchCredits();\n    updateCreditDisplay(credits);\n\n    // Refresh credits every 5 minutes\n    creditsRefreshInterval = setInterval(async () => {\n        const refreshedCredits = await fetchCredits();\n        updateCreditDisplay(refreshedCredits);\n    }, 5 * 60 * 1000);\n}\n\n/**\n * Cleanup credits module - call on plugin unload\n */\nfunction cleanupCredits() {\n    if (creditsRefreshInterval) {\n        clearInterval(creditsRefreshInterval);\n        creditsRefreshInterval = null;\n    }\n}\n\n/**\n * Manually refresh credits (e.g., after a processing operation)\n */\nasync function refreshCredits() {\n    const credits = await fetchCredits();\n    updateCreditDisplay(credits);\n    return credits;\n}\n\n/**\n * Retry fetching credits with exponential backoff\n * Called when user clicks the \"Retry\" badge\n */\nasync function retryFetchCredits() {\n    if (creditsRetryCount >= MAX_CREDITS_RETRIES) {\n        console.warn('[SPLICE] Max retry attempts reached for credits fetch');\n        updateCreditDisplay({\n            _error: true,\n            message: 'Max retries exceeded. Check your connection and try again later.'\n        });\n        creditsRetryCount = 0; // Reset for next attempt\n        return null;\n    }\n\n    creditsRetryCount++;\n    console.log(`[SPLICE] Retrying credits fetch (attempt ${creditsRetryCount}/${MAX_CREDITS_RETRIES})`);\n\n    // Exponential backoff: 1s, 2s, 4s\n    const delay = Math.pow(2, creditsRetryCount - 1) * 1000;\n\n    // Show retrying state\n    const creditBadge = document.getElementById('creditBadge');\n    if (creditBadge) {\n        creditBadge.textContent = `Retry ${creditsRetryCount}...`;\n        creditBadge.classList.add('retrying');\n    }\n\n    await new Promise(resolve => setTimeout(resolve, delay));\n\n    const credits = await fetchCredits();\n\n    if (creditBadge) {\n        creditBadge.classList.remove('retrying');\n    }\n\n    updateCreditDisplay(credits);\n    return credits;\n}\n\n/**\n * Handle click on credit badge\n * - If error state: retry fetching\n * - If login state: open login modal\n * - Otherwise: refresh credits\n */\nfunction handleCreditBadgeClick() {\n    const creditBadge = document.getElementById('creditBadge');\n    if (!creditBadge) return;\n\n    if (creditBadge.classList.contains('error')) {\n        retryFetchCredits();\n    } else if (creditBadge.classList.contains('login')) {\n        // Open login modal (handled in main.js)\n        const loginModal = document.getElementById('loginModal');\n        if (loginModal) {\n            loginModal.classList.remove('hidden');\n        }\n    } else {\n        // Normal state - just refresh\n        refreshCredits();\n    }\n}\n\n// Export for window access\nwindow.fetchCredits = fetchCredits;\nwindow.clearCreditsCache = clearCreditsCache;\nwindow.updateCreditDisplay = updateCreditDisplay;\nwindow.checkIsolationAccess = checkIsolationAccess;\nwindow.getCurrentCredits = getCurrentCredits;\nwindow.hasFeatureAccess = hasFeatureAccess;\nwindow.getRequiredTier = getRequiredTier;\nwindow.initCredits = initCredits;\nwindow.cleanupCredits = cleanupCredits;\nwindow.refreshCredits = refreshCredits;\nwindow.retryFetchCredits = retryFetchCredits;\nwindow.handleCreditBadgeClick = handleCreditBadgeClick;\n\n","numLines":429,"startLine":1,"totalLines":429}}}
{"parentUuid":"5b41cdb0-2ae1-4a11-9f25-f87a011fca8f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012jVaTcAuWmAp68EfpXNGtx","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Panel Configuration\n     3→ * Backend URLs, paths, and utility functions\n     4→ */\n     5→\n     6→// ============================================================================\n     7→// DEBUG MODE CONFIGURATION\n     8→// ============================================================================\n     9→\n    10→/**\n    11→ * Debug mode flag - enables verbose diagnostic logging\n    12→ * Can be enabled via localStorage for troubleshooting:\n    13→ *   localStorage.setItem('spliceDebugMode', 'true');\n    14→ *\n    15→ * Default: false (production mode - minimal logging)\n    16→ */\n    17→const SPLICE_DEBUG = localStorage.getItem('spliceDebugMode') === 'true';\n    18→\n    19→/**\n    20→ * Debug logging function - only outputs when debug mode is enabled\n    21→ * Use this for diagnostic/development logging that should be silent in production\n    22→ * @param {...any} args - Arguments to log (prefixed with [SPLICE DEBUG])\n    23→ */\n    24→function debugLog(...args) {\n    25→    if (SPLICE_DEBUG) {\n    26→        console.log('[SPLICE DEBUG]', ...args);\n    27→    }\n    28→}\n    29→\n    30→/**\n    31→ * Debug fetch logging - verbose fetch request/response logging\n    32→ * @param {...any} args - Arguments to log (prefixed with [SPLICE FETCH])\n    33→ */\n    34→function debugFetch(...args) {\n    35→    if (SPLICE_DEBUG) {\n    36→        console.log('[SPLICE FETCH]', ...args);\n    37→    }\n    38→}\n    39→\n    40→// ============================================================================\n    41→// BACKEND CONFIGURATION\n    42→// ============================================================================\n    43→const SPLICE_CONFIG = {\n    44→    VERSION: '6.0.3',\n    45→    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    46→    BACKEND_DEV: 'https://127.0.0.1:3847',\n    47→    FETCH_TIMEOUT: 120000, // 2 minutes\n    48→    RETRY_ATTEMPTS: 3,\n    49→    RETRY_DELAY: 1000\n    50→};\n    51→\n    52→/**\n    53→ * Get the backend URL based on environment\n    54→ * FIXED: CEP panels always run from file://, so we default to PROD\n    55→ * Use localStorage to override for local development if needed\n    56→ */\n    57→function getBackendUrl() {\n    58→    // Priority 1: Allow override via localStorage (for local dev testing)\n    59→    const customUrl = localStorage.getItem('spliceBackendUrl');\n    60→    if (customUrl) {\n    61→        debugLog('Using custom backend URL from localStorage:', customUrl);\n    62→        return customUrl;\n    63→    }\n    64→\n    65→    // Priority 2: Default to production backend\n    66→    // (CEP panels always run from file://, so can't reliably detect dev mode)\n    67→    debugLog('Using production backend URL:', SPLICE_CONFIG.BACKEND_PROD);\n    68→    return SPLICE_CONFIG.BACKEND_PROD;\n    69→}\n    70→\n    71→// ============================================================================\n    72→// JSX BRIDGE - Communicate with Premiere Pro\n    73→// ============================================================================\n    74→const jsx = {\n    75→    cs: null,\n    76→    _initPromise: null,\n    77→    _initialized: false,\n    78→\n    79→    /**\n    80→     * Initialize the CSInterface\n    81→     * Returns a promise that resolves when ready (true/false)\n    82→     * Does NOT reject - gracefully handles missing CEP environment\n    83→     */\n    84→    init: function() {\n    85→        if (this._initPromise) return this._initPromise;\n    86→\n    87→        this._initPromise = new Promise((resolve) => {\n    88→            try {\n    89→                if (typeof CSInterface !== 'undefined') {\n    90→                    this.cs = new CSInterface();\n    91→                    // Verify we're in a real CEP environment by checking for __adobe_cep__\n    92→                    if (window.__adobe_cep__) {\n    93→                        this._initialized = true;\n    94→                        debugLog('[JSX] CSInterface initialized successfully (CEP environment detected)');\n    95→                    } else {\n    96→                        // CSInterface exists but no CEP runtime - browser/dev mode\n    97→                        this._initialized = true;\n    98→                        debugLog('[JSX] CSInterface initialized (development/browser mode)');\n    99→                    }\n   100→                } else {\n   101→                    console.warn('[JSX] CSInterface not available - panel may not function correctly');\n   102→                    this._initialized = false;\n   103→                }\n   104→            } catch (err) {\n   105→                console.error('[JSX] Failed to initialize CSInterface:', err);\n   106→                this._initialized = false;\n   107→            }\n   108→            resolve(this._initialized);\n   109→        });\n   110→\n   111→        return this._initPromise;\n   112→    },\n   113→\n   114→    /**\n   115→     * Ensure JSX is initialized before making calls\n   116→     */\n   117→    ensureInitialized: async function() {\n   118→        if (!this._initialized) {\n   119→            await this.init();\n   120→        }\n   121→        if (!this.cs) {\n   122→            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n   123→        }\n   124→    },\n   125→\n   126→    /**\n   127→     * Execute ExtendScript in Premiere Pro\n   128→     * @param {string} script - ExtendScript to execute\n   129→     * @returns {Promise<any>} - Parsed result\n   130→     */\n   131→    evalScript: async function(script) {\n   132→        await this.ensureInitialized();\n   133→\n   134→        return new Promise((resolve, reject) => {\n   135→            this.cs.evalScript(script, (result) => {\n   136→                if (result === 'undefined' || result === undefined) {\n   137→                    resolve(null);\n   138→                    return;\n   139→                }\n   140→\n   141→                // Check for EvalScript error or ExtendScript runtime errors\n   142→                if (typeof result === 'string' && (\n   143→                    result.indexOf('EvalScript error') !== -1 ||\n   144→                    result.indexOf('Error:') !== -1 ||\n   145→                    result.indexOf('TypeError:') !== -1 ||\n   146→                    result.indexOf('ReferenceError:') !== -1\n   147→                )) {\n   148→                    reject(new Error(result));\n   149→                    return;\n   150→                }\n   151→\n   152→                // Try to parse JSON\n   153→                try {\n   154→                    const parsed = JSON.parse(result);\n   155→                    if (parsed.error) {\n   156→                        reject(new Error(parsed.error));\n   157→                    } else {\n   158→                        resolve(parsed);\n   159→                    }\n   160→                } catch (e) {\n   161→                    // Return as-is if not JSON\n   162→                    resolve(result);\n   163→                }\n   164→            });\n   165→        });\n   166→    },\n   167→\n   168→    /**\n   169→     * Call a JSX function with arguments\n   170→     * @param {string} funcName - Function name\n   171→     * @param {...any} args - Arguments to pass\n   172→     * @returns {Promise<any>}\n   173→     */\n   174→    call: async function(funcName, ...args) {\n   175→        await this.ensureInitialized();\n   176→\n   177→        const escapedArgs = args.map(arg => {\n   178→            if (arg === null || arg === undefined) return 'null';\n   179→            if (typeof arg === 'string') {\n   180→                // Escape backslashes first, then other special chars\n   181→                return `'${arg\n   182→                    .replace(/\\\\/g, '\\\\\\\\')\n   183→                    .replace(/'/g, \"\\\\'\")\n   184→                    .replace(/\\r/g, '\\\\r')\n   185→                    .replace(/\\n/g, '\\\\n')\n   186→                    .replace(/\\t/g, '\\\\t')}'`;\n   187→            }\n   188→            if (typeof arg === 'object') {\n   189→                return `'${JSON.stringify(arg)\n   190→                    .replace(/\\\\/g, '\\\\\\\\')\n   191→                    .replace(/'/g, \"\\\\'\")}'`;\n   192→            }\n   193→            return String(arg);\n   194→        });\n   195→\n   196→        const script = `${funcName}(${escapedArgs.join(', ')})`;\n   197→        return this.evalScript(script);\n   198→    }\n   199→};\n   200→\n   201→// ============================================================================\n   202→// FETCH UTILITIES\n   203→// ============================================================================\n   204→\n   205→/**\n   206→ * Fetch with timeout support\n   207→ * @param {string} url - URL to fetch\n   208→ * @param {object} options - Fetch options\n   209→ * @param {number} timeout - Timeout in ms\n   210→ */\n   211→async function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n   212→    // DIAGNOSTIC: Log fetch request details (debug mode only)\n   213→    debugFetch('=== FETCH REQUEST START ===');\n   214→    debugFetch('URL:', url);\n   215→    debugFetch('Method:', options?.method || 'GET');\n   216→    debugFetch('Headers:', options?.headers);\n   217→    debugFetch('Timeout:', timeout);\n   218→    debugFetch('Is CEP environment:', typeof CSInterface !== 'undefined');\n   219→    debugFetch('=================================');\n   220→\n   221→    const controller = new AbortController();\n   222→    const timeoutId = setTimeout(() => controller.abort(), timeout);\n   223→\n   224→    try {\n   225→        const response = await fetch(url, {\n   226→            ...options,\n   227→            signal: controller.signal\n   228→        });\n   229→        clearTimeout(timeoutId);\n   230→\n   231→        // DIAGNOSTIC: Log successful response (debug mode only)\n   232→        debugFetch('=== FETCH RESPONSE SUCCESS ===');\n   233→        debugFetch('Status:', response.status);\n   234→        debugFetch('OK:', response.ok);\n   235→        debugFetch('=================================');\n   236→\n   237→        return response;\n   238→    } catch (error) {\n   239→        clearTimeout(timeoutId);\n   240→\n   241→        // DIAGNOSTIC: Log raw fetch error (debug mode only)\n   242→        debugFetch('=== FETCH ERROR CAUGHT ===');\n   243→        debugFetch('Error name:', error?.name);\n   244→        debugFetch('Error message:', error?.message);\n   245→        debugFetch('Error type:', typeof error);\n   246→        debugFetch('Error constructor:', error?.constructor?.name);\n   247→        debugFetch('Is AbortError:', error.name === 'AbortError');\n   248→        debugFetch('Is TypeError:', error.name === 'TypeError');\n   249→        debugFetch('Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\n   250→        debugFetch('=================================');\n   251→\n   252→        if (error.name === 'AbortError') {\n   253→            throw new Error(`Request timeout after ${timeout}ms`);\n   254→        }\n   255→        throw error;\n   256→    }\n   257→}\n   258→\n   259→/**\n   260→ * Parse error response from backend\n   261→ * @param {Response} response - Fetch response\n   262→ */\n   263→async function parseErrorResponse(response) {\n   264→    try {\n   265→        const data = await response.json();\n   266→        return data.error || data.message || `HTTP ${response.status}`;\n   267→    } catch {\n   268→        return `HTTP ${response.status}: ${response.statusText}`;\n   269→    }\n   270→}\n   271→\n   272→/**\n   273→ * Get auth headers for API requests\n   274→ * Uses JWT Bearer token if available, with legacy fallback\n   275→ */\n   276→function getAuthHeaders() {\n   277→    const headers = { 'Content-Type': 'application/json' };\n   278→    const settings = getSettings();\n   279→\n   280→    // Prefer JWT Bearer token (modern auth)\n   281→    if (settings.accessToken) {\n   282→        headers['Authorization'] = `Bearer ${settings.accessToken}`;\n   283→        return headers;\n   284→    }\n   285→\n   286→    // Legacy fallback for backwards compatibility\n   287→    // This will be removed after 2026-04-11\n   288→    if (settings.customerId) {\n   289→        headers['x-stripe-customer-id'] = settings.customerId;\n   290→        console.warn('[SPLICE] Using deprecated x-stripe-customer-id header. Please re-login to upgrade to JWT auth.');\n   291→    }\n   292→\n   293→    return headers;\n   294→}\n   295→\n   296→/**\n   297→ * Check if the access token is expired or about to expire\n   298→ * @returns {boolean} True if token needs refresh\n   299→ */\n   300→function isTokenExpired() {\n   301→    const settings = getSettings();\n   302→    if (!settings.tokenExpiry) return true;\n   303→\n   304→    // Refresh if less than 5 minutes remaining\n   305→    const bufferMs = 5 * 60 * 1000;\n   306→    return Date.now() >= (settings.tokenExpiry - bufferMs);\n   307→}\n   308→\n   309→/**\n   310→ * Refresh the access token using the refresh token\n   311→ * @returns {Promise<boolean>} True if refresh succeeded\n   312→ */\n   313→async function refreshAccessToken() {\n   314→    const settings = getSettings();\n   315→\n   316→    if (!settings.refreshToken) {\n   317→        debugLog('[Auth] No refresh token available');\n   318→        return false;\n   319→    }\n   320→\n   321→    try {\n   322→        debugLog('[Auth] Refreshing access token...');\n   323→\n   324→        const response = await fetchWithTimeout(`${getBackendUrl()}/auth/refresh`, {\n   325→            method: 'POST',\n   326→            headers: { 'Content-Type': 'application/json' },\n   327→            body: JSON.stringify({ refreshToken: settings.refreshToken })\n   328→        }, 30000);\n   329→\n   330→        if (!response.ok) {\n   331→            const errorMsg = await parseErrorResponse(response);\n   332→            console.error('[Auth] Token refresh failed:', errorMsg);\n   333→\n   334→            // If refresh token is invalid, clear auth and require re-login\n   335→            if (response.status === 401) {\n   336→                clearAuthTokens();\n   337→            }\n   338→            return false;\n   339→        }\n   340→\n   341→        const data = await response.json();\n   342→\n   343→        // Save new access token\n   344→        const expiresInMs = (data.expiresIn || 86400) * 1000; // Default 24h\n   345→        saveSettings({\n   346→            accessToken: data.token,\n   347→            tokenExpiry: Date.now() + expiresInMs\n   348→        });\n   349→\n   350→        debugLog('[Auth] Access token refreshed successfully');\n   351→        return true;\n   352→    } catch (err) {\n   353→        console.error('[Auth] Token refresh error:', err);\n   354→        return false;\n   355→    }\n   356→}\n   357→\n   358→/**\n   359→ * Clear all auth tokens (call on logout or auth failure)\n   360→ */\n   361→function clearAuthTokens() {\n   362→    saveSettings({\n   363→        accessToken: null,\n   364→        refreshToken: null,\n   365→        tokenExpiry: null\n   366→    });\n   367→    debugLog('[Auth] Auth tokens cleared');\n   368→}\n   369→\n   370→/**\n   371→ * Ensure we have a valid access token, refreshing if needed\n   372→ * @returns {Promise<boolean>} True if we have a valid token\n   373→ */\n   374→async function ensureValidToken() {\n   375→    const settings = getSettings();\n   376→\n   377→    // No token at all - need to login\n   378→    if (!settings.accessToken) {\n   379→        return false;\n   380→    }\n   381→\n   382→    // Token not expired - good to go\n   383→    if (!isTokenExpired()) {\n   384→        return true;\n   385→    }\n   386→\n   387→    // Try to refresh\n   388→    return await refreshAccessToken();\n   389→}\n   390→\n   391→// ============================================================================\n   392→// SETTINGS MANAGEMENT\n   393→// ============================================================================\n   394→\n   395→const DEFAULT_SETTINGS = {\n   396→    sensitivity: 50,\n   397→    minSilenceLength: 0.5,\n   398→    sourceIsolated: false,\n   399→    enableTakesDetection: true,\n   400→    enableJCut: false,\n   401→    jcutLeadIn: 0.3,\n   402→    jcutLeadOut: 0.2,\n   403→    enableZoom: false,\n   404→    zoomFrequency: 'medium',\n   405→    zoomPreset: 'medium',\n   406→    zoomPlacement: 'sentence_start',\n   407→    enableChapters: false,\n   408→    maxChapters: 10,\n   409→    minChapterLength: 60,\n   410→    enableProfanity: false,\n   411→    profanityLanguage: 'en',\n   412→    bleepType: 'standard',\n   413→    // Authentication\n   414→    customerId: null,\n   415→    licenseKey: null,\n   416→    accessToken: null,\n   417→    refreshToken: null,\n   418→    tokenExpiry: null,\n   419→    // UI State\n   420→    expandedOptions: false,\n   421→    activePreset: 'podcast',\n   422→    rememberOptions: false\n   423→};\n   424→\n   425→// Current storage version for future migrations\n   426→const SETTINGS_STORAGE_VERSION = 2;\n   427→\n   428→// Fields that contain sensitive data and should be encrypted\n   429→const SENSITIVE_FIELDS = ['customerId', 'licenseKey', 'accessToken', 'refreshToken'];\n   430→\n   431→// ============================================================================\n   432→// ENCRYPTION HELPERS FOR SENSITIVE DATA\n   433→// ============================================================================\n   434→\n   435→/**\n   436→ * Simple obfuscation for localStorage\n   437→ * NOTE: This is NOT cryptographically secure, but provides basic protection\n   438→ * against casual inspection of localStorage. For truly sensitive data,\n   439→ * consider server-side storage or proper encryption libraries.\n   440→ *\n   441→ * @param {any} data - Data to encode\n   442→ * @returns {string|null} Encoded string or null on error\n   443→ */\n   444→function encryptForStorage(data) {\n   445→    try {\n   446→        if (data === null || data === undefined) {\n   447→            return null;\n   448→        }\n   449→        // Double encode to add slight obfuscation layer\n   450→        const jsonStr = JSON.stringify(data);\n   451→        const encoded = encodeURIComponent(jsonStr);\n   452→        return btoa(encoded);\n   453→    } catch (e) {\n   454→        debugLog('[Config] Encryption error:', e);\n   455→        return null;\n   456→    }\n   457→}\n   458→\n   459→/**\n   460→ * Decode obfuscated data from localStorage\n   461→ *\n   462→ * @param {string} data - Encoded string\n   463→ * @returns {any|null} Decoded data or null on error\n   464→ */\n   465→function decryptFromStorage(data) {\n   466→    try {\n   467→        if (!data || typeof data !== 'string') {\n   468→            return null;\n   469→        }\n   470→        const decoded = atob(data);\n   471→        const jsonStr = decodeURIComponent(decoded);\n   472→        return JSON.parse(jsonStr);\n   473→    } catch (e) {\n   474→        // This is expected for unencrypted legacy data - don't log as warning\n   475→        return null;\n   476→    }\n   477→}\n   478→\n   479→/**\n   480→ * Check if a value appears to be encrypted (base64 encoded JSON)\n   481→ *\n   482→ * @param {any} value - Value to check\n   483→ * @returns {boolean} True if value appears to be encrypted\n   484→ */\n   485→function isEncryptedValue(value) {\n   486→    if (!value || typeof value !== 'string') {\n   487→        return false;\n   488→    }\n   489→    // Unencrypted values typically start with known patterns\n   490→    // (e.g., \"cus_\" for Stripe customer IDs, \"SPLICE-\" for license keys)\n   491→    if (value.startsWith('cus_') || value.startsWith('SPLICE-')) {\n   492→        return false;\n   493→    }\n   494→    // Check if it's a valid base64 string that decodes to valid JSON\n   495→    try {\n   496→        const decoded = atob(value);\n   497→        const jsonStr = decodeURIComponent(decoded);\n   498→        JSON.parse(jsonStr);\n   499→        return true;\n   500→    } catch {\n   501→        return false;\n   502→    }\n   503→}\n   504→\n   505→/**\n   506→ * Encrypt sensitive fields in settings object\n   507→ *\n   508→ * @param {Object} settings - Settings object with plaintext sensitive fields\n   509→ * @returns {Object} Settings with encrypted sensitive fields\n   510→ */\n   511→function encryptSensitiveFields(settings) {\n   512→    const encrypted = { ...settings };\n   513→\n   514→    for (const field of SENSITIVE_FIELDS) {\n   515→        if (encrypted[field] !== null && encrypted[field] !== undefined) {\n   516→            // Only encrypt if not already encrypted\n   517→            if (!isEncryptedValue(encrypted[field])) {\n   518→                encrypted[field] = encryptForStorage(encrypted[field]);\n   519→                debugLog(`[Config] Encrypted field: ${field}`);\n   520→            }\n   521→        }\n   522→    }\n   523→\n   524→    return encrypted;\n   525→}\n   526→\n   527→/**\n   528→ * Decrypt sensitive fields in settings object\n   529→ *\n   530→ * @param {Object} settings - Settings object with encrypted sensitive fields\n   531→ * @returns {Object} Settings with decrypted sensitive fields\n   532→ */\n   533→function decryptSensitiveFields(settings) {\n   534→    const decrypted = { ...settings };\n   535→\n   536→    for (const field of SENSITIVE_FIELDS) {\n   537→        if (decrypted[field] !== null && decrypted[field] !== undefined) {\n   538→            // Check if it looks encrypted before attempting to decrypt\n   539→            if (isEncryptedValue(decrypted[field])) {\n   540→                const decryptedValue = decryptFromStorage(decrypted[field]);\n   541→                if (decryptedValue !== null) {\n   542→                    decrypted[field] = decryptedValue;\n   543→                    debugLog(`[Config] Decrypted field: ${field}`);\n   544→                }\n   545→            }\n   546→            // If not encrypted (legacy data), keep the original value\n   547→        }\n   548→    }\n   549→\n   550→    return decrypted;\n   551→}\n   552→\n   553→/**\n   554→ * Internal save function to avoid recursion during migration\n   555→ * @private\n   556→ */\n   557→function _saveSettingsInternal(settings) {\n   558→    try {\n   559→        // Encrypt sensitive fields before storing\n   560→        const toStore = encryptSensitiveFields(settings);\n   561→\n   562→        // Add version marker for future migrations\n   563→        toStore._storageVersion = SETTINGS_STORAGE_VERSION;\n   564→\n   565→        localStorage.setItem('spliceSettings', JSON.stringify(toStore));\n   566→        return true;\n   567→    } catch (e) {\n   568→        console.warn('[Config] Error saving settings:', e);\n   569→        return false;\n   570→    }\n   571→}\n   572→\n   573→/**\n   574→ * Get settings from localStorage\n   575→ * Handles migration from unencrypted to encrypted storage format\n   576→ */\n   577→function getSettings() {\n   578→    try {\n   579→        const stored = localStorage.getItem('spliceSettings');\n   580→        if (stored) {\n   581→            const parsed = JSON.parse(stored);\n   582→\n   583→            // Decrypt sensitive fields (handles both encrypted and legacy unencrypted data)\n   584→            const decrypted = decryptSensitiveFields(parsed);\n   585→\n   586→            // Check if migration is needed (no version marker = legacy data)\n   587→            if (!parsed._storageVersion) {\n   588→                // Migrate legacy data: save with encryption and version marker\n   589→                debugLog('[Config] Migrating legacy settings to encrypted format');\n   590→                const migratedSettings = { ...DEFAULT_SETTINGS, ...decrypted };\n   591→                // Use internal save to avoid infinite recursion\n   592→                _saveSettingsInternal(migratedSettings);\n   593→            }\n   594→\n   595→            // Return merged settings without internal fields\n   596→            const result = { ...DEFAULT_SETTINGS, ...decrypted };\n   597→            delete result._storageVersion;\n   598→            return result;\n   599→        }\n   600→    } catch (e) {\n   601→        console.warn('[Config] Error loading settings:', e);\n   602→    }\n   603→    return { ...DEFAULT_SETTINGS };\n   604→}\n   605→\n   606→/**\n   607→ * Save settings to localStorage\n   608→ * Encrypts sensitive fields before storing\n   609→ */\n   610→function saveSettings(settings) {\n   611→    try {\n   612→        // Get current settings (decrypted) and merge with new settings\n   613→        const current = getSettings();\n   614→        const merged = { ...current, ...settings };\n   615→\n   616→        return _saveSettingsInternal(merged);\n   617→    } catch (e) {\n   618→        console.warn('[Config] Error saving settings:', e);\n   619→        return false;\n   620→    }\n   621→}\n   622→\n   623→/**\n   624→ * Clear specific setting\n   625→ */\n   626→function clearSetting(key) {\n   627→    const settings = getSettings();\n   628→    delete settings[key];\n   629→    _saveSettingsInternal(settings);\n   630→}\n   631→\n   632→// ============================================================================\n   633→// OFFLINE DETECTION\n   634→// ============================================================================\n   635→\n   636→let isOnlineState = true;\n   637→let offlineCheckInterval = null;\n   638→\n   639→/**\n   640→ * Check if online\n   641→ */\n   642→function isOnline() {\n   643→    return isOnlineState && navigator.onLine;\n   644→}\n   645→\n   646→/**\n   647→ * Initialize offline detection\n   648→ */\n   649→function initOfflineDetection() {\n   650→    // Browser events\n   651→    window.addEventListener('online', () => {\n   652→        isOnlineState = true;\n   653→        updateOfflineUI(true);\n   654→    });\n   655→\n   656→    window.addEventListener('offline', () => {\n   657→        isOnlineState = false;\n   658→        updateOfflineUI(false);\n   659→    });\n   660→\n   661→    // Periodic check\n   662→    offlineCheckInterval = setInterval(async () => {\n   663→        try {\n   664→            const response = await fetchWithTimeout(\n   665→                `${getBackendUrl()}/health`,\n   666→                { method: 'GET' },\n   667→                5000\n   668→            );\n   669→            isOnlineState = response.ok;\n   670→        } catch {\n   671→            isOnlineState = false;\n   672→        }\n   673→        updateOfflineUI(isOnlineState);\n   674→    }, 30000);\n   675→}\n   676→\n   677→/**\n   678→ * Update UI based on online state\n   679→ */\n   680→function updateOfflineUI(online) {\n   681→    const goBtn = document.getElementById('goBtn');\n   682→    const status = document.getElementById('status');\n   683→\n   684→    if (goBtn) {\n   685→        goBtn.disabled = !online;\n   686→    }\n   687→\n   688→    if (status) {\n   689→        if (!online) {\n   690→            status.textContent = 'Offline - Check your connection';\n   691→            status.style.color = '#dc3545';\n   692→        } else {\n   693→            // Reset status when back online\n   694→            status.textContent = 'Ready';\n   695→            status.style.color = '#888';\n   696→        }\n   697→    }\n   698→}\n   699→\n   700→// ============================================================================\n   701→// UTILITY FUNCTIONS\n   702→// ============================================================================\n   703→\n   704→/**\n   705→ * SECURITY: Escape HTML to prevent XSS attacks\n   706→ * Use this when inserting untrusted content into innerHTML\n   707→ * @param {string} str - String to escape\n   708→ * @returns {string} Escaped string safe for innerHTML\n   709→ */\n   710→function escapeHtml(str) {\n   711→    if (str === null || str === undefined) return '';\n   712→    if (typeof str !== 'string') str = String(str);\n   713→\n   714→    const escapeMap = {\n   715→        '&': '&amp;',\n   716→        '<': '&lt;',\n   717→        '>': '&gt;',\n   718→        '\"': '&quot;',\n   719→        \"'\": '&#x27;',\n   720→        '/': '&#x2F;',\n   721→        '`': '&#x60;'\n   722→    };\n   723→\n   724→    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n   725→}\n   726→\n   727→/**\n   728→ * SECURITY: Create safe HTML from template with escaped values\n   729→ * @param {TemplateStringsArray} strings - Template strings\n   730→ * @param {...any} values - Values to escape\n   731→ * @returns {string} HTML with escaped values\n   732→ */\n   733→function safeHtml(strings, ...values) {\n   734→    return strings.reduce((result, str, i) => {\n   735→        const value = values[i - 1];\n   736→        const escaped = escapeHtml(value);\n   737→        return result + escaped + str;\n   738→    });\n   739→}\n   740→\n   741→/**\n   742→ * Format time in MM:SS or HH:MM:SS\n   743→ */\n   744→function formatTime(seconds) {\n   745→    if (isNaN(seconds) || seconds < 0) return '0:00';\n   746→\n   747→    const hours = Math.floor(seconds / 3600);\n   748→    const minutes = Math.floor((seconds % 3600) / 60);\n   749→    const secs = Math.floor(seconds % 60);\n   750→\n   751→    if (hours > 0) {\n   752→        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n   753→    }\n   754→    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n   755→}\n   756→\n   757→/**\n   758→ * Set status message\n   759→ */\n   760→function setStatus(message, isError = false) {\n   761→    const status = document.getElementById('status');\n   762→    if (status) {\n   763→        status.textContent = message;\n   764→        status.style.color = isError ? '#dc3545' : '#888';\n   765→    }\n   766→}\n   767→\n   768→/**\n   769→ * Debounce function calls\n   770→ */\n   771→function debounce(func, wait) {\n   772→    let timeout;\n   773→    return function executedFunction(...args) {\n   774→        const later = () => {\n   775→            clearTimeout(timeout);\n   776→            func(...args);\n   777→        };\n   778→        clearTimeout(timeout);\n   779→        timeout = setTimeout(later, wait);\n   780→    };\n   781→}\n   782→\n   783→// ============================================================================\n   784→// PRESET PROFILES\n   785→// ============================================================================\n   786→\n   787→/**\n   788→ * Detection presets for different content types.\n   789→ * Each preset defines optimal settings for a specific use case.\n   790→ */\n   791→const PRESETS = {\n   792→    // Custom - user-defined settings (default)\n   793→    custom: {\n   794→        name: 'Custom',\n   795→        description: 'Your custom settings',\n   796→        icon: 'settings',\n   797→        settings: null // Uses current user settings\n   798→    },\n   799→\n   800→    // Podcast - longer pauses are natural, be conservative\n   801→    podcast: {\n   802→        name: 'Podcast',\n   803→        description: 'Longer natural pauses, J-Cuts enabled',\n   804→        icon: 'mic',\n   805→        settings: {\n   806→            sensitivity: 35,\n   807→            threshold: -35,\n   808→            minSilenceLength: 0.8,\n   809→            paddingStart: 0.15,\n   810→            paddingEnd: 0.15,\n   811→            enableTakesDetection: true,\n   812→            enableJCut: true,\n   813→            jCutLeadIn: 0.3,\n   814→            jCutLeadOut: 0.2\n   815→        }\n   816→    },\n   817→\n   818→    // Interview - balanced, respects speaker pauses\n   819→    interview: {\n   820→        name: 'Interview',\n   821→        description: 'Balanced cuts, J-Cuts for smooth transitions',\n   822→        icon: 'people',\n   823→        settings: {\n   824→            sensitivity: 50,\n   825→            threshold: -32,\n   826→            minSilenceLength: 0.5,\n   827→            paddingStart: 0.12,\n   828→            paddingEnd: 0.08,\n   829→            enableTakesDetection: true,\n   830→            enableJCut: true,\n   831→            jCutLeadIn: 0.25,\n   832→            jCutLeadOut: 0.15\n   833→        }\n   834→    },\n   835→\n   836→    // Reaction video - fast pacing, quick cuts\n   837→    reaction: {\n   838→        name: 'Reaction',\n   839→        description: 'Fast-paced, tight cuts for energy',\n   840→        icon: 'bolt',\n   841→        settings: {\n   842→            sensitivity: 70,\n   843→            threshold: -28,\n   844→            minSilenceLength: 0.3,\n   845→            paddingStart: 0.05,\n   846→            paddingEnd: 0.03,\n   847→            enableTakesDetection: false,\n   848→            enableJCut: false,\n   849→            jCutLeadIn: 0,\n   850→            jCutLeadOut: 0\n   851→        }\n   852→    },\n   853→\n   854→    // Tutorial/Educational - preserve thinking pauses\n   855→    tutorial: {\n   856→        name: 'Tutorial',\n   857→        description: 'Preserves teaching pace, J-Cuts enabled',\n   858→        icon: 'school',\n   859→        settings: {\n   860→            sensitivity: 30,\n   861→            threshold: -38,\n   862→            minSilenceLength: 1.0,\n   863→            paddingStart: 0.2,\n   864→            paddingEnd: 0.15,\n   865→            enableTakesDetection: true,\n   866→            enableJCut: true,\n   867→            jCutLeadIn: 0.35,\n   868→            jCutLeadOut: 0.25\n   869→        }\n   870→    },\n   871→\n   872→    // Vlog/YouTube - punchy edits, engagement-focused\n   873→    vlog: {\n   874→        name: 'Vlog',\n   875→        description: 'Punchy edits for YouTube engagement',\n   876→        icon: 'videocam',\n   877→        settings: {\n   878→            sensitivity: 65,\n   879→            threshold: -30,\n   880→            minSilenceLength: 0.35,\n   881→            paddingStart: 0.08,\n   882→            paddingEnd: 0.05,\n   883→            enableTakesDetection: true,\n   884→            enableJCut: false,\n   885→            jCutLeadIn: 0,\n   886→            jCutLeadOut: 0\n   887→        }\n   888→    }\n   889→};\n   890→\n   891→/**\n   892→ * List of built-in preset IDs\n   893→ */\n   894→const BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n   895→\n   896→/**\n   897→ * Get all available presets\n   898→ * @returns {Object} All preset definitions\n   899→ */\n   900→function getPresets() {\n   901→    return { ...PRESETS };\n   902→}\n   903→\n   904→/**\n   905→ * Get a specific preset by name\n   906→ * @param {string} presetName - Name of the preset\n   907→ * @returns {Object|null} Preset definition or null if not found\n   908→ */\n   909→function getPreset(presetName) {\n   910→    return PRESETS[presetName] || null;\n   911→}\n   912→\n   913→/**\n   914→ * Check if a preset is a built-in preset\n   915→ * @param {string} id - Preset ID to check\n   916→ * @returns {boolean} True if built-in, false if custom\n   917→ */\n   918→function isBuiltInPreset(id) {\n   919→    return BUILT_IN_PRESET_IDS.includes(id);\n   920→}\n   921→\n   922→/**\n   923→ * Apply a preset to current settings\n   924→ * @param {string} presetName - Name of the preset to apply\n   925→ * @returns {Object} The applied settings\n   926→ */\n   927→function applyPreset(presetName) {\n   928→    const preset = PRESETS[presetName];\n   929→\n   930→    if (!preset) {\n   931→        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n   932→        return getSettings();\n   933→    }\n   934→\n   935→    // Custom preset uses current settings\n   936→    if (presetName === 'custom' || !preset.settings) {\n   937→        saveSettings({ activePreset: 'custom' });\n   938→        return getSettings();\n   939→    }\n   940→\n   941→    // Apply preset settings\n   942→    const newSettings = {\n   943→        ...preset.settings,\n   944→        activePreset: presetName\n   945→    };\n   946→\n   947→    saveSettings(newSettings);\n   948→    debugLog(`Applied preset: ${preset.name}`);\n   949→\n   950→    return getSettings();\n   951→}\n   952→\n   953→/**\n   954→ * Get the currently active preset\n   955→ * @returns {string} Active preset name\n   956→ */\n   957→function getActivePreset() {\n   958→    const settings = getSettings();\n   959→    return settings.activePreset || 'custom';\n   960→}\n   961→\n   962→/**\n   963→ * Initialize preset selector\n   964→ */\n   965→function initPresetSelector() {\n   966→    const presetSelector = document.getElementById('presetSelector');\n   967→    const sensitivitySlider = document.getElementById('sensitivitySlider');\n   968→\n   969→    if (!presetSelector) return;\n   970→\n   971→    // Set initial value from settings\n   972→    const settings = getSettings();\n   973→    presetSelector.value = settings.activePreset || 'podcast';\n   974→\n   975→    // Handle preset change\n   976→    presetSelector.addEventListener('change', () => {\n   977→        const presetId = presetSelector.value;\n   978→        const appliedSettings = applyPreset(presetId);\n   979→\n   980→        // Update sensitivity slider to match preset\n   981→        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n   982→            sensitivitySlider.value = appliedSettings.sensitivity;\n   983→            // Update display value\n   984→            const sensitivityValue = document.getElementById('sensitivityValue');\n   985→            if (sensitivityValue) {\n   986→                sensitivityValue.textContent = appliedSettings.sensitivity;\n   987→            }\n   988→        }\n   989→\n   990→        // Update takes detection checkbox\n   991→        const enableTakesDetection = document.getElementById('enableTakesDetection');\n   992→        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n   993→            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n   994→        }\n   995→\n   996→        // Update J-Cut checkbox\n   997→        const enableJCut = document.getElementById('enableJCut');\n   998→        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n   999→            enableJCut.checked = appliedSettings.enableJCut;\n  1000→            // Toggle J-Cut settings visibility\n  1001→            const jcutSettings = document.getElementById('jcutSettings');\n  1002→            if (jcutSettings) {\n  1003→                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n  1004→            }\n  1005→        }\n  1006→\n  1007→        const preset = getPreset(presetId);\n  1008→        if (preset) {\n  1009→            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n  1010→        }\n  1011→    });\n  1012→\n  1013→    // Switch to custom when user manually changes sensitivity\n  1014→    if (sensitivitySlider) {\n  1015→        sensitivitySlider.addEventListener('change', () => {\n  1016→            if (presetSelector.value !== 'custom') {\n  1017→                presetSelector.value = 'custom';\n  1018→                saveSettings({ activePreset: 'custom' });\n  1019→            }\n  1020→        });\n  1021→    }\n  1022→}\n  1023→\n  1024→// ============================================================================\n  1025→// LOGIN MODAL\n  1026→// ============================================================================\n  1027→\n  1028→/**\n  1029→ * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n  1030→ * Character set excludes confusing chars: 0/O, 1/I/L\n  1031→ */\n  1032→function isValidLicenseKeyFormat(key) {\n  1033→    if (!key || typeof key !== 'string') return false;\n  1034→    const normalized = key.toUpperCase().trim();\n  1035→    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n  1036→    return pattern.test(normalized);\n  1037→}\n  1038→\n  1039→/**\n  1040→ * Initialize login modal handlers\n  1041→ */\n  1042→function initLoginModal() {\n  1043→    const loginModal = document.getElementById('loginModal');\n  1044→    const closeLoginBtn = document.getElementById('closeLoginBtn');\n  1045→    const saveLoginBtn = document.getElementById('saveLoginBtn');\n  1046→    const licenseKeyInput = document.getElementById('licenseKeyInput');\n  1047→    const creditBadge = document.getElementById('creditBadge');\n  1048→\n  1049→    // Handle credit badge click - retry on error, or show login modal\n  1050→    if (creditBadge) {\n  1051→        creditBadge.addEventListener('click', async () => {\n  1052→            if (creditBadge.classList.contains('error')) {\n  1053→                creditBadge.textContent = '...';\n  1054→                if (typeof refreshCredits === 'function') {\n  1055→                    await refreshCredits();\n  1056→                }\n  1057→                return;\n  1058→            }\n  1059→            showLoginModal();\n  1060→        });\n  1061→    }\n  1062→\n  1063→    // Close login modal\n  1064→    if (closeLoginBtn && loginModal) {\n  1065→        closeLoginBtn.addEventListener('click', () => {\n  1066→            loginModal.classList.add('hidden');\n  1067→        });\n  1068→    }\n  1069→\n  1070→    // Close on backdrop click\n  1071→    if (loginModal) {\n  1072→        loginModal.addEventListener('click', (e) => {\n  1073→            if (e.target === loginModal) {\n  1074→                loginModal.classList.add('hidden');\n  1075→            }\n  1076→        });\n  1077→    }\n  1078→\n  1079→    // Activate license key\n  1080→    if (saveLoginBtn) {\n  1081→        saveLoginBtn.addEventListener('click', async () => {\n  1082→            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n  1083→\n  1084→            if (!licenseKey) {\n  1085→                showLoginError('Please enter your license key');\n  1086→                return;\n  1087→            }\n  1088→\n  1089→            if (!isValidLicenseKeyFormat(licenseKey)) {\n  1090→                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n  1091→                return;\n  1092→            }\n  1093→\n  1094→            saveLoginBtn.disabled = true;\n  1095→            saveLoginBtn.textContent = 'Activating...';\n  1096→\n  1097→            try {\n  1098→                // Use /auth/login endpoint which returns JWT tokens\n  1099→                const response = await fetchWithTimeout(`${getBackendUrl()}/auth/login`, {\n  1100→                    method: 'POST',\n  1101→                    headers: { 'Content-Type': 'application/json' },\n  1102→                    body: JSON.stringify({ licenseKey: licenseKey })\n  1103→                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n  1104→\n  1105→                const result = await response.json();\n  1106→\n  1107→                if (!result.success) {\n  1108→                    showLoginError(result.error || 'Activation failed');\n  1109→                    return;\n  1110→                }\n  1111→\n  1112→                // Store JWT tokens and customer info\n  1113→                const expiresInMs = (result.expiresIn || 86400) * 1000; // Default 24h\n  1114→                saveSettings({\n  1115→                    customerId: result.customerId,\n  1116→                    accessToken: result.token,\n  1117→                    refreshToken: result.refreshToken,\n  1118→                    tokenExpiry: Date.now() + expiresInMs,\n  1119→                    licenseKey: licenseKey // Keep for re-authentication\n  1120→                });\n  1121→\n  1122→                loginModal?.classList.add('hidden');\n  1123→\n  1124→                if (typeof refreshCredits === 'function') {\n  1125→                    await refreshCredits();\n  1126→                }\n  1127→\n  1128→                const tierName = result.tier ? result.tier.charAt(0).toUpperCase() + result.tier.slice(1) : 'Unknown';\n  1129→                setStatus(`License activated! ${tierName} tier`);\n  1130→            } catch (err) {\n  1131→                console.error('[SPLICE] License activation error:', err);\n  1132→\n  1133→                // DIAGNOSTIC LOGGING: Capture exact error details (debug mode only)\n  1134→                debugLog('=== CEP LICENSE ACTIVATION ERROR DIAGNOSTICS ===');\n  1135→                debugLog('Error name:', err?.name);\n  1136→                debugLog('Error message:', err?.message);\n  1137→                debugLog('Error stack:', err?.stack);\n  1138→                debugLog('Backend URL:', getBackendUrl());\n  1139→                debugLog('Fetch timeout:', SPLICE_CONFIG.FETCH_TIMEOUT);\n  1140→                debugLog('Is CEP environment:', typeof CSInterface !== 'undefined');\n  1141→                debugLog('User agent:', navigator?.userAgent);\n  1142→                debugLog('Error constructor:', err?.constructor?.name);\n  1143→                debugLog('Is TypeError:', err?.name === 'TypeError');\n  1144→                debugLog('Message contains \"Failed to fetch\":', err?.message?.includes('Failed to fetch'));\n  1145→                debugLog('Message contains \"fetch\":', err?.message?.toLowerCase()?.includes('fetch'));\n  1146→                debugLog('Message contains \"network\":', err?.message?.toLowerCase()?.includes('network'));\n  1147→                debugLog('Message contains \"CORS\":', err?.message?.toLowerCase()?.includes('cors'));\n  1148→                debugLog('Message contains \"SSL\":', err?.message?.toLowerCase()?.includes('ssl'));\n  1149→                debugLog('Message contains \"certificate\":', err?.message?.toLowerCase()?.includes('certificate'));\n  1150→                debugLog('Full error object:', JSON.stringify(err, Object.getOwnPropertyNames(err)));\n  1151→                debugLog('================================================');\n  1152→\n  1153→                // Provide detailed error message based on error type\n  1154→                let errorMessage = 'Connection error. ';\n  1155→\n  1156→                if (err.message === 'Request timed out') {\n  1157→                    errorMessage += 'Server is not responding. Check if backend is running.';\n  1158→                } else if (err.message?.includes('Failed to fetch') || err.name === 'TypeError') {\n  1159→                    errorMessage += `Cannot reach ${getBackendUrl()}. Check network/firewall.`;\n  1160→                } else if (err.message?.includes('CORS')) {\n  1161→                    errorMessage += 'CORS error. Contact support.';\n  1162→                } else if (err.message?.includes('SSL') || err.message?.includes('certificate')) {\n  1163→                    errorMessage += 'SSL certificate error. Try updating your system certificates.';\n  1164→                } else if (err.message) {\n  1165→                    errorMessage += err.message;\n  1166→                } else {\n  1167→                    errorMessage += 'Unknown error. Check console for details.';\n  1168→                }\n  1169→\n  1170→                debugLog('Final error message shown to user:', errorMessage);\n  1171→                showLoginError(errorMessage);\n  1172→            } finally {\n  1173→                saveLoginBtn.disabled = false;\n  1174→                saveLoginBtn.textContent = 'Activate';\n  1175→            }\n  1176→        });\n  1177→    }\n  1178→\n  1179→    // Email lookup\n  1180→    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n  1181→    const lookupEmailInput = document.getElementById('lookupEmailInput');\n  1182→\n  1183→    if (lookupLicenseBtn) {\n  1184→        lookupLicenseBtn.addEventListener('click', async () => {\n  1185→            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n  1186→\n  1187→            if (!email) {\n  1188→                showLoginError('Please enter your email address');\n  1189→                return;\n  1190→            }\n  1191→\n  1192→            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  1193→            if (!emailRegex.test(email)) {\n  1194→                showLoginError('Please enter a valid email address');\n  1195→                return;\n  1196→            }\n  1197→\n  1198→            lookupLicenseBtn.disabled = true;\n  1199→            lookupLicenseBtn.textContent = 'Looking up...';\n  1200→\n  1201→            try {\n  1202→                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n  1203→                    method: 'POST',\n  1204→                    headers: { 'Content-Type': 'application/json' },\n  1205→                    body: JSON.stringify({ email })\n  1206→                }, 30000);\n  1207→\n  1208→                const result = await response.json();\n  1209→\n  1210→                // Note: For security, the backend does NOT return the license key directly.\n  1211→                // It sends the key via email to prevent enumeration attacks.\n  1212→                if (result.success) {\n  1213→                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n  1214→                } else {\n  1215→                    showLoginError(result.error || 'Lookup failed. Please try again.');\n  1216→                }\n  1217→            } catch (err) {\n  1218→                console.error('[SPLICE] License lookup error:', err);\n  1219→                showLoginError('Failed to look up license. Please try again.');\n  1220→            } finally {\n  1221→                lookupLicenseBtn.disabled = false;\n  1222→                lookupLicenseBtn.textContent = 'Lookup';\n  1223→            }\n  1224→        });\n  1225→    }\n  1226→\n  1227→    // Handle external URL buttons\n  1228→    // CEP panels cannot use target=\"_blank\" for security reasons.\n  1229→    // Must use CSInterface.openURLInDefaultBrowser() instead.\n  1230→    initExternalLinkButtons();\n  1231→}\n  1232→\n  1233→/**\n  1234→ * Initialize all external link buttons that need CSInterface.openURLInDefaultBrowser()\n  1235→ * CEP panels cannot use target=\"_blank\" due to security restrictions\n  1236→ */\n  1237→function initExternalLinkButtons() {\n  1238→    // Check if CSInterface is available\n  1239→    if (typeof CSInterface === 'undefined') {\n  1240→        console.warn('[SPLICE] CSInterface not available - external links disabled');\n  1241→        return;\n  1242→    }\n  1243→\n  1244→    let cs;\n  1245→    try {\n  1246→        cs = new CSInterface();\n  1247→    } catch (e) {\n  1248→        console.warn('[SPLICE] Failed to create CSInterface:', e.message);\n  1249→        return;\n  1250→    }\n  1251→\n  1252→    // Buy a License button\n  1253→    const buyLicenseBtn = document.querySelector('.btn-buy-license');\n  1254→\n  1255→    if (buyLicenseBtn) {\n  1256→        buyLicenseBtn.addEventListener('click', (e) => {\n  1257→            e.preventDefault();\n  1258→            e.stopPropagation();\n  1259→\n  1260→            // Visual feedback\n  1261→            buyLicenseBtn.textContent = 'Opening...';\n  1262→            buyLicenseBtn.style.backgroundColor = '#28a745';\n  1263→\n  1264→            try {\n  1265→                cs.openURLInDefaultBrowser('https://spliceclips.com/pricing');\n  1266→\n  1267→                // Reset button after a delay\n  1268→                setTimeout(() => {\n  1269→                    buyLicenseBtn.textContent = 'Buy License';\n  1270→                    buyLicenseBtn.style.backgroundColor = '';\n  1271→                }, 2000);\n  1272→            } catch (err) {\n  1273→                console.error('[SPLICE] Failed to open URL:', err.message);\n  1274→                buyLicenseBtn.textContent = 'Error';\n  1275→                buyLicenseBtn.style.backgroundColor = '#dc3545';\n  1276→            }\n  1277→        });\n  1278→    }\n  1279→    \n  1280→    // View Plans button (in upgrade modal)\n  1281→    const viewPlansBtn = document.querySelector('.btn-view-plans');\n  1282→    if (viewPlansBtn) {\n  1283→        viewPlansBtn.addEventListener('click', (e) => {\n  1284→            e.preventDefault();\n  1285→            e.stopPropagation();\n  1286→            const url = viewPlansBtn.dataset.url || 'https://spliceclips.com/pricing';\n  1287→            cs.openURLInDefaultBrowser(url);\n  1288→        });\n  1289→    }\n  1290→    \n  1291→    // Referral link button\n  1292→    const referralBtn = document.querySelector('.btn-referral');\n  1293→    if (referralBtn) {\n  1294→        referralBtn.addEventListener('click', (e) => {\n  1295→            e.preventDefault();\n  1296→            e.stopPropagation();\n  1297→            const url = referralBtn.dataset.url || 'https://splice.video/referrals';\n  1298→            cs.openURLInDefaultBrowser(url);\n  1299→        });\n  1300→    }\n  1301→}\n  1302→\n  1303→/**\n  1304→ * Show login modal\n  1305→ */\n  1306→function showLoginModal() {\n  1307→    const loginModal = document.getElementById('loginModal');\n  1308→    const loginError = document.getElementById('loginError');\n  1309→    if (loginError) loginError.style.display = 'none';\n  1310→    if (loginModal) loginModal.classList.remove('hidden');\n  1311→}\n  1312→\n  1313→/**\n  1314→ * Show login error message\n  1315→ */\n  1316→function showLoginError(message) {\n  1317→    const loginError = document.getElementById('loginError');\n  1318→    if (loginError) {\n  1319→        loginError.textContent = message;\n  1320→        loginError.style.display = 'block';\n  1321→    }\n  1322→}\n  1323→\n  1324→/**\n  1325→ * Check if user is logged in\n  1326→ */\n  1327→function isLoggedIn() {\n  1328→    const settings = getSettings();\n  1329→    return !!settings.customerId;\n  1330→}\n  1331→\n  1332→/**\n  1333→ * Logout - clear all auth data\n  1334→ */\n  1335→function logout() {\n  1336→    // Clear all auth-related settings\n  1337→    saveSettings({\n  1338→        customerId: null,\n  1339→        accessToken: null,\n  1340→        refreshToken: null,\n  1341→        tokenExpiry: null,\n  1342→        licenseKey: null\n  1343→    });\n  1344→\n  1345→    if (typeof clearCreditsCache === 'function') {\n  1346→        clearCreditsCache();\n  1347→    }\n  1348→    if (typeof updateCreditDisplay === 'function') {\n  1349→        updateCreditDisplay(null);\n  1350→    }\n  1351→    setStatus('Logged out');\n  1352→}\n  1353→\n  1354→// Initialize JSX bridge when loaded\n  1355→document.addEventListener('DOMContentLoaded', () => {\n  1356→    jsx.init();\n  1357→});\n  1358→\n  1359→// Export for modules\n  1360→window.SPLICE_CONFIG = SPLICE_CONFIG;\n  1361→window.SPLICE_DEBUG = SPLICE_DEBUG;\n  1362→window.debugLog = debugLog;\n  1363→window.debugFetch = debugFetch;\n  1364→window.getBackendUrl = getBackendUrl;\n  1365→window.fetchWithTimeout = fetchWithTimeout;\n  1366→window.parseErrorResponse = parseErrorResponse;\n  1367→window.getAuthHeaders = getAuthHeaders;\n  1368→window.getSettings = getSettings;\n  1369→window.saveSettings = saveSettings;\n  1370→window.clearSetting = clearSetting;\n  1371→window.isOnline = isOnline;\n  1372→window.initOfflineDetection = initOfflineDetection;\n  1373→window.formatTime = formatTime;\n  1374→window.setStatus = setStatus;\n  1375→window.debounce = debounce;\n  1376→window.jsx = jsx;\n  1377→window.PRESETS = PRESETS;\n  1378→window.getPresets = getPresets;\n  1379→window.getPreset = getPreset;\n  1380→window.applyPreset = applyPreset;\n  1381→window.getActivePreset = getActivePreset;\n  1382→window.isBuiltInPreset = isBuiltInPreset;\n  1383→window.initPresetSelector = initPresetSelector;\n  1384→window.initLoginModal = initLoginModal;\n  1385→window.showLoginModal = showLoginModal;\n  1386→window.isLoggedIn = isLoggedIn;\n  1387→window.logout = logout;\n  1388→window.escapeHtml = escapeHtml;\n  1389→window.safeHtml = safeHtml;\n  1390→// JWT Auth functions\n  1391→window.isTokenExpired = isTokenExpired;\n  1392→window.refreshAccessToken = refreshAccessToken;\n  1393→window.clearAuthTokens = clearAuthTokens;\n  1394→window.ensureValidToken = ensureValidToken;\n  1395→\n\n</system-reminder>\n"}]},"uuid":"1cc54cab-3f78-49a5-a744-163e7184062d","timestamp":"2026-01-12T01:12:02.084Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/panel/js/config.js","content":"/**\n * SPLICE CEP Panel Configuration\n * Backend URLs, paths, and utility functions\n */\n\n// ============================================================================\n// DEBUG MODE CONFIGURATION\n// ============================================================================\n\n/**\n * Debug mode flag - enables verbose diagnostic logging\n * Can be enabled via localStorage for troubleshooting:\n *   localStorage.setItem('spliceDebugMode', 'true');\n *\n * Default: false (production mode - minimal logging)\n */\nconst SPLICE_DEBUG = localStorage.getItem('spliceDebugMode') === 'true';\n\n/**\n * Debug logging function - only outputs when debug mode is enabled\n * Use this for diagnostic/development logging that should be silent in production\n * @param {...any} args - Arguments to log (prefixed with [SPLICE DEBUG])\n */\nfunction debugLog(...args) {\n    if (SPLICE_DEBUG) {\n        console.log('[SPLICE DEBUG]', ...args);\n    }\n}\n\n/**\n * Debug fetch logging - verbose fetch request/response logging\n * @param {...any} args - Arguments to log (prefixed with [SPLICE FETCH])\n */\nfunction debugFetch(...args) {\n    if (SPLICE_DEBUG) {\n        console.log('[SPLICE FETCH]', ...args);\n    }\n}\n\n// ============================================================================\n// BACKEND CONFIGURATION\n// ============================================================================\nconst SPLICE_CONFIG = {\n    VERSION: '6.0.3',\n    BACKEND_PROD: 'https://splice-api-production.up.railway.app',\n    BACKEND_DEV: 'https://127.0.0.1:3847',\n    FETCH_TIMEOUT: 120000, // 2 minutes\n    RETRY_ATTEMPTS: 3,\n    RETRY_DELAY: 1000\n};\n\n/**\n * Get the backend URL based on environment\n * FIXED: CEP panels always run from file://, so we default to PROD\n * Use localStorage to override for local development if needed\n */\nfunction getBackendUrl() {\n    // Priority 1: Allow override via localStorage (for local dev testing)\n    const customUrl = localStorage.getItem('spliceBackendUrl');\n    if (customUrl) {\n        debugLog('Using custom backend URL from localStorage:', customUrl);\n        return customUrl;\n    }\n\n    // Priority 2: Default to production backend\n    // (CEP panels always run from file://, so can't reliably detect dev mode)\n    debugLog('Using production backend URL:', SPLICE_CONFIG.BACKEND_PROD);\n    return SPLICE_CONFIG.BACKEND_PROD;\n}\n\n// ============================================================================\n// JSX BRIDGE - Communicate with Premiere Pro\n// ============================================================================\nconst jsx = {\n    cs: null,\n    _initPromise: null,\n    _initialized: false,\n\n    /**\n     * Initialize the CSInterface\n     * Returns a promise that resolves when ready (true/false)\n     * Does NOT reject - gracefully handles missing CEP environment\n     */\n    init: function() {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = new Promise((resolve) => {\n            try {\n                if (typeof CSInterface !== 'undefined') {\n                    this.cs = new CSInterface();\n                    // Verify we're in a real CEP environment by checking for __adobe_cep__\n                    if (window.__adobe_cep__) {\n                        this._initialized = true;\n                        debugLog('[JSX] CSInterface initialized successfully (CEP environment detected)');\n                    } else {\n                        // CSInterface exists but no CEP runtime - browser/dev mode\n                        this._initialized = true;\n                        debugLog('[JSX] CSInterface initialized (development/browser mode)');\n                    }\n                } else {\n                    console.warn('[JSX] CSInterface not available - panel may not function correctly');\n                    this._initialized = false;\n                }\n            } catch (err) {\n                console.error('[JSX] Failed to initialize CSInterface:', err);\n                this._initialized = false;\n            }\n            resolve(this._initialized);\n        });\n\n        return this._initPromise;\n    },\n\n    /**\n     * Ensure JSX is initialized before making calls\n     */\n    ensureInitialized: async function() {\n        if (!this._initialized) {\n            await this.init();\n        }\n        if (!this.cs) {\n            throw new Error('CSInterface not initialized. Make sure you are running in CEP environment.');\n        }\n    },\n\n    /**\n     * Execute ExtendScript in Premiere Pro\n     * @param {string} script - ExtendScript to execute\n     * @returns {Promise<any>} - Parsed result\n     */\n    evalScript: async function(script) {\n        await this.ensureInitialized();\n\n        return new Promise((resolve, reject) => {\n            this.cs.evalScript(script, (result) => {\n                if (result === 'undefined' || result === undefined) {\n                    resolve(null);\n                    return;\n                }\n\n                // Check for EvalScript error or ExtendScript runtime errors\n                if (typeof result === 'string' && (\n                    result.indexOf('EvalScript error') !== -1 ||\n                    result.indexOf('Error:') !== -1 ||\n                    result.indexOf('TypeError:') !== -1 ||\n                    result.indexOf('ReferenceError:') !== -1\n                )) {\n                    reject(new Error(result));\n                    return;\n                }\n\n                // Try to parse JSON\n                try {\n                    const parsed = JSON.parse(result);\n                    if (parsed.error) {\n                        reject(new Error(parsed.error));\n                    } else {\n                        resolve(parsed);\n                    }\n                } catch (e) {\n                    // Return as-is if not JSON\n                    resolve(result);\n                }\n            });\n        });\n    },\n\n    /**\n     * Call a JSX function with arguments\n     * @param {string} funcName - Function name\n     * @param {...any} args - Arguments to pass\n     * @returns {Promise<any>}\n     */\n    call: async function(funcName, ...args) {\n        await this.ensureInitialized();\n\n        const escapedArgs = args.map(arg => {\n            if (arg === null || arg === undefined) return 'null';\n            if (typeof arg === 'string') {\n                // Escape backslashes first, then other special chars\n                return `'${arg\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")\n                    .replace(/\\r/g, '\\\\r')\n                    .replace(/\\n/g, '\\\\n')\n                    .replace(/\\t/g, '\\\\t')}'`;\n            }\n            if (typeof arg === 'object') {\n                return `'${JSON.stringify(arg)\n                    .replace(/\\\\/g, '\\\\\\\\')\n                    .replace(/'/g, \"\\\\'\")}'`;\n            }\n            return String(arg);\n        });\n\n        const script = `${funcName}(${escapedArgs.join(', ')})`;\n        return this.evalScript(script);\n    }\n};\n\n// ============================================================================\n// FETCH UTILITIES\n// ============================================================================\n\n/**\n * Fetch with timeout support\n * @param {string} url - URL to fetch\n * @param {object} options - Fetch options\n * @param {number} timeout - Timeout in ms\n */\nasync function fetchWithTimeout(url, options = {}, timeout = SPLICE_CONFIG.FETCH_TIMEOUT) {\n    // DIAGNOSTIC: Log fetch request details (debug mode only)\n    debugFetch('=== FETCH REQUEST START ===');\n    debugFetch('URL:', url);\n    debugFetch('Method:', options?.method || 'GET');\n    debugFetch('Headers:', options?.headers);\n    debugFetch('Timeout:', timeout);\n    debugFetch('Is CEP environment:', typeof CSInterface !== 'undefined');\n    debugFetch('=================================');\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n        const response = await fetch(url, {\n            ...options,\n            signal: controller.signal\n        });\n        clearTimeout(timeoutId);\n\n        // DIAGNOSTIC: Log successful response (debug mode only)\n        debugFetch('=== FETCH RESPONSE SUCCESS ===');\n        debugFetch('Status:', response.status);\n        debugFetch('OK:', response.ok);\n        debugFetch('=================================');\n\n        return response;\n    } catch (error) {\n        clearTimeout(timeoutId);\n\n        // DIAGNOSTIC: Log raw fetch error (debug mode only)\n        debugFetch('=== FETCH ERROR CAUGHT ===');\n        debugFetch('Error name:', error?.name);\n        debugFetch('Error message:', error?.message);\n        debugFetch('Error type:', typeof error);\n        debugFetch('Error constructor:', error?.constructor?.name);\n        debugFetch('Is AbortError:', error.name === 'AbortError');\n        debugFetch('Is TypeError:', error.name === 'TypeError');\n        debugFetch('Full error object:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\n        debugFetch('=================================');\n\n        if (error.name === 'AbortError') {\n            throw new Error(`Request timeout after ${timeout}ms`);\n        }\n        throw error;\n    }\n}\n\n/**\n * Parse error response from backend\n * @param {Response} response - Fetch response\n */\nasync function parseErrorResponse(response) {\n    try {\n        const data = await response.json();\n        return data.error || data.message || `HTTP ${response.status}`;\n    } catch {\n        return `HTTP ${response.status}: ${response.statusText}`;\n    }\n}\n\n/**\n * Get auth headers for API requests\n * Uses JWT Bearer token if available, with legacy fallback\n */\nfunction getAuthHeaders() {\n    const headers = { 'Content-Type': 'application/json' };\n    const settings = getSettings();\n\n    // Prefer JWT Bearer token (modern auth)\n    if (settings.accessToken) {\n        headers['Authorization'] = `Bearer ${settings.accessToken}`;\n        return headers;\n    }\n\n    // Legacy fallback for backwards compatibility\n    // This will be removed after 2026-04-11\n    if (settings.customerId) {\n        headers['x-stripe-customer-id'] = settings.customerId;\n        console.warn('[SPLICE] Using deprecated x-stripe-customer-id header. Please re-login to upgrade to JWT auth.');\n    }\n\n    return headers;\n}\n\n/**\n * Check if the access token is expired or about to expire\n * @returns {boolean} True if token needs refresh\n */\nfunction isTokenExpired() {\n    const settings = getSettings();\n    if (!settings.tokenExpiry) return true;\n\n    // Refresh if less than 5 minutes remaining\n    const bufferMs = 5 * 60 * 1000;\n    return Date.now() >= (settings.tokenExpiry - bufferMs);\n}\n\n/**\n * Refresh the access token using the refresh token\n * @returns {Promise<boolean>} True if refresh succeeded\n */\nasync function refreshAccessToken() {\n    const settings = getSettings();\n\n    if (!settings.refreshToken) {\n        debugLog('[Auth] No refresh token available');\n        return false;\n    }\n\n    try {\n        debugLog('[Auth] Refreshing access token...');\n\n        const response = await fetchWithTimeout(`${getBackendUrl()}/auth/refresh`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ refreshToken: settings.refreshToken })\n        }, 30000);\n\n        if (!response.ok) {\n            const errorMsg = await parseErrorResponse(response);\n            console.error('[Auth] Token refresh failed:', errorMsg);\n\n            // If refresh token is invalid, clear auth and require re-login\n            if (response.status === 401) {\n                clearAuthTokens();\n            }\n            return false;\n        }\n\n        const data = await response.json();\n\n        // Save new access token\n        const expiresInMs = (data.expiresIn || 86400) * 1000; // Default 24h\n        saveSettings({\n            accessToken: data.token,\n            tokenExpiry: Date.now() + expiresInMs\n        });\n\n        debugLog('[Auth] Access token refreshed successfully');\n        return true;\n    } catch (err) {\n        console.error('[Auth] Token refresh error:', err);\n        return false;\n    }\n}\n\n/**\n * Clear all auth tokens (call on logout or auth failure)\n */\nfunction clearAuthTokens() {\n    saveSettings({\n        accessToken: null,\n        refreshToken: null,\n        tokenExpiry: null\n    });\n    debugLog('[Auth] Auth tokens cleared');\n}\n\n/**\n * Ensure we have a valid access token, refreshing if needed\n * @returns {Promise<boolean>} True if we have a valid token\n */\nasync function ensureValidToken() {\n    const settings = getSettings();\n\n    // No token at all - need to login\n    if (!settings.accessToken) {\n        return false;\n    }\n\n    // Token not expired - good to go\n    if (!isTokenExpired()) {\n        return true;\n    }\n\n    // Try to refresh\n    return await refreshAccessToken();\n}\n\n// ============================================================================\n// SETTINGS MANAGEMENT\n// ============================================================================\n\nconst DEFAULT_SETTINGS = {\n    sensitivity: 50,\n    minSilenceLength: 0.5,\n    sourceIsolated: false,\n    enableTakesDetection: true,\n    enableJCut: false,\n    jcutLeadIn: 0.3,\n    jcutLeadOut: 0.2,\n    enableZoom: false,\n    zoomFrequency: 'medium',\n    zoomPreset: 'medium',\n    zoomPlacement: 'sentence_start',\n    enableChapters: false,\n    maxChapters: 10,\n    minChapterLength: 60,\n    enableProfanity: false,\n    profanityLanguage: 'en',\n    bleepType: 'standard',\n    // Authentication\n    customerId: null,\n    licenseKey: null,\n    accessToken: null,\n    refreshToken: null,\n    tokenExpiry: null,\n    // UI State\n    expandedOptions: false,\n    activePreset: 'podcast',\n    rememberOptions: false\n};\n\n// Current storage version for future migrations\nconst SETTINGS_STORAGE_VERSION = 2;\n\n// Fields that contain sensitive data and should be encrypted\nconst SENSITIVE_FIELDS = ['customerId', 'licenseKey', 'accessToken', 'refreshToken'];\n\n// ============================================================================\n// ENCRYPTION HELPERS FOR SENSITIVE DATA\n// ============================================================================\n\n/**\n * Simple obfuscation for localStorage\n * NOTE: This is NOT cryptographically secure, but provides basic protection\n * against casual inspection of localStorage. For truly sensitive data,\n * consider server-side storage or proper encryption libraries.\n *\n * @param {any} data - Data to encode\n * @returns {string|null} Encoded string or null on error\n */\nfunction encryptForStorage(data) {\n    try {\n        if (data === null || data === undefined) {\n            return null;\n        }\n        // Double encode to add slight obfuscation layer\n        const jsonStr = JSON.stringify(data);\n        const encoded = encodeURIComponent(jsonStr);\n        return btoa(encoded);\n    } catch (e) {\n        debugLog('[Config] Encryption error:', e);\n        return null;\n    }\n}\n\n/**\n * Decode obfuscated data from localStorage\n *\n * @param {string} data - Encoded string\n * @returns {any|null} Decoded data or null on error\n */\nfunction decryptFromStorage(data) {\n    try {\n        if (!data || typeof data !== 'string') {\n            return null;\n        }\n        const decoded = atob(data);\n        const jsonStr = decodeURIComponent(decoded);\n        return JSON.parse(jsonStr);\n    } catch (e) {\n        // This is expected for unencrypted legacy data - don't log as warning\n        return null;\n    }\n}\n\n/**\n * Check if a value appears to be encrypted (base64 encoded JSON)\n *\n * @param {any} value - Value to check\n * @returns {boolean} True if value appears to be encrypted\n */\nfunction isEncryptedValue(value) {\n    if (!value || typeof value !== 'string') {\n        return false;\n    }\n    // Unencrypted values typically start with known patterns\n    // (e.g., \"cus_\" for Stripe customer IDs, \"SPLICE-\" for license keys)\n    if (value.startsWith('cus_') || value.startsWith('SPLICE-')) {\n        return false;\n    }\n    // Check if it's a valid base64 string that decodes to valid JSON\n    try {\n        const decoded = atob(value);\n        const jsonStr = decodeURIComponent(decoded);\n        JSON.parse(jsonStr);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Encrypt sensitive fields in settings object\n *\n * @param {Object} settings - Settings object with plaintext sensitive fields\n * @returns {Object} Settings with encrypted sensitive fields\n */\nfunction encryptSensitiveFields(settings) {\n    const encrypted = { ...settings };\n\n    for (const field of SENSITIVE_FIELDS) {\n        if (encrypted[field] !== null && encrypted[field] !== undefined) {\n            // Only encrypt if not already encrypted\n            if (!isEncryptedValue(encrypted[field])) {\n                encrypted[field] = encryptForStorage(encrypted[field]);\n                debugLog(`[Config] Encrypted field: ${field}`);\n            }\n        }\n    }\n\n    return encrypted;\n}\n\n/**\n * Decrypt sensitive fields in settings object\n *\n * @param {Object} settings - Settings object with encrypted sensitive fields\n * @returns {Object} Settings with decrypted sensitive fields\n */\nfunction decryptSensitiveFields(settings) {\n    const decrypted = { ...settings };\n\n    for (const field of SENSITIVE_FIELDS) {\n        if (decrypted[field] !== null && decrypted[field] !== undefined) {\n            // Check if it looks encrypted before attempting to decrypt\n            if (isEncryptedValue(decrypted[field])) {\n                const decryptedValue = decryptFromStorage(decrypted[field]);\n                if (decryptedValue !== null) {\n                    decrypted[field] = decryptedValue;\n                    debugLog(`[Config] Decrypted field: ${field}`);\n                }\n            }\n            // If not encrypted (legacy data), keep the original value\n        }\n    }\n\n    return decrypted;\n}\n\n/**\n * Internal save function to avoid recursion during migration\n * @private\n */\nfunction _saveSettingsInternal(settings) {\n    try {\n        // Encrypt sensitive fields before storing\n        const toStore = encryptSensitiveFields(settings);\n\n        // Add version marker for future migrations\n        toStore._storageVersion = SETTINGS_STORAGE_VERSION;\n\n        localStorage.setItem('spliceSettings', JSON.stringify(toStore));\n        return true;\n    } catch (e) {\n        console.warn('[Config] Error saving settings:', e);\n        return false;\n    }\n}\n\n/**\n * Get settings from localStorage\n * Handles migration from unencrypted to encrypted storage format\n */\nfunction getSettings() {\n    try {\n        const stored = localStorage.getItem('spliceSettings');\n        if (stored) {\n            const parsed = JSON.parse(stored);\n\n            // Decrypt sensitive fields (handles both encrypted and legacy unencrypted data)\n            const decrypted = decryptSensitiveFields(parsed);\n\n            // Check if migration is needed (no version marker = legacy data)\n            if (!parsed._storageVersion) {\n                // Migrate legacy data: save with encryption and version marker\n                debugLog('[Config] Migrating legacy settings to encrypted format');\n                const migratedSettings = { ...DEFAULT_SETTINGS, ...decrypted };\n                // Use internal save to avoid infinite recursion\n                _saveSettingsInternal(migratedSettings);\n            }\n\n            // Return merged settings without internal fields\n            const result = { ...DEFAULT_SETTINGS, ...decrypted };\n            delete result._storageVersion;\n            return result;\n        }\n    } catch (e) {\n        console.warn('[Config] Error loading settings:', e);\n    }\n    return { ...DEFAULT_SETTINGS };\n}\n\n/**\n * Save settings to localStorage\n * Encrypts sensitive fields before storing\n */\nfunction saveSettings(settings) {\n    try {\n        // Get current settings (decrypted) and merge with new settings\n        const current = getSettings();\n        const merged = { ...current, ...settings };\n\n        return _saveSettingsInternal(merged);\n    } catch (e) {\n        console.warn('[Config] Error saving settings:', e);\n        return false;\n    }\n}\n\n/**\n * Clear specific setting\n */\nfunction clearSetting(key) {\n    const settings = getSettings();\n    delete settings[key];\n    _saveSettingsInternal(settings);\n}\n\n// ============================================================================\n// OFFLINE DETECTION\n// ============================================================================\n\nlet isOnlineState = true;\nlet offlineCheckInterval = null;\n\n/**\n * Check if online\n */\nfunction isOnline() {\n    return isOnlineState && navigator.onLine;\n}\n\n/**\n * Initialize offline detection\n */\nfunction initOfflineDetection() {\n    // Browser events\n    window.addEventListener('online', () => {\n        isOnlineState = true;\n        updateOfflineUI(true);\n    });\n\n    window.addEventListener('offline', () => {\n        isOnlineState = false;\n        updateOfflineUI(false);\n    });\n\n    // Periodic check\n    offlineCheckInterval = setInterval(async () => {\n        try {\n            const response = await fetchWithTimeout(\n                `${getBackendUrl()}/health`,\n                { method: 'GET' },\n                5000\n            );\n            isOnlineState = response.ok;\n        } catch {\n            isOnlineState = false;\n        }\n        updateOfflineUI(isOnlineState);\n    }, 30000);\n}\n\n/**\n * Update UI based on online state\n */\nfunction updateOfflineUI(online) {\n    const goBtn = document.getElementById('goBtn');\n    const status = document.getElementById('status');\n\n    if (goBtn) {\n        goBtn.disabled = !online;\n    }\n\n    if (status) {\n        if (!online) {\n            status.textContent = 'Offline - Check your connection';\n            status.style.color = '#dc3545';\n        } else {\n            // Reset status when back online\n            status.textContent = 'Ready';\n            status.style.color = '#888';\n        }\n    }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * SECURITY: Escape HTML to prevent XSS attacks\n * Use this when inserting untrusted content into innerHTML\n * @param {string} str - String to escape\n * @returns {string} Escaped string safe for innerHTML\n */\nfunction escapeHtml(str) {\n    if (str === null || str === undefined) return '';\n    if (typeof str !== 'string') str = String(str);\n\n    const escapeMap = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;',\n        '/': '&#x2F;',\n        '`': '&#x60;'\n    };\n\n    return str.replace(/[&<>\"'\\/`]/g, char => escapeMap[char]);\n}\n\n/**\n * SECURITY: Create safe HTML from template with escaped values\n * @param {TemplateStringsArray} strings - Template strings\n * @param {...any} values - Values to escape\n * @returns {string} HTML with escaped values\n */\nfunction safeHtml(strings, ...values) {\n    return strings.reduce((result, str, i) => {\n        const value = values[i - 1];\n        const escaped = escapeHtml(value);\n        return result + escaped + str;\n    });\n}\n\n/**\n * Format time in MM:SS or HH:MM:SS\n */\nfunction formatTime(seconds) {\n    if (isNaN(seconds) || seconds < 0) return '0:00';\n\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n\n    if (hours > 0) {\n        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Set status message\n */\nfunction setStatus(message, isError = false) {\n    const status = document.getElementById('status');\n    if (status) {\n        status.textContent = message;\n        status.style.color = isError ? '#dc3545' : '#888';\n    }\n}\n\n/**\n * Debounce function calls\n */\nfunction debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n        const later = () => {\n            clearTimeout(timeout);\n            func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n\n// ============================================================================\n// PRESET PROFILES\n// ============================================================================\n\n/**\n * Detection presets for different content types.\n * Each preset defines optimal settings for a specific use case.\n */\nconst PRESETS = {\n    // Custom - user-defined settings (default)\n    custom: {\n        name: 'Custom',\n        description: 'Your custom settings',\n        icon: 'settings',\n        settings: null // Uses current user settings\n    },\n\n    // Podcast - longer pauses are natural, be conservative\n    podcast: {\n        name: 'Podcast',\n        description: 'Longer natural pauses, J-Cuts enabled',\n        icon: 'mic',\n        settings: {\n            sensitivity: 35,\n            threshold: -35,\n            minSilenceLength: 0.8,\n            paddingStart: 0.15,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.3,\n            jCutLeadOut: 0.2\n        }\n    },\n\n    // Interview - balanced, respects speaker pauses\n    interview: {\n        name: 'Interview',\n        description: 'Balanced cuts, J-Cuts for smooth transitions',\n        icon: 'people',\n        settings: {\n            sensitivity: 50,\n            threshold: -32,\n            minSilenceLength: 0.5,\n            paddingStart: 0.12,\n            paddingEnd: 0.08,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.25,\n            jCutLeadOut: 0.15\n        }\n    },\n\n    // Reaction video - fast pacing, quick cuts\n    reaction: {\n        name: 'Reaction',\n        description: 'Fast-paced, tight cuts for energy',\n        icon: 'bolt',\n        settings: {\n            sensitivity: 70,\n            threshold: -28,\n            minSilenceLength: 0.3,\n            paddingStart: 0.05,\n            paddingEnd: 0.03,\n            enableTakesDetection: false,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    },\n\n    // Tutorial/Educational - preserve thinking pauses\n    tutorial: {\n        name: 'Tutorial',\n        description: 'Preserves teaching pace, J-Cuts enabled',\n        icon: 'school',\n        settings: {\n            sensitivity: 30,\n            threshold: -38,\n            minSilenceLength: 1.0,\n            paddingStart: 0.2,\n            paddingEnd: 0.15,\n            enableTakesDetection: true,\n            enableJCut: true,\n            jCutLeadIn: 0.35,\n            jCutLeadOut: 0.25\n        }\n    },\n\n    // Vlog/YouTube - punchy edits, engagement-focused\n    vlog: {\n        name: 'Vlog',\n        description: 'Punchy edits for YouTube engagement',\n        icon: 'videocam',\n        settings: {\n            sensitivity: 65,\n            threshold: -30,\n            minSilenceLength: 0.35,\n            paddingStart: 0.08,\n            paddingEnd: 0.05,\n            enableTakesDetection: true,\n            enableJCut: false,\n            jCutLeadIn: 0,\n            jCutLeadOut: 0\n        }\n    }\n};\n\n/**\n * List of built-in preset IDs\n */\nconst BUILT_IN_PRESET_IDS = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];\n\n/**\n * Get all available presets\n * @returns {Object} All preset definitions\n */\nfunction getPresets() {\n    return { ...PRESETS };\n}\n\n/**\n * Get a specific preset by name\n * @param {string} presetName - Name of the preset\n * @returns {Object|null} Preset definition or null if not found\n */\nfunction getPreset(presetName) {\n    return PRESETS[presetName] || null;\n}\n\n/**\n * Check if a preset is a built-in preset\n * @param {string} id - Preset ID to check\n * @returns {boolean} True if built-in, false if custom\n */\nfunction isBuiltInPreset(id) {\n    return BUILT_IN_PRESET_IDS.includes(id);\n}\n\n/**\n * Apply a preset to current settings\n * @param {string} presetName - Name of the preset to apply\n * @returns {Object} The applied settings\n */\nfunction applyPreset(presetName) {\n    const preset = PRESETS[presetName];\n\n    if (!preset) {\n        console.warn(`[SPLICE] Unknown preset: ${presetName}`);\n        return getSettings();\n    }\n\n    // Custom preset uses current settings\n    if (presetName === 'custom' || !preset.settings) {\n        saveSettings({ activePreset: 'custom' });\n        return getSettings();\n    }\n\n    // Apply preset settings\n    const newSettings = {\n        ...preset.settings,\n        activePreset: presetName\n    };\n\n    saveSettings(newSettings);\n    debugLog(`Applied preset: ${preset.name}`);\n\n    return getSettings();\n}\n\n/**\n * Get the currently active preset\n * @returns {string} Active preset name\n */\nfunction getActivePreset() {\n    const settings = getSettings();\n    return settings.activePreset || 'custom';\n}\n\n/**\n * Initialize preset selector\n */\nfunction initPresetSelector() {\n    const presetSelector = document.getElementById('presetSelector');\n    const sensitivitySlider = document.getElementById('sensitivitySlider');\n\n    if (!presetSelector) return;\n\n    // Set initial value from settings\n    const settings = getSettings();\n    presetSelector.value = settings.activePreset || 'podcast';\n\n    // Handle preset change\n    presetSelector.addEventListener('change', () => {\n        const presetId = presetSelector.value;\n        const appliedSettings = applyPreset(presetId);\n\n        // Update sensitivity slider to match preset\n        if (sensitivitySlider && appliedSettings.sensitivity !== undefined) {\n            sensitivitySlider.value = appliedSettings.sensitivity;\n            // Update display value\n            const sensitivityValue = document.getElementById('sensitivityValue');\n            if (sensitivityValue) {\n                sensitivityValue.textContent = appliedSettings.sensitivity;\n            }\n        }\n\n        // Update takes detection checkbox\n        const enableTakesDetection = document.getElementById('enableTakesDetection');\n        if (enableTakesDetection && appliedSettings.enableTakesDetection !== undefined) {\n            enableTakesDetection.checked = appliedSettings.enableTakesDetection;\n        }\n\n        // Update J-Cut checkbox\n        const enableJCut = document.getElementById('enableJCut');\n        if (enableJCut && appliedSettings.enableJCut !== undefined) {\n            enableJCut.checked = appliedSettings.enableJCut;\n            // Toggle J-Cut settings visibility\n            const jcutSettings = document.getElementById('jcutSettings');\n            if (jcutSettings) {\n                jcutSettings.classList.toggle('collapsed', !appliedSettings.enableJCut);\n            }\n        }\n\n        const preset = getPreset(presetId);\n        if (preset) {\n            setStatus(`Preset: ${preset.name} - ${preset.description}`);\n        }\n    });\n\n    // Switch to custom when user manually changes sensitivity\n    if (sensitivitySlider) {\n        sensitivitySlider.addEventListener('change', () => {\n            if (presetSelector.value !== 'custom') {\n                presetSelector.value = 'custom';\n                saveSettings({ activePreset: 'custom' });\n            }\n        });\n    }\n}\n\n// ============================================================================\n// LOGIN MODAL\n// ============================================================================\n\n/**\n * Validate license key format: SPLICE-XXXX-XXXX-XXXX\n * Character set excludes confusing chars: 0/O, 1/I/L\n */\nfunction isValidLicenseKeyFormat(key) {\n    if (!key || typeof key !== 'string') return false;\n    const normalized = key.toUpperCase().trim();\n    const pattern = /^SPLICE-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}-[ABCDEFGHJKMNPQRSTUVWXYZ23456789]{4}$/;\n    return pattern.test(normalized);\n}\n\n/**\n * Initialize login modal handlers\n */\nfunction initLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const closeLoginBtn = document.getElementById('closeLoginBtn');\n    const saveLoginBtn = document.getElementById('saveLoginBtn');\n    const licenseKeyInput = document.getElementById('licenseKeyInput');\n    const creditBadge = document.getElementById('creditBadge');\n\n    // Handle credit badge click - retry on error, or show login modal\n    if (creditBadge) {\n        creditBadge.addEventListener('click', async () => {\n            if (creditBadge.classList.contains('error')) {\n                creditBadge.textContent = '...';\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n                return;\n            }\n            showLoginModal();\n        });\n    }\n\n    // Close login modal\n    if (closeLoginBtn && loginModal) {\n        closeLoginBtn.addEventListener('click', () => {\n            loginModal.classList.add('hidden');\n        });\n    }\n\n    // Close on backdrop click\n    if (loginModal) {\n        loginModal.addEventListener('click', (e) => {\n            if (e.target === loginModal) {\n                loginModal.classList.add('hidden');\n            }\n        });\n    }\n\n    // Activate license key\n    if (saveLoginBtn) {\n        saveLoginBtn.addEventListener('click', async () => {\n            const licenseKey = licenseKeyInput?.value?.trim()?.toUpperCase();\n\n            if (!licenseKey) {\n                showLoginError('Please enter your license key');\n                return;\n            }\n\n            if (!isValidLicenseKeyFormat(licenseKey)) {\n                showLoginError('Invalid format. Expected: SPLICE-XXXX-XXXX-XXXX');\n                return;\n            }\n\n            saveLoginBtn.disabled = true;\n            saveLoginBtn.textContent = 'Activating...';\n\n            try {\n                // Use /auth/login endpoint which returns JWT tokens\n                const response = await fetchWithTimeout(`${getBackendUrl()}/auth/login`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ licenseKey: licenseKey })\n                }, SPLICE_CONFIG.FETCH_TIMEOUT);\n\n                const result = await response.json();\n\n                if (!result.success) {\n                    showLoginError(result.error || 'Activation failed');\n                    return;\n                }\n\n                // Store JWT tokens and customer info\n                const expiresInMs = (result.expiresIn || 86400) * 1000; // Default 24h\n                saveSettings({\n                    customerId: result.customerId,\n                    accessToken: result.token,\n                    refreshToken: result.refreshToken,\n                    tokenExpiry: Date.now() + expiresInMs,\n                    licenseKey: licenseKey // Keep for re-authentication\n                });\n\n                loginModal?.classList.add('hidden');\n\n                if (typeof refreshCredits === 'function') {\n                    await refreshCredits();\n                }\n\n                const tierName = result.tier ? result.tier.charAt(0).toUpperCase() + result.tier.slice(1) : 'Unknown';\n                setStatus(`License activated! ${tierName} tier`);\n            } catch (err) {\n                console.error('[SPLICE] License activation error:', err);\n\n                // DIAGNOSTIC LOGGING: Capture exact error details (debug mode only)\n                debugLog('=== CEP LICENSE ACTIVATION ERROR DIAGNOSTICS ===');\n                debugLog('Error name:', err?.name);\n                debugLog('Error message:', err?.message);\n                debugLog('Error stack:', err?.stack);\n                debugLog('Backend URL:', getBackendUrl());\n                debugLog('Fetch timeout:', SPLICE_CONFIG.FETCH_TIMEOUT);\n                debugLog('Is CEP environment:', typeof CSInterface !== 'undefined');\n                debugLog('User agent:', navigator?.userAgent);\n                debugLog('Error constructor:', err?.constructor?.name);\n                debugLog('Is TypeError:', err?.name === 'TypeError');\n                debugLog('Message contains \"Failed to fetch\":', err?.message?.includes('Failed to fetch'));\n                debugLog('Message contains \"fetch\":', err?.message?.toLowerCase()?.includes('fetch'));\n                debugLog('Message contains \"network\":', err?.message?.toLowerCase()?.includes('network'));\n                debugLog('Message contains \"CORS\":', err?.message?.toLowerCase()?.includes('cors'));\n                debugLog('Message contains \"SSL\":', err?.message?.toLowerCase()?.includes('ssl'));\n                debugLog('Message contains \"certificate\":', err?.message?.toLowerCase()?.includes('certificate'));\n                debugLog('Full error object:', JSON.stringify(err, Object.getOwnPropertyNames(err)));\n                debugLog('================================================');\n\n                // Provide detailed error message based on error type\n                let errorMessage = 'Connection error. ';\n\n                if (err.message === 'Request timed out') {\n                    errorMessage += 'Server is not responding. Check if backend is running.';\n                } else if (err.message?.includes('Failed to fetch') || err.name === 'TypeError') {\n                    errorMessage += `Cannot reach ${getBackendUrl()}. Check network/firewall.`;\n                } else if (err.message?.includes('CORS')) {\n                    errorMessage += 'CORS error. Contact support.';\n                } else if (err.message?.includes('SSL') || err.message?.includes('certificate')) {\n                    errorMessage += 'SSL certificate error. Try updating your system certificates.';\n                } else if (err.message) {\n                    errorMessage += err.message;\n                } else {\n                    errorMessage += 'Unknown error. Check console for details.';\n                }\n\n                debugLog('Final error message shown to user:', errorMessage);\n                showLoginError(errorMessage);\n            } finally {\n                saveLoginBtn.disabled = false;\n                saveLoginBtn.textContent = 'Activate';\n            }\n        });\n    }\n\n    // Email lookup\n    const lookupLicenseBtn = document.getElementById('lookupLicenseBtn');\n    const lookupEmailInput = document.getElementById('lookupEmailInput');\n\n    if (lookupLicenseBtn) {\n        lookupLicenseBtn.addEventListener('click', async () => {\n            const email = lookupEmailInput?.value?.trim()?.toLowerCase();\n\n            if (!email) {\n                showLoginError('Please enter your email address');\n                return;\n            }\n\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(email)) {\n                showLoginError('Please enter a valid email address');\n                return;\n            }\n\n            lookupLicenseBtn.disabled = true;\n            lookupLicenseBtn.textContent = 'Looking up...';\n\n            try {\n                const response = await fetchWithTimeout(`${getBackendUrl()}/license/lookup`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ email })\n                }, 30000);\n\n                const result = await response.json();\n\n                // Note: For security, the backend does NOT return the license key directly.\n                // It sends the key via email to prevent enumeration attacks.\n                if (result.success) {\n                    setStatus(result.message || 'If a license exists, it will be sent to your email.');\n                } else {\n                    showLoginError(result.error || 'Lookup failed. Please try again.');\n                }\n            } catch (err) {\n                console.error('[SPLICE] License lookup error:', err);\n                showLoginError('Failed to look up license. Please try again.');\n            } finally {\n                lookupLicenseBtn.disabled = false;\n                lookupLicenseBtn.textContent = 'Lookup';\n            }\n        });\n    }\n\n    // Handle external URL buttons\n    // CEP panels cannot use target=\"_blank\" for security reasons.\n    // Must use CSInterface.openURLInDefaultBrowser() instead.\n    initExternalLinkButtons();\n}\n\n/**\n * Initialize all external link buttons that need CSInterface.openURLInDefaultBrowser()\n * CEP panels cannot use target=\"_blank\" due to security restrictions\n */\nfunction initExternalLinkButtons() {\n    // Check if CSInterface is available\n    if (typeof CSInterface === 'undefined') {\n        console.warn('[SPLICE] CSInterface not available - external links disabled');\n        return;\n    }\n\n    let cs;\n    try {\n        cs = new CSInterface();\n    } catch (e) {\n        console.warn('[SPLICE] Failed to create CSInterface:', e.message);\n        return;\n    }\n\n    // Buy a License button\n    const buyLicenseBtn = document.querySelector('.btn-buy-license');\n\n    if (buyLicenseBtn) {\n        buyLicenseBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n\n            // Visual feedback\n            buyLicenseBtn.textContent = 'Opening...';\n            buyLicenseBtn.style.backgroundColor = '#28a745';\n\n            try {\n                cs.openURLInDefaultBrowser('https://spliceclips.com/pricing');\n\n                // Reset button after a delay\n                setTimeout(() => {\n                    buyLicenseBtn.textContent = 'Buy License';\n                    buyLicenseBtn.style.backgroundColor = '';\n                }, 2000);\n            } catch (err) {\n                console.error('[SPLICE] Failed to open URL:', err.message);\n                buyLicenseBtn.textContent = 'Error';\n                buyLicenseBtn.style.backgroundColor = '#dc3545';\n            }\n        });\n    }\n    \n    // View Plans button (in upgrade modal)\n    const viewPlansBtn = document.querySelector('.btn-view-plans');\n    if (viewPlansBtn) {\n        viewPlansBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const url = viewPlansBtn.dataset.url || 'https://spliceclips.com/pricing';\n            cs.openURLInDefaultBrowser(url);\n        });\n    }\n    \n    // Referral link button\n    const referralBtn = document.querySelector('.btn-referral');\n    if (referralBtn) {\n        referralBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const url = referralBtn.dataset.url || 'https://splice.video/referrals';\n            cs.openURLInDefaultBrowser(url);\n        });\n    }\n}\n\n/**\n * Show login modal\n */\nfunction showLoginModal() {\n    const loginModal = document.getElementById('loginModal');\n    const loginError = document.getElementById('loginError');\n    if (loginError) loginError.style.display = 'none';\n    if (loginModal) loginModal.classList.remove('hidden');\n}\n\n/**\n * Show login error message\n */\nfunction showLoginError(message) {\n    const loginError = document.getElementById('loginError');\n    if (loginError) {\n        loginError.textContent = message;\n        loginError.style.display = 'block';\n    }\n}\n\n/**\n * Check if user is logged in\n */\nfunction isLoggedIn() {\n    const settings = getSettings();\n    return !!settings.customerId;\n}\n\n/**\n * Logout - clear all auth data\n */\nfunction logout() {\n    // Clear all auth-related settings\n    saveSettings({\n        customerId: null,\n        accessToken: null,\n        refreshToken: null,\n        tokenExpiry: null,\n        licenseKey: null\n    });\n\n    if (typeof clearCreditsCache === 'function') {\n        clearCreditsCache();\n    }\n    if (typeof updateCreditDisplay === 'function') {\n        updateCreditDisplay(null);\n    }\n    setStatus('Logged out');\n}\n\n// Initialize JSX bridge when loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    jsx.init();\n});\n\n// Export for modules\nwindow.SPLICE_CONFIG = SPLICE_CONFIG;\nwindow.SPLICE_DEBUG = SPLICE_DEBUG;\nwindow.debugLog = debugLog;\nwindow.debugFetch = debugFetch;\nwindow.getBackendUrl = getBackendUrl;\nwindow.fetchWithTimeout = fetchWithTimeout;\nwindow.parseErrorResponse = parseErrorResponse;\nwindow.getAuthHeaders = getAuthHeaders;\nwindow.getSettings = getSettings;\nwindow.saveSettings = saveSettings;\nwindow.clearSetting = clearSetting;\nwindow.isOnline = isOnline;\nwindow.initOfflineDetection = initOfflineDetection;\nwindow.formatTime = formatTime;\nwindow.setStatus = setStatus;\nwindow.debounce = debounce;\nwindow.jsx = jsx;\nwindow.PRESETS = PRESETS;\nwindow.getPresets = getPresets;\nwindow.getPreset = getPreset;\nwindow.applyPreset = applyPreset;\nwindow.getActivePreset = getActivePreset;\nwindow.isBuiltInPreset = isBuiltInPreset;\nwindow.initPresetSelector = initPresetSelector;\nwindow.initLoginModal = initLoginModal;\nwindow.showLoginModal = showLoginModal;\nwindow.isLoggedIn = isLoggedIn;\nwindow.logout = logout;\nwindow.escapeHtml = escapeHtml;\nwindow.safeHtml = safeHtml;\n// JWT Auth functions\nwindow.isTokenExpired = isTokenExpired;\nwindow.refreshAccessToken = refreshAccessToken;\nwindow.clearAuthTokens = clearAuthTokens;\nwindow.ensureValidToken = ensureValidToken;\n","numLines":1395,"startLine":1,"totalLines":1395}}}
{"parentUuid":"1cc54cab-3f78-49a5-a744-163e7184062d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a3b7417","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_0129NWqd2kf8CtX5UG4wWiR5","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a comprehensive view of the CEP panel detection workflow. Let me generate a detailed verification report.\n\n---\n\n# CEP Panel AI Detection Workflow Verification Report\n\n## Overall Verdict: **PASS WITH ISSUES**\n\nThe detection workflow is generally well-implemented with good error handling and progress indicators. However, there are several issues beta testers may encounter that should be addressed before wider release.\n\n---\n\n## Requirements Checklist\n\n### 1. Pre-detection Checks\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Sequence open validation with retries | **MET** | `checkSequenceOpen()` has retry logic (default 2 retries, 300ms delay) |\n| Audio export for analysis | **MET** | Audio export with fallback to clip audio path |\n| User authentication check | **PARTIALLY MET** | Online check exists, but auth check happens implicitly during API calls |\n\n### 2. Detection Flow (runDetection function)\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Progress UI updates | **MET** | Progress bar and text updates at 10%, 30%, 60%, 65%, 80%, 90% |\n| Silence detection call | **MET** | Calls `/silences-rms` endpoint |\n| Take detection call (if enabled) | **MET** | Calls `/analyze` endpoint when enabled |\n| Profanity detection call (if enabled) | **MET** | Calls `/profanity` endpoint when enabled |\n| Chapter detection call (if enabled) | **MET** | Calls `/chapters` endpoint when enabled |\n| Zoom detection call (if enabled) | **MET** | Calls `/zoom` endpoint when enabled |\n\n### 3. Error Handling\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Network errors | **MET** | fetchWithTimeout handles AbortError and network failures |\n| 401 unauthorized handling | **PARTIALLY MET** | Handled in credits.js with token refresh, but main detection flow only logs warning |\n| 402 payment required (insufficient credits) | **PARTIALLY MET** | Logged as warning for takes detection, but workflow continues |\n| Backend error responses | **MET** | parseErrorResponse extracts error messages |\n| User-friendly error messages via setStatus() | **MET** | Error messages displayed to users |\n\n### 4. Results Handling\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Preview list population | **MET** | renderPreviewList() creates clickable items |\n| Silence/take/chapter/zoom data storage | **MET** | Data stored in module-level variables |\n| UI updates after detection | **MET** | showCombinedPreview() handles display |\n\n### 5. Apply Operations\n\n| Requirement | Status | Notes |\n|-------------|--------|-------|\n| Marker creation | **MET** | jsx.call('createMarker') for all types |\n| Razor cuts | **NOT DIRECTLY TESTED** | Not visible in current main.js |\n| Sequence building | **MET** | buildSequence() creates cut list and calls JSX |\n\n---\n\n## Detailed Findings\n\n### CRITICAL Issues (Priority: High)\n\n#### Issue 1: 401 Authentication Error During Detection Not Properly Handled\n**Location:** `/Users/imorgado/SPLICE/splice-cep/panel/js/main.js` lines 758-768\n\n**Problem:** When takes detection returns 401, the code only logs a warning and continues. The user is not prompted to re-login, and the detection result is incomplete.\n\n```javascript\nif (analyzeResponse.status === 401) {\n    console.warn('[SPLICE] Takes detection skipped: authentication required');\n}\n```\n\n**Impact:** Beta testers with expired tokens will get partial results without understanding why.\n\n**Recommendation:** Add explicit check before detection starts to ensure valid token:\n```javascript\n// Add at start of runDetection():\nif (!await ensureValidToken()) {\n    setStatus('Session expired. Please log in again.', true);\n    showLoginModal();\n    return;\n}\n```\n\n---\n\n#### Issue 2: Silent Failures for Profanity/Chapter/Zoom Detection\n**Location:** Lines 776-871\n\n**Problem:** When optional detections fail, the error is only logged to console. Users may not notice in the status bar because:\n1. setStatus() is called but quickly overwritten by final success message\n2. The `true` (error) flag shows red briefly, then the green success status appears\n\n**Impact:** Beta testers may think these features don't work when they actually failed silently.\n\n**Recommendation:** Aggregate errors and show summary at end:\n```javascript\nconst detectionErrors = [];\n// ... during detection ...\nif (!profanityResponse.ok) {\n    detectionErrors.push('profanity');\n}\n// ... at end ...\nif (detectionErrors.length > 0) {\n    setStatus(`Detection complete. Some features failed: ${detectionErrors.join(', ')}`, true);\n}\n```\n\n---\n\n### HIGH Priority Issues\n\n#### Issue 3: No Auth Check Before Detection Starts\n**Location:** Line 631-649\n\n**Problem:** The code checks for sequence and online status, but not authentication. A logged-out user will attempt detection, get to the API call, then fail.\n\n**Current Flow:**\n1. Check sequence open - YES\n2. Check online - YES\n3. Export audio - SUCCESS\n4. Call /silences-rms - FAILS with 401\n\n**Better Flow:**\n1. Check sequence open - YES\n2. Check online - YES\n3. Check authenticated - NO -> Show login modal\n4. Export audio - SUCCESS\n5. Call API - SUCCESS\n\n**Recommendation:** Add auth check in runDetection() before API calls:\n```javascript\n// After online check, before audio export:\nconst settings = getSettings();\nif (!settings.customerId && !settings.accessToken) {\n    setStatus('Please log in to use detection features', true);\n    showLoginModal();\n    isOperationInProgress = false;\n    return;\n}\n```\n\n---\n\n#### Issue 4: Audio Export Error Message Could Be Clearer\n**Location:** Lines 676-704\n\n**Problem:** When audio export fails, the error message is generic:\n```\n\"Could not export or locate audio file. Please ensure sequence has audio tracks.\"\n```\n\n**Impact:** Beta testers won't know if:\n- The sequence truly has no audio\n- Export failed due to permissions\n- The fallback clip lookup failed\n\n**Recommendation:** Include the actual error in the message:\n```javascript\nif (!audioFilePath) {\n    const detail = exportError?.message || clipError?.message || 'Unknown error';\n    throw new Error(`Could not export audio: ${detail}. Ensure sequence has audio tracks.`);\n}\n```\n\n---\n\n### MEDIUM Priority Issues\n\n#### Issue 5: Progress Bar Jumps Are Not Smooth\n**Location:** Lines 676-871\n\n**Problem:** Progress updates are at fixed percentages (10%, 30%, 60%, 65%, 80%, 90%) regardless of actual work done. If takes detection is disabled, progress jumps from 30% to 80%.\n\n**Impact:** Users may perceive the tool as \"stuck\" during long operations like audio export.\n\n**Recommendation:** Calculate progress dynamically based on enabled features.\n\n---\n\n#### Issue 6: No Timeout Feedback During Long Operations\n**Location:** config.js line 47 `FETCH_TIMEOUT: 120000`\n\n**Problem:** 2-minute timeout is long. Users see no feedback that something is still happening.\n\n**Impact:** Beta testers may think the panel has frozen.\n\n**Recommendation:** Add periodic status updates during long operations:\n```javascript\nupdateProgress(30, 'Detecting silences... (this may take a moment for long audio)');\n```\n\n---\n\n#### Issue 7: Error State Not Cleared Between Runs\n**Location:** Line 646-648\n\n**Problem:** `lastSequenceCheckError` is set on failure, but only cleared in runDetection. If user clicks Go, fails, fixes issue, and clicks Go again, the old error context may still influence behavior.\n\n**Impact:** Confusing error messages on retry.\n\n**Recommendation:** Clear error state at start of runDetection().\n\n---\n\n### LOW Priority Issues\n\n#### Issue 8: No Visual Distinction for Different Error Types\n**Problem:** All errors show in same red color via setStatus(..., true). Users cannot distinguish between:\n- Network errors (retryable)\n- Auth errors (need login)\n- Insufficient credits (need upgrade)\n\n**Recommendation:** Use different status colors or icons for different error types.\n\n---\n\n#### Issue 9: Credits Badge Click Handler Has Duplicate Logic\n**Location:** main.js lines 1309-1321 and config.js lines 1050-1060\n\n**Problem:** Credit badge click handler is registered in both main.js and config.js, potentially causing double-handling.\n\n**Impact:** May cause unexpected behavior.\n\n**Recommendation:** Remove duplicate from main.js since config.js handles it via initLoginModal().\n\n---\n\n## Workflow Trace for Beta Tester\n\nHere's what a beta tester would experience:\n\n### Happy Path (All Works)\n1. User opens sequence in Timeline\n2. Clicks \"Go\" button\n3. Progress: \"Exporting audio...\" (10%)\n4. Progress: \"Detecting silences...\" (30%)\n5. Progress: \"Detecting takes...\" (60%)\n6. Progress: \"Detecting profanity...\" (65%) [if enabled]\n7. Progress: \"Detecting chapters...\" (80%) [if enabled]\n8. Progress: \"Detecting zoom points...\" (90%) [if enabled]\n9. Status: \"Found X silences, Y takes\"\n10. Preview list appears with clickable items\n11. User can select/deselect, apply markers, or build sequence\n\n### Error Paths\n\n| Scenario | What User Sees | Is It Clear? |\n|----------|----------------|--------------|\n| No sequence open | \"Please open a sequence in the Timeline first\" (red) | **YES** |\n| Offline | \"Offline - Check your connection\" (red) | **YES** |\n| JSX connection failed | \"Premiere Pro connection issue - try reopening panel\" (red) | **YES** |\n| Not logged in | Detection starts, then fails at API call | **NO** - Should prompt login first |\n| Token expired | Partial results, console warning | **NO** - Should prompt re-login |\n| Insufficient credits | \"Takes detection skipped: insufficient credits\" (red, brief) | **PARTIAL** - Message may be overwritten |\n| Audio export failed | \"Could not export or locate audio file\" (red) | **PARTIAL** - Generic message |\n| Network timeout | \"Request timeout after 120000ms\" (red) | **YES** |\n\n---\n\n## Summary of Recommendations\n\n### Must Fix Before Beta Release\n1. **Add authentication check at start of runDetection()** - Prevents wasted API calls and confusing partial results\n2. **Aggregate and display errors for optional detections** - Users need to know what worked and what didn't\n\n### Should Fix\n3. **Include specific error details in audio export failure message**\n4. **Add periodic status updates during long operations**\n5. **Remove duplicate credit badge click handler**\n\n### Nice to Have\n6. **Dynamic progress bar calculation based on enabled features**\n7. **Visual distinction for different error types**\n8. **Clear error state explicitly at start of each detection run**\n\n---\n\n## Files Reviewed\n\n| File | Purpose |\n|------|---------|\n| `/Users/imorgado/SPLICE/splice-cep/panel/js/main.js` | Main detection workflow, UI handlers |\n| `/Users/imorgado/SPLICE/splice-cep/panel/js/config.js` | Backend URLs, JSX bridge, settings, auth utilities |\n| `/Users/imorgado/SPLICE/splice-cep/panel/js/credits.js` | Credit display, feature access checks |"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5647,"cache_creation_input_tokens":16934,"cache_read_input_tokens":48303,"cache_creation":{"ephemeral_5m_input_tokens":16934,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2bSq1HCgsW42KMeyQqg","type":"assistant","uuid":"5cb4533c-f7da-414e-af4e-d5295e61d56b","timestamp":"2026-01-12T01:12:58.294Z"}
