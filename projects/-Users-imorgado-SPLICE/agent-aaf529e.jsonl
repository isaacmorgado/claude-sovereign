{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":"Validate all external service integrations in splice-backend/services/.\n\nCheck each service file:\n\n**transcription.js** - OpenAI Whisper integration\n**takeDetection.js** - GPT-4o-mini integration\n**musicGeneration.js** - Mureka API integration\n**vocalIsolation.js** - Replicate API integration\n**chapterDetection.js** - GPT integration\n**usageTracking.js** - PostgreSQL integration\n**licenseService.js** - PostgreSQL + key generation\n**r2Storage.js** - Cloudflare R2 integration\n\nFor each verify:\n1. API client properly initialized\n2. Functions exported and callable\n3. Error handling exists\n4. Required env vars documented\n\nAlso check:\n- Database schema exists for required tables\n- Stripe webhook handles all subscription events\n\nReport: Service status with any missing implementations or broken integrations."},"uuid":"f70758d6-6803-4fac-9672-0d83d923c1ee","timestamp":"2025-12-27T01:34:53.448Z"}
{"parentUuid":"f70758d6-6803-4fac-9672-0d83d923c1ee","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_0151dcrLT8ubodjxXT7fmpxy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015BVjdpMCvKM4aKTt8vZV2S","name":"Glob","input":{"pattern":"splice-backend/services/*.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20496,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20496,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWWLFGGNeUkGMZaQVr58o","type":"assistant","uuid":"ab10f06f-b9fd-4598-be00-9ee252c04a87","timestamp":"2025-12-27T01:34:56.578Z"}
{"parentUuid":"ab10f06f-b9fd-4598-be00-9ee252c04a87","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_0151dcrLT8ubodjxXT7fmpxy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GWhrH98KNFf1ewBqksxXqn","name":"Glob","input":{"pattern":"splice-backend/**/*schema*.sql"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20496,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20496,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWWLFGGNeUkGMZaQVr58o","type":"assistant","uuid":"fd90b8ad-ca22-44d3-ba99-d28ce31d3728","timestamp":"2025-12-27T01:34:57.202Z"}
{"parentUuid":"fd90b8ad-ca22-44d3-ba99-d28ce31d3728","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_0151dcrLT8ubodjxXT7fmpxy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TdPNFG7BnutaiCiRzAWx6G","name":"Glob","input":{"pattern":"splice-backend/**/*migration*.sql"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":20496,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":20496,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CWWLFGGNeUkGMZaQVr58o","type":"assistant","uuid":"fe4d156a-d9f2-4ebc-b54a-2dc1819a3eaa","timestamp":"2025-12-27T01:34:57.659Z"}
{"parentUuid":"fe4d156a-d9f2-4ebc-b54a-2dc1819a3eaa","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TdPNFG7BnutaiCiRzAWx6G","type":"tool_result","content":"No files found"}]},"uuid":"b7607616-a4e6-492e-8405-c748b9ef9f99","timestamp":"2025-12-27T01:34:58.481Z","toolUseResult":{"filenames":[],"durationMs":783,"numFiles":0,"truncated":false}}
{"parentUuid":"b7607616-a4e6-492e-8405-c748b9ef9f99","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GWhrH98KNFf1ewBqksxXqn","type":"tool_result","content":"No files found"}]},"uuid":"b1cf587d-fc1f-4a1a-b074-432ca3b449c8","timestamp":"2025-12-27T01:34:58.487Z","toolUseResult":{"filenames":[],"durationMs":789,"numFiles":0,"truncated":false}}
{"parentUuid":"b1cf587d-fc1f-4a1a-b074-432ca3b449c8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015BVjdpMCvKM4aKTt8vZV2S","type":"tool_result","content":"/Users/imorgado/SPLICE/splice-backend/services/silenceDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/xmlProcessor.js\n/Users/imorgado/SPLICE/splice-backend/services/ffprobeSilence.js\n/Users/imorgado/SPLICE/splice-backend/services/licenseService.js\n/Users/imorgado/SPLICE/splice-backend/services/referralService.js\n/Users/imorgado/SPLICE/splice-backend/services/cutListGenerator.js\n/Users/imorgado/SPLICE/splice-backend/services/captionExporter.js\n/Users/imorgado/SPLICE/splice-backend/services/vocalIsolation.js\n/Users/imorgado/SPLICE/splice-backend/services/takeDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js\n/Users/imorgado/SPLICE/splice-backend/services/securityUtils.js\n/Users/imorgado/SPLICE/splice-backend/services/musicQueue.js\n/Users/imorgado/SPLICE/splice-backend/services/r2Storage.js\n/Users/imorgado/SPLICE/splice-backend/services/repetitionDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/rmsSilenceDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/sceneAnalysis.js\n/Users/imorgado/SPLICE/splice-backend/services/multitrackAnalysis.js\n/Users/imorgado/SPLICE/splice-backend/services/profanityDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/musicTimeline.js\n/Users/imorgado/SPLICE/splice-backend/services/socialReframe.js\n/Users/imorgado/SPLICE/splice-backend/services/songIdentification.js\n/Users/imorgado/SPLICE/splice-backend/services/transcription.js\n/Users/imorgado/SPLICE/splice-backend/services/youtubeGenerator.js\n/Users/imorgado/SPLICE/splice-backend/services/zoomGenerator.js\n/Users/imorgado/SPLICE/splice-backend/services/animatedCaptions.js\n/Users/imorgado/SPLICE/splice-backend/services/chapterDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/faceDetection.js\n/Users/imorgado/SPLICE/splice-backend/services/musicAlignment.js\n/Users/imorgado/SPLICE/splice-backend/services/textBasedEditing.js\n/Users/imorgado/SPLICE/splice-backend/services/musicGeneration.js"}]},"uuid":"7e4f4964-72c6-483a-8538-ebea9ed0de5d","timestamp":"2025-12-27T01:34:58.544Z","toolUseResult":{"filenames":["/Users/imorgado/SPLICE/splice-backend/services/silenceDetection.js","/Users/imorgado/SPLICE/splice-backend/services/xmlProcessor.js","/Users/imorgado/SPLICE/splice-backend/services/ffprobeSilence.js","/Users/imorgado/SPLICE/splice-backend/services/licenseService.js","/Users/imorgado/SPLICE/splice-backend/services/referralService.js","/Users/imorgado/SPLICE/splice-backend/services/cutListGenerator.js","/Users/imorgado/SPLICE/splice-backend/services/captionExporter.js","/Users/imorgado/SPLICE/splice-backend/services/vocalIsolation.js","/Users/imorgado/SPLICE/splice-backend/services/takeDetection.js","/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","/Users/imorgado/SPLICE/splice-backend/services/securityUtils.js","/Users/imorgado/SPLICE/splice-backend/services/musicQueue.js","/Users/imorgado/SPLICE/splice-backend/services/r2Storage.js","/Users/imorgado/SPLICE/splice-backend/services/repetitionDetection.js","/Users/imorgado/SPLICE/splice-backend/services/rmsSilenceDetection.js","/Users/imorgado/SPLICE/splice-backend/services/sceneAnalysis.js","/Users/imorgado/SPLICE/splice-backend/services/multitrackAnalysis.js","/Users/imorgado/SPLICE/splice-backend/services/profanityDetection.js","/Users/imorgado/SPLICE/splice-backend/services/musicTimeline.js","/Users/imorgado/SPLICE/splice-backend/services/socialReframe.js","/Users/imorgado/SPLICE/splice-backend/services/songIdentification.js","/Users/imorgado/SPLICE/splice-backend/services/transcription.js","/Users/imorgado/SPLICE/splice-backend/services/youtubeGenerator.js","/Users/imorgado/SPLICE/splice-backend/services/zoomGenerator.js","/Users/imorgado/SPLICE/splice-backend/services/animatedCaptions.js","/Users/imorgado/SPLICE/splice-backend/services/chapterDetection.js","/Users/imorgado/SPLICE/splice-backend/services/faceDetection.js","/Users/imorgado/SPLICE/splice-backend/services/musicAlignment.js","/Users/imorgado/SPLICE/splice-backend/services/textBasedEditing.js","/Users/imorgado/SPLICE/splice-backend/services/musicGeneration.js"],"durationMs":845,"numFiles":30,"truncated":false}}
{"parentUuid":"7e4f4964-72c6-483a-8538-ebea9ed0de5d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E819z5DqT1rXDC8S3zbUBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QJkwRx4pRLfGjCobMetCmi","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/transcription.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":60,"cache_creation_input_tokens":854,"cache_read_input_tokens":20496,"cache_creation":{"ephemeral_5m_input_tokens":854,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWWLFe7X9VMV2WzDtG88d","type":"assistant","uuid":"d24d32ca-8312-498d-a1ed-6ec2704be919","timestamp":"2025-12-27T01:35:02.105Z"}
{"parentUuid":"d24d32ca-8312-498d-a1ed-6ec2704be919","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E819z5DqT1rXDC8S3zbUBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JNnH1u2wCbZscxb7r9DXab","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/takeDetection.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":60,"cache_creation_input_tokens":854,"cache_read_input_tokens":20496,"cache_creation":{"ephemeral_5m_input_tokens":854,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWWLFe7X9VMV2WzDtG88d","type":"assistant","uuid":"143bb26c-205e-48db-bf21-730419498fef","timestamp":"2025-12-27T01:35:02.687Z"}
{"parentUuid":"143bb26c-205e-48db-bf21-730419498fef","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E819z5DqT1rXDC8S3zbUBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017UDqc4JRfNhQjyZeBNtWys","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/musicGeneration.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":60,"cache_creation_input_tokens":854,"cache_read_input_tokens":20496,"cache_creation":{"ephemeral_5m_input_tokens":854,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWWLFe7X9VMV2WzDtG88d","type":"assistant","uuid":"14b67a01-f2f9-4f15-ba52-d703116c1f0c","timestamp":"2025-12-27T01:35:03.330Z"}
{"parentUuid":"14b67a01-f2f9-4f15-ba52-d703116c1f0c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E819z5DqT1rXDC8S3zbUBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QkPhPHZ2qKUbyHaZx71GiD","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/vocalIsolation.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":60,"cache_creation_input_tokens":854,"cache_read_input_tokens":20496,"cache_creation":{"ephemeral_5m_input_tokens":854,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWWLFe7X9VMV2WzDtG88d","type":"assistant","uuid":"ddb1cff2-c537-4ced-ba7b-2a5a6be324d4","timestamp":"2025-12-27T01:35:04.025Z"}
{"parentUuid":"ddb1cff2-c537-4ced-ba7b-2a5a6be324d4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E819z5DqT1rXDC8S3zbUBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018zzPRutpvKxWr3QXwpWhiJ","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/chapterDetection.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":60,"cache_creation_input_tokens":854,"cache_read_input_tokens":20496,"cache_creation":{"ephemeral_5m_input_tokens":854,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWWLFe7X9VMV2WzDtG88d","type":"assistant","uuid":"72af991d-6aac-4c39-8979-473a9e16119c","timestamp":"2025-12-27T01:35:04.675Z"}
{"parentUuid":"72af991d-6aac-4c39-8979-473a9e16119c","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E819z5DqT1rXDC8S3zbUBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LQ9DFsLbbeBpLWVhGR7fPH","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":60,"cache_creation_input_tokens":854,"cache_read_input_tokens":20496,"cache_creation":{"ephemeral_5m_input_tokens":854,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWWLFe7X9VMV2WzDtG88d","type":"assistant","uuid":"88d8abaa-2213-4431-bc24-7373190adf11","timestamp":"2025-12-27T01:35:05.277Z"}
{"parentUuid":"88d8abaa-2213-4431-bc24-7373190adf11","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E819z5DqT1rXDC8S3zbUBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YJ5D4mcVHFEtTDWWRPrUCe","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/licenseService.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":60,"cache_creation_input_tokens":854,"cache_read_input_tokens":20496,"cache_creation":{"ephemeral_5m_input_tokens":854,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWWLFe7X9VMV2WzDtG88d","type":"assistant","uuid":"fa51eb06-1c54-4625-a78e-d3477ba6c348","timestamp":"2025-12-27T01:35:05.917Z"}
{"parentUuid":"fa51eb06-1c54-4625-a78e-d3477ba6c348","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01E819z5DqT1rXDC8S3zbUBd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ju71ZnMmomYwHF44yfTWBp","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/services/r2Storage.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":60,"cache_creation_input_tokens":854,"cache_read_input_tokens":20496,"cache_creation":{"ephemeral_5m_input_tokens":854,"ephemeral_1h_input_tokens":0},"output_tokens":22,"service_tier":"standard"}},"requestId":"req_011CWWLFe7X9VMV2WzDtG88d","type":"assistant","uuid":"ed9804c2-236b-4009-8b5d-f7b75d386884","timestamp":"2025-12-27T01:35:06.504Z"}
{"parentUuid":"ed9804c2-236b-4009-8b5d-f7b75d386884","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QJkwRx4pRLfGjCobMetCmi","type":"tool_result","content":"     1→/**\n     2→ * Slice 4: Whisper Transcription Service\n     3→ *\n     4→ * Handles audio transcription using OpenAI's Whisper model.\n     5→ * Returns timestamped segments required for take detection.\n     6→ * Includes caching to avoid repeated API calls.\n     7→ */\n     8→\n     9→\n    10→const fs = require('fs');\n    11→const OpenAI = require('openai');\n    12→\n    13→// Initialize OpenAI client\n    14→const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n    15→\n    16→// In-memory cache: { wavPath: { mtime, result, cachedAt } }\n    17→const transcriptCache = new Map();\n    18→\n    19→// Cache configuration\n    20→const MAX_CACHE_SIZE = 50;\n    21→const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour TTL\n    22→\n    23→/**\n    24→ * Retry function with exponential backoff\n    25→ * @param {Function} fn - Async function to retry\n    26→ * @param {number} retries - Number of retry attempts (default: 3)\n    27→ * @param {number} baseDelay - Base delay in ms (default: 1000)\n    28→ * @returns {Promise<any>} Result of the function\n    29→ */\n    30→async function withRetry(fn, retries = 3, baseDelay = 1000) {\n    31→  let lastError;\n    32→\n    33→  for (let attempt = 0; attempt <= retries; attempt++) {\n    34→    try {\n    35→      return await fn();\n    36→    } catch (err) {\n    37→      lastError = err;\n    38→\n    39→      // Don't retry on quota exceeded - fail immediately\n    40→      if (err.code === 'insufficient_quota' || err.message?.includes('quota')) {\n    41→        throw new Error('OpenAI API quota exceeded. Please check your billing at https://platform.openai.com/account/billing');\n    42→      }\n    43→\n    44→      // Don't retry on the last attempt\n    45→      if (attempt === retries) {\n    46→        break;\n    47→      }\n    48→\n    49→      // Calculate delay with exponential backoff + jitter\n    50→      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 500;\n    51→\n    52→      // Only retry on retryable errors\n    53→      const isRetryable =\n    54→        err.status === 429 ||                          // Rate limit\n    55→        err.status === 500 ||                          // Server error\n    56→        err.status === 502 ||                          // Bad gateway\n    57→        err.status === 503 ||                          // Service unavailable\n    58→        err.code === 'ECONNRESET' ||                   // Connection reset\n    59→        err.code === 'ETIMEDOUT' ||                    // Timeout\n    60→        err.message?.includes('Connection error') ||   // Connection error\n    61→        err.message?.includes('network');              // Network error\n    62→\n    63→      if (!isRetryable) {\n    64→        throw err;\n    65→      }\n    66→\n    67→      console.log(`[SPLICE] Retry ${attempt + 1}/${retries} after ${Math.round(delay)}ms: ${err.message}`);\n    68→      await new Promise(resolve => setTimeout(resolve, delay));\n    69→    }\n    70→  }\n    71→\n    72→  throw lastError;\n    73→}\n    74→\n    75→/**\n    76→ * LRU cache set with size limit and TTL\n    77→ * Evicts oldest entries when cache exceeds MAX_CACHE_SIZE\n    78→ * @param {string} key - Cache key\n    79→ * @param {any} value - Value to cache (should include mtime, result)\n    80→ */\n    81→function cacheSet(key, value) {\n    82→  // Clean up expired entries first\n    83→  cleanExpiredEntries();\n    84→\n    85→  // Evict oldest entries if at capacity\n    86→  while (transcriptCache.size >= MAX_CACHE_SIZE) {\n    87→    const oldestKey = transcriptCache.keys().next().value;\n    88→    transcriptCache.delete(oldestKey);\n    89→    console.log(`[SPLICE] Cache eviction: removed ${oldestKey}`);\n    90→  }\n    91→\n    92→  // Add cachedAt timestamp\n    93→  transcriptCache.set(key, {\n    94→    ...value,\n    95→    cachedAt: Date.now()\n    96→  });\n    97→}\n    98→\n    99→/**\n   100→ * Get from cache with TTL check\n   101→ * @param {string} key - Cache key\n   102→ * @returns {object|null} Cached value or null if expired/missing\n   103→ */\n   104→function cacheGet(key) {\n   105→  const entry = transcriptCache.get(key);\n   106→  if (!entry) return null;\n   107→\n   108→  // Check TTL\n   109→  if (Date.now() - entry.cachedAt > CACHE_TTL_MS) {\n   110→    transcriptCache.delete(key);\n   111→    console.log(`[SPLICE] Cache entry expired: ${key}`);\n   112→    return null;\n   113→  }\n   114→\n   115→  return entry;\n   116→}\n   117→\n   118→/**\n   119→ * Clean up expired cache entries\n   120→ * Called periodically and before cache set\n   121→ */\n   122→function cleanExpiredEntries() {\n   123→  const now = Date.now();\n   124→  let cleaned = 0;\n   125→\n   126→  for (const [key, entry] of transcriptCache.entries()) {\n   127→    if (now - entry.cachedAt > CACHE_TTL_MS) {\n   128→      transcriptCache.delete(key);\n   129→      cleaned++;\n   130→    }\n   131→  }\n   132→\n   133→  if (cleaned > 0) {\n   134→    console.log(`[SPLICE] Cleaned ${cleaned} expired cache entries`);\n   135→  }\n   136→}\n   137→\n   138→/**\n   139→ * Unified transcription: calls Whisper ONCE with both word and segment granularities.\n   140→ * All other transcription functions should use this cache.\n   141→ *\n   142→ * @param {string} wavPath - Path to the WAV file\n   143→ * @returns {Promise<{text: string, segments: Array, words: Array, duration: number, language: string}>}\n   144→ */\n   145→async function transcribeFull(wavPath) {\n   146→  // Check cache based on file modification time and TTL\n   147→  const stats = fs.statSync(wavPath);\n   148→  const mtime = stats.mtimeMs;\n   149→  const cacheKey = `full:${wavPath}`;\n   150→\n   151→  const cached = cacheGet(cacheKey);  // Uses TTL-aware getter\n   152→  if (cached && cached.mtime === mtime) {\n   153→    console.log('[SPLICE] Using cached full transcription (file unchanged, cache valid)');\n   154→    return cached.result;\n   155→  }\n   156→\n   157→  console.log('[SPLICE] Starting unified Whisper transcription (words + segments)...');\n   158→\n   159→  // Single Whisper call with BOTH granularities\n   160→  const transcription = await withRetry(async () => {\n   161→    return await openai.audio.transcriptions.create({\n   162→      file: fs.createReadStream(wavPath),\n   163→      model: 'whisper-1',\n   164→      response_format: 'verbose_json',\n   165→      timestamp_granularities: ['word', 'segment'],\n   166→      language: 'en',\n   167→    });\n   168→  });\n   169→\n   170→  console.log(`[SPLICE] Unified transcription complete: ${transcription.segments?.length || 0} segments, ${transcription.words?.length || 0} words`);\n   171→\n   172→  // Build unified result with both segments and words\n   173→  const result = {\n   174→    text: transcription.text,\n   175→    segments: (transcription.segments || []).map(s => ({\n   176→      id: s.id,\n   177→      start: s.start,\n   178→      end: s.end,\n   179→      text: s.text\n   180→    })),\n   181→    words: (transcription.words || []).map(w => ({\n   182→      word: w.word,\n   183→      start: w.start,\n   184→      end: w.end\n   185→    })),\n   186→    language: transcription.language || 'en',\n   187→    duration: transcription.duration || 0\n   188→  };\n   189→\n   190→  // Cache the unified result\n   191→  cacheSet(cacheKey, { mtime, result });\n   192→  console.log(`[SPLICE] Full transcription cached (${result.segments.length} segments, ${result.words.length} words)`);\n   193→\n   194→  return result;\n   195→}\n   196→\n   197→/**\n   198→ * Transcribe audio file using Whisper with segment timestamps (with caching)\n   199→ * Uses unified transcribeFull() cache to avoid duplicate API calls.\n   200→ *\n   201→ * @param {string} wavPath - Path to the WAV file\n   202→ * @returns {Promise<{text: string, segments: Array, language: string, duration: number}>}\n   203→ */\n   204→async function transcribeAudio(wavPath) {\n   205→  // Use unified transcription (gets both segments and words)\n   206→  const full = await transcribeFull(wavPath);\n   207→\n   208→  // Return segment-focused result (matches legacy format)\n   209→  return {\n   210→    text: full.text,\n   211→    segments: full.segments,\n   212→    language: full.language,\n   213→    duration: full.duration\n   214→  };\n   215→}\n   216→\n   217→/**\n   218→ * Transcribe audio with word-level timestamps using Whisper\n   219→ * Uses unified transcribeFull() cache to avoid duplicate API calls.\n   220→ *\n   221→ * @param {string} wavPath - Path to the WAV file\n   222→ * @returns {Promise<{text: string, words: Array<{word: string, start: number, end: number}>}>}\n   223→ */\n   224→async function transcribeWithWords(wavPath) {\n   225→  // Use unified transcription (gets both segments and words)\n   226→  const full = await transcribeFull(wavPath);\n   227→\n   228→  // Return word-focused result (matches legacy format)\n   229→  return {\n   230→    text: full.text,\n   231→    words: full.words,\n   232→    language: full.language,\n   233→    duration: full.duration\n   234→  };\n   235→}\n   236→\n   237→/**\n   238→ * Clear transcription cache\n   239→ * Useful for testing or memory management\n   240→ */\n   241→function clearCache() {\n   242→  const size = transcriptCache.size;\n   243→  transcriptCache.clear();\n   244→  console.log(`[SPLICE] Cleared ${size} cached transcription(s)`);\n   245→  return size;\n   246→}\n   247→\n   248→/**\n   249→ * Get cache statistics\n   250→ */\n   251→function getCacheStats() {\n   252→  const now = Date.now();\n   253→  const entries = [];\n   254→\n   255→  for (const [key, entry] of transcriptCache.entries()) {\n   256→    const ageMs = now - entry.cachedAt;\n   257→    entries.push({\n   258→      key,\n   259→      ageMs,\n   260→      ageMinutes: Math.floor(ageMs / 60000),\n   261→      expiresInMs: Math.max(0, CACHE_TTL_MS - ageMs),\n   262→      expired: ageMs > CACHE_TTL_MS\n   263→    });\n   264→  }\n   265→\n   266→  return {\n   267→    entries: transcriptCache.size,\n   268→    ttlMs: CACHE_TTL_MS,\n   269→    ttlMinutes: CACHE_TTL_MS / 60000,\n   270→    maxSize: MAX_CACHE_SIZE,\n   271→    keys: Array.from(transcriptCache.keys()),\n   272→    details: entries\n   273→  };\n   274→}\n   275→\n   276→module.exports = { transcribeFull, transcribeAudio, transcribeWithWords, clearCache, getCacheStats };\n   277→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e5a13ee4-bf53-4d2a-9478-0137ef043316","timestamp":"2025-12-27T01:35:06.565Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/transcription.js","content":"/**\n * Slice 4: Whisper Transcription Service\n *\n * Handles audio transcription using OpenAI's Whisper model.\n * Returns timestamped segments required for take detection.\n * Includes caching to avoid repeated API calls.\n */\n\n\nconst fs = require('fs');\nconst OpenAI = require('openai');\n\n// Initialize OpenAI client\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\n// In-memory cache: { wavPath: { mtime, result, cachedAt } }\nconst transcriptCache = new Map();\n\n// Cache configuration\nconst MAX_CACHE_SIZE = 50;\nconst CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour TTL\n\n/**\n * Retry function with exponential backoff\n * @param {Function} fn - Async function to retry\n * @param {number} retries - Number of retry attempts (default: 3)\n * @param {number} baseDelay - Base delay in ms (default: 1000)\n * @returns {Promise<any>} Result of the function\n */\nasync function withRetry(fn, retries = 3, baseDelay = 1000) {\n  let lastError;\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n\n      // Don't retry on quota exceeded - fail immediately\n      if (err.code === 'insufficient_quota' || err.message?.includes('quota')) {\n        throw new Error('OpenAI API quota exceeded. Please check your billing at https://platform.openai.com/account/billing');\n      }\n\n      // Don't retry on the last attempt\n      if (attempt === retries) {\n        break;\n      }\n\n      // Calculate delay with exponential backoff + jitter\n      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 500;\n\n      // Only retry on retryable errors\n      const isRetryable =\n        err.status === 429 ||                          // Rate limit\n        err.status === 500 ||                          // Server error\n        err.status === 502 ||                          // Bad gateway\n        err.status === 503 ||                          // Service unavailable\n        err.code === 'ECONNRESET' ||                   // Connection reset\n        err.code === 'ETIMEDOUT' ||                    // Timeout\n        err.message?.includes('Connection error') ||   // Connection error\n        err.message?.includes('network');              // Network error\n\n      if (!isRetryable) {\n        throw err;\n      }\n\n      console.log(`[SPLICE] Retry ${attempt + 1}/${retries} after ${Math.round(delay)}ms: ${err.message}`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * LRU cache set with size limit and TTL\n * Evicts oldest entries when cache exceeds MAX_CACHE_SIZE\n * @param {string} key - Cache key\n * @param {any} value - Value to cache (should include mtime, result)\n */\nfunction cacheSet(key, value) {\n  // Clean up expired entries first\n  cleanExpiredEntries();\n\n  // Evict oldest entries if at capacity\n  while (transcriptCache.size >= MAX_CACHE_SIZE) {\n    const oldestKey = transcriptCache.keys().next().value;\n    transcriptCache.delete(oldestKey);\n    console.log(`[SPLICE] Cache eviction: removed ${oldestKey}`);\n  }\n\n  // Add cachedAt timestamp\n  transcriptCache.set(key, {\n    ...value,\n    cachedAt: Date.now()\n  });\n}\n\n/**\n * Get from cache with TTL check\n * @param {string} key - Cache key\n * @returns {object|null} Cached value or null if expired/missing\n */\nfunction cacheGet(key) {\n  const entry = transcriptCache.get(key);\n  if (!entry) return null;\n\n  // Check TTL\n  if (Date.now() - entry.cachedAt > CACHE_TTL_MS) {\n    transcriptCache.delete(key);\n    console.log(`[SPLICE] Cache entry expired: ${key}`);\n    return null;\n  }\n\n  return entry;\n}\n\n/**\n * Clean up expired cache entries\n * Called periodically and before cache set\n */\nfunction cleanExpiredEntries() {\n  const now = Date.now();\n  let cleaned = 0;\n\n  for (const [key, entry] of transcriptCache.entries()) {\n    if (now - entry.cachedAt > CACHE_TTL_MS) {\n      transcriptCache.delete(key);\n      cleaned++;\n    }\n  }\n\n  if (cleaned > 0) {\n    console.log(`[SPLICE] Cleaned ${cleaned} expired cache entries`);\n  }\n}\n\n/**\n * Unified transcription: calls Whisper ONCE with both word and segment granularities.\n * All other transcription functions should use this cache.\n *\n * @param {string} wavPath - Path to the WAV file\n * @returns {Promise<{text: string, segments: Array, words: Array, duration: number, language: string}>}\n */\nasync function transcribeFull(wavPath) {\n  // Check cache based on file modification time and TTL\n  const stats = fs.statSync(wavPath);\n  const mtime = stats.mtimeMs;\n  const cacheKey = `full:${wavPath}`;\n\n  const cached = cacheGet(cacheKey);  // Uses TTL-aware getter\n  if (cached && cached.mtime === mtime) {\n    console.log('[SPLICE] Using cached full transcription (file unchanged, cache valid)');\n    return cached.result;\n  }\n\n  console.log('[SPLICE] Starting unified Whisper transcription (words + segments)...');\n\n  // Single Whisper call with BOTH granularities\n  const transcription = await withRetry(async () => {\n    return await openai.audio.transcriptions.create({\n      file: fs.createReadStream(wavPath),\n      model: 'whisper-1',\n      response_format: 'verbose_json',\n      timestamp_granularities: ['word', 'segment'],\n      language: 'en',\n    });\n  });\n\n  console.log(`[SPLICE] Unified transcription complete: ${transcription.segments?.length || 0} segments, ${transcription.words?.length || 0} words`);\n\n  // Build unified result with both segments and words\n  const result = {\n    text: transcription.text,\n    segments: (transcription.segments || []).map(s => ({\n      id: s.id,\n      start: s.start,\n      end: s.end,\n      text: s.text\n    })),\n    words: (transcription.words || []).map(w => ({\n      word: w.word,\n      start: w.start,\n      end: w.end\n    })),\n    language: transcription.language || 'en',\n    duration: transcription.duration || 0\n  };\n\n  // Cache the unified result\n  cacheSet(cacheKey, { mtime, result });\n  console.log(`[SPLICE] Full transcription cached (${result.segments.length} segments, ${result.words.length} words)`);\n\n  return result;\n}\n\n/**\n * Transcribe audio file using Whisper with segment timestamps (with caching)\n * Uses unified transcribeFull() cache to avoid duplicate API calls.\n *\n * @param {string} wavPath - Path to the WAV file\n * @returns {Promise<{text: string, segments: Array, language: string, duration: number}>}\n */\nasync function transcribeAudio(wavPath) {\n  // Use unified transcription (gets both segments and words)\n  const full = await transcribeFull(wavPath);\n\n  // Return segment-focused result (matches legacy format)\n  return {\n    text: full.text,\n    segments: full.segments,\n    language: full.language,\n    duration: full.duration\n  };\n}\n\n/**\n * Transcribe audio with word-level timestamps using Whisper\n * Uses unified transcribeFull() cache to avoid duplicate API calls.\n *\n * @param {string} wavPath - Path to the WAV file\n * @returns {Promise<{text: string, words: Array<{word: string, start: number, end: number}>}>}\n */\nasync function transcribeWithWords(wavPath) {\n  // Use unified transcription (gets both segments and words)\n  const full = await transcribeFull(wavPath);\n\n  // Return word-focused result (matches legacy format)\n  return {\n    text: full.text,\n    words: full.words,\n    language: full.language,\n    duration: full.duration\n  };\n}\n\n/**\n * Clear transcription cache\n * Useful for testing or memory management\n */\nfunction clearCache() {\n  const size = transcriptCache.size;\n  transcriptCache.clear();\n  console.log(`[SPLICE] Cleared ${size} cached transcription(s)`);\n  return size;\n}\n\n/**\n * Get cache statistics\n */\nfunction getCacheStats() {\n  const now = Date.now();\n  const entries = [];\n\n  for (const [key, entry] of transcriptCache.entries()) {\n    const ageMs = now - entry.cachedAt;\n    entries.push({\n      key,\n      ageMs,\n      ageMinutes: Math.floor(ageMs / 60000),\n      expiresInMs: Math.max(0, CACHE_TTL_MS - ageMs),\n      expired: ageMs > CACHE_TTL_MS\n    });\n  }\n\n  return {\n    entries: transcriptCache.size,\n    ttlMs: CACHE_TTL_MS,\n    ttlMinutes: CACHE_TTL_MS / 60000,\n    maxSize: MAX_CACHE_SIZE,\n    keys: Array.from(transcriptCache.keys()),\n    details: entries\n  };\n}\n\nmodule.exports = { transcribeFull, transcribeAudio, transcribeWithWords, clearCache, getCacheStats };\n","numLines":277,"startLine":1,"totalLines":277}}}
{"parentUuid":"e5a13ee4-bf53-4d2a-9478-0137ef043316","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JNnH1u2wCbZscxb7r9DXab","type":"tool_result","content":"     1→/**\n     2→ * Slice 5: GPT-4o-mini Take Detection Service\n     3→ *\n     4→ * Analyzes transcripts to identify distinct takes (repeated attempts).\n     5→ * Uses GPT-4o-mini for intelligent content analysis.\n     6→ */\n     7→\n     8→const OpenAI = require('openai');\n     9→\n    10→// Initialize OpenAI client\n    11→const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n    12→\n    13→/**\n    14→ * Build the take detection prompt\n    15→ * @param {string} segmentsText - Formatted transcript segments\n    16→ * @returns {string} The prompt for GPT\n    17→ */\n    18→function buildPrompt(segmentsText) {\n    19→  return `Analyze this video transcript and identify distinct \"takes\" (repeated attempts at the same content).\n    20→\n    21→Look for:\n    22→- Explicit markers: \"take 1\", \"take 2\", \"cut\", \"again\", \"one more time\"\n    23→- Content repetition: same lines delivered multiple times\n    24→- Natural breaks: long pauses, restarts, or topic shifts that indicate a new attempt\n    25→\n    26→TRANSCRIPT WITH TIMESTAMPS:\n    27→${segmentsText}\n    28→\n    29→Respond with JSON only (no markdown):\n    30→{\n    31→  \"takes\": [\n    32→    {\n    33→      \"takeNumber\": 1,\n    34→      \"start\": 0.00,\n    35→      \"end\": 10.50,\n    36→      \"shortLabel\": \"2-5 word summary of key events/topic (e.g. 'revenge against Randy')\",\n    37→      \"description\": \"Brief description of this take\",\n    38→      \"isBest\": false,\n    39→      \"reason\": \"Why this is/isn't the best take\"\n    40→    }\n    41→  ],\n    42→  \"analysis\": \"Brief overall analysis of the recording\"\n    43→}\n    44→\n    45→If no distinct takes are found (continuous recording), return a single take covering the full duration.`;\n    46→}\n    47→\n    48→/**\n    49→ * Format transcript segments for the prompt\n    50→ * @param {Array} segments - Transcript segments with timestamps\n    51→ * @returns {string} Formatted text\n    52→ */\n    53→function formatSegments(segments) {\n    54→  return segments\n    55→    .map(s => `[${s.start.toFixed(2)}-${s.end.toFixed(2)}] ${s.text}`)\n    56→    .join('\\n');\n    57→}\n    58→\n    59→/**\n    60→ * Create fallback response when parsing fails\n    61→ * @param {number} duration - Total duration of the recording\n    62→ * @returns {Object} Fallback takes response\n    63→ */\n    64→function createFallbackResponse(duration) {\n    65→  return {\n    66→    takes: [{\n    67→      takeNumber: 1,\n    68→      start: 0,\n    69→      end: duration || 0,\n    70→      description: 'Full recording (parsing failed)',\n    71→      isBest: true,\n    72→      reason: 'Single continuous take'\n    73→    }],\n    74→    analysis: 'Could not parse take detection response'\n    75→  };\n    76→}\n    77→\n    78→/**\n    79→ * Detect takes in a transcript using GPT-4o-mini\n    80→ * @param {Object} transcript - Transcript with segments and duration\n    81→ * @returns {Promise<{takes: Array, analysis: string}>}\n    82→ */\n    83→async function detectTakes(transcript) {\n    84→  console.log('[SPLICE] Starting GPT-4o-mini take detection...');\n    85→\n    86→  const segmentsText = formatSegments(transcript.segments);\n    87→  const prompt = buildPrompt(segmentsText);\n    88→\n    89→  const response = await openai.chat.completions.create({\n    90→    model: 'gpt-4o-mini',\n    91→    messages: [{ role: 'user', content: prompt }],\n    92→    temperature: 0.3,\n    93→  });\n    94→\n    95→  const content = response.choices?.[0]?.message?.content;\n    96→  if (!content) {\n    97→    console.error('[SPLICE] No response from AI service');\n    98→    return createFallbackResponse(transcript.duration);\n    99→  }\n   100→  console.log('[SPLICE] Take detection complete');\n   101→\n   102→  try {\n   103→    return JSON.parse(content);\n   104→  } catch {\n   105→    console.error('[SPLICE] Failed to parse GPT response:', content);\n   106→    return createFallbackResponse(transcript.duration);\n   107→  }\n   108→}\n   109→\n   110→module.exports = { detectTakes };\n   111→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f74488d8-ad69-442d-aba1-d2dd2a65ce3a","timestamp":"2025-12-27T01:35:06.565Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/takeDetection.js","content":"/**\n * Slice 5: GPT-4o-mini Take Detection Service\n *\n * Analyzes transcripts to identify distinct takes (repeated attempts).\n * Uses GPT-4o-mini for intelligent content analysis.\n */\n\nconst OpenAI = require('openai');\n\n// Initialize OpenAI client\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\n/**\n * Build the take detection prompt\n * @param {string} segmentsText - Formatted transcript segments\n * @returns {string} The prompt for GPT\n */\nfunction buildPrompt(segmentsText) {\n  return `Analyze this video transcript and identify distinct \"takes\" (repeated attempts at the same content).\n\nLook for:\n- Explicit markers: \"take 1\", \"take 2\", \"cut\", \"again\", \"one more time\"\n- Content repetition: same lines delivered multiple times\n- Natural breaks: long pauses, restarts, or topic shifts that indicate a new attempt\n\nTRANSCRIPT WITH TIMESTAMPS:\n${segmentsText}\n\nRespond with JSON only (no markdown):\n{\n  \"takes\": [\n    {\n      \"takeNumber\": 1,\n      \"start\": 0.00,\n      \"end\": 10.50,\n      \"shortLabel\": \"2-5 word summary of key events/topic (e.g. 'revenge against Randy')\",\n      \"description\": \"Brief description of this take\",\n      \"isBest\": false,\n      \"reason\": \"Why this is/isn't the best take\"\n    }\n  ],\n  \"analysis\": \"Brief overall analysis of the recording\"\n}\n\nIf no distinct takes are found (continuous recording), return a single take covering the full duration.`;\n}\n\n/**\n * Format transcript segments for the prompt\n * @param {Array} segments - Transcript segments with timestamps\n * @returns {string} Formatted text\n */\nfunction formatSegments(segments) {\n  return segments\n    .map(s => `[${s.start.toFixed(2)}-${s.end.toFixed(2)}] ${s.text}`)\n    .join('\\n');\n}\n\n/**\n * Create fallback response when parsing fails\n * @param {number} duration - Total duration of the recording\n * @returns {Object} Fallback takes response\n */\nfunction createFallbackResponse(duration) {\n  return {\n    takes: [{\n      takeNumber: 1,\n      start: 0,\n      end: duration || 0,\n      description: 'Full recording (parsing failed)',\n      isBest: true,\n      reason: 'Single continuous take'\n    }],\n    analysis: 'Could not parse take detection response'\n  };\n}\n\n/**\n * Detect takes in a transcript using GPT-4o-mini\n * @param {Object} transcript - Transcript with segments and duration\n * @returns {Promise<{takes: Array, analysis: string}>}\n */\nasync function detectTakes(transcript) {\n  console.log('[SPLICE] Starting GPT-4o-mini take detection...');\n\n  const segmentsText = formatSegments(transcript.segments);\n  const prompt = buildPrompt(segmentsText);\n\n  const response = await openai.chat.completions.create({\n    model: 'gpt-4o-mini',\n    messages: [{ role: 'user', content: prompt }],\n    temperature: 0.3,\n  });\n\n  const content = response.choices?.[0]?.message?.content;\n  if (!content) {\n    console.error('[SPLICE] No response from AI service');\n    return createFallbackResponse(transcript.duration);\n  }\n  console.log('[SPLICE] Take detection complete');\n\n  try {\n    return JSON.parse(content);\n  } catch {\n    console.error('[SPLICE] Failed to parse GPT response:', content);\n    return createFallbackResponse(transcript.duration);\n  }\n}\n\nmodule.exports = { detectTakes };\n","numLines":111,"startLine":1,"totalLines":111}}}
{"parentUuid":"f74488d8-ad69-442d-aba1-d2dd2a65ce3a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QkPhPHZ2qKUbyHaZx71GiD","type":"tool_result","content":"     1→/**\n     2→ * Vocal Isolation Service\n     3→ *\n     4→ * Uses Replicate's Demucs model to separate vocals from audio.\n     5→ * Cost: ~$0.015/min\n     6→ *\n     7→ * Workflow:\n     8→ * 1. Upload audio to temporary URL (or use file path)\n     9→ * 2. Call Replicate Demucs API\n    10→ * 3. Download isolated vocals track\n    11→ * 4. Return path to clean vocals file\n    12→ */\n    13→\n    14→const fs = require('fs');\n    15→const path = require('path');\n    16→const https = require('https');\n    17→const http = require('http');\n    18→\n    19→// Replicate API configuration\n    20→const REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;\n    21→const DEMUCS_MODEL = 'cjwbw/demucs:25a173108cff36ef9f80f854c162d01df9e6528be175794b81158fa03836d953';\n    22→\n    23→/**\n    24→ * Isolate vocals from an audio file using Demucs via Replicate\n    25→ *\n    26→ * @param {string} audioPath - Path to input audio file\n    27→ * @param {Object} options - Configuration options\n    28→ * @param {string} options.outputDir - Directory for output (default: same as input)\n    29→ * @param {string} options.stem - Which stem to extract: 'vocals', 'drums', 'bass', 'other' (default: 'vocals')\n    30→ * @returns {Promise<Object>} Result with path to isolated vocals\n    31→ */\n    32→async function isolateVocals(audioPath, options = {}) {\n    33→  const { outputDir = path.dirname(audioPath), stem = 'vocals' } = options;\n    34→\n    35→  if (!REPLICATE_API_TOKEN) {\n    36→    throw new Error('REPLICATE_API_TOKEN environment variable is required');\n    37→  }\n    38→\n    39→  if (!fs.existsSync(audioPath)) {\n    40→    throw new Error(`Audio file not found: ${audioPath}`);\n    41→  }\n    42→\n    43→  console.log(`[VocalIsolation] Starting isolation for: ${audioPath}`);\n    44→  const startTime = Date.now();\n    45→\n    46→  // Read audio file and convert to base64 data URI (async to avoid blocking)\n    47→  const audioBuffer = await fs.promises.readFile(audioPath);\n    48→  const base64Audio = audioBuffer.toString('base64');\n    49→  const mimeType = getMimeType(audioPath);\n    50→  const dataUri = `data:${mimeType};base64,${base64Audio}`;\n    51→\n    52→  // Create prediction on Replicate\n    53→  const prediction = await createPrediction(dataUri);\n    54→  console.log(`[VocalIsolation] Prediction created: ${prediction.id}`);\n    55→\n    56→  // Poll for completion\n    57→  const result = await pollPrediction(prediction.id);\n    58→\n    59→  if (result.status === 'failed') {\n    60→    throw new Error(`Vocal isolation failed: ${result.error || 'Unknown error'}`);\n    61→  }\n    62→\n    63→  // Download the requested stem\n    64→  const stemUrl = result.output[stem];\n    65→  if (!stemUrl) {\n    66→    throw new Error(`Stem '${stem}' not found in output. Available: ${Object.keys(result.output).join(', ')}`);\n    67→  }\n    68→\n    69→  // Generate output filename\n    70→  const inputBasename = path.basename(audioPath, path.extname(audioPath));\n    71→  const outputFilename = `${inputBasename}_${stem}.wav`;\n    72→  const outputPath = path.join(outputDir, outputFilename);\n    73→\n    74→  // Download the isolated track\n    75→  await downloadFile(stemUrl, outputPath);\n    76→\n    77→  const duration = ((Date.now() - startTime) / 1000).toFixed(1);\n    78→  console.log(`[VocalIsolation] Complete in ${duration}s: ${outputPath}`);\n    79→\n    80→  return {\n    81→    success: true,\n    82→    inputPath: audioPath,\n    83→    outputPath,\n    84→    stem,\n    85→    processingTime: parseFloat(duration),\n    86→    allStems: Object.keys(result.output)\n    87→  };\n    88→}\n    89→\n    90→/**\n    91→ * Create a prediction on Replicate\n    92→ */\n    93→async function createPrediction(audioDataUri) {\n    94→  const requestBody = JSON.stringify({\n    95→    version: DEMUCS_MODEL.split(':')[1],\n    96→    input: {\n    97→      audio: audioDataUri,\n    98→      output_format: 'wav'\n    99→    }\n   100→  });\n   101→\n   102→  return new Promise((resolve, reject) => {\n   103→    const req = https.request({\n   104→      hostname: 'api.replicate.com',\n   105→      path: '/v1/predictions',\n   106→      method: 'POST',\n   107→      headers: {\n   108→        'Authorization': `Bearer ${REPLICATE_API_TOKEN}`,\n   109→        'Content-Type': 'application/json',\n   110→        'Content-Length': Buffer.byteLength(requestBody)\n   111→      }\n   112→    }, (res) => {\n   113→      let data = '';\n   114→      res.on('data', chunk => data += chunk);\n   115→      res.on('end', () => {\n   116→        try {\n   117→          const parsed = JSON.parse(data);\n   118→          if (res.statusCode >= 400) {\n   119→            reject(new Error(`Replicate API error: ${parsed.detail || data}`));\n   120→          } else {\n   121→            resolve(parsed);\n   122→          }\n   123→        } catch {\n   124→          reject(new Error(`Failed to parse Replicate response: ${data}`));\n   125→        }\n   126→      });\n   127→    });\n   128→\n   129→    req.on('error', reject);\n   130→    req.write(requestBody);\n   131→    req.end();\n   132→  });\n   133→}\n   134→\n   135→/**\n   136→ * Poll prediction status until complete\n   137→ */\n   138→async function pollPrediction(predictionId, maxWaitMs = 300000) {\n   139→  const startTime = Date.now();\n   140→  const pollInterval = 2000; // 2 seconds\n   141→\n   142→  while (Date.now() - startTime < maxWaitMs) {\n   143→    const prediction = await getPrediction(predictionId);\n   144→\n   145→    if (prediction.status === 'succeeded') {\n   146→      return prediction;\n   147→    }\n   148→\n   149→    if (prediction.status === 'failed' || prediction.status === 'canceled') {\n   150→      return prediction;\n   151→    }\n   152→\n   153→    console.log(`[VocalIsolation] Status: ${prediction.status}...`);\n   154→    await sleep(pollInterval);\n   155→  }\n   156→\n   157→  throw new Error(`Prediction timed out after ${maxWaitMs / 1000}s`);\n   158→}\n   159→\n   160→/**\n   161→ * Get prediction status from Replicate\n   162→ */\n   163→async function getPrediction(predictionId) {\n   164→  return new Promise((resolve, reject) => {\n   165→    const req = https.request({\n   166→      hostname: 'api.replicate.com',\n   167→      path: `/v1/predictions/${predictionId}`,\n   168→      method: 'GET',\n   169→      headers: {\n   170→        'Authorization': `Bearer ${REPLICATE_API_TOKEN}`\n   171→      }\n   172→    }, (res) => {\n   173→      let data = '';\n   174→      res.on('data', chunk => data += chunk);\n   175→      res.on('end', () => {\n   176→        try {\n   177→          resolve(JSON.parse(data));\n   178→        } catch {\n   179→          reject(new Error(`Failed to parse prediction status: ${data}`));\n   180→        }\n   181→      });\n   182→    });\n   183→\n   184→    req.on('error', reject);\n   185→    req.end();\n   186→  });\n   187→}\n   188→\n   189→/**\n   190→ * Safely remove a file, ignoring errors if file doesn't exist\n   191→ */\n   192→function safeUnlink(filePath) {\n   193→  try {\n   194→    fs.unlinkSync(filePath);\n   195→  } catch (err) {\n   196→    // Ignore ENOENT (file not found) - file may not exist yet or already deleted\n   197→    if (err.code !== 'ENOENT') {\n   198→      console.warn(`[VocalIsolation] Warning: Failed to delete ${filePath}: ${err.message}`);\n   199→    }\n   200→  }\n   201→}\n   202→\n   203→/**\n   204→ * Download a file from URL to local path\n   205→ */\n   206→async function downloadFile(url, outputPath) {\n   207→  return new Promise((resolve, reject) => {\n   208→    const file = fs.createWriteStream(outputPath);\n   209→    const protocol = url.startsWith('https') ? https : http;\n   210→\n   211→    protocol.get(url, (response) => {\n   212→      // Handle redirects\n   213→      if (response.statusCode === 301 || response.statusCode === 302) {\n   214→        file.close();\n   215→        safeUnlink(outputPath);\n   216→        return downloadFile(response.headers.location, outputPath)\n   217→          .then(resolve)\n   218→          .catch(reject);\n   219→      }\n   220→\n   221→      if (response.statusCode !== 200) {\n   222→        file.close();\n   223→        safeUnlink(outputPath);\n   224→        reject(new Error(`Failed to download: HTTP ${response.statusCode}`));\n   225→        return;\n   226→      }\n   227→\n   228→      response.pipe(file);\n   229→      file.on('finish', () => {\n   230→        file.close();\n   231→        resolve();\n   232→      });\n   233→    }).on('error', (err) => {\n   234→      file.close();\n   235→      safeUnlink(outputPath);\n   236→      reject(err);\n   237→    });\n   238→  });\n   239→}\n   240→\n   241→/**\n   242→ * Get MIME type from file extension\n   243→ */\n   244→function getMimeType(filePath) {\n   245→  const ext = path.extname(filePath).toLowerCase();\n   246→  const mimeTypes = {\n   247→    '.wav': 'audio/wav',\n   248→    '.mp3': 'audio/mpeg',\n   249→    '.m4a': 'audio/mp4',\n   250→    '.flac': 'audio/flac',\n   251→    '.ogg': 'audio/ogg',\n   252→    '.aac': 'audio/aac'\n   253→  };\n   254→  return mimeTypes[ext] || 'audio/wav';\n   255→}\n   256→\n   257→/**\n   258→ * Sleep utility\n   259→ */\n   260→function sleep(ms) {\n   261→  return new Promise(resolve => global.setTimeout(resolve, ms));\n   262→}\n   263→\n   264→/**\n   265→ * Check if Replicate API token is configured\n   266→ */\n   267→function isReplicateConfigured() {\n   268→  return !!REPLICATE_API_TOKEN;\n   269→}\n   270→\n   271→module.exports = {\n   272→  isolateVocals,\n   273→  isReplicateConfigured\n   274→};\n   275→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"40fdec44-37af-4770-bf39-9e57995db28e","timestamp":"2025-12-27T01:35:06.566Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/vocalIsolation.js","content":"/**\n * Vocal Isolation Service\n *\n * Uses Replicate's Demucs model to separate vocals from audio.\n * Cost: ~$0.015/min\n *\n * Workflow:\n * 1. Upload audio to temporary URL (or use file path)\n * 2. Call Replicate Demucs API\n * 3. Download isolated vocals track\n * 4. Return path to clean vocals file\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst https = require('https');\nconst http = require('http');\n\n// Replicate API configuration\nconst REPLICATE_API_TOKEN = process.env.REPLICATE_API_TOKEN;\nconst DEMUCS_MODEL = 'cjwbw/demucs:25a173108cff36ef9f80f854c162d01df9e6528be175794b81158fa03836d953';\n\n/**\n * Isolate vocals from an audio file using Demucs via Replicate\n *\n * @param {string} audioPath - Path to input audio file\n * @param {Object} options - Configuration options\n * @param {string} options.outputDir - Directory for output (default: same as input)\n * @param {string} options.stem - Which stem to extract: 'vocals', 'drums', 'bass', 'other' (default: 'vocals')\n * @returns {Promise<Object>} Result with path to isolated vocals\n */\nasync function isolateVocals(audioPath, options = {}) {\n  const { outputDir = path.dirname(audioPath), stem = 'vocals' } = options;\n\n  if (!REPLICATE_API_TOKEN) {\n    throw new Error('REPLICATE_API_TOKEN environment variable is required');\n  }\n\n  if (!fs.existsSync(audioPath)) {\n    throw new Error(`Audio file not found: ${audioPath}`);\n  }\n\n  console.log(`[VocalIsolation] Starting isolation for: ${audioPath}`);\n  const startTime = Date.now();\n\n  // Read audio file and convert to base64 data URI (async to avoid blocking)\n  const audioBuffer = await fs.promises.readFile(audioPath);\n  const base64Audio = audioBuffer.toString('base64');\n  const mimeType = getMimeType(audioPath);\n  const dataUri = `data:${mimeType};base64,${base64Audio}`;\n\n  // Create prediction on Replicate\n  const prediction = await createPrediction(dataUri);\n  console.log(`[VocalIsolation] Prediction created: ${prediction.id}`);\n\n  // Poll for completion\n  const result = await pollPrediction(prediction.id);\n\n  if (result.status === 'failed') {\n    throw new Error(`Vocal isolation failed: ${result.error || 'Unknown error'}`);\n  }\n\n  // Download the requested stem\n  const stemUrl = result.output[stem];\n  if (!stemUrl) {\n    throw new Error(`Stem '${stem}' not found in output. Available: ${Object.keys(result.output).join(', ')}`);\n  }\n\n  // Generate output filename\n  const inputBasename = path.basename(audioPath, path.extname(audioPath));\n  const outputFilename = `${inputBasename}_${stem}.wav`;\n  const outputPath = path.join(outputDir, outputFilename);\n\n  // Download the isolated track\n  await downloadFile(stemUrl, outputPath);\n\n  const duration = ((Date.now() - startTime) / 1000).toFixed(1);\n  console.log(`[VocalIsolation] Complete in ${duration}s: ${outputPath}`);\n\n  return {\n    success: true,\n    inputPath: audioPath,\n    outputPath,\n    stem,\n    processingTime: parseFloat(duration),\n    allStems: Object.keys(result.output)\n  };\n}\n\n/**\n * Create a prediction on Replicate\n */\nasync function createPrediction(audioDataUri) {\n  const requestBody = JSON.stringify({\n    version: DEMUCS_MODEL.split(':')[1],\n    input: {\n      audio: audioDataUri,\n      output_format: 'wav'\n    }\n  });\n\n  return new Promise((resolve, reject) => {\n    const req = https.request({\n      hostname: 'api.replicate.com',\n      path: '/v1/predictions',\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${REPLICATE_API_TOKEN}`,\n        'Content-Type': 'application/json',\n        'Content-Length': Buffer.byteLength(requestBody)\n      }\n    }, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        try {\n          const parsed = JSON.parse(data);\n          if (res.statusCode >= 400) {\n            reject(new Error(`Replicate API error: ${parsed.detail || data}`));\n          } else {\n            resolve(parsed);\n          }\n        } catch {\n          reject(new Error(`Failed to parse Replicate response: ${data}`));\n        }\n      });\n    });\n\n    req.on('error', reject);\n    req.write(requestBody);\n    req.end();\n  });\n}\n\n/**\n * Poll prediction status until complete\n */\nasync function pollPrediction(predictionId, maxWaitMs = 300000) {\n  const startTime = Date.now();\n  const pollInterval = 2000; // 2 seconds\n\n  while (Date.now() - startTime < maxWaitMs) {\n    const prediction = await getPrediction(predictionId);\n\n    if (prediction.status === 'succeeded') {\n      return prediction;\n    }\n\n    if (prediction.status === 'failed' || prediction.status === 'canceled') {\n      return prediction;\n    }\n\n    console.log(`[VocalIsolation] Status: ${prediction.status}...`);\n    await sleep(pollInterval);\n  }\n\n  throw new Error(`Prediction timed out after ${maxWaitMs / 1000}s`);\n}\n\n/**\n * Get prediction status from Replicate\n */\nasync function getPrediction(predictionId) {\n  return new Promise((resolve, reject) => {\n    const req = https.request({\n      hostname: 'api.replicate.com',\n      path: `/v1/predictions/${predictionId}`,\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${REPLICATE_API_TOKEN}`\n      }\n    }, (res) => {\n      let data = '';\n      res.on('data', chunk => data += chunk);\n      res.on('end', () => {\n        try {\n          resolve(JSON.parse(data));\n        } catch {\n          reject(new Error(`Failed to parse prediction status: ${data}`));\n        }\n      });\n    });\n\n    req.on('error', reject);\n    req.end();\n  });\n}\n\n/**\n * Safely remove a file, ignoring errors if file doesn't exist\n */\nfunction safeUnlink(filePath) {\n  try {\n    fs.unlinkSync(filePath);\n  } catch (err) {\n    // Ignore ENOENT (file not found) - file may not exist yet or already deleted\n    if (err.code !== 'ENOENT') {\n      console.warn(`[VocalIsolation] Warning: Failed to delete ${filePath}: ${err.message}`);\n    }\n  }\n}\n\n/**\n * Download a file from URL to local path\n */\nasync function downloadFile(url, outputPath) {\n  return new Promise((resolve, reject) => {\n    const file = fs.createWriteStream(outputPath);\n    const protocol = url.startsWith('https') ? https : http;\n\n    protocol.get(url, (response) => {\n      // Handle redirects\n      if (response.statusCode === 301 || response.statusCode === 302) {\n        file.close();\n        safeUnlink(outputPath);\n        return downloadFile(response.headers.location, outputPath)\n          .then(resolve)\n          .catch(reject);\n      }\n\n      if (response.statusCode !== 200) {\n        file.close();\n        safeUnlink(outputPath);\n        reject(new Error(`Failed to download: HTTP ${response.statusCode}`));\n        return;\n      }\n\n      response.pipe(file);\n      file.on('finish', () => {\n        file.close();\n        resolve();\n      });\n    }).on('error', (err) => {\n      file.close();\n      safeUnlink(outputPath);\n      reject(err);\n    });\n  });\n}\n\n/**\n * Get MIME type from file extension\n */\nfunction getMimeType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  const mimeTypes = {\n    '.wav': 'audio/wav',\n    '.mp3': 'audio/mpeg',\n    '.m4a': 'audio/mp4',\n    '.flac': 'audio/flac',\n    '.ogg': 'audio/ogg',\n    '.aac': 'audio/aac'\n  };\n  return mimeTypes[ext] || 'audio/wav';\n}\n\n/**\n * Sleep utility\n */\nfunction sleep(ms) {\n  return new Promise(resolve => global.setTimeout(resolve, ms));\n}\n\n/**\n * Check if Replicate API token is configured\n */\nfunction isReplicateConfigured() {\n  return !!REPLICATE_API_TOKEN;\n}\n\nmodule.exports = {\n  isolateVocals,\n  isReplicateConfigured\n};\n","numLines":275,"startLine":1,"totalLines":275}}}
{"parentUuid":"40fdec44-37af-4770-bf39-9e57995db28e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018zzPRutpvKxWr3QXwpWhiJ","type":"tool_result","content":"     1→/**\n     2→ * SPLICE Chapter Detection Service\n     3→ *\n     4→ * Analyzes transcripts to identify natural chapter/topic boundaries.\n     5→ * Uses GPT-4o-mini for intelligent topic segmentation.\n     6→ *\n     7→ * Features:\n     8→ * - Automatic chapter boundary detection\n     9→ * - YouTube timestamp format generation\n    10→ * - Timeline marker data for Premiere Pro\n    11→ * - Configurable chapter count and minimum length\n    12→ */\n    13→\n    14→const OpenAI = require('openai');\n    15→\n    16→// Lazy-load OpenAI client to avoid errors when API key is not set\n    17→let openai = null;\n    18→function getOpenAI() {\n    19→  if (!openai) {\n    20→    openai = new OpenAI();\n    21→  }\n    22→  return openai;\n    23→}\n    24→\n    25→/**\n    26→ * Detect chapters in a transcript using AI\n    27→ * @param {Object} transcript - Transcript with text and/or segments\n    28→ * @param {Object} settings - Detection settings\n    29→ * @returns {Promise<Object>} Detected chapters, timestamps, and markers\n    30→ */\n    31→async function detectChapters(transcript, settings = {}) {\n    32→  const {\n    33→    maxChapters = 10,\n    34→    minChapterLength = 60, // seconds\n    35→    // language = 'en', // reserved for future i18n\n    36→    titleStyle = 'standard' // 'standard', 'youtube', 'shorts'\n    37→  } = settings;\n    38→\n    39→  // Get full text from transcript\n    40→  const text = extractText(transcript);\n    41→\n    42→  if (!text || text.length < 100) {\n    43→    console.log('[SPLICE Chapters] Transcript too short for chapter detection');\n    44→    return {\n    45→      chapters: [],\n    46→      youtubeTimestamps: '',\n    47→      markers: [],\n    48→      metadata: {\n    49→        chapterCount: 0,\n    50→        reason: 'transcript_too_short'\n    51→      }\n    52→    };\n    53→  }\n    54→\n    55→  // Get duration\n    56→  const duration = transcript.duration ||\n    57→    (transcript.segments?.length > 0 ? transcript.segments[transcript.segments.length - 1].end : 0);\n    58→\n    59→  if (duration < minChapterLength * 2) {\n    60→    console.log('[SPLICE Chapters] Content too short for multiple chapters');\n    61→    return {\n    62→      chapters: [{\n    63→        startTime: 0,\n    64→        title: 'Full Video',\n    65→        description: 'Video content'\n    66→      }],\n    67→      youtubeTimestamps: '0:00 Full Video',\n    68→      markers: [{\n    69→        time: 0,\n    70→        name: 'Full Video',\n    71→        comment: 'Video content'\n    72→      }],\n    73→      metadata: {\n    74→        chapterCount: 1,\n    75→        reason: 'single_chapter'\n    76→      }\n    77→    };\n    78→  }\n    79→\n    80→  console.log(`[SPLICE Chapters] Analyzing transcript (${text.length} chars, ${Math.floor(duration)}s)`);\n    81→\n    82→  try {\n    83→    const prompt = buildChapterPrompt(text, maxChapters, minChapterLength, duration, titleStyle);\n    84→\n    85→    const response = await getOpenAI().chat.completions.create({\n    86→      model: 'gpt-4o-mini',\n    87→      messages: [\n    88→        {\n    89→          role: 'system',\n    90→          content: `You are a video chapter detection expert. Analyze transcripts to identify natural topic changes and chapter boundaries. Return structured JSON with accurate timestamps.`\n    91→        },\n    92→        {\n    93→          role: 'user',\n    94→          content: prompt\n    95→        }\n    96→      ],\n    97→      temperature: 0.3,\n    98→      max_tokens: 1000,\n    99→      response_format: { type: 'json_object' }\n   100→    });\n   101→\n   102→    const content = response.choices?.[0]?.message?.content;\n   103→    if (!content) {\n   104→      throw new Error('No response from AI service');\n   105→    }\n   106→    const result = JSON.parse(content);\n   107→    const chapters = result.chapters || result || [];\n   108→\n   109→    // Validate and clean chapters\n   110→    const validChapters = validateChapters(chapters, duration, minChapterLength);\n   111→\n   112→    // Generate YouTube timestamps\n   113→    const youtubeTimestamps = formatYouTubeTimestamps(validChapters);\n   114→\n   115→    // Generate marker data\n   116→    const markers = validChapters.map(ch => ({\n   117→      time: ch.startTime,\n   118→      name: ch.title,\n   119→      comment: ch.description || '',\n   120→      keywords: ch.keywords || []\n   121→    }));\n   122→\n   123→    console.log(`[SPLICE Chapters] Detected ${validChapters.length} chapters`);\n   124→\n   125→    return {\n   126→      chapters: validChapters,\n   127→      youtubeTimestamps,\n   128→      markers,\n   129→      metadata: {\n   130→        chapterCount: validChapters.length,\n   131→        duration,\n   132→        model: 'gpt-4o-mini',\n   133→        titleStyle\n   134→      }\n   135→    };\n   136→\n   137→  } catch (err) {\n   138→    console.error('[SPLICE Chapters] Detection error:', err);\n   139→    throw new Error(`Chapter detection failed: ${err.message}`);\n   140→  }\n   141→}\n   142→\n   143→/**\n   144→ * Extract plain text from transcript\n   145→ * @param {Object} transcript - Transcript object\n   146→ * @returns {string} Plain text\n   147→ */\n   148→function extractText(transcript) {\n   149→  if (typeof transcript === 'string') {\n   150→    return transcript;\n   151→  }\n   152→\n   153→  if (transcript.text) {\n   154→    return transcript.text;\n   155→  }\n   156→\n   157→  if (transcript.segments) {\n   158→    return transcript.segments\n   159→      .map(s => s.text || s.content || '')\n   160→      .join(' ')\n   161→      .trim();\n   162→  }\n   163→\n   164→  if (transcript.words) {\n   165→    return transcript.words\n   166→      .map(w => w.word || w.text || '')\n   167→      .join(' ')\n   168→      .trim();\n   169→  }\n   170→\n   171→  return '';\n   172→}\n   173→\n   174→/**\n   175→ * Build the prompt for chapter detection\n   176→ * @param {string} text - Transcript text\n   177→ * @param {number} maxChapters - Maximum chapters\n   178→ * @param {number} minLength - Minimum chapter length\n   179→ * @param {number} duration - Total duration\n   180→ * @param {string} titleStyle - Title style: 'standard', 'youtube', 'shorts'\n   181→ * @returns {string} Formatted prompt\n   182→ */\n   183→function buildChapterPrompt(text, maxChapters, minLength, duration, titleStyle = 'standard') {\n   184→  // Truncate text if too long (keep first 15000 chars)\n   185→  const truncatedText = text.length > 15000 ? text.substring(0, 15000) + '...' : text;\n   186→\n   187→  // Get title style rules based on format\n   188→  let titleRules = '';\n   189→  switch (titleStyle) {\n   190→    case 'youtube':\n   191→      titleRules = `TITLE STYLE (YouTube Long-Form):\n   192→- Create engaging, SEO-optimized titles (5-8 words max)\n   193→- Use keywords that viewers might search for\n   194→- Make titles compelling and clickable\n   195→- Include relevant topic keywords\n   196→- Avoid clickbait but be interesting\n   197→- Example: \"Setting Up Your Development Environment\"`;\n   198→      break;\n   199→    case 'shorts':\n   200→      titleRules = `TITLE STYLE (YouTube Shorts/TikTok):\n   201→- Create punchy, hook-style titles (3-5 words max)\n   202→- Use action words and emotional triggers\n   203→- Make it scroll-stopping and urgent\n   204→- Keep it ultra-concise for mobile\n   205→- Example: \"This Changes Everything\" or \"Wait For It...\"`;\n   206→      break;\n   207→    default:\n   208→      titleRules = `TITLE STYLE:\n   209→- Create short, descriptive titles (3-5 words max)\n   210→- Focus on the main topic of each section\n   211→- Be clear and informative`;\n   212→  }\n   213→\n   214→  return `Analyze this transcript and identify natural chapter breaks.\n   215→\n   216→RULES:\n   217→- Maximum ${maxChapters} chapters\n   218→- Minimum ${minLength} seconds between chapters\n   219→- First chapter MUST start at 0 seconds\n   220→- Total video duration is ${Math.floor(duration)} seconds\n   221→- Identify topic/subject changes\n   222→\n   223→${titleRules}\n   224→\n   225→TRANSCRIPT:\n   226→${truncatedText}\n   227→\n   228→Return JSON in this exact format:\n   229→{\n   230→  \"chapters\": [\n   231→    {\n   232→      \"startTime\": 0,\n   233→      \"title\": \"Introduction\",\n   234→      \"description\": \"Brief description of this chapter\",\n   235→      \"keywords\": [\"keyword1\", \"keyword2\"]\n   236→    },\n   237→    {\n   238→      \"startTime\": 120,\n   239→      \"title\": \"Main Topic\",\n   240→      \"description\": \"Description of what happens\",\n   241→      \"keywords\": [\"topic\", \"subject\"]\n   242→    }\n   243→  ]\n   244→}\n   245→\n   246→IMPORTANT:\n   247→- startTime values must be in SECONDS as numbers, not strings.\n   248→- Include 2-3 relevant keywords for each chapter for SEO.`;\n   249→}\n   250→\n   251→/**\n   252→ * Validate and clean detected chapters\n   253→ * @param {Array} chapters - Raw chapters from AI\n   254→ * @param {number} duration - Total duration\n   255→ * @param {number} minLength - Minimum chapter length\n   256→ * @returns {Array} Validated chapters\n   257→ */\n   258→function validateChapters(chapters, duration, minLength) {\n   259→  if (!Array.isArray(chapters)) {\n   260→    return [{\n   261→      startTime: 0,\n   262→      title: 'Video',\n   263→      description: 'Full video content'\n   264→    }];\n   265→  }\n   266→\n   267→  const validChapters = [];\n   268→  let lastTime = -minLength;\n   269→\n   270→  // Sort by start time\n   271→  const sorted = [...chapters].sort((a, b) => {\n   272→    const aTime = parseFloat(a.startTime) || 0;\n   273→    const bTime = parseFloat(b.startTime) || 0;\n   274→    return aTime - bTime;\n   275→  });\n   276→\n   277→  for (const chapter of sorted) {\n   278→    const startTime = parseFloat(chapter.startTime) || 0;\n   279→\n   280→    // Skip if too close to last chapter\n   281→    if (startTime - lastTime < minLength && validChapters.length > 0) {\n   282→      continue;\n   283→    }\n   284→\n   285→    // Skip if past duration\n   286→    if (startTime >= duration) {\n   287→      continue;\n   288→    }\n   289→\n   290→    // Ensure title exists\n   291→    const title = (chapter.title || 'Chapter ' + (validChapters.length + 1)).substring(0, 50);\n   292→    const description = (chapter.description || '').substring(0, 200);\n   293→\n   294→    // Preserve keywords if provided by AI\n   295→    const keywords = Array.isArray(chapter.keywords) ? chapter.keywords.slice(0, 5) : [];\n   296→\n   297→    validChapters.push({\n   298→      startTime: parseFloat(startTime.toFixed(2)),\n   299→      title,\n   300→      description,\n   301→      keywords\n   302→    });\n   303→\n   304→    lastTime = startTime;\n   305→  }\n   306→\n   307→  // Ensure first chapter starts at 0\n   308→  if (validChapters.length > 0 && validChapters[0].startTime > 0) {\n   309→    validChapters.unshift({\n   310→      startTime: 0,\n   311→      title: 'Introduction',\n   312→      description: 'Video introduction'\n   313→    });\n   314→  }\n   315→\n   316→  // Ensure at least one chapter\n   317→  if (validChapters.length === 0) {\n   318→    validChapters.push({\n   319→      startTime: 0,\n   320→      title: 'Video',\n   321→      description: 'Full video content'\n   322→    });\n   323→  }\n   324→\n   325→  return validChapters;\n   326→}\n   327→\n   328→/**\n   329→ * Format chapters as YouTube timestamps\n   330→ * @param {Array} chapters - Array of chapter objects\n   331→ * @returns {string} YouTube-formatted timestamp string\n   332→ */\n   333→function formatYouTubeTimestamps(chapters) {\n   334→  return chapters.map(ch => {\n   335→    const totalSeconds = Math.floor(ch.startTime);\n   336→    const hours = Math.floor(totalSeconds / 3600);\n   337→    const minutes = Math.floor((totalSeconds % 3600) / 60);\n   338→    const seconds = totalSeconds % 60;\n   339→\n   340→    let time;\n   341→    if (hours > 0) {\n   342→      time = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n   343→    } else {\n   344→      time = `${minutes}:${seconds.toString().padStart(2, '0')}`;\n   345→    }\n   346→\n   347→    return `${time} ${ch.title}`;\n   348→  }).join('\\n');\n   349→}\n   350→\n   351→/**\n   352→ * Detect chapters from segments (fallback without AI)\n   353→ * Uses silence gaps and segment boundaries\n   354→ * @param {Object} transcript - Transcript with segments\n   355→ * @param {Object} settings - Detection settings\n   356→ * @returns {Object} Detected chapters\n   357→ */\n   358→function detectChaptersFallback(transcript, settings = {}) {\n   359→  const {\n   360→    minChapterLength = 120,\n   361→    gapThreshold = 3 // seconds of silence to consider chapter break\n   362→  } = settings;\n   363→\n   364→  const segments = transcript.segments || [];\n   365→  if (segments.length === 0) {\n   366→    return {\n   367→      chapters: [{ startTime: 0, title: 'Video', description: '' }],\n   368→      youtubeTimestamps: '0:00 Video',\n   369→      markers: [{ time: 0, name: 'Video', comment: '' }],\n   370→      metadata: { chapterCount: 1, method: 'fallback' }\n   371→    };\n   372→  }\n   373→\n   374→  const chapters = [{ startTime: 0, title: 'Chapter 1', description: '' }];\n   375→  let chapterNum = 2;\n   376→  let lastEnd = 0;\n   377→  let lastChapterTime = 0;\n   378→\n   379→  for (const segment of segments) {\n   380→    const gap = segment.start - lastEnd;\n   381→\n   382→    // Large gap indicates potential chapter break\n   383→    if (gap >= gapThreshold && segment.start - lastChapterTime >= minChapterLength) {\n   384→      chapters.push({\n   385→        startTime: parseFloat(segment.start.toFixed(2)),\n   386→        title: `Chapter ${chapterNum}`,\n   387→        description: ''\n   388→      });\n   389→      chapterNum++;\n   390→      lastChapterTime = segment.start;\n   391→    }\n   392→\n   393→    lastEnd = segment.end;\n   394→  }\n   395→\n   396→  return {\n   397→    chapters,\n   398→    youtubeTimestamps: formatYouTubeTimestamps(chapters),\n   399→    markers: chapters.map(ch => ({\n   400→      time: ch.startTime,\n   401→      name: ch.title,\n   402→      comment: ch.description\n   403→    })),\n   404→    metadata: {\n   405→      chapterCount: chapters.length,\n   406→      method: 'fallback'\n   407→    }\n   408→  };\n   409→}\n   410→\n   411→/**\n   412→ * Generate chapter divider data for timeline insertion\n   413→ * Creates divider clips with text, colors, and animation data\n   414→ * @param {Array} chapters - Array of chapter objects\n   415→ * @param {Object} settings - Divider settings\n   416→ * @returns {Object} Divider data for builder insertion\n   417→ */\n   418→function generateChapterDividers(chapters, settings = {}) {\n   419→  const {\n   420→    duration = 3, // seconds per divider\n   421→    style = 'gradient', // 'gradient', 'solid', 'minimal'\n   422→    colorScheme = 'blue', // 'blue', 'purple', 'green', 'orange', 'custom'\n   423→    fadeIn = 0.5,\n   424→    fadeOut = 0.5,\n   425→    fontSize = 72,\n   426→    fontFamily = 'Arial',\n   427→    position = 'center', // 'center', 'lower-third', 'top'\n   428→    includeChapterNumber = true,\n   429→    customColors = null\n   430→  } = settings;\n   431→\n   432→  // Color schemes for gradients\n   433→  const colorSchemes = {\n   434→    blue: { start: '#1e3a8a', end: '#3b82f6', text: '#ffffff' },\n   435→    purple: { start: '#581c87', end: '#a855f7', text: '#ffffff' },\n   436→    green: { start: '#14532d', end: '#22c55e', text: '#ffffff' },\n   437→    orange: { start: '#7c2d12', end: '#f97316', text: '#ffffff' },\n   438→    red: { start: '#7f1d1d', end: '#ef4444', text: '#ffffff' },\n   439→    custom: customColors || { start: '#000000', end: '#333333', text: '#ffffff' }\n   440→  };\n   441→\n   442→  const colors = colorSchemes[colorScheme] || colorSchemes.blue;\n   443→\n   444→  // Position presets (as percentages)\n   445→  const positions = {\n   446→    'center': { x: 50, y: 50 },\n   447→    'lower-third': { x: 50, y: 80 },\n   448→    'top': { x: 50, y: 20 }\n   449→  };\n   450→\n   451→  const pos = positions[position] || positions.center;\n   452→\n   453→  const dividers = chapters.map((chapter, index) => {\n   454→    const chapterNum = index + 1;\n   455→    const displayTitle = includeChapterNumber\n   456→      ? `Chapter ${chapterNum}: ${chapter.title}`\n   457→      : chapter.title;\n   458→\n   459→    return {\n   460→      // Timing\n   461→      insertTime: chapter.startTime,\n   462→      duration: duration,\n   463→      fadeIn: fadeIn,\n   464→      fadeOut: fadeOut,\n   465→\n   466→      // Content\n   467→      chapterNumber: chapterNum,\n   468→      title: chapter.title,\n   469→      displayTitle: displayTitle,\n   470→      description: chapter.description || '',\n   471→      keywords: chapter.keywords || [],\n   472→\n   473→      // Styling\n   474→      style: style,\n   475→      colors: {\n   476→        background: colors.start,\n   477→        backgroundEnd: colors.end,\n   478→        text: colors.text\n   479→      },\n   480→\n   481→      // Text properties\n   482→      font: {\n   483→        family: fontFamily,\n   484→        size: fontSize,\n   485→        weight: 'bold'\n   486→      },\n   487→\n   488→      // Position (percentages)\n   489→      position: {\n   490→        x: pos.x,\n   491→        y: pos.y\n   492→      },\n   493→\n   494→      // Animation\n   495→      animation: {\n   496→        type: 'fade',\n   497→        easeIn: 'ease-out',\n   498→        easeOut: 'ease-in'\n   499→      },\n   500→\n   501→      // Marker for Premiere Pro\n   502→      markerData: {\n   503→        time: chapter.startTime,\n   504→        name: `SPLICE: ${displayTitle}`,\n   505→        comment: `Chapter divider - ${chapter.description || 'No description'}`,\n   506→        colorIndex: 5 // Cerulean\n   507→      }\n   508→    };\n   509→  });\n   510→\n   511→  return {\n   512→    dividers,\n   513→    settings: {\n   514→      duration,\n   515→      style,\n   516→      colorScheme,\n   517→      position,\n   518→      fadeIn,\n   519→      fadeOut\n   520→    },\n   521→    metadata: {\n   522→      count: dividers.length,\n   523→      totalDuration: dividers.length * duration\n   524→    }\n   525→  };\n   526→}\n   527→\n   528→/**\n   529→ * Get available divider styles and color schemes\n   530→ * @returns {Object} Available options\n   531→ */\n   532→function getDividerPresets() {\n   533→  return {\n   534→    styles: [\n   535→      { id: 'gradient', name: 'Gradient', description: 'Smooth color gradient background' },\n   536→      { id: 'solid', name: 'Solid', description: 'Single color background' },\n   537→      { id: 'minimal', name: 'Minimal', description: 'Text only with subtle shadow' }\n   538→    ],\n   539→    colorSchemes: [\n   540→      { id: 'blue', name: 'Blue', colors: { start: '#1e3a8a', end: '#3b82f6' } },\n   541→      { id: 'purple', name: 'Purple', colors: { start: '#581c87', end: '#a855f7' } },\n   542→      { id: 'green', name: 'Green', colors: { start: '#14532d', end: '#22c55e' } },\n   543→      { id: 'orange', name: 'Orange', colors: { start: '#7c2d12', end: '#f97316' } },\n   544→      { id: 'red', name: 'Red', colors: { start: '#7f1d1d', end: '#ef4444' } }\n   545→    ],\n   546→    positions: [\n   547→      { id: 'center', name: 'Center', y: 50 },\n   548→      { id: 'lower-third', name: 'Lower Third', y: 80 },\n   549→      { id: 'top', name: 'Top', y: 20 }\n   550→    ],\n   551→    defaults: {\n   552→      duration: 3,\n   553→      fadeIn: 0.5,\n   554→      fadeOut: 0.5,\n   555→      fontSize: 72,\n   556→      style: 'gradient',\n   557→      colorScheme: 'blue',\n   558→      position: 'center'\n   559→    }\n   560→  };\n   561→}\n   562→\n   563→module.exports = {\n   564→  detectChapters,\n   565→  detectChaptersFallback,\n   566→  formatYouTubeTimestamps,\n   567→  extractText,\n   568→  validateChapters,\n   569→  generateChapterDividers,\n   570→  getDividerPresets\n   571→};\n   572→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1cb24607-24e1-4c38-85d9-c5c710649da1","timestamp":"2025-12-27T01:35:06.566Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/chapterDetection.js","content":"/**\n * SPLICE Chapter Detection Service\n *\n * Analyzes transcripts to identify natural chapter/topic boundaries.\n * Uses GPT-4o-mini for intelligent topic segmentation.\n *\n * Features:\n * - Automatic chapter boundary detection\n * - YouTube timestamp format generation\n * - Timeline marker data for Premiere Pro\n * - Configurable chapter count and minimum length\n */\n\nconst OpenAI = require('openai');\n\n// Lazy-load OpenAI client to avoid errors when API key is not set\nlet openai = null;\nfunction getOpenAI() {\n  if (!openai) {\n    openai = new OpenAI();\n  }\n  return openai;\n}\n\n/**\n * Detect chapters in a transcript using AI\n * @param {Object} transcript - Transcript with text and/or segments\n * @param {Object} settings - Detection settings\n * @returns {Promise<Object>} Detected chapters, timestamps, and markers\n */\nasync function detectChapters(transcript, settings = {}) {\n  const {\n    maxChapters = 10,\n    minChapterLength = 60, // seconds\n    // language = 'en', // reserved for future i18n\n    titleStyle = 'standard' // 'standard', 'youtube', 'shorts'\n  } = settings;\n\n  // Get full text from transcript\n  const text = extractText(transcript);\n\n  if (!text || text.length < 100) {\n    console.log('[SPLICE Chapters] Transcript too short for chapter detection');\n    return {\n      chapters: [],\n      youtubeTimestamps: '',\n      markers: [],\n      metadata: {\n        chapterCount: 0,\n        reason: 'transcript_too_short'\n      }\n    };\n  }\n\n  // Get duration\n  const duration = transcript.duration ||\n    (transcript.segments?.length > 0 ? transcript.segments[transcript.segments.length - 1].end : 0);\n\n  if (duration < minChapterLength * 2) {\n    console.log('[SPLICE Chapters] Content too short for multiple chapters');\n    return {\n      chapters: [{\n        startTime: 0,\n        title: 'Full Video',\n        description: 'Video content'\n      }],\n      youtubeTimestamps: '0:00 Full Video',\n      markers: [{\n        time: 0,\n        name: 'Full Video',\n        comment: 'Video content'\n      }],\n      metadata: {\n        chapterCount: 1,\n        reason: 'single_chapter'\n      }\n    };\n  }\n\n  console.log(`[SPLICE Chapters] Analyzing transcript (${text.length} chars, ${Math.floor(duration)}s)`);\n\n  try {\n    const prompt = buildChapterPrompt(text, maxChapters, minChapterLength, duration, titleStyle);\n\n    const response = await getOpenAI().chat.completions.create({\n      model: 'gpt-4o-mini',\n      messages: [\n        {\n          role: 'system',\n          content: `You are a video chapter detection expert. Analyze transcripts to identify natural topic changes and chapter boundaries. Return structured JSON with accurate timestamps.`\n        },\n        {\n          role: 'user',\n          content: prompt\n        }\n      ],\n      temperature: 0.3,\n      max_tokens: 1000,\n      response_format: { type: 'json_object' }\n    });\n\n    const content = response.choices?.[0]?.message?.content;\n    if (!content) {\n      throw new Error('No response from AI service');\n    }\n    const result = JSON.parse(content);\n    const chapters = result.chapters || result || [];\n\n    // Validate and clean chapters\n    const validChapters = validateChapters(chapters, duration, minChapterLength);\n\n    // Generate YouTube timestamps\n    const youtubeTimestamps = formatYouTubeTimestamps(validChapters);\n\n    // Generate marker data\n    const markers = validChapters.map(ch => ({\n      time: ch.startTime,\n      name: ch.title,\n      comment: ch.description || '',\n      keywords: ch.keywords || []\n    }));\n\n    console.log(`[SPLICE Chapters] Detected ${validChapters.length} chapters`);\n\n    return {\n      chapters: validChapters,\n      youtubeTimestamps,\n      markers,\n      metadata: {\n        chapterCount: validChapters.length,\n        duration,\n        model: 'gpt-4o-mini',\n        titleStyle\n      }\n    };\n\n  } catch (err) {\n    console.error('[SPLICE Chapters] Detection error:', err);\n    throw new Error(`Chapter detection failed: ${err.message}`);\n  }\n}\n\n/**\n * Extract plain text from transcript\n * @param {Object} transcript - Transcript object\n * @returns {string} Plain text\n */\nfunction extractText(transcript) {\n  if (typeof transcript === 'string') {\n    return transcript;\n  }\n\n  if (transcript.text) {\n    return transcript.text;\n  }\n\n  if (transcript.segments) {\n    return transcript.segments\n      .map(s => s.text || s.content || '')\n      .join(' ')\n      .trim();\n  }\n\n  if (transcript.words) {\n    return transcript.words\n      .map(w => w.word || w.text || '')\n      .join(' ')\n      .trim();\n  }\n\n  return '';\n}\n\n/**\n * Build the prompt for chapter detection\n * @param {string} text - Transcript text\n * @param {number} maxChapters - Maximum chapters\n * @param {number} minLength - Minimum chapter length\n * @param {number} duration - Total duration\n * @param {string} titleStyle - Title style: 'standard', 'youtube', 'shorts'\n * @returns {string} Formatted prompt\n */\nfunction buildChapterPrompt(text, maxChapters, minLength, duration, titleStyle = 'standard') {\n  // Truncate text if too long (keep first 15000 chars)\n  const truncatedText = text.length > 15000 ? text.substring(0, 15000) + '...' : text;\n\n  // Get title style rules based on format\n  let titleRules = '';\n  switch (titleStyle) {\n    case 'youtube':\n      titleRules = `TITLE STYLE (YouTube Long-Form):\n- Create engaging, SEO-optimized titles (5-8 words max)\n- Use keywords that viewers might search for\n- Make titles compelling and clickable\n- Include relevant topic keywords\n- Avoid clickbait but be interesting\n- Example: \"Setting Up Your Development Environment\"`;\n      break;\n    case 'shorts':\n      titleRules = `TITLE STYLE (YouTube Shorts/TikTok):\n- Create punchy, hook-style titles (3-5 words max)\n- Use action words and emotional triggers\n- Make it scroll-stopping and urgent\n- Keep it ultra-concise for mobile\n- Example: \"This Changes Everything\" or \"Wait For It...\"`;\n      break;\n    default:\n      titleRules = `TITLE STYLE:\n- Create short, descriptive titles (3-5 words max)\n- Focus on the main topic of each section\n- Be clear and informative`;\n  }\n\n  return `Analyze this transcript and identify natural chapter breaks.\n\nRULES:\n- Maximum ${maxChapters} chapters\n- Minimum ${minLength} seconds between chapters\n- First chapter MUST start at 0 seconds\n- Total video duration is ${Math.floor(duration)} seconds\n- Identify topic/subject changes\n\n${titleRules}\n\nTRANSCRIPT:\n${truncatedText}\n\nReturn JSON in this exact format:\n{\n  \"chapters\": [\n    {\n      \"startTime\": 0,\n      \"title\": \"Introduction\",\n      \"description\": \"Brief description of this chapter\",\n      \"keywords\": [\"keyword1\", \"keyword2\"]\n    },\n    {\n      \"startTime\": 120,\n      \"title\": \"Main Topic\",\n      \"description\": \"Description of what happens\",\n      \"keywords\": [\"topic\", \"subject\"]\n    }\n  ]\n}\n\nIMPORTANT:\n- startTime values must be in SECONDS as numbers, not strings.\n- Include 2-3 relevant keywords for each chapter for SEO.`;\n}\n\n/**\n * Validate and clean detected chapters\n * @param {Array} chapters - Raw chapters from AI\n * @param {number} duration - Total duration\n * @param {number} minLength - Minimum chapter length\n * @returns {Array} Validated chapters\n */\nfunction validateChapters(chapters, duration, minLength) {\n  if (!Array.isArray(chapters)) {\n    return [{\n      startTime: 0,\n      title: 'Video',\n      description: 'Full video content'\n    }];\n  }\n\n  const validChapters = [];\n  let lastTime = -minLength;\n\n  // Sort by start time\n  const sorted = [...chapters].sort((a, b) => {\n    const aTime = parseFloat(a.startTime) || 0;\n    const bTime = parseFloat(b.startTime) || 0;\n    return aTime - bTime;\n  });\n\n  for (const chapter of sorted) {\n    const startTime = parseFloat(chapter.startTime) || 0;\n\n    // Skip if too close to last chapter\n    if (startTime - lastTime < minLength && validChapters.length > 0) {\n      continue;\n    }\n\n    // Skip if past duration\n    if (startTime >= duration) {\n      continue;\n    }\n\n    // Ensure title exists\n    const title = (chapter.title || 'Chapter ' + (validChapters.length + 1)).substring(0, 50);\n    const description = (chapter.description || '').substring(0, 200);\n\n    // Preserve keywords if provided by AI\n    const keywords = Array.isArray(chapter.keywords) ? chapter.keywords.slice(0, 5) : [];\n\n    validChapters.push({\n      startTime: parseFloat(startTime.toFixed(2)),\n      title,\n      description,\n      keywords\n    });\n\n    lastTime = startTime;\n  }\n\n  // Ensure first chapter starts at 0\n  if (validChapters.length > 0 && validChapters[0].startTime > 0) {\n    validChapters.unshift({\n      startTime: 0,\n      title: 'Introduction',\n      description: 'Video introduction'\n    });\n  }\n\n  // Ensure at least one chapter\n  if (validChapters.length === 0) {\n    validChapters.push({\n      startTime: 0,\n      title: 'Video',\n      description: 'Full video content'\n    });\n  }\n\n  return validChapters;\n}\n\n/**\n * Format chapters as YouTube timestamps\n * @param {Array} chapters - Array of chapter objects\n * @returns {string} YouTube-formatted timestamp string\n */\nfunction formatYouTubeTimestamps(chapters) {\n  return chapters.map(ch => {\n    const totalSeconds = Math.floor(ch.startTime);\n    const hours = Math.floor(totalSeconds / 3600);\n    const minutes = Math.floor((totalSeconds % 3600) / 60);\n    const seconds = totalSeconds % 60;\n\n    let time;\n    if (hours > 0) {\n      time = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n    } else {\n      time = `${minutes}:${seconds.toString().padStart(2, '0')}`;\n    }\n\n    return `${time} ${ch.title}`;\n  }).join('\\n');\n}\n\n/**\n * Detect chapters from segments (fallback without AI)\n * Uses silence gaps and segment boundaries\n * @param {Object} transcript - Transcript with segments\n * @param {Object} settings - Detection settings\n * @returns {Object} Detected chapters\n */\nfunction detectChaptersFallback(transcript, settings = {}) {\n  const {\n    minChapterLength = 120,\n    gapThreshold = 3 // seconds of silence to consider chapter break\n  } = settings;\n\n  const segments = transcript.segments || [];\n  if (segments.length === 0) {\n    return {\n      chapters: [{ startTime: 0, title: 'Video', description: '' }],\n      youtubeTimestamps: '0:00 Video',\n      markers: [{ time: 0, name: 'Video', comment: '' }],\n      metadata: { chapterCount: 1, method: 'fallback' }\n    };\n  }\n\n  const chapters = [{ startTime: 0, title: 'Chapter 1', description: '' }];\n  let chapterNum = 2;\n  let lastEnd = 0;\n  let lastChapterTime = 0;\n\n  for (const segment of segments) {\n    const gap = segment.start - lastEnd;\n\n    // Large gap indicates potential chapter break\n    if (gap >= gapThreshold && segment.start - lastChapterTime >= minChapterLength) {\n      chapters.push({\n        startTime: parseFloat(segment.start.toFixed(2)),\n        title: `Chapter ${chapterNum}`,\n        description: ''\n      });\n      chapterNum++;\n      lastChapterTime = segment.start;\n    }\n\n    lastEnd = segment.end;\n  }\n\n  return {\n    chapters,\n    youtubeTimestamps: formatYouTubeTimestamps(chapters),\n    markers: chapters.map(ch => ({\n      time: ch.startTime,\n      name: ch.title,\n      comment: ch.description\n    })),\n    metadata: {\n      chapterCount: chapters.length,\n      method: 'fallback'\n    }\n  };\n}\n\n/**\n * Generate chapter divider data for timeline insertion\n * Creates divider clips with text, colors, and animation data\n * @param {Array} chapters - Array of chapter objects\n * @param {Object} settings - Divider settings\n * @returns {Object} Divider data for builder insertion\n */\nfunction generateChapterDividers(chapters, settings = {}) {\n  const {\n    duration = 3, // seconds per divider\n    style = 'gradient', // 'gradient', 'solid', 'minimal'\n    colorScheme = 'blue', // 'blue', 'purple', 'green', 'orange', 'custom'\n    fadeIn = 0.5,\n    fadeOut = 0.5,\n    fontSize = 72,\n    fontFamily = 'Arial',\n    position = 'center', // 'center', 'lower-third', 'top'\n    includeChapterNumber = true,\n    customColors = null\n  } = settings;\n\n  // Color schemes for gradients\n  const colorSchemes = {\n    blue: { start: '#1e3a8a', end: '#3b82f6', text: '#ffffff' },\n    purple: { start: '#581c87', end: '#a855f7', text: '#ffffff' },\n    green: { start: '#14532d', end: '#22c55e', text: '#ffffff' },\n    orange: { start: '#7c2d12', end: '#f97316', text: '#ffffff' },\n    red: { start: '#7f1d1d', end: '#ef4444', text: '#ffffff' },\n    custom: customColors || { start: '#000000', end: '#333333', text: '#ffffff' }\n  };\n\n  const colors = colorSchemes[colorScheme] || colorSchemes.blue;\n\n  // Position presets (as percentages)\n  const positions = {\n    'center': { x: 50, y: 50 },\n    'lower-third': { x: 50, y: 80 },\n    'top': { x: 50, y: 20 }\n  };\n\n  const pos = positions[position] || positions.center;\n\n  const dividers = chapters.map((chapter, index) => {\n    const chapterNum = index + 1;\n    const displayTitle = includeChapterNumber\n      ? `Chapter ${chapterNum}: ${chapter.title}`\n      : chapter.title;\n\n    return {\n      // Timing\n      insertTime: chapter.startTime,\n      duration: duration,\n      fadeIn: fadeIn,\n      fadeOut: fadeOut,\n\n      // Content\n      chapterNumber: chapterNum,\n      title: chapter.title,\n      displayTitle: displayTitle,\n      description: chapter.description || '',\n      keywords: chapter.keywords || [],\n\n      // Styling\n      style: style,\n      colors: {\n        background: colors.start,\n        backgroundEnd: colors.end,\n        text: colors.text\n      },\n\n      // Text properties\n      font: {\n        family: fontFamily,\n        size: fontSize,\n        weight: 'bold'\n      },\n\n      // Position (percentages)\n      position: {\n        x: pos.x,\n        y: pos.y\n      },\n\n      // Animation\n      animation: {\n        type: 'fade',\n        easeIn: 'ease-out',\n        easeOut: 'ease-in'\n      },\n\n      // Marker for Premiere Pro\n      markerData: {\n        time: chapter.startTime,\n        name: `SPLICE: ${displayTitle}`,\n        comment: `Chapter divider - ${chapter.description || 'No description'}`,\n        colorIndex: 5 // Cerulean\n      }\n    };\n  });\n\n  return {\n    dividers,\n    settings: {\n      duration,\n      style,\n      colorScheme,\n      position,\n      fadeIn,\n      fadeOut\n    },\n    metadata: {\n      count: dividers.length,\n      totalDuration: dividers.length * duration\n    }\n  };\n}\n\n/**\n * Get available divider styles and color schemes\n * @returns {Object} Available options\n */\nfunction getDividerPresets() {\n  return {\n    styles: [\n      { id: 'gradient', name: 'Gradient', description: 'Smooth color gradient background' },\n      { id: 'solid', name: 'Solid', description: 'Single color background' },\n      { id: 'minimal', name: 'Minimal', description: 'Text only with subtle shadow' }\n    ],\n    colorSchemes: [\n      { id: 'blue', name: 'Blue', colors: { start: '#1e3a8a', end: '#3b82f6' } },\n      { id: 'purple', name: 'Purple', colors: { start: '#581c87', end: '#a855f7' } },\n      { id: 'green', name: 'Green', colors: { start: '#14532d', end: '#22c55e' } },\n      { id: 'orange', name: 'Orange', colors: { start: '#7c2d12', end: '#f97316' } },\n      { id: 'red', name: 'Red', colors: { start: '#7f1d1d', end: '#ef4444' } }\n    ],\n    positions: [\n      { id: 'center', name: 'Center', y: 50 },\n      { id: 'lower-third', name: 'Lower Third', y: 80 },\n      { id: 'top', name: 'Top', y: 20 }\n    ],\n    defaults: {\n      duration: 3,\n      fadeIn: 0.5,\n      fadeOut: 0.5,\n      fontSize: 72,\n      style: 'gradient',\n      colorScheme: 'blue',\n      position: 'center'\n    }\n  };\n}\n\nmodule.exports = {\n  detectChapters,\n  detectChaptersFallback,\n  formatYouTubeTimestamps,\n  extractText,\n  validateChapters,\n  generateChapterDividers,\n  getDividerPresets\n};\n","numLines":572,"startLine":1,"totalLines":572}}}
{"parentUuid":"1cb24607-24e1-4c38-85d9-c5c710649da1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YJ5D4mcVHFEtTDWWRPrUCe","type":"tool_result","content":"     1→/**\n     2→ * License Key Service\n     3→ *\n     4→ * Generates and validates license keys for user authentication.\n     5→ * License keys are generated when a user purchases a subscription via Stripe.\n     6→ * Format: SPLICE-XXXX-XXXX-XXXX (alphanumeric, no confusing characters)\n     7→ */\n     8→\n     9→const { Pool } = require('pg');\n    10→const crypto = require('crypto');\n    11→\n    12→// Use the same pool configuration as other services\n    13→const pool = new Pool({\n    14→  connectionString: process.env.DATABASE_URL,\n    15→  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    16→  max: 20,\n    17→  idleTimeoutMillis: 30000,\n    18→  connectionTimeoutMillis: 5000\n    19→});\n    20→\n    21→// Characters for key generation (no confusing chars: 0/O, 1/I/L)\n    22→const KEY_CHARS = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';\n    23→\n    24→/**\n    25→ * Initialize license_keys table\n    26→ */\n    27→async function initLicenseTables() {\n    28→  const client = await pool.connect();\n    29→  try {\n    30→    await client.query(`\n    31→      CREATE TABLE IF NOT EXISTS license_keys (\n    32→        id SERIAL PRIMARY KEY,\n    33→        key VARCHAR(21) UNIQUE NOT NULL,\n    34→        stripe_customer_id VARCHAR(255) NOT NULL,\n    35→        created_at TIMESTAMP DEFAULT NOW(),\n    36→        activated_at TIMESTAMP,\n    37→        is_active BOOLEAN DEFAULT TRUE\n    38→      )\n    39→    `);\n    40→\n    41→    // Migrate existing column if needed (for existing databases)\n    42→    await client.query(`\n    43→      DO $$\n    44→      BEGIN\n    45→        IF EXISTS (\n    46→          SELECT 1 FROM information_schema.columns\n    47→          WHERE table_name = 'license_keys'\n    48→          AND column_name = 'key'\n    49→          AND character_maximum_length = 19\n    50→        ) THEN\n    51→          ALTER TABLE license_keys ALTER COLUMN key TYPE VARCHAR(21);\n    52→        END IF;\n    53→      END $$;\n    54→    `);\n    55→\n    56→    // Add indexes for efficient lookups\n    57→    await client.query(`\n    58→      CREATE INDEX IF NOT EXISTS idx_license_keys_key\n    59→      ON license_keys(key)\n    60→    `);\n    61→\n    62→    await client.query(`\n    63→      CREATE INDEX IF NOT EXISTS idx_license_keys_customer\n    64→      ON license_keys(stripe_customer_id)\n    65→    `);\n    66→\n    67→    console.log('[License] Database tables initialized');\n    68→  } finally {\n    69→    client.release();\n    70→  }\n    71→}\n    72→\n    73→/**\n    74→ * Generate a random 4-character segment\n    75→ * @returns {string} 4 uppercase alphanumeric characters\n    76→ */\n    77→function generateSegment() {\n    78→  let segment = '';\n    79→  for (let i = 0; i < 4; i++) {\n    80→    segment += KEY_CHARS.charAt(crypto.randomInt(KEY_CHARS.length));\n    81→  }\n    82→  return segment;\n    83→}\n    84→\n    85→/**\n    86→ * Generate a license key in format SPLICE-XXXX-XXXX-XXXX\n    87→ * @returns {string} License key\n    88→ */\n    89→function generateKeyString() {\n    90→  return `SPLICE-${generateSegment()}-${generateSegment()}-${generateSegment()}`;\n    91→}\n    92→\n    93→/**\n    94→ * Validate license key format\n    95→ * @param {string} key - License key to validate\n    96→ * @returns {boolean} True if format is valid\n    97→ */\n    98→function isValidKeyFormat(key) {\n    99→  if (!key || typeof key !== 'string') return false;\n   100→\n   101→  // Normalize: uppercase and trim\n   102→  const normalized = key.toUpperCase().trim();\n   103→\n   104→  // Must match SPLICE-XXXX-XXXX-XXXX pattern\n   105→  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;\n   106→  return pattern.test(normalized);\n   107→}\n   108→\n   109→/**\n   110→ * Normalize a license key (uppercase, trim)\n   111→ * @param {string} key - License key\n   112→ * @returns {string} Normalized key\n   113→ */\n   114→function normalizeKey(key) {\n   115→  return (key || '').toUpperCase().trim();\n   116→}\n   117→\n   118→/**\n   119→ * Generate a new license key for a Stripe customer\n   120→ *\n   121→ * @param {string} stripeCustomerId - Stripe customer ID\n   122→ * @returns {Promise<{success: boolean, key?: string, error?: string}>}\n   123→ */\n   124→async function generateLicenseKey(stripeCustomerId) {\n   125→  if (!stripeCustomerId) {\n   126→    return { success: false, error: 'Customer ID is required' };\n   127→  }\n   128→\n   129→  const client = await pool.connect();\n   130→  try {\n   131→    // Check if customer already has a key\n   132→    const existing = await client.query(\n   133→      'SELECT key FROM license_keys WHERE stripe_customer_id = $1',\n   134→      [stripeCustomerId]\n   135→    );\n   136→\n   137→    if (existing.rows.length > 0) {\n   138→      return {\n   139→        success: true,\n   140→        key: existing.rows[0].key,\n   141→        existing: true\n   142→      };\n   143→    }\n   144→\n   145→    // Generate unique key with retry logic\n   146→    let key;\n   147→    let attempts = 0;\n   148→    const maxAttempts = 10;\n   149→\n   150→    while (attempts < maxAttempts) {\n   151→      key = generateKeyString();\n   152→      try {\n   153→        await client.query(\n   154→          `INSERT INTO license_keys (key, stripe_customer_id)\n   155→           VALUES ($1, $2)`,\n   156→          [key, stripeCustomerId]\n   157→        );\n   158→        break;\n   159→      } catch (err) {\n   160→        if (err.code === '23505') { // Unique violation\n   161→          attempts++;\n   162→          continue;\n   163→        }\n   164→        throw err;\n   165→      }\n   166→    }\n   167→\n   168→    if (attempts >= maxAttempts) {\n   169→      return { success: false, error: 'Failed to generate unique license key' };\n   170→    }\n   171→\n   172→    console.log(`[License] Generated key for customer ${stripeCustomerId}: ${key}`);\n   173→    return { success: true, key };\n   174→  } finally {\n   175→    client.release();\n   176→  }\n   177→}\n   178→\n   179→/**\n   180→ * Activate a license key\n   181→ *\n   182→ * Uses SELECT ... FOR UPDATE to prevent race conditions where\n   183→ * the same license key could be activated on multiple devices simultaneously.\n   184→ *\n   185→ * @param {string} key - License key to activate\n   186→ * @returns {Promise<{success: boolean, customerId?: string, error?: string}>}\n   187→ */\n   188→async function activateLicenseKey(key) {\n   189→  if (!key) {\n   190→    return { success: false, error: 'License key is required' };\n   191→  }\n   192→\n   193→  const normalized = normalizeKey(key);\n   194→\n   195→  if (!isValidKeyFormat(normalized)) {\n   196→    return { success: false, error: 'Invalid license key format. Expected: SPLICE-XXXX-XXXX-XXXX' };\n   197→  }\n   198→\n   199→  const client = await pool.connect();\n   200→  try {\n   201→    // Begin transaction\n   202→    await client.query('BEGIN');\n   203→\n   204→    // Look up the key WITH ROW LOCK to prevent concurrent activation\n   205→    const result = await client.query(\n   206→      'SELECT * FROM license_keys WHERE key = $1 FOR UPDATE',\n   207→      [normalized]\n   208→    );\n   209→\n   210→    if (result.rows.length === 0) {\n   211→      await client.query('ROLLBACK');\n   212→      return { success: false, error: 'License key not found' };\n   213→    }\n   214→\n   215→    const license = result.rows[0];\n   216→\n   217→    if (!license.is_active) {\n   218→      await client.query('ROLLBACK');\n   219→      return { success: false, error: 'License key has been deactivated' };\n   220→    }\n   221→\n   222→    // Check if already activated (within the transaction lock)\n   223→    if (license.activated_at) {\n   224→      await client.query('COMMIT');\n   225→      // Key already activated - still return success with customer ID\n   226→      // This allows the same user to re-activate on new devices\n   227→      return {\n   228→        success: true,\n   229→        customerId: license.stripe_customer_id,\n   230→        alreadyActivated: true,\n   231→        activatedAt: license.activated_at\n   232→      };\n   233→    }\n   234→\n   235→    // Activate the key\n   236→    await client.query(\n   237→      'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n   238→      [license.id]\n   239→    );\n   240→\n   241→    // Commit the transaction\n   242→    await client.query('COMMIT');\n   243→\n   244→    console.log(`[License] Activated key ${normalized} for customer ${license.stripe_customer_id}`);\n   245→\n   246→    return {\n   247→      success: true,\n   248→      customerId: license.stripe_customer_id,\n   249→      alreadyActivated: false\n   250→    };\n   251→  } catch (err) {\n   252→    // Rollback on any error\n   253→    await client.query('ROLLBACK');\n   254→    console.error('[License] Activation error:', err);\n   255→    throw err;\n   256→  } finally {\n   257→    client.release();\n   258→  }\n   259→}\n   260→\n   261→/**\n   262→ * Get license key for a customer\n   263→ *\n   264→ * @param {string} stripeCustomerId - Stripe customer ID\n   265→ * @returns {Promise<{success: boolean, key?: string, activated?: boolean, error?: string}>}\n   266→ */\n   267→async function getLicenseByCustomerId(stripeCustomerId) {\n   268→  if (!stripeCustomerId) {\n   269→    return { success: false, error: 'Customer ID is required' };\n   270→  }\n   271→\n   272→  const result = await pool.query(\n   273→    'SELECT * FROM license_keys WHERE stripe_customer_id = $1',\n   274→    [stripeCustomerId]\n   275→  );\n   276→\n   277→  if (result.rows.length === 0) {\n   278→    return { success: false, error: 'No license key found for this customer' };\n   279→  }\n   280→\n   281→  const license = result.rows[0];\n   282→  return {\n   283→    success: true,\n   284→    key: license.key,\n   285→    activated: !!license.activated_at,\n   286→    isActive: license.is_active,\n   287→    createdAt: license.created_at,\n   288→    activatedAt: license.activated_at\n   289→  };\n   290→}\n   291→\n   292→/**\n   293→ * Deactivate a license key\n   294→ *\n   295→ * @param {string} key - License key to deactivate\n   296→ * @returns {Promise<{success: boolean, error?: string}>}\n   297→ */\n   298→async function deactivateLicenseKey(key) {\n   299→  if (!key) {\n   300→    return { success: false, error: 'License key is required' };\n   301→  }\n   302→\n   303→  const normalized = normalizeKey(key);\n   304→\n   305→  const result = await pool.query(\n   306→    'UPDATE license_keys SET is_active = FALSE WHERE key = $1 RETURNING id',\n   307→    [normalized]\n   308→  );\n   309→\n   310→  if (result.rowCount === 0) {\n   311→    return { success: false, error: 'License key not found' };\n   312→  }\n   313→\n   314→  console.log(`[License] Deactivated key: ${normalized}`);\n   315→  return { success: true };\n   316→}\n   317→\n   318→/**\n   319→ * Reactivate a license key\n   320→ *\n   321→ * @param {string} key - License key to reactivate\n   322→ * @returns {Promise<{success: boolean, error?: string}>}\n   323→ */\n   324→async function reactivateLicenseKey(key) {\n   325→  if (!key) {\n   326→    return { success: false, error: 'License key is required' };\n   327→  }\n   328→\n   329→  const normalized = normalizeKey(key);\n   330→\n   331→  const result = await pool.query(\n   332→    'UPDATE license_keys SET is_active = TRUE WHERE key = $1 RETURNING id',\n   333→    [normalized]\n   334→  );\n   335→\n   336→  if (result.rowCount === 0) {\n   337→    return { success: false, error: 'License key not found' };\n   338→  }\n   339→\n   340→  console.log(`[License] Reactivated key: ${normalized}`);\n   341→  return { success: true };\n   342→}\n   343→\n   344→module.exports = {\n   345→  initLicenseTables,\n   346→  generateLicenseKey,\n   347→  activateLicenseKey,\n   348→  getLicenseByCustomerId,\n   349→  deactivateLicenseKey,\n   350→  reactivateLicenseKey,\n   351→  isValidKeyFormat,\n   352→  normalizeKey,\n   353→  // Exposed for testing\n   354→  generateKeyString\n   355→};\n   356→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"da38e87b-fea6-47fb-8b0e-6bc85d831e72","timestamp":"2025-12-27T01:35:06.566Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/licenseService.js","content":"/**\n * License Key Service\n *\n * Generates and validates license keys for user authentication.\n * License keys are generated when a user purchases a subscription via Stripe.\n * Format: SPLICE-XXXX-XXXX-XXXX (alphanumeric, no confusing characters)\n */\n\nconst { Pool } = require('pg');\nconst crypto = require('crypto');\n\n// Use the same pool configuration as other services\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 5000\n});\n\n// Characters for key generation (no confusing chars: 0/O, 1/I/L)\nconst KEY_CHARS = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';\n\n/**\n * Initialize license_keys table\n */\nasync function initLicenseTables() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS license_keys (\n        id SERIAL PRIMARY KEY,\n        key VARCHAR(21) UNIQUE NOT NULL,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        created_at TIMESTAMP DEFAULT NOW(),\n        activated_at TIMESTAMP,\n        is_active BOOLEAN DEFAULT TRUE\n      )\n    `);\n\n    // Migrate existing column if needed (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF EXISTS (\n          SELECT 1 FROM information_schema.columns\n          WHERE table_name = 'license_keys'\n          AND column_name = 'key'\n          AND character_maximum_length = 19\n        ) THEN\n          ALTER TABLE license_keys ALTER COLUMN key TYPE VARCHAR(21);\n        END IF;\n      END $$;\n    `);\n\n    // Add indexes for efficient lookups\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_license_keys_key\n      ON license_keys(key)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_license_keys_customer\n      ON license_keys(stripe_customer_id)\n    `);\n\n    console.log('[License] Database tables initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Generate a random 4-character segment\n * @returns {string} 4 uppercase alphanumeric characters\n */\nfunction generateSegment() {\n  let segment = '';\n  for (let i = 0; i < 4; i++) {\n    segment += KEY_CHARS.charAt(crypto.randomInt(KEY_CHARS.length));\n  }\n  return segment;\n}\n\n/**\n * Generate a license key in format SPLICE-XXXX-XXXX-XXXX\n * @returns {string} License key\n */\nfunction generateKeyString() {\n  return `SPLICE-${generateSegment()}-${generateSegment()}-${generateSegment()}`;\n}\n\n/**\n * Validate license key format\n * @param {string} key - License key to validate\n * @returns {boolean} True if format is valid\n */\nfunction isValidKeyFormat(key) {\n  if (!key || typeof key !== 'string') return false;\n\n  // Normalize: uppercase and trim\n  const normalized = key.toUpperCase().trim();\n\n  // Must match SPLICE-XXXX-XXXX-XXXX pattern\n  const pattern = /^SPLICE-[A-Z2-9]{4}-[A-Z2-9]{4}-[A-Z2-9]{4}$/;\n  return pattern.test(normalized);\n}\n\n/**\n * Normalize a license key (uppercase, trim)\n * @param {string} key - License key\n * @returns {string} Normalized key\n */\nfunction normalizeKey(key) {\n  return (key || '').toUpperCase().trim();\n}\n\n/**\n * Generate a new license key for a Stripe customer\n *\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, key?: string, error?: string}>}\n */\nasync function generateLicenseKey(stripeCustomerId) {\n  if (!stripeCustomerId) {\n    return { success: false, error: 'Customer ID is required' };\n  }\n\n  const client = await pool.connect();\n  try {\n    // Check if customer already has a key\n    const existing = await client.query(\n      'SELECT key FROM license_keys WHERE stripe_customer_id = $1',\n      [stripeCustomerId]\n    );\n\n    if (existing.rows.length > 0) {\n      return {\n        success: true,\n        key: existing.rows[0].key,\n        existing: true\n      };\n    }\n\n    // Generate unique key with retry logic\n    let key;\n    let attempts = 0;\n    const maxAttempts = 10;\n\n    while (attempts < maxAttempts) {\n      key = generateKeyString();\n      try {\n        await client.query(\n          `INSERT INTO license_keys (key, stripe_customer_id)\n           VALUES ($1, $2)`,\n          [key, stripeCustomerId]\n        );\n        break;\n      } catch (err) {\n        if (err.code === '23505') { // Unique violation\n          attempts++;\n          continue;\n        }\n        throw err;\n      }\n    }\n\n    if (attempts >= maxAttempts) {\n      return { success: false, error: 'Failed to generate unique license key' };\n    }\n\n    console.log(`[License] Generated key for customer ${stripeCustomerId}: ${key}`);\n    return { success: true, key };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Activate a license key\n *\n * Uses SELECT ... FOR UPDATE to prevent race conditions where\n * the same license key could be activated on multiple devices simultaneously.\n *\n * @param {string} key - License key to activate\n * @returns {Promise<{success: boolean, customerId?: string, error?: string}>}\n */\nasync function activateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  if (!isValidKeyFormat(normalized)) {\n    return { success: false, error: 'Invalid license key format. Expected: SPLICE-XXXX-XXXX-XXXX' };\n  }\n\n  const client = await pool.connect();\n  try {\n    // Begin transaction\n    await client.query('BEGIN');\n\n    // Look up the key WITH ROW LOCK to prevent concurrent activation\n    const result = await client.query(\n      'SELECT * FROM license_keys WHERE key = $1 FOR UPDATE',\n      [normalized]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, error: 'License key not found' };\n    }\n\n    const license = result.rows[0];\n\n    if (!license.is_active) {\n      await client.query('ROLLBACK');\n      return { success: false, error: 'License key has been deactivated' };\n    }\n\n    // Check if already activated (within the transaction lock)\n    if (license.activated_at) {\n      await client.query('COMMIT');\n      // Key already activated - still return success with customer ID\n      // This allows the same user to re-activate on new devices\n      return {\n        success: true,\n        customerId: license.stripe_customer_id,\n        alreadyActivated: true,\n        activatedAt: license.activated_at\n      };\n    }\n\n    // Activate the key\n    await client.query(\n      'UPDATE license_keys SET activated_at = NOW() WHERE id = $1',\n      [license.id]\n    );\n\n    // Commit the transaction\n    await client.query('COMMIT');\n\n    console.log(`[License] Activated key ${normalized} for customer ${license.stripe_customer_id}`);\n\n    return {\n      success: true,\n      customerId: license.stripe_customer_id,\n      alreadyActivated: false\n    };\n  } catch (err) {\n    // Rollback on any error\n    await client.query('ROLLBACK');\n    console.error('[License] Activation error:', err);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get license key for a customer\n *\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, key?: string, activated?: boolean, error?: string}>}\n */\nasync function getLicenseByCustomerId(stripeCustomerId) {\n  if (!stripeCustomerId) {\n    return { success: false, error: 'Customer ID is required' };\n  }\n\n  const result = await pool.query(\n    'SELECT * FROM license_keys WHERE stripe_customer_id = $1',\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { success: false, error: 'No license key found for this customer' };\n  }\n\n  const license = result.rows[0];\n  return {\n    success: true,\n    key: license.key,\n    activated: !!license.activated_at,\n    isActive: license.is_active,\n    createdAt: license.created_at,\n    activatedAt: license.activated_at\n  };\n}\n\n/**\n * Deactivate a license key\n *\n * @param {string} key - License key to deactivate\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function deactivateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  const result = await pool.query(\n    'UPDATE license_keys SET is_active = FALSE WHERE key = $1 RETURNING id',\n    [normalized]\n  );\n\n  if (result.rowCount === 0) {\n    return { success: false, error: 'License key not found' };\n  }\n\n  console.log(`[License] Deactivated key: ${normalized}`);\n  return { success: true };\n}\n\n/**\n * Reactivate a license key\n *\n * @param {string} key - License key to reactivate\n * @returns {Promise<{success: boolean, error?: string}>}\n */\nasync function reactivateLicenseKey(key) {\n  if (!key) {\n    return { success: false, error: 'License key is required' };\n  }\n\n  const normalized = normalizeKey(key);\n\n  const result = await pool.query(\n    'UPDATE license_keys SET is_active = TRUE WHERE key = $1 RETURNING id',\n    [normalized]\n  );\n\n  if (result.rowCount === 0) {\n    return { success: false, error: 'License key not found' };\n  }\n\n  console.log(`[License] Reactivated key: ${normalized}`);\n  return { success: true };\n}\n\nmodule.exports = {\n  initLicenseTables,\n  generateLicenseKey,\n  activateLicenseKey,\n  getLicenseByCustomerId,\n  deactivateLicenseKey,\n  reactivateLicenseKey,\n  isValidKeyFormat,\n  normalizeKey,\n  // Exposed for testing\n  generateKeyString\n};\n","numLines":356,"startLine":1,"totalLines":356}}}
{"parentUuid":"da38e87b-fea6-47fb-8b0e-6bc85d831e72","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ju71ZnMmomYwHF44yfTWBp","type":"tool_result","content":"     1→/**\n     2→ * Cloudflare R2 Storage Service\n     3→ * Handles music file uploads and signed URL generation\n     4→ */\n     5→\n     6→const { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand, HeadObjectCommand } = require('@aws-sdk/client-s3');\n     7→const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');\n     8→\n     9→// Initialize R2 client (lazy initialization)\n    10→let s3Client = null;\n    11→\n    12→function getS3Client() {\n    13→  if (!s3Client) {\n    14→    // Validate required environment variables\n    15→    const requiredEnvVars = ['R2_ACCOUNT_ID', 'R2_ACCESS_KEY_ID', 'R2_SECRET_ACCESS_KEY', 'R2_BUCKET_NAME'];\n    16→    const missing = requiredEnvVars.filter(v => !process.env[v]);\n    17→\n    18→    if (missing.length > 0) {\n    19→      throw new Error(`Missing R2 environment variables: ${missing.join(', ')}`);\n    20→    }\n    21→\n    22→    s3Client = new S3Client({\n    23→      region: 'auto',\n    24→      endpoint: `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,\n    25→      credentials: {\n    26→        accessKeyId: process.env.R2_ACCESS_KEY_ID,\n    27→        secretAccessKey: process.env.R2_SECRET_ACCESS_KEY\n    28→      }\n    29→    });\n    30→  }\n    31→  return s3Client;\n    32→}\n    33→\n    34→/**\n    35→ * Generate storage key for music file\n    36→ * @param {string} customerId - Stripe customer ID\n    37→ * @param {string} jobId - Music generation job ID\n    38→ * @param {string} filename - File name (e.g., 'master.wav', 'preview.mp3')\n    39→ * @returns {string} Storage key path\n    40→ */\n    41→function generateStorageKey(customerId, jobId, filename = 'master.wav') {\n    42→  // Sanitize inputs\n    43→  const safeCustomerId = customerId.replace(/[^a-zA-Z0-9_-]/g, '');\n    44→  const safeJobId = jobId.replace(/[^a-zA-Z0-9_-]/g, '');\n    45→  const safeFilename = filename.replace(/[^a-zA-Z0-9._-]/g, '');\n    46→\n    47→  return `${safeCustomerId}/${safeJobId}/${safeFilename}`;\n    48→}\n    49→\n    50→/**\n    51→ * Upload music file to R2\n    52→ * @param {Buffer} buffer - File buffer\n    53→ * @param {string} key - Storage key (use generateStorageKey)\n    54→ * @param {Object} metadata - Optional metadata\n    55→ * @returns {Promise<{success: boolean, key: string, size: number}>}\n    56→ */\n    57→async function uploadMusic(buffer, key, _metadata = {}) {\n    58→  const client = getS3Client();\n    59→\n    60→  // Determine content type from key\n    61→  let contentType = 'audio/wav';\n    62→  if (key.endsWith('.mp3')) contentType = 'audio/mpeg';\n    63→  else if (key.endsWith('.json')) contentType = 'application/json';\n    64→\n    65→  const command = new PutObjectCommand({\n    66→    Bucket: process.env.R2_BUCKET_NAME,\n    67→    Key: key,\n    68→    Body: buffer,\n    69→    ContentType: contentType,\n    70→    Metadata: {\n    71→      ..._metadata,\n    72→      'uploaded-at': new Date().toISOString()\n    73→    }\n    74→  });\n    75→\n    76→  await client.send(command);\n    77→\n    78→  return {\n    79→    success: true,\n    80→    key,\n    81→    size: buffer.length\n    82→  };\n    83→}\n    84→\n    85→/**\n    86→ * Upload metadata JSON file\n    87→ * @param {string} key - Storage key for metadata file\n    88→ * @param {Object} metadata - Metadata object to store\n    89→ * @returns {Promise<{success: boolean, key: string}>}\n    90→ */\n    91→async function uploadMetadata(key, metadata) {\n    92→  const buffer = Buffer.from(JSON.stringify(metadata, null, 2));\n    93→  return uploadMusic(buffer, key, { type: 'metadata' });\n    94→}\n    95→\n    96→/**\n    97→ * Upload buffer to R2 with specified content type\n    98→ * @param {string} key - Storage key\n    99→ * @param {Buffer} buffer - File buffer\n   100→ * @param {string} contentType - Content type (e.g., 'audio/wav')\n   101→ * @returns {Promise<{success: boolean, key: string, size: number}>}\n   102→ */\n   103→async function uploadBuffer(key, buffer, contentType = 'audio/wav') {\n   104→  const client = getS3Client();\n   105→\n   106→  const command = new PutObjectCommand({\n   107→    Bucket: process.env.R2_BUCKET_NAME,\n   108→    Key: key,\n   109→    Body: buffer,\n   110→    ContentType: contentType,\n   111→    Metadata: {\n   112→      'uploaded-at': new Date().toISOString()\n   113→    }\n   114→  });\n   115→\n   116→  await client.send(command);\n   117→\n   118→  return {\n   119→    success: true,\n   120→    key,\n   121→    size: buffer.length\n   122→  };\n   123→}\n   124→\n   125→/**\n   126→ * Download file from R2 as buffer\n   127→ * @param {string} key - Storage key\n   128→ * @returns {Promise<Buffer>} File buffer\n   129→ */\n   130→async function downloadFile(key) {\n   131→  const client = getS3Client();\n   132→\n   133→  const command = new GetObjectCommand({\n   134→    Bucket: process.env.R2_BUCKET_NAME,\n   135→    Key: key\n   136→  });\n   137→\n   138→  const response = await client.send(command);\n   139→\n   140→  // Convert stream to buffer\n   141→  const chunks = [];\n   142→  for await (const chunk of response.Body) {\n   143→    chunks.push(chunk);\n   144→  }\n   145→\n   146→  return Buffer.concat(chunks);\n   147→}\n   148→\n   149→/**\n   150→ * Get signed download URL for music file\n   151→ * @param {string} key - Storage key\n   152→ * @param {number} expiresIn - URL expiration in seconds (default 1 hour)\n   153→ * @returns {Promise<string>} Signed URL\n   154→ */\n   155→async function getSignedDownloadUrl(key, expiresIn = 3600) {\n   156→  const client = getS3Client();\n   157→\n   158→  const command = new GetObjectCommand({\n   159→    Bucket: process.env.R2_BUCKET_NAME,\n   160→    Key: key\n   161→  });\n   162→\n   163→  return getSignedUrl(client, command, { expiresIn });\n   164→}\n   165→\n   166→/**\n   167→ * Get signed upload URL (for direct client uploads)\n   168→ * @param {string} key - Storage key\n   169→ * @param {string} contentType - File content type\n   170→ * @param {number} expiresIn - URL expiration in seconds (default 30 minutes)\n   171→ * @returns {Promise<{url: string, key: string, expiresIn: number}>}\n   172→ */\n   173→async function getSignedUploadUrl(key, contentType = 'audio/wav', expiresIn = 1800) {\n   174→  const client = getS3Client();\n   175→\n   176→  const command = new PutObjectCommand({\n   177→    Bucket: process.env.R2_BUCKET_NAME,\n   178→    Key: key,\n   179→    ContentType: contentType\n   180→  });\n   181→\n   182→  const url = await getSignedUrl(client, command, { expiresIn });\n   183→\n   184→  return {\n   185→    url,\n   186→    key,\n   187→    expiresIn\n   188→  };\n   189→}\n   190→\n   191→/**\n   192→ * Delete music file from R2\n   193→ * @param {string} key - Storage key\n   194→ * @returns {Promise<{success: boolean}>}\n   195→ */\n   196→async function deleteMusic(key) {\n   197→  const client = getS3Client();\n   198→\n   199→  const command = new DeleteObjectCommand({\n   200→    Bucket: process.env.R2_BUCKET_NAME,\n   201→    Key: key\n   202→  });\n   203→\n   204→  await client.send(command);\n   205→\n   206→  return { success: true };\n   207→}\n   208→\n   209→/**\n   210→ * Delete all files for a job (master, preview, metadata)\n   211→ * @param {string} customerId - Stripe customer ID\n   212→ * @param {string} jobId - Music generation job ID\n   213→ * @returns {Promise<{success: boolean, deleted: string[]}>}\n   214→ */\n   215→async function deleteJobFiles(customerId, jobId) {\n   216→  const files = ['master.wav', 'preview.mp3', 'metadata.json'];\n   217→  const deleted = [];\n   218→\n   219→  for (const file of files) {\n   220→    const key = generateStorageKey(customerId, jobId, file);\n   221→    try {\n   222→      await deleteMusic(key);\n   223→      deleted.push(key);\n   224→    } catch (error) {\n   225→      // Ignore not found errors\n   226→      if (error.name !== 'NoSuchKey') {\n   227→        console.error(`Failed to delete ${key}:`, error.message);\n   228→      }\n   229→    }\n   230→  }\n   231→\n   232→  return { success: true, deleted };\n   233→}\n   234→\n   235→/**\n   236→ * Check if file exists in R2\n   237→ * @param {string} key - Storage key\n   238→ * @returns {Promise<boolean>}\n   239→ */\n   240→async function fileExists(key) {\n   241→  const client = getS3Client();\n   242→\n   243→  try {\n   244→    const command = new HeadObjectCommand({\n   245→      Bucket: process.env.R2_BUCKET_NAME,\n   246→      Key: key\n   247→    });\n   248→\n   249→    await client.send(command);\n   250→    return true;\n   251→  } catch (error) {\n   252→    if (error.name === 'NotFound' || error.$metadata?.httpStatusCode === 404) {\n   253→      return false;\n   254→    }\n   255→    throw error;\n   256→  }\n   257→}\n   258→\n   259→/**\n   260→ * Get file metadata (size, content type, etc.)\n   261→ * @param {string} key - Storage key\n   262→ * @returns {Promise<{size: number, contentType: string, lastModified: Date}|null>}\n   263→ */\n   264→async function getFileInfo(key) {\n   265→  const client = getS3Client();\n   266→\n   267→  try {\n   268→    const command = new HeadObjectCommand({\n   269→      Bucket: process.env.R2_BUCKET_NAME,\n   270→      Key: key\n   271→    });\n   272→\n   273→    const response = await client.send(command);\n   274→\n   275→    return {\n   276→      size: response.ContentLength,\n   277→      contentType: response.ContentType,\n   278→      lastModified: response.LastModified\n   279→    };\n   280→  } catch (error) {\n   281→    if (error.name === 'NotFound' || error.$metadata?.httpStatusCode === 404) {\n   282→      return null;\n   283→    }\n   284→    throw error;\n   285→  }\n   286→}\n   287→\n   288→module.exports = {\n   289→  generateStorageKey,\n   290→  uploadMusic,\n   291→  uploadMetadata,\n   292→  uploadBuffer,\n   293→  downloadFile,\n   294→  getSignedDownloadUrl,\n   295→  getSignedUploadUrl,\n   296→  deleteMusic,\n   297→  deleteJobFiles,\n   298→  fileExists,\n   299→  getFileInfo\n   300→};\n   301→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b4edd7f9-a84b-4a92-b692-92c37f886c5f","timestamp":"2025-12-27T01:35:06.566Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/r2Storage.js","content":"/**\n * Cloudflare R2 Storage Service\n * Handles music file uploads and signed URL generation\n */\n\nconst { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand, HeadObjectCommand } = require('@aws-sdk/client-s3');\nconst { getSignedUrl } = require('@aws-sdk/s3-request-presigner');\n\n// Initialize R2 client (lazy initialization)\nlet s3Client = null;\n\nfunction getS3Client() {\n  if (!s3Client) {\n    // Validate required environment variables\n    const requiredEnvVars = ['R2_ACCOUNT_ID', 'R2_ACCESS_KEY_ID', 'R2_SECRET_ACCESS_KEY', 'R2_BUCKET_NAME'];\n    const missing = requiredEnvVars.filter(v => !process.env[v]);\n\n    if (missing.length > 0) {\n      throw new Error(`Missing R2 environment variables: ${missing.join(', ')}`);\n    }\n\n    s3Client = new S3Client({\n      region: 'auto',\n      endpoint: `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,\n      credentials: {\n        accessKeyId: process.env.R2_ACCESS_KEY_ID,\n        secretAccessKey: process.env.R2_SECRET_ACCESS_KEY\n      }\n    });\n  }\n  return s3Client;\n}\n\n/**\n * Generate storage key for music file\n * @param {string} customerId - Stripe customer ID\n * @param {string} jobId - Music generation job ID\n * @param {string} filename - File name (e.g., 'master.wav', 'preview.mp3')\n * @returns {string} Storage key path\n */\nfunction generateStorageKey(customerId, jobId, filename = 'master.wav') {\n  // Sanitize inputs\n  const safeCustomerId = customerId.replace(/[^a-zA-Z0-9_-]/g, '');\n  const safeJobId = jobId.replace(/[^a-zA-Z0-9_-]/g, '');\n  const safeFilename = filename.replace(/[^a-zA-Z0-9._-]/g, '');\n\n  return `${safeCustomerId}/${safeJobId}/${safeFilename}`;\n}\n\n/**\n * Upload music file to R2\n * @param {Buffer} buffer - File buffer\n * @param {string} key - Storage key (use generateStorageKey)\n * @param {Object} metadata - Optional metadata\n * @returns {Promise<{success: boolean, key: string, size: number}>}\n */\nasync function uploadMusic(buffer, key, _metadata = {}) {\n  const client = getS3Client();\n\n  // Determine content type from key\n  let contentType = 'audio/wav';\n  if (key.endsWith('.mp3')) contentType = 'audio/mpeg';\n  else if (key.endsWith('.json')) contentType = 'application/json';\n\n  const command = new PutObjectCommand({\n    Bucket: process.env.R2_BUCKET_NAME,\n    Key: key,\n    Body: buffer,\n    ContentType: contentType,\n    Metadata: {\n      ..._metadata,\n      'uploaded-at': new Date().toISOString()\n    }\n  });\n\n  await client.send(command);\n\n  return {\n    success: true,\n    key,\n    size: buffer.length\n  };\n}\n\n/**\n * Upload metadata JSON file\n * @param {string} key - Storage key for metadata file\n * @param {Object} metadata - Metadata object to store\n * @returns {Promise<{success: boolean, key: string}>}\n */\nasync function uploadMetadata(key, metadata) {\n  const buffer = Buffer.from(JSON.stringify(metadata, null, 2));\n  return uploadMusic(buffer, key, { type: 'metadata' });\n}\n\n/**\n * Upload buffer to R2 with specified content type\n * @param {string} key - Storage key\n * @param {Buffer} buffer - File buffer\n * @param {string} contentType - Content type (e.g., 'audio/wav')\n * @returns {Promise<{success: boolean, key: string, size: number}>}\n */\nasync function uploadBuffer(key, buffer, contentType = 'audio/wav') {\n  const client = getS3Client();\n\n  const command = new PutObjectCommand({\n    Bucket: process.env.R2_BUCKET_NAME,\n    Key: key,\n    Body: buffer,\n    ContentType: contentType,\n    Metadata: {\n      'uploaded-at': new Date().toISOString()\n    }\n  });\n\n  await client.send(command);\n\n  return {\n    success: true,\n    key,\n    size: buffer.length\n  };\n}\n\n/**\n * Download file from R2 as buffer\n * @param {string} key - Storage key\n * @returns {Promise<Buffer>} File buffer\n */\nasync function downloadFile(key) {\n  const client = getS3Client();\n\n  const command = new GetObjectCommand({\n    Bucket: process.env.R2_BUCKET_NAME,\n    Key: key\n  });\n\n  const response = await client.send(command);\n\n  // Convert stream to buffer\n  const chunks = [];\n  for await (const chunk of response.Body) {\n    chunks.push(chunk);\n  }\n\n  return Buffer.concat(chunks);\n}\n\n/**\n * Get signed download URL for music file\n * @param {string} key - Storage key\n * @param {number} expiresIn - URL expiration in seconds (default 1 hour)\n * @returns {Promise<string>} Signed URL\n */\nasync function getSignedDownloadUrl(key, expiresIn = 3600) {\n  const client = getS3Client();\n\n  const command = new GetObjectCommand({\n    Bucket: process.env.R2_BUCKET_NAME,\n    Key: key\n  });\n\n  return getSignedUrl(client, command, { expiresIn });\n}\n\n/**\n * Get signed upload URL (for direct client uploads)\n * @param {string} key - Storage key\n * @param {string} contentType - File content type\n * @param {number} expiresIn - URL expiration in seconds (default 30 minutes)\n * @returns {Promise<{url: string, key: string, expiresIn: number}>}\n */\nasync function getSignedUploadUrl(key, contentType = 'audio/wav', expiresIn = 1800) {\n  const client = getS3Client();\n\n  const command = new PutObjectCommand({\n    Bucket: process.env.R2_BUCKET_NAME,\n    Key: key,\n    ContentType: contentType\n  });\n\n  const url = await getSignedUrl(client, command, { expiresIn });\n\n  return {\n    url,\n    key,\n    expiresIn\n  };\n}\n\n/**\n * Delete music file from R2\n * @param {string} key - Storage key\n * @returns {Promise<{success: boolean}>}\n */\nasync function deleteMusic(key) {\n  const client = getS3Client();\n\n  const command = new DeleteObjectCommand({\n    Bucket: process.env.R2_BUCKET_NAME,\n    Key: key\n  });\n\n  await client.send(command);\n\n  return { success: true };\n}\n\n/**\n * Delete all files for a job (master, preview, metadata)\n * @param {string} customerId - Stripe customer ID\n * @param {string} jobId - Music generation job ID\n * @returns {Promise<{success: boolean, deleted: string[]}>}\n */\nasync function deleteJobFiles(customerId, jobId) {\n  const files = ['master.wav', 'preview.mp3', 'metadata.json'];\n  const deleted = [];\n\n  for (const file of files) {\n    const key = generateStorageKey(customerId, jobId, file);\n    try {\n      await deleteMusic(key);\n      deleted.push(key);\n    } catch (error) {\n      // Ignore not found errors\n      if (error.name !== 'NoSuchKey') {\n        console.error(`Failed to delete ${key}:`, error.message);\n      }\n    }\n  }\n\n  return { success: true, deleted };\n}\n\n/**\n * Check if file exists in R2\n * @param {string} key - Storage key\n * @returns {Promise<boolean>}\n */\nasync function fileExists(key) {\n  const client = getS3Client();\n\n  try {\n    const command = new HeadObjectCommand({\n      Bucket: process.env.R2_BUCKET_NAME,\n      Key: key\n    });\n\n    await client.send(command);\n    return true;\n  } catch (error) {\n    if (error.name === 'NotFound' || error.$metadata?.httpStatusCode === 404) {\n      return false;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get file metadata (size, content type, etc.)\n * @param {string} key - Storage key\n * @returns {Promise<{size: number, contentType: string, lastModified: Date}|null>}\n */\nasync function getFileInfo(key) {\n  const client = getS3Client();\n\n  try {\n    const command = new HeadObjectCommand({\n      Bucket: process.env.R2_BUCKET_NAME,\n      Key: key\n    });\n\n    const response = await client.send(command);\n\n    return {\n      size: response.ContentLength,\n      contentType: response.ContentType,\n      lastModified: response.LastModified\n    };\n  } catch (error) {\n    if (error.name === 'NotFound' || error.$metadata?.httpStatusCode === 404) {\n      return null;\n    }\n    throw error;\n  }\n}\n\nmodule.exports = {\n  generateStorageKey,\n  uploadMusic,\n  uploadMetadata,\n  uploadBuffer,\n  downloadFile,\n  getSignedDownloadUrl,\n  getSignedUploadUrl,\n  deleteMusic,\n  deleteJobFiles,\n  fileExists,\n  getFileInfo\n};\n","numLines":301,"startLine":1,"totalLines":301}}}
{"parentUuid":"b4edd7f9-a84b-4a92-b692-92c37f886c5f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017UDqc4JRfNhQjyZeBNtWys","type":"tool_result","content":"     1→/**\n     2→ * Music Generation Service\n     3→ * Generates AI music using Mureka API\n     4→ */\n     5→\n     6→const https = require('https');\n     7→const { exec } = require('child_process');\n     8→const { promisify } = require('util');\n     9→const fs = require('fs').promises;\n    10→const path = require('path');\n    11→const sceneAnalysis = require('./sceneAnalysis');\n    12→\n    13→const execAsync = promisify(exec);\n    14→\n    15→// Mureka API configuration\n    16→const MUREKA_API_KEY = process.env.MUREKA_API_KEY;\n    17→const MUREKA_BASE_URL = 'api.mureka.ai';\n    18→const MUREKA_API_VERSION = 'v1';\n    19→\n    20→// Generation settings\n    21→const DEFAULT_DURATION = 60;\n    22→const MIN_DURATION = 30;\n    23→const MAX_DURATION = 180;\n    24→const POLL_INTERVAL = 5000; // 5 seconds\n    25→const MAX_POLL_ATTEMPTS = 120; // 10 minutes max\n    26→\n    27→// Mood presets with Mureka-compatible descriptions\n    28→const MOOD_PRESETS = {\n    29→  energetic: 'upbeat, high energy, driving rhythm, motivational',\n    30→  relaxed: 'calm, peaceful, ambient, soothing',\n    31→  melancholic: 'sad, emotional, introspective, minor key',\n    32→  intense: 'powerful, dramatic, cinematic, building tension',\n    33→  happy: 'joyful, cheerful, bright, uplifting',\n    34→  mysterious: 'dark, suspenseful, atmospheric, enigmatic',\n    35→  romantic: 'warm, intimate, gentle, loving',\n    36→  epic: 'grand, orchestral, sweeping, heroic',\n    37→  chill: 'lo-fi, laid-back, smooth, easy-going',\n    38→  neutral: 'balanced, versatile, general purpose'\n    39→};\n    40→\n    41→// Instrument categories\n    42→const INSTRUMENT_PRESETS = {\n    43→  acoustic: ['acoustic guitar', 'piano', 'strings', 'woodwinds'],\n    44→  electronic: ['synthesizer', 'drum machine', 'bass', 'pads'],\n    45→  rock: ['electric guitar', 'drums', 'bass guitar', 'distortion'],\n    46→  orchestral: ['strings', 'brass', 'woodwinds', 'percussion', 'harp'],\n    47→  minimal: ['piano', 'ambient pads'],\n    48→  hiphop: ['808 bass', 'hi-hats', 'trap drums', 'synth']\n    49→};\n    50→\n    51→/**\n    52→ * Check if Mureka API key is configured\n    53→ * @returns {boolean}\n    54→ */\n    55→function hasMurekaCredentials() {\n    56→  return !!MUREKA_API_KEY;\n    57→}\n    58→\n    59→/**\n    60→ * Build prompt for Mureka API from generation options\n    61→ * @param {Object} options - Generation options\n    62→ * @returns {string} Formatted prompt\n    63→ */\n    64→function buildMurekaPrompt(options) {\n    65→  const parts = [];\n    66→\n    67→  // Add custom prompt if provided\n    68→  if (options.prompt) {\n    69→    parts.push(options.prompt);\n    70→  }\n    71→\n    72→  // Add reference song style if available\n    73→  if (options.referenceSong && options.referenceSong.identified) {\n    74→    parts.push(`Style inspired by \"${options.referenceSong.title}\" by ${options.referenceSong.artist}`);\n    75→\n    76→    if (options.referenceSong.bpm) {\n    77→      parts.push(`Tempo around ${options.referenceSong.bpm} BPM`);\n    78→    }\n    79→\n    80→    if (options.referenceSong.key) {\n    81→      parts.push(`Key: ${options.referenceSong.key}`);\n    82→    }\n    83→\n    84→    if (options.referenceSong.genres?.length > 0) {\n    85→      parts.push(`Genre: ${options.referenceSong.genres.join(', ')}`);\n    86→    }\n    87→  }\n    88→\n    89→  // Add mood description\n    90→  if (options.mood) {\n    91→    const moodDescription = MOOD_PRESETS[options.mood] || options.mood;\n    92→    parts.push(`Mood: ${moodDescription}`);\n    93→  }\n    94→\n    95→  // Add instruments\n    96→  if (options.instruments?.length > 0) {\n    97→    const instruments = options.instruments.map(i => {\n    98→      // Check if it's a preset or individual instrument\n    99→      if (INSTRUMENT_PRESETS[i]) {\n   100→        return INSTRUMENT_PRESETS[i].join(', ');\n   101→      }\n   102→      return i;\n   103→    }).join(', ');\n   104→    parts.push(`Instruments: ${instruments}`);\n   105→  }\n   106→\n   107→  // Add duration\n   108→  const duration = clampDuration(options.duration || DEFAULT_DURATION);\n   109→  parts.push(`Duration: approximately ${duration} seconds`);\n   110→\n   111→  // Add quality markers\n   112→  parts.push('Instrumental only, no vocals');\n   113→  parts.push('Suitable as background music for video');\n   114→  parts.push('Professional quality, well-mixed');\n   115→\n   116→  return parts.join('. ');\n   117→}\n   118→\n   119→/**\n   120→ * Clamp duration to valid range\n   121→ * @param {number} duration - Duration in seconds\n   122→ * @returns {number} Clamped duration\n   123→ */\n   124→function clampDuration(duration) {\n   125→  return Math.min(Math.max(duration, MIN_DURATION), MAX_DURATION);\n   126→}\n   127→\n   128→/**\n   129→ * Make HTTP request to Mureka API\n   130→ * @param {string} method - HTTP method\n   131→ * @param {string} endpoint - API endpoint\n   132→ * @param {Object} data - Request body (for POST)\n   133→ * @returns {Promise<Object>} API response\n   134→ */\n   135→async function murekaRequest(method, endpoint, data = null) {\n   136→  if (!MUREKA_API_KEY) {\n   137→    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\n   138→  }\n   139→\n   140→  return new Promise((resolve, reject) => {\n   141→    const options = {\n   142→      hostname: MUREKA_BASE_URL,\n   143→      path: `/${MUREKA_API_VERSION}${endpoint}`,\n   144→      method,\n   145→      headers: {\n   146→        'Authorization': `Bearer ${MUREKA_API_KEY}`,\n   147→        'Content-Type': 'application/json',\n   148→        'Accept': 'application/json'\n   149→      }\n   150→    };\n   151→\n   152→    const req = https.request(options, (res) => {\n   153→      let responseData = '';\n   154→\n   155→      res.on('data', (chunk) => {\n   156→        responseData += chunk;\n   157→      });\n   158→\n   159→      res.on('end', () => {\n   160→        try {\n   161→          const parsed = JSON.parse(responseData);\n   162→\n   163→          if (res.statusCode >= 400) {\n   164→            const error = new Error(parsed.message || parsed.error || 'Mureka API error');\n   165→            error.statusCode = res.statusCode;\n   166→            error.response = parsed;\n   167→            reject(error);\n   168→            return;\n   169→          }\n   170→\n   171→          resolve(parsed);\n   172→        } catch (parseError) {\n   173→          reject(new Error(`Failed to parse Mureka response: ${parseError.message}`));\n   174→        }\n   175→      });\n   176→    });\n   177→\n   178→    req.on('error', (error) => {\n   179→      reject(new Error(`Mureka API request failed: ${error.message}`));\n   180→    });\n   181→\n   182→    req.on('timeout', () => {\n   183→      req.destroy();\n   184→      reject(new Error('Mureka API request timeout'));\n   185→    });\n   186→\n   187→    req.setTimeout(60000); // 60 second timeout\n   188→\n   189→    if (data) {\n   190→      req.write(JSON.stringify(data));\n   191→    }\n   192→\n   193→    req.end();\n   194→  });\n   195→}\n   196→\n   197→/**\n   198→ * Submit music generation request to Mureka\n   199→ * @param {Object} options - Generation options\n   200→ * @returns {Promise<{taskId: string, status: string}>}\n   201→ */\n   202→async function submitGeneration(options) {\n   203→  const prompt = buildMurekaPrompt(options);\n   204→  const duration = clampDuration(options.duration || DEFAULT_DURATION);\n   205→\n   206→  const requestBody = {\n   207→    prompt,\n   208→    duration,\n   209→    type: 'instrumental', // Background music mode\n   210→    format: 'wav',\n   211→    quality: 'high'\n   212→  };\n   213→\n   214→  // Add reference track if available\n   215→  if (options.referenceTrackUrl) {\n   216→    requestBody.reference_url = options.referenceTrackUrl;\n   217→  }\n   218→\n   219→  const response = await murekaRequest('POST', '/generate', requestBody);\n   220→\n   221→  if (!response.task_id) {\n   222→    throw new Error('Mureka did not return a task ID');\n   223→  }\n   224→\n   225→  return {\n   226→    taskId: response.task_id,\n   227→    status: response.status || 'pending',\n   228→    estimatedTime: response.estimated_time || '3-5 minutes'\n   229→  };\n   230→}\n   231→\n   232→/**\n   233→ * Check status of a generation task\n   234→ * @param {string} taskId - Mureka task ID\n   235→ * @returns {Promise<Object>} Task status\n   236→ */\n   237→async function checkTaskStatus(taskId) {\n   238→  const response = await murekaRequest('GET', `/tasks/${taskId}`);\n   239→\n   240→  return {\n   241→    taskId,\n   242→    status: response.status,\n   243→    progress: response.progress || 0,\n   244→    audioUrl: response.audio_url || null,\n   245→    previewUrl: response.preview_url || null,\n   246→    duration: response.duration || null,\n   247→    error: response.error || null\n   248→  };\n   249→}\n   250→\n   251→/**\n   252→ * Poll for task completion\n   253→ * @param {string} taskId - Mureka task ID\n   254→ * @param {Function} onProgress - Progress callback\n   255→ * @returns {Promise<Object>} Completed task result\n   256→ */\n   257→async function pollForCompletion(taskId, onProgress = null) {\n   258→  let attempts = 0;\n   259→\n   260→  while (attempts < MAX_POLL_ATTEMPTS) {\n   261→    attempts++;\n   262→\n   263→    const status = await checkTaskStatus(taskId);\n   264→\n   265→    if (onProgress) {\n   266→      onProgress(status.progress, status.status);\n   267→    }\n   268→\n   269→    if (status.status === 'completed') {\n   270→      if (!status.audioUrl) {\n   271→        throw new Error('Mureka completed but no audio URL provided');\n   272→      }\n   273→      return status;\n   274→    }\n   275→\n   276→    if (status.status === 'failed') {\n   277→      throw new Error(status.error || 'Mureka generation failed');\n   278→    }\n   279→\n   280→    if (status.status === 'cancelled') {\n   281→      throw new Error('Mureka generation was cancelled');\n   282→    }\n   283→\n   284→    // Wait before polling again\n   285→    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));\n   286→  }\n   287→\n   288→  throw new Error('Mureka generation timed out after 10 minutes');\n   289→}\n   290→\n   291→/**\n   292→ * Download audio file from URL\n   293→ * @param {string} url - Audio URL\n   294→ * @returns {Promise<Buffer>} Audio buffer\n   295→ */\n   296→async function downloadAudio(url) {\n   297→  return new Promise((resolve, reject) => {\n   298→    const protocol = url.startsWith('https') ? https : require('http');\n   299→\n   300→    protocol.get(url, (res) => {\n   301→      if (res.statusCode === 302 || res.statusCode === 301) {\n   302→        // Handle redirect\n   303→        return downloadAudio(res.headers.location).then(resolve).catch(reject);\n   304→      }\n   305→\n   306→      if (res.statusCode !== 200) {\n   307→        reject(new Error(`Failed to download audio: HTTP ${res.statusCode}`));\n   308→        return;\n   309→      }\n   310→\n   311→      const chunks = [];\n   312→      res.on('data', (chunk) => chunks.push(chunk));\n   313→      res.on('end', () => resolve(Buffer.concat(chunks)));\n   314→      res.on('error', reject);\n   315→    }).on('error', reject);\n   316→  });\n   317→}\n   318→\n   319→/**\n   320→ * Convert audio buffer to preview MP3\n   321→ * @param {Buffer} wavBuffer - WAV audio buffer\n   322→ * @returns {Promise<Buffer>} MP3 buffer\n   323→ */\n   324→async function createPreviewMp3(wavBuffer) {\n   325→  const tempDir = process.env.TEMP_DIR || '/tmp/splice-music';\n   326→  const tempWav = path.join(tempDir, `preview_${Date.now()}.wav`);\n   327→  const tempMp3 = path.join(tempDir, `preview_${Date.now()}.mp3`);\n   328→\n   329→  try {\n   330→    // Ensure temp dir exists\n   331→    await fs.mkdir(tempDir, { recursive: true });\n   332→\n   333→    // Write WAV to temp file\n   334→    await fs.writeFile(tempWav, wavBuffer);\n   335→\n   336→    // Convert to MP3 using FFmpeg\n   337→    await execAsync(`ffmpeg -y -i \"${tempWav}\" -codec:a libmp3lame -qscale:a 4 \"${tempMp3}\"`, {\n   338→      timeout: 30000\n   339→    });\n   340→\n   341→    // Read MP3 buffer\n   342→    const mp3Buffer = await fs.readFile(tempMp3);\n   343→\n   344→    return mp3Buffer;\n   345→  } finally {\n   346→    // Cleanup temp files\n   347→    try {\n   348→      await fs.unlink(tempWav);\n   349→      await fs.unlink(tempMp3);\n   350→    } catch (_e) {\n   351→      // Ignore cleanup errors\n   352→    }\n   353→  }\n   354→}\n   355→\n   356→/**\n   357→ * Generate music title from options\n   358→ * @param {Object} options - Generation options\n   359→ * @returns {string} Generated title\n   360→ */\n   361→function generateTitle(options) {\n   362→  const parts = [];\n   363→\n   364→  // Add mood\n   365→  if (options.mood) {\n   366→    parts.push(options.mood.charAt(0).toUpperCase() + options.mood.slice(1));\n   367→  }\n   368→\n   369→  // Add reference song if available\n   370→  if (options.referenceSong?.title) {\n   371→    parts.push(`(${options.referenceSong.title} style)`);\n   372→  }\n   373→\n   374→  // Add genre if available\n   375→  if (options.referenceSong?.genres?.[0]) {\n   376→    parts.push(options.referenceSong.genres[0]);\n   377→  }\n   378→\n   379→  // Fallback\n   380→  if (parts.length === 0) {\n   381→    parts.push('AI Generated');\n   382→  }\n   383→\n   384→  parts.push('Music');\n   385→\n   386→  return parts.join(' ');\n   387→}\n   388→\n   389→/**\n   390→ * Full music generation flow\n   391→ * @param {Object} options - Generation options\n   392→ * @param {Function} onProgress - Progress callback\n   393→ * @returns {Promise<Object>} Generated music result\n   394→ */\n   395→async function generateMusic(options, onProgress = null) {\n   396→  // Validate credentials\n   397→  if (!hasMurekaCredentials()) {\n   398→    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\n   399→  }\n   400→\n   401→  // Submit generation request\n   402→  const { taskId } = await submitGeneration(options);\n   403→\n   404→  if (onProgress) {\n   405→    onProgress(10, 'submitted');\n   406→  }\n   407→\n   408→  // Poll for completion\n   409→  const result = await pollForCompletion(taskId, (progress, status) => {\n   410→    if (onProgress) {\n   411→      // Scale progress to 10-90 range (10 for submitted, 90 for downloading)\n   412→      const scaledProgress = 10 + Math.floor(progress * 0.8);\n   413→      onProgress(scaledProgress, status);\n   414→    }\n   415→  });\n   416→\n   417→  if (onProgress) {\n   418→    onProgress(90, 'downloading');\n   419→  }\n   420→\n   421→  // Download audio\n   422→  const audioBuffer = await downloadAudio(result.audioUrl);\n   423→\n   424→  if (onProgress) {\n   425→    onProgress(95, 'processing');\n   426→  }\n   427→\n   428→  // Create preview MP3\n   429→  let previewBuffer;\n   430→  try {\n   431→    previewBuffer = await createPreviewMp3(audioBuffer);\n   432→  } catch (error) {\n   433→    console.warn('Failed to create preview MP3:', error.message);\n   434→    previewBuffer = null;\n   435→  }\n   436→\n   437→  // Generate title\n   438→  const title = generateTitle(options);\n   439→\n   440→  if (onProgress) {\n   441→    onProgress(100, 'completed');\n   442→  }\n   443→\n   444→  return {\n   445→    title,\n   446→    taskId: result.taskId,\n   447→    duration: result.duration || options.duration || DEFAULT_DURATION,\n   448→    audioBuffer,\n   449→    previewBuffer,\n   450→    audioUrl: result.audioUrl,\n   451→    previewUrl: result.previewUrl\n   452→  };\n   453→}\n   454→\n   455→/**\n   456→ * Get available moods\n   457→ * @returns {Object} Mood presets\n   458→ */\n   459→function getAvailableMoods() {\n   460→  return Object.keys(MOOD_PRESETS).map(key => ({\n   461→    id: key,\n   462→    name: key.charAt(0).toUpperCase() + key.slice(1),\n   463→    description: MOOD_PRESETS[key]\n   464→  }));\n   465→}\n   466→\n   467→/**\n   468→ * Get available instrument presets\n   469→ * @returns {Object} Instrument presets\n   470→ */\n   471→function getAvailableInstruments() {\n   472→  return Object.keys(INSTRUMENT_PRESETS).map(key => ({\n   473→    id: key,\n   474→    name: key.charAt(0).toUpperCase() + key.slice(1),\n   475→    instruments: INSTRUMENT_PRESETS[key]\n   476→  }));\n   477→}\n   478→\n   479→/**\n   480→ * Validate generation options\n   481→ * @param {Object} options - Generation options\n   482→ * @returns {{valid: boolean, errors: string[]}}\n   483→ */\n   484→function validateOptions(options) {\n   485→  const errors = [];\n   486→\n   487→  // Check duration\n   488→  if (options.duration !== undefined) {\n   489→    if (typeof options.duration !== 'number') {\n   490→      errors.push('Duration must be a number');\n   491→    } else if (options.duration < MIN_DURATION) {\n   492→      errors.push(`Duration must be at least ${MIN_DURATION} seconds`);\n   493→    } else if (options.duration > MAX_DURATION) {\n   494→      errors.push(`Duration must be at most ${MAX_DURATION} seconds`);\n   495→    }\n   496→  }\n   497→\n   498→  // Check mood\n   499→  if (options.mood && !MOOD_PRESETS[options.mood]) {\n   500→    // Allow custom moods, just log a warning\n   501→    console.warn(`Unknown mood preset: ${options.mood}. Using as custom description.`);\n   502→  }\n   503→\n   504→  // Check instruments\n   505→  if (options.instruments && !Array.isArray(options.instruments)) {\n   506→    errors.push('Instruments must be an array');\n   507→  }\n   508→\n   509→  return {\n   510→    valid: errors.length === 0,\n   511→    errors\n   512→  };\n   513→}\n   514→\n   515→/**\n   516→ * Generate multiple music variations in parallel\n   517→ * Creates 3 variations with subtle prompt differences for user selection\n   518→ * @param {Object} options - Generation options\n   519→ * @param {Function} onProgress - Progress callback (variationIndex, progress, status)\n   520→ * @returns {Promise<Object>} Object with variations array\n   521→ */\n   522→async function generateVariations(options, onProgress = null) {\n   523→  // Validate credentials\n   524→  if (!hasMurekaCredentials()) {\n   525→    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\n   526→  }\n   527→\n   528→  // Create 3 prompt variations with subtle differences\n   529→  const variationPrompts = createVariationPrompts(options);\n   530→  const variationCount = 3;\n   531→\n   532→  // Track progress for each variation\n   533→  const variationProgress = new Array(variationCount).fill(0);\n   534→  const variationStatus = new Array(variationCount).fill('pending');\n   535→\n   536→  // Submit all variations in parallel\n   537→  const submittedTasks = await Promise.all(\n   538→    variationPrompts.map(async (varOptions, index) => {\n   539→      try {\n   540→        const { taskId } = await submitGeneration(varOptions);\n   541→        variationStatus[index] = 'submitted';\n   542→        if (onProgress) {\n   543→          onProgress(index, 10, 'submitted');\n   544→        }\n   545→        return { taskId, options: varOptions, index };\n   546→      } catch (error) {\n   547→        console.error(`Variation ${index + 1} submission failed:`, error.message);\n   548→        throw new Error(`Variation ${index + 1} failed to submit: ${error.message}`);\n   549→      }\n   550→    })\n   551→  );\n   552→\n   553→  // Poll all tasks in parallel\n   554→  const results = await Promise.all(\n   555→    submittedTasks.map(async ({ taskId, options: varOptions, index }) => {\n   556→      try {\n   557→        const result = await pollForCompletion(taskId, (progress, status) => {\n   558→          variationProgress[index] = progress;\n   559→          variationStatus[index] = status;\n   560→          if (onProgress) {\n   561→            // Scale progress to 10-90 range\n   562→            const scaledProgress = 10 + Math.floor(progress * 0.8);\n   563→            onProgress(index, scaledProgress, status);\n   564→          }\n   565→        });\n   566→\n   567→        if (onProgress) {\n   568→          onProgress(index, 90, 'downloading');\n   569→        }\n   570→\n   571→        // Download audio\n   572→        const audioBuffer = await downloadAudio(result.audioUrl);\n   573→\n   574→        if (onProgress) {\n   575→          onProgress(index, 95, 'processing');\n   576→        }\n   577→\n   578→        // Create preview MP3\n   579→        let previewBuffer;\n   580→        try {\n   581→          previewBuffer = await createPreviewMp3(audioBuffer);\n   582→        } catch (error) {\n   583→          console.warn(`Failed to create preview MP3 for variation ${index + 1}:`, error.message);\n   584→          previewBuffer = null;\n   585→        }\n   586→\n   587→        if (onProgress) {\n   588→          onProgress(index, 100, 'completed');\n   589→        }\n   590→\n   591→        return {\n   592→          variationIndex: index,\n   593→          variationName: getVariationName(index),\n   594→          title: generateTitle(varOptions),\n   595→          taskId: result.taskId,\n   596→          duration: result.duration || varOptions.duration || DEFAULT_DURATION,\n   597→          audioBuffer,\n   598→          previewBuffer,\n   599→          audioUrl: result.audioUrl,\n   600→          previewUrl: result.previewUrl,\n   601→          promptDescription: varOptions.variationDescription || ''\n   602→        };\n   603→      } catch (error) {\n   604→        console.error(`Variation ${index + 1} failed:`, error.message);\n   605→        return {\n   606→          variationIndex: index,\n   607→          variationName: getVariationName(index),\n   608→          error: error.message,\n   609→          failed: true\n   610→        };\n   611→      }\n   612→    })\n   613→  );\n   614→\n   615→  // Check if at least one variation succeeded\n   616→  const successfulVariations = results.filter(r => !r.failed);\n   617→  if (successfulVariations.length === 0) {\n   618→    throw new Error('All variations failed to generate');\n   619→  }\n   620→\n   621→  return {\n   622→    variations: results,\n   623→    successCount: successfulVariations.length,\n   624→    failedCount: results.length - successfulVariations.length,\n   625→    totalCount: results.length\n   626→  };\n   627→}\n   628→\n   629→/**\n   630→ * Create 3 variation prompts with subtle differences\n   631→ * @param {Object} baseOptions - Base generation options\n   632→ * @returns {Object[]} Array of 3 variation options\n   633→ */\n   634→function createVariationPrompts(baseOptions) {\n   635→  // Variation modifiers to create subtle differences\n   636→  const variations = [\n   637→    {\n   638→      suffix: 'Version A - Original interpretation',\n   639→      variationDescription: 'Original interpretation with balanced arrangement',\n   640→      moodModifier: ''\n   641→    },\n   642→    {\n   643→      suffix: 'Version B - More dynamic',\n   644→      variationDescription: 'More dynamic with increased energy and variation',\n   645→      moodModifier: 'with added dynamic range and rhythmic variation'\n   646→    },\n   647→    {\n   648→      suffix: 'Version C - More subtle',\n   649→      variationDescription: 'More subtle and minimalist approach',\n   650→      moodModifier: 'with a more subtle, understated approach'\n   651→    }\n   652→  ];\n   653→\n   654→  return variations.map((variation, index) => {\n   655→    // Create modified options for each variation\n   656→    const modifiedOptions = { ...baseOptions };\n   657→\n   658→    // Build variation-specific prompt\n   659→    const basePrompt = baseOptions.prompt || '';\n   660→    const variationPrompt = basePrompt\n   661→      ? `${basePrompt}. ${variation.suffix}`\n   662→      : variation.suffix;\n   663→\n   664→    modifiedOptions.prompt = variationPrompt;\n   665→    modifiedOptions.variationIndex = index;\n   666→    modifiedOptions.variationDescription = variation.variationDescription;\n   667→\n   668→    // Slightly modify mood description for variety\n   669→    if (variation.moodModifier) {\n   670→      modifiedOptions.moodModifier = variation.moodModifier;\n   671→    }\n   672→\n   673→    return modifiedOptions;\n   674→  });\n   675→}\n   676→\n   677→/**\n   678→ * Get variation display name\n   679→ * @param {number} index - Variation index (0-2)\n   680→ * @returns {string} Display name\n   681→ */\n   682→function getVariationName(index) {\n   683→  const names = ['Version A', 'Version B', 'Version C'];\n   684→  return names[index] || `Version ${index + 1}`;\n   685→}\n   686→\n   687→/**\n   688→ * Build Mureka prompt with variation modifier\n   689→ * Extended version of buildMurekaPrompt that handles variations\n   690→ * @param {Object} options - Generation options with potential variation modifiers\n   691→ * @returns {string} Formatted prompt\n   692→ */\n   693→function buildMurekaPromptWithVariation(options) {\n   694→  const parts = [];\n   695→\n   696→  // Add custom prompt if provided (includes variation suffix)\n   697→  if (options.prompt) {\n   698→    parts.push(options.prompt);\n   699→  }\n   700→\n   701→  // Add reference song style if available\n   702→  if (options.referenceSong && options.referenceSong.identified) {\n   703→    parts.push(`Style inspired by \"${options.referenceSong.title}\" by ${options.referenceSong.artist}`);\n   704→\n   705→    if (options.referenceSong.bpm) {\n   706→      parts.push(`Tempo around ${options.referenceSong.bpm} BPM`);\n   707→    }\n   708→\n   709→    if (options.referenceSong.key) {\n   710→      parts.push(`Key: ${options.referenceSong.key}`);\n   711→    }\n   712→\n   713→    if (options.referenceSong.genres?.length > 0) {\n   714→      parts.push(`Genre: ${options.referenceSong.genres.join(', ')}`);\n   715→    }\n   716→  }\n   717→\n   718→  // Add mood description with variation modifier\n   719→  if (options.mood) {\n   720→    let moodDescription = MOOD_PRESETS[options.mood] || options.mood;\n   721→    if (options.moodModifier) {\n   722→      moodDescription = `${moodDescription} ${options.moodModifier}`;\n   723→    }\n   724→    parts.push(`Mood: ${moodDescription}`);\n   725→  }\n   726→\n   727→  // Add instruments\n   728→  if (options.instruments?.length > 0) {\n   729→    const instruments = options.instruments.map(i => {\n   730→      if (INSTRUMENT_PRESETS[i]) {\n   731→        return INSTRUMENT_PRESETS[i].join(', ');\n   732→      }\n   733→      return i;\n   734→    }).join(', ');\n   735→    parts.push(`Instruments: ${instruments}`);\n   736→  }\n   737→\n   738→  // Add duration\n   739→  const duration = clampDuration(options.duration || DEFAULT_DURATION);\n   740→  parts.push(`Duration: approximately ${duration} seconds`);\n   741→\n   742→  // Add quality markers\n   743→  parts.push('Instrumental only, no vocals');\n   744→  parts.push('Suitable as background music for video');\n   745→  parts.push('Professional quality, well-mixed');\n   746→\n   747→  return parts.join('. ');\n   748→}\n   749→\n   750→/**\n   751→ * Generate scene-aware music using transcript analysis\n   752→ * Analyzes transcript for mood/energy and builds enhanced prompt\n   753→ * @param {Object[]} segments - Transcript segments with {id, start, end, text}\n   754→ * @param {Object} options - Generation options\n   755→ * @param {Function} onProgress - Progress callback\n   756→ * @returns {Promise<Object>} Generated music result with scene context\n   757→ */\n   758→async function generateSceneAwareMusic(segments, options, onProgress = null) {\n   759→  // Validate credentials\n   760→  if (!hasMurekaCredentials()) {\n   761→    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\n   762→  }\n   763→\n   764→  if (onProgress) {\n   765→    onProgress(5, 'analyzing');\n   766→  }\n   767→\n   768→  // Analyze scenes from transcript\n   769→  const sceneContext = await sceneAnalysis.analyzeScenes(segments);\n   770→\n   771→  if (onProgress) {\n   772→    onProgress(15, 'building_prompt');\n   773→  }\n   774→\n   775→  // Build scene-aware prompt\n   776→  const enhancedPrompt = sceneAnalysis.buildSceneAwarePrompt(sceneContext, options);\n   777→\n   778→  // Create modified options with scene-aware prompt\n   779→  const sceneAwareOptions = {\n   780→    ...options,\n   781→    prompt: enhancedPrompt,\n   782→    // Store scene context for metadata\n   783→    _sceneContext: sceneContext\n   784→  };\n   785→\n   786→  if (onProgress) {\n   787→    onProgress(20, 'generating');\n   788→  }\n   789→\n   790→  // Submit generation with scene-aware prompt\n   791→  const { taskId } = await submitGeneration(sceneAwareOptions);\n   792→\n   793→  // Poll for completion\n   794→  const result = await pollForCompletion(taskId, (progress, pollStatus) => {\n   795→    if (onProgress) {\n   796→      // Scale progress to 20-90 range\n   797→      const scaledProgress = 20 + Math.floor(progress * 0.7);\n   798→      onProgress(scaledProgress, pollStatus);\n   799→    }\n   800→  });\n   801→\n   802→  if (onProgress) {\n   803→    onProgress(90, 'downloading');\n   804→  }\n   805→\n   806→  // Download audio\n   807→  const audioBuffer = await downloadAudio(result.audioUrl);\n   808→\n   809→  if (onProgress) {\n   810→    onProgress(95, 'processing');\n   811→  }\n   812→\n   813→  // Create preview MP3\n   814→  let previewBuffer;\n   815→  try {\n   816→    previewBuffer = await createPreviewMp3(audioBuffer);\n   817→  } catch (error) {\n   818→    console.warn('Failed to create preview MP3:', error.message);\n   819→    previewBuffer = null;\n   820→  }\n   821→\n   822→  // Generate title with scene context\n   823→  const title = generateSceneAwareTitle(options, sceneContext);\n   824→\n   825→  if (onProgress) {\n   826→    onProgress(100, 'completed');\n   827→  }\n   828→\n   829→  return {\n   830→    title,\n   831→    taskId: result.taskId,\n   832→    duration: result.duration || options.duration || DEFAULT_DURATION,\n   833→    audioBuffer,\n   834→    previewBuffer,\n   835→    audioUrl: result.audioUrl,\n   836→    previewUrl: result.previewUrl,\n   837→    // Include scene analysis metadata\n   838→    sceneContext: {\n   839→      dominantMood: sceneContext.dominantMood,\n   840→      averageEnergy: sceneContext.averageEnergy,\n   841→      sceneCount: sceneContext.scenes.length,\n   842→      summary: sceneAnalysis.getSceneContextSummary(sceneContext)\n   843→    }\n   844→  };\n   845→}\n   846→\n   847→/**\n   848→ * Generate title for scene-aware music\n   849→ * @param {Object} options - Generation options\n   850→ * @param {Object} sceneContext - Scene analysis result\n   851→ * @returns {string} Generated title\n   852→ */\n   853→function generateSceneAwareTitle(options, sceneContext) {\n   854→  const parts = [];\n   855→\n   856→  // Add detected mood\n   857→  if (sceneContext.dominantMood && sceneContext.dominantMood !== 'neutral') {\n   858→    const moodName = sceneContext.dominantMood.charAt(0).toUpperCase() +\n   859→      sceneContext.dominantMood.slice(1);\n   860→    parts.push(moodName);\n   861→  }\n   862→\n   863→  // Add energy indicator\n   864→  const energy = sceneContext.averageEnergy;\n   865→  if (energy >= 75) {\n   866→    parts.push('High-Energy');\n   867→  } else if (energy <= 30) {\n   868→    parts.push('Ambient');\n   869→  }\n   870→\n   871→  // Add user mood if different\n   872→  if (options.mood && options.mood !== sceneContext.dominantMood) {\n   873→    const userMood = options.mood.charAt(0).toUpperCase() + options.mood.slice(1);\n   874→    parts.push(userMood);\n   875→  }\n   876→\n   877→  // Add reference song if available\n   878→  if (options.referenceSong?.title) {\n   879→    parts.push(`(${options.referenceSong.title} style)`);\n   880→  }\n   881→\n   882→  // Fallback\n   883→  if (parts.length === 0) {\n   884→    parts.push('Scene-Aware');\n   885→  }\n   886→\n   887→  parts.push('Music');\n   888→\n   889→  return parts.join(' ');\n   890→}\n   891→\n   892→/**\n   893→ * Validate scene-aware generation options\n   894→ * @param {Object[]} segments - Transcript segments\n   895→ * @param {Object} options - Generation options\n   896→ * @returns {{valid: boolean, errors: string[]}}\n   897→ */\n   898→function validateSceneAwareOptions(segments, options) {\n   899→  const errors = [];\n   900→\n   901→  // Check segments\n   902→  if (!segments || !Array.isArray(segments)) {\n   903→    errors.push('Transcript segments are required');\n   904→  } else if (segments.length === 0) {\n   905→    errors.push('At least one transcript segment is required');\n   906→  } else {\n   907→    // Validate segment format\n   908→    const hasValidFormat = segments.every(s =>\n   909→      typeof s.start === 'number' &&\n   910→      typeof s.end === 'number' &&\n   911→      typeof s.text === 'string'\n   912→    );\n   913→    if (!hasValidFormat) {\n   914→      errors.push('Segments must have start, end (numbers), and text (string)');\n   915→    }\n   916→  }\n   917→\n   918→  // Also validate base options\n   919→  const baseValidation = validateOptions(options);\n   920→  if (!baseValidation.valid) {\n   921→    errors.push(...baseValidation.errors);\n   922→  }\n   923→\n   924→  return {\n   925→    valid: errors.length === 0,\n   926→    errors\n   927→  };\n   928→}\n   929→\n   930→module.exports = {\n   931→  hasMurekaCredentials,\n   932→  buildMurekaPrompt,\n   933→  buildMurekaPromptWithVariation,\n   934→  clampDuration,\n   935→  submitGeneration,\n   936→  checkTaskStatus,\n   937→  pollForCompletion,\n   938→  downloadAudio,\n   939→  createPreviewMp3,\n   940→  generateTitle,\n   941→  generateMusic,\n   942→  generateVariations,\n   943→  createVariationPrompts,\n   944→  getVariationName,\n   945→  getAvailableMoods,\n   946→  getAvailableInstruments,\n   947→  validateOptions,\n   948→  // Scene-aware functions\n   949→  generateSceneAwareMusic,\n   950→  generateSceneAwareTitle,\n   951→  validateSceneAwareOptions,\n   952→  MOOD_PRESETS,\n   953→  INSTRUMENT_PRESETS,\n   954→  MIN_DURATION,\n   955→  MAX_DURATION,\n   956→  DEFAULT_DURATION\n   957→};\n   958→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"72c7ca6c-59ad-44da-b008-eb0f0c345d9e","timestamp":"2025-12-27T01:35:06.685Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/musicGeneration.js","content":"/**\n * Music Generation Service\n * Generates AI music using Mureka API\n */\n\nconst https = require('https');\nconst { exec } = require('child_process');\nconst { promisify } = require('util');\nconst fs = require('fs').promises;\nconst path = require('path');\nconst sceneAnalysis = require('./sceneAnalysis');\n\nconst execAsync = promisify(exec);\n\n// Mureka API configuration\nconst MUREKA_API_KEY = process.env.MUREKA_API_KEY;\nconst MUREKA_BASE_URL = 'api.mureka.ai';\nconst MUREKA_API_VERSION = 'v1';\n\n// Generation settings\nconst DEFAULT_DURATION = 60;\nconst MIN_DURATION = 30;\nconst MAX_DURATION = 180;\nconst POLL_INTERVAL = 5000; // 5 seconds\nconst MAX_POLL_ATTEMPTS = 120; // 10 minutes max\n\n// Mood presets with Mureka-compatible descriptions\nconst MOOD_PRESETS = {\n  energetic: 'upbeat, high energy, driving rhythm, motivational',\n  relaxed: 'calm, peaceful, ambient, soothing',\n  melancholic: 'sad, emotional, introspective, minor key',\n  intense: 'powerful, dramatic, cinematic, building tension',\n  happy: 'joyful, cheerful, bright, uplifting',\n  mysterious: 'dark, suspenseful, atmospheric, enigmatic',\n  romantic: 'warm, intimate, gentle, loving',\n  epic: 'grand, orchestral, sweeping, heroic',\n  chill: 'lo-fi, laid-back, smooth, easy-going',\n  neutral: 'balanced, versatile, general purpose'\n};\n\n// Instrument categories\nconst INSTRUMENT_PRESETS = {\n  acoustic: ['acoustic guitar', 'piano', 'strings', 'woodwinds'],\n  electronic: ['synthesizer', 'drum machine', 'bass', 'pads'],\n  rock: ['electric guitar', 'drums', 'bass guitar', 'distortion'],\n  orchestral: ['strings', 'brass', 'woodwinds', 'percussion', 'harp'],\n  minimal: ['piano', 'ambient pads'],\n  hiphop: ['808 bass', 'hi-hats', 'trap drums', 'synth']\n};\n\n/**\n * Check if Mureka API key is configured\n * @returns {boolean}\n */\nfunction hasMurekaCredentials() {\n  return !!MUREKA_API_KEY;\n}\n\n/**\n * Build prompt for Mureka API from generation options\n * @param {Object} options - Generation options\n * @returns {string} Formatted prompt\n */\nfunction buildMurekaPrompt(options) {\n  const parts = [];\n\n  // Add custom prompt if provided\n  if (options.prompt) {\n    parts.push(options.prompt);\n  }\n\n  // Add reference song style if available\n  if (options.referenceSong && options.referenceSong.identified) {\n    parts.push(`Style inspired by \"${options.referenceSong.title}\" by ${options.referenceSong.artist}`);\n\n    if (options.referenceSong.bpm) {\n      parts.push(`Tempo around ${options.referenceSong.bpm} BPM`);\n    }\n\n    if (options.referenceSong.key) {\n      parts.push(`Key: ${options.referenceSong.key}`);\n    }\n\n    if (options.referenceSong.genres?.length > 0) {\n      parts.push(`Genre: ${options.referenceSong.genres.join(', ')}`);\n    }\n  }\n\n  // Add mood description\n  if (options.mood) {\n    const moodDescription = MOOD_PRESETS[options.mood] || options.mood;\n    parts.push(`Mood: ${moodDescription}`);\n  }\n\n  // Add instruments\n  if (options.instruments?.length > 0) {\n    const instruments = options.instruments.map(i => {\n      // Check if it's a preset or individual instrument\n      if (INSTRUMENT_PRESETS[i]) {\n        return INSTRUMENT_PRESETS[i].join(', ');\n      }\n      return i;\n    }).join(', ');\n    parts.push(`Instruments: ${instruments}`);\n  }\n\n  // Add duration\n  const duration = clampDuration(options.duration || DEFAULT_DURATION);\n  parts.push(`Duration: approximately ${duration} seconds`);\n\n  // Add quality markers\n  parts.push('Instrumental only, no vocals');\n  parts.push('Suitable as background music for video');\n  parts.push('Professional quality, well-mixed');\n\n  return parts.join('. ');\n}\n\n/**\n * Clamp duration to valid range\n * @param {number} duration - Duration in seconds\n * @returns {number} Clamped duration\n */\nfunction clampDuration(duration) {\n  return Math.min(Math.max(duration, MIN_DURATION), MAX_DURATION);\n}\n\n/**\n * Make HTTP request to Mureka API\n * @param {string} method - HTTP method\n * @param {string} endpoint - API endpoint\n * @param {Object} data - Request body (for POST)\n * @returns {Promise<Object>} API response\n */\nasync function murekaRequest(method, endpoint, data = null) {\n  if (!MUREKA_API_KEY) {\n    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\n  }\n\n  return new Promise((resolve, reject) => {\n    const options = {\n      hostname: MUREKA_BASE_URL,\n      path: `/${MUREKA_API_VERSION}${endpoint}`,\n      method,\n      headers: {\n        'Authorization': `Bearer ${MUREKA_API_KEY}`,\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n      }\n    };\n\n    const req = https.request(options, (res) => {\n      let responseData = '';\n\n      res.on('data', (chunk) => {\n        responseData += chunk;\n      });\n\n      res.on('end', () => {\n        try {\n          const parsed = JSON.parse(responseData);\n\n          if (res.statusCode >= 400) {\n            const error = new Error(parsed.message || parsed.error || 'Mureka API error');\n            error.statusCode = res.statusCode;\n            error.response = parsed;\n            reject(error);\n            return;\n          }\n\n          resolve(parsed);\n        } catch (parseError) {\n          reject(new Error(`Failed to parse Mureka response: ${parseError.message}`));\n        }\n      });\n    });\n\n    req.on('error', (error) => {\n      reject(new Error(`Mureka API request failed: ${error.message}`));\n    });\n\n    req.on('timeout', () => {\n      req.destroy();\n      reject(new Error('Mureka API request timeout'));\n    });\n\n    req.setTimeout(60000); // 60 second timeout\n\n    if (data) {\n      req.write(JSON.stringify(data));\n    }\n\n    req.end();\n  });\n}\n\n/**\n * Submit music generation request to Mureka\n * @param {Object} options - Generation options\n * @returns {Promise<{taskId: string, status: string}>}\n */\nasync function submitGeneration(options) {\n  const prompt = buildMurekaPrompt(options);\n  const duration = clampDuration(options.duration || DEFAULT_DURATION);\n\n  const requestBody = {\n    prompt,\n    duration,\n    type: 'instrumental', // Background music mode\n    format: 'wav',\n    quality: 'high'\n  };\n\n  // Add reference track if available\n  if (options.referenceTrackUrl) {\n    requestBody.reference_url = options.referenceTrackUrl;\n  }\n\n  const response = await murekaRequest('POST', '/generate', requestBody);\n\n  if (!response.task_id) {\n    throw new Error('Mureka did not return a task ID');\n  }\n\n  return {\n    taskId: response.task_id,\n    status: response.status || 'pending',\n    estimatedTime: response.estimated_time || '3-5 minutes'\n  };\n}\n\n/**\n * Check status of a generation task\n * @param {string} taskId - Mureka task ID\n * @returns {Promise<Object>} Task status\n */\nasync function checkTaskStatus(taskId) {\n  const response = await murekaRequest('GET', `/tasks/${taskId}`);\n\n  return {\n    taskId,\n    status: response.status,\n    progress: response.progress || 0,\n    audioUrl: response.audio_url || null,\n    previewUrl: response.preview_url || null,\n    duration: response.duration || null,\n    error: response.error || null\n  };\n}\n\n/**\n * Poll for task completion\n * @param {string} taskId - Mureka task ID\n * @param {Function} onProgress - Progress callback\n * @returns {Promise<Object>} Completed task result\n */\nasync function pollForCompletion(taskId, onProgress = null) {\n  let attempts = 0;\n\n  while (attempts < MAX_POLL_ATTEMPTS) {\n    attempts++;\n\n    const status = await checkTaskStatus(taskId);\n\n    if (onProgress) {\n      onProgress(status.progress, status.status);\n    }\n\n    if (status.status === 'completed') {\n      if (!status.audioUrl) {\n        throw new Error('Mureka completed but no audio URL provided');\n      }\n      return status;\n    }\n\n    if (status.status === 'failed') {\n      throw new Error(status.error || 'Mureka generation failed');\n    }\n\n    if (status.status === 'cancelled') {\n      throw new Error('Mureka generation was cancelled');\n    }\n\n    // Wait before polling again\n    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));\n  }\n\n  throw new Error('Mureka generation timed out after 10 minutes');\n}\n\n/**\n * Download audio file from URL\n * @param {string} url - Audio URL\n * @returns {Promise<Buffer>} Audio buffer\n */\nasync function downloadAudio(url) {\n  return new Promise((resolve, reject) => {\n    const protocol = url.startsWith('https') ? https : require('http');\n\n    protocol.get(url, (res) => {\n      if (res.statusCode === 302 || res.statusCode === 301) {\n        // Handle redirect\n        return downloadAudio(res.headers.location).then(resolve).catch(reject);\n      }\n\n      if (res.statusCode !== 200) {\n        reject(new Error(`Failed to download audio: HTTP ${res.statusCode}`));\n        return;\n      }\n\n      const chunks = [];\n      res.on('data', (chunk) => chunks.push(chunk));\n      res.on('end', () => resolve(Buffer.concat(chunks)));\n      res.on('error', reject);\n    }).on('error', reject);\n  });\n}\n\n/**\n * Convert audio buffer to preview MP3\n * @param {Buffer} wavBuffer - WAV audio buffer\n * @returns {Promise<Buffer>} MP3 buffer\n */\nasync function createPreviewMp3(wavBuffer) {\n  const tempDir = process.env.TEMP_DIR || '/tmp/splice-music';\n  const tempWav = path.join(tempDir, `preview_${Date.now()}.wav`);\n  const tempMp3 = path.join(tempDir, `preview_${Date.now()}.mp3`);\n\n  try {\n    // Ensure temp dir exists\n    await fs.mkdir(tempDir, { recursive: true });\n\n    // Write WAV to temp file\n    await fs.writeFile(tempWav, wavBuffer);\n\n    // Convert to MP3 using FFmpeg\n    await execAsync(`ffmpeg -y -i \"${tempWav}\" -codec:a libmp3lame -qscale:a 4 \"${tempMp3}\"`, {\n      timeout: 30000\n    });\n\n    // Read MP3 buffer\n    const mp3Buffer = await fs.readFile(tempMp3);\n\n    return mp3Buffer;\n  } finally {\n    // Cleanup temp files\n    try {\n      await fs.unlink(tempWav);\n      await fs.unlink(tempMp3);\n    } catch (_e) {\n      // Ignore cleanup errors\n    }\n  }\n}\n\n/**\n * Generate music title from options\n * @param {Object} options - Generation options\n * @returns {string} Generated title\n */\nfunction generateTitle(options) {\n  const parts = [];\n\n  // Add mood\n  if (options.mood) {\n    parts.push(options.mood.charAt(0).toUpperCase() + options.mood.slice(1));\n  }\n\n  // Add reference song if available\n  if (options.referenceSong?.title) {\n    parts.push(`(${options.referenceSong.title} style)`);\n  }\n\n  // Add genre if available\n  if (options.referenceSong?.genres?.[0]) {\n    parts.push(options.referenceSong.genres[0]);\n  }\n\n  // Fallback\n  if (parts.length === 0) {\n    parts.push('AI Generated');\n  }\n\n  parts.push('Music');\n\n  return parts.join(' ');\n}\n\n/**\n * Full music generation flow\n * @param {Object} options - Generation options\n * @param {Function} onProgress - Progress callback\n * @returns {Promise<Object>} Generated music result\n */\nasync function generateMusic(options, onProgress = null) {\n  // Validate credentials\n  if (!hasMurekaCredentials()) {\n    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\n  }\n\n  // Submit generation request\n  const { taskId } = await submitGeneration(options);\n\n  if (onProgress) {\n    onProgress(10, 'submitted');\n  }\n\n  // Poll for completion\n  const result = await pollForCompletion(taskId, (progress, status) => {\n    if (onProgress) {\n      // Scale progress to 10-90 range (10 for submitted, 90 for downloading)\n      const scaledProgress = 10 + Math.floor(progress * 0.8);\n      onProgress(scaledProgress, status);\n    }\n  });\n\n  if (onProgress) {\n    onProgress(90, 'downloading');\n  }\n\n  // Download audio\n  const audioBuffer = await downloadAudio(result.audioUrl);\n\n  if (onProgress) {\n    onProgress(95, 'processing');\n  }\n\n  // Create preview MP3\n  let previewBuffer;\n  try {\n    previewBuffer = await createPreviewMp3(audioBuffer);\n  } catch (error) {\n    console.warn('Failed to create preview MP3:', error.message);\n    previewBuffer = null;\n  }\n\n  // Generate title\n  const title = generateTitle(options);\n\n  if (onProgress) {\n    onProgress(100, 'completed');\n  }\n\n  return {\n    title,\n    taskId: result.taskId,\n    duration: result.duration || options.duration || DEFAULT_DURATION,\n    audioBuffer,\n    previewBuffer,\n    audioUrl: result.audioUrl,\n    previewUrl: result.previewUrl\n  };\n}\n\n/**\n * Get available moods\n * @returns {Object} Mood presets\n */\nfunction getAvailableMoods() {\n  return Object.keys(MOOD_PRESETS).map(key => ({\n    id: key,\n    name: key.charAt(0).toUpperCase() + key.slice(1),\n    description: MOOD_PRESETS[key]\n  }));\n}\n\n/**\n * Get available instrument presets\n * @returns {Object} Instrument presets\n */\nfunction getAvailableInstruments() {\n  return Object.keys(INSTRUMENT_PRESETS).map(key => ({\n    id: key,\n    name: key.charAt(0).toUpperCase() + key.slice(1),\n    instruments: INSTRUMENT_PRESETS[key]\n  }));\n}\n\n/**\n * Validate generation options\n * @param {Object} options - Generation options\n * @returns {{valid: boolean, errors: string[]}}\n */\nfunction validateOptions(options) {\n  const errors = [];\n\n  // Check duration\n  if (options.duration !== undefined) {\n    if (typeof options.duration !== 'number') {\n      errors.push('Duration must be a number');\n    } else if (options.duration < MIN_DURATION) {\n      errors.push(`Duration must be at least ${MIN_DURATION} seconds`);\n    } else if (options.duration > MAX_DURATION) {\n      errors.push(`Duration must be at most ${MAX_DURATION} seconds`);\n    }\n  }\n\n  // Check mood\n  if (options.mood && !MOOD_PRESETS[options.mood]) {\n    // Allow custom moods, just log a warning\n    console.warn(`Unknown mood preset: ${options.mood}. Using as custom description.`);\n  }\n\n  // Check instruments\n  if (options.instruments && !Array.isArray(options.instruments)) {\n    errors.push('Instruments must be an array');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n\n/**\n * Generate multiple music variations in parallel\n * Creates 3 variations with subtle prompt differences for user selection\n * @param {Object} options - Generation options\n * @param {Function} onProgress - Progress callback (variationIndex, progress, status)\n * @returns {Promise<Object>} Object with variations array\n */\nasync function generateVariations(options, onProgress = null) {\n  // Validate credentials\n  if (!hasMurekaCredentials()) {\n    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\n  }\n\n  // Create 3 prompt variations with subtle differences\n  const variationPrompts = createVariationPrompts(options);\n  const variationCount = 3;\n\n  // Track progress for each variation\n  const variationProgress = new Array(variationCount).fill(0);\n  const variationStatus = new Array(variationCount).fill('pending');\n\n  // Submit all variations in parallel\n  const submittedTasks = await Promise.all(\n    variationPrompts.map(async (varOptions, index) => {\n      try {\n        const { taskId } = await submitGeneration(varOptions);\n        variationStatus[index] = 'submitted';\n        if (onProgress) {\n          onProgress(index, 10, 'submitted');\n        }\n        return { taskId, options: varOptions, index };\n      } catch (error) {\n        console.error(`Variation ${index + 1} submission failed:`, error.message);\n        throw new Error(`Variation ${index + 1} failed to submit: ${error.message}`);\n      }\n    })\n  );\n\n  // Poll all tasks in parallel\n  const results = await Promise.all(\n    submittedTasks.map(async ({ taskId, options: varOptions, index }) => {\n      try {\n        const result = await pollForCompletion(taskId, (progress, status) => {\n          variationProgress[index] = progress;\n          variationStatus[index] = status;\n          if (onProgress) {\n            // Scale progress to 10-90 range\n            const scaledProgress = 10 + Math.floor(progress * 0.8);\n            onProgress(index, scaledProgress, status);\n          }\n        });\n\n        if (onProgress) {\n          onProgress(index, 90, 'downloading');\n        }\n\n        // Download audio\n        const audioBuffer = await downloadAudio(result.audioUrl);\n\n        if (onProgress) {\n          onProgress(index, 95, 'processing');\n        }\n\n        // Create preview MP3\n        let previewBuffer;\n        try {\n          previewBuffer = await createPreviewMp3(audioBuffer);\n        } catch (error) {\n          console.warn(`Failed to create preview MP3 for variation ${index + 1}:`, error.message);\n          previewBuffer = null;\n        }\n\n        if (onProgress) {\n          onProgress(index, 100, 'completed');\n        }\n\n        return {\n          variationIndex: index,\n          variationName: getVariationName(index),\n          title: generateTitle(varOptions),\n          taskId: result.taskId,\n          duration: result.duration || varOptions.duration || DEFAULT_DURATION,\n          audioBuffer,\n          previewBuffer,\n          audioUrl: result.audioUrl,\n          previewUrl: result.previewUrl,\n          promptDescription: varOptions.variationDescription || ''\n        };\n      } catch (error) {\n        console.error(`Variation ${index + 1} failed:`, error.message);\n        return {\n          variationIndex: index,\n          variationName: getVariationName(index),\n          error: error.message,\n          failed: true\n        };\n      }\n    })\n  );\n\n  // Check if at least one variation succeeded\n  const successfulVariations = results.filter(r => !r.failed);\n  if (successfulVariations.length === 0) {\n    throw new Error('All variations failed to generate');\n  }\n\n  return {\n    variations: results,\n    successCount: successfulVariations.length,\n    failedCount: results.length - successfulVariations.length,\n    totalCount: results.length\n  };\n}\n\n/**\n * Create 3 variation prompts with subtle differences\n * @param {Object} baseOptions - Base generation options\n * @returns {Object[]} Array of 3 variation options\n */\nfunction createVariationPrompts(baseOptions) {\n  // Variation modifiers to create subtle differences\n  const variations = [\n    {\n      suffix: 'Version A - Original interpretation',\n      variationDescription: 'Original interpretation with balanced arrangement',\n      moodModifier: ''\n    },\n    {\n      suffix: 'Version B - More dynamic',\n      variationDescription: 'More dynamic with increased energy and variation',\n      moodModifier: 'with added dynamic range and rhythmic variation'\n    },\n    {\n      suffix: 'Version C - More subtle',\n      variationDescription: 'More subtle and minimalist approach',\n      moodModifier: 'with a more subtle, understated approach'\n    }\n  ];\n\n  return variations.map((variation, index) => {\n    // Create modified options for each variation\n    const modifiedOptions = { ...baseOptions };\n\n    // Build variation-specific prompt\n    const basePrompt = baseOptions.prompt || '';\n    const variationPrompt = basePrompt\n      ? `${basePrompt}. ${variation.suffix}`\n      : variation.suffix;\n\n    modifiedOptions.prompt = variationPrompt;\n    modifiedOptions.variationIndex = index;\n    modifiedOptions.variationDescription = variation.variationDescription;\n\n    // Slightly modify mood description for variety\n    if (variation.moodModifier) {\n      modifiedOptions.moodModifier = variation.moodModifier;\n    }\n\n    return modifiedOptions;\n  });\n}\n\n/**\n * Get variation display name\n * @param {number} index - Variation index (0-2)\n * @returns {string} Display name\n */\nfunction getVariationName(index) {\n  const names = ['Version A', 'Version B', 'Version C'];\n  return names[index] || `Version ${index + 1}`;\n}\n\n/**\n * Build Mureka prompt with variation modifier\n * Extended version of buildMurekaPrompt that handles variations\n * @param {Object} options - Generation options with potential variation modifiers\n * @returns {string} Formatted prompt\n */\nfunction buildMurekaPromptWithVariation(options) {\n  const parts = [];\n\n  // Add custom prompt if provided (includes variation suffix)\n  if (options.prompt) {\n    parts.push(options.prompt);\n  }\n\n  // Add reference song style if available\n  if (options.referenceSong && options.referenceSong.identified) {\n    parts.push(`Style inspired by \"${options.referenceSong.title}\" by ${options.referenceSong.artist}`);\n\n    if (options.referenceSong.bpm) {\n      parts.push(`Tempo around ${options.referenceSong.bpm} BPM`);\n    }\n\n    if (options.referenceSong.key) {\n      parts.push(`Key: ${options.referenceSong.key}`);\n    }\n\n    if (options.referenceSong.genres?.length > 0) {\n      parts.push(`Genre: ${options.referenceSong.genres.join(', ')}`);\n    }\n  }\n\n  // Add mood description with variation modifier\n  if (options.mood) {\n    let moodDescription = MOOD_PRESETS[options.mood] || options.mood;\n    if (options.moodModifier) {\n      moodDescription = `${moodDescription} ${options.moodModifier}`;\n    }\n    parts.push(`Mood: ${moodDescription}`);\n  }\n\n  // Add instruments\n  if (options.instruments?.length > 0) {\n    const instruments = options.instruments.map(i => {\n      if (INSTRUMENT_PRESETS[i]) {\n        return INSTRUMENT_PRESETS[i].join(', ');\n      }\n      return i;\n    }).join(', ');\n    parts.push(`Instruments: ${instruments}`);\n  }\n\n  // Add duration\n  const duration = clampDuration(options.duration || DEFAULT_DURATION);\n  parts.push(`Duration: approximately ${duration} seconds`);\n\n  // Add quality markers\n  parts.push('Instrumental only, no vocals');\n  parts.push('Suitable as background music for video');\n  parts.push('Professional quality, well-mixed');\n\n  return parts.join('. ');\n}\n\n/**\n * Generate scene-aware music using transcript analysis\n * Analyzes transcript for mood/energy and builds enhanced prompt\n * @param {Object[]} segments - Transcript segments with {id, start, end, text}\n * @param {Object} options - Generation options\n * @param {Function} onProgress - Progress callback\n * @returns {Promise<Object>} Generated music result with scene context\n */\nasync function generateSceneAwareMusic(segments, options, onProgress = null) {\n  // Validate credentials\n  if (!hasMurekaCredentials()) {\n    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\n  }\n\n  if (onProgress) {\n    onProgress(5, 'analyzing');\n  }\n\n  // Analyze scenes from transcript\n  const sceneContext = await sceneAnalysis.analyzeScenes(segments);\n\n  if (onProgress) {\n    onProgress(15, 'building_prompt');\n  }\n\n  // Build scene-aware prompt\n  const enhancedPrompt = sceneAnalysis.buildSceneAwarePrompt(sceneContext, options);\n\n  // Create modified options with scene-aware prompt\n  const sceneAwareOptions = {\n    ...options,\n    prompt: enhancedPrompt,\n    // Store scene context for metadata\n    _sceneContext: sceneContext\n  };\n\n  if (onProgress) {\n    onProgress(20, 'generating');\n  }\n\n  // Submit generation with scene-aware prompt\n  const { taskId } = await submitGeneration(sceneAwareOptions);\n\n  // Poll for completion\n  const result = await pollForCompletion(taskId, (progress, pollStatus) => {\n    if (onProgress) {\n      // Scale progress to 20-90 range\n      const scaledProgress = 20 + Math.floor(progress * 0.7);\n      onProgress(scaledProgress, pollStatus);\n    }\n  });\n\n  if (onProgress) {\n    onProgress(90, 'downloading');\n  }\n\n  // Download audio\n  const audioBuffer = await downloadAudio(result.audioUrl);\n\n  if (onProgress) {\n    onProgress(95, 'processing');\n  }\n\n  // Create preview MP3\n  let previewBuffer;\n  try {\n    previewBuffer = await createPreviewMp3(audioBuffer);\n  } catch (error) {\n    console.warn('Failed to create preview MP3:', error.message);\n    previewBuffer = null;\n  }\n\n  // Generate title with scene context\n  const title = generateSceneAwareTitle(options, sceneContext);\n\n  if (onProgress) {\n    onProgress(100, 'completed');\n  }\n\n  return {\n    title,\n    taskId: result.taskId,\n    duration: result.duration || options.duration || DEFAULT_DURATION,\n    audioBuffer,\n    previewBuffer,\n    audioUrl: result.audioUrl,\n    previewUrl: result.previewUrl,\n    // Include scene analysis metadata\n    sceneContext: {\n      dominantMood: sceneContext.dominantMood,\n      averageEnergy: sceneContext.averageEnergy,\n      sceneCount: sceneContext.scenes.length,\n      summary: sceneAnalysis.getSceneContextSummary(sceneContext)\n    }\n  };\n}\n\n/**\n * Generate title for scene-aware music\n * @param {Object} options - Generation options\n * @param {Object} sceneContext - Scene analysis result\n * @returns {string} Generated title\n */\nfunction generateSceneAwareTitle(options, sceneContext) {\n  const parts = [];\n\n  // Add detected mood\n  if (sceneContext.dominantMood && sceneContext.dominantMood !== 'neutral') {\n    const moodName = sceneContext.dominantMood.charAt(0).toUpperCase() +\n      sceneContext.dominantMood.slice(1);\n    parts.push(moodName);\n  }\n\n  // Add energy indicator\n  const energy = sceneContext.averageEnergy;\n  if (energy >= 75) {\n    parts.push('High-Energy');\n  } else if (energy <= 30) {\n    parts.push('Ambient');\n  }\n\n  // Add user mood if different\n  if (options.mood && options.mood !== sceneContext.dominantMood) {\n    const userMood = options.mood.charAt(0).toUpperCase() + options.mood.slice(1);\n    parts.push(userMood);\n  }\n\n  // Add reference song if available\n  if (options.referenceSong?.title) {\n    parts.push(`(${options.referenceSong.title} style)`);\n  }\n\n  // Fallback\n  if (parts.length === 0) {\n    parts.push('Scene-Aware');\n  }\n\n  parts.push('Music');\n\n  return parts.join(' ');\n}\n\n/**\n * Validate scene-aware generation options\n * @param {Object[]} segments - Transcript segments\n * @param {Object} options - Generation options\n * @returns {{valid: boolean, errors: string[]}}\n */\nfunction validateSceneAwareOptions(segments, options) {\n  const errors = [];\n\n  // Check segments\n  if (!segments || !Array.isArray(segments)) {\n    errors.push('Transcript segments are required');\n  } else if (segments.length === 0) {\n    errors.push('At least one transcript segment is required');\n  } else {\n    // Validate segment format\n    const hasValidFormat = segments.every(s =>\n      typeof s.start === 'number' &&\n      typeof s.end === 'number' &&\n      typeof s.text === 'string'\n    );\n    if (!hasValidFormat) {\n      errors.push('Segments must have start, end (numbers), and text (string)');\n    }\n  }\n\n  // Also validate base options\n  const baseValidation = validateOptions(options);\n  if (!baseValidation.valid) {\n    errors.push(...baseValidation.errors);\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}\n\nmodule.exports = {\n  hasMurekaCredentials,\n  buildMurekaPrompt,\n  buildMurekaPromptWithVariation,\n  clampDuration,\n  submitGeneration,\n  checkTaskStatus,\n  pollForCompletion,\n  downloadAudio,\n  createPreviewMp3,\n  generateTitle,\n  generateMusic,\n  generateVariations,\n  createVariationPrompts,\n  getVariationName,\n  getAvailableMoods,\n  getAvailableInstruments,\n  validateOptions,\n  // Scene-aware functions\n  generateSceneAwareMusic,\n  generateSceneAwareTitle,\n  validateSceneAwareOptions,\n  MOOD_PRESETS,\n  INSTRUMENT_PRESETS,\n  MIN_DURATION,\n  MAX_DURATION,\n  DEFAULT_DURATION\n};\n","numLines":958,"startLine":1,"totalLines":958}}}
{"parentUuid":"72c7ca6c-59ad-44da-b008-eb0f0c345d9e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LQ9DFsLbbeBpLWVhGR7fPH","type":"tool_result","content":"     1→/**\n     2→ * Usage Tracking Service\n     3→ *\n     4→ * Tracks user credit balances and usage for billing.\n     5→ * Uses PostgreSQL for persistence.\n     6→ */\n     7→\n     8→const { Pool } = require('pg');\n     9→\n    10→// PostgreSQL connection pool with proper limits\n    11→const pool = new Pool({\n    12→  connectionString: process.env.DATABASE_URL,\n    13→  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    14→  // PERFORMANCE: Set connection pool limits\n    15→  max: 20,                    // Maximum number of clients in the pool\n    16→  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n    17→  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n    18→});\n    19→\n    20→// Hours per tier (regular processing)\n    21→// Pricing: Starter $19/mo, Pro $49/mo, Team $149/mo\n    22→const TIER_HOURS = {\n    23→  starter: 12,   // 12 hrs/month\n    24→  pro: 30,       // 30 hrs/month\n    25→  team: 100,     // 100 hrs/month\n    26→  cancelled: 0\n    27→};\n    28→\n    29→// Isolation minutes per tier (sized to maintain 80% margins)\n    30→const TIER_ISOLATION_MINUTES = {\n    31→  starter: 0,     // No isolation access\n    32→  pro: 45,        // 45 minutes included\n    33→  team: 180,      // 3 hours included\n    34→  cancelled: 0\n    35→};\n    36→\n    37→// Convert to hours for database storage\n    38→const TIER_ISOLATION_HOURS = {\n    39→  starter: 0,\n    40→  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n    41→  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n    42→  cancelled: 0\n    43→};\n    44→\n    45→// Overage rate for isolation beyond included minutes\n    46→const ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n    47→\n    48→/**\n    49→ * Initialize database tables\n    50→ */\n    51→async function initDatabase() {\n    52→  const client = await pool.connect();\n    53→  try {\n    54→    await client.query(`\n    55→      CREATE TABLE IF NOT EXISTS users (\n    56→        id SERIAL PRIMARY KEY,\n    57→        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n    58→        email VARCHAR(255),\n    59→        tier VARCHAR(50) DEFAULT 'starter',\n    60→        hours_remaining DECIMAL(10,4) DEFAULT 15,\n    61→        hours_total DECIMAL(10,4) DEFAULT 15,\n    62→        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n    63→        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n    64→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    65→        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    66→      )\n    67→    `);\n    68→\n    69→    // Add isolation columns if they don't exist (for existing databases)\n    70→    await client.query(`\n    71→      DO $$\n    72→      BEGIN\n    73→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n    74→          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n    75→        END IF;\n    76→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n    77→          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n    78→        END IF;\n    79→      END $$;\n    80→    `);\n    81→\n    82→    await client.query(`\n    83→      CREATE TABLE IF NOT EXISTS usage_log (\n    84→        id SERIAL PRIMARY KEY,\n    85→        user_id INTEGER REFERENCES users(id),\n    86→        stripe_customer_id VARCHAR(255),\n    87→        audio_duration_seconds DECIMAL(10,2),\n    88→        hours_used DECIMAL(10,6),\n    89→        endpoint VARCHAR(100),\n    90→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    91→      )\n    92→    `);\n    93→\n    94→    await client.query(`\n    95→      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    96→    `);\n    97→\n    98→    await client.query(`\n    99→      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n   100→    `);\n   101→\n   102→    // PERFORMANCE: Add composite index for efficient customer usage history queries\n   103→    await client.query(`\n   104→      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n   105→      ON usage_log(stripe_customer_id, created_at DESC)\n   106→    `);\n   107→\n   108→    // Webhook events table for idempotency\n   109→    await client.query(`\n   110→      CREATE TABLE IF NOT EXISTS webhook_events (\n   111→        id SERIAL PRIMARY KEY,\n   112→        event_id VARCHAR(255) UNIQUE NOT NULL,\n   113→        event_type VARCHAR(100),\n   114→        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n   115→      )\n   116→    `);\n   117→\n   118→    await client.query(`\n   119→      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n   120→    `);\n   121→\n   122→    console.log('[UsageTracking] Database initialized');\n   123→  } finally {\n   124→    client.release();\n   125→  }\n   126→}\n   127→\n   128→/**\n   129→ * Get or create a user by Stripe customer ID\n   130→ * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n   131→ */\n   132→async function getOrCreateUser(stripeCustomerId, email = null) {\n   133→  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n   134→  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n   135→  const result = await pool.query(\n   136→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   137→     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n   138→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   139→     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n   140→     RETURNING *`,\n   141→    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n   142→  );\n   143→\n   144→  return result.rows[0];\n   145→}\n   146→\n   147→/**\n   148→ * Get user's current credit balance\n   149→ */\n   150→async function getBalance(stripeCustomerId) {\n   151→  const user = await getOrCreateUser(stripeCustomerId);\n   152→  const hoursTotal = parseFloat(user.hours_total);\n   153→  const hoursRemaining = parseFloat(user.hours_remaining);\n   154→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   155→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   156→\n   157→  // Tier display names\n   158→  const tierNames = {\n   159→    starter: 'Starter',\n   160→    pro: 'Pro',\n   161→    team: 'Team',\n   162→    cancelled: 'Cancelled'\n   163→  };\n   164→\n   165→  return {\n   166→    hoursRemaining,\n   167→    hoursTotal,\n   168→    isolationHoursRemaining,\n   169→    isolationHoursTotal,\n   170→    tier: user.tier,\n   171→    tierName: tierNames[user.tier] || user.tier,\n   172→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   173→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   174→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   175→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   176→  };\n   177→}\n   178→\n   179→/**\n   180→ * Check if user has enough credits for estimated duration\n   181→ */\n   182→async function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n   183→  const balance = await getBalance(stripeCustomerId);\n   184→  const estimatedHours = estimatedSeconds / 3600;\n   185→  return balance.hoursRemaining >= estimatedHours;\n   186→}\n   187→\n   188→/**\n   189→ * Reserve credits atomically using SELECT ... FOR UPDATE\n   190→ * This prevents race conditions where multiple requests pass credit check\n   191→ * before any deduction occurs.\n   192→ *\n   193→ * @param {string} stripeCustomerId - Customer ID\n   194→ * @param {number} estimatedSeconds - Estimated processing time in seconds\n   195→ * @param {string} endpoint - Endpoint name for tracking\n   196→ * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n   197→ */\n   198→async function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n   199→  const estimatedHours = estimatedSeconds / 3600;\n   200→  const client = await pool.connect();\n   201→\n   202→  try {\n   203→    await client.query('BEGIN');\n   204→\n   205→    // Lock the row for this customer - prevents concurrent modifications\n   206→    const result = await client.query(\n   207→      `SELECT id, hours_remaining FROM users\n   208→       WHERE stripe_customer_id = $1\n   209→       FOR UPDATE`,\n   210→      [stripeCustomerId]\n   211→    );\n   212→\n   213→    if (result.rows.length === 0) {\n   214→      // Create user if doesn't exist (within transaction)\n   215→      const newUser = await client.query(\n   216→        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n   217→         VALUES ($1, 'starter', $2, $2)\n   218→         RETURNING id, hours_remaining`,\n   219→        [stripeCustomerId, TIER_HOURS.starter]\n   220→      );\n   221→      result.rows = newUser.rows;\n   222→    }\n   223→\n   224→    const user = result.rows[0];\n   225→    const hoursRemaining = parseFloat(user.hours_remaining);\n   226→\n   227→    // Check if enough credits\n   228→    if (hoursRemaining < estimatedHours) {\n   229→      await client.query('ROLLBACK');\n   230→      return {\n   231→        success: false,\n   232→        error: 'Insufficient credits',\n   233→        hoursRemaining,\n   234→        hoursRequired: estimatedHours\n   235→      };\n   236→    }\n   237→\n   238→    // Generate unique reservation ID\n   239→    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   240→\n   241→    // Reserve credits by deducting the estimated amount\n   242→    await client.query(\n   243→      `UPDATE users\n   244→       SET hours_remaining = hours_remaining - $1,\n   245→           updated_at = CURRENT_TIMESTAMP\n   246→       WHERE stripe_customer_id = $2`,\n   247→      [estimatedHours, stripeCustomerId]\n   248→    );\n   249→\n   250→    // Log the reservation\n   251→    await client.query(\n   252→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   253→       VALUES ($1, $2, $3, $4, $5)`,\n   254→      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n   255→    );\n   256→\n   257→    await client.query('COMMIT');\n   258→\n   259→    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n   260→\n   261→    return {\n   262→      success: true,\n   263→      reservationId,\n   264→      hoursReserved: estimatedHours,\n   265→      hoursRemaining: hoursRemaining - estimatedHours\n   266→    };\n   267→  } catch (err) {\n   268→    await client.query('ROLLBACK');\n   269→    console.error('[UsageTracking] Reservation error:', err);\n   270→    throw err;\n   271→  } finally {\n   272→    client.release();\n   273→  }\n   274→}\n   275→\n   276→/**\n   277→ * Confirm a reservation (finalize usage) or adjust for actual duration\n   278→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   279→ *\n   280→ * @param {string} stripeCustomerId - Customer ID\n   281→ * @param {number} actualSeconds - Actual processing time in seconds\n   282→ * @param {number} reservedSeconds - Originally reserved seconds\n   283→ * @param {string} endpoint - Endpoint name\n   284→ * @returns {Promise<object>} Updated balance\n   285→ */\n   286→async function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n   287→  const actualHours = actualSeconds / 3600;\n   288→  const reservedHours = reservedSeconds / 3600;\n   289→  const difference = reservedHours - actualHours;\n   290→\n   291→  const client = await pool.connect();\n   292→  try {\n   293→    await client.query('BEGIN');\n   294→\n   295→    // Lock the row and get current state\n   296→    const result = await client.query(\n   297→      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n   298→       FROM users\n   299→       WHERE stripe_customer_id = $1\n   300→       FOR UPDATE`,\n   301→      [stripeCustomerId]\n   302→    );\n   303→\n   304→    if (result.rows.length === 0) {\n   305→      await client.query('ROLLBACK');\n   306→      throw new Error('User not found');\n   307→    }\n   308→\n   309→    let user = result.rows[0];\n   310→\n   311→    // If actual usage was less than reserved, refund the difference\n   312→    if (difference > 0) {\n   313→      const updateResult = await client.query(\n   314→        `UPDATE users\n   315→         SET hours_remaining = hours_remaining + $1,\n   316→             updated_at = CURRENT_TIMESTAMP\n   317→         WHERE stripe_customer_id = $2\n   318→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   319→        [difference, stripeCustomerId]\n   320→      );\n   321→      user = { ...user, ...updateResult.rows[0] };\n   322→\n   323→      // Log the adjustment\n   324→      await client.query(\n   325→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   326→         VALUES ($1, $2, $3, $4, $5)`,\n   327→        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n   328→      );\n   329→    } else if (difference < 0) {\n   330→      // Actual usage was more than reserved - deduct the extra\n   331→      const updateResult = await client.query(\n   332→        `UPDATE users\n   333→         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   334→             updated_at = CURRENT_TIMESTAMP\n   335→         WHERE stripe_customer_id = $2\n   336→         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   337→        [-difference, stripeCustomerId]\n   338→      );\n   339→      user = { ...user, ...updateResult.rows[0] };\n   340→\n   341→      // Log the additional usage\n   342→      await client.query(\n   343→        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   344→         VALUES ($1, $2, $3, $4, $5)`,\n   345→        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n   346→      );\n   347→    }\n   348→\n   349→    await client.query('COMMIT');\n   350→\n   351→    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n   352→\n   353→    // Build balance from data we already have (no extra SELECT needed)\n   354→    const hoursTotal = parseFloat(user.hours_total);\n   355→    const hoursRemaining = parseFloat(user.hours_remaining);\n   356→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   357→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   358→\n   359→    const tierNames = {\n   360→      starter: 'Starter',\n   361→      pro: 'Pro',\n   362→      team: 'Team',\n   363→      cancelled: 'Cancelled'\n   364→    };\n   365→\n   366→    return {\n   367→      hoursRemaining,\n   368→      hoursTotal,\n   369→      isolationHoursRemaining,\n   370→      isolationHoursTotal,\n   371→      tier: user.tier,\n   372→      tierName: tierNames[user.tier] || user.tier,\n   373→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   374→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   375→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   376→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   377→    };\n   378→  } catch (err) {\n   379→    await client.query('ROLLBACK');\n   380→    throw err;\n   381→  } finally {\n   382→    client.release();\n   383→  }\n   384→}\n   385→\n   386→/**\n   387→ * Release a reservation (refund credits on processing failure)\n   388→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   389→ *\n   390→ * @param {string} stripeCustomerId - Customer ID\n   391→ * @param {number} reservedSeconds - Originally reserved seconds\n   392→ * @param {string} endpoint - Endpoint name\n   393→ * @param {string} reason - Reason for release\n   394→ * @returns {Promise<object>} Updated balance\n   395→ */\n   396→async function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n   397→  const reservedHours = reservedSeconds / 3600;\n   398→\n   399→  const client = await pool.connect();\n   400→  try {\n   401→    await client.query('BEGIN');\n   402→\n   403→    // Lock the row and get id for logging\n   404→    const result = await client.query(\n   405→      `SELECT id FROM users\n   406→       WHERE stripe_customer_id = $1\n   407→       FOR UPDATE`,\n   408→      [stripeCustomerId]\n   409→    );\n   410→\n   411→    if (result.rows.length === 0) {\n   412→      await client.query('ROLLBACK');\n   413→      throw new Error('User not found');\n   414→    }\n   415→\n   416→    const userId = result.rows[0].id;\n   417→\n   418→    // Refund the reserved amount with RETURNING\n   419→    const updateResult = await client.query(\n   420→      `UPDATE users\n   421→       SET hours_remaining = hours_remaining + $1,\n   422→           updated_at = CURRENT_TIMESTAMP\n   423→       WHERE stripe_customer_id = $2\n   424→       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   425→      [reservedHours, stripeCustomerId]\n   426→    );\n   427→\n   428→    const user = updateResult.rows[0];\n   429→\n   430→    // Log the refund\n   431→    await client.query(\n   432→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   433→       VALUES ($1, $2, $3, $4, $5)`,\n   434→      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n   435→    );\n   436→\n   437→    await client.query('COMMIT');\n   438→\n   439→    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n   440→\n   441→    // Build balance from RETURNING data (no extra SELECT needed)\n   442→    const hoursTotal = parseFloat(user.hours_total);\n   443→    const hoursRemaining = parseFloat(user.hours_remaining);\n   444→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   445→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   446→\n   447→    const tierNames = {\n   448→      starter: 'Starter',\n   449→      pro: 'Pro',\n   450→      team: 'Team',\n   451→      cancelled: 'Cancelled'\n   452→    };\n   453→\n   454→    return {\n   455→      hoursRemaining,\n   456→      hoursTotal,\n   457→      isolationHoursRemaining,\n   458→      isolationHoursTotal,\n   459→      tier: user.tier,\n   460→      tierName: tierNames[user.tier] || user.tier,\n   461→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   462→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   463→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   464→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   465→    };\n   466→  } catch (err) {\n   467→    await client.query('ROLLBACK');\n   468→    throw err;\n   469→  } finally {\n   470→    client.release();\n   471→  }\n   472→}\n   473→\n   474→/**\n   475→ * Check if user can use vocal isolation\n   476→ * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n   477→ */\n   478→async function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n   479→  const balance = await getBalance(stripeCustomerId);\n   480→\n   481→  // Starter tier has no isolation access\n   482→  if (!balance.hasIsolationAccess) {\n   483→    return {\n   484→      allowed: false,\n   485→      reason: 'upgrade_required',\n   486→      message: 'Vocal isolation requires Pro or Team tier',\n   487→      hasIncludedHours: false,\n   488→      overageRequired: false,\n   489→      overageCost: 0\n   490→    };\n   491→  }\n   492→\n   493→  const estimatedHours = estimatedMinutes / 60;\n   494→  const remainingIncluded = balance.isolationHoursRemaining;\n   495→\n   496→  // Check if within included hours\n   497→  if (remainingIncluded >= estimatedHours) {\n   498→    return {\n   499→      allowed: true,\n   500→      reason: 'included',\n   501→      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n   502→      hasIncludedHours: true,\n   503→      overageRequired: false,\n   504→      overageCost: 0,\n   505→      isolationHoursRemaining: remainingIncluded - estimatedHours\n   506→    };\n   507→  }\n   508→\n   509→  // Calculate overage\n   510→  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n   511→  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   512→\n   513→  return {\n   514→    allowed: true,\n   515→    reason: 'overage',\n   516→    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n   517→    hasIncludedHours: remainingIncluded > 0,\n   518→    overageRequired: true,\n   519→    overageMinutes,\n   520→    overageCost,\n   521→    isolationHoursRemaining: 0\n   522→  };\n   523→}\n   524→\n   525→/**\n   526→ * Deduct isolation usage from user's balance\n   527→ * Returns overage cost if beyond included hours\n   528→ * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n   529→ */\n   530→async function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n   531→  const durationMinutes = audioDurationSeconds / 60;\n   532→  const durationHours = audioDurationSeconds / 3600;\n   533→\n   534→  const client = await pool.connect();\n   535→  try {\n   536→    await client.query('BEGIN');\n   537→\n   538→    // Lock the row for this customer - prevents concurrent modifications\n   539→    const userResult = await client.query(\n   540→      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n   541→       FROM users WHERE stripe_customer_id = $1\n   542→       FOR UPDATE`,\n   543→      [stripeCustomerId]\n   544→    );\n   545→\n   546→    if (userResult.rows.length === 0) {\n   547→      await client.query('ROLLBACK');\n   548→      throw new Error('User not found');\n   549→    }\n   550→\n   551→    const user = userResult.rows[0];\n   552→    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n   553→\n   554→    let overageCost = 0;\n   555→    let hoursFromIncluded = 0;\n   556→    let overageMinutes = 0;\n   557→\n   558→    if (remainingIncluded >= durationHours) {\n   559→      // Fully covered by included hours\n   560→      hoursFromIncluded = durationHours;\n   561→    } else {\n   562→      // Partial or full overage\n   563→      hoursFromIncluded = remainingIncluded;\n   564→      overageMinutes = durationMinutes - (remainingIncluded * 60);\n   565→      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n   566→    }\n   567→\n   568→    // Update isolation balance with RETURNING to get new values\n   569→    const updateResult = await client.query(\n   570→      `UPDATE users\n   571→       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n   572→           updated_at = CURRENT_TIMESTAMP\n   573→       WHERE stripe_customer_id = $2\n   574→       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n   575→      [durationHours, stripeCustomerId]\n   576→    );\n   577→\n   578→    const updatedUser = updateResult.rows[0];\n   579→\n   580→    // Log usage (mark as isolation)\n   581→    await client.query(\n   582→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   583→       VALUES ($1, $2, $3, $4, $5)`,\n   584→      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n   585→    );\n   586→\n   587→    await client.query('COMMIT');\n   588→\n   589→    // Build balance from RETURNING data (no extra SELECT needed)\n   590→    const hoursTotal = parseFloat(updatedUser.hours_total);\n   591→    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n   592→    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n   593→    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n   594→\n   595→    const tierNames = {\n   596→      starter: 'Starter',\n   597→      pro: 'Pro',\n   598→      team: 'Team',\n   599→      cancelled: 'Cancelled'\n   600→    };\n   601→\n   602→    return {\n   603→      hoursRemaining,\n   604→      hoursTotal,\n   605→      isolationHoursRemaining,\n   606→      isolationHoursTotal,\n   607→      tier: updatedUser.tier,\n   608→      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n   609→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   610→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   611→      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n   612→      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n   613→      isolationUsed: {\n   614→        durationMinutes,\n   615→        hoursFromIncluded,\n   616→        overageMinutes,\n   617→        overageCost\n   618→      }\n   619→    };\n   620→  } catch (err) {\n   621→    await client.query('ROLLBACK');\n   622→    throw err;\n   623→  } finally {\n   624→    client.release();\n   625→  }\n   626→}\n   627→\n   628→/**\n   629→ * Deduct usage from user's balance\n   630→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   631→ * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n   632→ */\n   633→async function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n   634→  const hoursUsed = audioDurationSeconds / 3600;\n   635→\n   636→  const client = await pool.connect();\n   637→  try {\n   638→    await client.query('BEGIN');\n   639→\n   640→    // Combined UPDATE with RETURNING - single query for update + get new values\n   641→    const updateResult = await client.query(\n   642→      `UPDATE users\n   643→       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n   644→           updated_at = CURRENT_TIMESTAMP\n   645→       WHERE stripe_customer_id = $2\n   646→       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   647→      [hoursUsed, stripeCustomerId]\n   648→    );\n   649→\n   650→    if (updateResult.rows.length === 0) {\n   651→      await client.query('ROLLBACK');\n   652→      throw new Error('User not found');\n   653→    }\n   654→\n   655→    const user = updateResult.rows[0];\n   656→\n   657→    // Log usage\n   658→    await client.query(\n   659→      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n   660→       VALUES ($1, $2, $3, $4, $5)`,\n   661→      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n   662→    );\n   663→\n   664→    await client.query('COMMIT');\n   665→\n   666→    // Build balance from RETURNING data (no extra SELECT needed)\n   667→    const hoursTotal = parseFloat(user.hours_total);\n   668→    const hoursRemaining = parseFloat(user.hours_remaining);\n   669→    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   670→    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   671→\n   672→    const tierNames = {\n   673→      starter: 'Starter',\n   674→      pro: 'Pro',\n   675→      team: 'Team',\n   676→      cancelled: 'Cancelled'\n   677→    };\n   678→\n   679→    return {\n   680→      hoursRemaining,\n   681→      hoursTotal,\n   682→      isolationHoursRemaining,\n   683→      isolationHoursTotal,\n   684→      tier: user.tier,\n   685→      tierName: tierNames[user.tier] || user.tier,\n   686→      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   687→      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   688→      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   689→      isolationOverageRate: ISOLATION_OVERAGE_RATE\n   690→    };\n   691→  } catch (err) {\n   692→    await client.query('ROLLBACK');\n   693→    throw err;\n   694→  } finally {\n   695→    client.release();\n   696→  }\n   697→}\n   698→\n   699→/**\n   700→ * Reset user's hours for new billing period\n   701→ * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n   702→ */\n   703→async function resetHours(stripeCustomerId, tier) {\n   704→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   705→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   706→\n   707→  const result = await pool.query(\n   708→    `UPDATE users\n   709→     SET hours_remaining = $1, hours_total = $1,\n   710→         isolation_hours_remaining = $2, isolation_hours_total = $2,\n   711→         tier = $3, updated_at = CURRENT_TIMESTAMP\n   712→     WHERE stripe_customer_id = $4\n   713→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   714→    [hours, isolationHours, tier, stripeCustomerId]\n   715→  );\n   716→\n   717→  if (result.rows.length === 0) {\n   718→    // User doesn't exist, create and return default balance\n   719→    return await getBalance(stripeCustomerId);\n   720→  }\n   721→\n   722→  const user = result.rows[0];\n   723→  const hoursTotal = parseFloat(user.hours_total);\n   724→  const hoursRemaining = parseFloat(user.hours_remaining);\n   725→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   726→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   727→\n   728→  const tierNames = {\n   729→    starter: 'Starter',\n   730→    pro: 'Pro',\n   731→    team: 'Team',\n   732→    cancelled: 'Cancelled'\n   733→  };\n   734→\n   735→  return {\n   736→    hoursRemaining,\n   737→    hoursTotal,\n   738→    isolationHoursRemaining,\n   739→    isolationHoursTotal,\n   740→    tier: user.tier,\n   741→    tierName: tierNames[user.tier] || user.tier,\n   742→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   743→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   744→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   745→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   746→  };\n   747→}\n   748→\n   749→/**\n   750→ * Update user's tier (from Stripe webhook)\n   751→ * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n   752→ */\n   753→async function updateTier(stripeCustomerId, tier, email = null) {\n   754→  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n   755→  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n   756→\n   757→  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n   758→  const result = await pool.query(\n   759→    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n   760→     VALUES ($1, $2, $3, $4, $4, $5, $5)\n   761→     ON CONFLICT (stripe_customer_id) DO UPDATE\n   762→     SET tier = $3, hours_remaining = $4, hours_total = $4,\n   763→         isolation_hours_remaining = $5, isolation_hours_total = $5,\n   764→         updated_at = CURRENT_TIMESTAMP\n   765→     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n   766→    [stripeCustomerId, email, tier, hours, isolationHours]\n   767→  );\n   768→\n   769→  const user = result.rows[0];\n   770→  const hoursTotal = parseFloat(user.hours_total);\n   771→  const hoursRemaining = parseFloat(user.hours_remaining);\n   772→  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n   773→  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n   774→\n   775→  const tierNames = {\n   776→    starter: 'Starter',\n   777→    pro: 'Pro',\n   778→    team: 'Team',\n   779→    cancelled: 'Cancelled'\n   780→  };\n   781→\n   782→  return {\n   783→    hoursRemaining,\n   784→    hoursTotal,\n   785→    isolationHoursRemaining,\n   786→    isolationHoursTotal,\n   787→    tier: user.tier,\n   788→    tierName: tierNames[user.tier] || user.tier,\n   789→    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n   790→    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n   791→    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n   792→    isolationOverageRate: ISOLATION_OVERAGE_RATE\n   793→  };\n   794→}\n   795→\n   796→/**\n   797→ * Get usage history for a user\n   798→ */\n   799→async function getUsageHistory(stripeCustomerId, limit = 50) {\n   800→  const result = await pool.query(\n   801→    `SELECT * FROM usage_log\n   802→     WHERE stripe_customer_id = $1\n   803→     ORDER BY created_at DESC\n   804→     LIMIT $2`,\n   805→    [stripeCustomerId, limit]\n   806→  );\n   807→  return result.rows;\n   808→}\n   809→\n   810→/**\n   811→ * Check if webhook event has already been processed (idempotency)\n   812→ */\n   813→async function isEventProcessed(eventId) {\n   814→  const result = await pool.query(\n   815→    'SELECT id FROM webhook_events WHERE event_id = $1',\n   816→    [eventId]\n   817→  );\n   818→  return result.rows.length > 0;\n   819→}\n   820→\n   821→/**\n   822→ * Record a processed webhook event\n   823→ */\n   824→async function recordWebhookEvent(eventId, eventType) {\n   825→  try {\n   826→    await pool.query(\n   827→      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n   828→      [eventId, eventType]\n   829→    );\n   830→  } catch (err) {\n   831→    // Ignore duplicate key errors (race condition safety)\n   832→    if (err.code !== '23505') throw err;\n   833→  }\n   834→}\n   835→\n   836→// =============================================================================\n   837→// Music Credits Functions (Phase 4 - AI Music Feature)\n   838→// =============================================================================\n   839→\n   840→// Music credits per tier\n   841→const TIER_MUSIC_CREDITS = {\n   842→  starter: 5,    // 5 songs/month\n   843→  pro: 20,       // 20 songs/month\n   844→  team: 100,     // 100 songs/month\n   845→  cancelled: 0\n   846→};\n   847→\n   848→// Overage rates for music\n   849→const MUSIC_OVERAGE_RATES = {\n   850→  starter: 0.50,  // $0.50/song\n   851→  pro: 0.30,      // $0.30/song\n   852→  team: 0.20      // $0.20/song\n   853→};\n   854→\n   855→/**\n   856→ * Get music credits balance for a customer\n   857→ * @param {string} stripeCustomerId - Stripe customer ID\n   858→ * @returns {Promise<{remaining: number, total: number, tier: string}>}\n   859→ */\n   860→async function getMusicCredits(stripeCustomerId) {\n   861→  const result = await pool.query(\n   862→    `SELECT music_credits_remaining, music_credits_total, tier\n   863→     FROM users\n   864→     WHERE stripe_customer_id = $1`,\n   865→    [stripeCustomerId]\n   866→  );\n   867→\n   868→  if (result.rows.length === 0) {\n   869→    return { remaining: 0, total: 0, tier: 'starter' };\n   870→  }\n   871→\n   872→  const row = result.rows[0];\n   873→  return {\n   874→    remaining: row.music_credits_remaining || 0,\n   875→    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n   876→    tier: row.tier || 'starter'\n   877→  };\n   878→}\n   879→\n   880→/**\n   881→ * Check if customer has music credits available\n   882→ * @param {string} stripeCustomerId - Stripe customer ID\n   883→ * @returns {Promise<boolean>}\n   884→ */\n   885→async function hasMusicCredits(stripeCustomerId) {\n   886→  const credits = await getMusicCredits(stripeCustomerId);\n   887→  return credits.remaining > 0;\n   888→}\n   889→\n   890→/**\n   891→ * Deduct one music credit from customer\n   892→ * @param {string} stripeCustomerId - Stripe customer ID\n   893→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n   894→ */\n   895→async function deductMusicCredit(stripeCustomerId) {\n   896→  const client = await pool.connect();\n   897→  try {\n   898→    await client.query('BEGIN');\n   899→\n   900→    // Lock row for update\n   901→    const result = await client.query(\n   902→      `SELECT music_credits_remaining, tier\n   903→       FROM users\n   904→       WHERE stripe_customer_id = $1\n   905→       FOR UPDATE`,\n   906→      [stripeCustomerId]\n   907→    );\n   908→\n   909→    if (result.rows.length === 0) {\n   910→      await client.query('ROLLBACK');\n   911→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n   912→    }\n   913→\n   914→    const { music_credits_remaining, tier } = result.rows[0];\n   915→    let charged = 0;\n   916→\n   917→    if (music_credits_remaining > 0) {\n   918→      // Deduct from included credits\n   919→      await client.query(\n   920→        `UPDATE users\n   921→         SET music_credits_remaining = music_credits_remaining - 1,\n   922→             updated_at = CURRENT_TIMESTAMP\n   923→         WHERE stripe_customer_id = $1`,\n   924→        [stripeCustomerId]\n   925→      );\n   926→    } else {\n   927→      // Overage - charge at tier rate\n   928→      charged = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n   929→      // Note: In production, you'd create a Stripe usage record here\n   930→      console.log(`[SPLICE] Music overage: ${stripeCustomerId} charged $${charged}`);\n   931→    }\n   932→\n   933→    // Log the usage\n   934→    await client.query(\n   935→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n   936→       VALUES ($1, 1, $2)\n   937→       ON CONFLICT DO NOTHING`,\n   938→      [stripeCustomerId, charged]\n   939→    );\n   940→\n   941→    await client.query('COMMIT');\n   942→\n   943→    const newCredits = await getMusicCredits(stripeCustomerId);\n   944→    return {\n   945→      success: true,\n   946→      remaining: newCredits.remaining,\n   947→      charged\n   948→    };\n   949→\n   950→  } catch (err) {\n   951→    await client.query('ROLLBACK');\n   952→    console.error('[SPLICE] Music credit deduction error:', err.message);\n   953→    return { success: false, remaining: 0, charged: 0, error: err.message };\n   954→  } finally {\n   955→    client.release();\n   956→  }\n   957→}\n   958→\n   959→/**\n   960→ * Reset music credits based on tier (called on subscription renewal)\n   961→ * @param {string} stripeCustomerId - Stripe customer ID\n   962→ * @param {string} tier - Subscription tier\n   963→ */\n   964→async function resetMusicCredits(stripeCustomerId, tier) {\n   965→  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n   966→\n   967→  await pool.query(\n   968→    `UPDATE users\n   969→     SET music_credits_remaining = $2,\n   970→         music_credits_total = $2,\n   971→         music_credits_reset_at = CURRENT_TIMESTAMP,\n   972→         updated_at = CURRENT_TIMESTAMP\n   973→     WHERE stripe_customer_id = $1`,\n   974→    [stripeCustomerId, credits]\n   975→  );\n   976→}\n   977→\n   978→/**\n   979→ * Add music credits (for promotional or overage purchases)\n   980→ * @param {string} stripeCustomerId - Stripe customer ID\n   981→ * @param {number} credits - Number of credits to add\n   982→ * @returns {Promise<{success: boolean, newBalance: number}>}\n   983→ */\n   984→async function addMusicCredits(stripeCustomerId, credits) {\n   985→  const result = await pool.query(\n   986→    `UPDATE users\n   987→     SET music_credits_remaining = music_credits_remaining + $2,\n   988→         updated_at = CURRENT_TIMESTAMP\n   989→     WHERE stripe_customer_id = $1\n   990→     RETURNING music_credits_remaining`,\n   991→    [stripeCustomerId, credits]\n   992→  );\n   993→\n   994→  if (result.rows.length === 0) {\n   995→    return { success: false, newBalance: 0 };\n   996→  }\n   997→\n   998→  return {\n   999→    success: true,\n  1000→    newBalance: result.rows[0].music_credits_remaining\n  1001→  };\n  1002→}\n  1003→\n  1004→/**\n  1005→ * Get music usage history for a customer\n  1006→ * @param {string} stripeCustomerId - Stripe customer ID\n  1007→ * @param {number} limit - Max records to return\n  1008→ * @returns {Promise<Object[]>}\n  1009→ */\n  1010→async function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  1011→  const result = await pool.query(\n  1012→    `SELECT * FROM music_usage_log\n  1013→     WHERE stripe_customer_id = $1\n  1014→     ORDER BY created_at DESC\n  1015→     LIMIT $2`,\n  1016→    [stripeCustomerId, limit]\n  1017→  );\n  1018→  return result.rows;\n  1019→}\n  1020→\n  1021→/**\n  1022→ * Initialize music credits columns (migration helper)\n  1023→ */\n  1024→async function initMusicCreditsColumns() {\n  1025→  const client = await pool.connect();\n  1026→  try {\n  1027→    // Add music credits columns if they don't exist\n  1028→    await client.query(`\n  1029→      DO $$\n  1030→      BEGIN\n  1031→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n  1032→          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n  1033→        END IF;\n  1034→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n  1035→          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n  1036→        END IF;\n  1037→        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n  1038→          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n  1039→        END IF;\n  1040→      END $$;\n  1041→    `);\n  1042→\n  1043→    // Create music usage log table\n  1044→    await client.query(`\n  1045→      CREATE TABLE IF NOT EXISTS music_usage_log (\n  1046→        id SERIAL PRIMARY KEY,\n  1047→        stripe_customer_id VARCHAR(255) NOT NULL,\n  1048→        credits_used INTEGER DEFAULT 1,\n  1049→        overage_charged DECIMAL(10,2) DEFAULT 0,\n  1050→        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n  1051→      )\n  1052→    `);\n  1053→\n  1054→    await client.query(`\n  1055→      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n  1056→      ON music_usage_log(stripe_customer_id)\n  1057→    `);\n  1058→\n  1059→    console.log('[SPLICE] Music credits columns initialized');\n  1060→  } finally {\n  1061→    client.release();\n  1062→  }\n  1063→}\n  1064→\n  1065→// Variations credits cost (equivalent to 2.5 music credits)\n  1066→const VARIATIONS_CREDIT_COST = 2.5;\n  1067→\n  1068→// Overage rates for variations (higher than single music due to 3 parallel generations)\n  1069→const VARIATIONS_OVERAGE_RATES = {\n  1070→  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  1071→  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  1072→  team: 0.50      // $0.50/variations (2.5x $0.20)\n  1073→};\n  1074→\n  1075→// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\n  1076→const SCENE_AWARE_CREDIT_COST = 1.5;\n  1077→\n  1078→// Overage rates for scene-aware music (75% margin)\n  1079→const SCENE_AWARE_OVERAGE_RATES = {\n  1080→  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  1081→  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  1082→  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n  1083→};\n  1084→\n  1085→/**\n  1086→ * Check if customer has enough credits for variations (2.5 credits)\n  1087→ * @param {string} stripeCustomerId - Stripe customer ID\n  1088→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1089→ */\n  1090→async function checkVariationsCredits(stripeCustomerId) {\n  1091→  const credits = await getMusicCredits(stripeCustomerId);\n  1092→  const creditsRequired = VARIATIONS_CREDIT_COST;\n  1093→\n  1094→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1095→  // Or if they're on a paid tier (overage allowed)\n  1096→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1097→\n  1098→  return {\n  1099→    canGenerate,\n  1100→    creditsAvailable: credits.remaining,\n  1101→    creditsRequired,\n  1102→    tier: credits.tier\n  1103→  };\n  1104→}\n  1105→\n  1106→/**\n  1107→ * Deduct variations credit from customer (2.5 credits worth)\n  1108→ * @param {string} stripeCustomerId - Stripe customer ID\n  1109→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1110→ */\n  1111→async function deductVariationsCredit(stripeCustomerId) {\n  1112→  const client = await pool.connect();\n  1113→  try {\n  1114→    await client.query('BEGIN');\n  1115→\n  1116→    // Lock row for update\n  1117→    const result = await client.query(\n  1118→      `SELECT music_credits_remaining, tier\n  1119→       FROM users\n  1120→       WHERE stripe_customer_id = $1\n  1121→       FOR UPDATE`,\n  1122→      [stripeCustomerId]\n  1123→    );\n  1124→\n  1125→    if (result.rows.length === 0) {\n  1126→      await client.query('ROLLBACK');\n  1127→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1128→    }\n  1129→\n  1130→    const { music_credits_remaining, tier } = result.rows[0];\n  1131→    let charged = 0;\n  1132→    let creditsDeducted = 0;\n  1133→\n  1134→    // Determine how many credits to deduct vs overage to charge\n  1135→    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n  1136→      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n  1137→      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n  1138→      await client.query(\n  1139→        `UPDATE users\n  1140→         SET music_credits_remaining = music_credits_remaining - $2,\n  1141→             updated_at = CURRENT_TIMESTAMP\n  1142→         WHERE stripe_customer_id = $1`,\n  1143→        [stripeCustomerId, creditsDeducted]\n  1144→      );\n  1145→    } else if (music_credits_remaining > 0) {\n  1146→      // Partial credits - deduct what they have and charge overage for the rest\n  1147→      const creditsPortion = music_credits_remaining;\n  1148→      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n  1149→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1150→      charged = overagePortion * overageRate;\n  1151→\n  1152→      creditsDeducted = creditsPortion;\n  1153→      await client.query(\n  1154→        `UPDATE users\n  1155→         SET music_credits_remaining = 0,\n  1156→             updated_at = CURRENT_TIMESTAMP\n  1157→         WHERE stripe_customer_id = $1`,\n  1158→        [stripeCustomerId]\n  1159→      );\n  1160→\n  1161→      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1162→    } else {\n  1163→      // No credits - full overage\n  1164→      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n  1165→      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1166→    }\n  1167→\n  1168→    // Log the usage\n  1169→    await client.query(\n  1170→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1171→       VALUES ($1, $2, $3)\n  1172→       ON CONFLICT DO NOTHING`,\n  1173→      [stripeCustomerId, creditsDeducted, charged]\n  1174→    );\n  1175→\n  1176→    await client.query('COMMIT');\n  1177→\n  1178→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1179→    return {\n  1180→      success: true,\n  1181→      remaining: newCredits.remaining,\n  1182→      creditsDeducted,\n  1183→      charged\n  1184→    };\n  1185→\n  1186→  } catch (err) {\n  1187→    await client.query('ROLLBACK');\n  1188→    console.error('[SPLICE] Variations credit deduction error:', err.message);\n  1189→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1190→  } finally {\n  1191→    client.release();\n  1192→  }\n  1193→}\n  1194→\n  1195→/**\n  1196→ * Check if customer has enough credits for scene-aware music (1.5 credits)\n  1197→ * @param {string} stripeCustomerId - Stripe customer ID\n  1198→ * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n  1199→ */\n  1200→async function checkSceneAwareCredits(stripeCustomerId) {\n  1201→  const credits = await getMusicCredits(stripeCustomerId);\n  1202→  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n  1203→\n  1204→  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  1205→  // Or if they're on a paid tier (overage allowed)\n  1206→  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n  1207→\n  1208→  return {\n  1209→    canGenerate,\n  1210→    creditsAvailable: credits.remaining,\n  1211→    creditsRequired,\n  1212→    tier: credits.tier\n  1213→  };\n  1214→}\n  1215→\n  1216→/**\n  1217→ * Deduct scene-aware music credit from customer (1.5 credits worth)\n  1218→ * @param {string} stripeCustomerId - Stripe customer ID\n  1219→ * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n  1220→ */\n  1221→async function deductSceneAwareCredit(stripeCustomerId) {\n  1222→  const client = await pool.connect();\n  1223→  try {\n  1224→    await client.query('BEGIN');\n  1225→\n  1226→    // Lock row for update\n  1227→    const result = await client.query(\n  1228→      `SELECT music_credits_remaining, tier\n  1229→       FROM users\n  1230→       WHERE stripe_customer_id = $1\n  1231→       FOR UPDATE`,\n  1232→      [stripeCustomerId]\n  1233→    );\n  1234→\n  1235→    if (result.rows.length === 0) {\n  1236→      await client.query('ROLLBACK');\n  1237→      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n  1238→    }\n  1239→\n  1240→    const { music_credits_remaining, tier } = result.rows[0];\n  1241→    let charged = 0;\n  1242→    let creditsDeducted = 0;\n  1243→\n  1244→    // Determine how many credits to deduct vs overage to charge\n  1245→    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n  1246→      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n  1247→      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n  1248→      await client.query(\n  1249→        `UPDATE users\n  1250→         SET music_credits_remaining = music_credits_remaining - $2,\n  1251→             updated_at = CURRENT_TIMESTAMP\n  1252→         WHERE stripe_customer_id = $1`,\n  1253→        [stripeCustomerId, creditsDeducted]\n  1254→      );\n  1255→    } else if (music_credits_remaining > 0) {\n  1256→      // Partial credits - deduct what they have and charge overage for the rest\n  1257→      const creditsPortion = music_credits_remaining;\n  1258→      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n  1259→      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n  1260→      charged = overagePortion * overageRate;\n  1261→\n  1262→      creditsDeducted = creditsPortion;\n  1263→      await client.query(\n  1264→        `UPDATE users\n  1265→         SET music_credits_remaining = 0,\n  1266→             updated_at = CURRENT_TIMESTAMP\n  1267→         WHERE stripe_customer_id = $1`,\n  1268→        [stripeCustomerId]\n  1269→      );\n  1270→\n  1271→      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n  1272→    } else {\n  1273→      // No credits - full overage\n  1274→      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n  1275→      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n  1276→    }\n  1277→\n  1278→    // Log the usage\n  1279→    await client.query(\n  1280→      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n  1281→       VALUES ($1, $2, $3)\n  1282→       ON CONFLICT DO NOTHING`,\n  1283→      [stripeCustomerId, creditsDeducted, charged]\n  1284→    );\n  1285→\n  1286→    await client.query('COMMIT');\n  1287→\n  1288→    const newCredits = await getMusicCredits(stripeCustomerId);\n  1289→    return {\n  1290→      success: true,\n  1291→      remaining: newCredits.remaining,\n  1292→      creditsDeducted,\n  1293→      charged\n  1294→    };\n  1295→\n  1296→  } catch (err) {\n  1297→    await client.query('ROLLBACK');\n  1298→    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n  1299→    return { success: false, remaining: 0, charged: 0, error: err.message };\n  1300→  } finally {\n  1301→    client.release();\n  1302→  }\n  1303→}\n  1304→\n  1305→module.exports = {\n  1306→  initDatabase,\n  1307→  getOrCreateUser,\n  1308→  getBalance,\n  1309→  hasCredits,\n  1310→  reserveCredits,\n  1311→  confirmReservation,\n  1312→  releaseReservation,\n  1313→  checkIsolationAccess,\n  1314→  deductUsage,\n  1315→  deductIsolationUsage,\n  1316→  resetHours,\n  1317→  updateTier,\n  1318→  getUsageHistory,\n  1319→  isEventProcessed,\n  1320→  recordWebhookEvent,\n  1321→  // Music credits functions\n  1322→  getMusicCredits,\n  1323→  hasMusicCredits,\n  1324→  deductMusicCredit,\n  1325→  resetMusicCredits,\n  1326→  addMusicCredits,\n  1327→  getMusicUsageHistory,\n  1328→  initMusicCreditsColumns,\n  1329→  // Variations credits functions\n  1330→  checkVariationsCredits,\n  1331→  deductVariationsCredit,\n  1332→  // Scene-aware credits functions\n  1333→  checkSceneAwareCredits,\n  1334→  deductSceneAwareCredit,\n  1335→  // Constants\n  1336→  TIER_HOURS,\n  1337→  TIER_ISOLATION_MINUTES,\n  1338→  TIER_ISOLATION_HOURS,\n  1339→  ISOLATION_OVERAGE_RATE,\n  1340→  TIER_MUSIC_CREDITS,\n  1341→  MUSIC_OVERAGE_RATES,\n  1342→  VARIATIONS_CREDIT_COST,\n  1343→  VARIATIONS_OVERAGE_RATES,\n  1344→  SCENE_AWARE_CREDIT_COST,\n  1345→  SCENE_AWARE_OVERAGE_RATES\n  1346→};\n  1347→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d5e21f99-75bb-4819-bbc0-c98a926e191b","timestamp":"2025-12-27T01:35:06.704Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js","content":"/**\n * Usage Tracking Service\n *\n * Tracks user credit balances and usage for billing.\n * Uses PostgreSQL for persistence.\n */\n\nconst { Pool } = require('pg');\n\n// PostgreSQL connection pool with proper limits\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n  // PERFORMANCE: Set connection pool limits\n  max: 20,                    // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000,   // Close idle connections after 30 seconds\n  connectionTimeoutMillis: 5000  // Timeout after 5 seconds when getting connection\n});\n\n// Hours per tier (regular processing)\n// Pricing: Starter $19/mo, Pro $49/mo, Team $149/mo\nconst TIER_HOURS = {\n  starter: 12,   // 12 hrs/month\n  pro: 30,       // 30 hrs/month\n  team: 100,     // 100 hrs/month\n  cancelled: 0\n};\n\n// Isolation minutes per tier (sized to maintain 80% margins)\nconst TIER_ISOLATION_MINUTES = {\n  starter: 0,     // No isolation access\n  pro: 45,        // 45 minutes included\n  team: 180,      // 3 hours included\n  cancelled: 0\n};\n\n// Convert to hours for database storage\nconst TIER_ISOLATION_HOURS = {\n  starter: 0,\n  pro: TIER_ISOLATION_MINUTES.pro / 60,      // 0.75 hours\n  team: TIER_ISOLATION_MINUTES.team / 60,    // 3 hours\n  cancelled: 0\n};\n\n// Overage rate for isolation beyond included minutes\nconst ISOLATION_OVERAGE_RATE = 0.10; // $0.10 per minute (85% margin)\n\n/**\n * Initialize database tables\n */\nasync function initDatabase() {\n  const client = await pool.connect();\n  try {\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) UNIQUE NOT NULL,\n        email VARCHAR(255),\n        tier VARCHAR(50) DEFAULT 'starter',\n        hours_remaining DECIMAL(10,4) DEFAULT 15,\n        hours_total DECIMAL(10,4) DEFAULT 15,\n        isolation_hours_remaining DECIMAL(10,4) DEFAULT 0,\n        isolation_hours_total DECIMAL(10,4) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Add isolation columns if they don't exist (for existing databases)\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_remaining') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_remaining DECIMAL(10,4) DEFAULT 0;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'isolation_hours_total') THEN\n          ALTER TABLE users ADD COLUMN isolation_hours_total DECIMAL(10,4) DEFAULT 0;\n        END IF;\n      END $$;\n    `);\n\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS usage_log (\n        id SERIAL PRIMARY KEY,\n        user_id INTEGER REFERENCES users(id),\n        stripe_customer_id VARCHAR(255),\n        audio_duration_seconds DECIMAL(10,2),\n        hours_used DECIMAL(10,6),\n        endpoint VARCHAR(100),\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_users_stripe_customer_id ON users(stripe_customer_id)\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_user_id ON usage_log(user_id)\n    `);\n\n    // PERFORMANCE: Add composite index for efficient customer usage history queries\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_usage_log_customer_created\n      ON usage_log(stripe_customer_id, created_at DESC)\n    `);\n\n    // Webhook events table for idempotency\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS webhook_events (\n        id SERIAL PRIMARY KEY,\n        event_id VARCHAR(255) UNIQUE NOT NULL,\n        event_type VARCHAR(100),\n        processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_webhook_events_event_id ON webhook_events(event_id)\n    `);\n\n    console.log('[UsageTracking] Database initialized');\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Get or create a user by Stripe customer ID\n * PERF-005: Uses INSERT...ON CONFLICT upsert for single-query operation\n */\nasync function getOrCreateUser(stripeCustomerId, email = null) {\n  // Use upsert with ON CONFLICT DO UPDATE to ensure RETURNING works for both cases\n  // The update sets stripe_customer_id = EXCLUDED.stripe_customer_id (no-op) to trigger RETURNING\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, 'starter', $3, $3, $4, $4)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET stripe_customer_id = EXCLUDED.stripe_customer_id\n     RETURNING *`,\n    [stripeCustomerId, email, TIER_HOURS.starter, TIER_ISOLATION_HOURS.starter]\n  );\n\n  return result.rows[0];\n}\n\n/**\n * Get user's current credit balance\n */\nasync function getBalance(stripeCustomerId) {\n  const user = await getOrCreateUser(stripeCustomerId);\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  // Tier display names\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Check if user has enough credits for estimated duration\n */\nasync function hasCredits(stripeCustomerId, estimatedSeconds = 0) {\n  const balance = await getBalance(stripeCustomerId);\n  const estimatedHours = estimatedSeconds / 3600;\n  return balance.hoursRemaining >= estimatedHours;\n}\n\n/**\n * Reserve credits atomically using SELECT ... FOR UPDATE\n * This prevents race conditions where multiple requests pass credit check\n * before any deduction occurs.\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} estimatedSeconds - Estimated processing time in seconds\n * @param {string} endpoint - Endpoint name for tracking\n * @returns {Promise<{success: boolean, reservationId?: string, error?: string}>}\n */\nasync function reserveCredits(stripeCustomerId, estimatedSeconds = 0, endpoint = 'unknown') {\n  const estimatedHours = estimatedSeconds / 3600;\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const result = await client.query(\n      `SELECT id, hours_remaining FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      // Create user if doesn't exist (within transaction)\n      const newUser = await client.query(\n        `INSERT INTO users (stripe_customer_id, tier, hours_remaining, hours_total)\n         VALUES ($1, 'starter', $2, $2)\n         RETURNING id, hours_remaining`,\n        [stripeCustomerId, TIER_HOURS.starter]\n      );\n      result.rows = newUser.rows;\n    }\n\n    const user = result.rows[0];\n    const hoursRemaining = parseFloat(user.hours_remaining);\n\n    // Check if enough credits\n    if (hoursRemaining < estimatedHours) {\n      await client.query('ROLLBACK');\n      return {\n        success: false,\n        error: 'Insufficient credits',\n        hoursRemaining,\n        hoursRequired: estimatedHours\n      };\n    }\n\n    // Generate unique reservation ID\n    const reservationId = `res_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Reserve credits by deducting the estimated amount\n    await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining - $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2`,\n      [estimatedHours, stripeCustomerId]\n    );\n\n    // Log the reservation\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, estimatedSeconds, estimatedHours, `${endpoint}:reserved`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Reserved ${estimatedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reservationId})`);\n\n    return {\n      success: true,\n      reservationId,\n      hoursReserved: estimatedHours,\n      hoursRemaining: hoursRemaining - estimatedHours\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[UsageTracking] Reservation error:', err);\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Confirm a reservation (finalize usage) or adjust for actual duration\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} actualSeconds - Actual processing time in seconds\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @returns {Promise<object>} Updated balance\n */\nasync function confirmReservation(stripeCustomerId, actualSeconds, reservedSeconds, endpoint = 'unknown') {\n  const actualHours = actualSeconds / 3600;\n  const reservedHours = reservedSeconds / 3600;\n  const difference = reservedHours - actualHours;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get current state\n    const result = await client.query(\n      `SELECT id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    let user = result.rows[0];\n\n    // If actual usage was less than reserved, refund the difference\n    if (difference > 0) {\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = hours_remaining + $1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the adjustment\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, -(reservedSeconds - actualSeconds), -difference, `${endpoint}:adjusted`]\n      );\n    } else if (difference < 0) {\n      // Actual usage was more than reserved - deduct the extra\n      const updateResult = await client.query(\n        `UPDATE users\n         SET hours_remaining = GREATEST(0, hours_remaining - $1),\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $2\n         RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n        [-difference, stripeCustomerId]\n      );\n      user = { ...user, ...updateResult.rows[0] };\n\n      // Log the additional usage\n      await client.query(\n        `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n         VALUES ($1, $2, $3, $4, $5)`,\n        [user.id, stripeCustomerId, actualSeconds - reservedSeconds, -difference, `${endpoint}:additional`]\n      );\n    }\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Confirmed ${actualHours.toFixed(4)}hrs (reserved: ${reservedHours.toFixed(4)}) for ${stripeCustomerId}`);\n\n    // Build balance from data we already have (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Release a reservation (refund credits on processing failure)\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n *\n * @param {string} stripeCustomerId - Customer ID\n * @param {number} reservedSeconds - Originally reserved seconds\n * @param {string} endpoint - Endpoint name\n * @param {string} reason - Reason for release\n * @returns {Promise<object>} Updated balance\n */\nasync function releaseReservation(stripeCustomerId, reservedSeconds, endpoint = 'unknown', reason = 'failed') {\n  const reservedHours = reservedSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row and get id for logging\n    const result = await client.query(\n      `SELECT id FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const userId = result.rows[0].id;\n\n    // Refund the reserved amount with RETURNING\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = hours_remaining + $1,\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [reservedHours, stripeCustomerId]\n    );\n\n    const user = updateResult.rows[0];\n\n    // Log the refund\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [userId, stripeCustomerId, -reservedSeconds, -reservedHours, `${endpoint}:released:${reason}`]\n    );\n\n    await client.query('COMMIT');\n\n    console.log(`[UsageTracking] Released ${reservedHours.toFixed(4)}hrs for ${stripeCustomerId} (${reason})`);\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if user can use vocal isolation\n * Returns: { allowed, hasIncludedHours, overageRequired, overageCost }\n */\nasync function checkIsolationAccess(stripeCustomerId, estimatedMinutes = 0) {\n  const balance = await getBalance(stripeCustomerId);\n\n  // Starter tier has no isolation access\n  if (!balance.hasIsolationAccess) {\n    return {\n      allowed: false,\n      reason: 'upgrade_required',\n      message: 'Vocal isolation requires Pro or Team tier',\n      hasIncludedHours: false,\n      overageRequired: false,\n      overageCost: 0\n    };\n  }\n\n  const estimatedHours = estimatedMinutes / 60;\n  const remainingIncluded = balance.isolationHoursRemaining;\n\n  // Check if within included hours\n  if (remainingIncluded >= estimatedHours) {\n    return {\n      allowed: true,\n      reason: 'included',\n      message: `Using ${estimatedMinutes.toFixed(1)} min of included isolation time`,\n      hasIncludedHours: true,\n      overageRequired: false,\n      overageCost: 0,\n      isolationHoursRemaining: remainingIncluded - estimatedHours\n    };\n  }\n\n  // Calculate overage\n  const overageMinutes = estimatedMinutes - (remainingIncluded * 60);\n  const overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n\n  return {\n    allowed: true,\n    reason: 'overage',\n    message: `${remainingIncluded > 0 ? `Using ${(remainingIncluded * 60).toFixed(1)} included min + ` : ''}${overageMinutes.toFixed(1)} min overage ($${overageCost.toFixed(2)})`,\n    hasIncludedHours: remainingIncluded > 0,\n    overageRequired: true,\n    overageMinutes,\n    overageCost,\n    isolationHoursRemaining: 0\n  };\n}\n\n/**\n * Deduct isolation usage from user's balance\n * Returns overage cost if beyond included hours\n * Uses SELECT...FOR UPDATE to prevent race conditions (like confirmReservation)\n */\nasync function deductIsolationUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'isolate-vocals') {\n  const durationMinutes = audioDurationSeconds / 60;\n  const durationHours = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock the row for this customer - prevents concurrent modifications\n    const userResult = await client.query(\n      `SELECT id, isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier\n       FROM users WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (userResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const user = userResult.rows[0];\n    const remainingIncluded = parseFloat(user.isolation_hours_remaining || 0);\n\n    let overageCost = 0;\n    let hoursFromIncluded = 0;\n    let overageMinutes = 0;\n\n    if (remainingIncluded >= durationHours) {\n      // Fully covered by included hours\n      hoursFromIncluded = durationHours;\n    } else {\n      // Partial or full overage\n      hoursFromIncluded = remainingIncluded;\n      overageMinutes = durationMinutes - (remainingIncluded * 60);\n      overageCost = overageMinutes * ISOLATION_OVERAGE_RATE;\n    }\n\n    // Update isolation balance with RETURNING to get new values\n    const updateResult = await client.query(\n      `UPDATE users\n       SET isolation_hours_remaining = GREATEST(0, isolation_hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING isolation_hours_remaining, isolation_hours_total, hours_remaining, hours_total, tier`,\n      [durationHours, stripeCustomerId]\n    );\n\n    const updatedUser = updateResult.rows[0];\n\n    // Log usage (mark as isolation)\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, durationHours, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(updatedUser.hours_total);\n    const hoursRemaining = parseFloat(updatedUser.hours_remaining);\n    const isolationHoursTotal = parseFloat(updatedUser.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(updatedUser.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: updatedUser.tier,\n      tierName: tierNames[updatedUser.tier] || updatedUser.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[updatedUser.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE,\n      isolationUsed: {\n        durationMinutes,\n        hoursFromIncluded,\n        overageMinutes,\n        overageCost\n      }\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Deduct usage from user's balance\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n * Uses transaction with rollback on failure for atomic UPDATE + INSERT\n */\nasync function deductUsage(stripeCustomerId, audioDurationSeconds, endpoint = 'unknown') {\n  const hoursUsed = audioDurationSeconds / 3600;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Combined UPDATE with RETURNING - single query for update + get new values\n    const updateResult = await client.query(\n      `UPDATE users\n       SET hours_remaining = GREATEST(0, hours_remaining - $1),\n           updated_at = CURRENT_TIMESTAMP\n       WHERE stripe_customer_id = $2\n       RETURNING id, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n      [hoursUsed, stripeCustomerId]\n    );\n\n    if (updateResult.rows.length === 0) {\n      await client.query('ROLLBACK');\n      throw new Error('User not found');\n    }\n\n    const user = updateResult.rows[0];\n\n    // Log usage\n    await client.query(\n      `INSERT INTO usage_log (user_id, stripe_customer_id, audio_duration_seconds, hours_used, endpoint)\n       VALUES ($1, $2, $3, $4, $5)`,\n      [user.id, stripeCustomerId, audioDurationSeconds, hoursUsed, endpoint]\n    );\n\n    await client.query('COMMIT');\n\n    // Build balance from RETURNING data (no extra SELECT needed)\n    const hoursTotal = parseFloat(user.hours_total);\n    const hoursRemaining = parseFloat(user.hours_remaining);\n    const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n    const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n    const tierNames = {\n      starter: 'Starter',\n      pro: 'Pro',\n      team: 'Team',\n      cancelled: 'Cancelled'\n    };\n\n    return {\n      hoursRemaining,\n      hoursTotal,\n      isolationHoursRemaining,\n      isolationHoursTotal,\n      tier: user.tier,\n      tierName: tierNames[user.tier] || user.tier,\n      percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n      isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n      hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n      isolationOverageRate: ISOLATION_OVERAGE_RATE\n    };\n  } catch (err) {\n    await client.query('ROLLBACK');\n    throw err;\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset user's hours for new billing period\n * Optimized: uses RETURNING to avoid extra SELECT after UPDATE\n */\nasync function resetHours(stripeCustomerId, tier) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  const result = await pool.query(\n    `UPDATE users\n     SET hours_remaining = $1, hours_total = $1,\n         isolation_hours_remaining = $2, isolation_hours_total = $2,\n         tier = $3, updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $4\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [hours, isolationHours, tier, stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    // User doesn't exist, create and return default balance\n    return await getBalance(stripeCustomerId);\n  }\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Update user's tier (from Stripe webhook)\n * Optimized: uses RETURNING and INSERT...ON CONFLICT for upsert\n */\nasync function updateTier(stripeCustomerId, tier, email = null) {\n  const hours = tier in TIER_HOURS ? TIER_HOURS[tier] : TIER_HOURS.starter;\n  const isolationHours = tier in TIER_ISOLATION_HOURS ? TIER_ISOLATION_HOURS[tier] : 0;\n\n  // Use upsert (INSERT...ON CONFLICT) with RETURNING to handle create/update in one query\n  const result = await pool.query(\n    `INSERT INTO users (stripe_customer_id, email, tier, hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total)\n     VALUES ($1, $2, $3, $4, $4, $5, $5)\n     ON CONFLICT (stripe_customer_id) DO UPDATE\n     SET tier = $3, hours_remaining = $4, hours_total = $4,\n         isolation_hours_remaining = $5, isolation_hours_total = $5,\n         updated_at = CURRENT_TIMESTAMP\n     RETURNING hours_remaining, hours_total, isolation_hours_remaining, isolation_hours_total, tier`,\n    [stripeCustomerId, email, tier, hours, isolationHours]\n  );\n\n  const user = result.rows[0];\n  const hoursTotal = parseFloat(user.hours_total);\n  const hoursRemaining = parseFloat(user.hours_remaining);\n  const isolationHoursTotal = parseFloat(user.isolation_hours_total || 0);\n  const isolationHoursRemaining = parseFloat(user.isolation_hours_remaining || 0);\n\n  const tierNames = {\n    starter: 'Starter',\n    pro: 'Pro',\n    team: 'Team',\n    cancelled: 'Cancelled'\n  };\n\n  return {\n    hoursRemaining,\n    hoursTotal,\n    isolationHoursRemaining,\n    isolationHoursTotal,\n    tier: user.tier,\n    tierName: tierNames[user.tier] || user.tier,\n    percentUsed: hoursTotal > 0 ? ((hoursTotal - hoursRemaining) / hoursTotal * 100).toFixed(1) : '0.0',\n    isolationPercentUsed: isolationHoursTotal > 0 ? ((isolationHoursTotal - isolationHoursRemaining) / isolationHoursTotal * 100).toFixed(1) : '0.0',\n    hasIsolationAccess: TIER_ISOLATION_HOURS[user.tier] > 0,\n    isolationOverageRate: ISOLATION_OVERAGE_RATE\n  };\n}\n\n/**\n * Get usage history for a user\n */\nasync function getUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Check if webhook event has already been processed (idempotency)\n */\nasync function isEventProcessed(eventId) {\n  const result = await pool.query(\n    'SELECT id FROM webhook_events WHERE event_id = $1',\n    [eventId]\n  );\n  return result.rows.length > 0;\n}\n\n/**\n * Record a processed webhook event\n */\nasync function recordWebhookEvent(eventId, eventType) {\n  try {\n    await pool.query(\n      'INSERT INTO webhook_events (event_id, event_type) VALUES ($1, $2) ON CONFLICT (event_id) DO NOTHING',\n      [eventId, eventType]\n    );\n  } catch (err) {\n    // Ignore duplicate key errors (race condition safety)\n    if (err.code !== '23505') throw err;\n  }\n}\n\n// =============================================================================\n// Music Credits Functions (Phase 4 - AI Music Feature)\n// =============================================================================\n\n// Music credits per tier\nconst TIER_MUSIC_CREDITS = {\n  starter: 5,    // 5 songs/month\n  pro: 20,       // 20 songs/month\n  team: 100,     // 100 songs/month\n  cancelled: 0\n};\n\n// Overage rates for music\nconst MUSIC_OVERAGE_RATES = {\n  starter: 0.50,  // $0.50/song\n  pro: 0.30,      // $0.30/song\n  team: 0.20      // $0.20/song\n};\n\n/**\n * Get music credits balance for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{remaining: number, total: number, tier: string}>}\n */\nasync function getMusicCredits(stripeCustomerId) {\n  const result = await pool.query(\n    `SELECT music_credits_remaining, music_credits_total, tier\n     FROM users\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId]\n  );\n\n  if (result.rows.length === 0) {\n    return { remaining: 0, total: 0, tier: 'starter' };\n  }\n\n  const row = result.rows[0];\n  return {\n    remaining: row.music_credits_remaining || 0,\n    total: row.music_credits_total || TIER_MUSIC_CREDITS[row.tier] || 0,\n    tier: row.tier || 'starter'\n  };\n}\n\n/**\n * Check if customer has music credits available\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<boolean>}\n */\nasync function hasMusicCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  return credits.remaining > 0;\n}\n\n/**\n * Deduct one music credit from customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductMusicCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n\n    if (music_credits_remaining > 0) {\n      // Deduct from included credits\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - 1,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n    } else {\n      // Overage - charge at tier rate\n      charged = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      // Note: In production, you'd create a Stripe usage record here\n      console.log(`[SPLICE] Music overage: ${stripeCustomerId} charged $${charged}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, 1, $2)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Music credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Reset music credits based on tier (called on subscription renewal)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {string} tier - Subscription tier\n */\nasync function resetMusicCredits(stripeCustomerId, tier) {\n  const credits = TIER_MUSIC_CREDITS[tier] || TIER_MUSIC_CREDITS.starter;\n\n  await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = $2,\n         music_credits_total = $2,\n         music_credits_reset_at = CURRENT_TIMESTAMP,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1`,\n    [stripeCustomerId, credits]\n  );\n}\n\n/**\n * Add music credits (for promotional or overage purchases)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} credits - Number of credits to add\n * @returns {Promise<{success: boolean, newBalance: number}>}\n */\nasync function addMusicCredits(stripeCustomerId, credits) {\n  const result = await pool.query(\n    `UPDATE users\n     SET music_credits_remaining = music_credits_remaining + $2,\n         updated_at = CURRENT_TIMESTAMP\n     WHERE stripe_customer_id = $1\n     RETURNING music_credits_remaining`,\n    [stripeCustomerId, credits]\n  );\n\n  if (result.rows.length === 0) {\n    return { success: false, newBalance: 0 };\n  }\n\n  return {\n    success: true,\n    newBalance: result.rows[0].music_credits_remaining\n  };\n}\n\n/**\n * Get music usage history for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @param {number} limit - Max records to return\n * @returns {Promise<Object[]>}\n */\nasync function getMusicUsageHistory(stripeCustomerId, limit = 50) {\n  const result = await pool.query(\n    `SELECT * FROM music_usage_log\n     WHERE stripe_customer_id = $1\n     ORDER BY created_at DESC\n     LIMIT $2`,\n    [stripeCustomerId, limit]\n  );\n  return result.rows;\n}\n\n/**\n * Initialize music credits columns (migration helper)\n */\nasync function initMusicCreditsColumns() {\n  const client = await pool.connect();\n  try {\n    // Add music credits columns if they don't exist\n    await client.query(`\n      DO $$\n      BEGIN\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_remaining') THEN\n          ALTER TABLE users ADD COLUMN music_credits_remaining INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_total') THEN\n          ALTER TABLE users ADD COLUMN music_credits_total INTEGER DEFAULT 5;\n        END IF;\n        IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'users' AND column_name = 'music_credits_reset_at') THEN\n          ALTER TABLE users ADD COLUMN music_credits_reset_at TIMESTAMP;\n        END IF;\n      END $$;\n    `);\n\n    // Create music usage log table\n    await client.query(`\n      CREATE TABLE IF NOT EXISTS music_usage_log (\n        id SERIAL PRIMARY KEY,\n        stripe_customer_id VARCHAR(255) NOT NULL,\n        credits_used INTEGER DEFAULT 1,\n        overage_charged DECIMAL(10,2) DEFAULT 0,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    await client.query(`\n      CREATE INDEX IF NOT EXISTS idx_music_usage_customer\n      ON music_usage_log(stripe_customer_id)\n    `);\n\n    console.log('[SPLICE] Music credits columns initialized');\n  } finally {\n    client.release();\n  }\n}\n\n// Variations credits cost (equivalent to 2.5 music credits)\nconst VARIATIONS_CREDIT_COST = 2.5;\n\n// Overage rates for variations (higher than single music due to 3 parallel generations)\nconst VARIATIONS_OVERAGE_RATES = {\n  starter: 1.25,  // $1.25/variations (2.5x $0.50)\n  pro: 0.75,      // $0.75/variations (2.5x $0.30)\n  team: 0.50      // $0.50/variations (2.5x $0.20)\n};\n\n// Scene-aware music credits cost (1.5 credits for transcript analysis + generation)\nconst SCENE_AWARE_CREDIT_COST = 1.5;\n\n// Overage rates for scene-aware music (75% margin)\nconst SCENE_AWARE_OVERAGE_RATES = {\n  starter: 0.75,  // $0.75/scene-aware (1.5x $0.50)\n  pro: 0.45,      // $0.45/scene-aware (1.5x $0.30)\n  team: 0.30      // $0.30/scene-aware (1.5x $0.20)\n};\n\n/**\n * Check if customer has enough credits for variations (2.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkVariationsCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = VARIATIONS_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct variations credit from customer (2.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductVariationsCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= VARIATIONS_CREDIT_COST) {\n      // Have enough credits - deduct 2.5 (rounded up to 3 for integer credits)\n      creditsDeducted = Math.ceil(VARIATIONS_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = VARIATIONS_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Variations partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = VARIATIONS_OVERAGE_RATES[tier] || VARIATIONS_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Variations full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Variations credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\n/**\n * Check if customer has enough credits for scene-aware music (1.5 credits)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{canGenerate: boolean, creditsAvailable: number, creditsRequired: number}>}\n */\nasync function checkSceneAwareCredits(stripeCustomerId) {\n  const credits = await getMusicCredits(stripeCustomerId);\n  const creditsRequired = SCENE_AWARE_CREDIT_COST;\n\n  // Allow if they have at least 1 credit (we'll charge overage for the rest)\n  // Or if they're on a paid tier (overage allowed)\n  const canGenerate = credits.remaining > 0 || credits.tier !== 'cancelled';\n\n  return {\n    canGenerate,\n    creditsAvailable: credits.remaining,\n    creditsRequired,\n    tier: credits.tier\n  };\n}\n\n/**\n * Deduct scene-aware music credit from customer (1.5 credits worth)\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Promise<{success: boolean, remaining: number, charged: number}>}\n */\nasync function deductSceneAwareCredit(stripeCustomerId) {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Lock row for update\n    const result = await client.query(\n      `SELECT music_credits_remaining, tier\n       FROM users\n       WHERE stripe_customer_id = $1\n       FOR UPDATE`,\n      [stripeCustomerId]\n    );\n\n    if (result.rows.length === 0) {\n      await client.query('ROLLBACK');\n      return { success: false, remaining: 0, charged: 0, error: 'User not found' };\n    }\n\n    const { music_credits_remaining, tier } = result.rows[0];\n    let charged = 0;\n    let creditsDeducted = 0;\n\n    // Determine how many credits to deduct vs overage to charge\n    if (music_credits_remaining >= SCENE_AWARE_CREDIT_COST) {\n      // Have enough credits - deduct 1.5 (rounded up to 2 for integer credits)\n      creditsDeducted = Math.ceil(SCENE_AWARE_CREDIT_COST);\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = music_credits_remaining - $2,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId, creditsDeducted]\n      );\n    } else if (music_credits_remaining > 0) {\n      // Partial credits - deduct what they have and charge overage for the rest\n      const creditsPortion = music_credits_remaining;\n      const overagePortion = SCENE_AWARE_CREDIT_COST - creditsPortion;\n      const overageRate = MUSIC_OVERAGE_RATES[tier] || MUSIC_OVERAGE_RATES.starter;\n      charged = overagePortion * overageRate;\n\n      creditsDeducted = creditsPortion;\n      await client.query(\n        `UPDATE users\n         SET music_credits_remaining = 0,\n             updated_at = CURRENT_TIMESTAMP\n         WHERE stripe_customer_id = $1`,\n        [stripeCustomerId]\n      );\n\n      console.log(`[SPLICE] Scene-aware partial overage: ${stripeCustomerId} used ${creditsPortion} credits, charged $${charged.toFixed(2)}`);\n    } else {\n      // No credits - full overage\n      charged = SCENE_AWARE_OVERAGE_RATES[tier] || SCENE_AWARE_OVERAGE_RATES.starter;\n      console.log(`[SPLICE] Scene-aware full overage: ${stripeCustomerId} charged $${charged.toFixed(2)}`);\n    }\n\n    // Log the usage\n    await client.query(\n      `INSERT INTO music_usage_log (stripe_customer_id, credits_used, overage_charged)\n       VALUES ($1, $2, $3)\n       ON CONFLICT DO NOTHING`,\n      [stripeCustomerId, creditsDeducted, charged]\n    );\n\n    await client.query('COMMIT');\n\n    const newCredits = await getMusicCredits(stripeCustomerId);\n    return {\n      success: true,\n      remaining: newCredits.remaining,\n      creditsDeducted,\n      charged\n    };\n\n  } catch (err) {\n    await client.query('ROLLBACK');\n    console.error('[SPLICE] Scene-aware credit deduction error:', err.message);\n    return { success: false, remaining: 0, charged: 0, error: err.message };\n  } finally {\n    client.release();\n  }\n}\n\nmodule.exports = {\n  initDatabase,\n  getOrCreateUser,\n  getBalance,\n  hasCredits,\n  reserveCredits,\n  confirmReservation,\n  releaseReservation,\n  checkIsolationAccess,\n  deductUsage,\n  deductIsolationUsage,\n  resetHours,\n  updateTier,\n  getUsageHistory,\n  isEventProcessed,\n  recordWebhookEvent,\n  // Music credits functions\n  getMusicCredits,\n  hasMusicCredits,\n  deductMusicCredit,\n  resetMusicCredits,\n  addMusicCredits,\n  getMusicUsageHistory,\n  initMusicCreditsColumns,\n  // Variations credits functions\n  checkVariationsCredits,\n  deductVariationsCredit,\n  // Scene-aware credits functions\n  checkSceneAwareCredits,\n  deductSceneAwareCredit,\n  // Constants\n  TIER_HOURS,\n  TIER_ISOLATION_MINUTES,\n  TIER_ISOLATION_HOURS,\n  ISOLATION_OVERAGE_RATE,\n  TIER_MUSIC_CREDITS,\n  MUSIC_OVERAGE_RATES,\n  VARIATIONS_CREDIT_COST,\n  VARIATIONS_OVERAGE_RATES,\n  SCENE_AWARE_CREDIT_COST,\n  SCENE_AWARE_OVERAGE_RATES\n};\n","numLines":1347,"startLine":1,"totalLines":1347}}}
{"parentUuid":"d5e21f99-75bb-4819-bbc0-c98a926e191b","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PHwYioBNnX7Aj7vtxWbxix","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the server.js file for Stripe webhook handling:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7694,"cache_creation_input_tokens":45776,"cache_read_input_tokens":21350,"cache_creation":{"ephemeral_5m_input_tokens":45776,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWWLGF1F77Sr2cR1qAZLP","type":"assistant","uuid":"2cb6c1a9-40e8-4e5d-a214-7836c88d5b97","timestamp":"2025-12-27T01:35:12.448Z"}
{"parentUuid":"2cb6c1a9-40e8-4e5d-a214-7836c88d5b97","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PHwYioBNnX7Aj7vtxWbxix","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013YJ6FofpmCKNLLS2aUnNdR","name":"Grep","input":{"pattern":"stripe.*webhook|handleWebhook|customer\\.subscription","path":"/Users/imorgado/SPLICE/splice-backend","-i":true,"output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7694,"cache_creation_input_tokens":45776,"cache_read_input_tokens":21350,"cache_creation":{"ephemeral_5m_input_tokens":45776,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CWWLGF1F77Sr2cR1qAZLP","type":"assistant","uuid":"281b20d8-1be4-4b12-b1b4-65cebb2db4e5","timestamp":"2025-12-27T01:35:14.747Z"}
{"parentUuid":"281b20d8-1be4-4b12-b1b4-65cebb2db4e5","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013YJ6FofpmCKNLLS2aUnNdR","type":"tool_result","content":"splice-backend/server.js:59:// Stripe for webhooks\nsplice-backend/server.js:236:// Stripe Webhook (must be before express.json())\nsplice-backend/server.js:241:  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\nsplice-backend/server.js:247:      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\nsplice-backend/server.js:250:      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\nsplice-backend/server.js:274:      case 'customer.subscription.created':\nsplice-backend/server.js:275:      case 'customer.subscription.updated': {\nsplice-backend/server.js:294:        if (event.type === 'customer.subscription.created') {\nsplice-backend/server.js:357:      case 'customer.subscription.deleted': {\nsplice-backend/.env.template:20:STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here\nsplice-backend/routes/health.js:61:        'POST /webhooks/stripe': 'Stripe webhook endpoint',\nsplice-backend/services/usageTracking.js:750: * Update user's tier (from Stripe webhook)\nsplice-backend/tests/e2e-license-flow.test.js:11: * NOTE: The actual Stripe webhook is tested in production with real Stripe events.\nsplice-backend/tests/e2e-license-flow.test.js:66:  console.log('Step 1: Generating license key (simulates Stripe webhook)...');\nsplice-backend/tests/stripe-webhook.test.js:2: * Stripe Webhook Tests\nsplice-backend/tests/stripe-webhook.test.js:75:console.log('\\n=== Stripe Webhook Tests ===\\n');\nsplice-backend/tests/stripe-webhook.test.js:97:  assertIncludes(serverSource, \"app.post('/webhooks/stripe', express.raw\", 'Webhook should use express.raw');\nsplice-backend/tests/stripe-webhook.test.js:106:test('should use stripe.webhooks.constructEvent', () => {\nsplice-backend/tests/stripe-webhook.test.js:107:  assertIncludes(serverSource, 'stripe.webhooks.constructEvent', 'Should use constructEvent');\nsplice-backend/tests/stripe-webhook.test.js:114:test('should check for STRIPE_WEBHOOK_SECRET', () => {\nsplice-backend/tests/stripe-webhook.test.js:115:  assertIncludes(serverSource, 'process.env.STRIPE_WEBHOOK_SECRET', 'Should use env secret');\nsplice-backend/tests/stripe-webhook.test.js:120:  assertIncludes(serverSource, 'STRIPE_WEBHOOK_SECRET not set in production', 'Should log critical error');\nsplice-backend/tests/stripe-webhook.test.js:134:test('should handle customer.subscription.created', () => {\nsplice-backend/tests/stripe-webhook.test.js:135:  assertIncludes(serverSource, 'customer.subscription.created', 'Should handle subscription created');\nsplice-backend/tests/stripe-webhook.test.js:138:test('should handle customer.subscription.updated', () => {\nsplice-backend/tests/stripe-webhook.test.js:139:  assertIncludes(serverSource, 'customer.subscription.updated', 'Should handle subscription updated');\nsplice-backend/tests/stripe-webhook.test.js:142:test('should handle customer.subscription.deleted', () => {\nsplice-backend/tests/stripe-webhook.test.js:143:  assertIncludes(serverSource, 'customer.subscription.deleted', 'Should handle subscription deleted');\nsplice-backend/tests/stripe-webhook.test.js:290:  'customer.subscription.created',\nsplice-backend/tests/stripe-webhook.test.js:291:  'customer.subscription.updated',\nsplice-backend/tests/stripe-webhook.test.js:292:  'customer.subscription.deleted'\nsplice-backend/tests/stripe-webhook.test.js:343:  console.log('\\n[OK] All Stripe Webhook tests passed');\nsplice-backend/tests/security.test.js:438:  assertIncludes(serverSource, 'CRITICAL: STRIPE_WEBHOOK_SECRET not set in production', 'Missing webhook secret warning');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:2: * Stripe Webhook Edge Cases Tests\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:74:console.log('\\n=== Stripe Webhook Edge Cases Tests ===\\n');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:84:  assertContains(serverSource, \"app.post('/webhooks/stripe'\", 'Missing webhook endpoint');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:95:test('should use STRIPE_WEBHOOK_SECRET from environment', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:96:  assertContains(serverSource, 'STRIPE_WEBHOOK_SECRET', 'Should use webhook secret env var');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:101:test('should call stripe.webhooks.constructEvent for verification', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:102:  assertContains(serverSource, 'stripe.webhooks.constructEvent', 'Should use constructEvent');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:141:test('should handle customer.subscription.created', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:142:  assertContains(serverSource, \"case 'customer.subscription.created'\", 'Should handle subscription created');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:145:test('should handle customer.subscription.updated', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:146:  assertContains(serverSource, \"case 'customer.subscription.updated'\", 'Should handle subscription updated');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:149:test('should handle customer.subscription.deleted', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:150:  assertContains(serverSource, \"case 'customer.subscription.deleted'\", 'Should handle subscription deleted');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:297:    type: 'customer.subscription.created',\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:322:    type: 'customer.subscription.deleted',\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:409:  assertContains(serverSource, \"case 'customer.subscription.updated'\", 'Should handle updates');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:495:  console.log('\\n[OK] All Stripe Webhook Edge Case tests passed');\nsplice-backend/tests/user-simulation.test.js:8: * 4. Stripe Configuration - Price IDs, webhooks, customer flow\nsplice-backend/tests/user-simulation.test.js:364:test('Stripe webhook endpoint exists', () => {\nsplice-backend/tests/user-simulation.test.js:365:  assert.ok(files.serverJs.includes('/webhooks/stripe'), 'Missing Stripe webhook endpoint');\nsplice-backend/tests/user-simulation.test.js:369:  assert.ok(files.serverJs.includes('constructEvent') || files.serverJs.includes('stripe.webhooks'),\nsplice-backend/tests/user-simulation.test.js:373:test('Handles customer.subscription events', () => {\nsplice-backend/tests/user-simulation.test.js:374:  const hasSubEvents = files.serverJs.includes('customer.subscription.created') ||"}]},"uuid":"8e7cba4e-c809-4b9a-a003-f9cc67ee5df8","timestamp":"2025-12-27T01:35:15.153Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"splice-backend/server.js:59:// Stripe for webhooks\nsplice-backend/server.js:236:// Stripe Webhook (must be before express.json())\nsplice-backend/server.js:241:  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\nsplice-backend/server.js:247:      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\nsplice-backend/server.js:250:      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\nsplice-backend/server.js:274:      case 'customer.subscription.created':\nsplice-backend/server.js:275:      case 'customer.subscription.updated': {\nsplice-backend/server.js:294:        if (event.type === 'customer.subscription.created') {\nsplice-backend/server.js:357:      case 'customer.subscription.deleted': {\nsplice-backend/.env.template:20:STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here\nsplice-backend/routes/health.js:61:        'POST /webhooks/stripe': 'Stripe webhook endpoint',\nsplice-backend/services/usageTracking.js:750: * Update user's tier (from Stripe webhook)\nsplice-backend/tests/e2e-license-flow.test.js:11: * NOTE: The actual Stripe webhook is tested in production with real Stripe events.\nsplice-backend/tests/e2e-license-flow.test.js:66:  console.log('Step 1: Generating license key (simulates Stripe webhook)...');\nsplice-backend/tests/stripe-webhook.test.js:2: * Stripe Webhook Tests\nsplice-backend/tests/stripe-webhook.test.js:75:console.log('\\n=== Stripe Webhook Tests ===\\n');\nsplice-backend/tests/stripe-webhook.test.js:97:  assertIncludes(serverSource, \"app.post('/webhooks/stripe', express.raw\", 'Webhook should use express.raw');\nsplice-backend/tests/stripe-webhook.test.js:106:test('should use stripe.webhooks.constructEvent', () => {\nsplice-backend/tests/stripe-webhook.test.js:107:  assertIncludes(serverSource, 'stripe.webhooks.constructEvent', 'Should use constructEvent');\nsplice-backend/tests/stripe-webhook.test.js:114:test('should check for STRIPE_WEBHOOK_SECRET', () => {\nsplice-backend/tests/stripe-webhook.test.js:115:  assertIncludes(serverSource, 'process.env.STRIPE_WEBHOOK_SECRET', 'Should use env secret');\nsplice-backend/tests/stripe-webhook.test.js:120:  assertIncludes(serverSource, 'STRIPE_WEBHOOK_SECRET not set in production', 'Should log critical error');\nsplice-backend/tests/stripe-webhook.test.js:134:test('should handle customer.subscription.created', () => {\nsplice-backend/tests/stripe-webhook.test.js:135:  assertIncludes(serverSource, 'customer.subscription.created', 'Should handle subscription created');\nsplice-backend/tests/stripe-webhook.test.js:138:test('should handle customer.subscription.updated', () => {\nsplice-backend/tests/stripe-webhook.test.js:139:  assertIncludes(serverSource, 'customer.subscription.updated', 'Should handle subscription updated');\nsplice-backend/tests/stripe-webhook.test.js:142:test('should handle customer.subscription.deleted', () => {\nsplice-backend/tests/stripe-webhook.test.js:143:  assertIncludes(serverSource, 'customer.subscription.deleted', 'Should handle subscription deleted');\nsplice-backend/tests/stripe-webhook.test.js:290:  'customer.subscription.created',\nsplice-backend/tests/stripe-webhook.test.js:291:  'customer.subscription.updated',\nsplice-backend/tests/stripe-webhook.test.js:292:  'customer.subscription.deleted'\nsplice-backend/tests/stripe-webhook.test.js:343:  console.log('\\n[OK] All Stripe Webhook tests passed');\nsplice-backend/tests/security.test.js:438:  assertIncludes(serverSource, 'CRITICAL: STRIPE_WEBHOOK_SECRET not set in production', 'Missing webhook secret warning');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:2: * Stripe Webhook Edge Cases Tests\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:74:console.log('\\n=== Stripe Webhook Edge Cases Tests ===\\n');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:84:  assertContains(serverSource, \"app.post('/webhooks/stripe'\", 'Missing webhook endpoint');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:95:test('should use STRIPE_WEBHOOK_SECRET from environment', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:96:  assertContains(serverSource, 'STRIPE_WEBHOOK_SECRET', 'Should use webhook secret env var');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:101:test('should call stripe.webhooks.constructEvent for verification', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:102:  assertContains(serverSource, 'stripe.webhooks.constructEvent', 'Should use constructEvent');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:141:test('should handle customer.subscription.created', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:142:  assertContains(serverSource, \"case 'customer.subscription.created'\", 'Should handle subscription created');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:145:test('should handle customer.subscription.updated', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:146:  assertContains(serverSource, \"case 'customer.subscription.updated'\", 'Should handle subscription updated');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:149:test('should handle customer.subscription.deleted', () => {\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:150:  assertContains(serverSource, \"case 'customer.subscription.deleted'\", 'Should handle subscription deleted');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:297:    type: 'customer.subscription.created',\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:322:    type: 'customer.subscription.deleted',\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:409:  assertContains(serverSource, \"case 'customer.subscription.updated'\", 'Should handle updates');\nsplice-backend/tests/stripe-webhook-edge-cases.test.js:495:  console.log('\\n[OK] All Stripe Webhook Edge Case tests passed');\nsplice-backend/tests/user-simulation.test.js:8: * 4. Stripe Configuration - Price IDs, webhooks, customer flow\nsplice-backend/tests/user-simulation.test.js:364:test('Stripe webhook endpoint exists', () => {\nsplice-backend/tests/user-simulation.test.js:365:  assert.ok(files.serverJs.includes('/webhooks/stripe'), 'Missing Stripe webhook endpoint');\nsplice-backend/tests/user-simulation.test.js:369:  assert.ok(files.serverJs.includes('constructEvent') || files.serverJs.includes('stripe.webhooks'),\nsplice-backend/tests/user-simulation.test.js:373:test('Handles customer.subscription events', () => {\nsplice-backend/tests/user-simulation.test.js:374:  const hasSubEvents = files.serverJs.includes('customer.subscription.created') ||","numLines":56}}
{"parentUuid":"8e7cba4e-c809-4b9a-a003-f9cc67ee5df8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HaHp92oPiWnxgUmbaGt1Sq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gt9D5KXaFJM1kL9e4qQz8B","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/server.js","offset":230,"limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":9836,"cache_read_input_tokens":67126,"cache_creation":{"ephemeral_5m_input_tokens":9836,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard"}},"requestId":"req_011CWWLGsBN87y3Jx5TCrFqd","type":"assistant","uuid":"65af3c83-3bda-4bfe-8caf-fd5ff2fa99eb","timestamp":"2025-12-27T01:35:19.613Z"}
{"parentUuid":"65af3c83-3bda-4bfe-8caf-fd5ff2fa99eb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gt9D5KXaFJM1kL9e4qQz8B","type":"tool_result","content":"   230→  // Log unknown price ID for debugging\n   231→  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n   232→  return 'starter';\n   233→}\n   234→\n   235→// =============================================================================\n   236→// Stripe Webhook (must be before express.json())\n   237→// =============================================================================\n   238→\n   239→app.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n   240→  const sig = req.headers['stripe-signature'];\n   241→  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n   242→\n   243→  let event;\n   244→\n   245→  try {\n   246→    if (webhookSecret) {\n   247→      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n   248→    } else if (isProduction) {\n   249→      // SECURITY: Reject unsigned webhooks in production\n   250→      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n   251→      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n   252→    } else {\n   253→      // For local development testing only\n   254→      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n   255→      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n   256→      event = JSON.parse(bodyString);\n   257→      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n   258→    }\n   259→  } catch (err) {\n   260→    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n   261→    return res.status(400).json({ error: 'Webhook signature verification failed' });\n   262→  }\n   263→\n   264→  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n   265→\n   266→  // Idempotency check - skip if already processed\n   267→  if (await usageTracking.isEventProcessed(event.id)) {\n   268→    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n   269→    return res.json({ received: true, skipped: true });\n   270→  }\n   271→\n   272→  try {\n   273→    switch (event.type) {\n   274→      case 'customer.subscription.created':\n   275→      case 'customer.subscription.updated': {\n   276→        const subscription = event.data.object;\n   277→        const customerId = subscription.customer;\n   278→\n   279→        // Validate customerId\n   280→        if (!customerId) {\n   281→          console.error('[SPLICE] Missing customer ID in subscription event');\n   282→          return res.status(400).json({ error: 'Missing customer ID' });\n   283→        }\n   284→\n   285→        // Get tier from price ID\n   286→        const priceId = subscription.items?.data?.[0]?.price?.id;\n   287→        const tier = getTierFromPriceId(priceId);\n   288→\n   289→        // Update user tier and reset hours\n   290→        await usageTracking.updateTier(customerId, tier);\n   291→        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n   292→\n   293→        // Generate license key for new subscriptions with retry and delivery\n   294→        if (event.type === 'customer.subscription.created') {\n   295→          let licenseResult = null;\n   296→          let retryCount = 0;\n   297→          const maxRetries = 3;\n   298→\n   299→          // Retry mechanism for license key generation\n   300→          while (retryCount < maxRetries) {\n   301→            licenseResult = await licenseService.generateLicenseKey(customerId);\n   302→            if (licenseResult.success) {\n   303→              break;\n   304→            }\n   305→            retryCount++;\n   306→            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n   307→            // Wait before retry (exponential backoff)\n   308→            if (retryCount < maxRetries) {\n   309→              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n   310→            }\n   311→          }\n   312→\n   313→          if (licenseResult && licenseResult.success) {\n   314→            // SECURITY: Mask license key in logs\n   315→            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n   316→\n   317→            // Store license key in Stripe subscription metadata as backup\n   318→            try {\n   319→              await stripe.subscriptions.update(subscription.id, {\n   320→                metadata: {\n   321→                  license_key: licenseResult.key,\n   322→                  license_generated_at: new Date().toISOString()\n   323→                }\n   324→              });\n   325→              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n   326→            } catch (stripeErr) {\n   327→              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n   328→            }\n   329→\n   330→            // Get customer email and send license key\n   331→            try {\n   332→              const customer = await stripe.customers.retrieve(customerId);\n   333→              if (customer.email) {\n   334→                // SECURITY: Mask sensitive data in logs\n   335→                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n   336→                // TODO: Integrate with email service (SendGrid, SES, etc.)\n   337→                // await sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n   338→\n   339→                // Store email in database for reference\n   340→                await usageTracking.updateTier(customerId, tier, customer.email);\n   341→              } else {\n   342→                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n   343→              }\n   344→            } catch (emailErr) {\n   345→              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n   346→            }\n   347→          } else {\n   348→            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n   349→            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n   350→            console.error(`[SPLICE] ${errorMsg}`);\n   351→            return res.status(500).json({ error: errorMsg });\n   352→          }\n   353→        }\n   354→        break;\n   355→      }\n   356→\n   357→      case 'customer.subscription.deleted': {\n   358→        const subscription = event.data.object;\n   359→        const customerId = subscription.customer;\n   360→\n   361→        // Validate customerId\n   362→        if (!customerId) {\n   363→          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n   364→          return res.status(400).json({ error: 'Missing customer ID' });\n   365→        }\n   366→\n   367→        // Downgrade to cancelled (0 hours)\n   368→        await usageTracking.updateTier(customerId, 'cancelled');\n   369→        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n   370→        break;\n   371→      }\n   372→\n   373→      case 'invoice.payment_succeeded': {\n   374→        const invoice = event.data.object;\n   375→        const customerId = invoice.customer;\n   376→        const subscriptionId = invoice.subscription;\n   377→\n   378→        // Validate customerId\n   379→        if (!customerId) {\n   380→          console.error('[SPLICE] Missing customer ID in invoice event');\n   381→          return res.status(400).json({ error: 'Missing customer ID' });\n   382→        }\n   383→\n   384→        // Reset hours on successful payment (new billing period)\n   385→        if (subscriptionId) {\n   386→          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n   387→          const priceId = subscription.items?.data?.[0]?.price?.id;\n   388→          const tier = getTierFromPriceId(priceId);\n   389→\n   390→          await usageTracking.resetHours(customerId, tier);\n   391→          console.log(`[SPLICE] Reset hours for customer ${customerId} (tier: ${tier})`);\n   392→        }\n   393→        break;\n   394→      }\n   395→\n   396→      default:\n   397→        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n   398→    }\n   399→\n   400→    // Record event as processed (idempotency)\n   401→    await usageTracking.recordWebhookEvent(event.id, event.type);\n   402→\n   403→    res.json({ received: true });\n   404→  } catch (err) {\n   405→    console.error('[SPLICE] Webhook handler error:', err);\n   406→    res.status(500).json({ error: err.message });\n   407→  }\n   408→});\n   409→\n   410→// Parse JSON body for all other routes\n   411→app.use(express.json());\n   412→\n   413→// =============================================================================\n   414→// Route Configuration Options\n   415→// =============================================================================\n   416→\n   417→const routeOptions = {\n   418→  middleware: {\n   419→    requireCredits,\n   420→    authenticateToken\n   421→  },\n   422→  services: {\n   423→    usageTracking,\n   424→    referralService,\n   425→    licenseService,\n   426→    stripe\n   427→  },\n   428→  authHelpers: {\n   429→    generateToken,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"cb405643-254d-45f5-b61e-eed76af03280","timestamp":"2025-12-27T01:35:19.695Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/server.js","content":"  // Log unknown price ID for debugging\n  console.warn(`[SPLICE] Unknown price ID: ${priceId} - defaulting to starter tier`);\n  return 'starter';\n}\n\n// =============================================================================\n// Stripe Webhook (must be before express.json())\n// =============================================================================\n\napp.post('/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {\n  const sig = req.headers['stripe-signature'];\n  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n  let event;\n\n  try {\n    if (webhookSecret) {\n      event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } else if (isProduction) {\n      // SECURITY: Reject unsigned webhooks in production\n      console.error('[SPLICE] CRITICAL: STRIPE_WEBHOOK_SECRET not set in production');\n      return res.status(500).json({ error: 'Webhook configuration error: secret not configured' });\n    } else {\n      // For local development testing only\n      // req.body is a Buffer from express.raw(), convert to string for JSON.parse\n      const bodyString = typeof req.body === 'string' ? req.body : req.body.toString('utf8');\n      event = JSON.parse(bodyString);\n      console.warn('[SPLICE] Warning: Processing webhook without signature verification (dev only)');\n    }\n  } catch (err) {\n    console.error('[SPLICE] Webhook signature verification failed:', err.message);\n    return res.status(400).json({ error: 'Webhook signature verification failed' });\n  }\n\n  console.log(`[SPLICE] Webhook received: ${event.type} (${event.id})`);\n\n  // Idempotency check - skip if already processed\n  if (await usageTracking.isEventProcessed(event.id)) {\n    console.log(`[SPLICE] Event ${event.id} already processed, skipping`);\n    return res.json({ received: true, skipped: true });\n  }\n\n  try {\n    switch (event.type) {\n      case 'customer.subscription.created':\n      case 'customer.subscription.updated': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Get tier from price ID\n        const priceId = subscription.items?.data?.[0]?.price?.id;\n        const tier = getTierFromPriceId(priceId);\n\n        // Update user tier and reset hours\n        await usageTracking.updateTier(customerId, tier);\n        console.log(`[SPLICE] Updated customer ${customerId} to tier: ${tier}`);\n\n        // Generate license key for new subscriptions with retry and delivery\n        if (event.type === 'customer.subscription.created') {\n          let licenseResult = null;\n          let retryCount = 0;\n          const maxRetries = 3;\n\n          // Retry mechanism for license key generation\n          while (retryCount < maxRetries) {\n            licenseResult = await licenseService.generateLicenseKey(customerId);\n            if (licenseResult.success) {\n              break;\n            }\n            retryCount++;\n            console.warn(`[SPLICE] License key generation attempt ${retryCount}/${maxRetries} failed: ${licenseResult.error}`);\n            // Wait before retry (exponential backoff)\n            if (retryCount < maxRetries) {\n              await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));\n            }\n          }\n\n          if (licenseResult && licenseResult.success) {\n            // SECURITY: Mask license key in logs\n            console.log(`[SPLICE] Generated license key for ${maskSensitiveData(customerId)}: ${maskSensitiveData(licenseResult.key)}`);\n\n            // Store license key in Stripe subscription metadata as backup\n            try {\n              await stripe.subscriptions.update(subscription.id, {\n                metadata: {\n                  license_key: licenseResult.key,\n                  license_generated_at: new Date().toISOString()\n                }\n              });\n              console.log(`[SPLICE] Stored license key in Stripe metadata for subscription ${subscription.id}`);\n            } catch (stripeErr) {\n              console.error(`[SPLICE] Failed to store license key in Stripe metadata:`, stripeErr.message);\n            }\n\n            // Get customer email and send license key\n            try {\n              const customer = await stripe.customers.retrieve(customerId);\n              if (customer.email) {\n                // SECURITY: Mask sensitive data in logs\n                console.log(`[SPLICE] License key ready for delivery to ${maskSensitiveData(customer.email)}: ${maskSensitiveData(licenseResult.key)}`);\n                // TODO: Integrate with email service (SendGrid, SES, etc.)\n                // await sendLicenseKeyEmail(customer.email, licenseResult.key, tier);\n\n                // Store email in database for reference\n                await usageTracking.updateTier(customerId, tier, customer.email);\n              } else {\n                console.warn(`[SPLICE] No email found for customer ${customerId}`);\n              }\n            } catch (emailErr) {\n              console.error(`[SPLICE] Error getting customer email:`, emailErr.message);\n            }\n          } else {\n            // CRITICAL: License generation failed - return 500 to trigger Stripe retry\n            const errorMsg = `Failed to generate license key after ${maxRetries} attempts: ${licenseResult?.error || 'Unknown error'}`;\n            console.error(`[SPLICE] ${errorMsg}`);\n            return res.status(500).json({ error: errorMsg });\n          }\n        }\n        break;\n      }\n\n      case 'customer.subscription.deleted': {\n        const subscription = event.data.object;\n        const customerId = subscription.customer;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in subscription.deleted event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Downgrade to cancelled (0 hours)\n        await usageTracking.updateTier(customerId, 'cancelled');\n        console.log(`[SPLICE] Subscription cancelled for customer ${customerId}`);\n        break;\n      }\n\n      case 'invoice.payment_succeeded': {\n        const invoice = event.data.object;\n        const customerId = invoice.customer;\n        const subscriptionId = invoice.subscription;\n\n        // Validate customerId\n        if (!customerId) {\n          console.error('[SPLICE] Missing customer ID in invoice event');\n          return res.status(400).json({ error: 'Missing customer ID' });\n        }\n\n        // Reset hours on successful payment (new billing period)\n        if (subscriptionId) {\n          const subscription = await stripe.subscriptions.retrieve(subscriptionId);\n          const priceId = subscription.items?.data?.[0]?.price?.id;\n          const tier = getTierFromPriceId(priceId);\n\n          await usageTracking.resetHours(customerId, tier);\n          console.log(`[SPLICE] Reset hours for customer ${customerId} (tier: ${tier})`);\n        }\n        break;\n      }\n\n      default:\n        console.log(`[SPLICE] Unhandled event type: ${event.type}`);\n    }\n\n    // Record event as processed (idempotency)\n    await usageTracking.recordWebhookEvent(event.id, event.type);\n\n    res.json({ received: true });\n  } catch (err) {\n    console.error('[SPLICE] Webhook handler error:', err);\n    res.status(500).json({ error: err.message });\n  }\n});\n\n// Parse JSON body for all other routes\napp.use(express.json());\n\n// =============================================================================\n// Route Configuration Options\n// =============================================================================\n\nconst routeOptions = {\n  middleware: {\n    requireCredits,\n    authenticateToken\n  },\n  services: {\n    usageTracking,\n    referralService,\n    licenseService,\n    stripe\n  },\n  authHelpers: {\n    generateToken,","numLines":200,"startLine":230,"totalLines":572}}}
{"parentUuid":"cb405643-254d-45f5-b61e-eed76af03280","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PU1JPptAKJ7CN9XNajF8M8","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the environment template and database initialization:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2976,"cache_read_input_tokens":76962,"cache_creation":{"ephemeral_5m_input_tokens":2976,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWWLHCduBUtRHtPigpowj","type":"assistant","uuid":"e5624e4c-2fa8-4fcb-9b1c-d7b079816d66","timestamp":"2025-12-27T01:35:23.039Z"}
{"parentUuid":"e5624e4c-2fa8-4fcb-9b1c-d7b079816d66","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PU1JPptAKJ7CN9XNajF8M8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Yb2BGJbnKSQBNDUAdqyFyc","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/.env.template"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2976,"cache_read_input_tokens":76962,"cache_creation":{"ephemeral_5m_input_tokens":2976,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWWLHCduBUtRHtPigpowj","type":"assistant","uuid":"152a2ca0-d956-4b51-8bb1-4d6d59a48692","timestamp":"2025-12-27T01:35:23.840Z"}
{"parentUuid":"152a2ca0-d956-4b51-8bb1-4d6d59a48692","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Yb2BGJbnKSQBNDUAdqyFyc","type":"tool_result","content":"     1→# =============================================================================\n     2→# SPLICE Backend Environment Variables\n     3→# =============================================================================\n     4→# Copy this file to .env and fill in your values\n     5→# NEVER commit .env to git\n     6→\n     7→# -----------------------------------------------------------------------------\n     8→# AI Services\n     9→# -----------------------------------------------------------------------------\n    10→GROQ_API_KEY=your_groq_api_key_here\n    11→OPENAI_API_KEY=your_openai_api_key_here\n    12→REPLICATE_API_TOKEN=your_replicate_token_here\n    13→\n    14→# -----------------------------------------------------------------------------\n    15→# Stripe (for billing/subscriptions)\n    16→# Get these from https://dashboard.stripe.com/apikeys\n    17→# -----------------------------------------------------------------------------\n    18→STRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key_here\n    19→STRIPE_SECRET_KEY=sk_test_your_secret_key_here\n    20→STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here\n    21→\n    22→# Stripe Price IDs (create products in Stripe Dashboard first)\n    23→STRIPE_PRICE_STARTER=price_your_starter_price_id\n    24→STRIPE_PRICE_PRO=price_your_pro_price_id\n    25→STRIPE_PRICE_TEAM=price_your_team_price_id\n    26→STRIPE_PRICE_OVERAGE=price_your_overage_price_id\n    27→\n    28→# -----------------------------------------------------------------------------\n    29→# Database (Railway PostgreSQL)\n    30→# Railway will auto-inject this when you add PostgreSQL\n    31→# -----------------------------------------------------------------------------\n    32→DATABASE_URL=postgresql://user:password@host:port/database\n    33→\n    34→# -----------------------------------------------------------------------------\n    35→# Server Config\n    36→# -----------------------------------------------------------------------------\n    37→PORT=3847\n    38→NODE_ENV=production\n    39→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"22fc13db-0bc6-450c-af83-a2c62979695e","timestamp":"2025-12-27T01:35:23.881Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/.env.template","content":"# =============================================================================\n# SPLICE Backend Environment Variables\n# =============================================================================\n# Copy this file to .env and fill in your values\n# NEVER commit .env to git\n\n# -----------------------------------------------------------------------------\n# AI Services\n# -----------------------------------------------------------------------------\nGROQ_API_KEY=your_groq_api_key_here\nOPENAI_API_KEY=your_openai_api_key_here\nREPLICATE_API_TOKEN=your_replicate_token_here\n\n# -----------------------------------------------------------------------------\n# Stripe (for billing/subscriptions)\n# Get these from https://dashboard.stripe.com/apikeys\n# -----------------------------------------------------------------------------\nSTRIPE_PUBLISHABLE_KEY=pk_test_your_publishable_key_here\nSTRIPE_SECRET_KEY=sk_test_your_secret_key_here\nSTRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here\n\n# Stripe Price IDs (create products in Stripe Dashboard first)\nSTRIPE_PRICE_STARTER=price_your_starter_price_id\nSTRIPE_PRICE_PRO=price_your_pro_price_id\nSTRIPE_PRICE_TEAM=price_your_team_price_id\nSTRIPE_PRICE_OVERAGE=price_your_overage_price_id\n\n# -----------------------------------------------------------------------------\n# Database (Railway PostgreSQL)\n# Railway will auto-inject this when you add PostgreSQL\n# -----------------------------------------------------------------------------\nDATABASE_URL=postgresql://user:password@host:port/database\n\n# -----------------------------------------------------------------------------\n# Server Config\n# -----------------------------------------------------------------------------\nPORT=3847\nNODE_ENV=production\n","numLines":39,"startLine":1,"totalLines":39}}}
{"parentUuid":"22fc13db-0bc6-450c-af83-a2c62979695e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TcpgAGhRsHLLq3MxuUyxj4","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check for R2 and Mureka environment variables and see if they're documented:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":658,"cache_read_input_tokens":79938,"cache_creation":{"ephemeral_5m_input_tokens":658,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWWLHWcPRH3JFz7TPRYHx","type":"assistant","uuid":"a981f63e-f2d4-4ee8-8499-bd66bc7d6425","timestamp":"2025-12-27T01:35:26.840Z"}
{"parentUuid":"a981f63e-f2d4-4ee8-8499-bd66bc7d6425","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TcpgAGhRsHLLq3MxuUyxj4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014UHbDZHxHdvDsp7TrKaKy6","name":"Grep","input":{"pattern":"MUREKA_API_KEY|R2_ACCOUNT_ID|R2_ACCESS_KEY|R2_BUCKET|ACRCLOUD","path":"/Users/imorgado/SPLICE/splice-backend","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":658,"cache_read_input_tokens":79938,"cache_creation":{"ephemeral_5m_input_tokens":658,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWWLHWcPRH3JFz7TPRYHx","type":"assistant","uuid":"df9d9b01-8760-4cdb-b3d6-3f19cdd7ad22","timestamp":"2025-12-27T01:35:28.959Z"}
{"parentUuid":"df9d9b01-8760-4cdb-b3d6-3f19cdd7ad22","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014UHbDZHxHdvDsp7TrKaKy6","type":"tool_result","content":"splice-backend/services/r2Storage.js:15:    const requiredEnvVars = ['R2_ACCOUNT_ID', 'R2_ACCESS_KEY_ID', 'R2_SECRET_ACCESS_KEY', 'R2_BUCKET_NAME'];\nsplice-backend/services/r2Storage.js:24:      endpoint: `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,\nsplice-backend/services/r2Storage.js:26:        accessKeyId: process.env.R2_ACCESS_KEY_ID,\nsplice-backend/services/r2Storage.js:66:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:107:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:134:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:159:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:177:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:200:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:245:      Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:269:      Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/musicGeneration.js:16:const MUREKA_API_KEY = process.env.MUREKA_API_KEY;\nsplice-backend/services/musicGeneration.js:56:  return !!MUREKA_API_KEY;\nsplice-backend/services/musicGeneration.js:136:  if (!MUREKA_API_KEY) {\nsplice-backend/services/musicGeneration.js:137:    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\nsplice-backend/services/musicGeneration.js:146:        'Authorization': `Bearer ${MUREKA_API_KEY}`,\nsplice-backend/services/musicGeneration.js:398:    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\nsplice-backend/services/musicGeneration.js:525:    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\nsplice-backend/services/musicGeneration.js:761:    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\nsplice-backend/services/songIdentification.js:17:const ACRCLOUD_HOST = process.env.ACRCLOUD_HOST || 'identify-us-west-2.acrcloud.com';\nsplice-backend/services/songIdentification.js:18:const ACRCLOUD_ACCESS_KEY = process.env.ACRCLOUD_ACCESS_KEY;\nsplice-backend/services/songIdentification.js:19:const ACRCLOUD_ACCESS_SECRET = process.env.ACRCLOUD_ACCESS_SECRET;\nsplice-backend/services/songIdentification.js:170:    .createHmac('sha1', ACRCLOUD_ACCESS_SECRET)\nsplice-backend/services/songIdentification.js:182:  if (!ACRCLOUD_ACCESS_KEY || !ACRCLOUD_ACCESS_SECRET) {\nsplice-backend/services/songIdentification.js:183:    throw new Error('ACRCloud credentials not configured. Set ACRCLOUD_ACCESS_KEY and ACRCLOUD_ACCESS_SECRET');\nsplice-backend/services/songIdentification.js:195:    ACRCLOUD_ACCESS_KEY,\nsplice-backend/services/songIdentification.js:210:  form.append('access_key', ACRCLOUD_ACCESS_KEY);\nsplice-backend/services/songIdentification.js:219:      hostname: ACRCLOUD_HOST,\nsplice-backend/services/songIdentification.js:472:  return !!(ACRCLOUD_ACCESS_KEY && ACRCLOUD_ACCESS_SECRET);\nsplice-backend/tests/music-final-e2e.test.js:209:  assert(songIdCode.includes('ACRCLOUD'), 'Should use ACRCloud');\nsplice-backend/tests/music-final-e2e.test.js:370:  assert(r2Code.includes('R2_ACCOUNT_ID'), 'Should check R2_ACCOUNT_ID');\nsplice-backend/tests/music-final-e2e.test.js:371:  assert(r2Code.includes('R2_ACCESS_KEY_ID'), 'Should check R2_ACCESS_KEY_ID');\nsplice-backend/tests/music-phase2-e2e.test.js:82:test('uses MUREKA_API_KEY environment variable', () => {\nsplice-backend/tests/music-phase2-e2e.test.js:83:  assert(musicGenCode.includes('MUREKA_API_KEY'), 'Should use MUREKA_API_KEY');\nsplice-backend/tests/music-phase2-e2e.test.js:84:  assert(musicGenCode.includes('process.env.MUREKA_API_KEY'), 'Should read from env');\nsplice-backend/tests/music-phase1-e2e.test.js:164:// ACRCLOUD INTEGRATION TESTS\nsplice-backend/tests/music-phase1-e2e.test.js:169:  assert(songIdCode.includes('ACRCLOUD_HOST'), 'Should use ACRCLOUD_HOST');\nsplice-backend/tests/music-phase1-e2e.test.js:170:  assert(songIdCode.includes('ACRCLOUD_ACCESS_KEY'), 'Should use ACRCLOUD_ACCESS_KEY');\nsplice-backend/tests/music-phase1-e2e.test.js:171:  assert(songIdCode.includes('ACRCLOUD_ACCESS_SECRET'), 'Should use ACRCLOUD_ACCESS_SECRET');\nsplice-backend/tests/music-phase0-e2e.test.js:74:  assert(r2StorageCode.includes('R2_ACCOUNT_ID'), 'Should check R2_ACCOUNT_ID');\nsplice-backend/tests/music-phase0-e2e.test.js:75:  assert(r2StorageCode.includes('R2_ACCESS_KEY_ID'), 'Should check R2_ACCESS_KEY_ID');\nsplice-backend/tests/music-phase0-e2e.test.js:77:  assert(r2StorageCode.includes('R2_BUCKET_NAME'), 'Should check R2_BUCKET_NAME');"}]},"uuid":"799dc47e-106d-4398-9d0f-f89182928afb","timestamp":"2025-12-27T01:35:29.389Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"splice-backend/services/r2Storage.js:15:    const requiredEnvVars = ['R2_ACCOUNT_ID', 'R2_ACCESS_KEY_ID', 'R2_SECRET_ACCESS_KEY', 'R2_BUCKET_NAME'];\nsplice-backend/services/r2Storage.js:24:      endpoint: `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,\nsplice-backend/services/r2Storage.js:26:        accessKeyId: process.env.R2_ACCESS_KEY_ID,\nsplice-backend/services/r2Storage.js:66:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:107:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:134:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:159:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:177:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:200:    Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:245:      Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/r2Storage.js:269:      Bucket: process.env.R2_BUCKET_NAME,\nsplice-backend/services/musicGeneration.js:16:const MUREKA_API_KEY = process.env.MUREKA_API_KEY;\nsplice-backend/services/musicGeneration.js:56:  return !!MUREKA_API_KEY;\nsplice-backend/services/musicGeneration.js:136:  if (!MUREKA_API_KEY) {\nsplice-backend/services/musicGeneration.js:137:    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\nsplice-backend/services/musicGeneration.js:146:        'Authorization': `Bearer ${MUREKA_API_KEY}`,\nsplice-backend/services/musicGeneration.js:398:    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\nsplice-backend/services/musicGeneration.js:525:    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\nsplice-backend/services/musicGeneration.js:761:    throw new Error('Mureka API key not configured. Set MUREKA_API_KEY environment variable.');\nsplice-backend/services/songIdentification.js:17:const ACRCLOUD_HOST = process.env.ACRCLOUD_HOST || 'identify-us-west-2.acrcloud.com';\nsplice-backend/services/songIdentification.js:18:const ACRCLOUD_ACCESS_KEY = process.env.ACRCLOUD_ACCESS_KEY;\nsplice-backend/services/songIdentification.js:19:const ACRCLOUD_ACCESS_SECRET = process.env.ACRCLOUD_ACCESS_SECRET;\nsplice-backend/services/songIdentification.js:170:    .createHmac('sha1', ACRCLOUD_ACCESS_SECRET)\nsplice-backend/services/songIdentification.js:182:  if (!ACRCLOUD_ACCESS_KEY || !ACRCLOUD_ACCESS_SECRET) {\nsplice-backend/services/songIdentification.js:183:    throw new Error('ACRCloud credentials not configured. Set ACRCLOUD_ACCESS_KEY and ACRCLOUD_ACCESS_SECRET');\nsplice-backend/services/songIdentification.js:195:    ACRCLOUD_ACCESS_KEY,\nsplice-backend/services/songIdentification.js:210:  form.append('access_key', ACRCLOUD_ACCESS_KEY);\nsplice-backend/services/songIdentification.js:219:      hostname: ACRCLOUD_HOST,\nsplice-backend/services/songIdentification.js:472:  return !!(ACRCLOUD_ACCESS_KEY && ACRCLOUD_ACCESS_SECRET);\nsplice-backend/tests/music-final-e2e.test.js:209:  assert(songIdCode.includes('ACRCLOUD'), 'Should use ACRCloud');\nsplice-backend/tests/music-final-e2e.test.js:370:  assert(r2Code.includes('R2_ACCOUNT_ID'), 'Should check R2_ACCOUNT_ID');\nsplice-backend/tests/music-final-e2e.test.js:371:  assert(r2Code.includes('R2_ACCESS_KEY_ID'), 'Should check R2_ACCESS_KEY_ID');\nsplice-backend/tests/music-phase2-e2e.test.js:82:test('uses MUREKA_API_KEY environment variable', () => {\nsplice-backend/tests/music-phase2-e2e.test.js:83:  assert(musicGenCode.includes('MUREKA_API_KEY'), 'Should use MUREKA_API_KEY');\nsplice-backend/tests/music-phase2-e2e.test.js:84:  assert(musicGenCode.includes('process.env.MUREKA_API_KEY'), 'Should read from env');\nsplice-backend/tests/music-phase1-e2e.test.js:164:// ACRCLOUD INTEGRATION TESTS\nsplice-backend/tests/music-phase1-e2e.test.js:169:  assert(songIdCode.includes('ACRCLOUD_HOST'), 'Should use ACRCLOUD_HOST');\nsplice-backend/tests/music-phase1-e2e.test.js:170:  assert(songIdCode.includes('ACRCLOUD_ACCESS_KEY'), 'Should use ACRCLOUD_ACCESS_KEY');\nsplice-backend/tests/music-phase1-e2e.test.js:171:  assert(songIdCode.includes('ACRCLOUD_ACCESS_SECRET'), 'Should use ACRCLOUD_ACCESS_SECRET');\nsplice-backend/tests/music-phase0-e2e.test.js:74:  assert(r2StorageCode.includes('R2_ACCOUNT_ID'), 'Should check R2_ACCOUNT_ID');\nsplice-backend/tests/music-phase0-e2e.test.js:75:  assert(r2StorageCode.includes('R2_ACCESS_KEY_ID'), 'Should check R2_ACCESS_KEY_ID');\nsplice-backend/tests/music-phase0-e2e.test.js:77:  assert(r2StorageCode.includes('R2_BUCKET_NAME'), 'Should check R2_BUCKET_NAME');","numLines":42}}
{"parentUuid":"799dc47e-106d-4398-9d0f-f89182928afb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"01622e3a-2464-4caa-b6a8-d703767493df","version":"2.0.76","gitBranch":"main","agentId":"aaf529e","slug":"soft-rolling-sunrise","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Lp4fcUbWy3VZ1sEN8jg2eD","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have all the information I need to provide a comprehensive validation report.\n\n---\n\n## External Service Integrations Validation Report\n\n### Overall Verdict: **PASS WITH ISSUES**\n\n---\n\n### Requirements Checklist\n\n| Service | API Client | Functions Exported | Error Handling | Env Vars Documented |\n|---------|------------|-------------------|----------------|---------------------|\n| transcription.js (OpenAI Whisper) | Check Met | Check Met | Check Met | Check Met |\n| takeDetection.js (GPT-4o-mini) | Check Met | Check Met | Check Met | Check Met |\n| musicGeneration.js (Mureka API) | Check Met | Check Met | Check Met | Partial |\n| vocalIsolation.js (Replicate) | Check Met | Check Met | Check Met | Check Met |\n| chapterDetection.js (GPT) | Check Met | Check Met | Check Met | Check Met |\n| usageTracking.js (PostgreSQL) | Check Met | Check Met | Check Met | Check Met |\n| licenseService.js (PostgreSQL) | Check Met | Check Met | Check Met | Check Met |\n| r2Storage.js (Cloudflare R2) | Check Met | Check Met | Check Met | Partial |\n| Database Schema | Check Met | N/A | N/A | N/A |\n| Stripe Webhook | Check Met | N/A | Check Met | Check Met |\n\n---\n\n### Detailed Findings\n\n#### 1. transcription.js - OpenAI Whisper Integration\n\n**Status: PASS**\n\n- **API Client**: Properly initialized at `/Users/imorgado/SPLICE/splice-backend/services/transcription.js:14`\n  ```javascript\n  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n  ```\n- **Functions Exported**: `transcribeFull`, `transcribeAudio`, `transcribeWithWords`, `clearCache`, `getCacheStats`\n- **Error Handling**: Comprehensive retry logic with exponential backoff (lines 30-73), handles quota exceeded, rate limits, connection errors\n- **Env Vars**: `OPENAI_API_KEY` documented in `.env.template` line 11\n\n---\n\n#### 2. takeDetection.js - GPT-4o-mini Integration\n\n**Status: PASS**\n\n- **API Client**: Properly initialized at `/Users/imorgado/SPLICE/splice-backend/services/takeDetection.js:11`\n  ```javascript\n  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n  ```\n- **Functions Exported**: `detectTakes`\n- **Error Handling**: Fallback response on parse failures (lines 64-76), null content check (lines 96-99)\n- **Env Vars**: Uses same `OPENAI_API_KEY` as transcription service\n\n---\n\n#### 3. musicGeneration.js - Mureka API Integration\n\n**Status: PASS WITH ISSUES**\n\n- **API Client**: Properly initialized with native HTTPS at `/Users/imorgado/SPLICE/splice-backend/services/musicGeneration.js:135-195`\n- **Functions Exported**: 22 functions including `generateMusic`, `generateVariations`, `generateSceneAwareMusic`, `getAvailableMoods`, `getAvailableInstruments`\n- **Error Handling**: Credential check (line 56), HTTP error handling (lines 163-169), timeout handling (line 187), polling with MAX_POLL_ATTEMPTS (line 286-288)\n- **Issue**: `MUREKA_API_KEY` NOT documented in `.env.template`\n\n**Priority: Medium** - Add `MUREKA_API_KEY` to `.env.template`\n\n---\n\n#### 4. vocalIsolation.js - Replicate API Integration\n\n**Status: PASS**\n\n- **API Client**: Native HTTPS with proper authentication at `/Users/imorgado/SPLICE/splice-backend/services/vocalIsolation.js:93-132`\n- **Functions Exported**: `isolateVocals`, `isReplicateConfigured`\n- **Error Handling**: Token validation (lines 35-37), file existence check (lines 39-41), polling timeout (line 157), HTTP error handling\n- **Env Vars**: `REPLICATE_API_TOKEN` documented in `.env.template` line 12\n\n---\n\n#### 5. chapterDetection.js - GPT Integration\n\n**Status: PASS**\n\n- **API Client**: Lazy-loaded OpenAI client at `/Users/imorgado/SPLICE/splice-backend/services/chapterDetection.js:17-23`\n  ```javascript\n  let openai = null;\n  function getOpenAI() {\n    if (!openai) { openai = new OpenAI(); }\n    return openai;\n  }\n  ```\n- **Functions Exported**: `detectChapters`, `detectChaptersFallback`, `formatYouTubeTimestamps`, `extractText`, `validateChapters`, `generateChapterDividers`, `getDividerPresets`\n- **Error Handling**: Short transcript handling (lines 42-53), fallback for short content (lines 59-78), JSON parse error handling (lines 137-140)\n- **Env Vars**: Uses `OPENAI_API_KEY` (auto-detected by OpenAI SDK)\n\n---\n\n#### 6. usageTracking.js - PostgreSQL Integration\n\n**Status: PASS**\n\n- **API Client**: Connection pool properly configured at `/Users/imorgado/SPLICE/splice-backend/services/usageTracking.js:10-18`\n  ```javascript\n  const pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,\n    max: 20, idleTimeoutMillis: 30000, connectionTimeoutMillis: 5000\n  });\n  ```\n- **Functions Exported**: 30+ functions including credit management, reservation system, music credits, isolation tracking\n- **Error Handling**: Transaction rollback on errors, `SELECT...FOR UPDATE` for race condition prevention\n- **Env Vars**: `DATABASE_URL` documented in `.env.template` line 32\n\n**Database Schema**: Properly defined via `initDatabase()` function (lines 48-126):\n- `users` table with tier, hours, isolation hours, music credits\n- `usage_log` table with indexes\n- `webhook_events` table for idempotency\n- Auto-migration for new columns\n\n---\n\n#### 7. licenseService.js - PostgreSQL + Key Generation\n\n**Status: PASS**\n\n- **API Client**: Connection pool at `/Users/imorgado/SPLICE/splice-backend/services/licenseService.js:13-18`\n- **Functions Exported**: `initLicenseTables`, `generateLicenseKey`, `activateLicenseKey`, `getLicenseByCustomerId`, `deactivateLicenseKey`, `reactivateLicenseKey`, `isValidKeyFormat`, `normalizeKey`, `generateKeyString`\n- **Error Handling**: Transaction-based activation with `FOR UPDATE` lock (lines 199-258), unique constraint retry (lines 150-166)\n- **Key Format**: `SPLICE-XXXX-XXXX-XXXX` using crypto.randomInt for secure generation\n\n**Database Schema**: `license_keys` table with proper indexes (lines 27-70)\n\n---\n\n#### 8. r2Storage.js - Cloudflare R2 Integration\n\n**Status: PASS WITH ISSUES**\n\n- **API Client**: Lazy-loaded S3 client at `/Users/imorgado/SPLICE/splice-backend/services/r2Storage.js:10-32`\n  ```javascript\n  s3Client = new S3Client({\n    region: 'auto',\n    endpoint: `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,\n    credentials: {...}\n  });\n  ```\n- **Functions Exported**: `generateStorageKey`, `uploadMusic`, `uploadMetadata`, `uploadBuffer`, `downloadFile`, `getSignedDownloadUrl`, `getSignedUploadUrl`, `deleteMusic`, `deleteJobFiles`, `fileExists`, `getFileInfo`\n- **Error Handling**: Missing env var validation (lines 15-19), file not found handling (lines 251-256)\n- **Issue**: R2 environment variables NOT documented in `.env.template`:\n  - `R2_ACCOUNT_ID`\n  - `R2_ACCESS_KEY_ID`\n  - `R2_SECRET_ACCESS_KEY`\n  - `R2_BUCKET_NAME`\n\n**Priority: Medium** - Add R2 variables to `.env.template`\n\n---\n\n#### 9. Stripe Webhook Handling\n\n**Status: PASS**\n\n**Location**: `/Users/imorgado/SPLICE/splice-backend/server.js:239-408`\n\n**Events Handled**:\n| Event | Handler | Status |\n|-------|---------|--------|\n| `customer.subscription.created` | Updates tier, generates license key | Check Met |\n| `customer.subscription.updated` | Updates tier | Check Met |\n| `customer.subscription.deleted` | Downgrades to cancelled | Check Met |\n| `invoice.payment_succeeded` | Resets hours for new billing period | Check Met |\n\n**Security Features**:\n- Signature verification via `stripe.webhooks.constructEvent`\n- Production mode rejects unsigned webhooks\n- Idempotency via `isEventProcessed()` and `recordWebhookEvent()`\n- Retry mechanism for license key generation (3 attempts with exponential backoff)\n\n**Env Vars**: `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`, price IDs all documented\n\n---\n\n### Additional Quality Issues (Beyond Requirements)\n\n#### 1. songIdentification.js - ACRCloud Integration (Not in Requirements)\n\n**Status: PASS WITH ISSUES**\n\n- Service exists at `/Users/imorgado/SPLICE/splice-backend/services/songIdentification.js`\n- Uses `ACRCLOUD_HOST`, `ACRCLOUD_ACCESS_KEY`, `ACRCLOUD_ACCESS_SECRET`\n- **Issue**: ACRCloud env vars NOT documented in `.env.template`\n\n**Priority: Low** - Add ACRCloud variables if feature is production-ready\n\n---\n\n### Recommendations\n\n#### Critical (None)\n\nNo critical issues identified.\n\n#### High Priority (None)\n\nNo high priority issues identified.\n\n#### Medium Priority\n\n1. **Add missing environment variables to `.env.template`**:\n\n   File: `/Users/imorgado/SPLICE/splice-backend/.env.template`\n   \n   Add after the Stripe section:\n   ```\n   # -----------------------------------------------------------------------------\n   # Music Generation (Mureka API)\n   # -----------------------------------------------------------------------------\n   MUREKA_API_KEY=your_mureka_api_key_here\n   \n   # -----------------------------------------------------------------------------\n   # Cloudflare R2 Storage\n   # -----------------------------------------------------------------------------\n   R2_ACCOUNT_ID=your_r2_account_id_here\n   R2_ACCESS_KEY_ID=your_r2_access_key_id_here\n   R2_SECRET_ACCESS_KEY=your_r2_secret_access_key_here\n   R2_BUCKET_NAME=splice-music\n   ```\n\n#### Low Priority\n\n2. **Document ACRCloud credentials** if song identification feature is production-ready:\n   ```\n   # -----------------------------------------------------------------------------\n   # Song Identification (ACRCloud)\n   # -----------------------------------------------------------------------------\n   ACRCLOUD_HOST=identify-us-west-2.acrcloud.com\n   ACRCLOUD_ACCESS_KEY=your_acrcloud_access_key_here\n   ACRCLOUD_ACCESS_SECRET=your_acrcloud_access_secret_here\n   ```\n\n---\n\n### Summary\n\nAll 8 required service integrations are properly implemented with:\n- Correct API client initialization\n- Properly exported callable functions\n- Comprehensive error handling\n- Database schemas defined via migration functions\n\nThe only issues are documentation gaps in `.env.template` for Mureka API and Cloudflare R2 credentials. The Stripe webhook correctly handles all subscription lifecycle events with proper idempotency and security measures."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1949,"cache_read_input_tokens":80596,"cache_creation":{"ephemeral_5m_input_tokens":1949,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWWLHv8EztHFCb8KKHdjn","type":"assistant","uuid":"4811544b-b695-4098-b492-4d16c546e4d1","timestamp":"2025-12-27T01:36:29.962Z"}
