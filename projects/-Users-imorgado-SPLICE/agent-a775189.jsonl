{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":"Add proper deprecation handling for the legacy `x-stripe-customer-id` authentication header in the SPLICE backend.\n\nLocation: /Users/imorgado/SPLICE/splice-backend/middleware/auth.js\n\nTasks:\n1. Find the legacy auth handling code (around line 405-427)\n\n2. Add deprecation warnings:\n   - Log a deprecation warning when legacy auth is used\n   - Add a `X-Deprecation-Warning` response header\n   - Include deprecation date in the warning\n\n3. Add environment variable control:\n   - Ensure `ALLOW_LEGACY_AUTH` defaults to `false` in production\n   - Add clear logging when legacy auth is disabled\n\n4. Update any documentation comments to reflect the deprecation\n\n5. Consider adding a sunset date (e.g., 90 days from now)\n\nExample deprecation header:\n```javascript\nres.set('X-Deprecation-Warning', 'x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: 2026-04-11');\n```\n\nMake the changes to properly deprecate this legacy authentication method."},"uuid":"8b4baf7f-45cf-499c-879d-45b72cfc3a5f","timestamp":"2026-01-11T23:47:55.468Z"}
{"parentUuid":"8b4baf7f-45cf-499c-879d-45b72cfc3a5f","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LiUtqq2rMkniJR8gguBHEk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011jW6SriQpESScsPyuNa5MA","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":27843,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":27843,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CX2V2pknSppBwTu74kZ1F","type":"assistant","uuid":"5a882114-82e6-41f5-a147-27c5b113f3f1","timestamp":"2026-01-11T23:47:59.231Z"}
{"parentUuid":"5a882114-82e6-41f5-a147-27c5b113f3f1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011jW6SriQpESScsPyuNa5MA","type":"tool_result","content":"     1→/**\n     2→ * JWT Authentication Middleware\n     3→ *\n     4→ * Replaces insecure x-stripe-customer-id header with JWT tokens.\n     5→ * Tokens are signed with a secret and contain the customer ID.\n     6→ *\n     7→ * Token Blacklist:\n     8→ * - Primary: Upstash Redis with automatic TTL-based expiry\n     9→ * - Fallback: In-memory Map (for development or Redis failures)\n    10→ */\n    11→\n    12→const jwt = require('jsonwebtoken');\n    13→const crypto = require('crypto');\n    14→const authLogger = require('../utils/authLogger');\n    15→const redis = require('../services/redisClient');\n    16→\n    17→// HIGH-007: Database pool for admin RBAC\n    18→let pool = null;\n    19→try {\n    20→  const { Pool } = require('pg');\n    21→  pool = new Pool({\n    22→    connectionString: process.env.DATABASE_URL,\n    23→    ssl: process.env.NODE_ENV === 'production'\n    24→      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n    25→      : false,\n    26→    max: 3, // Small pool just for auth checks\n    27→    idleTimeoutMillis: 30000,\n    28→  });\n    29→} catch (err) {\n    30→  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n    31→}\n    32→\n    33→// JWT configuration\n    34→const JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\n    35→const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\n    36→const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n    37→\n    38→// Redis key prefix for blacklisted tokens\n    39→const BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n    40→\n    41→// Check if running in production\n    42→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    43→\n    44→// HIGH-001: Validate JWT_SECRET security requirements\n    45→if (isProduction) {\n    46→  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    47→    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    48→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    49→    process.exit(1);\n    50→  }\n    51→  \n    52→  if (JWT_SECRET.length < 32) {\n    53→    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    54→    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    55→    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    56→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    57→    process.exit(1);\n    58→  }\n    59→}\n    60→\n    61→/**\n    62→ * Fallback Token Blacklist (In-Memory)\n    63→ * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n    64→ */\n    65→const fallbackBlacklist = new Map();\n    66→\n    67→// Track if we're using fallback mode\n    68→let usingFallback = false;\n    69→\n    70→// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\n    71→const BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n    72→\n    73→/**\n    74→ * Clean up expired entries from the fallback blacklist\n    75→ * Only runs when using in-memory fallback\n    76→ */\n    77→function cleanupFallbackBlacklist() {\n    78→  if (!usingFallback || fallbackBlacklist.size === 0) {\n    79→    return;\n    80→  }\n    81→\n    82→  const now = Math.floor(Date.now() / 1000);\n    83→  let cleanedCount = 0;\n    84→\n    85→  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    86→    if (exp <= now) {\n    87→      fallbackBlacklist.delete(jti);\n    88→      cleanedCount++;\n    89→    }\n    90→  }\n    91→\n    92→  if (cleanedCount > 0) {\n    93→    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n    94→  }\n    95→}\n    96→\n    97→// Start periodic cleanup for fallback (unref to allow process exit)\n    98→const cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\n    99→if (cleanupTimer.unref) {\n   100→  cleanupTimer.unref();\n   101→}\n   102→\n   103→/**\n   104→ * Add a token to the blacklist\n   105→ * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n   106→ * @param {string} jti - JWT ID claim\n   107→ * @param {number} exp - Token expiration timestamp (Unix seconds)\n   108→ * @param {Object} options - Additional options for logging\n   109→ * @param {string} options.userId - User ID for logging\n   110→ * @param {string} options.reason - Reason for revocation (logout, security, admin)\n   111→ * @returns {Promise<boolean>} True if successfully blacklisted\n   112→ */\n   113→async function blacklistToken(jti, exp, options = {}) {\n   114→  if (!jti) {\n   115→    console.warn('[Auth] Cannot blacklist token without jti');\n   116→    return false;\n   117→  }\n   118→\n   119→  const now = Math.floor(Date.now() / 1000);\n   120→  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n   121→\n   122→  // Try Redis first\n   123→  if (redis.isRedisAvailable()) {\n   124→    try {\n   125→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   126→      const success = await redis.set(key, exp, ttlSeconds);\n   127→\n   128→      if (success) {\n   129→        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n   130→        usingFallback = false;\n   131→        // Log token revocation with structured logging\n   132→        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   133→        return true;\n   134→      }\n   135→    } catch (err) {\n   136→      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n   137→    }\n   138→  }\n   139→\n   140→  // Fallback to in-memory\n   141→  usingFallback = true;\n   142→  fallbackBlacklist.set(jti, exp);\n   143→  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n   144→\n   145→  // Log token revocation with structured logging\n   146→  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   147→  return true;\n   148→}\n   149→\n   150→/**\n   151→ * Check if a token is blacklisted\n   152→ * Checks Redis first, then fallback in-memory store\n   153→ * @param {string} jti - JWT ID claim\n   154→ * @returns {Promise<boolean>} True if token is blacklisted\n   155→ */\n   156→async function isTokenBlacklisted(jti) {\n   157→  if (!jti) {\n   158→    return false;\n   159→  }\n   160→\n   161→  // Try Redis first\n   162→  if (redis.isRedisAvailable()) {\n   163→    try {\n   164→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   165→      const exists = await redis.exists(key);\n   166→\n   167→      if (exists) {\n   168→        return true;\n   169→      }\n   170→\n   171→      // Also check fallback in case token was blacklisted during Redis downtime\n   172→      // and Redis is now back up\n   173→      if (fallbackBlacklist.has(jti)) {\n   174→        // Migrate to Redis if token still valid\n   175→        const exp = fallbackBlacklist.get(jti);\n   176→        const now = Math.floor(Date.now() / 1000);\n   177→        if (exp > now) {\n   178→          const ttlSeconds = exp - now;\n   179→          await redis.set(key, exp, ttlSeconds);\n   180→          fallbackBlacklist.delete(jti);\n   181→          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n   182→        } else {\n   183→          // Expired, remove from fallback\n   184→          fallbackBlacklist.delete(jti);\n   185→        }\n   186→        return true;\n   187→      }\n   188→\n   189→      return false;\n   190→    } catch (err) {\n   191→      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n   192→    }\n   193→  }\n   194→\n   195→  // Fallback to in-memory check\n   196→  if (fallbackBlacklist.has(jti)) {\n   197→    const exp = fallbackBlacklist.get(jti);\n   198→    const now = Math.floor(Date.now() / 1000);\n   199→    if (exp > now) {\n   200→      return true;\n   201→    }\n   202→    // Expired, remove it\n   203→    fallbackBlacklist.delete(jti);\n   204→  }\n   205→\n   206→  return false;\n   207→}\n   208→\n   209→/**\n   210→ * Get blacklist statistics (for monitoring)\n   211→ * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n   212→ */\n   213→async function getBlacklistStats() {\n   214→  const redisAvailable = redis.isRedisAvailable();\n   215→  const redisStatus = redis.getRedisStatus();\n   216→\n   217→  return {\n   218→    storage: redisAvailable ? 'redis' : 'memory',\n   219→    redisConnected: redisStatus.connected,\n   220→    redisError: redisStatus.error,\n   221→    fallbackSize: fallbackBlacklist.size,\n   222→    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n   223→    usingFallback\n   224→  };\n   225→}\n   226→\n   227→/**\n   228→ * Generate a JWT token for a customer\n   229→ * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n   230→ * @param {Object} options - Additional options\n   231→ * @param {string} options.tier - User's subscription tier\n   232→ * @param {string} options.email - User's email (optional)\n   233→ * @returns {Object} { token, expiresIn }\n   234→ */\n   235→function generateToken(stripeCustomerId, options = {}) {\n   236→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   237→    throw new Error('Invalid Stripe customer ID');\n   238→  }\n   239→\n   240→  const payload = {\n   241→    sub: stripeCustomerId,\n   242→    type: 'access',\n   243→    tier: options.tier || 'starter',\n   244→    iat: Math.floor(Date.now() / 1000),\n   245→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   246→  };\n   247→\n   248→  if (options.email) {\n   249→    payload.email = options.email;\n   250→  }\n   251→\n   252→  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n   253→\n   254→  return {\n   255→    token,\n   256→    expiresIn: JWT_EXPIRES_IN,\n   257→    tokenType: 'Bearer'\n   258→  };\n   259→}\n   260→\n   261→/**\n   262→ * Generate a refresh token for a customer\n   263→ * @param {string} stripeCustomerId - Stripe customer ID\n   264→ * @returns {Object} { refreshToken, expiresIn }\n   265→ */\n   266→function generateRefreshToken(stripeCustomerId) {\n   267→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   268→    throw new Error('Invalid Stripe customer ID');\n   269→  }\n   270→\n   271→  const payload = {\n   272→    sub: stripeCustomerId,\n   273→    type: 'refresh',\n   274→    iat: Math.floor(Date.now() / 1000),\n   275→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   276→  };\n   277→\n   278→  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n   279→\n   280→  return {\n   281→    refreshToken,\n   282→    expiresIn: JWT_REFRESH_EXPIRES_IN\n   283→  };\n   284→}\n   285→\n   286→/**\n   287→ * Verify and decode a JWT token (async version)\n   288→ * Checks both JWT signature validity and token blacklist status via Redis\n   289→ * @param {string} token - JWT token to verify\n   290→ * @param {Object} options - Verification options\n   291→ * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n   292→ * @param {Object} options.req - Express request object for logging (optional)\n   293→ * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n   294→ */\n   295→async function verifyToken(token, options = {}) {\n   296→  const { checkBlacklist = true, req = null } = options;\n   297→\n   298→  try {\n   299→    const decoded = jwt.verify(token, JWT_SECRET);\n   300→\n   301→    // Check if token has been revoked (blacklisted) - async Redis check\n   302→    if (checkBlacklist && decoded.jti) {\n   303→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   304→      if (isBlacklisted) {\n   305→        if (req) {\n   306→          authLogger.logTokenBlacklisted(req, decoded.jti);\n   307→        }\n   308→        return null;\n   309→      }\n   310→    }\n   311→\n   312→    return decoded;\n   313→  } catch (err) {\n   314→    // Log specific error types for debugging\n   315→    if (err.name === 'TokenExpiredError') {\n   316→      if (req) {\n   317→        authLogger.logTokenExpired(req);\n   318→      }\n   319→    } else if (err.name === 'JsonWebTokenError') {\n   320→      if (req) {\n   321→        authLogger.logTokenInvalid(req, err.message);\n   322→      }\n   323→    }\n   324→    return null;\n   325→  }\n   326→}\n   327→\n   328→/**\n   329→ * Synchronous token verification (for cases where async is not possible)\n   330→ * Does NOT check blacklist - use verifyToken() for full verification\n   331→ * @param {string} token - JWT token to verify\n   332→ * @returns {Object|null} Decoded payload or null if invalid\n   333→ */\n   334→function verifyTokenSync(token) {\n   335→  try {\n   336→    return jwt.verify(token, JWT_SECRET);\n   337→  } catch {\n   338→    return null;\n   339→  }\n   340→}\n   341→\n   342→/**\n   343→ * Extract Bearer token from Authorization header\n   344→ * @param {string} authHeader - Authorization header value\n   345→ * @returns {string|null} Token or null if not found\n   346→ */\n   347→function extractBearerToken(authHeader) {\n   348→  if (!authHeader || typeof authHeader !== 'string') {\n   349→    return null;\n   350→  }\n   351→\n   352→  const parts = authHeader.split(' ');\n   353→  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n   354→    return null;\n   355→  }\n   356→\n   357→  return parts[1];\n   358→}\n   359→\n   360→/**\n   361→ * Middleware to authenticate JWT tokens\n   362→ * Sets req.stripeCustomerId if valid token found\n   363→ *\n   364→ * Supports both:\n   365→ * - Authorization: Bearer <token> (preferred)\n   366→ * - x-stripe-customer-id header (legacy, will be deprecated)\n   367→ */\n   368→async function authenticateToken(req, res, next) {\n   369→  // First, try JWT token from Authorization header\n   370→  const authHeader = req.headers['authorization'];\n   371→  const token = extractBearerToken(authHeader);\n   372→\n   373→  if (token) {\n   374→    // First verify JWT signature without blacklist check to get specific error messages\n   375→    const decoded = verifyTokenSync(token);\n   376→\n   377→    if (!decoded || !decoded.sub) {\n   378→      // Token is invalid or expired (signature failed)\n   379→      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n   380→      return res.status(401).json({\n   381→        error: 'Invalid or expired token',\n   382→        message: 'Please log in again to continue'\n   383→      });\n   384→    }\n   385→\n   386→    // Check if token has been revoked (blacklisted) - async Redis check\n   387→    if (decoded.jti) {\n   388→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   389→      if (isBlacklisted) {\n   390→        authLogger.logTokenBlacklisted(req, decoded.jti);\n   391→        return res.status(401).json({\n   392→          error: 'Token has been revoked',\n   393→          message: 'This session has been logged out. Please log in again.'\n   394→        });\n   395→      }\n   396→    }\n   397→\n   398→    // Token is valid and not revoked\n   399→    req.stripeCustomerId = decoded.sub;\n   400→    req.tokenData = decoded;\n   401→    req.rawToken = token; // Store raw token for logout\n   402→    return next();\n   403→  }\n   404→\n   405→  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n   406→  // This will be deprecated in future versions\n   407→  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   408→  if (legacyCustomerId) {\n   409→    // Log deprecation warning with structured logging (once per request)\n   410→    if (!req._legacyAuthWarned) {\n   411→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   412→      req._legacyAuthWarned = true;\n   413→    }\n   414→\n   415→    // Validate format\n   416→    if (!legacyCustomerId.startsWith('cus_')) {\n   417→      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n   418→      return res.status(401).json({\n   419→        error: 'Invalid customer ID format',\n   420→        message: 'Customer ID must start with cus_'\n   421→      });\n   422→    }\n   423→\n   424→    req.stripeCustomerId = legacyCustomerId;\n   425→    req.isLegacyAuth = true;\n   426→    return next();\n   427→  }\n   428→\n   429→  // No authentication provided\n   430→  return res.status(401).json({\n   431→    error: 'Authentication required',\n   432→    message: 'Please provide a valid Bearer token in the Authorization header'\n   433→  });\n   434→}\n   435→\n   436→/**\n   437→ * Optional authentication middleware\n   438→ * Allows unauthenticated access but sets req.stripeCustomerId if token present\n   439→ */\n   440→async function optionalAuthentication(req, res, next) {\n   441→  const authHeader = req.headers['authorization'];\n   442→  const token = extractBearerToken(authHeader);\n   443→\n   444→  if (token) {\n   445→    const decoded = await verifyToken(token);\n   446→    if (decoded && decoded.sub) {\n   447→      req.stripeCustomerId = decoded.sub;\n   448→      req.tokenData = decoded;\n   449→    }\n   450→  } else {\n   451→    // Check legacy header\n   452→    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   453→    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n   454→      req.stripeCustomerId = legacyCustomerId;\n   455→      req.isLegacyAuth = true;\n   456→    }\n   457→  }\n   458→\n   459→  next();\n   460→}\n   461→\n   462→/**\n   463→ * HIGH-007: Database-backed admin role check middleware\n   464→ * Checks the user's role in the database instead of relying on env vars\n   465→ * Requires authenticateToken middleware to run first\n   466→ *\n   467→ * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n   468→ * @param {Object} res - Express response object\n   469→ * @param {Function} next - Express next function\n   470→ */\n   471→async function requireAdmin(req, res, next) {\n   472→  // Must be authenticated first\n   473→  if (!req.stripeCustomerId) {\n   474→    return res.status(401).json({\n   475→      error: 'Authentication required',\n   476→      message: 'Please log in to access this resource'\n   477→    });\n   478→  }\n   479→\n   480→  // Check if database pool is available\n   481→  if (!pool) {\n   482→    console.error('[Auth] Admin check failed: Database pool not available');\n   483→    return res.status(503).json({\n   484→      error: 'Service unavailable',\n   485→      message: 'Admin verification temporarily unavailable'\n   486→    });\n   487→  }\n   488→\n   489→  try {\n   490→    // Query database for user role\n   491→    const result = await pool.query(\n   492→      'SELECT role FROM users WHERE stripe_customer_id = $1',\n   493→      [req.stripeCustomerId]\n   494→    );\n   495→\n   496→    if (!result.rows[0]) {\n   497→      authLogger.logAdminAccessDenied(req, 'User not found in database');\n   498→      return res.status(403).json({\n   499→        error: 'Access denied',\n   500→        message: 'User account not found'\n   501→      });\n   502→    }\n   503→\n   504→    const userRole = result.rows[0].role;\n   505→\n   506→    if (userRole !== 'admin') {\n   507→      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n   508→      return res.status(403).json({\n   509→        error: 'Admin access required',\n   510→        message: 'This action requires administrator privileges'\n   511→      });\n   512→    }\n   513→\n   514→    // User is admin - log and proceed\n   515→    authLogger.logAdminAccess(req);\n   516→    req.isAdmin = true;\n   517→    next();\n   518→  } catch (err) {\n   519→    console.error('[Auth] Admin role check failed:', err.message);\n   520→    return res.status(500).json({\n   521→      error: 'Authorization check failed',\n   522→      message: 'Unable to verify admin privileges'\n   523→    });\n   524→  }\n   525→}\n   526→\n   527→/**\n   528→ * Mask sensitive data for logging\n   529→ * @param {string} key - License key or other sensitive string\n   530→ * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n   531→ */\n   532→function maskSensitiveData(data) {\n   533→  if (!data || typeof data !== 'string') {\n   534→    return '****';\n   535→  }\n   536→\n   537→  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n   538→  if (data.startsWith('SPLICE-')) {\n   539→    const parts = data.split('-');\n   540→    if (parts.length === 5) {\n   541→      return `${parts[0]}-${parts[1]}-****-****-****`;\n   542→    }\n   543→  }\n   544→\n   545→  // For customer IDs (cus_xxxx format)\n   546→  if (data.startsWith('cus_')) {\n   547→    if (data.length > 10) {\n   548→      return `cus_${data.slice(4, 8)}****`;\n   549→    }\n   550→    return 'cus_****';\n   551→  }\n   552→\n   553→  // For JWTs (eyJ... format)\n   554→  if (data.startsWith('eyJ')) {\n   555→    return `${data.slice(0, 10)}...****`;\n   556→  }\n   557→\n   558→  // For emails\n   559→  if (data.includes('@')) {\n   560→    const [local, domain] = data.split('@');\n   561→    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n   562→    return `${maskedLocal}@${domain}`;\n   563→  }\n   564→\n   565→  // Generic masking - show first 4 chars\n   566→  if (data.length > 8) {\n   567→    return `${data.slice(0, 4)}****`;\n   568→  }\n   569→\n   570→  return '****';\n   571→}\n   572→\n   573→module.exports = {\n   574→  generateToken,\n   575→  generateRefreshToken,\n   576→  verifyToken,\n   577→  verifyTokenSync,\n   578→  extractBearerToken,\n   579→  authenticateToken,\n   580→  optionalAuthentication,\n   581→  maskSensitiveData,\n   582→  // HIGH-007: Admin RBAC middleware\n   583→  requireAdmin,\n   584→  // Token blacklist functions\n   585→  blacklistToken,\n   586→  isTokenBlacklisted,\n   587→  getBlacklistStats,\n   588→  // Structured logging\n   589→  authLogger,\n   590→  // Constants\n   591→  JWT_SECRET,\n   592→  JWT_EXPIRES_IN\n   593→};\n   594→\n\n</system-reminder>\n"}]},"uuid":"62748434-f52e-4d17-9609-67e1422ef1f4","timestamp":"2026-01-11T23:47:59.264Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","content":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n  // This will be deprecated in future versions\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // Check legacy header\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      req.stripeCustomerId = legacyCustomerId;\n      req.isLegacyAuth = true;\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};\n","numLines":594,"startLine":1,"totalLines":594}}}
{"parentUuid":"62748434-f52e-4d17-9609-67e1422ef1f4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_017kfrLdP6JQcNtaVSmb6YW9","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the authLogger to see what logging methods are available and how they're structured:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7576,"cache_read_input_tokens":27843,"cache_creation":{"ephemeral_5m_input_tokens":7576,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CX2V36ekmKTzW7rVJqJUW","type":"assistant","uuid":"d3f19bd3-7a8e-42c2-899c-502973de651a","timestamp":"2026-01-11T23:48:02.003Z"}
{"parentUuid":"d3f19bd3-7a8e-42c2-899c-502973de651a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_017kfrLdP6JQcNtaVSmb6YW9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TL3TuQe8P5A7GLAmySuJEn","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/utils/authLogger.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":7576,"cache_read_input_tokens":27843,"cache_creation":{"ephemeral_5m_input_tokens":7576,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CX2V36ekmKTzW7rVJqJUW","type":"assistant","uuid":"86d5adee-7442-42ed-a075-9271169be6e2","timestamp":"2026-01-11T23:48:02.903Z"}
{"parentUuid":"86d5adee-7442-42ed-a075-9271169be6e2","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TL3TuQe8P5A7GLAmySuJEn","type":"tool_result","content":"     1→/**\n     2→ * Structured Authentication Logger\n     3→ *\n     4→ * Provides consistent JSON-formatted logging for authentication events.\n     5→ * Designed to be captured by log aggregators (CloudWatch, Datadog, etc.)\n     6→ *\n     7→ * Log Format:\n     8→ * {\n     9→ *   timestamp: ISO8601 string,\n    10→ *   event_type: string,\n    11→ *   level: 'info' | 'warn' | 'error',\n    12→ *   user_id: string (masked),\n    13→ *   ip_address: string,\n    14→ *   details: object\n    15→ * }\n    16→ */\n    17→\n    18→/**\n    19→ * Event types for authentication logging\n    20→ */\n    21→const AUTH_EVENTS = {\n    22→  // Login events\n    23→  LOGIN_SUCCESS: 'auth.login.success',\n    24→  LOGIN_FAILED: 'auth.login.failed',\n    25→  LOGIN_RATE_LIMITED: 'auth.login.rate_limited',\n    26→\n    27→  // Logout events\n    28→  LOGOUT_SUCCESS: 'auth.logout.success',\n    29→  LOGOUT_FAILED: 'auth.logout.failed',\n    30→\n    31→  // Token events\n    32→  TOKEN_REFRESH_SUCCESS: 'auth.token.refresh_success',\n    33→  TOKEN_REFRESH_FAILED: 'auth.token.refresh_failed',\n    34→  TOKEN_REVOKED: 'auth.token.revoked',\n    35→  TOKEN_EXPIRED: 'auth.token.expired',\n    36→  TOKEN_INVALID: 'auth.token.invalid',\n    37→  TOKEN_BLACKLISTED: 'auth.token.blacklisted',\n    38→\n    39→  // Security events\n    40→  SUSPICIOUS_ACTIVITY: 'auth.security.suspicious',\n    41→  MULTIPLE_FAILED_ATTEMPTS: 'auth.security.multiple_failures',\n    42→  LEGACY_AUTH_USED: 'auth.security.legacy_header',\n    43→\n    44→  // Admin access events (HIGH-007: Database-backed RBAC)\n    45→  ADMIN_ACCESS_GRANTED: 'auth.admin.access_granted',\n    46→  ADMIN_ACCESS_DENIED: 'auth.admin.access_denied',\n    47→\n    48→  // Blacklist events\n    49→  BLACKLIST_CLEANUP: 'auth.blacklist.cleanup'\n    50→};\n    51→\n    52→/**\n    53→ * Log levels\n    54→ */\n    55→const LOG_LEVELS = {\n    56→  INFO: 'info',\n    57→  WARN: 'warn',\n    58→  ERROR: 'error'\n    59→};\n    60→\n    61→/**\n    62→ * In-memory store for tracking failed login attempts per IP\n    63→ * Used to detect suspicious activity\n    64→ */\n    65→const failedAttempts = new Map();\n    66→\n    67→// Cleanup failed attempts every 15 minutes\n    68→const FAILED_ATTEMPTS_TTL = 15 * 60 * 1000;\n    69→const FAILED_ATTEMPTS_THRESHOLD = 5; // Log suspicious after 5 failures\n    70→\n    71→/**\n    72→ * Extract client IP from request\n    73→ * Handles proxied requests (X-Forwarded-For, X-Real-IP)\n    74→ * @param {Object} req - Express request object\n    75→ * @returns {string} Client IP address\n    76→ */\n    77→function getClientIp(req) {\n    78→  if (!req) return 'unknown';\n    79→\n    80→  // Check for proxied IP (common in production behind load balancers)\n    81→  const forwarded = req.headers['x-forwarded-for'];\n    82→  if (forwarded) {\n    83→    // X-Forwarded-For can contain multiple IPs; take the first (client)\n    84→    return forwarded.split(',')[0].trim();\n    85→  }\n    86→\n    87→  const realIp = req.headers['x-real-ip'];\n    88→  if (realIp) {\n    89→    return realIp;\n    90→  }\n    91→\n    92→  // Direct connection\n    93→  return req.ip || req.connection?.remoteAddress || 'unknown';\n    94→}\n    95→\n    96→/**\n    97→ * Mask sensitive data for logging\n    98→ * @param {string} data - Sensitive string to mask\n    99→ * @param {string} type - Type of data ('user_id', 'email', 'token', 'jti', 'license_key')\n   100→ * @returns {string} Masked string\n   101→ */\n   102→function maskData(data, type = 'generic') {\n   103→  if (!data || typeof data !== 'string') {\n   104→    return '[empty]';\n   105→  }\n   106→\n   107→  switch (type) {\n   108→    case 'user_id':\n   109→      // Customer ID: cus_xxxx -> cus_xxxx****\n   110→      if (data.startsWith('cus_') && data.length > 10) {\n   111→        return `cus_${data.slice(4, 8)}****`;\n   112→      }\n   113→      return 'cus_****';\n   114→\n   115→    case 'email':\n   116→      if (data.includes('@')) {\n   117→        const [local, domain] = data.split('@');\n   118→        const maskedLocal = local.length > 2\n   119→          ? `${local[0]}***${local[local.length - 1]}`\n   120→          : '***';\n   121→        return `${maskedLocal}@${domain}`;\n   122→      }\n   123→      return '***@***.***';\n   124→\n   125→    case 'jti':\n   126→      // JWT ID: show first 8 chars\n   127→      if (data.length > 8) {\n   128→        return `${data.slice(0, 8)}...`;\n   129→      }\n   130→      return data;\n   131→\n   132→    case 'token':\n   133→      // JWT token: show first 10 chars\n   134→      if (data.startsWith('eyJ') && data.length > 10) {\n   135→        return `${data.slice(0, 10)}...`;\n   136→      }\n   137→      return '[token]';\n   138→\n   139→    case 'license_key':\n   140→      // License key: SPLICE-XXXX-XXXX-XXXX-XXXX -> SPLICE-XXXX-****-****-****\n   141→      if (data.startsWith('SPLICE-')) {\n   142→        const parts = data.split('-');\n   143→        if (parts.length === 5) {\n   144→          return `${parts[0]}-${parts[1]}-****-****-****`;\n   145→        }\n   146→      }\n   147→      return 'SPLICE-****';\n   148→\n   149→    default:\n   150→      // Generic: show first 4 chars\n   151→      if (data.length > 8) {\n   152→        return `${data.slice(0, 4)}****`;\n   153→      }\n   154→      return '****';\n   155→  }\n   156→}\n   157→\n   158→/**\n   159→ * Create a structured log entry\n   160→ * @param {string} eventType - Event type from AUTH_EVENTS\n   161→ * @param {string} level - Log level from LOG_LEVELS\n   162→ * @param {Object} options - Log options\n   163→ * @returns {Object} Structured log object\n   164→ */\n   165→function createLogEntry(eventType, level, options = {}) {\n   166→  const {\n   167→    userId = null,\n   168→    ipAddress = 'unknown',\n   169→    jti = null,\n   170→    reason = null,\n   171→    email = null,\n   172→    tier = null,\n   173→    details = {}\n   174→  } = options;\n   175→\n   176→  const entry = {\n   177→    timestamp: new Date().toISOString(),\n   178→    event_type: eventType,\n   179→    level,\n   180→    service: 'splice-auth'\n   181→  };\n   182→\n   183→  // Add user context if available (always masked)\n   184→  if (userId) {\n   185→    entry.user_id = maskData(userId, 'user_id');\n   186→  }\n   187→\n   188→  // Add IP address\n   189→  entry.ip_address = ipAddress;\n   190→\n   191→  // Add optional fields\n   192→  if (jti) {\n   193→    entry.jti = maskData(jti, 'jti');\n   194→  }\n   195→\n   196→  if (reason) {\n   197→    entry.reason = reason;\n   198→  }\n   199→\n   200→  if (email) {\n   201→    entry.email = maskData(email, 'email');\n   202→  }\n   203→\n   204→  if (tier) {\n   205→    entry.tier = tier;\n   206→  }\n   207→\n   208→  // Add any additional details\n   209→  if (Object.keys(details).length > 0) {\n   210→    entry.details = details;\n   211→  }\n   212→\n   213→  return entry;\n   214→}\n   215→\n   216→/**\n   217→ * Output a structured log entry\n   218→ * @param {Object} entry - Log entry object\n   219→ */\n   220→function outputLog(entry) {\n   221→  const jsonLog = JSON.stringify(entry);\n   222→\n   223→  switch (entry.level) {\n   224→    case LOG_LEVELS.ERROR:\n   225→      console.error(jsonLog);\n   226→      break;\n   227→    case LOG_LEVELS.WARN:\n   228→      console.warn(jsonLog);\n   229→      break;\n   230→    default:\n   231→      console.log(jsonLog);\n   232→  }\n   233→}\n   234→\n   235→/**\n   236→ * Track failed login attempt for an IP\n   237→ * @param {string} ip - Client IP address\n   238→ * @returns {number} Number of failed attempts from this IP\n   239→ */\n   240→function trackFailedAttempt(ip) {\n   241→  const now = Date.now();\n   242→  const existing = failedAttempts.get(ip) || { count: 0, firstAttempt: now };\n   243→\n   244→  // Reset if TTL expired\n   245→  if (now - existing.firstAttempt > FAILED_ATTEMPTS_TTL) {\n   246→    existing.count = 0;\n   247→    existing.firstAttempt = now;\n   248→  }\n   249→\n   250→  existing.count++;\n   251→  existing.lastAttempt = now;\n   252→  failedAttempts.set(ip, existing);\n   253→\n   254→  return existing.count;\n   255→}\n   256→\n   257→/**\n   258→ * Clear failed attempts for an IP (on successful login)\n   259→ * @param {string} ip - Client IP address\n   260→ */\n   261→function clearFailedAttempts(ip) {\n   262→  failedAttempts.delete(ip);\n   263→}\n   264→\n   265→/**\n   266→ * Get failed attempts info for an IP\n   267→ * @param {string} ip - Client IP address\n   268→ * @returns {Object|null} Failed attempts info or null\n   269→ */\n   270→function getFailedAttempts(ip) {\n   271→  return failedAttempts.get(ip) || null;\n   272→}\n   273→\n   274→// ============================================================================\n   275→// Public Logging Functions\n   276→// ============================================================================\n   277→\n   278→/**\n   279→ * Log successful login\n   280→ * @param {Object} req - Express request object\n   281→ * @param {string} userId - Customer ID\n   282→ * @param {Object} options - Additional options (email, tier)\n   283→ */\n   284→function logLoginSuccess(req, userId, options = {}) {\n   285→  const ip = getClientIp(req);\n   286→  clearFailedAttempts(ip); // Reset failed attempts on success\n   287→\n   288→  const entry = createLogEntry(AUTH_EVENTS.LOGIN_SUCCESS, LOG_LEVELS.INFO, {\n   289→    userId,\n   290→    ipAddress: ip,\n   291→    email: options.email,\n   292→    tier: options.tier\n   293→  });\n   294→\n   295→  outputLog(entry);\n   296→}\n   297→\n   298→/**\n   299→ * Log failed login attempt\n   300→ * @param {Object} req - Express request object\n   301→ * @param {string} reason - Reason for failure\n   302→ * @param {Object} options - Additional options (licenseKey)\n   303→ */\n   304→function logLoginFailed(req, reason, options = {}) {\n   305→  const ip = getClientIp(req);\n   306→  const attemptCount = trackFailedAttempt(ip);\n   307→\n   308→  const entry = createLogEntry(AUTH_EVENTS.LOGIN_FAILED, LOG_LEVELS.WARN, {\n   309→    ipAddress: ip,\n   310→    reason,\n   311→    details: {\n   312→      attempt_count: attemptCount,\n   313→      license_key_provided: !!options.licenseKey,\n   314→      license_key_masked: options.licenseKey ? maskData(options.licenseKey, 'license_key') : null\n   315→    }\n   316→  });\n   317→\n   318→  outputLog(entry);\n   319→\n   320→  // Log suspicious activity if threshold exceeded\n   321→  if (attemptCount >= FAILED_ATTEMPTS_THRESHOLD) {\n   322→    logSuspiciousActivity(req, 'multiple_failed_logins', {\n   323→      attempt_count: attemptCount,\n   324→      window_minutes: Math.floor(FAILED_ATTEMPTS_TTL / 60000)\n   325→    });\n   326→  }\n   327→}\n   328→\n   329→/**\n   330→ * Log successful logout\n   331→ * @param {Object} req - Express request object\n   332→ * @param {string} userId - Customer ID\n   333→ * @param {Object} options - Additional options (jti, refreshTokenRevoked)\n   334→ */\n   335→function logLogoutSuccess(req, userId, options = {}) {\n   336→  const entry = createLogEntry(AUTH_EVENTS.LOGOUT_SUCCESS, LOG_LEVELS.INFO, {\n   337→    userId,\n   338→    ipAddress: getClientIp(req),\n   339→    jti: options.jti,\n   340→    details: {\n   341→      refresh_token_revoked: !!options.refreshTokenRevoked\n   342→    }\n   343→  });\n   344→\n   345→  outputLog(entry);\n   346→}\n   347→\n   348→/**\n   349→ * Log token refresh success\n   350→ * @param {Object} req - Express request object\n   351→ * @param {string} userId - Customer ID\n   352→ */\n   353→function logTokenRefreshSuccess(req, userId) {\n   354→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_SUCCESS, LOG_LEVELS.INFO, {\n   355→    userId,\n   356→    ipAddress: getClientIp(req)\n   357→  });\n   358→\n   359→  outputLog(entry);\n   360→}\n   361→\n   362→/**\n   363→ * Log token refresh failure\n   364→ * @param {Object} req - Express request object\n   365→ * @param {string} reason - Reason for failure\n   366→ */\n   367→function logTokenRefreshFailed(req, reason) {\n   368→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_FAILED, LOG_LEVELS.WARN, {\n   369→    ipAddress: getClientIp(req),\n   370→    reason\n   371→  });\n   372→\n   373→  outputLog(entry);\n   374→}\n   375→\n   376→/**\n   377→ * Log token revocation (blacklisting)\n   378→ * @param {string} userId - Customer ID\n   379→ * @param {string} jti - JWT ID\n   380→ * @param {string} reason - Reason for revocation (logout, security, admin)\n   381→ */\n   382→function logTokenRevoked(userId, jti, reason = 'logout') {\n   383→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REVOKED, LOG_LEVELS.INFO, {\n   384→    userId,\n   385→    jti,\n   386→    reason,\n   387→    ipAddress: 'internal'\n   388→  });\n   389→\n   390→  outputLog(entry);\n   391→}\n   392→\n   393→/**\n   394→ * Log token validation failure (expired)\n   395→ * @param {Object} req - Express request object\n   396→ */\n   397→function logTokenExpired(req) {\n   398→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_EXPIRED, LOG_LEVELS.INFO, {\n   399→    ipAddress: getClientIp(req)\n   400→  });\n   401→\n   402→  outputLog(entry);\n   403→}\n   404→\n   405→/**\n   406→ * Log token validation failure (invalid signature/format)\n   407→ * @param {Object} req - Express request object\n   408→ * @param {string} reason - Specific reason\n   409→ */\n   410→function logTokenInvalid(req, reason) {\n   411→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_INVALID, LOG_LEVELS.WARN, {\n   412→    ipAddress: getClientIp(req),\n   413→    reason\n   414→  });\n   415→\n   416→  outputLog(entry);\n   417→}\n   418→\n   419→/**\n   420→ * Log blacklisted token access attempt\n   421→ * @param {Object} req - Express request object\n   422→ * @param {string} jti - JWT ID\n   423→ */\n   424→function logTokenBlacklisted(req, jti) {\n   425→  const entry = createLogEntry(AUTH_EVENTS.TOKEN_BLACKLISTED, LOG_LEVELS.WARN, {\n   426→    ipAddress: getClientIp(req),\n   427→    jti,\n   428→    reason: 'Token has been revoked'\n   429→  });\n   430→\n   431→  outputLog(entry);\n   432→}\n   433→\n   434→/**\n   435→ * Log suspicious activity\n   436→ * @param {Object} req - Express request object\n   437→ * @param {string} activity - Type of suspicious activity\n   438→ * @param {Object} details - Additional details\n   439→ */\n   440→function logSuspiciousActivity(req, activity, details = {}) {\n   441→  const entry = createLogEntry(AUTH_EVENTS.SUSPICIOUS_ACTIVITY, LOG_LEVELS.WARN, {\n   442→    ipAddress: getClientIp(req),\n   443→    reason: activity,\n   444→    details\n   445→  });\n   446→\n   447→  outputLog(entry);\n   448→}\n   449→\n   450→/**\n   451→ * Log use of legacy authentication header\n   452→ * @param {Object} req - Express request object\n   453→ * @param {string} userId - Customer ID\n   454→ */\n   455→function logLegacyAuthUsed(req, userId) {\n   456→  const entry = createLogEntry(AUTH_EVENTS.LEGACY_AUTH_USED, LOG_LEVELS.WARN, {\n   457→    userId,\n   458→    ipAddress: getClientIp(req),\n   459→    reason: 'x-stripe-customer-id header used instead of JWT'\n   460→  });\n   461→\n   462→  outputLog(entry);\n   463→}\n   464→\n   465→/**\n   466→ * Log blacklist cleanup\n   467→ * @param {number} removedCount - Number of entries removed\n   468→ * @param {number} remainingCount - Number of entries remaining\n   469→ */\n   470→function logBlacklistCleanup(removedCount, remainingCount) {\n   471→  const entry = createLogEntry(AUTH_EVENTS.BLACKLIST_CLEANUP, LOG_LEVELS.INFO, {\n   472→    ipAddress: 'internal',\n   473→    details: {\n   474→      removed_count: removedCount,\n   475→      remaining_count: remainingCount\n   476→    }\n   477→  });\n   478→\n   479→  outputLog(entry);\n   480→}\n   481→\n   482→/**\n   483→ * Log successful admin access (HIGH-007: Database-backed RBAC)\n   484→ * @param {Object} req - Express request object\n   485→ */\n   486→function logAdminAccess(req) {\n   487→  const entry = createLogEntry(AUTH_EVENTS.ADMIN_ACCESS_GRANTED, LOG_LEVELS.INFO, {\n   488→    userId: req.stripeCustomerId || req.user?.id,\n   489→    ipAddress: getClientIp(req),\n   490→    details: {\n   491→      path: req.path,\n   492→      method: req.method,\n   493→      user_agent: req.headers?.['user-agent']\n   494→    }\n   495→  });\n   496→\n   497→  outputLog(entry);\n   498→}\n   499→\n   500→/**\n   501→ * Log denied admin access attempt (HIGH-007: Database-backed RBAC)\n   502→ * @param {Object} req - Express request object\n   503→ * @param {string} reason - Reason for denial\n   504→ */\n   505→function logAdminAccessDenied(req, reason) {\n   506→  const entry = createLogEntry(AUTH_EVENTS.ADMIN_ACCESS_DENIED, LOG_LEVELS.WARN, {\n   507→    userId: req.stripeCustomerId || req.user?.id,\n   508→    ipAddress: getClientIp(req),\n   509→    reason,\n   510→    details: {\n   511→      path: req.path,\n   512→      method: req.method,\n   513→      user_agent: req.headers?.['user-agent']\n   514→    }\n   515→  });\n   516→\n   517→  outputLog(entry);\n   518→}\n   519→\n   520→// Cleanup interval for failed attempts tracking\n   521→setInterval(() => {\n   522→  const now = Date.now();\n   523→  for (const [ip, data] of failedAttempts.entries()) {\n   524→    if (now - data.lastAttempt > FAILED_ATTEMPTS_TTL) {\n   525→      failedAttempts.delete(ip);\n   526→    }\n   527→  }\n   528→}, FAILED_ATTEMPTS_TTL);\n   529→\n   530→module.exports = {\n   531→  // Event types\n   532→  AUTH_EVENTS,\n   533→  LOG_LEVELS,\n   534→\n   535→  // Utility functions\n   536→  getClientIp,\n   537→  maskData,\n   538→\n   539→  // Failed attempts tracking\n   540→  trackFailedAttempt,\n   541→  clearFailedAttempts,\n   542→  getFailedAttempts,\n   543→  FAILED_ATTEMPTS_THRESHOLD,\n   544→\n   545→  // Logging functions\n   546→  logLoginSuccess,\n   547→  logLoginFailed,\n   548→  logLogoutSuccess,\n   549→  logTokenRefreshSuccess,\n   550→  logTokenRefreshFailed,\n   551→  logTokenRevoked,\n   552→  logTokenExpired,\n   553→  logTokenInvalid,\n   554→  logTokenBlacklisted,\n   555→  logSuspiciousActivity,\n   556→  logLegacyAuthUsed,\n   557→  logBlacklistCleanup,\n   558→  // HIGH-007: Admin access logging\n   559→  logAdminAccess,\n   560→  logAdminAccessDenied\n   561→};\n   562→\n\n</system-reminder>\n"}]},"uuid":"f7776ed7-7dce-40e6-a83a-73ade6088fa4","timestamp":"2026-01-11T23:48:02.956Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/utils/authLogger.js","content":"/**\n * Structured Authentication Logger\n *\n * Provides consistent JSON-formatted logging for authentication events.\n * Designed to be captured by log aggregators (CloudWatch, Datadog, etc.)\n *\n * Log Format:\n * {\n *   timestamp: ISO8601 string,\n *   event_type: string,\n *   level: 'info' | 'warn' | 'error',\n *   user_id: string (masked),\n *   ip_address: string,\n *   details: object\n * }\n */\n\n/**\n * Event types for authentication logging\n */\nconst AUTH_EVENTS = {\n  // Login events\n  LOGIN_SUCCESS: 'auth.login.success',\n  LOGIN_FAILED: 'auth.login.failed',\n  LOGIN_RATE_LIMITED: 'auth.login.rate_limited',\n\n  // Logout events\n  LOGOUT_SUCCESS: 'auth.logout.success',\n  LOGOUT_FAILED: 'auth.logout.failed',\n\n  // Token events\n  TOKEN_REFRESH_SUCCESS: 'auth.token.refresh_success',\n  TOKEN_REFRESH_FAILED: 'auth.token.refresh_failed',\n  TOKEN_REVOKED: 'auth.token.revoked',\n  TOKEN_EXPIRED: 'auth.token.expired',\n  TOKEN_INVALID: 'auth.token.invalid',\n  TOKEN_BLACKLISTED: 'auth.token.blacklisted',\n\n  // Security events\n  SUSPICIOUS_ACTIVITY: 'auth.security.suspicious',\n  MULTIPLE_FAILED_ATTEMPTS: 'auth.security.multiple_failures',\n  LEGACY_AUTH_USED: 'auth.security.legacy_header',\n\n  // Admin access events (HIGH-007: Database-backed RBAC)\n  ADMIN_ACCESS_GRANTED: 'auth.admin.access_granted',\n  ADMIN_ACCESS_DENIED: 'auth.admin.access_denied',\n\n  // Blacklist events\n  BLACKLIST_CLEANUP: 'auth.blacklist.cleanup'\n};\n\n/**\n * Log levels\n */\nconst LOG_LEVELS = {\n  INFO: 'info',\n  WARN: 'warn',\n  ERROR: 'error'\n};\n\n/**\n * In-memory store for tracking failed login attempts per IP\n * Used to detect suspicious activity\n */\nconst failedAttempts = new Map();\n\n// Cleanup failed attempts every 15 minutes\nconst FAILED_ATTEMPTS_TTL = 15 * 60 * 1000;\nconst FAILED_ATTEMPTS_THRESHOLD = 5; // Log suspicious after 5 failures\n\n/**\n * Extract client IP from request\n * Handles proxied requests (X-Forwarded-For, X-Real-IP)\n * @param {Object} req - Express request object\n * @returns {string} Client IP address\n */\nfunction getClientIp(req) {\n  if (!req) return 'unknown';\n\n  // Check for proxied IP (common in production behind load balancers)\n  const forwarded = req.headers['x-forwarded-for'];\n  if (forwarded) {\n    // X-Forwarded-For can contain multiple IPs; take the first (client)\n    return forwarded.split(',')[0].trim();\n  }\n\n  const realIp = req.headers['x-real-ip'];\n  if (realIp) {\n    return realIp;\n  }\n\n  // Direct connection\n  return req.ip || req.connection?.remoteAddress || 'unknown';\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} data - Sensitive string to mask\n * @param {string} type - Type of data ('user_id', 'email', 'token', 'jti', 'license_key')\n * @returns {string} Masked string\n */\nfunction maskData(data, type = 'generic') {\n  if (!data || typeof data !== 'string') {\n    return '[empty]';\n  }\n\n  switch (type) {\n    case 'user_id':\n      // Customer ID: cus_xxxx -> cus_xxxx****\n      if (data.startsWith('cus_') && data.length > 10) {\n        return `cus_${data.slice(4, 8)}****`;\n      }\n      return 'cus_****';\n\n    case 'email':\n      if (data.includes('@')) {\n        const [local, domain] = data.split('@');\n        const maskedLocal = local.length > 2\n          ? `${local[0]}***${local[local.length - 1]}`\n          : '***';\n        return `${maskedLocal}@${domain}`;\n      }\n      return '***@***.***';\n\n    case 'jti':\n      // JWT ID: show first 8 chars\n      if (data.length > 8) {\n        return `${data.slice(0, 8)}...`;\n      }\n      return data;\n\n    case 'token':\n      // JWT token: show first 10 chars\n      if (data.startsWith('eyJ') && data.length > 10) {\n        return `${data.slice(0, 10)}...`;\n      }\n      return '[token]';\n\n    case 'license_key':\n      // License key: SPLICE-XXXX-XXXX-XXXX-XXXX -> SPLICE-XXXX-****-****-****\n      if (data.startsWith('SPLICE-')) {\n        const parts = data.split('-');\n        if (parts.length === 5) {\n          return `${parts[0]}-${parts[1]}-****-****-****`;\n        }\n      }\n      return 'SPLICE-****';\n\n    default:\n      // Generic: show first 4 chars\n      if (data.length > 8) {\n        return `${data.slice(0, 4)}****`;\n      }\n      return '****';\n  }\n}\n\n/**\n * Create a structured log entry\n * @param {string} eventType - Event type from AUTH_EVENTS\n * @param {string} level - Log level from LOG_LEVELS\n * @param {Object} options - Log options\n * @returns {Object} Structured log object\n */\nfunction createLogEntry(eventType, level, options = {}) {\n  const {\n    userId = null,\n    ipAddress = 'unknown',\n    jti = null,\n    reason = null,\n    email = null,\n    tier = null,\n    details = {}\n  } = options;\n\n  const entry = {\n    timestamp: new Date().toISOString(),\n    event_type: eventType,\n    level,\n    service: 'splice-auth'\n  };\n\n  // Add user context if available (always masked)\n  if (userId) {\n    entry.user_id = maskData(userId, 'user_id');\n  }\n\n  // Add IP address\n  entry.ip_address = ipAddress;\n\n  // Add optional fields\n  if (jti) {\n    entry.jti = maskData(jti, 'jti');\n  }\n\n  if (reason) {\n    entry.reason = reason;\n  }\n\n  if (email) {\n    entry.email = maskData(email, 'email');\n  }\n\n  if (tier) {\n    entry.tier = tier;\n  }\n\n  // Add any additional details\n  if (Object.keys(details).length > 0) {\n    entry.details = details;\n  }\n\n  return entry;\n}\n\n/**\n * Output a structured log entry\n * @param {Object} entry - Log entry object\n */\nfunction outputLog(entry) {\n  const jsonLog = JSON.stringify(entry);\n\n  switch (entry.level) {\n    case LOG_LEVELS.ERROR:\n      console.error(jsonLog);\n      break;\n    case LOG_LEVELS.WARN:\n      console.warn(jsonLog);\n      break;\n    default:\n      console.log(jsonLog);\n  }\n}\n\n/**\n * Track failed login attempt for an IP\n * @param {string} ip - Client IP address\n * @returns {number} Number of failed attempts from this IP\n */\nfunction trackFailedAttempt(ip) {\n  const now = Date.now();\n  const existing = failedAttempts.get(ip) || { count: 0, firstAttempt: now };\n\n  // Reset if TTL expired\n  if (now - existing.firstAttempt > FAILED_ATTEMPTS_TTL) {\n    existing.count = 0;\n    existing.firstAttempt = now;\n  }\n\n  existing.count++;\n  existing.lastAttempt = now;\n  failedAttempts.set(ip, existing);\n\n  return existing.count;\n}\n\n/**\n * Clear failed attempts for an IP (on successful login)\n * @param {string} ip - Client IP address\n */\nfunction clearFailedAttempts(ip) {\n  failedAttempts.delete(ip);\n}\n\n/**\n * Get failed attempts info for an IP\n * @param {string} ip - Client IP address\n * @returns {Object|null} Failed attempts info or null\n */\nfunction getFailedAttempts(ip) {\n  return failedAttempts.get(ip) || null;\n}\n\n// ============================================================================\n// Public Logging Functions\n// ============================================================================\n\n/**\n * Log successful login\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n * @param {Object} options - Additional options (email, tier)\n */\nfunction logLoginSuccess(req, userId, options = {}) {\n  const ip = getClientIp(req);\n  clearFailedAttempts(ip); // Reset failed attempts on success\n\n  const entry = createLogEntry(AUTH_EVENTS.LOGIN_SUCCESS, LOG_LEVELS.INFO, {\n    userId,\n    ipAddress: ip,\n    email: options.email,\n    tier: options.tier\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log failed login attempt\n * @param {Object} req - Express request object\n * @param {string} reason - Reason for failure\n * @param {Object} options - Additional options (licenseKey)\n */\nfunction logLoginFailed(req, reason, options = {}) {\n  const ip = getClientIp(req);\n  const attemptCount = trackFailedAttempt(ip);\n\n  const entry = createLogEntry(AUTH_EVENTS.LOGIN_FAILED, LOG_LEVELS.WARN, {\n    ipAddress: ip,\n    reason,\n    details: {\n      attempt_count: attemptCount,\n      license_key_provided: !!options.licenseKey,\n      license_key_masked: options.licenseKey ? maskData(options.licenseKey, 'license_key') : null\n    }\n  });\n\n  outputLog(entry);\n\n  // Log suspicious activity if threshold exceeded\n  if (attemptCount >= FAILED_ATTEMPTS_THRESHOLD) {\n    logSuspiciousActivity(req, 'multiple_failed_logins', {\n      attempt_count: attemptCount,\n      window_minutes: Math.floor(FAILED_ATTEMPTS_TTL / 60000)\n    });\n  }\n}\n\n/**\n * Log successful logout\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n * @param {Object} options - Additional options (jti, refreshTokenRevoked)\n */\nfunction logLogoutSuccess(req, userId, options = {}) {\n  const entry = createLogEntry(AUTH_EVENTS.LOGOUT_SUCCESS, LOG_LEVELS.INFO, {\n    userId,\n    ipAddress: getClientIp(req),\n    jti: options.jti,\n    details: {\n      refresh_token_revoked: !!options.refreshTokenRevoked\n    }\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token refresh success\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n */\nfunction logTokenRefreshSuccess(req, userId) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_SUCCESS, LOG_LEVELS.INFO, {\n    userId,\n    ipAddress: getClientIp(req)\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token refresh failure\n * @param {Object} req - Express request object\n * @param {string} reason - Reason for failure\n */\nfunction logTokenRefreshFailed(req, reason) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REFRESH_FAILED, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    reason\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token revocation (blacklisting)\n * @param {string} userId - Customer ID\n * @param {string} jti - JWT ID\n * @param {string} reason - Reason for revocation (logout, security, admin)\n */\nfunction logTokenRevoked(userId, jti, reason = 'logout') {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_REVOKED, LOG_LEVELS.INFO, {\n    userId,\n    jti,\n    reason,\n    ipAddress: 'internal'\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token validation failure (expired)\n * @param {Object} req - Express request object\n */\nfunction logTokenExpired(req) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_EXPIRED, LOG_LEVELS.INFO, {\n    ipAddress: getClientIp(req)\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log token validation failure (invalid signature/format)\n * @param {Object} req - Express request object\n * @param {string} reason - Specific reason\n */\nfunction logTokenInvalid(req, reason) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_INVALID, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    reason\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log blacklisted token access attempt\n * @param {Object} req - Express request object\n * @param {string} jti - JWT ID\n */\nfunction logTokenBlacklisted(req, jti) {\n  const entry = createLogEntry(AUTH_EVENTS.TOKEN_BLACKLISTED, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    jti,\n    reason: 'Token has been revoked'\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log suspicious activity\n * @param {Object} req - Express request object\n * @param {string} activity - Type of suspicious activity\n * @param {Object} details - Additional details\n */\nfunction logSuspiciousActivity(req, activity, details = {}) {\n  const entry = createLogEntry(AUTH_EVENTS.SUSPICIOUS_ACTIVITY, LOG_LEVELS.WARN, {\n    ipAddress: getClientIp(req),\n    reason: activity,\n    details\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log use of legacy authentication header\n * @param {Object} req - Express request object\n * @param {string} userId - Customer ID\n */\nfunction logLegacyAuthUsed(req, userId) {\n  const entry = createLogEntry(AUTH_EVENTS.LEGACY_AUTH_USED, LOG_LEVELS.WARN, {\n    userId,\n    ipAddress: getClientIp(req),\n    reason: 'x-stripe-customer-id header used instead of JWT'\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log blacklist cleanup\n * @param {number} removedCount - Number of entries removed\n * @param {number} remainingCount - Number of entries remaining\n */\nfunction logBlacklistCleanup(removedCount, remainingCount) {\n  const entry = createLogEntry(AUTH_EVENTS.BLACKLIST_CLEANUP, LOG_LEVELS.INFO, {\n    ipAddress: 'internal',\n    details: {\n      removed_count: removedCount,\n      remaining_count: remainingCount\n    }\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log successful admin access (HIGH-007: Database-backed RBAC)\n * @param {Object} req - Express request object\n */\nfunction logAdminAccess(req) {\n  const entry = createLogEntry(AUTH_EVENTS.ADMIN_ACCESS_GRANTED, LOG_LEVELS.INFO, {\n    userId: req.stripeCustomerId || req.user?.id,\n    ipAddress: getClientIp(req),\n    details: {\n      path: req.path,\n      method: req.method,\n      user_agent: req.headers?.['user-agent']\n    }\n  });\n\n  outputLog(entry);\n}\n\n/**\n * Log denied admin access attempt (HIGH-007: Database-backed RBAC)\n * @param {Object} req - Express request object\n * @param {string} reason - Reason for denial\n */\nfunction logAdminAccessDenied(req, reason) {\n  const entry = createLogEntry(AUTH_EVENTS.ADMIN_ACCESS_DENIED, LOG_LEVELS.WARN, {\n    userId: req.stripeCustomerId || req.user?.id,\n    ipAddress: getClientIp(req),\n    reason,\n    details: {\n      path: req.path,\n      method: req.method,\n      user_agent: req.headers?.['user-agent']\n    }\n  });\n\n  outputLog(entry);\n}\n\n// Cleanup interval for failed attempts tracking\nsetInterval(() => {\n  const now = Date.now();\n  for (const [ip, data] of failedAttempts.entries()) {\n    if (now - data.lastAttempt > FAILED_ATTEMPTS_TTL) {\n      failedAttempts.delete(ip);\n    }\n  }\n}, FAILED_ATTEMPTS_TTL);\n\nmodule.exports = {\n  // Event types\n  AUTH_EVENTS,\n  LOG_LEVELS,\n\n  // Utility functions\n  getClientIp,\n  maskData,\n\n  // Failed attempts tracking\n  trackFailedAttempt,\n  clearFailedAttempts,\n  getFailedAttempts,\n  FAILED_ATTEMPTS_THRESHOLD,\n\n  // Logging functions\n  logLoginSuccess,\n  logLoginFailed,\n  logLogoutSuccess,\n  logTokenRefreshSuccess,\n  logTokenRefreshFailed,\n  logTokenRevoked,\n  logTokenExpired,\n  logTokenInvalid,\n  logTokenBlacklisted,\n  logSuspiciousActivity,\n  logLegacyAuthUsed,\n  logBlacklistCleanup,\n  // HIGH-007: Admin access logging\n  logAdminAccess,\n  logAdminAccessDenied\n};\n","numLines":562,"startLine":1,"totalLines":562}}}
{"parentUuid":"f7776ed7-7dce-40e6-a83a-73ade6088fa4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_016k777om1wPihwRTQx92suJ","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a complete understanding of the code. I'll implement the deprecation handling for the legacy `x-stripe-customer-id` authentication header. Here's my plan:\n\n1. Add environment variable control (`ALLOW_LEGACY_AUTH`)\n2. Add a sunset date constant (90 days from today)\n3. Update the `authenticateToken` middleware with deprecation warnings and response headers\n4. Update the `optionalAuthentication` middleware similarly\n5. Add a new logging function for deprecation warnings\n6. Update documentation comments\n\nLet me start with the edits:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6556,"cache_read_input_tokens":35419,"cache_creation":{"ephemeral_5m_input_tokens":6556,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX2V3NMKBMvm6jekQ4DDL","type":"assistant","uuid":"d172294f-6049-41a9-a966-2ae51c72f066","timestamp":"2026-01-11T23:48:08.228Z"}
{"parentUuid":"d172294f-6049-41a9-a966-2ae51c72f066","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_016k777om1wPihwRTQx92suJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WLaSaWRBFcGfJibg8VsoRX","name":"Edit","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","old_string":"// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;","new_string":"// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6556,"cache_read_input_tokens":35419,"cache_creation":{"ephemeral_5m_input_tokens":6556,"ephemeral_1h_input_tokens":0},"output_tokens":733,"service_tier":"standard"}},"requestId":"req_011CX2V3NMKBMvm6jekQ4DDL","type":"assistant","uuid":"22efb331-5d47-4670-8b7a-6c1c60f7e614","timestamp":"2026-01-11T23:48:17.567Z"}
{"parentUuid":"22efb331-5d47-4670-8b7a-6c1c60f7e614","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WLaSaWRBFcGfJibg8VsoRX","type":"tool_result","content":"The file /Users/imorgado/SPLICE/splice-backend/middleware/auth.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    37→\n    38→// Redis key prefix for blacklisted tokens\n    39→const BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n    40→\n    41→// Check if running in production\n    42→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    43→\n    44→// =============================================================================\n    45→// Legacy Authentication Deprecation Configuration\n    46→// =============================================================================\n    47→// The x-stripe-customer-id header is deprecated and will be removed.\n    48→// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n    49→\n    50→/**\n    51→ * Legacy auth sunset date (90 days from 2026-01-11)\n    52→ * After this date, legacy auth will be completely removed\n    53→ */\n    54→const LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n    55→\n    56→/**\n    57→ * Whether to allow legacy x-stripe-customer-id header authentication\n    58→ * Defaults to false in production, true in development for backward compatibility\n    59→ */\n    60→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n    61→  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n    62→\n    63→// Log legacy auth configuration on startup\n    64→if (isProduction) {\n    65→  if (ALLOW_LEGACY_AUTH) {\n    66→    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    67→    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    68→    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n    69→  } else {\n    70→    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n    71→  }\n    72→} else {\n    73→  if (ALLOW_LEGACY_AUTH) {\n    74→    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    75→  } else {\n    76→    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n    77→  }\n    78→}\n    79→\n    80→// HIGH-001: Validate JWT_SECRET security requirements\n    81→if (isProduction) {\n    82→  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {"}]},"uuid":"63fdebbd-9475-4b02-9482-99c9d467d2b1","timestamp":"2026-01-11T23:48:17.608Z","toolUseResult":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","oldString":"// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;","newString":"// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}","originalFile":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n  // This will be deprecated in future versions\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // Check legacy header\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      req.stripeCustomerId = legacyCustomerId;\n      req.isLegacyAuth = true;\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};\n","structuredPatch":[{"oldStart":41,"oldLines":6,"newStart":41,"newLines":42,"lines":[" // Check if running in production"," const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;"," ","+// =============================================================================","+// Legacy Authentication Deprecation Configuration","+// =============================================================================","+// The x-stripe-customer-id header is deprecated and will be removed.","+// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)","+","+/**","+ * Legacy auth sunset date (90 days from 2026-01-11)","+ * After this date, legacy auth will be completely removed","+ */","+const LEGACY_AUTH_SUNSET_DATE = '2026-04-11';","+","+/**","+ * Whether to allow legacy x-stripe-customer-id header authentication","+ * Defaults to false in production, true in development for backward compatibility","+ */","+const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||","+  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');","+","+// Log legacy auth configuration on startup","+if (isProduction) {","+  if (ALLOW_LEGACY_AUTH) {","+    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');","+    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);","+    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');","+  } else {","+    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');","+  }","+} else {","+  if (ALLOW_LEGACY_AUTH) {","+    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);","+  } else {","+    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');","+  }","+}","+"," // HIGH-001: Validate JWT_SECRET security requirements"," if (isProduction) {","   if (JWT_SECRET === 'splice-dev-secret-change-in-production') {"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"63fdebbd-9475-4b02-9482-99c9d467d2b1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Horm1u4ULbPN5gXz1yp54J","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the `authenticateToken` middleware to include the deprecation warning header and proper handling:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1471,"cache_read_input_tokens":41975,"cache_creation":{"ephemeral_5m_input_tokens":1471,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX2V4T1PVhvNj89JfqCi2","type":"assistant","uuid":"df661126-1f84-4035-b57f-40e524349375","timestamp":"2026-01-11T23:48:20.367Z"}
{"parentUuid":"df661126-1f84-4035-b57f-40e524349375","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Horm1u4ULbPN5gXz1yp54J","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01L5U2FVK6oFqv8FYW7R1WBd","name":"Edit","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","old_string":"  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n  // This will be deprecated in future versions\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }","new_string":"  // ==========================================================================\n  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n  // This authentication method is deprecated and will be removed after\n  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n  // ==========================================================================\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Check if legacy auth is allowed\n    if (!ALLOW_LEGACY_AUTH) {\n      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      return res.status(401).json({\n        error: 'Legacy authentication disabled',\n        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n      });\n    }\n\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    // Set deprecation warning header on the response\n    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1471,"cache_read_input_tokens":41975,"cache_creation":{"ephemeral_5m_input_tokens":1471,"ephemeral_1h_input_tokens":0},"output_tokens":959,"service_tier":"standard"}},"requestId":"req_011CX2V4T1PVhvNj89JfqCi2","type":"assistant","uuid":"15b9dfdb-4c07-46c4-bb9e-02bf7ab071b0","timestamp":"2026-01-11T23:48:34.618Z"}
{"parentUuid":"15b9dfdb-4c07-46c4-bb9e-02bf7ab071b0","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L5U2FVK6oFqv8FYW7R1WBd","type":"tool_result","content":"The file /Users/imorgado/SPLICE/splice-backend/middleware/auth.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   437→    req.rawToken = token; // Store raw token for logout\n   438→    return next();\n   439→  }\n   440→\n   441→  // ==========================================================================\n   442→  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n   443→  // This authentication method is deprecated and will be removed after\n   444→  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n   445→  // ==========================================================================\n   446→  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   447→  if (legacyCustomerId) {\n   448→    // Check if legacy auth is allowed\n   449→    if (!ALLOW_LEGACY_AUTH) {\n   450→      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n   451→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   452→      return res.status(401).json({\n   453→        error: 'Legacy authentication disabled',\n   454→        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n   455→        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n   456→      });\n   457→    }\n   458→\n   459→    // Log deprecation warning with structured logging (once per request)\n   460→    if (!req._legacyAuthWarned) {\n   461→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   462→      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n   463→      req._legacyAuthWarned = true;\n   464→    }\n   465→\n   466→    // Validate format\n   467→    if (!legacyCustomerId.startsWith('cus_')) {\n   468→      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n   469→      return res.status(401).json({\n   470→        error: 'Invalid customer ID format',\n   471→        message: 'Customer ID must start with cus_'\n   472→      });\n   473→    }\n   474→\n   475→    // Set deprecation warning header on the response\n   476→    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n   477→    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n   478→\n   479→    req.stripeCustomerId = legacyCustomerId;\n   480→    req.isLegacyAuth = true;\n   481→    return next();\n   482→  }\n   483→\n   484→  // No authentication provided\n   485→  return res.status(401).json({\n   486→    error: 'Authentication required',"}]},"uuid":"8b1507d8-cbdb-435c-9264-d40c4fad2290","timestamp":"2026-01-11T23:48:34.659Z","toolUseResult":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","oldString":"  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n  // This will be deprecated in future versions\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }","newString":"  // ==========================================================================\n  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n  // This authentication method is deprecated and will be removed after\n  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n  // ==========================================================================\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Check if legacy auth is allowed\n    if (!ALLOW_LEGACY_AUTH) {\n      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      return res.status(401).json({\n        error: 'Legacy authentication disabled',\n        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n      });\n    }\n\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    // Set deprecation warning header on the response\n    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }","originalFile":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)\n  // This will be deprecated in future versions\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // Check legacy header\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      req.stripeCustomerId = legacyCustomerId;\n      req.isLegacyAuth = true;\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};\n","structuredPatch":[{"oldStart":438,"oldLines":13,"newStart":438,"newLines":28,"lines":["     return next();","   }"," ","-  // Fallback: Legacy x-stripe-customer-id header (for backward compatibility)","-  // This will be deprecated in future versions","+  // ==========================================================================","+  // DEPRECATED: Legacy x-stripe-customer-id header authentication","+  // This authentication method is deprecated and will be removed after","+  // the sunset date. Clients should migrate to JWT Bearer token authentication.","+  // ==========================================================================","   const legacyCustomerId = req.headers['x-stripe-customer-id'];","   if (legacyCustomerId) {","+    // Check if legacy auth is allowed","+    if (!ALLOW_LEGACY_AUTH) {","+      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);","+      authLogger.logLegacyAuthUsed(req, legacyCustomerId);","+      return res.status(401).json({","+        error: 'Legacy authentication disabled',","+        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',","+        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'","+      });","+    }","+","     // Log deprecation warning with structured logging (once per request)","     if (!req._legacyAuthWarned) {","       authLogger.logLegacyAuthUsed(req, legacyCustomerId);","+      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);","       req._legacyAuthWarned = true;","     }"," "]},{"oldStart":457,"oldLines":6,"newStart":472,"newLines":10,"lines":["       });","     }"," ","+    // Set deprecation warning header on the response","+    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);","+    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);","+","     req.stripeCustomerId = legacyCustomerId;","     req.isLegacyAuth = true;","     return next();"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"8b1507d8-cbdb-435c-9264-d40c4fad2290","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_011DXq1fLh9BhU7k9dm78Tq8","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the `optionalAuthentication` middleware to include similar deprecation handling:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1900,"cache_read_input_tokens":43446,"cache_creation":{"ephemeral_5m_input_tokens":1900,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2V5hucJ76gsyGxUguED","type":"assistant","uuid":"9e0bac79-d275-4b61-990c-d692dfcac59e","timestamp":"2026-01-11T23:48:37.686Z"}
{"parentUuid":"9e0bac79-d275-4b61-990c-d692dfcac59e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_011DXq1fLh9BhU7k9dm78Tq8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NoNWWQmGFYHwsNN7E9uDb4","name":"Edit","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","old_string":"/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // Check legacy header\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      req.stripeCustomerId = legacyCustomerId;\n      req.isLegacyAuth = true;\n    }\n  }\n\n  next();\n}","new_string":"/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n *\n * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      // Only accept legacy auth if allowed\n      if (ALLOW_LEGACY_AUTH) {\n        // Log deprecation warning\n        if (!req._legacyAuthWarned) {\n          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n          req._legacyAuthWarned = true;\n        }\n\n        // Set deprecation warning headers\n        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n        req.stripeCustomerId = legacyCustomerId;\n        req.isLegacyAuth = true;\n      }\n      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n    }\n  }\n\n  next();\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1900,"cache_read_input_tokens":43446,"cache_creation":{"ephemeral_5m_input_tokens":1900,"ephemeral_1h_input_tokens":0},"output_tokens":843,"service_tier":"standard"}},"requestId":"req_011CX2V5hucJ76gsyGxUguED","type":"assistant","uuid":"4619e813-8b22-414f-86b0-6b1dcda3d998","timestamp":"2026-01-11T23:48:48.291Z"}
{"parentUuid":"4619e813-8b22-414f-86b0-6b1dcda3d998","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NoNWWQmGFYHwsNN7E9uDb4","type":"tool_result","content":"The file /Users/imorgado/SPLICE/splice-backend/middleware/auth.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   487→    message: 'Please provide a valid Bearer token in the Authorization header'\n   488→  });\n   489→}\n   490→\n   491→/**\n   492→ * Optional authentication middleware\n   493→ * Allows unauthenticated access but sets req.stripeCustomerId if token present\n   494→ *\n   495→ * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n   496→ */\n   497→async function optionalAuthentication(req, res, next) {\n   498→  const authHeader = req.headers['authorization'];\n   499→  const token = extractBearerToken(authHeader);\n   500→\n   501→  if (token) {\n   502→    const decoded = await verifyToken(token);\n   503→    if (decoded && decoded.sub) {\n   504→      req.stripeCustomerId = decoded.sub;\n   505→      req.tokenData = decoded;\n   506→    }\n   507→  } else {\n   508→    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n   509→    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   510→    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n   511→      // Only accept legacy auth if allowed\n   512→      if (ALLOW_LEGACY_AUTH) {\n   513→        // Log deprecation warning\n   514→        if (!req._legacyAuthWarned) {\n   515→          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   516→          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n   517→          req._legacyAuthWarned = true;\n   518→        }\n   519→\n   520→        // Set deprecation warning headers\n   521→        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n   522→        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n   523→\n   524→        req.stripeCustomerId = legacyCustomerId;\n   525→        req.isLegacyAuth = true;\n   526→      }\n   527→      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n   528→    }\n   529→  }\n   530→\n   531→  next();\n   532→}\n   533→\n   534→/**\n   535→ * HIGH-007: Database-backed admin role check middleware\n   536→ * Checks the user's role in the database instead of relying on env vars"}]},"uuid":"927118c3-5a61-4912-b25a-789d6032183d","timestamp":"2026-01-11T23:48:48.326Z","toolUseResult":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","oldString":"/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // Check legacy header\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      req.stripeCustomerId = legacyCustomerId;\n      req.isLegacyAuth = true;\n    }\n  }\n\n  next();\n}","newString":"/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n *\n * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      // Only accept legacy auth if allowed\n      if (ALLOW_LEGACY_AUTH) {\n        // Log deprecation warning\n        if (!req._legacyAuthWarned) {\n          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n          req._legacyAuthWarned = true;\n        }\n\n        // Set deprecation warning headers\n        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n        req.stripeCustomerId = legacyCustomerId;\n        req.isLegacyAuth = true;\n      }\n      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n    }\n  }\n\n  next();\n}","originalFile":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // ==========================================================================\n  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n  // This authentication method is deprecated and will be removed after\n  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n  // ==========================================================================\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Check if legacy auth is allowed\n    if (!ALLOW_LEGACY_AUTH) {\n      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      return res.status(401).json({\n        error: 'Legacy authentication disabled',\n        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n      });\n    }\n\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    // Set deprecation warning header on the response\n    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // Check legacy header\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      req.stripeCustomerId = legacyCustomerId;\n      req.isLegacyAuth = true;\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};\n","structuredPatch":[{"oldStart":491,"oldLines":6,"newStart":491,"newLines":8,"lines":[" /**","  * Optional authentication middleware","  * Allows unauthenticated access but sets req.stripeCustomerId if token present","+ *","+ * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH","  */"," async function optionalAuthentication(req, res, next) {","   const authHeader = req.headers['authorization'];"]},{"oldStart":503,"oldLines":11,"newStart":505,"newLines":26,"lines":["       req.tokenData = decoded;","     }","   } else {","-    // Check legacy header","+    // DEPRECATED: Legacy x-stripe-customer-id header authentication","     const legacyCustomerId = req.headers['x-stripe-customer-id'];","     if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {","-      req.stripeCustomerId = legacyCustomerId;","-      req.isLegacyAuth = true;","+      // Only accept legacy auth if allowed","+      if (ALLOW_LEGACY_AUTH) {","+        // Log deprecation warning","+        if (!req._legacyAuthWarned) {","+          authLogger.logLegacyAuthUsed(req, legacyCustomerId);","+          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);","+          req._legacyAuthWarned = true;","+        }","+","+        // Set deprecation warning headers","+        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);","+        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);","+","+        req.stripeCustomerId = legacyCustomerId;","+        req.isLegacyAuth = true;","+      }","+      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)","     }","   }"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"927118c3-5a61-4912-b25a-789d6032183d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_014WxA5n9igTYauaLb6xAkxA","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the file header documentation comment to reflect the deprecation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1607,"cache_read_input_tokens":45346,"cache_creation":{"ephemeral_5m_input_tokens":1607,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2V6iNfqhme84VLAmb4j","type":"assistant","uuid":"2d73dc21-a6ef-4f76-9913-dcff5bd4e67a","timestamp":"2026-01-11T23:48:50.945Z"}
{"parentUuid":"2d73dc21-a6ef-4f76-9913-dcff5bd4e67a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_014WxA5n9igTYauaLb6xAkxA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MMG34PPeXDwigbTucPw5Wm","name":"Edit","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","old_string":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */","new_string":"/**\n * JWT Authentication Middleware\n *\n * Primary authentication method: JWT Bearer tokens\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n *\n * DEPRECATION NOTICE:\n * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n * - Sunset Date: 2026-04-11\n * - Control: Set ALLOW_LEGACY_AUTH environment variable\n *   - Production default: false (disabled)\n *   - Development default: true (enabled for backward compatibility)\n * - Clients using legacy auth will receive X-Deprecation-Warning headers\n * - After sunset date, legacy auth will be completely removed\n *\n * Migration Guide:\n * 1. Call POST /auth/login with license key to obtain JWT tokens\n * 2. Use Authorization: Bearer <token> header for all authenticated requests\n * 3. Use POST /auth/refresh to refresh expired tokens\n */"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1607,"cache_read_input_tokens":45346,"cache_creation":{"ephemeral_5m_input_tokens":1607,"ephemeral_1h_input_tokens":0},"output_tokens":495,"service_tier":"standard"}},"requestId":"req_011CX2V6iNfqhme84VLAmb4j","type":"assistant","uuid":"ae7147ae-d63c-4056-9d74-1e2f11c0cc5e","timestamp":"2026-01-11T23:48:59.118Z"}
{"parentUuid":"ae7147ae-d63c-4056-9d74-1e2f11c0cc5e","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MMG34PPeXDwigbTucPw5Wm","type":"tool_result","content":"The file /Users/imorgado/SPLICE/splice-backend/middleware/auth.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n     1→/**\n     2→ * JWT Authentication Middleware\n     3→ *\n     4→ * Primary authentication method: JWT Bearer tokens\n     5→ * Tokens are signed with a secret and contain the customer ID.\n     6→ *\n     7→ * Token Blacklist:\n     8→ * - Primary: Upstash Redis with automatic TTL-based expiry\n     9→ * - Fallback: In-memory Map (for development or Redis failures)\n    10→ *\n    11→ * DEPRECATION NOTICE:\n    12→ * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n    13→ * - Sunset Date: 2026-04-11\n    14→ * - Control: Set ALLOW_LEGACY_AUTH environment variable\n    15→ *   - Production default: false (disabled)\n    16→ *   - Development default: true (enabled for backward compatibility)\n    17→ * - Clients using legacy auth will receive X-Deprecation-Warning headers\n    18→ * - After sunset date, legacy auth will be completely removed\n    19→ *\n    20→ * Migration Guide:\n    21→ * 1. Call POST /auth/login with license key to obtain JWT tokens\n    22→ * 2. Use Authorization: Bearer <token> header for all authenticated requests\n    23→ * 3. Use POST /auth/refresh to refresh expired tokens\n    24→ */\n    25→\n    26→const jwt = require('jsonwebtoken');\n    27→const crypto = require('crypto');\n    28→const authLogger = require('../utils/authLogger');"}]},"uuid":"bb5f85b0-091e-4949-b510-53ef2fbaba03","timestamp":"2026-01-11T23:48:59.155Z","toolUseResult":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","oldString":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */","newString":"/**\n * JWT Authentication Middleware\n *\n * Primary authentication method: JWT Bearer tokens\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n *\n * DEPRECATION NOTICE:\n * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n * - Sunset Date: 2026-04-11\n * - Control: Set ALLOW_LEGACY_AUTH environment variable\n *   - Production default: false (disabled)\n *   - Development default: true (enabled for backward compatibility)\n * - Clients using legacy auth will receive X-Deprecation-Warning headers\n * - After sunset date, legacy auth will be completely removed\n *\n * Migration Guide:\n * 1. Call POST /auth/login with license key to obtain JWT tokens\n * 2. Use Authorization: Bearer <token> header for all authenticated requests\n * 3. Use POST /auth/refresh to refresh expired tokens\n */","originalFile":"/**\n * JWT Authentication Middleware\n *\n * Replaces insecure x-stripe-customer-id header with JWT tokens.\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // ==========================================================================\n  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n  // This authentication method is deprecated and will be removed after\n  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n  // ==========================================================================\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Check if legacy auth is allowed\n    if (!ALLOW_LEGACY_AUTH) {\n      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      return res.status(401).json({\n        error: 'Legacy authentication disabled',\n        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n      });\n    }\n\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    // Set deprecation warning header on the response\n    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n *\n * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      // Only accept legacy auth if allowed\n      if (ALLOW_LEGACY_AUTH) {\n        // Log deprecation warning\n        if (!req._legacyAuthWarned) {\n          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n          req._legacyAuthWarned = true;\n        }\n\n        // Set deprecation warning headers\n        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n        req.stripeCustomerId = legacyCustomerId;\n        req.isLegacyAuth = true;\n      }\n      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};\n","structuredPatch":[{"oldStart":1,"oldLines":12,"newStart":1,"newLines":26,"lines":[" /**","  * JWT Authentication Middleware","  *","- * Replaces insecure x-stripe-customer-id header with JWT tokens.","+ * Primary authentication method: JWT Bearer tokens","  * Tokens are signed with a secret and contain the customer ID.","  *","  * Token Blacklist:","  * - Primary: Upstash Redis with automatic TTL-based expiry","  * - Fallback: In-memory Map (for development or Redis failures)","+ *","+ * DEPRECATION NOTICE:","+ * The legacy x-stripe-customer-id header authentication is DEPRECATED.","+ * - Sunset Date: 2026-04-11","+ * - Control: Set ALLOW_LEGACY_AUTH environment variable","+ *   - Production default: false (disabled)","+ *   - Development default: true (enabled for backward compatibility)","+ * - Clients using legacy auth will receive X-Deprecation-Warning headers","+ * - After sunset date, legacy auth will be completely removed","+ *","+ * Migration Guide:","+ * 1. Call POST /auth/login with license key to obtain JWT tokens","+ * 2. Use Authorization: Bearer <token> header for all authenticated requests","+ * 3. Use POST /auth/refresh to refresh expired tokens","  */"," "," const jwt = require('jsonwebtoken');"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"bb5f85b0-091e-4949-b510-53ef2fbaba03","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HVQcfeq8xNKBeyJJ1tVyQD","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the module exports to include the new constants:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1042,"cache_read_input_tokens":46953,"cache_creation":{"ephemeral_5m_input_tokens":1042,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2V7WfF4VRbYrFywkbKQ","type":"assistant","uuid":"ebd8bbf3-50b4-497e-b522-753ac184eb51","timestamp":"2026-01-11T23:49:01.614Z"}
{"parentUuid":"ebd8bbf3-50b4-497e-b522-753ac184eb51","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HVQcfeq8xNKBeyJJ1tVyQD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K8D3duYUUZ3V46tPHm26r8","name":"Edit","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","old_string":"module.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};","new_string":"module.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN,\n  // Legacy auth deprecation constants\n  LEGACY_AUTH_SUNSET_DATE,\n  ALLOW_LEGACY_AUTH\n};"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1042,"cache_read_input_tokens":46953,"cache_creation":{"ephemeral_5m_input_tokens":1042,"ephemeral_1h_input_tokens":0},"output_tokens":427,"service_tier":"standard"}},"requestId":"req_011CX2V7WfF4VRbYrFywkbKQ","type":"assistant","uuid":"82973b9c-a226-4acd-857a-44a5ac5ab093","timestamp":"2026-01-11T23:49:07.080Z"}
{"parentUuid":"82973b9c-a226-4acd-857a-44a5ac5ab093","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K8D3duYUUZ3V46tPHm26r8","type":"tool_result","content":"The file /Users/imorgado/SPLICE/splice-backend/middleware/auth.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   655→\n   656→  return '****';\n   657→}\n   658→\n   659→module.exports = {\n   660→  generateToken,\n   661→  generateRefreshToken,\n   662→  verifyToken,\n   663→  verifyTokenSync,\n   664→  extractBearerToken,\n   665→  authenticateToken,\n   666→  optionalAuthentication,\n   667→  maskSensitiveData,\n   668→  // HIGH-007: Admin RBAC middleware\n   669→  requireAdmin,\n   670→  // Token blacklist functions\n   671→  blacklistToken,\n   672→  isTokenBlacklisted,\n   673→  getBlacklistStats,\n   674→  // Structured logging\n   675→  authLogger,\n   676→  // Constants\n   677→  JWT_SECRET,\n   678→  JWT_EXPIRES_IN,\n   679→  // Legacy auth deprecation constants\n   680→  LEGACY_AUTH_SUNSET_DATE,\n   681→  ALLOW_LEGACY_AUTH\n   682→};\n   683→"}]},"uuid":"1d07ff4b-eeaa-4d6c-ac59-81292ea7bfe4","timestamp":"2026-01-11T23:49:07.122Z","toolUseResult":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","oldString":"module.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};","newString":"module.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN,\n  // Legacy auth deprecation constants\n  LEGACY_AUTH_SUNSET_DATE,\n  ALLOW_LEGACY_AUTH\n};","originalFile":"/**\n * JWT Authentication Middleware\n *\n * Primary authentication method: JWT Bearer tokens\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n *\n * DEPRECATION NOTICE:\n * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n * - Sunset Date: 2026-04-11\n * - Control: Set ALLOW_LEGACY_AUTH environment variable\n *   - Production default: false (disabled)\n *   - Development default: true (enabled for backward compatibility)\n * - Clients using legacy auth will receive X-Deprecation-Warning headers\n * - After sunset date, legacy auth will be completely removed\n *\n * Migration Guide:\n * 1. Call POST /auth/login with license key to obtain JWT tokens\n * 2. Use Authorization: Bearer <token> header for all authenticated requests\n * 3. Use POST /auth/refresh to refresh expired tokens\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // ==========================================================================\n  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n  // This authentication method is deprecated and will be removed after\n  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n  // ==========================================================================\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Check if legacy auth is allowed\n    if (!ALLOW_LEGACY_AUTH) {\n      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      return res.status(401).json({\n        error: 'Legacy authentication disabled',\n        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n      });\n    }\n\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    // Set deprecation warning header on the response\n    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n *\n * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      // Only accept legacy auth if allowed\n      if (ALLOW_LEGACY_AUTH) {\n        // Log deprecation warning\n        if (!req._legacyAuthWarned) {\n          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n          req._legacyAuthWarned = true;\n        }\n\n        // Set deprecation warning headers\n        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n        req.stripeCustomerId = legacyCustomerId;\n        req.isLegacyAuth = true;\n      }\n      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN\n};\n","structuredPatch":[{"oldStart":675,"oldLines":5,"newStart":675,"newLines":8,"lines":["   authLogger,","   // Constants","   JWT_SECRET,","-  JWT_EXPIRES_IN","+  JWT_EXPIRES_IN,","+  // Legacy auth deprecation constants","+  LEGACY_AUTH_SUNSET_DATE,","+  ALLOW_LEGACY_AUTH"," };"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"1d07ff4b-eeaa-4d6c-ac59-81292ea7bfe4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C5Gk898LrFA9zRJfQtY2ot","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also update the authenticateToken function's JSDoc comment to better document the deprecation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":750,"cache_read_input_tokens":47995,"cache_creation":{"ephemeral_5m_input_tokens":750,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2V86hsEtg3SyKdgHfyj","type":"assistant","uuid":"2485b724-8bdc-4cc6-a74a-f07a979f1195","timestamp":"2026-01-11T23:49:10.114Z"}
{"parentUuid":"2485b724-8bdc-4cc6-a74a-f07a979f1195","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C5Gk898LrFA9zRJfQtY2ot","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PQSSRFFZa45r5DrxyoaMPq","name":"Edit","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","old_string":"/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */","new_string":"/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Authentication Methods:\n * - Authorization: Bearer <token> (PREFERRED - use this method)\n * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)\n *\n * DEPRECATION: x-stripe-customer-id header\n * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var\n * - Production: Disabled by default (returns 401)\n * - Development: Enabled by default for backward compatibility\n * - Sunset Date: 2026-04-11 (after which it will be removed entirely)\n * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers\n *\n * @param {Object} req - Express request object\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":750,"cache_read_input_tokens":47995,"cache_creation":{"ephemeral_5m_input_tokens":750,"ephemeral_1h_input_tokens":0},"output_tokens":433,"service_tier":"standard"}},"requestId":"req_011CX2V86hsEtg3SyKdgHfyj","type":"assistant","uuid":"f9719270-445d-40c1-906e-a5f58360fcf6","timestamp":"2026-01-11T23:49:17.105Z"}
{"parentUuid":"f9719270-445d-40c1-906e-a5f58360fcf6","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PQSSRFFZa45r5DrxyoaMPq","type":"tool_result","content":"The file /Users/imorgado/SPLICE/splice-backend/middleware/auth.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   406→\n   407→  return parts[1];\n   408→}\n   409→\n   410→/**\n   411→ * Middleware to authenticate JWT tokens\n   412→ * Sets req.stripeCustomerId if valid token found\n   413→ *\n   414→ * Authentication Methods:\n   415→ * - Authorization: Bearer <token> (PREFERRED - use this method)\n   416→ * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)\n   417→ *\n   418→ * DEPRECATION: x-stripe-customer-id header\n   419→ * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var\n   420→ * - Production: Disabled by default (returns 401)\n   421→ * - Development: Enabled by default for backward compatibility\n   422→ * - Sunset Date: 2026-04-11 (after which it will be removed entirely)\n   423→ * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers\n   424→ *\n   425→ * @param {Object} req - Express request object\n   426→ * @param {Object} res - Express response object\n   427→ * @param {Function} next - Express next function\n   428→ */\n   429→async function authenticateToken(req, res, next) {\n   430→  // First, try JWT token from Authorization header\n   431→  const authHeader = req.headers['authorization'];\n   432→  const token = extractBearerToken(authHeader);"}]},"uuid":"d67e46e0-1b89-4ccb-934a-39a25a513c0d","timestamp":"2026-01-11T23:49:17.146Z","toolUseResult":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","oldString":"/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */","newString":"/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Authentication Methods:\n * - Authorization: Bearer <token> (PREFERRED - use this method)\n * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)\n *\n * DEPRECATION: x-stripe-customer-id header\n * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var\n * - Production: Disabled by default (returns 401)\n * - Development: Enabled by default for backward compatibility\n * - Sunset Date: 2026-04-11 (after which it will be removed entirely)\n * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers\n *\n * @param {Object} req - Express request object\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */","originalFile":"/**\n * JWT Authentication Middleware\n *\n * Primary authentication method: JWT Bearer tokens\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n *\n * DEPRECATION NOTICE:\n * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n * - Sunset Date: 2026-04-11\n * - Control: Set ALLOW_LEGACY_AUTH environment variable\n *   - Production default: false (disabled)\n *   - Development default: true (enabled for backward compatibility)\n * - Clients using legacy auth will receive X-Deprecation-Warning headers\n * - After sunset date, legacy auth will be completely removed\n *\n * Migration Guide:\n * 1. Call POST /auth/login with license key to obtain JWT tokens\n * 2. Use Authorization: Bearer <token> header for all authenticated requests\n * 3. Use POST /auth/refresh to refresh expired tokens\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Supports both:\n * - Authorization: Bearer <token> (preferred)\n * - x-stripe-customer-id header (legacy, will be deprecated)\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // ==========================================================================\n  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n  // This authentication method is deprecated and will be removed after\n  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n  // ==========================================================================\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Check if legacy auth is allowed\n    if (!ALLOW_LEGACY_AUTH) {\n      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      return res.status(401).json({\n        error: 'Legacy authentication disabled',\n        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n      });\n    }\n\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    // Set deprecation warning header on the response\n    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n *\n * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      // Only accept legacy auth if allowed\n      if (ALLOW_LEGACY_AUTH) {\n        // Log deprecation warning\n        if (!req._legacyAuthWarned) {\n          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n          req._legacyAuthWarned = true;\n        }\n\n        // Set deprecation warning headers\n        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n        req.stripeCustomerId = legacyCustomerId;\n        req.isLegacyAuth = true;\n      }\n      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN,\n  // Legacy auth deprecation constants\n  LEGACY_AUTH_SUNSET_DATE,\n  ALLOW_LEGACY_AUTH\n};\n","structuredPatch":[{"oldStart":411,"oldLines":9,"newStart":411,"newLines":20,"lines":["  * Middleware to authenticate JWT tokens","  * Sets req.stripeCustomerId if valid token found","  *","- * Supports both:","- * - Authorization: Bearer <token> (preferred)","- * - x-stripe-customer-id header (legacy, will be deprecated)","+ * Authentication Methods:","+ * - Authorization: Bearer <token> (PREFERRED - use this method)","+ * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)","+ *","+ * DEPRECATION: x-stripe-customer-id header","+ * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var","+ * - Production: Disabled by default (returns 401)","+ * - Development: Enabled by default for backward compatibility","+ * - Sunset Date: 2026-04-11 (after which it will be removed entirely)","+ * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers","+ *","+ * @param {Object} req - Express request object","+ * @param {Object} res - Express response object","+ * @param {Function} next - Express next function","  */"," async function authenticateToken(req, res, next) {","   // First, try JWT token from Authorization header"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"d67e46e0-1b89-4ccb-934a-39a25a513c0d","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_016p13xHhswkh6LHHAexPo3q","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me verify the changes by reading the full file to ensure everything is correct:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":971,"cache_read_input_tokens":48745,"cache_creation":{"ephemeral_5m_input_tokens":971,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2V8qfXDK8n64qFV8B2h","type":"assistant","uuid":"c587a35d-42e1-44b4-96a4-7538a767b5b3","timestamp":"2026-01-11T23:49:20.859Z"}
{"parentUuid":"c587a35d-42e1-44b4-96a4-7538a767b5b3","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_016p13xHhswkh6LHHAexPo3q","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018eVXK6rYB8zFiMLFFN4A1d","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":971,"cache_read_input_tokens":48745,"cache_creation":{"ephemeral_5m_input_tokens":971,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2V8qfXDK8n64qFV8B2h","type":"assistant","uuid":"86011bbe-7d81-4b56-8940-9ce1cfb624d9","timestamp":"2026-01-11T23:49:21.368Z"}
{"parentUuid":"86011bbe-7d81-4b56-8940-9ce1cfb624d9","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018eVXK6rYB8zFiMLFFN4A1d","type":"tool_result","content":"     1→/**\n     2→ * JWT Authentication Middleware\n     3→ *\n     4→ * Primary authentication method: JWT Bearer tokens\n     5→ * Tokens are signed with a secret and contain the customer ID.\n     6→ *\n     7→ * Token Blacklist:\n     8→ * - Primary: Upstash Redis with automatic TTL-based expiry\n     9→ * - Fallback: In-memory Map (for development or Redis failures)\n    10→ *\n    11→ * DEPRECATION NOTICE:\n    12→ * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n    13→ * - Sunset Date: 2026-04-11\n    14→ * - Control: Set ALLOW_LEGACY_AUTH environment variable\n    15→ *   - Production default: false (disabled)\n    16→ *   - Development default: true (enabled for backward compatibility)\n    17→ * - Clients using legacy auth will receive X-Deprecation-Warning headers\n    18→ * - After sunset date, legacy auth will be completely removed\n    19→ *\n    20→ * Migration Guide:\n    21→ * 1. Call POST /auth/login with license key to obtain JWT tokens\n    22→ * 2. Use Authorization: Bearer <token> header for all authenticated requests\n    23→ * 3. Use POST /auth/refresh to refresh expired tokens\n    24→ */\n    25→\n    26→const jwt = require('jsonwebtoken');\n    27→const crypto = require('crypto');\n    28→const authLogger = require('../utils/authLogger');\n    29→const redis = require('../services/redisClient');\n    30→\n    31→// HIGH-007: Database pool for admin RBAC\n    32→let pool = null;\n    33→try {\n    34→  const { Pool } = require('pg');\n    35→  pool = new Pool({\n    36→    connectionString: process.env.DATABASE_URL,\n    37→    ssl: process.env.NODE_ENV === 'production'\n    38→      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n    39→      : false,\n    40→    max: 3, // Small pool just for auth checks\n    41→    idleTimeoutMillis: 30000,\n    42→  });\n    43→} catch (err) {\n    44→  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n    45→}\n    46→\n    47→// JWT configuration\n    48→const JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\n    49→const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\n    50→const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n    51→\n    52→// Redis key prefix for blacklisted tokens\n    53→const BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n    54→\n    55→// Check if running in production\n    56→const isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n    57→\n    58→// =============================================================================\n    59→// Legacy Authentication Deprecation Configuration\n    60→// =============================================================================\n    61→// The x-stripe-customer-id header is deprecated and will be removed.\n    62→// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n    63→\n    64→/**\n    65→ * Legacy auth sunset date (90 days from 2026-01-11)\n    66→ * After this date, legacy auth will be completely removed\n    67→ */\n    68→const LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n    69→\n    70→/**\n    71→ * Whether to allow legacy x-stripe-customer-id header authentication\n    72→ * Defaults to false in production, true in development for backward compatibility\n    73→ */\n    74→const ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n    75→  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n    76→\n    77→// Log legacy auth configuration on startup\n    78→if (isProduction) {\n    79→  if (ALLOW_LEGACY_AUTH) {\n    80→    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    81→    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    82→    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n    83→  } else {\n    84→    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n    85→  }\n    86→} else {\n    87→  if (ALLOW_LEGACY_AUTH) {\n    88→    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    89→  } else {\n    90→    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n    91→  }\n    92→}\n    93→\n    94→// HIGH-001: Validate JWT_SECRET security requirements\n    95→if (isProduction) {\n    96→  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    97→    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    98→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    99→    process.exit(1);\n   100→  }\n   101→  \n   102→  if (JWT_SECRET.length < 32) {\n   103→    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n   104→    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n   105→    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n   106→    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n   107→    process.exit(1);\n   108→  }\n   109→}\n   110→\n   111→/**\n   112→ * Fallback Token Blacklist (In-Memory)\n   113→ * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n   114→ */\n   115→const fallbackBlacklist = new Map();\n   116→\n   117→// Track if we're using fallback mode\n   118→let usingFallback = false;\n   119→\n   120→// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\n   121→const BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n   122→\n   123→/**\n   124→ * Clean up expired entries from the fallback blacklist\n   125→ * Only runs when using in-memory fallback\n   126→ */\n   127→function cleanupFallbackBlacklist() {\n   128→  if (!usingFallback || fallbackBlacklist.size === 0) {\n   129→    return;\n   130→  }\n   131→\n   132→  const now = Math.floor(Date.now() / 1000);\n   133→  let cleanedCount = 0;\n   134→\n   135→  for (const [jti, exp] of fallbackBlacklist.entries()) {\n   136→    if (exp <= now) {\n   137→      fallbackBlacklist.delete(jti);\n   138→      cleanedCount++;\n   139→    }\n   140→  }\n   141→\n   142→  if (cleanedCount > 0) {\n   143→    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n   144→  }\n   145→}\n   146→\n   147→// Start periodic cleanup for fallback (unref to allow process exit)\n   148→const cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\n   149→if (cleanupTimer.unref) {\n   150→  cleanupTimer.unref();\n   151→}\n   152→\n   153→/**\n   154→ * Add a token to the blacklist\n   155→ * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n   156→ * @param {string} jti - JWT ID claim\n   157→ * @param {number} exp - Token expiration timestamp (Unix seconds)\n   158→ * @param {Object} options - Additional options for logging\n   159→ * @param {string} options.userId - User ID for logging\n   160→ * @param {string} options.reason - Reason for revocation (logout, security, admin)\n   161→ * @returns {Promise<boolean>} True if successfully blacklisted\n   162→ */\n   163→async function blacklistToken(jti, exp, options = {}) {\n   164→  if (!jti) {\n   165→    console.warn('[Auth] Cannot blacklist token without jti');\n   166→    return false;\n   167→  }\n   168→\n   169→  const now = Math.floor(Date.now() / 1000);\n   170→  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n   171→\n   172→  // Try Redis first\n   173→  if (redis.isRedisAvailable()) {\n   174→    try {\n   175→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   176→      const success = await redis.set(key, exp, ttlSeconds);\n   177→\n   178→      if (success) {\n   179→        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n   180→        usingFallback = false;\n   181→        // Log token revocation with structured logging\n   182→        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   183→        return true;\n   184→      }\n   185→    } catch (err) {\n   186→      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n   187→    }\n   188→  }\n   189→\n   190→  // Fallback to in-memory\n   191→  usingFallback = true;\n   192→  fallbackBlacklist.set(jti, exp);\n   193→  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n   194→\n   195→  // Log token revocation with structured logging\n   196→  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n   197→  return true;\n   198→}\n   199→\n   200→/**\n   201→ * Check if a token is blacklisted\n   202→ * Checks Redis first, then fallback in-memory store\n   203→ * @param {string} jti - JWT ID claim\n   204→ * @returns {Promise<boolean>} True if token is blacklisted\n   205→ */\n   206→async function isTokenBlacklisted(jti) {\n   207→  if (!jti) {\n   208→    return false;\n   209→  }\n   210→\n   211→  // Try Redis first\n   212→  if (redis.isRedisAvailable()) {\n   213→    try {\n   214→      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n   215→      const exists = await redis.exists(key);\n   216→\n   217→      if (exists) {\n   218→        return true;\n   219→      }\n   220→\n   221→      // Also check fallback in case token was blacklisted during Redis downtime\n   222→      // and Redis is now back up\n   223→      if (fallbackBlacklist.has(jti)) {\n   224→        // Migrate to Redis if token still valid\n   225→        const exp = fallbackBlacklist.get(jti);\n   226→        const now = Math.floor(Date.now() / 1000);\n   227→        if (exp > now) {\n   228→          const ttlSeconds = exp - now;\n   229→          await redis.set(key, exp, ttlSeconds);\n   230→          fallbackBlacklist.delete(jti);\n   231→          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n   232→        } else {\n   233→          // Expired, remove from fallback\n   234→          fallbackBlacklist.delete(jti);\n   235→        }\n   236→        return true;\n   237→      }\n   238→\n   239→      return false;\n   240→    } catch (err) {\n   241→      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n   242→    }\n   243→  }\n   244→\n   245→  // Fallback to in-memory check\n   246→  if (fallbackBlacklist.has(jti)) {\n   247→    const exp = fallbackBlacklist.get(jti);\n   248→    const now = Math.floor(Date.now() / 1000);\n   249→    if (exp > now) {\n   250→      return true;\n   251→    }\n   252→    // Expired, remove it\n   253→    fallbackBlacklist.delete(jti);\n   254→  }\n   255→\n   256→  return false;\n   257→}\n   258→\n   259→/**\n   260→ * Get blacklist statistics (for monitoring)\n   261→ * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n   262→ */\n   263→async function getBlacklistStats() {\n   264→  const redisAvailable = redis.isRedisAvailable();\n   265→  const redisStatus = redis.getRedisStatus();\n   266→\n   267→  return {\n   268→    storage: redisAvailable ? 'redis' : 'memory',\n   269→    redisConnected: redisStatus.connected,\n   270→    redisError: redisStatus.error,\n   271→    fallbackSize: fallbackBlacklist.size,\n   272→    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n   273→    usingFallback\n   274→  };\n   275→}\n   276→\n   277→/**\n   278→ * Generate a JWT token for a customer\n   279→ * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n   280→ * @param {Object} options - Additional options\n   281→ * @param {string} options.tier - User's subscription tier\n   282→ * @param {string} options.email - User's email (optional)\n   283→ * @returns {Object} { token, expiresIn }\n   284→ */\n   285→function generateToken(stripeCustomerId, options = {}) {\n   286→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   287→    throw new Error('Invalid Stripe customer ID');\n   288→  }\n   289→\n   290→  const payload = {\n   291→    sub: stripeCustomerId,\n   292→    type: 'access',\n   293→    tier: options.tier || 'starter',\n   294→    iat: Math.floor(Date.now() / 1000),\n   295→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   296→  };\n   297→\n   298→  if (options.email) {\n   299→    payload.email = options.email;\n   300→  }\n   301→\n   302→  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n   303→\n   304→  return {\n   305→    token,\n   306→    expiresIn: JWT_EXPIRES_IN,\n   307→    tokenType: 'Bearer'\n   308→  };\n   309→}\n   310→\n   311→/**\n   312→ * Generate a refresh token for a customer\n   313→ * @param {string} stripeCustomerId - Stripe customer ID\n   314→ * @returns {Object} { refreshToken, expiresIn }\n   315→ */\n   316→function generateRefreshToken(stripeCustomerId) {\n   317→  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n   318→    throw new Error('Invalid Stripe customer ID');\n   319→  }\n   320→\n   321→  const payload = {\n   322→    sub: stripeCustomerId,\n   323→    type: 'refresh',\n   324→    iat: Math.floor(Date.now() / 1000),\n   325→    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n   326→  };\n   327→\n   328→  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n   329→\n   330→  return {\n   331→    refreshToken,\n   332→    expiresIn: JWT_REFRESH_EXPIRES_IN\n   333→  };\n   334→}\n   335→\n   336→/**\n   337→ * Verify and decode a JWT token (async version)\n   338→ * Checks both JWT signature validity and token blacklist status via Redis\n   339→ * @param {string} token - JWT token to verify\n   340→ * @param {Object} options - Verification options\n   341→ * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n   342→ * @param {Object} options.req - Express request object for logging (optional)\n   343→ * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n   344→ */\n   345→async function verifyToken(token, options = {}) {\n   346→  const { checkBlacklist = true, req = null } = options;\n   347→\n   348→  try {\n   349→    const decoded = jwt.verify(token, JWT_SECRET);\n   350→\n   351→    // Check if token has been revoked (blacklisted) - async Redis check\n   352→    if (checkBlacklist && decoded.jti) {\n   353→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   354→      if (isBlacklisted) {\n   355→        if (req) {\n   356→          authLogger.logTokenBlacklisted(req, decoded.jti);\n   357→        }\n   358→        return null;\n   359→      }\n   360→    }\n   361→\n   362→    return decoded;\n   363→  } catch (err) {\n   364→    // Log specific error types for debugging\n   365→    if (err.name === 'TokenExpiredError') {\n   366→      if (req) {\n   367→        authLogger.logTokenExpired(req);\n   368→      }\n   369→    } else if (err.name === 'JsonWebTokenError') {\n   370→      if (req) {\n   371→        authLogger.logTokenInvalid(req, err.message);\n   372→      }\n   373→    }\n   374→    return null;\n   375→  }\n   376→}\n   377→\n   378→/**\n   379→ * Synchronous token verification (for cases where async is not possible)\n   380→ * Does NOT check blacklist - use verifyToken() for full verification\n   381→ * @param {string} token - JWT token to verify\n   382→ * @returns {Object|null} Decoded payload or null if invalid\n   383→ */\n   384→function verifyTokenSync(token) {\n   385→  try {\n   386→    return jwt.verify(token, JWT_SECRET);\n   387→  } catch {\n   388→    return null;\n   389→  }\n   390→}\n   391→\n   392→/**\n   393→ * Extract Bearer token from Authorization header\n   394→ * @param {string} authHeader - Authorization header value\n   395→ * @returns {string|null} Token or null if not found\n   396→ */\n   397→function extractBearerToken(authHeader) {\n   398→  if (!authHeader || typeof authHeader !== 'string') {\n   399→    return null;\n   400→  }\n   401→\n   402→  const parts = authHeader.split(' ');\n   403→  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n   404→    return null;\n   405→  }\n   406→\n   407→  return parts[1];\n   408→}\n   409→\n   410→/**\n   411→ * Middleware to authenticate JWT tokens\n   412→ * Sets req.stripeCustomerId if valid token found\n   413→ *\n   414→ * Authentication Methods:\n   415→ * - Authorization: Bearer <token> (PREFERRED - use this method)\n   416→ * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)\n   417→ *\n   418→ * DEPRECATION: x-stripe-customer-id header\n   419→ * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var\n   420→ * - Production: Disabled by default (returns 401)\n   421→ * - Development: Enabled by default for backward compatibility\n   422→ * - Sunset Date: 2026-04-11 (after which it will be removed entirely)\n   423→ * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers\n   424→ *\n   425→ * @param {Object} req - Express request object\n   426→ * @param {Object} res - Express response object\n   427→ * @param {Function} next - Express next function\n   428→ */\n   429→async function authenticateToken(req, res, next) {\n   430→  // First, try JWT token from Authorization header\n   431→  const authHeader = req.headers['authorization'];\n   432→  const token = extractBearerToken(authHeader);\n   433→\n   434→  if (token) {\n   435→    // First verify JWT signature without blacklist check to get specific error messages\n   436→    const decoded = verifyTokenSync(token);\n   437→\n   438→    if (!decoded || !decoded.sub) {\n   439→      // Token is invalid or expired (signature failed)\n   440→      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n   441→      return res.status(401).json({\n   442→        error: 'Invalid or expired token',\n   443→        message: 'Please log in again to continue'\n   444→      });\n   445→    }\n   446→\n   447→    // Check if token has been revoked (blacklisted) - async Redis check\n   448→    if (decoded.jti) {\n   449→      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n   450→      if (isBlacklisted) {\n   451→        authLogger.logTokenBlacklisted(req, decoded.jti);\n   452→        return res.status(401).json({\n   453→          error: 'Token has been revoked',\n   454→          message: 'This session has been logged out. Please log in again.'\n   455→        });\n   456→      }\n   457→    }\n   458→\n   459→    // Token is valid and not revoked\n   460→    req.stripeCustomerId = decoded.sub;\n   461→    req.tokenData = decoded;\n   462→    req.rawToken = token; // Store raw token for logout\n   463→    return next();\n   464→  }\n   465→\n   466→  // ==========================================================================\n   467→  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n   468→  // This authentication method is deprecated and will be removed after\n   469→  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n   470→  // ==========================================================================\n   471→  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   472→  if (legacyCustomerId) {\n   473→    // Check if legacy auth is allowed\n   474→    if (!ALLOW_LEGACY_AUTH) {\n   475→      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n   476→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   477→      return res.status(401).json({\n   478→        error: 'Legacy authentication disabled',\n   479→        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n   480→        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n   481→      });\n   482→    }\n   483→\n   484→    // Log deprecation warning with structured logging (once per request)\n   485→    if (!req._legacyAuthWarned) {\n   486→      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   487→      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n   488→      req._legacyAuthWarned = true;\n   489→    }\n   490→\n   491→    // Validate format\n   492→    if (!legacyCustomerId.startsWith('cus_')) {\n   493→      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n   494→      return res.status(401).json({\n   495→        error: 'Invalid customer ID format',\n   496→        message: 'Customer ID must start with cus_'\n   497→      });\n   498→    }\n   499→\n   500→    // Set deprecation warning header on the response\n   501→    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n   502→    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n   503→\n   504→    req.stripeCustomerId = legacyCustomerId;\n   505→    req.isLegacyAuth = true;\n   506→    return next();\n   507→  }\n   508→\n   509→  // No authentication provided\n   510→  return res.status(401).json({\n   511→    error: 'Authentication required',\n   512→    message: 'Please provide a valid Bearer token in the Authorization header'\n   513→  });\n   514→}\n   515→\n   516→/**\n   517→ * Optional authentication middleware\n   518→ * Allows unauthenticated access but sets req.stripeCustomerId if token present\n   519→ *\n   520→ * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n   521→ */\n   522→async function optionalAuthentication(req, res, next) {\n   523→  const authHeader = req.headers['authorization'];\n   524→  const token = extractBearerToken(authHeader);\n   525→\n   526→  if (token) {\n   527→    const decoded = await verifyToken(token);\n   528→    if (decoded && decoded.sub) {\n   529→      req.stripeCustomerId = decoded.sub;\n   530→      req.tokenData = decoded;\n   531→    }\n   532→  } else {\n   533→    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n   534→    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n   535→    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n   536→      // Only accept legacy auth if allowed\n   537→      if (ALLOW_LEGACY_AUTH) {\n   538→        // Log deprecation warning\n   539→        if (!req._legacyAuthWarned) {\n   540→          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n   541→          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n   542→          req._legacyAuthWarned = true;\n   543→        }\n   544→\n   545→        // Set deprecation warning headers\n   546→        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n   547→        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n   548→\n   549→        req.stripeCustomerId = legacyCustomerId;\n   550→        req.isLegacyAuth = true;\n   551→      }\n   552→      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n   553→    }\n   554→  }\n   555→\n   556→  next();\n   557→}\n   558→\n   559→/**\n   560→ * HIGH-007: Database-backed admin role check middleware\n   561→ * Checks the user's role in the database instead of relying on env vars\n   562→ * Requires authenticateToken middleware to run first\n   563→ *\n   564→ * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n   565→ * @param {Object} res - Express response object\n   566→ * @param {Function} next - Express next function\n   567→ */\n   568→async function requireAdmin(req, res, next) {\n   569→  // Must be authenticated first\n   570→  if (!req.stripeCustomerId) {\n   571→    return res.status(401).json({\n   572→      error: 'Authentication required',\n   573→      message: 'Please log in to access this resource'\n   574→    });\n   575→  }\n   576→\n   577→  // Check if database pool is available\n   578→  if (!pool) {\n   579→    console.error('[Auth] Admin check failed: Database pool not available');\n   580→    return res.status(503).json({\n   581→      error: 'Service unavailable',\n   582→      message: 'Admin verification temporarily unavailable'\n   583→    });\n   584→  }\n   585→\n   586→  try {\n   587→    // Query database for user role\n   588→    const result = await pool.query(\n   589→      'SELECT role FROM users WHERE stripe_customer_id = $1',\n   590→      [req.stripeCustomerId]\n   591→    );\n   592→\n   593→    if (!result.rows[0]) {\n   594→      authLogger.logAdminAccessDenied(req, 'User not found in database');\n   595→      return res.status(403).json({\n   596→        error: 'Access denied',\n   597→        message: 'User account not found'\n   598→      });\n   599→    }\n   600→\n   601→    const userRole = result.rows[0].role;\n   602→\n   603→    if (userRole !== 'admin') {\n   604→      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n   605→      return res.status(403).json({\n   606→        error: 'Admin access required',\n   607→        message: 'This action requires administrator privileges'\n   608→      });\n   609→    }\n   610→\n   611→    // User is admin - log and proceed\n   612→    authLogger.logAdminAccess(req);\n   613→    req.isAdmin = true;\n   614→    next();\n   615→  } catch (err) {\n   616→    console.error('[Auth] Admin role check failed:', err.message);\n   617→    return res.status(500).json({\n   618→      error: 'Authorization check failed',\n   619→      message: 'Unable to verify admin privileges'\n   620→    });\n   621→  }\n   622→}\n   623→\n   624→/**\n   625→ * Mask sensitive data for logging\n   626→ * @param {string} key - License key or other sensitive string\n   627→ * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n   628→ */\n   629→function maskSensitiveData(data) {\n   630→  if (!data || typeof data !== 'string') {\n   631→    return '****';\n   632→  }\n   633→\n   634→  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n   635→  if (data.startsWith('SPLICE-')) {\n   636→    const parts = data.split('-');\n   637→    if (parts.length === 5) {\n   638→      return `${parts[0]}-${parts[1]}-****-****-****`;\n   639→    }\n   640→  }\n   641→\n   642→  // For customer IDs (cus_xxxx format)\n   643→  if (data.startsWith('cus_')) {\n   644→    if (data.length > 10) {\n   645→      return `cus_${data.slice(4, 8)}****`;\n   646→    }\n   647→    return 'cus_****';\n   648→  }\n   649→\n   650→  // For JWTs (eyJ... format)\n   651→  if (data.startsWith('eyJ')) {\n   652→    return `${data.slice(0, 10)}...****`;\n   653→  }\n   654→\n   655→  // For emails\n   656→  if (data.includes('@')) {\n   657→    const [local, domain] = data.split('@');\n   658→    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n   659→    return `${maskedLocal}@${domain}`;\n   660→  }\n   661→\n   662→  // Generic masking - show first 4 chars\n   663→  if (data.length > 8) {\n   664→    return `${data.slice(0, 4)}****`;\n   665→  }\n   666→\n   667→  return '****';\n   668→}\n   669→\n   670→module.exports = {\n   671→  generateToken,\n   672→  generateRefreshToken,\n   673→  verifyToken,\n   674→  verifyTokenSync,\n   675→  extractBearerToken,\n   676→  authenticateToken,\n   677→  optionalAuthentication,\n   678→  maskSensitiveData,\n   679→  // HIGH-007: Admin RBAC middleware\n   680→  requireAdmin,\n   681→  // Token blacklist functions\n   682→  blacklistToken,\n   683→  isTokenBlacklisted,\n   684→  getBlacklistStats,\n   685→  // Structured logging\n   686→  authLogger,\n   687→  // Constants\n   688→  JWT_SECRET,\n   689→  JWT_EXPIRES_IN,\n   690→  // Legacy auth deprecation constants\n   691→  LEGACY_AUTH_SUNSET_DATE,\n   692→  ALLOW_LEGACY_AUTH\n   693→};\n   694→\n\n</system-reminder>\n"}]},"uuid":"88cb2410-89ed-4c25-9b24-aca9009120f4","timestamp":"2026-01-11T23:49:21.405Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-backend/middleware/auth.js","content":"/**\n * JWT Authentication Middleware\n *\n * Primary authentication method: JWT Bearer tokens\n * Tokens are signed with a secret and contain the customer ID.\n *\n * Token Blacklist:\n * - Primary: Upstash Redis with automatic TTL-based expiry\n * - Fallback: In-memory Map (for development or Redis failures)\n *\n * DEPRECATION NOTICE:\n * The legacy x-stripe-customer-id header authentication is DEPRECATED.\n * - Sunset Date: 2026-04-11\n * - Control: Set ALLOW_LEGACY_AUTH environment variable\n *   - Production default: false (disabled)\n *   - Development default: true (enabled for backward compatibility)\n * - Clients using legacy auth will receive X-Deprecation-Warning headers\n * - After sunset date, legacy auth will be completely removed\n *\n * Migration Guide:\n * 1. Call POST /auth/login with license key to obtain JWT tokens\n * 2. Use Authorization: Bearer <token> header for all authenticated requests\n * 3. Use POST /auth/refresh to refresh expired tokens\n */\n\nconst jwt = require('jsonwebtoken');\nconst crypto = require('crypto');\nconst authLogger = require('../utils/authLogger');\nconst redis = require('../services/redisClient');\n\n// HIGH-007: Database pool for admin RBAC\nlet pool = null;\ntry {\n  const { Pool } = require('pg');\n  pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: process.env.NODE_ENV === 'production'\n      ? { rejectUnauthorized: process.env.DATABASE_SSL_REJECT_UNAUTHORIZED !== 'false' }\n      : false,\n    max: 3, // Small pool just for auth checks\n    idleTimeoutMillis: 30000,\n  });\n} catch (err) {\n  console.warn('[Auth] PostgreSQL pool not available for admin RBAC:', err.message);\n}\n\n// JWT configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'splice-dev-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\n// Redis key prefix for blacklisted tokens\nconst BLACKLIST_KEY_PREFIX = 'token:blacklist:';\n\n// Check if running in production\nconst isProduction = process.env.NODE_ENV === 'production' || process.env.RAILWAY_ENVIRONMENT;\n\n// =============================================================================\n// Legacy Authentication Deprecation Configuration\n// =============================================================================\n// The x-stripe-customer-id header is deprecated and will be removed.\n// Set ALLOW_LEGACY_AUTH=true to temporarily enable legacy auth (NOT recommended in production)\n\n/**\n * Legacy auth sunset date (90 days from 2026-01-11)\n * After this date, legacy auth will be completely removed\n */\nconst LEGACY_AUTH_SUNSET_DATE = '2026-04-11';\n\n/**\n * Whether to allow legacy x-stripe-customer-id header authentication\n * Defaults to false in production, true in development for backward compatibility\n */\nconst ALLOW_LEGACY_AUTH = process.env.ALLOW_LEGACY_AUTH === 'true' ||\n  (!isProduction && process.env.ALLOW_LEGACY_AUTH !== 'false');\n\n// Log legacy auth configuration on startup\nif (isProduction) {\n  if (ALLOW_LEGACY_AUTH) {\n    console.warn('[Auth] WARNING: Legacy x-stripe-customer-id authentication is ENABLED in production.');\n    console.warn(`[Auth] This header is DEPRECATED and will be removed after ${LEGACY_AUTH_SUNSET_DATE}.`);\n    console.warn('[Auth] Set ALLOW_LEGACY_AUTH=false to disable legacy auth.');\n  } else {\n    console.log('[Auth] Legacy x-stripe-customer-id authentication is DISABLED (recommended for production).');\n  }\n} else {\n  if (ALLOW_LEGACY_AUTH) {\n    console.log(`[Auth] Legacy auth enabled in development. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n  } else {\n    console.log('[Auth] Legacy auth disabled in development (ALLOW_LEGACY_AUTH=false).');\n  }\n}\n\n// HIGH-001: Validate JWT_SECRET security requirements\nif (isProduction) {\n  if (JWT_SECRET === 'splice-dev-secret-change-in-production') {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET not set in production! Set JWT_SECRET environment variable.');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n  \n  if (JWT_SECRET.length < 32) {\n    console.error('[SECURITY] CRITICAL: JWT_SECRET must be at least 32 characters for cryptographic security.');\n    console.error('[SECURITY] Current length:', JWT_SECRET.length, 'characters');\n    console.error('[SECURITY] Generate a secure secret: openssl rand -base64 48');\n    console.error('[SECURITY] Exiting process to prevent insecure operation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Fallback Token Blacklist (In-Memory)\n * Used when Redis is unavailable. Maps jti -> expiration timestamp.\n */\nconst fallbackBlacklist = new Map();\n\n// Track if we're using fallback mode\nlet usingFallback = false;\n\n// Cleanup interval for expired fallback blacklist entries (every 15 minutes)\nconst BLACKLIST_CLEANUP_INTERVAL = 15 * 60 * 1000;\n\n/**\n * Clean up expired entries from the fallback blacklist\n * Only runs when using in-memory fallback\n */\nfunction cleanupFallbackBlacklist() {\n  if (!usingFallback || fallbackBlacklist.size === 0) {\n    return;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  let cleanedCount = 0;\n\n  for (const [jti, exp] of fallbackBlacklist.entries()) {\n    if (exp <= now) {\n      fallbackBlacklist.delete(jti);\n      cleanedCount++;\n    }\n  }\n\n  if (cleanedCount > 0) {\n    authLogger.logBlacklistCleanup(cleanedCount, fallbackBlacklist.size);\n  }\n}\n\n// Start periodic cleanup for fallback (unref to allow process exit)\nconst cleanupTimer = setInterval(cleanupFallbackBlacklist, BLACKLIST_CLEANUP_INTERVAL);\nif (cleanupTimer.unref) {\n  cleanupTimer.unref();\n}\n\n/**\n * Add a token to the blacklist\n * Uses Redis with automatic TTL, falls back to in-memory if Redis unavailable\n * @param {string} jti - JWT ID claim\n * @param {number} exp - Token expiration timestamp (Unix seconds)\n * @param {Object} options - Additional options for logging\n * @param {string} options.userId - User ID for logging\n * @param {string} options.reason - Reason for revocation (logout, security, admin)\n * @returns {Promise<boolean>} True if successfully blacklisted\n */\nasync function blacklistToken(jti, exp, options = {}) {\n  if (!jti) {\n    console.warn('[Auth] Cannot blacklist token without jti');\n    return false;\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const ttlSeconds = Math.max(exp - now, 1); // At least 1 second TTL\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const success = await redis.set(key, exp, ttlSeconds);\n\n      if (success) {\n        console.log(`[Auth] Token blacklisted in Redis: ${jti.slice(0, 8)}..., TTL: ${ttlSeconds}s`);\n        usingFallback = false;\n        // Log token revocation with structured logging\n        authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n        return true;\n      }\n    } catch (err) {\n      console.error('[Auth] Redis blacklist failed, using fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory\n  usingFallback = true;\n  fallbackBlacklist.set(jti, exp);\n  console.log(`[Auth] Token blacklisted in memory (fallback): ${jti.slice(0, 8)}..., expires at ${new Date(exp * 1000).toISOString()}`);\n\n  // Log token revocation with structured logging\n  authLogger.logTokenRevoked(options.userId || 'unknown', jti, options.reason || 'logout');\n  return true;\n}\n\n/**\n * Check if a token is blacklisted\n * Checks Redis first, then fallback in-memory store\n * @param {string} jti - JWT ID claim\n * @returns {Promise<boolean>} True if token is blacklisted\n */\nasync function isTokenBlacklisted(jti) {\n  if (!jti) {\n    return false;\n  }\n\n  // Try Redis first\n  if (redis.isRedisAvailable()) {\n    try {\n      const key = `${BLACKLIST_KEY_PREFIX}${jti}`;\n      const exists = await redis.exists(key);\n\n      if (exists) {\n        return true;\n      }\n\n      // Also check fallback in case token was blacklisted during Redis downtime\n      // and Redis is now back up\n      if (fallbackBlacklist.has(jti)) {\n        // Migrate to Redis if token still valid\n        const exp = fallbackBlacklist.get(jti);\n        const now = Math.floor(Date.now() / 1000);\n        if (exp > now) {\n          const ttlSeconds = exp - now;\n          await redis.set(key, exp, ttlSeconds);\n          fallbackBlacklist.delete(jti);\n          console.log(`[Auth] Migrated blacklist entry to Redis: ${jti.slice(0, 8)}...`);\n        } else {\n          // Expired, remove from fallback\n          fallbackBlacklist.delete(jti);\n        }\n        return true;\n      }\n\n      return false;\n    } catch (err) {\n      console.error('[Auth] Redis blacklist check failed, checking fallback:', err.message);\n    }\n  }\n\n  // Fallback to in-memory check\n  if (fallbackBlacklist.has(jti)) {\n    const exp = fallbackBlacklist.get(jti);\n    const now = Math.floor(Date.now() / 1000);\n    if (exp > now) {\n      return true;\n    }\n    // Expired, remove it\n    fallbackBlacklist.delete(jti);\n  }\n\n  return false;\n}\n\n/**\n * Get blacklist statistics (for monitoring)\n * @returns {Promise<Object>} { storage, redisConnected, fallbackSize, fallbackEntries, usingFallback }\n */\nasync function getBlacklistStats() {\n  const redisAvailable = redis.isRedisAvailable();\n  const redisStatus = redis.getRedisStatus();\n\n  return {\n    storage: redisAvailable ? 'redis' : 'memory',\n    redisConnected: redisStatus.connected,\n    redisError: redisStatus.error,\n    fallbackSize: fallbackBlacklist.size,\n    fallbackEntries: Array.from(fallbackBlacklist.entries()).slice(0, 10), // First 10 for debugging\n    usingFallback\n  };\n}\n\n/**\n * Generate a JWT token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID (cus_xxx)\n * @param {Object} options - Additional options\n * @param {string} options.tier - User's subscription tier\n * @param {string} options.email - User's email (optional)\n * @returns {Object} { token, expiresIn }\n */\nfunction generateToken(stripeCustomerId, options = {}) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'access',\n    tier: options.tier || 'starter',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  if (options.email) {\n    payload.email = options.email;\n  }\n\n  const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\n\n  return {\n    token,\n    expiresIn: JWT_EXPIRES_IN,\n    tokenType: 'Bearer'\n  };\n}\n\n/**\n * Generate a refresh token for a customer\n * @param {string} stripeCustomerId - Stripe customer ID\n * @returns {Object} { refreshToken, expiresIn }\n */\nfunction generateRefreshToken(stripeCustomerId) {\n  if (!stripeCustomerId || !stripeCustomerId.startsWith('cus_')) {\n    throw new Error('Invalid Stripe customer ID');\n  }\n\n  const payload = {\n    sub: stripeCustomerId,\n    type: 'refresh',\n    iat: Math.floor(Date.now() / 1000),\n    jti: crypto.randomUUID() // Unique token identifier for blacklisting\n  };\n\n  const refreshToken = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });\n\n  return {\n    refreshToken,\n    expiresIn: JWT_REFRESH_EXPIRES_IN\n  };\n}\n\n/**\n * Verify and decode a JWT token (async version)\n * Checks both JWT signature validity and token blacklist status via Redis\n * @param {string} token - JWT token to verify\n * @param {Object} options - Verification options\n * @param {boolean} options.checkBlacklist - Whether to check token blacklist (default: true)\n * @param {Object} options.req - Express request object for logging (optional)\n * @returns {Promise<Object|null>} Decoded payload or null if invalid/revoked\n */\nasync function verifyToken(token, options = {}) {\n  const { checkBlacklist = true, req = null } = options;\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (checkBlacklist && decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        if (req) {\n          authLogger.logTokenBlacklisted(req, decoded.jti);\n        }\n        return null;\n      }\n    }\n\n    return decoded;\n  } catch (err) {\n    // Log specific error types for debugging\n    if (err.name === 'TokenExpiredError') {\n      if (req) {\n        authLogger.logTokenExpired(req);\n      }\n    } else if (err.name === 'JsonWebTokenError') {\n      if (req) {\n        authLogger.logTokenInvalid(req, err.message);\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * Synchronous token verification (for cases where async is not possible)\n * Does NOT check blacklist - use verifyToken() for full verification\n * @param {string} token - JWT token to verify\n * @returns {Object|null} Decoded payload or null if invalid\n */\nfunction verifyTokenSync(token) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract Bearer token from Authorization header\n * @param {string} authHeader - Authorization header value\n * @returns {string|null} Token or null if not found\n */\nfunction extractBearerToken(authHeader) {\n  if (!authHeader || typeof authHeader !== 'string') {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {\n    return null;\n  }\n\n  return parts[1];\n}\n\n/**\n * Middleware to authenticate JWT tokens\n * Sets req.stripeCustomerId if valid token found\n *\n * Authentication Methods:\n * - Authorization: Bearer <token> (PREFERRED - use this method)\n * - x-stripe-customer-id header (DEPRECATED - see deprecation notice below)\n *\n * DEPRECATION: x-stripe-customer-id header\n * - This method is deprecated and controlled by ALLOW_LEGACY_AUTH env var\n * - Production: Disabled by default (returns 401)\n * - Development: Enabled by default for backward compatibility\n * - Sunset Date: 2026-04-11 (after which it will be removed entirely)\n * - When enabled, responses include X-Deprecation-Warning and X-Deprecation-Sunset headers\n *\n * @param {Object} req - Express request object\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function authenticateToken(req, res, next) {\n  // First, try JWT token from Authorization header\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    // First verify JWT signature without blacklist check to get specific error messages\n    const decoded = verifyTokenSync(token);\n\n    if (!decoded || !decoded.sub) {\n      // Token is invalid or expired (signature failed)\n      authLogger.logTokenInvalid(req, 'Invalid or expired token');\n      return res.status(401).json({\n        error: 'Invalid or expired token',\n        message: 'Please log in again to continue'\n      });\n    }\n\n    // Check if token has been revoked (blacklisted) - async Redis check\n    if (decoded.jti) {\n      const isBlacklisted = await isTokenBlacklisted(decoded.jti);\n      if (isBlacklisted) {\n        authLogger.logTokenBlacklisted(req, decoded.jti);\n        return res.status(401).json({\n          error: 'Token has been revoked',\n          message: 'This session has been logged out. Please log in again.'\n        });\n      }\n    }\n\n    // Token is valid and not revoked\n    req.stripeCustomerId = decoded.sub;\n    req.tokenData = decoded;\n    req.rawToken = token; // Store raw token for logout\n    return next();\n  }\n\n  // ==========================================================================\n  // DEPRECATED: Legacy x-stripe-customer-id header authentication\n  // This authentication method is deprecated and will be removed after\n  // the sunset date. Clients should migrate to JWT Bearer token authentication.\n  // ==========================================================================\n  const legacyCustomerId = req.headers['x-stripe-customer-id'];\n  if (legacyCustomerId) {\n    // Check if legacy auth is allowed\n    if (!ALLOW_LEGACY_AUTH) {\n      console.warn(`[Auth] Legacy auth attempt rejected (disabled): ${legacyCustomerId.slice(0, 8)}...`);\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      return res.status(401).json({\n        error: 'Legacy authentication disabled',\n        message: 'The x-stripe-customer-id header is no longer supported. Please use JWT Bearer token authentication.',\n        migration_guide: 'Use POST /auth/login with your license key to obtain a JWT token, then include it as: Authorization: Bearer <token>'\n      });\n    }\n\n    // Log deprecation warning with structured logging (once per request)\n    if (!req._legacyAuthWarned) {\n      authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n      console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n      req._legacyAuthWarned = true;\n    }\n\n    // Validate format\n    if (!legacyCustomerId.startsWith('cus_')) {\n      authLogger.logTokenInvalid(req, 'Invalid legacy customer ID format');\n      return res.status(401).json({\n        error: 'Invalid customer ID format',\n        message: 'Customer ID must start with cus_'\n      });\n    }\n\n    // Set deprecation warning header on the response\n    res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n    res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n    req.stripeCustomerId = legacyCustomerId;\n    req.isLegacyAuth = true;\n    return next();\n  }\n\n  // No authentication provided\n  return res.status(401).json({\n    error: 'Authentication required',\n    message: 'Please provide a valid Bearer token in the Authorization header'\n  });\n}\n\n/**\n * Optional authentication middleware\n * Allows unauthenticated access but sets req.stripeCustomerId if token present\n *\n * Note: Legacy x-stripe-customer-id header is deprecated and controlled by ALLOW_LEGACY_AUTH\n */\nasync function optionalAuthentication(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = extractBearerToken(authHeader);\n\n  if (token) {\n    const decoded = await verifyToken(token);\n    if (decoded && decoded.sub) {\n      req.stripeCustomerId = decoded.sub;\n      req.tokenData = decoded;\n    }\n  } else {\n    // DEPRECATED: Legacy x-stripe-customer-id header authentication\n    const legacyCustomerId = req.headers['x-stripe-customer-id'];\n    if (legacyCustomerId && legacyCustomerId.startsWith('cus_')) {\n      // Only accept legacy auth if allowed\n      if (ALLOW_LEGACY_AUTH) {\n        // Log deprecation warning\n        if (!req._legacyAuthWarned) {\n          authLogger.logLegacyAuthUsed(req, legacyCustomerId);\n          console.warn(`[Auth] DEPRECATION: Legacy auth used by ${legacyCustomerId.slice(0, 8)}... - migrate before ${LEGACY_AUTH_SUNSET_DATE}`);\n          req._legacyAuthWarned = true;\n        }\n\n        // Set deprecation warning headers\n        res.set('X-Deprecation-Warning', `x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: ${LEGACY_AUTH_SUNSET_DATE}`);\n        res.set('X-Deprecation-Sunset', LEGACY_AUTH_SUNSET_DATE);\n\n        req.stripeCustomerId = legacyCustomerId;\n        req.isLegacyAuth = true;\n      }\n      // If legacy auth is disabled, silently ignore (optional auth doesn't require auth)\n    }\n  }\n\n  next();\n}\n\n/**\n * HIGH-007: Database-backed admin role check middleware\n * Checks the user's role in the database instead of relying on env vars\n * Requires authenticateToken middleware to run first\n *\n * @param {Object} req - Express request object (must have req.stripeCustomerId set)\n * @param {Object} res - Express response object\n * @param {Function} next - Express next function\n */\nasync function requireAdmin(req, res, next) {\n  // Must be authenticated first\n  if (!req.stripeCustomerId) {\n    return res.status(401).json({\n      error: 'Authentication required',\n      message: 'Please log in to access this resource'\n    });\n  }\n\n  // Check if database pool is available\n  if (!pool) {\n    console.error('[Auth] Admin check failed: Database pool not available');\n    return res.status(503).json({\n      error: 'Service unavailable',\n      message: 'Admin verification temporarily unavailable'\n    });\n  }\n\n  try {\n    // Query database for user role\n    const result = await pool.query(\n      'SELECT role FROM users WHERE stripe_customer_id = $1',\n      [req.stripeCustomerId]\n    );\n\n    if (!result.rows[0]) {\n      authLogger.logAdminAccessDenied(req, 'User not found in database');\n      return res.status(403).json({\n        error: 'Access denied',\n        message: 'User account not found'\n      });\n    }\n\n    const userRole = result.rows[0].role;\n\n    if (userRole !== 'admin') {\n      authLogger.logAdminAccessDenied(req, `Role is '${userRole}', admin required`);\n      return res.status(403).json({\n        error: 'Admin access required',\n        message: 'This action requires administrator privileges'\n      });\n    }\n\n    // User is admin - log and proceed\n    authLogger.logAdminAccess(req);\n    req.isAdmin = true;\n    next();\n  } catch (err) {\n    console.error('[Auth] Admin role check failed:', err.message);\n    return res.status(500).json({\n      error: 'Authorization check failed',\n      message: 'Unable to verify admin privileges'\n    });\n  }\n}\n\n/**\n * Mask sensitive data for logging\n * @param {string} key - License key or other sensitive string\n * @returns {string} Masked string (e.g., \"SPLICE-ABC1-****-****-****\")\n */\nfunction maskSensitiveData(data) {\n  if (!data || typeof data !== 'string') {\n    return '****';\n  }\n\n  // For license keys (SPLICE-XXXX-XXXX-XXXX-XXXX format)\n  if (data.startsWith('SPLICE-')) {\n    const parts = data.split('-');\n    if (parts.length === 5) {\n      return `${parts[0]}-${parts[1]}-****-****-****`;\n    }\n  }\n\n  // For customer IDs (cus_xxxx format)\n  if (data.startsWith('cus_')) {\n    if (data.length > 10) {\n      return `cus_${data.slice(4, 8)}****`;\n    }\n    return 'cus_****';\n  }\n\n  // For JWTs (eyJ... format)\n  if (data.startsWith('eyJ')) {\n    return `${data.slice(0, 10)}...****`;\n  }\n\n  // For emails\n  if (data.includes('@')) {\n    const [local, domain] = data.split('@');\n    const maskedLocal = local.length > 2 ? `${local[0]}***${local[local.length-1]}` : '***';\n    return `${maskedLocal}@${domain}`;\n  }\n\n  // Generic masking - show first 4 chars\n  if (data.length > 8) {\n    return `${data.slice(0, 4)}****`;\n  }\n\n  return '****';\n}\n\nmodule.exports = {\n  generateToken,\n  generateRefreshToken,\n  verifyToken,\n  verifyTokenSync,\n  extractBearerToken,\n  authenticateToken,\n  optionalAuthentication,\n  maskSensitiveData,\n  // HIGH-007: Admin RBAC middleware\n  requireAdmin,\n  // Token blacklist functions\n  blacklistToken,\n  isTokenBlacklisted,\n  getBlacklistStats,\n  // Structured logging\n  authLogger,\n  // Constants\n  JWT_SECRET,\n  JWT_EXPIRES_IN,\n  // Legacy auth deprecation constants\n  LEGACY_AUTH_SUNSET_DATE,\n  ALLOW_LEGACY_AUTH\n};\n","numLines":694,"startLine":1,"totalLines":694}}}
{"parentUuid":"88cb2410-89ed-4c25-9b24-aca9009120f4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C6jQBx3DcTxeNjCs4Ebhm5","type":"message","role":"assistant","content":[{"type":"text","text":"The changes look complete. Let me run the tests to make sure the code still works correctly:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":9290,"cache_read_input_tokens":49716,"cache_creation":{"ephemeral_5m_input_tokens":9290,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2V99qAhiKTDDam5J63x","type":"assistant","uuid":"e7b19d97-1e07-455b-b9df-03d7520f6825","timestamp":"2026-01-11T23:49:24.425Z"}
{"parentUuid":"e7b19d97-1e07-455b-b9df-03d7520f6825","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C6jQBx3DcTxeNjCs4Ebhm5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RSMiC14hPBgNAfPSSRPUhX","name":"Bash","input":{"command":"cd /Users/imorgado/SPLICE/splice-backend && npm test 2>&1 | head -100","description":"Run backend tests","timeout":60000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":9290,"cache_read_input_tokens":49716,"cache_creation":{"ephemeral_5m_input_tokens":9290,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2V99qAhiKTDDam5J63x","type":"assistant","uuid":"5a403023-bd77-444f-8544-065f74ede1d5","timestamp":"2026-01-11T23:49:25.794Z"}
{"parentUuid":"5a403023-bd77-444f-8544-065f74ede1d5","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RSMiC14hPBgNAfPSSRPUhX","type":"tool_result","content":"> splice-backend@6.0.3 test\n> node tests/auth.test.js\n\n\n=== Authentication E2E Tests ===\n\n1. POST /auth/login - Login Tests\n  ✓ login with valid license key returns tokens\n  ✓ login with invalid license key returns 401\n  ✓ login with deactivated license key returns 401\n  ✓ login without license key returns 400\n\n2. POST /auth/refresh - Token Refresh Tests\n  ✓ refresh with valid refresh token returns new tokens\n  ✓ refresh with invalid refresh token returns 401\n  ✓ refresh with access token (wrong type) returns 401\n  ✓ refresh without token returns 400\n\n3. POST /auth/logout - Logout Tests\n  ✓ logout blacklists current token\n  ✓ logout also blacklists provided refresh token\n\n4. Protected Route Access Tests\n  ✓ protected route access with valid token succeeds\n  ✓ protected route rejection with blacklisted token\n  ✓ protected route rejection with expired token\n  ✓ protected route rejection with invalid token\n  ✓ protected route rejection without any authentication\n\n5. Legacy Auth Header Support Tests\n  ✓ legacy x-stripe-customer-id header is accepted\n  ✓ invalid legacy customer ID format rejected\n\n6. Token Generation Edge Cases\n  ✓ generateToken requires valid Stripe customer ID\n  ✓ generateToken requires customer ID starting with cus_\n  ✓ generateRefreshToken requires valid Stripe customer ID\n  ✓ generated tokens have unique jti\n\n7. Bearer Token Extraction Tests\n  ✓ extractBearerToken handles valid Bearer header\n  ✓ extractBearerToken handles lowercase bearer\n  ✓ extractBearerToken returns null for non-Bearer auth\n  ✓ extractBearerToken returns null for malformed header\n  ✓ extractBearerToken returns null for null header\n  ✓ extractBearerToken returns null for undefined header\n\n8. Full Login-Use-Logout Flow\n  ✓ complete auth lifecycle works correctly\n\n=== Authentication Test Summary ===\n  Passed: 28\n  Failed: 0\n  Total: 28\n\n✓ All authentication tests passed","is_error":false}]},"uuid":"0297e918-7e6b-4650-97e4-a206b2ad7bdb","timestamp":"2026-01-11T23:49:26.808Z","toolUseResult":{"stdout":"> splice-backend@6.0.3 test\n> node tests/auth.test.js\n\n\n=== Authentication E2E Tests ===\n\n1. POST /auth/login - Login Tests\n  ✓ login with valid license key returns tokens\n  ✓ login with invalid license key returns 401\n  ✓ login with deactivated license key returns 401\n  ✓ login without license key returns 400\n\n2. POST /auth/refresh - Token Refresh Tests\n  ✓ refresh with valid refresh token returns new tokens\n  ✓ refresh with invalid refresh token returns 401\n  ✓ refresh with access token (wrong type) returns 401\n  ✓ refresh without token returns 400\n\n3. POST /auth/logout - Logout Tests\n  ✓ logout blacklists current token\n  ✓ logout also blacklists provided refresh token\n\n4. Protected Route Access Tests\n  ✓ protected route access with valid token succeeds\n  ✓ protected route rejection with blacklisted token\n  ✓ protected route rejection with expired token\n  ✓ protected route rejection with invalid token\n  ✓ protected route rejection without any authentication\n\n5. Legacy Auth Header Support Tests\n  ✓ legacy x-stripe-customer-id header is accepted\n  ✓ invalid legacy customer ID format rejected\n\n6. Token Generation Edge Cases\n  ✓ generateToken requires valid Stripe customer ID\n  ✓ generateToken requires customer ID starting with cus_\n  ✓ generateRefreshToken requires valid Stripe customer ID\n  ✓ generated tokens have unique jti\n\n7. Bearer Token Extraction Tests\n  ✓ extractBearerToken handles valid Bearer header\n  ✓ extractBearerToken handles lowercase bearer\n  ✓ extractBearerToken returns null for non-Bearer auth\n  ✓ extractBearerToken returns null for malformed header\n  ✓ extractBearerToken returns null for null header\n  ✓ extractBearerToken returns null for undefined header\n\n8. Full Login-Use-Logout Flow\n  ✓ complete auth lifecycle works correctly\n\n=== Authentication Test Summary ===\n  Passed: 28\n  Failed: 0\n  Total: 28\n\n✓ All authentication tests passed","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"0297e918-7e6b-4650-97e4-a206b2ad7bdb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UKgz72tGbWbt7vr76KjWes","type":"message","role":"assistant","content":[{"type":"text","text":"All tests pass. Let me also verify the linting:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":789,"cache_read_input_tokens":59006,"cache_creation":{"ephemeral_5m_input_tokens":789,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2V9YwxrkxcvYLsJsiXs","type":"assistant","uuid":"3f60e45f-bbd6-448d-9943-b86422707860","timestamp":"2026-01-11T23:49:29.367Z"}
{"parentUuid":"3f60e45f-bbd6-448d-9943-b86422707860","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UKgz72tGbWbt7vr76KjWes","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017CnzDXtq1K36LjqhziKrqt","name":"Bash","input":{"command":"cd /Users/imorgado/SPLICE/splice-backend && npm run lint 2>&1","description":"Run linter on backend","timeout":30000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":789,"cache_read_input_tokens":59006,"cache_creation":{"ephemeral_5m_input_tokens":789,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2V9YwxrkxcvYLsJsiXs","type":"assistant","uuid":"279ac33d-a434-4c20-b0ba-b0aef7fdbd39","timestamp":"2026-01-11T23:49:30.499Z"}
{"parentUuid":"279ac33d-a434-4c20-b0ba-b0aef7fdbd39","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 1\n\n> splice-backend@6.0.3 lint\n> eslint --config eslint.config.cjs .\n\n\n/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js\n  191:10  error  'endpointRateLimit' is defined but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/routes/auth.js\n  15:9  error  'endpointRateLimit' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/scripts/setup-beta-testers.js\n  454:13  error  'product' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/scripts/verify-beta-testers.js\n  118:16  error  'usageErr' is defined but never used. Allowed unused caught errors must match /^_/u  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/emailService.js\n  24:10  error  'err' is defined but never used. Allowed unused caught errors must match /^_/u      no-unused-vars\n  34:29  error  'options' is assigned a value but never used. Allowed unused args must match /^_/u  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/musicGeneration.js\n  18:9  error  'circuitBreakers' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/r2Storage.js\n  15:9  error  'circuitBreakers' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/transcription.js\n  17:9  error  'circuitBreakers' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/webhookService.js\n  18:10  error  'err' is defined but never used. Allowed unused caught errors must match /^_/u  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/tests/circuit-breaker.test.js\n   11:1   error  'describe' is not defined    no-undef\n   14:3   error  'beforeEach' is not defined  no-undef\n   25:3   error  'describe' is not defined    no-undef\n   26:5   error  'test' is not defined        no-undef\n   28:7   error  'expect' is not defined      no-undef\n   31:5   error  'test' is not defined        no-undef\n   33:31  error  'jest' is not defined        no-undef\n   36:13  error  'expect' is not defined      no-undef\n   37:13  error  'expect' is not defined      no-undef\n   38:13  error  'expect' is not defined      no-undef\n   42:7   error  'expect' is not defined      no-undef\n   45:5   error  'test' is not defined        no-undef\n   47:31  error  'jest' is not defined        no-undef\n   48:13  error  'expect' is not defined      no-undef\n   49:13  error  'expect' is not defined      no-undef\n   50:13  error  'expect' is not defined      no-undef\n   52:7   error  'expect' is not defined      no-undef\n   55:27  error  'jest' is not defined        no-undef\n   56:13  error  'expect' is not defined      no-undef\n   59:7   error  'expect' is not defined      no-undef\n   62:5   error  'test' is not defined        no-undef\n   64:31  error  'jest' is not defined        no-undef\n   65:13  error  'expect' is not defined      no-undef\n   66:13  error  'expect' is not defined      no-undef\n   67:13  error  'expect' is not defined      no-undef\n   69:7   error  'expect' is not defined      no-undef\n   75:31  error  'jest' is not defined        no-undef\n   79:7   error  'expect' is not defined      no-undef\n   82:5   error  'test' is not defined        no-undef\n   84:31  error  'jest' is not defined        no-undef\n   85:13  error  'expect' is not defined      no-undef\n   86:13  error  'expect' is not defined      no-undef\n   87:13  error  'expect' is not defined      no-undef\n   93:31  error  'jest' is not defined        no-undef\n   96:7   error  'expect' is not defined      no-undef\n   97:7   error  'expect' is not defined      no-undef\n  100:5   error  'test' is not defined        no-undef\n  102:31  error  'jest' is not defined        no-undef\n  103:13  error  'expect' is not defined      no-undef\n  104:13  error  'expect' is not defined      no-undef\n  105:13  error  'expect' is not defined      no-undef\n  107:7   error  'expect' is not defined      no-undef\n  113:13  error  'expect' is not defined      no-undef\n  115:7   error  'expect' is not defined      no-undef\n  119:3   error  'describe' is not defined    no-undef\n  120:5   error  'test' is not defined        no-undef\n  121:28  error  'jest' is not defined        no-undef\n  123:13  error  'expect' is not defined      no-undef\n  126:5   error  'test' is not defined        no-undef\n  127:28  error  'jest' is not defined        no-undef\n  130:7   error  'expect' is not defined      no-undef\n  133:5   error  'test' is not defined        no-undef\n  134:28  error  'jest' is not defined        no-undef\n  137:13  error  'expect' is not defined      no-undef\n  138:13  error  'expect' is not defined      no-undef\n  139:13  error  'expect' is not defined      no-undef\n  142:7   error  'expect' is not defined      no-undef\n  146:3   error  'describe' is not defined    no-undef\n  147:5   error  'test' is not defined        no-undef\n  148:31  error  'jest' is not defined        no-undef\n  151:13  error  \n\n... [1863 characters truncated] ...\n\nerror  'expect' is not defined      no-undef\n  234:13  error  'expect' is not defined      no-undef\n  237:7   error  'expect' is not defined      no-undef\n  241:3   error  'describe' is not defined    no-undef\n  242:5   error  'test' is not defined        no-undef\n  244:31  error  'jest' is not defined        no-undef\n  245:13  error  'expect' is not defined      no-undef\n  246:13  error  'expect' is not defined      no-undef\n  247:13  error  'expect' is not defined      no-undef\n  249:7   error  'expect' is not defined      no-undef\n  255:7   error  'expect' is not defined      no-undef\n  257:7   error  'expect' is not defined      no-undef\n  258:7   error  'expect' is not defined      no-undef\n  263:1   error  'describe' is not defined    no-undef\n  264:3   error  'beforeEach' is not defined  no-undef\n  269:3   error  'describe' is not defined    no-undef\n  270:5   error  'test' is not defined        no-undef\n  272:7   error  'expect' is not defined      no-undef\n  273:7   error  'expect' is not defined      no-undef\n  276:7   error  'expect' is not defined      no-undef\n  279:5   error  'test' is not defined        no-undef\n  281:33  error  'jest' is not defined        no-undef\n  284:13  error  'expect' is not defined      no-undef\n  285:13  error  'expect' is not defined      no-undef\n  286:13  error  'expect' is not defined      no-undef\n  287:13  error  'expect' is not defined      no-undef\n  288:13  error  'expect' is not defined      no-undef\n  292:7   error  'expect' is not defined      no-undef\n  296:3   error  'describe' is not defined    no-undef\n  297:5   error  'test' is not defined        no-undef\n  299:7   error  'expect' is not defined      no-undef\n  300:7   error  'expect' is not defined      no-undef\n  303:7   error  'expect' is not defined      no-undef\n  307:3   error  'describe' is not defined    no-undef\n  308:5   error  'test' is not defined        no-undef\n  310:7   error  'expect' is not defined      no-undef\n  311:7   error  'expect' is not defined      no-undef\n  314:7   error  'expect' is not defined      no-undef\n  318:3   error  'describe' is not defined    no-undef\n  319:5   error  'test' is not defined        no-undef\n  321:7   error  'expect' is not defined      no-undef\n  322:7   error  'expect' is not defined      no-undef\n  325:7   error  'expect' is not defined      no-undef\n  329:3   error  'describe' is not defined    no-undef\n  330:5   error  'test' is not defined        no-undef\n  332:7   error  'expect' is not defined      no-undef\n  333:7   error  'expect' is not defined      no-undef\n  336:7   error  'expect' is not defined      no-undef\n  341:1   error  'describe' is not defined    no-undef\n  345:3   error  'beforeEach' is not defined  no-undef\n  354:26  error  'jest' is not defined        no-undef\n  358:3   error  'test' is not defined        no-undef\n  359:29  error  'jest' is not defined        no-undef\n  361:11  error  'expect' is not defined      no-undef\n  362:11  error  'expect' is not defined      no-undef\n  363:11  error  'expect' is not defined      no-undef\n  365:5   error  'expect' is not defined      no-undef\n  366:7   error  'expect' is not defined      no-undef\n  373:3   error  'test' is not defined        no-undef\n  375:29  error  'jest' is not defined        no-undef\n  376:11  error  'expect' is not defined      no-undef\n  377:11  error  'expect' is not defined      no-undef\n  378:11  error  'expect' is not defined      no-undef\n  387:29  error  'jest' is not defined        no-undef\n  390:5   error  'expect' is not defined      no-undef\n  391:7   error  'expect' is not defined      no-undef\n  398:3   error  'test' is not defined        no-undef\n  400:29  error  'jest' is not defined        no-undef\n  401:11  error  'expect' is not defined      no-undef\n  402:11  error  'expect' is not defined      no-undef\n  403:11  error  'expect' is not defined      no-undef\n  412:29  error  'jest' is not defined        no-undef\n  415:5   error  'expect' is not defined      no-undef\n  416:7   error  'expect' is not defined      no-undef\n  424:1   error  'describe' is not defined    no-undef\n  427:3   error  'beforeEach' is not defined  no-undef\n  437:3   error  'test' is not defined        no-undef\n  442:11  error  'expect' is not defined      no-undef\n  445:3   error  'test' is not defined        no-undef\n  446:11  error  'expect' is not defined      no-undef\n  447:11  error  'expect' is not defined      no-undef\n  450:3   error  'test' is not defined        no-undef\n  454:5   error  'expect' is not defined      no-undef\n  457:3   error  'test' is not defined        no-undef\n  458:29  error  'jest' is not defined        no-undef\n  459:29  error  'jest' is not defined        no-undef\n  475:5   error  'expect' is not defined      no-undef\n\n/Users/imorgado/SPLICE/splice-backend/utils/circuitBreaker.js\n  270:16  error  'fallbackError' is defined but never used. Allowed unused caught errors must match /^_/u  no-unused-vars\n\n✖ 192 problems (192 errors, 0 warnings)","is_error":true,"tool_use_id":"toolu_017CnzDXtq1K36LjqhziKrqt"}]},"uuid":"65b9df11-8d14-499f-9c2f-0a8b7727dfff","timestamp":"2026-01-11T23:49:32.492Z","toolUseResult":"Error: Exit code 1\n\n> splice-backend@6.0.3 lint\n> eslint --config eslint.config.cjs .\n\n\n/Users/imorgado/SPLICE/splice-backend/middleware/rateLimiter.js\n  191:10  error  'endpointRateLimit' is defined but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/routes/auth.js\n  15:9  error  'endpointRateLimit' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/scripts/setup-beta-testers.js\n  454:13  error  'product' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/scripts/verify-beta-testers.js\n  118:16  error  'usageErr' is defined but never used. Allowed unused caught errors must match /^_/u  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/emailService.js\n  24:10  error  'err' is defined but never used. Allowed unused caught errors must match /^_/u      no-unused-vars\n  34:29  error  'options' is assigned a value but never used. Allowed unused args must match /^_/u  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/musicGeneration.js\n  18:9  error  'circuitBreakers' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/r2Storage.js\n  15:9  error  'circuitBreakers' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/transcription.js\n  17:9  error  'circuitBreakers' is assigned a value but never used  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/services/webhookService.js\n  18:10  error  'err' is defined but never used. Allowed unused caught errors must match /^_/u  no-unused-vars\n\n/Users/imorgado/SPLICE/splice-backend/tests/circuit-breaker.test.js\n   11:1   error  'describe' is not defined    no-undef\n   14:3   error  'beforeEach' is not defined  no-undef\n   25:3   error  'describe' is not defined    no-undef\n   26:5   error  'test' is not defined        no-undef\n   28:7   error  'expect' is not defined      no-undef\n   31:5   error  'test' is not defined        no-undef\n   33:31  error  'jest' is not defined        no-undef\n   36:13  error  'expect' is not defined      no-undef\n   37:13  error  'expect' is not defined      no-undef\n   38:13  error  'expect' is not defined      no-undef\n   42:7   error  'expect' is not defined      no-undef\n   45:5   error  'test' is not defined        no-undef\n   47:31  error  'jest' is not defined        no-undef\n   48:13  error  'expect' is not defined      no-undef\n   49:13  error  'expect' is not defined      no-undef\n   50:13  error  'expect' is not defined      no-undef\n   52:7   error  'expect' is not defined      no-undef\n   55:27  error  'jest' is not defined        no-undef\n   56:13  error  'expect' is not defined      no-undef\n   59:7   error  'expect' is not defined      no-undef\n   62:5   error  'test' is not defined        no-undef\n   64:31  error  'jest' is not defined        no-undef\n   65:13  error  'expect' is not defined      no-undef\n   66:13  error  'expect' is not defined      no-undef\n   67:13  error  'expect' is not defined      no-undef\n   69:7   error  'expect' is not defined      no-undef\n   75:31  error  'jest' is not defined        no-undef\n   79:7   error  'expect' is not defined      no-undef\n   82:5   error  'test' is not defined        no-undef\n   84:31  error  'jest' is not defined        no-undef\n   85:13  error  'expect' is not defined      no-undef\n   86:13  error  'expect' is not defined      no-undef\n   87:13  error  'expect' is not defined      no-undef\n   93:31  error  'jest' is not defined        no-undef\n   96:7   error  'expect' is not defined      no-undef\n   97:7   error  'expect' is not defined      no-undef\n  100:5   error  'test' is not defined        no-undef\n  102:31  error  'jest' is not defined        no-undef\n  103:13  error  'expect' is not defined      no-undef\n  104:13  error  'expect' is not defined      no-undef\n  105:13  error  'expect' is not defined      no-undef\n  107:7   error  'expect' is not defined      no-undef\n  113:13  error  'expect' is not defined      no-undef\n  115:7   error  'expect' is not defined      no-undef\n  119:3   error  'describe' is not defined    no-undef\n  120:5   error  'test' is not defined        no-undef\n  121:28  error  'jest' is not defined        no-undef\n  123:13  error  'expect' is not defined      no-undef\n  126:5   error  'test' is not defined        no-undef\n  127:28  error  'jest' is not defined        no-undef\n  130:7   error  'expect' is not defined      no-undef\n  133:5   error  'test' is not defined        no-undef\n  134:28  error  'jest' is not defined        no-undef\n  137:13  error  'expect' is not defined      no-undef\n  138:13  error  'expect' is not defined      no-undef\n  139:13  error  'expect' is not defined      no-undef\n  142:7   error  'expect' is not defined      no-undef\n  146:3   error  'describe' is not defined    no-undef\n  147:5   error  'test' is not defined        no-undef\n  148:31  error  'jest' is not defined        no-undef\n  151:13  error  \n\n... [1863 characters truncated] ...\n\nerror  'expect' is not defined      no-undef\n  234:13  error  'expect' is not defined      no-undef\n  237:7   error  'expect' is not defined      no-undef\n  241:3   error  'describe' is not defined    no-undef\n  242:5   error  'test' is not defined        no-undef\n  244:31  error  'jest' is not defined        no-undef\n  245:13  error  'expect' is not defined      no-undef\n  246:13  error  'expect' is not defined      no-undef\n  247:13  error  'expect' is not defined      no-undef\n  249:7   error  'expect' is not defined      no-undef\n  255:7   error  'expect' is not defined      no-undef\n  257:7   error  'expect' is not defined      no-undef\n  258:7   error  'expect' is not defined      no-undef\n  263:1   error  'describe' is not defined    no-undef\n  264:3   error  'beforeEach' is not defined  no-undef\n  269:3   error  'describe' is not defined    no-undef\n  270:5   error  'test' is not defined        no-undef\n  272:7   error  'expect' is not defined      no-undef\n  273:7   error  'expect' is not defined      no-undef\n  276:7   error  'expect' is not defined      no-undef\n  279:5   error  'test' is not defined        no-undef\n  281:33  error  'jest' is not defined        no-undef\n  284:13  error  'expect' is not defined      no-undef\n  285:13  error  'expect' is not defined      no-undef\n  286:13  error  'expect' is not defined      no-undef\n  287:13  error  'expect' is not defined      no-undef\n  288:13  error  'expect' is not defined      no-undef\n  292:7   error  'expect' is not defined      no-undef\n  296:3   error  'describe' is not defined    no-undef\n  297:5   error  'test' is not defined        no-undef\n  299:7   error  'expect' is not defined      no-undef\n  300:7   error  'expect' is not defined      no-undef\n  303:7   error  'expect' is not defined      no-undef\n  307:3   error  'describe' is not defined    no-undef\n  308:5   error  'test' is not defined        no-undef\n  310:7   error  'expect' is not defined      no-undef\n  311:7   error  'expect' is not defined      no-undef\n  314:7   error  'expect' is not defined      no-undef\n  318:3   error  'describe' is not defined    no-undef\n  319:5   error  'test' is not defined        no-undef\n  321:7   error  'expect' is not defined      no-undef\n  322:7   error  'expect' is not defined      no-undef\n  325:7   error  'expect' is not defined      no-undef\n  329:3   error  'describe' is not defined    no-undef\n  330:5   error  'test' is not defined        no-undef\n  332:7   error  'expect' is not defined      no-undef\n  333:7   error  'expect' is not defined      no-undef\n  336:7   error  'expect' is not defined      no-undef\n  341:1   error  'describe' is not defined    no-undef\n  345:3   error  'beforeEach' is not defined  no-undef\n  354:26  error  'jest' is not defined        no-undef\n  358:3   error  'test' is not defined        no-undef\n  359:29  error  'jest' is not defined        no-undef\n  361:11  error  'expect' is not defined      no-undef\n  362:11  error  'expect' is not defined      no-undef\n  363:11  error  'expect' is not defined      no-undef\n  365:5   error  'expect' is not defined      no-undef\n  366:7   error  'expect' is not defined      no-undef\n  373:3   error  'test' is not defined        no-undef\n  375:29  error  'jest' is not defined        no-undef\n  376:11  error  'expect' is not defined      no-undef\n  377:11  error  'expect' is not defined      no-undef\n  378:11  error  'expect' is not defined      no-undef\n  387:29  error  'jest' is not defined        no-undef\n  390:5   error  'expect' is not defined      no-undef\n  391:7   error  'expect' is not defined      no-undef\n  398:3   error  'test' is not defined        no-undef\n  400:29  error  'jest' is not defined        no-undef\n  401:11  error  'expect' is not defined      no-undef\n  402:11  error  'expect' is not defined      no-undef\n  403:11  error  'expect' is not defined      no-undef\n  412:29  error  'jest' is not defined        no-undef\n  415:5   error  'expect' is not defined      no-undef\n  416:7   error  'expect' is not defined      no-undef\n  424:1   error  'describe' is not defined    no-undef\n  427:3   error  'beforeEach' is not defined  no-undef\n  437:3   error  'test' is not defined        no-undef\n  442:11  error  'expect' is not defined      no-undef\n  445:3   error  'test' is not defined        no-undef\n  446:11  error  'expect' is not defined      no-undef\n  447:11  error  'expect' is not defined      no-undef\n  450:3   error  'test' is not defined        no-undef\n  454:5   error  'expect' is not defined      no-undef\n  457:3   error  'test' is not defined        no-undef\n  458:29  error  'jest' is not defined        no-undef\n  459:29  error  'jest' is not defined        no-undef\n  475:5   error  'expect' is not defined      no-undef\n\n/Users/imorgado/SPLICE/splice-backend/utils/circuitBreaker.js\n  270:16  error  'fallbackError' is defined but never used. Allowed unused caught errors must match /^_/u  no-unused-vars\n\n✖ 192 problems (192 errors, 0 warnings)"}
{"parentUuid":"65b9df11-8d14-499f-9c2f-0a8b7727dfff","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CcBZ1ty9G8zsB1QNQ8P1SK","type":"message","role":"assistant","content":[{"type":"text","text":"The linting errors are pre-existing issues in other files, not related to my changes. The auth.js file I edited doesn't have any new linting errors. Let me specifically check just the auth.js file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3598,"cache_read_input_tokens":59795,"cache_creation":{"ephemeral_5m_input_tokens":3598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2V9yCE8ZVEXRMrnAWqA","type":"assistant","uuid":"22003d87-698b-4c0c-96af-bba706ec2d56","timestamp":"2026-01-11T23:49:36.196Z"}
{"parentUuid":"22003d87-698b-4c0c-96af-bba706ec2d56","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CcBZ1ty9G8zsB1QNQ8P1SK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016FLKHwPyoSCcQ4zWA443Ut","name":"Bash","input":{"command":"cd /Users/imorgado/SPLICE/splice-backend && npx eslint --config eslint.config.cjs middleware/auth.js 2>&1","description":"Lint only auth.js file"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3598,"cache_read_input_tokens":59795,"cache_creation":{"ephemeral_5m_input_tokens":3598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX2V9yCE8ZVEXRMrnAWqA","type":"assistant","uuid":"14188191-1e2a-42a7-8834-06012cfe6cce","timestamp":"2026-01-11T23:49:37.512Z"}
{"parentUuid":"14188191-1e2a-42a7-8834-06012cfe6cce","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016FLKHwPyoSCcQ4zWA443Ut","type":"tool_result","content":"","is_error":false}]},"uuid":"a4f1d219-b3a3-4c71-9f01-ae732550b4f1","timestamp":"2026-01-11T23:49:38.756Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"a4f1d219-b3a3-4c71-9f01-ae732550b4f1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"dccef0b9-8cc0-4d0c-9a97-f234ebd6961d","version":"2.0.76","gitBranch":"main","agentId":"a775189","slug":"proud-honking-gosling","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Nzxp42v2CEKcbWQFyVviZv","type":"message","role":"assistant","content":[{"type":"text","text":"The auth.js file passes linting with no errors. The implementation is complete. Here's a summary of the changes made:\n\n## Summary of Changes to `/Users/imorgado/SPLICE/splice-backend/middleware/auth.js`\n\n### 1. Added Deprecation Configuration (lines 58-92)\n- Added `LEGACY_AUTH_SUNSET_DATE` constant set to `2026-04-11` (90 days from today)\n- Added `ALLOW_LEGACY_AUTH` environment variable control:\n  - **Production**: Defaults to `false` (legacy auth disabled)\n  - **Development**: Defaults to `true` (enabled for backward compatibility)\n- Added startup logging to clearly indicate legacy auth status\n\n### 2. Updated `authenticateToken` Middleware (lines 466-507)\n- Added check for `ALLOW_LEGACY_AUTH` - returns 401 with migration guide if disabled\n- Added `X-Deprecation-Warning` header with message and sunset date\n- Added `X-Deprecation-Sunset` header with the sunset date\n- Added console warnings when legacy auth is used\n- Enhanced error response when legacy auth is disabled to include a `migration_guide` field\n\n### 3. Updated `optionalAuthentication` Middleware (lines 532-557)\n- Added check for `ALLOW_LEGACY_AUTH` before accepting legacy auth\n- Added deprecation warning headers when legacy auth is used\n- If legacy auth is disabled, requests silently continue without auth (appropriate for optional auth)\n\n### 4. Updated Documentation\n- Enhanced file header comment with full deprecation notice and migration guide (lines 1-24)\n- Enhanced `authenticateToken` function JSDoc with detailed deprecation information (lines 410-428)\n- Added deprecation note to `optionalAuthentication` JSDoc (lines 516-521)\n\n### 5. Updated Module Exports (lines 691-692)\n- Exported `LEGACY_AUTH_SUNSET_DATE` and `ALLOW_LEGACY_AUTH` constants for use by other modules\n\n### Key Behaviors\n\n| Environment | `ALLOW_LEGACY_AUTH` Default | Legacy Auth Behavior |\n|-------------|----------------------------|---------------------|\n| Production | `false` | Returns 401 with migration guide |\n| Development | `true` | Accepts but logs warnings + sets deprecation headers |\n\n**Response Headers when legacy auth is allowed:**\n```\nX-Deprecation-Warning: x-stripe-customer-id header is deprecated. Please use JWT authentication. Sunset date: 2026-04-11\nX-Deprecation-Sunset: 2026-04-11\n```"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":271,"cache_read_input_tokens":63393,"cache_creation":{"ephemeral_5m_input_tokens":271,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CX2VAS1XcgGod41ZK1CkE","type":"assistant","uuid":"55947391-1679-4de1-9b41-a2ebd0cf9174","timestamp":"2026-01-11T23:49:54.497Z"}
