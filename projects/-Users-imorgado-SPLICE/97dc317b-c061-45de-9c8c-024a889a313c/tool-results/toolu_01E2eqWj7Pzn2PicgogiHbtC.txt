     1→import { NextRequest, NextResponse } from "next/server";
     2→import Stripe from "stripe";
     3→
     4→// Force Node.js runtime (not Edge) for better Stripe compatibility
     5→export const runtime = "nodejs";
     6→export const maxDuration = 30;
     7→
     8→// Lazy initialization to avoid errors during build
     9→let stripe: Stripe | null = null;
    10→function getStripe(): Stripe {
    11→  if (!stripe) {
    12→    if (!process.env.STRIPE_SECRET_KEY) {
    13→      throw new Error("STRIPE_SECRET_KEY is not configured");
    14→    }
    15→    stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
    16→      timeout: 10000,
    17→      maxNetworkRetries: 2,
    18→    });
    19→  }
    20→  return stripe;
    21→}
    22→
    23→// Get price IDs at runtime to ensure env vars are loaded
    24→function getPriceIds() {
    25→  return {
    26→    monthly: {
    27→      starter: process.env.STRIPE_PRICE_STARTER || "",
    28→      pro: process.env.STRIPE_PRICE_PRO || "",
    29→      team: process.env.STRIPE_PRICE_TEAM || "",
    30→    },
    31→    annual: {
    32→      starter: process.env.STRIPE_PRICE_STARTER_ANNUAL || "",
    33→      pro: process.env.STRIPE_PRICE_PRO_ANNUAL || "",
    34→      team: process.env.STRIPE_PRICE_TEAM_ANNUAL || "",
    35→    },
    36→  };
    37→}
    38→
    39→export async function POST(request: NextRequest) {
    40→  try {
    41→    const body = await request.json();
    42→    const { plan, email, successUrl, cancelUrl, billing = "monthly" } = body;
    43→
    44→    // Get price IDs at runtime
    45→    const allPrices = getPriceIds();
    46→    const priceIds = billing === "annual" ? allPrices.annual : allPrices.monthly;
    47→
    48→    if (!plan || !priceIds[plan as keyof typeof priceIds]) {
    49→      return NextResponse.json(
    50→        { error: "Invalid plan selected" },
    51→        { status: 400 }
    52→      );
    53→    }
    54→
    55→    const priceId = priceIds[plan as keyof typeof priceIds];
    56→
    57→    if (!priceId) {
    58→      return NextResponse.json(
    59→        { error: "Price ID not configured for this plan" },
    60→        { status: 500 }
    61→      );
    62→    }
    63→
    64→    // Create Stripe checkout session using raw fetch (workaround for Vercel SDK connectivity issues)
    65→    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || "https://splice-website.vercel.app";
    66→    const successUrlFinal = successUrl || `${baseUrl}/checkout/success`;
    67→    const cancelUrlFinal = cancelUrl || `${baseUrl}/pricing`;
    68→
    69→    const params = new URLSearchParams();
    70→    params.append("mode", "subscription");
    71→    params.append("payment_method_types[0]", "card");
    72→    params.append("line_items[0][price]", priceId);
    73→    params.append("line_items[0][quantity]", "1");
    74→    if (email) params.append("customer_email", email);
    75→    params.append("success_url", successUrlFinal);
    76→    params.append("cancel_url", cancelUrlFinal);
    77→    params.append("subscription_data[trial_period_days]", "14");
    78→    params.append("subscription_data[metadata][plan]", plan);
    79→    params.append("subscription_data[metadata][billing]", billing);
    80→    params.append("metadata[plan]", plan);
    81→    params.append("metadata[billing]", billing);
    82→    params.append("allow_promotion_codes", "true");
    83→    params.append("billing_address_collection", "required");
    84→
    85→    const response = await fetch("https://api.stripe.com/v1/checkout/sessions", {
    86→      method: "POST",
    87→      headers: {
    88→        "Authorization": `Bearer ${process.env.STRIPE_SECRET_KEY}`,
    89→        "Content-Type": "application/x-www-form-urlencoded",
    90→      },
    91→      body: params,
    92→    });
    93→
    94→    if (!response.ok) {
    95→      const errorData = await response.json();
    96→      console.error("[Checkout] Stripe API error:", errorData);
    97→      throw new Error(errorData.error?.message || "Stripe API error");
    98→    }
    99→
   100→    const session = await response.json();
   101→
   102→    return NextResponse.json({
   103→      sessionId: session.id,
   104→      url: session.url,
   105→    });
   106→  } catch (error) {
   107→    console.error("[Checkout] Error:", error instanceof Error ? error.message : error);
   108→    return NextResponse.json(
   109→      {
   110→        error:
   111→          error instanceof Error ? error.message : "Failed to create checkout session",
   112→      },
   113→      { status: 500 }
   114→    );
   115→  }
   116→}
   117→
   118→export async function GET(request: NextRequest) {
   119→  const searchParams = request.nextUrl.searchParams;
   120→  const sessionId = searchParams.get("session_id");
   121→
   122→  if (!sessionId) {
   123→    return NextResponse.json(
   124→      { error: "Session ID is required" },
   125→      { status: 400 }
   126→    );
   127→  }
   128→
   129→  try {
   130→    const session = await getStripe().checkout.sessions.retrieve(sessionId, {
   131→      expand: ["subscription", "customer"],
   132→    });
   133→
   134→    return NextResponse.json({
   135→      status: session.status,
   136→      customerEmail: session.customer_details?.email,
   137→      plan: session.metadata?.plan,
   138→      subscriptionId:
   139→        typeof session.subscription === "string"
   140→          ? session.subscription
   141→          : session.subscription?.id,
   142→    });
   143→  } catch (error) {
   144→    console.error("Session retrieval error:", error);
   145→    return NextResponse.json(
   146→      {
   147→        error:
   148→          error instanceof Error
   149→            ? error.message
   150→            : "Failed to retrieve session",
   151→      },
   152→      { status: 500 }
   153→    );
   154→  }
   155→}
   156→

</system-reminder>
