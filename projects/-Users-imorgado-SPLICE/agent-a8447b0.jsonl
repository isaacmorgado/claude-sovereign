{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","type":"user","message":{"role":"user","content":"Analyze the Fireside deobfuscated multitrack module at /Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack\n\nThis is likely code from a competing Premiere Pro plugin. Analyze:\n1. All files in this directory\n2. How multitrack editing is implemented\n3. What APIs/methods are used\n4. Data structures and algorithms\n5. How it integrates with Premiere Pro\n\nProvide detailed documentation of the implementation that could be adapted for SPLICE."},"uuid":"90dc2c35-2280-4c14-a3fc-854fd44ccbee","timestamp":"2025-12-25T18:00:51.675Z"}
{"parentUuid":"90dc2c35-2280-4c14-a3fc-854fd44ccbee","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016rKbJr4AaFLXgfCYec2Dod","type":"message","role":"assistant","content":[{"type":"text","text":"I'll analyze the Fireside deobfuscated multitrack module to understand their implementation. Let me start by exploring the directory structure and all files."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":12370,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":12370,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWTqpEkcxfxPwQi4HML2t","type":"assistant","uuid":"96107c3f-3101-4525-8eae-1754ab632cdd","timestamp":"2025-12-25T18:00:53.003Z"}
{"parentUuid":"96107c3f-3101-4525-8eae-1754ab632cdd","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016rKbJr4AaFLXgfCYec2Dod","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012ni1FJgmY19eFNsWt16n6X","name":"Bash","input":{"command":"find /Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack -type f -name \"*.js\" -o -name \"*.json\" -o -name \"*.ts\" -o -name \"*.txt\" | head -50","description":"List all files in Fireside multitrack module"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":12370,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":12370,"ephemeral_1h_input_tokens":0},"output_tokens":170,"service_tier":"standard"}},"requestId":"req_011CWTqpEkcxfxPwQi4HML2t","type":"assistant","uuid":"ac2e445d-b83a-49f4-80c9-d12537d10d4a","timestamp":"2025-12-25T18:00:53.502Z"}
{"parentUuid":"ac2e445d-b83a-49f4-80c9-d12537d10d4a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012ni1FJgmY19eFNsWt16n6X","type":"tool_result","content":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/main_clean.js\n/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/listeners.js\n/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/ui_clean.js\n/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/helpers_clean.js","is_error":false}]},"uuid":"3ae88cc8-4d95-4465-921a-5146a8666ac4","timestamp":"2025-12-25T18:00:53.602Z","toolUseResult":{"stdout":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/main_clean.js\n/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/listeners.js\n/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/ui_clean.js\n/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/helpers_clean.js","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"3ae88cc8-4d95-4465-921a-5146a8666ac4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015BfTHFEbZk8mmhmCHt5W9X","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read all four files to understand their implementation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":327,"cache_read_input_tokens":12370,"cache_creation":{"ephemeral_5m_input_tokens":327,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWTqpPBP4HcTAm5NxtKh4","type":"assistant","uuid":"401b496c-6bce-434e-a042-bd8a9fcc47cb","timestamp":"2025-12-25T18:00:54.725Z"}
{"parentUuid":"401b496c-6bce-434e-a042-bd8a9fcc47cb","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015BfTHFEbZk8mmhmCHt5W9X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012Y3w4QdNZ4Zgen6E3TSfzq","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/main_clean.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":327,"cache_read_input_tokens":12370,"cache_creation":{"ephemeral_5m_input_tokens":327,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWTqpPBP4HcTAm5NxtKh4","type":"assistant","uuid":"ca0dec74-5916-4b29-8801-a3723ff938b4","timestamp":"2025-12-25T18:00:54.957Z"}
{"parentUuid":"ca0dec74-5916-4b29-8801-a3723ff938b4","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015BfTHFEbZk8mmhmCHt5W9X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WbYNr31kvADZSawcjYVewi","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/listeners.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":327,"cache_read_input_tokens":12370,"cache_creation":{"ephemeral_5m_input_tokens":327,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWTqpPBP4HcTAm5NxtKh4","type":"assistant","uuid":"5e2a86b5-b4af-4197-b205-0804e02678df","timestamp":"2025-12-25T18:00:55.127Z"}
{"parentUuid":"5e2a86b5-b4af-4197-b205-0804e02678df","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015BfTHFEbZk8mmhmCHt5W9X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017bXeX4P16Dr9JoyL7bZeaT","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/ui_clean.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":327,"cache_read_input_tokens":12370,"cache_creation":{"ephemeral_5m_input_tokens":327,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWTqpPBP4HcTAm5NxtKh4","type":"assistant","uuid":"e8b5615a-b1e2-4fd7-8d22-afde9c008d16","timestamp":"2025-12-25T18:00:55.431Z"}
{"parentUuid":"e8b5615a-b1e2-4fd7-8d22-afde9c008d16","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","message":{"model":"claude-haiku-4-5-20251001","id":"msg_015BfTHFEbZk8mmhmCHt5W9X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VcimV5wU1fpbRi9qTMzpoi","name":"Read","input":{"file_path":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/helpers_clean.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":327,"cache_read_input_tokens":12370,"cache_creation":{"ephemeral_5m_input_tokens":327,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWTqpPBP4HcTAm5NxtKh4","type":"assistant","uuid":"e19bb538-5524-4918-b75b-b5fe01ee2fe7","timestamp":"2025-12-25T18:00:55.614Z"}
{"parentUuid":"e19bb538-5524-4918-b75b-b5fe01ee2fe7","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012Y3w4QdNZ4Zgen6E3TSfzq","type":"tool_result","content":"     1→async function multitrack_audio() {\n     2→    // License Verification\n     3→    const isValidLicense = await verify_license_throttled();\n     4→    if (!isValidLicense || !check_function_availability('multitrack_audio')) {\n     5→        showError('Please provide a valid license key in the Settings menu');\n     6→        return;\n     7→    }\n     8→\n     9→    // Schedule Log Upload\n    10→    test_52_schedule_log_upload(0); // Delay 0\n    11→\n    12→    regular_license_key_checker();\n    13→    await test_45_save_state('Before multitrack audio');\n    14→    await test_46_retrieve_undo_state_info();\n    15→\n    16→    const trackingId = tracker['start']('multitrack_audio');\n    17→\n    18→    try {\n    19→        showSpinner('Detecting silences for each track');\n    20→        let multitrack_parameters = await test_48_get_multitrack_params();\n    21→\n    22→        if (!multitrack_parameters['scopeValid']) {\n    23→            showError('Please ensure your In/Out points are valid');\n    24→            hideSpinner();\n    25→            return;\n    26→        }\n    27→\n    28→        // Determine method for removing silences (local processing vs JSX script)\n    29→        const method = (multitrack_parameters['method'] == 'original') ? 'jsx_and_compare' : 'local';\n    30→        const timeMethod = (multitrack_parameters['method'] == 'original') ? 'Seconds' : 'Frames';\n    31→\n    32→        // Loop through selected audio tracks\n    33→        const audioTrackIndices = multitrack_parameters['keyAudioTrackIndices'];\n    34→        for (let trackLoopIndex = 0; trackLoopIndex < audioTrackIndices['length']; trackLoopIndex++) {\n    35→            const trackIndex = audioTrackIndices[trackLoopIndex];\n    36→            const inPoint = multitrack_parameters['inPoint'];\n    37→            const outPoint = multitrack_parameters['outPoint'];\n    38→\n    39→            // Chunk duration constant (likely frames). 1800 frames @ 60fps = 30s, @ 30fps = 60s.\n    40→            const chunkDuration = 1800;\n    41→\n    42→            // Split the range into chunks to process sequentially\n    43→            const chunks = chunk(inPoint, outPoint, chunkDuration, false);\n    44→\n    45→            for (let chunkIndex = 0; chunkIndex < chunks['length']; chunkIndex++) {\n    46→                const chunkStart = chunks[chunkIndex][0];\n    47→                const chunkEnd = chunks[chunkIndex][1];\n    48→\n    49→                showSpinner('Detecting silences (Track ' + (trackLoopIndex + 1) + '/' + audioTrackIndices['length'] + ') — Chunk ' + (chunkIndex + 1) + '/' + chunks['length']);\n    50→\n    51→                // Set In Point in active sequence\n    52→                let jsxScript = 'app.project.activeSequence.setInPoint(' + chunkStart + ')';\n    53→                await new Promise(resolve => {\n    54→                    jsx['evalScript'](jsxScript, function (res) {\n    55→                        resolve(res);\n    56→                    });\n    57→                });\n    58→\n    59→                // Set Out Point in active sequence\n    60→                jsxScript = 'app.project.activeSequence.setOutPoint(' + chunkEnd + ')';\n    61→                await new Promise(resolve => {\n    62→                    jsx['evalScript'](jsxScript, function (res) {\n    63→                        resolve(res);\n    64→                    });\n    65→                });\n    66→\n    67→                // Detect silences in the current chunk\n    68→                const silenceResult = await test_39_detect_silences(\n    69→                    [trackIndex],\n    70→                    multitrack_parameters['min_silence_length'],\n    71→                    multitrack_parameters['threshold'],\n    72→                    'inout',\n    73→                    multitrack_parameters['format']\n    74→                );\n    75→\n    76→                let silentRanges = silenceResult?.['silentRanges'] || [];\n    77→                if (!silentRanges['length']) continue;\n    78→\n    79→                // Adjust ranges by adding the chunk start offset\n    80→                silentRanges = silentRanges['map'](range => [range[0] + chunkStart, range[1] + chunkStart]);\n    81→\n    82→                // Apply Padding to silent ranges\n    83→                const paddedRanges = silentRanges['map'](range => [\n    84→                    range[0] + multitrack_parameters['padding_start'] / 1000,\n    85→                    range[1] - multitrack_parameters['padding_end'] / 1000\n    86→                ]);\n    87→\n    88→                // Filter out invalid ranges (where start >= end)\n    89→                const filteredRanges = paddedRanges['filter'](range => range[0] < range[1]);\n    90→\n    91→                if (!filteredRanges['length']) continue;\n    92→\n    93→                // Remove the detected silences\n    94→                await remove_silences(\n    95→                    false, // showEndMessage\n    96→                    'advanced', // mode\n    97→                    filteredRanges, // silences\n    98→                    method,\n    99→                    timeMethod,\n   100→                    'disable', // operation\n   101→                    true, // single_track_mode\n   102→                    trackIndex,\n   103→                    'audio', // target_track_type\n   104→                    multitrack_parameters['disable_linked_video'] // affect_linked_tracks\n   105→                );\n   106→\n   107→                showSpinner('Detecting silences (Track ' + (trackLoopIndex + 1) + '/' + audioTrackIndices['length'] + ') — Chunk ' + (chunkIndex + 1) + '/' + chunks['length']);\n   108→            }\n   109→        }\n   110→    } catch (e) {\n   111→        handleErrorNotification(e);\n   112→    } finally {\n   113→        showMessage('Done!');\n   114→        hideSpinner();\n   115→        clear_abort_undo_state();\n   116→        tracker['end'](trackingId);\n   117→        test_52_schedule_log_upload(1000);\n   118→    }\n   119→}\n   120→\n   121→async function multitrack_video_analyze() {\n   122→    const isValidLicense = await verify_license_throttled();\n   123→    if (!isValidLicense || !check_function_availability('multitrack_video_analyze')) {\n   124→        showError('Please provide a valid license key in the Settings menu');\n   125→        return;\n   126→    }\n   127→\n   128→    test_52_schedule_log_upload(0);\n   129→    regular_license_key_checker();\n   130→    await test_45_save_state('Before multitrack video');\n   131→    await test_46_retrieve_undo_state_info();\n   132→\n   133→    const trackingId = tracker['start']('multitrack_video_analyze');\n   134→\n   135→    try {\n   136→        showSpinner();\n   137→        let displayParams = await test_48_get_multitrack_params();\n   138→\n   139→        if (!displayParams['scopeValid']) {\n   140→            showError('Please ensure your In/Out points are valid');\n   141→            hideSpinner();\n   142→            return;\n   143→        }\n   144→\n   145→        // Initialize random arrays for cutaway/shot logic\n   146→        g_shots_random_floats_array = Array.from({ length: 1000 }, () => Math.random());\n   147→        g_multicam_cutaway_random_floats_array = Array.from({ length: 1000 }, () => Math.random());\n   148→\n   149→        multitrack_readSpeakerNamesFromHTML(false); // empty_allowed = false\n   150→        multitrack_readVideoMappingSelections();\n   151→\n   152→        if (!test_52_validate_multitrack_selections()) {\n   153→            hideSpinner();\n   154→            return;\n   155→        }\n   156→\n   157→        let speakersIndices = Array.from(Array(g_num_speakers).keys());\n   158→        const inPt = displayParams['inPoint'];\n   159→        const outPt = displayParams['outPoint'];\n   160→        const chunkDuration = 1800;\n   161→\n   162→        const chunks = chunk(inPt, outPt, chunkDuration, false);\n   163→\n   164→        let audioLevels = Array.from({ length: g_num_speakers }, () => []);\n   165→        let averageAudioLevels = [];\n   166→        let allTimestamps = [];\n   167→\n   168→        for (let chunkIndex = 0; chunkIndex < chunks['length']; chunkIndex++) {\n   169→            const chunkStart = chunks[chunkIndex][0];\n   170→            const chunkEnd = chunks[chunkIndex][1];\n   171→\n   172→            // Set In/Out points for analysis\n   173→            var script = 'app.project.activeSequence.setInPoint(' + chunkStart + ')';\n   174→            await new Promise(resolve => { jsx.evalScript(script, function (res) { resolve(res); }); });\n   175→\n   176→            script = 'app.project.activeSequence.setOutPoint(' + chunkEnd + ')';\n   177→            await new Promise(resolve => { jsx.evalScript(script, function (res) { resolve(res); }); });\n   178→\n   179→            // Loop through speakers + 1 extra pass (which seems to be for the mix/average)\n   180→            for (let passIndex = 0; passIndex < speakersIndices['length'] + 1; passIndex++) {\n   181→                showSpinner('Analyzing audio ' + (passIndex + 1) + ' of ' + speakersIndices['length'] + ' (chunk ' + (chunkIndex + 1) + '/' + chunks['length'] + ')');\n   182→\n   183→                let currentMuteState = await new Promise((resolve, reject) => {\n   184→                    jsx.evalScript('getMuteState()', function (res) { resolve(JSON.parse(res)); });\n   185→                });\n   186→\n   187→                var workingMuteState = JSON.parse(JSON.stringify(currentMuteState));\n   188→\n   189→                if (passIndex < speakersIndices['length']) {\n   190→                    // Mute everyone EXCEPT speaker 'passIndex'\n   191→                    // The logic +!(idx == passIndex) means:\n   192→                    // if idx == passIndex -> !(true) = false -> +false = 0 (Unmuted)\n   193→                    // if idx != passIndex -> !(false) = true -> +true = 1 (Muted)\n   194→                    workingMuteState['audio'] = workingMuteState['audio'].map((val, idx) => +!(idx == passIndex));\n   195→\n   196→                } else {\n   197→                    // Extra pass: Unmute everything (set all to 0)\n   198→                    workingMuteState['audio'] = workingMuteState['audio'].map((val, idx) => 0);\n   199→                }\n   200→\n   201→                await new Promise((resolve) => {\n   202→                    jsx.evalScript('setMuteState(\\'' + JSON.stringify(workingMuteState) + '\\')', function (res) { resolve(res); });\n   203→                });\n   204→\n   205→                const exportedAudio = await test_1_extract_audio_from_sequence('inout', 'mp3-low');\n   206→                const rmsData = await test_50_get_RMS_array(exportedAudio, 'multitrack');\n   207→\n   208→                if (passIndex == 0) {\n   209→                    const timestamps = rmsData['x'].map(t => t + chunkStart);\n   210→                    allTimestamps = allTimestamps.concat(timestamps);\n   211→                }\n   212→\n   213→                if (passIndex < speakersIndices['length']) {\n   214→                    audioLevels[passIndex] = audioLevels[passIndex].concat(rmsData['y']);\n   215→                } else {\n   216→                    averageAudioLevels = averageAudioLevels.concat(rmsData['y']);\n   217→                }\n   218→            }\n   219→        }\n   220→\n   221→        g_audio_track_times = allTimestamps;\n   222→        showSpinner('Cleaning up audio levels...');\n   223→\n   224→        // Normalize/Cleanup levels: subtract \"average\" (noise floor?) from mix\n   225→        g_cleaned_up_levels = audioLevels.map(levels => levels.map((val, idx) => {\n   226→            const noise = averageAudioLevels[idx] ?? -100;\n   227→            let cleanVal = Math.min(Math.max(val - noise, -100), 0);\n   228→            if (isNaN(cleanVal)) cleanVal = -100;\n   229→            return cleanVal;\n   230→        }));\n   231→\n   232→        g_multitrack_decision_overrides = [];\n   233→        control_multitrack_wide_shots_tolerance_input();\n   234→        writeHTML_cutaway_checkboxes();\n   235→        writeHTML_multitrack_boosts();\n   236→\n   237→        if (multitrack_wide_shots_available()) {\n   238→            test_101_finetune_multitrack_wide_shot_tolerance();\n   239→        } else {\n   240→            test_51_decide_multicam_cuts();\n   241→        }\n   242→\n   243→        writeHTML_multitrack_decisions_table();\n   244→        update_multitrack_screentime_chart();\n   245→        open_menu('multitrack-video-results-list');\n   246→\n   247→    } catch (e) {\n   248→        handleErrorNotification(e);\n   249→    } finally {\n   250→        hideSpinner();\n   251→        clear_abort_undo_state();\n   252→        tracker['end'](trackingId);\n   253→        test_52_schedule_log_upload(0);\n   254→    }\n   255→}\n   256→\n   257→async function multitrack_video_cut() {\n   258→    if (!(await verify_license_throttled()) || !check_function_availability('multitrack_video_cut')) {\n   259→        showError('Please provide a valid license key in the Settings menu');\n   260→        return;\n   261→    }\n   262→\n   263→    test_52_schedule_log_upload(0);\n   264→    regular_license_key_checker();\n   265→    await test_45_save_state('Before multitrack video edit');\n   266→    await test_46_retrieve_undo_state_info();\n   267→\n   268→    const trackingId = tracker['start']('multitrack_video_cut');\n   269→\n   270→    try {\n   271→        let startT = g_multitrack_decisions[0]['time_range'][0];\n   272→        let endT = g_multitrack_decisions[g_multitrack_decisions.length - 1]['time_range'][1];\n   273→\n   274→        let decisions = JSON.parse(JSON.stringify(g_multitrack_decisions));\n   275→\n   276→        // Merge adjacent decisions if they use the same video index, to reduce number of cuts\n   277→        for (let i = 0; i < decisions.length - 1; i++) {\n   278→            if (decisions[i]['video_index'] == decisions[i + 1]['video_index'] &&\n   279→                decisions[i]['time_range'][1] == decisions[i + 1]['time_range'][0]) {\n   280→\n   281→                decisions[i]['time_range'][1] = decisions[i + 1]['time_range'][1];\n   282→                decisions.splice(i + 1, 1);\n   283→                i--;\n   284→            }\n   285→        }\n   286→\n   287→        // Map video selections to actual time ranges\n   288→        let clipsByTrack = Array(g_multitrack_video_mapping_selection_indices.length);\n   289→\n   290→        for (let mappingIndex = 0; mappingIndex < g_multitrack_video_mapping_selection_indices.length; mappingIndex++) {\n   291→            let ranges = [];\n   292→            for (let decisionIndex = 0; decisionIndex < decisions.length; decisionIndex++) {\n   293→                if (decisions[decisionIndex]['video_index'] == mappingIndex) {\n   294→                    ranges.push([decisions[decisionIndex]['time_range'][0], decisions[decisionIndex]['time_range'][1]]);\n   295→                }\n   296→            }\n   297→            if (g_multitrack_video_mapping_selection_indices[mappingIndex] == -1) {\n   298→                ranges = null;\n   299→            }\n   300→            clipsByTrack[mappingIndex] = ranges;\n   301→        }\n   302→\n   303→        // Calculate inverse segments (segments that should be REMOVED to keep only the selected clips)\n   304→        let inverseSegments = Array(g_multitrack_video_mapping_selection_indices.length);\n   305→        for (let trackIndex = 0; trackIndex < clipsByTrack.length; trackIndex++) {\n   306→            if (clipsByTrack[trackIndex] == null) {\n   307→                inverseSegments[trackIndex] = null;\n   308→            } else {\n   309→                inverseSegments[trackIndex] = test_44_get_inverse_segments(clipsByTrack[trackIndex], startT, endT);\n   310→            }\n   311→        }\n   312→\n   313→        let params = await test_48_get_multitrack_params();\n   314→        let deletionType = 'local';\n   315→        if (params['operation'] == 'delete') deletionType = 'jsx_and_compare';\n   316→\n   317→        // Apply edits to video tracks: Remove inverse segments\n   318→        for (let inverseIndex = 0; inverseIndex < inverseSegments.length; inverseIndex++) {\n   319→            if (inverseSegments[inverseIndex] != null && inverseSegments[inverseIndex].length > 0) {\n   320→                await remove_silences(\n   321→                    false, // showEndMessage\n   322→                    'advanced', // mode\n   323→                    inverseSegments[inverseIndex], // silences/removal ranges\n   324→                    deletionType, // method\n   325→                    'Frames', // time_method\n   326→                    params['operation'], // operation\n   327→                    true, // single_track_mode\n   328→                    inverseIndex, // target_track_index\n   329→                    'video', // type\n   330→                    false, // affect linked\n   331→                    0 // anchor\n   332→                );\n   333→            }\n   334→        }\n   335→\n   336→        // Handle Audio Muting if requested\n   337→        if (params['mute_audio']) {\n   338→            let consolidatedDecisions = [];\n   339→            if (g_multitrack_decisions.length) {\n   340→                consolidatedDecisions.push(g_multitrack_decisions[0]);\n   341→            }\n   342→\n   343→            // Re-consolidate decisions specifically for audio logic \n   344→            // (extending blocks if cutaway or same speaker)\n   345→            let writeIndex = 0;\n   346→            for (let readIndex = 1; readIndex < g_multitrack_decisions.length; readIndex++) {\n   347→                if (g_multitrack_decisions[readIndex]['reason'].includes('Cutaway') ||\n   348→                    g_multitrack_decisions[readIndex]['speaker'] === consolidatedDecisions[writeIndex]['speaker']) {\n   349→\n   350→                    consolidatedDecisions[writeIndex]['time_range'][1] = g_multitrack_decisions[readIndex]['time_range'][1];\n   351→                } else {\n   352→                    writeIndex++;\n   353→                    consolidatedDecisions.push(g_multitrack_decisions[readIndex]);\n   354→                }\n   355→            }\n   356→\n   357→            const speakerNameToIndex = {};\n   358→            g_multitrack_speaker_names.forEach((name, idx) => { speakerNameToIndex[name] = idx; });\n   359→\n   360→            let muteRangesBySpeaker = {};\n   361→            const allSpeakersIndices = Array.from(Array(g_num_speakers).keys());\n   362→\n   363→            for (let decisionIndex = 0; decisionIndex < consolidatedDecisions.length; decisionIndex++) {\n   364→                const videoIndex = consolidatedDecisions[decisionIndex]['video_index'];\n   365→                const speakersInVideo = g_multitrack_video_mapping[videoIndex];\n   366→\n   367→                // Mute speakers NOT in the current video angle\n   368→                const speakersToMute = allSpeakersIndices.filter(idx => !speakersInVideo.includes(idx));\n   369→\n   370→                for (let muteSpeakerIndex = 0; muteSpeakerIndex < speakersToMute.length; muteSpeakerIndex++) {\n   371→                    const speakerIdx = speakersToMute[muteSpeakerIndex];\n   372→                    if (muteRangesBySpeaker.hasOwnProperty(speakerIdx)) {\n   373→                        muteRangesBySpeaker[speakerIdx].push(consolidatedDecisions[decisionIndex]['time_range']);\n   374→                    } else {\n   375→                        muteRangesBySpeaker[speakerIdx] = [consolidatedDecisions[decisionIndex]['time_range']];\n   376→                    }\n   377→                }\n   378→            }\n   379→\n   380→            // Merge adjacent mute ranges for efficiency\n   381→            Object.keys(muteRangesBySpeaker).forEach(speakerIdxKey => {\n   382→                muteRangesBySpeaker[speakerIdxKey] = joinAndFlattenArrays(muteRangesBySpeaker[speakerIdxKey]);\n   383→            });\n   384→\n   385→            // Apply silences to audio tracks\n   386→            for (let rangeGroupIndex = 0; rangeGroupIndex < Object.keys(muteRangesBySpeaker).length; rangeGroupIndex++) {\n   387→                await remove_silences(\n   388→                    false, // showEndMessage\n   389→                    'advanced', // mode\n   390→                    muteRangesBySpeaker[rangeGroupIndex], // ranges to mute\n   391→                    deletionType,\n   392→                    'Frames',\n   393→                    params['operation'],\n   394→                    true, // single_track_mode\n   395→                    rangeGroupIndex, // target_track_index\n   396→                    'audio', // track type\n   397→                    false, // affect_linked_tracks\n   398→                    0 // anchor_every\n   399→                );\n   400→            }\n   401→        }\n   402→\n   403→    } catch (e) {\n   404→        handleErrorNotification(e);\n   405→    } finally {\n   406→        hideSpinner();\n   407→        clear_abort_undo_state();\n   408→        tracker['end'](trackingId);\n   409→        test_52_schedule_log_upload(0);\n   410→    }\n   411→}\n   412→\n   413→function joinAdjacentArrays(arr) {\n   414→    if (!arr || arr.length === 0) return [];\n   415→    const result = [];\n   416→    let currentGroup = [arr[0]];\n   417→\n   418→    for (let i = 1; i < arr.length; i++) {\n   419→        const lastGroup = currentGroup[currentGroup.length - 1];\n   420→        const currentItem = arr[i];\n   421→\n   422→        // Epsilon check for continuity\n   423→        const diff = Math.abs(lastGroup[1] - currentItem[0]);\n   424→        if (diff <= 0.0001) {\n   425→            currentGroup.push(currentItem);\n   426→        } else {\n   427→            result.push(currentGroup);\n   428→            currentGroup = [currentItem];\n   429→        }\n   430→    }\n   431→    result.push(currentGroup);\n   432→    return result;\n   433→}\n   434→\n   435→function joinAndFlattenArrays(arr) {\n   436→    const grouped = joinAdjacentArrays(arr);\n   437→    return grouped.map(group => {\n   438→        if (group.length === 1) return group[0];\n   439→        return [\n   440→            group[0][0], // Start of first\n   441→            group[group.length - 1][1] // End of last\n   442→        ];\n   443→    });\n   444→}\n   445→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"02c238dd-5785-40cf-a1c9-0da2ac1dffe8","timestamp":"2025-12-25T18:00:55.667Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/main_clean.js","content":"async function multitrack_audio() {\n    // License Verification\n    const isValidLicense = await verify_license_throttled();\n    if (!isValidLicense || !check_function_availability('multitrack_audio')) {\n        showError('Please provide a valid license key in the Settings menu');\n        return;\n    }\n\n    // Schedule Log Upload\n    test_52_schedule_log_upload(0); // Delay 0\n\n    regular_license_key_checker();\n    await test_45_save_state('Before multitrack audio');\n    await test_46_retrieve_undo_state_info();\n\n    const trackingId = tracker['start']('multitrack_audio');\n\n    try {\n        showSpinner('Detecting silences for each track');\n        let multitrack_parameters = await test_48_get_multitrack_params();\n\n        if (!multitrack_parameters['scopeValid']) {\n            showError('Please ensure your In/Out points are valid');\n            hideSpinner();\n            return;\n        }\n\n        // Determine method for removing silences (local processing vs JSX script)\n        const method = (multitrack_parameters['method'] == 'original') ? 'jsx_and_compare' : 'local';\n        const timeMethod = (multitrack_parameters['method'] == 'original') ? 'Seconds' : 'Frames';\n\n        // Loop through selected audio tracks\n        const audioTrackIndices = multitrack_parameters['keyAudioTrackIndices'];\n        for (let trackLoopIndex = 0; trackLoopIndex < audioTrackIndices['length']; trackLoopIndex++) {\n            const trackIndex = audioTrackIndices[trackLoopIndex];\n            const inPoint = multitrack_parameters['inPoint'];\n            const outPoint = multitrack_parameters['outPoint'];\n\n            // Chunk duration constant (likely frames). 1800 frames @ 60fps = 30s, @ 30fps = 60s.\n            const chunkDuration = 1800;\n\n            // Split the range into chunks to process sequentially\n            const chunks = chunk(inPoint, outPoint, chunkDuration, false);\n\n            for (let chunkIndex = 0; chunkIndex < chunks['length']; chunkIndex++) {\n                const chunkStart = chunks[chunkIndex][0];\n                const chunkEnd = chunks[chunkIndex][1];\n\n                showSpinner('Detecting silences (Track ' + (trackLoopIndex + 1) + '/' + audioTrackIndices['length'] + ') — Chunk ' + (chunkIndex + 1) + '/' + chunks['length']);\n\n                // Set In Point in active sequence\n                let jsxScript = 'app.project.activeSequence.setInPoint(' + chunkStart + ')';\n                await new Promise(resolve => {\n                    jsx['evalScript'](jsxScript, function (res) {\n                        resolve(res);\n                    });\n                });\n\n                // Set Out Point in active sequence\n                jsxScript = 'app.project.activeSequence.setOutPoint(' + chunkEnd + ')';\n                await new Promise(resolve => {\n                    jsx['evalScript'](jsxScript, function (res) {\n                        resolve(res);\n                    });\n                });\n\n                // Detect silences in the current chunk\n                const silenceResult = await test_39_detect_silences(\n                    [trackIndex],\n                    multitrack_parameters['min_silence_length'],\n                    multitrack_parameters['threshold'],\n                    'inout',\n                    multitrack_parameters['format']\n                );\n\n                let silentRanges = silenceResult?.['silentRanges'] || [];\n                if (!silentRanges['length']) continue;\n\n                // Adjust ranges by adding the chunk start offset\n                silentRanges = silentRanges['map'](range => [range[0] + chunkStart, range[1] + chunkStart]);\n\n                // Apply Padding to silent ranges\n                const paddedRanges = silentRanges['map'](range => [\n                    range[0] + multitrack_parameters['padding_start'] / 1000,\n                    range[1] - multitrack_parameters['padding_end'] / 1000\n                ]);\n\n                // Filter out invalid ranges (where start >= end)\n                const filteredRanges = paddedRanges['filter'](range => range[0] < range[1]);\n\n                if (!filteredRanges['length']) continue;\n\n                // Remove the detected silences\n                await remove_silences(\n                    false, // showEndMessage\n                    'advanced', // mode\n                    filteredRanges, // silences\n                    method,\n                    timeMethod,\n                    'disable', // operation\n                    true, // single_track_mode\n                    trackIndex,\n                    'audio', // target_track_type\n                    multitrack_parameters['disable_linked_video'] // affect_linked_tracks\n                );\n\n                showSpinner('Detecting silences (Track ' + (trackLoopIndex + 1) + '/' + audioTrackIndices['length'] + ') — Chunk ' + (chunkIndex + 1) + '/' + chunks['length']);\n            }\n        }\n    } catch (e) {\n        handleErrorNotification(e);\n    } finally {\n        showMessage('Done!');\n        hideSpinner();\n        clear_abort_undo_state();\n        tracker['end'](trackingId);\n        test_52_schedule_log_upload(1000);\n    }\n}\n\nasync function multitrack_video_analyze() {\n    const isValidLicense = await verify_license_throttled();\n    if (!isValidLicense || !check_function_availability('multitrack_video_analyze')) {\n        showError('Please provide a valid license key in the Settings menu');\n        return;\n    }\n\n    test_52_schedule_log_upload(0);\n    regular_license_key_checker();\n    await test_45_save_state('Before multitrack video');\n    await test_46_retrieve_undo_state_info();\n\n    const trackingId = tracker['start']('multitrack_video_analyze');\n\n    try {\n        showSpinner();\n        let displayParams = await test_48_get_multitrack_params();\n\n        if (!displayParams['scopeValid']) {\n            showError('Please ensure your In/Out points are valid');\n            hideSpinner();\n            return;\n        }\n\n        // Initialize random arrays for cutaway/shot logic\n        g_shots_random_floats_array = Array.from({ length: 1000 }, () => Math.random());\n        g_multicam_cutaway_random_floats_array = Array.from({ length: 1000 }, () => Math.random());\n\n        multitrack_readSpeakerNamesFromHTML(false); // empty_allowed = false\n        multitrack_readVideoMappingSelections();\n\n        if (!test_52_validate_multitrack_selections()) {\n            hideSpinner();\n            return;\n        }\n\n        let speakersIndices = Array.from(Array(g_num_speakers).keys());\n        const inPt = displayParams['inPoint'];\n        const outPt = displayParams['outPoint'];\n        const chunkDuration = 1800;\n\n        const chunks = chunk(inPt, outPt, chunkDuration, false);\n\n        let audioLevels = Array.from({ length: g_num_speakers }, () => []);\n        let averageAudioLevels = [];\n        let allTimestamps = [];\n\n        for (let chunkIndex = 0; chunkIndex < chunks['length']; chunkIndex++) {\n            const chunkStart = chunks[chunkIndex][0];\n            const chunkEnd = chunks[chunkIndex][1];\n\n            // Set In/Out points for analysis\n            var script = 'app.project.activeSequence.setInPoint(' + chunkStart + ')';\n            await new Promise(resolve => { jsx.evalScript(script, function (res) { resolve(res); }); });\n\n            script = 'app.project.activeSequence.setOutPoint(' + chunkEnd + ')';\n            await new Promise(resolve => { jsx.evalScript(script, function (res) { resolve(res); }); });\n\n            // Loop through speakers + 1 extra pass (which seems to be for the mix/average)\n            for (let passIndex = 0; passIndex < speakersIndices['length'] + 1; passIndex++) {\n                showSpinner('Analyzing audio ' + (passIndex + 1) + ' of ' + speakersIndices['length'] + ' (chunk ' + (chunkIndex + 1) + '/' + chunks['length'] + ')');\n\n                let currentMuteState = await new Promise((resolve, reject) => {\n                    jsx.evalScript('getMuteState()', function (res) { resolve(JSON.parse(res)); });\n                });\n\n                var workingMuteState = JSON.parse(JSON.stringify(currentMuteState));\n\n                if (passIndex < speakersIndices['length']) {\n                    // Mute everyone EXCEPT speaker 'passIndex'\n                    // The logic +!(idx == passIndex) means:\n                    // if idx == passIndex -> !(true) = false -> +false = 0 (Unmuted)\n                    // if idx != passIndex -> !(false) = true -> +true = 1 (Muted)\n                    workingMuteState['audio'] = workingMuteState['audio'].map((val, idx) => +!(idx == passIndex));\n\n                } else {\n                    // Extra pass: Unmute everything (set all to 0)\n                    workingMuteState['audio'] = workingMuteState['audio'].map((val, idx) => 0);\n                }\n\n                await new Promise((resolve) => {\n                    jsx.evalScript('setMuteState(\\'' + JSON.stringify(workingMuteState) + '\\')', function (res) { resolve(res); });\n                });\n\n                const exportedAudio = await test_1_extract_audio_from_sequence('inout', 'mp3-low');\n                const rmsData = await test_50_get_RMS_array(exportedAudio, 'multitrack');\n\n                if (passIndex == 0) {\n                    const timestamps = rmsData['x'].map(t => t + chunkStart);\n                    allTimestamps = allTimestamps.concat(timestamps);\n                }\n\n                if (passIndex < speakersIndices['length']) {\n                    audioLevels[passIndex] = audioLevels[passIndex].concat(rmsData['y']);\n                } else {\n                    averageAudioLevels = averageAudioLevels.concat(rmsData['y']);\n                }\n            }\n        }\n\n        g_audio_track_times = allTimestamps;\n        showSpinner('Cleaning up audio levels...');\n\n        // Normalize/Cleanup levels: subtract \"average\" (noise floor?) from mix\n        g_cleaned_up_levels = audioLevels.map(levels => levels.map((val, idx) => {\n            const noise = averageAudioLevels[idx] ?? -100;\n            let cleanVal = Math.min(Math.max(val - noise, -100), 0);\n            if (isNaN(cleanVal)) cleanVal = -100;\n            return cleanVal;\n        }));\n\n        g_multitrack_decision_overrides = [];\n        control_multitrack_wide_shots_tolerance_input();\n        writeHTML_cutaway_checkboxes();\n        writeHTML_multitrack_boosts();\n\n        if (multitrack_wide_shots_available()) {\n            test_101_finetune_multitrack_wide_shot_tolerance();\n        } else {\n            test_51_decide_multicam_cuts();\n        }\n\n        writeHTML_multitrack_decisions_table();\n        update_multitrack_screentime_chart();\n        open_menu('multitrack-video-results-list');\n\n    } catch (e) {\n        handleErrorNotification(e);\n    } finally {\n        hideSpinner();\n        clear_abort_undo_state();\n        tracker['end'](trackingId);\n        test_52_schedule_log_upload(0);\n    }\n}\n\nasync function multitrack_video_cut() {\n    if (!(await verify_license_throttled()) || !check_function_availability('multitrack_video_cut')) {\n        showError('Please provide a valid license key in the Settings menu');\n        return;\n    }\n\n    test_52_schedule_log_upload(0);\n    regular_license_key_checker();\n    await test_45_save_state('Before multitrack video edit');\n    await test_46_retrieve_undo_state_info();\n\n    const trackingId = tracker['start']('multitrack_video_cut');\n\n    try {\n        let startT = g_multitrack_decisions[0]['time_range'][0];\n        let endT = g_multitrack_decisions[g_multitrack_decisions.length - 1]['time_range'][1];\n\n        let decisions = JSON.parse(JSON.stringify(g_multitrack_decisions));\n\n        // Merge adjacent decisions if they use the same video index, to reduce number of cuts\n        for (let i = 0; i < decisions.length - 1; i++) {\n            if (decisions[i]['video_index'] == decisions[i + 1]['video_index'] &&\n                decisions[i]['time_range'][1] == decisions[i + 1]['time_range'][0]) {\n\n                decisions[i]['time_range'][1] = decisions[i + 1]['time_range'][1];\n                decisions.splice(i + 1, 1);\n                i--;\n            }\n        }\n\n        // Map video selections to actual time ranges\n        let clipsByTrack = Array(g_multitrack_video_mapping_selection_indices.length);\n\n        for (let mappingIndex = 0; mappingIndex < g_multitrack_video_mapping_selection_indices.length; mappingIndex++) {\n            let ranges = [];\n            for (let decisionIndex = 0; decisionIndex < decisions.length; decisionIndex++) {\n                if (decisions[decisionIndex]['video_index'] == mappingIndex) {\n                    ranges.push([decisions[decisionIndex]['time_range'][0], decisions[decisionIndex]['time_range'][1]]);\n                }\n            }\n            if (g_multitrack_video_mapping_selection_indices[mappingIndex] == -1) {\n                ranges = null;\n            }\n            clipsByTrack[mappingIndex] = ranges;\n        }\n\n        // Calculate inverse segments (segments that should be REMOVED to keep only the selected clips)\n        let inverseSegments = Array(g_multitrack_video_mapping_selection_indices.length);\n        for (let trackIndex = 0; trackIndex < clipsByTrack.length; trackIndex++) {\n            if (clipsByTrack[trackIndex] == null) {\n                inverseSegments[trackIndex] = null;\n            } else {\n                inverseSegments[trackIndex] = test_44_get_inverse_segments(clipsByTrack[trackIndex], startT, endT);\n            }\n        }\n\n        let params = await test_48_get_multitrack_params();\n        let deletionType = 'local';\n        if (params['operation'] == 'delete') deletionType = 'jsx_and_compare';\n\n        // Apply edits to video tracks: Remove inverse segments\n        for (let inverseIndex = 0; inverseIndex < inverseSegments.length; inverseIndex++) {\n            if (inverseSegments[inverseIndex] != null && inverseSegments[inverseIndex].length > 0) {\n                await remove_silences(\n                    false, // showEndMessage\n                    'advanced', // mode\n                    inverseSegments[inverseIndex], // silences/removal ranges\n                    deletionType, // method\n                    'Frames', // time_method\n                    params['operation'], // operation\n                    true, // single_track_mode\n                    inverseIndex, // target_track_index\n                    'video', // type\n                    false, // affect linked\n                    0 // anchor\n                );\n            }\n        }\n\n        // Handle Audio Muting if requested\n        if (params['mute_audio']) {\n            let consolidatedDecisions = [];\n            if (g_multitrack_decisions.length) {\n                consolidatedDecisions.push(g_multitrack_decisions[0]);\n            }\n\n            // Re-consolidate decisions specifically for audio logic \n            // (extending blocks if cutaway or same speaker)\n            let writeIndex = 0;\n            for (let readIndex = 1; readIndex < g_multitrack_decisions.length; readIndex++) {\n                if (g_multitrack_decisions[readIndex]['reason'].includes('Cutaway') ||\n                    g_multitrack_decisions[readIndex]['speaker'] === consolidatedDecisions[writeIndex]['speaker']) {\n\n                    consolidatedDecisions[writeIndex]['time_range'][1] = g_multitrack_decisions[readIndex]['time_range'][1];\n                } else {\n                    writeIndex++;\n                    consolidatedDecisions.push(g_multitrack_decisions[readIndex]);\n                }\n            }\n\n            const speakerNameToIndex = {};\n            g_multitrack_speaker_names.forEach((name, idx) => { speakerNameToIndex[name] = idx; });\n\n            let muteRangesBySpeaker = {};\n            const allSpeakersIndices = Array.from(Array(g_num_speakers).keys());\n\n            for (let decisionIndex = 0; decisionIndex < consolidatedDecisions.length; decisionIndex++) {\n                const videoIndex = consolidatedDecisions[decisionIndex]['video_index'];\n                const speakersInVideo = g_multitrack_video_mapping[videoIndex];\n\n                // Mute speakers NOT in the current video angle\n                const speakersToMute = allSpeakersIndices.filter(idx => !speakersInVideo.includes(idx));\n\n                for (let muteSpeakerIndex = 0; muteSpeakerIndex < speakersToMute.length; muteSpeakerIndex++) {\n                    const speakerIdx = speakersToMute[muteSpeakerIndex];\n                    if (muteRangesBySpeaker.hasOwnProperty(speakerIdx)) {\n                        muteRangesBySpeaker[speakerIdx].push(consolidatedDecisions[decisionIndex]['time_range']);\n                    } else {\n                        muteRangesBySpeaker[speakerIdx] = [consolidatedDecisions[decisionIndex]['time_range']];\n                    }\n                }\n            }\n\n            // Merge adjacent mute ranges for efficiency\n            Object.keys(muteRangesBySpeaker).forEach(speakerIdxKey => {\n                muteRangesBySpeaker[speakerIdxKey] = joinAndFlattenArrays(muteRangesBySpeaker[speakerIdxKey]);\n            });\n\n            // Apply silences to audio tracks\n            for (let rangeGroupIndex = 0; rangeGroupIndex < Object.keys(muteRangesBySpeaker).length; rangeGroupIndex++) {\n                await remove_silences(\n                    false, // showEndMessage\n                    'advanced', // mode\n                    muteRangesBySpeaker[rangeGroupIndex], // ranges to mute\n                    deletionType,\n                    'Frames',\n                    params['operation'],\n                    true, // single_track_mode\n                    rangeGroupIndex, // target_track_index\n                    'audio', // track type\n                    false, // affect_linked_tracks\n                    0 // anchor_every\n                );\n            }\n        }\n\n    } catch (e) {\n        handleErrorNotification(e);\n    } finally {\n        hideSpinner();\n        clear_abort_undo_state();\n        tracker['end'](trackingId);\n        test_52_schedule_log_upload(0);\n    }\n}\n\nfunction joinAdjacentArrays(arr) {\n    if (!arr || arr.length === 0) return [];\n    const result = [];\n    let currentGroup = [arr[0]];\n\n    for (let i = 1; i < arr.length; i++) {\n        const lastGroup = currentGroup[currentGroup.length - 1];\n        const currentItem = arr[i];\n\n        // Epsilon check for continuity\n        const diff = Math.abs(lastGroup[1] - currentItem[0]);\n        if (diff <= 0.0001) {\n            currentGroup.push(currentItem);\n        } else {\n            result.push(currentGroup);\n            currentGroup = [currentItem];\n        }\n    }\n    result.push(currentGroup);\n    return result;\n}\n\nfunction joinAndFlattenArrays(arr) {\n    const grouped = joinAdjacentArrays(arr);\n    return grouped.map(group => {\n        if (group.length === 1) return group[0];\n        return [\n            group[0][0], // Start of first\n            group[group.length - 1][1] // End of last\n        ];\n    });\n}\n","numLines":445,"startLine":1,"totalLines":445}}}
{"parentUuid":"02c238dd-5785-40cf-a1c9-0da2ac1dffe8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WbYNr31kvADZSawcjYVewi","type":"tool_result","content":"     1→/**\n     2→ * Listeners for the Multitrack Editor\n     3→ * This file handles user interactions for the multitrack editing features,\n     4→ * including time navigation, manual overrides, scrolling, audio thresholds,\n     5→ * video track settings, and decision modifiers.\n     6→ */\n     7→\n     8→/**\n     9→ * Sets listeners for jumping to specific decision points in the timeline.\n    10→ * Triggered when clicking on the time section of a multitrack video button.\n    11→ */\n    12→function set_multitrack_go_to_time_listeners() {\n    13→    $('.button-multitrack-video-time-section').on('click', function (event) {\n    14→        // Parse the decision number from the button's attribute\n    15→        let decisionNumber = parseInt($(this).parent().parent().attr('multitrack-video-decision-number'));\n    16→\n    17→        // Jump to the specific decision in the timeline\n    18→        select_multitrack_decision_number(decisionNumber);\n    19→\n    20→        // Remove focus from the button\n    21→        $(this).blur();\n    22→\n    23→        // Track the event\n    24→        tracker.event('GO TO MULTITRACK DECISION: Decision number: ' + decisionNumber);\n    25→    });\n    26→}\n    27→\n    28→/**\n    29→ * Sets listeners for manually changing video tracks (decisions).\n    30→ * Handles clicking on individual video buttons in the decision list.\n    31→ */\n    32→function set_multitrack_manual_listeners() {\n    33→    // Unbind existing listeners to prevent duplicates\n    34→    $('.multitrack-manual-video-track-button').off('click');\n    35→\n    36→    // Listener for manual video track buttons\n    37→    $('.multitrack-manual-video-track-button').on('click', function (event) {\n    38→        // Find the parent row element\n    39→        let rowElement = $(this).closest('.multitrack-video-table-row');\n    40→        console.log('Row element: ', rowElement);\n    41→\n    42→        // Calculate the decision index (0-based) from the 1-based decision number\n    43→        // Formula from obfuscated code: -0x699*0x3+0xc1*-0x1c+0x28e8 = -5067 - 5404 + 10472 = 1\n    44→        // So it's parseInt(attr) - 1\n    45→        let decisionIndex = parseInt(rowElement.attr('multitrack-video-decision-number')) - 1;\n    46→        console.log('Decision index: ', decisionIndex);\n    47→\n    48→        // Show the list of available video angles for this decision\n    49→        multitrack_decisions_show_video_switch_list(decisionIndex);\n    50→\n    51→        // Remove focus\n    52→        $(this).blur();\n    53→    });\n    54→\n    55→    // Listener for resetting all overrides\n    56→    $('#multitrack-video-reset-overrides').off('click');\n    57→    $('#multitrack-video-reset-overrides').on('click', function (event) {\n    58→        // Clear all manual overrides\n    59→        g_multitrack_decision_overrides = [];\n    60→\n    61→        // Re-run the decision logic\n    62→        if (multitrack_wide_shots_available()) {\n    63→            test_101_finetune_multitrack_wide_shot_tolerance();\n    64→        } else {\n    65→            test_51_decide_multicam_cuts();\n    66→        }\n    67→\n    68→        // Update the UI\n    69→        writeHTML_multitrack_decisions_table();\n    70→        update_multitrack_screentime_chart();\n    71→    });\n    72→}\n    73→\n    74→/**\n    75→ * Sets listeners for the scroll synchronization and preview buttons.\n    76→ */\n    77→function set_multitrack_scroll_listeners() {\n    78→    $('#button-multivideo-show-preview').off('click');\n    79→    $('#button-multivideo-show-preview').on('click', function (event) {\n    80→        // Animate scroll to the top of the multitrack video table\n    81→        // Offset calculation from obfuscated code: 0x5b3*-0x2+-0xceb*-0x3+-0x1b42\n    82→        // -2918 + 9921 - 6978 = 25\n    83→        $('html, body').animate({\n    84→            'scrollTop': $('#multitrack-video-table').offset().top - 25\n    85→        });\n    86→    });\n    87→}\n    88→\n    89→/**\n    90→ * Sets listeners for audio threshold controls.\n    91→ * Handles validation and updates for the custom audio threshold input.\n    92→ */\n    93→function set_multitrack_audio_listeners() {\n    94→    // Sync range slider to number input\n    95→    $('#range-multitrack-audio-custom-threshold').on('input', function (event) {\n    96→        const value = $(this).val();\n    97→        $('#value-multitrack-audio-custom-threshold').val(value);\n    98→        $('#value-multitrack-audio-custom-threshold').removeClass('text-red-300 focus:text-red-700');\n    99→    });\n   100→\n   101→    // Validation for number input\n   102→    $('#value-multitrack-audio-custom-threshold').on('input', function (event) {\n   103→        const value = parseInt($(this).val());\n   104→\n   105→        // Check if value is a valid number and within range [-100, 0]\n   106→        // Lower bound: -(-0x26ee*0x1+0x1*-0x26f3+0x4e45) = -(-9966 - 9971 + 20037) = -100\n   107→        // Upper bound: 0x9*0x231+0x493*0x5+0x178*-0x1d = 5049 + 5855 - 10904 = 0\n   108→        if (!isNaN(value) && value >= -100 && value <= 0) {\n   109→            console.log('New VALID value typed for threshold: ', value);\n   110→            $('#range-multitrack-audio-custom-threshold').val(value);\n   111→            $('#value-multitrack-audio-custom-threshold').val(value);\n   112→            $('#value-multitrack-audio-custom-threshold').removeClass('text-red-300 focus:text-red-700');\n   113→        } else {\n   114→            console.log('INVALID value for threshold: ', value);\n   115→            $('#value-multitrack-audio-custom-threshold').addClass('text-red-300 focus:text-red-700');\n   116→        }\n   117→    });\n   118→\n   119→    // Blur input on Enter key\n   120→    $('#value-multitrack-audio-custom-threshold').on('keyup', function (event) {\n   121→        // 0x1*-0x1cc6+-0xff8*-0x1+0xcdb = -7366 + 4088 + 3291 = 13 (Enter key) -- Wait calc might be wrong in thought trace but 13 is standard.\n   122→        // Re-verifying logic: 7366 is 0x1cc6. 4088 is 0xff8. 3291 is 0xcdb.\n   123→        // -7366 + 4088 + 3291 = 13. Correct.\n   124→        if (event.keyCode === 13) {\n   125→            $(this).blur();\n   126→        }\n   127→    });\n   128→}\n   129→\n   130→/**\n   131→ * Sets listeners for managing video track names and speakers.\n   132→ */\n   133→function set_multitrack_video_listeners() {\n   134→    // Redraw selection UI when audio names change\n   135→    $('#multitrack-video-audio-names input').on('input', function (event) {\n   136→        console.log('Multitrack-video audio name: Input change!');\n   137→        writeHTML_multitrack_videoTrackSelect();\n   138→    });\n   139→\n   140→    // Delete speaker button\n   141→    $('.button-multitrack-video-speaker-delete').on('click', function (event) {\n   142→        $(this).parent().remove();\n   143→        $('#button-multitrack-add-speaker').removeClass('hidden');\n   144→        showMultiTrackSelection();\n   145→    });\n   146→\n   147→    // Add speaker button\n   148→    $('#button-multitrack-add-speaker').on('click', function (event) {\n   149→        $('#multitrack-video-audio-names').append('<input type=\\'text\\' style=\\'display:none;width:0px;height:0px\\'>');\n   150→        showMultiTrackSelection();\n   151→    });\n   152→}\n   153→\n   154→/**\n   155→ * Sets listeners for various decision modifiers (sliders and checkboxes).\n   156→ * These controls affect how the multitrack editing algorithm behaves.\n   157→ */\n   158→function reset_multitrack_decision_modifiers_listeners() {\n   159→    // Define the correct update logic based on available shots\n   160→    const runUpdateLogic = () => {\n   161→        try {\n   162→            if (multitrack_wide_shots_available()) {\n   163→                test_101_finetune_multitrack_wide_shot_tolerance();\n   164→            } else {\n   165→                test_51_decide_multicam_cuts();\n   166→            }\n   167→            writeHTML_multitrack_decisions_table();\n   168→            update_multitrack_screentime_chart();\n   169→        } catch (error) {\n   170→            console.log('Error in reset_multitrack_decision_modifiers_listeners: ', error);\n   171→        }\n   172→    };\n   173→\n   174→    // Range sliders (mouse up triggers recalculation)\n   175→    const rangeSelectors = '#range-multitrack-switching-frequency, #range-multitrack-switching-minimum-shot-duration, #range-multitrack-wide-shot-percentage, #range-multitrack-wide-shot-tolerance, #range-multitrack-max-time, #range-multitrack-cutaway-duration, .range-multitrack-boost';\n   176→\n   177→    $(rangeSelectors).off('mouseup');\n   178→    $(rangeSelectors).on('mouseup', function (event) {\n   179→        runUpdateLogic();\n   180→    });\n   181→\n   182→    // Checkboxes (input change triggers recalculation and UI toggles)\n   183→    const checkboxSelectors = '#checkbox-multitrack-cutaways, #checkbox-multitrack-boost, .checkbox-cutaway-video-track';\n   184→\n   185→    $(checkboxSelectors).off('input');\n   186→    $(checkboxSelectors).on('input', function (event) {\n   187→        // Toggle advanced cutaway options\n   188→        if ($('#checkbox-multitrack-cutaways').is(':checked')) {\n   189→            $('#multitrack-cutaways-advanced').removeClass('hidden');\n   190→        } else {\n   191→            $('#multitrack-cutaways-advanced').addClass('hidden');\n   192→        }\n   193→\n   194→        // Toggle advanced boost options\n   195→        if ($('#checkbox-multitrack-boost').is(':checked')) {\n   196→            $('#multitrack-boost-advanced').removeClass('hidden');\n   197→        } else {\n   198→            $('#multitrack-boost-advanced').addClass('hidden');\n   199→        }\n   200→\n   201→        runUpdateLogic();\n   202→    });\n   203→\n   204→    // Individual slider value updates (sync text display)\n   205→\n   206→    // Switching frequency\n   207→    $('#range-multitrack-switching-frequency').off('input');\n   208→    $('#range-multitrack-switching-frequency').on('input', function (event) {\n   209→        $('#value-multitrack-switching-frequency').text(parseInt($(this).val()));\n   210→    });\n   211→\n   212→    // Minimum shot duration\n   213→    $('#range-multitrack-switching-minimum-shot-duration').off('input');\n   214→    $('#range-multitrack-switching-minimum-shot-duration').on('input', function (event) {\n   215→        $('#value-multitrack-switching-minimum-shot-duration').text(parseFloat($(this).val()));\n   216→    });\n   217→\n   218→    // Broad shot tolerance\n   219→    $('#range-multitrack-wide-shot-tolerance').off('input');\n   220→    $('#range-multitrack-wide-shot-tolerance').on('input', function (event) {\n   221→        $('#value-multitrack-wide-shot-tolerance').text(parseInt($(this).val()));\n   222→    });\n   223→\n   224→    // Broad shot percentage\n   225→    $('#range-multitrack-wide-shot-percentage').off('input');\n   226→    $('#range-multitrack-wide-shot-percentage').on('input', function (event) {\n   227→        $('#value-multitrack-wide-shot-percentage').text(parseInt($(this).val()));\n   228→    });\n   229→\n   230→    // Max time\n   231→    $('#range-multitrack-max-time').off('input');\n   232→    $('#range-multitrack-max-time').on('input', function (event) {\n   233→        $('#value-multitrack-max-time').text(parseInt($(this).val()));\n   234→    });\n   235→\n   236→    // Cutaway duration\n   237→    $('#range-multitrack-cutaway-duration').off('input');\n   238→    $('#range-multitrack-cutaway-duration').on('input', function (event) {\n   239→        $('#value-multitrack-cutaway-duration').text(parseInt($(this).val()));\n   240→    });\n   241→\n   242→    // Cutaway length range (special handling with debounce)\n   243→    $('#range-cutaway-length').off('input');\n   244→    $('#range-cutaway-length').on('input', function (event) {\n   245→        // Update display text \"min-max\"\n   246→        const minVal = parseInt($('#range-cutaway-length').attr('data-value-min'));\n   247→        const maxVal = parseInt($('#range-cutaway-length').attr('data-value-max'));\n   248→        $('#value-multitrack-cutaway-duration').text(minVal + '-' + maxVal);\n   249→\n   250→        // Debounce the heavy update logic\n   251→        // Delay calc: -0x155d+-0x1786*-0x1+-0x35 = -5469 + 6022 - 53 = 500ms\n   252→        if (g_cutaway_timeout) window.clearTimeout(g_cutaway_timeout);\n   253→        g_cutaway_timeout = window.setTimeout(() => {\n   254→            runUpdateLogic();\n   255→        }, 500);\n   256→    });\n   257→}\n   258→\n   259→/**\n   260→ * Sets listeners for the settings menu.\n   261→ */\n   262→function set_multitrack_settings_listeners() {\n   263→    $('[name=\\'setting-multitrack-audio-threshold-method\\']').on('input', function (event) {\n   264→        if ($(this).attr('id') == 'setting-multitrack-audio-threshold-method-custom') {\n   265→            $('#container-multitrack-audio-custom-threshold').removeClass('hidden');\n   266→        } else {\n   267→            $('#container-multitrack-audio-custom-threshold').addClass('hidden');\n   268→        }\n   269→    });\n   270→}\n   271→\n   272→/**\n   273→ * Sets the listener for the Auto-Balance button.\n   274→ * Uses an algorithm to automatically tune multitrack distribution.\n   275→ */\n   276→function set_multitrack_auto_balance_listener() {\n   277→    $('#button-multitrack-auto-balance').off('click');\n   278→    $('#button-multitrack-auto-balance').on('click', async function (event) {\n   279→        try {\n   280→            await test_102_auto_tune_multitrack_distribution();\n   281→            writeHTML_multitrack_decisions_table();\n   282→            update_multitrack_screentime_chart();\n   283→            $(this).blur();\n   284→        } catch (error) {\n   285→            console.log('Error in auto-balance:', error);\n   286→            handleErrorNotification(error);\n   287→        }\n   288→    });\n   289→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c9dfdc19-0310-4e8f-9012-56b028710c01","timestamp":"2025-12-25T18:00:55.667Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/listeners.js","content":"/**\n * Listeners for the Multitrack Editor\n * This file handles user interactions for the multitrack editing features,\n * including time navigation, manual overrides, scrolling, audio thresholds,\n * video track settings, and decision modifiers.\n */\n\n/**\n * Sets listeners for jumping to specific decision points in the timeline.\n * Triggered when clicking on the time section of a multitrack video button.\n */\nfunction set_multitrack_go_to_time_listeners() {\n    $('.button-multitrack-video-time-section').on('click', function (event) {\n        // Parse the decision number from the button's attribute\n        let decisionNumber = parseInt($(this).parent().parent().attr('multitrack-video-decision-number'));\n\n        // Jump to the specific decision in the timeline\n        select_multitrack_decision_number(decisionNumber);\n\n        // Remove focus from the button\n        $(this).blur();\n\n        // Track the event\n        tracker.event('GO TO MULTITRACK DECISION: Decision number: ' + decisionNumber);\n    });\n}\n\n/**\n * Sets listeners for manually changing video tracks (decisions).\n * Handles clicking on individual video buttons in the decision list.\n */\nfunction set_multitrack_manual_listeners() {\n    // Unbind existing listeners to prevent duplicates\n    $('.multitrack-manual-video-track-button').off('click');\n\n    // Listener for manual video track buttons\n    $('.multitrack-manual-video-track-button').on('click', function (event) {\n        // Find the parent row element\n        let rowElement = $(this).closest('.multitrack-video-table-row');\n        console.log('Row element: ', rowElement);\n\n        // Calculate the decision index (0-based) from the 1-based decision number\n        // Formula from obfuscated code: -0x699*0x3+0xc1*-0x1c+0x28e8 = -5067 - 5404 + 10472 = 1\n        // So it's parseInt(attr) - 1\n        let decisionIndex = parseInt(rowElement.attr('multitrack-video-decision-number')) - 1;\n        console.log('Decision index: ', decisionIndex);\n\n        // Show the list of available video angles for this decision\n        multitrack_decisions_show_video_switch_list(decisionIndex);\n\n        // Remove focus\n        $(this).blur();\n    });\n\n    // Listener for resetting all overrides\n    $('#multitrack-video-reset-overrides').off('click');\n    $('#multitrack-video-reset-overrides').on('click', function (event) {\n        // Clear all manual overrides\n        g_multitrack_decision_overrides = [];\n\n        // Re-run the decision logic\n        if (multitrack_wide_shots_available()) {\n            test_101_finetune_multitrack_wide_shot_tolerance();\n        } else {\n            test_51_decide_multicam_cuts();\n        }\n\n        // Update the UI\n        writeHTML_multitrack_decisions_table();\n        update_multitrack_screentime_chart();\n    });\n}\n\n/**\n * Sets listeners for the scroll synchronization and preview buttons.\n */\nfunction set_multitrack_scroll_listeners() {\n    $('#button-multivideo-show-preview').off('click');\n    $('#button-multivideo-show-preview').on('click', function (event) {\n        // Animate scroll to the top of the multitrack video table\n        // Offset calculation from obfuscated code: 0x5b3*-0x2+-0xceb*-0x3+-0x1b42\n        // -2918 + 9921 - 6978 = 25\n        $('html, body').animate({\n            'scrollTop': $('#multitrack-video-table').offset().top - 25\n        });\n    });\n}\n\n/**\n * Sets listeners for audio threshold controls.\n * Handles validation and updates for the custom audio threshold input.\n */\nfunction set_multitrack_audio_listeners() {\n    // Sync range slider to number input\n    $('#range-multitrack-audio-custom-threshold').on('input', function (event) {\n        const value = $(this).val();\n        $('#value-multitrack-audio-custom-threshold').val(value);\n        $('#value-multitrack-audio-custom-threshold').removeClass('text-red-300 focus:text-red-700');\n    });\n\n    // Validation for number input\n    $('#value-multitrack-audio-custom-threshold').on('input', function (event) {\n        const value = parseInt($(this).val());\n\n        // Check if value is a valid number and within range [-100, 0]\n        // Lower bound: -(-0x26ee*0x1+0x1*-0x26f3+0x4e45) = -(-9966 - 9971 + 20037) = -100\n        // Upper bound: 0x9*0x231+0x493*0x5+0x178*-0x1d = 5049 + 5855 - 10904 = 0\n        if (!isNaN(value) && value >= -100 && value <= 0) {\n            console.log('New VALID value typed for threshold: ', value);\n            $('#range-multitrack-audio-custom-threshold').val(value);\n            $('#value-multitrack-audio-custom-threshold').val(value);\n            $('#value-multitrack-audio-custom-threshold').removeClass('text-red-300 focus:text-red-700');\n        } else {\n            console.log('INVALID value for threshold: ', value);\n            $('#value-multitrack-audio-custom-threshold').addClass('text-red-300 focus:text-red-700');\n        }\n    });\n\n    // Blur input on Enter key\n    $('#value-multitrack-audio-custom-threshold').on('keyup', function (event) {\n        // 0x1*-0x1cc6+-0xff8*-0x1+0xcdb = -7366 + 4088 + 3291 = 13 (Enter key) -- Wait calc might be wrong in thought trace but 13 is standard.\n        // Re-verifying logic: 7366 is 0x1cc6. 4088 is 0xff8. 3291 is 0xcdb.\n        // -7366 + 4088 + 3291 = 13. Correct.\n        if (event.keyCode === 13) {\n            $(this).blur();\n        }\n    });\n}\n\n/**\n * Sets listeners for managing video track names and speakers.\n */\nfunction set_multitrack_video_listeners() {\n    // Redraw selection UI when audio names change\n    $('#multitrack-video-audio-names input').on('input', function (event) {\n        console.log('Multitrack-video audio name: Input change!');\n        writeHTML_multitrack_videoTrackSelect();\n    });\n\n    // Delete speaker button\n    $('.button-multitrack-video-speaker-delete').on('click', function (event) {\n        $(this).parent().remove();\n        $('#button-multitrack-add-speaker').removeClass('hidden');\n        showMultiTrackSelection();\n    });\n\n    // Add speaker button\n    $('#button-multitrack-add-speaker').on('click', function (event) {\n        $('#multitrack-video-audio-names').append('<input type=\\'text\\' style=\\'display:none;width:0px;height:0px\\'>');\n        showMultiTrackSelection();\n    });\n}\n\n/**\n * Sets listeners for various decision modifiers (sliders and checkboxes).\n * These controls affect how the multitrack editing algorithm behaves.\n */\nfunction reset_multitrack_decision_modifiers_listeners() {\n    // Define the correct update logic based on available shots\n    const runUpdateLogic = () => {\n        try {\n            if (multitrack_wide_shots_available()) {\n                test_101_finetune_multitrack_wide_shot_tolerance();\n            } else {\n                test_51_decide_multicam_cuts();\n            }\n            writeHTML_multitrack_decisions_table();\n            update_multitrack_screentime_chart();\n        } catch (error) {\n            console.log('Error in reset_multitrack_decision_modifiers_listeners: ', error);\n        }\n    };\n\n    // Range sliders (mouse up triggers recalculation)\n    const rangeSelectors = '#range-multitrack-switching-frequency, #range-multitrack-switching-minimum-shot-duration, #range-multitrack-wide-shot-percentage, #range-multitrack-wide-shot-tolerance, #range-multitrack-max-time, #range-multitrack-cutaway-duration, .range-multitrack-boost';\n\n    $(rangeSelectors).off('mouseup');\n    $(rangeSelectors).on('mouseup', function (event) {\n        runUpdateLogic();\n    });\n\n    // Checkboxes (input change triggers recalculation and UI toggles)\n    const checkboxSelectors = '#checkbox-multitrack-cutaways, #checkbox-multitrack-boost, .checkbox-cutaway-video-track';\n\n    $(checkboxSelectors).off('input');\n    $(checkboxSelectors).on('input', function (event) {\n        // Toggle advanced cutaway options\n        if ($('#checkbox-multitrack-cutaways').is(':checked')) {\n            $('#multitrack-cutaways-advanced').removeClass('hidden');\n        } else {\n            $('#multitrack-cutaways-advanced').addClass('hidden');\n        }\n\n        // Toggle advanced boost options\n        if ($('#checkbox-multitrack-boost').is(':checked')) {\n            $('#multitrack-boost-advanced').removeClass('hidden');\n        } else {\n            $('#multitrack-boost-advanced').addClass('hidden');\n        }\n\n        runUpdateLogic();\n    });\n\n    // Individual slider value updates (sync text display)\n\n    // Switching frequency\n    $('#range-multitrack-switching-frequency').off('input');\n    $('#range-multitrack-switching-frequency').on('input', function (event) {\n        $('#value-multitrack-switching-frequency').text(parseInt($(this).val()));\n    });\n\n    // Minimum shot duration\n    $('#range-multitrack-switching-minimum-shot-duration').off('input');\n    $('#range-multitrack-switching-minimum-shot-duration').on('input', function (event) {\n        $('#value-multitrack-switching-minimum-shot-duration').text(parseFloat($(this).val()));\n    });\n\n    // Broad shot tolerance\n    $('#range-multitrack-wide-shot-tolerance').off('input');\n    $('#range-multitrack-wide-shot-tolerance').on('input', function (event) {\n        $('#value-multitrack-wide-shot-tolerance').text(parseInt($(this).val()));\n    });\n\n    // Broad shot percentage\n    $('#range-multitrack-wide-shot-percentage').off('input');\n    $('#range-multitrack-wide-shot-percentage').on('input', function (event) {\n        $('#value-multitrack-wide-shot-percentage').text(parseInt($(this).val()));\n    });\n\n    // Max time\n    $('#range-multitrack-max-time').off('input');\n    $('#range-multitrack-max-time').on('input', function (event) {\n        $('#value-multitrack-max-time').text(parseInt($(this).val()));\n    });\n\n    // Cutaway duration\n    $('#range-multitrack-cutaway-duration').off('input');\n    $('#range-multitrack-cutaway-duration').on('input', function (event) {\n        $('#value-multitrack-cutaway-duration').text(parseInt($(this).val()));\n    });\n\n    // Cutaway length range (special handling with debounce)\n    $('#range-cutaway-length').off('input');\n    $('#range-cutaway-length').on('input', function (event) {\n        // Update display text \"min-max\"\n        const minVal = parseInt($('#range-cutaway-length').attr('data-value-min'));\n        const maxVal = parseInt($('#range-cutaway-length').attr('data-value-max'));\n        $('#value-multitrack-cutaway-duration').text(minVal + '-' + maxVal);\n\n        // Debounce the heavy update logic\n        // Delay calc: -0x155d+-0x1786*-0x1+-0x35 = -5469 + 6022 - 53 = 500ms\n        if (g_cutaway_timeout) window.clearTimeout(g_cutaway_timeout);\n        g_cutaway_timeout = window.setTimeout(() => {\n            runUpdateLogic();\n        }, 500);\n    });\n}\n\n/**\n * Sets listeners for the settings menu.\n */\nfunction set_multitrack_settings_listeners() {\n    $('[name=\\'setting-multitrack-audio-threshold-method\\']').on('input', function (event) {\n        if ($(this).attr('id') == 'setting-multitrack-audio-threshold-method-custom') {\n            $('#container-multitrack-audio-custom-threshold').removeClass('hidden');\n        } else {\n            $('#container-multitrack-audio-custom-threshold').addClass('hidden');\n        }\n    });\n}\n\n/**\n * Sets the listener for the Auto-Balance button.\n * Uses an algorithm to automatically tune multitrack distribution.\n */\nfunction set_multitrack_auto_balance_listener() {\n    $('#button-multitrack-auto-balance').off('click');\n    $('#button-multitrack-auto-balance').on('click', async function (event) {\n        try {\n            await test_102_auto_tune_multitrack_distribution();\n            writeHTML_multitrack_decisions_table();\n            update_multitrack_screentime_chart();\n            $(this).blur();\n        } catch (error) {\n            console.log('Error in auto-balance:', error);\n            handleErrorNotification(error);\n        }\n    });\n}","numLines":289,"startLine":1,"totalLines":289}}}
{"parentUuid":"c9dfdc19-0310-4e8f-9012-56b028710c01","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VcimV5wU1fpbRi9qTMzpoi","type":"tool_result","content":"     1→function test_51_decide_multicam_cuts(\n     2→  smoothing_window = null,\n     3→  cutaways_enabled = null,\n     4→  max_time = null,\n     5→  cutaway_min_len = null,\n     6→  cutaway_max_len = null,\n     7→  wide_shot_tolerance = null,\n     8→  Y = null,\n     9→  R = null,\n    10→) {\n    11→  const Z = {\n    12→    eahhi: function (T, u) {\n    13→      return T(u);\n    14→    },\n    15→    poGJN: \":checked\",\n    16→    WSbTq: function (T, u) {\n    17→      return T(u);\n    18→    },\n    19→    QxEvv: function (T, u) {\n    20→      return T(u);\n    21→    },\n    22→    ICkdl: function (T, u) {\n    23→      return T == u;\n    24→    },\n    25→    osEKp: function (T, u) {\n    26→      return T * u;\n    27→    },\n    28→    FyQAu: function (T, u) {\n    29→      return T - u;\n    30→    },\n    31→    ejgoS: function (T, u) {\n    32→      return T(u);\n    33→    },\n    34→    dJyIa: \"#range-mul\" + \"titrack-sw\" + \"itching-fr\" + \"equency\",\n    35→    rgXeY: function (T, u) {\n    36→      return T * u;\n    37→    },\n    38→    uzqrn: function (T, u) {\n    39→      return T / u;\n    40→    },\n    41→    GYHpJ: function (T, u) {\n    42→      return T(u);\n    43→    },\n    44→    ZyQaz: function (T, u) {\n    45→      return T == u;\n    46→    },\n    47→    jPpSw: function (T, u) {\n    48→      return T(u);\n    49→    },\n    50→    dqTGl: function (T, u) {\n    51→      return T(u);\n    52→    },\n    53→    mKziM: \"#range-mul\" + \"titrack-ma\" + \"x-time\",\n    54→    myBEI: function (T, u) {\n    55→      return T(u);\n    56→    },\n    57→    cfGQC: function (T, u) {\n    58→      return T(u);\n    59→    },\n    60→    RBBno: \"#range-cut\" + \"away-lengt\" + \"h\",\n    61→    DGYeb: function (T, u) {\n    62→      return T(u);\n    63→    },\n    64→    hWTRQ: function (T, u) {\n    65→      return T(u);\n    66→    },\n    67→    DbgUe: \"#checkbox-\" + \"multitrack\" + \"-cutaways\",\n    68→    DMzRS: function (T, u) {\n    69→      return T == u;\n    70→    },\n    71→    tzzOs: function (T, u) {\n    72→      return T(u);\n    73→    },\n    74→    jKijF: function (T, u) {\n    75→      return T(u);\n    76→    },\n    77→    jUiAE: \"#range-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\",\n    78→    OlIJH: function (T, u) {\n    79→      return T(u);\n    80→    },\n    81→    lavNG: \"#multitrac\" + \"max_time-video-cu\" + \"taway-trac\" + \"ks-list-to\",\n    82→    UNkJq: \".checkbox-\" + \"cutaway-vi\" + \"deo-track\",\n    83→    wUXJh: function (T, u) {\n    84→      return T(u);\n    85→    },\n    86→    Pflpz: \"#multitrac\" + \"max_time-video-cu\" + \"taway-trac\" + \"ks-list-fr\" + \"om\",\n    87→    dqYbn: function (T, u) {\n    88→      return T < u;\n    89→    },\n    90→    Pubka: function (T, u) {\n    91→      return T < u;\n    92→    },\n    93→    NPBxG: function (T, u) {\n    94→      return T === u;\n    95→    },\n    96→    xoKgM: function (T, u) {\n    97→      return T < u;\n    98→    },\n    99→    lSYAw: function (T, u) {\n   100→      return T < u;\n   101→    },\n   102→    hklwg: function (T, u) {\n   103→      return T > u;\n   104→    },\n   105→    yQEwl: function (T, u) {\n   106→      return T(u);\n   107→    },\n   108→    tTCtb: \"#checkbox-\" + \"multitrack\" + \"-boost\",\n   109→    iWatM: function (T, u) {\n   110→      return T < u;\n   111→    },\n   112→    newFU: function (T, u) {\n   113→      return T + u;\n   114→    },\n   115→    eeSYc: \"Error\\x20appl\" + \"ying\\x20speak\" + \"er\\x20boosts\",\n   116→    uctqB: function (T, u) {\n   117→      return T < u;\n   118→    },\n   119→    eMeje: function (T, u) {\n   120→      return T > u;\n   121→    },\n   122→    DveaP: function (T, u) {\n   123→      return T == u;\n   124→    },\n   125→    ZPEZf: function (T, u) {\n   126→      return T == u;\n   127→    },\n   128→    OWwpz: function (T, u) {\n   129→      return T - u;\n   130→    },\n   131→    QfdQD: function (T, u) {\n   132→      return T < u;\n   133→    },\n   134→    zhnnb: function (T, u) {\n   135→      return T != u;\n   136→    },\n   137→    mPXBr: function (T, u) {\n   138→      return T(u);\n   139→    },\n   140→    VpEls: \"#range-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\",\n   141→    Axtsu: function (T, u, P) {\n   142→      return T(u, P);\n   143→    },\n   144→    oAHsH: function (T, u) {\n   145→      return T > u;\n   146→    },\n   147→    pvASx: function (T, u) {\n   148→      return T < u;\n   149→    },\n   150→    ADnlS: function (T, u) {\n   151→      return T > u;\n   152→    },\n   153→    BOhlD: function (T, u) {\n   154→      return T == u;\n   155→    },\n   156→    cJKIa: \"Wide\\x20(mult\" + \".\\x20speakers\" + \")\",\n   157→    bhVBA: function (T, u) {\n   158→      return T - u;\n   159→    },\n   160→    EEMuI: function (T, u) {\n   161→      return T < u;\n   162→    },\n   163→    xiKKU: \"Error\\x20pick\" + \"ing\\x20wide\\x20s\" + \"hot\",\n   164→    lPuwu: function (T, u) {\n   165→      return T == u;\n   166→    },\n   167→    gsvFy: function (T, u) {\n   168→      return T - u;\n   169→    },\n   170→    JWjNa: function (T, u) {\n   171→      return T < u;\n   172→    },\n   173→    jknsx: function (T, u) {\n   174→      return T < u;\n   175→    },\n   176→    KVYOO: function (T, u) {\n   177→      return T - u;\n   178→    },\n   179→    gErNW: function (T, u) {\n   180→      return T + u;\n   181→    },\n   182→    PJQqS: function (T, u) {\n   183→      return T == u;\n   184→    },\n   185→    spyjr: function (T, u) {\n   186→      return T == u;\n   187→    },\n   188→    dnVfx: function (T, u) {\n   189→      return T + u;\n   190→    },\n   191→    FTfdQ: function (T, u) {\n   192→      return T + u;\n   193→    },\n   194→    thyho: function (T, u) {\n   195→      return T / u;\n   196→    },\n   197→    NTMqW: function (T, u) {\n   198→      return T < u;\n   199→    },\n   200→    CgNcL: function (T, u) {\n   201→      return T / u;\n   202→    },\n   203→    gldFo: function (T, u) {\n   204→      return T - u;\n   205→    },\n   206→    wZmQn: function (T, u) {\n   207→      return T == u;\n   208→    },\n   209→    aLrJM: function (T, u) {\n   210→      return T < u;\n   211→    },\n   212→    HAWbu: function (T, u) {\n   213→      return T > u;\n   214→    },\n   215→    eaoMK: function (T, u) {\n   216→      return T * u;\n   217→    },\n   218→    AAqvQ: function (T, u) {\n   219→      return T == u;\n   220→    },\n   221→    HKFuA: function (T, u) {\n   222→      return T * u;\n   223→    },\n   224→    WcJXk: function (T, u) {\n   225→      return T == u;\n   226→    },\n   227→    ZfJhu: function (T, u) {\n   228→      return T - u;\n   229→    },\n   230→    oCgJA: function (T, u) {\n   231→      return T - u;\n   232→    },\n   233→    dzyDn: function (T, u) {\n   234→      return T - u;\n   235→    },\n   236→    rLfRf: function (T, u) {\n   237→      return T - u;\n   238→    },\n   239→    xdCuJ: function (T, u) {\n   240→      return T < u;\n   241→    },\n   242→  };\n   243→  smoothing_window == null &&\n   244→    ((switching_frequency = parseInt(\n   245→      $(\"#range-multitrack-switching-frequency\")[\"val\"](),\n   246→    )),\n   247→      (smoothing_window = parseInt(\n   248→        -0x778 + -0x250c + 0x2cc0 - 60 * (switching_frequency / 100),\n   249→      )),\n   250→      (smoothing_window = parseInt(smoothing_window / 10)));\n   251→  max_time == null && (max_time = parseInt($(\"#range-multitrack-max-time\")[\"val\"]()));\n   252→  cutaway_min_len == null &&\n   253→    (cutaway_min_len = parseInt($(\"#range-cutaway-length\")[\"attr\"](\"data-value\" + \"-min\")));\n   254→  cutaway_max_len == null &&\n   255→    (cutaway_max_len = parseInt($(\"#range-cutaway-length\")[\"attr\"](\"data-value\" + \"-max\")));\n   256→  cutaways_enabled == null && (cutaways_enabled = $(\"#checkbox-multitrack-cutaways\")[\"is\"](\":checked\"));\n   257→  wide_shot_tolerance == null &&\n   258→    (wide_shot_tolerance = parseInt($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"]()));\n   259→  let Q = [];\n   260→  $(\"#multitrack-video-cutaway-tracks-list-to\")\n   261→  [\"find\"](\".checkbox-cutaway-video-track\")\n   262→  [\"each\"](function () {\n   263→    $(this)[\"is\"](\":checked\") && Q[\"push\"](parseInt($(this)[\"val\"]()));\n   264→  });\n   265→  let s = [];\n   266→  $(\"#multitrack-video-cutaway-tracks-list-from\")\n   267→  [\"find\"](\".checkbox-cutaway-video-track\")\n   268→  [\"each\"](function () {\n   269→    $(this)[\"is\"](\":checked\") && s[\"push\"](parseInt($(this)[\"val\"]()));\n   270→  });\n   271→  let c = parseFloat(\n   272→    $(\n   273→      \"#range-mul\" + \"titrack-sw\" + \"itching-mi\" + \"nimum-shot\" + \"-duration\",\n   274→    )[\"val\"](),\n   275→  ),\n   276→    y = 0,\n   277→    O = 0,\n   278→    b = [];\n   279→  for (let T = 0; T < g_num_speakers; T++) {\n   280→    let u = null,\n   281→      P = Infinity;\n   282→    for (let d = 0; d < g_multitrack_video_mapping[\"length\"]; d++) {\n   283→      g_multitrack_video_mapping[d][\"includes\"](T) &&\n   284→        g_multitrack_video_mapping[d][\"length\"] < P &&\n   285→        ((u = d), (P = g_multitrack_video_mapping[d][\"length\"]));\n   286→    }\n   287→    b[\"push\"]([u]);\n   288→  }\n   289→  for (let x = 0; x < g_num_speakers; x++) {\n   290→    const m = g_multitrack_video_mapping[b[x][0]][\"length\"];\n   291→    for (let q = 0; q < g_multitrack_video_mapping[\"length\"]; q++) {\n   292→      (g_multitrack_video_mapping[q][\"includes\"](x) &&\n   293→        g_multitrack_video_mapping[q][\"length\"] === m &&\n   294→        b[x][\"push\"](q),\n   295→        (b[x] = [...new Set(b[x])]));\n   296→    }\n   297→  }\n   298→  let S = [];\n   299→  for (let r = 0; r < g_num_speakers; r++) {\n   300→    let f = [];\n   301→    for (let X = 0; X < g_multitrack_video_mapping[\"length\"]; X++) {\n   302→      g_multitrack_video_mapping[X][\"includes\"](r) &&\n   303→        g_multitrack_video_mapping[X][\"length\"] === 1 &&\n   304→        f[\"push\"](X);\n   305→    }\n   306→    S[\"push\"](f);\n   307→  }\n   308→  let l = Array(g_num_speakers)[\"fill\"](-1);\n   309→  function e(D, I) {\n   310→    let g = b[D];\n   311→    if (g[\"length\"] == 1) return g[0];\n   312→    const v = g[Math[\"floor\"](g_shots_random_floats_array[I] * g[\"length\"])];\n   313→    return v;\n   314→  }\n   315→  let H = [];\n   316→  for (let D = 0; D < g_multitrack_video_mapping[\"length\"]; D++) {\n   317→    !b[\"flat\"]()[\"includes\"](D) &&\n   318→      g_multitrack_video_mapping[D][\"length\"] > 0 &&\n   319→      H[\"push\"](D);\n   320→  }\n   321→  cleaned_up_levels_blurred = JSON[\"parse\"](\n   322→    JSON[\"stringify\"](g_cleaned_up_levels),\n   323→  );\n   324→  if (smoothing_window > 0)\n   325→    for (let I = 0; I < cleaned_up_levels_blurred[\"length\"]; I++) {\n   326→      cleaned_up_levels_blurred[I] = tools[\"applyGauss\" + \"ianBlur\"](\n   327→        g_cleaned_up_levels[I],\n   328→        smoothing_window,\n   329→      );\n   330→    }\n   331→  try {\n   332→    if ($(\"#checkbox-multitrack-boost\")[\"is\"](\":checked\")) {\n   333→      let g = Array[\"from\"]({ length: g_num_speakers }, () => 0);\n   334→      for (let v = 0; v < g_num_speakers; v++) {\n   335→        g[v] = parseFloat($(\"#range-mul\" + \"titrack-bo\" + \"ost-\" + v)[\"val\"]());\n   336→      }\n   337→      for (let J = 0; J < cleaned_up_levels_blurred[\"length\"]; J++) {\n   338→        let W = g[J];\n   339→        for (let F = 0; F < cleaned_up_levels_blurred[J][\"length\"]; F++) {\n   340→          cleaned_up_levels_blurred[J][F] = cleaned_up_levels_blurred[J][F] + W;\n   341→        }\n   342→      }\n   343→    }\n   344→  } catch (h) {\n   345→    console[\"error\"](\"Error applying speaker boosts\", h);\n   346→  }\n   347→  ((max_levels = tools[\"max_of_arr\" + \"ays\"](cleaned_up_levels_blurred)),\n   348→    (decisions_raw_audio = Array(cleaned_up_levels_blurred[0][\"length\"])));\n   349→  let L = Array[\"from\"](\n   350→    {\n   351→      length: cleaned_up_levels_blurred[0][\"length\"],\n   352→    },\n   353→    () => new Set(),\n   354→  ),\n   355→    M = max_levels[\"map\"]((V) => V - wide_shot_tolerance);\n   356→  for (let V = 0; V < cleaned_up_levels_blurred[0][\"length\"]; V++) {\n   357→    for (let G = 0; G < cleaned_up_levels_blurred[\"length\"]; G++) {\n   358→      if (\n   359→        Math[\"abs\"](cleaned_up_levels_blurred[G][V] - max_levels[V]) <\n   360→        -0x14a + 0x85 + 0xc5 + 0.01\n   361→      )\n   362→        ((decisions_raw_audio[V] = G), L[V][\"add\"](G));\n   363→      else cleaned_up_levels_blurred[G][V] > M[V] && L[V][\"add\"](G);\n   364→    }\n   365→    ((L[V] = Array[\"from\"](L[V])),\n   366→      decisions_raw_audio[V] == null &&\n   367→      (V == 0\n   368→        ? (decisions_raw_audio[V] = 0)\n   369→        : (decisions_raw_audio[V] = decisions_raw_audio[V - 1])));\n   370→  }\n   371→  let o = [],\n   372→    C = decisions_raw_audio[0],\n   373→    w = L[0],\n   374→    t = g_audio_track_times[0];\n   375→  for (let E = 1; E < decisions_raw_audio[\"length\"]; E++) {\n   376→    if (\n   377→      !tools[\"arraysEqua\" + \"lIgnoreOrd\" + \"er\"](L[E], w) ||\n   378→      E == decisions_raw_audio[\"length\"] - 1\n   379→    ) {\n   380→      let U = g_audio_track_times[E],\n   381→        K = L[E],\n   382→        p = decisions_raw_audio[E] != C,\n   383→        z0 = !tools[\"arraysEqua\" + \"lIgnoreOrd\" + \"er\"](L[E], w),\n   384→        z1 = parseInt($(\"#range-multitrack-wide-shot-percentage\")[\"val\"]()),\n   385→        z2 = z1 > 0,\n   386→        z3 = e(C, o[\"length\"]),\n   387→        z4 = \"Speaker\";\n   388→      if (w[\"length\"] > 1 && z2) {\n   389→        let z6 = [],\n   390→          z7 = 0;\n   391→        for (let z8 = 0; z8 < g_multitrack_video_mapping[\"length\"]; z8++) {\n   392→          let z9 = w[\"filter\"]((zz) =>\n   393→            g_multitrack_video_mapping[z8][\"includes\"](zz),\n   394→          )[\"length\"];\n   395→          if (z9 > z7) ((z6 = [z8]), (z7 = z9));\n   396→          else z9 == z7 && z6[\"push\"](z8);\n   397→        }\n   398→        if (z6[\"length\"] > 0 && z7 > 1)\n   399→          try {\n   400→            z3 = z6[\"reduce\"]((zk, zA) =>\n   401→              g_multitrack_video_mapping[zk][\"length\"] <\n   402→                g_multitrack_video_mapping[zA][\"length\"]\n   403→                ? zk\n   404→                : zA,\n   405→            );\n   406→            let zz = Math[\"min\"](\n   407→              ...z6[\"map\"]((zk) => g_multitrack_video_mapping[zk][\"length\"]),\n   408→            ),\n   409→              zn = z6[\"filter\"](\n   410→                (zk) => g_multitrack_video_mapping[zk][\"length\"] == zz,\n   411→              );\n   412→            if (zn[\"length\"] == 1)\n   413→              ((z3 = zn[0]), (z4 = \"Wide (mult. speakers)\"));\n   414→            else {\n   415→              for (let zk = o[\"length\"] - 1; zk >= 0; zk--) {\n   416→                let zA = o[zk];\n   417→                if (zA[\"time_range\"][1] - zA[\"time_range\"][0] < c) continue;\n   418→                zn[\"includes\"](zA[\"video_inde\" + \"x\"]) &&\n   419→                  (zn = zn[\"filter\"]((za) => za != zA[\"video_inde\" + \"x\"]));\n   420→                if (zn[\"length\"] == 1) break;\n   421→              }\n   422→              ((z3 = zn[0]), (z4 = \"Wide (mult. speakers)\"));\n   423→            }\n   424→          } catch (za) {\n   425→            tracker[\"error\"](\"Error picking wide shot\", za);\n   426→          }\n   427→      }\n   428→      let z5;\n   429→      (w[\"length\"] == 1\n   430→        ? (z5 = g_multitrack_speaker_names[C])\n   431→        : (z5 = w[\"map\"]((zB) => g_multitrack_speaker_names[zB])\n   432→        [\"sort\"]()\n   433→        [\"join\"](\",\\x20\")),\n   434→        (section = {\n   435→          speaker: z5,\n   436→          speakers: w[\"map\"]((zB) => g_multitrack_speaker_names[zB])[\"sort\"](),\n   437→          audio_index: C,\n   438→          video_index: z3,\n   439→          time_range: [t, g_audio_track_times[E]],\n   440→          reason: z4,\n   441→          override: ![],\n   442→          override_index: null,\n   443→        }),\n   444→        o[\"push\"](JSON[\"parse\"](JSON[\"stringify\"](section))),\n   445→        (C = decisions_raw_audio[E]),\n   446→        (t = g_audio_track_times[E]),\n   447→        (w = L[E]));\n   448→    }\n   449→  }\n   450→  for (let zB = 0; zB < o[\"length\"]; zB++) {\n   451→    ((decision_length = o[zB][\"time_range\"][1] - o[zB][\"time_range\"][0]),\n   452→      decision_length < c &&\n   453→      (zB > 0\n   454→        ? ((o[zB - 1][\"time_range\"][1] = o[zB][\"time_range\"][1]),\n   455→          o[\"splice\"](zB, 1),\n   456→          zB--)\n   457→        : ((o[zB + 1][\"time_range\"][0] = o[zB][\"time_range\"][0]),\n   458→          o[\"splice\"](zB, 1),\n   459→          zB--)));\n   460→  }\n   461→  for (let zY = 0; zY < o[\"length\"] - 1; zY++) {\n   462→    (o[zY][\"video_inde\" + \"x\"] == o[zY + 1][\"video_inde\" + \"x\"] ||\n   463→      tools[\"arraysEqua\" + \"lIgnoreOrd\" + \"er\"](\n   464→        o[zY][\"speakers\"],\n   465→        o[zY + 1][\"speakers\"],\n   466→      )) &&\n   467→      ((o[zY][\"time_range\"][1] = o[zY + 1][\"time_range\"][1]),\n   468→        (o[zY][\"reason\"] == \"Wide\\x20(mult\" + \".\\x20speakers\" + \")\" ||\n   469→          o[zY + 1][\"reason\"] == \"Wide (mult. speakers)\") &&\n   470→        (o[zY][\"reason\"] = \"Wide (mult. speakers)\"),\n   471→        o[\"splice\"](zY + 1, 1),\n   472→        zY--);\n   473→  }\n   474→  let N = (max_time - cutaway_max_len) / 2;\n   475→  if (cutaways_enabled)\n   476→    for (let zR = 0; zR < o[\"length\"]; zR++) {\n   477→      decision_length = o[zR][\"time_range\"][1] - o[zR][\"time_range\"][0];\n   478→      if (decision_length > max_time) {\n   479→        num_cuts = Math[\"floor\"]((decision_length - N) / N + cutaway_max_len);\n   480→        let zZ = o[zR][\"time_range\"][1],\n   481→          zQ = o[zR][\"speaker\"],\n   482→          zs = o[zR][\"speakers\"],\n   483→          zj = o[zR][\"audio_inde\" + \"x\"],\n   484→          zc = o[zR][\"video_inde\" + \"x\"],\n   485→          zy = Q;\n   486→        zy = zy[\"filter\"]((zS) => zS != zc);\n   487→        if (zy[\"length\"] == 0) continue;\n   488→        if (!s[\"includes\"](zc)) continue;\n   489→        o[zR][\"time_range\"][1] = o[zR][\"time_range\"][0] + N;\n   490→        let zO = o[zR][\"time_range\"][1],\n   491→          zb = null;\n   492→        for (let zS = 0; zS < num_cuts; zS++) {\n   493→          let zl = zy;\n   494→          zS > 0 && zl[\"length\"] > 1 && (zl = zl[\"filter\"]((zw) => zw != zb));\n   495→          zl[\"length\"] == 0 &&\n   496→            ((other_speakers = Array[\"from\"](\n   497→              Array(g_multitrack_speaker_names[\"length\"])[\"keys\"](),\n   498→            )),\n   499→              (other_speakers = other_speakers[\"filter\"]((zw) => zw != zj)),\n   500→              (zl = other_speakers[\"map\"]((zw) => b[zw])[\"flat\"]()));\n   501→          let ze = Math[\"floor\"](g_shots_random_floats_array[y] * zl[\"length\"]),\n   502→            zH = zl[ze];\n   503→          y++;\n   504→          let zL = cutaway_min_len + g_multicam_cutaway_random_floats_array[O] * (cutaway_max_len - cutaway_min_len);\n   505→          (O++,\n   506→            (new_decision_B = {\n   507→              speaker: zQ,\n   508→              speakers: zs,\n   509→              audio_index: zj == 0 ? 1 : 0,\n   510→              video_index: zH,\n   511→              time_range: [zO, zO + zL],\n   512→              reason:\n   513→                g_multitrack_video_mapping[zH][\"length\"] == 1\n   514→                  ? \"Cutaway\"\n   515→                  : \"Cutaway\\x20(w\" + \"ide)\",\n   516→              override: ![],\n   517→              override_index: null,\n   518→            }),\n   519→            (new_decision_B = JSON[\"parse\"](JSON[\"stringify\"](new_decision_B))),\n   520→            (zO += zL));\n   521→          let zM = Array[\"from\"](new Set([...b[zj], ...H]));\n   522→          ((zM = zM[\"filter\"]((zw) => zw != zH)),\n   523→            (zM = zM[\"filter\"]((zw) => {\n   524→              return g_multitrack_video_mapping[zw][\"includes\"](zj);\n   525→            })));\n   526→          let zo = Math[\"floor\"](g_shots_random_floats_array[y] * zM[\"length\"]),\n   527→            zC = zM[zo];\n   528→          ((zb = zC),\n   529→            y++,\n   530→            (new_decision_A = {\n   531→              speaker: zQ,\n   532→              speakers: zs,\n   533→              audio_index: zj,\n   534→              video_index: zC,\n   535→              time_range: [zO, zO + N],\n   536→              reason: b[zj][\"includes\"](zC)\n   537→                ? \"Speaker\"\n   538→                : \"Speaker\\x20(cutaway_max_len\" + \"lt.\\x20)\",\n   539→              override: ![],\n   540→              override_index: null,\n   541→            }),\n   542→            zS == num_cuts - 1 && (new_decision_A[\"time_range\"][1] = zZ),\n   543→            (new_decision_A = JSON[\"parse\"](JSON[\"stringify\"](new_decision_A))),\n   544→            (zO += N),\n   545→            o[\"push\"](new_decision_B),\n   546→            o[\"push\"](new_decision_A));\n   547→        }\n   548→      }\n   549→    }\n   550→  (o[\"sort\"](function (zw, zt) {\n   551→    return zw[\"time_range\"][0] - zt[\"time_range\"][0];\n   552→  }),\n   553→    (o[0][\"time_range\"][0] = Math[\"max\"](\n   554→      0,\n   555→      o[0][\"time_range\"][0] - 0x99e + 0x12 * 0x20b + -0x1 * 0x2e64 + 0.375,\n   556→    )),\n   557→    (o[o[\"length\"] - 1][\"time_range\"][1] =\n   558→      o[o[\"length\"] - 1][\"time_range\"][1] +\n   559→      -0x106b +\n   560→      -0x10d2 +\n   561→      0x213d +\n   562→      0.375));\n   563→  for (let zw = 0; zw < g_multitrack_decision_overrides[\"length\"]; zw++) {\n   564→    for (let zt = 0; zt < o[\"length\"]; zt++) {\n   565→      g_multitrack_decision_overrides[zw][\"time\"] >= o[zt][\"time_range\"][0] &&\n   566→        g_multitrack_decision_overrides[zw][\"time\"] < o[zt][\"time_range\"][1] &&\n   567→        ((o[zt][\"override\"] = !![]),\n   568→          (o[zt][\"override_i\" + \"ndex\"] = zw),\n   569→          (o[zt][\"video_inde\" + \"x\"] =\n   570→            g_multitrack_decision_overrides[zw][\"video_inde\" + \"x\"]));\n   571→    }\n   572→  }\n   573→  g_multitrack_decisions = JSON[\"parse\"](JSON[\"stringify\"](o));\n   574→}\n   575→function test_52_validate_multitrack_selections() {\n   576→  const smoothing_window = {\n   577→    FEjBG: function (cutaways_enabled, max_time) {\n   578→      return cutaways_enabled < max_time;\n   579→    },\n   580→    aTCgG: function (cutaways_enabled, max_time) {\n   581→      return cutaways_enabled(max_time);\n   582→    },\n   583→    CyWXJ:\n   584→      \"Please\\x20use\" + \"\\x20at\\x20least\\x20\" + \"2\\x20video\\x20tr\" + \"acks\",\n   585→    UrFWQ: function (cutaways_enabled, max_time) {\n   586→      return cutaways_enabled(max_time);\n   587→    },\n   588→    YkYEe: function (cutaways_enabled, max_time) {\n   589→      return cutaways_enabled < max_time;\n   590→    },\n   591→    yQSGa:\n   592→      \"Please\\x20mak\" +\n   593→      \"e\\x20sure\\x20all\" +\n   594→      \"\\x20speakers\\x20\" +\n   595→      \"are\\x20covere\" +\n   596→      \"d\\x20by\\x20the\\x20v\" +\n   597→      \"ideo\\x20track\" +\n   598→      \"s.\",\n   599→  };\n   600→  nonzero_video_tracks = g_multitrack_video_mapping_selection_indices[\"filter\"](\n   601→    (cutaways_enabled) => cutaways_enabled != 0,\n   602→  );\n   603→  if (nonzero_video_tracks[\"length\"] < 2)\n   604→    return (showError(\"Please use at least 2 video tracks\"), ![]);\n   605→  speaker_covered = Array(g_multitrack_speaker_names[\"length\"])[\"fill\"](![]);\n   606→  for (let cutaways_enabled = 0; cutaways_enabled < g_multitrack_video_mapping[\"length\"]; cutaways_enabled++) {\n   607→    for (\n   608→      let max_time = 0;\n   609→      g_multitrack_video_mapping[cutaways_enabled][\"length\"] <\n   610→      g_multitrack_video_mapping[cutaways_enabled][\"length\"];\n   611→      max_time++\n   612→    ) {\n   613→      speaker_covered[g_multitrack_video_mapping[cutaways_enabled][max_time]] = !![];\n   614→    }\n   615→  }\n   616→  if (speaker_covered[\"includes\"](![]))\n   617→    return (\n   618→      showError(\n   619→        \"Please make sure all speakers are covered by the video tracks.\",\n   620→      ),\n   621→      ![]\n   622→    );\n   623→  return !![];\n   624→}\n   625→function test_100_get_multitrack_screentime_summary() {\n   626→  const smoothing_window = {\n   627→    BMZvm: function (cutaway_min_len, cutaway_max_len) {\n   628→      return cutaway_min_len < cutaway_max_len;\n   629→    },\n   630→    Kaolc: function (cutaway_min_len, cutaway_max_len) {\n   631→      return cutaway_min_len == cutaway_max_len;\n   632→    },\n   633→    cyxMB: function (cutaway_min_len, cutaway_max_len) {\n   634→      return cutaway_min_len > cutaway_max_len;\n   635→    },\n   636→    xvFWw: function (cutaway_min_len, cutaway_max_len) {\n   637→      return cutaway_min_len - cutaway_max_len;\n   638→    },\n   639→  };\n   640→  let cutaways_enabled = Array[\"from\"](\n   641→    { length: g_multitrack_video_mapping[\"length\"] },\n   642→    () => 0,\n   643→  );\n   644→  for (let cutaway_min_len = 0; cutaway_min_len < g_multitrack_decisions[\"length\"]; cutaway_min_len++) {\n   645→    const cutaway_max_len = g_multitrack_decisions[cutaway_min_len];\n   646→    cutaways_enabled[cutaway_max_len[\"video_inde\" + \"x\"]] += cutaway_max_len[\"time_range\"][1] - cutaway_max_len[\"time_range\"][0];\n   647→  }\n   648→  let max_time = Array[\"from\"](\n   649→    {\n   650→      length: g_multitrack_speaker_names[\"length\"] + 1,\n   651→    },\n   652→    () => 0,\n   653→  );\n   654→  for (let wide_shot_tolerance = 0; wide_shot_tolerance < g_multitrack_video_mapping[\"length\"]; wide_shot_tolerance++) {\n   655→    if (g_multitrack_video_mapping[wide_shot_tolerance][\"length\"] == 0) continue;\n   656→    else\n   657→      g_multitrack_video_mapping[wide_shot_tolerance][\"length\"] > 1\n   658→        ? (max_time[max_time[\"length\"] - 1] += cutaways_enabled[wide_shot_tolerance])\n   659→        : (max_time[g_multitrack_video_mapping[wide_shot_tolerance][0]] += cutaways_enabled[wide_shot_tolerance]);\n   660→  }\n   661→  return max_time;\n   662→}\n   663→var multitrack_wide_shot_percentage_acceptable_error = 1,\n   664→  multitrack_wide_shot_finetune_step_size = 0x27d * 0xd + -0x2405 + 0x3ac + 0.1;\n   665→function test_101_finetune_multitrack_wide_shot_tolerance() {\n   666→  const smoothing_window = {\n   667→    BerEx: function (Z, Q) {\n   668→      return Z(Q);\n   669→    },\n   670→    MowVw: function (Z, Q) {\n   671→      return Z === Q;\n   672→    },\n   673→    KkwnW: \"#range-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\",\n   674→    FafhB: function (Z) {\n   675→      return Z();\n   676→    },\n   677→    CDcqU: function (Z, Q) {\n   678→      return Z === Q;\n   679→    },\n   680→    niHxX: function (Z, Q) {\n   681→      return Z <= Q;\n   682→    },\n   683→    DyYGO: function (Z, Q) {\n   684→      return Z + Q;\n   685→    },\n   686→    COhgN: function (Z) {\n   687→      return Z();\n   688→    },\n   689→    mcjgW: function (Z, Q) {\n   690→      return Z * Q;\n   691→    },\n   692→    fYaxm: function (Z, Q) {\n   693→      return Z / Q;\n   694→    },\n   695→    LAqSU: function (Z, Q) {\n   696→      return Z - Q;\n   697→    },\n   698→    UpulG: function (Z, Q) {\n   699→      return Z > Q;\n   700→    },\n   701→    oquVL: function (Z, Q) {\n   702→      return Z < Q;\n   703→    },\n   704→    FvPRv: function (Z, Q) {\n   705→      return Z === Q;\n   706→    },\n   707→    MHBVQ: function (Z, Q) {\n   708→      return Z !== Q;\n   709→    },\n   710→    KiaeT: function (Z, Q) {\n   711→      return Z - Q;\n   712→    },\n   713→    mggBm: function (Z, Q) {\n   714→      return Z - Q;\n   715→    },\n   716→    YyFGb: function (Z) {\n   717→      return Z();\n   718→    },\n   719→  };\n   720→  let cutaways_enabled = parseInt(\n   721→    $(\"#range-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\")[\"val\"](),\n   722→  );\n   723→  if (cutaways_enabled === 0) {\n   724→    ($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"](0),\n   725→      test_51_decide_multicam_cuts());\n   726→    return;\n   727→  } else {\n   728→    if (cutaways_enabled === 100) {\n   729→      ($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"](100),\n   730→        test_51_decide_multicam_cuts());\n   731→      return;\n   732→    }\n   733→  }\n   734→  let max_time = 0,\n   735→    cutaway_min_len = 100,\n   736→    cutaway_max_len = 50,\n   737→    wide_shot_tolerance = Infinity,\n   738→    Y = { tolerance: null, percentage: Infinity },\n   739→    R = { tolerance: null, percentage: -Infinity };\n   740→  while (max_time <= cutaway_min_len) {\n   741→    const Z = Math[\"floor\"]((max_time + cutaway_min_len) / 2);\n   742→    ($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"](Z),\n   743→      test_51_decide_multicam_cuts());\n   744→    let Q = test_100_get_multitrack_screentime_summary(),\n   745→      s = Q[\"reduce\"]((y, O) => y + O, 0),\n   746→      j = (s[(1)[\"length\"] - 1] / s) * 100;\n   747→    j > cutaways_enabled\n   748→      ? (j < Y[\"percentage\"] && (Y = { tolerance: Z, percentage: j }),\n   749→        (cutaway_min_len = Z - 1))\n   750→      : (j > R[\"percentage\"] && (R = { tolerance: Z, percentage: j }),\n   751→        (max_time = Z + 1));\n   752→    const c = Math[\"abs\"](cutaways_enabled - j);\n   753→    if (c < wide_shot_tolerance) {\n   754→      ((wide_shot_tolerance = c), (cutaway_max_len = Z));\n   755→      if (c <= multitrack_wide_shot_percentage_acceptable_error) break;\n   756→    }\n   757→    if (max_time === cutaway_min_len) break;\n   758→  }\n   759→  if (Y[\"tolerance\"] !== null && R[\"tolerance\"] !== null) {\n   760→    const y = Math[\"abs\"](cutaways_enabled - Y[\"percentage\"]),\n   761→      O = Math[\"abs\"](cutaways_enabled - R[\"percentage\"]);\n   762→    cutaway_max_len = y < O ? Y[\"tolerance\"] : R[\"tolerance\"];\n   763→  }\n   764→  ($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"](cutaway_max_len),\n   765→    test_51_decide_multicam_cuts());\n   766→}\n   767→function combination_as_names(smoothing_window, cutaways_enabled) {\n   768→  const max_time = {\n   769→    YJaXs: function (cutaway_max_len, wide_shot_tolerance) {\n   770→      return cutaway_max_len == wide_shot_tolerance;\n   771→    },\n   772→    OkAUN: \"(ignore\\x20tr\" + \"ack)\",\n   773→    awYMq: function (cutaway_max_len, wide_shot_tolerance) {\n   774→      return cutaway_max_len < wide_shot_tolerance;\n   775→    },\n   776→    bKTyD: function (cutaway_max_len, wide_shot_tolerance) {\n   777→      return cutaway_max_len == wide_shot_tolerance;\n   778→    },\n   779→    xvCld: function (cutaway_max_len, wide_shot_tolerance) {\n   780→      return cutaway_max_len + wide_shot_tolerance;\n   781→    },\n   782→  };\n   783→  if (smoothing_window[\"length\"] == 0) return \"(ignore track)\";\n   784→  let cutaway_min_len = [];\n   785→  for (let cutaway_max_len = 0; cutaway_max_len < smoothing_window[\"length\"]; cutaway_max_len++) {\n   786→    cutaways_enabled[smoothing_window[cutaway_max_len]] == \"\" ? cutaway_min_len[\"push\"](\"cutaway_min_len\" + (smoothing_window[cutaway_max_len] + 1)) : cutaway_min_len[\"push\"](cutaways_enabled[smoothing_window[cutaway_max_len]]);\n   787→  }\n   788→  return cutaway_min_len[\"join\"](\",\\x20\");\n   789→}\n   790→function multitrack_wide_shots_available() {\n   791→  const smoothing_window = {\n   792→    JcUaV: function (k, A) {\n   793→      return k > A;\n   794→    },\n   795→  };\n   796→  let n = ![];\n   797→  for (let k = 0; k < g_multitrack_video_mapping[\"length\"]; k++) {\n   798→    if (g_multitrack_video_mapping[k][\"length\"] > 1) {\n   799→      n = !![];\n   800→      break;\n   801→    }\n   802→  }\n   803→  return n;\n   804→}\n   805→async function test_102_auto_tune_multitrack_distribution() {\n   806→  const z = {\n   807→    xNoQC: function (A, a) {\n   808→      return A(a);\n   809→    },\n   810→    lTxsm: \":checked\",\n   811→    LKotQ: function (A) {\n   812→      return A();\n   813→    },\n   814→    yGtND: \"Error\\x20reco\" + \"mputing\\x20de\" + \"cisions:\",\n   815→    ZcTfL: function (A, a) {\n   816→      return A - a;\n   817→    },\n   818→    vVJYq: function (A, a) {\n   819→      return A + a;\n   820→    },\n   821→    kUBVd: function (A, a) {\n   822→      return A > a;\n   823→    },\n   824→    ORrLZ: function (A, a) {\n   825→      return A > a;\n   826→    },\n   827→    TvOEd: function (A, a) {\n   828→      return A / a;\n   829→    },\n   830→    OnVaB: function (A, a) {\n   831→      return A(a);\n   832→    },\n   833→    CaKRg: function (A, a) {\n   834→      return A(a);\n   835→    },\n   836→    tAbTA: function (A, a) {\n   837→      return A(a);\n   838→    },\n   839→    OpkSw: function (A, a) {\n   840→      return A(a);\n   841→    },\n   842→    ZIlRT: \"#range-mul\" + \"titrack-sw\" + \"itching-fr\" + \"equency\",\n   843→    qQLbW: function (A, a) {\n   844→      return A(a);\n   845→    },\n   846→    jDrUa:\n   847→      \"#range-mul\" + \"titrack-sw\" + \"itching-mi\" + \"nimum-shot\" + \"-duration\",\n   848→    IcQDP: \"#range-mul\" + \"titrack-ma\" + \"x-time\",\n   849→    XjKgh: function (A, a) {\n   850→      return A(a);\n   851→    },\n   852→    TmoWN: \"#range-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\",\n   853→    yuqlk: function (A, a) {\n   854→      return A(a);\n   855→    },\n   856→    ndfpn: \"#range-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\",\n   857→    COgfH: \"#range-cut\" + \"away-lengt\" + \"h\",\n   858→    CIfQy: \"data-value\" + \"-min\",\n   859→    jDKdh: function (A, a) {\n   860→      return A(a);\n   861→    },\n   862→    liSBq: \"data-value\" + \"-max\",\n   863→    xXpRb: function (A, a) {\n   864→      return A(a);\n   865→    },\n   866→    XGZWj: \"#multitrac\" + \"k-video-cu\" + \"taway-trac\" + \"ks-list-to\",\n   867→    nsirO: \".checkbox-\" + \"cutaway-vi\" + \"deo-track\",\n   868→    ZVLrq: function (A, a) {\n   869→      return A(a);\n   870→    },\n   871→    DHvEF: function (A, a) {\n   872→      return A(a);\n   873→    },\n   874→    bHKXh: \"checked\",\n   875→    MWaMq: function (A, a) {\n   876→      return A < a;\n   877→    },\n   878→    Howij: function (A, a) {\n   879→      return A(a);\n   880→    },\n   881→    VOlXV: function (A, a) {\n   882→      return A + a;\n   883→    },\n   884→    jqKCB: function (A, a) {\n   885→      return A(a);\n   886→    },\n   887→    JYQSi: \"#value-mul\" + \"titrack-sw\" + \"itching-fr\" + \"equency\",\n   888→    xeiHb: \"input\",\n   889→    YYmFX:\n   890→      \"#value-mul\" + \"titrack-sw\" + \"itching-mi\" + \"nimum-shot\" + \"-duration\",\n   891→    LuFUT: function (A, a) {\n   892→      return A(a);\n   893→    },\n   894→    alFMb: \"#value-mul\" + \"titrack-ma\" + \"x-time\",\n   895→    ZNqQf: function (A, a) {\n   896→      return A(a);\n   897→    },\n   898→    UUeOX: \"#value-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\",\n   899→    jReEE: function (A, a) {\n   900→      return A(a);\n   901→    },\n   902→    uMkUU: function (A, a) {\n   903→      return A !== a;\n   904→    },\n   905→    CSpYX: \"undefined\",\n   906→    aHMHL: function (A, a) {\n   907→      return A(a);\n   908→    },\n   909→    oplWw: function (A, a) {\n   910→      return A(a);\n   911→    },\n   912→    ahZeQ: \"#checkbox-\" + \"multitrack\" + \"-cutaways\",\n   913→    iWcgB: \"#multitrac\" + \"k-video-cu\" + \"taway-trac\" + \"ks-list-fr\" + \"om\",\n   914→    DHCJP: function (A, a) {\n   915→      return A < a;\n   916→    },\n   917→    HSMVo: function (A, a) {\n   918→      return A === a;\n   919→    },\n   920→    DUBMV: function (A) {\n   921→      return A();\n   922→    },\n   923→    nbumQ: function (A) {\n   924→      return A();\n   925→    },\n   926→    xubWX: \"#checkbox-\" + \"multitrack\" + \"-boost\",\n   927→    FijCn: function (A) {\n   928→      return A();\n   929→    },\n   930→    TTEOb: function (A, a) {\n   931→      return A(a);\n   932→    },\n   933→    gKKrf: function (A, a) {\n   934→      return A <= a;\n   935→    },\n   936→    vqUel: function (A, a) {\n   937→      return A(a);\n   938→    },\n   939→    fOLuO: function (A, a) {\n   940→      return A(a);\n   941→    },\n   942→    dbhzC: function (A) {\n   943→      return A();\n   944→    },\n   945→    ciqwA: \"Discrete\\x20b\" + \"oost\\x20accep\" + \"t\",\n   946→    VVdkP: function (A) {\n   947→      return A();\n   948→    },\n   949→    jiIPC: function (A) {\n   950→      return A();\n   951→    },\n   952→    OhtEh: function (A) {\n   953→      return A();\n   954→    },\n   955→    Qccus: function (A, a) {\n   956→      return A < a;\n   957→    },\n   958→    TBgYr: function (A) {\n   959→      return A();\n   960→    },\n   961→    jSKrh: \"Discrete\\x20c\" + \"utoff\\x20acce\" + \"pt\",\n   962→    HZGQL: function (A, a) {\n   963→      return A(a);\n   964→    },\n   965→    TDiET: function (A) {\n   966→      return A();\n   967→    },\n   968→    IcSBy: function (A, a) {\n   969→      return A < a;\n   970→    },\n   971→    PtLeE: function (A, a) {\n   972→      return A - a;\n   973→    },\n   974→    KIqYw: function (A) {\n   975→      return A();\n   976→    },\n   977→    yCsZc: \"Discrete\\x20m\" + \"inShot\\x20acc\" + \"ept\",\n   978→    pQIqx: function (A, a) {\n   979→      return A(a);\n   980→    },\n   981→    FGLnb: function (A) {\n   982→      return A();\n   983→    },\n   984→    lVNmd: function (A, a) {\n   985→      return A - a;\n   986→    },\n   987→    IkVZR: function (A) {\n   988→      return A();\n   989→    },\n   990→    TffDY: function (A, a) {\n   991→      return A < a;\n   992→    },\n   993→    ltmci: function (A) {\n   994→      return A();\n   995→    },\n   996→    FaUlJ: \"Accepted\\x20b\" + \"oosts\\x20step\",\n   997→    KjpwL: function (A, a) {\n   998→      return A * a;\n   999→    },\n  1000→    MeFzF: function (A) {\n  1001→      return A();\n  1002→    },\n  1003→    bwLMr: function (A, a) {\n  1004→      return A + a;\n  1005→    },\n  1006→    zRpJM: function (A, a) {\n  1007→      return A === a;\n  1008→    },\n  1009→    vZJMH: function (A) {\n  1010→      return A();\n  1011→    },\n  1012→    tQIxq: \"Accepted\\x20s\" + \"witchingFr\" + \"equency\\x20st\" + \"ep\",\n  1013→    bWPAw: function (A, a) {\n  1014→      return A(a);\n  1015→    },\n  1016→    CAaEz: \"Reverted\\x20s\" + \"witchingFr\" + \"equency\\x20st\" + \"ep\",\n  1017→    YufmM: function (A, a) {\n  1018→      return A - a;\n  1019→    },\n  1020→    BkVVa: function (A) {\n  1021→      return A();\n  1022→    },\n  1023→    QJEoi: function (A, a) {\n  1024→      return A - a;\n  1025→    },\n  1026→    QOGZX: function (A, a) {\n  1027→      return A(a);\n  1028→    },\n  1029→    ZVNDe: function (A) {\n  1030→      return A();\n  1031→    },\n  1032→    fsnBk: function (A, a) {\n  1033→      return A === a;\n  1034→    },\n  1035→    XtAhn: function (A) {\n  1036→      return A();\n  1037→    },\n  1038→    hGzjV: function (A, a) {\n  1039→      return A - a;\n  1040→    },\n  1041→    Mnvfh: \"Accepted\\x20m\" + \"inShotDura\" + \"tion\\x20step\",\n  1042→    fxgKX: function (A, a) {\n  1043→      return A(a);\n  1044→    },\n  1045→    LhKSS: \"Reverted\\x20m\" + \"inShotDura\" + \"tion\\x20step\",\n  1046→    jLANk: function (A, a) {\n  1047→      return A + a;\n  1048→    },\n  1049→    rUUeR: function (A) {\n  1050→      return A();\n  1051→    },\n  1052→    jCxex: function (A, a) {\n  1053→      return A < a;\n  1054→    },\n  1055→    tucKn: function (A, a) {\n  1056→      return A - a;\n  1057→    },\n  1058→    VjqJW: function (A) {\n  1059→      return A();\n  1060→    },\n  1061→    vxTHZ: \"Accepted\\x20m\" + \"inShotDura\" + \"tion\\x20up\\x20st\" + \"ep\",\n  1062→    qKqDo: \"Reverted\\x20m\" + \"inShotDura\" + \"tion\\x20up\\x20st\" + \"ep\",\n  1063→    oRNwq: function (A) {\n  1064→      return A();\n  1065→    },\n  1066→    JWAPv: function (A, a) {\n  1067→      return A - a;\n  1068→    },\n  1069→    llKTP: function (A, a) {\n  1070→      return A === a;\n  1071→    },\n  1072→    XPGea: function (A) {\n  1073→      return A();\n  1074→    },\n  1075→    hVweT: \"Accepted\\x20m\" + \"axTimeEffe\" + \"ctiveCutof\" + \"f\\x20step\",\n  1076→    mVEha: \"Reverted\\x20m\" + \"axTimeEffe\" + \"ctiveCutof\" + \"f\\x20step\",\n  1077→    XwIGP: function (A, a) {\n  1078→      return A + a;\n  1079→    },\n  1080→    HaeGm: function (A, a) {\n  1081→      return A - a;\n  1082→    },\n  1083→    FkQrs: \"Reverted\\x20m\" + \"axTimeEffe\" + \"ctiveCutof\" + \"f\\x20up\\x20step\",\n  1084→    wiJEU: function (A, a) {\n  1085→      return A(a);\n  1086→    },\n  1087→    GRXwo: function (A, a) {\n  1088→      return A(a);\n  1089→    },\n  1090→    McfBY: function (A) {\n  1091→      return A();\n  1092→    },\n  1093→    jDrXB: \"Accepted\\x20b\" + \"oosts\\x20togg\" + \"le\",\n  1094→    WkrTB: function (A, a) {\n  1095→      return A(a);\n  1096→    },\n  1097→    wOFnZ: \"Reverted\\x20b\" + \"oosts\\x20togg\" + \"le\",\n  1098→    rKXlQ: function (A) {\n  1099→      return A();\n  1100→    },\n  1101→    VqqEi: function (A, a) {\n  1102→      return A < a;\n  1103→    },\n  1104→    gyPXx: function (A, a) {\n  1105→      return A - a;\n  1106→    },\n  1107→    NDfJm: function (A, a) {\n  1108→      return A === a;\n  1109→    },\n  1110→    pagbq: function (A) {\n  1111→      return A();\n  1112→    },\n  1113→    ehDNZ: function (A, a) {\n  1114→      return A + a;\n  1115→    },\n  1116→    kKEWG: function (A, a) {\n  1117→      return A(a);\n  1118→    },\n  1119→    GzgrS: function (A) {\n  1120→      return A();\n  1121→    },\n  1122→    VVzGZ: function (A, a) {\n  1123→      return A < a;\n  1124→    },\n  1125→    AXbnQ: function (A) {\n  1126→      return A();\n  1127→    },\n  1128→    xLFOk: \"Accepted\\x20c\" + \"utaway\\x20rou\" + \"ting/durat\" + \"ion\\x20step\",\n  1129→    BEFLJ: function (A, a) {\n  1130→      return A(a);\n  1131→    },\n  1132→    VMcdt: function (A) {\n  1133→      return A();\n  1134→    },\n  1135→    KbtHO: \"Reverted\\x20c\" + \"utaway\\x20rou\" + \"ting/durat\" + \"ion\\x20step\",\n  1136→    SnRNs: function (A) {\n  1137→      return A();\n  1138→    },\n  1139→    nHYcB: function (A, a) {\n  1140→      return A - a;\n  1141→    },\n  1142→    ZXBrj: function (A) {\n  1143→      return A();\n  1144→    },\n  1145→    mTXcV: \"Accepted\\x20c\" + \"utaway\\x20dur\" + \"ation\\x20down\" + \"\\x20step\",\n  1146→    kuiBd: function (A) {\n  1147→      return A();\n  1148→    },\n  1149→    jJZyk: function (A, a) {\n  1150→      return A / a;\n  1151→    },\n  1152→    esvdC: function (A) {\n  1153→      return A();\n  1154→    },\n  1155→    wDqwG: function (A, a) {\n  1156→      return A < a;\n  1157→    },\n  1158→    dVUGO:\n  1159→      \"Accepted\\x20w\" +\n  1160→      \"ide\\x20finetu\" +\n  1161→      \"ne\\x20toward\\x20\" +\n  1162→      \"~equal\\x20ent\" +\n  1163→      \"ity\\x20share\",\n  1164→    OEgoX: function (A) {\n  1165→      return A();\n  1166→    },\n  1167→    oPxbw: \"Reverted\\x20w\" + \"ide\\x20finetu\" + \"ne\\x20step\",\n  1168→    nQZLR: \"test_102_a\" + \"uto_tune_m\" + \"ultitrack_\" + \"distributi\" + \"on\",\n  1169→    EflRM: \"Auto-balan\" + \"cing...\",\n  1170→    GhSRt: function (A, a) {\n  1171→      return A(a);\n  1172→    },\n  1173→    VzITD: function (A, a) {\n  1174→      return A(a);\n  1175→    },\n  1176→    sRlwR: function (A, a) {\n  1177→      return A(a);\n  1178→    },\n  1179→    UgXYh: function (A, a) {\n  1180→      return A(a);\n  1181→    },\n  1182→    jFuGq: function (A, a) {\n  1183→      return A(a);\n  1184→    },\n  1185→    jXUsz: \"#range-mul\" + \"titrack-bo\" + \"ost-\",\n  1186→    TyIke: \"Auto-balan\" + \"ce\\x20setting\" + \"s\\x20snapshot\" + \":\",\n  1187→    lPLBE: \"Screentime\" + \"\\x20per\\x20speak\" + \"er:\",\n  1188→    VNsxw: function (A) {\n  1189→      return A();\n  1190→    },\n  1191→    jWIvn: function (A) {\n  1192→      return A();\n  1193→    },\n  1194→    EtGew: \"Initial\\x20sh\" + \"ares:\",\n  1195→    EqfcD: \"maxAbsErro\" + \"r:\",\n  1196→    LDldm: function (A) {\n  1197→      return A();\n  1198→    },\n  1199→    WPgfU: function (A, a) {\n  1200→      return A > a;\n  1201→    },\n  1202→    uIiCU: function (A, a) {\n  1203→      return A && a;\n  1204→    },\n  1205→    oYwEJ: function (A, a) {\n  1206→      return A(a);\n  1207→    },\n  1208→    VNsax: \"Cutaways\\x20t\" + \"rial\\x20rever\" + \"ted\\x20after\\x20\" + \"sweep\",\n  1209→    ViZVQ: \"Sweep\",\n  1210→    YLGBu: \"best\\x20maxAb\" + \"sError:\",\n  1211→    XqSoX: \"shares:\",\n  1212→    siwSP:\n  1213→      \"Auto-balan\" +\n  1214→      \"ce\\x20converg\" +\n  1215→      \"ed\\x20to\\x20≤1%\\x20\" +\n  1216→      \"after\\x20full\" +\n  1217→      \"\\x20sweep.\",\n  1218→    xbTDm: function (A, a) {\n  1219→      return A > a;\n  1220→    },\n  1221→    VjDWt: function (A) {\n  1222→      return A();\n  1223→    },\n  1224→    xfRpf: \"#multitrac\" + \"k-screenti\" + \"me-chart\",\n  1225→    HoUnf: \"html,\\x20body\",\n  1226→    HxxjF: \"#button-mu\" + \"ltitrack-a\" + \"uto-balanc\" + \"e\",\n  1227→    Swljx: \"disabled\",\n  1228→  },\n  1229→    k = tracker[\"start\"](\"test_102_auto_tune_multitrack_distribution\");\n  1230→  try {\n  1231→    (showSpinner(\"Auto-balancing...\"),\n  1232→      $(\"#button-mu\" + \"ltitrack-a\" + \"uto-balanc\" + \"e\")[\"prop\"](\n  1233→        \"disabled\",\n  1234→        !![],\n  1235→      ));\n  1236→    const A = parseInt(\n  1237→      $(\"#range-mul\" + \"titrack-sw\" + \"itching-fr\" + \"equency\")[\"val\"](),\n  1238→    ),\n  1239→      a = parseFloat(\n  1240→        $(\"#range-multitrack-switching-minimum-shot-duration\")[\"val\"](),\n  1241→      ),\n  1242→      B = parseInt(\n  1243→        $(\"#range-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\")[\"val\"](),\n  1244→      ),\n  1245→      Y = parseInt($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"]()),\n  1246→      R = parseInt($(\"#range-mul\" + \"titrack-ma\" + \"x-time\")[\"val\"]()),\n  1247→      Z = parseInt($(\"#range-cutaway-length\")[\"attr\"](\"data-value-min\")),\n  1248→      Q = parseInt($(\"#range-cutaway-length\")[\"attr\"](\"data-value-max\")),\n  1249→      s = $(\"#checkbox-multitrack-cutaways\")[\"is\"](\":checked\"),\n  1250→      j = $(\"#checkbox-\" + \"multitrack\" + \"-boost\")[\"is\"](\":checked\");\n  1251→    let c = [];\n  1252→    $(\"#multitrack-video-cutaway-tracks-list-to\")\n  1253→    [\"find\"](\".checkbox-cutaway-video-track\")\n  1254→    [\"each\"](function () {\n  1255→      $(this)[\"is\"](\":checked\") && c[\"push\"](parseInt($(this)[\"val\"]()));\n  1256→    });\n  1257→    let y = [];\n  1258→    $(\"#multitrack-video-cutaway-tracks-list-from\")\n  1259→    [\"find\"](\".checkbox-cutaway-video-track\")\n  1260→    [\"each\"](function () {\n  1261→      $(this)[\"is\"](\":checked\") && y[\"push\"](parseInt($(this)[\"val\"]()));\n  1262→    });\n  1263→    let O = Array[\"from\"]({ length: g_num_speakers }, () => 0);\n  1264→    try {\n  1265→      for (let f = 0; f < g_num_speakers; f++) {\n  1266→        const X = parseFloat($(\"#range-multitrack-boost-\" + f)[\"val\"]());\n  1267→        O[f] = isNaN(X) ? 0 : X;\n  1268→      }\n  1269→    } catch (D) {\n  1270→      O = Array[\"from\"]({ length: g_num_speakers }, () => 0);\n  1271→    }\n  1272→    const b = {\n  1273→      switchingFrequency: A,\n  1274→      minShotDuration: a,\n  1275→      wideShotPercentage: B,\n  1276→      wideShotTolerance: Y,\n  1277→      maxTimeEffectiveCutoff: R,\n  1278→      cutawayDurationMin: Z,\n  1279→      cutawayDurationMax: Q,\n  1280→      cutawaysEnabled: s,\n  1281→      boostsEnabled: j,\n  1282→      cutawayAllowedTracksTo: c,\n  1283→      cutawayAllowedTracksFrom: y,\n  1284→      speakerBoosts: O,\n  1285→    };\n  1286→    console[\"log\"](\"Auto-balance settings snapshot:\", b);\n  1287→    const S = test_100_get_multitrack_screentime_summary();\n  1288→    console[\"log\"](\"Screentime per speaker:\", S);\n  1289→    function l() {\n  1290→      try {\n  1291→        test_51_decide_multicam_cuts();\n  1292→      } catch (I) {\n  1293→        console[\"log\"](\"Error recomputing decisions:\", I);\n  1294→      }\n  1295→    }\n  1296→    function H() {\n  1297→      const I = test_100_get_multitrack_screentime_summary(),\n  1298→        g = I[\"reduce\"]((z0, z1) => z0 + z1, 0),\n  1299→        J = I[I[\"length\"] - 1] || 0,\n  1300→        W = Math[\"max\"](0, g - J),\n  1301→        F = g_multitrack_speaker_names[\"length\"],\n  1302→        h = multitrack_wide_shots_available(),\n  1303→        V = h ? F + 1 : F,\n  1304→        G = V > 0 ? 1 / V : 0,\n  1305→        E = I[\"slice\"](0, F);\n  1306→      let U = [];\n  1307→      if (h) {\n  1308→        const z0 = g > 0 ? g : 1;\n  1309→        ((U = E[\"map\"]((z1) => z1 / z0)), U[\"push\"](J / z0));\n  1310→      } else {\n  1311→        const z1 = W > 0 ? W : 1;\n  1312→        U = E[\"map\"]((z2) => z2 / z1);\n  1313→      }\n  1314→      const K = U[\"map\"]((z2) => G - z2),\n  1315→        p = K[\"reduce\"]((z2, z3) => Math[\"max\"](z2, Math[\"abs\"](z3)), 0);\n  1316→      return {\n  1317→        shares: U,\n  1318→        errors: K,\n  1319→        maxAbsError: p,\n  1320→        total: g,\n  1321→        wide: J,\n  1322→        totalNoWide: W,\n  1323→        secs: E,\n  1324→        target: G,\n  1325→        includeWide: h,\n  1326→        numSpeakers: F,\n  1327→      };\n  1328→    }\n  1329→    function L() {\n  1330→      const I = g_multitrack_speaker_names[\"length\"],\n  1331→        g = Array[\"from\"](\n  1332→          { length: I },\n  1333→          (z0, z1) =>\n  1334→            parseFloat($(\"#range-mul\" + \"titrack-bo\" + \"ost-\" + z1)[\"val\"]()) ||\n  1335→            0,\n  1336→        ),\n  1337→        J = parseInt($(\"#range-multitrack-switching-frequency\")[\"val\"]()),\n  1338→        W = parseFloat(\n  1339→          $(\"#range-multitrack-switching-minimum-shot-duration\")[\"val\"](),\n  1340→        ),\n  1341→        F = parseInt($(\"#range-multitrack-max-time\")[\"val\"]()),\n  1342→        h = parseInt($(\"#range-multitrack-wide-shot-percentage\")[\"val\"]()),\n  1343→        V = parseInt($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"]()),\n  1344→        G = parseFloat($(\"#range-cutaway-length\")[\"attr\"](\"data-value-min\")),\n  1345→        E = parseFloat($(\"#range-cutaway-length\")[\"attr\"](\"data-value-max\")),\n  1346→        U = $(\"#checkbox-\" + \"multitrack\" + \"-cutaways\")[\"is\"](\":checked\");\n  1347→      let K = [];\n  1348→      $(\"#multitrack-video-cutaway-tracks-list-to\")\n  1349→      [\"find\"](\".checkbox-cutaway-video-track\")\n  1350→      [\"each\"](function () {\n  1351→        if ($(this)[\"is\"](\":checked\")) K[\"push\"](parseInt($(this)[\"val\"]()));\n  1352→      });\n  1353→      let p = [];\n  1354→      return (\n  1355→        $(\"#multitrac\" + \"k-video-cu\" + \"taway-trac\" + \"ks-list-fr\" + \"om\")\n  1356→        [\"find\"](\".checkbox-cutaway-video-track\")\n  1357→        [\"each\"](function () {\n  1358→          if ($(this)[\"is\"](\":checked\"))\n  1359→            p[\"push\"](parseInt($(this)[\"val\"]()));\n  1360→        }),\n  1361→        {\n  1362→          boosts: g,\n  1363→          switchingFrequencyNow: J,\n  1364→          minShotDurationNow: W,\n  1365→          maxTimeEffectiveCutoffNow: F,\n  1366→          wideShotPercentageNow: h,\n  1367→          wideShotToleranceNow: V,\n  1368→          cutawayDurationMinNow: G,\n  1369→          cutawayDurationMaxNow: E,\n  1370→          cutawaysEnabledNow: U,\n  1371→          toList: K,\n  1372→          fromList: p,\n  1373→        }\n  1374→      );\n  1375→    }\n  1376→    function M(I) {\n  1377→      const g = {\n  1378→        yOxGW: \"checked\",\n  1379→        TrUzg: function (J, W) {\n  1380→          return J(W);\n  1381→        },\n  1382→      };\n  1383→      for (let J = 0; J < I[\"boosts\"][\"length\"]; J++) {\n  1384→        $(\"#range-mul\" + \"titrack-bo\" + \"ost-\" + J)[\"val\"](I[\"boosts\"][J]);\n  1385→      }\n  1386→      ($(\"#range-multitrack-switching-frequency\")\n  1387→      [\"val\"](I[\"switchingF\" + \"requencyNo\" + \"w\"])\n  1388→      [\"trigger\"](\"input\"),\n  1389→        $(\"#value-multitrack-switching-frequency\")[\"text\"](\n  1390→          parseInt(I[\"switchingF\" + \"requencyNo\" + \"w\"]),\n  1391→        ),\n  1392→        $(\n  1393→          \"#range-mul\" +\n  1394→          \"titrack-sw\" +\n  1395→          \"itching-mi\" +\n  1396→          \"nimum-shot\" +\n  1397→          \"-duration\",\n  1398→        )\n  1399→        [\"val\"](I[\"minShotDur\" + \"ationNow\"])\n  1400→        [\"trigger\"](\"input\"),\n  1401→        $(\"#value-multitrack-switching-minimum-shot-duration\")[\"text\"](\n  1402→          parseFloat(I[\"minShotDur\" + \"ationNow\"]),\n  1403→        ),\n  1404→        $(\"#range-multitrack-max-time\")\n  1405→        [\"val\"](I[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"])\n  1406→        [\"trigger\"](\"input\"),\n  1407→        $(\"#value-multitrack-max-time\")[\"text\"](\n  1408→          parseInt(I[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"]),\n  1409→        ),\n  1410→        typeof I[\"wideShotPe\" + \"rcentageNo\" + \"w\"] !== \"undefined\" &&\n  1411→        ($(\"#range-multitrack-wide-shot-percentage\")\n  1412→        [\"val\"](I[\"wideShotPe\" + \"rcentageNo\" + \"w\"])\n  1413→        [\"trigger\"](\"input\"),\n  1414→          $(\"#value-multitrack-wide-shot-percentage\")[\"text\"](\n  1415→            parseInt(I[\"wideShotPe\" + \"rcentageNo\" + \"w\"]),\n  1416→          )),\n  1417→        typeof I[\"wideShotTo\" + \"leranceNow\"] !== \"undefined\" &&\n  1418→        ($(\"#range-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\")\n  1419→        [\"val\"](I[\"wideShotTo\" + \"leranceNow\"])\n  1420→        [\"trigger\"](\"input\"),\n  1421→          $(\"#value-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\")[\"text\"](\n  1422→            parseInt(I[\"wideShotTo\" + \"leranceNow\"]),\n  1423→          )),\n  1424→        $(\"#range-cut\" + \"away-lengt\" + \"h\")[\"attr\"](\n  1425→          \"data-value\" + \"-min\",\n  1426→          I[\"cutawayDur\" + \"ationMinNo\" + \"w\"],\n  1427→        ),\n  1428→        $(\"#range-cut\" + \"away-lengt\" + \"h\")[\"attr\"](\n  1429→          \"data-value\" + \"-max\",\n  1430→          I[\"cutawayDur\" + \"ationMaxNo\" + \"w\"],\n  1431→        ),\n  1432→        $(\"#value-mul\" + \"titrack-cu\" + \"taway-dura\" + \"tion\")[\"text\"](\n  1433→          I[\"cutawayDur\" + \"ationMinNo\" + \"w\"] +\n  1434→          \"-\" +\n  1435→          I[\"cutawayDur\" + \"ationMaxNo\" + \"w\"],\n  1436→        ),\n  1437→        $(\"#checkbox-multitrack-cutaways\")\n  1438→        [\"prop\"](\"checked\", I[\"cutawaysEn\" + \"abledNow\"])\n  1439→        [\"trigger\"](\"input\"),\n  1440→        $(\"#multitrack-video-cutaway-tracks-list-to\")\n  1441→        [\"find\"](\".checkbox-cutaway-video-track\")\n  1442→        [\"each\"](function () {\n  1443→          $(this)[\"prop\"](\n  1444→            g[\"yOxGW\"],\n  1445→            I[\"toList\"][\"includes\"](g[\"TrUzg\"](parseInt, $(this)[\"val\"]())),\n  1446→          );\n  1447→        }),\n  1448→        $(\"#multitrack-video-cutaway-tracks-list-from\")\n  1449→        [\"find\"](\".checkbox-cutaway-video-track\")\n  1450→        [\"each\"](function () {\n  1451→          $(this)[\"prop\"](\n  1452→            \"checked\",\n  1453→            I[\"fromList\"][\"includes\"](parseInt($(this)[\"val\"]())),\n  1454→          );\n  1455→        }));\n  1456→    }\n  1457→    function o() {\n  1458→      const I = Array[\"from\"](\n  1459→        { length: g_multitrack_speaker_names[\"length\"] },\n  1460→        () => [],\n  1461→      );\n  1462→      for (let g = 0; g < g_multitrack_video_mapping[\"length\"]; g++) {\n  1463→        if (g_multitrack_video_mapping[g][\"length\"] === 1) {\n  1464→          const J = g_multitrack_video_mapping[g][0];\n  1465→          I[J][\"push\"](g);\n  1466→        }\n  1467→      }\n  1468→      return I;\n  1469→    }\n  1470→    let C = 1;\n  1471→    const w = 0x3bc + 0x242b * -0x1 + 0x206f + 0.01,\n  1472→      t = -50,\n  1473→      N = 50,\n  1474→      T = { min: 0xa, max: 0x64, step: 0x5 },\n  1475→      u = { min: 0.75, max: 0x3, step: 0.25 },\n  1476→      P = { min: 0xa, max: 0xf0, step: 0x5 },\n  1477→      d = { min: 0.5, max: 0x6, step: 0.25 };\n  1478→    ((function () {\n  1479→      const I = g_multitrack_speaker_names[\"length\"],\n  1480→        g = multitrack_wide_shots_available(),\n  1481→        J = (G) => {\n  1482→          const E = L();\n  1483→          ((E[\"boosts\"] = Array[\"from\"]({ length: I }, () => 0)),\n  1484→            (E[\"switchingF\" + \"requencyNo\" + \"w\"] = 50),\n  1485→            (E[\"minShotDur\" + \"ationNow\"] = 2),\n  1486→            (E[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] = 60),\n  1487→            (E[\"cutawaysEn\" + \"abledNow\"] = !!G),\n  1488→            (E[\"cutawayDur\" + \"ationMinNo\" + \"w\"] = 2),\n  1489→            (E[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] = 4));\n  1490→          if (g) {\n  1491→            const U = Math[\"round\"]((100 / (I + 1)) * 100) / 100;\n  1492→            E[\"wideShotPe\" + \"rcentageNo\" + \"w\"] = U;\n  1493→          }\n  1494→          return E;\n  1495→        },\n  1496→        W = J(!![]);\n  1497→      (M(W), $(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", !![]), l());\n  1498→      let F = H();\n  1499→      const h = J(![]);\n  1500→      (M(h),\n  1501→        $(\"#checkbox-\" + \"multitrack\" + \"-boost\")[\"prop\"](\"checked\", !![]),\n  1502→        l());\n  1503→      let V = H();\n  1504→      F[\"maxAbsErro\" + \"r\"] <= V[\"maxAbsErro\" + \"r\"]\n  1505→        ? (M(W),\n  1506→          $(\"#checkbox-\" + \"multitrack\" + \"-boost\")[\"prop\"](\"checked\", !![]))\n  1507→        : (M(h), $(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", !![]));\n  1508→    })(),\n  1509→      l());\n  1510→    let x = H(),\n  1511→      m = L();\n  1512→    (console[\"log\"](\n  1513→      \"Initial shares:\",\n  1514→      x[\"shares\"],\n  1515→      \"maxAbsError:\",\n  1516→      x[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1517→    ),\n  1518→      (function I() {\n  1519→        const g = g_multitrack_speaker_names[\"length\"],\n  1520→          J = [-4, -3, -2, -1, 0, 1, 2, 3, 4];\n  1521→        for (let h = 0; h < g; h++) {\n  1522→          let V = ![];\n  1523→          for (let G = 0; G < J[\"length\"]; G++) {\n  1524→            const E = L(),\n  1525→              U = E[\"boosts\"][\"slice\"]();\n  1526→            ((U[h] = Math[\"max\"](-6, Math[\"min\"](6, J[G]))),\n  1527→              (E[\"boosts\"] = U),\n  1528→              $(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", !![]),\n  1529→              M(E),\n  1530→              l());\n  1531→            const K = H();\n  1532→            if (\n  1533→              K[\"maxAbsErro\" + \"r\"] <\n  1534→              x[\"maxAbsErro\" + \"r\"] -\n  1535→              (-0x25bd * 0x1 + -0x1c * -0xa4 + 0x13cd + 0.0005)\n  1536→            ) {\n  1537→              ((x = K),\n  1538→                (m = L()),\n  1539→                (V = !![]),\n  1540→                console[\"log\"](\"Discrete boost accept\", {\n  1541→                  speaker: h,\n  1542→                  boost: U[h],\n  1543→                  maxAbsError: K[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1544→                }));\n  1545→              break;\n  1546→            }\n  1547→          }\n  1548→          !V && (M(m), l());\n  1549→        }\n  1550→        const W = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60];\n  1551→        for (let p = 0; p < W[\"length\"]; p++) {\n  1552→          const z0 = L();\n  1553→          ((z0[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] = W[p]), M(z0), l());\n  1554→          const z1 = H();\n  1555→          z1[\"maxAbsErro\" + \"r\"] <\n  1556→            x[\"maxAbsErro\" + \"r\"] -\n  1557→            (-0x24f7 * 0x1 + -0x20f4 * 0x1 + 0x45eb * 0x1 + 0.0005) &&\n  1558→            ((x = z1),\n  1559→              (m = L()),\n  1560→              console[\"log\"](\"Discrete cutoff accept\", {\n  1561→                maxTimeEffectiveCutoff: z0[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"],\n  1562→                maxAbsError: z1[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1563→              }));\n  1564→        }\n  1565→        (M(m), l());\n  1566→        const F = [\n  1567→          -0x104c * -0x1 + -0x2021 + 0xfd5 + 0.75,\n  1568→          1,\n  1569→          -0xfa1 + 0xc * 0x2c5 + 0x2 * -0x8cd + 0.25,\n  1570→          0x12ed + -0x20c0 + -0x1 * -0xdd4 + 0.5,\n  1571→          0x1595 + 0x26dd + -0x3c71 * 0x1 + 0.75,\n  1572→          2,\n  1573→          -0xe4c + -0x21da + 0x3028 + 0.25,\n  1574→          0xc * -0x13f + 0x20f3 * 0x1 + -0x11fd + 0.5,\n  1575→          0x356 * 0x3 + 0x1166 + 0x922 * -0x3 + 0.75,\n  1576→          3,\n  1577→        ];\n  1578→        for (let z2 = 0; z2 < F[\"length\"]; z2++) {\n  1579→          const z3 = L();\n  1580→          ((z3[\"minShotDur\" + \"ationNow\"] = F[z2]), M(z3), l());\n  1581→          const z4 = H();\n  1582→          z4[\"maxAbsErro\" + \"r\"] <\n  1583→            x[\"maxAbsErro\" + \"r\"] - 0x7 * -0x31c + -0x514 + 0x1ad8 + 0.0005 &&\n  1584→            ((x = z4),\n  1585→              (m = L()),\n  1586→              console[\"log\"](\"Discrete minShot accept\", {\n  1587→                minShotDuration: z3[\"minShotDur\" + \"ationNow\"],\n  1588→                maxAbsError: z4[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1589→              }));\n  1590→        }\n  1591→        (M(m), l());\n  1592→      })());\n  1593→    let q = 0;\n  1594→    const r = Date[\"now\"]();\n  1595→    while (!![]) {\n  1596→      q++;\n  1597→      let g = ![];\n  1598→      const J = g_multitrack_speaker_names[\"length\"],\n  1599→        W = o(),\n  1600→        F = x[\"target\"];\n  1601→      let h = null;\n  1602→      (function () {\n  1603→        const E = L();\n  1604→        ((E[\"boosts\"] = E[\"boosts\"][\"map\"]((K, p) => {\n  1605→          const z0 = Math[\"max\"](\n  1606→            t,\n  1607→            Math[\"min\"](N, K + C * (F - x[\"shares\"][p])),\n  1608→          );\n  1609→          return isNaN(z0) ? 0 : z0;\n  1610→        })),\n  1611→          M(E),\n  1612→          l());\n  1613→        const U = H();\n  1614→        U[\"maxAbsErro\" + \"r\"] <\n  1615→          x[\"maxAbsErro\" + \"r\"] - (0x238 * 0x1 + -0x15 * 0x65 + 0x611 + 0.0005)\n  1616→          ? ((x = U),\n  1617→            (m = L()),\n  1618→            (g = !![]),\n  1619→            console[\"log\"](\"Accepted boosts step\", {\n  1620→              boosts: E[\"boosts\"],\n  1621→              maxAbsError: U[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1622→            }))\n  1623→          : (M(m),\n  1624→            l(),\n  1625→            (C = Math[\"max\"](\n  1626→              0x8 * -0x399 + -0x1ef7 + 0x3bbf + 0.25,\n  1627→              C * 0x1a43 + 0x2 * -0x3e6 + -0xa3 * 0x1d + 0.75,\n  1628→            )),\n  1629→            console[\"log\"](\n  1630→              \"Reverted\\x20b\" +\n  1631→              \"oosts\\x20step\" +\n  1632→              \",\\x20annealed\" +\n  1633→              \"\\x20kBoost:\",\n  1634→              C[\"toFixed\"](2),\n  1635→            ));\n  1636→      })();\n  1637→      const V = [],\n  1638→        G = [];\n  1639→      for (let E = 0; E < J; E++) {\n  1640→        if (x[\"shares\"][E] < F) V[\"push\"](E);\n  1641→        else {\n  1642→          if (x[\"shares\"][E] > F) G[\"push\"](E);\n  1643→        }\n  1644→      }\n  1645→      ((function () {\n  1646→        if (V[\"length\"] === 0) return;\n  1647→        const U = L(),\n  1648→          K = Math[\"min\"](\n  1649→            T[\"max\"],\n  1650→            U[\"switchingF\" + \"requencyNo\" + \"w\"] + T[\"step\"],\n  1651→          );\n  1652→        if (K === U[\"switchingF\" + \"requencyNo\" + \"w\"]) return;\n  1653→        ((U[\"switchingF\" + \"requencyNo\" + \"w\"] = K), M(U), l());\n  1654→        const p = H();\n  1655→        p[\"maxAbsErro\" + \"r\"] <\n  1656→          x[\"maxAbsErro\" + \"r\"] - (0x1 * 0x2495 + -0x8c9 + -0x1bcc + 0.0005)\n  1657→          ? ((x = p),\n  1658→            (m = L()),\n  1659→            (g = !![]),\n  1660→            console[\"log\"](\"Accepted switchingFrequency step\", {\n  1661→              switchingFrequency: K,\n  1662→              maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1663→            }))\n  1664→          : (M(m), l(), console[\"log\"](\"Reverted switchingFrequency step\"));\n  1665→      })(),\n  1666→        (function () {\n  1667→          if (V[\"length\"] === 0) return;\n  1668→          const U = L(),\n  1669→            K = Math[\"max\"](\n  1670→              T[\"min\"],\n  1671→              U[\"switchingF\" + \"requencyNo\" + \"w\"] - T[\"step\"],\n  1672→            );\n  1673→          if (K === U[\"switchingF\" + \"requencyNo\" + \"w\"]) return;\n  1674→          ((U[\"switchingF\" + \"requencyNo\" + \"w\"] = K), M(U), l());\n  1675→          const p = H();\n  1676→          p[\"maxAbsErro\" + \"r\"] <\n  1677→            x[\"maxAbsErro\" + \"r\"] - 0x18ad + -0x1 * 0x337 + 0x1 * -0x1576 + 0.0005\n  1678→            ? ((x = p),\n  1679→              (m = L()),\n  1680→              (g = !![]),\n  1681→              console[\"log\"](\n  1682→                \"Accepted\\x20s\" + \"witchingFr\" + \"equency\\x20do\" + \"wn\\x20step\",\n  1683→                {\n  1684→                  switchingFrequency: K,\n  1685→                  maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1686→                },\n  1687→              ))\n  1688→            : (M(m),\n  1689→              l(),\n  1690→              console[\"log\"](\n  1691→                \"Reverted\\x20s\" + \"witchingFr\" + \"equency\\x20do\" + \"wn\\x20step\",\n  1692→              ));\n  1693→        })(),\n  1694→        (function () {\n  1695→          if (V[\"length\"] === 0) return;\n  1696→          const U = L(),\n  1697→            K = Math[\"max\"](u[\"min\"], U[\"minShotDur\" + \"ationNow\"] - u[\"step\"]);\n  1698→          if (K === U[\"minShotDur\" + \"ationNow\"]) return;\n  1699→          ((U[\"minShotDur\" + \"ationNow\"] = K), M(U), l());\n  1700→          const p = H();\n  1701→          p[\"maxAbsErro\" + \"r\"] <\n  1702→            x[\"maxAbsErro\" + \"r\"] - -0x116b + 0x1 * 0x2351 + -0x11e6 + 0.0005\n  1703→            ? ((x = p),\n  1704→              (m = L()),\n  1705→              (g = !![]),\n  1706→              console[\"log\"](\"Accepted minShotDuration step\", {\n  1707→                minShotDuration: K,\n  1708→                maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1709→              }))\n  1710→            : (M(m), l(), console[\"log\"](\"Reverted minShotDuration step\"));\n  1711→        })(),\n  1712→        (function () {\n  1713→          if (V[\"length\"] === 0) return;\n  1714→          const U = L(),\n  1715→            K = Math[\"min\"](u[\"max\"], U[\"minShotDur\" + \"ationNow\"] + u[\"step\"]);\n  1716→          if (K === U[\"minShotDur\" + \"ationNow\"]) return;\n  1717→          ((U[\"minShotDur\" + \"ationNow\"] = K), M(U), l());\n  1718→          const p = H();\n  1719→          p[\"maxAbsErro\" + \"r\"] <\n  1720→            x[\"maxAbsErro\" + \"r\"] - -0x13 * -0x9 + -0x148 + 0x9d + 0.0005\n  1721→            ? ((x = p),\n  1722→              (m = L()),\n  1723→              (g = !![]),\n  1724→              console[\"log\"](\"Accepted minShotDuration up step\", {\n  1725→                minShotDuration: K,\n  1726→                maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1727→              }))\n  1728→            : (M(m), l(), console[\"log\"](\"Reverted minShotDuration up step\"));\n  1729→        })(),\n  1730→        (function () {\n  1731→          if (V[\"length\"] === 0) return;\n  1732→          const U = L(),\n  1733→            K = Math[\"max\"](\n  1734→              P[\"min\"],\n  1735→              U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] - P[\"step\"],\n  1736→            );\n  1737→          if (K === U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"]) return;\n  1738→          ((U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] = K), M(U), l());\n  1739→          const p = H();\n  1740→          p[\"maxAbsErro\" + \"r\"] <\n  1741→            x[\"maxAbsErro\" + \"r\"] -\n  1742→            (-0x2 * 0x811 + -0x8e7 * -0x3 + 0xa93 * -0x1 + 0.0005)\n  1743→            ? ((x = p),\n  1744→              (m = L()),\n  1745→              (g = !![]),\n  1746→              console[\"log\"](\"Accepted maxTimeEffectiveCutoff step\", {\n  1747→                maxTimeEffectiveCutoff: K,\n  1748→                maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1749→              }))\n  1750→            : (M(m),\n  1751→              l(),\n  1752→              console[\"log\"](\"Reverted maxTimeEffectiveCutoff step\"));\n  1753→        })(),\n  1754→        (function () {\n  1755→          if (V[\"length\"] === 0) return;\n  1756→          const U = L(),\n  1757→            K = Math[\"min\"](\n  1758→              P[\"max\"],\n  1759→              U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] + P[\"step\"],\n  1760→            );\n  1761→          if (K === U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"]) return;\n  1762→          ((U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] = K), M(U), l());\n  1763→          const p = H();\n  1764→          p[\"maxAbsErro\" + \"r\"] <\n  1765→            x[\"maxAbsErro\" + \"r\"] - 0x43 * 0x86 + 0xf67 + -0x3279 + 0.0005\n  1766→            ? ((x = p),\n  1767→              (m = L()),\n  1768→              (g = !![]),\n  1769→              console[\"log\"](\n  1770→                \"Accepted\\x20m\" +\n  1771→                \"axTimeEffe\" +\n  1772→                \"ctiveCutof\" +\n  1773→                \"f\\x20up\\x20step\",\n  1774→                {\n  1775→                  maxTimeEffectiveCutoff: K,\n  1776→                  maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1777→                },\n  1778→              ))\n  1779→            : (M(m),\n  1780→              l(),\n  1781→              console[\"log\"](\"Reverted maxTimeEffectiveCutoff up step\"));\n  1782→        })());\n  1783→      (function () {\n  1784→        const U = L();\n  1785→        U[\"cutawaysEn\" + \"abledNow\"] = $(\"#checkbox-multitrack-cutaways\")[\"is\"](\n  1786→          \":checked\",\n  1787→        );\n  1788→        const K = $(\"#checkbox-multitrack-boost\")[\"is\"](\":checked\");\n  1789→        ($(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", !K), l());\n  1790→        const p = H();\n  1791→        p[\"maxAbsErro\" + \"r\"] <\n  1792→          x[\"maxAbsErro\" + \"r\"] - -0x1d30 + 0x1495 * -0x1 + 0x5d * 0x89 + 0.0005\n  1793→          ? ((x = p),\n  1794→            (m = L()),\n  1795→            (g = !![]),\n  1796→            console[\"log\"](\"Accepted boosts toggle\", {\n  1797→              boostsEnabled: !K,\n  1798→              maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1799→            }))\n  1800→          : ($(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", K),\n  1801→            M(m),\n  1802→            l(),\n  1803→            console[\"log\"](\"Reverted boosts toggle\"));\n  1804→      })();\n  1805→      ((function () {\n  1806→        const U = $(\"#checkbox-multitrack-cutaways\")[\"is\"](\":checked\");\n  1807→        ($(\"#checkbox-multitrack-cutaways\")[\"prop\"](\"checked\", !U), l());\n  1808→        const K = H();\n  1809→        K[\"maxAbsErro\" + \"r\"] <\n  1810→          x[\"maxAbsErro\" + \"r\"] -\n  1811→          0x1 * -0x2300 +\n  1812→          -0xf * 0x126 +\n  1813→          -0xa * -0x539 +\n  1814→          0.0005\n  1815→          ? ((x = K),\n  1816→            (m = L()),\n  1817→            (g = !![]),\n  1818→            console[\"log\"](\"Accepted\\x20c\" + \"utaways\\x20to\" + \"ggle\", {\n  1819→              cutawaysEnabled: !U,\n  1820→              maxAbsError: K[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1821→            }))\n  1822→          : ((h = { prev: U }),\n  1823→            console[\"log\"](\n  1824→              \"Cutaways\\x20t\" +\n  1825→              \"oggle\\x20kept\" +\n  1826→              \"\\x20temporari\" +\n  1827→              \"ly\\x20for\\x20com\" +\n  1828→              \"pound\\x20tria\" +\n  1829→              \"l\",\n  1830→            ));\n  1831→      })(),\n  1832→        (function () {\n  1833→          if (V[\"length\"] === 0 || G[\"length\"] === 0) return;\n  1834→          const U = L();\n  1835→          U[\"cutawaysEn\" + \"abledNow\"] = !![];\n  1836→          const K = new Set(),\n  1837→            p = new Set();\n  1838→          (V[\"forEach\"]((z3) => W[z3][\"forEach\"]((z4) => K[\"add\"](z4))),\n  1839→            G[\"forEach\"]((z3) => W[z3][\"forEach\"]((z4) => p[\"add\"](z4))),\n  1840→            (U[\"toList\"] = Array[\"from\"](K)),\n  1841→            (U[\"fromList\"] = Array[\"from\"](p)));\n  1842→          const z0 = Math[\"min\"](\n  1843→            d[\"max\"],\n  1844→            U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] + d[\"step\"],\n  1845→          ),\n  1846→            z1 = Math[\"min\"](\n  1847→              d[\"max\"],\n  1848→              Math[\"max\"](z0, U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] + d[\"step\"]),\n  1849→            );\n  1850→          ((U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] = z0),\n  1851→            (U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] = z1),\n  1852→            M(U),\n  1853→            l());\n  1854→          const z2 = H();\n  1855→          z2[\"maxAbsErro\" + \"r\"] <\n  1856→            x[\"maxAbsErro\" + \"r\"] - (0x17a8 + 0x4 * 0x8bf + -0x3aa4 + 0.0005)\n  1857→            ? ((x = z2),\n  1858→              (m = L()),\n  1859→              (g = !![]),\n  1860→              console[\"log\"](\"Accepted cutaway routing/duration step\", {\n  1861→                to: U[\"toList\"],\n  1862→                from: U[\"fromList\"],\n  1863→                cutawayDurationMin: U[\"cutawayDur\" + \"ationMinNo\" + \"w\"],\n  1864→                cutawayDurationMax: U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"],\n  1865→                maxAbsError: z2[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1866→              }))\n  1867→            : (M(m),\n  1868→              l(),\n  1869→              console[\"log\"](\"Reverted cutaway routing/duration step\"));\n  1870→        })(),\n  1871→        (function () {\n  1872→          if (V[\"length\"] === 0 || G[\"length\"] === 0) return;\n  1873→          const U = L();\n  1874→          U[\"cutawaysEn\" + \"abledNow\"] = !![];\n  1875→          const K = Math[\"max\"](\n  1876→            d[\"min\"],\n  1877→            U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] - d[\"step\"],\n  1878→          ),\n  1879→            p = Math[\"max\"](\n  1880→              K,\n  1881→              Math[\"max\"](\n  1882→                d[\"min\"],\n  1883→                U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] - d[\"step\"],\n  1884→              ),\n  1885→            );\n  1886→          if (\n  1887→            K === U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] &&\n  1888→            p === U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"]\n  1889→          )\n  1890→            return;\n  1891→          ((U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] = K),\n  1892→            (U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] = p),\n  1893→            M(U),\n  1894→            l());\n  1895→          const z0 = H();\n  1896→          z0[\"maxAbsErro\" + \"r\"] <\n  1897→            x[\"maxAbsErro\" + \"r\"] - (0xc1d + 0x1 * 0x527 + -0x1ba * 0xa + 0.0005)\n  1898→            ? ((x = z0),\n  1899→              (m = L()),\n  1900→              (g = !![]),\n  1901→              console[\"log\"](\"Accepted cutaway duration down step\", {\n  1902→                cutawayDurationMin: U[\"cutawayDur\" + \"ationMinNo\" + \"w\"],\n  1903→                cutawayDurationMax: U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"],\n  1904→                maxAbsError: z0[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1905→              }))\n  1906→            : (M(m),\n  1907→              l(),\n  1908→              console[\"log\"](\n  1909→                \"Reverted\\x20c\" +\n  1910→                \"utaway\\x20dur\" +\n  1911→                \"ation\\x20down\" +\n  1912→                \"\\x20step\",\n  1913→              ));\n  1914→        })(),\n  1915→        (function () {\n  1916→          const U = H();\n  1917→          if (U[\"includeWid\" + \"e\"]) {\n  1918→            const K = U[\"numSpeaker\" + \"s\"] + 1,\n  1919→              p = Math[\"round\"]((100 / K) * 100) / 100;\n  1920→            $(\"#range-multitrack-wide-shot-percentage\")\n  1921→            [\"val\"](p)\n  1922→            [\"trigger\"](\"input\");\n  1923→            try {\n  1924→              test_101_finetune_multitrack_wide_shot_tolerance();\n  1925→            } catch (z1) { }\n  1926→            l();\n  1927→            const z0 = H();\n  1928→            z0[\"maxAbsErro\" + \"r\"] <\n  1929→              x[\"maxAbsErro\" + \"r\"] -\n  1930→              -0xd4 * -0x1f +\n  1931→              -0x9b * 0x1 +\n  1932→              0xcf * -0x1f +\n  1933→              0.0005\n  1934→              ? ((x = z0),\n  1935→                (m = L()),\n  1936→                (g = !![]),\n  1937→                console[\"log\"](\n  1938→                  \"Accepted wide finetune toward ~equal entity share\",\n  1939→                  {\n  1940→                    targetWidePercent: p,\n  1941→                    maxAbsError: z0[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1942→                  },\n  1943→                ))\n  1944→              : (M(m), l(), console[\"log\"](\"Reverted wide finetune step\"));\n  1945→          }\n  1946→        })());\n  1947→      h &&\n  1948→        !g &&\n  1949→        ($(\"#checkbox-\" + \"multitrack\" + \"-cutaways\")[\"prop\"](\n  1950→          \"checked\",\n  1951→          h[\"prev\"],\n  1952→        ),\n  1953→          M(m),\n  1954→          l(),\n  1955→          console[\"log\"](\"Cutaways trial reverted after sweep\"));\n  1956→      console[\"log\"](\n  1957→        \"Sweep\",\n  1958→        q,\n  1959→        \"best maxAbsError:\",\n  1960→        x[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n  1961→        \"shares:\",\n  1962→        x[\"shares\"][\"map\"]((U) => Number(U[\"toFixed\"](4))),\n  1963→      );\n  1964→      if (x[\"maxAbsErro\" + \"r\"] <= w && !g) {\n  1965→        (M(m),\n  1966→          l(),\n  1967→          console[\"log\"](\n  1968→            \"Auto-balance converged to \\u22641% after full sweep.\",\n  1969→          ));\n  1970→        break;\n  1971→      }\n  1972→      if (Date[\"now\"]() - r > 10000) {\n  1973→        (console[\"log\"](\n  1974→          \"Auto-balan\" +\n  1975→          \"ce\\x20timeout\" +\n  1976→          \"\\x20reached\\x20(\" +\n  1977→          \"10s).\\x20Appl\" +\n  1978→          \"ying\\x20best-\" +\n  1979→          \"found\\x20sett\" +\n  1980→          \"ings\\x20and\\x20e\" +\n  1981→          \"xiting.\",\n  1982→        ),\n  1983→          M(m),\n  1984→          l());\n  1985→        break;\n  1986→      }\n  1987→      await new Promise((U) => setTimeout(U, 0));\n  1988→    }\n  1989→  } catch (U) {\n  1990→    (tracker[\"error\"](\n  1991→      \"test_102_a\" +\n  1992→      \"uto_tune_m\" +\n  1993→      \"ultitrack_\" +\n  1994→      \"distributi\" +\n  1995→      \"on\\x20failed\",\n  1996→    ),\n  1997→      console[\"error\"](U));\n  1998→    throw U;\n  1999→  } finally {\n  2000→    ($(\"#multitrack-screentime-chart\")[\"length\"] &&\n  2001→      $(\"html, body\")[\"animate\"](\n  2002→        {\n  2003→          scrollTop: $(\"#multitrack-screentime-chart\")[\"offset\"]()[\"top\"] - 25,\n  2004→        },\n  2005→        200,\n  2006→      ),\n  2007→      $(\"#button-multitrack-auto-balance\")[\"prop\"](\"disabled\", ![]),\n  2008→      hideSpinner(),\n  2009→      tracker[\"end\"](k));\n  2010→  }\n  2011→}\n  2012→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"19e5ff69-d1a1-4fdc-9174-7338a754016a","timestamp":"2025-12-25T18:00:55.894Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/helpers_clean.js","content":"function test_51_decide_multicam_cuts(\n  smoothing_window = null,\n  cutaways_enabled = null,\n  max_time = null,\n  cutaway_min_len = null,\n  cutaway_max_len = null,\n  wide_shot_tolerance = null,\n  Y = null,\n  R = null,\n) {\n  const Z = {\n    eahhi: function (T, u) {\n      return T(u);\n    },\n    poGJN: \":checked\",\n    WSbTq: function (T, u) {\n      return T(u);\n    },\n    QxEvv: function (T, u) {\n      return T(u);\n    },\n    ICkdl: function (T, u) {\n      return T == u;\n    },\n    osEKp: function (T, u) {\n      return T * u;\n    },\n    FyQAu: function (T, u) {\n      return T - u;\n    },\n    ejgoS: function (T, u) {\n      return T(u);\n    },\n    dJyIa: \"#range-mul\" + \"titrack-sw\" + \"itching-fr\" + \"equency\",\n    rgXeY: function (T, u) {\n      return T * u;\n    },\n    uzqrn: function (T, u) {\n      return T / u;\n    },\n    GYHpJ: function (T, u) {\n      return T(u);\n    },\n    ZyQaz: function (T, u) {\n      return T == u;\n    },\n    jPpSw: function (T, u) {\n      return T(u);\n    },\n    dqTGl: function (T, u) {\n      return T(u);\n    },\n    mKziM: \"#range-mul\" + \"titrack-ma\" + \"x-time\",\n    myBEI: function (T, u) {\n      return T(u);\n    },\n    cfGQC: function (T, u) {\n      return T(u);\n    },\n    RBBno: \"#range-cut\" + \"away-lengt\" + \"h\",\n    DGYeb: function (T, u) {\n      return T(u);\n    },\n    hWTRQ: function (T, u) {\n      return T(u);\n    },\n    DbgUe: \"#checkbox-\" + \"multitrack\" + \"-cutaways\",\n    DMzRS: function (T, u) {\n      return T == u;\n    },\n    tzzOs: function (T, u) {\n      return T(u);\n    },\n    jKijF: function (T, u) {\n      return T(u);\n    },\n    jUiAE: \"#range-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\",\n    OlIJH: function (T, u) {\n      return T(u);\n    },\n    lavNG: \"#multitrac\" + \"max_time-video-cu\" + \"taway-trac\" + \"ks-list-to\",\n    UNkJq: \".checkbox-\" + \"cutaway-vi\" + \"deo-track\",\n    wUXJh: function (T, u) {\n      return T(u);\n    },\n    Pflpz: \"#multitrac\" + \"max_time-video-cu\" + \"taway-trac\" + \"ks-list-fr\" + \"om\",\n    dqYbn: function (T, u) {\n      return T < u;\n    },\n    Pubka: function (T, u) {\n      return T < u;\n    },\n    NPBxG: function (T, u) {\n      return T === u;\n    },\n    xoKgM: function (T, u) {\n      return T < u;\n    },\n    lSYAw: function (T, u) {\n      return T < u;\n    },\n    hklwg: function (T, u) {\n      return T > u;\n    },\n    yQEwl: function (T, u) {\n      return T(u);\n    },\n    tTCtb: \"#checkbox-\" + \"multitrack\" + \"-boost\",\n    iWatM: function (T, u) {\n      return T < u;\n    },\n    newFU: function (T, u) {\n      return T + u;\n    },\n    eeSYc: \"Error\\x20appl\" + \"ying\\x20speak\" + \"er\\x20boosts\",\n    uctqB: function (T, u) {\n      return T < u;\n    },\n    eMeje: function (T, u) {\n      return T > u;\n    },\n    DveaP: function (T, u) {\n      return T == u;\n    },\n    ZPEZf: function (T, u) {\n      return T == u;\n    },\n    OWwpz: function (T, u) {\n      return T - u;\n    },\n    QfdQD: function (T, u) {\n      return T < u;\n    },\n    zhnnb: function (T, u) {\n      return T != u;\n    },\n    mPXBr: function (T, u) {\n      return T(u);\n    },\n    VpEls: \"#range-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\",\n    Axtsu: function (T, u, P) {\n      return T(u, P);\n    },\n    oAHsH: function (T, u) {\n      return T > u;\n    },\n    pvASx: function (T, u) {\n      return T < u;\n    },\n    ADnlS: function (T, u) {\n      return T > u;\n    },\n    BOhlD: function (T, u) {\n      return T == u;\n    },\n    cJKIa: \"Wide\\x20(mult\" + \".\\x20speakers\" + \")\",\n    bhVBA: function (T, u) {\n      return T - u;\n    },\n    EEMuI: function (T, u) {\n      return T < u;\n    },\n    xiKKU: \"Error\\x20pick\" + \"ing\\x20wide\\x20s\" + \"hot\",\n    lPuwu: function (T, u) {\n      return T == u;\n    },\n    gsvFy: function (T, u) {\n      return T - u;\n    },\n    JWjNa: function (T, u) {\n      return T < u;\n    },\n    jknsx: function (T, u) {\n      return T < u;\n    },\n    KVYOO: function (T, u) {\n      return T - u;\n    },\n    gErNW: function (T, u) {\n      return T + u;\n    },\n    PJQqS: function (T, u) {\n      return T == u;\n    },\n    spyjr: function (T, u) {\n      return T == u;\n    },\n    dnVfx: function (T, u) {\n      return T + u;\n    },\n    FTfdQ: function (T, u) {\n      return T + u;\n    },\n    thyho: function (T, u) {\n      return T / u;\n    },\n    NTMqW: function (T, u) {\n      return T < u;\n    },\n    CgNcL: function (T, u) {\n      return T / u;\n    },\n    gldFo: function (T, u) {\n      return T - u;\n    },\n    wZmQn: function (T, u) {\n      return T == u;\n    },\n    aLrJM: function (T, u) {\n      return T < u;\n    },\n    HAWbu: function (T, u) {\n      return T > u;\n    },\n    eaoMK: function (T, u) {\n      return T * u;\n    },\n    AAqvQ: function (T, u) {\n      return T == u;\n    },\n    HKFuA: function (T, u) {\n      return T * u;\n    },\n    WcJXk: function (T, u) {\n      return T == u;\n    },\n    ZfJhu: function (T, u) {\n      return T - u;\n    },\n    oCgJA: function (T, u) {\n      return T - u;\n    },\n    dzyDn: function (T, u) {\n      return T - u;\n    },\n    rLfRf: function (T, u) {\n      return T - u;\n    },\n    xdCuJ: function (T, u) {\n      return T < u;\n    },\n  };\n  smoothing_window == null &&\n    ((switching_frequency = parseInt(\n      $(\"#range-multitrack-switching-frequency\")[\"val\"](),\n    )),\n      (smoothing_window = parseInt(\n        -0x778 + -0x250c + 0x2cc0 - 60 * (switching_frequency / 100),\n      )),\n      (smoothing_window = parseInt(smoothing_window / 10)));\n  max_time == null && (max_time = parseInt($(\"#range-multitrack-max-time\")[\"val\"]()));\n  cutaway_min_len == null &&\n    (cutaway_min_len = parseInt($(\"#range-cutaway-length\")[\"attr\"](\"data-value\" + \"-min\")));\n  cutaway_max_len == null &&\n    (cutaway_max_len = parseInt($(\"#range-cutaway-length\")[\"attr\"](\"data-value\" + \"-max\")));\n  cutaways_enabled == null && (cutaways_enabled = $(\"#checkbox-multitrack-cutaways\")[\"is\"](\":checked\"));\n  wide_shot_tolerance == null &&\n    (wide_shot_tolerance = parseInt($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"]()));\n  let Q = [];\n  $(\"#multitrack-video-cutaway-tracks-list-to\")\n  [\"find\"](\".checkbox-cutaway-video-track\")\n  [\"each\"](function () {\n    $(this)[\"is\"](\":checked\") && Q[\"push\"](parseInt($(this)[\"val\"]()));\n  });\n  let s = [];\n  $(\"#multitrack-video-cutaway-tracks-list-from\")\n  [\"find\"](\".checkbox-cutaway-video-track\")\n  [\"each\"](function () {\n    $(this)[\"is\"](\":checked\") && s[\"push\"](parseInt($(this)[\"val\"]()));\n  });\n  let c = parseFloat(\n    $(\n      \"#range-mul\" + \"titrack-sw\" + \"itching-mi\" + \"nimum-shot\" + \"-duration\",\n    )[\"val\"](),\n  ),\n    y = 0,\n    O = 0,\n    b = [];\n  for (let T = 0; T < g_num_speakers; T++) {\n    let u = null,\n      P = Infinity;\n    for (let d = 0; d < g_multitrack_video_mapping[\"length\"]; d++) {\n      g_multitrack_video_mapping[d][\"includes\"](T) &&\n        g_multitrack_video_mapping[d][\"length\"] < P &&\n        ((u = d), (P = g_multitrack_video_mapping[d][\"length\"]));\n    }\n    b[\"push\"]([u]);\n  }\n  for (let x = 0; x < g_num_speakers; x++) {\n    const m = g_multitrack_video_mapping[b[x][0]][\"length\"];\n    for (let q = 0; q < g_multitrack_video_mapping[\"length\"]; q++) {\n      (g_multitrack_video_mapping[q][\"includes\"](x) &&\n        g_multitrack_video_mapping[q][\"length\"] === m &&\n        b[x][\"push\"](q),\n        (b[x] = [...new Set(b[x])]));\n    }\n  }\n  let S = [];\n  for (let r = 0; r < g_num_speakers; r++) {\n    let f = [];\n    for (let X = 0; X < g_multitrack_video_mapping[\"length\"]; X++) {\n      g_multitrack_video_mapping[X][\"includes\"](r) &&\n        g_multitrack_video_mapping[X][\"length\"] === 1 &&\n        f[\"push\"](X);\n    }\n    S[\"push\"](f);\n  }\n  let l = Array(g_num_speakers)[\"fill\"](-1);\n  function e(D, I) {\n    let g = b[D];\n    if (g[\"length\"] == 1) return g[0];\n    const v = g[Math[\"floor\"](g_shots_random_floats_array[I] * g[\"length\"])];\n    return v;\n  }\n  let H = [];\n  for (let D = 0; D < g_multitrack_video_mapping[\"length\"]; D++) {\n    !b[\"flat\"]()[\"includes\"](D) &&\n      g_multitrack_video_mapping[D][\"length\"] > 0 &&\n      H[\"push\"](D);\n  }\n  cleaned_up_levels_blurred = JSON[\"parse\"](\n    JSON[\"stringify\"](g_cleaned_up_levels),\n  );\n  if (smoothing_window > 0)\n    for (let I = 0; I < cleaned_up_levels_blurred[\"length\"]; I++) {\n      cleaned_up_levels_blurred[I] = tools[\"applyGauss\" + \"ianBlur\"](\n        g_cleaned_up_levels[I],\n        smoothing_window,\n      );\n    }\n  try {\n    if ($(\"#checkbox-multitrack-boost\")[\"is\"](\":checked\")) {\n      let g = Array[\"from\"]({ length: g_num_speakers }, () => 0);\n      for (let v = 0; v < g_num_speakers; v++) {\n        g[v] = parseFloat($(\"#range-mul\" + \"titrack-bo\" + \"ost-\" + v)[\"val\"]());\n      }\n      for (let J = 0; J < cleaned_up_levels_blurred[\"length\"]; J++) {\n        let W = g[J];\n        for (let F = 0; F < cleaned_up_levels_blurred[J][\"length\"]; F++) {\n          cleaned_up_levels_blurred[J][F] = cleaned_up_levels_blurred[J][F] + W;\n        }\n      }\n    }\n  } catch (h) {\n    console[\"error\"](\"Error applying speaker boosts\", h);\n  }\n  ((max_levels = tools[\"max_of_arr\" + \"ays\"](cleaned_up_levels_blurred)),\n    (decisions_raw_audio = Array(cleaned_up_levels_blurred[0][\"length\"])));\n  let L = Array[\"from\"](\n    {\n      length: cleaned_up_levels_blurred[0][\"length\"],\n    },\n    () => new Set(),\n  ),\n    M = max_levels[\"map\"]((V) => V - wide_shot_tolerance);\n  for (let V = 0; V < cleaned_up_levels_blurred[0][\"length\"]; V++) {\n    for (let G = 0; G < cleaned_up_levels_blurred[\"length\"]; G++) {\n      if (\n        Math[\"abs\"](cleaned_up_levels_blurred[G][V] - max_levels[V]) <\n        -0x14a + 0x85 + 0xc5 + 0.01\n      )\n        ((decisions_raw_audio[V] = G), L[V][\"add\"](G));\n      else cleaned_up_levels_blurred[G][V] > M[V] && L[V][\"add\"](G);\n    }\n    ((L[V] = Array[\"from\"](L[V])),\n      decisions_raw_audio[V] == null &&\n      (V == 0\n        ? (decisions_raw_audio[V] = 0)\n        : (decisions_raw_audio[V] = decisions_raw_audio[V - 1])));\n  }\n  let o = [],\n    C = decisions_raw_audio[0],\n    w = L[0],\n    t = g_audio_track_times[0];\n  for (let E = 1; E < decisions_raw_audio[\"length\"]; E++) {\n    if (\n      !tools[\"arraysEqua\" + \"lIgnoreOrd\" + \"er\"](L[E], w) ||\n      E == decisions_raw_audio[\"length\"] - 1\n    ) {\n      let U = g_audio_track_times[E],\n        K = L[E],\n        p = decisions_raw_audio[E] != C,\n        z0 = !tools[\"arraysEqua\" + \"lIgnoreOrd\" + \"er\"](L[E], w),\n        z1 = parseInt($(\"#range-multitrack-wide-shot-percentage\")[\"val\"]()),\n        z2 = z1 > 0,\n        z3 = e(C, o[\"length\"]),\n        z4 = \"Speaker\";\n      if (w[\"length\"] > 1 && z2) {\n        let z6 = [],\n          z7 = 0;\n        for (let z8 = 0; z8 < g_multitrack_video_mapping[\"length\"]; z8++) {\n          let z9 = w[\"filter\"]((zz) =>\n            g_multitrack_video_mapping[z8][\"includes\"](zz),\n          )[\"length\"];\n          if (z9 > z7) ((z6 = [z8]), (z7 = z9));\n          else z9 == z7 && z6[\"push\"](z8);\n        }\n        if (z6[\"length\"] > 0 && z7 > 1)\n          try {\n            z3 = z6[\"reduce\"]((zk, zA) =>\n              g_multitrack_video_mapping[zk][\"length\"] <\n                g_multitrack_video_mapping[zA][\"length\"]\n                ? zk\n                : zA,\n            );\n            let zz = Math[\"min\"](\n              ...z6[\"map\"]((zk) => g_multitrack_video_mapping[zk][\"length\"]),\n            ),\n              zn = z6[\"filter\"](\n                (zk) => g_multitrack_video_mapping[zk][\"length\"] == zz,\n              );\n            if (zn[\"length\"] == 1)\n              ((z3 = zn[0]), (z4 = \"Wide (mult. speakers)\"));\n            else {\n              for (let zk = o[\"length\"] - 1; zk >= 0; zk--) {\n                let zA = o[zk];\n                if (zA[\"time_range\"][1] - zA[\"time_range\"][0] < c) continue;\n                zn[\"includes\"](zA[\"video_inde\" + \"x\"]) &&\n                  (zn = zn[\"filter\"]((za) => za != zA[\"video_inde\" + \"x\"]));\n                if (zn[\"length\"] == 1) break;\n              }\n              ((z3 = zn[0]), (z4 = \"Wide (mult. speakers)\"));\n            }\n          } catch (za) {\n            tracker[\"error\"](\"Error picking wide shot\", za);\n          }\n      }\n      let z5;\n      (w[\"length\"] == 1\n        ? (z5 = g_multitrack_speaker_names[C])\n        : (z5 = w[\"map\"]((zB) => g_multitrack_speaker_names[zB])\n        [\"sort\"]()\n        [\"join\"](\",\\x20\")),\n        (section = {\n          speaker: z5,\n          speakers: w[\"map\"]((zB) => g_multitrack_speaker_names[zB])[\"sort\"](),\n          audio_index: C,\n          video_index: z3,\n          time_range: [t, g_audio_track_times[E]],\n          reason: z4,\n          override: ![],\n          override_index: null,\n        }),\n        o[\"push\"](JSON[\"parse\"](JSON[\"stringify\"](section))),\n        (C = decisions_raw_audio[E]),\n        (t = g_audio_track_times[E]),\n        (w = L[E]));\n    }\n  }\n  for (let zB = 0; zB < o[\"length\"]; zB++) {\n    ((decision_length = o[zB][\"time_range\"][1] - o[zB][\"time_range\"][0]),\n      decision_length < c &&\n      (zB > 0\n        ? ((o[zB - 1][\"time_range\"][1] = o[zB][\"time_range\"][1]),\n          o[\"splice\"](zB, 1),\n          zB--)\n        : ((o[zB + 1][\"time_range\"][0] = o[zB][\"time_range\"][0]),\n          o[\"splice\"](zB, 1),\n          zB--)));\n  }\n  for (let zY = 0; zY < o[\"length\"] - 1; zY++) {\n    (o[zY][\"video_inde\" + \"x\"] == o[zY + 1][\"video_inde\" + \"x\"] ||\n      tools[\"arraysEqua\" + \"lIgnoreOrd\" + \"er\"](\n        o[zY][\"speakers\"],\n        o[zY + 1][\"speakers\"],\n      )) &&\n      ((o[zY][\"time_range\"][1] = o[zY + 1][\"time_range\"][1]),\n        (o[zY][\"reason\"] == \"Wide\\x20(mult\" + \".\\x20speakers\" + \")\" ||\n          o[zY + 1][\"reason\"] == \"Wide (mult. speakers)\") &&\n        (o[zY][\"reason\"] = \"Wide (mult. speakers)\"),\n        o[\"splice\"](zY + 1, 1),\n        zY--);\n  }\n  let N = (max_time - cutaway_max_len) / 2;\n  if (cutaways_enabled)\n    for (let zR = 0; zR < o[\"length\"]; zR++) {\n      decision_length = o[zR][\"time_range\"][1] - o[zR][\"time_range\"][0];\n      if (decision_length > max_time) {\n        num_cuts = Math[\"floor\"]((decision_length - N) / N + cutaway_max_len);\n        let zZ = o[zR][\"time_range\"][1],\n          zQ = o[zR][\"speaker\"],\n          zs = o[zR][\"speakers\"],\n          zj = o[zR][\"audio_inde\" + \"x\"],\n          zc = o[zR][\"video_inde\" + \"x\"],\n          zy = Q;\n        zy = zy[\"filter\"]((zS) => zS != zc);\n        if (zy[\"length\"] == 0) continue;\n        if (!s[\"includes\"](zc)) continue;\n        o[zR][\"time_range\"][1] = o[zR][\"time_range\"][0] + N;\n        let zO = o[zR][\"time_range\"][1],\n          zb = null;\n        for (let zS = 0; zS < num_cuts; zS++) {\n          let zl = zy;\n          zS > 0 && zl[\"length\"] > 1 && (zl = zl[\"filter\"]((zw) => zw != zb));\n          zl[\"length\"] == 0 &&\n            ((other_speakers = Array[\"from\"](\n              Array(g_multitrack_speaker_names[\"length\"])[\"keys\"](),\n            )),\n              (other_speakers = other_speakers[\"filter\"]((zw) => zw != zj)),\n              (zl = other_speakers[\"map\"]((zw) => b[zw])[\"flat\"]()));\n          let ze = Math[\"floor\"](g_shots_random_floats_array[y] * zl[\"length\"]),\n            zH = zl[ze];\n          y++;\n          let zL = cutaway_min_len + g_multicam_cutaway_random_floats_array[O] * (cutaway_max_len - cutaway_min_len);\n          (O++,\n            (new_decision_B = {\n              speaker: zQ,\n              speakers: zs,\n              audio_index: zj == 0 ? 1 : 0,\n              video_index: zH,\n              time_range: [zO, zO + zL],\n              reason:\n                g_multitrack_video_mapping[zH][\"length\"] == 1\n                  ? \"Cutaway\"\n                  : \"Cutaway\\x20(w\" + \"ide)\",\n              override: ![],\n              override_index: null,\n            }),\n            (new_decision_B = JSON[\"parse\"](JSON[\"stringify\"](new_decision_B))),\n            (zO += zL));\n          let zM = Array[\"from\"](new Set([...b[zj], ...H]));\n          ((zM = zM[\"filter\"]((zw) => zw != zH)),\n            (zM = zM[\"filter\"]((zw) => {\n              return g_multitrack_video_mapping[zw][\"includes\"](zj);\n            })));\n          let zo = Math[\"floor\"](g_shots_random_floats_array[y] * zM[\"length\"]),\n            zC = zM[zo];\n          ((zb = zC),\n            y++,\n            (new_decision_A = {\n              speaker: zQ,\n              speakers: zs,\n              audio_index: zj,\n              video_index: zC,\n              time_range: [zO, zO + N],\n              reason: b[zj][\"includes\"](zC)\n                ? \"Speaker\"\n                : \"Speaker\\x20(cutaway_max_len\" + \"lt.\\x20)\",\n              override: ![],\n              override_index: null,\n            }),\n            zS == num_cuts - 1 && (new_decision_A[\"time_range\"][1] = zZ),\n            (new_decision_A = JSON[\"parse\"](JSON[\"stringify\"](new_decision_A))),\n            (zO += N),\n            o[\"push\"](new_decision_B),\n            o[\"push\"](new_decision_A));\n        }\n      }\n    }\n  (o[\"sort\"](function (zw, zt) {\n    return zw[\"time_range\"][0] - zt[\"time_range\"][0];\n  }),\n    (o[0][\"time_range\"][0] = Math[\"max\"](\n      0,\n      o[0][\"time_range\"][0] - 0x99e + 0x12 * 0x20b + -0x1 * 0x2e64 + 0.375,\n    )),\n    (o[o[\"length\"] - 1][\"time_range\"][1] =\n      o[o[\"length\"] - 1][\"time_range\"][1] +\n      -0x106b +\n      -0x10d2 +\n      0x213d +\n      0.375));\n  for (let zw = 0; zw < g_multitrack_decision_overrides[\"length\"]; zw++) {\n    for (let zt = 0; zt < o[\"length\"]; zt++) {\n      g_multitrack_decision_overrides[zw][\"time\"] >= o[zt][\"time_range\"][0] &&\n        g_multitrack_decision_overrides[zw][\"time\"] < o[zt][\"time_range\"][1] &&\n        ((o[zt][\"override\"] = !![]),\n          (o[zt][\"override_i\" + \"ndex\"] = zw),\n          (o[zt][\"video_inde\" + \"x\"] =\n            g_multitrack_decision_overrides[zw][\"video_inde\" + \"x\"]));\n    }\n  }\n  g_multitrack_decisions = JSON[\"parse\"](JSON[\"stringify\"](o));\n}\nfunction test_52_validate_multitrack_selections() {\n  const smoothing_window = {\n    FEjBG: function (cutaways_enabled, max_time) {\n      return cutaways_enabled < max_time;\n    },\n    aTCgG: function (cutaways_enabled, max_time) {\n      return cutaways_enabled(max_time);\n    },\n    CyWXJ:\n      \"Please\\x20use\" + \"\\x20at\\x20least\\x20\" + \"2\\x20video\\x20tr\" + \"acks\",\n    UrFWQ: function (cutaways_enabled, max_time) {\n      return cutaways_enabled(max_time);\n    },\n    YkYEe: function (cutaways_enabled, max_time) {\n      return cutaways_enabled < max_time;\n    },\n    yQSGa:\n      \"Please\\x20mak\" +\n      \"e\\x20sure\\x20all\" +\n      \"\\x20speakers\\x20\" +\n      \"are\\x20covere\" +\n      \"d\\x20by\\x20the\\x20v\" +\n      \"ideo\\x20track\" +\n      \"s.\",\n  };\n  nonzero_video_tracks = g_multitrack_video_mapping_selection_indices[\"filter\"](\n    (cutaways_enabled) => cutaways_enabled != 0,\n  );\n  if (nonzero_video_tracks[\"length\"] < 2)\n    return (showError(\"Please use at least 2 video tracks\"), ![]);\n  speaker_covered = Array(g_multitrack_speaker_names[\"length\"])[\"fill\"](![]);\n  for (let cutaways_enabled = 0; cutaways_enabled < g_multitrack_video_mapping[\"length\"]; cutaways_enabled++) {\n    for (\n      let max_time = 0;\n      g_multitrack_video_mapping[cutaways_enabled][\"length\"] <\n      g_multitrack_video_mapping[cutaways_enabled][\"length\"];\n      max_time++\n    ) {\n      speaker_covered[g_multitrack_video_mapping[cutaways_enabled][max_time]] = !![];\n    }\n  }\n  if (speaker_covered[\"includes\"](![]))\n    return (\n      showError(\n        \"Please make sure all speakers are covered by the video tracks.\",\n      ),\n      ![]\n    );\n  return !![];\n}\nfunction test_100_get_multitrack_screentime_summary() {\n  const smoothing_window = {\n    BMZvm: function (cutaway_min_len, cutaway_max_len) {\n      return cutaway_min_len < cutaway_max_len;\n    },\n    Kaolc: function (cutaway_min_len, cutaway_max_len) {\n      return cutaway_min_len == cutaway_max_len;\n    },\n    cyxMB: function (cutaway_min_len, cutaway_max_len) {\n      return cutaway_min_len > cutaway_max_len;\n    },\n    xvFWw: function (cutaway_min_len, cutaway_max_len) {\n      return cutaway_min_len - cutaway_max_len;\n    },\n  };\n  let cutaways_enabled = Array[\"from\"](\n    { length: g_multitrack_video_mapping[\"length\"] },\n    () => 0,\n  );\n  for (let cutaway_min_len = 0; cutaway_min_len < g_multitrack_decisions[\"length\"]; cutaway_min_len++) {\n    const cutaway_max_len = g_multitrack_decisions[cutaway_min_len];\n    cutaways_enabled[cutaway_max_len[\"video_inde\" + \"x\"]] += cutaway_max_len[\"time_range\"][1] - cutaway_max_len[\"time_range\"][0];\n  }\n  let max_time = Array[\"from\"](\n    {\n      length: g_multitrack_speaker_names[\"length\"] + 1,\n    },\n    () => 0,\n  );\n  for (let wide_shot_tolerance = 0; wide_shot_tolerance < g_multitrack_video_mapping[\"length\"]; wide_shot_tolerance++) {\n    if (g_multitrack_video_mapping[wide_shot_tolerance][\"length\"] == 0) continue;\n    else\n      g_multitrack_video_mapping[wide_shot_tolerance][\"length\"] > 1\n        ? (max_time[max_time[\"length\"] - 1] += cutaways_enabled[wide_shot_tolerance])\n        : (max_time[g_multitrack_video_mapping[wide_shot_tolerance][0]] += cutaways_enabled[wide_shot_tolerance]);\n  }\n  return max_time;\n}\nvar multitrack_wide_shot_percentage_acceptable_error = 1,\n  multitrack_wide_shot_finetune_step_size = 0x27d * 0xd + -0x2405 + 0x3ac + 0.1;\nfunction test_101_finetune_multitrack_wide_shot_tolerance() {\n  const smoothing_window = {\n    BerEx: function (Z, Q) {\n      return Z(Q);\n    },\n    MowVw: function (Z, Q) {\n      return Z === Q;\n    },\n    KkwnW: \"#range-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\",\n    FafhB: function (Z) {\n      return Z();\n    },\n    CDcqU: function (Z, Q) {\n      return Z === Q;\n    },\n    niHxX: function (Z, Q) {\n      return Z <= Q;\n    },\n    DyYGO: function (Z, Q) {\n      return Z + Q;\n    },\n    COhgN: function (Z) {\n      return Z();\n    },\n    mcjgW: function (Z, Q) {\n      return Z * Q;\n    },\n    fYaxm: function (Z, Q) {\n      return Z / Q;\n    },\n    LAqSU: function (Z, Q) {\n      return Z - Q;\n    },\n    UpulG: function (Z, Q) {\n      return Z > Q;\n    },\n    oquVL: function (Z, Q) {\n      return Z < Q;\n    },\n    FvPRv: function (Z, Q) {\n      return Z === Q;\n    },\n    MHBVQ: function (Z, Q) {\n      return Z !== Q;\n    },\n    KiaeT: function (Z, Q) {\n      return Z - Q;\n    },\n    mggBm: function (Z, Q) {\n      return Z - Q;\n    },\n    YyFGb: function (Z) {\n      return Z();\n    },\n  };\n  let cutaways_enabled = parseInt(\n    $(\"#range-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\")[\"val\"](),\n  );\n  if (cutaways_enabled === 0) {\n    ($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"](0),\n      test_51_decide_multicam_cuts());\n    return;\n  } else {\n    if (cutaways_enabled === 100) {\n      ($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"](100),\n        test_51_decide_multicam_cuts());\n      return;\n    }\n  }\n  let max_time = 0,\n    cutaway_min_len = 100,\n    cutaway_max_len = 50,\n    wide_shot_tolerance = Infinity,\n    Y = { tolerance: null, percentage: Infinity },\n    R = { tolerance: null, percentage: -Infinity };\n  while (max_time <= cutaway_min_len) {\n    const Z = Math[\"floor\"]((max_time + cutaway_min_len) / 2);\n    ($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"](Z),\n      test_51_decide_multicam_cuts());\n    let Q = test_100_get_multitrack_screentime_summary(),\n      s = Q[\"reduce\"]((y, O) => y + O, 0),\n      j = (s[(1)[\"length\"] - 1] / s) * 100;\n    j > cutaways_enabled\n      ? (j < Y[\"percentage\"] && (Y = { tolerance: Z, percentage: j }),\n        (cutaway_min_len = Z - 1))\n      : (j > R[\"percentage\"] && (R = { tolerance: Z, percentage: j }),\n        (max_time = Z + 1));\n    const c = Math[\"abs\"](cutaways_enabled - j);\n    if (c < wide_shot_tolerance) {\n      ((wide_shot_tolerance = c), (cutaway_max_len = Z));\n      if (c <= multitrack_wide_shot_percentage_acceptable_error) break;\n    }\n    if (max_time === cutaway_min_len) break;\n  }\n  if (Y[\"tolerance\"] !== null && R[\"tolerance\"] !== null) {\n    const y = Math[\"abs\"](cutaways_enabled - Y[\"percentage\"]),\n      O = Math[\"abs\"](cutaways_enabled - R[\"percentage\"]);\n    cutaway_max_len = y < O ? Y[\"tolerance\"] : R[\"tolerance\"];\n  }\n  ($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"](cutaway_max_len),\n    test_51_decide_multicam_cuts());\n}\nfunction combination_as_names(smoothing_window, cutaways_enabled) {\n  const max_time = {\n    YJaXs: function (cutaway_max_len, wide_shot_tolerance) {\n      return cutaway_max_len == wide_shot_tolerance;\n    },\n    OkAUN: \"(ignore\\x20tr\" + \"ack)\",\n    awYMq: function (cutaway_max_len, wide_shot_tolerance) {\n      return cutaway_max_len < wide_shot_tolerance;\n    },\n    bKTyD: function (cutaway_max_len, wide_shot_tolerance) {\n      return cutaway_max_len == wide_shot_tolerance;\n    },\n    xvCld: function (cutaway_max_len, wide_shot_tolerance) {\n      return cutaway_max_len + wide_shot_tolerance;\n    },\n  };\n  if (smoothing_window[\"length\"] == 0) return \"(ignore track)\";\n  let cutaway_min_len = [];\n  for (let cutaway_max_len = 0; cutaway_max_len < smoothing_window[\"length\"]; cutaway_max_len++) {\n    cutaways_enabled[smoothing_window[cutaway_max_len]] == \"\" ? cutaway_min_len[\"push\"](\"cutaway_min_len\" + (smoothing_window[cutaway_max_len] + 1)) : cutaway_min_len[\"push\"](cutaways_enabled[smoothing_window[cutaway_max_len]]);\n  }\n  return cutaway_min_len[\"join\"](\",\\x20\");\n}\nfunction multitrack_wide_shots_available() {\n  const smoothing_window = {\n    JcUaV: function (k, A) {\n      return k > A;\n    },\n  };\n  let n = ![];\n  for (let k = 0; k < g_multitrack_video_mapping[\"length\"]; k++) {\n    if (g_multitrack_video_mapping[k][\"length\"] > 1) {\n      n = !![];\n      break;\n    }\n  }\n  return n;\n}\nasync function test_102_auto_tune_multitrack_distribution() {\n  const z = {\n    xNoQC: function (A, a) {\n      return A(a);\n    },\n    lTxsm: \":checked\",\n    LKotQ: function (A) {\n      return A();\n    },\n    yGtND: \"Error\\x20reco\" + \"mputing\\x20de\" + \"cisions:\",\n    ZcTfL: function (A, a) {\n      return A - a;\n    },\n    vVJYq: function (A, a) {\n      return A + a;\n    },\n    kUBVd: function (A, a) {\n      return A > a;\n    },\n    ORrLZ: function (A, a) {\n      return A > a;\n    },\n    TvOEd: function (A, a) {\n      return A / a;\n    },\n    OnVaB: function (A, a) {\n      return A(a);\n    },\n    CaKRg: function (A, a) {\n      return A(a);\n    },\n    tAbTA: function (A, a) {\n      return A(a);\n    },\n    OpkSw: function (A, a) {\n      return A(a);\n    },\n    ZIlRT: \"#range-mul\" + \"titrack-sw\" + \"itching-fr\" + \"equency\",\n    qQLbW: function (A, a) {\n      return A(a);\n    },\n    jDrUa:\n      \"#range-mul\" + \"titrack-sw\" + \"itching-mi\" + \"nimum-shot\" + \"-duration\",\n    IcQDP: \"#range-mul\" + \"titrack-ma\" + \"x-time\",\n    XjKgh: function (A, a) {\n      return A(a);\n    },\n    TmoWN: \"#range-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\",\n    yuqlk: function (A, a) {\n      return A(a);\n    },\n    ndfpn: \"#range-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\",\n    COgfH: \"#range-cut\" + \"away-lengt\" + \"h\",\n    CIfQy: \"data-value\" + \"-min\",\n    jDKdh: function (A, a) {\n      return A(a);\n    },\n    liSBq: \"data-value\" + \"-max\",\n    xXpRb: function (A, a) {\n      return A(a);\n    },\n    XGZWj: \"#multitrac\" + \"k-video-cu\" + \"taway-trac\" + \"ks-list-to\",\n    nsirO: \".checkbox-\" + \"cutaway-vi\" + \"deo-track\",\n    ZVLrq: function (A, a) {\n      return A(a);\n    },\n    DHvEF: function (A, a) {\n      return A(a);\n    },\n    bHKXh: \"checked\",\n    MWaMq: function (A, a) {\n      return A < a;\n    },\n    Howij: function (A, a) {\n      return A(a);\n    },\n    VOlXV: function (A, a) {\n      return A + a;\n    },\n    jqKCB: function (A, a) {\n      return A(a);\n    },\n    JYQSi: \"#value-mul\" + \"titrack-sw\" + \"itching-fr\" + \"equency\",\n    xeiHb: \"input\",\n    YYmFX:\n      \"#value-mul\" + \"titrack-sw\" + \"itching-mi\" + \"nimum-shot\" + \"-duration\",\n    LuFUT: function (A, a) {\n      return A(a);\n    },\n    alFMb: \"#value-mul\" + \"titrack-ma\" + \"x-time\",\n    ZNqQf: function (A, a) {\n      return A(a);\n    },\n    UUeOX: \"#value-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\",\n    jReEE: function (A, a) {\n      return A(a);\n    },\n    uMkUU: function (A, a) {\n      return A !== a;\n    },\n    CSpYX: \"undefined\",\n    aHMHL: function (A, a) {\n      return A(a);\n    },\n    oplWw: function (A, a) {\n      return A(a);\n    },\n    ahZeQ: \"#checkbox-\" + \"multitrack\" + \"-cutaways\",\n    iWcgB: \"#multitrac\" + \"k-video-cu\" + \"taway-trac\" + \"ks-list-fr\" + \"om\",\n    DHCJP: function (A, a) {\n      return A < a;\n    },\n    HSMVo: function (A, a) {\n      return A === a;\n    },\n    DUBMV: function (A) {\n      return A();\n    },\n    nbumQ: function (A) {\n      return A();\n    },\n    xubWX: \"#checkbox-\" + \"multitrack\" + \"-boost\",\n    FijCn: function (A) {\n      return A();\n    },\n    TTEOb: function (A, a) {\n      return A(a);\n    },\n    gKKrf: function (A, a) {\n      return A <= a;\n    },\n    vqUel: function (A, a) {\n      return A(a);\n    },\n    fOLuO: function (A, a) {\n      return A(a);\n    },\n    dbhzC: function (A) {\n      return A();\n    },\n    ciqwA: \"Discrete\\x20b\" + \"oost\\x20accep\" + \"t\",\n    VVdkP: function (A) {\n      return A();\n    },\n    jiIPC: function (A) {\n      return A();\n    },\n    OhtEh: function (A) {\n      return A();\n    },\n    Qccus: function (A, a) {\n      return A < a;\n    },\n    TBgYr: function (A) {\n      return A();\n    },\n    jSKrh: \"Discrete\\x20c\" + \"utoff\\x20acce\" + \"pt\",\n    HZGQL: function (A, a) {\n      return A(a);\n    },\n    TDiET: function (A) {\n      return A();\n    },\n    IcSBy: function (A, a) {\n      return A < a;\n    },\n    PtLeE: function (A, a) {\n      return A - a;\n    },\n    KIqYw: function (A) {\n      return A();\n    },\n    yCsZc: \"Discrete\\x20m\" + \"inShot\\x20acc\" + \"ept\",\n    pQIqx: function (A, a) {\n      return A(a);\n    },\n    FGLnb: function (A) {\n      return A();\n    },\n    lVNmd: function (A, a) {\n      return A - a;\n    },\n    IkVZR: function (A) {\n      return A();\n    },\n    TffDY: function (A, a) {\n      return A < a;\n    },\n    ltmci: function (A) {\n      return A();\n    },\n    FaUlJ: \"Accepted\\x20b\" + \"oosts\\x20step\",\n    KjpwL: function (A, a) {\n      return A * a;\n    },\n    MeFzF: function (A) {\n      return A();\n    },\n    bwLMr: function (A, a) {\n      return A + a;\n    },\n    zRpJM: function (A, a) {\n      return A === a;\n    },\n    vZJMH: function (A) {\n      return A();\n    },\n    tQIxq: \"Accepted\\x20s\" + \"witchingFr\" + \"equency\\x20st\" + \"ep\",\n    bWPAw: function (A, a) {\n      return A(a);\n    },\n    CAaEz: \"Reverted\\x20s\" + \"witchingFr\" + \"equency\\x20st\" + \"ep\",\n    YufmM: function (A, a) {\n      return A - a;\n    },\n    BkVVa: function (A) {\n      return A();\n    },\n    QJEoi: function (A, a) {\n      return A - a;\n    },\n    QOGZX: function (A, a) {\n      return A(a);\n    },\n    ZVNDe: function (A) {\n      return A();\n    },\n    fsnBk: function (A, a) {\n      return A === a;\n    },\n    XtAhn: function (A) {\n      return A();\n    },\n    hGzjV: function (A, a) {\n      return A - a;\n    },\n    Mnvfh: \"Accepted\\x20m\" + \"inShotDura\" + \"tion\\x20step\",\n    fxgKX: function (A, a) {\n      return A(a);\n    },\n    LhKSS: \"Reverted\\x20m\" + \"inShotDura\" + \"tion\\x20step\",\n    jLANk: function (A, a) {\n      return A + a;\n    },\n    rUUeR: function (A) {\n      return A();\n    },\n    jCxex: function (A, a) {\n      return A < a;\n    },\n    tucKn: function (A, a) {\n      return A - a;\n    },\n    VjqJW: function (A) {\n      return A();\n    },\n    vxTHZ: \"Accepted\\x20m\" + \"inShotDura\" + \"tion\\x20up\\x20st\" + \"ep\",\n    qKqDo: \"Reverted\\x20m\" + \"inShotDura\" + \"tion\\x20up\\x20st\" + \"ep\",\n    oRNwq: function (A) {\n      return A();\n    },\n    JWAPv: function (A, a) {\n      return A - a;\n    },\n    llKTP: function (A, a) {\n      return A === a;\n    },\n    XPGea: function (A) {\n      return A();\n    },\n    hVweT: \"Accepted\\x20m\" + \"axTimeEffe\" + \"ctiveCutof\" + \"f\\x20step\",\n    mVEha: \"Reverted\\x20m\" + \"axTimeEffe\" + \"ctiveCutof\" + \"f\\x20step\",\n    XwIGP: function (A, a) {\n      return A + a;\n    },\n    HaeGm: function (A, a) {\n      return A - a;\n    },\n    FkQrs: \"Reverted\\x20m\" + \"axTimeEffe\" + \"ctiveCutof\" + \"f\\x20up\\x20step\",\n    wiJEU: function (A, a) {\n      return A(a);\n    },\n    GRXwo: function (A, a) {\n      return A(a);\n    },\n    McfBY: function (A) {\n      return A();\n    },\n    jDrXB: \"Accepted\\x20b\" + \"oosts\\x20togg\" + \"le\",\n    WkrTB: function (A, a) {\n      return A(a);\n    },\n    wOFnZ: \"Reverted\\x20b\" + \"oosts\\x20togg\" + \"le\",\n    rKXlQ: function (A) {\n      return A();\n    },\n    VqqEi: function (A, a) {\n      return A < a;\n    },\n    gyPXx: function (A, a) {\n      return A - a;\n    },\n    NDfJm: function (A, a) {\n      return A === a;\n    },\n    pagbq: function (A) {\n      return A();\n    },\n    ehDNZ: function (A, a) {\n      return A + a;\n    },\n    kKEWG: function (A, a) {\n      return A(a);\n    },\n    GzgrS: function (A) {\n      return A();\n    },\n    VVzGZ: function (A, a) {\n      return A < a;\n    },\n    AXbnQ: function (A) {\n      return A();\n    },\n    xLFOk: \"Accepted\\x20c\" + \"utaway\\x20rou\" + \"ting/durat\" + \"ion\\x20step\",\n    BEFLJ: function (A, a) {\n      return A(a);\n    },\n    VMcdt: function (A) {\n      return A();\n    },\n    KbtHO: \"Reverted\\x20c\" + \"utaway\\x20rou\" + \"ting/durat\" + \"ion\\x20step\",\n    SnRNs: function (A) {\n      return A();\n    },\n    nHYcB: function (A, a) {\n      return A - a;\n    },\n    ZXBrj: function (A) {\n      return A();\n    },\n    mTXcV: \"Accepted\\x20c\" + \"utaway\\x20dur\" + \"ation\\x20down\" + \"\\x20step\",\n    kuiBd: function (A) {\n      return A();\n    },\n    jJZyk: function (A, a) {\n      return A / a;\n    },\n    esvdC: function (A) {\n      return A();\n    },\n    wDqwG: function (A, a) {\n      return A < a;\n    },\n    dVUGO:\n      \"Accepted\\x20w\" +\n      \"ide\\x20finetu\" +\n      \"ne\\x20toward\\x20\" +\n      \"~equal\\x20ent\" +\n      \"ity\\x20share\",\n    OEgoX: function (A) {\n      return A();\n    },\n    oPxbw: \"Reverted\\x20w\" + \"ide\\x20finetu\" + \"ne\\x20step\",\n    nQZLR: \"test_102_a\" + \"uto_tune_m\" + \"ultitrack_\" + \"distributi\" + \"on\",\n    EflRM: \"Auto-balan\" + \"cing...\",\n    GhSRt: function (A, a) {\n      return A(a);\n    },\n    VzITD: function (A, a) {\n      return A(a);\n    },\n    sRlwR: function (A, a) {\n      return A(a);\n    },\n    UgXYh: function (A, a) {\n      return A(a);\n    },\n    jFuGq: function (A, a) {\n      return A(a);\n    },\n    jXUsz: \"#range-mul\" + \"titrack-bo\" + \"ost-\",\n    TyIke: \"Auto-balan\" + \"ce\\x20setting\" + \"s\\x20snapshot\" + \":\",\n    lPLBE: \"Screentime\" + \"\\x20per\\x20speak\" + \"er:\",\n    VNsxw: function (A) {\n      return A();\n    },\n    jWIvn: function (A) {\n      return A();\n    },\n    EtGew: \"Initial\\x20sh\" + \"ares:\",\n    EqfcD: \"maxAbsErro\" + \"r:\",\n    LDldm: function (A) {\n      return A();\n    },\n    WPgfU: function (A, a) {\n      return A > a;\n    },\n    uIiCU: function (A, a) {\n      return A && a;\n    },\n    oYwEJ: function (A, a) {\n      return A(a);\n    },\n    VNsax: \"Cutaways\\x20t\" + \"rial\\x20rever\" + \"ted\\x20after\\x20\" + \"sweep\",\n    ViZVQ: \"Sweep\",\n    YLGBu: \"best\\x20maxAb\" + \"sError:\",\n    XqSoX: \"shares:\",\n    siwSP:\n      \"Auto-balan\" +\n      \"ce\\x20converg\" +\n      \"ed\\x20to\\x20≤1%\\x20\" +\n      \"after\\x20full\" +\n      \"\\x20sweep.\",\n    xbTDm: function (A, a) {\n      return A > a;\n    },\n    VjDWt: function (A) {\n      return A();\n    },\n    xfRpf: \"#multitrac\" + \"k-screenti\" + \"me-chart\",\n    HoUnf: \"html,\\x20body\",\n    HxxjF: \"#button-mu\" + \"ltitrack-a\" + \"uto-balanc\" + \"e\",\n    Swljx: \"disabled\",\n  },\n    k = tracker[\"start\"](\"test_102_auto_tune_multitrack_distribution\");\n  try {\n    (showSpinner(\"Auto-balancing...\"),\n      $(\"#button-mu\" + \"ltitrack-a\" + \"uto-balanc\" + \"e\")[\"prop\"](\n        \"disabled\",\n        !![],\n      ));\n    const A = parseInt(\n      $(\"#range-mul\" + \"titrack-sw\" + \"itching-fr\" + \"equency\")[\"val\"](),\n    ),\n      a = parseFloat(\n        $(\"#range-multitrack-switching-minimum-shot-duration\")[\"val\"](),\n      ),\n      B = parseInt(\n        $(\"#range-mul\" + \"titrack-wi\" + \"de-shot-pe\" + \"rcentage\")[\"val\"](),\n      ),\n      Y = parseInt($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"]()),\n      R = parseInt($(\"#range-mul\" + \"titrack-ma\" + \"x-time\")[\"val\"]()),\n      Z = parseInt($(\"#range-cutaway-length\")[\"attr\"](\"data-value-min\")),\n      Q = parseInt($(\"#range-cutaway-length\")[\"attr\"](\"data-value-max\")),\n      s = $(\"#checkbox-multitrack-cutaways\")[\"is\"](\":checked\"),\n      j = $(\"#checkbox-\" + \"multitrack\" + \"-boost\")[\"is\"](\":checked\");\n    let c = [];\n    $(\"#multitrack-video-cutaway-tracks-list-to\")\n    [\"find\"](\".checkbox-cutaway-video-track\")\n    [\"each\"](function () {\n      $(this)[\"is\"](\":checked\") && c[\"push\"](parseInt($(this)[\"val\"]()));\n    });\n    let y = [];\n    $(\"#multitrack-video-cutaway-tracks-list-from\")\n    [\"find\"](\".checkbox-cutaway-video-track\")\n    [\"each\"](function () {\n      $(this)[\"is\"](\":checked\") && y[\"push\"](parseInt($(this)[\"val\"]()));\n    });\n    let O = Array[\"from\"]({ length: g_num_speakers }, () => 0);\n    try {\n      for (let f = 0; f < g_num_speakers; f++) {\n        const X = parseFloat($(\"#range-multitrack-boost-\" + f)[\"val\"]());\n        O[f] = isNaN(X) ? 0 : X;\n      }\n    } catch (D) {\n      O = Array[\"from\"]({ length: g_num_speakers }, () => 0);\n    }\n    const b = {\n      switchingFrequency: A,\n      minShotDuration: a,\n      wideShotPercentage: B,\n      wideShotTolerance: Y,\n      maxTimeEffectiveCutoff: R,\n      cutawayDurationMin: Z,\n      cutawayDurationMax: Q,\n      cutawaysEnabled: s,\n      boostsEnabled: j,\n      cutawayAllowedTracksTo: c,\n      cutawayAllowedTracksFrom: y,\n      speakerBoosts: O,\n    };\n    console[\"log\"](\"Auto-balance settings snapshot:\", b);\n    const S = test_100_get_multitrack_screentime_summary();\n    console[\"log\"](\"Screentime per speaker:\", S);\n    function l() {\n      try {\n        test_51_decide_multicam_cuts();\n      } catch (I) {\n        console[\"log\"](\"Error recomputing decisions:\", I);\n      }\n    }\n    function H() {\n      const I = test_100_get_multitrack_screentime_summary(),\n        g = I[\"reduce\"]((z0, z1) => z0 + z1, 0),\n        J = I[I[\"length\"] - 1] || 0,\n        W = Math[\"max\"](0, g - J),\n        F = g_multitrack_speaker_names[\"length\"],\n        h = multitrack_wide_shots_available(),\n        V = h ? F + 1 : F,\n        G = V > 0 ? 1 / V : 0,\n        E = I[\"slice\"](0, F);\n      let U = [];\n      if (h) {\n        const z0 = g > 0 ? g : 1;\n        ((U = E[\"map\"]((z1) => z1 / z0)), U[\"push\"](J / z0));\n      } else {\n        const z1 = W > 0 ? W : 1;\n        U = E[\"map\"]((z2) => z2 / z1);\n      }\n      const K = U[\"map\"]((z2) => G - z2),\n        p = K[\"reduce\"]((z2, z3) => Math[\"max\"](z2, Math[\"abs\"](z3)), 0);\n      return {\n        shares: U,\n        errors: K,\n        maxAbsError: p,\n        total: g,\n        wide: J,\n        totalNoWide: W,\n        secs: E,\n        target: G,\n        includeWide: h,\n        numSpeakers: F,\n      };\n    }\n    function L() {\n      const I = g_multitrack_speaker_names[\"length\"],\n        g = Array[\"from\"](\n          { length: I },\n          (z0, z1) =>\n            parseFloat($(\"#range-mul\" + \"titrack-bo\" + \"ost-\" + z1)[\"val\"]()) ||\n            0,\n        ),\n        J = parseInt($(\"#range-multitrack-switching-frequency\")[\"val\"]()),\n        W = parseFloat(\n          $(\"#range-multitrack-switching-minimum-shot-duration\")[\"val\"](),\n        ),\n        F = parseInt($(\"#range-multitrack-max-time\")[\"val\"]()),\n        h = parseInt($(\"#range-multitrack-wide-shot-percentage\")[\"val\"]()),\n        V = parseInt($(\"#range-multitrack-wide-shot-tolerance\")[\"val\"]()),\n        G = parseFloat($(\"#range-cutaway-length\")[\"attr\"](\"data-value-min\")),\n        E = parseFloat($(\"#range-cutaway-length\")[\"attr\"](\"data-value-max\")),\n        U = $(\"#checkbox-\" + \"multitrack\" + \"-cutaways\")[\"is\"](\":checked\");\n      let K = [];\n      $(\"#multitrack-video-cutaway-tracks-list-to\")\n      [\"find\"](\".checkbox-cutaway-video-track\")\n      [\"each\"](function () {\n        if ($(this)[\"is\"](\":checked\")) K[\"push\"](parseInt($(this)[\"val\"]()));\n      });\n      let p = [];\n      return (\n        $(\"#multitrac\" + \"k-video-cu\" + \"taway-trac\" + \"ks-list-fr\" + \"om\")\n        [\"find\"](\".checkbox-cutaway-video-track\")\n        [\"each\"](function () {\n          if ($(this)[\"is\"](\":checked\"))\n            p[\"push\"](parseInt($(this)[\"val\"]()));\n        }),\n        {\n          boosts: g,\n          switchingFrequencyNow: J,\n          minShotDurationNow: W,\n          maxTimeEffectiveCutoffNow: F,\n          wideShotPercentageNow: h,\n          wideShotToleranceNow: V,\n          cutawayDurationMinNow: G,\n          cutawayDurationMaxNow: E,\n          cutawaysEnabledNow: U,\n          toList: K,\n          fromList: p,\n        }\n      );\n    }\n    function M(I) {\n      const g = {\n        yOxGW: \"checked\",\n        TrUzg: function (J, W) {\n          return J(W);\n        },\n      };\n      for (let J = 0; J < I[\"boosts\"][\"length\"]; J++) {\n        $(\"#range-mul\" + \"titrack-bo\" + \"ost-\" + J)[\"val\"](I[\"boosts\"][J]);\n      }\n      ($(\"#range-multitrack-switching-frequency\")\n      [\"val\"](I[\"switchingF\" + \"requencyNo\" + \"w\"])\n      [\"trigger\"](\"input\"),\n        $(\"#value-multitrack-switching-frequency\")[\"text\"](\n          parseInt(I[\"switchingF\" + \"requencyNo\" + \"w\"]),\n        ),\n        $(\n          \"#range-mul\" +\n          \"titrack-sw\" +\n          \"itching-mi\" +\n          \"nimum-shot\" +\n          \"-duration\",\n        )\n        [\"val\"](I[\"minShotDur\" + \"ationNow\"])\n        [\"trigger\"](\"input\"),\n        $(\"#value-multitrack-switching-minimum-shot-duration\")[\"text\"](\n          parseFloat(I[\"minShotDur\" + \"ationNow\"]),\n        ),\n        $(\"#range-multitrack-max-time\")\n        [\"val\"](I[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"])\n        [\"trigger\"](\"input\"),\n        $(\"#value-multitrack-max-time\")[\"text\"](\n          parseInt(I[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"]),\n        ),\n        typeof I[\"wideShotPe\" + \"rcentageNo\" + \"w\"] !== \"undefined\" &&\n        ($(\"#range-multitrack-wide-shot-percentage\")\n        [\"val\"](I[\"wideShotPe\" + \"rcentageNo\" + \"w\"])\n        [\"trigger\"](\"input\"),\n          $(\"#value-multitrack-wide-shot-percentage\")[\"text\"](\n            parseInt(I[\"wideShotPe\" + \"rcentageNo\" + \"w\"]),\n          )),\n        typeof I[\"wideShotTo\" + \"leranceNow\"] !== \"undefined\" &&\n        ($(\"#range-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\")\n        [\"val\"](I[\"wideShotTo\" + \"leranceNow\"])\n        [\"trigger\"](\"input\"),\n          $(\"#value-mul\" + \"titrack-wi\" + \"de-shot-to\" + \"lerance\")[\"text\"](\n            parseInt(I[\"wideShotTo\" + \"leranceNow\"]),\n          )),\n        $(\"#range-cut\" + \"away-lengt\" + \"h\")[\"attr\"](\n          \"data-value\" + \"-min\",\n          I[\"cutawayDur\" + \"ationMinNo\" + \"w\"],\n        ),\n        $(\"#range-cut\" + \"away-lengt\" + \"h\")[\"attr\"](\n          \"data-value\" + \"-max\",\n          I[\"cutawayDur\" + \"ationMaxNo\" + \"w\"],\n        ),\n        $(\"#value-mul\" + \"titrack-cu\" + \"taway-dura\" + \"tion\")[\"text\"](\n          I[\"cutawayDur\" + \"ationMinNo\" + \"w\"] +\n          \"-\" +\n          I[\"cutawayDur\" + \"ationMaxNo\" + \"w\"],\n        ),\n        $(\"#checkbox-multitrack-cutaways\")\n        [\"prop\"](\"checked\", I[\"cutawaysEn\" + \"abledNow\"])\n        [\"trigger\"](\"input\"),\n        $(\"#multitrack-video-cutaway-tracks-list-to\")\n        [\"find\"](\".checkbox-cutaway-video-track\")\n        [\"each\"](function () {\n          $(this)[\"prop\"](\n            g[\"yOxGW\"],\n            I[\"toList\"][\"includes\"](g[\"TrUzg\"](parseInt, $(this)[\"val\"]())),\n          );\n        }),\n        $(\"#multitrack-video-cutaway-tracks-list-from\")\n        [\"find\"](\".checkbox-cutaway-video-track\")\n        [\"each\"](function () {\n          $(this)[\"prop\"](\n            \"checked\",\n            I[\"fromList\"][\"includes\"](parseInt($(this)[\"val\"]())),\n          );\n        }));\n    }\n    function o() {\n      const I = Array[\"from\"](\n        { length: g_multitrack_speaker_names[\"length\"] },\n        () => [],\n      );\n      for (let g = 0; g < g_multitrack_video_mapping[\"length\"]; g++) {\n        if (g_multitrack_video_mapping[g][\"length\"] === 1) {\n          const J = g_multitrack_video_mapping[g][0];\n          I[J][\"push\"](g);\n        }\n      }\n      return I;\n    }\n    let C = 1;\n    const w = 0x3bc + 0x242b * -0x1 + 0x206f + 0.01,\n      t = -50,\n      N = 50,\n      T = { min: 0xa, max: 0x64, step: 0x5 },\n      u = { min: 0.75, max: 0x3, step: 0.25 },\n      P = { min: 0xa, max: 0xf0, step: 0x5 },\n      d = { min: 0.5, max: 0x6, step: 0.25 };\n    ((function () {\n      const I = g_multitrack_speaker_names[\"length\"],\n        g = multitrack_wide_shots_available(),\n        J = (G) => {\n          const E = L();\n          ((E[\"boosts\"] = Array[\"from\"]({ length: I }, () => 0)),\n            (E[\"switchingF\" + \"requencyNo\" + \"w\"] = 50),\n            (E[\"minShotDur\" + \"ationNow\"] = 2),\n            (E[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] = 60),\n            (E[\"cutawaysEn\" + \"abledNow\"] = !!G),\n            (E[\"cutawayDur\" + \"ationMinNo\" + \"w\"] = 2),\n            (E[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] = 4));\n          if (g) {\n            const U = Math[\"round\"]((100 / (I + 1)) * 100) / 100;\n            E[\"wideShotPe\" + \"rcentageNo\" + \"w\"] = U;\n          }\n          return E;\n        },\n        W = J(!![]);\n      (M(W), $(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", !![]), l());\n      let F = H();\n      const h = J(![]);\n      (M(h),\n        $(\"#checkbox-\" + \"multitrack\" + \"-boost\")[\"prop\"](\"checked\", !![]),\n        l());\n      let V = H();\n      F[\"maxAbsErro\" + \"r\"] <= V[\"maxAbsErro\" + \"r\"]\n        ? (M(W),\n          $(\"#checkbox-\" + \"multitrack\" + \"-boost\")[\"prop\"](\"checked\", !![]))\n        : (M(h), $(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", !![]));\n    })(),\n      l());\n    let x = H(),\n      m = L();\n    (console[\"log\"](\n      \"Initial shares:\",\n      x[\"shares\"],\n      \"maxAbsError:\",\n      x[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n    ),\n      (function I() {\n        const g = g_multitrack_speaker_names[\"length\"],\n          J = [-4, -3, -2, -1, 0, 1, 2, 3, 4];\n        for (let h = 0; h < g; h++) {\n          let V = ![];\n          for (let G = 0; G < J[\"length\"]; G++) {\n            const E = L(),\n              U = E[\"boosts\"][\"slice\"]();\n            ((U[h] = Math[\"max\"](-6, Math[\"min\"](6, J[G]))),\n              (E[\"boosts\"] = U),\n              $(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", !![]),\n              M(E),\n              l());\n            const K = H();\n            if (\n              K[\"maxAbsErro\" + \"r\"] <\n              x[\"maxAbsErro\" + \"r\"] -\n              (-0x25bd * 0x1 + -0x1c * -0xa4 + 0x13cd + 0.0005)\n            ) {\n              ((x = K),\n                (m = L()),\n                (V = !![]),\n                console[\"log\"](\"Discrete boost accept\", {\n                  speaker: h,\n                  boost: U[h],\n                  maxAbsError: K[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n                }));\n              break;\n            }\n          }\n          !V && (M(m), l());\n        }\n        const W = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60];\n        for (let p = 0; p < W[\"length\"]; p++) {\n          const z0 = L();\n          ((z0[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] = W[p]), M(z0), l());\n          const z1 = H();\n          z1[\"maxAbsErro\" + \"r\"] <\n            x[\"maxAbsErro\" + \"r\"] -\n            (-0x24f7 * 0x1 + -0x20f4 * 0x1 + 0x45eb * 0x1 + 0.0005) &&\n            ((x = z1),\n              (m = L()),\n              console[\"log\"](\"Discrete cutoff accept\", {\n                maxTimeEffectiveCutoff: z0[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"],\n                maxAbsError: z1[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n              }));\n        }\n        (M(m), l());\n        const F = [\n          -0x104c * -0x1 + -0x2021 + 0xfd5 + 0.75,\n          1,\n          -0xfa1 + 0xc * 0x2c5 + 0x2 * -0x8cd + 0.25,\n          0x12ed + -0x20c0 + -0x1 * -0xdd4 + 0.5,\n          0x1595 + 0x26dd + -0x3c71 * 0x1 + 0.75,\n          2,\n          -0xe4c + -0x21da + 0x3028 + 0.25,\n          0xc * -0x13f + 0x20f3 * 0x1 + -0x11fd + 0.5,\n          0x356 * 0x3 + 0x1166 + 0x922 * -0x3 + 0.75,\n          3,\n        ];\n        for (let z2 = 0; z2 < F[\"length\"]; z2++) {\n          const z3 = L();\n          ((z3[\"minShotDur\" + \"ationNow\"] = F[z2]), M(z3), l());\n          const z4 = H();\n          z4[\"maxAbsErro\" + \"r\"] <\n            x[\"maxAbsErro\" + \"r\"] - 0x7 * -0x31c + -0x514 + 0x1ad8 + 0.0005 &&\n            ((x = z4),\n              (m = L()),\n              console[\"log\"](\"Discrete minShot accept\", {\n                minShotDuration: z3[\"minShotDur\" + \"ationNow\"],\n                maxAbsError: z4[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n              }));\n        }\n        (M(m), l());\n      })());\n    let q = 0;\n    const r = Date[\"now\"]();\n    while (!![]) {\n      q++;\n      let g = ![];\n      const J = g_multitrack_speaker_names[\"length\"],\n        W = o(),\n        F = x[\"target\"];\n      let h = null;\n      (function () {\n        const E = L();\n        ((E[\"boosts\"] = E[\"boosts\"][\"map\"]((K, p) => {\n          const z0 = Math[\"max\"](\n            t,\n            Math[\"min\"](N, K + C * (F - x[\"shares\"][p])),\n          );\n          return isNaN(z0) ? 0 : z0;\n        })),\n          M(E),\n          l());\n        const U = H();\n        U[\"maxAbsErro\" + \"r\"] <\n          x[\"maxAbsErro\" + \"r\"] - (0x238 * 0x1 + -0x15 * 0x65 + 0x611 + 0.0005)\n          ? ((x = U),\n            (m = L()),\n            (g = !![]),\n            console[\"log\"](\"Accepted boosts step\", {\n              boosts: E[\"boosts\"],\n              maxAbsError: U[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n            }))\n          : (M(m),\n            l(),\n            (C = Math[\"max\"](\n              0x8 * -0x399 + -0x1ef7 + 0x3bbf + 0.25,\n              C * 0x1a43 + 0x2 * -0x3e6 + -0xa3 * 0x1d + 0.75,\n            )),\n            console[\"log\"](\n              \"Reverted\\x20b\" +\n              \"oosts\\x20step\" +\n              \",\\x20annealed\" +\n              \"\\x20kBoost:\",\n              C[\"toFixed\"](2),\n            ));\n      })();\n      const V = [],\n        G = [];\n      for (let E = 0; E < J; E++) {\n        if (x[\"shares\"][E] < F) V[\"push\"](E);\n        else {\n          if (x[\"shares\"][E] > F) G[\"push\"](E);\n        }\n      }\n      ((function () {\n        if (V[\"length\"] === 0) return;\n        const U = L(),\n          K = Math[\"min\"](\n            T[\"max\"],\n            U[\"switchingF\" + \"requencyNo\" + \"w\"] + T[\"step\"],\n          );\n        if (K === U[\"switchingF\" + \"requencyNo\" + \"w\"]) return;\n        ((U[\"switchingF\" + \"requencyNo\" + \"w\"] = K), M(U), l());\n        const p = H();\n        p[\"maxAbsErro\" + \"r\"] <\n          x[\"maxAbsErro\" + \"r\"] - (0x1 * 0x2495 + -0x8c9 + -0x1bcc + 0.0005)\n          ? ((x = p),\n            (m = L()),\n            (g = !![]),\n            console[\"log\"](\"Accepted switchingFrequency step\", {\n              switchingFrequency: K,\n              maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n            }))\n          : (M(m), l(), console[\"log\"](\"Reverted switchingFrequency step\"));\n      })(),\n        (function () {\n          if (V[\"length\"] === 0) return;\n          const U = L(),\n            K = Math[\"max\"](\n              T[\"min\"],\n              U[\"switchingF\" + \"requencyNo\" + \"w\"] - T[\"step\"],\n            );\n          if (K === U[\"switchingF\" + \"requencyNo\" + \"w\"]) return;\n          ((U[\"switchingF\" + \"requencyNo\" + \"w\"] = K), M(U), l());\n          const p = H();\n          p[\"maxAbsErro\" + \"r\"] <\n            x[\"maxAbsErro\" + \"r\"] - 0x18ad + -0x1 * 0x337 + 0x1 * -0x1576 + 0.0005\n            ? ((x = p),\n              (m = L()),\n              (g = !![]),\n              console[\"log\"](\n                \"Accepted\\x20s\" + \"witchingFr\" + \"equency\\x20do\" + \"wn\\x20step\",\n                {\n                  switchingFrequency: K,\n                  maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n                },\n              ))\n            : (M(m),\n              l(),\n              console[\"log\"](\n                \"Reverted\\x20s\" + \"witchingFr\" + \"equency\\x20do\" + \"wn\\x20step\",\n              ));\n        })(),\n        (function () {\n          if (V[\"length\"] === 0) return;\n          const U = L(),\n            K = Math[\"max\"](u[\"min\"], U[\"minShotDur\" + \"ationNow\"] - u[\"step\"]);\n          if (K === U[\"minShotDur\" + \"ationNow\"]) return;\n          ((U[\"minShotDur\" + \"ationNow\"] = K), M(U), l());\n          const p = H();\n          p[\"maxAbsErro\" + \"r\"] <\n            x[\"maxAbsErro\" + \"r\"] - -0x116b + 0x1 * 0x2351 + -0x11e6 + 0.0005\n            ? ((x = p),\n              (m = L()),\n              (g = !![]),\n              console[\"log\"](\"Accepted minShotDuration step\", {\n                minShotDuration: K,\n                maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n              }))\n            : (M(m), l(), console[\"log\"](\"Reverted minShotDuration step\"));\n        })(),\n        (function () {\n          if (V[\"length\"] === 0) return;\n          const U = L(),\n            K = Math[\"min\"](u[\"max\"], U[\"minShotDur\" + \"ationNow\"] + u[\"step\"]);\n          if (K === U[\"minShotDur\" + \"ationNow\"]) return;\n          ((U[\"minShotDur\" + \"ationNow\"] = K), M(U), l());\n          const p = H();\n          p[\"maxAbsErro\" + \"r\"] <\n            x[\"maxAbsErro\" + \"r\"] - -0x13 * -0x9 + -0x148 + 0x9d + 0.0005\n            ? ((x = p),\n              (m = L()),\n              (g = !![]),\n              console[\"log\"](\"Accepted minShotDuration up step\", {\n                minShotDuration: K,\n                maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n              }))\n            : (M(m), l(), console[\"log\"](\"Reverted minShotDuration up step\"));\n        })(),\n        (function () {\n          if (V[\"length\"] === 0) return;\n          const U = L(),\n            K = Math[\"max\"](\n              P[\"min\"],\n              U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] - P[\"step\"],\n            );\n          if (K === U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"]) return;\n          ((U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] = K), M(U), l());\n          const p = H();\n          p[\"maxAbsErro\" + \"r\"] <\n            x[\"maxAbsErro\" + \"r\"] -\n            (-0x2 * 0x811 + -0x8e7 * -0x3 + 0xa93 * -0x1 + 0.0005)\n            ? ((x = p),\n              (m = L()),\n              (g = !![]),\n              console[\"log\"](\"Accepted maxTimeEffectiveCutoff step\", {\n                maxTimeEffectiveCutoff: K,\n                maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n              }))\n            : (M(m),\n              l(),\n              console[\"log\"](\"Reverted maxTimeEffectiveCutoff step\"));\n        })(),\n        (function () {\n          if (V[\"length\"] === 0) return;\n          const U = L(),\n            K = Math[\"min\"](\n              P[\"max\"],\n              U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] + P[\"step\"],\n            );\n          if (K === U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"]) return;\n          ((U[\"maxTimeEff\" + \"ectiveCuto\" + \"ffNow\"] = K), M(U), l());\n          const p = H();\n          p[\"maxAbsErro\" + \"r\"] <\n            x[\"maxAbsErro\" + \"r\"] - 0x43 * 0x86 + 0xf67 + -0x3279 + 0.0005\n            ? ((x = p),\n              (m = L()),\n              (g = !![]),\n              console[\"log\"](\n                \"Accepted\\x20m\" +\n                \"axTimeEffe\" +\n                \"ctiveCutof\" +\n                \"f\\x20up\\x20step\",\n                {\n                  maxTimeEffectiveCutoff: K,\n                  maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n                },\n              ))\n            : (M(m),\n              l(),\n              console[\"log\"](\"Reverted maxTimeEffectiveCutoff up step\"));\n        })());\n      (function () {\n        const U = L();\n        U[\"cutawaysEn\" + \"abledNow\"] = $(\"#checkbox-multitrack-cutaways\")[\"is\"](\n          \":checked\",\n        );\n        const K = $(\"#checkbox-multitrack-boost\")[\"is\"](\":checked\");\n        ($(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", !K), l());\n        const p = H();\n        p[\"maxAbsErro\" + \"r\"] <\n          x[\"maxAbsErro\" + \"r\"] - -0x1d30 + 0x1495 * -0x1 + 0x5d * 0x89 + 0.0005\n          ? ((x = p),\n            (m = L()),\n            (g = !![]),\n            console[\"log\"](\"Accepted boosts toggle\", {\n              boostsEnabled: !K,\n              maxAbsError: p[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n            }))\n          : ($(\"#checkbox-multitrack-boost\")[\"prop\"](\"checked\", K),\n            M(m),\n            l(),\n            console[\"log\"](\"Reverted boosts toggle\"));\n      })();\n      ((function () {\n        const U = $(\"#checkbox-multitrack-cutaways\")[\"is\"](\":checked\");\n        ($(\"#checkbox-multitrack-cutaways\")[\"prop\"](\"checked\", !U), l());\n        const K = H();\n        K[\"maxAbsErro\" + \"r\"] <\n          x[\"maxAbsErro\" + \"r\"] -\n          0x1 * -0x2300 +\n          -0xf * 0x126 +\n          -0xa * -0x539 +\n          0.0005\n          ? ((x = K),\n            (m = L()),\n            (g = !![]),\n            console[\"log\"](\"Accepted\\x20c\" + \"utaways\\x20to\" + \"ggle\", {\n              cutawaysEnabled: !U,\n              maxAbsError: K[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n            }))\n          : ((h = { prev: U }),\n            console[\"log\"](\n              \"Cutaways\\x20t\" +\n              \"oggle\\x20kept\" +\n              \"\\x20temporari\" +\n              \"ly\\x20for\\x20com\" +\n              \"pound\\x20tria\" +\n              \"l\",\n            ));\n      })(),\n        (function () {\n          if (V[\"length\"] === 0 || G[\"length\"] === 0) return;\n          const U = L();\n          U[\"cutawaysEn\" + \"abledNow\"] = !![];\n          const K = new Set(),\n            p = new Set();\n          (V[\"forEach\"]((z3) => W[z3][\"forEach\"]((z4) => K[\"add\"](z4))),\n            G[\"forEach\"]((z3) => W[z3][\"forEach\"]((z4) => p[\"add\"](z4))),\n            (U[\"toList\"] = Array[\"from\"](K)),\n            (U[\"fromList\"] = Array[\"from\"](p)));\n          const z0 = Math[\"min\"](\n            d[\"max\"],\n            U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] + d[\"step\"],\n          ),\n            z1 = Math[\"min\"](\n              d[\"max\"],\n              Math[\"max\"](z0, U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] + d[\"step\"]),\n            );\n          ((U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] = z0),\n            (U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] = z1),\n            M(U),\n            l());\n          const z2 = H();\n          z2[\"maxAbsErro\" + \"r\"] <\n            x[\"maxAbsErro\" + \"r\"] - (0x17a8 + 0x4 * 0x8bf + -0x3aa4 + 0.0005)\n            ? ((x = z2),\n              (m = L()),\n              (g = !![]),\n              console[\"log\"](\"Accepted cutaway routing/duration step\", {\n                to: U[\"toList\"],\n                from: U[\"fromList\"],\n                cutawayDurationMin: U[\"cutawayDur\" + \"ationMinNo\" + \"w\"],\n                cutawayDurationMax: U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"],\n                maxAbsError: z2[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n              }))\n            : (M(m),\n              l(),\n              console[\"log\"](\"Reverted cutaway routing/duration step\"));\n        })(),\n        (function () {\n          if (V[\"length\"] === 0 || G[\"length\"] === 0) return;\n          const U = L();\n          U[\"cutawaysEn\" + \"abledNow\"] = !![];\n          const K = Math[\"max\"](\n            d[\"min\"],\n            U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] - d[\"step\"],\n          ),\n            p = Math[\"max\"](\n              K,\n              Math[\"max\"](\n                d[\"min\"],\n                U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] - d[\"step\"],\n              ),\n            );\n          if (\n            K === U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] &&\n            p === U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"]\n          )\n            return;\n          ((U[\"cutawayDur\" + \"ationMinNo\" + \"w\"] = K),\n            (U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"] = p),\n            M(U),\n            l());\n          const z0 = H();\n          z0[\"maxAbsErro\" + \"r\"] <\n            x[\"maxAbsErro\" + \"r\"] - (0xc1d + 0x1 * 0x527 + -0x1ba * 0xa + 0.0005)\n            ? ((x = z0),\n              (m = L()),\n              (g = !![]),\n              console[\"log\"](\"Accepted cutaway duration down step\", {\n                cutawayDurationMin: U[\"cutawayDur\" + \"ationMinNo\" + \"w\"],\n                cutawayDurationMax: U[\"cutawayDur\" + \"ationMaxNo\" + \"w\"],\n                maxAbsError: z0[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n              }))\n            : (M(m),\n              l(),\n              console[\"log\"](\n                \"Reverted\\x20c\" +\n                \"utaway\\x20dur\" +\n                \"ation\\x20down\" +\n                \"\\x20step\",\n              ));\n        })(),\n        (function () {\n          const U = H();\n          if (U[\"includeWid\" + \"e\"]) {\n            const K = U[\"numSpeaker\" + \"s\"] + 1,\n              p = Math[\"round\"]((100 / K) * 100) / 100;\n            $(\"#range-multitrack-wide-shot-percentage\")\n            [\"val\"](p)\n            [\"trigger\"](\"input\");\n            try {\n              test_101_finetune_multitrack_wide_shot_tolerance();\n            } catch (z1) { }\n            l();\n            const z0 = H();\n            z0[\"maxAbsErro\" + \"r\"] <\n              x[\"maxAbsErro\" + \"r\"] -\n              -0xd4 * -0x1f +\n              -0x9b * 0x1 +\n              0xcf * -0x1f +\n              0.0005\n              ? ((x = z0),\n                (m = L()),\n                (g = !![]),\n                console[\"log\"](\n                  \"Accepted wide finetune toward ~equal entity share\",\n                  {\n                    targetWidePercent: p,\n                    maxAbsError: z0[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n                  },\n                ))\n              : (M(m), l(), console[\"log\"](\"Reverted wide finetune step\"));\n          }\n        })());\n      h &&\n        !g &&\n        ($(\"#checkbox-\" + \"multitrack\" + \"-cutaways\")[\"prop\"](\n          \"checked\",\n          h[\"prev\"],\n        ),\n          M(m),\n          l(),\n          console[\"log\"](\"Cutaways trial reverted after sweep\"));\n      console[\"log\"](\n        \"Sweep\",\n        q,\n        \"best maxAbsError:\",\n        x[\"maxAbsErro\" + \"r\"][\"toFixed\"](4),\n        \"shares:\",\n        x[\"shares\"][\"map\"]((U) => Number(U[\"toFixed\"](4))),\n      );\n      if (x[\"maxAbsErro\" + \"r\"] <= w && !g) {\n        (M(m),\n          l(),\n          console[\"log\"](\n            \"Auto-balance converged to \\u22641% after full sweep.\",\n          ));\n        break;\n      }\n      if (Date[\"now\"]() - r > 10000) {\n        (console[\"log\"](\n          \"Auto-balan\" +\n          \"ce\\x20timeout\" +\n          \"\\x20reached\\x20(\" +\n          \"10s).\\x20Appl\" +\n          \"ying\\x20best-\" +\n          \"found\\x20sett\" +\n          \"ings\\x20and\\x20e\" +\n          \"xiting.\",\n        ),\n          M(m),\n          l());\n        break;\n      }\n      await new Promise((U) => setTimeout(U, 0));\n    }\n  } catch (U) {\n    (tracker[\"error\"](\n      \"test_102_a\" +\n      \"uto_tune_m\" +\n      \"ultitrack_\" +\n      \"distributi\" +\n      \"on\\x20failed\",\n    ),\n      console[\"error\"](U));\n    throw U;\n  } finally {\n    ($(\"#multitrack-screentime-chart\")[\"length\"] &&\n      $(\"html, body\")[\"animate\"](\n        {\n          scrollTop: $(\"#multitrack-screentime-chart\")[\"offset\"]()[\"top\"] - 25,\n        },\n        200,\n      ),\n      $(\"#button-multitrack-auto-balance\")[\"prop\"](\"disabled\", ![]),\n      hideSpinner(),\n      tracker[\"end\"](k));\n  }\n}\n","numLines":2012,"startLine":1,"totalLines":2012}}}
{"parentUuid":"19e5ff69-d1a1-4fdc-9174-7338a754016a","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017bXeX4P16Dr9JoyL7bZeaT","type":"tool_result","content":"     1→async function test_48_get_multitrack_params() {\n     2→    multitrack_parameters = null;\n     3→    try {\n     4→        if (!$('[menu-name=multitrack-audio]').hasClass('hidden')) {\n     5→            // AUDIO MODE\n     6→            console.log('test_48: audio mode');\n     7→            const sorted_indices = '6|1|8|3|2|5|0|4|9|7'.split('|');\n     8→\n     9→            // Re-ordered logic based on flow analysis\n    10→            // 0: detect_nonspeech\n    11→            multitrack_parameters = {}; // Initialized implicitly or via object assignment logic found later? \n    12→            // Correct logic flow reconstruction:\n    13→\n    14→            // 6: Log\n    15→            // 1: getInterpolatedValueFromStops\n    16→            multitrack_parameters = getInterpolatedValueFromStops(0, silence_cutting_parameters_stops);\n    17→\n    18→            // 8: Threshold method\n    19→            if ($('#setting-multitrack-audio-threshold-method-auto').is(':checked')) {\n    20→                multitrack_parameters['threshold_method'] = 'auto';\n    21→                multitrack_parameters['threshold'] = null;\n    22→            } else {\n    23→                multitrack_parameters['operation'] = 'custom';\n    24→                multitrack_parameters['threshold'] = parseFloat($('#range-multitrack-audio-custom-threshold').val());\n    25→            }\n    26→\n    27→            // 3: Key Audio Indices Init\n    28→            multitrack_parameters['keyAudioTrackIndices'] = [];\n    29→\n    30→            // 2: Key Audio Tracks\n    31→            $('#setting-multitrack-tracks-audio input').each(function (A) {\n    32→                console.log($(this));\n    33→                if ($(this).is(':checked')) {\n    34→                    multitrack_parameters['keyAudioTrackIndices'].push(parseInt($(this).val()));\n    35→                    console.log('Added checked track to multitrack_parameters.keyAudioTrackIndices', parseInt($(this).val()));\n    36→                }\n    37→            });\n    38→\n    39→            // 5: Scope\n    40→            if ($('#setting-multitrack-audio-scope-inout').is(':checked')) {\n    41→                multitrack_parameters['scope'] = 'inout';\n    42→            } else {\n    43→                multitrack_parameters['scope'] = 'full';\n    44→            }\n    45→\n    46→            // 0: Detect Nonspeech\n    47→            multitrack_parameters['detect_nonspeech'] = $('#detect-nonspeech-multitrack-audio').is(':checked');\n    48→\n    49→            // 4: Disable Linked Video\n    50→            multitrack_parameters['disable_linked_video'] = $('#disable-linked-video-multitrack-audio').is(':checked');\n    51→\n    52→            // 9: Format\n    53→            if ($('#setting-multitrack-audio-format-wav').is(':checked')) {\n    54→                multitrack_parameters['format'] = 'wav';\n    55→            } else {\n    56→                multitrack_parameters['format'] = 'mp3-high';\n    57→            }\n    58→\n    59→            // 7: Method\n    60→            if ($('#multitrack-audio-algorithm-basic-original').is(':checked')) {\n    61→                multitrack_parameters['method'] = 'original';\n    62→            } else {\n    63→                multitrack_parameters['method'] = 'rapid';\n    64→            }\n    65→\n    66→        } else {\n    67→            // VIDEO MODE\n    68→            // 5: Log\n    69→            console.log('test_48: video mode');\n    70→\n    71→            // 2: Init\n    72→            multitrack_parameters = {};\n    73→\n    74→            // 4: Default Operation\n    75→            multitrack_parameters['operation'] = 'disable';\n    76→\n    77→            // 1: Operation check\n    78→            if ($('#multitrack-video-operation-disable').is(':checked')) {\n    79→                multitrack_parameters['operation'] = 'disable';\n    80→            } else {\n    81→                multitrack_parameters['operation'] = 'delete';\n    82→            }\n    83→\n    84→            // 0: Mute Audio\n    85→            multitrack_parameters['mute_audio'] = $('#multitrack-video-operation-mute-audio').is(':checked');\n    86→\n    87→            // 3: Scope\n    88→            if ($('#multitrack-video-scope-inout').is(':checked')) {\n    89→                multitrack_parameters['scope'] = 'inout';\n    90→            } else {\n    91→                multitrack_parameters['scope'] = 'full';\n    92→            }\n    93→        }\n    94→    } catch (B) {\n    95→        console.log('error while getting silence parameters', B);\n    96→    }\n    97→\n    98→    if (multitrack_parameters['scope'] == 'inout') {\n    99→        // IN/OUT Logic\n   100→        console.log('eval_string', eval_string);\n   101→        // getInPoint\n   102→        console.log('eval_string', 'app.project.activeSequence.getInPoint()');\n   103→        eval_string = 'app.project.activeSequence.getInPoint()';\n   104→        multitrack_parameters['inPoint'] = await new Promise((resolve, reject) => {\n   105→            jsx['evalScript'](eval_string, function (s) {\n   106→                console.log('result', s);\n   107→                resolve(parseFloat(s));\n   108→            });\n   109→        });\n   110→\n   111→        // getOutPoint\n   112→        eval_string = 'app.project.activeSequence.getOutPoint()';\n   113→        console.log('eval_string', eval_string);\n   114→        multitrack_parameters['outPoint'] = await new Promise((resolve, reject) => {\n   115→            jsx['evalScript'](eval_string, function (s) {\n   116→                console.log('result', s);\n   117→                resolve(parseFloat(s));\n   118→            });\n   119→        });\n   120→\n   121→    } else {\n   122→        // FULL/WORKAREA Logic\n   123→        // getWorkAreaInPoint\n   124→        console.log('eval_string', eval_string);\n   125→        eval_string = 'app.project.activeSequence.getWorkAreaInPoint()';\n   126→        multitrack_parameters['inPoint'] = await new Promise((resolve, reject) => {\n   127→            jsx['evalScript'](eval_string, function (c) {\n   128→                console.log('result', c);\n   129→                resolve(parseFloat(c));\n   130→            });\n   131→        });\n   132→\n   133→        // getWorkAreaOutPoint\n   134→        eval_string = 'app.project.activeSequence.getWorkAreaOutPoint()';\n   135→        console.log('eval_string', eval_string);\n   136→        multitrack_parameters['outPoint'] = await new Promise((resolve, reject) => {\n   137→            jsx['evalScript'](eval_string, function (c) {\n   138→                console.log('result', c);\n   139→                resolve(parseFloat(c));\n   140→            });\n   141→        });\n   142→    }\n   143→\n   144→    multitrack_parameters['inPoint'] = Math.max(multitrack_parameters['inPoint'], 0);\n   145→    multitrack_parameters['scopeValid'] = true;\n   146→    if (multitrack_parameters['scope'] == 'inout') {\n   147→        if (multitrack_parameters['inPoint'] == multitrack_parameters['outPoint']) {\n   148→            multitrack_parameters['scopeValid'] = false;\n   149→        }\n   150→        if (multitrack_parameters['inPoint'] < 0 || multitrack_parameters['outPoint'] < 0) {\n   151→            multitrack_parameters['scopeValid'] = false;\n   152→        }\n   153→        if (multitrack_parameters['inPoint'] > multitrack_parameters['outPoint']) {\n   154→            multitrack_parameters['scopeValid'] = false;\n   155→        }\n   156→    }\n   157→    console.log(multitrack_parameters);\n   158→    return multitrack_parameters;\n   159→}\n   160→\n   161→function writeHTML_multitrack_audioTrackText() {\n   162→    let html = '';\n   163→    // Loop through speakers\n   164→    for (let n = 0; n < g_num_speakers; n++) {\n   165→        let speakerName = g_multitrack_speaker_names[n];\n   166→        let deleteButton;\n   167→        const imgIcon = '<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4A...AAAABJRU5ErkJggg==\" alt=\"multiply\" class=\"w-6\">';\n   168→\n   169→        // n < 2 ? Disabled Delete : Enabled Delete\n   170→        if (n < 2) {\n   171→            deleteButton = '<button disabled class=\"cursor-not-allowed button-multitrack-video-speaker-delete ms-2 me-0 rounded-md px-1 border bg-shorts-500 hover:bg-shorts-400 active:bg-shorts-600 border-shorts-400 hover:border-shorts-300 active:border-shorts-500 text-white disabled:opacity-50 disabled:bg-shorts-500 disabled:border-shorts-400\">' + imgIcon + '</button>';\n   172→        } else {\n   173→            deleteButton = '<button class=\"button-multitrack-video-speaker-delete ms-2 me-0 rounded-md px-1 border bg-shorts-500 hover:bg-shorts-400 active:bg-shorts-600 border-shorts-400 hover:border-shorts-300 active:border-shorts-500 text-white disabled:opacity-50 disabled:bg-shorts-500 disabled:border-shorts-400\">' + imgIcon + '</button>';\n   174→        }\n   175→\n   176→        html += `\n   177→          <div class=\"flex justify-between my-1\">\n   178→             <div class=\"w-10 select-none\">A${n + 1}:</div>\n   179→             <input id=\"textinput-multitrack-video-speaker-name-${n + 1}\" speaker-number=\"${n}\" type=\"text\" value=\"${speakerName}\" class=\"grow bg-shorts-500 text-shorts-100 hover:bg-shorts-400 focus:border-shorts-600 focus:bg-shorts-400 w-full rounded px-2 py-1 text-sm text-sm leading-tight focus:outline-none\" >\n   180→             ${deleteButton}\n   181→          </div>\n   182→        `;\n   183→    }\n   184→\n   185→    let add_speaker_hidden = '';\n   186→    if (g_num_speakers < g_num_audio_tracks) {\n   187→        add_speaker_hidden = '';\n   188→    } else {\n   189→        add_speaker_hidden = 'hidden';\n   190→    }\n   191→\n   192→    html += `\n   193→          <div class=\"w-full flex justify-center\">\n   194→             <button id=\"button-multitrack-add-speaker\" class=\"${add_speaker_hidden} mt-1 px-3 me-0 rounded-md border bg-shorts-500 hover:bg-shorts-400 active:bg-shorts-600 border-shorts-400 hover:border-shorts-300 active:border-shorts-500 text-whi1te disabled:opacity-50 disabled:bg-shorts-500 disabled:border-shorts-400 text-gray-300 text-xl\">+</button>\n   195→          </div>\n   196→        `;\n   197→\n   198→    console.log(html);\n   199→    $('#multitrack-video-audio-names').html(html);\n   200→    set_multitrack_video_listeners();\n   201→}\n   202→\n   203→function multitrack_readSpeakerNamesFromHTML(z = true) {\n   204→    g_multitrack_speaker_names = [];\n   205→    g_num_speakers = 0;\n   206→\n   207→    $('#multitrack-video-audio-names input').each(function () {\n   208→        let val = $(this).val();\n   209→        if ($(this).val() == '' && !z) {\n   210→            val = 'A' + (g_num_speakers + 1);\n   211→        }\n   212→        g_multitrack_speaker_names.push(val);\n   213→        g_num_speakers++;\n   214→    });\n   215→\n   216→    let empty_array = Array(20).fill(''); // Assuming 20 based on similar fills usually being a safe max\n   217→    g_multitrack_speaker_names = g_multitrack_speaker_names.concat(empty_array);\n   218→    g_multitrack_speaker_names = g_multitrack_speaker_names.slice(0, g_num_speakers);\n   219→}\n   220→\n   221→function multitrack_readVideoMappingSelections() {\n   222→    g_multitrack_video_mapping_selection_indices = [];\n   223→    $('#multitrack-video-mapping select').each(function () {\n   224→        g_multitrack_video_mapping_selection_indices.push(parseInt($(this).val()));\n   225→    });\n   226→\n   227→    let empty_array = Array(20).fill(0);\n   228→    g_multitrack_video_mapping_selection_indices = g_multitrack_video_mapping_selection_indices.concat(empty_array);\n   229→    g_multitrack_video_mapping_selection_indices = g_multitrack_video_mapping_selection_indices.slice(0, g_num_video_tracks);\n   230→\n   231→    let n = tools['powerSet'](g_multitrack_speaker_names.length);\n   232→    n.unshift([]);\n   233→    g_multitrack_video_mapping = [];\n   234→    for (let k = 0; k < g_multitrack_video_mapping_selection_indices.length; k++) {\n   235→        let A = g_multitrack_video_mapping_selection_indices[k];\n   236→        g_multitrack_video_mapping.push(n[A]);\n   237→    }\n   238→}\n   239→\n   240→function writeHTML_multitrack_videoTrackSelect() {\n   241→    multitrack_readSpeakerNamesFromHTML();\n   242→    multitrack_readVideoMappingSelections();\n   243→\n   244→    let n = tools['powerSet'](g_multitrack_speaker_names.length);\n   245→    n.unshift([]); // Add empty set as option 0?\n   246→\n   247→    let html = '\\n      ';\n   248→    for (let A = 0; A < g_num_video_tracks; A++) {\n   249→        html += `\n   250→          <div class=\"flex justify-between items-center my-0.5\">\n   251→             <div class=\"w-10 select-none\">V${A + 1}:</div>\n   252→             <select id=\"multitrack-video-mapping-${A + 1}\" video-track-number=\"${A + 1}\" class=\" grow border text-xs rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-1 bg-gray-700 border-gray-600 placeholder-gray-400 text-white focus:ring-blue-500 focus:border-blue-500\">\n   253→             `;\n   254→\n   255→        for (let a = 0; a < n.length; a++) {\n   256→            let selected = (g_multitrack_video_mapping_selection_indices[A] == a) ? 'selected' : '';\n   257→            html += `\n   258→                  <option value=\"${a}\" ${selected}>${combination_as_names(n[a], g_multitrack_speaker_names)}</option>`;\n   259→        }\n   260→\n   261→        html += `\n   262→             </select>\n   263→          </div>`;\n   264→    }\n   265→\n   266→    $('#multitrack-video-mapping').html(html);\n   267→    $('#multitrack-video-mapping select').select2({\n   268→        'theme': 'firecut-multitrack',\n   269→        'minimumResultsForSearch': -1\n   270→    });\n   271→}\n   272→\n   273→async function showMultiTrackSelection() {\n   274→    // Sequence roughly: '0|5|3|2|4|1'\n   275→\n   276→    // 0: Build Track Names\n   277→    let result = await buildTrackNamesArray();\n   278→    videoTrackNames = result[0];\n   279→    audioTrackNames = result[1];\n   280→\n   281→    // 5: Num Video Tracks\n   282→    g_num_video_tracks = videoTrackNames.length;\n   283→\n   284→    // 3: Num Audio Tracks\n   285→    g_num_audio_tracks = audioTrackNames.length;\n   286→\n   287→    // 2: Read Speaker Names (Initialize)\n   288→    multitrack_readSpeakerNamesFromHTML();\n   289→\n   290→    // 4: Write Audio Track HTML\n   291→    writeHTML_multitrack_audioTrackText();\n   292→\n   293→    // 1: Write Video Track HTML\n   294→    writeHTML_multitrack_videoTrackSelect();\n   295→}\n   296→\n   297→async function writeHTML_multitrack_boosts() {\n   298→    let html = '';\n   299→    for (let k = 0; k < g_multitrack_speaker_names.length; k++) {\n   300→        html += `\n   301→          <div class=\"flex justify-between items-center mt-0 multitrack-boost-speaker\">\n   302→             <div class=\"w-40\">   \n   303→                 <div class=\"flex items-center w-full \">\n   304→                     <div class=\"text-sm select-none text-left me-2 bg-transparent border-transparent rounded-md outline-none focus:border-transparent \">\n   305→                         ${g_multitrack_speaker_names[k]}\n   306→                     </div>\n   307→                 </div>\n   308→             </div>\n   309→             <div class=\"w-32\">   \n   310→                 <div class=\"text-sm w-full select-none text-center me-2 bg-transparent border-transparent rounded-md outline-none focus:border-transparent \">\n   311→                     <span class=\"value-multitrack-boost\" id=\"value-multitrack-boost-${k}\">0</span> dB\n   312→                 </div>\n   313→             </div>\n   314→             <div class=\"grow\">\n   315→                 <input id=\"range-multitrack-boost-${k}\" type=\"range\" value=\"0\" min=\"-50\" max=\"50\" step=\"1\" class=\"accent-purple-700 range-multitrack-boost outline-none w-full my-2 h-1 rounded-lg appearance-none cursor-pointer bg-gray-700 active:bg-gray-700 focus:bg-gray-700\">\n   316→             </div>\n   317→          </div>\n   318→        `;\n   319→    }\n   320→\n   321→    $('#multitrack-boost-advanced').html(html);\n   322→\n   323→    $('.range-multitrack-boost').off('input');\n   324→    $('.range-multitrack-boost').on('input', function () {\n   325→        let val = $(this).val();\n   326→        let display = $(this).closest('.multitrack-boost-speaker').find('.value-multitrack-boost');\n   327→        display.html(val);\n   328→    });\n   329→\n   330→    reset_multitrack_decision_modifiers_listeners();\n   331→    set_multitrack_auto_balance_listener();\n   332→}\n   333→\n   334→function multitrack_decisions_show_video_switch_list(decision_index) {\n   335→    let html = '';\n   336→    let valid_video_indices = [];\n   337→\n   338→    // Find video tracks that have content (mapping length > 0)\n   339→    for (let Z = 0; Z < g_multitrack_video_mapping.length; Z++) {\n   340→        if (g_multitrack_video_mapping[Z].length > 0) {\n   341→            valid_video_indices.push(Z);\n   342→        }\n   343→    }\n   344→\n   345→    let current_video_index = g_multitrack_decisions[decision_index]['video_index'];\n   346→    if (!g_multitrack_decisions[decision_index]['override']) {\n   347→        current_video_index = -1; // Auto\n   348→    }\n   349→\n   350→    // Auto Option\n   351→    html += `\n   352→        <div>\n   353→           <input data-decision_index=\"${decision_index}\" type=\"radio\" id=\"video-switch-list-auto\" name=\"video-switch-list\" value=\"-1\" class=\"hidden peer\" \n   354→           ${(current_video_index == -1 ? 'checked' : '')}\n   355→           >\n   356→           <label for=\"video-switch-list-auto\" class=\"flex items-center justify-between h-5 w-9 text-zinc-200 bg-zinc-700 hover:bg-gray-400 active:bg-gray-500 rounded cursor-pointer  peer-checked:bg-gray-500 peer-checked:text-white\">\n   357→              <div class=\"w-full text-sm text-center\">Auto</div>\n   358→           </label>\n   359→        </div>`;\n   360→\n   361→    // Video Options\n   362→    for (let Q = 0; Q < valid_video_indices.length; Q++) {\n   363→        let idx = valid_video_indices[Q];\n   364→        html += `\n   365→        <div>\n   366→           <input data-decision_index=\"${decision_index}\" type=\"radio\" id=\"video-switch-list-${idx}\" name=\"video-switch-list\" value=\"${idx}\" class=\"hidden peer\"\n   367→           ${(idx == current_video_index ? 'checked' : '')}\n   368→           >\n   369→           <label for=\"video-switch-list-${idx}\" class=\"flex items-center justify-between h-5 w-5 text-zinc-200 bg-zinc-700 hover:bg-gray-400 active:bg-gray-500 rounded cursor-pointer  peer-checked:bg-gray-500 peer-checked:text-white\">\n   370→              <div class=\"w-full text-sm text-center\">${idx + 1}</div>\n   371→           </label>\n   372→        </div>`;\n   373→    }\n   374→\n   375→    $('#multitrack-decisions-video-switch-list').html(html);\n   376→    $('#multitrack-decisions-video-switch-list').removeClass('hidden');\n   377→    $('#multitrack-decisions-video-switch-list-bg').removeClass('hidden');\n   378→\n   379→    $('#multitrack-decisions-video-switch-list input').off('click');\n   380→    $('#multitrack-decisions-video-switch-list input').on('click', function () {\n   381→        let val = parseInt($(this).val());\n   382→        console.log(val);\n   383→        let decIndex = parseInt($(this).data('decision_index'));\n   384→\n   385→        // Remove existing override if present\n   386→        if (g_multitrack_decisions[decIndex]['override']) {\n   387→            g_multitrack_decision_overrides.splice(g_multitrack_decisions[decIndex]['override_index'], 1);\n   388→        }\n   389→\n   390→        if (val != -1) {\n   391→            // Add new override\n   392→            g_multitrack_decision_overrides.push({\n   393→                'time': (g_multitrack_decisions[decIndex]['time_range'][0] + g_multitrack_decisions[decIndex]['time_range'][1]) / 2,\n   394→                'video_index': val\n   395→            });\n   396→        }\n   397→\n   398→        if (multitrack_wide_shots_available()) {\n   399→            test_101_finetune_multitrack_wide_shot_tolerance();\n   400→        } else {\n   401→            test_51_decide_multicam_cuts();\n   402→        }\n   403→\n   404→        writeHTML_multitrack_decisions_table();\n   405→        update_multitrack_screentime_chart();\n   406→        $('#multitrack-decisions-video-switch-list').addClass('hidden');\n   407→        $('#multitrack-decisions-video-switch-list-bg').addClass('hidden');\n   408→    });\n   409→\n   410→    $('#multitrack-decisions-video-switch-list-bg').off('click');\n   411→    $('#multitrack-decisions-video-switch-list-bg').on('click', function (s) {\n   412→        $('#multitrack-decisions-video-switch-list').addClass('hidden');\n   413→        $('#multitrack-decisions-video-switch-list-bg').addClass('hidden');\n   414→        s.stopPropagation();\n   415→    });\n   416→\n   417→    // Positioning\n   418→    let listButton = $('.multitrack-video-table-row[multitrack-video-decision-number=\"' + (decision_index + 1) + '\"] .multitrack-manual-video-track-button');\n   419→    let offset = { 'top': listButton.offset().top, 'left': listButton.offset().left };\n   420→    let width = listButton.width();\n   421→\n   422→    $('#multitrack-decisions-video-switch-list').css({\n   423→        'top': offset.top - 5,\n   424→        'left': offset.left + (width / 2) - ($('#multitrack-decisions-video-switch-list').width() / 2)\n   425→    });\n   426→}\n   427→\n   428→async function writeHTML_multitrack_decisions_table() {\n   429→    let mode = 'manual';\n   430→    let eval_string = 'getVideoFrameRateInSeconds()';\n   431→    console.log('eval_string', eval_string);\n   432→\n   433→    let videoFrameRate = await new Promise((resolve, reject) => {\n   434→        jsx['evalScript'](eval_string, function (R) {\n   435→            console.log('result', R);\n   436→            resolve(R);\n   437→        });\n   438→    });\n   439→    videoFrameRate = parseFloat(videoFrameRate);\n   440→    console.log('videoFrameRate', videoFrameRate);\n   441→\n   442→    let tbody = $('#multitrack-video-table tbody');\n   443→    let html = '';\n   444→\n   445→    for (let a = 0; a < g_multitrack_decisions.length; a++) {\n   446→        let decision = g_multitrack_decisions[a];\n   447→        let startTime = timeConversion(decision['time_range'][0], 's', 'hh:mm:ss', videoFrameRate);\n   448→        let duration = timeConversion(decision['time_range'][1] - decision['time_range'][0], 's', 'hh:mm:ss', videoFrameRate);\n   449→        let endTime = timeConversion(decision['time_range'][1], 's', 'hh:mm:ss', videoFrameRate);\n   450→\n   451→        let buttonClass = 'bg-shorts-500 border-shorts-400 hover:bg-shorts-300 hover:border-shorts-200 active:bg-shorts-500 active:border-shorts-400';\n   452→        let speakerCellContent = '';\n   453→        let speakerCellStyle = '';\n   454→        let speakerName = decision['speaker'];\n   455→        let speakerColor = g_speaker_colors[g_multitrack_speaker_names.indexOf(decision['speaker'])];\n   456→        let stripeStyle = '';\n   457→\n   458→        if (decision['speakers'].length > 1) {\n   459→            speakerColor = '';\n   460→            stripeStyle = generate_stripe_style(decision['speakers'].map(b => g_speaker_colors_hex[g_multitrack_speaker_names.indexOf(b)]));\n   461→        }\n   462→\n   463→        if (g_multitrack_decisions.length == 1) {\n   464→            speakerName = decision['speaker'];\n   465→            speakerCellStyle = 'rounded-md border-2 ';\n   466→        } else if (a < g_multitrack_decisions.length - 1) {\n   467→            // Not last\n   468→            if (a == 0) {\n   469→                // First\n   470→                speakerName = decision['speaker'];\n   471→                speakerCellStyle += 'rounded-t-md border-t-2 ';\n   472→            } else if (decision['speaker'] != g_multitrack_decisions[a - 1]['speaker']) {\n   473→                // Change of speaker\n   474→                speakerName = decision['speaker'];\n   475→                speakerCellStyle += 'rounded-t-md border-t-2 ';\n   476→            }\n   477→\n   478→            if (decision['speaker'] != g_multitrack_decisions[a + 1]['speaker']) {\n   479→                // Next is different\n   480→                speakerCellStyle += 'rounded-b-md border-b-2 ';\n   481→            }\n   482→        } else {\n   483→            // Last\n   484→            if (decision['speaker'] != g_multitrack_decisions[a - 1]['speaker']) {\n   485→                speakerName = decision['speaker'];\n   486→                speakerCellStyle += 'rounded-t-md border-t-2 ';\n   487→            }\n   488→            speakerCellStyle += 'rounded-b-md border-b-2 ';\n   489→        }\n   490→\n   491→        let speakerCell = `<td class=\"p-0 px-1 text-left font-bold border-shorts-700 text-white ${speakerCellStyle} ${speakerColor}\" style=\"${stripeStyle}\">${speakerName}</td>`;\n   492→\n   493→        html += `\n   494→          <tr class=\"multitrack-video-table-row\" multitrack-video-decision-number=\"${a + 1}\">\n   495→              ${speakerCell}\n   496→              <td class=\"p-0 ps-1 text-left\">\n   497→                  ${decision['reason']}\n   498→              </td>`;\n   499→\n   500→        if (decision['override']) {\n   501→            html += `\n   502→              <td class=\"p-0 flex justify-center\">\n   503→                  <button class=\"multitrack-manual-video-track-button p-0 w-6 text-center rounded-md px-1 text-white bg-cyan-600 border border-cyan-600 hover:bg-cyan-400 hover:border-cyan-400 active:bg-cyan-600 active:border-cyan-600 cursor-pointer\">\n   504→                      ${decision['video_index'] + 1}\n   505→                  </button>\n   506→              </td>`;\n   507→        } else {\n   508→            html += `\n   509→              <td class=\"p-0 flex justify-center\">\n   510→                  <button class=\"multitrack-manual-video-track-button p-0 w-6 text-center rounded-md px-1 text-white bg-gray-500 border border-gray-500 hover:bg-gray-400 hover:border-gray-400 active:bg-gray-600 active:border-gray-600 cursor-pointer\">\n   511→                      ${decision['video_index'] + 1}\n   512→                  </button>\n   513→              </td>`;\n   514→        }\n   515→\n   516→        html += `\n   517→              <td class=\"ps-1 col-span-3\">\n   518→                  <button class=\"flex justify-between button-multitrack-video-time-section w-full m-0 rounded-md px-1 text-white ${buttonClass}\">\n   519→                      <div class=\"px-1\">${startTime}</div>\n   520→                      <div class=\"px-1\">➔</div>\n   521→                      <div class=\"px-1\">${duration}</div>  \n   522→                  </button>    \n   523→              </td>\n   524→              <td class=\"p-0 ps-1 text-center hidden xs:table-cell select-none\">\n   525→                  ${endTime}\n   526→              </td>\n   527→          </tr>\n   528→        `;\n   529→    }\n   530→\n   531→    tbody.html(html);\n   532→    set_multitrack_go_to_time_listeners();\n   533→    if (mode == 'manual') {\n   534→        set_multitrack_manual_listeners();\n   535→    }\n   536→}\n   537→\n   538→function select_multitrack_decision_number(z) {\n   539→    let index = z - 1;\n   540→    let start = g_multitrack_decisions[index]['time_range'][0];\n   541→    let end = g_multitrack_decisions[index]['time_range'][1];\n   542→\n   543→    console.log('Moving to time section: ', start, end);\n   544→\n   545→    // Set In Point\n   546→    let eval_string = 'app.project.activeSequence.setInPoint(' + start + ')';\n   547→    new Promise((resolve, reject) => {\n   548→        jsx['evalScript'](eval_string, function (Z) {\n   549→            console.log('result', Z);\n   550→            resolve(Z);\n   551→        });\n   552→    });\n   553→\n   554→    // Set Out Point\n   555→    eval_string = 'app.project.activeSequence.setOutPoint(' + end + ')';\n   556→    new Promise((resolve, reject) => {\n   557→        jsx['evalScript'](eval_string, function (Q) {\n   558→            console.log('result', Q);\n   559→            resolve(Q);\n   560→        });\n   561→    });\n   562→\n   563→    // Move Playhead\n   564→    let ticks = parseInt(start * ticks_per_second);\n   565→    eval_string = 'app.project.activeSequence.setPlayerPosition(\"' + ticks + '\")';\n   566→    new Promise((resolve, reject) => {\n   567→        jsx['evalScript'](eval_string, function (Q) {\n   568→            console.log('result', Q);\n   569→            resolve(Q);\n   570→        });\n   571→    });\n   572→}\n   573→\n   574→function control_multitrack_wide_shots_tolerance_input() {\n   575→    let available = multitrack_wide_shots_available();\n   576→    if (available) {\n   577→        $('#multitrack-wide-shot-tolerance-container').removeClass('opacity-20 cursor-not-allowed');\n   578→        $('#range-multitrack-wide-shot-tolerance').prop('disabled', false);\n   579→        $('#range-multitrack-wide-shot-percentage').prop('disabled', false);\n   580→        $('#no-wide-shots').addClass('hidden');\n   581→    } else {\n   582→        $('#multitrack-wide-shot-tolerance-container').addClass('opacity-20 cursor-not-allowed');\n   583→        $('#range-multitrack-wide-shot-tolerance').prop('disabled', true);\n   584→        $('#range-multitrack-wide-shot-percentage').prop('disabled', true);\n   585→        $('#no-wide-shots').removeClass('hidden');\n   586→    }\n   587→}\n   588→\n   589→var multitrack_pixels_per_character = 10;\n   590→\n   591→function update_multitrack_screentime_chart() {\n   592→    let summary = test_100_get_multitrack_screentime_summary();\n   593→    let total = summary.reduce((a, b) => a + b, 0);\n   594→    // Adjusted total to account for potential gaps or just normalizing?\n   595→    // Using * 0.9 + ??? \"0x1*-0x1521+-0x11f6+-0x1*-0x2717+0.9\"\n   596→    // -5409 - 4598 + 10007 = 0?\n   597→    // The constant calculation seems to evaluate to 0.9.\n   598→\n   599→    let percentages = summary.map(Y => (Y / total) * 100);\n   600→    let chartWidth = $('body').width() * 0.9;\n   601→\n   602→    let html = '';\n   603→    for (let Y = 0; Y < g_multitrack_speaker_names.length + 1; Y++) {\n   604→        let name = (Y === g_multitrack_speaker_names.length) ? 'Wide' : g_multitrack_speaker_names[Y];\n   605→        let colorClass = (Y === g_multitrack_speaker_names.length) ? 'bg-shorts-300' : g_speaker_colors[Y];\n   606→\n   607→        // Width in pixels for this bar\n   608→        let widthPx = (chartWidth * percentages[Y]) / 100;\n   609→        let textWidth = multitrack_pixels_per_character * name.length;\n   610→\n   611→        let content = '';\n   612→        if (widthPx >= textWidth) {\n   613→            content = `\n   614→                  <div>\n   615→                      <span class=\"font-bold\">${name}</span> (${Math.round(percentages[Y])}%)\n   616→                  </div>`;\n   617→        } else if (widthPx >= 20) { // Enough for ... \n   618→            content = `\n   619→                  <div>\n   620→                      <span class=\"font-bold block group-hover:hidden\">...</span>\n   621→                  </div>`;\n   622→        }\n   623→\n   624→        // Hover content always shows full info\n   625→        content += `\n   626→              <div class=\"hidden group-hover:block\">\n   627→                  <span class=\"font-bold\">${name}</span> (${Math.round(percentages[Y])}%)\n   628→              </div>\n   629→        `;\n   630→\n   631→        html += `\n   632→            <div class=\"group relative select-none flex items-center justify-center h-full text-white border border-shorts-700 ${colorClass} text-center\" style=\"width:${percentages[Y]}%\">\n   633→                ${content}\n   634→            </div>`;\n   635→    }\n   636→\n   637→    $('#multitrack-screentime-chart').html(html);\n   638→}\n   639→\n   640→function writeHTML_cutaway_checkboxes() {\n   641→    let html = '';\n   642→    for (let A = 0; A < g_multitrack_video_mapping.length; A++) {\n   643→        if (g_multitrack_video_mapping[A].length == 0) continue;\n   644→\n   645→        let checked = 'checked';\n   646→        // HTML construction\n   647→        html += `\n   648→          <div class=\"flex items-center\">\n   649→              <label class=\"ms-1 text-sm font-medium select-none flex items-center space-x-1\">\n   650→                  <input type=\"checkbox\" class=\"accent-purple-700 checkbox-cutaway-video-track\" name=\"cutaway-track-${A}\" value=\"${A}\" checked>\n   651→                  <div>V${A + 1}</div>\n   652→              </label>\n   653→          </div>\n   654→        `;\n   655→    }\n   656→    $('.multitrack-video-cutaway-tracks-list').html(html);\n   657→\n   658→    let any_wide = false;\n   659→    for (let Y = 0; Y < g_multitrack_video_mapping.length; Y++) {\n   660→        if (g_multitrack_video_mapping[Y].length > 1) {\n   661→            any_wide = true;\n   662→            break;\n   663→        }\n   664→    }\n   665→\n   666→    if (any_wide) {\n   667→        for (let R = 0; R < g_multitrack_video_mapping.length; R++) {\n   668→            console.log('i', R);\n   669→            if (g_multitrack_video_mapping[R].length > 1) {\n   670→                console.log('wide shot');\n   671→                $('#multitrack-video-cutaway-tracks-list-from').find('input[value=' + R + ']').prop('checked', false);\n   672→            } else {\n   673→                console.log('not wide shot');\n   674→                $('#multitrack-video-cutaway-tracks-list-to').find('input[value=' + R + ']').prop('checked', false);\n   675→            }\n   676→        }\n   677→    }\n   678→    reset_multitrack_decision_modifiers_listeners();\n   679→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"cc787847-10b7-48ca-b112-b98636a99b88","timestamp":"2025-12-25T18:00:55.939Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/ui_clean.js","content":"async function test_48_get_multitrack_params() {\n    multitrack_parameters = null;\n    try {\n        if (!$('[menu-name=multitrack-audio]').hasClass('hidden')) {\n            // AUDIO MODE\n            console.log('test_48: audio mode');\n            const sorted_indices = '6|1|8|3|2|5|0|4|9|7'.split('|');\n\n            // Re-ordered logic based on flow analysis\n            // 0: detect_nonspeech\n            multitrack_parameters = {}; // Initialized implicitly or via object assignment logic found later? \n            // Correct logic flow reconstruction:\n\n            // 6: Log\n            // 1: getInterpolatedValueFromStops\n            multitrack_parameters = getInterpolatedValueFromStops(0, silence_cutting_parameters_stops);\n\n            // 8: Threshold method\n            if ($('#setting-multitrack-audio-threshold-method-auto').is(':checked')) {\n                multitrack_parameters['threshold_method'] = 'auto';\n                multitrack_parameters['threshold'] = null;\n            } else {\n                multitrack_parameters['operation'] = 'custom';\n                multitrack_parameters['threshold'] = parseFloat($('#range-multitrack-audio-custom-threshold').val());\n            }\n\n            // 3: Key Audio Indices Init\n            multitrack_parameters['keyAudioTrackIndices'] = [];\n\n            // 2: Key Audio Tracks\n            $('#setting-multitrack-tracks-audio input').each(function (A) {\n                console.log($(this));\n                if ($(this).is(':checked')) {\n                    multitrack_parameters['keyAudioTrackIndices'].push(parseInt($(this).val()));\n                    console.log('Added checked track to multitrack_parameters.keyAudioTrackIndices', parseInt($(this).val()));\n                }\n            });\n\n            // 5: Scope\n            if ($('#setting-multitrack-audio-scope-inout').is(':checked')) {\n                multitrack_parameters['scope'] = 'inout';\n            } else {\n                multitrack_parameters['scope'] = 'full';\n            }\n\n            // 0: Detect Nonspeech\n            multitrack_parameters['detect_nonspeech'] = $('#detect-nonspeech-multitrack-audio').is(':checked');\n\n            // 4: Disable Linked Video\n            multitrack_parameters['disable_linked_video'] = $('#disable-linked-video-multitrack-audio').is(':checked');\n\n            // 9: Format\n            if ($('#setting-multitrack-audio-format-wav').is(':checked')) {\n                multitrack_parameters['format'] = 'wav';\n            } else {\n                multitrack_parameters['format'] = 'mp3-high';\n            }\n\n            // 7: Method\n            if ($('#multitrack-audio-algorithm-basic-original').is(':checked')) {\n                multitrack_parameters['method'] = 'original';\n            } else {\n                multitrack_parameters['method'] = 'rapid';\n            }\n\n        } else {\n            // VIDEO MODE\n            // 5: Log\n            console.log('test_48: video mode');\n\n            // 2: Init\n            multitrack_parameters = {};\n\n            // 4: Default Operation\n            multitrack_parameters['operation'] = 'disable';\n\n            // 1: Operation check\n            if ($('#multitrack-video-operation-disable').is(':checked')) {\n                multitrack_parameters['operation'] = 'disable';\n            } else {\n                multitrack_parameters['operation'] = 'delete';\n            }\n\n            // 0: Mute Audio\n            multitrack_parameters['mute_audio'] = $('#multitrack-video-operation-mute-audio').is(':checked');\n\n            // 3: Scope\n            if ($('#multitrack-video-scope-inout').is(':checked')) {\n                multitrack_parameters['scope'] = 'inout';\n            } else {\n                multitrack_parameters['scope'] = 'full';\n            }\n        }\n    } catch (B) {\n        console.log('error while getting silence parameters', B);\n    }\n\n    if (multitrack_parameters['scope'] == 'inout') {\n        // IN/OUT Logic\n        console.log('eval_string', eval_string);\n        // getInPoint\n        console.log('eval_string', 'app.project.activeSequence.getInPoint()');\n        eval_string = 'app.project.activeSequence.getInPoint()';\n        multitrack_parameters['inPoint'] = await new Promise((resolve, reject) => {\n            jsx['evalScript'](eval_string, function (s) {\n                console.log('result', s);\n                resolve(parseFloat(s));\n            });\n        });\n\n        // getOutPoint\n        eval_string = 'app.project.activeSequence.getOutPoint()';\n        console.log('eval_string', eval_string);\n        multitrack_parameters['outPoint'] = await new Promise((resolve, reject) => {\n            jsx['evalScript'](eval_string, function (s) {\n                console.log('result', s);\n                resolve(parseFloat(s));\n            });\n        });\n\n    } else {\n        // FULL/WORKAREA Logic\n        // getWorkAreaInPoint\n        console.log('eval_string', eval_string);\n        eval_string = 'app.project.activeSequence.getWorkAreaInPoint()';\n        multitrack_parameters['inPoint'] = await new Promise((resolve, reject) => {\n            jsx['evalScript'](eval_string, function (c) {\n                console.log('result', c);\n                resolve(parseFloat(c));\n            });\n        });\n\n        // getWorkAreaOutPoint\n        eval_string = 'app.project.activeSequence.getWorkAreaOutPoint()';\n        console.log('eval_string', eval_string);\n        multitrack_parameters['outPoint'] = await new Promise((resolve, reject) => {\n            jsx['evalScript'](eval_string, function (c) {\n                console.log('result', c);\n                resolve(parseFloat(c));\n            });\n        });\n    }\n\n    multitrack_parameters['inPoint'] = Math.max(multitrack_parameters['inPoint'], 0);\n    multitrack_parameters['scopeValid'] = true;\n    if (multitrack_parameters['scope'] == 'inout') {\n        if (multitrack_parameters['inPoint'] == multitrack_parameters['outPoint']) {\n            multitrack_parameters['scopeValid'] = false;\n        }\n        if (multitrack_parameters['inPoint'] < 0 || multitrack_parameters['outPoint'] < 0) {\n            multitrack_parameters['scopeValid'] = false;\n        }\n        if (multitrack_parameters['inPoint'] > multitrack_parameters['outPoint']) {\n            multitrack_parameters['scopeValid'] = false;\n        }\n    }\n    console.log(multitrack_parameters);\n    return multitrack_parameters;\n}\n\nfunction writeHTML_multitrack_audioTrackText() {\n    let html = '';\n    // Loop through speakers\n    for (let n = 0; n < g_num_speakers; n++) {\n        let speakerName = g_multitrack_speaker_names[n];\n        let deleteButton;\n        const imgIcon = '<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4A...AAAABJRU5ErkJggg==\" alt=\"multiply\" class=\"w-6\">';\n\n        // n < 2 ? Disabled Delete : Enabled Delete\n        if (n < 2) {\n            deleteButton = '<button disabled class=\"cursor-not-allowed button-multitrack-video-speaker-delete ms-2 me-0 rounded-md px-1 border bg-shorts-500 hover:bg-shorts-400 active:bg-shorts-600 border-shorts-400 hover:border-shorts-300 active:border-shorts-500 text-white disabled:opacity-50 disabled:bg-shorts-500 disabled:border-shorts-400\">' + imgIcon + '</button>';\n        } else {\n            deleteButton = '<button class=\"button-multitrack-video-speaker-delete ms-2 me-0 rounded-md px-1 border bg-shorts-500 hover:bg-shorts-400 active:bg-shorts-600 border-shorts-400 hover:border-shorts-300 active:border-shorts-500 text-white disabled:opacity-50 disabled:bg-shorts-500 disabled:border-shorts-400\">' + imgIcon + '</button>';\n        }\n\n        html += `\n          <div class=\"flex justify-between my-1\">\n             <div class=\"w-10 select-none\">A${n + 1}:</div>\n             <input id=\"textinput-multitrack-video-speaker-name-${n + 1}\" speaker-number=\"${n}\" type=\"text\" value=\"${speakerName}\" class=\"grow bg-shorts-500 text-shorts-100 hover:bg-shorts-400 focus:border-shorts-600 focus:bg-shorts-400 w-full rounded px-2 py-1 text-sm text-sm leading-tight focus:outline-none\" >\n             ${deleteButton}\n          </div>\n        `;\n    }\n\n    let add_speaker_hidden = '';\n    if (g_num_speakers < g_num_audio_tracks) {\n        add_speaker_hidden = '';\n    } else {\n        add_speaker_hidden = 'hidden';\n    }\n\n    html += `\n          <div class=\"w-full flex justify-center\">\n             <button id=\"button-multitrack-add-speaker\" class=\"${add_speaker_hidden} mt-1 px-3 me-0 rounded-md border bg-shorts-500 hover:bg-shorts-400 active:bg-shorts-600 border-shorts-400 hover:border-shorts-300 active:border-shorts-500 text-whi1te disabled:opacity-50 disabled:bg-shorts-500 disabled:border-shorts-400 text-gray-300 text-xl\">+</button>\n          </div>\n        `;\n\n    console.log(html);\n    $('#multitrack-video-audio-names').html(html);\n    set_multitrack_video_listeners();\n}\n\nfunction multitrack_readSpeakerNamesFromHTML(z = true) {\n    g_multitrack_speaker_names = [];\n    g_num_speakers = 0;\n\n    $('#multitrack-video-audio-names input').each(function () {\n        let val = $(this).val();\n        if ($(this).val() == '' && !z) {\n            val = 'A' + (g_num_speakers + 1);\n        }\n        g_multitrack_speaker_names.push(val);\n        g_num_speakers++;\n    });\n\n    let empty_array = Array(20).fill(''); // Assuming 20 based on similar fills usually being a safe max\n    g_multitrack_speaker_names = g_multitrack_speaker_names.concat(empty_array);\n    g_multitrack_speaker_names = g_multitrack_speaker_names.slice(0, g_num_speakers);\n}\n\nfunction multitrack_readVideoMappingSelections() {\n    g_multitrack_video_mapping_selection_indices = [];\n    $('#multitrack-video-mapping select').each(function () {\n        g_multitrack_video_mapping_selection_indices.push(parseInt($(this).val()));\n    });\n\n    let empty_array = Array(20).fill(0);\n    g_multitrack_video_mapping_selection_indices = g_multitrack_video_mapping_selection_indices.concat(empty_array);\n    g_multitrack_video_mapping_selection_indices = g_multitrack_video_mapping_selection_indices.slice(0, g_num_video_tracks);\n\n    let n = tools['powerSet'](g_multitrack_speaker_names.length);\n    n.unshift([]);\n    g_multitrack_video_mapping = [];\n    for (let k = 0; k < g_multitrack_video_mapping_selection_indices.length; k++) {\n        let A = g_multitrack_video_mapping_selection_indices[k];\n        g_multitrack_video_mapping.push(n[A]);\n    }\n}\n\nfunction writeHTML_multitrack_videoTrackSelect() {\n    multitrack_readSpeakerNamesFromHTML();\n    multitrack_readVideoMappingSelections();\n\n    let n = tools['powerSet'](g_multitrack_speaker_names.length);\n    n.unshift([]); // Add empty set as option 0?\n\n    let html = '\\n      ';\n    for (let A = 0; A < g_num_video_tracks; A++) {\n        html += `\n          <div class=\"flex justify-between items-center my-0.5\">\n             <div class=\"w-10 select-none\">V${A + 1}:</div>\n             <select id=\"multitrack-video-mapping-${A + 1}\" video-track-number=\"${A + 1}\" class=\" grow border text-xs rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-1 bg-gray-700 border-gray-600 placeholder-gray-400 text-white focus:ring-blue-500 focus:border-blue-500\">\n             `;\n\n        for (let a = 0; a < n.length; a++) {\n            let selected = (g_multitrack_video_mapping_selection_indices[A] == a) ? 'selected' : '';\n            html += `\n                  <option value=\"${a}\" ${selected}>${combination_as_names(n[a], g_multitrack_speaker_names)}</option>`;\n        }\n\n        html += `\n             </select>\n          </div>`;\n    }\n\n    $('#multitrack-video-mapping').html(html);\n    $('#multitrack-video-mapping select').select2({\n        'theme': 'firecut-multitrack',\n        'minimumResultsForSearch': -1\n    });\n}\n\nasync function showMultiTrackSelection() {\n    // Sequence roughly: '0|5|3|2|4|1'\n\n    // 0: Build Track Names\n    let result = await buildTrackNamesArray();\n    videoTrackNames = result[0];\n    audioTrackNames = result[1];\n\n    // 5: Num Video Tracks\n    g_num_video_tracks = videoTrackNames.length;\n\n    // 3: Num Audio Tracks\n    g_num_audio_tracks = audioTrackNames.length;\n\n    // 2: Read Speaker Names (Initialize)\n    multitrack_readSpeakerNamesFromHTML();\n\n    // 4: Write Audio Track HTML\n    writeHTML_multitrack_audioTrackText();\n\n    // 1: Write Video Track HTML\n    writeHTML_multitrack_videoTrackSelect();\n}\n\nasync function writeHTML_multitrack_boosts() {\n    let html = '';\n    for (let k = 0; k < g_multitrack_speaker_names.length; k++) {\n        html += `\n          <div class=\"flex justify-between items-center mt-0 multitrack-boost-speaker\">\n             <div class=\"w-40\">   \n                 <div class=\"flex items-center w-full \">\n                     <div class=\"text-sm select-none text-left me-2 bg-transparent border-transparent rounded-md outline-none focus:border-transparent \">\n                         ${g_multitrack_speaker_names[k]}\n                     </div>\n                 </div>\n             </div>\n             <div class=\"w-32\">   \n                 <div class=\"text-sm w-full select-none text-center me-2 bg-transparent border-transparent rounded-md outline-none focus:border-transparent \">\n                     <span class=\"value-multitrack-boost\" id=\"value-multitrack-boost-${k}\">0</span> dB\n                 </div>\n             </div>\n             <div class=\"grow\">\n                 <input id=\"range-multitrack-boost-${k}\" type=\"range\" value=\"0\" min=\"-50\" max=\"50\" step=\"1\" class=\"accent-purple-700 range-multitrack-boost outline-none w-full my-2 h-1 rounded-lg appearance-none cursor-pointer bg-gray-700 active:bg-gray-700 focus:bg-gray-700\">\n             </div>\n          </div>\n        `;\n    }\n\n    $('#multitrack-boost-advanced').html(html);\n\n    $('.range-multitrack-boost').off('input');\n    $('.range-multitrack-boost').on('input', function () {\n        let val = $(this).val();\n        let display = $(this).closest('.multitrack-boost-speaker').find('.value-multitrack-boost');\n        display.html(val);\n    });\n\n    reset_multitrack_decision_modifiers_listeners();\n    set_multitrack_auto_balance_listener();\n}\n\nfunction multitrack_decisions_show_video_switch_list(decision_index) {\n    let html = '';\n    let valid_video_indices = [];\n\n    // Find video tracks that have content (mapping length > 0)\n    for (let Z = 0; Z < g_multitrack_video_mapping.length; Z++) {\n        if (g_multitrack_video_mapping[Z].length > 0) {\n            valid_video_indices.push(Z);\n        }\n    }\n\n    let current_video_index = g_multitrack_decisions[decision_index]['video_index'];\n    if (!g_multitrack_decisions[decision_index]['override']) {\n        current_video_index = -1; // Auto\n    }\n\n    // Auto Option\n    html += `\n        <div>\n           <input data-decision_index=\"${decision_index}\" type=\"radio\" id=\"video-switch-list-auto\" name=\"video-switch-list\" value=\"-1\" class=\"hidden peer\" \n           ${(current_video_index == -1 ? 'checked' : '')}\n           >\n           <label for=\"video-switch-list-auto\" class=\"flex items-center justify-between h-5 w-9 text-zinc-200 bg-zinc-700 hover:bg-gray-400 active:bg-gray-500 rounded cursor-pointer  peer-checked:bg-gray-500 peer-checked:text-white\">\n              <div class=\"w-full text-sm text-center\">Auto</div>\n           </label>\n        </div>`;\n\n    // Video Options\n    for (let Q = 0; Q < valid_video_indices.length; Q++) {\n        let idx = valid_video_indices[Q];\n        html += `\n        <div>\n           <input data-decision_index=\"${decision_index}\" type=\"radio\" id=\"video-switch-list-${idx}\" name=\"video-switch-list\" value=\"${idx}\" class=\"hidden peer\"\n           ${(idx == current_video_index ? 'checked' : '')}\n           >\n           <label for=\"video-switch-list-${idx}\" class=\"flex items-center justify-between h-5 w-5 text-zinc-200 bg-zinc-700 hover:bg-gray-400 active:bg-gray-500 rounded cursor-pointer  peer-checked:bg-gray-500 peer-checked:text-white\">\n              <div class=\"w-full text-sm text-center\">${idx + 1}</div>\n           </label>\n        </div>`;\n    }\n\n    $('#multitrack-decisions-video-switch-list').html(html);\n    $('#multitrack-decisions-video-switch-list').removeClass('hidden');\n    $('#multitrack-decisions-video-switch-list-bg').removeClass('hidden');\n\n    $('#multitrack-decisions-video-switch-list input').off('click');\n    $('#multitrack-decisions-video-switch-list input').on('click', function () {\n        let val = parseInt($(this).val());\n        console.log(val);\n        let decIndex = parseInt($(this).data('decision_index'));\n\n        // Remove existing override if present\n        if (g_multitrack_decisions[decIndex]['override']) {\n            g_multitrack_decision_overrides.splice(g_multitrack_decisions[decIndex]['override_index'], 1);\n        }\n\n        if (val != -1) {\n            // Add new override\n            g_multitrack_decision_overrides.push({\n                'time': (g_multitrack_decisions[decIndex]['time_range'][0] + g_multitrack_decisions[decIndex]['time_range'][1]) / 2,\n                'video_index': val\n            });\n        }\n\n        if (multitrack_wide_shots_available()) {\n            test_101_finetune_multitrack_wide_shot_tolerance();\n        } else {\n            test_51_decide_multicam_cuts();\n        }\n\n        writeHTML_multitrack_decisions_table();\n        update_multitrack_screentime_chart();\n        $('#multitrack-decisions-video-switch-list').addClass('hidden');\n        $('#multitrack-decisions-video-switch-list-bg').addClass('hidden');\n    });\n\n    $('#multitrack-decisions-video-switch-list-bg').off('click');\n    $('#multitrack-decisions-video-switch-list-bg').on('click', function (s) {\n        $('#multitrack-decisions-video-switch-list').addClass('hidden');\n        $('#multitrack-decisions-video-switch-list-bg').addClass('hidden');\n        s.stopPropagation();\n    });\n\n    // Positioning\n    let listButton = $('.multitrack-video-table-row[multitrack-video-decision-number=\"' + (decision_index + 1) + '\"] .multitrack-manual-video-track-button');\n    let offset = { 'top': listButton.offset().top, 'left': listButton.offset().left };\n    let width = listButton.width();\n\n    $('#multitrack-decisions-video-switch-list').css({\n        'top': offset.top - 5,\n        'left': offset.left + (width / 2) - ($('#multitrack-decisions-video-switch-list').width() / 2)\n    });\n}\n\nasync function writeHTML_multitrack_decisions_table() {\n    let mode = 'manual';\n    let eval_string = 'getVideoFrameRateInSeconds()';\n    console.log('eval_string', eval_string);\n\n    let videoFrameRate = await new Promise((resolve, reject) => {\n        jsx['evalScript'](eval_string, function (R) {\n            console.log('result', R);\n            resolve(R);\n        });\n    });\n    videoFrameRate = parseFloat(videoFrameRate);\n    console.log('videoFrameRate', videoFrameRate);\n\n    let tbody = $('#multitrack-video-table tbody');\n    let html = '';\n\n    for (let a = 0; a < g_multitrack_decisions.length; a++) {\n        let decision = g_multitrack_decisions[a];\n        let startTime = timeConversion(decision['time_range'][0], 's', 'hh:mm:ss', videoFrameRate);\n        let duration = timeConversion(decision['time_range'][1] - decision['time_range'][0], 's', 'hh:mm:ss', videoFrameRate);\n        let endTime = timeConversion(decision['time_range'][1], 's', 'hh:mm:ss', videoFrameRate);\n\n        let buttonClass = 'bg-shorts-500 border-shorts-400 hover:bg-shorts-300 hover:border-shorts-200 active:bg-shorts-500 active:border-shorts-400';\n        let speakerCellContent = '';\n        let speakerCellStyle = '';\n        let speakerName = decision['speaker'];\n        let speakerColor = g_speaker_colors[g_multitrack_speaker_names.indexOf(decision['speaker'])];\n        let stripeStyle = '';\n\n        if (decision['speakers'].length > 1) {\n            speakerColor = '';\n            stripeStyle = generate_stripe_style(decision['speakers'].map(b => g_speaker_colors_hex[g_multitrack_speaker_names.indexOf(b)]));\n        }\n\n        if (g_multitrack_decisions.length == 1) {\n            speakerName = decision['speaker'];\n            speakerCellStyle = 'rounded-md border-2 ';\n        } else if (a < g_multitrack_decisions.length - 1) {\n            // Not last\n            if (a == 0) {\n                // First\n                speakerName = decision['speaker'];\n                speakerCellStyle += 'rounded-t-md border-t-2 ';\n            } else if (decision['speaker'] != g_multitrack_decisions[a - 1]['speaker']) {\n                // Change of speaker\n                speakerName = decision['speaker'];\n                speakerCellStyle += 'rounded-t-md border-t-2 ';\n            }\n\n            if (decision['speaker'] != g_multitrack_decisions[a + 1]['speaker']) {\n                // Next is different\n                speakerCellStyle += 'rounded-b-md border-b-2 ';\n            }\n        } else {\n            // Last\n            if (decision['speaker'] != g_multitrack_decisions[a - 1]['speaker']) {\n                speakerName = decision['speaker'];\n                speakerCellStyle += 'rounded-t-md border-t-2 ';\n            }\n            speakerCellStyle += 'rounded-b-md border-b-2 ';\n        }\n\n        let speakerCell = `<td class=\"p-0 px-1 text-left font-bold border-shorts-700 text-white ${speakerCellStyle} ${speakerColor}\" style=\"${stripeStyle}\">${speakerName}</td>`;\n\n        html += `\n          <tr class=\"multitrack-video-table-row\" multitrack-video-decision-number=\"${a + 1}\">\n              ${speakerCell}\n              <td class=\"p-0 ps-1 text-left\">\n                  ${decision['reason']}\n              </td>`;\n\n        if (decision['override']) {\n            html += `\n              <td class=\"p-0 flex justify-center\">\n                  <button class=\"multitrack-manual-video-track-button p-0 w-6 text-center rounded-md px-1 text-white bg-cyan-600 border border-cyan-600 hover:bg-cyan-400 hover:border-cyan-400 active:bg-cyan-600 active:border-cyan-600 cursor-pointer\">\n                      ${decision['video_index'] + 1}\n                  </button>\n              </td>`;\n        } else {\n            html += `\n              <td class=\"p-0 flex justify-center\">\n                  <button class=\"multitrack-manual-video-track-button p-0 w-6 text-center rounded-md px-1 text-white bg-gray-500 border border-gray-500 hover:bg-gray-400 hover:border-gray-400 active:bg-gray-600 active:border-gray-600 cursor-pointer\">\n                      ${decision['video_index'] + 1}\n                  </button>\n              </td>`;\n        }\n\n        html += `\n              <td class=\"ps-1 col-span-3\">\n                  <button class=\"flex justify-between button-multitrack-video-time-section w-full m-0 rounded-md px-1 text-white ${buttonClass}\">\n                      <div class=\"px-1\">${startTime}</div>\n                      <div class=\"px-1\">➔</div>\n                      <div class=\"px-1\">${duration}</div>  \n                  </button>    \n              </td>\n              <td class=\"p-0 ps-1 text-center hidden xs:table-cell select-none\">\n                  ${endTime}\n              </td>\n          </tr>\n        `;\n    }\n\n    tbody.html(html);\n    set_multitrack_go_to_time_listeners();\n    if (mode == 'manual') {\n        set_multitrack_manual_listeners();\n    }\n}\n\nfunction select_multitrack_decision_number(z) {\n    let index = z - 1;\n    let start = g_multitrack_decisions[index]['time_range'][0];\n    let end = g_multitrack_decisions[index]['time_range'][1];\n\n    console.log('Moving to time section: ', start, end);\n\n    // Set In Point\n    let eval_string = 'app.project.activeSequence.setInPoint(' + start + ')';\n    new Promise((resolve, reject) => {\n        jsx['evalScript'](eval_string, function (Z) {\n            console.log('result', Z);\n            resolve(Z);\n        });\n    });\n\n    // Set Out Point\n    eval_string = 'app.project.activeSequence.setOutPoint(' + end + ')';\n    new Promise((resolve, reject) => {\n        jsx['evalScript'](eval_string, function (Q) {\n            console.log('result', Q);\n            resolve(Q);\n        });\n    });\n\n    // Move Playhead\n    let ticks = parseInt(start * ticks_per_second);\n    eval_string = 'app.project.activeSequence.setPlayerPosition(\"' + ticks + '\")';\n    new Promise((resolve, reject) => {\n        jsx['evalScript'](eval_string, function (Q) {\n            console.log('result', Q);\n            resolve(Q);\n        });\n    });\n}\n\nfunction control_multitrack_wide_shots_tolerance_input() {\n    let available = multitrack_wide_shots_available();\n    if (available) {\n        $('#multitrack-wide-shot-tolerance-container').removeClass('opacity-20 cursor-not-allowed');\n        $('#range-multitrack-wide-shot-tolerance').prop('disabled', false);\n        $('#range-multitrack-wide-shot-percentage').prop('disabled', false);\n        $('#no-wide-shots').addClass('hidden');\n    } else {\n        $('#multitrack-wide-shot-tolerance-container').addClass('opacity-20 cursor-not-allowed');\n        $('#range-multitrack-wide-shot-tolerance').prop('disabled', true);\n        $('#range-multitrack-wide-shot-percentage').prop('disabled', true);\n        $('#no-wide-shots').removeClass('hidden');\n    }\n}\n\nvar multitrack_pixels_per_character = 10;\n\nfunction update_multitrack_screentime_chart() {\n    let summary = test_100_get_multitrack_screentime_summary();\n    let total = summary.reduce((a, b) => a + b, 0);\n    // Adjusted total to account for potential gaps or just normalizing?\n    // Using * 0.9 + ??? \"0x1*-0x1521+-0x11f6+-0x1*-0x2717+0.9\"\n    // -5409 - 4598 + 10007 = 0?\n    // The constant calculation seems to evaluate to 0.9.\n\n    let percentages = summary.map(Y => (Y / total) * 100);\n    let chartWidth = $('body').width() * 0.9;\n\n    let html = '';\n    for (let Y = 0; Y < g_multitrack_speaker_names.length + 1; Y++) {\n        let name = (Y === g_multitrack_speaker_names.length) ? 'Wide' : g_multitrack_speaker_names[Y];\n        let colorClass = (Y === g_multitrack_speaker_names.length) ? 'bg-shorts-300' : g_speaker_colors[Y];\n\n        // Width in pixels for this bar\n        let widthPx = (chartWidth * percentages[Y]) / 100;\n        let textWidth = multitrack_pixels_per_character * name.length;\n\n        let content = '';\n        if (widthPx >= textWidth) {\n            content = `\n                  <div>\n                      <span class=\"font-bold\">${name}</span> (${Math.round(percentages[Y])}%)\n                  </div>`;\n        } else if (widthPx >= 20) { // Enough for ... \n            content = `\n                  <div>\n                      <span class=\"font-bold block group-hover:hidden\">...</span>\n                  </div>`;\n        }\n\n        // Hover content always shows full info\n        content += `\n              <div class=\"hidden group-hover:block\">\n                  <span class=\"font-bold\">${name}</span> (${Math.round(percentages[Y])}%)\n              </div>\n        `;\n\n        html += `\n            <div class=\"group relative select-none flex items-center justify-center h-full text-white border border-shorts-700 ${colorClass} text-center\" style=\"width:${percentages[Y]}%\">\n                ${content}\n            </div>`;\n    }\n\n    $('#multitrack-screentime-chart').html(html);\n}\n\nfunction writeHTML_cutaway_checkboxes() {\n    let html = '';\n    for (let A = 0; A < g_multitrack_video_mapping.length; A++) {\n        if (g_multitrack_video_mapping[A].length == 0) continue;\n\n        let checked = 'checked';\n        // HTML construction\n        html += `\n          <div class=\"flex items-center\">\n              <label class=\"ms-1 text-sm font-medium select-none flex items-center space-x-1\">\n                  <input type=\"checkbox\" class=\"accent-purple-700 checkbox-cutaway-video-track\" name=\"cutaway-track-${A}\" value=\"${A}\" checked>\n                  <div>V${A + 1}</div>\n              </label>\n          </div>\n        `;\n    }\n    $('.multitrack-video-cutaway-tracks-list').html(html);\n\n    let any_wide = false;\n    for (let Y = 0; Y < g_multitrack_video_mapping.length; Y++) {\n        if (g_multitrack_video_mapping[Y].length > 1) {\n            any_wide = true;\n            break;\n        }\n    }\n\n    if (any_wide) {\n        for (let R = 0; R < g_multitrack_video_mapping.length; R++) {\n            console.log('i', R);\n            if (g_multitrack_video_mapping[R].length > 1) {\n                console.log('wide shot');\n                $('#multitrack-video-cutaway-tracks-list-from').find('input[value=' + R + ']').prop('checked', false);\n            } else {\n                console.log('not wide shot');\n                $('#multitrack-video-cutaway-tracks-list-to').find('input[value=' + R + ']').prop('checked', false);\n            }\n        }\n    }\n    reset_multitrack_decision_modifiers_listeners();\n}","numLines":679,"startLine":1,"totalLines":679}}}
{"parentUuid":"cc787847-10b7-48ca-b112-b98636a99b88","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"40e35131-d872-47c8-a3ec-760adc72c5aa","version":"2.0.76","gitBranch":"main","agentId":"a8447b0","slug":"zippy-mixing-wilkes","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01AmWej78LbMMuAUPZKWYEaE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me create a comprehensive analysis document based on what I've found:\n\n## DETAILED ANALYSIS: Fireside Deobfuscated Multitrack Module\n\n### Overview\n\nThe Fireside multitrack editing module is a sophisticated competitor implementation for automated multicam editing in Premiere Pro. It demonstrates advanced techniques for audio analysis, intelligent video angle selection, and complex parameter optimization. Here's the complete technical breakdown:\n\n---\n\n### 1. ARCHITECTURE & WORKFLOW\n\n#### Core Functions (main_clean.js)\n\n**Three Main Workflows:**\n\n1. **`multitrack_audio()`** - Audio-only silence removal across multiple tracks\n   - Chunks analysis by 1800 frames (30-60 seconds depending on framerate)\n   - Per-track silence detection and padding adjustment\n   - Supports \"original\" (JSX) or \"rapid\" (local) processing methods\n   - License verification + usage tracking\n\n2. **`multitrack_video_analyze()`** - Video angle analysis and decision making\n   - Analyzes audio levels for each speaker separately\n   - Uses random number arrays for cutaway/shot selection (deterministic randomness)\n   - Generates \"cleaned\" audio levels by subtracting noise floor\n   - Applies speaker boosts and switching frequency smoothing\n   - Calls `test_51_decide_multicam_cuts()` to generate final decisions\n\n3. **`multitrack_video_cut()`** - Executes video edits and audio muting\n   - Applies inverse segment deletion to video tracks\n   - Consolidates decisions for audio muting logic\n   - Extends mute ranges for speakers not visible on current video angle\n   - Merges adjacent mute ranges for efficiency\n\n---\n\n### 2. AUDIO ANALYSIS PIPELINE\n\n#### Key Metrics (ui_clean.js):\n\n```\nAudio Level Processing:\n├─ RMS extraction for each speaker track (separate pass)\n├─ Noise floor calculation (average/mix of all speakers)\n├─ Cleanup: Level[speaker] - Level[average] (normalized to -100 to 0 dB)\n├─ Gaussian Blur smoothing (configurable window)\n└─ Speaker boost application (+/- dB adjustments)\n```\n\n#### Data Structures:\n- `g_cleaned_up_levels`: Array of arrays [speaker[timeframe[rms_value]]]\n- `g_audio_track_times`: Timestamps for each RMS sample\n- `g_cleaned_up_levels_blurred`: Smoothed audio levels\n\n---\n\n### 3. MULTITRACK DECISION ENGINE (helpers_clean.js)\n\n#### `test_51_decide_multicam_cuts()` - Core Algorithm\n\n**Input Parameters:**\n- `smoothing_window` - Gaussian blur kernel size (frames)\n- `switching_frequency` - How often to allow cuts (0-100 scale)\n- `min_shot_duration` - Minimum length before allowing next cut (seconds)\n- `wide_shot_percentage` - Target % of time showing wide shots (0-100)\n- `wide_shot_tolerance` - Threshold for multi-speaker detection\n- `cutaway_duration` - Min/max length for cutaway clips\n- `cutaways_enabled` - Toggle for cutaway insertion\n\n**Algorithm Steps:**\n\n1. **Track Mapping Construction** (lines 279-307):\n   - For each speaker, identify which video tracks show them\n   - Build primary track list `b[speaker]` = [track indices]\n   - Identify single-speaker vs multi-speaker tracks\n   - Create shortlist `S[speaker]` for single-speaker tracks only\n\n2. **Wide Shot Detection** (lines 315-320):\n   - Find tracks that don't contain primary speakers (`H` array)\n   - These are available for cutaways\n\n3. **Audio Level Smoothing** (lines 324-330):\n   - Apply Gaussian blur if smoothing_window > 0\n   - Reduces noise in speaker detection\n\n4. **Speaker Boost Application** (lines 332-343):\n   - Add dB boosts to each speaker's audio level\n   - Range: -50 to +50 dB (configurable per speaker)\n\n5. **Decision Making** (lines 349-449):\n   - For each time point, find speaker with loudest audio\n   - Detect when speaker changes or multiple speakers reach threshold\n   - \"Wide shot\" = multiple speakers above tolerance\n   - Create decision objects with:\n     ```javascript\n     {\n       speaker: \"Speaker Name\",\n       speakers: [multi-speaker array],\n       audio_index: primary_speaker_idx,\n       video_index: selected_track_idx,\n       time_range: [start, end],\n       reason: \"Speaker\" | \"Wide (mult. speakers)\" | \"Cutaway\" | etc,\n       override: boolean,\n       override_index: user_manual_override_idx\n     }\n     ```\n\n6. **Decision Consolidation** (lines 450-472):\n   - Merge decisions shorter than `min_shot_duration`\n   - Merge adjacent decisions using same video track or same speakers\n   - Merge consecutive wide shots\n\n7. **Cutaway Insertion** (lines 474-549):\n   - For long clips exceeding `max_time`:\n     - Calculate cut interval `N = (max_time - cutaway_max_len) / 2`\n     - Insert cutaway clips of random length between min/max duration\n     - Alternate with return-to-speaker cuts\n     - Use random selection from allowed cutaway tracks\n\n8. **Manual Overrides** (lines 563-572):\n   - Apply user-selected video angle overrides\n   - Overrides only affect specific time ranges\n\n**Decision Merging Logic:**\n```javascript\n// Merge if:\n// 1. Same video track + adjacent time ranges\n// 2. Same speakers + adjacent time ranges\n// 3. Both are wide shots (even if different speaker combos)\n```\n\n---\n\n### 4. WIDE SHOT FINE-TUNING (test_101_finetune_multitrack_wide_shot_tolerance)\n\n**Algorithm: Binary Search with Tolerance Target**\n\n```\nGoal: Achieve target wide_shot_percentage ± acceptable_error (1%)\n\nWhile tolerance_error > acceptable_error:\n  mid = (low + high) / 2\n  run_decision_algorithm_with(tolerance=mid)\n  actual_percentage = wide_shot_screentime / total_screentime\n  \n  if actual_percentage > target:\n    adjust_high = mid  // Too many wide shots\n  else:\n    adjust_low = mid   // Not enough wide shots\n  \n  if error < best_error:\n    best_tolerance = mid\n```\n\nThis fine-tunes the multi-speaker threshold to hit exact wide-shot percentages.\n\n---\n\n### 5. AUTO-BALANCING OPTIMIZER (test_102_auto_tune_multitrack_distribution)\n\n**Purpose:** Automatically balance speaker screentime to equal distribution\n\n**Key Concepts:**\n\n1. **Target Share Calculation:**\n   - If wide shots enabled: target = 1 / (num_speakers + 1)\n   - Otherwise: target = 1 / num_speakers\n\n2. **Discrete Parameter Tuning:**\n   ```\n   Parameters tested in order:\n   - Speaker boosts (discrete: -6 to +6 dB in 1dB steps)\n   - Max time effective cutoff (10-60 seconds, step 5)\n   - Min shot duration (0.75-3 seconds, step 0.25)\n   - Switching frequency (10-100, step 5)\n   - Cutaway duration (0.5-6 seconds, step 0.25)\n   - Wide shot percentage tuning (if available)\n   ```\n\n3. **Convergence:**\n   - Target: maxAbsError ≤ 1% after full parameter sweep\n   - Timeout: 10 seconds\n   - Uses annealing to reduce boost step size as it converges\n   - Logs all accepted/reverted steps for debugging\n\n4. **Decision Reverting:**\n   - If a parameter change increases error, revert it\n   - Uses saved state snapshots for rollback\n   - Maintains best-found configuration\n\n---\n\n### 6. KEY DATA STRUCTURES & GLOBAL STATE\n\n```javascript\n// Audio Analysis State\ng_cleaned_up_levels              // [speaker][timeframe] = RMS level\ng_audio_track_times              // [timeframe] = seconds\ng_shots_random_floats_array      // 1000 deterministic random values for shots\ng_multicam_cutaway_random_floats // 1000 random values for cutaway selection\n\n// Video Mapping\ng_multitrack_video_mapping           // [video_track] = [speaker_indices]\ng_multitrack_video_mapping_selection_indices // User selections per track\ng_multitrack_speaker_names       // User-entered speaker names\ng_num_speakers                   // Count of speakers\ng_num_video_tracks               // Count of video tracks\n\n// Decision State\ng_multitrack_decisions           // Array of decision objects\ng_multitrack_decision_overrides  // Manual user overrides {time, video_index}\n\n// UI State\ng_speaker_colors                 // CSS class names per speaker\ng_speaker_colors_hex             // Hex color codes for striping\n```\n\n---\n\n### 7. LISTENER ARCHITECTURE (listeners.js)\n\n**UI Interactions:**\n\n1. **Decision Navigation:**\n   - Click time range → Jump to decision in timeline\n   - Click video button → Show video track selection popup\n\n2. **Parameter Controls:**\n   - Range sliders (mouseup) → Re-run decision algorithm + chart update\n   - Checkboxes (input) → Re-run algorithm + toggle advanced sections\n   - Auto-Balance button → Run full optimization sweep\n\n3. **Audio Threshold Control:**\n   - Range and number input syncing\n   - Validation: -100 to 0 dB range\n\n4. **Speaker/Track Management:**\n   - Add/delete speaker entries\n   - Select video track mappings (power set combinations)\n   - Cutaway track selection (from/to lists)\n\n---\n\n### 8. PREMIERE PRO INTEGRATION\n\n#### JSX Script Execution:\n```javascript\njsx.evalScript(script, callback)  // Async execution pattern\n\n// Common Scripts:\napp.project.activeSequence.getInPoint()\napp.project.activeSequence.getOutPoint()\napp.project.activeSequence.setInPoint(frames)\napp.project.activeSequence.setOutPoint(frames)\napp.project.activeSequence.getWorkAreaInPoint()\napp.project.activeSequence.getWorkAreaOutPoint()\napp.project.activeSequence.setPlayerPosition(ticks)\n\n// Mute State Management:\ngetMuteState()           // Returns JSON of mute states per track\nsetMuteState(json)       // Sets mute states from JSON\ngetVideoFrameRateInSeconds()\n```\n\n#### Chunk Processing:\n- Splits timeline into 1800-frame chunks for analysis\n- Sets in/out points per chunk\n- Reduces memory footprint on large sequences\n\n---\n\n### 9. ALGORITHMS FOR ADAPTATION TO SPLICE\n\n#### Key Techniques SPLICE Could Adopt:\n\n1. **Audio Noise Floor Subtraction:**\n   ```javascript\n   // Separate speaker analysis with mix baseline\n   cleanedLevel = speakerLevel - averageLevel\n   // Eliminates background noise artifacts\n   ```\n\n2. **Gaussian Blur Smoothing:**\n   ```javascript\n   // Reduce spurious single-frame speaker changes\n   smoothed = gaussianBlur(levels, window_size)\n   ```\n\n3. **Deterministic Randomness:**\n   ```javascript\n   // Pre-generate random arrays for reproducibility\n   g_shots_random_floats_array = Array.from({length: 1000}, () => Math.random())\n   selection = array[Math.floor(random_array[index] * array.length)]\n   ```\n\n4. **Decision Consolidation Patterns:**\n   - Merge short decisions into neighbors\n   - Merge same-track adjacent segments\n   - Merge same-speaker ranges\n\n5. **Parameter Optimization:**\n   - Discrete tuning with acceptance thresholds\n   - Annealing for convergence\n   - Multi-parameter sweeps\n\n6. **Video Track Mapping:**\n   - Power set combinations (which speakers on each video track)\n   - Track selection by speaker isolation level\n   - Fallback to less-isolated tracks when needed\n\n---\n\n### 10. COMPARISON TO SPLICE'S CURRENT APPROACH\n\n| Aspect | Fireside | SPLICE v3.5 |\n|--------|----------|------------|\n| **Audio Analysis** | Per-speaker RMS + noise floor | Silence detection only |\n| **Video Selection** | Audio-driven with wide shots | Manual cut list |\n| **Optimization** | Auto-balance parameter tuning | No optimization |\n| **Determinism** | Pre-generated random arrays | N/A |\n| **Cutaway Logic** | Sophisticated insertion + routing | Not implemented |\n| **Mute Decisions** | Speaker visibility-based | N/A |\n| **Parameter Tuning** | Gradient-free discrete search | Static parameters |\n\n---\n\n### 11. CRITICAL IMPLEMENTATION DETAILS\n\n**Epsilon Tolerance for Range Merging:**\n```javascript\n// (line 423-424) Adjacent ranges considered contiguous if:\nif (Math.abs(lastRange.end - currentRange.start) <= 0.0001) {\n  // Merge them\n}\n```\n\n**Speaker Detection Threshold:**\n```javascript\n// (line 358-363) Speaker with loudest audio selected if:\n// 1. Within 0.01 dB of max, OR\n// 2. Above (max - wide_shot_tolerance)\n```\n\n**Cutaway Interval Calculation:**\n```javascript\n// (line 474) For long clips exceeding max_time:\nN = (max_time - cutaway_max_len) / 2\n// Creates balanced intervals for insertion\n```\n\n---\n\n### MALWARE/OBFUSCATION NOTES\n\n**This is legitimate code deobfuscation.** The helpers_clean.js file shows extreme obfuscation typical of commercial plugins protecting IP:\n- Hex arithmetic for constants\n- String concatenation to hide identifiers\n- Function wrappers with meaningless names\n- Variable renaming (T, u, P, etc.)\n\nThis is standard code protection, not malicious behavior. The deobfuscation reveals the actual algorithm logic safely.\n\n---\n\n### RECOMMENDATIONS FOR SPLICE\n\n1. **Implement Noise Floor Subtraction:** Improve speaker detection by subtracting background noise\n2. **Add Parameter Auto-Tuning:** Use discrete optimization for screentime balance\n3. **Implement Cutaway Logic:** Insert strategic cutaways for longer speaker segments\n4. **Audio Smoothing:** Apply Gaussian blur to reduce false speaker changes\n5. **Wide Shot Detection:** Identify multi-speaker segments for better visual variety\n6. **Mute Audio Based on Visibility:** Mute speakers not visible in current video angle\n\nAll analysis complete. The files are located at:\n- `/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/main_clean.js`\n- `/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/listeners.js`\n- `/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/ui_clean.js`\n- `/Users/imorgado/Desktop/Fireside_Deobstuficated/multitrack/helpers_clean.js`"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":31716,"cache_creation_input_tokens":22368,"cache_read_input_tokens":12697,"cache_creation":{"ephemeral_5m_input_tokens":22368,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWTqpZz237DdDh1JcFiwd","type":"assistant","uuid":"73a38fa7-a067-41b8-95b7-3f0a0e25dab3","timestamp":"2025-12-25T18:01:35.052Z"}
