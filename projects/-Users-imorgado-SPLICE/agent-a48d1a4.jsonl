{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a48d1a4","type":"user","message":{"role":"user","content":"Investigate the CEP EvalScript errors. Read splice-cep/jsx/hostScript.jsx and analyze the following functions that are failing:\n1. getActiveSequence()\n2. getAllSequences()\n3. Any functions that access app.project.activeSequence or QE DOM\n\nCompare them with checkSequenceOpen() which WORKS. Identify what's different - look for:\n- Syntax errors\n- Undefined variables\n- Missing try/catch\n- JSON serialization issues\n- Return statement problems\n\nReport your findings with specific line numbers and code issues."},"uuid":"d2277ea8-01d1-4b34-8d7c-40f4deb9f454","timestamp":"2026-01-12T07:49:01.680Z"}
{"parentUuid":"d2277ea8-01d1-4b34-8d7c-40f4deb9f454","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a48d1a4","slug":"fizzy-hatching-flame","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UjYiSu9S6vzpDP97bHpj1k","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HM6A6rpomyPJzRUZSNoEBw","name":"Read","input":{"file_path":"/Users/imorgado/SPLICE/splice-cep/jsx/hostScript.jsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":29234,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":29234,"ephemeral_1h_input_tokens":0},"output_tokens":73,"service_tier":"standard"}},"requestId":"req_011CX37ifzjo23KpAF9aumQx","type":"assistant","uuid":"0d712fdd-d350-4469-8ced-c0cfc2fd40a1","timestamp":"2026-01-12T07:49:06.009Z"}
{"parentUuid":"0d712fdd-d350-4469-8ced-c0cfc2fd40a1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a48d1a4","slug":"fizzy-hatching-flame","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HM6A6rpomyPJzRUZSNoEBw","type":"tool_result","content":"     1→/**\n     2→ * SPLICE CEP Host Script\n     3→ * ExtendScript for Premiere Pro\n     4→ *\n     5→ * Provides all Premiere Pro API functions called via jsx.evalScript()\n     6→ * Based on proven patterns from FireCut and SPLICE UXP builder\n     7→ */\n     8→\n     9→// ============================================================================\n    10→// GLOBAL CONSTANTS & STATE\n    11→// ============================================================================\n    12→var SPLICE_VERSION = \"6.0.3\";\n    13→var TICKS_PER_SECOND = 254016000000;\n    14→var time_tolerance = 0.01; // 10ms tolerance for clip matching\n    15→var temp_bin = null;\n    16→var sequence_default_timecode = null;\n    17→\n    18→// Color label indices (Premiere Pro standard)\n    19→var COLOR_LABELS = {\n    20→    NONE: 0,\n    21→    VIOLET: 1,\n    22→    IRIS: 2,\n    23→    CARIBBEAN: 3,\n    24→    LAVENDER: 4,\n    25→    CERULEAN: 5,\n    26→    FOREST: 6,\n    27→    ROSE: 7,\n    28→    MANGO: 8,\n    29→    PURPLE: 9,\n    30→    BLUE: 10,\n    31→    TEAL: 11,\n    32→    MAGENTA: 12,\n    33→    TAN: 13,\n    34→    GREEN: 14,\n    35→    BROWN: 15,\n    36→    YELLOW: 16\n    37→};\n    38→\n    39→// Segment type to color mapping\n    40→var SEGMENT_COLORS = {\n    41→    speech: COLOR_LABELS.FOREST,\n    42→    take: COLOR_LABELS.LAVENDER,\n    43→    best_take: COLOR_LABELS.CERULEAN,\n    44→    silence: COLOR_LABELS.VIOLET,\n    45→    wide_shot: COLOR_LABELS.YELLOW,\n    46→    speaker_a: COLOR_LABELS.MANGO,\n    47→    speaker_b: COLOR_LABELS.CARIBBEAN\n    48→};\n    49→\n    50→// Timecode display formats\n    51→var TIMECODES = {\n    52→    TIMEDISPLAY_Frames: 4\n    53→};\n    54→\n    55→// Translation map for localized effect names\n    56→var translations = {\n    57→    \"Motion\": [\"Motion\", \"Mouvement\", \"Bewegung\", \"Movimiento\", \"Movimento\"],\n    58→    \"Transform\": [\"Transform\", \"Transformation\", \"Transformieren\", \"Transformar\"],\n    59→    \"Scale\": [\"Scale\", \"Echelle\", \"Skalierung\", \"Escala\"],\n    60→    \"Scale Height\": [\"Scale Height\", \"Hauteur de l'echelle\", \"Skalierungshoehe\"],\n    61→    \"Scale Width\": [\"Scale Width\", \"Largeur de l'echelle\", \"Skalierungsbreite\"],\n    62→    \"Position\": [\"Position\", \"Posicion\", \"Posicao\"],\n    63→    \"Anchor Point\": [\"Anchor Point\", \"Point d'ancrage\", \"Ankerpunkt\"],\n    64→    \"Rotation\": [\"Rotation\", \"Rotacion\", \"Rotacao\"],\n    65→    \"Opacity\": [\"Opacity\", \"Opacite\", \"Deckkraft\", \"Opacidad\"]\n    66→};\n    67→\n    68→// Project item types\n    69→var project_item_type = {\n    70→    \"clip\": 1,\n    71→    \"bin\": 2,\n    72→    \"root\": 3,\n    73→    \"file\": 4\n    74→};\n    75→\n    76→// ============================================================================\n    77→// SECURITY: INPUT VALIDATION UTILITIES (CEP-CRIT-001)\n    78→// Prevents path traversal, command injection, and null byte attacks\n    79→// ============================================================================\n    80→\n    81→/**\n    82→ * Validate and sanitize file paths to prevent path traversal attacks\n    83→ * @param {string} path - File path to validate\n    84→ * @returns {Object} { valid: boolean, path: string, error: string }\n    85→ */\n    86→function validateFilePath(path) {\n    87→    if (!path || typeof path !== 'string') {\n    88→        return { valid: false, path: null, error: 'Invalid path: must be a non-empty string' };\n    89→    }\n    90→\n    91→    // Check for null bytes (CVE potential)\n    92→    if (path.indexOf('\\0') !== -1 || path.indexOf('\\x00') !== -1) {\n    93→        return { valid: false, path: null, error: 'Invalid path: null bytes detected' };\n    94→    }\n    95→\n    96→    // Normalize path separators\n    97→    var normalized = path.replace(/\\\\/g, '/');\n    98→\n    99→    // Check for directory traversal attempts\n   100→    if (normalized.indexOf('../') !== -1 || normalized.indexOf('..\\\\') !== -1) {\n   101→        return { valid: false, path: null, error: 'Invalid path: directory traversal detected' };\n   102→    }\n   103→\n   104→    // Check for potentially dangerous characters in paths (command injection)\n   105→    var dangerousChars = /[`$();|&<>]/;\n   106→    if (dangerousChars.test(path)) {\n   107→        return { valid: false, path: null, error: 'Invalid path: dangerous characters detected' };\n   108→    }\n   109→\n   110→    // Check for protocol handlers that could be exploited\n   111→    var protocolPattern = /^[a-zA-Z][a-zA-Z0-9+.-]*:/;\n   112→    if (protocolPattern.test(path) && !path.match(/^[A-Z]:\\//i)) {\n   113→        // Allow Windows drive letters (C:/) but block other protocols (javascript:, data:, etc.)\n   114→        return { valid: false, path: null, error: 'Invalid path: protocol handlers not allowed' };\n   115→    }\n   116→\n   117→    return { valid: true, path: path, error: null };\n   118→}\n   119→\n   120→/**\n   121→ * Validate sequence name to prevent XSS and injection\n   122→ * @param {string} name - Sequence name to validate\n   123→ * @returns {Object} { valid: boolean, name: string, error: string }\n   124→ */\n   125→function validateSequenceName(name) {\n   126→    if (!name || typeof name !== 'string') {\n   127→        return { valid: false, name: null, error: 'Invalid name: must be a non-empty string' };\n   128→    }\n   129→\n   130→    // Check for null bytes\n   131→    if (name.indexOf('\\0') !== -1) {\n   132→        return { valid: false, name: null, error: 'Invalid name: null bytes detected' };\n   133→    }\n   134→\n   135→    // Check for potentially dangerous characters (file system reserved on Windows)\n   136→    var invalidChars = /[<>:\"|?*]/;\n   137→    if (invalidChars.test(name)) {\n   138→        return { valid: false, name: null, error: 'Invalid name: contains reserved characters' };\n   139→    }\n   140→\n   141→    // Limit length to prevent buffer overflows\n   142→    if (name.length > 255) {\n   143→        return { valid: false, name: null, error: 'Invalid name: exceeds maximum length (255)' };\n   144→    }\n   145→\n   146→    return { valid: true, name: name, error: null };\n   147→}\n   148→\n   149→/**\n   150→ * Validate numeric parameters to prevent injection and DoS\n   151→ * @param {*} value - Value to validate\n   152→ * @param {number} min - Minimum allowed value\n   153→ * @param {number} max - Maximum allowed value\n   154→ * @param {string} paramName - Parameter name for error messages\n   155→ * @returns {Object} { valid: boolean, value: number, error: string }\n   156→ */\n   157→function validateNumericParam(value, min, max, paramName) {\n   158→    if (value === undefined || value === null) {\n   159→        return { valid: false, value: null, error: paramName + ' is required' };\n   160→    }\n   161→\n   162→    var num = parseFloat(value);\n   163→    if (isNaN(num)) {\n   164→        return { valid: false, value: null, error: paramName + ' must be a number' };\n   165→    }\n   166→\n   167→    if (num < min || num > max) {\n   168→        return { valid: false, value: null, error: paramName + ' must be between ' + min + ' and ' + max };\n   169→    }\n   170→\n   171→    return { valid: true, value: num, error: null };\n   172→}\n   173→\n   174→/**\n   175→ * Sanitize string for safe use in Premiere Pro operations\n   176→ * @param {string} str - String to sanitize\n   177→ * @returns {string} Sanitized string\n   178→ */\n   179→function sanitizeString(str) {\n   180→    if (!str || typeof str !== 'string') {\n   181→        return '';\n   182→    }\n   183→\n   184→    // Remove null bytes\n   185→    str = str.replace(/\\0/g, '');\n   186→\n   187→    // Escape special characters that could be problematic in ExtendScript\n   188→    str = str.replace(/[\\r\\n]/g, ' ');\n   189→\n   190→    return str;\n   191→}\n   192→\n   193→/**\n   194→ * Validate array of time values (for markers, cuts, etc.)\n   195→ * @param {Array} times - Array of time values\n   196→ * @param {number} maxLength - Maximum array length (DoS prevention)\n   197→ * @returns {Object} { valid: boolean, times: Array, error: string }\n   198→ */\n   199→function validateTimeArray(times, maxLength) {\n   200→    if (!times || !Array.isArray(times)) {\n   201→        return { valid: false, times: null, error: 'Times must be an array' };\n   202→    }\n   203→\n   204→    maxLength = maxLength || 10000; // Default limit\n   205→    if (times.length > maxLength) {\n   206→        return { valid: false, times: null, error: 'Too many time values (max: ' + maxLength + ')' };\n   207→    }\n   208→\n   209→    for (var i = 0; i < times.length; i++) {\n   210→        var validation = validateNumericParam(times[i], 0, Number.MAX_VALUE, 'time[' + i + ']');\n   211→        if (!validation.valid) {\n   212→            return { valid: false, times: null, error: validation.error };\n   213→        }\n   214→    }\n   215→\n   216→    return { valid: true, times: times, error: null };\n   217→}\n   218→\n   219→// ============================================================================\n   220→// INITIALIZATION\n   221→// ============================================================================\n   222→\n   223→/**\n   224→ * Check if QE (Quality Engine) DOM is available\n   225→ * QE provides extended functionality not available in standard DOM\n   226→ */\n   227→function isQEAvailable() {\n   228→    try {\n   229→        return typeof qe !== 'undefined' && qe !== null && qe.project;\n   230→    } catch (e) {\n   231→        return false;\n   232→    }\n   233→}\n   234→\n   235→/**\n   236→ * Enable QE DOM if not already enabled\n   237→ * @returns {boolean} true if QE is now available\n   238→ */\n   239→function enableQE() {\n   240→    try {\n   241→        if (isQEAvailable()) return true;\n   242→        app.enableQE();\n   243→        return isQEAvailable();\n   244→    } catch (e) {\n   245→        $.writeln('[SPLICE] enableQE failed: ' + e.message);\n   246→        return false;\n   247→    }\n   248→}\n   249→\n   250→/**\n   251→ * Safe wrapper for QE operations\n   252→ * @param {Function} operation - The QE operation to execute\n   253→ * @param {string} operationName - Name for error reporting\n   254→ * @returns {Object} Result or error object\n   255→ */\n   256→function safeQEOperation(operation, operationName) {\n   257→    try {\n   258→        if (!isQEAvailable()) {\n   259→            if (!enableQE()) {\n   260→                return { error: \"QE not available. Please ensure Premiere Pro supports QE DOM.\" };\n   261→            }\n   262→        }\n   263→        return operation();\n   264→    } catch (e) {\n   265→        return { error: operationName + \" failed: \" + e.message };\n   266→    }\n   267→}\n   268→\n   269→function initialise() {\n   270→    try {\n   271→        storeDefaultTimecode();\n   272→        // Try to enable QE on startup\n   273→        var qeStatus = enableQE();\n   274→        return JSON.stringify({ success: true, version: SPLICE_VERSION, qeAvailable: qeStatus });\n   275→    } catch (e) {\n   276→        $.writeln('[SPLICE] initialise error: ' + e.message);\n   277→        return JSON.stringify({ success: false, error: e.message, version: SPLICE_VERSION });\n   278→    }\n   279→}\n   280→\n   281→function storeDefaultTimecode() {\n   282→    try {\n   283→        if (app && app.project && app.project.activeSequence) {\n   284→            sequence_default_timecode = app.project.activeSequence.getSettings().videoDisplayFormat;\n   285→        }\n   286→    } catch (e) {\n   287→        $.writeln('[SPLICE] storeDefaultTimecode failed: ' + e.message);\n   288→    }\n   289→}\n   290→\n   291→/**\n   292→ * Check if a sequence is currently open/active in the Timeline\n   293→ * Uses multiple fallbacks to ensure accurate detection\n   294→ * @returns {boolean} true if a sequence is open\n   295→ */\n   296→function checkSequenceOpen() {\n   297→    try {\n   298→        $.writeln('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC START ==========');\n   299→        \n   300→        // Check if app exists\n   301→        if (!app) {\n   302→            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app object does not exist');\n   303→            return false;\n   304→        }\n   305→        $.writeln('[SPLICE] checkSequenceOpen: app object exists');\n   306→        \n   307→        // Check if project exists\n   308→        if (!app.project) {\n   309→            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app.project does not exist');\n   310→            return false;\n   311→        }\n   312→        $.writeln('[SPLICE] checkSequenceOpen: app.project exists');\n   313→        \n   314→        // Check if sequences collection exists\n   315→        if (!app.project.sequences) {\n   316→            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app.project.sequences does not exist');\n   317→            return false;\n   318→        }\n   319→        $.writeln('[SPLICE] checkSequenceOpen: app.project.sequences exists');\n   320→        \n   321→        // Log total number of sequences\n   322→        var numSequences = app.project.sequences.numSequences;\n   323→        $.writeln('[SPLICE] checkSequenceOpen: Total sequences in project: ' + numSequences);\n   324→        \n   325→        // List all sequences with their details\n   326→        for (var i = 0; i < numSequences; i++) {\n   327→            var seq = app.project.sequences[i];\n   328→            if (seq) {\n   329→                $.writeln('[SPLICE] checkSequenceOpen:   - Sequence ' + i + ': name=\"' + seq.name + '\", id=' + seq.sequenceID);\n   330→            }\n   331→        }\n   332→        \n   333→        // Primary check: Standard DOM - Check for activeSequence\n   334→        $.writeln('[SPLICE] checkSequenceOpen: Checking app.project.activeSequence...');\n   335→        if (app.project.activeSequence) {\n   336→            var activeSeq = app.project.activeSequence;\n   337→            $.writeln('[SPLICE] checkSequenceOpen: SUCCESS - Found active sequence via DOM');\n   338→            $.writeln('[SPLICE] checkSequenceOpen:   - name: ' + activeSeq.name);\n   339→            $.writeln('[SPLICE] checkSequenceOpen:   - sequenceID: ' + activeSeq.sequenceID);\n   340→            $.writeln('[SPLICE] checkSequenceOpen:   - videoTracks: ' + activeSeq.videoTracks.numTracks);\n   341→            $.writeln('[SPLICE] checkSequenceOpen:   - audioTracks: ' + activeSeq.audioTracks.numTracks);\n   342→            $.writeln('[SPLICE] checkSequenceOpen:   - frameSize: ' + activeSeq.frameSizeHorizontal + 'x' + activeSeq.frameSizeVertical);\n   343→            $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n   344→            return true;\n   345→        }\n   346→        $.writeln('[SPLICE] checkSequenceOpen: app.project.activeSequence is null/undefined');\n   347→\n   348→        // Fallback: Try QE DOM (requires enableQE first)\n   349→        $.writeln('[SPLICE] checkSequenceOpen: Trying QE DOM fallback...');\n   350→        if (enableQE()) {\n   351→            try {\n   352→                $.writeln('[SPLICE] checkSequenceOpen: QE DOM is enabled');\n   353→                var qeSeq = qe.project.getActiveSequence();\n   354→                if (qeSeq && qeSeq.name) {\n   355→                    $.writeln('[SPLICE] checkSequenceOpen: SUCCESS - Found active sequence via QE DOM: ' + qeSeq.name);\n   356→                    $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n   357→                    return true;\n   358→                }\n   359→                $.writeln('[SPLICE] checkSequenceOpen: QE DOM returned null or sequence without name');\n   360→            } catch (qeErr) {\n   361→                $.writeln('[SPLICE] checkSequenceOpen: QE sequence check failed: ' + qeErr.message);\n   362→            }\n   363→        } else {\n   364→            $.writeln('[SPLICE] checkSequenceOpen: QE DOM is NOT available/enabled');\n   365→        }\n   366→\n   367→        $.writeln('[SPLICE] checkSequenceOpen: No active sequence found in either DOM or QE DOM');\n   368→        $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (FALSE) ==========');\n   369→        return false;\n   370→    } catch (e) {\n   371→        $.writeln('[SPLICE] checkSequenceOpen: EXCEPTION - ' + e.message);\n   372→        $.writeln('[SPLICE] checkSequenceOpen: Stack: ' + (e.stack || 'no stack available'));\n   373→        $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (ERROR) ==========');\n   374→        return false;\n   375→    }\n   376→}\n   377→\n   378→function getVersion() {\n   379→    return SPLICE_VERSION;\n   380→}\n   381→\n   382→// ============================================================================\n   383→// TIME CONVERSION UTILITIES\n   384→// ============================================================================\n   385→\n   386→/**\n   387→ * Get the actual frames per second from the sequence\n   388→ * videoFrameRate.seconds gives seconds per frame, so we need to invert it\n   389→ */\n   390→function getActualFrameRate() {\n   391→    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n   392→    // secsPerFrame is e.g., 0.03333... for 30fps, so 1/secsPerFrame = 30\n   393→    return 1 / secsPerFrame;\n   394→}\n   395→\n   396→function quantise_time(time_seconds) {\n   397→    // Get seconds per frame (e.g., 0.0333 for 30fps)\n   398→    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n   399→    // Round to nearest frame boundary\n   400→    return secsPerFrame * Math.round(time_seconds / secsPerFrame);\n   401→}\n   402→\n   403→function frames_to_time(number_of_frames) {\n   404→    // seconds per frame * number of frames = total seconds\n   405→    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n   406→    return number_of_frames * secsPerFrame;\n   407→}\n   408→\n   409→function frames_to_ticks(number_of_frames) {\n   410→    // Convert frames to ticks: frames * seconds_per_frame * ticks_per_second\n   411→    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n   412→    return number_of_frames * secsPerFrame * TICKS_PER_SECOND;\n   413→}\n   414→\n   415→function seconds_to_ticks(seconds) {\n   416→    return seconds * TICKS_PER_SECOND;\n   417→}\n   418→\n   419→function ticks_to_seconds(ticks) {\n   420→    return ticks / TICKS_PER_SECOND;\n   421→}\n   422→\n   423→function getVideoFrameRateInSeconds() {\n   424→    try {\n   425→        var seq = app.project.activeSequence;\n   426→        if (!seq) {\n   427→            $.writeln('[SPLICE] getVideoFrameRateInSeconds: No active sequence');\n   428→            return null;\n   429→        }\n   430→        return seq.getSettings().videoFrameRate.seconds;\n   431→    } catch (e) {\n   432→        $.writeln('[SPLICE] getVideoFrameRateInSeconds error: ' + e.message);\n   433→        return null;\n   434→    }\n   435→}\n   436→\n   437→function secondsToCurrentTimecode(seconds) {\n   438→    var seq = app.project.activeSequence;\n   439→    if (seq) {\n   440→        var t = new Time();\n   441→        t.seconds = parseFloat(seconds);\n   442→        var settings = app.project.activeSequence.getSettings();\n   443→        return t.getFormatted(settings.videoFrameRate, settings.videoDisplayFormat);\n   444→    }\n   445→    return false;\n   446→}\n   447→\n   448→// ============================================================================\n   449→// TIMECODE FORMAT\n   450→// ============================================================================\n   451→\n   452→function setTimecodeToFrames() {\n   453→    var seq = app.project.activeSequence;\n   454→    if (seq) {\n   455→        var currentSeqSettings = app.project.activeSequence.getSettings();\n   456→        if (currentSeqSettings.videoDisplayFormat != TIMECODES.TIMEDISPLAY_Frames) {\n   457→            currentSeqSettings.videoDisplayFormat = TIMECODES.TIMEDISPLAY_Frames;\n   458→            app.project.activeSequence.setSettings(currentSeqSettings);\n   459→        }\n   460→    }\n   461→}\n   462→\n   463→function setTimecodeToDefault() {\n   464→    var seq = app.project.activeSequence;\n   465→    if (seq && sequence_default_timecode) {\n   466→        var currentSeqSettings = app.project.activeSequence.getSettings();\n   467→        currentSeqSettings.videoDisplayFormat = sequence_default_timecode;\n   468→        app.project.activeSequence.setSettings(currentSeqSettings);\n   469→    }\n   470→}\n   471→\n   472→function getTimecodeFormat() {\n   473→    return app.project.activeSequence.getSettings().videoDisplayFormat;\n   474→}\n   475→\n   476→function setTimecodeFormat(format) {\n   477→    format = parseInt(format);\n   478→    var seq = app.project.activeSequence;\n   479→    if (seq) {\n   480→        var currentSeqSettings = app.project.activeSequence.getSettings();\n   481→        currentSeqSettings.videoDisplayFormat = format;\n   482→        app.project.activeSequence.setSettings(currentSeqSettings);\n   483→    }\n   484→    return true;\n   485→}\n   486→\n   487→// ============================================================================\n   488→// SEQUENCE & PROJECT OPERATIONS\n   489→// ============================================================================\n   490→\n   491→function getActiveSequence() {\n   492→    var seq = app.project.activeSequence;\n   493→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   494→\n   495→    return JSON.stringify({\n   496→        name: seq.name,\n   497→        id: seq.sequenceID,\n   498→        duration: seq.end,\n   499→        videoTrackCount: seq.videoTracks.numTracks,\n   500→        audioTrackCount: seq.audioTracks.numTracks,\n   501→        frameRate: seq.getSettings().videoFrameRate.seconds,\n   502→        width: seq.frameSizeHorizontal,\n   503→        height: seq.frameSizeVertical\n   504→    });\n   505→}\n   506→\n   507→function getSequenceSettings() {\n   508→    var seq = app.project.activeSequence;\n   509→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   510→\n   511→    var settings = seq.getSettings();\n   512→    return JSON.stringify({\n   513→        frameRate: settings.videoFrameRate.seconds,\n   514→        width: settings.videoFrameWidth,\n   515→        height: settings.videoFrameHeight,\n   516→        displayFormat: settings.videoDisplayFormat\n   517→    });\n   518→}\n   519→\n   520→function cloneSequence(newName) {\n   521→    var seq = app.project.activeSequence;\n   522→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   523→\n   524→    try {\n   525→        // Clone the sequence\n   526→        seq.clone();\n   527→\n   528→        // Find the cloned sequence (last one with matching name pattern)\n   529→        var clonedSeq = null;\n   530→        for (var i = app.project.sequences.numSequences - 1; i >= 0; i--) {\n   531→            var s = app.project.sequences[i];\n   532→            if (s.name.indexOf(seq.name) === 0 && s.sequenceID !== seq.sequenceID) {\n   533→                clonedSeq = s;\n   534→                break;\n   535→            }\n   536→        }\n   537→\n   538→        if (clonedSeq && newName) {\n   539→            clonedSeq.name = newName;\n   540→        }\n   541→\n   542→        return JSON.stringify({\n   543→            success: true,\n   544→            sequenceId: clonedSeq ? clonedSeq.sequenceID : null,\n   545→            name: clonedSeq ? clonedSeq.name : newName\n   546→        });\n   547→    } catch (e) {\n   548→        return JSON.stringify({ error: e.message });\n   549→    }\n   550→}\n   551→\n   552→function createNewSequence(name) {\n   553→    try {\n   554→        app.project.createNewSequence(name);\n   555→        var seq = app.project.activeSequence;\n   556→        return JSON.stringify({\n   557→            success: true,\n   558→            sequenceId: seq.sequenceID,\n   559→            name: seq.name\n   560→        });\n   561→    } catch (e) {\n   562→        return JSON.stringify({ error: e.message });\n   563→    }\n   564→}\n   565→\n   566→function setActiveSequence(sequenceId) {\n   567→    for (var i = 0; i < app.project.sequences.numSequences; i++) {\n   568→        if (app.project.sequences[i].sequenceID === sequenceId) {\n   569→            app.project.activeSequence = app.project.sequences[i];\n   570→            return JSON.stringify({ success: true });\n   571→        }\n   572→    }\n   573→    return JSON.stringify({ error: \"Sequence not found\" });\n   574→}\n   575→\n   576→/**\n   577→ * Seek playhead to a specific time in seconds\n   578→ */\n   579→function seekToTime(seconds) {\n   580→    var seq = app.project.activeSequence;\n   581→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   582→\n   583→    try {\n   584→        // Convert seconds to ticks\n   585→        var ticks = seconds * TICKS_PER_SECOND;\n   586→\n   587→        // Create a Time object and set position\n   588→        var playerPos = seq.getPlayerPosition();\n   589→        playerPos.seconds = seconds;\n   590→        seq.setPlayerPosition(playerPos.ticks.toString());\n   591→\n   592→        return JSON.stringify({ success: true, position: seconds });\n   593→    } catch (e) {\n   594→        return JSON.stringify({ error: e.message });\n   595→    }\n   596→}\n   597→\n   598→/**\n   599→ * Get current playhead position in seconds\n   600→ */\n   601→function getPlayerPosition() {\n   602→    var seq = app.project.activeSequence;\n   603→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   604→\n   605→    try {\n   606→        var pos = seq.getPlayerPosition();\n   607→        return JSON.stringify({\n   608→            ticks: pos.ticks,\n   609→            seconds: pos.seconds\n   610→        });\n   611→    } catch (e) {\n   612→        return JSON.stringify({ error: e.message });\n   613→    }\n   614→}\n   615→\n   616→// ============================================================================\n   617→// RAZOR OPERATIONS\n   618→// ============================================================================\n   619→\n   620→function razorSequenceAtFrames(frames) {\n   621→    if (!isQEAvailable() && !enableQE()) {\n   622→        return JSON.stringify({ error: \"QE not available for razor operation\" });\n   623→    }\n   624→    try {\n   625→        frames = String(frames);\n   626→        setTimecodeToFrames();\n   627→        qe.project.getActiveSequence().razor(frames);\n   628→        return JSON.stringify({ success: true });\n   629→    } catch (e) {\n   630→        return JSON.stringify({ error: \"Razor failed: \" + e.message });\n   631→    }\n   632→}\n   633→\n   634→function razorSequenceAtSeconds(seconds) {\n   635→    try {\n   636→        var frames = parseInt(Math.round(seconds / app.project.activeSequence.getSettings().videoFrameRate.seconds)).toString();\n   637→        return razorSequenceAtFrames(frames);\n   638→    } catch (e) {\n   639→        return JSON.stringify({ error: \"Razor at seconds failed: \" + e.message });\n   640→    }\n   641→}\n   642→\n   643→function razorSequenceAtFramesArray(silences_array) {\n   644→    if (!isQEAvailable() && !enableQE()) {\n   645→        return JSON.stringify({ error: \"QE not available for razor operation\" });\n   646→    }\n   647→    try {\n   648→        setTimecodeToFrames();\n   649→        silences_array = JSON.parse(silences_array);\n   650→        var razorCount = 0;\n   651→        for (var i = 0; i < silences_array.length; i++) {\n   652→            for (var j = 0; j < silences_array[i].length; j++) {\n   653→                var frames = String(silences_array[i][j]);\n   654→                qe.project.getActiveSequence().razor(frames);\n   655→                razorCount++;\n   656→            }\n   657→        }\n   658→        return JSON.stringify({ success: true, razorCount: razorCount });\n   659→    } catch (e) {\n   660→        return JSON.stringify({ error: \"Razor array failed: \" + e.message });\n   661→    }\n   662→}\n   663→\n   664→function razorTrackAtFrames(trackType, trackIndex, frames) {\n   665→    if (!isQEAvailable() && !enableQE()) {\n   666→        return JSON.stringify({ error: \"QE not available for track razor\" });\n   667→    }\n   668→    try {\n   669→        frames = String(frames);\n   670→        setTimecodeToFrames();\n   671→        if (trackType == \"video\") {\n   672→            qe.project.getActiveSequence().getVideoTrackAt(trackIndex).razor(frames);\n   673→        } else if (trackType == \"audio\") {\n   674→            qe.project.getActiveSequence().getAudioTrackAt(trackIndex).razor(frames);\n   675→        }\n   676→        return JSON.stringify({ success: true });\n   677→    } catch (e) {\n   678→        return JSON.stringify({ error: \"Track razor failed: \" + e.message });\n   679→    }\n   680→}\n   681→\n   682→function razorTrackAtSeconds(trackType, trackIndex, seconds) {\n   683→    try {\n   684→        var frames = parseInt(Math.round(seconds / app.project.activeSequence.getSettings().videoFrameRate.seconds)).toString();\n   685→        return razorTrackAtFrames(trackType, trackIndex, frames);\n   686→    } catch (e) {\n   687→        return JSON.stringify({ error: \"Track razor at seconds failed: \" + e.message });\n   688→    }\n   689→}\n   690→\n   691→// ============================================================================\n   692→// CLIP OPERATIONS\n   693→// ============================================================================\n   694→\n   695→/**\n   696→ * Get currently selected clips in the timeline\n   697→ * @returns {string} JSON with selected clip data or error\n   698→ */\n   699→function getSelectedClips() {\n   700→    try {\n   701→        var seq = app.project.activeSequence;\n   702→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   703→\n   704→        var selection = seq.getSelection();\n   705→        var clips = [];\n   706→\n   707→        for (var i = 0; i < selection.length; i++) {\n   708→            var clip = selection[i];\n   709→            clips.push({\n   710→                index: i,\n   711→                name: clip.name,\n   712→                start: clip.start.seconds,\n   713→                end: clip.end.seconds,\n   714→                duration: clip.duration.seconds,\n   715→                inPoint: clip.inPoint ? clip.inPoint.seconds : null,\n   716→                outPoint: clip.outPoint ? clip.outPoint.seconds : null,\n   717→                mediaPath: clip.projectItem ? clip.projectItem.getMediaPath() : null\n   718→            });\n   719→        }\n   720→\n   721→        $.writeln('[SPLICE] getSelectedClips: Found ' + clips.length + ' selected clips');\n   722→        return JSON.stringify({\n   723→            count: clips.length,\n   724→            clips: clips\n   725→        });\n   726→    } catch (e) {\n   727→        $.writeln('[SPLICE] getSelectedClips error: ' + e.message);\n   728→        return JSON.stringify({ error: \"getSelectedClips failed: \" + e.message });\n   729→    }\n   730→}\n   731→\n   732→function getClipsInTrack(trackIndex, trackType) {\n   733→    try {\n   734→        var seq = app.project.activeSequence;\n   735→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   736→\n   737→        var tracks = trackType === \"audio\" ? seq.audioTracks : seq.videoTracks;\n   738→        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n   739→            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex + \" (max: \" + (tracks.numTracks - 1) + \")\" });\n   740→        }\n   741→\n   742→        var clips = [];\n   743→        var trackClips = tracks[trackIndex].clips;\n   744→        for (var i = 0; i < trackClips.numItems; i++) {\n   745→            var clip = trackClips[i];\n   746→            clips.push({\n   747→                index: i,\n   748→                name: clip.name,\n   749→                start: clip.start.seconds,\n   750→                end: clip.end.seconds,\n   751→                duration: clip.duration.seconds,\n   752→                inPoint: clip.inPoint.seconds,\n   753→                outPoint: clip.outPoint.seconds,\n   754→                mediaPath: clip.projectItem ? clip.projectItem.getMediaPath() : null\n   755→            });\n   756→        }\n   757→        return JSON.stringify(clips);\n   758→    } catch (e) {\n   759→        $.writeln('[SPLICE] getClipsInTrack error: ' + e.message);\n   760→        return JSON.stringify({ error: \"getClipsInTrack failed: \" + e.message });\n   761→    }\n   762→}\n   763→\n   764→function getClipsInTrack_Timings_Seconds(trackIndex, trackType) {\n   765→    try {\n   766→        var seq = app.project.activeSequence;\n   767→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   768→\n   769→        var tracks = trackType === \"audio\" ? seq.audioTracks : seq.videoTracks;\n   770→        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n   771→            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex });\n   772→        }\n   773→\n   774→        var clips = [];\n   775→        var trackClips = tracks[trackIndex].clips;\n   776→        for (var i = 0; i < trackClips.numItems; i++) {\n   777→            clips.push([\n   778→                trackClips[i].start.seconds,\n   779→                trackClips[i].end.seconds\n   780→            ]);\n   781→        }\n   782→        return JSON.stringify(clips);\n   783→    } catch (e) {\n   784→        $.writeln('[SPLICE] getClipsInTrack_Timings_Seconds error: ' + e.message);\n   785→        return JSON.stringify({ error: \"getClipsInTrack_Timings_Seconds failed: \" + e.message });\n   786→    }\n   787→}\n   788→\n   789→function deleteClipsAtSilencePointsInTrack(silences, trackType, trackIndex) {\n   790→    try {\n   791→        var seq = app.project.activeSequence;\n   792→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n   793→\n   794→        // Validate trackType\n   795→        if (trackType !== \"video\" && trackType !== \"audio\") {\n   796→            return JSON.stringify({ error: \"Invalid track type: \" + trackType });\n   797→        }\n   798→\n   799→        // Parse silences JSON\n   800→        var silencesArr;\n   801→        try {\n   802→            silencesArr = JSON.parse(silences);\n   803→        } catch (parseErr) {\n   804→            return JSON.stringify({ error: \"Invalid silences JSON: \" + parseErr.message });\n   805→        }\n   806→\n   807→        // Get tracks and validate index\n   808→        var tracks = trackType === \"video\" ? seq.videoTracks : seq.audioTracks;\n   809→        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n   810→            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex + \" (max: \" + (tracks.numTracks - 1) + \")\" });\n   811→        }\n   812→\n   813→        var clips = tracks[trackIndex].clips;\n   814→        var deleted = 0;\n   815→\n   816→        // Iterate backwards to avoid index shifting (use numItems, not length)\n   817→        for (var i = clips.numItems - 1; i >= 0; i--) {\n   818→            var clip = clips[i];\n   819→            var start = clip.start.seconds;\n   820→            var end = clip.end.seconds;\n   821→            var center = (start + end) / 2;\n   822→\n   823→            for (var j = 0; j < silencesArr.length; j++) {\n   824→                var silence = silencesArr[j];\n   825→                var silenceCenter = (silence[0] + silence[1]) / 2;\n   826→                if (silenceCenter > start && silenceCenter < end) {\n   827→                    clip.remove(false, false);\n   828→                    deleted++;\n   829→                    break;\n   830→                }\n   831→            }\n   832→        }\n   833→\n   834→        $.writeln('[SPLICE] deleteClipsAtSilencePointsInTrack: Deleted ' + deleted + ' clips from ' + trackType + ' track ' + trackIndex);\n   835→        return JSON.stringify({ deleted: deleted });\n   836→    } catch (e) {\n   837→        $.writeln('[SPLICE] deleteClipsAtSilencePointsInTrack error: ' + e.message);\n   838→        return JSON.stringify({ error: \"deleteClipsAtSilencePointsInTrack failed: \" + e.message });\n   839→    }\n   840→}\n   841→\n   842→function makeRemainingClipsContiguousInTrack(silences, deltas, trackType, trackIndex) {\n   843→    silences = JSON.parse(silences);\n   844→    deltas = JSON.parse(deltas);\n   845→\n   846→    var clips;\n   847→    if (trackType == \"video\") {\n   848→        clips = app.project.activeSequence.videoTracks[trackIndex].clips;\n   849→    } else if (trackType == \"audio\") {\n   850→        clips = app.project.activeSequence.audioTracks[trackIndex].clips;\n   851→    }\n   852→\n   853→    for (var i = 0; i < clips.length; i++) {\n   854→        var clip = clips[i];\n   855→        var end = clip.end.seconds;\n   856→        var num_silences = -1;\n   857→\n   858→        for (var j = 0; j < silences.length; j++) {\n   859→            if (end > silences[j][1]) {\n   860→                num_silences++;\n   861→            }\n   862→        }\n   863→\n   864→        if (num_silences > -1 && num_silences < deltas.length) {\n   865→            var delta = deltas[num_silences];\n   866→            var t_start = clip.start;\n   867→            t_start.seconds = t_start.seconds - delta;\n   868→            clip.start = t_start;\n   869→            var t_end = clip.end;\n   870→            t_end.seconds = t_end.seconds - delta;\n   871→            clip.end = t_end;\n   872→        }\n   873→    }\n   874→    return JSON.stringify({ success: true });\n   875→}\n   876→\n   877→function removeClipByIndex(trackType, trackIndex, clipIndex) {\n   878→    try {\n   879→        if (trackType == \"video\") {\n   880→            app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex].remove(false, false);\n   881→        } else if (trackType == \"audio\") {\n   882→            app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex].remove(false, false);\n   883→        }\n   884→        return JSON.stringify({ success: true });\n   885→    } catch (e) {\n   886→        return JSON.stringify({ error: e.message });\n   887→    }\n   888→}\n   889→\n   890→function setClipInOutPoints(trackType, trackIndex, clipIndex, inPoint, outPoint) {\n   891→    try {\n   892→        var clip;\n   893→        if (trackType == \"video\") {\n   894→            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n   895→        } else if (trackType == \"audio\") {\n   896→            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n   897→        }\n   898→\n   899→        if (inPoint !== null) {\n   900→            var inTime = new Time();\n   901→            inTime.seconds = inPoint;\n   902→            clip.inPoint = inTime;\n   903→        }\n   904→        if (outPoint !== null) {\n   905→            var outTime = new Time();\n   906→            outTime.seconds = outPoint;\n   907→            clip.outPoint = outTime;\n   908→        }\n   909→        return JSON.stringify({ success: true });\n   910→    } catch (e) {\n   911→        return JSON.stringify({ error: e.message });\n   912→    }\n   913→}\n   914→\n   915→function setClipStartEnd(trackType, trackIndex, clipIndex, startSeconds, endSeconds) {\n   916→    try {\n   917→        var clip;\n   918→        if (trackType == \"video\") {\n   919→            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n   920→        } else if (trackType == \"audio\") {\n   921→            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n   922→        }\n   923→\n   924→        if (startSeconds !== null) {\n   925→            var startTime = clip.start;\n   926→            startTime.seconds = startSeconds;\n   927→            clip.start = startTime;\n   928→        }\n   929→        if (endSeconds !== null) {\n   930→            var endTime = clip.end;\n   931→            endTime.seconds = endSeconds;\n   932→            clip.end = endTime;\n   933→        }\n   934→        return JSON.stringify({ success: true });\n   935→    } catch (e) {\n   936→        return JSON.stringify({ error: e.message });\n   937→    }\n   938→}\n   939→\n   940→// ============================================================================\n   941→// TRACK OPERATIONS\n   942→// ============================================================================\n   943→\n   944→function getTrackNames(trackType) {\n   945→    if (!isQEAvailable() && !enableQE()) {\n   946→        // Fallback: use standard DOM\n   947→        var ret = [];\n   948→        try {\n   949→            if (trackType == \"video\") {\n   950→                for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n   951→                    ret.push(\"V\" + (i + 1));\n   952→                }\n   953→            } else if (trackType == \"audio\") {\n   954→                for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n   955→                    ret.push(\"A\" + (i + 1));\n   956→                }\n   957→            }\n   958→        } catch (e) {\n   959→            return JSON.stringify({ error: \"Failed to get track names: \" + e.message });\n   960→        }\n   961→        return JSON.stringify(ret);\n   962→    }\n   963→\n   964→    try {\n   965→        var ret = [];\n   966→        if (trackType == \"video\") {\n   967→            for (var i = 0; i < qe.project.getActiveSequence().numVideoTracks; i++) {\n   968→                ret.push(qe.project.getActiveSequence().getVideoTrackAt(i).name);\n   969→            }\n   970→        } else if (trackType == \"audio\") {\n   971→            for (var i = 0; i < qe.project.getActiveSequence().numAudioTracks; i++) {\n   972→                ret.push(qe.project.getActiveSequence().getAudioTrackAt(i).name);\n   973→            }\n   974→        }\n   975→        return JSON.stringify(ret);\n   976→    } catch (e) {\n   977→        return JSON.stringify({ error: \"Failed to get track names: \" + e.message });\n   978→    }\n   979→}\n   980→\n   981→function getNumTracks(trackType) {\n   982→    try {\n   983→        if (trackType == \"video\") {\n   984→            return app.project.activeSequence.videoTracks.numTracks;\n   985→        } else if (trackType == \"audio\") {\n   986→            return app.project.activeSequence.audioTracks.numTracks;\n   987→        }\n   988→        return 0;\n   989→    } catch (e) {\n   990→        return JSON.stringify({ error: \"Failed to get track count: \" + e.message });\n   991→    }\n   992→}\n   993→\n   994→function addVideoTrack() {\n   995→    if (!isQEAvailable() && !enableQE()) {\n   996→        return JSON.stringify({ error: \"QE not available for adding tracks\" });\n   997→    }\n   998→    try {\n   999→        var trackId = qe.project.getActiveSequence().numVideoTracks;\n  1000→        qe.project.getActiveSequence().addTracks(1, trackId, 0, 0);\n  1001→        return JSON.stringify({ success: true, trackId: trackId });\n  1002→    } catch (e) {\n  1003→        return JSON.stringify({ error: \"Failed to add video track: \" + e.message });\n  1004→    }\n  1005→}\n  1006→\n  1007→function addAudioTrack() {\n  1008→    if (!isQEAvailable() && !enableQE()) {\n  1009→        return JSON.stringify({ error: \"QE not available for adding tracks\" });\n  1010→    }\n  1011→    try {\n  1012→        var trackId = qe.project.getActiveSequence().numAudioTracks;\n  1013→        qe.project.getActiveSequence().addTracks(0, 0, 1, 1, trackId);\n  1014→        return JSON.stringify({ success: true, trackId: trackId });\n  1015→    } catch (e) {\n  1016→        return JSON.stringify({ error: \"Failed to add audio track: \" + e.message });\n  1017→    }\n  1018→}\n  1019→\n  1020→function removeVideoTrack(trackIndex) {\n  1021→    if (!isQEAvailable() && !enableQE()) {\n  1022→        return JSON.stringify({ error: \"QE not available for removing tracks\" });\n  1023→    }\n  1024→    try {\n  1025→        qe.project.getActiveSequence().removeVideoTrack(trackIndex);\n  1026→        return JSON.stringify({ success: true });\n  1027→    } catch (e) {\n  1028→        return JSON.stringify({ error: \"Failed to remove video track: \" + e.message });\n  1029→    }\n  1030→}\n  1031→\n  1032→function removeAudioTrack(trackIndex) {\n  1033→    if (!isQEAvailable() && !enableQE()) {\n  1034→        return JSON.stringify({ error: \"QE not available for removing tracks\" });\n  1035→    }\n  1036→    try {\n  1037→        qe.project.getActiveSequence().removeAudioTrack(trackIndex);\n  1038→        return JSON.stringify({ success: true });\n  1039→    } catch (e) {\n  1040→        return JSON.stringify({ error: \"Failed to remove audio track: \" + e.message });\n  1041→    }\n  1042→}\n  1043→\n  1044→// ============================================================================\n  1045→// MUTE STATE\n  1046→// ============================================================================\n  1047→\n  1048→function getMuteState() {\n  1049→    var mute_state_video = [];\n  1050→    for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n  1051→        mute_state_video.push(app.project.activeSequence.videoTracks[i].isMuted());\n  1052→    }\n  1053→    var mute_state_audio = [];\n  1054→    for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n  1055→        mute_state_audio.push(app.project.activeSequence.audioTracks[i].isMuted());\n  1056→    }\n  1057→    return JSON.stringify({ audio: mute_state_audio, video: mute_state_video });\n  1058→}\n  1059→\n  1060→function setMuteState(mute_state) {\n  1061→    mute_state = JSON.parse(mute_state);\n  1062→    for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n  1063→        if (i < mute_state.video.length) {\n  1064→            app.project.activeSequence.videoTracks[i].setMute(mute_state.video[i]);\n  1065→        }\n  1066→    }\n  1067→    for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n  1068→        if (i < mute_state.audio.length) {\n  1069→            app.project.activeSequence.audioTracks[i].setMute(mute_state.audio[i]);\n  1070→        }\n  1071→    }\n  1072→    return true;\n  1073→}\n  1074→\n  1075→// ============================================================================\n  1076→// PROJECT ITEM OPERATIONS\n  1077→// ============================================================================\n  1078→\n  1079→function findItemByName(bin, name) {\n  1080→    for (var i = 0; i < bin.children.numItems; i++) {\n  1081→        if (bin.children[i].name === name) {\n  1082→            return bin.children[i];\n  1083→        }\n  1084→        if (bin.children[i].children !== undefined) {\n  1085→            var item = findItemByName(bin.children[i], name);\n  1086→            if (item) return item;\n  1087→        }\n  1088→    }\n  1089→    return null;\n  1090→}\n  1091→\n  1092→function findItemByPath(bin, path) {\n  1093→    for (var i = 0; i < bin.children.numItems; i++) {\n  1094→        var item = bin.children[i];\n  1095→        if (item.getMediaPath && item.getMediaPath() === path) {\n  1096→            return item;\n  1097→        }\n  1098→        if (item.children !== undefined) {\n  1099→            var found = findItemByPath(item, path);\n  1100→            if (found) return found;\n  1101→        }\n  1102→    }\n  1103→    return null;\n  1104→}\n  1105→\n  1106→function importFile(filePath) {\n  1107→    try {\n  1108→        var success = app.project.importFiles([filePath], true, app.project.rootItem, false);\n  1109→        if (success) {\n  1110→            // Find the imported item\n  1111→            var item = findItemByPath(app.project.rootItem, filePath);\n  1112→            return JSON.stringify({\n  1113→                success: true,\n  1114→                nodeId: item ? item.nodeId : null\n  1115→            });\n  1116→        }\n  1117→        return JSON.stringify({ error: \"Import failed\" });\n  1118→    } catch (e) {\n  1119→        return JSON.stringify({ error: e.message });\n  1120→    }\n  1121→}\n  1122→\n  1123→function getSpliceBin() {\n  1124→    var rootItemChildren = app.project.rootItem.children;\n  1125→    var spliceBin = null;\n  1126→\n  1127→    for (var i = 0; i < rootItemChildren.numItems; i++) {\n  1128→        if (rootItemChildren[i].name === \"SPLICE\" && rootItemChildren[i].type === 2) {\n  1129→            spliceBin = rootItemChildren[i];\n  1130→            break;\n  1131→        }\n  1132→    }\n  1133→\n  1134→    if (!spliceBin) {\n  1135→        app.project.rootItem.createBin(\"SPLICE\");\n  1136→        return getSpliceBin();\n  1137→    }\n  1138→\n  1139→    return spliceBin;\n  1140→}\n  1141→\n  1142→function getAllProjectItems() {\n  1143→    var items = [];\n  1144→\n  1145→    function collectItems(bin, path) {\n  1146→        for (var i = 0; i < bin.children.numItems; i++) {\n  1147→            var item = bin.children[i];\n  1148→            var itemPath = path + \"/\" + item.name;\n  1149→\n  1150→            items.push({\n  1151→                nodeId: item.nodeId,\n  1152→                name: item.name,\n  1153→                type: item.type,\n  1154→                treePath: itemPath,\n  1155→                mediaPath: item.getMediaPath ? item.getMediaPath() : null\n  1156→            });\n  1157→\n  1158→            if (item.children !== undefined && item.type === 2) {\n  1159→                collectItems(item, itemPath);\n  1160→            }\n  1161→        }\n  1162→    }\n  1163→\n  1164→    collectItems(app.project.rootItem, \"\");\n  1165→    return JSON.stringify(items);\n  1166→}\n  1167→\n  1168→// ============================================================================\n  1169→// CLIP INSERTION\n  1170→// ============================================================================\n  1171→\n  1172→function insertClipAtTime(projectItemNodeId, trackIndex, startSeconds, trackType) {\n  1173→    try {\n  1174→        var item = findItemByNodeId(app.project.rootItem, projectItemNodeId);\n  1175→        if (!item) {\n  1176→            return JSON.stringify({ error: \"Project item not found\" });\n  1177→        }\n  1178→\n  1179→        var targetTime = new Time();\n  1180→        targetTime.seconds = startSeconds;\n  1181→\n  1182→        if (trackType === \"video\") {\n  1183→            app.project.activeSequence.videoTracks[trackIndex].insertClip(item, targetTime);\n  1184→        } else if (trackType === \"audio\") {\n  1185→            app.project.activeSequence.audioTracks[trackIndex].insertClip(item, targetTime);\n  1186→        }\n  1187→\n  1188→        return JSON.stringify({ success: true });\n  1189→    } catch (e) {\n  1190→        return JSON.stringify({ error: e.message });\n  1191→    }\n  1192→}\n  1193→\n  1194→function findItemByNodeId(bin, nodeId) {\n  1195→    for (var i = 0; i < bin.children.numItems; i++) {\n  1196→        if (bin.children[i].nodeId === nodeId) {\n  1197→            return bin.children[i];\n  1198→        }\n  1199→        if (bin.children[i].children !== undefined) {\n  1200→            var found = findItemByNodeId(bin.children[i], nodeId);\n  1201→            if (found) return found;\n  1202→        }\n  1203→    }\n  1204→    return null;\n  1205→}\n  1206→\n  1207→// ============================================================================\n  1208→// MARKER OPERATIONS\n  1209→// ============================================================================\n  1210→\n  1211→function createMarker(timeSeconds, name, duration, comments, colorIndex) {\n  1212→    try {\n  1213→        var seq = app.project.activeSequence;\n  1214→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1215→\n  1216→        var markers = seq.markers;\n  1217→        var marker = markers.createMarker(timeSeconds);\n  1218→\n  1219→        if (name) marker.name = name;\n  1220→        if (comments) marker.comments = comments;\n  1221→        if (colorIndex !== undefined) marker.setColorByIndex(colorIndex);\n  1222→        if (duration && duration > 0) {\n  1223→            // Set marker end time properly using a Time object\n  1224→            var endTime = new Time();\n  1225→            endTime.seconds = marker.start.seconds + duration;\n  1226→            marker.end = endTime;\n  1227→        }\n  1228→\n  1229→        return JSON.stringify({\n  1230→            success: true,\n  1231→            guid: marker.guid\n  1232→        });\n  1233→    } catch (e) {\n  1234→        return JSON.stringify({ error: e.message });\n  1235→    }\n  1236→}\n  1237→\n  1238→function getMarkers() {\n  1239→    try {\n  1240→        var seq = app.project.activeSequence;\n  1241→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1242→\n  1243→        var markers = seq.markers;\n  1244→        var result = [];\n  1245→\n  1246→        for (var i = 0; i < markers.numMarkers; i++) {\n  1247→            var marker = markers[i];\n  1248→            result.push({\n  1249→                guid: marker.guid,\n  1250→                name: marker.name,\n  1251→                comments: marker.comments,\n  1252→                start: marker.start.seconds,\n  1253→                end: marker.end.seconds,\n  1254→                type: marker.type\n  1255→            });\n  1256→        }\n  1257→\n  1258→        return JSON.stringify(result);\n  1259→    } catch (e) {\n  1260→        return JSON.stringify({ error: e.message });\n  1261→    }\n  1262→}\n  1263→\n  1264→function deleteMarker(markerGuid) {\n  1265→    try {\n  1266→        var seq = app.project.activeSequence;\n  1267→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1268→\n  1269→        var markers = seq.markers;\n  1270→        for (var i = 0; i < markers.numMarkers; i++) {\n  1271→            if (markers[i].guid === markerGuid) {\n  1272→                markers[i].remove();\n  1273→                return JSON.stringify({ success: true });\n  1274→            }\n  1275→        }\n  1276→        return JSON.stringify({ error: \"Marker not found\" });\n  1277→    } catch (e) {\n  1278→        return JSON.stringify({ error: e.message });\n  1279→    }\n  1280→}\n  1281→\n  1282→function deleteAllMarkers() {\n  1283→    try {\n  1284→        var seq = app.project.activeSequence;\n  1285→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1286→\n  1287→        var markers = seq.markers;\n  1288→        var count = markers.numMarkers;\n  1289→\n  1290→        // Delete from end to beginning to avoid index shifting\n  1291→        for (var i = count - 1; i >= 0; i--) {\n  1292→            markers[i].remove();\n  1293→        }\n  1294→\n  1295→        return JSON.stringify({ success: true, deleted: count });\n  1296→    } catch (e) {\n  1297→        return JSON.stringify({ error: e.message });\n  1298→    }\n  1299→}\n  1300→\n  1301→function deleteMarkersByName(namePattern) {\n  1302→    try {\n  1303→        var seq = app.project.activeSequence;\n  1304→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1305→\n  1306→        var markers = seq.markers;\n  1307→        var deleted = 0;\n  1308→\n  1309→        for (var i = markers.numMarkers - 1; i >= 0; i--) {\n  1310→            if (markers[i].name && markers[i].name.indexOf(namePattern) !== -1) {\n  1311→                markers[i].remove();\n  1312→                deleted++;\n  1313→            }\n  1314→        }\n  1315→\n  1316→        return JSON.stringify({ success: true, deleted: deleted });\n  1317→    } catch (e) {\n  1318→        return JSON.stringify({ error: e.message });\n  1319→    }\n  1320→}\n  1321→\n  1322→// ============================================================================\n  1323→// COLOR LABEL OPERATIONS\n  1324→// ============================================================================\n  1325→\n  1326→function setClipColorLabel(trackType, trackIndex, clipIndex, colorIndex) {\n  1327→    try {\n  1328→        var clip;\n  1329→        if (trackType == \"video\") {\n  1330→            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n  1331→        } else if (trackType == \"audio\") {\n  1332→            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n  1333→        }\n  1334→\n  1335→        if (clip && clip.projectItem) {\n  1336→            clip.projectItem.setColorLabel(colorIndex);\n  1337→        }\n  1338→        return JSON.stringify({ success: true });\n  1339→    } catch (e) {\n  1340→        return JSON.stringify({ error: e.message });\n  1341→    }\n  1342→}\n  1343→\n  1344→function setProjectItemColorLabel(nodeId, colorIndex) {\n  1345→    try {\n  1346→        var item = findItemByNodeId(app.project.rootItem, nodeId);\n  1347→        if (item) {\n  1348→            item.setColorLabel(colorIndex);\n  1349→            return JSON.stringify({ success: true });\n  1350→        }\n  1351→        return JSON.stringify({ error: \"Item not found\" });\n  1352→    } catch (e) {\n  1353→        return JSON.stringify({ error: e.message });\n  1354→    }\n  1355→}\n  1356→\n  1357→// ============================================================================\n  1358→// SEQUENCE BUILDING (CORE v3.5 FUNCTIONALITY)\n  1359→// ============================================================================\n  1360→\n  1361→function buildSequenceFromCutList(cutListJson) {\n  1362→    try {\n  1363→        var cutList = JSON.parse(cutListJson);\n  1364→        var seq = app.project.activeSequence;\n  1365→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1366→\n  1367→        // Clone the sequence\n  1368→        var newSequenceName = seq.name + \"_SPLICE\";\n  1369→        seq.clone();\n  1370→\n  1371→        // Find the cloned sequence\n  1372→        var newSeq = null;\n  1373→        for (var i = app.project.sequences.numSequences - 1; i >= 0; i--) {\n  1374→            var s = app.project.sequences[i];\n  1375→            if (s.name.indexOf(seq.name) === 0 && s.sequenceID !== seq.sequenceID) {\n  1376→                newSeq = s;\n  1377→                break;\n  1378→            }\n  1379→        }\n  1380→\n  1381→        if (!newSeq) {\n  1382→            return JSON.stringify({ error: \"Failed to clone sequence\" });\n  1383→        }\n  1384→\n  1385→        newSeq.name = newSequenceName;\n  1386→        app.project.activeSequence = newSeq;\n  1387→\n  1388→        // Clear all clips from the new sequence\n  1389→        clearSequence();\n  1390→\n  1391→        // Insert segments\n  1392→        var currentPosition = 0;\n  1393→        var stats = {\n  1394→            segmentsInserted: 0,\n  1395→            totalDuration: 0\n  1396→        };\n  1397→\n  1398→        for (var i = 0; i < cutList.segments.length; i++) {\n  1399→            var segment = cutList.segments[i];\n  1400→\n  1401→            // Find the source project item\n  1402→            var sourceItem = null;\n  1403→            if (segment.sourcePath) {\n  1404→                sourceItem = findItemByPath(app.project.rootItem, segment.sourcePath);\n  1405→            }\n  1406→            if (!sourceItem && segment.sourceName) {\n  1407→                sourceItem = findItemByName(app.project.rootItem, segment.sourceName);\n  1408→            }\n  1409→\n  1410→            if (!sourceItem) continue;\n  1411→\n  1412→            // Set color label\n  1413→            if (segment.colorHint && SEGMENT_COLORS[segment.colorHint]) {\n  1414→                sourceItem.setColorLabel(SEGMENT_COLORS[segment.colorHint]);\n  1415→            } else if (segment.type && SEGMENT_COLORS[segment.type]) {\n  1416→                sourceItem.setColorLabel(SEGMENT_COLORS[segment.type]);\n  1417→            }\n  1418→\n  1419→            // Insert clip at current position\n  1420→            var targetTime = new Time();\n  1421→            targetTime.seconds = currentPosition;\n  1422→\n  1423→            newSeq.videoTracks[0].insertClip(sourceItem, targetTime);\n  1424→\n  1425→            // Set in/out points\n  1426→            var clipDuration = segment.outPoint - segment.inPoint;\n  1427→            var videoClips = newSeq.videoTracks[0].clips;\n  1428→            var insertedClip = videoClips[videoClips.numItems - 1];\n  1429→\n  1430→            if (insertedClip) {\n  1431→                var inTime = new Time();\n  1432→                inTime.seconds = segment.inPoint;\n  1433→                insertedClip.inPoint = inTime;\n  1434→\n  1435→                var outTime = new Time();\n  1436→                outTime.seconds = segment.outPoint;\n  1437→                insertedClip.outPoint = outTime;\n  1438→\n  1439→                // Set clip name if takeLabel provided\n  1440→                if (segment.takeLabel) {\n  1441→                    insertedClip.name = segment.takeLabel;\n  1442→                }\n  1443→            }\n  1444→\n  1445→            currentPosition += clipDuration;\n  1446→            stats.segmentsInserted++;\n  1447→            stats.totalDuration += clipDuration;\n  1448→        }\n  1449→\n  1450→        return JSON.stringify({\n  1451→            success: true,\n  1452→            sequenceName: newSequenceName,\n  1453→            stats: stats\n  1454→        });\n  1455→    } catch (e) {\n  1456→        return JSON.stringify({ error: e.message });\n  1457→    }\n  1458→}\n  1459→\n  1460→function clearSequence() {\n  1461→    try {\n  1462→        var seq = app.project.activeSequence;\n  1463→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1464→\n  1465→        var removed = { video: 0, audio: 0 };\n  1466→\n  1467→        // Remove all video clips\n  1468→        for (var t = 0; t < seq.videoTracks.numTracks; t++) {\n  1469→            var clips = seq.videoTracks[t].clips;\n  1470→            for (var i = clips.numItems - 1; i >= 0; i--) {\n  1471→                clips[i].remove(false, false);\n  1472→                removed.video++;\n  1473→            }\n  1474→        }\n  1475→\n  1476→        // Remove all audio clips\n  1477→        for (var t = 0; t < seq.audioTracks.numTracks; t++) {\n  1478→            var clips = seq.audioTracks[t].clips;\n  1479→            for (var i = clips.numItems - 1; i >= 0; i--) {\n  1480→                clips[i].remove(false, false);\n  1481→                removed.audio++;\n  1482→            }\n  1483→        }\n  1484→\n  1485→        $.writeln('[SPLICE] clearSequence: Removed ' + removed.video + ' video clips, ' + removed.audio + ' audio clips');\n  1486→        return JSON.stringify({ success: true, removed: removed });\n  1487→    } catch (e) {\n  1488→        $.writeln('[SPLICE] clearSequence error: ' + e.message);\n  1489→        return JSON.stringify({ error: \"Clear sequence failed: \" + e.message });\n  1490→    }\n  1491→}\n  1492→\n  1493→// ============================================================================\n  1494→// WORK AREA\n  1495→// ============================================================================\n  1496→\n  1497→function getWorkArea() {\n  1498→    var seq = app.project.activeSequence;\n  1499→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1500→\n  1501→    return JSON.stringify({\n  1502→        inPoint: seq.getInPoint(),\n  1503→        outPoint: seq.getOutPoint()\n  1504→    });\n  1505→}\n  1506→\n  1507→function setWorkArea(inPoint, outPoint) {\n  1508→    var seq = app.project.activeSequence;\n  1509→    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1510→\n  1511→    seq.setInPoint(inPoint);\n  1512→    seq.setOutPoint(outPoint);\n  1513→    return JSON.stringify({ success: true });\n  1514→}\n  1515→\n  1516→// ============================================================================\n  1517→// AUDIO EXPORT\n  1518→// ============================================================================\n  1519→\n  1520→function exportSequenceAudio(outputPath, inPoint, outPoint) {\n  1521→    try {\n  1522→        var seq = app.project.activeSequence;\n  1523→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1524→\n  1525→        // Use the AME (Adobe Media Encoder) for export\n  1526→        var encoder = app.encoder;\n  1527→        if (!encoder) {\n  1528→            return JSON.stringify({ error: \"Media Encoder not available\" });\n  1529→        }\n  1530→\n  1531→        // Create export preset for WAV\n  1532→        var presetPath = encoder.getDefaultPresetPath();\n  1533→\n  1534→        // Queue the export\n  1535→        encoder.encodeSequence(\n  1536→            seq,\n  1537→            outputPath,\n  1538→            presetPath,\n  1539→            0, // WorkAreaType: 0 = entire, 1 = work area\n  1540→            false // removeOnCompletion\n  1541→        );\n  1542→\n  1543→        return JSON.stringify({ success: true, outputPath: outputPath });\n  1544→    } catch (e) {\n  1545→        return JSON.stringify({ error: e.message });\n  1546→    }\n  1547→}\n  1548→\n  1549→/**\n  1550→ * Export sequence audio for SPLICE analysis\n  1551→ * Uses AME to export WAV audio to temp folder\n  1552→ * @returns {Object} { success, outputPath } or { error }\n  1553→ */\n  1554→function exportSequenceAudioForAnalysis() {\n  1555→    try {\n  1556→        var seq = app.project.activeSequence;\n  1557→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1558→\n  1559→        // Generate temp file path\n  1560→        var tempFolder = Folder.temp.fsName;\n  1561→        var timestamp = new Date().getTime();\n  1562→        var outputPath = tempFolder + \"/splice_audio_\" + timestamp + \".wav\";\n  1563→\n  1564→        // Check if we have audio tracks with content\n  1565→        var hasAudio = false;\n  1566→        for (var i = 0; i < seq.audioTracks.numTracks; i++) {\n  1567→            if (seq.audioTracks[i].clips.numItems > 0) {\n  1568→                hasAudio = true;\n  1569→                break;\n  1570→            }\n  1571→        }\n  1572→\n  1573→        if (!hasAudio) {\n  1574→            return JSON.stringify({ error: \"Sequence has no audio clips\" });\n  1575→        }\n  1576→\n  1577→        // Use AME for export if available\n  1578→        if (app.encoder && app.encoder.encodeSequence) {\n  1579→            // Find audio-only preset or use default\n  1580→            var presetPath = null;\n  1581→            try {\n  1582→                // Try to find WAV preset in common locations\n  1583→                var presetFolders = [\n  1584→                    Folder.appData.fsName + \"/Adobe/Common/AME/15.0/Presets\",\n  1585→                    Folder.appData.fsName + \"/Adobe/Common/AME/14.0/Presets\",\n  1586→                    app.path + \"/MediaIO/systempresets/58534430_4d756c74-6962697400000000/WAV 48kHz.epr\"\n  1587→                ];\n  1588→\n  1589→                for (var i = 0; i < presetFolders.length; i++) {\n  1590→                    var presetFile = new File(presetFolders[i]);\n  1591→                    if (presetFile.exists) {\n  1592→                        presetPath = presetFile.fsName;\n  1593→                        break;\n  1594→                    }\n  1595→                }\n  1596→\n  1597→                // Fall back to default preset\n  1598→                if (!presetPath) {\n  1599→                    presetPath = app.encoder.getDefaultPresetPath();\n  1600→                }\n  1601→            } catch (e) {\n  1602→                presetPath = app.encoder.getDefaultPresetPath();\n  1603→            }\n  1604→\n  1605→            // Start the encode\n  1606→            var success = app.encoder.encodeSequence(\n  1607→                seq,\n  1608→                outputPath,\n  1609→                presetPath,\n  1610→                0, // WorkAreaType: 0 = entire sequence\n  1611→                false // removeOnCompletion\n  1612→            );\n  1613→\n  1614→            if (success) {\n  1615→                return JSON.stringify({ success: true, outputPath: outputPath, method: \"ame\" });\n  1616→            }\n  1617→        }\n  1618→\n  1619→        // Fallback: Try to get the source audio path from first clip\n  1620→        return getFirstClipAudioPath();\n  1621→\n  1622→    } catch (e) {\n  1623→        return JSON.stringify({ error: e.message });\n  1624→    }\n  1625→}\n  1626→\n  1627→/**\n  1628→ * Get the audio/video file path from the first clip in the timeline\n  1629→ * Used as fallback when AME export is not available\n  1630→ * @returns {Object} { success, path } or { error }\n  1631→ */\n  1632→function getFirstClipAudioPath() {\n  1633→    try {\n  1634→        var seq = app.project.activeSequence;\n  1635→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1636→\n  1637→        // First try audio tracks\n  1638→        for (var i = 0; i < seq.audioTracks.numTracks; i++) {\n  1639→            var track = seq.audioTracks[i];\n  1640→            if (track.clips.numItems > 0) {\n  1641→                var clip = track.clips[0];\n  1642→                if (clip.projectItem && clip.projectItem.getMediaPath) {\n  1643→                    var mediaPath = clip.projectItem.getMediaPath();\n  1644→                    if (mediaPath && mediaPath.length > 0) {\n  1645→                        return JSON.stringify({ success: true, path: mediaPath, method: \"audio_track\" });\n  1646→                    }\n  1647→                }\n  1648→            }\n  1649→        }\n  1650→\n  1651→        // Fall back to video tracks (which may have linked audio)\n  1652→        for (var i = 0; i < seq.videoTracks.numTracks; i++) {\n  1653→            var track = seq.videoTracks[i];\n  1654→            if (track.clips.numItems > 0) {\n  1655→                var clip = track.clips[0];\n  1656→                if (clip.projectItem && clip.projectItem.getMediaPath) {\n  1657→                    var mediaPath = clip.projectItem.getMediaPath();\n  1658→                    if (mediaPath && mediaPath.length > 0) {\n  1659→                        return JSON.stringify({ success: true, path: mediaPath, method: \"video_track\" });\n  1660→                    }\n  1661→                }\n  1662→            }\n  1663→        }\n  1664→\n  1665→        return JSON.stringify({ error: \"No clips with media paths found in sequence\" });\n  1666→    } catch (e) {\n  1667→        return JSON.stringify({ error: e.message });\n  1668→    }\n  1669→}\n  1670→\n  1671→// ============================================================================\n  1672→// UTILITY FUNCTIONS\n  1673→// ============================================================================\n  1674→\n  1675→function moveClipByNTracks(currentTrackId, clipStartTime, nTracksToMove, trackType) {\n  1676→    if (!isQEAvailable() && !enableQE()) {\n  1677→        return JSON.stringify({ error: \"QE not available for moving clips between tracks\" });\n  1678→    }\n  1679→\n  1680→    try {\n  1681→        var accuracy = 3;\n  1682→        var search_start_time = clipStartTime.toFixed(accuracy);\n  1683→\n  1684→        if (trackType == \"audio\") {\n  1685→            var numClipsInTrack = qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).numItems;\n  1686→            for (var j = 0; j < numClipsInTrack; j++) {\n  1687→                if (qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).getItemAt(j).start.secs.toFixed(accuracy) == search_start_time) {\n  1688→                    qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).getItemAt(j).moveToTrack(0, nTracksToMove, \"0\");\n  1689→                    return JSON.stringify({ success: true });\n  1690→                }\n  1691→            }\n  1692→        } else if (trackType == \"video\") {\n  1693→            var numClipsInTrack = qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).numItems;\n  1694→            for (var j = 0; j < numClipsInTrack; j++) {\n  1695→                if (qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).getItemAt(j).start.secs.toFixed(accuracy) == search_start_time) {\n  1696→                    qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).getItemAt(j).moveToTrack(nTracksToMove, 0, \"0\");\n  1697→                    return JSON.stringify({ success: true });\n  1698→                }\n  1699→            }\n  1700→        }\n  1701→        return JSON.stringify({ error: \"Clip not found at specified time\" });\n  1702→    } catch (e) {\n  1703→        return JSON.stringify({ error: \"Move clip failed: \" + e.message });\n  1704→    }\n  1705→}\n  1706→\n  1707→function linkIdenticalClipsInTracks(videoTrackIndex, audioTrackIndex) {\n  1708→    var selected_clips = app.project.activeSequence.getSelection();\n  1709→    for (var i = 0; i < selected_clips.length; i++) {\n  1710→        selected_clips[i].setSelected(false, false);\n  1711→    }\n  1712→\n  1713→    var video_clips = app.project.activeSequence.videoTracks[videoTrackIndex].clips;\n  1714→    var audio_clips = app.project.activeSequence.audioTracks[audioTrackIndex].clips;\n  1715→\n  1716→    for (var i = 0; i < video_clips.numItems; i++) {\n  1717→        var video_clip = video_clips[i];\n  1718→        var video_start = video_clip.start.seconds;\n  1719→\n  1720→        for (var j = 0; j < audio_clips.numItems; j++) {\n  1721→            var audio_clip = audio_clips[j];\n  1722→            var audio_start = audio_clip.start.seconds;\n  1723→\n  1724→            if (Math.abs(video_start - audio_start) < time_tolerance) {\n  1725→                video_clip.setSelected(true, false);\n  1726→                audio_clip.setSelected(true, false);\n  1727→                app.project.activeSequence.linkSelection();\n  1728→                video_clip.setSelected(false, false);\n  1729→                audio_clip.setSelected(false, false);\n  1730→                break;\n  1731→            }\n  1732→        }\n  1733→    }\n  1734→    return true;\n  1735→}\n  1736→\n  1737→// ============================================================================\n  1738→// ZOOM OPERATIONS (Phase 3)\n  1739→// ============================================================================\n  1740→\n  1741→function addZoomMarker(startSeconds, scale, duration, easing) {\n  1742→    try {\n  1743→        var name = \"ZOOM: \" + scale + \"%\";\n  1744→        var comments = \"Duration: \" + duration + \"s | Easing: \" + (easing || \"ease-in-out\");\n  1745→        return createMarker(startSeconds, name, duration, comments, COLOR_LABELS.YELLOW);\n  1746→    } catch (e) {\n  1747→        return JSON.stringify({ error: e.message });\n  1748→    }\n  1749→}\n  1750→\n  1751→// ============================================================================\n  1752→// CHAPTER OPERATIONS (Phase 3)\n  1753→// ============================================================================\n  1754→\n  1755→function addChapterMarker(timeSeconds, title, description) {\n  1756→    try {\n  1757→        var seq = app.project.activeSequence;\n  1758→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1759→\n  1760→        var markers = seq.markers;\n  1761→        var marker = markers.createMarker(timeSeconds);\n  1762→\n  1763→        marker.name = title;\n  1764→        if (description) marker.comments = description;\n  1765→        marker.setColorByIndex(COLOR_LABELS.BLUE);\n  1766→        marker.setTypeAsChapter();\n  1767→\n  1768→        return JSON.stringify({\n  1769→            success: true,\n  1770→            guid: marker.guid\n  1771→        });\n  1772→    } catch (e) {\n  1773→        return JSON.stringify({ error: e.message });\n  1774→    }\n  1775→}\n  1776→\n  1777→function getChapterMarkers() {\n  1778→    try {\n  1779→        var seq = app.project.activeSequence;\n  1780→        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n  1781→\n  1782→        var markers = seq.markers;\n  1783→        var chapters = [];\n  1784→\n  1785→        for (var i = 0; i < markers.numMarkers; i++) {\n  1786→            var marker = markers[i];\n  1787→            if (marker.type === \"Chapter\") {\n  1788→                chapters.push({\n  1789→                    guid: marker.guid,\n  1790→                    name: marker.name,\n  1791→                    comments: marker.comments,\n  1792→                    start: marker.start.seconds\n  1793→                });\n  1794→            }\n  1795→        }\n  1796→\n  1797→        return JSON.stringify(chapters);\n  1798→    } catch (e) {\n  1799→        return JSON.stringify({ error: e.message });\n  1800→    }\n  1801→}\n  1802→\n  1803→// ============================================================================\n  1804→// UNDO OPERATIONS\n  1805→// ============================================================================\n  1806→\n  1807→function undo() {\n  1808→    app.project.undo();\n  1809→    return true;\n  1810→}\n  1811→\n  1812→function redo() {\n  1813→    app.project.redo();\n  1814→    return true;\n  1815→}\n  1816→\n  1817→// ============================================================================\n  1818→// DEBUG / LOGGING\n  1819→// ============================================================================\n  1820→\n  1821→function log(message) {\n  1822→    $.writeln(\"[SPLICE] \" + message);\n  1823→}\n  1824→\n  1825→function getDebugInfo() {\n  1826→    return JSON.stringify({\n  1827→        version: SPLICE_VERSION,\n  1828→        hasActiveSequence: app.project.activeSequence ? true : false,\n  1829→        sequenceName: app.project.activeSequence ? app.project.activeSequence.name : null,\n  1830→        numSequences: app.project.sequences.numSequences,\n  1831→        numProjectItems: app.project.rootItem.children.numItems\n  1832→    });\n  1833→}\n  1834→\n  1835→// NOTE: Do NOT auto-initialize on load - CEP will call initialise() explicitly\n  1836→// when the panel is ready. Auto-initialization can fail if no project is open.\n  1837→$.writeln('[SPLICE] hostScript.jsx loaded - version ' + SPLICE_VERSION);\n  1838→\n\n</system-reminder>\n"}]},"uuid":"126a1b03-f3b7-442f-8a22-224f2a2f2258","timestamp":"2026-01-12T07:49:06.225Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/SPLICE/splice-cep/jsx/hostScript.jsx","content":"/**\n * SPLICE CEP Host Script\n * ExtendScript for Premiere Pro\n *\n * Provides all Premiere Pro API functions called via jsx.evalScript()\n * Based on proven patterns from FireCut and SPLICE UXP builder\n */\n\n// ============================================================================\n// GLOBAL CONSTANTS & STATE\n// ============================================================================\nvar SPLICE_VERSION = \"6.0.3\";\nvar TICKS_PER_SECOND = 254016000000;\nvar time_tolerance = 0.01; // 10ms tolerance for clip matching\nvar temp_bin = null;\nvar sequence_default_timecode = null;\n\n// Color label indices (Premiere Pro standard)\nvar COLOR_LABELS = {\n    NONE: 0,\n    VIOLET: 1,\n    IRIS: 2,\n    CARIBBEAN: 3,\n    LAVENDER: 4,\n    CERULEAN: 5,\n    FOREST: 6,\n    ROSE: 7,\n    MANGO: 8,\n    PURPLE: 9,\n    BLUE: 10,\n    TEAL: 11,\n    MAGENTA: 12,\n    TAN: 13,\n    GREEN: 14,\n    BROWN: 15,\n    YELLOW: 16\n};\n\n// Segment type to color mapping\nvar SEGMENT_COLORS = {\n    speech: COLOR_LABELS.FOREST,\n    take: COLOR_LABELS.LAVENDER,\n    best_take: COLOR_LABELS.CERULEAN,\n    silence: COLOR_LABELS.VIOLET,\n    wide_shot: COLOR_LABELS.YELLOW,\n    speaker_a: COLOR_LABELS.MANGO,\n    speaker_b: COLOR_LABELS.CARIBBEAN\n};\n\n// Timecode display formats\nvar TIMECODES = {\n    TIMEDISPLAY_Frames: 4\n};\n\n// Translation map for localized effect names\nvar translations = {\n    \"Motion\": [\"Motion\", \"Mouvement\", \"Bewegung\", \"Movimiento\", \"Movimento\"],\n    \"Transform\": [\"Transform\", \"Transformation\", \"Transformieren\", \"Transformar\"],\n    \"Scale\": [\"Scale\", \"Echelle\", \"Skalierung\", \"Escala\"],\n    \"Scale Height\": [\"Scale Height\", \"Hauteur de l'echelle\", \"Skalierungshoehe\"],\n    \"Scale Width\": [\"Scale Width\", \"Largeur de l'echelle\", \"Skalierungsbreite\"],\n    \"Position\": [\"Position\", \"Posicion\", \"Posicao\"],\n    \"Anchor Point\": [\"Anchor Point\", \"Point d'ancrage\", \"Ankerpunkt\"],\n    \"Rotation\": [\"Rotation\", \"Rotacion\", \"Rotacao\"],\n    \"Opacity\": [\"Opacity\", \"Opacite\", \"Deckkraft\", \"Opacidad\"]\n};\n\n// Project item types\nvar project_item_type = {\n    \"clip\": 1,\n    \"bin\": 2,\n    \"root\": 3,\n    \"file\": 4\n};\n\n// ============================================================================\n// SECURITY: INPUT VALIDATION UTILITIES (CEP-CRIT-001)\n// Prevents path traversal, command injection, and null byte attacks\n// ============================================================================\n\n/**\n * Validate and sanitize file paths to prevent path traversal attacks\n * @param {string} path - File path to validate\n * @returns {Object} { valid: boolean, path: string, error: string }\n */\nfunction validateFilePath(path) {\n    if (!path || typeof path !== 'string') {\n        return { valid: false, path: null, error: 'Invalid path: must be a non-empty string' };\n    }\n\n    // Check for null bytes (CVE potential)\n    if (path.indexOf('\\0') !== -1 || path.indexOf('\\x00') !== -1) {\n        return { valid: false, path: null, error: 'Invalid path: null bytes detected' };\n    }\n\n    // Normalize path separators\n    var normalized = path.replace(/\\\\/g, '/');\n\n    // Check for directory traversal attempts\n    if (normalized.indexOf('../') !== -1 || normalized.indexOf('..\\\\') !== -1) {\n        return { valid: false, path: null, error: 'Invalid path: directory traversal detected' };\n    }\n\n    // Check for potentially dangerous characters in paths (command injection)\n    var dangerousChars = /[`$();|&<>]/;\n    if (dangerousChars.test(path)) {\n        return { valid: false, path: null, error: 'Invalid path: dangerous characters detected' };\n    }\n\n    // Check for protocol handlers that could be exploited\n    var protocolPattern = /^[a-zA-Z][a-zA-Z0-9+.-]*:/;\n    if (protocolPattern.test(path) && !path.match(/^[A-Z]:\\//i)) {\n        // Allow Windows drive letters (C:/) but block other protocols (javascript:, data:, etc.)\n        return { valid: false, path: null, error: 'Invalid path: protocol handlers not allowed' };\n    }\n\n    return { valid: true, path: path, error: null };\n}\n\n/**\n * Validate sequence name to prevent XSS and injection\n * @param {string} name - Sequence name to validate\n * @returns {Object} { valid: boolean, name: string, error: string }\n */\nfunction validateSequenceName(name) {\n    if (!name || typeof name !== 'string') {\n        return { valid: false, name: null, error: 'Invalid name: must be a non-empty string' };\n    }\n\n    // Check for null bytes\n    if (name.indexOf('\\0') !== -1) {\n        return { valid: false, name: null, error: 'Invalid name: null bytes detected' };\n    }\n\n    // Check for potentially dangerous characters (file system reserved on Windows)\n    var invalidChars = /[<>:\"|?*]/;\n    if (invalidChars.test(name)) {\n        return { valid: false, name: null, error: 'Invalid name: contains reserved characters' };\n    }\n\n    // Limit length to prevent buffer overflows\n    if (name.length > 255) {\n        return { valid: false, name: null, error: 'Invalid name: exceeds maximum length (255)' };\n    }\n\n    return { valid: true, name: name, error: null };\n}\n\n/**\n * Validate numeric parameters to prevent injection and DoS\n * @param {*} value - Value to validate\n * @param {number} min - Minimum allowed value\n * @param {number} max - Maximum allowed value\n * @param {string} paramName - Parameter name for error messages\n * @returns {Object} { valid: boolean, value: number, error: string }\n */\nfunction validateNumericParam(value, min, max, paramName) {\n    if (value === undefined || value === null) {\n        return { valid: false, value: null, error: paramName + ' is required' };\n    }\n\n    var num = parseFloat(value);\n    if (isNaN(num)) {\n        return { valid: false, value: null, error: paramName + ' must be a number' };\n    }\n\n    if (num < min || num > max) {\n        return { valid: false, value: null, error: paramName + ' must be between ' + min + ' and ' + max };\n    }\n\n    return { valid: true, value: num, error: null };\n}\n\n/**\n * Sanitize string for safe use in Premiere Pro operations\n * @param {string} str - String to sanitize\n * @returns {string} Sanitized string\n */\nfunction sanitizeString(str) {\n    if (!str || typeof str !== 'string') {\n        return '';\n    }\n\n    // Remove null bytes\n    str = str.replace(/\\0/g, '');\n\n    // Escape special characters that could be problematic in ExtendScript\n    str = str.replace(/[\\r\\n]/g, ' ');\n\n    return str;\n}\n\n/**\n * Validate array of time values (for markers, cuts, etc.)\n * @param {Array} times - Array of time values\n * @param {number} maxLength - Maximum array length (DoS prevention)\n * @returns {Object} { valid: boolean, times: Array, error: string }\n */\nfunction validateTimeArray(times, maxLength) {\n    if (!times || !Array.isArray(times)) {\n        return { valid: false, times: null, error: 'Times must be an array' };\n    }\n\n    maxLength = maxLength || 10000; // Default limit\n    if (times.length > maxLength) {\n        return { valid: false, times: null, error: 'Too many time values (max: ' + maxLength + ')' };\n    }\n\n    for (var i = 0; i < times.length; i++) {\n        var validation = validateNumericParam(times[i], 0, Number.MAX_VALUE, 'time[' + i + ']');\n        if (!validation.valid) {\n            return { valid: false, times: null, error: validation.error };\n        }\n    }\n\n    return { valid: true, times: times, error: null };\n}\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\n\n/**\n * Check if QE (Quality Engine) DOM is available\n * QE provides extended functionality not available in standard DOM\n */\nfunction isQEAvailable() {\n    try {\n        return typeof qe !== 'undefined' && qe !== null && qe.project;\n    } catch (e) {\n        return false;\n    }\n}\n\n/**\n * Enable QE DOM if not already enabled\n * @returns {boolean} true if QE is now available\n */\nfunction enableQE() {\n    try {\n        if (isQEAvailable()) return true;\n        app.enableQE();\n        return isQEAvailable();\n    } catch (e) {\n        $.writeln('[SPLICE] enableQE failed: ' + e.message);\n        return false;\n    }\n}\n\n/**\n * Safe wrapper for QE operations\n * @param {Function} operation - The QE operation to execute\n * @param {string} operationName - Name for error reporting\n * @returns {Object} Result or error object\n */\nfunction safeQEOperation(operation, operationName) {\n    try {\n        if (!isQEAvailable()) {\n            if (!enableQE()) {\n                return { error: \"QE not available. Please ensure Premiere Pro supports QE DOM.\" };\n            }\n        }\n        return operation();\n    } catch (e) {\n        return { error: operationName + \" failed: \" + e.message };\n    }\n}\n\nfunction initialise() {\n    try {\n        storeDefaultTimecode();\n        // Try to enable QE on startup\n        var qeStatus = enableQE();\n        return JSON.stringify({ success: true, version: SPLICE_VERSION, qeAvailable: qeStatus });\n    } catch (e) {\n        $.writeln('[SPLICE] initialise error: ' + e.message);\n        return JSON.stringify({ success: false, error: e.message, version: SPLICE_VERSION });\n    }\n}\n\nfunction storeDefaultTimecode() {\n    try {\n        if (app && app.project && app.project.activeSequence) {\n            sequence_default_timecode = app.project.activeSequence.getSettings().videoDisplayFormat;\n        }\n    } catch (e) {\n        $.writeln('[SPLICE] storeDefaultTimecode failed: ' + e.message);\n    }\n}\n\n/**\n * Check if a sequence is currently open/active in the Timeline\n * Uses multiple fallbacks to ensure accurate detection\n * @returns {boolean} true if a sequence is open\n */\nfunction checkSequenceOpen() {\n    try {\n        $.writeln('[SPLICE] ========== checkSequenceOpen DIAGNOSTIC START ==========');\n        \n        // Check if app exists\n        if (!app) {\n            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app object does not exist');\n            return false;\n        }\n        $.writeln('[SPLICE] checkSequenceOpen: app object exists');\n        \n        // Check if project exists\n        if (!app.project) {\n            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app.project does not exist');\n            return false;\n        }\n        $.writeln('[SPLICE] checkSequenceOpen: app.project exists');\n        \n        // Check if sequences collection exists\n        if (!app.project.sequences) {\n            $.writeln('[SPLICE] checkSequenceOpen: ERROR - app.project.sequences does not exist');\n            return false;\n        }\n        $.writeln('[SPLICE] checkSequenceOpen: app.project.sequences exists');\n        \n        // Log total number of sequences\n        var numSequences = app.project.sequences.numSequences;\n        $.writeln('[SPLICE] checkSequenceOpen: Total sequences in project: ' + numSequences);\n        \n        // List all sequences with their details\n        for (var i = 0; i < numSequences; i++) {\n            var seq = app.project.sequences[i];\n            if (seq) {\n                $.writeln('[SPLICE] checkSequenceOpen:   - Sequence ' + i + ': name=\"' + seq.name + '\", id=' + seq.sequenceID);\n            }\n        }\n        \n        // Primary check: Standard DOM - Check for activeSequence\n        $.writeln('[SPLICE] checkSequenceOpen: Checking app.project.activeSequence...');\n        if (app.project.activeSequence) {\n            var activeSeq = app.project.activeSequence;\n            $.writeln('[SPLICE] checkSequenceOpen: SUCCESS - Found active sequence via DOM');\n            $.writeln('[SPLICE] checkSequenceOpen:   - name: ' + activeSeq.name);\n            $.writeln('[SPLICE] checkSequenceOpen:   - sequenceID: ' + activeSeq.sequenceID);\n            $.writeln('[SPLICE] checkSequenceOpen:   - videoTracks: ' + activeSeq.videoTracks.numTracks);\n            $.writeln('[SPLICE] checkSequenceOpen:   - audioTracks: ' + activeSeq.audioTracks.numTracks);\n            $.writeln('[SPLICE] checkSequenceOpen:   - frameSize: ' + activeSeq.frameSizeHorizontal + 'x' + activeSeq.frameSizeVertical);\n            $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n            return true;\n        }\n        $.writeln('[SPLICE] checkSequenceOpen: app.project.activeSequence is null/undefined');\n\n        // Fallback: Try QE DOM (requires enableQE first)\n        $.writeln('[SPLICE] checkSequenceOpen: Trying QE DOM fallback...');\n        if (enableQE()) {\n            try {\n                $.writeln('[SPLICE] checkSequenceOpen: QE DOM is enabled');\n                var qeSeq = qe.project.getActiveSequence();\n                if (qeSeq && qeSeq.name) {\n                    $.writeln('[SPLICE] checkSequenceOpen: SUCCESS - Found active sequence via QE DOM: ' + qeSeq.name);\n                    $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (TRUE) ==========');\n                    return true;\n                }\n                $.writeln('[SPLICE] checkSequenceOpen: QE DOM returned null or sequence without name');\n            } catch (qeErr) {\n                $.writeln('[SPLICE] checkSequenceOpen: QE sequence check failed: ' + qeErr.message);\n            }\n        } else {\n            $.writeln('[SPLICE] checkSequenceOpen: QE DOM is NOT available/enabled');\n        }\n\n        $.writeln('[SPLICE] checkSequenceOpen: No active sequence found in either DOM or QE DOM');\n        $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (FALSE) ==========');\n        return false;\n    } catch (e) {\n        $.writeln('[SPLICE] checkSequenceOpen: EXCEPTION - ' + e.message);\n        $.writeln('[SPLICE] checkSequenceOpen: Stack: ' + (e.stack || 'no stack available'));\n        $.writeln('[SPLICE] checkSequenceOpen: ========== checkSequenceOpen DIAGNOSTIC END (ERROR) ==========');\n        return false;\n    }\n}\n\nfunction getVersion() {\n    return SPLICE_VERSION;\n}\n\n// ============================================================================\n// TIME CONVERSION UTILITIES\n// ============================================================================\n\n/**\n * Get the actual frames per second from the sequence\n * videoFrameRate.seconds gives seconds per frame, so we need to invert it\n */\nfunction getActualFrameRate() {\n    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n    // secsPerFrame is e.g., 0.03333... for 30fps, so 1/secsPerFrame = 30\n    return 1 / secsPerFrame;\n}\n\nfunction quantise_time(time_seconds) {\n    // Get seconds per frame (e.g., 0.0333 for 30fps)\n    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n    // Round to nearest frame boundary\n    return secsPerFrame * Math.round(time_seconds / secsPerFrame);\n}\n\nfunction frames_to_time(number_of_frames) {\n    // seconds per frame * number of frames = total seconds\n    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n    return number_of_frames * secsPerFrame;\n}\n\nfunction frames_to_ticks(number_of_frames) {\n    // Convert frames to ticks: frames * seconds_per_frame * ticks_per_second\n    var secsPerFrame = app.project.activeSequence.getSettings().videoFrameRate.seconds;\n    return number_of_frames * secsPerFrame * TICKS_PER_SECOND;\n}\n\nfunction seconds_to_ticks(seconds) {\n    return seconds * TICKS_PER_SECOND;\n}\n\nfunction ticks_to_seconds(ticks) {\n    return ticks / TICKS_PER_SECOND;\n}\n\nfunction getVideoFrameRateInSeconds() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) {\n            $.writeln('[SPLICE] getVideoFrameRateInSeconds: No active sequence');\n            return null;\n        }\n        return seq.getSettings().videoFrameRate.seconds;\n    } catch (e) {\n        $.writeln('[SPLICE] getVideoFrameRateInSeconds error: ' + e.message);\n        return null;\n    }\n}\n\nfunction secondsToCurrentTimecode(seconds) {\n    var seq = app.project.activeSequence;\n    if (seq) {\n        var t = new Time();\n        t.seconds = parseFloat(seconds);\n        var settings = app.project.activeSequence.getSettings();\n        return t.getFormatted(settings.videoFrameRate, settings.videoDisplayFormat);\n    }\n    return false;\n}\n\n// ============================================================================\n// TIMECODE FORMAT\n// ============================================================================\n\nfunction setTimecodeToFrames() {\n    var seq = app.project.activeSequence;\n    if (seq) {\n        var currentSeqSettings = app.project.activeSequence.getSettings();\n        if (currentSeqSettings.videoDisplayFormat != TIMECODES.TIMEDISPLAY_Frames) {\n            currentSeqSettings.videoDisplayFormat = TIMECODES.TIMEDISPLAY_Frames;\n            app.project.activeSequence.setSettings(currentSeqSettings);\n        }\n    }\n}\n\nfunction setTimecodeToDefault() {\n    var seq = app.project.activeSequence;\n    if (seq && sequence_default_timecode) {\n        var currentSeqSettings = app.project.activeSequence.getSettings();\n        currentSeqSettings.videoDisplayFormat = sequence_default_timecode;\n        app.project.activeSequence.setSettings(currentSeqSettings);\n    }\n}\n\nfunction getTimecodeFormat() {\n    return app.project.activeSequence.getSettings().videoDisplayFormat;\n}\n\nfunction setTimecodeFormat(format) {\n    format = parseInt(format);\n    var seq = app.project.activeSequence;\n    if (seq) {\n        var currentSeqSettings = app.project.activeSequence.getSettings();\n        currentSeqSettings.videoDisplayFormat = format;\n        app.project.activeSequence.setSettings(currentSeqSettings);\n    }\n    return true;\n}\n\n// ============================================================================\n// SEQUENCE & PROJECT OPERATIONS\n// ============================================================================\n\nfunction getActiveSequence() {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    return JSON.stringify({\n        name: seq.name,\n        id: seq.sequenceID,\n        duration: seq.end,\n        videoTrackCount: seq.videoTracks.numTracks,\n        audioTrackCount: seq.audioTracks.numTracks,\n        frameRate: seq.getSettings().videoFrameRate.seconds,\n        width: seq.frameSizeHorizontal,\n        height: seq.frameSizeVertical\n    });\n}\n\nfunction getSequenceSettings() {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    var settings = seq.getSettings();\n    return JSON.stringify({\n        frameRate: settings.videoFrameRate.seconds,\n        width: settings.videoFrameWidth,\n        height: settings.videoFrameHeight,\n        displayFormat: settings.videoDisplayFormat\n    });\n}\n\nfunction cloneSequence(newName) {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    try {\n        // Clone the sequence\n        seq.clone();\n\n        // Find the cloned sequence (last one with matching name pattern)\n        var clonedSeq = null;\n        for (var i = app.project.sequences.numSequences - 1; i >= 0; i--) {\n            var s = app.project.sequences[i];\n            if (s.name.indexOf(seq.name) === 0 && s.sequenceID !== seq.sequenceID) {\n                clonedSeq = s;\n                break;\n            }\n        }\n\n        if (clonedSeq && newName) {\n            clonedSeq.name = newName;\n        }\n\n        return JSON.stringify({\n            success: true,\n            sequenceId: clonedSeq ? clonedSeq.sequenceID : null,\n            name: clonedSeq ? clonedSeq.name : newName\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction createNewSequence(name) {\n    try {\n        app.project.createNewSequence(name);\n        var seq = app.project.activeSequence;\n        return JSON.stringify({\n            success: true,\n            sequenceId: seq.sequenceID,\n            name: seq.name\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction setActiveSequence(sequenceId) {\n    for (var i = 0; i < app.project.sequences.numSequences; i++) {\n        if (app.project.sequences[i].sequenceID === sequenceId) {\n            app.project.activeSequence = app.project.sequences[i];\n            return JSON.stringify({ success: true });\n        }\n    }\n    return JSON.stringify({ error: \"Sequence not found\" });\n}\n\n/**\n * Seek playhead to a specific time in seconds\n */\nfunction seekToTime(seconds) {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    try {\n        // Convert seconds to ticks\n        var ticks = seconds * TICKS_PER_SECOND;\n\n        // Create a Time object and set position\n        var playerPos = seq.getPlayerPosition();\n        playerPos.seconds = seconds;\n        seq.setPlayerPosition(playerPos.ticks.toString());\n\n        return JSON.stringify({ success: true, position: seconds });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n/**\n * Get current playhead position in seconds\n */\nfunction getPlayerPosition() {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    try {\n        var pos = seq.getPlayerPosition();\n        return JSON.stringify({\n            ticks: pos.ticks,\n            seconds: pos.seconds\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// RAZOR OPERATIONS\n// ============================================================================\n\nfunction razorSequenceAtFrames(frames) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for razor operation\" });\n    }\n    try {\n        frames = String(frames);\n        setTimecodeToFrames();\n        qe.project.getActiveSequence().razor(frames);\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: \"Razor failed: \" + e.message });\n    }\n}\n\nfunction razorSequenceAtSeconds(seconds) {\n    try {\n        var frames = parseInt(Math.round(seconds / app.project.activeSequence.getSettings().videoFrameRate.seconds)).toString();\n        return razorSequenceAtFrames(frames);\n    } catch (e) {\n        return JSON.stringify({ error: \"Razor at seconds failed: \" + e.message });\n    }\n}\n\nfunction razorSequenceAtFramesArray(silences_array) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for razor operation\" });\n    }\n    try {\n        setTimecodeToFrames();\n        silences_array = JSON.parse(silences_array);\n        var razorCount = 0;\n        for (var i = 0; i < silences_array.length; i++) {\n            for (var j = 0; j < silences_array[i].length; j++) {\n                var frames = String(silences_array[i][j]);\n                qe.project.getActiveSequence().razor(frames);\n                razorCount++;\n            }\n        }\n        return JSON.stringify({ success: true, razorCount: razorCount });\n    } catch (e) {\n        return JSON.stringify({ error: \"Razor array failed: \" + e.message });\n    }\n}\n\nfunction razorTrackAtFrames(trackType, trackIndex, frames) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for track razor\" });\n    }\n    try {\n        frames = String(frames);\n        setTimecodeToFrames();\n        if (trackType == \"video\") {\n            qe.project.getActiveSequence().getVideoTrackAt(trackIndex).razor(frames);\n        } else if (trackType == \"audio\") {\n            qe.project.getActiveSequence().getAudioTrackAt(trackIndex).razor(frames);\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: \"Track razor failed: \" + e.message });\n    }\n}\n\nfunction razorTrackAtSeconds(trackType, trackIndex, seconds) {\n    try {\n        var frames = parseInt(Math.round(seconds / app.project.activeSequence.getSettings().videoFrameRate.seconds)).toString();\n        return razorTrackAtFrames(trackType, trackIndex, frames);\n    } catch (e) {\n        return JSON.stringify({ error: \"Track razor at seconds failed: \" + e.message });\n    }\n}\n\n// ============================================================================\n// CLIP OPERATIONS\n// ============================================================================\n\n/**\n * Get currently selected clips in the timeline\n * @returns {string} JSON with selected clip data or error\n */\nfunction getSelectedClips() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var selection = seq.getSelection();\n        var clips = [];\n\n        for (var i = 0; i < selection.length; i++) {\n            var clip = selection[i];\n            clips.push({\n                index: i,\n                name: clip.name,\n                start: clip.start.seconds,\n                end: clip.end.seconds,\n                duration: clip.duration.seconds,\n                inPoint: clip.inPoint ? clip.inPoint.seconds : null,\n                outPoint: clip.outPoint ? clip.outPoint.seconds : null,\n                mediaPath: clip.projectItem ? clip.projectItem.getMediaPath() : null\n            });\n        }\n\n        $.writeln('[SPLICE] getSelectedClips: Found ' + clips.length + ' selected clips');\n        return JSON.stringify({\n            count: clips.length,\n            clips: clips\n        });\n    } catch (e) {\n        $.writeln('[SPLICE] getSelectedClips error: ' + e.message);\n        return JSON.stringify({ error: \"getSelectedClips failed: \" + e.message });\n    }\n}\n\nfunction getClipsInTrack(trackIndex, trackType) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var tracks = trackType === \"audio\" ? seq.audioTracks : seq.videoTracks;\n        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex + \" (max: \" + (tracks.numTracks - 1) + \")\" });\n        }\n\n        var clips = [];\n        var trackClips = tracks[trackIndex].clips;\n        for (var i = 0; i < trackClips.numItems; i++) {\n            var clip = trackClips[i];\n            clips.push({\n                index: i,\n                name: clip.name,\n                start: clip.start.seconds,\n                end: clip.end.seconds,\n                duration: clip.duration.seconds,\n                inPoint: clip.inPoint.seconds,\n                outPoint: clip.outPoint.seconds,\n                mediaPath: clip.projectItem ? clip.projectItem.getMediaPath() : null\n            });\n        }\n        return JSON.stringify(clips);\n    } catch (e) {\n        $.writeln('[SPLICE] getClipsInTrack error: ' + e.message);\n        return JSON.stringify({ error: \"getClipsInTrack failed: \" + e.message });\n    }\n}\n\nfunction getClipsInTrack_Timings_Seconds(trackIndex, trackType) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var tracks = trackType === \"audio\" ? seq.audioTracks : seq.videoTracks;\n        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex });\n        }\n\n        var clips = [];\n        var trackClips = tracks[trackIndex].clips;\n        for (var i = 0; i < trackClips.numItems; i++) {\n            clips.push([\n                trackClips[i].start.seconds,\n                trackClips[i].end.seconds\n            ]);\n        }\n        return JSON.stringify(clips);\n    } catch (e) {\n        $.writeln('[SPLICE] getClipsInTrack_Timings_Seconds error: ' + e.message);\n        return JSON.stringify({ error: \"getClipsInTrack_Timings_Seconds failed: \" + e.message });\n    }\n}\n\nfunction deleteClipsAtSilencePointsInTrack(silences, trackType, trackIndex) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Validate trackType\n        if (trackType !== \"video\" && trackType !== \"audio\") {\n            return JSON.stringify({ error: \"Invalid track type: \" + trackType });\n        }\n\n        // Parse silences JSON\n        var silencesArr;\n        try {\n            silencesArr = JSON.parse(silences);\n        } catch (parseErr) {\n            return JSON.stringify({ error: \"Invalid silences JSON: \" + parseErr.message });\n        }\n\n        // Get tracks and validate index\n        var tracks = trackType === \"video\" ? seq.videoTracks : seq.audioTracks;\n        if (trackIndex < 0 || trackIndex >= tracks.numTracks) {\n            return JSON.stringify({ error: \"Invalid track index: \" + trackIndex + \" (max: \" + (tracks.numTracks - 1) + \")\" });\n        }\n\n        var clips = tracks[trackIndex].clips;\n        var deleted = 0;\n\n        // Iterate backwards to avoid index shifting (use numItems, not length)\n        for (var i = clips.numItems - 1; i >= 0; i--) {\n            var clip = clips[i];\n            var start = clip.start.seconds;\n            var end = clip.end.seconds;\n            var center = (start + end) / 2;\n\n            for (var j = 0; j < silencesArr.length; j++) {\n                var silence = silencesArr[j];\n                var silenceCenter = (silence[0] + silence[1]) / 2;\n                if (silenceCenter > start && silenceCenter < end) {\n                    clip.remove(false, false);\n                    deleted++;\n                    break;\n                }\n            }\n        }\n\n        $.writeln('[SPLICE] deleteClipsAtSilencePointsInTrack: Deleted ' + deleted + ' clips from ' + trackType + ' track ' + trackIndex);\n        return JSON.stringify({ deleted: deleted });\n    } catch (e) {\n        $.writeln('[SPLICE] deleteClipsAtSilencePointsInTrack error: ' + e.message);\n        return JSON.stringify({ error: \"deleteClipsAtSilencePointsInTrack failed: \" + e.message });\n    }\n}\n\nfunction makeRemainingClipsContiguousInTrack(silences, deltas, trackType, trackIndex) {\n    silences = JSON.parse(silences);\n    deltas = JSON.parse(deltas);\n\n    var clips;\n    if (trackType == \"video\") {\n        clips = app.project.activeSequence.videoTracks[trackIndex].clips;\n    } else if (trackType == \"audio\") {\n        clips = app.project.activeSequence.audioTracks[trackIndex].clips;\n    }\n\n    for (var i = 0; i < clips.length; i++) {\n        var clip = clips[i];\n        var end = clip.end.seconds;\n        var num_silences = -1;\n\n        for (var j = 0; j < silences.length; j++) {\n            if (end > silences[j][1]) {\n                num_silences++;\n            }\n        }\n\n        if (num_silences > -1 && num_silences < deltas.length) {\n            var delta = deltas[num_silences];\n            var t_start = clip.start;\n            t_start.seconds = t_start.seconds - delta;\n            clip.start = t_start;\n            var t_end = clip.end;\n            t_end.seconds = t_end.seconds - delta;\n            clip.end = t_end;\n        }\n    }\n    return JSON.stringify({ success: true });\n}\n\nfunction removeClipByIndex(trackType, trackIndex, clipIndex) {\n    try {\n        if (trackType == \"video\") {\n            app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex].remove(false, false);\n        } else if (trackType == \"audio\") {\n            app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex].remove(false, false);\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction setClipInOutPoints(trackType, trackIndex, clipIndex, inPoint, outPoint) {\n    try {\n        var clip;\n        if (trackType == \"video\") {\n            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n        } else if (trackType == \"audio\") {\n            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n        }\n\n        if (inPoint !== null) {\n            var inTime = new Time();\n            inTime.seconds = inPoint;\n            clip.inPoint = inTime;\n        }\n        if (outPoint !== null) {\n            var outTime = new Time();\n            outTime.seconds = outPoint;\n            clip.outPoint = outTime;\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction setClipStartEnd(trackType, trackIndex, clipIndex, startSeconds, endSeconds) {\n    try {\n        var clip;\n        if (trackType == \"video\") {\n            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n        } else if (trackType == \"audio\") {\n            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n        }\n\n        if (startSeconds !== null) {\n            var startTime = clip.start;\n            startTime.seconds = startSeconds;\n            clip.start = startTime;\n        }\n        if (endSeconds !== null) {\n            var endTime = clip.end;\n            endTime.seconds = endSeconds;\n            clip.end = endTime;\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// TRACK OPERATIONS\n// ============================================================================\n\nfunction getTrackNames(trackType) {\n    if (!isQEAvailable() && !enableQE()) {\n        // Fallback: use standard DOM\n        var ret = [];\n        try {\n            if (trackType == \"video\") {\n                for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n                    ret.push(\"V\" + (i + 1));\n                }\n            } else if (trackType == \"audio\") {\n                for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n                    ret.push(\"A\" + (i + 1));\n                }\n            }\n        } catch (e) {\n            return JSON.stringify({ error: \"Failed to get track names: \" + e.message });\n        }\n        return JSON.stringify(ret);\n    }\n\n    try {\n        var ret = [];\n        if (trackType == \"video\") {\n            for (var i = 0; i < qe.project.getActiveSequence().numVideoTracks; i++) {\n                ret.push(qe.project.getActiveSequence().getVideoTrackAt(i).name);\n            }\n        } else if (trackType == \"audio\") {\n            for (var i = 0; i < qe.project.getActiveSequence().numAudioTracks; i++) {\n                ret.push(qe.project.getActiveSequence().getAudioTrackAt(i).name);\n            }\n        }\n        return JSON.stringify(ret);\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to get track names: \" + e.message });\n    }\n}\n\nfunction getNumTracks(trackType) {\n    try {\n        if (trackType == \"video\") {\n            return app.project.activeSequence.videoTracks.numTracks;\n        } else if (trackType == \"audio\") {\n            return app.project.activeSequence.audioTracks.numTracks;\n        }\n        return 0;\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to get track count: \" + e.message });\n    }\n}\n\nfunction addVideoTrack() {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for adding tracks\" });\n    }\n    try {\n        var trackId = qe.project.getActiveSequence().numVideoTracks;\n        qe.project.getActiveSequence().addTracks(1, trackId, 0, 0);\n        return JSON.stringify({ success: true, trackId: trackId });\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to add video track: \" + e.message });\n    }\n}\n\nfunction addAudioTrack() {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for adding tracks\" });\n    }\n    try {\n        var trackId = qe.project.getActiveSequence().numAudioTracks;\n        qe.project.getActiveSequence().addTracks(0, 0, 1, 1, trackId);\n        return JSON.stringify({ success: true, trackId: trackId });\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to add audio track: \" + e.message });\n    }\n}\n\nfunction removeVideoTrack(trackIndex) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for removing tracks\" });\n    }\n    try {\n        qe.project.getActiveSequence().removeVideoTrack(trackIndex);\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to remove video track: \" + e.message });\n    }\n}\n\nfunction removeAudioTrack(trackIndex) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for removing tracks\" });\n    }\n    try {\n        qe.project.getActiveSequence().removeAudioTrack(trackIndex);\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: \"Failed to remove audio track: \" + e.message });\n    }\n}\n\n// ============================================================================\n// MUTE STATE\n// ============================================================================\n\nfunction getMuteState() {\n    var mute_state_video = [];\n    for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n        mute_state_video.push(app.project.activeSequence.videoTracks[i].isMuted());\n    }\n    var mute_state_audio = [];\n    for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n        mute_state_audio.push(app.project.activeSequence.audioTracks[i].isMuted());\n    }\n    return JSON.stringify({ audio: mute_state_audio, video: mute_state_video });\n}\n\nfunction setMuteState(mute_state) {\n    mute_state = JSON.parse(mute_state);\n    for (var i = 0; i < app.project.activeSequence.videoTracks.numTracks; i++) {\n        if (i < mute_state.video.length) {\n            app.project.activeSequence.videoTracks[i].setMute(mute_state.video[i]);\n        }\n    }\n    for (var i = 0; i < app.project.activeSequence.audioTracks.numTracks; i++) {\n        if (i < mute_state.audio.length) {\n            app.project.activeSequence.audioTracks[i].setMute(mute_state.audio[i]);\n        }\n    }\n    return true;\n}\n\n// ============================================================================\n// PROJECT ITEM OPERATIONS\n// ============================================================================\n\nfunction findItemByName(bin, name) {\n    for (var i = 0; i < bin.children.numItems; i++) {\n        if (bin.children[i].name === name) {\n            return bin.children[i];\n        }\n        if (bin.children[i].children !== undefined) {\n            var item = findItemByName(bin.children[i], name);\n            if (item) return item;\n        }\n    }\n    return null;\n}\n\nfunction findItemByPath(bin, path) {\n    for (var i = 0; i < bin.children.numItems; i++) {\n        var item = bin.children[i];\n        if (item.getMediaPath && item.getMediaPath() === path) {\n            return item;\n        }\n        if (item.children !== undefined) {\n            var found = findItemByPath(item, path);\n            if (found) return found;\n        }\n    }\n    return null;\n}\n\nfunction importFile(filePath) {\n    try {\n        var success = app.project.importFiles([filePath], true, app.project.rootItem, false);\n        if (success) {\n            // Find the imported item\n            var item = findItemByPath(app.project.rootItem, filePath);\n            return JSON.stringify({\n                success: true,\n                nodeId: item ? item.nodeId : null\n            });\n        }\n        return JSON.stringify({ error: \"Import failed\" });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction getSpliceBin() {\n    var rootItemChildren = app.project.rootItem.children;\n    var spliceBin = null;\n\n    for (var i = 0; i < rootItemChildren.numItems; i++) {\n        if (rootItemChildren[i].name === \"SPLICE\" && rootItemChildren[i].type === 2) {\n            spliceBin = rootItemChildren[i];\n            break;\n        }\n    }\n\n    if (!spliceBin) {\n        app.project.rootItem.createBin(\"SPLICE\");\n        return getSpliceBin();\n    }\n\n    return spliceBin;\n}\n\nfunction getAllProjectItems() {\n    var items = [];\n\n    function collectItems(bin, path) {\n        for (var i = 0; i < bin.children.numItems; i++) {\n            var item = bin.children[i];\n            var itemPath = path + \"/\" + item.name;\n\n            items.push({\n                nodeId: item.nodeId,\n                name: item.name,\n                type: item.type,\n                treePath: itemPath,\n                mediaPath: item.getMediaPath ? item.getMediaPath() : null\n            });\n\n            if (item.children !== undefined && item.type === 2) {\n                collectItems(item, itemPath);\n            }\n        }\n    }\n\n    collectItems(app.project.rootItem, \"\");\n    return JSON.stringify(items);\n}\n\n// ============================================================================\n// CLIP INSERTION\n// ============================================================================\n\nfunction insertClipAtTime(projectItemNodeId, trackIndex, startSeconds, trackType) {\n    try {\n        var item = findItemByNodeId(app.project.rootItem, projectItemNodeId);\n        if (!item) {\n            return JSON.stringify({ error: \"Project item not found\" });\n        }\n\n        var targetTime = new Time();\n        targetTime.seconds = startSeconds;\n\n        if (trackType === \"video\") {\n            app.project.activeSequence.videoTracks[trackIndex].insertClip(item, targetTime);\n        } else if (trackType === \"audio\") {\n            app.project.activeSequence.audioTracks[trackIndex].insertClip(item, targetTime);\n        }\n\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction findItemByNodeId(bin, nodeId) {\n    for (var i = 0; i < bin.children.numItems; i++) {\n        if (bin.children[i].nodeId === nodeId) {\n            return bin.children[i];\n        }\n        if (bin.children[i].children !== undefined) {\n            var found = findItemByNodeId(bin.children[i], nodeId);\n            if (found) return found;\n        }\n    }\n    return null;\n}\n\n// ============================================================================\n// MARKER OPERATIONS\n// ============================================================================\n\nfunction createMarker(timeSeconds, name, duration, comments, colorIndex) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var marker = markers.createMarker(timeSeconds);\n\n        if (name) marker.name = name;\n        if (comments) marker.comments = comments;\n        if (colorIndex !== undefined) marker.setColorByIndex(colorIndex);\n        if (duration && duration > 0) {\n            // Set marker end time properly using a Time object\n            var endTime = new Time();\n            endTime.seconds = marker.start.seconds + duration;\n            marker.end = endTime;\n        }\n\n        return JSON.stringify({\n            success: true,\n            guid: marker.guid\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction getMarkers() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var result = [];\n\n        for (var i = 0; i < markers.numMarkers; i++) {\n            var marker = markers[i];\n            result.push({\n                guid: marker.guid,\n                name: marker.name,\n                comments: marker.comments,\n                start: marker.start.seconds,\n                end: marker.end.seconds,\n                type: marker.type\n            });\n        }\n\n        return JSON.stringify(result);\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction deleteMarker(markerGuid) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        for (var i = 0; i < markers.numMarkers; i++) {\n            if (markers[i].guid === markerGuid) {\n                markers[i].remove();\n                return JSON.stringify({ success: true });\n            }\n        }\n        return JSON.stringify({ error: \"Marker not found\" });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction deleteAllMarkers() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var count = markers.numMarkers;\n\n        // Delete from end to beginning to avoid index shifting\n        for (var i = count - 1; i >= 0; i--) {\n            markers[i].remove();\n        }\n\n        return JSON.stringify({ success: true, deleted: count });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction deleteMarkersByName(namePattern) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var deleted = 0;\n\n        for (var i = markers.numMarkers - 1; i >= 0; i--) {\n            if (markers[i].name && markers[i].name.indexOf(namePattern) !== -1) {\n                markers[i].remove();\n                deleted++;\n            }\n        }\n\n        return JSON.stringify({ success: true, deleted: deleted });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// COLOR LABEL OPERATIONS\n// ============================================================================\n\nfunction setClipColorLabel(trackType, trackIndex, clipIndex, colorIndex) {\n    try {\n        var clip;\n        if (trackType == \"video\") {\n            clip = app.project.activeSequence.videoTracks[trackIndex].clips[clipIndex];\n        } else if (trackType == \"audio\") {\n            clip = app.project.activeSequence.audioTracks[trackIndex].clips[clipIndex];\n        }\n\n        if (clip && clip.projectItem) {\n            clip.projectItem.setColorLabel(colorIndex);\n        }\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction setProjectItemColorLabel(nodeId, colorIndex) {\n    try {\n        var item = findItemByNodeId(app.project.rootItem, nodeId);\n        if (item) {\n            item.setColorLabel(colorIndex);\n            return JSON.stringify({ success: true });\n        }\n        return JSON.stringify({ error: \"Item not found\" });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// SEQUENCE BUILDING (CORE v3.5 FUNCTIONALITY)\n// ============================================================================\n\nfunction buildSequenceFromCutList(cutListJson) {\n    try {\n        var cutList = JSON.parse(cutListJson);\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Clone the sequence\n        var newSequenceName = seq.name + \"_SPLICE\";\n        seq.clone();\n\n        // Find the cloned sequence\n        var newSeq = null;\n        for (var i = app.project.sequences.numSequences - 1; i >= 0; i--) {\n            var s = app.project.sequences[i];\n            if (s.name.indexOf(seq.name) === 0 && s.sequenceID !== seq.sequenceID) {\n                newSeq = s;\n                break;\n            }\n        }\n\n        if (!newSeq) {\n            return JSON.stringify({ error: \"Failed to clone sequence\" });\n        }\n\n        newSeq.name = newSequenceName;\n        app.project.activeSequence = newSeq;\n\n        // Clear all clips from the new sequence\n        clearSequence();\n\n        // Insert segments\n        var currentPosition = 0;\n        var stats = {\n            segmentsInserted: 0,\n            totalDuration: 0\n        };\n\n        for (var i = 0; i < cutList.segments.length; i++) {\n            var segment = cutList.segments[i];\n\n            // Find the source project item\n            var sourceItem = null;\n            if (segment.sourcePath) {\n                sourceItem = findItemByPath(app.project.rootItem, segment.sourcePath);\n            }\n            if (!sourceItem && segment.sourceName) {\n                sourceItem = findItemByName(app.project.rootItem, segment.sourceName);\n            }\n\n            if (!sourceItem) continue;\n\n            // Set color label\n            if (segment.colorHint && SEGMENT_COLORS[segment.colorHint]) {\n                sourceItem.setColorLabel(SEGMENT_COLORS[segment.colorHint]);\n            } else if (segment.type && SEGMENT_COLORS[segment.type]) {\n                sourceItem.setColorLabel(SEGMENT_COLORS[segment.type]);\n            }\n\n            // Insert clip at current position\n            var targetTime = new Time();\n            targetTime.seconds = currentPosition;\n\n            newSeq.videoTracks[0].insertClip(sourceItem, targetTime);\n\n            // Set in/out points\n            var clipDuration = segment.outPoint - segment.inPoint;\n            var videoClips = newSeq.videoTracks[0].clips;\n            var insertedClip = videoClips[videoClips.numItems - 1];\n\n            if (insertedClip) {\n                var inTime = new Time();\n                inTime.seconds = segment.inPoint;\n                insertedClip.inPoint = inTime;\n\n                var outTime = new Time();\n                outTime.seconds = segment.outPoint;\n                insertedClip.outPoint = outTime;\n\n                // Set clip name if takeLabel provided\n                if (segment.takeLabel) {\n                    insertedClip.name = segment.takeLabel;\n                }\n            }\n\n            currentPosition += clipDuration;\n            stats.segmentsInserted++;\n            stats.totalDuration += clipDuration;\n        }\n\n        return JSON.stringify({\n            success: true,\n            sequenceName: newSequenceName,\n            stats: stats\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction clearSequence() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var removed = { video: 0, audio: 0 };\n\n        // Remove all video clips\n        for (var t = 0; t < seq.videoTracks.numTracks; t++) {\n            var clips = seq.videoTracks[t].clips;\n            for (var i = clips.numItems - 1; i >= 0; i--) {\n                clips[i].remove(false, false);\n                removed.video++;\n            }\n        }\n\n        // Remove all audio clips\n        for (var t = 0; t < seq.audioTracks.numTracks; t++) {\n            var clips = seq.audioTracks[t].clips;\n            for (var i = clips.numItems - 1; i >= 0; i--) {\n                clips[i].remove(false, false);\n                removed.audio++;\n            }\n        }\n\n        $.writeln('[SPLICE] clearSequence: Removed ' + removed.video + ' video clips, ' + removed.audio + ' audio clips');\n        return JSON.stringify({ success: true, removed: removed });\n    } catch (e) {\n        $.writeln('[SPLICE] clearSequence error: ' + e.message);\n        return JSON.stringify({ error: \"Clear sequence failed: \" + e.message });\n    }\n}\n\n// ============================================================================\n// WORK AREA\n// ============================================================================\n\nfunction getWorkArea() {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    return JSON.stringify({\n        inPoint: seq.getInPoint(),\n        outPoint: seq.getOutPoint()\n    });\n}\n\nfunction setWorkArea(inPoint, outPoint) {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    seq.setInPoint(inPoint);\n    seq.setOutPoint(outPoint);\n    return JSON.stringify({ success: true });\n}\n\n// ============================================================================\n// AUDIO EXPORT\n// ============================================================================\n\nfunction exportSequenceAudio(outputPath, inPoint, outPoint) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Use the AME (Adobe Media Encoder) for export\n        var encoder = app.encoder;\n        if (!encoder) {\n            return JSON.stringify({ error: \"Media Encoder not available\" });\n        }\n\n        // Create export preset for WAV\n        var presetPath = encoder.getDefaultPresetPath();\n\n        // Queue the export\n        encoder.encodeSequence(\n            seq,\n            outputPath,\n            presetPath,\n            0, // WorkAreaType: 0 = entire, 1 = work area\n            false // removeOnCompletion\n        );\n\n        return JSON.stringify({ success: true, outputPath: outputPath });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n/**\n * Export sequence audio for SPLICE analysis\n * Uses AME to export WAV audio to temp folder\n * @returns {Object} { success, outputPath } or { error }\n */\nfunction exportSequenceAudioForAnalysis() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Generate temp file path\n        var tempFolder = Folder.temp.fsName;\n        var timestamp = new Date().getTime();\n        var outputPath = tempFolder + \"/splice_audio_\" + timestamp + \".wav\";\n\n        // Check if we have audio tracks with content\n        var hasAudio = false;\n        for (var i = 0; i < seq.audioTracks.numTracks; i++) {\n            if (seq.audioTracks[i].clips.numItems > 0) {\n                hasAudio = true;\n                break;\n            }\n        }\n\n        if (!hasAudio) {\n            return JSON.stringify({ error: \"Sequence has no audio clips\" });\n        }\n\n        // Use AME for export if available\n        if (app.encoder && app.encoder.encodeSequence) {\n            // Find audio-only preset or use default\n            var presetPath = null;\n            try {\n                // Try to find WAV preset in common locations\n                var presetFolders = [\n                    Folder.appData.fsName + \"/Adobe/Common/AME/15.0/Presets\",\n                    Folder.appData.fsName + \"/Adobe/Common/AME/14.0/Presets\",\n                    app.path + \"/MediaIO/systempresets/58534430_4d756c74-6962697400000000/WAV 48kHz.epr\"\n                ];\n\n                for (var i = 0; i < presetFolders.length; i++) {\n                    var presetFile = new File(presetFolders[i]);\n                    if (presetFile.exists) {\n                        presetPath = presetFile.fsName;\n                        break;\n                    }\n                }\n\n                // Fall back to default preset\n                if (!presetPath) {\n                    presetPath = app.encoder.getDefaultPresetPath();\n                }\n            } catch (e) {\n                presetPath = app.encoder.getDefaultPresetPath();\n            }\n\n            // Start the encode\n            var success = app.encoder.encodeSequence(\n                seq,\n                outputPath,\n                presetPath,\n                0, // WorkAreaType: 0 = entire sequence\n                false // removeOnCompletion\n            );\n\n            if (success) {\n                return JSON.stringify({ success: true, outputPath: outputPath, method: \"ame\" });\n            }\n        }\n\n        // Fallback: Try to get the source audio path from first clip\n        return getFirstClipAudioPath();\n\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n/**\n * Get the audio/video file path from the first clip in the timeline\n * Used as fallback when AME export is not available\n * @returns {Object} { success, path } or { error }\n */\nfunction getFirstClipAudioPath() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // First try audio tracks\n        for (var i = 0; i < seq.audioTracks.numTracks; i++) {\n            var track = seq.audioTracks[i];\n            if (track.clips.numItems > 0) {\n                var clip = track.clips[0];\n                if (clip.projectItem && clip.projectItem.getMediaPath) {\n                    var mediaPath = clip.projectItem.getMediaPath();\n                    if (mediaPath && mediaPath.length > 0) {\n                        return JSON.stringify({ success: true, path: mediaPath, method: \"audio_track\" });\n                    }\n                }\n            }\n        }\n\n        // Fall back to video tracks (which may have linked audio)\n        for (var i = 0; i < seq.videoTracks.numTracks; i++) {\n            var track = seq.videoTracks[i];\n            if (track.clips.numItems > 0) {\n                var clip = track.clips[0];\n                if (clip.projectItem && clip.projectItem.getMediaPath) {\n                    var mediaPath = clip.projectItem.getMediaPath();\n                    if (mediaPath && mediaPath.length > 0) {\n                        return JSON.stringify({ success: true, path: mediaPath, method: \"video_track\" });\n                    }\n                }\n            }\n        }\n\n        return JSON.stringify({ error: \"No clips with media paths found in sequence\" });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\nfunction moveClipByNTracks(currentTrackId, clipStartTime, nTracksToMove, trackType) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for moving clips between tracks\" });\n    }\n\n    try {\n        var accuracy = 3;\n        var search_start_time = clipStartTime.toFixed(accuracy);\n\n        if (trackType == \"audio\") {\n            var numClipsInTrack = qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).numItems;\n            for (var j = 0; j < numClipsInTrack; j++) {\n                if (qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).getItemAt(j).start.secs.toFixed(accuracy) == search_start_time) {\n                    qe.project.getActiveSequence().getAudioTrackAt(currentTrackId).getItemAt(j).moveToTrack(0, nTracksToMove, \"0\");\n                    return JSON.stringify({ success: true });\n                }\n            }\n        } else if (trackType == \"video\") {\n            var numClipsInTrack = qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).numItems;\n            for (var j = 0; j < numClipsInTrack; j++) {\n                if (qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).getItemAt(j).start.secs.toFixed(accuracy) == search_start_time) {\n                    qe.project.getActiveSequence().getVideoTrackAt(currentTrackId).getItemAt(j).moveToTrack(nTracksToMove, 0, \"0\");\n                    return JSON.stringify({ success: true });\n                }\n            }\n        }\n        return JSON.stringify({ error: \"Clip not found at specified time\" });\n    } catch (e) {\n        return JSON.stringify({ error: \"Move clip failed: \" + e.message });\n    }\n}\n\nfunction linkIdenticalClipsInTracks(videoTrackIndex, audioTrackIndex) {\n    var selected_clips = app.project.activeSequence.getSelection();\n    for (var i = 0; i < selected_clips.length; i++) {\n        selected_clips[i].setSelected(false, false);\n    }\n\n    var video_clips = app.project.activeSequence.videoTracks[videoTrackIndex].clips;\n    var audio_clips = app.project.activeSequence.audioTracks[audioTrackIndex].clips;\n\n    for (var i = 0; i < video_clips.numItems; i++) {\n        var video_clip = video_clips[i];\n        var video_start = video_clip.start.seconds;\n\n        for (var j = 0; j < audio_clips.numItems; j++) {\n            var audio_clip = audio_clips[j];\n            var audio_start = audio_clip.start.seconds;\n\n            if (Math.abs(video_start - audio_start) < time_tolerance) {\n                video_clip.setSelected(true, false);\n                audio_clip.setSelected(true, false);\n                app.project.activeSequence.linkSelection();\n                video_clip.setSelected(false, false);\n                audio_clip.setSelected(false, false);\n                break;\n            }\n        }\n    }\n    return true;\n}\n\n// ============================================================================\n// ZOOM OPERATIONS (Phase 3)\n// ============================================================================\n\nfunction addZoomMarker(startSeconds, scale, duration, easing) {\n    try {\n        var name = \"ZOOM: \" + scale + \"%\";\n        var comments = \"Duration: \" + duration + \"s | Easing: \" + (easing || \"ease-in-out\");\n        return createMarker(startSeconds, name, duration, comments, COLOR_LABELS.YELLOW);\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// CHAPTER OPERATIONS (Phase 3)\n// ============================================================================\n\nfunction addChapterMarker(timeSeconds, title, description) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var marker = markers.createMarker(timeSeconds);\n\n        marker.name = title;\n        if (description) marker.comments = description;\n        marker.setColorByIndex(COLOR_LABELS.BLUE);\n        marker.setTypeAsChapter();\n\n        return JSON.stringify({\n            success: true,\n            guid: marker.guid\n        });\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\nfunction getChapterMarkers() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        var markers = seq.markers;\n        var chapters = [];\n\n        for (var i = 0; i < markers.numMarkers; i++) {\n            var marker = markers[i];\n            if (marker.type === \"Chapter\") {\n                chapters.push({\n                    guid: marker.guid,\n                    name: marker.name,\n                    comments: marker.comments,\n                    start: marker.start.seconds\n                });\n            }\n        }\n\n        return JSON.stringify(chapters);\n    } catch (e) {\n        return JSON.stringify({ error: e.message });\n    }\n}\n\n// ============================================================================\n// UNDO OPERATIONS\n// ============================================================================\n\nfunction undo() {\n    app.project.undo();\n    return true;\n}\n\nfunction redo() {\n    app.project.redo();\n    return true;\n}\n\n// ============================================================================\n// DEBUG / LOGGING\n// ============================================================================\n\nfunction log(message) {\n    $.writeln(\"[SPLICE] \" + message);\n}\n\nfunction getDebugInfo() {\n    return JSON.stringify({\n        version: SPLICE_VERSION,\n        hasActiveSequence: app.project.activeSequence ? true : false,\n        sequenceName: app.project.activeSequence ? app.project.activeSequence.name : null,\n        numSequences: app.project.sequences.numSequences,\n        numProjectItems: app.project.rootItem.children.numItems\n    });\n}\n\n// NOTE: Do NOT auto-initialize on load - CEP will call initialise() explicitly\n// when the panel is ready. Auto-initialization can fail if no project is open.\n$.writeln('[SPLICE] hostScript.jsx loaded - version ' + SPLICE_VERSION);\n","numLines":1838,"startLine":1,"totalLines":1838}}}
{"parentUuid":"126a1b03-f3b7-442f-8a22-224f2a2f2258","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/SPLICE","sessionId":"5f015cfc-0476-4608-91d9-cf0946100ba2","version":"2.0.76","gitBranch":"main","agentId":"a48d1a4","slug":"fizzy-hatching-flame","message":{"model":"claude-opus-4-5-20251101","id":"msg_0111KHsUfauqKcTL1nmAYFxR","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have the full `hostScript.jsx` file. Let me analyze the failing functions compared to the working `checkSequenceOpen()` function.\n\n## Bug Summary\nThe `getActiveSequence()` and `getAllSequences()` functions may be failing due to missing try/catch blocks, improper error handling, and differences in how they access the Premiere Pro DOM compared to the working `checkSequenceOpen()` function.\n\n## Analysis Report\n\n### 1. `checkSequenceOpen()` (Lines 296-376) - WORKING FUNCTION\n\nThis function **works** because it has:\n- Comprehensive try/catch wrapper (line 297-375)\n- Null checks for `app`, `app.project`, `app.project.sequences` before accessing them\n- Detailed diagnostic logging via `$.writeln()`\n- Returns a simple boolean (not JSON)\n- Falls back to QE DOM if standard DOM fails\n\n### 2. `getActiveSequence()` (Lines 491-505) - POTENTIALLY FAILING\n\n**Issues Found:**\n\n1. **NO try/catch block** - If any property access fails, the entire function throws an unhandled exception\n2. **No null/undefined checks** before accessing nested properties like `seq.videoTracks.numTracks`\n3. **Direct JSON.stringify of object** - If `seq.getSettings()` throws, it crashes\n\n```javascript\n// Line 491-505 - NO ERROR HANDLING\nfunction getActiveSequence() {\n    var seq = app.project.activeSequence;\n    if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n    return JSON.stringify({\n        name: seq.name,\n        id: seq.sequenceID,\n        duration: seq.end,  // seq.end might not exist or return undefined\n        videoTrackCount: seq.videoTracks.numTracks,  // Could fail if videoTracks is undefined\n        audioTrackCount: seq.audioTracks.numTracks,  // Could fail if audioTracks is undefined  \n        frameRate: seq.getSettings().videoFrameRate.seconds,  // getSettings() could throw\n        width: seq.frameSizeHorizontal,\n        height: seq.frameSizeVertical\n    });\n}\n```\n\n**Root Cause**: Missing try/catch and nested property access without validation.\n\n### 3. `getAllSequences()` - FUNCTION DOES NOT EXIST\n\nI searched the entire file and **there is no `getAllSequences()` function defined**. This would definitely cause an EvalScript error if called.\n\n### 4. Other QE DOM Functions That Could Fail\n\nLooking at functions that access `qe.project.getActiveSequence()`:\n\n#### `razorSequenceAtFrames()` (Lines 620-632)\n```javascript\nfunction razorSequenceAtFrames(frames) {\n    if (!isQEAvailable() && !enableQE()) {\n        return JSON.stringify({ error: \"QE not available for razor operation\" });\n    }\n    try {\n        frames = String(frames);\n        setTimecodeToFrames();\n        qe.project.getActiveSequence().razor(frames);  // Can fail if no active sequence in QE\n        return JSON.stringify({ success: true });\n    } catch (e) {\n        return JSON.stringify({ error: \"Razor failed: \" + e.message });\n    }\n}\n```\n**Issue**: Does check for QE availability but doesn't check if `getActiveSequence()` returns null.\n\n#### `getTrackNames()` (Lines 944-979)\n```javascript\nfunction getTrackNames(trackType) {\n    // ... fallback code ...\n    try {\n        var ret = [];\n        if (trackType == \"video\") {\n            for (var i = 0; i < qe.project.getActiveSequence().numVideoTracks; i++) {\n                ret.push(qe.project.getActiveSequence().getVideoTrackAt(i).name);\n            }\n        }\n        // ...\n    }\n}\n```\n**Issue**: Calls `qe.project.getActiveSequence()` multiple times in a loop without caching or null check.\n\n### 5. Comparison: Why `checkSequenceOpen()` Works\n\n| Aspect | `checkSequenceOpen()` | `getActiveSequence()` |\n|--------|----------------------|----------------------|\n| Try/catch | Yes (line 297) | **NO** |\n| Null checks before access | Yes (lines 301-318) | Partial (only seq) |\n| Validates nested properties | Yes | **NO** |\n| Error logging | Yes (`$.writeln`) | **NO** |\n| Return type on error | `false` | JSON error string |\n| QE fallback | Yes | **NO** |\n\n## Trace Path\n\n1. Panel calls `jsx.evalScript('getActiveSequence()')`\n2. ExtendScript engine executes `getActiveSequence()`\n3. `app.project.activeSequence` returns a sequence object\n4. Accessing `seq.getSettings().videoFrameRate.seconds` throws if `getSettings()` returns null/undefined\n5. OR accessing `seq.videoTracks.numTracks` throws if `videoTracks` is undefined\n6. No try/catch catches the error\n7. ExtendScript engine returns error to CEP panel\n8. CEP interprets this as an EvalScript error\n\n## Fix\n\nHere's the corrected `getActiveSequence()` function:\n\n```javascript\nfunction getActiveSequence() {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n\n        // Safely get settings\n        var settings = null;\n        var frameRate = null;\n        try {\n            settings = seq.getSettings();\n            if (settings && settings.videoFrameRate) {\n                frameRate = settings.videoFrameRate.seconds;\n            }\n        } catch (settingsErr) {\n            $.writeln('[SPLICE] getActiveSequence: Failed to get settings: ' + settingsErr.message);\n        }\n\n        return JSON.stringify({\n            name: seq.name || \"Unknown\",\n            id: seq.sequenceID || null,\n            duration: seq.end || 0,\n            videoTrackCount: seq.videoTracks ? seq.videoTracks.numTracks : 0,\n            audioTrackCount: seq.audioTracks ? seq.audioTracks.numTracks : 0,\n            frameRate: frameRate,\n            width: seq.frameSizeHorizontal || 0,\n            height: seq.frameSizeVertical || 0\n        });\n    } catch (e) {\n        $.writeln('[SPLICE] getActiveSequence error: ' + e.message);\n        return JSON.stringify({ error: \"getActiveSequence failed: \" + e.message });\n    }\n}\n```\n\n## Missing Function: `getAllSequences()`\n\nThis function needs to be created:\n\n```javascript\nfunction getAllSequences() {\n    try {\n        if (!app || !app.project || !app.project.sequences) {\n            return JSON.stringify({ error: \"No project open\" });\n        }\n\n        var sequences = [];\n        var numSeqs = app.project.sequences.numSequences;\n\n        for (var i = 0; i < numSeqs; i++) {\n            var seq = app.project.sequences[i];\n            if (seq) {\n                sequences.push({\n                    name: seq.name || \"Unknown\",\n                    id: seq.sequenceID || null,\n                    index: i\n                });\n            }\n        }\n\n        return JSON.stringify({\n            count: sequences.length,\n            sequences: sequences\n        });\n    } catch (e) {\n        $.writeln('[SPLICE] getAllSequences error: ' + e.message);\n        return JSON.stringify({ error: \"getAllSequences failed: \" + e.message });\n    }\n}\n```\n\n## Prevention\n\n1. **Add try/catch to ALL functions** that access Premiere Pro DOM\n2. **Add null checks** before accessing nested properties\n3. **Add diagnostic logging** via `$.writeln()` for debugging\n4. **Cache QE sequence reference** instead of calling `qe.project.getActiveSequence()` multiple times\n5. **Create a pattern/template** for new functions:\n\n```javascript\nfunction myFunction(param) {\n    try {\n        var seq = app.project.activeSequence;\n        if (!seq) return JSON.stringify({ error: \"No active sequence\" });\n        \n        // Function logic here\n        \n        return JSON.stringify({ success: true, data: result });\n    } catch (e) {\n        $.writeln('[SPLICE] myFunction error: ' + e.message);\n        return JSON.stringify({ error: \"myFunction failed: \" + e.message });\n    }\n}\n```"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":24609,"cache_read_input_tokens":29234,"cache_creation":{"ephemeral_5m_input_tokens":24609,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX37j1KLfSm6RbnKmznqy","type":"assistant","uuid":"7aac308b-2ed8-481a-9839-513ad1c9576b","timestamp":"2026-01-12T07:49:40.122Z"}
