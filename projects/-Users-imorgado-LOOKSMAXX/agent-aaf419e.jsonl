{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX","sessionId":"e587686a-bce3-4666-abc5-b08c2aebde91","version":"2.0.70","gitBranch":"","agentId":"aaf419e","type":"user","message":{"role":"user","content":"Thoroughly analyze /Users/imorgado/LOOKSMAXX/TECHNICAL_SPECS.md focusing on: Angular measurements (Nasolabial, Nasofrontal, Gonial, Mentolabial angles), their definitions, reference points, and any ideal/normal ranges mentioned. Extract all details about how these angles should be calculated."},"uuid":"3b5c8d27-c6b5-4ce7-ad8f-5fdd870082a1","timestamp":"2025-12-18T02:37:13.242Z"}
{"parentUuid":"3b5c8d27-c6b5-4ce7-ad8f-5fdd870082a1","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX","sessionId":"e587686a-bce3-4666-abc5-b08c2aebde91","version":"2.0.70","gitBranch":"","agentId":"aaf419e","slug":"humming-honking-locket","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012pBKzNYDeKsaGCgg2H1j9P","type":"message","role":"assistant","content":[{"type":"text","text":"I'll analyze the TECHNICAL_SPECS.md file to extract detailed information about the Angular measurements you're interested in."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":9804,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":9804,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWDNihSNDzQ26uYiuJugd","type":"assistant","uuid":"5c5067cf-44c7-4d5b-93ba-52512a5b6fbc","timestamp":"2025-12-18T02:37:14.952Z"}
{"parentUuid":"5c5067cf-44c7-4d5b-93ba-52512a5b6fbc","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX","sessionId":"e587686a-bce3-4666-abc5-b08c2aebde91","version":"2.0.70","gitBranch":"","agentId":"aaf419e","slug":"humming-honking-locket","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012pBKzNYDeKsaGCgg2H1j9P","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017QpidBrDWbPE42m2wPuETT","name":"Read","input":{"file_path":"/Users/imorgado/LOOKSMAXX/TECHNICAL_SPECS.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":9804,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":9804,"ephemeral_1h_input_tokens":0},"output_tokens":98,"service_tier":"standard"}},"requestId":"req_011CWDNihSNDzQ26uYiuJugd","type":"assistant","uuid":"6dd72f6b-d8aa-491f-a754-0e3e767c2392","timestamp":"2025-12-18T02:37:15.172Z"}
{"parentUuid":"6dd72f6b-d8aa-491f-a754-0e3e767c2392","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX","sessionId":"e587686a-bce3-4666-abc5-b08c2aebde91","version":"2.0.70","gitBranch":"","agentId":"aaf419e","slug":"humming-honking-locket","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017QpidBrDWbPE42m2wPuETT","type":"tool_result","content":"     1→# FaceIQ Labs - Technical Specification Document\n     2→## Reverse-Engineered Facial Analysis System\n     3→\n     4→**Document Version:** 1.0\n     5→**Date:** December 2024\n     6→**Source:** Reverse-engineered from beta.faceiqlabs.com\n     7→\n     8→---\n     9→\n    10→## Table of Contents\n    11→\n    12→1. [System Architecture](#1-system-architecture)\n    13→2. [Data Flow Pipeline](#2-data-flow-pipeline)\n    14→3. [Core Scoring Engine](#3-core-scoring-engine)\n    15→4. [Landmark Detection System](#4-landmark-detection-system)\n    16→5. [Ratio Calculation Functions](#5-ratio-calculation-functions)\n    17→6. [Decoded Scoring Standards Database](#6-decoded-scoring-standards-database)\n    18→7. [Implementation Strategy](#7-implementation-strategy)\n    19→8. [API Reference](#8-api-reference)\n    20→\n    21→---\n    22→\n    23→## 1. System Architecture\n    24→\n    25→### 1.1 Hybrid Processing Model\n    26→\n    27→The system uses a **hybrid architecture** that splits processing between client and server:\n    28→\n    29→```\n    30→┌─────────────────────────────────────────────────────────────────────────────┐\n    31→│                           FACIAL ANALYSIS SYSTEM                            │\n    32→├─────────────────────────────────────────────────────────────────────────────┤\n    33→│                                                                             │\n    34→│  ┌─────────────────────────────┐    ┌─────────────────────────────────┐   │\n    35→│  │     CLIENT-SIDE (Browser)   │    │      SERVER-SIDE (API)          │   │\n    36→│  ├─────────────────────────────┤    ├─────────────────────────────────┤   │\n    37→│  │                             │    │                                 │   │\n    38→│  │  ┌───────────────────────┐  │    │  ┌───────────────────────────┐ │   │\n    39→│  │  │   MediaPipe WASM      │  │    │  │  Custom Landmark Model    │ │   │\n    40→│  │  │   FaceLandmarker      │  │    │  │  (Side Profile)           │ │   │\n    41→│  │  └───────────────────────┘  │    │  └───────────────────────────┘ │   │\n    42→│  │            │                │    │              │                 │   │\n    43→│  │            ▼                │    │              ▼                 │   │\n    44→│  │  ┌───────────────────────┐  │    │  ┌───────────────────────────┐ │   │\n    45→│  │  │  478 Facial Landmarks │  │    │  │  106 Side Landmarks       │ │   │\n    46→│  │  │  (Front Profile)      │  │    │  │  + Rotation Data          │ │   │\n    47→│  │  └───────────────────────┘  │    │  └───────────────────────────┘ │   │\n    48→│  │            │                │    │              │                 │   │\n    49→│  │            ▼                │    │              ▼                 │   │\n    50→│  │  ┌───────────────────────┐  │    │  ┌───────────────────────────┐ │   │\n    51→│  │  │  Ratio Calculations   │  │    │  │  Scoring Engine           │ │   │\n    52→│  │  │  (JavaScript)         │  │    │  │  (Server-side)            │ │   │\n    53→│  │  └───────────────────────┘  │    │  └───────────────────────────┘ │   │\n    54→│  │                             │    │                                 │   │\n    55→│  └─────────────────────────────┘    └─────────────────────────────────┘   │\n    56→│                                                                             │\n    57→└─────────────────────────────────────────────────────────────────────────────┘\n    58→```\n    59→\n    60→### 1.2 Component Responsibilities\n    61→\n    62→| Component | Location | Responsibility |\n    63→|-----------|----------|----------------|\n    64→| MediaPipe FaceLandmarker | Client (WASM) | Detect 478 landmarks on front-facing images |\n    65→| Side Landmark API | Server | Detect landmarks on side profile images |\n    66→| Landmark Mapper | Client | Convert raw indices to named anatomical points |\n    67→| Ratio Calculator | Client | Compute facial ratios from landmark coordinates |\n    68→| Scoring Engine | Server | Apply exponential decay scoring with ideal ranges |\n    69→| Standards Database | Server | Store ideal min/max values for all ratios |\n    70→\n    71→---\n    72→\n    73→## 2. Data Flow Pipeline\n    74→\n    75→### 2.1 Complete Processing Flow\n    76→\n    77→```\n    78→┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐\n    79→│   CAPTURE    │────▶│   DETECT     │────▶│  CALCULATE   │────▶│    SCORE     │\n    80→│   Image      │     │  Landmarks   │     │   Ratios     │     │   Results    │\n    81→└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘\n    82→       │                    │                    │                    │\n    83→       ▼                    ▼                    ▼                    ▼\n    84→  Front Photo         478 Points            50+ Ratios          0-10 Scores\n    85→  Side Photo          106 Points           (angles, %)         + Deviation\n    86→```\n    87→\n    88→### 2.2 Front Profile Pipeline\n    89→\n    90→```javascript\n    91→// Step 1: Initialize MediaPipe FaceLandmarker\n    92→const faceLandmarker = await FaceLandmarker.createFromModelPath(\n    93→    wasmFileset,\n    94→    \"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task\"\n    95→);\n    96→\n    97→// Step 2: Detect landmarks\n    98→const results = faceLandmarker.detect(imageElement);\n    99→const landmarks = results.faceLandmarks[0]; // Array of 478 {x, y, z} points\n   100→\n   101→// Step 3: Map to named points\n   102→const namedLandmarks = mapLandmarksToNames(landmarks, imageWidth, imageHeight);\n   103→\n   104→// Step 4: Calculate ratios\n   105→const ratios = calculateAllRatios(namedLandmarks, \"front\");\n   106→\n   107→// Step 5: Score each ratio\n   108→const scores = ratios.map(r => ({\n   109→    name: r.name,\n   110→    value: r.value,\n   111→    score: calculateScore(r.value, r.idealMin, r.idealMax, r.decayRate)\n   112→}));\n   113→```\n   114→\n   115→### 2.3 Side Profile Pipeline\n   116→\n   117→```javascript\n   118→// Step 1: Upload image to server\n   119→const formData = new FormData();\n   120→formData.append(\"image\", imageBlob, \"side.jpg\");\n   121→\n   122→// Step 2: Server detects landmarks\n   123→const response = await fetch(\"/api/side-landmarks\", {\n   124→    method: \"POST\",\n   125→    body: formData\n   126→});\n   127→\n   128→// Step 3: Receive landmark data\n   129→const { landmarks, direction, rotationAngle, bbox } = await response.json();\n   130→\n   131→// Step 4: Map to named anatomical points\n   132→const namedLandmarks = mapSideLandmarksToNames(landmarks, imageWidth, imageHeight);\n   133→\n   134→// Step 5: Calculate side-specific ratios\n   135→const ratios = calculateAllRatios(namedLandmarks, \"side\");\n   136→```\n   137→\n   138→---\n   139→\n   140→## 3. Core Scoring Engine\n   141→\n   142→### 3.1 The Exponential Decay Scoring Function\n   143→\n   144→This is the exact scoring algorithm extracted from the application:\n   145→\n   146→```javascript\n   147→/**\n   148→ * Calculate a score (0-10) based on how close a value is to the ideal range.\n   149→ * Uses exponential decay for values outside the ideal range.\n   150→ *\n   151→ * @param {number} value - The measured ratio value\n   152→ * @param {number} idealMin - Minimum of ideal range\n   153→ * @param {number} idealMax - Maximum of ideal range\n   154→ * @param {number} decayRate - Rate of score decay (default 0.2)\n   155→ * @param {number} maxScore - Maximum possible score (default 10)\n   156→ * @returns {number} Score from 0 to 10\n   157→ */\n   158→function calculateScore(value, idealMin, idealMax, decayRate = 0.2, maxScore = 10) {\n   159→    const minScore = -maxScore;\n   160→\n   161→    let rawScore;\n   162→\n   163→    if (value >= idealMin && value <= idealMax) {\n   164→        // Value is within ideal range - perfect score\n   165→        rawScore = maxScore;\n   166→    } else {\n   167→        // Calculate distance from ideal range\n   168→        const distance = value < idealMin\n   169→            ? (idealMin - value)\n   170→            : (value - idealMax);\n   171→\n   172→        // Apply exponential decay\n   173→        // Score decreases exponentially the further from ideal\n   174→        rawScore = minScore + (maxScore - minScore) * Math.exp(-decayRate * distance);\n   175→    }\n   176→\n   177→    // Normalize to 0-10 scale\n   178→    const range = maxScore - minScore;\n   179→    const normalizedScore = (rawScore - minScore) / range * 10;\n   180→\n   181→    return Math.max(0, Math.min(10, normalizedScore));\n   182→}\n   183→```\n   184→\n   185→### 3.2 Mathematical Explanation\n   186→\n   187→The exponential decay formula:\n   188→\n   189→```\n   190→                    ┌─ maxScore                          if idealMin ≤ value ≤ idealMax\n   191→                    │\n   192→score(value) = ─────┤\n   193→                    │\n   194→                    └─ minScore + (maxScore - minScore) × e^(-decay × distance)    otherwise\n   195→```\n   196→\n   197→Where:\n   198→- `distance = |value - nearest_ideal_boundary|`\n   199→- `decay` = 0.2 (default rate)\n   200→- `e` = Euler's number (≈2.718)\n   201→\n   202→**Visualization of Score Curve:**\n   203→\n   204→```\n   205→Score\n   206→  10 │          ┌──────────────┐\n   207→     │         ╱                ╲\n   208→   8 │        ╱                  ╲\n   209→     │       ╱                    ╲\n   210→   6 │      ╱                      ╲\n   211→     │     ╱                        ╲\n   212→   4 │    ╱                          ╲\n   213→     │   ╱                            ╲\n   214→   2 │  ╱                              ╲\n   215→     │ ╱                                ╲\n   216→   0 │╱                                  ╲______________\n   217→     └────────────────────────────────────────────────── Value\n   218→              │        │        │\n   219→           idealMin   ideal   idealMax\n   220→                     range\n   221→```\n   222→\n   223→### 3.3 Custom Curve Support\n   224→\n   225→For ratios with non-standard scoring curves:\n   226→\n   227→```javascript\n   228→/**\n   229→ * Calculate score using custom interpolation points\n   230→ *\n   231→ * @param {number} value - The measured value\n   232→ * @param {Array} customPoints - Array of {x, y} points defining the curve\n   233→ * @returns {number} Interpolated score (0-10)\n   234→ */\n   235→function calculateScoreFromCurve(value, customPoints) {\n   236→    // Sort points by x value\n   237→    const sorted = [...customPoints].sort((a, b) => a.x - b.x);\n   238→\n   239→    // Find surrounding points for interpolation\n   240→    for (let i = 0; i < sorted.length - 1; i++) {\n   241→        if (value >= sorted[i].x && value <= sorted[i + 1].x) {\n   242→            // Linear interpolation between points\n   243→            const t = (value - sorted[i].x) / (sorted[i + 1].x - sorted[i].x);\n   244→            return sorted[i].y + t * (sorted[i + 1].y - sorted[i].y);\n   245→        }\n   246→    }\n   247→\n   248→    // Extrapolate if outside range\n   249→    if (value < sorted[0].x) return sorted[0].y;\n   250→    return sorted[sorted.length - 1].y;\n   251→}\n   252→```\n   253→\n   254→---\n   255→\n   256→## 4. Landmark Detection System\n   257→\n   258→### 4.1 MediaPipe FaceLandmarker Setup\n   259→\n   260→```javascript\n   261→import { FaceLandmarker, FilesetResolver } from \"@mediapipe/tasks-vision\";\n   262→\n   263→async function initializeFaceLandmarker() {\n   264→    const wasmFileset = await FilesetResolver.forVisionTasks(\n   265→        \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm\"\n   266→    );\n   267→\n   268→    const faceLandmarker = await FaceLandmarker.createFromOptions(wasmFileset, {\n   269→        baseOptions: {\n   270→            modelAssetPath: \"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task\",\n   271→            delegate: \"GPU\"\n   272→        },\n   273→        runningMode: \"IMAGE\",\n   274→        numFaces: 1,\n   275→        outputFacialTransformationMatrixes: true,\n   276→        outputFaceBlendshapes: false\n   277→    });\n   278→\n   279→    return faceLandmarker;\n   280→}\n   281→```\n   282→\n   283→### 4.2 Front Profile Landmark Index Map\n   284→\n   285→```javascript\n   286→/**\n   287→ * MediaPipe FaceLandmarker index to anatomical point mapping\n   288→ * Based on MediaPipe's 478-point face mesh\n   289→ */\n   290→const FRONT_LANDMARK_INDICES = {\n   291→    // Facial outline\n   292→    chinBottom: 152,\n   293→    chinLeft: 172,\n   294→    chinRight: 397,\n   295→\n   296→    // Forehead\n   297→    hairline: 10,        // Top of forehead\n   298→    glabella: 9,         // Between eyebrows\n   299→\n   300→    // Eyes - Left\n   301→    leftEyePupil: 468,   // Iris center (if available) or approximate\n   302→    leftEyeMedialCanthus: 133,\n   303→    leftEyeLateralCanthus: 33,\n   304→    leftEyeUpperEyelid: 159,\n   305→    leftEyeLowerEyelid: 145,\n   306→    leftEyelidHoodEnd: 130,\n   307→\n   308→    // Eyes - Right\n   309→    rightEyePupil: 473,\n   310→    rightEyeMedialCanthus: 362,\n   311→    rightEyeLateralCanthus: 263,\n   312→    rightEyeUpperEyelid: 386,\n   313→    rightEyeLowerEyelid: 374,\n   314→    rightEyelidHoodEnd: 359,\n   315→\n   316→    // Eyebrows - Left\n   317→    leftBrowInnerCorner: 107,\n   318→    leftBrowHead: 66,\n   319→    leftBrowPeak: 105,\n   320→    leftBrowArch: 70,\n   321→\n   322→    // Eyebrows - Right\n   323→    rightBrowInnerCorner: 336,\n   324→    rightBrowHead: 296,\n   325→    rightBrowPeak: 334,\n   326→    rightBrowArch: 300,\n   327→\n   328→    // Nose\n   329→    nasion: 6,           // Bridge of nose\n   330→    noseBottom: 4,       // Tip of nose\n   331→    nasalBase: 2,        // Base of nose\n   332→    noseLeft: 129,       // Left nostril\n   333→    noseRight: 358,      // Right nostril\n   334→\n   335→    // Mouth\n   336→    cupidsBow: 0,        // Center upper lip\n   337→    mouthMiddle: 13,     // Center of mouth\n   338→    lowerLip: 14,        // Center lower lip\n   339→    mouthLeft: 61,       // Left corner\n   340→    mouthRight: 291,     // Right corner\n   341→\n   342→    // Cheeks\n   343→    leftCheek: 234,      // Widest point left\n   344→    rightCheek: 454,     // Widest point right\n   345→\n   346→    // Jaw\n   347→    leftTopGonion: 172,  // Left jaw angle\n   348→    rightTopGonion: 397, // Right jaw angle\n   349→    leftBottomGonion: 140,\n   350→    rightBottomGonion: 369,\n   351→\n   352→    // Temples\n   353→    leftTemple: 127,\n   354→    rightTemple: 356,\n   355→\n   356→    // Ears\n   357→    leftOuterEar: 234,\n   358→    rightOuterEar: 454,\n   359→\n   360→    // Neck\n   361→    neckLeft: 177,\n   362→    neckRight: 401\n   363→};\n   364→```\n   365→\n   366→### 4.3 Side Profile Landmark Index Map\n   367→\n   368→```javascript\n   369→/**\n   370→ * Side profile landmark indices (custom model)\n   371→ * Used after /api/side-landmarks detection\n   372→ */\n   373→const SIDE_LANDMARK_INDICES = {\n   374→    // Cranial\n   375→    vertex: \"calculated\",    // Top of head (calculated)\n   376→    occiput: \"calculated\",   // Back of head (calculated)\n   377→\n   378→    // Forehead\n   379→    trichion: \"calculated\",  // Hairline\n   380→    glabella: 104,           // Between brows\n   381→\n   382→    // Nose\n   383→    nasion: 72,              // Bridge\n   384→    rhinion: \"calculated\",   // Nasal bridge midpoint\n   385→    supratip: \"calculated\",  // Above tip\n   386→    pronasale: 83,           // Tip of nose\n   387→    infratip: \"calculated\",  // Below tip\n   388→    columella: \"calculated\", // Columella base\n   389→    subnasale: \"calculated\", // Below nose\n   390→    subalare: 77,            // Nostril base\n   391→\n   392→    // Lips\n   393→    labraleSuperius: 67,     // Upper lip\n   394→    labraleInferius: 59,     // Lower lip\n   395→    sublabiale: \"calculated\",// Below lower lip\n   396→    cheilion: 52,            // Corner of mouth\n   397→\n   398→    // Chin\n   399→    pogonion: 24,            // Chin point\n   400→    menton: \"calculated\",    // Chin bottom\n   401→\n   402→    // Jaw\n   403→    gonionTop: \"calculated\", // Upper jaw angle\n   404→    gonionBottom: 2,         // Lower jaw angle\n   405→\n   406→    // Ear\n   407→    porion: \"calculated\",    // Ear canal\n   408→    tragus: \"calculated\",    // Ear tragus\n   409→    intertragicNotch: \"calculated\",\n   410→\n   411→    // Eye\n   412→    orbitale: \"calculated\",  // Lower orbit\n   413→    cornealApex: 40,         // Eye center\n   414→\n   415→    // Neck\n   416→    cervicalPoint: \"calculated\",\n   417→    neckPoint: \"calculated\",\n   418→\n   419→    // Cheek\n   420→    cheekbone: \"calculated\"\n   421→};\n   422→```\n   423→\n   424→### 4.4 Calculated Landmark Functions\n   425→\n   426→```javascript\n   427→/**\n   428→ * Calculate derived landmarks from raw detected points\n   429→ */\n   430→const CALCULATED_LANDMARKS = {\n   431→    vertex: (landmarks) => {\n   432→        const glabella = getLandmark(landmarks, 10);\n   433→        const occiput = getLandmark(landmarks, 8);\n   434→        const nasion = getLandmark(landmarks, 1);\n   435→        const hairline = getLandmark(landmarks, 12);\n   436→        const distance = euclidean(glabella, occiput);\n   437→        return translatePoint(glabella, {\n   438→            along: { from: nasion, to: hairline },\n   439→            by: -distance\n   440→        });\n   441→    },\n   442→\n   443→    occiput: (landmarks) => {\n   444→        const vertex = getLandmark(landmarks, 9);\n   445→        const pronasale = getLandmark(landmarks, 83);\n   446→        const distance = euclidean(vertex, pronasale);\n   447→        return translatePoint(vertex, {\n   448→            along: { from: pronasale, to: vertex },\n   449→            by: distance\n   450→        });\n   451→    },\n   452→\n   453→    menton: (landmarks) => {\n   454→        const chinFront = getLandmark(landmarks, 0);\n   455→        const chinBottom = getLandmark(landmarks, 8);\n   456→        return {\n   457→            x: (chinFront.x + chinBottom.x) / 2,\n   458→            y: (chinFront.y + chinBottom.y) / 2\n   459→        };\n   460→    },\n   461→\n   462→    rhinion: (landmarks, namedPoints) => {\n   463→        if (!namedPoints.pronasale || !namedPoints.nasion) return null;\n   464→        const pronasale = toPixels(namedPoints.pronasale, landmarks.imageWidth, landmarks.imageHeight);\n   465→        return translatePoint(pronasale, {\n   466→            along: { from: pronasale, to: toPixels(namedPoints.nasion, landmarks.imageWidth, landmarks.imageHeight) },\n   467→            by: euclidean(getLandmark(landmarks, 74), getLandmark(landmarks, 72))\n   468→        });\n   469→    }\n   470→    // ... additional calculated points\n   471→};\n   472→```\n   473→\n   474→---\n   475→\n   476→## 5. Ratio Calculation Functions\n   477→\n   478→### 5.1 Core Utility Functions\n   479→\n   480→```javascript\n   481→/**\n   482→ * Calculate Euclidean distance between two points\n   483→ */\n   484→function euclidean(point1, point2) {\n   485→    const dx = point2.x - point1.x;\n   486→    const dy = point2.y - point1.y;\n   487→    return Math.sqrt(dx * dx + dy * dy);\n   488→}\n   489→\n   490→/**\n   491→ * Calculate midpoint between two points\n   492→ */\n   493→function midpoint(point1, point2) {\n   494→    return {\n   495→        x: (point1.x + point2.x) / 2,\n   496→        y: (point1.y + point2.y) / 2\n   497→    };\n   498→}\n   499→\n   500→/**\n   501→ * Safe division with fallback\n   502→ */\n   503→function ratio(numerator, denominator, fallback = 0) {\n   504→    if (!isFinite(numerator) || !isFinite(denominator) || Math.abs(denominator) < 1e-10) {\n   505→        return fallback;\n   506→    }\n   507→    const result = numerator / denominator;\n   508→    return isFinite(result) ? result : fallback;\n   509→}\n   510→\n   511→/**\n   512→ * Calculate angle at vertex (in degrees)\n   513→ * Returns angle ABC where B is the vertex\n   514→ */\n   515→function angle(pointA, vertex, pointC) {\n   516→    const vectorBA = { x: pointA.x - vertex.x, y: pointA.y - vertex.y };\n   517→    const vectorBC = { x: pointC.x - vertex.x, y: pointC.y - vertex.y };\n   518→\n   519→    const dotProduct = vectorBA.x * vectorBC.x + vectorBA.y * vectorBC.y;\n   520→    const magnitudeProduct = Math.sqrt(vectorBA.x ** 2 + vectorBA.y ** 2) *\n   521→                             Math.sqrt(vectorBC.x ** 2 + vectorBC.y ** 2);\n   522→\n   523→    if (Math.abs(magnitudeProduct) < 1e-10) return 0;\n   524→\n   525→    const cosAngle = Math.max(-1, Math.min(1, dotProduct / magnitudeProduct));\n   526→    return (180 / Math.PI) * Math.acos(cosAngle);\n   527→}\n   528→```\n   529→\n   530→### 5.2 Front Profile Ratio Calculations\n   531→\n   532→```javascript\n   533→const FRONT_RATIO_CALCULATIONS = {\n   534→    \"Midface Ratio\": (landmarks) => {\n   535→        const leftPupil = landmarks.leftEyePupil;\n   536→        const rightPupil = landmarks.rightEyePupil;\n   537→        const cupidsBow = landmarks.cupidsBow;\n   538→        if (!leftPupil || !rightPupil || !cupidsBow) return null;\n   539→\n   540→        const eyeWidth = Math.abs(rightPupil.x - leftPupil.x);\n   541→        const eyeCenterY = (leftPupil.y + rightPupil.y) / 2;\n   542→        return ratio(eyeWidth, Math.abs(cupidsBow.y - eyeCenterY));\n   543→    },\n   544→\n   545→    \"Eye Separation Ratio\": (landmarks) => {\n   546→        const leftPupil = landmarks.leftEyePupil;\n   547→        const rightPupil = landmarks.rightEyePupil;\n   548→        const leftCheek = landmarks.leftCheek;\n   549→        const rightCheek = landmarks.rightCheek;\n   550→        if (!leftPupil || !rightPupil || !leftCheek || !rightCheek) return null;\n   551→\n   552→        return 100 * ratio(\n   553→            Math.abs(rightPupil.x - leftPupil.x),\n   554→            Math.abs(rightCheek.x - leftCheek.x)\n   555→        );\n   556→    },\n   557→\n   558→    \"Total Facial Width to Height Ratio\": (landmarks) => {\n   559→        const leftCheek = landmarks.leftCheek;\n   560→        const rightCheek = landmarks.rightCheek;\n   561→        const hairline = landmarks.hairline;\n   562→        const chinBottom = landmarks.chinBottom;\n   563→        if (!leftCheek || !rightCheek || !hairline || !chinBottom) return null;\n   564→\n   565→        return ratio(\n   566→            Math.abs(chinBottom.y - hairline.y),\n   567→            Math.abs(rightCheek.x - leftCheek.x)\n   568→        );\n   569→    },\n   570→\n   571→    \"Bigonial Width\": (landmarks) => {\n   572→        const leftGonion = landmarks.leftTopGonion;\n   573→        const rightGonion = landmarks.rightTopGonion;\n   574→        const leftCheek = landmarks.leftCheek;\n   575→        const rightCheek = landmarks.rightCheek;\n   576→        if (!leftGonion || !rightGonion || !leftCheek || !rightCheek) return null;\n   577→\n   578→        return 100 * ratio(\n   579→            Math.abs(rightGonion.x - leftGonion.x),\n   580→            Math.abs(rightCheek.x - leftCheek.x)\n   581→        );\n   582→    },\n   583→\n   584→    \"Lateral Canthal Tilt\": (landmarks) => {\n   585→        const leftMedial = landmarks.leftEyeMedialCanthus;\n   586→        const leftLateral = landmarks.leftEyeLateralCanthus;\n   587→        const rightMedial = landmarks.rightEyeMedialCanthus;\n   588→        const rightLateral = landmarks.rightEyeLateralCanthus;\n   589→        if (!leftMedial || !leftLateral || !rightMedial || !rightLateral) return null;\n   590→\n   591→        const leftTilt = (180 / Math.PI) * Math.atan2(\n   592→            leftMedial.y - leftLateral.y,\n   593→            leftMedial.x - leftLateral.x\n   594→        );\n   595→        const rightTilt = (180 / Math.PI) * Math.atan2(\n   596→            rightMedial.y - rightLateral.y,\n   597→            rightLateral.x - rightMedial.x\n   598→        );\n   599→        return (leftTilt + rightTilt) / 2;\n   600→    },\n   601→\n   602→    \"Lower Third\": (landmarks) => {\n   603→        const hairline = landmarks.hairline;\n   604→        const noseBottom = landmarks.noseBottom;\n   605→        const chinBottom = landmarks.chinBottom;\n   606→        const leftBrowInner = landmarks.leftBrowInnerCorner;\n   607→        const leftBrowHead = landmarks.leftBrowHead;\n   608→        const rightBrowInner = landmarks.rightBrowInnerCorner;\n   609→        const rightBrowHead = landmarks.rightBrowHead;\n   610→        if (!hairline || !noseBottom || !chinBottom || !leftBrowInner ||\n   611→            !leftBrowHead || !rightBrowInner || !rightBrowHead) return null;\n   612→\n   613→        const faceHeight = Math.abs(chinBottom.y - hairline.y);\n   614→        return ((chinBottom.y - noseBottom.y) / faceHeight) * 100;\n   615→    },\n   616→\n   617→    \"Middle Third\": (landmarks) => {\n   618→        const hairline = landmarks.hairline;\n   619→        const noseBottom = landmarks.noseBottom;\n   620→        const chinBottom = landmarks.chinBottom;\n   621→        const leftBrowInner = landmarks.leftBrowInnerCorner;\n   622→        const leftBrowHead = landmarks.leftBrowHead;\n   623→        const rightBrowInner = landmarks.rightBrowInnerCorner;\n   624→        const rightBrowHead = landmarks.rightBrowHead;\n   625→        if (!hairline || !noseBottom || !chinBottom || !leftBrowInner ||\n   626→            !leftBrowHead || !rightBrowInner || !rightBrowHead) return null;\n   627→\n   628→        const faceHeight = Math.abs(chinBottom.y - hairline.y);\n   629→        const browMid = midpoint(midpoint(leftBrowInner, leftBrowHead),\n   630→                                  midpoint(rightBrowInner, rightBrowHead));\n   631→        return ((noseBottom.y - browMid.y) / faceHeight) * 100;\n   632→    },\n   633→\n   634→    \"Top Third\": (landmarks) => {\n   635→        const hairline = landmarks.hairline;\n   636→        const chinBottom = landmarks.chinBottom;\n   637→        const leftBrowInner = landmarks.leftBrowInnerCorner;\n   638→        const leftBrowHead = landmarks.leftBrowHead;\n   639→        const rightBrowInner = landmarks.rightBrowInnerCorner;\n   640→        const rightBrowHead = landmarks.rightBrowHead;\n   641→        if (!hairline || !chinBottom || !leftBrowInner || !leftBrowHead ||\n   642→            !rightBrowInner || !rightBrowHead) return null;\n   643→\n   644→        const faceHeight = Math.abs(chinBottom.y - hairline.y);\n   645→        const browMid = midpoint(midpoint(leftBrowInner, leftBrowHead),\n   646→                                  midpoint(rightBrowInner, rightBrowHead));\n   647→        return ((browMid.y - hairline.y) / faceHeight) * 100;\n   648→    },\n   649→\n   650→    \"Eye Aspect Ratio\": (landmarks) => {\n   651→        const leftMedial = landmarks.leftEyeMedialCanthus;\n   652→        const leftLateral = landmarks.leftEyeLateralCanthus;\n   653→        const leftUpper = landmarks.leftEyeUpperEyelid;\n   654→        const leftLower = landmarks.leftEyeLowerEyelid;\n   655→        const rightMedial = landmarks.rightEyeMedialCanthus;\n   656→        const rightLateral = landmarks.rightEyeLateralCanthus;\n   657→        const rightUpper = landmarks.rightEyeUpperEyelid;\n   658→        const rightLower = landmarks.rightEyeLowerEyelid;\n   659→        if (!leftMedial || !leftLateral || !leftUpper || !leftLower ||\n   660→            !rightMedial || !rightLateral || !rightUpper || !rightLower) return null;\n   661→\n   662→        const leftRatio = ratio(Math.abs(leftLateral.x - leftMedial.x),\n   663→                                Math.abs(leftLower.y - leftUpper.y));\n   664→        const rightRatio = ratio(Math.abs(rightLateral.x - rightMedial.x),\n   665→                                 Math.abs(rightLower.y - rightUpper.y));\n   666→        return (leftRatio + rightRatio) / 2;\n   667→    },\n   668→\n   669→    \"Jaw Frontal Angle\": (landmarks) => {\n   670→        const leftGonion = landmarks.leftBottomGonion;\n   671→        const rightGonion = landmarks.rightBottomGonion;\n   672→        const chinLeft = landmarks.chinLeft;\n   673→        const chinRight = landmarks.chinRight;\n   674→        if (!leftGonion || !rightGonion || !chinLeft || !chinRight) return null;\n   675→\n   676→        // Calculate angle between jaw lines\n   677→        return 180 - angle(leftGonion, chinLeft, chinRight, rightGonion);\n   678→    }\n   679→};\n   680→```\n   681→\n   682→### 5.3 Side Profile Ratio Calculations\n   683→\n   684→```javascript\n   685→const SIDE_RATIO_CALCULATIONS = {\n   686→    \"Gonial Angle\": (landmarks) => {\n   687→        const gonionTop = landmarks.gonionTop;\n   688→        const gonionBottom = landmarks.gonionBottom;\n   689→        const menton = landmarks.menton;\n   690→        const tragus = landmarks.intertragicNotch;\n   691→        if (!gonionTop || !gonionBottom || !menton || !tragus) return null;\n   692→\n   693→        const angle1 = Math.atan2(gonionTop.y - tragus.y, gonionTop.x - tragus.x);\n   694→        const angle2 = Math.atan2(gonionBottom.y - menton.y, gonionBottom.x - menton.x);\n   695→        let angleDiff = (180 / Math.PI) * Math.abs(angle1 - angle2);\n   696→        return angleDiff > 180 ? 360 - angleDiff : angleDiff;\n   697→    },\n   698→\n   699→    \"Nasolabial Angle\": (landmarks) => {\n   700→        const columella = landmarks.columella;\n   701→        const subnasale = landmarks.subnasale;\n   702→        const labraleSuperius = landmarks.labraleSuperius;\n   703→        if (!columella || !subnasale || !labraleSuperius) return null;\n   704→\n   705→        return angle(columella, subnasale, labraleSuperius);\n   706→    },\n   707→\n   708→    \"Nasofrontal Angle\": (landmarks) => {\n   709→        const glabella = landmarks.glabella;\n   710→        const nasion = landmarks.nasion;\n   711→        const supratip = landmarks.supratip;\n   712→        if (!glabella || !nasion || !supratip) return null;\n   713→\n   714→        return angle(glabella, nasion, supratip);\n   715→    },\n   716→\n   717→    \"Mentolabial Angle\": (landmarks) => {\n   718→        const labraleInferius = landmarks.labraleInferius;\n   719→        const sublabiale = landmarks.sublabiale;\n   720→        const pogonion = landmarks.pogonion;\n   721→        if (!labraleInferius || !sublabiale || !pogonion) return null;\n   722→\n   723→        return angle(labraleInferius, sublabiale, pogonion);\n   724→    },\n   725→\n   726→    \"Facial Convexity (Glabella)\": (landmarks) => {\n   727→        const glabella = landmarks.glabella;\n   728→        const subnasale = landmarks.subnasale;\n   729→        const pogonion = landmarks.pogonion;\n   730→        if (!glabella || !subnasale || !pogonion) return null;\n   731→\n   732→        return angle(glabella, subnasale, pogonion);\n   733→    },\n   734→\n   735→    \"Total Facial Convexity\": (landmarks) => {\n   736→        const glabella = landmarks.glabella;\n   737→        const pronasale = landmarks.pronasale;\n   738→        const pogonion = landmarks.pogonion;\n   739→        if (!glabella || !pronasale || !pogonion) return null;\n   740→\n   741→        const baseAngle = angle(glabella, pronasale, pogonion);\n   742→\n   743→        // Determine if convex or concave\n   744→        const v1 = { x: glabella.x - pronasale.x, y: glabella.y - pronasale.y };\n   745→        const v2 = { x: pogonion.x - pronasale.x, y: pogonion.y - pronasale.y };\n   746→        const cross = v1.x * v2.y - v1.y * v2.x;\n   747→\n   748→        return cross < 0 ? baseAngle : 360 - baseAngle;\n   749→    },\n   750→\n   751→    \"Submental Cervical Angle\": (landmarks) => {\n   752→        const menton = landmarks.menton;\n   753→        const cervicalPoint = landmarks.cervicalPoint;\n   754→        const neckPoint = landmarks.neckPoint;\n   755→        if (!menton || !cervicalPoint || !neckPoint) return null;\n   756→\n   757→        return angle(menton, cervicalPoint, neckPoint);\n   758→    },\n   759→\n   760→    \"Nasal Tip Angle\": (landmarks) => {\n   761→        const supratip = landmarks.supratip;\n   762→        const pronasale = landmarks.pronasale;\n   763→        const infratip = landmarks.infratip;\n   764→        if (!supratip || !pronasale || !infratip) return null;\n   765→\n   766→        return angle(supratip, pronasale, infratip);\n   767→    },\n   768→\n   769→    \"Nasofacial Angle\": (landmarks) => {\n   770→        const nasion = landmarks.nasion;\n   771→        const pronasale = landmarks.pronasale;\n   772→        const pogonion = landmarks.pogonion;\n   773→        if (!nasion || !pronasale || !pogonion) return null;\n   774→\n   775→        const baseAngle = angle(pronasale, nasion, pogonion);\n   776→        return baseAngle > 90 ? 180 - baseAngle : baseAngle;\n   777→    },\n   778→\n   779→    \"Mandibular Plane Angle\": (landmarks) => {\n   780→        const gonionTop = landmarks.gonionTop;\n   781→        const gonionBottom = landmarks.gonionBottom;\n   782→        const menton = landmarks.menton;\n   783→        const tragus = landmarks.tragus;\n   784→        if (!gonionTop || !gonionBottom || !menton || !tragus) return null;\n   785→\n   786→        // Calculate intersection of mandibular plane with Frankfort horizontal\n   787→        // Complex geometric calculation...\n   788→        // Returns angle in degrees\n   789→    }\n   790→};\n   791→```\n   792→\n   793→---\n   794→\n   795→## 6. Decoded Scoring Standards Database\n   796→\n   797→### 6.1 Confirmed Ratios (Clear Names)\n   798→\n   799→| Ratio Name | Ideal Min | Ideal Max | Unit | Profile | Decay Rate |\n   800→|------------|-----------|-----------|------|---------|------------|\n   801→| Top Third | 29.00 | 33.00 | % | Front | 0.2 |\n   802→| Middle Third | 31.00 | 34.00 | % | Front | 0.2 |\n   803→| Lower Third | 33.40 | 37.50 | % | Front | 0.2 |\n   804→| Eye Separation Ratio | 45.00 | 47.50 | % | Front | 0.2 |\n   805→| Eyebrow Low Setedness | 0.00 | 0.66 | x | Front | 0.2 |\n   806→| Total Facial Width to Height Ratio | 1.33 | 1.38 | x | Front | 0.2 |\n   807→| Gonial Angle | 113.00 | 123.00 | ° | Side | 0.2 |\n   808→| Facial Convexity (Glabella) | 167.00 | 176.00 | ° | Side | 0.2 |\n   809→| Submental Cervical Angle | 92.00 | 110.00 | ° | Side | 0.2 |\n   810→| Recession relative to Frankfort plane | 0.00 | 15.00 | mm | Side | 0.2 |\n   811→\n   812→### 6.2 Fingerprinted Ratios (Decoded from Obfuscation)\n   813→\n   814→Based on anthropometric analysis matching ideal ranges to scientific literature:\n   815→\n   816→| Predicted Ratio Name | Ideal Min | Ideal Max | Unit | Confidence | Evidence |\n   817→|---------------------|-----------|-----------|------|------------|----------|\n   818→| **Nasolabial Angle** | 60.54 | 105.97 | ° | 95% | Matches Farkas 90-105° standard |\n   819→| **Nasofrontal Angle** | 142.50 | 150.12 | ° | 95% | Matches Powell 130-140° (scaled) |\n   820→| **Mentolabial Angle** | 65.19 | 101.55 | ° | 85% | Matches standard 80-120° |\n   821→| **Eye Aspect Ratio** | 2.44 | 2.89 | x | 85% | Matches Farkas palpebral fissure 2.5-3.0 |\n   822→| **Lower Lip E-Line Position** | -25.61 | -11.04 | DW | 90% | Ricketts E-line standard (scaled) |\n   823→| **Upper Lip E-Line Position** | -18.63 | -8.83 | DW | 90% | Upper lip E-line standard (scaled) |\n   824→| **Upper Lip S-Line Position** | -4.66 | 0.00 | DW | 75% | Steiner S-line standard |\n   825→| **Lower Lip S-Line Position** | -2.33 | 2.21 | DW | 75% | S-line balanced position |\n   826→| **Upper Lip Burstone Line** | -2.33 | 2.21 | DW | 70% | Burstone line standard |\n   827→| **Deviation of IAA & JFA** | 0.00 | 11.04 | DW | 85% | Zero = perfect symmetry |\n   828→| **Ear Protrusion Angle** | 0.00 | 17.66 | ° | 80% | Standard 15-20° from head |\n   829→| **Bigonial Width %** | 37.25 | 57.40 | % | 80% | Jaw-to-face width ratio |\n   830→| **Bitemporal Width %** | 46.57 | 52.98 | % | 80% | Temple-to-cheek ratio |\n   831→| **Chin to Philtrum Ratio** | 4.42 | 4.50 | DW | 80% | Very tight range (critical ratio) |\n   832→| **Total Facial Convexity** | 135.05 | 172.19 | ° | 85% | Standard 140-150° |\n   833→| **Nasal Tip Angle** | 139.70 | 158.95 | ° | 70% | Nasal tip definition |\n   834→| **Mouth Width to Nose Width** | 2.77 | 3.78 | x | 65% | Powell 1.5x (scaled ~3.0) |\n   835→| **Lower Lip to Upper Lip Ratio** | 4.19 | 4.46 | DW | 70% | Standard 1:1.6-2.0 (scaled) |\n   836→| **Ipsilateral Alar Angle** | 26.08 | 36.65 | ° | 60% | Midface width relationship |\n   837→| **Cheekbone Height %** | 23.28 | 57.40 | % | 65% | Position as % of face height |\n   838→| **Mandibular Plane Angle** | 41.91 | 97.13 | DW | 65% | Wide range (scaled 20-30°) |\n   839→\n   840→### 6.3 Understanding the \"DW\" Unit\n   841→\n   842→The \"DW\" (Digital Width) unit appears to be a **normalized measurement system**:\n   843→\n   844→```\n   845→DW = Actual_Measurement × Scale_Factor\n   846→\n   847→Where Scale_Factor ≈ 10 for mm measurements\n   848→      Scale_Factor ≈ 100 for small ratios\n   849→```\n   850→\n   851→**Conversion Guide:**\n   852→- Values 0-50 DW → Likely percentages or small ratios\n   853→- Values 50-200 DW → Likely angles in degrees or scaled mm\n   854→- Values 300-800 DW → Likely mm measurements × 10 or complex scaled ratios\n   855→\n   856→### 6.4 Complete Ratio Configuration Schema\n   857→\n   858→```javascript\n   859→const RATIO_CONFIG = {\n   860→    \"Top Third\": {\n   861→        name: \"Top Third\",\n   862→        profileType: \"front\",\n   863→        idealMin: 29.00,\n   864→        idealMax: 33.00,\n   865→        unit: \"%\",\n   866→        decayRate: 0.2,\n   867→        category: \"Facial Proportions\",\n   868→        description: \"Percentage of face height from hairline to brow line\",\n   869→        landmarks: [\"hairline\", \"leftBrowHead\", \"leftBrowInnerCorner\",\n   870→                   \"rightBrowHead\", \"rightBrowInnerCorner\", \"chinBottom\"]\n   871→    },\n   872→    \"Nasolabial Angle\": {\n   873→        name: \"Nasolabial Angle\",\n   874→        profileType: \"side\",\n   875→        idealMin: 90.00,  // Unscaled standard value\n   876→        idealMax: 105.00,\n   877→        unit: \"°\",\n   878→        decayRate: 0.2,\n   879→        category: \"Nasal Angles\",\n   880→        description: \"Angle between columella and upper lip\",\n   881→        landmarks: [\"columella\", \"subnasale\", \"labraleSuperius\"],\n   882→        scientificReference: \"Farkas LG, 1994\"\n   883→    },\n   884→    // ... additional configurations\n   885→};\n   886→```\n   887→\n   888→---\n   889→\n   890→## 7. Implementation Strategy\n   891→\n   892→### 7.1 Required Libraries\n   893→\n   894→```json\n   895→{\n   896→  \"dependencies\": {\n   897→    \"@mediapipe/tasks-vision\": \"^0.10.0\",\n   898→    \"react\": \"^18.0.0\",\n   899→    \"next\": \"^14.0.0\"\n   900→  },\n   901→  \"devDependencies\": {\n   902→    \"typescript\": \"^5.0.0\"\n   903→  }\n   904→}\n   905→```\n   906→\n   907→**Python Backend (Alternative):**\n   908→```\n   909→mediapipe>=0.10.0\n   910→opencv-python>=4.8.0\n   911→numpy>=1.24.0\n   912→flask>=2.3.0  # or fastapi\n   913→```\n   914→\n   915→### 7.2 Project Structure\n   916→\n   917→```\n   918→facial-analysis/\n   919→├── src/\n   920→│   ├── lib/\n   921→│   │   ├── mediapipe/\n   922→│   │   │   ├── faceLandmarker.ts      # MediaPipe initialization\n   923→│   │   │   └── landmarkMapper.ts       # Index to name mapping\n   924→│   │   ├── calculations/\n   925→│   │   │   ├── ratios.ts              # Ratio calculation functions\n   926→│   │   │   ├── scoring.ts             # Score calculation engine\n   927→│   │   │   └── utilities.ts           # Math helper functions\n   928→│   │   ├── standards/\n   929→│   │   │   ├── idealRanges.ts         # Ideal min/max database\n   930→│   │   │   └── ratioConfig.ts         # Full ratio configurations\n   931→│   │   └── types/\n   932→│   │       └── index.ts               # TypeScript interfaces\n   933→│   ├── components/\n   934→│   │   ├── FaceCapture.tsx            # Camera/upload component\n   935→│   │   ├── AnalysisResults.tsx        # Score display\n   936→│   │   └── RatioVisualization.tsx     # Overlay visualization\n   937→│   └── api/\n   938→│       └── side-landmarks/\n   939→│           └── route.ts               # Side profile API\n   940→├── public/\n   941→│   └── models/                        # MediaPipe model files\n   942→└── package.json\n   943→```\n   944→\n   945→### 7.3 TypeScript Interfaces\n   946→\n   947→```typescript\n   948→interface Point {\n   949→    x: number;\n   950→    y: number;\n   951→    z?: number;\n   952→}\n   953→\n   954→interface NamedLandmarks {\n   955→    [key: string]: Point | null;\n   956→}\n   957→\n   958→interface RatioConfig {\n   959→    name: string;\n   960→    profileType: \"front\" | \"side\";\n   961→    idealMin: number;\n   962→    idealMax: number;\n   963→    unit: string;\n   964→    decayRate: number;\n   965→    category: string;\n   966→    description: string;\n   967→    landmarks: string[];\n   968→    calculationFn?: (landmarks: NamedLandmarks) => number | null;\n   969→}\n   970→\n   971→interface RatioResult {\n   972→    name: string;\n   973→    value: number | null;\n   974→    score: number | null;\n   975→    standardizedScore: number;\n   976→    idealMin: number;\n   977→    idealMax: number;\n   978→    unit: string;\n   979→    deviation: \"below\" | \"ideal\" | \"above\";\n   980→    isIdeal: boolean;\n   981→}\n   982→\n   983→interface AnalysisResult {\n   984→    frontRatios: RatioResult[];\n   985→    sideRatios: RatioResult[];\n   986→    overallScore: number;\n   987→    categoryScores: { [category: string]: number };\n   988→    landmarks: {\n   989→        front: NamedLandmarks;\n   990→        side: NamedLandmarks;\n   991→    };\n   992→}\n   993→```\n   994→\n   995→### 7.4 Quick Start Implementation\n   996→\n   997→```typescript\n   998→// main.ts - Minimal implementation\n   999→\n  1000→import { FaceLandmarker, FilesetResolver } from \"@mediapipe/tasks-vision\";\n  1001→import { FRONT_LANDMARK_INDICES, FRONT_RATIO_CALCULATIONS, RATIO_CONFIG } from \"./config\";\n  1002→\n  1003→class FacialAnalyzer {\n  1004→    private faceLandmarker: FaceLandmarker | null = null;\n  1005→\n  1006→    async initialize() {\n  1007→        const wasmFileset = await FilesetResolver.forVisionTasks(\n  1008→            \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm\"\n  1009→        );\n  1010→\n  1011→        this.faceLandmarker = await FaceLandmarker.createFromModelPath(\n  1012→            wasmFileset,\n  1013→            \"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task\"\n  1014→        );\n  1015→    }\n  1016→\n  1017→    analyzeFrontProfile(imageElement: HTMLImageElement): AnalysisResult {\n  1018→        if (!this.faceLandmarker) throw new Error(\"Not initialized\");\n  1019→\n  1020→        // Detect landmarks\n  1021→        const results = this.faceLandmarker.detect(imageElement);\n  1022→        if (!results.faceLandmarks.length) throw new Error(\"No face detected\");\n  1023→\n  1024→        const rawLandmarks = results.faceLandmarks[0];\n  1025→\n  1026→        // Map to named points\n  1027→        const namedLandmarks = this.mapLandmarks(rawLandmarks, imageElement);\n  1028→\n  1029→        // Calculate ratios\n  1030→        const ratios = this.calculateRatios(namedLandmarks, \"front\");\n  1031→\n  1032→        // Score ratios\n  1033→        const scoredRatios = this.scoreRatios(ratios);\n  1034→\n  1035→        return {\n  1036→            frontRatios: scoredRatios,\n  1037→            sideRatios: [],\n  1038→            overallScore: this.calculateOverallScore(scoredRatios),\n  1039→            categoryScores: this.calculateCategoryScores(scoredRatios),\n  1040→            landmarks: { front: namedLandmarks, side: {} }\n  1041→        };\n  1042→    }\n  1043→\n  1044→    private mapLandmarks(raw: Point[], image: HTMLImageElement): NamedLandmarks {\n  1045→        const named: NamedLandmarks = {};\n  1046→\n  1047→        for (const [name, index] of Object.entries(FRONT_LANDMARK_INDICES)) {\n  1048→            if (typeof index === \"number\" && raw[index]) {\n  1049→                named[name] = {\n  1050→                    x: raw[index].x * image.width,\n  1051→                    y: raw[index].y * image.height\n  1052→                };\n  1053→            }\n  1054→        }\n  1055→\n  1056→        return named;\n  1057→    }\n  1058→\n  1059→    private calculateRatios(landmarks: NamedLandmarks, profile: \"front\" | \"side\") {\n  1060→        const calculations = profile === \"front\"\n  1061→            ? FRONT_RATIO_CALCULATIONS\n  1062→            : SIDE_RATIO_CALCULATIONS;\n  1063→\n  1064→        return Object.entries(calculations).map(([name, fn]) => ({\n  1065→            name,\n  1066→            value: fn(landmarks),\n  1067→            config: RATIO_CONFIG[name]\n  1068→        }));\n  1069→    }\n  1070→\n  1071→    private scoreRatios(ratios: any[]): RatioResult[] {\n  1072→        return ratios.map(r => {\n  1073→            const score = r.value !== null\n  1074→                ? this.calculateScore(r.value, r.config.idealMin, r.config.idealMax, r.config.decayRate)\n  1075→                : null;\n  1076→\n  1077→            return {\n  1078→                name: r.name,\n  1079→                value: r.value,\n  1080→                score,\n  1081→                standardizedScore: score ?? 0,\n  1082→                idealMin: r.config.idealMin,\n  1083→                idealMax: r.config.idealMax,\n  1084→                unit: r.config.unit,\n  1085→                deviation: this.getDeviation(r.value, r.config.idealMin, r.config.idealMax),\n  1086→                isIdeal: r.value !== null && r.value >= r.config.idealMin && r.value <= r.config.idealMax\n  1087→            };\n  1088→        });\n  1089→    }\n  1090→\n  1091→    private calculateScore(value: number, min: number, max: number, decay: number = 0.2): number {\n  1092→        const maxScore = 10;\n  1093→        const minScore = -maxScore;\n  1094→\n  1095→        let rawScore: number;\n  1096→        if (value >= min && value <= max) {\n  1097→            rawScore = maxScore;\n  1098→        } else {\n  1099→            const distance = value < min ? (min - value) : (value - max);\n  1100→            rawScore = minScore + (maxScore - minScore) * Math.exp(-decay * distance);\n  1101→        }\n  1102→\n  1103→        const range = maxScore - minScore;\n  1104→        return Math.max(0, Math.min(10, ((rawScore - minScore) / range) * 10));\n  1105→    }\n  1106→\n  1107→    private getDeviation(value: number | null, min: number, max: number): \"below\" | \"ideal\" | \"above\" {\n  1108→        if (value === null) return \"ideal\";\n  1109→        if (value < min) return \"below\";\n  1110→        if (value > max) return \"above\";\n  1111→        return \"ideal\";\n  1112→    }\n  1113→\n  1114→    private calculateOverallScore(ratios: RatioResult[]): number {\n  1115→        const validScores = ratios.filter(r => r.score !== null).map(r => r.score!);\n  1116→        return validScores.length ? validScores.reduce((a, b) => a + b, 0) / validScores.length : 0;\n  1117→    }\n  1118→\n  1119→    private calculateCategoryScores(ratios: RatioResult[]): { [key: string]: number } {\n  1120→        const categories: { [key: string]: number[] } = {};\n  1121→\n  1122→        for (const ratio of ratios) {\n  1123→            const category = RATIO_CONFIG[ratio.name]?.category || \"Other\";\n  1124→            if (!categories[category]) categories[category] = [];\n  1125→            if (ratio.score !== null) categories[category].push(ratio.score);\n  1126→        }\n  1127→\n  1128→        const scores: { [key: string]: number } = {};\n  1129→        for (const [cat, values] of Object.entries(categories)) {\n  1130→            scores[cat] = values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;\n  1131→        }\n  1132→\n  1133→        return scores;\n  1134→    }\n  1135→}\n  1136→\n  1137→export default FacialAnalyzer;\n  1138→```\n  1139→\n  1140→---\n  1141→\n  1142→## 8. API Reference\n  1143→\n  1144→### 8.1 Side Landmarks API\n  1145→\n  1146→**Endpoint:** `POST /api/side-landmarks`\n  1147→\n  1148→**Request:**\n  1149→```\n  1150→Content-Type: multipart/form-data\n  1151→\n  1152→Fields:\n  1153→- image: JPEG/PNG file (side profile photo)\n  1154→```\n  1155→\n  1156→**Response:**\n  1157→```json\n  1158→{\n  1159→    \"success\": true,\n  1160→    \"data\": {\n  1161→        \"landmarks\": [\n  1162→            { \"x\": 0.123, \"y\": 0.456 },\n  1163→            // ... 106 landmark points\n  1164→        ],\n  1165→        \"direction\": \"left\",  // or \"right\"\n  1166→        \"rotationAngle\": 2.5,\n  1167→        \"center\": { \"x\": 0.5, \"y\": 0.5 },\n  1168→        \"crop\": {\n  1169→            \"x\": 100,\n  1170→            \"y\": 50,\n  1171→            \"width\": 400,\n  1172→            \"height\": 500,\n  1173→            \"scale\": 1.2\n  1174→        },\n  1175→        \"bbox\": {\n  1176→            \"minX\": 100,\n  1177→            \"minY\": 50,\n  1178→            \"maxX\": 500,\n  1179→            \"maxY\": 550\n  1180→        }\n  1181→    }\n  1182→}\n  1183→```\n  1184→\n  1185→### 8.2 Analysis API\n  1186→\n  1187→**Endpoint:** `POST /api/faces`\n  1188→\n  1189→**Request:**\n  1190→```json\n  1191→{\n  1192→    \"frontPhotoUrl\": \"data:image/jpeg;base64,...\",\n  1193→    \"sidePhotoUrl\": \"data:image/jpeg;base64,...\",\n  1194→    \"gender\": \"male\",\n  1195→    \"ethnicity\": \"caucasian\"\n  1196→}\n  1197→```\n  1198→\n  1199→**Response:**\n  1200→```json\n  1201→{\n  1202→    \"success\": true,\n  1203→    \"faceId\": \"abc123\",\n  1204→    \"frontRatios\": [\n  1205→        {\n  1206→            \"name\": \"Eye Separation Ratio\",\n  1207→            \"value\": 46.5,\n  1208→            \"score\": 9.2,\n  1209→            \"standardizedScore\": 9.2,\n  1210→            \"unit\": \"%\",\n  1211→            \"idealMin\": 45.0,\n  1212→            \"idealMax\": 47.5\n  1213→        }\n  1214→    ],\n  1215→    \"sideRatios\": [...],\n  1216→    \"overallScore\": 7.8\n  1217→}\n  1218→```\n  1219→\n  1220→---\n  1221→\n  1222→## Appendix A: Scientific References\n  1223→\n  1224→1. **Farkas LG** (1994). \"Anthropometry of the Head and Face\" - Primary source for facial proportions\n  1225→2. **Powell N, Humphreys B** (1984). \"Proportions of the Aesthetic Face\" - Golden ratio applications\n  1226→3. **Ricketts RM** (1968). \"The Esthetic E-Plane\" - E-line lip position standards\n  1227→4. **Steiner CC** (1959). \"Cephalometrics for You and Me\" - S-line standards\n  1228→5. **Burstone CJ** (1967). \"Lip Posture and Its Significance\" - Burstone line\n  1229→\n  1230→---\n  1231→\n  1232→## Appendix B: Changelog\n  1233→\n  1234→| Version | Date | Changes |\n  1235→|---------|------|---------|\n  1236→| 1.0 | Dec 2024 | Initial reverse-engineering documentation |\n  1237→\n  1238→---\n  1239→\n  1240→*This document was created through reverse-engineering of publicly accessible web application code for educational and research purposes.*\n  1241→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8479e8f6-2e84-4c3f-b09a-f70fd1453bf8","timestamp":"2025-12-18T02:37:15.357Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/imorgado/LOOKSMAXX/TECHNICAL_SPECS.md","content":"# FaceIQ Labs - Technical Specification Document\n## Reverse-Engineered Facial Analysis System\n\n**Document Version:** 1.0\n**Date:** December 2024\n**Source:** Reverse-engineered from beta.faceiqlabs.com\n\n---\n\n## Table of Contents\n\n1. [System Architecture](#1-system-architecture)\n2. [Data Flow Pipeline](#2-data-flow-pipeline)\n3. [Core Scoring Engine](#3-core-scoring-engine)\n4. [Landmark Detection System](#4-landmark-detection-system)\n5. [Ratio Calculation Functions](#5-ratio-calculation-functions)\n6. [Decoded Scoring Standards Database](#6-decoded-scoring-standards-database)\n7. [Implementation Strategy](#7-implementation-strategy)\n8. [API Reference](#8-api-reference)\n\n---\n\n## 1. System Architecture\n\n### 1.1 Hybrid Processing Model\n\nThe system uses a **hybrid architecture** that splits processing between client and server:\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                           FACIAL ANALYSIS SYSTEM                            │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                             │\n│  ┌─────────────────────────────┐    ┌─────────────────────────────────┐   │\n│  │     CLIENT-SIDE (Browser)   │    │      SERVER-SIDE (API)          │   │\n│  ├─────────────────────────────┤    ├─────────────────────────────────┤   │\n│  │                             │    │                                 │   │\n│  │  ┌───────────────────────┐  │    │  ┌───────────────────────────┐ │   │\n│  │  │   MediaPipe WASM      │  │    │  │  Custom Landmark Model    │ │   │\n│  │  │   FaceLandmarker      │  │    │  │  (Side Profile)           │ │   │\n│  │  └───────────────────────┘  │    │  └───────────────────────────┘ │   │\n│  │            │                │    │              │                 │   │\n│  │            ▼                │    │              ▼                 │   │\n│  │  ┌───────────────────────┐  │    │  ┌───────────────────────────┐ │   │\n│  │  │  478 Facial Landmarks │  │    │  │  106 Side Landmarks       │ │   │\n│  │  │  (Front Profile)      │  │    │  │  + Rotation Data          │ │   │\n│  │  └───────────────────────┘  │    │  └───────────────────────────┘ │   │\n│  │            │                │    │              │                 │   │\n│  │            ▼                │    │              ▼                 │   │\n│  │  ┌───────────────────────┐  │    │  ┌───────────────────────────┐ │   │\n│  │  │  Ratio Calculations   │  │    │  │  Scoring Engine           │ │   │\n│  │  │  (JavaScript)         │  │    │  │  (Server-side)            │ │   │\n│  │  └───────────────────────┘  │    │  └───────────────────────────┘ │   │\n│  │                             │    │                                 │   │\n│  └─────────────────────────────┘    └─────────────────────────────────┘   │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### 1.2 Component Responsibilities\n\n| Component | Location | Responsibility |\n|-----------|----------|----------------|\n| MediaPipe FaceLandmarker | Client (WASM) | Detect 478 landmarks on front-facing images |\n| Side Landmark API | Server | Detect landmarks on side profile images |\n| Landmark Mapper | Client | Convert raw indices to named anatomical points |\n| Ratio Calculator | Client | Compute facial ratios from landmark coordinates |\n| Scoring Engine | Server | Apply exponential decay scoring with ideal ranges |\n| Standards Database | Server | Store ideal min/max values for all ratios |\n\n---\n\n## 2. Data Flow Pipeline\n\n### 2.1 Complete Processing Flow\n\n```\n┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐\n│   CAPTURE    │────▶│   DETECT     │────▶│  CALCULATE   │────▶│    SCORE     │\n│   Image      │     │  Landmarks   │     │   Ratios     │     │   Results    │\n└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘\n       │                    │                    │                    │\n       ▼                    ▼                    ▼                    ▼\n  Front Photo         478 Points            50+ Ratios          0-10 Scores\n  Side Photo          106 Points           (angles, %)         + Deviation\n```\n\n### 2.2 Front Profile Pipeline\n\n```javascript\n// Step 1: Initialize MediaPipe FaceLandmarker\nconst faceLandmarker = await FaceLandmarker.createFromModelPath(\n    wasmFileset,\n    \"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task\"\n);\n\n// Step 2: Detect landmarks\nconst results = faceLandmarker.detect(imageElement);\nconst landmarks = results.faceLandmarks[0]; // Array of 478 {x, y, z} points\n\n// Step 3: Map to named points\nconst namedLandmarks = mapLandmarksToNames(landmarks, imageWidth, imageHeight);\n\n// Step 4: Calculate ratios\nconst ratios = calculateAllRatios(namedLandmarks, \"front\");\n\n// Step 5: Score each ratio\nconst scores = ratios.map(r => ({\n    name: r.name,\n    value: r.value,\n    score: calculateScore(r.value, r.idealMin, r.idealMax, r.decayRate)\n}));\n```\n\n### 2.3 Side Profile Pipeline\n\n```javascript\n// Step 1: Upload image to server\nconst formData = new FormData();\nformData.append(\"image\", imageBlob, \"side.jpg\");\n\n// Step 2: Server detects landmarks\nconst response = await fetch(\"/api/side-landmarks\", {\n    method: \"POST\",\n    body: formData\n});\n\n// Step 3: Receive landmark data\nconst { landmarks, direction, rotationAngle, bbox } = await response.json();\n\n// Step 4: Map to named anatomical points\nconst namedLandmarks = mapSideLandmarksToNames(landmarks, imageWidth, imageHeight);\n\n// Step 5: Calculate side-specific ratios\nconst ratios = calculateAllRatios(namedLandmarks, \"side\");\n```\n\n---\n\n## 3. Core Scoring Engine\n\n### 3.1 The Exponential Decay Scoring Function\n\nThis is the exact scoring algorithm extracted from the application:\n\n```javascript\n/**\n * Calculate a score (0-10) based on how close a value is to the ideal range.\n * Uses exponential decay for values outside the ideal range.\n *\n * @param {number} value - The measured ratio value\n * @param {number} idealMin - Minimum of ideal range\n * @param {number} idealMax - Maximum of ideal range\n * @param {number} decayRate - Rate of score decay (default 0.2)\n * @param {number} maxScore - Maximum possible score (default 10)\n * @returns {number} Score from 0 to 10\n */\nfunction calculateScore(value, idealMin, idealMax, decayRate = 0.2, maxScore = 10) {\n    const minScore = -maxScore;\n\n    let rawScore;\n\n    if (value >= idealMin && value <= idealMax) {\n        // Value is within ideal range - perfect score\n        rawScore = maxScore;\n    } else {\n        // Calculate distance from ideal range\n        const distance = value < idealMin\n            ? (idealMin - value)\n            : (value - idealMax);\n\n        // Apply exponential decay\n        // Score decreases exponentially the further from ideal\n        rawScore = minScore + (maxScore - minScore) * Math.exp(-decayRate * distance);\n    }\n\n    // Normalize to 0-10 scale\n    const range = maxScore - minScore;\n    const normalizedScore = (rawScore - minScore) / range * 10;\n\n    return Math.max(0, Math.min(10, normalizedScore));\n}\n```\n\n### 3.2 Mathematical Explanation\n\nThe exponential decay formula:\n\n```\n                    ┌─ maxScore                          if idealMin ≤ value ≤ idealMax\n                    │\nscore(value) = ─────┤\n                    │\n                    └─ minScore + (maxScore - minScore) × e^(-decay × distance)    otherwise\n```\n\nWhere:\n- `distance = |value - nearest_ideal_boundary|`\n- `decay` = 0.2 (default rate)\n- `e` = Euler's number (≈2.718)\n\n**Visualization of Score Curve:**\n\n```\nScore\n  10 │          ┌──────────────┐\n     │         ╱                ╲\n   8 │        ╱                  ╲\n     │       ╱                    ╲\n   6 │      ╱                      ╲\n     │     ╱                        ╲\n   4 │    ╱                          ╲\n     │   ╱                            ╲\n   2 │  ╱                              ╲\n     │ ╱                                ╲\n   0 │╱                                  ╲______________\n     └────────────────────────────────────────────────── Value\n              │        │        │\n           idealMin   ideal   idealMax\n                     range\n```\n\n### 3.3 Custom Curve Support\n\nFor ratios with non-standard scoring curves:\n\n```javascript\n/**\n * Calculate score using custom interpolation points\n *\n * @param {number} value - The measured value\n * @param {Array} customPoints - Array of {x, y} points defining the curve\n * @returns {number} Interpolated score (0-10)\n */\nfunction calculateScoreFromCurve(value, customPoints) {\n    // Sort points by x value\n    const sorted = [...customPoints].sort((a, b) => a.x - b.x);\n\n    // Find surrounding points for interpolation\n    for (let i = 0; i < sorted.length - 1; i++) {\n        if (value >= sorted[i].x && value <= sorted[i + 1].x) {\n            // Linear interpolation between points\n            const t = (value - sorted[i].x) / (sorted[i + 1].x - sorted[i].x);\n            return sorted[i].y + t * (sorted[i + 1].y - sorted[i].y);\n        }\n    }\n\n    // Extrapolate if outside range\n    if (value < sorted[0].x) return sorted[0].y;\n    return sorted[sorted.length - 1].y;\n}\n```\n\n---\n\n## 4. Landmark Detection System\n\n### 4.1 MediaPipe FaceLandmarker Setup\n\n```javascript\nimport { FaceLandmarker, FilesetResolver } from \"@mediapipe/tasks-vision\";\n\nasync function initializeFaceLandmarker() {\n    const wasmFileset = await FilesetResolver.forVisionTasks(\n        \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm\"\n    );\n\n    const faceLandmarker = await FaceLandmarker.createFromOptions(wasmFileset, {\n        baseOptions: {\n            modelAssetPath: \"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task\",\n            delegate: \"GPU\"\n        },\n        runningMode: \"IMAGE\",\n        numFaces: 1,\n        outputFacialTransformationMatrixes: true,\n        outputFaceBlendshapes: false\n    });\n\n    return faceLandmarker;\n}\n```\n\n### 4.2 Front Profile Landmark Index Map\n\n```javascript\n/**\n * MediaPipe FaceLandmarker index to anatomical point mapping\n * Based on MediaPipe's 478-point face mesh\n */\nconst FRONT_LANDMARK_INDICES = {\n    // Facial outline\n    chinBottom: 152,\n    chinLeft: 172,\n    chinRight: 397,\n\n    // Forehead\n    hairline: 10,        // Top of forehead\n    glabella: 9,         // Between eyebrows\n\n    // Eyes - Left\n    leftEyePupil: 468,   // Iris center (if available) or approximate\n    leftEyeMedialCanthus: 133,\n    leftEyeLateralCanthus: 33,\n    leftEyeUpperEyelid: 159,\n    leftEyeLowerEyelid: 145,\n    leftEyelidHoodEnd: 130,\n\n    // Eyes - Right\n    rightEyePupil: 473,\n    rightEyeMedialCanthus: 362,\n    rightEyeLateralCanthus: 263,\n    rightEyeUpperEyelid: 386,\n    rightEyeLowerEyelid: 374,\n    rightEyelidHoodEnd: 359,\n\n    // Eyebrows - Left\n    leftBrowInnerCorner: 107,\n    leftBrowHead: 66,\n    leftBrowPeak: 105,\n    leftBrowArch: 70,\n\n    // Eyebrows - Right\n    rightBrowInnerCorner: 336,\n    rightBrowHead: 296,\n    rightBrowPeak: 334,\n    rightBrowArch: 300,\n\n    // Nose\n    nasion: 6,           // Bridge of nose\n    noseBottom: 4,       // Tip of nose\n    nasalBase: 2,        // Base of nose\n    noseLeft: 129,       // Left nostril\n    noseRight: 358,      // Right nostril\n\n    // Mouth\n    cupidsBow: 0,        // Center upper lip\n    mouthMiddle: 13,     // Center of mouth\n    lowerLip: 14,        // Center lower lip\n    mouthLeft: 61,       // Left corner\n    mouthRight: 291,     // Right corner\n\n    // Cheeks\n    leftCheek: 234,      // Widest point left\n    rightCheek: 454,     // Widest point right\n\n    // Jaw\n    leftTopGonion: 172,  // Left jaw angle\n    rightTopGonion: 397, // Right jaw angle\n    leftBottomGonion: 140,\n    rightBottomGonion: 369,\n\n    // Temples\n    leftTemple: 127,\n    rightTemple: 356,\n\n    // Ears\n    leftOuterEar: 234,\n    rightOuterEar: 454,\n\n    // Neck\n    neckLeft: 177,\n    neckRight: 401\n};\n```\n\n### 4.3 Side Profile Landmark Index Map\n\n```javascript\n/**\n * Side profile landmark indices (custom model)\n * Used after /api/side-landmarks detection\n */\nconst SIDE_LANDMARK_INDICES = {\n    // Cranial\n    vertex: \"calculated\",    // Top of head (calculated)\n    occiput: \"calculated\",   // Back of head (calculated)\n\n    // Forehead\n    trichion: \"calculated\",  // Hairline\n    glabella: 104,           // Between brows\n\n    // Nose\n    nasion: 72,              // Bridge\n    rhinion: \"calculated\",   // Nasal bridge midpoint\n    supratip: \"calculated\",  // Above tip\n    pronasale: 83,           // Tip of nose\n    infratip: \"calculated\",  // Below tip\n    columella: \"calculated\", // Columella base\n    subnasale: \"calculated\", // Below nose\n    subalare: 77,            // Nostril base\n\n    // Lips\n    labraleSuperius: 67,     // Upper lip\n    labraleInferius: 59,     // Lower lip\n    sublabiale: \"calculated\",// Below lower lip\n    cheilion: 52,            // Corner of mouth\n\n    // Chin\n    pogonion: 24,            // Chin point\n    menton: \"calculated\",    // Chin bottom\n\n    // Jaw\n    gonionTop: \"calculated\", // Upper jaw angle\n    gonionBottom: 2,         // Lower jaw angle\n\n    // Ear\n    porion: \"calculated\",    // Ear canal\n    tragus: \"calculated\",    // Ear tragus\n    intertragicNotch: \"calculated\",\n\n    // Eye\n    orbitale: \"calculated\",  // Lower orbit\n    cornealApex: 40,         // Eye center\n\n    // Neck\n    cervicalPoint: \"calculated\",\n    neckPoint: \"calculated\",\n\n    // Cheek\n    cheekbone: \"calculated\"\n};\n```\n\n### 4.4 Calculated Landmark Functions\n\n```javascript\n/**\n * Calculate derived landmarks from raw detected points\n */\nconst CALCULATED_LANDMARKS = {\n    vertex: (landmarks) => {\n        const glabella = getLandmark(landmarks, 10);\n        const occiput = getLandmark(landmarks, 8);\n        const nasion = getLandmark(landmarks, 1);\n        const hairline = getLandmark(landmarks, 12);\n        const distance = euclidean(glabella, occiput);\n        return translatePoint(glabella, {\n            along: { from: nasion, to: hairline },\n            by: -distance\n        });\n    },\n\n    occiput: (landmarks) => {\n        const vertex = getLandmark(landmarks, 9);\n        const pronasale = getLandmark(landmarks, 83);\n        const distance = euclidean(vertex, pronasale);\n        return translatePoint(vertex, {\n            along: { from: pronasale, to: vertex },\n            by: distance\n        });\n    },\n\n    menton: (landmarks) => {\n        const chinFront = getLandmark(landmarks, 0);\n        const chinBottom = getLandmark(landmarks, 8);\n        return {\n            x: (chinFront.x + chinBottom.x) / 2,\n            y: (chinFront.y + chinBottom.y) / 2\n        };\n    },\n\n    rhinion: (landmarks, namedPoints) => {\n        if (!namedPoints.pronasale || !namedPoints.nasion) return null;\n        const pronasale = toPixels(namedPoints.pronasale, landmarks.imageWidth, landmarks.imageHeight);\n        return translatePoint(pronasale, {\n            along: { from: pronasale, to: toPixels(namedPoints.nasion, landmarks.imageWidth, landmarks.imageHeight) },\n            by: euclidean(getLandmark(landmarks, 74), getLandmark(landmarks, 72))\n        });\n    }\n    // ... additional calculated points\n};\n```\n\n---\n\n## 5. Ratio Calculation Functions\n\n### 5.1 Core Utility Functions\n\n```javascript\n/**\n * Calculate Euclidean distance between two points\n */\nfunction euclidean(point1, point2) {\n    const dx = point2.x - point1.x;\n    const dy = point2.y - point1.y;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Calculate midpoint between two points\n */\nfunction midpoint(point1, point2) {\n    return {\n        x: (point1.x + point2.x) / 2,\n        y: (point1.y + point2.y) / 2\n    };\n}\n\n/**\n * Safe division with fallback\n */\nfunction ratio(numerator, denominator, fallback = 0) {\n    if (!isFinite(numerator) || !isFinite(denominator) || Math.abs(denominator) < 1e-10) {\n        return fallback;\n    }\n    const result = numerator / denominator;\n    return isFinite(result) ? result : fallback;\n}\n\n/**\n * Calculate angle at vertex (in degrees)\n * Returns angle ABC where B is the vertex\n */\nfunction angle(pointA, vertex, pointC) {\n    const vectorBA = { x: pointA.x - vertex.x, y: pointA.y - vertex.y };\n    const vectorBC = { x: pointC.x - vertex.x, y: pointC.y - vertex.y };\n\n    const dotProduct = vectorBA.x * vectorBC.x + vectorBA.y * vectorBC.y;\n    const magnitudeProduct = Math.sqrt(vectorBA.x ** 2 + vectorBA.y ** 2) *\n                             Math.sqrt(vectorBC.x ** 2 + vectorBC.y ** 2);\n\n    if (Math.abs(magnitudeProduct) < 1e-10) return 0;\n\n    const cosAngle = Math.max(-1, Math.min(1, dotProduct / magnitudeProduct));\n    return (180 / Math.PI) * Math.acos(cosAngle);\n}\n```\n\n### 5.2 Front Profile Ratio Calculations\n\n```javascript\nconst FRONT_RATIO_CALCULATIONS = {\n    \"Midface Ratio\": (landmarks) => {\n        const leftPupil = landmarks.leftEyePupil;\n        const rightPupil = landmarks.rightEyePupil;\n        const cupidsBow = landmarks.cupidsBow;\n        if (!leftPupil || !rightPupil || !cupidsBow) return null;\n\n        const eyeWidth = Math.abs(rightPupil.x - leftPupil.x);\n        const eyeCenterY = (leftPupil.y + rightPupil.y) / 2;\n        return ratio(eyeWidth, Math.abs(cupidsBow.y - eyeCenterY));\n    },\n\n    \"Eye Separation Ratio\": (landmarks) => {\n        const leftPupil = landmarks.leftEyePupil;\n        const rightPupil = landmarks.rightEyePupil;\n        const leftCheek = landmarks.leftCheek;\n        const rightCheek = landmarks.rightCheek;\n        if (!leftPupil || !rightPupil || !leftCheek || !rightCheek) return null;\n\n        return 100 * ratio(\n            Math.abs(rightPupil.x - leftPupil.x),\n            Math.abs(rightCheek.x - leftCheek.x)\n        );\n    },\n\n    \"Total Facial Width to Height Ratio\": (landmarks) => {\n        const leftCheek = landmarks.leftCheek;\n        const rightCheek = landmarks.rightCheek;\n        const hairline = landmarks.hairline;\n        const chinBottom = landmarks.chinBottom;\n        if (!leftCheek || !rightCheek || !hairline || !chinBottom) return null;\n\n        return ratio(\n            Math.abs(chinBottom.y - hairline.y),\n            Math.abs(rightCheek.x - leftCheek.x)\n        );\n    },\n\n    \"Bigonial Width\": (landmarks) => {\n        const leftGonion = landmarks.leftTopGonion;\n        const rightGonion = landmarks.rightTopGonion;\n        const leftCheek = landmarks.leftCheek;\n        const rightCheek = landmarks.rightCheek;\n        if (!leftGonion || !rightGonion || !leftCheek || !rightCheek) return null;\n\n        return 100 * ratio(\n            Math.abs(rightGonion.x - leftGonion.x),\n            Math.abs(rightCheek.x - leftCheek.x)\n        );\n    },\n\n    \"Lateral Canthal Tilt\": (landmarks) => {\n        const leftMedial = landmarks.leftEyeMedialCanthus;\n        const leftLateral = landmarks.leftEyeLateralCanthus;\n        const rightMedial = landmarks.rightEyeMedialCanthus;\n        const rightLateral = landmarks.rightEyeLateralCanthus;\n        if (!leftMedial || !leftLateral || !rightMedial || !rightLateral) return null;\n\n        const leftTilt = (180 / Math.PI) * Math.atan2(\n            leftMedial.y - leftLateral.y,\n            leftMedial.x - leftLateral.x\n        );\n        const rightTilt = (180 / Math.PI) * Math.atan2(\n            rightMedial.y - rightLateral.y,\n            rightLateral.x - rightMedial.x\n        );\n        return (leftTilt + rightTilt) / 2;\n    },\n\n    \"Lower Third\": (landmarks) => {\n        const hairline = landmarks.hairline;\n        const noseBottom = landmarks.noseBottom;\n        const chinBottom = landmarks.chinBottom;\n        const leftBrowInner = landmarks.leftBrowInnerCorner;\n        const leftBrowHead = landmarks.leftBrowHead;\n        const rightBrowInner = landmarks.rightBrowInnerCorner;\n        const rightBrowHead = landmarks.rightBrowHead;\n        if (!hairline || !noseBottom || !chinBottom || !leftBrowInner ||\n            !leftBrowHead || !rightBrowInner || !rightBrowHead) return null;\n\n        const faceHeight = Math.abs(chinBottom.y - hairline.y);\n        return ((chinBottom.y - noseBottom.y) / faceHeight) * 100;\n    },\n\n    \"Middle Third\": (landmarks) => {\n        const hairline = landmarks.hairline;\n        const noseBottom = landmarks.noseBottom;\n        const chinBottom = landmarks.chinBottom;\n        const leftBrowInner = landmarks.leftBrowInnerCorner;\n        const leftBrowHead = landmarks.leftBrowHead;\n        const rightBrowInner = landmarks.rightBrowInnerCorner;\n        const rightBrowHead = landmarks.rightBrowHead;\n        if (!hairline || !noseBottom || !chinBottom || !leftBrowInner ||\n            !leftBrowHead || !rightBrowInner || !rightBrowHead) return null;\n\n        const faceHeight = Math.abs(chinBottom.y - hairline.y);\n        const browMid = midpoint(midpoint(leftBrowInner, leftBrowHead),\n                                  midpoint(rightBrowInner, rightBrowHead));\n        return ((noseBottom.y - browMid.y) / faceHeight) * 100;\n    },\n\n    \"Top Third\": (landmarks) => {\n        const hairline = landmarks.hairline;\n        const chinBottom = landmarks.chinBottom;\n        const leftBrowInner = landmarks.leftBrowInnerCorner;\n        const leftBrowHead = landmarks.leftBrowHead;\n        const rightBrowInner = landmarks.rightBrowInnerCorner;\n        const rightBrowHead = landmarks.rightBrowHead;\n        if (!hairline || !chinBottom || !leftBrowInner || !leftBrowHead ||\n            !rightBrowInner || !rightBrowHead) return null;\n\n        const faceHeight = Math.abs(chinBottom.y - hairline.y);\n        const browMid = midpoint(midpoint(leftBrowInner, leftBrowHead),\n                                  midpoint(rightBrowInner, rightBrowHead));\n        return ((browMid.y - hairline.y) / faceHeight) * 100;\n    },\n\n    \"Eye Aspect Ratio\": (landmarks) => {\n        const leftMedial = landmarks.leftEyeMedialCanthus;\n        const leftLateral = landmarks.leftEyeLateralCanthus;\n        const leftUpper = landmarks.leftEyeUpperEyelid;\n        const leftLower = landmarks.leftEyeLowerEyelid;\n        const rightMedial = landmarks.rightEyeMedialCanthus;\n        const rightLateral = landmarks.rightEyeLateralCanthus;\n        const rightUpper = landmarks.rightEyeUpperEyelid;\n        const rightLower = landmarks.rightEyeLowerEyelid;\n        if (!leftMedial || !leftLateral || !leftUpper || !leftLower ||\n            !rightMedial || !rightLateral || !rightUpper || !rightLower) return null;\n\n        const leftRatio = ratio(Math.abs(leftLateral.x - leftMedial.x),\n                                Math.abs(leftLower.y - leftUpper.y));\n        const rightRatio = ratio(Math.abs(rightLateral.x - rightMedial.x),\n                                 Math.abs(rightLower.y - rightUpper.y));\n        return (leftRatio + rightRatio) / 2;\n    },\n\n    \"Jaw Frontal Angle\": (landmarks) => {\n        const leftGonion = landmarks.leftBottomGonion;\n        const rightGonion = landmarks.rightBottomGonion;\n        const chinLeft = landmarks.chinLeft;\n        const chinRight = landmarks.chinRight;\n        if (!leftGonion || !rightGonion || !chinLeft || !chinRight) return null;\n\n        // Calculate angle between jaw lines\n        return 180 - angle(leftGonion, chinLeft, chinRight, rightGonion);\n    }\n};\n```\n\n### 5.3 Side Profile Ratio Calculations\n\n```javascript\nconst SIDE_RATIO_CALCULATIONS = {\n    \"Gonial Angle\": (landmarks) => {\n        const gonionTop = landmarks.gonionTop;\n        const gonionBottom = landmarks.gonionBottom;\n        const menton = landmarks.menton;\n        const tragus = landmarks.intertragicNotch;\n        if (!gonionTop || !gonionBottom || !menton || !tragus) return null;\n\n        const angle1 = Math.atan2(gonionTop.y - tragus.y, gonionTop.x - tragus.x);\n        const angle2 = Math.atan2(gonionBottom.y - menton.y, gonionBottom.x - menton.x);\n        let angleDiff = (180 / Math.PI) * Math.abs(angle1 - angle2);\n        return angleDiff > 180 ? 360 - angleDiff : angleDiff;\n    },\n\n    \"Nasolabial Angle\": (landmarks) => {\n        const columella = landmarks.columella;\n        const subnasale = landmarks.subnasale;\n        const labraleSuperius = landmarks.labraleSuperius;\n        if (!columella || !subnasale || !labraleSuperius) return null;\n\n        return angle(columella, subnasale, labraleSuperius);\n    },\n\n    \"Nasofrontal Angle\": (landmarks) => {\n        const glabella = landmarks.glabella;\n        const nasion = landmarks.nasion;\n        const supratip = landmarks.supratip;\n        if (!glabella || !nasion || !supratip) return null;\n\n        return angle(glabella, nasion, supratip);\n    },\n\n    \"Mentolabial Angle\": (landmarks) => {\n        const labraleInferius = landmarks.labraleInferius;\n        const sublabiale = landmarks.sublabiale;\n        const pogonion = landmarks.pogonion;\n        if (!labraleInferius || !sublabiale || !pogonion) return null;\n\n        return angle(labraleInferius, sublabiale, pogonion);\n    },\n\n    \"Facial Convexity (Glabella)\": (landmarks) => {\n        const glabella = landmarks.glabella;\n        const subnasale = landmarks.subnasale;\n        const pogonion = landmarks.pogonion;\n        if (!glabella || !subnasale || !pogonion) return null;\n\n        return angle(glabella, subnasale, pogonion);\n    },\n\n    \"Total Facial Convexity\": (landmarks) => {\n        const glabella = landmarks.glabella;\n        const pronasale = landmarks.pronasale;\n        const pogonion = landmarks.pogonion;\n        if (!glabella || !pronasale || !pogonion) return null;\n\n        const baseAngle = angle(glabella, pronasale, pogonion);\n\n        // Determine if convex or concave\n        const v1 = { x: glabella.x - pronasale.x, y: glabella.y - pronasale.y };\n        const v2 = { x: pogonion.x - pronasale.x, y: pogonion.y - pronasale.y };\n        const cross = v1.x * v2.y - v1.y * v2.x;\n\n        return cross < 0 ? baseAngle : 360 - baseAngle;\n    },\n\n    \"Submental Cervical Angle\": (landmarks) => {\n        const menton = landmarks.menton;\n        const cervicalPoint = landmarks.cervicalPoint;\n        const neckPoint = landmarks.neckPoint;\n        if (!menton || !cervicalPoint || !neckPoint) return null;\n\n        return angle(menton, cervicalPoint, neckPoint);\n    },\n\n    \"Nasal Tip Angle\": (landmarks) => {\n        const supratip = landmarks.supratip;\n        const pronasale = landmarks.pronasale;\n        const infratip = landmarks.infratip;\n        if (!supratip || !pronasale || !infratip) return null;\n\n        return angle(supratip, pronasale, infratip);\n    },\n\n    \"Nasofacial Angle\": (landmarks) => {\n        const nasion = landmarks.nasion;\n        const pronasale = landmarks.pronasale;\n        const pogonion = landmarks.pogonion;\n        if (!nasion || !pronasale || !pogonion) return null;\n\n        const baseAngle = angle(pronasale, nasion, pogonion);\n        return baseAngle > 90 ? 180 - baseAngle : baseAngle;\n    },\n\n    \"Mandibular Plane Angle\": (landmarks) => {\n        const gonionTop = landmarks.gonionTop;\n        const gonionBottom = landmarks.gonionBottom;\n        const menton = landmarks.menton;\n        const tragus = landmarks.tragus;\n        if (!gonionTop || !gonionBottom || !menton || !tragus) return null;\n\n        // Calculate intersection of mandibular plane with Frankfort horizontal\n        // Complex geometric calculation...\n        // Returns angle in degrees\n    }\n};\n```\n\n---\n\n## 6. Decoded Scoring Standards Database\n\n### 6.1 Confirmed Ratios (Clear Names)\n\n| Ratio Name | Ideal Min | Ideal Max | Unit | Profile | Decay Rate |\n|------------|-----------|-----------|------|---------|------------|\n| Top Third | 29.00 | 33.00 | % | Front | 0.2 |\n| Middle Third | 31.00 | 34.00 | % | Front | 0.2 |\n| Lower Third | 33.40 | 37.50 | % | Front | 0.2 |\n| Eye Separation Ratio | 45.00 | 47.50 | % | Front | 0.2 |\n| Eyebrow Low Setedness | 0.00 | 0.66 | x | Front | 0.2 |\n| Total Facial Width to Height Ratio | 1.33 | 1.38 | x | Front | 0.2 |\n| Gonial Angle | 113.00 | 123.00 | ° | Side | 0.2 |\n| Facial Convexity (Glabella) | 167.00 | 176.00 | ° | Side | 0.2 |\n| Submental Cervical Angle | 92.00 | 110.00 | ° | Side | 0.2 |\n| Recession relative to Frankfort plane | 0.00 | 15.00 | mm | Side | 0.2 |\n\n### 6.2 Fingerprinted Ratios (Decoded from Obfuscation)\n\nBased on anthropometric analysis matching ideal ranges to scientific literature:\n\n| Predicted Ratio Name | Ideal Min | Ideal Max | Unit | Confidence | Evidence |\n|---------------------|-----------|-----------|------|------------|----------|\n| **Nasolabial Angle** | 60.54 | 105.97 | ° | 95% | Matches Farkas 90-105° standard |\n| **Nasofrontal Angle** | 142.50 | 150.12 | ° | 95% | Matches Powell 130-140° (scaled) |\n| **Mentolabial Angle** | 65.19 | 101.55 | ° | 85% | Matches standard 80-120° |\n| **Eye Aspect Ratio** | 2.44 | 2.89 | x | 85% | Matches Farkas palpebral fissure 2.5-3.0 |\n| **Lower Lip E-Line Position** | -25.61 | -11.04 | DW | 90% | Ricketts E-line standard (scaled) |\n| **Upper Lip E-Line Position** | -18.63 | -8.83 | DW | 90% | Upper lip E-line standard (scaled) |\n| **Upper Lip S-Line Position** | -4.66 | 0.00 | DW | 75% | Steiner S-line standard |\n| **Lower Lip S-Line Position** | -2.33 | 2.21 | DW | 75% | S-line balanced position |\n| **Upper Lip Burstone Line** | -2.33 | 2.21 | DW | 70% | Burstone line standard |\n| **Deviation of IAA & JFA** | 0.00 | 11.04 | DW | 85% | Zero = perfect symmetry |\n| **Ear Protrusion Angle** | 0.00 | 17.66 | ° | 80% | Standard 15-20° from head |\n| **Bigonial Width %** | 37.25 | 57.40 | % | 80% | Jaw-to-face width ratio |\n| **Bitemporal Width %** | 46.57 | 52.98 | % | 80% | Temple-to-cheek ratio |\n| **Chin to Philtrum Ratio** | 4.42 | 4.50 | DW | 80% | Very tight range (critical ratio) |\n| **Total Facial Convexity** | 135.05 | 172.19 | ° | 85% | Standard 140-150° |\n| **Nasal Tip Angle** | 139.70 | 158.95 | ° | 70% | Nasal tip definition |\n| **Mouth Width to Nose Width** | 2.77 | 3.78 | x | 65% | Powell 1.5x (scaled ~3.0) |\n| **Lower Lip to Upper Lip Ratio** | 4.19 | 4.46 | DW | 70% | Standard 1:1.6-2.0 (scaled) |\n| **Ipsilateral Alar Angle** | 26.08 | 36.65 | ° | 60% | Midface width relationship |\n| **Cheekbone Height %** | 23.28 | 57.40 | % | 65% | Position as % of face height |\n| **Mandibular Plane Angle** | 41.91 | 97.13 | DW | 65% | Wide range (scaled 20-30°) |\n\n### 6.3 Understanding the \"DW\" Unit\n\nThe \"DW\" (Digital Width) unit appears to be a **normalized measurement system**:\n\n```\nDW = Actual_Measurement × Scale_Factor\n\nWhere Scale_Factor ≈ 10 for mm measurements\n      Scale_Factor ≈ 100 for small ratios\n```\n\n**Conversion Guide:**\n- Values 0-50 DW → Likely percentages or small ratios\n- Values 50-200 DW → Likely angles in degrees or scaled mm\n- Values 300-800 DW → Likely mm measurements × 10 or complex scaled ratios\n\n### 6.4 Complete Ratio Configuration Schema\n\n```javascript\nconst RATIO_CONFIG = {\n    \"Top Third\": {\n        name: \"Top Third\",\n        profileType: \"front\",\n        idealMin: 29.00,\n        idealMax: 33.00,\n        unit: \"%\",\n        decayRate: 0.2,\n        category: \"Facial Proportions\",\n        description: \"Percentage of face height from hairline to brow line\",\n        landmarks: [\"hairline\", \"leftBrowHead\", \"leftBrowInnerCorner\",\n                   \"rightBrowHead\", \"rightBrowInnerCorner\", \"chinBottom\"]\n    },\n    \"Nasolabial Angle\": {\n        name: \"Nasolabial Angle\",\n        profileType: \"side\",\n        idealMin: 90.00,  // Unscaled standard value\n        idealMax: 105.00,\n        unit: \"°\",\n        decayRate: 0.2,\n        category: \"Nasal Angles\",\n        description: \"Angle between columella and upper lip\",\n        landmarks: [\"columella\", \"subnasale\", \"labraleSuperius\"],\n        scientificReference: \"Farkas LG, 1994\"\n    },\n    // ... additional configurations\n};\n```\n\n---\n\n## 7. Implementation Strategy\n\n### 7.1 Required Libraries\n\n```json\n{\n  \"dependencies\": {\n    \"@mediapipe/tasks-vision\": \"^0.10.0\",\n    \"react\": \"^18.0.0\",\n    \"next\": \"^14.0.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\"\n  }\n}\n```\n\n**Python Backend (Alternative):**\n```\nmediapipe>=0.10.0\nopencv-python>=4.8.0\nnumpy>=1.24.0\nflask>=2.3.0  # or fastapi\n```\n\n### 7.2 Project Structure\n\n```\nfacial-analysis/\n├── src/\n│   ├── lib/\n│   │   ├── mediapipe/\n│   │   │   ├── faceLandmarker.ts      # MediaPipe initialization\n│   │   │   └── landmarkMapper.ts       # Index to name mapping\n│   │   ├── calculations/\n│   │   │   ├── ratios.ts              # Ratio calculation functions\n│   │   │   ├── scoring.ts             # Score calculation engine\n│   │   │   └── utilities.ts           # Math helper functions\n│   │   ├── standards/\n│   │   │   ├── idealRanges.ts         # Ideal min/max database\n│   │   │   └── ratioConfig.ts         # Full ratio configurations\n│   │   └── types/\n│   │       └── index.ts               # TypeScript interfaces\n│   ├── components/\n│   │   ├── FaceCapture.tsx            # Camera/upload component\n│   │   ├── AnalysisResults.tsx        # Score display\n│   │   └── RatioVisualization.tsx     # Overlay visualization\n│   └── api/\n│       └── side-landmarks/\n│           └── route.ts               # Side profile API\n├── public/\n│   └── models/                        # MediaPipe model files\n└── package.json\n```\n\n### 7.3 TypeScript Interfaces\n\n```typescript\ninterface Point {\n    x: number;\n    y: number;\n    z?: number;\n}\n\ninterface NamedLandmarks {\n    [key: string]: Point | null;\n}\n\ninterface RatioConfig {\n    name: string;\n    profileType: \"front\" | \"side\";\n    idealMin: number;\n    idealMax: number;\n    unit: string;\n    decayRate: number;\n    category: string;\n    description: string;\n    landmarks: string[];\n    calculationFn?: (landmarks: NamedLandmarks) => number | null;\n}\n\ninterface RatioResult {\n    name: string;\n    value: number | null;\n    score: number | null;\n    standardizedScore: number;\n    idealMin: number;\n    idealMax: number;\n    unit: string;\n    deviation: \"below\" | \"ideal\" | \"above\";\n    isIdeal: boolean;\n}\n\ninterface AnalysisResult {\n    frontRatios: RatioResult[];\n    sideRatios: RatioResult[];\n    overallScore: number;\n    categoryScores: { [category: string]: number };\n    landmarks: {\n        front: NamedLandmarks;\n        side: NamedLandmarks;\n    };\n}\n```\n\n### 7.4 Quick Start Implementation\n\n```typescript\n// main.ts - Minimal implementation\n\nimport { FaceLandmarker, FilesetResolver } from \"@mediapipe/tasks-vision\";\nimport { FRONT_LANDMARK_INDICES, FRONT_RATIO_CALCULATIONS, RATIO_CONFIG } from \"./config\";\n\nclass FacialAnalyzer {\n    private faceLandmarker: FaceLandmarker | null = null;\n\n    async initialize() {\n        const wasmFileset = await FilesetResolver.forVisionTasks(\n            \"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm\"\n        );\n\n        this.faceLandmarker = await FaceLandmarker.createFromModelPath(\n            wasmFileset,\n            \"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task\"\n        );\n    }\n\n    analyzeFrontProfile(imageElement: HTMLImageElement): AnalysisResult {\n        if (!this.faceLandmarker) throw new Error(\"Not initialized\");\n\n        // Detect landmarks\n        const results = this.faceLandmarker.detect(imageElement);\n        if (!results.faceLandmarks.length) throw new Error(\"No face detected\");\n\n        const rawLandmarks = results.faceLandmarks[0];\n\n        // Map to named points\n        const namedLandmarks = this.mapLandmarks(rawLandmarks, imageElement);\n\n        // Calculate ratios\n        const ratios = this.calculateRatios(namedLandmarks, \"front\");\n\n        // Score ratios\n        const scoredRatios = this.scoreRatios(ratios);\n\n        return {\n            frontRatios: scoredRatios,\n            sideRatios: [],\n            overallScore: this.calculateOverallScore(scoredRatios),\n            categoryScores: this.calculateCategoryScores(scoredRatios),\n            landmarks: { front: namedLandmarks, side: {} }\n        };\n    }\n\n    private mapLandmarks(raw: Point[], image: HTMLImageElement): NamedLandmarks {\n        const named: NamedLandmarks = {};\n\n        for (const [name, index] of Object.entries(FRONT_LANDMARK_INDICES)) {\n            if (typeof index === \"number\" && raw[index]) {\n                named[name] = {\n                    x: raw[index].x * image.width,\n                    y: raw[index].y * image.height\n                };\n            }\n        }\n\n        return named;\n    }\n\n    private calculateRatios(landmarks: NamedLandmarks, profile: \"front\" | \"side\") {\n        const calculations = profile === \"front\"\n            ? FRONT_RATIO_CALCULATIONS\n            : SIDE_RATIO_CALCULATIONS;\n\n        return Object.entries(calculations).map(([name, fn]) => ({\n            name,\n            value: fn(landmarks),\n            config: RATIO_CONFIG[name]\n        }));\n    }\n\n    private scoreRatios(ratios: any[]): RatioResult[] {\n        return ratios.map(r => {\n            const score = r.value !== null\n                ? this.calculateScore(r.value, r.config.idealMin, r.config.idealMax, r.config.decayRate)\n                : null;\n\n            return {\n                name: r.name,\n                value: r.value,\n                score,\n                standardizedScore: score ?? 0,\n                idealMin: r.config.idealMin,\n                idealMax: r.config.idealMax,\n                unit: r.config.unit,\n                deviation: this.getDeviation(r.value, r.config.idealMin, r.config.idealMax),\n                isIdeal: r.value !== null && r.value >= r.config.idealMin && r.value <= r.config.idealMax\n            };\n        });\n    }\n\n    private calculateScore(value: number, min: number, max: number, decay: number = 0.2): number {\n        const maxScore = 10;\n        const minScore = -maxScore;\n\n        let rawScore: number;\n        if (value >= min && value <= max) {\n            rawScore = maxScore;\n        } else {\n            const distance = value < min ? (min - value) : (value - max);\n            rawScore = minScore + (maxScore - minScore) * Math.exp(-decay * distance);\n        }\n\n        const range = maxScore - minScore;\n        return Math.max(0, Math.min(10, ((rawScore - minScore) / range) * 10));\n    }\n\n    private getDeviation(value: number | null, min: number, max: number): \"below\" | \"ideal\" | \"above\" {\n        if (value === null) return \"ideal\";\n        if (value < min) return \"below\";\n        if (value > max) return \"above\";\n        return \"ideal\";\n    }\n\n    private calculateOverallScore(ratios: RatioResult[]): number {\n        const validScores = ratios.filter(r => r.score !== null).map(r => r.score!);\n        return validScores.length ? validScores.reduce((a, b) => a + b, 0) / validScores.length : 0;\n    }\n\n    private calculateCategoryScores(ratios: RatioResult[]): { [key: string]: number } {\n        const categories: { [key: string]: number[] } = {};\n\n        for (const ratio of ratios) {\n            const category = RATIO_CONFIG[ratio.name]?.category || \"Other\";\n            if (!categories[category]) categories[category] = [];\n            if (ratio.score !== null) categories[category].push(ratio.score);\n        }\n\n        const scores: { [key: string]: number } = {};\n        for (const [cat, values] of Object.entries(categories)) {\n            scores[cat] = values.length ? values.reduce((a, b) => a + b, 0) / values.length : 0;\n        }\n\n        return scores;\n    }\n}\n\nexport default FacialAnalyzer;\n```\n\n---\n\n## 8. API Reference\n\n### 8.1 Side Landmarks API\n\n**Endpoint:** `POST /api/side-landmarks`\n\n**Request:**\n```\nContent-Type: multipart/form-data\n\nFields:\n- image: JPEG/PNG file (side profile photo)\n```\n\n**Response:**\n```json\n{\n    \"success\": true,\n    \"data\": {\n        \"landmarks\": [\n            { \"x\": 0.123, \"y\": 0.456 },\n            // ... 106 landmark points\n        ],\n        \"direction\": \"left\",  // or \"right\"\n        \"rotationAngle\": 2.5,\n        \"center\": { \"x\": 0.5, \"y\": 0.5 },\n        \"crop\": {\n            \"x\": 100,\n            \"y\": 50,\n            \"width\": 400,\n            \"height\": 500,\n            \"scale\": 1.2\n        },\n        \"bbox\": {\n            \"minX\": 100,\n            \"minY\": 50,\n            \"maxX\": 500,\n            \"maxY\": 550\n        }\n    }\n}\n```\n\n### 8.2 Analysis API\n\n**Endpoint:** `POST /api/faces`\n\n**Request:**\n```json\n{\n    \"frontPhotoUrl\": \"data:image/jpeg;base64,...\",\n    \"sidePhotoUrl\": \"data:image/jpeg;base64,...\",\n    \"gender\": \"male\",\n    \"ethnicity\": \"caucasian\"\n}\n```\n\n**Response:**\n```json\n{\n    \"success\": true,\n    \"faceId\": \"abc123\",\n    \"frontRatios\": [\n        {\n            \"name\": \"Eye Separation Ratio\",\n            \"value\": 46.5,\n            \"score\": 9.2,\n            \"standardizedScore\": 9.2,\n            \"unit\": \"%\",\n            \"idealMin\": 45.0,\n            \"idealMax\": 47.5\n        }\n    ],\n    \"sideRatios\": [...],\n    \"overallScore\": 7.8\n}\n```\n\n---\n\n## Appendix A: Scientific References\n\n1. **Farkas LG** (1994). \"Anthropometry of the Head and Face\" - Primary source for facial proportions\n2. **Powell N, Humphreys B** (1984). \"Proportions of the Aesthetic Face\" - Golden ratio applications\n3. **Ricketts RM** (1968). \"The Esthetic E-Plane\" - E-line lip position standards\n4. **Steiner CC** (1959). \"Cephalometrics for You and Me\" - S-line standards\n5. **Burstone CJ** (1967). \"Lip Posture and Its Significance\" - Burstone line\n\n---\n\n## Appendix B: Changelog\n\n| Version | Date | Changes |\n|---------|------|---------|\n| 1.0 | Dec 2024 | Initial reverse-engineering documentation |\n\n---\n\n*This document was created through reverse-engineering of publicly accessible web application code for educational and research purposes.*\n","numLines":1241,"startLine":1,"totalLines":1241}}}
{"parentUuid":"8479e8f6-2e84-4c3f-b09a-f70fd1453bf8","isSidechain":true,"userType":"external","cwd":"/Users/imorgado/LOOKSMAXX","sessionId":"e587686a-bce3-4666-abc5-b08c2aebde91","version":"2.0.70","gitBranch":"","agentId":"aaf419e","slug":"humming-honking-locket","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QRmVbb5pj1cqTKytwnWkyE","type":"message","role":"assistant","content":[{"type":"text","text":"Based on my thorough analysis of the TECHNICAL_SPECS.md file, here are the detailed findings on the Angular measurements you requested:\n\n## ANGULAR MEASUREMENTS ANALYSIS\n\n### 1. NASOLABIAL ANGLE\n\n**Definition:**\nThe angle between the columella (septum/nose base) and the upper lip.\n\n**Reference Points:**\n- **Columella**: The structure between and below the nostrils\n- **Subnasale**: The point directly below the nose where it meets the upper lip\n- **Labrale Superius**: The upper lip edge/margin\n\n**Calculation Formula:**\n```javascript\nangle(columella, subnasale, labraleSuperius)\n```\nWhere the angle is calculated at the vertex (subnasale), measuring the angle between vectors from subnasale to columella and from subnasale to labraleSuperius.\n\n**Ideal Range:**\n- **Minimum**: 60.54°\n- **Maximum**: 105.97°\n- **Scientific Standard**: 90-105° (Farkas, 1994)\n- **Confidence Level**: 95%\n\n**Decay Rate**: 0.2\n\n**Profile Type**: Side profile only\n\n---\n\n### 2. NASOFRONTAL ANGLE\n\n**Definition:**\nThe angle between the glabella (area between the eyebrows) and the nasal supratip, measured at the nasion (bridge of nose).\n\n**Reference Points:**\n- **Glabella**: Located between eyebrows (MediaPipe index 104 for side profile)\n- **Nasion**: Bridge of nose (MediaPipe index 72 for side profile)\n- **Supratip**: The area above the nasal tip (calculated landmark)\n\n**Calculation Formula:**\n```javascript\nangle(glabella, nasion, supratip)\n```\nAngle is calculated at the vertex (nasion), measuring between vectors from nasion to glabella and from nasion to supratip.\n\n**Ideal Range:**\n- **Minimum**: 142.50°\n- **Maximum**: 150.12°\n- **Scientific Standard**: Powell 130-140° (scaled)\n- **Confidence Level**: 95%\n\n**Decay Rate**: 0.2\n\n**Profile Type**: Side profile only\n\n---\n\n### 3. GONIAL ANGLE\n\n**Definition:**\nThe angle of the jaw at the gonion (jaw angle). This represents the angle between the upper and lower jaw lines at their junction point.\n\n**Reference Points:**\n- **Gonion Top**: Upper jaw angle point (calculated landmark)\n- **Gonion Bottom**: Lower jaw angle point (MediaPipe index 2 for side profile)\n- **Menton**: Chin point (calculated landmark)\n- **Tragus/Intertragic Notch**: Reference point for angle measurement\n\n**Calculation Formula:**\n```javascript\nconst angle1 = Math.atan2(gonionTop.y - tragus.y, gonionTop.x - tragus.x);\nconst angle2 = Math.atan2(gonionBottom.y - menton.y, gonionBottom.x - menton.x);\nlet angleDiff = (180 / Math.PI) * Math.abs(angle1 - angle2);\nreturn angleDiff > 180 ? 360 - angleDiff : angleDiff;\n```\n\n**Ideal Range:**\n- **Minimum**: 113.00°\n- **Maximum**: 123.00°\n- **Unit**: Degrees (°)\n- **Confidence Level**: Confirmed\n\n**Decay Rate**: 0.2\n\n**Profile Type**: Side profile only\n\n---\n\n### 4. MENTOLABIAL ANGLE\n\n**Definition:**\nThe angle between the lower lip and the chin, measured at the sublabial point (below the lower lip).\n\n**Reference Points:**\n- **Labrale Inferius**: Lower lip edge/margin (MediaPipe index 59 for side profile)\n- **Sublabiale**: Point below the lower lip (calculated landmark)\n- **Pogonion**: Most anterior (forward) point of the chin (MediaPipe index 24 for side profile)\n\n**Calculation Formula:**\n```javascript\nangle(labraleInferius, sublabiale, pogonion)\n```\nAngle is calculated at the vertex (sublabiale), measuring between vectors from sublabiale to labraleInferius and from sublabiale to pogonion.\n\n**Ideal Range:**\n- **Minimum**: 65.19°\n- **Maximum**: 101.55°\n- **Scientific Standard**: 80-120° range\n- **Confidence Level**: 85%\n\n**Decay Rate**: 0.2\n\n**Profile Type**: Side profile only\n\n---\n\n## UNIVERSAL ANGLE CALCULATION FUNCTION\n\nAll angles use this core algorithm:\n\n```javascript\nfunction angle(pointA, vertex, pointC) {\n    // Create vectors from vertex to each point\n    const vectorBA = { x: pointA.x - vertex.x, y: pointA.y - vertex.y };\n    const vectorBC = { x: pointC.x - vertex.x, y: pointC.y - vertex.y };\n\n    // Calculate dot product of vectors\n    const dotProduct = vectorBA.x * vectorBC.x + vectorBA.y * vectorBC.y;\n    \n    // Calculate magnitudes\n    const magnitudeProduct = Math.sqrt(vectorBA.x ** 2 + vectorBA.y ** 2) *\n                             Math.sqrt(vectorBC.x ** 2 + vectorBC.y ** 2);\n\n    // Handle edge case: prevent division by zero\n    if (Math.abs(magnitudeProduct) < 1e-10) return 0;\n\n    // Clamp cosine to valid range [-1, 1] to avoid NaN\n    const cosAngle = Math.max(-1, Math.min(1, dotProduct / magnitudeProduct));\n    \n    // Convert from radians to degrees\n    return (180 / Math.PI) * Math.acos(cosAngle);\n}\n```\n\n---\n\n## SCORING METHODOLOGY FOR ANGLES\n\nAll four angles are scored using the exponential decay function:\n\n```javascript\nfunction calculateScore(value, idealMin, idealMax, decayRate = 0.2, maxScore = 10) {\n    const minScore = -maxScore;\n    let rawScore;\n\n    if (value >= idealMin && value <= idealMax) {\n        // Perfect score if within ideal range\n        rawScore = maxScore;\n    } else {\n        // Calculate distance from nearest ideal boundary\n        const distance = value < idealMin \n            ? (idealMin - value) \n            : (value - idealMax);\n        \n        // Apply exponential decay: lower scores further from ideal\n        rawScore = minScore + (maxScore - minScore) * Math.exp(-decayRate * distance);\n    }\n\n    // Normalize to 0-10 scale\n    const range = maxScore - minScore;\n    const normalizedScore = (rawScore - minScore) / range * 10;\n    \n    return Math.max(0, Math.min(10, normalizedScore));\n}\n```\n\n---\n\n## SIDE PROFILE LANDMARKS USED\n\nAll four angular measurements require side profile analysis and use these indexed landmarks:\n\n| Landmark | Index | Used In |\n|----------|-------|---------|\n| Glabella | 104 | Nasofrontal |\n| Nasion | 72 | Nasofrontal |\n| Subalare | 77 | Nasolabial |\n| Pronasale | 83 | Nasolabial |\n| Labrale Superius | 67 | Nasolabial |\n| Labrale Inferius | 59 | Mentolabial |\n| Pogonion | 24 | Mentolabial |\n| Gonion Bottom | 2 | Gonial |\n\n---\n\n## KEY CALCULATION DETAILS\n\n**Coordinate System**: All points are normalized to image dimensions (0-1 range from MediaPipe, then scaled to pixel coordinates).\n\n**Decimal Precision**: Values are typically returned to 2-3 decimal places.\n\n**Validation**: All angle calculations include magnitude checks to prevent division by zero and NaN errors.\n\n**Units**: All angles are expressed in degrees (0-180° typically, though the calculation can theoretically produce 0-360°).\n\n**Confidence Mapping**: The system uses these confidence levels based on scientific literature:\n- Nasolabial: 95% (matches Farkas standard)\n- Nasofrontal: 95% (scaled from Powell)\n- Mentolabial: 85% (standard range matched)\n- Gonial: Confirmed (no confidence percentage listed)"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":18061,"cache_read_input_tokens":9804,"cache_creation":{"ephemeral_5m_input_tokens":18061,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWDNirT6th1RHX1kWE6Qi","type":"assistant","uuid":"ee95bc62-efd0-474d-87bd-7c142cd40324","timestamp":"2025-12-18T02:37:30.858Z"}
