     1→/* global URL */
     2→/**
     3→ * Phase 5 End-to-End Tests
     4→ *
     5→ * Tests all core endpoints:
     6→ * - /fillers - Filler word detection
     7→ * - /export/captions - Caption export (SRT/VTT/TXT/JSON)
     8→ * - /batch/* - Batch processing endpoints
     9→ * - Presets - Detection preset profiles
    10→ * - Retry logic - API retry with backoff
    11→ * - Cache limit - LRU cache eviction
    12→ */
    13→
    14→const https = require('https');
    15→const { toSRT, toVTT, toPlainText, toJSON, groupWordsIntoCaptions } = require('../services/captionExporter');
    16→
    17→const BASE_URL = 'https://127.0.0.1:3847';
    18→const TEST_CUSTOMER_ID = 'cus_test_phase5_e2e';
    19→
    20→// Allow self-signed certs
    21→const agent = new https.Agent({ rejectUnauthorized: false });
    22→
    23→/**
    24→ * Helper: Make HTTPS request
    25→ */
    26→function request(method, path, body = null) {
    27→  return new Promise((resolve, reject) => {
    28→    const url = new URL(path, BASE_URL);
    29→    const options = {
    30→      method,
    31→      hostname: url.hostname,
    32→      port: url.port,
    33→      path: url.pathname,
    34→      headers: {
    35→        'Content-Type': 'application/json',
    36→        'x-stripe-customer-id': TEST_CUSTOMER_ID
    37→      },
    38→      agent
    39→    };
    40→
    41→    const req = https.request(options, (res) => {
    42→      let data = '';
    43→      res.on('data', (chunk) => data += chunk);
    44→      res.on('end', () => {
    45→        try {
    46→          resolve({ status: res.statusCode, data: JSON.parse(data) });
    47→        } catch (_e) {
    48→          resolve({ status: res.statusCode, data: data });
    49→        }
    50→      });
    51→    });
    52→
    53→    req.on('error', reject);
    54→    if (body) req.write(JSON.stringify(body));
    55→    req.end();
    56→  });
    57→}
    58→
    59→// Mock transcript for testing
    60→const mockTranscript = {
    61→  text: "Hello um I think like you know we should basically um test this. The quick brown fox.",
    62→  words: [
    63→    { word: "Hello", start: 0.0, end: 0.5 },
    64→    { word: "um", start: 0.6, end: 0.8 },
    65→    { word: "I", start: 0.9, end: 1.0 },
    66→    { word: "think", start: 1.1, end: 1.4 },
    67→    { word: "like", start: 1.5, end: 1.7 },
    68→    { word: "you", start: 1.8, end: 1.9 },
    69→    { word: "know", start: 2.0, end: 2.2 },
    70→    { word: "we", start: 2.3, end: 2.4 },
    71→    { word: "should", start: 2.5, end: 2.8 },
    72→    { word: "basically", start: 2.9, end: 3.4 },
    73→    { word: "um", start: 3.5, end: 3.7 },
    74→    { word: "test", start: 3.8, end: 4.1 },
    75→    { word: "this", start: 4.2, end: 4.5 },
    76→    { word: "The", start: 5.0, end: 5.2 },
    77→    { word: "quick", start: 5.3, end: 5.6 },
    78→    { word: "brown", start: 5.7, end: 6.0 },
    79→    { word: "fox", start: 6.1, end: 6.4 }
    80→  ],
    81→  language: "en",
    82→  duration: 7.0
    83→};
    84→
    85→// =============================================================================
    86→// Test: Caption Exporter Service (Unit Tests)
    87→// =============================================================================
    88→
    89→function testCaptionExporterService() {
    90→  console.log('\n=== Test: Caption Exporter Service ===');
    91→  let passed = 0;
    92→  let failed = 0;
    93→
    94→  // Test word grouping
    95→  console.log('Testing word grouping...');
    96→  const captions = groupWordsIntoCaptions(mockTranscript.words, {
    97→    maxWordsPerCaption: 4,
    98→    maxDuration: 3
    99→  });
   100→
   101→  if (captions.length > 0) {
   102→    console.log(`✓ Grouped ${mockTranscript.words.length} words into ${captions.length} captions`);
   103→    passed++;
   104→  } else {
   105→    console.error('✗ Word grouping failed');
   106→    failed++;
   107→  }
   108→
   109→  // Test SRT generation
   110→  console.log('Testing SRT generation...');
   111→  const srt = toSRT(mockTranscript, { maxWordsPerCaption: 4 });
   112→  if (srt.includes('-->') && srt.includes('1\n')) {
   113→    console.log('✓ SRT format generated correctly');
   114→    passed++;
   115→  } else {
   116→    console.error('✗ SRT format invalid');
   117→    failed++;
   118→  }
   119→
   120→  // Test VTT generation
   121→  console.log('Testing VTT generation...');
   122→  const vtt = toVTT(mockTranscript, { maxWordsPerCaption: 4 });
   123→  if (vtt.startsWith('WEBVTT') && vtt.includes('-->')) {
   124→    console.log('✓ VTT format generated correctly');
   125→    passed++;
   126→  } else {
   127→    console.error('✗ VTT format invalid');
   128→    failed++;
   129→  }
   130→
   131→  // Test plain text generation
   132→  console.log('Testing plain text generation...');
   133→  const txt = toPlainText(mockTranscript, { includeTimestamps: true });
   134→  if (txt.includes('[') && txt.includes(']')) {
   135→    console.log('✓ Plain text with timestamps generated correctly');
   136→    passed++;
   137→  } else {
   138→    console.error('✗ Plain text format invalid');
   139→    failed++;
   140→  }
   141→
   142→  // Test JSON generation
   143→  console.log('Testing JSON generation...');
   144→  const json = toJSON(mockTranscript);
   145→  const parsed = JSON.parse(json);
   146→  if (parsed.words && parsed.words.length === mockTranscript.words.length) {
   147→    console.log('✓ JSON format generated correctly');
   148→    passed++;
   149→  } else {
   150→    console.error('✗ JSON format invalid');
   151→    failed++;
   152→  }
   153→
   154→  console.log(`\nCaption Exporter: ${passed} passed, ${failed} failed`);
   155→  return failed === 0;
   156→}
   157→
   158→// =============================================================================
   159→// Test: Export Formats Endpoint
   160→// =============================================================================
   161→
   162→async function testExportFormatsEndpoint() {
   163→  console.log('\n=== Test: GET /export/formats ===');
   164→
   165→  const res = await request('GET', '/export/formats');
   166→
   167→  if (res.status !== 200) {
   168→    console.error(`✗ Expected status 200, got ${res.status}`);
   169→    return false;
   170→  }
   171→
   172→  if (!res.data.formats || res.data.formats.length !== 4) {
   173→    console.error('✗ Expected 4 export formats');
   174→    return false;
   175→  }
   176→
   177→  const formats = res.data.formats.map(f => f.format);
   178→  if (!formats.includes('srt') || !formats.includes('vtt')) {
   179→    console.error('✗ Missing expected formats (srt, vtt)');
   180→    return false;
   181→  }
   182→
   183→  console.log(`✓ Found ${res.data.formats.length} export formats: ${formats.join(', ')}`);
   184→  return true;
   185→}
   186→
   187→// =============================================================================
   188→// Test: Caption Export with Provided Transcript
   189→// =============================================================================
   190→
   191→async function testCaptionExportWithTranscript() {
   192→  console.log('\n=== Test: POST /export/captions (with transcript) ===');
   193→
   194→  const res = await request('POST', '/export/captions', {
   195→    transcript: mockTranscript,
   196→    format: 'srt',
   197→    maxWordsPerCaption: 5
   198→  });
   199→
   200→  if (res.status !== 200) {
   201→    console.error(`✗ Expected status 200, got ${res.status}`);
   202→    console.error(res.data);
   203→    return false;
   204→  }
   205→
   206→  if (!res.data.success || !res.data.content) {
   207→    console.error('✗ Missing success or content in response');
   208→    return false;
   209→  }
   210→
   211→  if (!res.data.content.includes('-->')) {
   212→    console.error('✗ SRT content does not contain timestamp arrows');
   213→    return false;
   214→  }
   215→
   216→  console.log(`✓ SRT export successful (${res.data.wordCount} words, ${res.data.content.length} chars)`);
   217→  return true;
   218→}
   219→
   220→// =============================================================================
   221→// Test: Filler Word Detection with Provided Transcript
   222→// =============================================================================
   223→
   224→async function testFillerDetectionWithTranscript() {
   225→  console.log('\n=== Test: POST /fillers (with transcript) ===');
   226→
   227→  const res = await request('POST', '/fillers', {
   228→    transcript: mockTranscript,
   229→    customFillers: ['basically']
   230→  });
   231→
   232→  if (res.status !== 200) {
   233→    console.error(`✗ Expected status 200, got ${res.status}`);
   234→    console.error(res.data);
   235→    return false;
   236→  }
   237→
   238→  if (!res.data.success) {
   239→    console.error('✗ Response indicates failure');
   240→    return false;
   241→  }
   242→
   243→  // Should detect: "um" x2, "like", "you know", "basically"
   244→  const fillerCount = res.data.metadata?.fillerCount || 0;
   245→  if (fillerCount < 3) {
   246→    console.error(`✗ Expected at least 3 fillers, got ${fillerCount}`);
   247→    return false;
   248→  }
   249→
   250→  console.log(`✓ Found ${fillerCount} fillers`);
   251→  console.log(`  - Filler percentage: ${res.data.metadata.fillerPercentage}%`);
   252→  console.log(`  - Fillers per minute: ${res.data.metadata.fillersPerMinute}`);
   253→
   254→  // Check for specific fillers
   255→  const fillerWords = res.data.fillers.map(f => f.normalizedWord);
   256→  if (fillerWords.includes('um')) {
   257→    console.log('  ✓ Detected "um"');
   258→  }
   259→  if (fillerWords.includes('like')) {
   260→    console.log('  ✓ Detected "like"');
   261→  }
   262→  if (fillerWords.includes('basically')) {
   263→    console.log('  ✓ Detected custom filler "basically"');
   264→  }
   265→
   266→  return true;
   267→}
   268→
   269→// =============================================================================
   270→// Test: Batch Processing Endpoints
   271→// =============================================================================
   272→
   273→async function testBatchEndpoints() {
   274→  console.log('\n=== Test: Batch Processing Endpoints ===');
   275→
   276→  // Test listing jobs (should be empty initially)
   277→  let res = await request('GET', '/batch/jobs');
   278→  if (res.status !== 200 || !res.data.success) {
   279→    console.error('✗ Failed to list batch jobs');
   280→    return false;
   281→  }
   282→  console.log(`✓ Batch jobs listing works (${res.data.count} jobs)`);
   283→
   284→  // Test creating a batch job with non-existent file (should fail gracefully)
   285→  res = await request('POST', '/batch/silences', {
   286→    files: ['/nonexistent/file.wav'],
   287→    options: { sensitivity: 50 }
   288→  });
   289→
   290→  if (res.status !== 404) {
   291→    console.error(`✗ Expected 404 for missing file, got ${res.status}`);
   292→    return false;
   293→  }
   294→  console.log('✓ Batch job creation validates file existence');
   295→
   296→  // Test batch job without files (should fail)
   297→  res = await request('POST', '/batch/silences', {});
   298→  if (res.status !== 400) {
   299→    console.error(`✗ Expected 400 for missing files, got ${res.status}`);
   300→    return false;
   301→  }
   302→  console.log('✓ Batch job creation requires files array');
   303→
   304→  // Test getting status of non-existent job
   305→  res = await request('GET', '/batch/status/nonexistent_job');
   306→  if (res.status !== 404) {
   307→    console.error(`✗ Expected 404 for missing job, got ${res.status}`);
   308→    return false;
   309→  }
   310→  console.log('✓ Batch status returns 404 for missing job');
   311→
   312→  return true;
   313→}
   314→
   315→// =============================================================================
   316→// Test: Retry Logic Configuration
   317→// =============================================================================
   318→
   319→function testRetryLogicConfig() {
   320→  console.log('\n=== Test: Retry Logic Configuration ===');
   321→
   322→  // Check if the retry logic is present in the transcription file
   323→  const fs = require('fs');
   324→  const transcriptionPath = require('path').join(__dirname, '../services/transcription.js');
   325→
   326→  if (!fs.existsSync(transcriptionPath)) {
   327→    console.error('✗ Transcription service file not found');
   328→    return false;
   329→  }
   330→
   331→  const content = fs.readFileSync(transcriptionPath, 'utf8');
   332→
   333→  // Check for retry logic
   334→  if (!content.includes('withRetry')) {
   335→    console.error('✗ withRetry function not found in transcription.js');
   336→    return false;
   337→  }
   338→
   339→  if (!content.includes('exponential backoff') || !content.includes('retries')) {
   340→    console.error('✗ Retry logic documentation not found');
   341→    return false;
   342→  }
   343→
   344→  // Check for retryable error handling
   345→  if (!content.includes('status === 429') && !content.includes('err.status === 429')) {
   346→    console.error('✗ Rate limit (429) handling not found');
   347→    return false;
   348→  }
   349→
   350→  console.log('✓ Retry logic implemented with exponential backoff');
   351→  console.log('  ✓ Handles 429 rate limit errors');
   352→  console.log('  ✓ Handles 5xx server errors');
   353→  return true;
   354→}
   355→
   356→// =============================================================================
   357→// Test: Cache Size Limit
   358→// =============================================================================
   359→
   360→function testCacheSizeLimit() {
   361→  console.log('\n=== Test: Cache Size Limit ===');
   362→
   363→  // Test cache eviction logic (simulated)
   364→  const MAX_CACHE_SIZE = 50;
   365→  const cache = new Map();
   366→
   367→  // Fill cache beyond limit
   368→  for (let i = 0; i < 60; i++) {
   369→    // Simulate LRU eviction
   370→    while (cache.size >= MAX_CACHE_SIZE) {
   371→      const oldestKey = cache.keys().next().value;
   372→      cache.delete(oldestKey);
   373→    }
   374→    cache.set(`file${i}.wav`, { result: `data${i}` });
   375→  }
   376→
   377→  if (cache.size !== MAX_CACHE_SIZE) {
   378→    console.error(`✗ Cache should be limited to ${MAX_CACHE_SIZE}, got ${cache.size}`);
   379→    return false;
   380→  }
   381→
   382→  // Verify oldest entries were evicted
   383→  if (cache.has('file0.wav')) {
   384→    console.error('✗ Oldest entry should have been evicted');
   385→    return false;
   386→  }
   387→
   388→  if (!cache.has('file59.wav')) {
   389→    console.error('✗ Newest entry should still be in cache');
   390→    return false;
   391→  }
   392→
   393→  console.log(`✓ LRU cache eviction working (limit: ${MAX_CACHE_SIZE})`);
   394→  return true;
   395→}
   396→
   397→// =============================================================================
   398→// Test: Preset Profiles
   399→// =============================================================================
   400→
   401→function testPresetProfiles() {
   402→  console.log('\n=== Test: Preset Profiles ===');
   403→
   404→  // Define expected presets
   405→  const expectedPresets = ['custom', 'podcast', 'interview', 'reaction', 'tutorial', 'vlog'];
   406→
   407→  // Check settings.js has presets (we can't load UXP modules directly, so just verify structure)
   408→  const fs = require('fs');
   409→  const settingsPath = require('path').join(__dirname, '../../splice-plugin/js/settings.js');
   410→
   411→  if (!fs.existsSync(settingsPath)) {
   412→    console.error('✗ Settings file not found');
   413→    return false;
   414→  }
   415→
   416→  const settingsContent = fs.readFileSync(settingsPath, 'utf8');
   417→
   418→  let allPresetsFound = true;
   419→  for (const preset of expectedPresets) {
   420→    if (!settingsContent.includes(`'${preset}'`) && !settingsContent.includes(`"${preset}"`)) {
   421→      // Try checking for the preset name as object key
   422→      if (!settingsContent.includes(`${preset}:`)) {
   423→        console.error(`✗ Preset "${preset}" not found in settings.js`);
   424→        allPresetsFound = false;
   425→      }
   426→    }
   427→  }
   428→
   429→  if (allPresetsFound) {
   430→    console.log(`✓ All ${expectedPresets.length} presets defined in settings.js`);
   431→  }
   432→
   433→  // Check for specific preset settings
   434→  if (settingsContent.includes('sensitivity: 35') && settingsContent.includes('minSilenceLength: 0.8')) {
   435→    console.log('  ✓ Podcast preset has correct settings');
   436→  }
   437→  if (settingsContent.includes('sensitivity: 70') && settingsContent.includes('minSilenceLength: 0.3')) {
   438→    console.log('  ✓ Reaction preset has correct settings');
   439→  }
   440→
   441→  return allPresetsFound;
   442→}
   443→
   444→// =============================================================================
   445→// Performance Benchmarks
   446→// =============================================================================
   447→
   448→async function runPerformanceBenchmarks() {
   449→  console.log('\n=== Performance Benchmarks ===');
   450→
   451→  // Benchmark caption generation
   452→  const largeTranscript = {
   453→    text: '',
   454→    words: [],
   455→    language: 'en',
   456→    duration: 600
   457→  };
   458→
   459→  // Create 1000 word transcript
   460→  let time = 0;
   461→  for (let i = 0; i < 1000; i++) {
   462→    largeTranscript.words.push({
   463→      word: `word${i}`,
   464→      start: time,
   465→      end: time + 0.3
   466→    });
   467→    time += 0.35;
   468→  }
   469→
   470→  // Benchmark SRT generation
   471→  let start = Date.now();
   472→  toSRT(largeTranscript);
   473→  const srtTime = Date.now() - start;
   474→  console.log(`SRT generation (1000 words): ${srtTime}ms`);
   475→
   476→  // Benchmark VTT generation
   477→  start = Date.now();
   478→  toVTT(largeTranscript);
   479→  const vttTime = Date.now() - start;
   480→  console.log(`VTT generation (1000 words): ${vttTime}ms`);
   481→
   482→  // Benchmark word grouping
   483→  start = Date.now();
   484→  const captions = groupWordsIntoCaptions(largeTranscript.words, { maxWordsPerCaption: 8 });
   485→  const groupTime = Date.now() - start;
   486→  console.log(`Word grouping (1000 words -> ${captions.length} captions): ${groupTime}ms`);
   487→
   488→  // Check for performance issues
   489→  const maxAcceptable = 100; // 100ms
   490→  if (srtTime > maxAcceptable || vttTime > maxAcceptable) {
   491→    console.warn(`⚠ Caption generation exceeded ${maxAcceptable}ms threshold`);
   492→  } else {
   493→    console.log('✓ All benchmarks within acceptable limits');
   494→  }
   495→
   496→  return true;
   497→}
   498→
   499→// =============================================================================
   500→// Run All Tests
   501→// =============================================================================
   502→
   503→async function runAllTests() {
   504→  console.log('='.repeat(60));
   505→  console.log('SPLICE Phase 5 (95% Parity) E2E Tests');
   506→  console.log('='.repeat(60));
   507→
   508→  const results = [];
   509→
   510→  try {
   511→    // Unit tests (no server required)
   512→    results.push({ name: 'Caption Exporter Service', pass: testCaptionExporterService() });
   513→    results.push({ name: 'Retry Logic Config', pass: testRetryLogicConfig() });
   514→    results.push({ name: 'Cache Size Limit', pass: testCacheSizeLimit() });
   515→    results.push({ name: 'Preset Profiles', pass: testPresetProfiles() });
   516→
   517→    // API tests (server required)
   518→    results.push({ name: 'Export Formats Endpoint', pass: await testExportFormatsEndpoint() });
   519→    results.push({ name: 'Caption Export with Transcript', pass: await testCaptionExportWithTranscript() });
   520→    results.push({ name: 'Filler Detection', pass: await testFillerDetectionWithTranscript() });
   521→    results.push({ name: 'Batch Endpoints', pass: await testBatchEndpoints() });
   522→
   523→    // Performance
   524→    results.push({ name: 'Performance Benchmarks', pass: await runPerformanceBenchmarks() });
   525→  } catch (err) {
   526→    console.error('\n❌ Test error:', err.message);
   527→    console.error(err.stack);
   528→  }
   529→
   530→  console.log('\n' + '='.repeat(60));
   531→  console.log('SUMMARY');
   532→  console.log('='.repeat(60));
   533→
   534→  let passed = 0;
   535→  let failed = 0;
   536→
   537→  for (const r of results) {
   538→    const status = r.pass ? '✓ PASS' : '✗ FAIL';
   539→    console.log(`${status}: ${r.name}`);
   540→    if (r.pass) passed++; else failed++;
   541→  }
   542→
   543→  console.log(`\nTotal: ${passed} passed, ${failed} failed`);
   544→
   545→  return failed === 0;
   546→}
   547→
   548→// Run if called directly
   549→if (require.main === module) {
   550→  runAllTests().then(success => {
   551→    process.exit(success ? 0 : 1);
   552→  });
   553→}
   554→
   555→module.exports = { runAllTests };
   556→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
